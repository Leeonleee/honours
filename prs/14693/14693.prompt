You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Sequences in COPY FROM <database>TO <otherDB> causes Dependency Error
### What happens?

> ./duckdb original.db
v1.1.2 f680b7d08f
Enter ".help" for usage hints.
D create sequence seq start 1;
D create table tbl (id int default nextval('seq'));
D attach 'backup.db';
D copy from database original to backup;
Dependency Error: Error adding dependency for object "tbl" - dependency "seq" is in catalog "original", which does not match the catalog "backup".
Cross catalog dependencies are not supported.

### To Reproduce

```bash
./duckdb original.db
```
```sql
create sequence seq start 1;
create table tbl (id int default nextval('seq'));
attach 'backup.db';
copy from database original to backup;
```
```console
Dependency Error: Error adding dependency for object "tbl" - dependency "seq" is in catalog "original", which does not match the catalog "backup".
Cross catalog dependencies are not supported.
```
### OS:

Windows 10

### DuckDB Version:

1.1.2

### DuckDB Client:

CLI

### Hardware:

_No response_

### Full Name:

johndapps

### Affiliation:

4LP

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Not applicable - the reproduction does not require a data set

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation/) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/catalog/catalog.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: 
3: #include "duckdb/catalog/catalog_search_path.hpp"
4: #include "duckdb/catalog/catalog_entry/list.hpp"
5: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
6: #include "duckdb/catalog/catalog_set.hpp"
7: #include "duckdb/catalog/default/default_schemas.hpp"
8: #include "duckdb/catalog/catalog_entry/type_catalog_entry.hpp"
9: #include "duckdb/common/exception.hpp"
10: #include "duckdb/main/client_context.hpp"
11: #include "duckdb/main/client_data.hpp"
12: #include "duckdb/main/database.hpp"
13: #include "duckdb/parser/expression/function_expression.hpp"
14: #include "duckdb/main/extension_helper.hpp"
15: #include "duckdb/parser/parsed_data/alter_table_info.hpp"
16: #include "duckdb/parser/parsed_data/create_aggregate_function_info.hpp"
17: #include "duckdb/parser/parsed_data/create_collation_info.hpp"
18: #include "duckdb/parser/parsed_data/create_copy_function_info.hpp"
19: #include "duckdb/parser/parsed_data/create_index_info.hpp"
20: #include "duckdb/parser/parsed_data/create_pragma_function_info.hpp"
21: #include "duckdb/parser/parsed_data/create_secret_info.hpp"
22: #include "duckdb/parser/parsed_data/create_scalar_function_info.hpp"
23: #include "duckdb/parser/parsed_data/create_schema_info.hpp"
24: #include "duckdb/parser/parsed_data/create_sequence_info.hpp"
25: #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
26: #include "duckdb/parser/parsed_data/create_type_info.hpp"
27: #include "duckdb/parser/parsed_data/create_view_info.hpp"
28: #include "duckdb/parser/parsed_data/drop_info.hpp"
29: #include "duckdb/planner/parsed_data/bound_create_table_info.hpp"
30: #include "duckdb/planner/binder.hpp"
31: #include "duckdb/catalog/default/default_types.hpp"
32: #include "duckdb/main/extension_entries.hpp"
33: #include "duckdb/main/extension/generated_extension_loader.hpp"
34: #include "duckdb/main/connection.hpp"
35: #include "duckdb/main/attached_database.hpp"
36: #include "duckdb/main/database_manager.hpp"
37: #include "duckdb/function/built_in_functions.hpp"
38: #include "duckdb/catalog/similar_catalog_entry.hpp"
39: #include "duckdb/storage/database_size.hpp"
40: #include <algorithm>
41: 
42: namespace duckdb {
43: 
44: Catalog::Catalog(AttachedDatabase &db) : db(db) {
45: }
46: 
47: Catalog::~Catalog() {
48: }
49: 
50: DatabaseInstance &Catalog::GetDatabase() {
51: 	return db.GetDatabase();
52: }
53: 
54: AttachedDatabase &Catalog::GetAttached() {
55: 	return db;
56: }
57: 
58: const AttachedDatabase &Catalog::GetAttached() const {
59: 	return db;
60: }
61: 
62: const string &Catalog::GetName() const {
63: 	return GetAttached().GetName();
64: }
65: 
66: idx_t Catalog::GetOid() {
67: 	return GetAttached().oid;
68: }
69: 
70: Catalog &Catalog::GetSystemCatalog(ClientContext &context) {
71: 	return Catalog::GetSystemCatalog(*context.db);
72: }
73: 
74: const string &GetDefaultCatalog(CatalogEntryRetriever &retriever) {
75: 	return DatabaseManager::GetDefaultDatabase(retriever.GetContext());
76: }
77: 
78: optional_ptr<Catalog> Catalog::GetCatalogEntry(CatalogEntryRetriever &retriever, const string &catalog_name) {
79: 	auto &context = retriever.GetContext();
80: 	auto &db_manager = DatabaseManager::Get(context);
81: 	if (catalog_name == TEMP_CATALOG) {
82: 		return &ClientData::Get(context).temporary_objects->GetCatalog();
83: 	}
84: 	if (catalog_name == SYSTEM_CATALOG) {
85: 		return &GetSystemCatalog(context);
86: 	}
87: 	auto entry =
88: 	    db_manager.GetDatabase(context, IsInvalidCatalog(catalog_name) ? GetDefaultCatalog(retriever) : catalog_name);
89: 	if (!entry) {
90: 		return nullptr;
91: 	}
92: 	return &entry->GetCatalog();
93: }
94: 
95: optional_ptr<Catalog> Catalog::GetCatalogEntry(ClientContext &context, const string &catalog_name) {
96: 	CatalogEntryRetriever entry_retriever(context);
97: 	return GetCatalogEntry(entry_retriever, catalog_name);
98: }
99: 
100: Catalog &Catalog::GetCatalog(CatalogEntryRetriever &retriever, const string &catalog_name) {
101: 	auto catalog = Catalog::GetCatalogEntry(retriever, catalog_name);
102: 	if (!catalog) {
103: 		throw BinderException("Catalog \"%s\" does not exist!", catalog_name);
104: 	}
105: 	return *catalog;
106: }
107: 
108: Catalog &Catalog::GetCatalog(ClientContext &context, const string &catalog_name) {
109: 	CatalogEntryRetriever entry_retriever(context);
110: 	return GetCatalog(entry_retriever, catalog_name);
111: }
112: 
113: //===--------------------------------------------------------------------===//
114: // Schema
115: //===--------------------------------------------------------------------===//
116: optional_ptr<CatalogEntry> Catalog::CreateSchema(ClientContext &context, CreateSchemaInfo &info) {
117: 	return CreateSchema(GetCatalogTransaction(context), info);
118: }
119: 
120: CatalogTransaction Catalog::GetCatalogTransaction(ClientContext &context) {
121: 	return CatalogTransaction(*this, context);
122: }
123: 
124: //===--------------------------------------------------------------------===//
125: // Table
126: //===--------------------------------------------------------------------===//
127: optional_ptr<CatalogEntry> Catalog::CreateTable(ClientContext &context, BoundCreateTableInfo &info) {
128: 	return CreateTable(GetCatalogTransaction(context), info);
129: }
130: 
131: optional_ptr<CatalogEntry> Catalog::CreateTable(ClientContext &context, unique_ptr<CreateTableInfo> info) {
132: 	auto binder = Binder::CreateBinder(context);
133: 	auto bound_info = binder->BindCreateTableInfo(std::move(info));
134: 	return CreateTable(context, *bound_info);
135: }
136: 
137: optional_ptr<CatalogEntry> Catalog::CreateTable(CatalogTransaction transaction, SchemaCatalogEntry &schema,
138:                                                 BoundCreateTableInfo &info) {
139: 	return schema.CreateTable(transaction, info);
140: }
141: 
142: optional_ptr<CatalogEntry> Catalog::CreateTable(CatalogTransaction transaction, BoundCreateTableInfo &info) {
143: 	auto &schema = GetSchema(transaction, info.base->schema);
144: 	return CreateTable(transaction, schema, info);
145: }
146: 
147: //===--------------------------------------------------------------------===//
148: // View
149: //===--------------------------------------------------------------------===//
150: optional_ptr<CatalogEntry> Catalog::CreateView(CatalogTransaction transaction, CreateViewInfo &info) {
151: 	auto &schema = GetSchema(transaction, info.schema);
152: 	return CreateView(transaction, schema, info);
153: }
154: 
155: optional_ptr<CatalogEntry> Catalog::CreateView(ClientContext &context, CreateViewInfo &info) {
156: 	return CreateView(GetCatalogTransaction(context), info);
157: }
158: 
159: optional_ptr<CatalogEntry> Catalog::CreateView(CatalogTransaction transaction, SchemaCatalogEntry &schema,
160:                                                CreateViewInfo &info) {
161: 	return schema.CreateView(transaction, info);
162: }
163: 
164: //===--------------------------------------------------------------------===//
165: // Sequence
166: //===--------------------------------------------------------------------===//
167: optional_ptr<CatalogEntry> Catalog::CreateSequence(CatalogTransaction transaction, CreateSequenceInfo &info) {
168: 	auto &schema = GetSchema(transaction, info.schema);
169: 	return CreateSequence(transaction, schema, info);
170: }
171: 
172: optional_ptr<CatalogEntry> Catalog::CreateSequence(ClientContext &context, CreateSequenceInfo &info) {
173: 	return CreateSequence(GetCatalogTransaction(context), info);
174: }
175: 
176: optional_ptr<CatalogEntry> Catalog::CreateSequence(CatalogTransaction transaction, SchemaCatalogEntry &schema,
177:                                                    CreateSequenceInfo &info) {
178: 	return schema.CreateSequence(transaction, info);
179: }
180: 
181: //===--------------------------------------------------------------------===//
182: // Type
183: //===--------------------------------------------------------------------===//
184: optional_ptr<CatalogEntry> Catalog::CreateType(CatalogTransaction transaction, CreateTypeInfo &info) {
185: 	auto &schema = GetSchema(transaction, info.schema);
186: 	return CreateType(transaction, schema, info);
187: }
188: 
189: optional_ptr<CatalogEntry> Catalog::CreateType(ClientContext &context, CreateTypeInfo &info) {
190: 	return CreateType(GetCatalogTransaction(context), info);
191: }
192: 
193: optional_ptr<CatalogEntry> Catalog::CreateType(CatalogTransaction transaction, SchemaCatalogEntry &schema,
194:                                                CreateTypeInfo &info) {
195: 	return schema.CreateType(transaction, info);
196: }
197: 
198: //===--------------------------------------------------------------------===//
199: // Table Function
200: //===--------------------------------------------------------------------===//
201: optional_ptr<CatalogEntry> Catalog::CreateTableFunction(CatalogTransaction transaction, CreateTableFunctionInfo &info) {
202: 	auto &schema = GetSchema(transaction, info.schema);
203: 	return CreateTableFunction(transaction, schema, info);
204: }
205: 
206: optional_ptr<CatalogEntry> Catalog::CreateTableFunction(ClientContext &context, CreateTableFunctionInfo &info) {
207: 	return CreateTableFunction(GetCatalogTransaction(context), info);
208: }
209: 
210: optional_ptr<CatalogEntry> Catalog::CreateTableFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema,
211:                                                         CreateTableFunctionInfo &info) {
212: 	return schema.CreateTableFunction(transaction, info);
213: }
214: 
215: optional_ptr<CatalogEntry> Catalog::CreateTableFunction(ClientContext &context,
216:                                                         optional_ptr<CreateTableFunctionInfo> info) {
217: 	return CreateTableFunction(context, *info);
218: }
219: 
220: //===--------------------------------------------------------------------===//
221: // Copy Function
222: //===--------------------------------------------------------------------===//
223: optional_ptr<CatalogEntry> Catalog::CreateCopyFunction(CatalogTransaction transaction, CreateCopyFunctionInfo &info) {
224: 	auto &schema = GetSchema(transaction, info.schema);
225: 	return CreateCopyFunction(transaction, schema, info);
226: }
227: 
228: optional_ptr<CatalogEntry> Catalog::CreateCopyFunction(ClientContext &context, CreateCopyFunctionInfo &info) {
229: 	return CreateCopyFunction(GetCatalogTransaction(context), info);
230: }
231: 
232: optional_ptr<CatalogEntry> Catalog::CreateCopyFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema,
233:                                                        CreateCopyFunctionInfo &info) {
234: 	return schema.CreateCopyFunction(transaction, info);
235: }
236: 
237: //===--------------------------------------------------------------------===//
238: // Pragma Function
239: //===--------------------------------------------------------------------===//
240: optional_ptr<CatalogEntry> Catalog::CreatePragmaFunction(CatalogTransaction transaction,
241:                                                          CreatePragmaFunctionInfo &info) {
242: 	auto &schema = GetSchema(transaction, info.schema);
243: 	return CreatePragmaFunction(transaction, schema, info);
244: }
245: 
246: optional_ptr<CatalogEntry> Catalog::CreatePragmaFunction(ClientContext &context, CreatePragmaFunctionInfo &info) {
247: 	return CreatePragmaFunction(GetCatalogTransaction(context), info);
248: }
249: 
250: optional_ptr<CatalogEntry> Catalog::CreatePragmaFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema,
251:                                                          CreatePragmaFunctionInfo &info) {
252: 	return schema.CreatePragmaFunction(transaction, info);
253: }
254: 
255: //===--------------------------------------------------------------------===//
256: // Function
257: //===--------------------------------------------------------------------===//
258: optional_ptr<CatalogEntry> Catalog::CreateFunction(CatalogTransaction transaction, CreateFunctionInfo &info) {
259: 	auto &schema = GetSchema(transaction, info.schema);
260: 	return CreateFunction(transaction, schema, info);
261: }
262: 
263: optional_ptr<CatalogEntry> Catalog::CreateFunction(ClientContext &context, CreateFunctionInfo &info) {
264: 	return CreateFunction(GetCatalogTransaction(context), info);
265: }
266: 
267: optional_ptr<CatalogEntry> Catalog::CreateFunction(CatalogTransaction transaction, SchemaCatalogEntry &schema,
268:                                                    CreateFunctionInfo &info) {
269: 	return schema.CreateFunction(transaction, info);
270: }
271: 
272: optional_ptr<CatalogEntry> Catalog::AddFunction(ClientContext &context, CreateFunctionInfo &info) {
273: 	info.on_conflict = OnCreateConflict::ALTER_ON_CONFLICT;
274: 	return CreateFunction(context, info);
275: }
276: 
277: //===--------------------------------------------------------------------===//
278: // Collation
279: //===--------------------------------------------------------------------===//
280: optional_ptr<CatalogEntry> Catalog::CreateCollation(CatalogTransaction transaction, CreateCollationInfo &info) {
281: 	auto &schema = GetSchema(transaction, info.schema);
282: 	return CreateCollation(transaction, schema, info);
283: }
284: 
285: optional_ptr<CatalogEntry> Catalog::CreateCollation(ClientContext &context, CreateCollationInfo &info) {
286: 	return CreateCollation(GetCatalogTransaction(context), info);
287: }
288: 
289: optional_ptr<CatalogEntry> Catalog::CreateCollation(CatalogTransaction transaction, SchemaCatalogEntry &schema,
290:                                                     CreateCollationInfo &info) {
291: 	return schema.CreateCollation(transaction, info);
292: }
293: 
294: //===--------------------------------------------------------------------===//
295: // Index
296: //===--------------------------------------------------------------------===//
297: optional_ptr<CatalogEntry> Catalog::CreateIndex(CatalogTransaction transaction, CreateIndexInfo &info) {
298: 	auto &schema = GetSchema(transaction, info.schema);
299: 	auto &table = schema.GetEntry(transaction, CatalogType::TABLE_ENTRY, info.table)->Cast<TableCatalogEntry>();
300: 	return schema.CreateIndex(transaction, info, table);
301: }
302: 
303: optional_ptr<CatalogEntry> Catalog::CreateIndex(ClientContext &context, CreateIndexInfo &info) {
304: 	return CreateIndex(GetCatalogTransaction(context), info);
305: }
306: 
307: //===--------------------------------------------------------------------===//
308: // Lookup Structures
309: //===--------------------------------------------------------------------===//
310: struct CatalogLookup {
311: 	CatalogLookup(Catalog &catalog, string schema_p, string name_p)
312: 	    : catalog(catalog), schema(std::move(schema_p)), name(std::move(name_p)) {
313: 	}
314: 
315: 	Catalog &catalog;
316: 	string schema;
317: 	string name;
318: };
319: 
320: //===--------------------------------------------------------------------===//
321: // Generic
322: //===--------------------------------------------------------------------===//
323: void Catalog::DropEntry(ClientContext &context, DropInfo &info) {
324: 	if (info.type == CatalogType::SCHEMA_ENTRY) {
325: 		// DROP SCHEMA
326: 		DropSchema(context, info);
327: 		return;
328: 	}
329: 
330: 	CatalogEntryRetriever retriever(context);
331: 	auto lookup = LookupEntry(retriever, info.type, info.schema, info.name, info.if_not_found);
332: 	if (!lookup.Found()) {
333: 		return;
334: 	}
335: 
336: 	lookup.schema->DropEntry(context, info);
337: }
338: 
339: SchemaCatalogEntry &Catalog::GetSchema(ClientContext &context, const string &name, QueryErrorContext error_context) {
340: 	return *Catalog::GetSchema(context, name, OnEntryNotFound::THROW_EXCEPTION, error_context);
341: }
342: 
343: optional_ptr<SchemaCatalogEntry> Catalog::GetSchema(ClientContext &context, const string &schema_name,
344:                                                     OnEntryNotFound if_not_found, QueryErrorContext error_context) {
345: 	return GetSchema(GetCatalogTransaction(context), schema_name, if_not_found, error_context);
346: }
347: 
348: SchemaCatalogEntry &Catalog::GetSchema(ClientContext &context, const string &catalog_name, const string &schema_name,
349:                                        QueryErrorContext error_context) {
350: 	return *Catalog::GetSchema(context, catalog_name, schema_name, OnEntryNotFound::THROW_EXCEPTION, error_context);
351: }
352: 
353: SchemaCatalogEntry &Catalog::GetSchema(CatalogTransaction transaction, const string &name,
354:                                        QueryErrorContext error_context) {
355: 	return *GetSchema(transaction, name, OnEntryNotFound::THROW_EXCEPTION, error_context);
356: }
357: 
358: //===--------------------------------------------------------------------===//
359: // Lookup
360: //===--------------------------------------------------------------------===//
361: vector<SimilarCatalogEntry> Catalog::SimilarEntriesInSchemas(ClientContext &context, const string &entry_name,
362:                                                              CatalogType type,
363:                                                              const reference_set_t<SchemaCatalogEntry> &schemas) {
364: 	vector<SimilarCatalogEntry> results;
365: 	for (auto schema_ref : schemas) {
366: 		auto &schema = schema_ref.get();
367: 		auto transaction = schema.catalog.GetCatalogTransaction(context);
368: 		auto entry = schema.GetSimilarEntry(transaction, type, entry_name);
369: 		if (!entry.Found()) {
370: 			// no similar entry found
371: 			continue;
372: 		}
373: 		if (results.empty() || results[0].score <= entry.score) {
374: 			if (!results.empty() && results[0].score < entry.score) {
375: 				results.clear();
376: 			}
377: 
378: 			results.push_back(entry);
379: 			results.back().schema = &schema;
380: 		}
381: 	}
382: 	return results;
383: }
384: 
385: vector<CatalogSearchEntry> GetCatalogEntries(CatalogEntryRetriever &retriever, const string &catalog,
386:                                              const string &schema) {
387: 	auto &context = retriever.GetContext();
388: 	vector<CatalogSearchEntry> entries;
389: 	auto &search_path = retriever.GetSearchPath();
390: 	if (IsInvalidCatalog(catalog) && IsInvalidSchema(schema)) {
391: 		// no catalog or schema provided - scan the entire search path
392: 		entries = search_path.Get();
393: 	} else if (IsInvalidCatalog(catalog)) {
394: 		auto catalogs = search_path.GetCatalogsForSchema(schema);
395: 		for (auto &catalog_name : catalogs) {
396: 			entries.emplace_back(catalog_name, schema);
397: 		}
398: 		if (entries.empty()) {
399: 			entries.emplace_back(DatabaseManager::GetDefaultDatabase(context), schema);
400: 		}
401: 	} else if (IsInvalidSchema(schema)) {
402: 		auto schemas = search_path.GetSchemasForCatalog(catalog);
403: 		for (auto &schema_name : schemas) {
404: 			entries.emplace_back(catalog, schema_name);
405: 		}
406: 		if (entries.empty()) {
407: 			entries.emplace_back(catalog, DEFAULT_SCHEMA);
408: 		}
409: 	} else {
410: 		// specific catalog and schema provided
411: 		entries.emplace_back(catalog, schema);
412: 	}
413: 	return entries;
414: }
415: 
416: void FindMinimalQualification(CatalogEntryRetriever &retriever, const string &catalog_name, const string &schema_name,
417:                               bool &qualify_database, bool &qualify_schema) {
418: 	// check if we can we qualify ONLY the schema
419: 	bool found = false;
420: 	auto entries = GetCatalogEntries(retriever, INVALID_CATALOG, schema_name);
421: 	for (auto &entry : entries) {
422: 		if (entry.catalog == catalog_name && entry.schema == schema_name) {
423: 			found = true;
424: 			break;
425: 		}
426: 	}
427: 	if (found) {
428: 		qualify_database = false;
429: 		qualify_schema = true;
430: 		return;
431: 	}
432: 	// check if we can qualify ONLY the catalog
433: 	found = false;
434: 	entries = GetCatalogEntries(retriever, catalog_name, INVALID_SCHEMA);
435: 	for (auto &entry : entries) {
436: 		if (entry.catalog == catalog_name && entry.schema == schema_name) {
437: 			found = true;
438: 			break;
439: 		}
440: 	}
441: 	if (found) {
442: 		qualify_database = true;
443: 		qualify_schema = false;
444: 		return;
445: 	}
446: 	// need to qualify both catalog and schema
447: 	qualify_database = true;
448: 	qualify_schema = true;
449: }
450: 
451: bool Catalog::TryAutoLoad(ClientContext &context, const string &original_name) noexcept {
452: 	string extension_name = ExtensionHelper::ApplyExtensionAlias(original_name);
453: 	if (context.db->ExtensionIsLoaded(extension_name)) {
454: 		return true;
455: 	}
456: #ifndef DUCKDB_DISABLE_EXTENSION_LOAD
457: 	auto &dbconfig = DBConfig::GetConfig(context);
458: 	if (!dbconfig.options.autoload_known_extensions) {
459: 		return false;
460: 	}
461: 	try {
462: 		if (ExtensionHelper::CanAutoloadExtension(extension_name)) {
463: 			return ExtensionHelper::TryAutoLoadExtension(context, extension_name);
464: 		}
465: 	} catch (...) {
466: 		return false;
467: 	}
468: #endif
469: 	return false;
470: }
471: 
472: void Catalog::AutoloadExtensionByConfigName(ClientContext &context, const string &configuration_name) {
473: #ifndef DUCKDB_DISABLE_EXTENSION_LOAD
474: 	auto &dbconfig = DBConfig::GetConfig(context);
475: 	if (dbconfig.options.autoload_known_extensions) {
476: 		auto extension_name = ExtensionHelper::FindExtensionInEntries(configuration_name, EXTENSION_SETTINGS);
477: 		if (ExtensionHelper::CanAutoloadExtension(extension_name)) {
478: 			ExtensionHelper::AutoLoadExtension(context, extension_name);
479: 			return;
480: 		}
481: 	}
482: #endif
483: 
484: 	throw Catalog::UnrecognizedConfigurationError(context, configuration_name);
485: }
486: 
487: static bool IsAutoloadableFunction(CatalogType type) {
488: 	return (type == CatalogType::TABLE_FUNCTION_ENTRY || type == CatalogType::SCALAR_FUNCTION_ENTRY ||
489: 	        type == CatalogType::AGGREGATE_FUNCTION_ENTRY || type == CatalogType::PRAGMA_FUNCTION_ENTRY);
490: }
491: 
492: bool IsTableFunction(CatalogType type) {
493: 	switch (type) {
494: 	case CatalogType::TABLE_FUNCTION_ENTRY:
495: 	case CatalogType::TABLE_MACRO_ENTRY:
496: 	case CatalogType::PRAGMA_FUNCTION_ENTRY:
497: 		return true;
498: 	default:
499: 		return false;
500: 	}
501: }
502: 
503: bool IsScalarFunction(CatalogType type) {
504: 	switch (type) {
505: 	case CatalogType::SCALAR_FUNCTION_ENTRY:
506: 	case CatalogType::AGGREGATE_FUNCTION_ENTRY:
507: 	case CatalogType::MACRO_ENTRY:
508: 		return true;
509: 	default:
510: 		return false;
511: 	}
512: }
513: 
514: static bool CompareCatalogTypes(CatalogType type_a, CatalogType type_b) {
515: 	if (type_a == type_b) {
516: 		// Types are same
517: 		return true;
518: 	}
519: 	if (IsScalarFunction(type_a) && IsScalarFunction(type_b)) {
520: 		return true;
521: 	}
522: 	if (IsTableFunction(type_a) && IsTableFunction(type_b)) {
523: 		return true;
524: 	}
525: 	return false;
526: }
527: 
528: bool Catalog::AutoLoadExtensionByCatalogEntry(DatabaseInstance &db, CatalogType type, const string &entry_name) {
529: #ifndef DUCKDB_DISABLE_EXTENSION_LOAD
530: 	auto &dbconfig = DBConfig::GetConfig(db);
531: 	if (dbconfig.options.autoload_known_extensions) {
532: 		string extension_name;
533: 		if (IsAutoloadableFunction(type)) {
534: 			auto lookup_result = ExtensionHelper::FindExtensionInFunctionEntries(entry_name, EXTENSION_FUNCTIONS);
535: 			if (lookup_result.empty()) {
536: 				return false;
537: 			}
538: 			for (auto &function : lookup_result) {
539: 				auto function_type = function.second;
540: 				// FIXME: what if there are two functions with the same name, from different extensions?
541: 				if (CompareCatalogTypes(type, function_type)) {
542: 					extension_name = function.first;
543: 					break;
544: 				}
545: 			}
546: 		} else if (type == CatalogType::COPY_FUNCTION_ENTRY) {
547: 			extension_name = ExtensionHelper::FindExtensionInEntries(entry_name, EXTENSION_COPY_FUNCTIONS);
548: 		} else if (type == CatalogType::TYPE_ENTRY) {
549: 			extension_name = ExtensionHelper::FindExtensionInEntries(entry_name, EXTENSION_TYPES);
550: 		} else if (type == CatalogType::COLLATION_ENTRY) {
551: 			extension_name = ExtensionHelper::FindExtensionInEntries(entry_name, EXTENSION_COLLATIONS);
552: 		}
553: 
554: 		if (!extension_name.empty() && ExtensionHelper::CanAutoloadExtension(extension_name)) {
555: 			ExtensionHelper::AutoLoadExtension(db, extension_name);
556: 			return true;
557: 		}
558: 	}
559: #endif
560: 
561: 	return false;
562: }
563: 
564: CatalogException Catalog::UnrecognizedConfigurationError(ClientContext &context, const string &name) {
565: 	// check if the setting exists in any extensions
566: 	auto extension_name = ExtensionHelper::FindExtensionInEntries(name, EXTENSION_SETTINGS);
567: 	if (!extension_name.empty()) {
568: 		auto error_message = "Setting with name \"" + name + "\" is not in the catalog, but it exists in the " +
569: 		                     extension_name + " extension.";
570: 		error_message = ExtensionHelper::AddExtensionInstallHintToErrorMsg(context, error_message, extension_name);
571: 		return CatalogException(error_message);
572: 	}
573: 	// the setting is not in an extension
574: 	// get a list of all options
575: 	vector<string> potential_names = DBConfig::GetOptionNames();
576: 	for (auto &entry : DBConfig::GetConfig(context).extension_parameters) {
577: 		potential_names.push_back(entry.first);
578: 	}
579: 	throw CatalogException::MissingEntry("configuration parameter", name, potential_names);
580: }
581: 
582: CatalogException Catalog::CreateMissingEntryException(CatalogEntryRetriever &retriever, const string &entry_name,
583:                                                       CatalogType type,
584:                                                       const reference_set_t<SchemaCatalogEntry> &schemas,
585:                                                       QueryErrorContext error_context) {
586: 	auto &context = retriever.GetContext();
587: 	auto entries = SimilarEntriesInSchemas(context, entry_name, type, schemas);
588: 
589: 	reference_set_t<SchemaCatalogEntry> unseen_schemas;
590: 	auto &db_manager = DatabaseManager::Get(context);
591: 	auto databases = db_manager.GetDatabases(context);
592: 	auto &config = DBConfig::GetConfig(context);
593: 
594: 	auto max_schema_count = config.GetSetting<CatalogErrorMaxSchemasSetting>(context);
595: 	for (auto database : databases) {
596: 		if (unseen_schemas.size() >= max_schema_count) {
597: 			break;
598: 		}
599: 		auto &catalog = database.get().GetCatalog();
600: 		auto current_schemas = catalog.GetAllSchemas(context);
601: 		for (auto &current_schema : current_schemas) {
602: 			if (unseen_schemas.size() >= max_schema_count) {
603: 				break;
604: 			}
605: 			unseen_schemas.insert(current_schema.get());
606: 		}
607: 	}
608: 	// check if the entry exists in any extension
609: 	string extension_name;
610: 	if (type == CatalogType::TABLE_FUNCTION_ENTRY || type == CatalogType::SCALAR_FUNCTION_ENTRY ||
611: 	    type == CatalogType::AGGREGATE_FUNCTION_ENTRY || type == CatalogType::PRAGMA_FUNCTION_ENTRY) {
612: 		auto lookup_result = ExtensionHelper::FindExtensionInFunctionEntries(entry_name, EXTENSION_FUNCTIONS);
613: 		do {
614: 			if (lookup_result.empty()) {
615: 				break;
616: 			}
617: 			vector<string> other_types;
618: 			string extension_for_error;
619: 			for (auto &function : lookup_result) {
620: 				auto function_type = function.second;
621: 				if (CompareCatalogTypes(type, function_type)) {
622: 					extension_name = function.first;
623: 					break;
624: 				}
625: 				extension_for_error = function.first;
626: 				other_types.push_back(CatalogTypeToString(function_type));
627: 			}
628: 			if (!extension_name.empty()) {
629: 				break;
630: 			}
631: 			if (other_types.size() == 1) {
632: 				auto &function_type = other_types[0];
633: 				auto error =
634: 				    CatalogException("%s with name \"%s\" is not in the catalog, a function by this name exists "
635: 				                     "in the %s extension, but it's of a different type, namely %s",
636: 				                     CatalogTypeToString(type), entry_name, extension_for_error, function_type);
637: 				return error;
638: 			} else {
639: 				D_ASSERT(!other_types.empty());
640: 				auto list_of_types = StringUtil::Join(other_types, ", ");
641: 				auto error =
642: 				    CatalogException("%s with name \"%s\" is not in the catalog, functions with this name exist "
643: 				                     "in the %s extension, but they are of different types, namely %s",
644: 				                     CatalogTypeToString(type), entry_name, extension_for_error, list_of_types);
645: 				return error;
646: 			}
647: 		} while (false);
648: 	} else if (type == CatalogType::TYPE_ENTRY) {
649: 		extension_name = ExtensionHelper::FindExtensionInEntries(entry_name, EXTENSION_TYPES);
650: 	} else if (type == CatalogType::COPY_FUNCTION_ENTRY) {
651: 		extension_name = ExtensionHelper::FindExtensionInEntries(entry_name, EXTENSION_COPY_FUNCTIONS);
652: 	} else if (type == CatalogType::COLLATION_ENTRY) {
653: 		extension_name = ExtensionHelper::FindExtensionInEntries(entry_name, EXTENSION_COLLATIONS);
654: 	}
655: 
656: 	// if we found an extension that can handle this catalog entry, create an error hinting the user
657: 	if (!extension_name.empty()) {
658: 		auto error_message = CatalogTypeToString(type) + " with name \"" + entry_name +
659: 		                     "\" is not in the catalog, but it exists in the " + extension_name + " extension.";
660: 		error_message = ExtensionHelper::AddExtensionInstallHintToErrorMsg(context, error_message, extension_name);
661: 		return CatalogException(error_message);
662: 	}
663: 
664: 	// entries in other schemas get a penalty
665: 	// however, if there is an exact match in another schema, we will always show it
666: 	static constexpr const double UNSEEN_PENALTY = 0.2;
667: 	auto unseen_entries = SimilarEntriesInSchemas(context, entry_name, type, unseen_schemas);
668: 	vector<string> suggestions;
669: 	if (!unseen_entries.empty() && (unseen_entries[0].score == 1.0 || unseen_entries[0].score - UNSEEN_PENALTY >
670: 	                                                                      (entries.empty() ? 0.0 : entries[0].score))) {
671: 		// the closest matching entry requires qualification as it is not in the default search path
672: 		// check how to minimally qualify this entry
673: 		for (auto &unseen_entry : unseen_entries) {
674: 			auto catalog_name = unseen_entry.schema->catalog.GetName();
675: 			auto schema_name = unseen_entry.schema->name;
676: 			bool qualify_database;
677: 			bool qualify_schema;
678: 			FindMinimalQualification(retriever, catalog_name, schema_name, qualify_database, qualify_schema);
679: 			suggestions.push_back(unseen_entry.GetQualifiedName(qualify_database, qualify_schema));
680: 		}
681: 	} else if (!entries.empty()) {
682: 		for (auto &entry : entries) {
683: 			suggestions.push_back(entry.name);
684: 		}
685: 	}
686: 
687: 	string did_you_mean;
688: 	std::sort(suggestions.begin(), suggestions.end());
689: 	if (suggestions.size() > 2) {
690: 		auto last = suggestions.back();
691: 		suggestions.pop_back();
692: 		did_you_mean = StringUtil::Join(suggestions, ", ") + ", or " + last;
693: 	} else {
694: 		did_you_mean = StringUtil::Join(suggestions, " or ");
695: 	}
696: 
697: 	return CatalogException::MissingEntry(type, entry_name, did_you_mean, error_context);
698: }
699: 
700: CatalogEntryLookup Catalog::TryLookupEntryInternal(CatalogTransaction transaction, CatalogType type,
701:                                                    const string &schema, const string &name) {
702: 	auto schema_entry = GetSchema(transaction, schema, OnEntryNotFound::RETURN_NULL);
703: 	if (!schema_entry) {
704: 		return {nullptr, nullptr, ErrorData()};
705: 	}
706: 	auto entry = schema_entry->GetEntry(transaction, type, name);
707: 	if (!entry) {
708: 		return {schema_entry, nullptr, ErrorData()};
709: 	}
710: 	return {schema_entry, entry, ErrorData()};
711: }
712: 
713: CatalogEntryLookup Catalog::TryLookupEntry(CatalogEntryRetriever &retriever, CatalogType type, const string &schema,
714:                                            const string &name, OnEntryNotFound if_not_found,
715:                                            QueryErrorContext error_context) {
716: 	auto &context = retriever.GetContext();
717: 	reference_set_t<SchemaCatalogEntry> schemas;
718: 	if (IsInvalidSchema(schema)) {
719: 		// try all schemas for this catalog
720: 		auto entries = GetCatalogEntries(retriever, GetName(), INVALID_SCHEMA);
721: 		for (auto &entry : entries) {
722: 			auto &candidate_schema = entry.schema;
723: 			auto transaction = GetCatalogTransaction(context);
724: 			auto result = TryLookupEntryInternal(transaction, type, candidate_schema, name);
725: 			if (result.Found()) {
726: 				return result;
727: 			}
728: 			if (result.schema) {
729: 				schemas.insert(*result.schema);
730: 			}
731: 		}
732: 	} else {
733: 		auto transaction = GetCatalogTransaction(context);
734: 		auto result = TryLookupEntryInternal(transaction, type, schema, name);
735: 		if (result.Found()) {
736: 			return result;
737: 		}
738: 		if (result.schema) {
739: 			schemas.insert(*result.schema);
740: 		}
741: 	}
742: 
743: 	if (if_not_found == OnEntryNotFound::RETURN_NULL) {
744: 		return {nullptr, nullptr, ErrorData()};
745: 	} else {
746: 		auto except = CreateMissingEntryException(retriever, name, type, schemas, error_context);
747: 		return {nullptr, nullptr, ErrorData(except)};
748: 	}
749: }
750: 
751: CatalogEntryLookup Catalog::LookupEntry(CatalogEntryRetriever &retriever, CatalogType type, const string &schema,
752:                                         const string &name, OnEntryNotFound if_not_found,
753:                                         QueryErrorContext error_context) {
754: 	auto res = TryLookupEntry(retriever, type, schema, name, if_not_found, error_context);
755: 
756: 	if (res.error.HasError()) {
757: 		res.error.Throw();
758: 	}
759: 
760: 	return res;
761: }
762: 
763: CatalogEntryLookup Catalog::TryLookupEntry(CatalogEntryRetriever &retriever, vector<CatalogLookup> &lookups,
764:                                            CatalogType type, const string &name, OnEntryNotFound if_not_found,
765:                                            QueryErrorContext error_context) {
766: 	auto &context = retriever.GetContext();
767: 	reference_set_t<SchemaCatalogEntry> schemas;
768: 	for (auto &lookup : lookups) {
769: 		auto transaction = lookup.catalog.GetCatalogTransaction(context);
770: 		auto result = lookup.catalog.TryLookupEntryInternal(transaction, type, lookup.schema, lookup.name);
771: 		if (result.Found()) {
772: 			return result;
773: 		}
774: 		if (result.schema) {
775: 			schemas.insert(*result.schema);
776: 		}
777: 	}
778: 
779: 	if (if_not_found == OnEntryNotFound::RETURN_NULL) {
780: 		return {nullptr, nullptr, ErrorData()};
781: 	} else {
782: 		auto except = CreateMissingEntryException(retriever, name, type, schemas, error_context);
783: 		return {nullptr, nullptr, ErrorData(except)};
784: 	}
785: }
786: 
787: CatalogEntryLookup Catalog::TryLookupDefaultTable(CatalogEntryRetriever &retriever, CatalogType type,
788:                                                   const string &catalog, const string &schema, const string &name,
789:                                                   OnEntryNotFound if_not_found, QueryErrorContext error_context) {
790: 	// Default tables of catalogs can only be accessed by the catalog name directly
791: 	if (!schema.empty() || !catalog.empty()) {
792: 		return {nullptr, nullptr, ErrorData()};
793: 	}
794: 
795: 	vector<CatalogLookup> catalog_by_name_lookups;
796: 	auto catalog_by_name = GetCatalogEntry(retriever, name);
797: 	if (catalog_by_name && catalog_by_name->HasDefaultTable()) {
798: 		catalog_by_name_lookups.emplace_back(*catalog_by_name, catalog_by_name->GetDefaultTableSchema(),
799: 		                                     catalog_by_name->GetDefaultTable());
800: 	}
801: 
802: 	return TryLookupEntry(retriever, catalog_by_name_lookups, type, name, if_not_found, error_context);
803: }
804: 
805: static void ThrowDefaultTableAmbiguityException(CatalogEntryLookup &base_lookup, CatalogEntryLookup &default_table,
806:                                                 const string &name) {
807: 	auto entry_type = CatalogTypeToString(base_lookup.entry->type);
808: 	string fully_qualified_name_hint;
809: 	if (base_lookup.schema) {
810: 		fully_qualified_name_hint = StringUtil::Format(": '%s.%s.%s'", base_lookup.schema->catalog.GetName(),
811: 		                                               base_lookup.schema->name, base_lookup.entry->name);
812: 	}
813: 	string fully_qualified_catalog_name_hint = StringUtil::Format(
814: 	    ": '%s.%s.%s'", default_table.schema->catalog.GetName(), default_table.schema->name, default_table.entry->name);
815: 	throw CatalogException(
816: 	    "Ambiguity detected for '%s': this could either refer to the '%s' '%s', or the "
817: 	    "attached catalog '%s' which has a default table. To avoid this error, either detach the catalog and "
818: 	    "reattach under a different name, or use a fully qualified name for the '%s'%s or for the Catalog "
819: 	    "Default Table%s.",
820: 	    name, entry_type, name, name, entry_type, fully_qualified_name_hint, fully_qualified_catalog_name_hint);
821: }
822: 
823: CatalogEntryLookup Catalog::TryLookupEntry(CatalogEntryRetriever &retriever, CatalogType type, const string &catalog,
824:                                            const string &schema, const string &name, OnEntryNotFound if_not_found,
825:                                            QueryErrorContext error_context) {
826: 	auto entries = GetCatalogEntries(retriever, catalog, schema);
827: 	vector<CatalogLookup> lookups;
828: 	vector<CatalogLookup> final_lookups;
829: 	lookups.reserve(entries.size());
830: 	for (auto &entry : entries) {
831: 		optional_ptr<Catalog> catalog_entry;
832: 		if (if_not_found == OnEntryNotFound::RETURN_NULL) {
833: 			catalog_entry = Catalog::GetCatalogEntry(retriever, entry.catalog);
834: 		} else {
835: 			catalog_entry = &Catalog::GetCatalog(retriever, entry.catalog);
836: 		}
837: 		if (!catalog_entry) {
838: 			return {nullptr, nullptr, ErrorData()};
839: 		}
840: 		D_ASSERT(catalog_entry);
841: 		auto lookup_behavior = catalog_entry->CatalogTypeLookupRule(type);
842: 		if (lookup_behavior == CatalogLookupBehavior::STANDARD) {
843: 			lookups.emplace_back(*catalog_entry, entry.schema, name);
844: 		} else if (lookup_behavior == CatalogLookupBehavior::LOWER_PRIORITY) {
845: 			final_lookups.emplace_back(*catalog_entry, entry.schema, name);
846: 		}
847: 	}
848: 
849: 	for (auto &lookup : final_lookups) {
850: 		lookups.emplace_back(std::move(lookup));
851: 	}
852: 
853: 	// Do the main lookup
854: 	auto lookup_result = TryLookupEntry(retriever, lookups, type, name, if_not_found, error_context);
855: 
856: 	// Special case for tables: we do a second lookup searching for catalogs with default tables that also match this
857: 	// lookup
858: 	if (type == CatalogType::TABLE_ENTRY) {
859: 		auto lookup_result_default_table =
860: 		    TryLookupDefaultTable(retriever, type, catalog, schema, name, if_not_found, error_context);
861: 
862: 		if (lookup_result_default_table.Found() && lookup_result.Found()) {
863: 			ThrowDefaultTableAmbiguityException(lookup_result, lookup_result_default_table, name);
864: 		}
865: 
866: 		if (lookup_result_default_table.Found()) {
867: 			return lookup_result_default_table;
868: 		}
869: 	}
870: 
871: 	return lookup_result;
872: }
873: 
874: optional_ptr<CatalogEntry> Catalog::GetEntry(CatalogEntryRetriever &retriever, CatalogType type,
875:                                              const string &schema_name, const string &name,
876:                                              OnEntryNotFound if_not_found, QueryErrorContext error_context) {
877: 	auto lookup_entry = TryLookupEntry(retriever, type, schema_name, name, if_not_found, error_context);
878: 
879: 	// Try autoloading extension to resolve lookup
880: 	if (!lookup_entry.Found()) {
881: 		if (AutoLoadExtensionByCatalogEntry(*retriever.GetContext().db, type, name)) {
882: 			lookup_entry = TryLookupEntry(retriever, type, schema_name, name, if_not_found, error_context);
883: 		}
884: 	}
885: 
886: 	if (lookup_entry.error.HasError()) {
887: 		lookup_entry.error.Throw();
888: 	}
889: 
890: 	return lookup_entry.entry.get();
891: }
892: 
893: optional_ptr<CatalogEntry> Catalog::GetEntry(ClientContext &context, CatalogType type, const string &schema_name,
894:                                              const string &name, OnEntryNotFound if_not_found,
895:                                              QueryErrorContext error_context) {
896: 	CatalogEntryRetriever retriever(context);
897: 	return GetEntry(retriever, type, schema_name, name, if_not_found, error_context);
898: }
899: 
900: CatalogEntry &Catalog::GetEntry(ClientContext &context, CatalogType type, const string &schema, const string &name,
901:                                 QueryErrorContext error_context) {
902: 	return *Catalog::GetEntry(context, type, schema, name, OnEntryNotFound::THROW_EXCEPTION, error_context);
903: }
904: 
905: optional_ptr<CatalogEntry> Catalog::GetEntry(CatalogEntryRetriever &retriever, CatalogType type, const string &catalog,
906:                                              const string &schema, const string &name, OnEntryNotFound if_not_found,
907:                                              QueryErrorContext error_context) {
908: 	auto result = TryLookupEntry(retriever, type, catalog, schema, name, if_not_found, error_context);
909: 
910: 	// Try autoloading extension to resolve lookup
911: 	if (!result.Found()) {
912: 		if (AutoLoadExtensionByCatalogEntry(*retriever.GetContext().db, type, name)) {
913: 			result = TryLookupEntry(retriever, type, catalog, schema, name, if_not_found, error_context);
914: 		}
915: 	}
916: 
917: 	if (result.error.HasError()) {
918: 		result.error.Throw();
919: 	}
920: 
921: 	if (!result.Found()) {
922: 		D_ASSERT(if_not_found == OnEntryNotFound::RETURN_NULL);
923: 		return nullptr;
924: 	}
925: 	return result.entry.get();
926: }
927: optional_ptr<CatalogEntry> Catalog::GetEntry(ClientContext &context, CatalogType type, const string &catalog,
928:                                              const string &schema, const string &name, OnEntryNotFound if_not_found,
929:                                              QueryErrorContext error_context) {
930: 	CatalogEntryRetriever retriever(context);
931: 	return GetEntry(retriever, type, catalog, schema, name, if_not_found, error_context);
932: }
933: 
934: CatalogEntry &Catalog::GetEntry(ClientContext &context, CatalogType type, const string &catalog, const string &schema,
935:                                 const string &name, QueryErrorContext error_context) {
936: 	return *Catalog::GetEntry(context, type, catalog, schema, name, OnEntryNotFound::THROW_EXCEPTION, error_context);
937: }
938: 
939: optional_ptr<SchemaCatalogEntry> Catalog::GetSchema(CatalogEntryRetriever &retriever, const string &catalog_name,
940:                                                     const string &schema_name, OnEntryNotFound if_not_found,
941:                                                     QueryErrorContext error_context) {
942: 	auto entries = GetCatalogEntries(retriever, catalog_name, schema_name);
943: 	for (idx_t i = 0; i < entries.size(); i++) {
944: 		auto on_not_found = i + 1 == entries.size() ? if_not_found : OnEntryNotFound::RETURN_NULL;
945: 		auto &catalog = Catalog::GetCatalog(retriever, entries[i].catalog);
946: 		auto result = catalog.GetSchema(retriever.GetContext(), schema_name, on_not_found, error_context);
947: 		if (result) {
948: 			return result;
949: 		}
950: 	}
951: 	return nullptr;
952: }
953: 
954: optional_ptr<SchemaCatalogEntry> Catalog::GetSchema(ClientContext &context, const string &catalog_name,
955:                                                     const string &schema_name, OnEntryNotFound if_not_found,
956:                                                     QueryErrorContext error_context) {
957: 	CatalogEntryRetriever retriever(context);
958: 	return GetSchema(retriever, catalog_name, schema_name, if_not_found, error_context);
959: }
960: 
961: vector<reference<SchemaCatalogEntry>> Catalog::GetSchemas(ClientContext &context) {
962: 	vector<reference<SchemaCatalogEntry>> schemas;
963: 	ScanSchemas(context, [&](SchemaCatalogEntry &entry) { schemas.push_back(entry); });
964: 	return schemas;
965: }
966: 
967: vector<reference<SchemaCatalogEntry>> Catalog::GetSchemas(CatalogEntryRetriever &retriever,
968:                                                           const string &catalog_name) {
969: 	vector<reference<Catalog>> catalogs;
970: 	if (IsInvalidCatalog(catalog_name)) {
971: 		reference_set_t<Catalog> inserted_catalogs;
972: 
973: 		auto &search_path = retriever.GetSearchPath();
974: 		for (auto &entry : search_path.Get()) {
975: 			auto &catalog = Catalog::GetCatalog(retriever, entry.catalog);
976: 			if (inserted_catalogs.find(catalog) != inserted_catalogs.end()) {
977: 				continue;
978: 			}
979: 			inserted_catalogs.insert(catalog);
980: 			catalogs.push_back(catalog);
981: 		}
982: 	} else {
983: 		catalogs.push_back(Catalog::GetCatalog(retriever, catalog_name));
984: 	}
985: 	vector<reference<SchemaCatalogEntry>> result;
986: 	for (auto catalog : catalogs) {
987: 		auto schemas = catalog.get().GetSchemas(retriever.GetContext());
988: 		result.insert(result.end(), schemas.begin(), schemas.end());
989: 	}
990: 	return result;
991: }
992: 
993: vector<reference<SchemaCatalogEntry>> Catalog::GetSchemas(ClientContext &context, const string &catalog_name) {
994: 	CatalogEntryRetriever retriever(context);
995: 	return GetSchemas(retriever, catalog_name);
996: }
997: 
998: vector<reference<SchemaCatalogEntry>> Catalog::GetAllSchemas(ClientContext &context) {
999: 	vector<reference<SchemaCatalogEntry>> result;
1000: 
1001: 	auto &db_manager = DatabaseManager::Get(context);
1002: 	auto databases = db_manager.GetDatabases(context);
1003: 	for (auto database : databases) {
1004: 		auto &catalog = database.get().GetCatalog();
1005: 		auto new_schemas = catalog.GetSchemas(context);
1006: 		result.insert(result.end(), new_schemas.begin(), new_schemas.end());
1007: 	}
1008: 	sort(result.begin(), result.end(),
1009: 	     [&](reference<SchemaCatalogEntry> left_p, reference<SchemaCatalogEntry> right_p) {
1010: 		     auto &left = left_p.get();
1011: 		     auto &right = right_p.get();
1012: 		     if (left.catalog.GetName() < right.catalog.GetName()) {
1013: 			     return true;
1014: 		     }
1015: 		     if (left.catalog.GetName() == right.catalog.GetName()) {
1016: 			     return left.name < right.name;
1017: 		     }
1018: 		     return false;
1019: 	     });
1020: 
1021: 	return result;
1022: }
1023: 
1024: void Catalog::Alter(CatalogTransaction transaction, AlterInfo &info) {
1025: 	if (transaction.HasContext()) {
1026: 		CatalogEntryRetriever retriever(transaction.GetContext());
1027: 		auto lookup = LookupEntry(retriever, info.GetCatalogType(), info.schema, info.name, info.if_not_found);
1028: 		if (!lookup.Found()) {
1029: 			return;
1030: 		}
1031: 		return lookup.schema->Alter(transaction, info);
1032: 	}
1033: 	D_ASSERT(info.if_not_found == OnEntryNotFound::THROW_EXCEPTION);
1034: 	auto &schema = GetSchema(transaction, info.schema);
1035: 	return schema.Alter(transaction, info);
1036: }
1037: 
1038: void Catalog::Alter(ClientContext &context, AlterInfo &info) {
1039: 	Alter(GetCatalogTransaction(context), info);
1040: }
1041: 
1042: vector<MetadataBlockInfo> Catalog::GetMetadataInfo(ClientContext &context) {
1043: 	return vector<MetadataBlockInfo>();
1044: }
1045: 
1046: //! Whether this catalog has a default table. Catalogs with a default table can be queries by their catalog name
1047: bool Catalog::HasDefaultTable() const {
1048: 	return !default_table.empty();
1049: }
1050: 
1051: void Catalog::SetDefaultTable(const string &schema, const string &name) {
1052: 	default_table = name;
1053: 	default_table_schema = schema;
1054: }
1055: 
1056: string Catalog::GetDefaultTable() const {
1057: 	return default_table;
1058: }
1059: 
1060: string Catalog::GetDefaultTableSchema() const {
1061: 	return !default_table_schema.empty() ? default_table_schema : DEFAULT_SCHEMA;
1062: }
1063: 
1064: void Catalog::Verify() {
1065: }
1066: 
1067: bool Catalog::IsSystemCatalog() const {
1068: 	return db.IsSystem();
1069: }
1070: 
1071: bool Catalog::IsTemporaryCatalog() const {
1072: 	return db.IsTemporary();
1073: }
1074: 
1075: } // namespace duckdb
[end of src/catalog/catalog.cpp]
[start of src/execution/physical_plan_generator.cpp]
1: #include "duckdb/execution/physical_plan_generator.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp"
4: #include "duckdb/common/types/column/column_data_collection.hpp"
5: #include "duckdb/execution/column_binding_resolver.hpp"
6: #include "duckdb/main/client_context.hpp"
7: #include "duckdb/main/config.hpp"
8: #include "duckdb/main/query_profiler.hpp"
9: #include "duckdb/planner/expression/bound_function_expression.hpp"
10: #include "duckdb/planner/operator/logical_extension_operator.hpp"
11: #include "duckdb/planner/operator/list.hpp"
12: #include "duckdb/execution/operator/helper/physical_verify_vector.hpp"
13: 
14: namespace duckdb {
15: 
16: class DependencyExtractor : public LogicalOperatorVisitor {
17: public:
18: 	explicit DependencyExtractor(LogicalDependencyList &dependencies) : dependencies(dependencies) {
19: 	}
20: 
21: protected:
22: 	unique_ptr<Expression> VisitReplace(BoundFunctionExpression &expr, unique_ptr<Expression> *expr_ptr) override {
23: 		// extract dependencies from the bound function expression
24: 		if (expr.function.dependency) {
25: 			expr.function.dependency(expr, dependencies);
26: 		}
27: 		return nullptr;
28: 	}
29: 
30: private:
31: 	LogicalDependencyList &dependencies;
32: };
33: 
34: PhysicalPlanGenerator::PhysicalPlanGenerator(ClientContext &context) : context(context) {
35: }
36: 
37: PhysicalPlanGenerator::~PhysicalPlanGenerator() {
38: }
39: 
40: unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(unique_ptr<LogicalOperator> op) {
41: 	auto &profiler = QueryProfiler::Get(context);
42: 
43: 	// first resolve column references
44: 	profiler.StartPhase(MetricsType::PHYSICAL_PLANNER_COLUMN_BINDING);
45: 	ColumnBindingResolver resolver;
46: 	resolver.VisitOperator(*op);
47: 	profiler.EndPhase();
48: 
49: 	// now resolve types of all the operators
50: 	profiler.StartPhase(MetricsType::PHYSICAL_PLANNER_RESOLVE_TYPES);
51: 	op->ResolveOperatorTypes();
52: 	profiler.EndPhase();
53: 
54: 	// extract dependencies from the logical plan
55: 	DependencyExtractor extractor(dependencies);
56: 	extractor.VisitOperator(*op);
57: 
58: 	// then create the main physical plan
59: 	profiler.StartPhase(MetricsType::PHYSICAL_PLANNER_CREATE_PLAN);
60: 	auto plan = CreatePlan(*op);
61: 	profiler.EndPhase();
62: 
63: 	plan->Verify();
64: 	return plan;
65: }
66: 
67: unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalOperator &op) {
68: 	op.estimated_cardinality = op.EstimateCardinality(context);
69: 	unique_ptr<PhysicalOperator> plan = nullptr;
70: 
71: 	switch (op.type) {
72: 	case LogicalOperatorType::LOGICAL_GET:
73: 		plan = CreatePlan(op.Cast<LogicalGet>());
74: 		break;
75: 	case LogicalOperatorType::LOGICAL_PROJECTION:
76: 		plan = CreatePlan(op.Cast<LogicalProjection>());
77: 		break;
78: 	case LogicalOperatorType::LOGICAL_EMPTY_RESULT:
79: 		plan = CreatePlan(op.Cast<LogicalEmptyResult>());
80: 		break;
81: 	case LogicalOperatorType::LOGICAL_FILTER:
82: 		plan = CreatePlan(op.Cast<LogicalFilter>());
83: 		break;
84: 	case LogicalOperatorType::LOGICAL_AGGREGATE_AND_GROUP_BY:
85: 		plan = CreatePlan(op.Cast<LogicalAggregate>());
86: 		break;
87: 	case LogicalOperatorType::LOGICAL_WINDOW:
88: 		plan = CreatePlan(op.Cast<LogicalWindow>());
89: 		break;
90: 	case LogicalOperatorType::LOGICAL_UNNEST:
91: 		plan = CreatePlan(op.Cast<LogicalUnnest>());
92: 		break;
93: 	case LogicalOperatorType::LOGICAL_LIMIT:
94: 		plan = CreatePlan(op.Cast<LogicalLimit>());
95: 		break;
96: 	case LogicalOperatorType::LOGICAL_SAMPLE:
97: 		plan = CreatePlan(op.Cast<LogicalSample>());
98: 		break;
99: 	case LogicalOperatorType::LOGICAL_ORDER_BY:
100: 		plan = CreatePlan(op.Cast<LogicalOrder>());
101: 		break;
102: 	case LogicalOperatorType::LOGICAL_TOP_N:
103: 		plan = CreatePlan(op.Cast<LogicalTopN>());
104: 		break;
105: 	case LogicalOperatorType::LOGICAL_COPY_TO_FILE:
106: 		plan = CreatePlan(op.Cast<LogicalCopyToFile>());
107: 		break;
108: 	case LogicalOperatorType::LOGICAL_DUMMY_SCAN:
109: 		plan = CreatePlan(op.Cast<LogicalDummyScan>());
110: 		break;
111: 	case LogicalOperatorType::LOGICAL_ANY_JOIN:
112: 		plan = CreatePlan(op.Cast<LogicalAnyJoin>());
113: 		break;
114: 	case LogicalOperatorType::LOGICAL_ASOF_JOIN:
115: 	case LogicalOperatorType::LOGICAL_DELIM_JOIN:
116: 	case LogicalOperatorType::LOGICAL_COMPARISON_JOIN:
117: 		plan = CreatePlan(op.Cast<LogicalComparisonJoin>());
118: 		break;
119: 	case LogicalOperatorType::LOGICAL_CROSS_PRODUCT:
120: 		plan = CreatePlan(op.Cast<LogicalCrossProduct>());
121: 		break;
122: 	case LogicalOperatorType::LOGICAL_POSITIONAL_JOIN:
123: 		plan = CreatePlan(op.Cast<LogicalPositionalJoin>());
124: 		break;
125: 	case LogicalOperatorType::LOGICAL_UNION:
126: 	case LogicalOperatorType::LOGICAL_EXCEPT:
127: 	case LogicalOperatorType::LOGICAL_INTERSECT:
128: 		plan = CreatePlan(op.Cast<LogicalSetOperation>());
129: 		break;
130: 	case LogicalOperatorType::LOGICAL_INSERT:
131: 		plan = CreatePlan(op.Cast<LogicalInsert>());
132: 		break;
133: 	case LogicalOperatorType::LOGICAL_DELETE:
134: 		plan = CreatePlan(op.Cast<LogicalDelete>());
135: 		break;
136: 	case LogicalOperatorType::LOGICAL_CHUNK_GET:
137: 		plan = CreatePlan(op.Cast<LogicalColumnDataGet>());
138: 		break;
139: 	case LogicalOperatorType::LOGICAL_DELIM_GET:
140: 		plan = CreatePlan(op.Cast<LogicalDelimGet>());
141: 		break;
142: 	case LogicalOperatorType::LOGICAL_EXPRESSION_GET:
143: 		plan = CreatePlan(op.Cast<LogicalExpressionGet>());
144: 		break;
145: 	case LogicalOperatorType::LOGICAL_UPDATE:
146: 		plan = CreatePlan(op.Cast<LogicalUpdate>());
147: 		break;
148: 	case LogicalOperatorType::LOGICAL_CREATE_TABLE:
149: 		plan = CreatePlan(op.Cast<LogicalCreateTable>());
150: 		break;
151: 	case LogicalOperatorType::LOGICAL_CREATE_INDEX:
152: 		plan = CreatePlan(op.Cast<LogicalCreateIndex>());
153: 		break;
154: 	case LogicalOperatorType::LOGICAL_CREATE_SECRET:
155: 		plan = CreatePlan(op.Cast<LogicalCreateSecret>());
156: 		break;
157: 	case LogicalOperatorType::LOGICAL_EXPLAIN:
158: 		plan = CreatePlan(op.Cast<LogicalExplain>());
159: 		break;
160: 	case LogicalOperatorType::LOGICAL_DISTINCT:
161: 		plan = CreatePlan(op.Cast<LogicalDistinct>());
162: 		break;
163: 	case LogicalOperatorType::LOGICAL_PREPARE:
164: 		plan = CreatePlan(op.Cast<LogicalPrepare>());
165: 		break;
166: 	case LogicalOperatorType::LOGICAL_EXECUTE:
167: 		plan = CreatePlan(op.Cast<LogicalExecute>());
168: 		break;
169: 	case LogicalOperatorType::LOGICAL_CREATE_VIEW:
170: 	case LogicalOperatorType::LOGICAL_CREATE_SEQUENCE:
171: 	case LogicalOperatorType::LOGICAL_CREATE_SCHEMA:
172: 	case LogicalOperatorType::LOGICAL_CREATE_MACRO:
173: 	case LogicalOperatorType::LOGICAL_CREATE_TYPE:
174: 		plan = CreatePlan(op.Cast<LogicalCreate>());
175: 		break;
176: 	case LogicalOperatorType::LOGICAL_PRAGMA:
177: 		plan = CreatePlan(op.Cast<LogicalPragma>());
178: 		break;
179: 	case LogicalOperatorType::LOGICAL_VACUUM:
180: 		plan = CreatePlan(op.Cast<LogicalVacuum>());
181: 		break;
182: 	case LogicalOperatorType::LOGICAL_TRANSACTION:
183: 	case LogicalOperatorType::LOGICAL_ALTER:
184: 	case LogicalOperatorType::LOGICAL_DROP:
185: 	case LogicalOperatorType::LOGICAL_LOAD:
186: 	case LogicalOperatorType::LOGICAL_ATTACH:
187: 	case LogicalOperatorType::LOGICAL_DETACH:
188: 		plan = CreatePlan(op.Cast<LogicalSimple>());
189: 		break;
190: 	case LogicalOperatorType::LOGICAL_RECURSIVE_CTE:
191: 		plan = CreatePlan(op.Cast<LogicalRecursiveCTE>());
192: 		break;
193: 	case LogicalOperatorType::LOGICAL_MATERIALIZED_CTE:
194: 		plan = CreatePlan(op.Cast<LogicalMaterializedCTE>());
195: 		break;
196: 	case LogicalOperatorType::LOGICAL_CTE_REF:
197: 		plan = CreatePlan(op.Cast<LogicalCTERef>());
198: 		break;
199: 	case LogicalOperatorType::LOGICAL_EXPORT:
200: 		plan = CreatePlan(op.Cast<LogicalExport>());
201: 		break;
202: 	case LogicalOperatorType::LOGICAL_SET:
203: 		plan = CreatePlan(op.Cast<LogicalSet>());
204: 		break;
205: 	case LogicalOperatorType::LOGICAL_RESET:
206: 		plan = CreatePlan(op.Cast<LogicalReset>());
207: 		break;
208: 	case LogicalOperatorType::LOGICAL_PIVOT:
209: 		plan = CreatePlan(op.Cast<LogicalPivot>());
210: 		break;
211: 	case LogicalOperatorType::LOGICAL_COPY_DATABASE:
212: 		plan = CreatePlan(op.Cast<LogicalCopyDatabase>());
213: 		break;
214: 	case LogicalOperatorType::LOGICAL_UPDATE_EXTENSIONS:
215: 		plan = CreatePlan(op.Cast<LogicalSimple>());
216: 		break;
217: 	case LogicalOperatorType::LOGICAL_EXTENSION_OPERATOR:
218: 		plan = op.Cast<LogicalExtensionOperator>().CreatePlan(context, *this);
219: 
220: 		if (!plan) {
221: 			throw InternalException("Missing PhysicalOperator for Extension Operator");
222: 		}
223: 		break;
224: 	case LogicalOperatorType::LOGICAL_JOIN:
225: 	case LogicalOperatorType::LOGICAL_DEPENDENT_JOIN:
226: 	case LogicalOperatorType::LOGICAL_INVALID: {
227: 		throw NotImplementedException("Unimplemented logical operator type!");
228: 	}
229: 	}
230: 	if (!plan) {
231: 		throw InternalException("Physical plan generator - no plan generated");
232: 	}
233: 
234: 	plan->estimated_cardinality = op.estimated_cardinality;
235: #ifdef DUCKDB_VERIFY_VECTOR_OPERATOR
236: 	auto verify = make_uniq<PhysicalVerifyVector>(std::move(plan));
237: 	plan = std::move(verify);
238: #endif
239: 
240: 	return plan;
241: }
242: 
243: } // namespace duckdb
[end of src/execution/physical_plan_generator.cpp]
[start of src/function/function_binder.cpp]
1: #include "duckdb/function/function_binder.hpp"
2: 
3: #include "duckdb/catalog/catalog.hpp"
4: #include "duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp"
5: #include "duckdb/common/limits.hpp"
6: #include "duckdb/execution/expression_executor.hpp"
7: #include "duckdb/function/aggregate_function.hpp"
8: #include "duckdb/function/cast_rules.hpp"
9: #include "duckdb/parser/parsed_data/create_secret_info.hpp"
10: #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
11: #include "duckdb/planner/expression/bound_cast_expression.hpp"
12: #include "duckdb/planner/expression/bound_constant_expression.hpp"
13: #include "duckdb/planner/expression/bound_function_expression.hpp"
14: #include "duckdb/planner/expression_binder.hpp"
15: #include "duckdb/function/scalar/generic_functions.hpp"
16: 
17: namespace duckdb {
18: 
19: FunctionBinder::FunctionBinder(ClientContext &context) : context(context) {
20: }
21: 
22: optional_idx FunctionBinder::BindVarArgsFunctionCost(const SimpleFunction &func, const vector<LogicalType> &arguments) {
23: 	if (arguments.size() < func.arguments.size()) {
24: 		// not enough arguments to fulfill the non-vararg part of the function
25: 		return optional_idx();
26: 	}
27: 	idx_t cost = 0;
28: 	for (idx_t i = 0; i < arguments.size(); i++) {
29: 		LogicalType arg_type = i < func.arguments.size() ? func.arguments[i] : func.varargs;
30: 		if (arguments[i] == arg_type) {
31: 			// arguments match: do nothing
32: 			continue;
33: 		}
34: 		int64_t cast_cost = CastFunctionSet::Get(context).ImplicitCastCost(arguments[i], arg_type);
35: 		if (cast_cost >= 0) {
36: 			// we can implicitly cast, add the cost to the total cost
37: 			cost += idx_t(cast_cost);
38: 		} else {
39: 			// we can't implicitly cast: throw an error
40: 			return optional_idx();
41: 		}
42: 	}
43: 	return cost;
44: }
45: 
46: optional_idx FunctionBinder::BindFunctionCost(const SimpleFunction &func, const vector<LogicalType> &arguments) {
47: 	if (func.HasVarArgs()) {
48: 		// special case varargs function
49: 		return BindVarArgsFunctionCost(func, arguments);
50: 	}
51: 	if (func.arguments.size() != arguments.size()) {
52: 		// invalid argument count: check the next function
53: 		return optional_idx();
54: 	}
55: 	idx_t cost = 0;
56: 	bool has_parameter = false;
57: 	for (idx_t i = 0; i < arguments.size(); i++) {
58: 		if (arguments[i].id() == LogicalTypeId::UNKNOWN) {
59: 			has_parameter = true;
60: 			continue;
61: 		}
62: 		int64_t cast_cost = CastFunctionSet::Get(context).ImplicitCastCost(arguments[i], func.arguments[i]);
63: 		if (cast_cost >= 0) {
64: 			// we can implicitly cast, add the cost to the total cost
65: 			cost += idx_t(cast_cost);
66: 		} else {
67: 			// we can't implicitly cast: throw an error
68: 			return optional_idx();
69: 		}
70: 	}
71: 	if (has_parameter) {
72: 		// all arguments are implicitly castable and there is a parameter - return 0 as cost
73: 		return 0;
74: 	}
75: 	return cost;
76: }
77: 
78: template <class T>
79: vector<idx_t> FunctionBinder::BindFunctionsFromArguments(const string &name, FunctionSet<T> &functions,
80:                                                          const vector<LogicalType> &arguments, ErrorData &error) {
81: 	optional_idx best_function;
82: 	idx_t lowest_cost = NumericLimits<idx_t>::Maximum();
83: 	vector<idx_t> candidate_functions;
84: 	for (idx_t f_idx = 0; f_idx < functions.functions.size(); f_idx++) {
85: 		auto &func = functions.functions[f_idx];
86: 		// check the arguments of the function
87: 		auto bind_cost = BindFunctionCost(func, arguments);
88: 		if (!bind_cost.IsValid()) {
89: 			// auto casting was not possible
90: 			continue;
91: 		}
92: 		auto cost = bind_cost.GetIndex();
93: 		if (cost == lowest_cost) {
94: 			candidate_functions.push_back(f_idx);
95: 			continue;
96: 		}
97: 		if (cost > lowest_cost) {
98: 			continue;
99: 		}
100: 		candidate_functions.clear();
101: 		lowest_cost = cost;
102: 		best_function = f_idx;
103: 	}
104: 	if (!best_function.IsValid()) {
105: 		// no matching function was found, throw an error
106: 		vector<string> candidates;
107: 		for (auto &f : functions.functions) {
108: 			candidates.push_back(f.ToString());
109: 		}
110: 		error = ErrorData(BinderException::NoMatchingFunction(name, arguments, candidates));
111: 		return candidate_functions;
112: 	}
113: 	candidate_functions.push_back(best_function.GetIndex());
114: 	return candidate_functions;
115: }
116: 
117: template <class T>
118: optional_idx FunctionBinder::MultipleCandidateException(const string &name, FunctionSet<T> &functions,
119:                                                         vector<idx_t> &candidate_functions,
120:                                                         const vector<LogicalType> &arguments, ErrorData &error) {
121: 	D_ASSERT(functions.functions.size() > 1);
122: 	// there are multiple possible function definitions
123: 	// throw an exception explaining which overloads are there
124: 	string call_str = Function::CallToString(name, arguments);
125: 	string candidate_str;
126: 	for (auto &conf : candidate_functions) {
127: 		T f = functions.GetFunctionByOffset(conf);
128: 		candidate_str += "\t" + f.ToString() + "\n";
129: 	}
130: 	error = ErrorData(
131: 	    ExceptionType::BINDER,
132: 	    StringUtil::Format("Could not choose a best candidate function for the function call \"%s\". In order to "
133: 	                       "select one, please add explicit type casts.\n\tCandidate functions:\n%s",
134: 	                       call_str, candidate_str));
135: 	return optional_idx();
136: }
137: 
138: template <class T>
139: optional_idx FunctionBinder::BindFunctionFromArguments(const string &name, FunctionSet<T> &functions,
140:                                                        const vector<LogicalType> &arguments, ErrorData &error) {
141: 	auto candidate_functions = BindFunctionsFromArguments<T>(name, functions, arguments, error);
142: 	if (candidate_functions.empty()) {
143: 		// no candidates
144: 		return optional_idx();
145: 	}
146: 	if (candidate_functions.size() > 1) {
147: 		// multiple candidates, check if there are any unknown arguments
148: 		bool has_parameters = false;
149: 		for (auto &arg_type : arguments) {
150: 			if (arg_type.id() == LogicalTypeId::UNKNOWN) {
151: 				//! there are! we could not resolve parameters in this case
152: 				throw ParameterNotResolvedException();
153: 			}
154: 		}
155: 		if (!has_parameters) {
156: 			return MultipleCandidateException(name, functions, candidate_functions, arguments, error);
157: 		}
158: 	}
159: 	return candidate_functions[0];
160: }
161: 
162: optional_idx FunctionBinder::BindFunction(const string &name, ScalarFunctionSet &functions,
163:                                           const vector<LogicalType> &arguments, ErrorData &error) {
164: 	return BindFunctionFromArguments(name, functions, arguments, error);
165: }
166: 
167: optional_idx FunctionBinder::BindFunction(const string &name, AggregateFunctionSet &functions,
168:                                           const vector<LogicalType> &arguments, ErrorData &error) {
169: 	return BindFunctionFromArguments(name, functions, arguments, error);
170: }
171: 
172: optional_idx FunctionBinder::BindFunction(const string &name, TableFunctionSet &functions,
173:                                           const vector<LogicalType> &arguments, ErrorData &error) {
174: 	return BindFunctionFromArguments(name, functions, arguments, error);
175: }
176: 
177: optional_idx FunctionBinder::BindFunction(const string &name, PragmaFunctionSet &functions, vector<Value> &parameters,
178:                                           ErrorData &error) {
179: 	vector<LogicalType> types;
180: 	for (auto &value : parameters) {
181: 		types.push_back(value.type());
182: 	}
183: 	auto entry = BindFunctionFromArguments(name, functions, types, error);
184: 	if (!entry.IsValid()) {
185: 		error.Throw();
186: 	}
187: 	auto candidate_function = functions.GetFunctionByOffset(entry.GetIndex());
188: 	// cast the input parameters
189: 	for (idx_t i = 0; i < parameters.size(); i++) {
190: 		auto target_type =
191: 		    i < candidate_function.arguments.size() ? candidate_function.arguments[i] : candidate_function.varargs;
192: 		parameters[i] = parameters[i].CastAs(context, target_type);
193: 	}
194: 	return entry;
195: }
196: 
197: vector<LogicalType> FunctionBinder::GetLogicalTypesFromExpressions(vector<unique_ptr<Expression>> &arguments) {
198: 	vector<LogicalType> types;
199: 	types.reserve(arguments.size());
200: 	for (auto &argument : arguments) {
201: 		types.push_back(ExpressionBinder::GetExpressionReturnType(*argument));
202: 	}
203: 	return types;
204: }
205: 
206: optional_idx FunctionBinder::BindFunction(const string &name, ScalarFunctionSet &functions,
207:                                           vector<unique_ptr<Expression>> &arguments, ErrorData &error) {
208: 	auto types = GetLogicalTypesFromExpressions(arguments);
209: 	return BindFunction(name, functions, types, error);
210: }
211: 
212: optional_idx FunctionBinder::BindFunction(const string &name, AggregateFunctionSet &functions,
213:                                           vector<unique_ptr<Expression>> &arguments, ErrorData &error) {
214: 	auto types = GetLogicalTypesFromExpressions(arguments);
215: 	return BindFunction(name, functions, types, error);
216: }
217: 
218: optional_idx FunctionBinder::BindFunction(const string &name, TableFunctionSet &functions,
219:                                           vector<unique_ptr<Expression>> &arguments, ErrorData &error) {
220: 	auto types = GetLogicalTypesFromExpressions(arguments);
221: 	return BindFunction(name, functions, types, error);
222: }
223: 
224: enum class LogicalTypeComparisonResult : uint8_t { IDENTICAL_TYPE, TARGET_IS_ANY, DIFFERENT_TYPES };
225: 
226: LogicalTypeComparisonResult RequiresCast(const LogicalType &source_type, const LogicalType &target_type) {
227: 	if (target_type.id() == LogicalTypeId::ANY) {
228: 		return LogicalTypeComparisonResult::TARGET_IS_ANY;
229: 	}
230: 	if (source_type == target_type) {
231: 		return LogicalTypeComparisonResult::IDENTICAL_TYPE;
232: 	}
233: 	if (source_type.id() == LogicalTypeId::LIST && target_type.id() == LogicalTypeId::LIST) {
234: 		return RequiresCast(ListType::GetChildType(source_type), ListType::GetChildType(target_type));
235: 	}
236: 	if (source_type.id() == LogicalTypeId::ARRAY && target_type.id() == LogicalTypeId::ARRAY) {
237: 		return RequiresCast(ArrayType::GetChildType(source_type), ArrayType::GetChildType(target_type));
238: 	}
239: 	return LogicalTypeComparisonResult::DIFFERENT_TYPES;
240: }
241: 
242: bool TypeRequiresPrepare(const LogicalType &type) {
243: 	if (type.id() == LogicalTypeId::ANY) {
244: 		return true;
245: 	}
246: 	if (type.id() == LogicalTypeId::LIST) {
247: 		return TypeRequiresPrepare(ListType::GetChildType(type));
248: 	}
249: 	return false;
250: }
251: 
252: LogicalType PrepareTypeForCastRecursive(const LogicalType &type) {
253: 	if (type.id() == LogicalTypeId::ANY) {
254: 		return AnyType::GetTargetType(type);
255: 	}
256: 	if (type.id() == LogicalTypeId::LIST) {
257: 		return LogicalType::LIST(PrepareTypeForCastRecursive(ListType::GetChildType(type)));
258: 	}
259: 	return type;
260: }
261: 
262: void PrepareTypeForCast(LogicalType &type) {
263: 	if (!TypeRequiresPrepare(type)) {
264: 		return;
265: 	}
266: 	type = PrepareTypeForCastRecursive(type);
267: }
268: 
269: void FunctionBinder::CastToFunctionArguments(SimpleFunction &function, vector<unique_ptr<Expression>> &children) {
270: 	for (auto &arg : function.arguments) {
271: 		PrepareTypeForCast(arg);
272: 	}
273: 	PrepareTypeForCast(function.varargs);
274: 
275: 	for (idx_t i = 0; i < children.size(); i++) {
276: 		auto target_type = i < function.arguments.size() ? function.arguments[i] : function.varargs;
277: 		if (target_type.id() == LogicalTypeId::STRING_LITERAL || target_type.id() == LogicalTypeId::INTEGER_LITERAL) {
278: 			throw InternalException(
279: 			    "Function %s returned a STRING_LITERAL or INTEGER_LITERAL type - return an explicit type instead",
280: 			    function.name);
281: 		}
282: 		target_type.Verify();
283: 		// don't cast lambda children, they get removed before execution
284: 		if (children[i]->return_type.id() == LogicalTypeId::LAMBDA) {
285: 			continue;
286: 		}
287: 		// check if the type of child matches the type of function argument
288: 		// if not we need to add a cast
289: 		auto cast_result = RequiresCast(children[i]->return_type, target_type);
290: 		// except for one special case: if the function accepts ANY argument
291: 		// in that case we don't add a cast
292: 		if (cast_result == LogicalTypeComparisonResult::DIFFERENT_TYPES) {
293: 			children[i] = BoundCastExpression::AddCastToType(context, std::move(children[i]), target_type);
294: 		}
295: 	}
296: }
297: 
298: unique_ptr<Expression> FunctionBinder::BindScalarFunction(const string &schema, const string &name,
299:                                                           vector<unique_ptr<Expression>> children, ErrorData &error,
300:                                                           bool is_operator, optional_ptr<Binder> binder) {
301: 	// bind the function
302: 	auto &function =
303: 	    Catalog::GetSystemCatalog(context).GetEntry(context, CatalogType::SCALAR_FUNCTION_ENTRY, schema, name);
304: 	D_ASSERT(function.type == CatalogType::SCALAR_FUNCTION_ENTRY);
305: 	return BindScalarFunction(function.Cast<ScalarFunctionCatalogEntry>(), std::move(children), error, is_operator,
306: 	                          binder);
307: }
308: 
309: unique_ptr<Expression> FunctionBinder::BindScalarFunction(ScalarFunctionCatalogEntry &func,
310:                                                           vector<unique_ptr<Expression>> children, ErrorData &error,
311:                                                           bool is_operator, optional_ptr<Binder> binder) {
312: 	// bind the function
313: 	auto best_function = BindFunction(func.name, func.functions, children, error);
314: 	if (!best_function.IsValid()) {
315: 		return nullptr;
316: 	}
317: 
318: 	// found a matching function!
319: 	auto bound_function = func.functions.GetFunctionByOffset(best_function.GetIndex());
320: 
321: 	// If any of the parameters are NULL, the function will just be replaced with a NULL constant
322: 	// But this NULL constant needs to have to correct type, because we use LogicalType::SQLNULL for binding macro's
323: 	// However, some functions may have an invalid return type, so we default to SQLNULL for those
324: 	LogicalType return_type_if_null;
325: 	switch (bound_function.return_type.id()) {
326: 	case LogicalTypeId::ANY:
327: 	case LogicalTypeId::DECIMAL:
328: 	case LogicalTypeId::STRUCT:
329: 	case LogicalTypeId::LIST:
330: 	case LogicalTypeId::MAP:
331: 	case LogicalTypeId::UNION:
332: 	case LogicalTypeId::ARRAY:
333: 		return_type_if_null = LogicalType::SQLNULL;
334: 		break;
335: 	default:
336: 		return_type_if_null = bound_function.return_type;
337: 	}
338: 
339: 	if (bound_function.null_handling == FunctionNullHandling::DEFAULT_NULL_HANDLING) {
340: 		for (auto &child : children) {
341: 			if (child->return_type == LogicalTypeId::SQLNULL) {
342: 				return make_uniq<BoundConstantExpression>(Value(return_type_if_null));
343: 			}
344: 			if (!child->IsFoldable()) {
345: 				continue;
346: 			}
347: 			Value result;
348: 			if (!ExpressionExecutor::TryEvaluateScalar(context, *child, result)) {
349: 				continue;
350: 			}
351: 			if (result.IsNull()) {
352: 				return make_uniq<BoundConstantExpression>(Value(return_type_if_null));
353: 			}
354: 		}
355: 	}
356: 	return BindScalarFunction(bound_function, std::move(children), is_operator, binder);
357: }
358: 
359: bool RequiresCollationPropagation(const LogicalType &type) {
360: 	return type.id() == LogicalTypeId::VARCHAR && !type.HasAlias();
361: }
362: 
363: string ExtractCollation(const vector<unique_ptr<Expression>> &children) {
364: 	string collation;
365: 	for (auto &arg : children) {
366: 		if (!RequiresCollationPropagation(arg->return_type)) {
367: 			// not a varchar column
368: 			continue;
369: 		}
370: 		auto child_collation = StringType::GetCollation(arg->return_type);
371: 		if (collation.empty()) {
372: 			collation = child_collation;
373: 		} else if (!child_collation.empty() && collation != child_collation) {
374: 			throw BinderException("Cannot combine types with different collation!");
375: 		}
376: 	}
377: 	return collation;
378: }
379: 
380: void PropagateCollations(ClientContext &, ScalarFunction &bound_function, vector<unique_ptr<Expression>> &children) {
381: 	if (!RequiresCollationPropagation(bound_function.return_type)) {
382: 		// we only need to propagate if the function returns a varchar
383: 		return;
384: 	}
385: 	auto collation = ExtractCollation(children);
386: 	if (collation.empty()) {
387: 		// no collation to propagate
388: 		return;
389: 	}
390: 	// propagate the collation to the return type
391: 	auto collation_type = LogicalType::VARCHAR_COLLATION(std::move(collation));
392: 	bound_function.return_type = std::move(collation_type);
393: }
394: 
395: void PushCollations(ClientContext &context, ScalarFunction &bound_function, vector<unique_ptr<Expression>> &children,
396:                     CollationType type) {
397: 	auto collation = ExtractCollation(children);
398: 	if (collation.empty()) {
399: 		// no collation to push
400: 		return;
401: 	}
402: 	// push collation into the return type if required
403: 	auto collation_type = LogicalType::VARCHAR_COLLATION(std::move(collation));
404: 	if (RequiresCollationPropagation(bound_function.return_type)) {
405: 		bound_function.return_type = collation_type;
406: 	}
407: 	// push collations to the children
408: 	for (auto &arg : children) {
409: 		if (RequiresCollationPropagation(arg->return_type)) {
410: 			// if this is a varchar type - propagate the collation
411: 			arg->return_type = collation_type;
412: 		}
413: 		// now push the actual collation handling
414: 		ExpressionBinder::PushCollation(context, arg, arg->return_type, type);
415: 	}
416: }
417: 
418: void HandleCollations(ClientContext &context, ScalarFunction &bound_function,
419:                       vector<unique_ptr<Expression>> &children) {
420: 	switch (bound_function.collation_handling) {
421: 	case FunctionCollationHandling::IGNORE_COLLATIONS:
422: 		// explicitly ignoring collation handling
423: 		break;
424: 	case FunctionCollationHandling::PROPAGATE_COLLATIONS:
425: 		PropagateCollations(context, bound_function, children);
426: 		break;
427: 	case FunctionCollationHandling::PUSH_COMBINABLE_COLLATIONS:
428: 		// first propagate, then push collations to the children
429: 		PushCollations(context, bound_function, children, CollationType::COMBINABLE_COLLATIONS);
430: 		break;
431: 	default:
432: 		throw InternalException("Unrecognized collation handling");
433: 	}
434: }
435: 
436: unique_ptr<Expression> FunctionBinder::BindScalarFunction(ScalarFunction bound_function,
437:                                                           vector<unique_ptr<Expression>> children, bool is_operator,
438:                                                           optional_ptr<Binder> binder) {
439: 	unique_ptr<FunctionData> bind_info;
440: 
441: 	if (bound_function.bind) {
442: 		bind_info = bound_function.bind(context, bound_function, children);
443: 	}
444: 	if (bound_function.get_modified_databases && binder) {
445: 		auto &properties = binder->GetStatementProperties();
446: 		FunctionModifiedDatabasesInput input(bind_info, properties);
447: 		bound_function.get_modified_databases(context, input);
448: 	}
449: 	HandleCollations(context, bound_function, children);
450: 
451: 	// check if we need to add casts to the children
452: 	CastToFunctionArguments(bound_function, children);
453: 
454: 	auto return_type = bound_function.return_type;
455: 	unique_ptr<Expression> result;
456: 	auto result_func = make_uniq<BoundFunctionExpression>(std::move(return_type), std::move(bound_function),
457: 	                                                      std::move(children), std::move(bind_info), is_operator);
458: 	if (result_func->function.bind_expression) {
459: 		// if a bind_expression callback is registered - call it and emit the resulting expression
460: 		FunctionBindExpressionInput input(context, result_func->bind_info.get(), *result_func);
461: 		result = result_func->function.bind_expression(input);
462: 	}
463: 	if (!result) {
464: 		result = std::move(result_func);
465: 	}
466: 	return result;
467: }
468: 
469: unique_ptr<BoundAggregateExpression> FunctionBinder::BindAggregateFunction(AggregateFunction bound_function,
470:                                                                            vector<unique_ptr<Expression>> children,
471:                                                                            unique_ptr<Expression> filter,
472:                                                                            AggregateType aggr_type) {
473: 	unique_ptr<FunctionData> bind_info;
474: 	if (bound_function.bind) {
475: 		bind_info = bound_function.bind(context, bound_function, children);
476: 		// we may have lost some arguments in the bind
477: 		children.resize(MinValue(bound_function.arguments.size(), children.size()));
478: 	}
479: 
480: 	// check if we need to add casts to the children
481: 	CastToFunctionArguments(bound_function, children);
482: 
483: 	return make_uniq<BoundAggregateExpression>(std::move(bound_function), std::move(children), std::move(filter),
484: 	                                           std::move(bind_info), aggr_type);
485: }
486: 
487: } // namespace duckdb
[end of src/function/function_binder.cpp]
[start of src/function/scalar/sequence/nextval.cpp]
1: #include "duckdb/function/scalar/sequence_functions.hpp"
2: #include "duckdb/function/scalar/sequence_utils.hpp"
3: 
4: #include "duckdb/catalog/catalog.hpp"
5: #include "duckdb/catalog/dependency_list.hpp"
6: #include "duckdb/catalog/catalog_entry/sequence_catalog_entry.hpp"
7: #include "duckdb/common/exception.hpp"
8: #include "duckdb/common/vector_operations/vector_operations.hpp"
9: #include "duckdb/execution/expression_executor.hpp"
10: #include "duckdb/planner/expression/bound_function_expression.hpp"
11: #include "duckdb/transaction/duck_transaction.hpp"
12: #include "duckdb/common/serializer/deserializer.hpp"
13: #include "duckdb/common/serializer/serializer.hpp"
14: #include "duckdb/common/vector_operations/unary_executor.hpp"
15: #include "duckdb/transaction/meta_transaction.hpp"
16: #include "duckdb/planner/binder.hpp"
17: 
18: namespace duckdb {
19: 
20: struct CurrentSequenceValueOperator {
21: 	static int64_t Operation(DuckTransaction &, SequenceCatalogEntry &seq) {
22: 		return seq.CurrentValue();
23: 	}
24: };
25: 
26: struct NextSequenceValueOperator {
27: 	static int64_t Operation(DuckTransaction &transaction, SequenceCatalogEntry &seq) {
28: 		return seq.NextValue(transaction);
29: 	}
30: };
31: 
32: SequenceCatalogEntry &BindSequence(ClientContext &context, string &catalog, string &schema, const string &name) {
33: 	// fetch the sequence from the catalog
34: 	Binder::BindSchemaOrCatalog(context, catalog, schema);
35: 	return Catalog::GetEntry<SequenceCatalogEntry>(context, catalog, schema, name);
36: }
37: 
38: SequenceCatalogEntry &BindSequence(ClientContext &context, const string &name) {
39: 	auto qname = QualifiedName::Parse(name);
40: 	return BindSequence(context, qname.catalog, qname.schema, qname.name);
41: }
42: 
43: struct NextValLocalState : public FunctionLocalState {
44: 	explicit NextValLocalState(DuckTransaction &transaction, SequenceCatalogEntry &sequence)
45: 	    : transaction(transaction), sequence(sequence) {
46: 	}
47: 
48: 	DuckTransaction &transaction;
49: 	SequenceCatalogEntry &sequence;
50: };
51: 
52: unique_ptr<FunctionLocalState> NextValLocalFunction(ExpressionState &state, const BoundFunctionExpression &expr,
53:                                                     FunctionData *bind_data) {
54: 	if (!bind_data) {
55: 		return nullptr;
56: 	}
57: 	auto &context = state.GetContext();
58: 	auto &info = bind_data->Cast<NextvalBindData>();
59: 	auto &sequence = info.sequence;
60: 	auto &transaction = DuckTransaction::Get(context, sequence.catalog);
61: 	return make_uniq<NextValLocalState>(transaction, sequence);
62: }
63: 
64: template <class OP>
65: static void NextValFunction(DataChunk &args, ExpressionState &state, Vector &result) {
66: 	auto &func_expr = state.expr.Cast<BoundFunctionExpression>();
67: 	if (!func_expr.bind_info) {
68: 		// no bind info - return null
69: 		result.SetVectorType(VectorType::CONSTANT_VECTOR);
70: 		ConstantVector::SetNull(result, true);
71: 		return;
72: 	}
73: 	auto &lstate = ExecuteFunctionState::GetFunctionState(state)->Cast<NextValLocalState>();
74: 	// sequence to use is hard coded
75: 	// increment the sequence
76: 	result.SetVectorType(VectorType::FLAT_VECTOR);
77: 	auto result_data = FlatVector::GetData<int64_t>(result);
78: 	for (idx_t i = 0; i < args.size(); i++) {
79: 		// get the next value from the sequence
80: 		result_data[i] = OP::Operation(lstate.transaction, lstate.sequence);
81: 	}
82: }
83: 
84: static unique_ptr<FunctionData> NextValBind(ClientContext &context, ScalarFunction &,
85:                                             vector<unique_ptr<Expression>> &arguments) {
86: 	if (!arguments[0]->IsFoldable()) {
87: 		throw NotImplementedException(
88: 		    "currval/nextval requires a constant sequence - non-constant sequences are no longer supported");
89: 	}
90: 	// parameter to nextval function is a foldable constant
91: 	// evaluate the constant and perform the catalog lookup already
92: 	auto seqname = ExpressionExecutor::EvaluateScalar(context, *arguments[0]);
93: 	if (seqname.IsNull()) {
94: 		return nullptr;
95: 	}
96: 	auto &seq = BindSequence(context, seqname.ToString());
97: 	return make_uniq<NextvalBindData>(seq);
98: }
99: 
100: static void NextValDependency(BoundFunctionExpression &expr, LogicalDependencyList &dependencies) {
101: 	if (!expr.bind_info) {
102: 		return;
103: 	}
104: 	auto &info = expr.bind_info->Cast<NextvalBindData>();
105: 	dependencies.AddDependency(info.sequence);
106: }
107: 
108: void Serialize(Serializer &serializer, const optional_ptr<FunctionData> bind_data, const ScalarFunction &) {
109: 	auto &next_val_bind_data = bind_data->Cast<NextvalBindData>();
110: 	serializer.WritePropertyWithDefault(100, "sequence_create_info", next_val_bind_data.create_info);
111: }
112: 
113: unique_ptr<FunctionData> Deserialize(Deserializer &deserializer, ScalarFunction &) {
114: 	auto create_info = deserializer.ReadPropertyWithExplicitDefault<unique_ptr<CreateInfo>>(100, "sequence_create_info",
115: 	                                                                                        unique_ptr<CreateInfo>());
116: 	if (!create_info) {
117: 		return nullptr;
118: 	}
119: 	auto &seq_info = create_info->Cast<CreateSequenceInfo>();
120: 	auto &context = deserializer.Get<ClientContext &>();
121: 	auto &sequence = BindSequence(context, seq_info.catalog, seq_info.schema, seq_info.name);
122: 	return make_uniq<NextvalBindData>(sequence);
123: }
124: 
125: void NextValModifiedDatabases(ClientContext &context, FunctionModifiedDatabasesInput &input) {
126: 	if (!input.bind_data) {
127: 		return;
128: 	}
129: 	auto &seq = input.bind_data->Cast<NextvalBindData>();
130: 	input.properties.RegisterDBModify(seq.sequence.ParentCatalog(), context);
131: }
132: 
133: ScalarFunction NextvalFun::GetFunction() {
134: 	ScalarFunction next_val("nextval", {LogicalType::VARCHAR}, LogicalType::BIGINT,
135: 	                        NextValFunction<NextSequenceValueOperator>, NextValBind, NextValDependency);
136: 	next_val.stability = FunctionStability::VOLATILE;
137: 	next_val.serialize = Serialize;
138: 	next_val.deserialize = Deserialize;
139: 	next_val.get_modified_databases = NextValModifiedDatabases;
140: 	next_val.init_local_state = NextValLocalFunction;
141: 	return next_val;
142: }
143: 
144: ScalarFunction CurrvalFun::GetFunction() {
145: 	ScalarFunction curr_val("currval", {LogicalType::VARCHAR}, LogicalType::BIGINT,
146: 	                        NextValFunction<CurrentSequenceValueOperator>, NextValBind, NextValDependency);
147: 	curr_val.stability = FunctionStability::VOLATILE;
148: 	curr_val.serialize = Serialize;
149: 	curr_val.deserialize = Deserialize;
150: 	curr_val.init_local_state = NextValLocalFunction;
151: 	return curr_val;
152: }
153: 
154: } // namespace duckdb
[end of src/function/scalar/sequence/nextval.cpp]
[start of src/function/scalar_function.cpp]
1: #include "duckdb/function/scalar_function.hpp"
2: 
3: namespace duckdb {
4: 
5: FunctionLocalState::~FunctionLocalState() {
6: }
7: 
8: ScalarFunctionInfo::~ScalarFunctionInfo() {
9: }
10: 
11: ScalarFunction::ScalarFunction(string name, vector<LogicalType> arguments, LogicalType return_type,
12:                                scalar_function_t function, bind_scalar_function_t bind,
13:                                dependency_function_t dependency, function_statistics_t statistics,
14:                                init_local_state_t init_local_state, LogicalType varargs, FunctionStability side_effects,
15:                                FunctionNullHandling null_handling, bind_lambda_function_t bind_lambda)
16:     : BaseScalarFunction(std::move(name), std::move(arguments), std::move(return_type), side_effects,
17:                          std::move(varargs), null_handling),
18:       function(std::move(function)), bind(bind), init_local_state(init_local_state), dependency(dependency),
19:       statistics(statistics), bind_lambda(bind_lambda), bind_expression(nullptr), get_modified_databases(nullptr),
20:       serialize(nullptr), deserialize(nullptr) {
21: }
22: 
23: ScalarFunction::ScalarFunction(vector<LogicalType> arguments, LogicalType return_type, scalar_function_t function,
24:                                bind_scalar_function_t bind, dependency_function_t dependency,
25:                                function_statistics_t statistics, init_local_state_t init_local_state,
26:                                LogicalType varargs, FunctionStability side_effects, FunctionNullHandling null_handling,
27:                                bind_lambda_function_t bind_lambda)
28:     : ScalarFunction(string(), std::move(arguments), std::move(return_type), std::move(function), bind, dependency,
29:                      statistics, init_local_state, std::move(varargs), side_effects, null_handling, bind_lambda) {
30: }
31: 
32: bool ScalarFunction::operator==(const ScalarFunction &rhs) const {
33: 	return name == rhs.name && arguments == rhs.arguments && return_type == rhs.return_type && varargs == rhs.varargs &&
34: 	       bind == rhs.bind && dependency == rhs.dependency && statistics == rhs.statistics &&
35: 	       bind_lambda == rhs.bind_lambda;
36: }
37: 
38: bool ScalarFunction::operator!=(const ScalarFunction &rhs) const {
39: 	return !(*this == rhs);
40: }
41: 
42: bool ScalarFunction::Equal(const ScalarFunction &rhs) const {
43: 	// number of types
44: 	if (this->arguments.size() != rhs.arguments.size()) {
45: 		return false;
46: 	}
47: 	// argument types
48: 	for (idx_t i = 0; i < this->arguments.size(); ++i) {
49: 		if (this->arguments[i] != rhs.arguments[i]) {
50: 			return false;
51: 		}
52: 	}
53: 	// return type
54: 	if (this->return_type != rhs.return_type) {
55: 		return false;
56: 	}
57: 	// varargs
58: 	if (this->varargs != rhs.varargs) {
59: 		return false;
60: 	}
61: 
62: 	return true; // they are equal
63: }
64: 
65: void ScalarFunction::NopFunction(DataChunk &input, ExpressionState &state, Vector &result) {
66: 	D_ASSERT(input.ColumnCount() >= 1);
67: 	result.Reference(input.data[0]);
68: }
69: 
70: } // namespace duckdb
[end of src/function/scalar_function.cpp]
[start of src/include/duckdb/function/function_binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/function/function_binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/function/function.hpp"
12: #include "duckdb/function/cast/cast_function_set.hpp"
13: #include "duckdb/function/scalar_function.hpp"
14: #include "duckdb/function/aggregate_function.hpp"
15: #include "duckdb/function/function_set.hpp"
16: #include "duckdb/common/exception/binder_exception.hpp"
17: #include "duckdb/common/error_data.hpp"
18: 
19: namespace duckdb {
20: 
21: //! The FunctionBinder class is responsible for binding functions
22: class FunctionBinder {
23: public:
24: 	DUCKDB_API explicit FunctionBinder(ClientContext &context);
25: 
26: 	ClientContext &context;
27: 
28: public:
29: 	//! Bind a scalar function from the set of functions and input arguments. Returns the index of the chosen function,
30: 	//! returns optional_idx() and sets error if none could be found
31: 	DUCKDB_API optional_idx BindFunction(const string &name, ScalarFunctionSet &functions,
32: 	                                     const vector<LogicalType> &arguments, ErrorData &error);
33: 	DUCKDB_API optional_idx BindFunction(const string &name, ScalarFunctionSet &functions,
34: 	                                     vector<unique_ptr<Expression>> &arguments, ErrorData &error);
35: 	//! Bind an aggregate function from the set of functions and input arguments. Returns the index of the chosen
36: 	//! function, returns optional_idx() and sets error if none could be found
37: 	DUCKDB_API optional_idx BindFunction(const string &name, AggregateFunctionSet &functions,
38: 	                                     const vector<LogicalType> &arguments, ErrorData &error);
39: 	DUCKDB_API optional_idx BindFunction(const string &name, AggregateFunctionSet &functions,
40: 	                                     vector<unique_ptr<Expression>> &arguments, ErrorData &error);
41: 	//! Bind a table function from the set of functions and input arguments. Returns the index of the chosen
42: 	//! function, returns optional_idx() and sets error if none could be found
43: 	DUCKDB_API optional_idx BindFunction(const string &name, TableFunctionSet &functions,
44: 	                                     const vector<LogicalType> &arguments, ErrorData &error);
45: 	DUCKDB_API optional_idx BindFunction(const string &name, TableFunctionSet &functions,
46: 	                                     vector<unique_ptr<Expression>> &arguments, ErrorData &error);
47: 	//! Bind a pragma function from the set of functions and input arguments
48: 	DUCKDB_API optional_idx BindFunction(const string &name, PragmaFunctionSet &functions, vector<Value> &parameters,
49: 	                                     ErrorData &error);
50: 
51: 	DUCKDB_API unique_ptr<Expression> BindScalarFunction(const string &schema, const string &name,
52: 	                                                     vector<unique_ptr<Expression>> children, ErrorData &error,
53: 	                                                     bool is_operator = false,
54: 	                                                     optional_ptr<Binder> binder = nullptr);
55: 	DUCKDB_API unique_ptr<Expression> BindScalarFunction(ScalarFunctionCatalogEntry &function,
56: 	                                                     vector<unique_ptr<Expression>> children, ErrorData &error,
57: 	                                                     bool is_operator = false,
58: 	                                                     optional_ptr<Binder> binder = nullptr);
59: 
60: 	DUCKDB_API unique_ptr<Expression> BindScalarFunction(ScalarFunction bound_function,
61: 	                                                     vector<unique_ptr<Expression>> children,
62: 	                                                     bool is_operator = false,
63: 	                                                     optional_ptr<Binder> binder = nullptr);
64: 
65: 	DUCKDB_API unique_ptr<BoundAggregateExpression>
66: 	BindAggregateFunction(AggregateFunction bound_function, vector<unique_ptr<Expression>> children,
67: 	                      unique_ptr<Expression> filter = nullptr,
68: 	                      AggregateType aggr_type = AggregateType::NON_DISTINCT);
69: 
70: 	DUCKDB_API static void BindSortedAggregate(ClientContext &context, BoundAggregateExpression &expr,
71: 	                                           const vector<unique_ptr<Expression>> &groups);
72: 
73: private:
74: 	//! Cast a set of expressions to the arguments of this function
75: 	void CastToFunctionArguments(SimpleFunction &function, vector<unique_ptr<Expression>> &children);
76: 	optional_idx BindVarArgsFunctionCost(const SimpleFunction &func, const vector<LogicalType> &arguments);
77: 	optional_idx BindFunctionCost(const SimpleFunction &func, const vector<LogicalType> &arguments);
78: 
79: 	template <class T>
80: 	vector<idx_t> BindFunctionsFromArguments(const string &name, FunctionSet<T> &functions,
81: 	                                         const vector<LogicalType> &arguments, ErrorData &error);
82: 
83: 	template <class T>
84: 	optional_idx MultipleCandidateException(const string &name, FunctionSet<T> &functions,
85: 	                                        vector<idx_t> &candidate_functions, const vector<LogicalType> &arguments,
86: 	                                        ErrorData &error);
87: 
88: 	template <class T>
89: 	optional_idx BindFunctionFromArguments(const string &name, FunctionSet<T> &functions,
90: 	                                       const vector<LogicalType> &arguments, ErrorData &error);
91: 
92: 	vector<LogicalType> GetLogicalTypesFromExpressions(vector<unique_ptr<Expression>> &arguments);
93: };
94: 
95: } // namespace duckdb
[end of src/include/duckdb/function/function_binder.hpp]
[start of src/include/duckdb/function/scalar_function.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/function/scalar_function.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/vector_operations/binary_executor.hpp"
12: #include "duckdb/common/vector_operations/ternary_executor.hpp"
13: #include "duckdb/common/vector_operations/unary_executor.hpp"
14: #include "duckdb/common/vector_operations/vector_operations.hpp"
15: #include "duckdb/execution/expression_executor_state.hpp"
16: #include "duckdb/function/function.hpp"
17: #include "duckdb/storage/statistics/base_statistics.hpp"
18: #include "duckdb/common/optional_ptr.hpp"
19: 
20: namespace duckdb {
21: 
22: struct FunctionLocalState {
23: 	DUCKDB_API virtual ~FunctionLocalState();
24: 
25: 	template <class TARGET>
26: 	TARGET &Cast() {
27: 		DynamicCastCheck<TARGET>(this);
28: 		return reinterpret_cast<TARGET &>(*this);
29: 	}
30: 	template <class TARGET>
31: 	const TARGET &Cast() const {
32: 		DynamicCastCheck<TARGET>(this);
33: 		return reinterpret_cast<const TARGET &>(*this);
34: 	}
35: };
36: 
37: struct ScalarFunctionInfo {
38: 	DUCKDB_API virtual ~ScalarFunctionInfo();
39: 
40: 	template <class TARGET>
41: 	TARGET &Cast() {
42: 		DynamicCastCheck<TARGET>(this);
43: 		return reinterpret_cast<TARGET &>(*this);
44: 	}
45: 	template <class TARGET>
46: 	const TARGET &Cast() const {
47: 		DynamicCastCheck<TARGET>(this);
48: 		return reinterpret_cast<const TARGET &>(*this);
49: 	}
50: };
51: 
52: class Binder;
53: class BoundFunctionExpression;
54: class LogicalDependencyList;
55: class ScalarFunctionCatalogEntry;
56: 
57: struct StatementProperties;
58: 
59: struct FunctionStatisticsInput {
60: 	FunctionStatisticsInput(BoundFunctionExpression &expr_p, optional_ptr<FunctionData> bind_data_p,
61: 	                        vector<BaseStatistics> &child_stats_p, unique_ptr<Expression> *expr_ptr_p)
62: 	    : expr(expr_p), bind_data(bind_data_p), child_stats(child_stats_p), expr_ptr(expr_ptr_p) {
63: 	}
64: 
65: 	BoundFunctionExpression &expr;
66: 	optional_ptr<FunctionData> bind_data;
67: 	vector<BaseStatistics> &child_stats;
68: 	unique_ptr<Expression> *expr_ptr;
69: };
70: 
71: struct FunctionModifiedDatabasesInput {
72: 	FunctionModifiedDatabasesInput(optional_ptr<FunctionData> bind_data_p, StatementProperties &properties)
73: 	    : bind_data(bind_data_p), properties(properties) {
74: 	}
75: 
76: 	optional_ptr<FunctionData> bind_data;
77: 	StatementProperties &properties;
78: };
79: 
80: struct FunctionBindExpressionInput {
81: 	FunctionBindExpressionInput(ClientContext &context_p, optional_ptr<FunctionData> bind_data_p,
82: 	                            BoundFunctionExpression &function_p)
83: 	    : context(context_p), bind_data(bind_data_p), function(function_p) {
84: 	}
85: 
86: 	ClientContext &context;
87: 	optional_ptr<FunctionData> bind_data;
88: 	BoundFunctionExpression &function;
89: };
90: 
91: //! The scalar function type
92: typedef std::function<void(DataChunk &, ExpressionState &, Vector &)> scalar_function_t;
93: //! The type to bind the scalar function and to create the function data
94: typedef unique_ptr<FunctionData> (*bind_scalar_function_t)(ClientContext &context, ScalarFunction &bound_function,
95:                                                            vector<unique_ptr<Expression>> &arguments);
96: //! The type to initialize a thread local state for the scalar function
97: typedef unique_ptr<FunctionLocalState> (*init_local_state_t)(ExpressionState &state,
98:                                                              const BoundFunctionExpression &expr,
99:                                                              FunctionData *bind_data);
100: //! The type to add the dependencies of this BoundFunctionExpression to the set of dependencies
101: typedef void (*dependency_function_t)(BoundFunctionExpression &expr, LogicalDependencyList &dependencies);
102: //! The type to propagate statistics for this scalar function
103: typedef unique_ptr<BaseStatistics> (*function_statistics_t)(ClientContext &context, FunctionStatisticsInput &input);
104: //! The type to bind lambda-specific parameter types
105: typedef LogicalType (*bind_lambda_function_t)(const idx_t parameter_idx, const LogicalType &list_child_type);
106: //! The type to bind lambda-specific parameter types
107: typedef void (*get_modified_databases_t)(ClientContext &context, FunctionModifiedDatabasesInput &input);
108: 
109: typedef void (*function_serialize_t)(Serializer &serializer, const optional_ptr<FunctionData> bind_data,
110:                                      const ScalarFunction &function);
111: typedef unique_ptr<FunctionData> (*function_deserialize_t)(Deserializer &deserializer, ScalarFunction &function);
112: 
113: //! The type to bind lambda-specific parameter types
114: typedef unique_ptr<Expression> (*function_bind_expression_t)(FunctionBindExpressionInput &input);
115: 
116: class ScalarFunction : public BaseScalarFunction { // NOLINT: work-around bug in clang-tidy
117: public:
118: 	DUCKDB_API ScalarFunction(string name, vector<LogicalType> arguments, LogicalType return_type,
119: 	                          scalar_function_t function, bind_scalar_function_t bind = nullptr,
120: 	                          dependency_function_t dependency = nullptr, function_statistics_t statistics = nullptr,
121: 	                          init_local_state_t init_local_state = nullptr,
122: 	                          LogicalType varargs = LogicalType(LogicalTypeId::INVALID),
123: 	                          FunctionStability stability = FunctionStability::CONSISTENT,
124: 	                          FunctionNullHandling null_handling = FunctionNullHandling::DEFAULT_NULL_HANDLING,
125: 	                          bind_lambda_function_t bind_lambda = nullptr);
126: 
127: 	DUCKDB_API ScalarFunction(vector<LogicalType> arguments, LogicalType return_type, scalar_function_t function,
128: 	                          bind_scalar_function_t bind = nullptr, dependency_function_t dependency = nullptr,
129: 	                          function_statistics_t statistics = nullptr, init_local_state_t init_local_state = nullptr,
130: 	                          LogicalType varargs = LogicalType(LogicalTypeId::INVALID),
131: 	                          FunctionStability stability = FunctionStability::CONSISTENT,
132: 	                          FunctionNullHandling null_handling = FunctionNullHandling::DEFAULT_NULL_HANDLING,
133: 	                          bind_lambda_function_t bind_lambda = nullptr);
134: 
135: 	//! The main scalar function to execute
136: 	scalar_function_t function;
137: 	//! The bind function (if any)
138: 	bind_scalar_function_t bind;
139: 	//! Init thread local state for the function (if any)
140: 	init_local_state_t init_local_state;
141: 	//! The dependency function (if any)
142: 	dependency_function_t dependency;
143: 	//! The statistics propagation function (if any)
144: 	function_statistics_t statistics;
145: 	//! The lambda bind function (if any)
146: 	bind_lambda_function_t bind_lambda;
147: 	//! Function to bind the result function expression directly (if any)
148: 	function_bind_expression_t bind_expression;
149: 	//! Gets the modified databases (if any)
150: 	get_modified_databases_t get_modified_databases;
151: 
152: 	function_serialize_t serialize;
153: 	function_deserialize_t deserialize;
154: 	//! Additional function info, passed to the bind
155: 	shared_ptr<ScalarFunctionInfo> function_info;
156: 
157: 	DUCKDB_API bool operator==(const ScalarFunction &rhs) const;
158: 	DUCKDB_API bool operator!=(const ScalarFunction &rhs) const;
159: 
160: 	DUCKDB_API bool Equal(const ScalarFunction &rhs) const;
161: 
162: public:
163: 	DUCKDB_API static void NopFunction(DataChunk &input, ExpressionState &state, Vector &result);
164: 
165: 	template <class TA, class TR, class OP>
166: 	static void UnaryFunction(DataChunk &input, ExpressionState &state, Vector &result) {
167: 		D_ASSERT(input.ColumnCount() >= 1);
168: 		UnaryExecutor::Execute<TA, TR, OP>(input.data[0], result, input.size());
169: 	}
170: 
171: 	template <class TA, class TB, class TR, class OP>
172: 	static void BinaryFunction(DataChunk &input, ExpressionState &state, Vector &result) {
173: 		D_ASSERT(input.ColumnCount() == 2);
174: 		BinaryExecutor::ExecuteStandard<TA, TB, TR, OP>(input.data[0], input.data[1], result, input.size());
175: 	}
176: 
177: 	template <class TA, class TB, class TC, class TR, class OP>
178: 	static void TernaryFunction(DataChunk &input, ExpressionState &state, Vector &result) {
179: 		D_ASSERT(input.ColumnCount() == 3);
180: 		TernaryExecutor::ExecuteStandard<TA, TB, TC, TR, OP>(input.data[0], input.data[1], input.data[2], result,
181: 		                                                     input.size());
182: 	}
183: 
184: public:
185: 	template <class OP>
186: 	static scalar_function_t GetScalarUnaryFunction(const LogicalType &type) {
187: 		scalar_function_t function;
188: 		switch (type.id()) {
189: 		case LogicalTypeId::TINYINT:
190: 			function = &ScalarFunction::UnaryFunction<int8_t, int8_t, OP>;
191: 			break;
192: 		case LogicalTypeId::SMALLINT:
193: 			function = &ScalarFunction::UnaryFunction<int16_t, int16_t, OP>;
194: 			break;
195: 		case LogicalTypeId::INTEGER:
196: 			function = &ScalarFunction::UnaryFunction<int32_t, int32_t, OP>;
197: 			break;
198: 		case LogicalTypeId::BIGINT:
199: 			function = &ScalarFunction::UnaryFunction<int64_t, int64_t, OP>;
200: 			break;
201: 		case LogicalTypeId::UTINYINT:
202: 			function = &ScalarFunction::UnaryFunction<uint8_t, uint8_t, OP>;
203: 			break;
204: 		case LogicalTypeId::USMALLINT:
205: 			function = &ScalarFunction::UnaryFunction<uint16_t, uint16_t, OP>;
206: 			break;
207: 		case LogicalTypeId::UINTEGER:
208: 			function = &ScalarFunction::UnaryFunction<uint32_t, uint32_t, OP>;
209: 			break;
210: 		case LogicalTypeId::UBIGINT:
211: 			function = &ScalarFunction::UnaryFunction<uint64_t, uint64_t, OP>;
212: 			break;
213: 		case LogicalTypeId::HUGEINT:
214: 			function = &ScalarFunction::UnaryFunction<hugeint_t, hugeint_t, OP>;
215: 			break;
216: 		case LogicalTypeId::UHUGEINT:
217: 			function = &ScalarFunction::UnaryFunction<uhugeint_t, uhugeint_t, OP>;
218: 			break;
219: 		case LogicalTypeId::FLOAT:
220: 			function = &ScalarFunction::UnaryFunction<float, float, OP>;
221: 			break;
222: 		case LogicalTypeId::DOUBLE:
223: 			function = &ScalarFunction::UnaryFunction<double, double, OP>;
224: 			break;
225: 		default:
226: 			throw InternalException("Unimplemented type for GetScalarUnaryFunction");
227: 		}
228: 		return function;
229: 	}
230: 
231: 	template <class TR, class OP>
232: 	static scalar_function_t GetScalarUnaryFunctionFixedReturn(const LogicalType &type) {
233: 		scalar_function_t function;
234: 		switch (type.id()) {
235: 		case LogicalTypeId::TINYINT:
236: 			function = &ScalarFunction::UnaryFunction<int8_t, TR, OP>;
237: 			break;
238: 		case LogicalTypeId::SMALLINT:
239: 			function = &ScalarFunction::UnaryFunction<int16_t, TR, OP>;
240: 			break;
241: 		case LogicalTypeId::INTEGER:
242: 			function = &ScalarFunction::UnaryFunction<int32_t, TR, OP>;
243: 			break;
244: 		case LogicalTypeId::BIGINT:
245: 			function = &ScalarFunction::UnaryFunction<int64_t, TR, OP>;
246: 			break;
247: 		case LogicalTypeId::UTINYINT:
248: 			function = &ScalarFunction::UnaryFunction<uint8_t, TR, OP>;
249: 			break;
250: 		case LogicalTypeId::USMALLINT:
251: 			function = &ScalarFunction::UnaryFunction<uint16_t, TR, OP>;
252: 			break;
253: 		case LogicalTypeId::UINTEGER:
254: 			function = &ScalarFunction::UnaryFunction<uint32_t, TR, OP>;
255: 			break;
256: 		case LogicalTypeId::UBIGINT:
257: 			function = &ScalarFunction::UnaryFunction<uint64_t, TR, OP>;
258: 			break;
259: 		case LogicalTypeId::HUGEINT:
260: 			function = &ScalarFunction::UnaryFunction<hugeint_t, TR, OP>;
261: 			break;
262: 		case LogicalTypeId::UHUGEINT:
263: 			function = &ScalarFunction::UnaryFunction<uhugeint_t, TR, OP>;
264: 			break;
265: 		case LogicalTypeId::FLOAT:
266: 			function = &ScalarFunction::UnaryFunction<float, TR, OP>;
267: 			break;
268: 		case LogicalTypeId::DOUBLE:
269: 			function = &ScalarFunction::UnaryFunction<double, TR, OP>;
270: 			break;
271: 		default:
272: 			throw InternalException("Unimplemented type for GetScalarUnaryFunctionFixedReturn");
273: 		}
274: 		return function;
275: 	}
276: };
277: 
278: } // namespace duckdb
[end of src/include/duckdb/function/scalar_function.hpp]
[start of src/include/duckdb/planner/binder.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/planner/binder.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/case_insensitive_map.hpp"
12: #include "duckdb/common/enums/join_type.hpp"
13: #include "duckdb/common/enums/statement_type.hpp"
14: #include "duckdb/common/exception/binder_exception.hpp"
15: #include "duckdb/common/reference_map.hpp"
16: #include "duckdb/common/unordered_map.hpp"
17: #include "duckdb/parser/column_definition.hpp"
18: #include "duckdb/parser/query_node.hpp"
19: #include "duckdb/parser/result_modifier.hpp"
20: #include "duckdb/parser/tableref/delimgetref.hpp"
21: #include "duckdb/parser/tokens.hpp"
22: #include "duckdb/planner/bind_context.hpp"
23: #include "duckdb/planner/bound_statement.hpp"
24: #include "duckdb/planner/bound_tokens.hpp"
25: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
26: #include "duckdb/planner/joinside.hpp"
27: #include "duckdb/planner/bound_constraint.hpp"
28: #include "duckdb/planner/logical_operator.hpp"
29: #include "duckdb/planner/tableref/bound_delimgetref.hpp"
30: 
31: namespace duckdb {
32: class BoundResultModifier;
33: class BoundSelectNode;
34: class ClientContext;
35: class ExpressionBinder;
36: class LimitModifier;
37: class OrderBinder;
38: class TableCatalogEntry;
39: class ViewCatalogEntry;
40: class TableMacroCatalogEntry;
41: class UpdateSetInfo;
42: class LogicalProjection;
43: class LogicalVacuum;
44: 
45: class ColumnList;
46: class ExternalDependency;
47: class TableFunction;
48: class TableStorageInfo;
49: class BoundConstraint;
50: 
51: struct CreateInfo;
52: struct BoundCreateTableInfo;
53: struct CommonTableExpressionInfo;
54: struct BoundParameterMap;
55: struct BoundPragmaInfo;
56: struct BoundLimitNode;
57: struct PivotColumnEntry;
58: struct UnpivotEntry;
59: 
60: enum class BindingMode : uint8_t { STANDARD_BINDING, EXTRACT_NAMES, EXTRACT_REPLACEMENT_SCANS };
61: enum class BinderType : uint8_t { REGULAR_BINDER, VIEW_BINDER };
62: 
63: struct CorrelatedColumnInfo {
64: 	ColumnBinding binding;
65: 	LogicalType type;
66: 	string name;
67: 	idx_t depth;
68: 
69: 	// NOLINTNEXTLINE - work-around bug in clang-tidy
70: 	CorrelatedColumnInfo(ColumnBinding binding, LogicalType type_p, string name_p, idx_t depth)
71: 	    : binding(binding), type(std::move(type_p)), name(std::move(name_p)), depth(depth) {
72: 	}
73: 	explicit CorrelatedColumnInfo(BoundColumnRefExpression &expr)
74: 	    : CorrelatedColumnInfo(expr.binding, expr.return_type, expr.GetName(), expr.depth) {
75: 	}
76: 
77: 	bool operator==(const CorrelatedColumnInfo &rhs) const {
78: 		return binding == rhs.binding;
79: 	}
80: };
81: 
82: //! Bind the parsed query tree to the actual columns present in the catalog.
83: /*!
84:   The binder is responsible for binding tables and columns to actual physical
85:   tables and columns in the catalog. In the process, it also resolves types of
86:   all expressions.
87: */
88: class Binder : public enable_shared_from_this<Binder> {
89: 	friend class ExpressionBinder;
90: 	friend class RecursiveDependentJoinPlanner;
91: 
92: public:
93: 	DUCKDB_API static shared_ptr<Binder> CreateBinder(ClientContext &context, optional_ptr<Binder> parent = nullptr,
94: 	                                                  BinderType binder_type = BinderType::REGULAR_BINDER);
95: 
96: 	//! The client context
97: 	ClientContext &context;
98: 	//! A mapping of names to common table expressions
99: 	case_insensitive_map_t<reference<CommonTableExpressionInfo>> CTE_bindings; // NOLINT
100: 	//! The CTEs that have already been bound
101: 	reference_set_t<CommonTableExpressionInfo> bound_ctes;
102: 	//! The bind context
103: 	BindContext bind_context;
104: 	//! The set of correlated columns bound by this binder (FIXME: this should probably be an unordered_set and not a
105: 	//! vector)
106: 	vector<CorrelatedColumnInfo> correlated_columns;
107: 	//! The set of parameter expressions bound by this binder
108: 	optional_ptr<BoundParameterMap> parameters;
109: 	//! The alias for the currently processing subquery, if it exists
110: 	string alias;
111: 	//! Macro parameter bindings (if any)
112: 	optional_ptr<DummyBinding> macro_binding;
113: 	//! The intermediate lambda bindings to bind nested lambdas (if any)
114: 	optional_ptr<vector<DummyBinding>> lambda_bindings;
115: 
116: 	unordered_map<idx_t, LogicalOperator *> recursive_ctes;
117: 
118: public:
119: 	DUCKDB_API BoundStatement Bind(SQLStatement &statement);
120: 	DUCKDB_API BoundStatement Bind(QueryNode &node);
121: 
122: 	unique_ptr<BoundCreateTableInfo> BindCreateTableInfo(unique_ptr<CreateInfo> info);
123: 	unique_ptr<BoundCreateTableInfo> BindCreateTableInfo(unique_ptr<CreateInfo> info, SchemaCatalogEntry &schema);
124: 	unique_ptr<BoundCreateTableInfo> BindCreateTableInfo(unique_ptr<CreateInfo> info, SchemaCatalogEntry &schema,
125: 	                                                     vector<unique_ptr<Expression>> &bound_defaults);
126: 	static unique_ptr<BoundCreateTableInfo> BindCreateTableCheckpoint(unique_ptr<CreateInfo> info,
127: 	                                                                  SchemaCatalogEntry &schema);
128: 
129: 	static vector<unique_ptr<BoundConstraint>> BindConstraints(ClientContext &context,
130: 	                                                           const vector<unique_ptr<Constraint>> &constraints,
131: 	                                                           const string &table_name, const ColumnList &columns);
132: 	vector<unique_ptr<BoundConstraint>> BindConstraints(const vector<unique_ptr<Constraint>> &constraints,
133: 	                                                    const string &table_name, const ColumnList &columns);
134: 	vector<unique_ptr<BoundConstraint>> BindConstraints(const TableCatalogEntry &table);
135: 	vector<unique_ptr<BoundConstraint>> BindNewConstraints(vector<unique_ptr<Constraint>> &constraints,
136: 	                                                       const string &table_name, const ColumnList &columns);
137: 	unique_ptr<BoundConstraint> BindConstraint(Constraint &constraint, const string &table, const ColumnList &columns);
138: 	unique_ptr<BoundConstraint> BindUniqueConstraint(Constraint &constraint, const string &table,
139: 	                                                 const ColumnList &columns);
140: 
141: 	BoundStatement BindAlterAddIndex(BoundStatement &result, CatalogEntry &entry, unique_ptr<AlterInfo> alter_info);
142: 
143: 	void SetCatalogLookupCallback(catalog_entry_callback_t callback);
144: 	void BindCreateViewInfo(CreateViewInfo &base);
145: 	SchemaCatalogEntry &BindSchema(CreateInfo &info);
146: 	SchemaCatalogEntry &BindCreateFunctionInfo(CreateInfo &info);
147: 
148: 	//! Check usage, and cast named parameters to their types
149: 	static void BindNamedParameters(named_parameter_type_map_t &types, named_parameter_map_t &values,
150: 	                                QueryErrorContext &error_context, string &func_name);
151: 	unique_ptr<BoundPragmaInfo> BindPragma(PragmaInfo &info, QueryErrorContext error_context);
152: 
153: 	unique_ptr<BoundTableRef> Bind(TableRef &ref);
154: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableRef &ref);
155: 
156: 	//! Generates an unused index for a table
157: 	idx_t GenerateTableIndex();
158: 
159: 	optional_ptr<CatalogEntry> GetCatalogEntry(CatalogType type, const string &catalog, const string &schema,
160: 	                                           const string &name, OnEntryNotFound on_entry_not_found,
161: 	                                           QueryErrorContext &error_context);
162: 
163: 	//! Add a common table expression to the binder
164: 	void AddCTE(const string &name, CommonTableExpressionInfo &cte);
165: 	//! Find all candidate common table expression by name; returns empty vector if none exists
166: 	vector<reference<CommonTableExpressionInfo>> FindCTE(const string &name, bool skip = false);
167: 
168: 	bool CTEIsAlreadyBound(CommonTableExpressionInfo &cte);
169: 
170: 	//! Add the view to the set of currently bound views - used for detecting recursive view definitions
171: 	void AddBoundView(ViewCatalogEntry &view);
172: 
173: 	void PushExpressionBinder(ExpressionBinder &binder);
174: 	void PopExpressionBinder();
175: 	void SetActiveBinder(ExpressionBinder &binder);
176: 	ExpressionBinder &GetActiveBinder();
177: 	bool HasActiveBinder();
178: 
179: 	vector<reference<ExpressionBinder>> &GetActiveBinders();
180: 
181: 	void MergeCorrelatedColumns(vector<CorrelatedColumnInfo> &other);
182: 	//! Add a correlated column to this binder (if it does not exist)
183: 	void AddCorrelatedColumn(const CorrelatedColumnInfo &info);
184: 
185: 	unique_ptr<LogicalOperator> BindUpdateSet(LogicalOperator &op, unique_ptr<LogicalOperator> root,
186: 	                                          UpdateSetInfo &set_info, TableCatalogEntry &table,
187: 	                                          vector<PhysicalIndex> &columns);
188: 	void BindDoUpdateSetExpressions(const string &table_alias, LogicalInsert &insert, UpdateSetInfo &set_info,
189: 	                                TableCatalogEntry &table, TableStorageInfo &storage_info);
190: 	void BindOnConflictClause(LogicalInsert &insert, TableCatalogEntry &table, InsertStatement &stmt);
191: 
192: 	void BindVacuumTable(LogicalVacuum &vacuum, unique_ptr<LogicalOperator> &root);
193: 
194: 	static void BindSchemaOrCatalog(ClientContext &context, string &catalog, string &schema);
195: 	void BindLogicalType(LogicalType &type, optional_ptr<Catalog> catalog = nullptr,
196: 	                     const string &schema = INVALID_SCHEMA);
197: 
198: 	optional_ptr<Binding> GetMatchingBinding(const string &table_name, const string &column_name, ErrorData &error);
199: 	optional_ptr<Binding> GetMatchingBinding(const string &schema_name, const string &table_name,
200: 	                                         const string &column_name, ErrorData &error);
201: 	optional_ptr<Binding> GetMatchingBinding(const string &catalog_name, const string &schema_name,
202: 	                                         const string &table_name, const string &column_name, ErrorData &error);
203: 
204: 	void SetBindingMode(BindingMode mode);
205: 	BindingMode GetBindingMode();
206: 	void AddTableName(string table_name);
207: 	void AddReplacementScan(const string &table_name, unique_ptr<TableRef> replacement);
208: 	const unordered_set<string> &GetTableNames();
209: 	case_insensitive_map_t<unique_ptr<TableRef>> &GetReplacementScans();
210: 	optional_ptr<SQLStatement> GetRootStatement() {
211: 		return root_statement;
212: 	}
213: 
214: 	void SetCanContainNulls(bool can_contain_nulls);
215: 	void SetAlwaysRequireRebind();
216: 
217: 	StatementProperties &GetStatementProperties();
218: 
219: private:
220: 	//! The parent binder (if any)
221: 	shared_ptr<Binder> parent;
222: 	//! The vector of active binders
223: 	vector<reference<ExpressionBinder>> active_binders;
224: 	//! The count of bound_tables
225: 	idx_t bound_tables;
226: 	//! Whether or not the binder has any unplanned dependent joins that still need to be planned/flattened
227: 	bool has_unplanned_dependent_joins = false;
228: 	//! Whether or not outside dependent joins have been planned and flattened
229: 	bool is_outside_flattened = true;
230: 	//! What kind of node we are binding using this binder
231: 	BinderType binder_type = BinderType::REGULAR_BINDER;
232: 	//! Whether or not the binder can contain NULLs as the root of expressions
233: 	bool can_contain_nulls = false;
234: 	//! The root statement of the query that is currently being parsed
235: 	optional_ptr<SQLStatement> root_statement;
236: 	//! Binding mode
237: 	BindingMode mode = BindingMode::STANDARD_BINDING;
238: 	//! Table names extracted for BindingMode::EXTRACT_NAMES
239: 	unordered_set<string> table_names;
240: 	//! Replacement Scans extracted for BindingMode::EXTRACT_REPLACEMENT_SCANS
241: 	case_insensitive_map_t<unique_ptr<TableRef>> replacement_scans;
242: 	//! The set of bound views
243: 	reference_set_t<ViewCatalogEntry> bound_views;
244: 	//! Used to retrieve CatalogEntry's
245: 	CatalogEntryRetriever entry_retriever;
246: 	//! Unnamed subquery index
247: 	idx_t unnamed_subquery_index = 1;
248: 	//! Statement properties
249: 	StatementProperties prop;
250: 
251: private:
252: 	//! Get the root binder (binder with no parent)
253: 	Binder &GetRootBinder();
254: 	//! Determine the depth of the binder
255: 	idx_t GetBinderDepth() const;
256: 	//! Bind the expressions of generated columns to check for errors
257: 	void BindGeneratedColumns(BoundCreateTableInfo &info);
258: 	//! Bind the default values of the columns of a table
259: 	void BindDefaultValues(const ColumnList &columns, vector<unique_ptr<Expression>> &bound_defaults);
260: 	//! Bind a limit value (LIMIT or OFFSET)
261: 	BoundLimitNode BindLimitValue(OrderBinder &order_binder, unique_ptr<ParsedExpression> limit_val, bool is_percentage,
262: 	                              bool is_offset);
263: 
264: 	//! Move correlated expressions from the child binder to this binder
265: 	void MoveCorrelatedExpressions(Binder &other);
266: 
267: 	//! Tries to bind the table name with replacement scans
268: 	unique_ptr<BoundTableRef> BindWithReplacementScan(ClientContext &context, BaseTableRef &ref);
269: 
270: 	template <class T>
271: 	BoundStatement BindWithCTE(T &statement);
272: 	BoundStatement Bind(SelectStatement &stmt);
273: 	BoundStatement Bind(InsertStatement &stmt);
274: 	BoundStatement Bind(CopyStatement &stmt, CopyToType copy_to_type);
275: 	BoundStatement Bind(DeleteStatement &stmt);
276: 	BoundStatement Bind(UpdateStatement &stmt);
277: 	BoundStatement Bind(CreateStatement &stmt);
278: 	BoundStatement Bind(DropStatement &stmt);
279: 	BoundStatement Bind(AlterStatement &stmt);
280: 	BoundStatement Bind(PrepareStatement &stmt);
281: 	BoundStatement Bind(ExecuteStatement &stmt);
282: 	BoundStatement Bind(TransactionStatement &stmt);
283: 	BoundStatement Bind(PragmaStatement &stmt);
284: 	BoundStatement Bind(ExplainStatement &stmt);
285: 	BoundStatement Bind(VacuumStatement &stmt);
286: 	BoundStatement Bind(RelationStatement &stmt);
287: 	BoundStatement Bind(CallStatement &stmt);
288: 	BoundStatement Bind(ExportStatement &stmt);
289: 	BoundStatement Bind(ExtensionStatement &stmt);
290: 	BoundStatement Bind(SetStatement &stmt);
291: 	BoundStatement Bind(SetVariableStatement &stmt);
292: 	BoundStatement Bind(ResetVariableStatement &stmt);
293: 	BoundStatement Bind(LoadStatement &stmt);
294: 	BoundStatement Bind(LogicalPlanStatement &stmt);
295: 	BoundStatement Bind(AttachStatement &stmt);
296: 	BoundStatement Bind(DetachStatement &stmt);
297: 	BoundStatement Bind(CopyDatabaseStatement &stmt);
298: 	BoundStatement Bind(UpdateExtensionsStatement &stmt);
299: 
300: 	BoundStatement BindReturning(vector<unique_ptr<ParsedExpression>> returning_list, TableCatalogEntry &table,
301: 	                             const string &alias, idx_t update_table_index,
302: 	                             unique_ptr<LogicalOperator> child_operator, BoundStatement result);
303: 
304: 	unique_ptr<QueryNode> BindTableMacro(FunctionExpression &function, TableMacroCatalogEntry &macro_func, idx_t depth);
305: 
306: 	unique_ptr<BoundCTENode> BindMaterializedCTE(CommonTableExpressionMap &cte_map);
307: 	unique_ptr<BoundCTENode> BindCTE(CTENode &statement);
308: 	//! Materializes CTEs if this is expected to improve performance
309: 	bool OptimizeCTEs(QueryNode &node);
310: 
311: 	unique_ptr<BoundQueryNode> BindNode(SelectNode &node);
312: 	unique_ptr<BoundQueryNode> BindNode(SetOperationNode &node);
313: 	unique_ptr<BoundQueryNode> BindNode(RecursiveCTENode &node);
314: 	unique_ptr<BoundQueryNode> BindNode(CTENode &node);
315: 	unique_ptr<BoundQueryNode> BindNode(QueryNode &node);
316: 
317: 	unique_ptr<LogicalOperator> VisitQueryNode(BoundQueryNode &node, unique_ptr<LogicalOperator> root);
318: 	unique_ptr<LogicalOperator> CreatePlan(BoundRecursiveCTENode &node);
319: 	unique_ptr<LogicalOperator> CreatePlan(BoundCTENode &node);
320: 	unique_ptr<LogicalOperator> CreatePlan(BoundCTENode &node, unique_ptr<LogicalOperator> base);
321: 	unique_ptr<LogicalOperator> CreatePlan(BoundSelectNode &statement);
322: 	unique_ptr<LogicalOperator> CreatePlan(BoundSetOperationNode &node);
323: 	unique_ptr<LogicalOperator> CreatePlan(BoundQueryNode &node);
324: 
325: 	unique_ptr<BoundTableRef> BindJoin(Binder &parent, TableRef &ref);
326: 	unique_ptr<BoundTableRef> Bind(BaseTableRef &ref);
327: 	unique_ptr<BoundTableRef> Bind(JoinRef &ref);
328: 	unique_ptr<BoundTableRef> Bind(SubqueryRef &ref, optional_ptr<CommonTableExpressionInfo> cte = nullptr);
329: 	unique_ptr<BoundTableRef> Bind(TableFunctionRef &ref);
330: 	unique_ptr<BoundTableRef> Bind(EmptyTableRef &ref);
331: 	unique_ptr<BoundTableRef> Bind(DelimGetRef &ref);
332: 	unique_ptr<BoundTableRef> Bind(ExpressionListRef &ref);
333: 	unique_ptr<BoundTableRef> Bind(ColumnDataRef &ref);
334: 	unique_ptr<BoundTableRef> Bind(PivotRef &expr);
335: 	unique_ptr<BoundTableRef> Bind(ShowRef &ref);
336: 
337: 	unique_ptr<SelectNode> BindPivot(PivotRef &expr, vector<unique_ptr<ParsedExpression>> all_columns);
338: 	unique_ptr<SelectNode> BindUnpivot(Binder &child_binder, PivotRef &expr,
339: 	                                   vector<unique_ptr<ParsedExpression>> all_columns,
340: 	                                   unique_ptr<ParsedExpression> &where_clause);
341: 	unique_ptr<BoundTableRef> BindBoundPivot(PivotRef &expr);
342: 	void ExtractUnpivotEntries(Binder &child_binder, PivotColumnEntry &entry, vector<UnpivotEntry> &unpivot_entries);
343: 	void ExtractUnpivotColumnName(ParsedExpression &expr, vector<string> &result);
344: 
345: 	bool BindTableFunctionParameters(TableFunctionCatalogEntry &table_function,
346: 	                                 vector<unique_ptr<ParsedExpression>> &expressions, vector<LogicalType> &arguments,
347: 	                                 vector<Value> &parameters, named_parameter_map_t &named_parameters,
348: 	                                 unique_ptr<BoundSubqueryRef> &subquery, ErrorData &error);
349: 	void BindTableInTableOutFunction(vector<unique_ptr<ParsedExpression>> &expressions,
350: 	                                 unique_ptr<BoundSubqueryRef> &subquery);
351: 	unique_ptr<LogicalOperator> BindTableFunction(TableFunction &function, vector<Value> parameters);
352: 	unique_ptr<LogicalOperator> BindTableFunctionInternal(TableFunction &table_function, const TableFunctionRef &ref,
353: 	                                                      vector<Value> parameters,
354: 	                                                      named_parameter_map_t named_parameters,
355: 	                                                      vector<LogicalType> input_table_types,
356: 	                                                      vector<string> input_table_names);
357: 
358: 	unique_ptr<LogicalOperator> CreatePlan(BoundBaseTableRef &ref);
359: 	unique_ptr<LogicalOperator> CreatePlan(BoundJoinRef &ref);
360: 	unique_ptr<LogicalOperator> CreatePlan(BoundSubqueryRef &ref);
361: 	unique_ptr<LogicalOperator> CreatePlan(BoundTableFunction &ref);
362: 	unique_ptr<LogicalOperator> CreatePlan(BoundEmptyTableRef &ref);
363: 	unique_ptr<LogicalOperator> CreatePlan(BoundExpressionListRef &ref);
364: 	unique_ptr<LogicalOperator> CreatePlan(BoundColumnDataRef &ref);
365: 	unique_ptr<LogicalOperator> CreatePlan(BoundCTERef &ref);
366: 	unique_ptr<LogicalOperator> CreatePlan(BoundPivotRef &ref);
367: 	unique_ptr<LogicalOperator> CreatePlan(BoundDelimGetRef &ref);
368: 
369: 	BoundStatement BindCopyTo(CopyStatement &stmt, CopyToType copy_to_type);
370: 	BoundStatement BindCopyFrom(CopyStatement &stmt);
371: 
372: 	void PrepareModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result);
373: 	void BindModifiers(BoundQueryNode &result, idx_t table_index, const vector<string> &names,
374: 	                   const vector<LogicalType> &sql_types, const SelectBindState &bind_state);
375: 
376: 	unique_ptr<BoundResultModifier> BindLimit(OrderBinder &order_binder, LimitModifier &limit_mod);
377: 	unique_ptr<BoundResultModifier> BindLimitPercent(OrderBinder &order_binder, LimitPercentModifier &limit_mod);
378: 	unique_ptr<Expression> BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr);
379: 
380: 	unique_ptr<LogicalOperator> PlanFilter(unique_ptr<Expression> condition, unique_ptr<LogicalOperator> root);
381: 
382: 	void PlanSubqueries(unique_ptr<Expression> &expr, unique_ptr<LogicalOperator> &root);
383: 	unique_ptr<Expression> PlanSubquery(BoundSubqueryExpression &expr, unique_ptr<LogicalOperator> &root);
384: 	unique_ptr<LogicalOperator> PlanLateralJoin(unique_ptr<LogicalOperator> left, unique_ptr<LogicalOperator> right,
385: 	                                            vector<CorrelatedColumnInfo> &correlated_columns,
386: 	                                            JoinType join_type = JoinType::INNER,
387: 	                                            unique_ptr<Expression> condition = nullptr);
388: 
389: 	unique_ptr<LogicalOperator> CastLogicalOperatorToTypes(vector<LogicalType> &source_types,
390: 	                                                       vector<LogicalType> &target_types,
391: 	                                                       unique_ptr<LogicalOperator> op);
392: 
393: 	BindingAlias FindBinding(const string &using_column, const string &join_side);
394: 	bool TryFindBinding(const string &using_column, const string &join_side, BindingAlias &result);
395: 
396: 	void AddUsingBindingSet(unique_ptr<UsingColumnSet> set);
397: 	BindingAlias RetrieveUsingBinding(Binder &current_binder, optional_ptr<UsingColumnSet> current_set,
398: 	                                  const string &column_name, const string &join_side);
399: 
400: 	void AddCTEMap(CommonTableExpressionMap &cte_map);
401: 
402: 	void ExpandStarExpressions(vector<unique_ptr<ParsedExpression>> &select_list,
403: 	                           vector<unique_ptr<ParsedExpression>> &new_select_list);
404: 	void ExpandStarExpression(unique_ptr<ParsedExpression> expr, vector<unique_ptr<ParsedExpression>> &new_select_list);
405: 	bool FindStarExpression(unique_ptr<ParsedExpression> &expr, StarExpression **star, bool is_root, bool in_columns);
406: 	void ReplaceUnpackedStarExpression(unique_ptr<ParsedExpression> &expr,
407: 	                                   vector<unique_ptr<ParsedExpression>> &replacements);
408: 	void ReplaceStarExpression(unique_ptr<ParsedExpression> &expr, unique_ptr<ParsedExpression> &replacement);
409: 	void BindWhereStarExpression(unique_ptr<ParsedExpression> &expr);
410: 
411: 	//! If only a schema name is provided (e.g. "a.b") then figure out if "a" is a schema or a catalog name
412: 	void BindSchemaOrCatalog(string &catalog_name, string &schema_name);
413: 	const string BindCatalog(string &catalog_name);
414: 	SchemaCatalogEntry &BindCreateSchema(CreateInfo &info);
415: 
416: 	unique_ptr<BoundQueryNode> BindSelectNode(SelectNode &statement, unique_ptr<BoundTableRef> from_table);
417: 
418: 	unique_ptr<LogicalOperator> BindCopyDatabaseSchema(Catalog &source_catalog, const string &target_database_name);
419: 	unique_ptr<LogicalOperator> BindCopyDatabaseData(Catalog &source_catalog, const string &target_database_name);
420: 
421: 	unique_ptr<BoundTableRef> BindShowQuery(ShowRef &ref);
422: 	unique_ptr<BoundTableRef> BindShowTable(ShowRef &ref);
423: 	unique_ptr<BoundTableRef> BindSummarize(ShowRef &ref);
424: 
425: 	unique_ptr<LogicalOperator> UnionOperators(vector<unique_ptr<LogicalOperator>> nodes);
426: 
427: private:
428: 	Binder(ClientContext &context, shared_ptr<Binder> parent, BinderType binder_type);
429: };
430: 
431: } // namespace duckdb
[end of src/include/duckdb/planner/binder.hpp]
[start of src/planner/binder/expression/bind_aggregate_expression.cpp]
1: #include "duckdb/catalog/catalog_entry/aggregate_function_catalog_entry.hpp"
2: #include "duckdb/common/operator/cast_operators.hpp"
3: #include "duckdb/common/pair.hpp"
4: #include "duckdb/execution/expression_executor.hpp"
5: #include "duckdb/function/function_binder.hpp"
6: #include "duckdb/function/scalar/generic_functions.hpp"
7: #include "duckdb/function/scalar/generic_common.hpp"
8: #include "duckdb/main/config.hpp"
9: #include "duckdb/parser/expression/constant_expression.hpp"
10: #include "duckdb/parser/expression/function_expression.hpp"
11: #include "duckdb/planner/binder.hpp"
12: #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
13: #include "duckdb/planner/expression/bound_cast_expression.hpp"
14: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
15: #include "duckdb/planner/expression/bound_constant_expression.hpp"
16: #include "duckdb/planner/expression/bound_function_expression.hpp"
17: #include "duckdb/planner/expression_binder/aggregate_binder.hpp"
18: #include "duckdb/planner/expression_binder/base_select_binder.hpp"
19: #include "duckdb/planner/expression_iterator.hpp"
20: #include "duckdb/planner/query_node/bound_select_node.hpp"
21: 
22: namespace duckdb {
23: 
24: static bool ExtractFunctionalDependencies(column_binding_set_t &deps, const unique_ptr<Expression> &expr) {
25: 	if (expr->type == ExpressionType::BOUND_COLUMN_REF) {
26: 		auto &colref = expr->Cast<BoundColumnRefExpression>();
27: 		deps.insert(colref.binding);
28: 	}
29: 
30: 	bool is_volatile = expr->IsVolatile();
31: 	ExpressionIterator::EnumerateChildren(
32: 	    *expr, [&](unique_ptr<Expression> &child) { is_volatile |= ExtractFunctionalDependencies(deps, child); });
33: 	return is_volatile;
34: }
35: 
36: static Value NegatePercentileValue(const Value &v, const bool desc) {
37: 	if (v.IsNull()) {
38: 		return v;
39: 	}
40: 
41: 	const auto frac = v.GetValue<double>();
42: 	if (frac < 0 || frac > 1) {
43: 		throw BinderException("PERCENTILEs can only take parameters in the range [0, 1]");
44: 	}
45: 
46: 	if (!desc) {
47: 		return v;
48: 	}
49: 
50: 	const auto &type = v.type();
51: 	switch (type.id()) {
52: 	case LogicalTypeId::DECIMAL: {
53: 		// Negate DECIMALs as DECIMAL.
54: 		const auto integral = IntegralValue::Get(v);
55: 		const auto width = DecimalType::GetWidth(type);
56: 		const auto scale = DecimalType::GetScale(type);
57: 		switch (type.InternalType()) {
58: 		case PhysicalType::INT16:
59: 			return Value::DECIMAL(Cast::Operation<hugeint_t, int16_t>(-integral), width, scale);
60: 		case PhysicalType::INT32:
61: 			return Value::DECIMAL(Cast::Operation<hugeint_t, int32_t>(-integral), width, scale);
62: 		case PhysicalType::INT64:
63: 			return Value::DECIMAL(Cast::Operation<hugeint_t, int64_t>(-integral), width, scale);
64: 		case PhysicalType::INT128:
65: 			return Value::DECIMAL(-integral, width, scale);
66: 		default:
67: 			throw InternalException("Unknown DECIMAL type");
68: 		}
69: 	}
70: 	default:
71: 		// Everything else can just be a DOUBLE
72: 		return Value::DOUBLE(-v.GetValue<double>());
73: 	}
74: }
75: 
76: static void NegatePercentileFractions(ClientContext &context, unique_ptr<ParsedExpression> &fractions, bool desc) {
77: 	D_ASSERT(fractions.get());
78: 	D_ASSERT(fractions->expression_class == ExpressionClass::BOUND_EXPRESSION);
79: 	auto &bound = BoundExpression::GetExpression(*fractions);
80: 
81: 	if (!bound->IsFoldable()) {
82: 		return;
83: 	}
84: 
85: 	Value value = ExpressionExecutor::EvaluateScalar(context, *bound);
86: 	if (value.type().id() == LogicalTypeId::LIST) {
87: 		vector<Value> values;
88: 		for (const auto &element_val : ListValue::GetChildren(value)) {
89: 			values.push_back(NegatePercentileValue(element_val, desc));
90: 		}
91: 		if (values.empty()) {
92: 			throw BinderException("Empty list in percentile not allowed");
93: 		}
94: 		bound = make_uniq<BoundConstantExpression>(Value::LIST(values));
95: 	} else {
96: 		bound = make_uniq<BoundConstantExpression>(NegatePercentileValue(value, desc));
97: 	}
98: }
99: 
100: BindResult BaseSelectBinder::BindAggregate(FunctionExpression &aggr, AggregateFunctionCatalogEntry &func, idx_t depth) {
101: 	// first bind the child of the aggregate expression (if any)
102: 	this->bound_aggregate = true;
103: 	unique_ptr<Expression> bound_filter;
104: 	AggregateBinder aggregate_binder(binder, context);
105: 	ErrorData error;
106: 
107: 	// Now we bind the filter (if any)
108: 	if (aggr.filter) {
109: 		aggregate_binder.BindChild(aggr.filter, 0, error);
110: 	}
111: 
112: 	// Handle ordered-set aggregates by moving the single ORDER BY expression to the front of the children.
113: 	//	https://www.postgresql.org/docs/current/functions-aggregate.html#FUNCTIONS-ORDEREDSET-TABLE
114: 	// We also have to handle ORDER BY in the argument list, so note how many arguments we should have
115: 	// and only inject the ordering expression if there are too few.
116: 	idx_t ordered_set_agg = 0;
117: 	bool negate_fractions = false;
118: 	if (aggr.order_bys && aggr.order_bys->orders.size() == 1) {
119: 		const auto &func_name = aggr.function_name;
120: 		if (func_name == "mode") {
121: 			ordered_set_agg = 1;
122: 		} else if (func_name == "quantile_cont" || func_name == "quantile_disc") {
123: 			ordered_set_agg = 2;
124: 
125: 			auto &config = DBConfig::GetConfig(context);
126: 			const auto &order = aggr.order_bys->orders[0];
127: 			const auto sense =
128: 			    (order.type == OrderType::ORDER_DEFAULT) ? config.options.default_order_type : order.type;
129: 			negate_fractions = (sense == OrderType::DESCENDING);
130: 		}
131: 	}
132: 
133: 	for (idx_t i = 0; i < aggr.children.size(); ++i) {
134: 		auto &child = aggr.children[i];
135: 		aggregate_binder.BindChild(child, 0, error);
136: 		// We have to negate the fractions for PERCENTILE_XXXX DESC
137: 		if (!error.HasError() && ordered_set_agg && i == aggr.children.size() - 1) {
138: 			NegatePercentileFractions(context, child, negate_fractions);
139: 		}
140: 	}
141: 
142: 	// Bind the ORDER BYs, if any
143: 	if (aggr.order_bys && !aggr.order_bys->orders.empty()) {
144: 		for (auto &order : aggr.order_bys->orders) {
145: 			if (order.expression->type == ExpressionType::VALUE_CONSTANT) {
146: 				auto &const_expr = order.expression->Cast<ConstantExpression>();
147: 				if (!const_expr.value.type().IsIntegral()) {
148: 					auto &config = ClientConfig::GetConfig(context);
149: 					if (!config.order_by_non_integer_literal) {
150: 						throw BinderException(
151: 						    *order.expression,
152: 						    "ORDER BY non-integer literal has no effect.\n* SET order_by_non_integer_literal=true to "
153: 						    "allow this behavior.\n\nPerhaps you misplaced ORDER BY; ORDER BY must appear "
154: 						    "after all regular arguments of the aggregate.");
155: 					}
156: 				}
157: 			}
158: 			aggregate_binder.BindChild(order.expression, 0, error);
159: 		}
160: 	}
161: 
162: 	if (error.HasError()) {
163: 		// failed to bind child
164: 		if (aggregate_binder.HasBoundColumns()) {
165: 			for (idx_t i = 0; i < aggr.children.size(); i++) {
166: 				// however, we bound columns!
167: 				// that means this aggregation belongs to this node
168: 				// check if we have to resolve any errors by binding with parent binders
169: 				auto result = aggregate_binder.BindCorrelatedColumns(aggr.children[i], error);
170: 				// if there is still an error after this, we could not successfully bind the aggregate
171: 				if (result.HasError()) {
172: 					result.error.Throw();
173: 				}
174: 				auto &bound_expr = BoundExpression::GetExpression(*aggr.children[i]);
175: 				ExtractCorrelatedExpressions(binder, *bound_expr);
176: 			}
177: 			if (aggr.filter) {
178: 				auto result = aggregate_binder.BindCorrelatedColumns(aggr.filter, error);
179: 				// if there is still an error after this, we could not successfully bind the aggregate
180: 				if (result.HasError()) {
181: 					result.error.Throw();
182: 				}
183: 				auto &bound_expr = BoundExpression::GetExpression(*aggr.filter);
184: 				ExtractCorrelatedExpressions(binder, *bound_expr);
185: 			}
186: 			if (aggr.order_bys && !aggr.order_bys->orders.empty()) {
187: 				for (auto &order : aggr.order_bys->orders) {
188: 					auto result = aggregate_binder.BindCorrelatedColumns(order.expression, error);
189: 					if (result.HasError()) {
190: 						result.error.Throw();
191: 					}
192: 					auto &bound_expr = BoundExpression::GetExpression(*order.expression);
193: 					ExtractCorrelatedExpressions(binder, *bound_expr);
194: 				}
195: 			}
196: 		} else {
197: 			// we didn't bind columns, try again in children
198: 			return BindResult(std::move(error));
199: 		}
200: 	} else if (depth > 0 && !aggregate_binder.HasBoundColumns()) {
201: 		return BindResult("Aggregate with only constant parameters has to be bound in the root subquery");
202: 	}
203: 
204: 	if (aggr.filter) {
205: 		auto &child = BoundExpression::GetExpression(*aggr.filter);
206: 		bound_filter = BoundCastExpression::AddCastToType(context, std::move(child), LogicalType::BOOLEAN);
207: 	}
208: 
209: 	// all children bound successfully
210: 	// extract the children and types
211: 	vector<LogicalType> types;
212: 	vector<LogicalType> arguments;
213: 	vector<unique_ptr<Expression>> children;
214: 
215: 	if (ordered_set_agg) {
216: 		const bool order_sensitive = (aggr.function_name == "mode");
217: 		// Inject missing ordering arguments
218: 		if (aggr.children.size() < ordered_set_agg) {
219: 			for (auto &order : aggr.order_bys->orders) {
220: 				auto &child = BoundExpression::GetExpression(*order.expression);
221: 				types.push_back(child->return_type);
222: 				arguments.push_back(child->return_type);
223: 				if (order_sensitive) {
224: 					children.push_back(child->Copy());
225: 				} else {
226: 					children.push_back(std::move(child));
227: 				}
228: 			}
229: 		}
230: 		if (!order_sensitive) {
231: 			aggr.order_bys->orders.clear();
232: 		}
233: 	}
234: 
235: 	for (idx_t i = 0; i < aggr.children.size(); i++) {
236: 		auto &child = BoundExpression::GetExpression(*aggr.children[i]);
237: 		types.push_back(child->return_type);
238: 		arguments.push_back(child->return_type);
239: 		children.push_back(std::move(child));
240: 	}
241: 
242: 	// bind the aggregate
243: 	FunctionBinder function_binder(context);
244: 	auto best_function = function_binder.BindFunction(func.name, func.functions, types, error);
245: 	if (!best_function.IsValid()) {
246: 		error.AddQueryLocation(aggr);
247: 		error.Throw();
248: 	}
249: 	// found a matching function!
250: 	auto bound_function = func.functions.GetFunctionByOffset(best_function.GetIndex());
251: 
252: 	// Bind any sort columns, unless the aggregate is order-insensitive
253: 	unique_ptr<BoundOrderModifier> order_bys;
254: 	if (!aggr.order_bys->orders.empty()) {
255: 		order_bys = make_uniq<BoundOrderModifier>();
256: 		auto &config = DBConfig::GetConfig(context);
257: 		for (auto &order : aggr.order_bys->orders) {
258: 			auto &order_expr = BoundExpression::GetExpression(*order.expression);
259: 			PushCollation(context, order_expr, order_expr->return_type);
260: 			const auto sense = config.ResolveOrder(order.type);
261: 			const auto null_order = config.ResolveNullOrder(sense, order.null_order);
262: 			order_bys->orders.emplace_back(sense, null_order, std::move(order_expr));
263: 		}
264: 	}
265: 
266: 	// If the aggregate is DISTINCT then the ORDER BYs need to be functional dependencies of the arguments.
267: 	if (aggr.distinct && order_bys) {
268: 		column_binding_set_t child_dependencies;
269: 		bool children_volatile = false;
270: 		for (const auto &child : children) {
271: 			children_volatile |= ExtractFunctionalDependencies(child_dependencies, child);
272: 		}
273: 
274: 		column_binding_set_t order_dependencies;
275: 		bool order_volatile = false;
276: 		for (const auto &order_by : order_bys->orders) {
277: 			order_volatile |= ExtractFunctionalDependencies(order_dependencies, order_by.expression);
278: 		}
279: 
280: 		bool in_args = !children_volatile && !order_volatile;
281: 		if (in_args) {
282: 			for (const auto &binding : order_dependencies) {
283: 				if (!child_dependencies.count(binding)) {
284: 					in_args = false;
285: 					break;
286: 				}
287: 			}
288: 		}
289: 
290: 		if (!in_args) {
291: 			throw BinderException("In a DISTINCT aggregate, ORDER BY expressions must appear in the argument list");
292: 		}
293: 	}
294: 
295: 	auto aggregate =
296: 	    function_binder.BindAggregateFunction(bound_function, std::move(children), std::move(bound_filter),
297: 	                                          aggr.distinct ? AggregateType::DISTINCT : AggregateType::NON_DISTINCT);
298: 	if (aggr.export_state) {
299: 		aggregate = ExportAggregateFunction::Bind(std::move(aggregate));
300: 	}
301: 	aggregate->order_bys = std::move(order_bys);
302: 
303: 	// check for all the aggregates if this aggregate already exists
304: 	idx_t aggr_index;
305: 	auto entry = node.aggregate_map.find(*aggregate);
306: 	if (entry == node.aggregate_map.end()) {
307: 		// new aggregate: insert into aggregate list
308: 		aggr_index = node.aggregates.size();
309: 		node.aggregate_map[*aggregate] = aggr_index;
310: 		node.aggregates.push_back(std::move(aggregate));
311: 	} else {
312: 		// duplicate aggregate: simplify refer to this aggregate
313: 		aggr_index = entry->second;
314: 	}
315: 
316: 	// now create a column reference referring to the aggregate
317: 	auto colref = make_uniq<BoundColumnRefExpression>(
318: 	    aggr.alias.empty() ? node.aggregates[aggr_index]->ToString() : aggr.alias,
319: 	    node.aggregates[aggr_index]->return_type, ColumnBinding(node.aggregate_index, aggr_index), depth);
320: 	// move the aggregate expression into the set of bound aggregates
321: 	return BindResult(std::move(colref));
322: }
323: } // namespace duckdb
[end of src/planner/binder/expression/bind_aggregate_expression.cpp]
[start of src/planner/binder/expression/bind_function_expression.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: #include "duckdb/catalog/catalog_entry/aggregate_function_catalog_entry.hpp"
3: #include "duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp"
4: #include "duckdb/catalog/catalog_entry/scalar_macro_catalog_entry.hpp"
5: #include "duckdb/execution/expression_executor.hpp"
6: #include "duckdb/function/function_binder.hpp"
7: #include "duckdb/parser/expression/function_expression.hpp"
8: #include "duckdb/parser/expression/lambda_expression.hpp"
9: #include "duckdb/planner/binder.hpp"
10: #include "duckdb/planner/expression/bound_cast_expression.hpp"
11: #include "duckdb/planner/expression/bound_constant_expression.hpp"
12: #include "duckdb/planner/expression/bound_function_expression.hpp"
13: #include "duckdb/planner/expression/bound_lambda_expression.hpp"
14: #include "duckdb/planner/expression/bound_reference_expression.hpp"
15: #include "duckdb/planner/expression_binder.hpp"
16: 
17: namespace duckdb {
18: 
19: BindResult ExpressionBinder::TryBindLambdaOrJson(FunctionExpression &function, idx_t depth, CatalogEntry &func) {
20: 
21: 	auto lambda_bind_result = BindLambdaFunction(function, func.Cast<ScalarFunctionCatalogEntry>(), depth);
22: 	if (!lambda_bind_result.HasError()) {
23: 		return lambda_bind_result;
24: 	}
25: 
26: 	auto json_bind_result = BindFunction(function, func.Cast<ScalarFunctionCatalogEntry>(), depth);
27: 	if (!json_bind_result.HasError()) {
28: 		return json_bind_result;
29: 	}
30: 
31: 	return BindResult("failed to bind function, either: " + lambda_bind_result.error.RawMessage() +
32: 	                  "\n"
33: 	                  " or: " +
34: 	                  json_bind_result.error.RawMessage());
35: }
36: 
37: BindResult ExpressionBinder::BindExpression(FunctionExpression &function, idx_t depth,
38:                                             unique_ptr<ParsedExpression> &expr_ptr) {
39: 	// lookup the function in the catalog
40: 	QueryErrorContext error_context(function.query_location);
41: 	binder.BindSchemaOrCatalog(function.catalog, function.schema);
42: 	auto func = GetCatalogEntry(CatalogType::SCALAR_FUNCTION_ENTRY, function.catalog, function.schema,
43: 	                            function.function_name, OnEntryNotFound::RETURN_NULL, error_context);
44: 	if (!func) {
45: 		// function was not found - check if we this is a table function
46: 		auto table_func = GetCatalogEntry(CatalogType::TABLE_FUNCTION_ENTRY, function.catalog, function.schema,
47: 		                                  function.function_name, OnEntryNotFound::RETURN_NULL, error_context);
48: 		if (table_func) {
49: 			throw BinderException(function,
50: 			                      "Function \"%s\" is a table function but it was used as a scalar function. This "
51: 			                      "function has to be called in a FROM clause (similar to a table).",
52: 			                      function.function_name);
53: 		}
54: 		// not a table function - check if the schema is set
55: 		if (!function.schema.empty()) {
56: 			// the schema is set - check if we can turn this the schema into a column ref
57: 			ErrorData error;
58: 			unique_ptr<ColumnRefExpression> colref;
59: 			if (function.catalog.empty()) {
60: 				colref = make_uniq<ColumnRefExpression>(function.schema);
61: 			} else {
62: 				colref = make_uniq<ColumnRefExpression>(function.schema, function.catalog);
63: 			}
64: 			auto new_colref = QualifyColumnName(*colref, error);
65: 			bool is_col = !error.HasError();
66: 			bool is_col_alias = QualifyColumnAlias(*colref);
67: 
68: 			if (is_col || is_col_alias) {
69: 				// we can! transform this into a function call on the column
70: 				// i.e. "x.lower()" becomes "lower(x)"
71: 				function.children.insert(function.children.begin(), std::move(colref));
72: 				function.catalog = INVALID_CATALOG;
73: 				function.schema = INVALID_SCHEMA;
74: 			}
75: 		}
76: 		// rebind the function
77: 		func = GetCatalogEntry(CatalogType::SCALAR_FUNCTION_ENTRY, function.catalog, function.schema,
78: 		                       function.function_name, OnEntryNotFound::THROW_EXCEPTION, error_context);
79: 	}
80: 
81: 	if (func->type != CatalogType::AGGREGATE_FUNCTION_ENTRY &&
82: 	    (function.distinct || function.filter || !function.order_bys->orders.empty())) {
83: 		throw InvalidInputException("Function \"%s\" is a %s. \"DISTINCT\", \"FILTER\", and \"ORDER BY\" are only "
84: 		                            "applicable to aggregate functions.",
85: 		                            function.function_name, CatalogTypeToString(func->type));
86: 	}
87: 
88: 	switch (func->type) {
89: 	case CatalogType::SCALAR_FUNCTION_ENTRY: {
90: 		if (function.IsLambdaFunction()) {
91: 			return TryBindLambdaOrJson(function, depth, *func);
92: 		}
93: 		return BindFunction(function, func->Cast<ScalarFunctionCatalogEntry>(), depth);
94: 	}
95: 	case CatalogType::MACRO_ENTRY:
96: 		// macro function
97: 		return BindMacro(function, func->Cast<ScalarMacroCatalogEntry>(), depth, expr_ptr);
98: 	default:
99: 		// aggregate function
100: 		return BindAggregate(function, func->Cast<AggregateFunctionCatalogEntry>(), depth);
101: 	}
102: }
103: 
104: BindResult ExpressionBinder::BindFunction(FunctionExpression &function, ScalarFunctionCatalogEntry &func, idx_t depth) {
105: 	// bind the children of the function expression
106: 	ErrorData error;
107: 
108: 	// bind of each child
109: 	for (idx_t i = 0; i < function.children.size(); i++) {
110: 		BindChild(function.children[i], depth, error);
111: 	}
112: 
113: 	if (error.HasError()) {
114: 		return BindResult(std::move(error));
115: 	}
116: 	if (binder.GetBindingMode() == BindingMode::EXTRACT_NAMES) {
117: 		return BindResult(make_uniq<BoundConstantExpression>(Value(LogicalType::SQLNULL)));
118: 	}
119: 
120: 	// all children bound successfully
121: 	// extract the children and types
122: 	vector<unique_ptr<Expression>> children;
123: 	for (idx_t i = 0; i < function.children.size(); i++) {
124: 		auto &child = BoundExpression::GetExpression(*function.children[i]);
125: 		children.push_back(std::move(child));
126: 	}
127: 
128: 	FunctionBinder function_binder(context);
129: 	auto result = function_binder.BindScalarFunction(func, std::move(children), error, function.is_operator, &binder);
130: 	if (!result) {
131: 		error.AddQueryLocation(function);
132: 		error.Throw();
133: 	}
134: 	if (result->type == ExpressionType::BOUND_FUNCTION) {
135: 		auto &bound_function = result->Cast<BoundFunctionExpression>();
136: 		if (bound_function.function.stability == FunctionStability::CONSISTENT_WITHIN_QUERY) {
137: 			binder.SetAlwaysRequireRebind();
138: 		}
139: 	}
140: 	return BindResult(std::move(result));
141: }
142: 
143: BindResult ExpressionBinder::BindLambdaFunction(FunctionExpression &function, ScalarFunctionCatalogEntry &func,
144:                                                 idx_t depth) {
145: 
146: 	// scalar functions with lambdas can never be overloaded
147: 	if (func.functions.functions.size() != 1) {
148: 		return BindResult("This scalar function does not support lambdas!");
149: 	}
150: 
151: 	// get the callback function for the lambda parameter types
152: 	auto &scalar_function = func.functions.functions.front();
153: 	auto &bind_lambda_function = scalar_function.bind_lambda;
154: 	if (!bind_lambda_function) {
155: 		return BindResult("This scalar function does not support lambdas!");
156: 	}
157: 
158: 	if (function.children.size() != 2) {
159: 		return BindResult("Invalid number of function arguments!");
160: 	}
161: 	D_ASSERT(function.children[1]->GetExpressionClass() == ExpressionClass::LAMBDA);
162: 
163: 	// bind the list parameter
164: 	ErrorData error;
165: 	BindChild(function.children[0], depth, error);
166: 	if (error.HasError()) {
167: 		return BindResult(std::move(error));
168: 	}
169: 
170: 	// get the logical type of the children of the list
171: 	auto &list_child = BoundExpression::GetExpression(*function.children[0]);
172: 	if (list_child->return_type.id() != LogicalTypeId::LIST && list_child->return_type.id() != LogicalTypeId::ARRAY &&
173: 	    list_child->return_type.id() != LogicalTypeId::SQLNULL &&
174: 	    list_child->return_type.id() != LogicalTypeId::UNKNOWN) {
175: 		return BindResult("Invalid LIST argument during lambda function binding!");
176: 	}
177: 
178: 	LogicalType list_child_type = list_child->return_type.id();
179: 	if (list_child->return_type.id() != LogicalTypeId::SQLNULL &&
180: 	    list_child->return_type.id() != LogicalTypeId::UNKNOWN) {
181: 
182: 		if (list_child->return_type.id() == LogicalTypeId::ARRAY) {
183: 			list_child_type = ArrayType::GetChildType(list_child->return_type);
184: 		} else {
185: 			list_child_type = ListType::GetChildType(list_child->return_type);
186: 		}
187: 	}
188: 
189: 	// bind the lambda parameter
190: 	auto &lambda_expr = function.children[1]->Cast<LambdaExpression>();
191: 	BindResult bind_lambda_result = BindExpression(lambda_expr, depth, list_child_type, &bind_lambda_function);
192: 
193: 	if (bind_lambda_result.HasError()) {
194: 		return BindResult(bind_lambda_result.error);
195: 	}
196: 
197: 	// successfully bound: replace the node with a BoundExpression
198: 	auto alias = function.children[1]->alias;
199: 	bind_lambda_result.expression->alias = alias;
200: 	if (!alias.empty()) {
201: 		bind_lambda_result.expression->alias = alias;
202: 	}
203: 	function.children[1] = make_uniq<BoundExpression>(std::move(bind_lambda_result.expression));
204: 
205: 	if (binder.GetBindingMode() == BindingMode::EXTRACT_NAMES) {
206: 		return BindResult(make_uniq<BoundConstantExpression>(Value(LogicalType::SQLNULL)));
207: 	}
208: 
209: 	// all children bound successfully
210: 	// extract the children and types
211: 	vector<unique_ptr<Expression>> children;
212: 	for (idx_t i = 0; i < function.children.size(); i++) {
213: 		auto &child = BoundExpression::GetExpression(*function.children[i]);
214: 		children.push_back(std::move(child));
215: 	}
216: 
217: 	// capture the (lambda) columns
218: 	auto &bound_lambda_expr = children.back()->Cast<BoundLambdaExpression>();
219: 	CaptureLambdaColumns(bound_lambda_expr, bound_lambda_expr.lambda_expr, &bind_lambda_function, list_child_type);
220: 
221: 	FunctionBinder function_binder(context);
222: 	unique_ptr<Expression> result =
223: 	    function_binder.BindScalarFunction(func, std::move(children), error, function.is_operator, &binder);
224: 	if (!result) {
225: 		error.AddQueryLocation(function);
226: 		error.Throw();
227: 	}
228: 
229: 	auto &bound_function_expr = result->Cast<BoundFunctionExpression>();
230: 	D_ASSERT(bound_function_expr.children.size() == 2);
231: 
232: 	// remove the lambda expression from the children
233: 	auto lambda = std::move(bound_function_expr.children.back());
234: 	bound_function_expr.children.pop_back();
235: 	auto &bound_lambda = lambda->Cast<BoundLambdaExpression>();
236: 
237: 	// push back (in reverse order) any nested lambda parameters so that we can later use them in the lambda
238: 	// expression (rhs). This happens after we bound the lambda expression of this depth. So it is relevant for
239: 	// correctly binding lambdas one level 'out'. Therefore, the current parameter count does not matter here.
240: 	idx_t offset = 0;
241: 	if (lambda_bindings) {
242: 		for (idx_t i = lambda_bindings->size(); i > 0; i--) {
243: 
244: 			auto &binding = (*lambda_bindings)[i - 1];
245: 			D_ASSERT(binding.names.size() == binding.types.size());
246: 
247: 			for (idx_t column_idx = binding.names.size(); column_idx > 0; column_idx--) {
248: 				auto bound_lambda_param = make_uniq<BoundReferenceExpression>(binding.names[column_idx - 1],
249: 				                                                              binding.types[column_idx - 1], offset);
250: 				offset++;
251: 				bound_function_expr.children.push_back(std::move(bound_lambda_param));
252: 			}
253: 		}
254: 	}
255: 
256: 	// push back the captures into the children vector
257: 	for (auto &capture : bound_lambda.captures) {
258: 		bound_function_expr.children.push_back(std::move(capture));
259: 	}
260: 
261: 	return BindResult(std::move(result));
262: }
263: 
264: BindResult ExpressionBinder::BindAggregate(FunctionExpression &expr, AggregateFunctionCatalogEntry &function,
265:                                            idx_t depth) {
266: 	return BindUnsupportedExpression(expr, depth, UnsupportedAggregateMessage());
267: }
268: 
269: BindResult ExpressionBinder::BindUnnest(FunctionExpression &expr, idx_t depth, bool root_expression) {
270: 	return BindUnsupportedExpression(expr, depth, UnsupportedUnnestMessage());
271: }
272: 
273: void ExpressionBinder::ThrowIfUnnestInLambda(const ColumnBinding &column_binding) {
274: }
275: 
276: string ExpressionBinder::UnsupportedAggregateMessage() {
277: 	return "Aggregate functions are not supported here";
278: }
279: 
280: string ExpressionBinder::UnsupportedUnnestMessage() {
281: 	return "UNNEST not supported here";
282: }
283: 
284: optional_ptr<CatalogEntry> ExpressionBinder::GetCatalogEntry(CatalogType type, const string &catalog,
285:                                                              const string &schema, const string &name,
286:                                                              OnEntryNotFound on_entry_not_found,
287:                                                              QueryErrorContext &error_context) {
288: 	return binder.GetCatalogEntry(type, catalog, schema, name, on_entry_not_found, error_context);
289: }
290: 
291: } // namespace duckdb
[end of src/planner/binder/expression/bind_function_expression.cpp]
[start of src/planner/binder/query_node/bind_select_node.cpp]
1: #include "duckdb/common/limits.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/execution/expression_executor.hpp"
4: #include "duckdb/function/aggregate/distributive_function_utils.hpp"
5: #include "duckdb/function/function_binder.hpp"
6: #include "duckdb/main/config.hpp"
7: #include "duckdb/parser/expression/columnref_expression.hpp"
8: #include "duckdb/parser/expression/comparison_expression.hpp"
9: #include "duckdb/parser/expression/conjunction_expression.hpp"
10: #include "duckdb/parser/expression/constant_expression.hpp"
11: #include "duckdb/parser/expression/function_expression.hpp"
12: #include "duckdb/parser/expression/star_expression.hpp"
13: #include "duckdb/parser/expression/subquery_expression.hpp"
14: #include "duckdb/parser/parsed_expression_iterator.hpp"
15: #include "duckdb/parser/query_node/select_node.hpp"
16: #include "duckdb/parser/tableref/basetableref.hpp"
17: #include "duckdb/parser/tableref/joinref.hpp"
18: #include "duckdb/planner/binder.hpp"
19: #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
20: #include "duckdb/planner/expression/bound_constant_expression.hpp"
21: #include "duckdb/planner/expression/bound_expanded_expression.hpp"
22: #include "duckdb/planner/expression_binder/column_alias_binder.hpp"
23: #include "duckdb/planner/expression_binder/constant_binder.hpp"
24: #include "duckdb/planner/expression_binder/group_binder.hpp"
25: #include "duckdb/planner/expression_binder/having_binder.hpp"
26: #include "duckdb/planner/expression_binder/order_binder.hpp"
27: #include "duckdb/planner/expression_binder/qualify_binder.hpp"
28: #include "duckdb/planner/expression_binder/select_bind_state.hpp"
29: #include "duckdb/planner/expression_binder/select_binder.hpp"
30: #include "duckdb/planner/expression_binder/where_binder.hpp"
31: #include "duckdb/planner/query_node/bound_select_node.hpp"
32: 
33: namespace duckdb {
34: 
35: unique_ptr<Expression> Binder::BindOrderExpression(OrderBinder &order_binder, unique_ptr<ParsedExpression> expr) {
36: 	// we treat the distinct list as an ORDER BY
37: 	auto bound_expr = order_binder.Bind(std::move(expr));
38: 	if (!bound_expr) {
39: 		// DISTINCT ON non-integer constant
40: 		// remove the expression from the DISTINCT ON list
41: 		return nullptr;
42: 	}
43: 	D_ASSERT(bound_expr->type == ExpressionType::VALUE_CONSTANT);
44: 	return bound_expr;
45: }
46: 
47: BoundLimitNode Binder::BindLimitValue(OrderBinder &order_binder, unique_ptr<ParsedExpression> limit_val,
48:                                       bool is_percentage, bool is_offset) {
49: 	auto new_binder = Binder::CreateBinder(context, this);
50: 	ExpressionBinder expr_binder(*new_binder, context);
51: 	auto target_type = is_percentage ? LogicalType::DOUBLE : LogicalType::BIGINT;
52: 	expr_binder.target_type = target_type;
53: 	auto original_limit = limit_val->Copy();
54: 	auto expr = expr_binder.Bind(limit_val);
55: 	if (expr->HasSubquery()) {
56: 		if (!order_binder.HasExtraList()) {
57: 			throw BinderException("Subquery in LIMIT/OFFSET not supported in set operation");
58: 		}
59: 		auto bound_limit = order_binder.CreateExtraReference(std::move(original_limit));
60: 		if (is_percentage) {
61: 			return BoundLimitNode::ExpressionPercentage(std::move(bound_limit));
62: 		} else {
63: 			return BoundLimitNode::ExpressionValue(std::move(bound_limit));
64: 		}
65: 	}
66: 	if (expr->IsFoldable()) {
67: 		//! this is a constant
68: 		auto val = ExpressionExecutor::EvaluateScalar(context, *expr).CastAs(context, target_type);
69: 		if (is_percentage) {
70: 			D_ASSERT(!is_offset);
71: 			double percentage_val;
72: 			if (val.IsNull()) {
73: 				percentage_val = 100.0;
74: 			} else {
75: 				percentage_val = val.GetValue<double>();
76: 			}
77: 			if (Value::IsNan(percentage_val) || percentage_val < 0 || percentage_val > 100) {
78: 				throw OutOfRangeException("Limit percent out of range, should be between 0% and 100%");
79: 			}
80: 			return BoundLimitNode::ConstantPercentage(percentage_val);
81: 		} else {
82: 			int64_t constant_val;
83: 			if (val.IsNull()) {
84: 				constant_val = is_offset ? 0 : NumericLimits<int64_t>::Maximum();
85: 			} else {
86: 				constant_val = val.GetValue<int64_t>();
87: 			}
88: 			if (constant_val < 0) {
89: 				throw BinderException(expr->query_location, "LIMIT/OFFSET cannot be negative");
90: 			}
91: 			return BoundLimitNode::ConstantValue(constant_val);
92: 		}
93: 	}
94: 	if (!new_binder->correlated_columns.empty()) {
95: 		throw BinderException("Correlated columns not supported in LIMIT/OFFSET");
96: 	}
97: 	// move any correlated columns to this binder
98: 	MoveCorrelatedExpressions(*new_binder);
99: 	if (is_percentage) {
100: 		return BoundLimitNode::ExpressionPercentage(std::move(expr));
101: 	} else {
102: 		return BoundLimitNode::ExpressionValue(std::move(expr));
103: 	}
104: }
105: 
106: duckdb::unique_ptr<BoundResultModifier> Binder::BindLimit(OrderBinder &order_binder, LimitModifier &limit_mod) {
107: 	auto result = make_uniq<BoundLimitModifier>();
108: 	if (limit_mod.limit) {
109: 		result->limit_val = BindLimitValue(order_binder, std::move(limit_mod.limit), false, false);
110: 	}
111: 	if (limit_mod.offset) {
112: 		result->offset_val = BindLimitValue(order_binder, std::move(limit_mod.offset), false, true);
113: 	}
114: 	return std::move(result);
115: }
116: 
117: unique_ptr<BoundResultModifier> Binder::BindLimitPercent(OrderBinder &order_binder, LimitPercentModifier &limit_mod) {
118: 	auto result = make_uniq<BoundLimitModifier>();
119: 	if (limit_mod.limit) {
120: 		result->limit_val = BindLimitValue(order_binder, std::move(limit_mod.limit), true, false);
121: 	}
122: 	if (limit_mod.offset) {
123: 		result->offset_val = BindLimitValue(order_binder, std::move(limit_mod.offset), false, true);
124: 	}
125: 	return std::move(result);
126: }
127: 
128: void Binder::PrepareModifiers(OrderBinder &order_binder, QueryNode &statement, BoundQueryNode &result) {
129: 	for (auto &mod : statement.modifiers) {
130: 		unique_ptr<BoundResultModifier> bound_modifier;
131: 		switch (mod->type) {
132: 		case ResultModifierType::DISTINCT_MODIFIER: {
133: 			auto &distinct = mod->Cast<DistinctModifier>();
134: 			auto bound_distinct = make_uniq<BoundDistinctModifier>();
135: 			bound_distinct->distinct_type =
136: 			    distinct.distinct_on_targets.empty() ? DistinctType::DISTINCT : DistinctType::DISTINCT_ON;
137: 			if (distinct.distinct_on_targets.empty()) {
138: 				for (idx_t i = 0; i < result.names.size(); i++) {
139: 					distinct.distinct_on_targets.push_back(
140: 					    make_uniq<ConstantExpression>(Value::INTEGER(UnsafeNumericCast<int32_t>(1 + i))));
141: 				}
142: 			}
143: 			order_binder.SetQueryComponent("DISTINCT ON");
144: 			for (auto &distinct_on_target : distinct.distinct_on_targets) {
145: 				auto expr = BindOrderExpression(order_binder, std::move(distinct_on_target));
146: 				if (!expr) {
147: 					continue;
148: 				}
149: 				bound_distinct->target_distincts.push_back(std::move(expr));
150: 			}
151: 			order_binder.SetQueryComponent();
152: 
153: 			bound_modifier = std::move(bound_distinct);
154: 			break;
155: 		}
156: 		case ResultModifierType::ORDER_MODIFIER: {
157: 
158: 			auto &order = mod->Cast<OrderModifier>();
159: 			auto bound_order = make_uniq<BoundOrderModifier>();
160: 			auto &config = DBConfig::GetConfig(context);
161: 			D_ASSERT(!order.orders.empty());
162: 			auto &order_binders = order_binder.GetBinders();
163: 			if (order.orders.size() == 1 && order.orders[0].expression->type == ExpressionType::STAR) {
164: 				auto &star = order.orders[0].expression->Cast<StarExpression>();
165: 				if (star.exclude_list.empty() && star.replace_list.empty() && !star.expr) {
166: 					// ORDER BY ALL
167: 					// replace the order list with the all elements in the SELECT list
168: 					auto order_type = config.ResolveOrder(order.orders[0].type);
169: 					auto null_order = config.ResolveNullOrder(order_type, order.orders[0].null_order);
170: 					auto constant_expr = make_uniq<BoundConstantExpression>(Value("ALL"));
171: 					bound_order->orders.emplace_back(order_type, null_order, std::move(constant_expr));
172: 					bound_modifier = std::move(bound_order);
173: 					break;
174: 				}
175: 			}
176: #if 0
177: 			// When this verification is enabled, replace ORDER BY x, y with ORDER BY create_sort_key(x, y)
178: 			// note that we don't enable this during actual verification since it doesn't always work
179: 			// e.g. it breaks EXPLAIN output on queries
180: 			bool can_replace = true;
181: 			for (auto &order_node : order.orders) {
182: 				if (order_node.expression->type == ExpressionType::VALUE_CONSTANT) {
183: 					// we cannot replace the sort key when we order by literals (e.g. ORDER BY 1, 2`
184: 					can_replace = false;
185: 					break;
186: 				}
187: 			}
188: 			if (!order_binder.HasExtraList()) {
189: 				// we can only do the replacement when we can order by elements that are not in the selection list
190: 				can_replace = false;
191: 			}
192: 			if (can_replace) {
193: 				vector<unique_ptr<ParsedExpression>> sort_key_parameters;
194: 				for (auto &order_node : order.orders) {
195: 					sort_key_parameters.push_back(std::move(order_node.expression));
196: 					auto type = config.ResolveOrder(order_node.type);
197: 					auto null_order = config.ResolveNullOrder(type, order_node.null_order);
198: 					string sort_param = EnumUtil::ToString(type) + " " + EnumUtil::ToString(null_order);
199: 					sort_key_parameters.push_back(make_uniq<ConstantExpression>(Value(sort_param)));
200: 				}
201: 				order.orders.clear();
202: 				auto create_sort_key = make_uniq<FunctionExpression>("create_sort_key", std::move(sort_key_parameters));
203: 				order.orders.emplace_back(OrderType::ASCENDING, OrderByNullType::NULLS_LAST, std::move(create_sort_key));
204: 			}
205: #endif
206: 			for (auto &order_node : order.orders) {
207: 				vector<unique_ptr<ParsedExpression>> order_list;
208: 				order_binders[0].get().ExpandStarExpression(std::move(order_node.expression), order_list);
209: 
210: 				auto type = config.ResolveOrder(order_node.type);
211: 				auto null_order = config.ResolveNullOrder(type, order_node.null_order);
212: 				for (auto &order_expr : order_list) {
213: 					auto bound_expr = BindOrderExpression(order_binder, std::move(order_expr));
214: 					if (!bound_expr) {
215: 						continue;
216: 					}
217: 					bound_order->orders.emplace_back(type, null_order, std::move(bound_expr));
218: 				}
219: 			}
220: 			if (!bound_order->orders.empty()) {
221: 				bound_modifier = std::move(bound_order);
222: 			}
223: 			break;
224: 		}
225: 		case ResultModifierType::LIMIT_MODIFIER:
226: 			bound_modifier = BindLimit(order_binder, mod->Cast<LimitModifier>());
227: 			break;
228: 		case ResultModifierType::LIMIT_PERCENT_MODIFIER:
229: 			bound_modifier = BindLimitPercent(order_binder, mod->Cast<LimitPercentModifier>());
230: 			break;
231: 		default:
232: 			throw InternalException("Unsupported result modifier");
233: 		}
234: 		if (bound_modifier) {
235: 			result.modifiers.push_back(std::move(bound_modifier));
236: 		}
237: 	}
238: }
239: 
240: unique_ptr<Expression> CreateOrderExpression(unique_ptr<Expression> expr, const vector<string> &names,
241:                                              const vector<LogicalType> &sql_types, idx_t table_index, idx_t index) {
242: 	if (index >= sql_types.size()) {
243: 		throw BinderException(*expr, "ORDER term out of range - should be between 1 and %lld", sql_types.size());
244: 	}
245: 	auto result = make_uniq<BoundColumnRefExpression>(std::move(expr->alias), sql_types[index],
246: 	                                                  ColumnBinding(table_index, index));
247: 	if (result->alias.empty() && index < names.size()) {
248: 		result->alias = names[index];
249: 	}
250: 	return std::move(result);
251: }
252: 
253: unique_ptr<Expression> FinalizeBindOrderExpression(unique_ptr<Expression> expr, idx_t table_index,
254:                                                    const vector<string> &names, const vector<LogicalType> &sql_types,
255:                                                    const SelectBindState &bind_state) {
256: 	auto &constant = expr->Cast<BoundConstantExpression>();
257: 	switch (constant.value.type().id()) {
258: 	case LogicalTypeId::UBIGINT: {
259: 		// index
260: 		auto index = UBigIntValue::Get(constant.value);
261: 		return CreateOrderExpression(std::move(expr), names, sql_types, table_index, bind_state.GetFinalIndex(index));
262: 	}
263: 	case LogicalTypeId::VARCHAR: {
264: 		// ORDER BY ALL
265: 		return nullptr;
266: 	}
267: 	case LogicalTypeId::STRUCT: {
268: 		// collation
269: 		auto &struct_values = StructValue::GetChildren(constant.value);
270: 		if (struct_values.size() > 2) {
271: 			throw InternalException("Expected one or two children: index and optional collation");
272: 		}
273: 		auto index = UBigIntValue::Get(struct_values[0]);
274: 		string collation;
275: 		if (struct_values.size() == 2) {
276: 			collation = StringValue::Get(struct_values[1]);
277: 		}
278: 		auto result = CreateOrderExpression(std::move(expr), names, sql_types, table_index, index);
279: 		if (!collation.empty()) {
280: 			if (sql_types[index].id() != LogicalTypeId::VARCHAR) {
281: 				throw BinderException(*result, "COLLATE can only be applied to varchar columns");
282: 			}
283: 			result->return_type = LogicalType::VARCHAR_COLLATION(std::move(collation));
284: 		}
285: 		return result;
286: 	}
287: 	default:
288: 		throw InternalException("Unknown type in FinalizeBindOrderExpression");
289: 	}
290: }
291: 
292: static void AssignReturnType(unique_ptr<Expression> &expr, idx_t table_index, const vector<string> &names,
293:                              const vector<LogicalType> &sql_types, const SelectBindState &bind_state) {
294: 	if (!expr) {
295: 		return;
296: 	}
297: 	if (expr->type == ExpressionType::VALUE_CONSTANT) {
298: 		expr = FinalizeBindOrderExpression(std::move(expr), table_index, names, sql_types, bind_state);
299: 	}
300: 	if (expr->type != ExpressionType::BOUND_COLUMN_REF) {
301: 		return;
302: 	}
303: 	auto &bound_colref = expr->Cast<BoundColumnRefExpression>();
304: 	bound_colref.return_type = sql_types[bound_colref.binding.column_index];
305: }
306: 
307: void Binder::BindModifiers(BoundQueryNode &result, idx_t table_index, const vector<string> &names,
308:                            const vector<LogicalType> &sql_types, const SelectBindState &bind_state) {
309: 	for (auto &bound_mod : result.modifiers) {
310: 		switch (bound_mod->type) {
311: 		case ResultModifierType::DISTINCT_MODIFIER: {
312: 			auto &distinct = bound_mod->Cast<BoundDistinctModifier>();
313: 			D_ASSERT(!distinct.target_distincts.empty());
314: 			// set types of distinct targets
315: 			for (auto &expr : distinct.target_distincts) {
316: 				expr = FinalizeBindOrderExpression(std::move(expr), table_index, names, sql_types, bind_state);
317: 				if (!expr) {
318: 					throw InternalException("DISTINCT ON ORDER BY ALL not supported");
319: 				}
320: 			}
321: 			for (auto &expr : distinct.target_distincts) {
322: 				ExpressionBinder::PushCollation(context, expr, expr->return_type);
323: 			}
324: 			break;
325: 		}
326: 		case ResultModifierType::LIMIT_MODIFIER: {
327: 			auto &limit = bound_mod->Cast<BoundLimitModifier>();
328: 			AssignReturnType(limit.limit_val.GetExpression(), table_index, names, sql_types, bind_state);
329: 			AssignReturnType(limit.offset_val.GetExpression(), table_index, names, sql_types, bind_state);
330: 			break;
331: 		}
332: 		case ResultModifierType::ORDER_MODIFIER: {
333: 			auto &order = bound_mod->Cast<BoundOrderModifier>();
334: 			bool order_by_all = false;
335: 			for (auto &order_node : order.orders) {
336: 				auto &expr = order_node.expression;
337: 				expr = FinalizeBindOrderExpression(std::move(expr), table_index, names, sql_types, bind_state);
338: 				if (!expr) {
339: 					order_by_all = true;
340: 				}
341: 			}
342: 			if (order_by_all) {
343: 				D_ASSERT(order.orders.size() == 1);
344: 				auto order_type = order.orders[0].type;
345: 				auto null_order = order.orders[0].null_order;
346: 				order.orders.clear();
347: 				for (idx_t i = 0; i < sql_types.size(); i++) {
348: 					auto expr = make_uniq<BoundColumnRefExpression>(sql_types[i], ColumnBinding(table_index, i));
349: 					if (i < names.size()) {
350: 						expr->alias = names[i];
351: 					}
352: 					order.orders.emplace_back(order_type, null_order, std::move(expr));
353: 				}
354: 			}
355: 			for (auto &order_node : order.orders) {
356: 				auto &expr = order_node.expression;
357: 				ExpressionBinder::PushCollation(context, order_node.expression, expr->return_type);
358: 			}
359: 			break;
360: 		}
361: 		default:
362: 			break;
363: 		}
364: 	}
365: }
366: 
367: unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {
368: 	D_ASSERT(statement.from_table);
369: 
370: 	// first bind the FROM table statement
371: 	auto from = std::move(statement.from_table);
372: 	auto from_table = Bind(*from);
373: 	return BindSelectNode(statement, std::move(from_table));
374: }
375: 
376: void Binder::BindWhereStarExpression(unique_ptr<ParsedExpression> &expr) {
377: 	// expand any expressions in the upper AND recursively
378: 	if (expr->type == ExpressionType::CONJUNCTION_AND) {
379: 		auto &conj = expr->Cast<ConjunctionExpression>();
380: 		for (auto &child : conj.children) {
381: 			BindWhereStarExpression(child);
382: 		}
383: 		return;
384: 	}
385: 	if (expr->type == ExpressionType::STAR) {
386: 		auto &star = expr->Cast<StarExpression>();
387: 		if (!star.columns) {
388: 			throw ParserException("STAR expression is not allowed in the WHERE clause. Use COLUMNS(*) instead.");
389: 		}
390: 	}
391: 	// expand the stars for this expression
392: 	vector<unique_ptr<ParsedExpression>> new_conditions;
393: 	ExpandStarExpression(std::move(expr), new_conditions);
394: 	if (new_conditions.empty()) {
395: 		throw ParserException("COLUMNS expansion resulted in empty set of columns");
396: 	}
397: 
398: 	// set up an AND conjunction between the expanded conditions
399: 	expr = std::move(new_conditions[0]);
400: 	for (idx_t i = 1; i < new_conditions.size(); i++) {
401: 		auto and_conj = make_uniq<ConjunctionExpression>(ExpressionType::CONJUNCTION_AND, std::move(expr),
402: 		                                                 std::move(new_conditions[i]));
403: 		expr = std::move(and_conj);
404: 	}
405: }
406: 
407: unique_ptr<BoundQueryNode> Binder::BindSelectNode(SelectNode &statement, unique_ptr<BoundTableRef> from_table) {
408: 	D_ASSERT(from_table);
409: 	D_ASSERT(!statement.from_table);
410: 	auto result = make_uniq<BoundSelectNode>();
411: 	result->projection_index = GenerateTableIndex();
412: 	result->group_index = GenerateTableIndex();
413: 	result->aggregate_index = GenerateTableIndex();
414: 	result->groupings_index = GenerateTableIndex();
415: 	result->window_index = GenerateTableIndex();
416: 	result->prune_index = GenerateTableIndex();
417: 
418: 	result->from_table = std::move(from_table);
419: 	// bind the sample clause
420: 	if (statement.sample) {
421: 		result->sample_options = std::move(statement.sample);
422: 	}
423: 
424: 	// visit the select list and expand any "*" statements
425: 	vector<unique_ptr<ParsedExpression>> new_select_list;
426: 	ExpandStarExpressions(statement.select_list, new_select_list);
427: 
428: 	if (new_select_list.empty()) {
429: 		throw BinderException("SELECT list is empty after resolving * expressions!");
430: 	}
431: 	statement.select_list = std::move(new_select_list);
432: 
433: 	auto &bind_state = result->bind_state;
434: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
435: 		auto &expr = statement.select_list[i];
436: 		result->names.push_back(expr->GetName());
437: 		ExpressionBinder::QualifyColumnNames(*this, expr);
438: 		if (!expr->alias.empty()) {
439: 			bind_state.alias_map[expr->alias] = i;
440: 			result->names[i] = expr->alias;
441: 		}
442: 		bind_state.projection_map[*expr] = i;
443: 		bind_state.original_expressions.push_back(expr->Copy());
444: 	}
445: 	result->column_count = statement.select_list.size();
446: 
447: 	// first visit the WHERE clause
448: 	// the WHERE clause happens before the GROUP BY, PROJECTION or HAVING clauses
449: 	if (statement.where_clause) {
450: 		// bind any star expressions in the WHERE clause
451: 		BindWhereStarExpression(statement.where_clause);
452: 
453: 		ColumnAliasBinder alias_binder(bind_state);
454: 		WhereBinder where_binder(*this, context, &alias_binder);
455: 		unique_ptr<ParsedExpression> condition = std::move(statement.where_clause);
456: 		result->where_clause = where_binder.Bind(condition);
457: 	}
458: 
459: 	// now bind all the result modifiers; including DISTINCT and ORDER BY targets
460: 	OrderBinder order_binder({*this}, statement, bind_state);
461: 	PrepareModifiers(order_binder, statement, *result);
462: 
463: 	vector<unique_ptr<ParsedExpression>> unbound_groups;
464: 	BoundGroupInformation info;
465: 	auto &group_expressions = statement.groups.group_expressions;
466: 	if (!group_expressions.empty()) {
467: 		// the statement has a GROUP BY clause, bind it
468: 		unbound_groups.resize(group_expressions.size());
469: 		GroupBinder group_binder(*this, context, statement, result->group_index, bind_state, info.alias_map);
470: 		for (idx_t i = 0; i < group_expressions.size(); i++) {
471: 
472: 			// we keep a copy of the unbound expression;
473: 			// we keep the unbound copy around to check for group references in the SELECT and HAVING clause
474: 			// the reason we want the unbound copy is because we want to figure out whether an expression
475: 			// is a group reference BEFORE binding in the SELECT/HAVING binder
476: 			group_binder.unbound_expression = group_expressions[i]->Copy();
477: 			group_binder.bind_index = i;
478: 
479: 			// bind the groups
480: 			LogicalType group_type;
481: 			auto bound_expr = group_binder.Bind(group_expressions[i], &group_type);
482: 			D_ASSERT(bound_expr->return_type.id() != LogicalTypeId::INVALID);
483: 
484: 			// find out whether the expression contains a subquery, it can't be copied if so
485: 			auto &bound_expr_ref = *bound_expr;
486: 			bool contains_subquery = bound_expr_ref.HasSubquery();
487: 
488: 			// push a potential collation, if necessary
489: 			bool requires_collation = ExpressionBinder::PushCollation(context, bound_expr, group_type);
490: 			if (!contains_subquery && requires_collation) {
491: 				// if there is a collation on a group x, we should group by the collated expr,
492: 				// but also push a first(x) aggregate in case x is selected (uncollated)
493: 				info.collated_groups[i] = result->aggregates.size();
494: 
495: 				auto first_fun = FirstFunctionGetter::GetFunction(bound_expr_ref.return_type);
496: 				vector<unique_ptr<Expression>> first_children;
497: 				// FIXME: would be better to just refer to this expression, but for now we copy
498: 				first_children.push_back(bound_expr_ref.Copy());
499: 
500: 				FunctionBinder function_binder(context);
501: 				auto function = function_binder.BindAggregateFunction(first_fun, std::move(first_children));
502: 				function->alias = "__collated_group";
503: 				result->aggregates.push_back(std::move(function));
504: 			}
505: 			result->groups.group_expressions.push_back(std::move(bound_expr));
506: 
507: 			// in the unbound expression we DO bind the table names of any ColumnRefs
508: 			// we do this to make sure that "table.a" and "a" are treated the same
509: 			// if we wouldn't do this then (SELECT test.a FROM test GROUP BY a) would not work because "test.a" <> "a"
510: 			// hence we convert "a" -> "test.a" in the unbound expression
511: 			unbound_groups[i] = std::move(group_binder.unbound_expression);
512: 			ExpressionBinder::QualifyColumnNames(*this, unbound_groups[i]);
513: 			info.map[*unbound_groups[i]] = i;
514: 		}
515: 	}
516: 	result->groups.grouping_sets = std::move(statement.groups.grouping_sets);
517: 
518: 	// bind the HAVING clause, if any
519: 	if (statement.having) {
520: 		HavingBinder having_binder(*this, context, *result, info, statement.aggregate_handling);
521: 		ExpressionBinder::QualifyColumnNames(having_binder, statement.having);
522: 		result->having = having_binder.Bind(statement.having);
523: 	}
524: 
525: 	// bind the QUALIFY clause, if any
526: 	vector<BoundColumnReferenceInfo> bound_qualify_columns;
527: 	if (statement.qualify) {
528: 		if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {
529: 			throw BinderException("Combining QUALIFY with GROUP BY ALL is not supported yet");
530: 		}
531: 		QualifyBinder qualify_binder(*this, context, *result, info);
532: 		ExpressionBinder::QualifyColumnNames(*this, statement.qualify);
533: 		result->qualify = qualify_binder.Bind(statement.qualify);
534: 		if (qualify_binder.HasBoundColumns()) {
535: 			if (qualify_binder.BoundAggregates()) {
536: 				throw BinderException("Cannot mix aggregates with non-aggregated columns!");
537: 			}
538: 			bound_qualify_columns = qualify_binder.GetBoundColumns();
539: 		}
540: 	}
541: 
542: 	// after that, we bind to the SELECT list
543: 	SelectBinder select_binder(*this, context, *result, info);
544: 
545: 	// if we expand select-list expressions, e.g., via UNNEST, then we need to possibly
546: 	// adjust the column index of the already bound ORDER BY modifiers, and not only set their types
547: 	vector<idx_t> group_by_all_indexes;
548: 	vector<string> new_names;
549: 	vector<LogicalType> internal_sql_types;
550: 
551: 	for (idx_t i = 0; i < statement.select_list.size(); i++) {
552: 		bool is_window = statement.select_list[i]->IsWindow();
553: 		idx_t unnest_count = result->unnests.size();
554: 		LogicalType result_type;
555: 		auto expr = select_binder.Bind(statement.select_list[i], &result_type, true);
556: 		bool is_original_column = i < result->column_count;
557: 		bool can_group_by_all =
558: 		    statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES && is_original_column;
559: 		result->bound_column_count++;
560: 
561: 		if (expr->type == ExpressionType::BOUND_EXPANDED) {
562: 			if (!is_original_column) {
563: 				throw BinderException("UNNEST of struct cannot be used in ORDER BY/DISTINCT ON clause");
564: 			}
565: 			if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {
566: 				throw BinderException("UNNEST of struct cannot be combined with GROUP BY ALL");
567: 			}
568: 
569: 			auto &expanded = expr->Cast<BoundExpandedExpression>();
570: 			auto &struct_expressions = expanded.expanded_expressions;
571: 			D_ASSERT(!struct_expressions.empty());
572: 
573: 			for (auto &struct_expr : struct_expressions) {
574: 				new_names.push_back(struct_expr->GetName());
575: 				result->types.push_back(struct_expr->return_type);
576: 				internal_sql_types.push_back(struct_expr->return_type);
577: 				result->select_list.push_back(std::move(struct_expr));
578: 			}
579: 			bind_state.AddExpandedColumn(struct_expressions.size());
580: 			continue;
581: 		}
582: 
583: 		if (expr->IsVolatile()) {
584: 			bind_state.SetExpressionIsVolatile(i);
585: 		}
586: 		if (expr->HasSubquery()) {
587: 			bind_state.SetExpressionHasSubquery(i);
588: 		}
589: 		bind_state.AddRegularColumn();
590: 
591: 		if (can_group_by_all && select_binder.HasBoundColumns()) {
592: 			if (select_binder.BoundAggregates()) {
593: 				throw BinderException("Cannot mix aggregates with non-aggregated columns!");
594: 			}
595: 			if (is_window) {
596: 				throw BinderException("Cannot group on a window clause");
597: 			}
598: 			if (result->unnests.size() > unnest_count) {
599: 				throw BinderException("Cannot group on an UNNEST or UNLIST clause");
600: 			}
601: 			// we are forcing aggregates, and the node has columns bound
602: 			// this entry becomes a group
603: 			group_by_all_indexes.push_back(i);
604: 		}
605: 
606: 		result->select_list.push_back(std::move(expr));
607: 		if (is_original_column) {
608: 			new_names.push_back(std::move(result->names[i]));
609: 			result->types.push_back(result_type);
610: 		}
611: 		internal_sql_types.push_back(result_type);
612: 
613: 		if (can_group_by_all) {
614: 			select_binder.ResetBindings();
615: 		}
616: 	}
617: 
618: 	// push the GROUP BY ALL expressions into the group set
619: 	for (auto &group_by_all_index : group_by_all_indexes) {
620: 		auto &expr = result->select_list[group_by_all_index];
621: 		auto group_ref = make_uniq<BoundColumnRefExpression>(
622: 		    expr->return_type, ColumnBinding(result->group_index, result->groups.group_expressions.size()));
623: 		result->groups.group_expressions.push_back(std::move(expr));
624: 		expr = std::move(group_ref);
625: 	}
626: 	result->column_count = new_names.size();
627: 	result->names = std::move(new_names);
628: 	result->need_prune = result->select_list.size() > result->column_count;
629: 
630: 	// in the normal select binder, we bind columns as if there is no aggregation
631: 	// i.e. in the query [SELECT i, SUM(i) FROM integers;] the "i" will be bound as a normal column
632: 	// since we have an aggregation, we need to either (1) throw an error, or (2) wrap the column in a FIRST() aggregate
633: 	// we choose the former one [CONTROVERSIAL: this is the PostgreSQL behavior]
634: 	if (!result->groups.group_expressions.empty() || !result->aggregates.empty() || statement.having ||
635: 	    !result->groups.grouping_sets.empty()) {
636: 		if (statement.aggregate_handling == AggregateHandling::NO_AGGREGATES_ALLOWED) {
637: 			throw BinderException("Aggregates cannot be present in a Project relation!");
638: 		} else {
639: 			vector<BoundColumnReferenceInfo> bound_columns;
640: 			if (select_binder.HasBoundColumns()) {
641: 				bound_columns = select_binder.GetBoundColumns();
642: 			}
643: 			for (auto &bound_qualify_col : bound_qualify_columns) {
644: 				bound_columns.push_back(bound_qualify_col);
645: 			}
646: 			if (!bound_columns.empty()) {
647: 				string error;
648: 				error = "column \"%s\" must appear in the GROUP BY clause or must be part of an aggregate function.";
649: 				if (statement.aggregate_handling == AggregateHandling::FORCE_AGGREGATES) {
650: 					error += "\nGROUP BY ALL will only group entries in the SELECT list. Add it to the SELECT list or "
651: 					         "GROUP BY this entry explicitly.";
652: 					throw BinderException(bound_columns[0].query_location, error, bound_columns[0].name);
653: 				} else {
654: 					error +=
655: 					    "\nEither add it to the GROUP BY list, or use \"ANY_VALUE(%s)\" if the exact value of \"%s\" "
656: 					    "is not important.";
657: 					throw BinderException(bound_columns[0].query_location, error, bound_columns[0].name,
658: 					                      bound_columns[0].name, bound_columns[0].name);
659: 				}
660: 			}
661: 		}
662: 	}
663: 
664: 	// QUALIFY clause requires at least one window function to be specified in at least one of the SELECT column list or
665: 	// the filter predicate of the QUALIFY clause
666: 	if (statement.qualify && result->windows.empty()) {
667: 		throw BinderException("at least one window function must appear in the SELECT column or QUALIFY clause");
668: 	}
669: 
670: 	// now that the SELECT list is bound, we set the types of DISTINCT/ORDER BY expressions
671: 	BindModifiers(*result, result->projection_index, result->names, internal_sql_types, bind_state);
672: 	return std::move(result);
673: }
674: 
675: } // namespace duckdb
[end of src/planner/binder/query_node/bind_select_node.cpp]
[start of src/planner/binder/query_node/plan_subquery.cpp]
1: #include "duckdb/function/aggregate/distributive_functions.hpp"
2: #include "duckdb/function/aggregate/distributive_function_utils.hpp"
3: #include "duckdb/main/client_config.hpp"
4: #include "duckdb/planner/binder.hpp"
5: #include "duckdb/planner/expression/bound_aggregate_expression.hpp"
6: #include "duckdb/planner/expression/bound_case_expression.hpp"
7: #include "duckdb/planner/expression/bound_cast_expression.hpp"
8: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
9: #include "duckdb/planner/expression/bound_comparison_expression.hpp"
10: #include "duckdb/planner/expression/bound_constant_expression.hpp"
11: #include "duckdb/planner/expression/bound_subquery_expression.hpp"
12: #include "duckdb/planner/expression/bound_window_expression.hpp"
13: #include "duckdb/planner/expression_iterator.hpp"
14: #include "duckdb/planner/operator/list.hpp"
15: #include "duckdb/planner/operator/logical_window.hpp"
16: #include "duckdb/function/function_binder.hpp"
17: #include "duckdb/planner/subquery/flatten_dependent_join.hpp"
18: #include "duckdb/common/enums/logical_operator_type.hpp"
19: #include "duckdb/planner/operator/logical_dependent_join.hpp"
20: #include "duckdb/planner/subquery/recursive_dependent_join_planner.hpp"
21: #include "duckdb/function/scalar/generic_functions.hpp"
22: 
23: namespace duckdb {
24: 
25: static unique_ptr<Expression> PlanUncorrelatedSubquery(Binder &binder, BoundSubqueryExpression &expr,
26:                                                        unique_ptr<LogicalOperator> &root,
27:                                                        unique_ptr<LogicalOperator> plan) {
28: 	D_ASSERT(!expr.IsCorrelated());
29: 	switch (expr.subquery_type) {
30: 	case SubqueryType::EXISTS: {
31: 		// uncorrelated EXISTS
32: 		// we only care about existence, hence we push a LIMIT 1 operator
33: 		auto limit = make_uniq<LogicalLimit>(BoundLimitNode::ConstantValue(1), BoundLimitNode());
34: 		limit->AddChild(std::move(plan));
35: 		plan = std::move(limit);
36: 
37: 		// now we push a COUNT(*) aggregate onto the limit, this will be either 0 or 1 (EXISTS or NOT EXISTS)
38: 		auto count_star_fun = CountStarFun::GetFunction();
39: 
40: 		FunctionBinder function_binder(binder.context);
41: 		auto count_star =
42: 		    function_binder.BindAggregateFunction(count_star_fun, {}, nullptr, AggregateType::NON_DISTINCT);
43: 		auto idx_type = count_star->return_type;
44: 		vector<unique_ptr<Expression>> aggregate_list;
45: 		aggregate_list.push_back(std::move(count_star));
46: 		auto aggregate_index = binder.GenerateTableIndex();
47: 		auto aggregate =
48: 		    make_uniq<LogicalAggregate>(binder.GenerateTableIndex(), aggregate_index, std::move(aggregate_list));
49: 		aggregate->AddChild(std::move(plan));
50: 		plan = std::move(aggregate);
51: 
52: 		// now we push a projection with a comparison to 1
53: 		auto left_child = make_uniq<BoundColumnRefExpression>(idx_type, ColumnBinding(aggregate_index, 0));
54: 		auto right_child = make_uniq<BoundConstantExpression>(Value::Numeric(idx_type, 1));
55: 		auto comparison = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_EQUAL, std::move(left_child),
56: 		                                                       std::move(right_child));
57: 
58: 		vector<unique_ptr<Expression>> projection_list;
59: 		projection_list.push_back(std::move(comparison));
60: 		auto projection_index = binder.GenerateTableIndex();
61: 		auto projection = make_uniq<LogicalProjection>(projection_index, std::move(projection_list));
62: 		projection->AddChild(std::move(plan));
63: 		plan = std::move(projection);
64: 
65: 		// we add it to the main query by adding a cross product
66: 		// FIXME: should use something else besides cross product as we always add only one scalar constant
67: 		root = LogicalCrossProduct::Create(std::move(root), std::move(plan));
68: 
69: 		// we replace the original subquery with a ColumnRefExpression referring to the result of the projection (either
70: 		// TRUE or FALSE)
71: 		return make_uniq<BoundColumnRefExpression>(expr.GetName(), LogicalType::BOOLEAN,
72: 		                                           ColumnBinding(projection_index, 0));
73: 	}
74: 	case SubqueryType::SCALAR: {
75: 		// uncorrelated scalar, we want to return the first entry
76: 		// figure out the table index of the bound table of the entry which we want to return
77: 		auto bindings = plan->GetColumnBindings();
78: 		D_ASSERT(bindings.size() == 1);
79: 		idx_t table_idx = bindings[0].table_index;
80: 
81: 		auto &config = ClientConfig::GetConfig(binder.context);
82: 		bool error_on_multiple_rows = config.scalar_subquery_error_on_multiple_rows;
83: 
84: 		// we push an aggregate that returns the FIRST element
85: 		vector<unique_ptr<Expression>> expressions;
86: 		auto bound = make_uniq<BoundColumnRefExpression>(expr.return_type, ColumnBinding(table_idx, 0));
87: 		vector<unique_ptr<Expression>> first_children;
88: 		first_children.push_back(std::move(bound));
89: 
90: 		FunctionBinder function_binder(binder.context);
91: 		auto first_agg =
92: 		    function_binder.BindAggregateFunction(FirstFunctionGetter::GetFunction(expr.return_type),
93: 		                                          std::move(first_children), nullptr, AggregateType::NON_DISTINCT);
94: 
95: 		expressions.push_back(std::move(first_agg));
96: 		if (error_on_multiple_rows) {
97: 			vector<unique_ptr<Expression>> count_children;
98: 			auto count_agg = function_binder.BindAggregateFunction(
99: 			    CountStarFun::GetFunction(), std::move(count_children), nullptr, AggregateType::NON_DISTINCT);
100: 			expressions.push_back(std::move(count_agg));
101: 		}
102: 		auto aggr_index = binder.GenerateTableIndex();
103: 
104: 		auto aggr = make_uniq<LogicalAggregate>(binder.GenerateTableIndex(), aggr_index, std::move(expressions));
105: 		aggr->AddChild(std::move(plan));
106: 		plan = std::move(aggr);
107: 
108: 		if (error_on_multiple_rows) {
109: 			// CASE WHEN count > 1 THEN error('Scalar subquery can only return a single row') ELSE first_agg END
110: 			idx_t proj_index = binder.GenerateTableIndex();
111: 
112: 			auto first_ref =
113: 			    make_uniq<BoundColumnRefExpression>(plan->expressions[0]->return_type, ColumnBinding(aggr_index, 0));
114: 			auto count_ref =
115: 			    make_uniq<BoundColumnRefExpression>(plan->expressions[1]->return_type, ColumnBinding(aggr_index, 1));
116: 
117: 			auto constant_one = make_uniq<BoundConstantExpression>(Value::BIGINT(1));
118: 			auto count_check = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_GREATERTHAN,
119: 			                                                        std::move(count_ref), std::move(constant_one));
120: 
121: 			vector<unique_ptr<Expression>> error_children;
122: 			error_children.push_back(make_uniq<BoundConstantExpression>(
123: 			    Value("More than one row returned by a subquery used as an expression - scalar subqueries can only "
124: 			          "return a single row.\n\nUse \"SET scalar_subquery_error_on_multiple_rows=false\" to revert to "
125: 			          "previous behavior of returning a random row.")));
126: 			auto error_expr = function_binder.BindScalarFunction(ErrorFun::GetFunction(), std::move(error_children));
127: 			error_expr->return_type = first_ref->return_type;
128: 			auto case_expr =
129: 			    make_uniq<BoundCaseExpression>(std::move(count_check), std::move(error_expr), std::move(first_ref));
130: 
131: 			vector<unique_ptr<Expression>> proj_expressions;
132: 			proj_expressions.push_back(std::move(case_expr));
133: 
134: 			auto proj = make_uniq<LogicalProjection>(proj_index, std::move(proj_expressions));
135: 			proj->AddChild(std::move(plan));
136: 			plan = std::move(proj);
137: 
138: 			aggr_index = proj_index;
139: 		}
140: 
141: 		// in the uncorrelated case, we add the value to the main query through a cross product
142: 		// FIXME: should use something else besides cross product as we always add only one scalar constant and cross
143: 		// product is not optimized for this.
144: 		D_ASSERT(root);
145: 		root = LogicalCrossProduct::Create(std::move(root), std::move(plan));
146: 
147: 		// we replace the original subquery with a BoundColumnRefExpression referring to the first result of the
148: 		// aggregation
149: 		return make_uniq<BoundColumnRefExpression>(expr.GetName(), expr.return_type, ColumnBinding(aggr_index, 0));
150: 	}
151: 	default: {
152: 		D_ASSERT(expr.subquery_type == SubqueryType::ANY);
153: 		// we generate a MARK join that results in either (TRUE, FALSE or NULL)
154: 		// subquery has NULL values -> result is (TRUE or NULL)
155: 		// subquery has no NULL values -> result is (TRUE, FALSE or NULL [if input is NULL])
156: 		// fetch the column bindings
157: 		auto plan_columns = plan->GetColumnBindings();
158: 
159: 		// then we generate the MARK join with the subquery
160: 		idx_t mark_index = binder.GenerateTableIndex();
161: 		auto join = make_uniq<LogicalComparisonJoin>(JoinType::MARK);
162: 		join->mark_index = mark_index;
163: 		join->AddChild(std::move(root));
164: 		join->AddChild(std::move(plan));
165: 		// create the JOIN condition
166: 		JoinCondition cond;
167: 		cond.left = std::move(expr.child);
168: 		cond.right = BoundCastExpression::AddDefaultCastToType(
169: 		    make_uniq<BoundColumnRefExpression>(expr.child_type, plan_columns[0]), expr.child_target);
170: 		cond.comparison = expr.comparison_type;
171: 		join->conditions.push_back(std::move(cond));
172: 		root = std::move(join);
173: 
174: 		// we replace the original subquery with a BoundColumnRefExpression referring to the mark column
175: 		return make_uniq<BoundColumnRefExpression>(expr.GetName(), expr.return_type, ColumnBinding(mark_index, 0));
176: 	}
177: 	}
178: }
179: 
180: static unique_ptr<LogicalComparisonJoin>
181: CreateDuplicateEliminatedJoin(const vector<CorrelatedColumnInfo> &correlated_columns, JoinType join_type,
182:                               unique_ptr<LogicalOperator> original_plan, bool perform_delim) {
183: 	auto delim_join = make_uniq<LogicalComparisonJoin>(join_type, LogicalOperatorType::LOGICAL_DELIM_JOIN);
184: 	if (!perform_delim) {
185: 		// if we are not performing a delim join, we push a row_number() OVER() window operator on the LHS
186: 		// and perform all duplicate elimination on that row number instead
187: 		D_ASSERT(correlated_columns[0].type.id() == LogicalTypeId::BIGINT);
188: 		auto window = make_uniq<LogicalWindow>(correlated_columns[0].binding.table_index);
189: 		auto row_number =
190: 		    make_uniq<BoundWindowExpression>(ExpressionType::WINDOW_ROW_NUMBER, LogicalType::BIGINT, nullptr, nullptr);
191: 		row_number->start = WindowBoundary::UNBOUNDED_PRECEDING;
192: 		row_number->end = WindowBoundary::CURRENT_ROW_ROWS;
193: 		row_number->alias = "delim_index";
194: 		window->expressions.push_back(std::move(row_number));
195: 		window->AddChild(std::move(original_plan));
196: 		original_plan = std::move(window);
197: 	}
198: 	delim_join->AddChild(std::move(original_plan));
199: 	for (idx_t i = 0; i < correlated_columns.size(); i++) {
200: 		auto &col = correlated_columns[i];
201: 		delim_join->duplicate_eliminated_columns.push_back(make_uniq<BoundColumnRefExpression>(col.type, col.binding));
202: 		delim_join->mark_types.push_back(col.type);
203: 	}
204: 	return delim_join;
205: }
206: 
207: static void CreateDelimJoinConditions(LogicalComparisonJoin &delim_join,
208:                                       const vector<CorrelatedColumnInfo> &correlated_columns,
209:                                       vector<ColumnBinding> bindings, idx_t base_offset, bool perform_delim) {
210: 	auto col_count = perform_delim ? correlated_columns.size() : 1;
211: 	for (idx_t i = 0; i < col_count; i++) {
212: 		auto &col = correlated_columns[i];
213: 		auto binding_idx = base_offset + i;
214: 		if (binding_idx >= bindings.size()) {
215: 			throw InternalException("Delim join - binding index out of range");
216: 		}
217: 		JoinCondition cond;
218: 		cond.left = make_uniq<BoundColumnRefExpression>(col.name, col.type, col.binding);
219: 		cond.right = make_uniq<BoundColumnRefExpression>(col.name, col.type, bindings[binding_idx]);
220: 		cond.comparison = ExpressionType::COMPARE_NOT_DISTINCT_FROM;
221: 		delim_join.conditions.push_back(std::move(cond));
222: 	}
223: }
224: 
225: static bool PerformDelimOnType(const LogicalType &type) {
226: 	if (type.InternalType() == PhysicalType::LIST) {
227: 		return false;
228: 	}
229: 	if (type.InternalType() == PhysicalType::STRUCT) {
230: 		for (auto &entry : StructType::GetChildTypes(type)) {
231: 			if (!PerformDelimOnType(entry.second)) {
232: 				return false;
233: 			}
234: 		}
235: 	}
236: 	return true;
237: }
238: 
239: static bool PerformDuplicateElimination(Binder &binder, vector<CorrelatedColumnInfo> &correlated_columns) {
240: 	if (!ClientConfig::GetConfig(binder.context).enable_optimizer) {
241: 		// if optimizations are disabled we always do a delim join
242: 		return true;
243: 	}
244: 	bool perform_delim = true;
245: 	for (auto &col : correlated_columns) {
246: 		if (!PerformDelimOnType(col.type)) {
247: 			perform_delim = false;
248: 			break;
249: 		}
250: 	}
251: 	if (perform_delim) {
252: 		return true;
253: 	}
254: 	auto binding = ColumnBinding(binder.GenerateTableIndex(), 0);
255: 	auto type = LogicalType::BIGINT;
256: 	auto name = "delim_index";
257: 	CorrelatedColumnInfo info(binding, type, name, 0);
258: 	correlated_columns.insert(correlated_columns.begin(), std::move(info));
259: 	return false;
260: }
261: 
262: static unique_ptr<Expression> PlanCorrelatedSubquery(Binder &binder, BoundSubqueryExpression &expr,
263:                                                      unique_ptr<LogicalOperator> &root,
264:                                                      unique_ptr<LogicalOperator> plan) {
265: 	auto &correlated_columns = expr.binder->correlated_columns;
266: 	// FIXME: there should be a way of disabling decorrelation for ANY queries as well, but not for now...
267: 	bool perform_delim =
268: 	    expr.subquery_type == SubqueryType::ANY ? true : PerformDuplicateElimination(binder, correlated_columns);
269: 	D_ASSERT(expr.IsCorrelated());
270: 	// correlated subquery
271: 	// for a more in-depth explanation of this code, read the paper "Unnesting Arbitrary Subqueries"
272: 	// we handle three types of correlated subqueries: Scalar, EXISTS and ANY
273: 	// all three cases are very similar with some minor changes (mainly the type of join performed at the end)
274: 	switch (expr.subquery_type) {
275: 	case SubqueryType::SCALAR: {
276: 		// correlated SCALAR query
277: 		// first push a DUPLICATE ELIMINATED join
278: 		// a duplicate eliminated join creates a duplicate eliminated copy of the LHS
279: 		// and pushes it into any DUPLICATE_ELIMINATED SCAN operators on the RHS
280: 
281: 		// in the SCALAR case, we create a SINGLE join (because we are only interested in obtaining the value)
282: 		// NULL values are equal in this join because we join on the correlated columns ONLY
283: 		// and e.g. in the query: SELECT (SELECT 42 FROM integers WHERE i1.i IS NULL LIMIT 1) FROM integers i1;
284: 		// the input value NULL will generate the value 42, and we need to join NULL on the LHS with NULL on the RHS
285: 		// the left side is the original plan
286: 		// this is the side that will be duplicate eliminated and pushed into the RHS
287: 		auto delim_join =
288: 		    CreateDuplicateEliminatedJoin(correlated_columns, JoinType::SINGLE, std::move(root), perform_delim);
289: 
290: 		// the right side initially is a DEPENDENT join between the duplicate eliminated scan and the subquery
291: 		// HOWEVER: we do not explicitly create the dependent join
292: 		// instead, we eliminate the dependent join by pushing it down into the right side of the plan
293: 		FlattenDependentJoins flatten(binder, correlated_columns, perform_delim);
294: 
295: 		// first we check which logical operators have correlated expressions in the first place
296: 		flatten.DetectCorrelatedExpressions(*plan);
297: 		// now we push the dependent join down
298: 		auto dependent_join = flatten.PushDownDependentJoin(std::move(plan));
299: 
300: 		// now the dependent join is fully eliminated
301: 		// we only need to create the join conditions between the LHS and the RHS
302: 		// fetch the set of columns
303: 		auto plan_columns = dependent_join->GetColumnBindings();
304: 
305: 		// now create the join conditions
306: 		CreateDelimJoinConditions(*delim_join, correlated_columns, plan_columns, flatten.delim_offset, perform_delim);
307: 		delim_join->AddChild(std::move(dependent_join));
308: 		root = std::move(delim_join);
309: 		// finally push the BoundColumnRefExpression referring to the data element returned by the join
310: 		return make_uniq<BoundColumnRefExpression>(expr.GetName(), expr.return_type, plan_columns[flatten.data_offset]);
311: 	}
312: 	case SubqueryType::EXISTS: {
313: 		// correlated EXISTS query
314: 		// this query is similar to the correlated SCALAR query, except we use a MARK join here
315: 		idx_t mark_index = binder.GenerateTableIndex();
316: 		auto delim_join =
317: 		    CreateDuplicateEliminatedJoin(correlated_columns, JoinType::MARK, std::move(root), perform_delim);
318: 		delim_join->mark_index = mark_index;
319: 		// RHS
320: 		FlattenDependentJoins flatten(binder, correlated_columns, perform_delim, true);
321: 		flatten.DetectCorrelatedExpressions(*plan);
322: 		auto dependent_join = flatten.PushDownDependentJoin(std::move(plan));
323: 
324: 		// fetch the set of columns
325: 		auto plan_columns = dependent_join->GetColumnBindings();
326: 
327: 		// now we create the join conditions between the dependent join and the original table
328: 		CreateDelimJoinConditions(*delim_join, correlated_columns, plan_columns, flatten.delim_offset, perform_delim);
329: 		delim_join->AddChild(std::move(dependent_join));
330: 		root = std::move(delim_join);
331: 		// finally push the BoundColumnRefExpression referring to the marker
332: 		return make_uniq<BoundColumnRefExpression>(expr.GetName(), expr.return_type, ColumnBinding(mark_index, 0));
333: 	}
334: 	default: {
335: 		D_ASSERT(expr.subquery_type == SubqueryType::ANY);
336: 		// correlated ANY query
337: 		// this query is similar to the correlated SCALAR query
338: 		// however, in this case we push a correlated MARK join
339: 		// note that in this join null values are NOT equal for ALL columns, but ONLY for the correlated columns
340: 		// the correlated mark join handles this case by itself
341: 		// as the MARK join has one extra join condition (the original condition, of the ANY expression, e.g.
342: 		// [i=ANY(...)])
343: 		idx_t mark_index = binder.GenerateTableIndex();
344: 		auto delim_join =
345: 		    CreateDuplicateEliminatedJoin(correlated_columns, JoinType::MARK, std::move(root), perform_delim);
346: 		delim_join->mark_index = mark_index;
347: 		// RHS
348: 		FlattenDependentJoins flatten(binder, correlated_columns, true, true);
349: 		flatten.DetectCorrelatedExpressions(*plan);
350: 		auto dependent_join = flatten.PushDownDependentJoin(std::move(plan));
351: 
352: 		// fetch the columns
353: 		auto plan_columns = dependent_join->GetColumnBindings();
354: 
355: 		// now we create the join conditions between the dependent join and the original table
356: 		CreateDelimJoinConditions(*delim_join, correlated_columns, plan_columns, flatten.delim_offset, perform_delim);
357: 		// add the actual condition based on the ANY/ALL predicate
358: 		JoinCondition compare_cond;
359: 		compare_cond.left = std::move(expr.child);
360: 		compare_cond.right = BoundCastExpression::AddDefaultCastToType(
361: 		    make_uniq<BoundColumnRefExpression>(expr.child_type, plan_columns[0]), expr.child_target);
362: 		compare_cond.comparison = expr.comparison_type;
363: 		delim_join->conditions.push_back(std::move(compare_cond));
364: 
365: 		delim_join->AddChild(std::move(dependent_join));
366: 		root = std::move(delim_join);
367: 		// finally push the BoundColumnRefExpression referring to the marker
368: 		return make_uniq<BoundColumnRefExpression>(expr.GetName(), expr.return_type, ColumnBinding(mark_index, 0));
369: 	}
370: 	}
371: }
372: 
373: void RecursiveDependentJoinPlanner::VisitOperator(LogicalOperator &op) {
374: 	if (!op.children.empty()) {
375: 		// Collect all recursive CTEs during recursive descend
376: 		if (op.type == LogicalOperatorType::LOGICAL_RECURSIVE_CTE) {
377: 			auto &rec_cte = op.Cast<LogicalRecursiveCTE>();
378: 			binder.recursive_ctes[rec_cte.table_index] = &op;
379: 		}
380: 		root = std::move(op.children[0]);
381: 		D_ASSERT(root);
382: 		if (root->type == LogicalOperatorType::LOGICAL_DEPENDENT_JOIN) {
383: 			// Found a dependent join, flatten it
384: 			auto &new_root = root->Cast<LogicalDependentJoin>();
385: 			root = binder.PlanLateralJoin(std::move(new_root.children[0]), std::move(new_root.children[1]),
386: 			                              new_root.correlated_columns, new_root.join_type,
387: 			                              std::move(new_root.join_condition));
388: 		}
389: 		VisitOperatorExpressions(op);
390: 		op.children[0] = std::move(root);
391: 		for (idx_t i = 0; i < op.children.size(); i++) {
392: 			D_ASSERT(op.children[i]);
393: 			VisitOperator(*op.children[i]);
394: 		}
395: 	}
396: }
397: 
398: unique_ptr<Expression> RecursiveDependentJoinPlanner::VisitReplace(BoundSubqueryExpression &expr,
399:                                                                    unique_ptr<Expression> *expr_ptr) {
400: 	return binder.PlanSubquery(expr, root);
401: }
402: 
403: unique_ptr<Expression> Binder::PlanSubquery(BoundSubqueryExpression &expr, unique_ptr<LogicalOperator> &root) {
404: 	D_ASSERT(root);
405: 	// first we translate the QueryNode of the subquery into a logical plan
406: 	// note that we do not plan nested subqueries yet
407: 	auto sub_binder = Binder::CreateBinder(context, this);
408: 	sub_binder->is_outside_flattened = false;
409: 	auto subquery_root = sub_binder->CreatePlan(*expr.subquery);
410: 	D_ASSERT(subquery_root);
411: 
412: 	// now we actually flatten the subquery
413: 	auto plan = std::move(subquery_root);
414: 
415: 	unique_ptr<Expression> result_expression;
416: 	if (!expr.IsCorrelated()) {
417: 		result_expression = PlanUncorrelatedSubquery(*this, expr, root, std::move(plan));
418: 	} else {
419: 		result_expression = PlanCorrelatedSubquery(*this, expr, root, std::move(plan));
420: 	}
421: 	// finally, we recursively plan the nested subqueries (if there are any)
422: 	if (sub_binder->has_unplanned_dependent_joins) {
423: 		RecursiveDependentJoinPlanner plan(*this);
424: 		plan.VisitOperator(*root);
425: 	}
426: 	return result_expression;
427: }
428: 
429: void Binder::PlanSubqueries(unique_ptr<Expression> &expr_ptr, unique_ptr<LogicalOperator> &root) {
430: 	if (!expr_ptr) {
431: 		return;
432: 	}
433: 	auto &expr = *expr_ptr;
434: 	// first visit the children of the node, if any
435: 	ExpressionIterator::EnumerateChildren(expr, [&](unique_ptr<Expression> &expr) { PlanSubqueries(expr, root); });
436: 
437: 	// check if this is a subquery node
438: 	if (expr.expression_class == ExpressionClass::BOUND_SUBQUERY) {
439: 		auto &subquery = expr.Cast<BoundSubqueryExpression>();
440: 		// subquery node! plan it
441: 		if (!is_outside_flattened) {
442: 			// detected a nested correlated subquery
443: 			// we don't plan it yet here, we are currently planning a subquery
444: 			// nested subqueries will only be planned AFTER the current subquery has been flattened entirely
445: 			has_unplanned_dependent_joins = true;
446: 			return;
447: 		}
448: 		expr_ptr = PlanSubquery(subquery, root);
449: 	}
450: }
451: 
452: unique_ptr<LogicalOperator> Binder::PlanLateralJoin(unique_ptr<LogicalOperator> left, unique_ptr<LogicalOperator> right,
453:                                                     vector<CorrelatedColumnInfo> &correlated, JoinType join_type,
454:                                                     unique_ptr<Expression> condition) {
455: 	// scan the right operator for correlated columns
456: 	// correlated LATERAL JOIN
457: 	vector<JoinCondition> conditions;
458: 	vector<unique_ptr<Expression>> arbitrary_expressions;
459: 	if (condition) {
460: 		// extract join conditions, if there are any
461: 		LogicalComparisonJoin::ExtractJoinConditions(context, join_type, JoinRefType::REGULAR, left, right,
462: 		                                             std::move(condition), conditions, arbitrary_expressions);
463: 	}
464: 
465: 	auto perform_delim = PerformDuplicateElimination(*this, correlated);
466: 	auto delim_join = CreateDuplicateEliminatedJoin(correlated, join_type, std::move(left), perform_delim);
467: 
468: 	FlattenDependentJoins flatten(*this, correlated, perform_delim);
469: 
470: 	// first we check which logical operators have correlated expressions in the first place
471: 	flatten.DetectCorrelatedExpressions(*right, true);
472: 	// now we push the dependent join down
473: 	auto dependent_join = flatten.PushDownDependentJoin(std::move(right), join_type != JoinType::INNER);
474: 
475: 	// now the dependent join is fully eliminated
476: 	// we only need to create the join conditions between the LHS and the RHS
477: 	// fetch the set of columns
478: 	auto plan_columns = dependent_join->GetColumnBindings();
479: 
480: 	// in case of a materialized CTE, the output is defined by the second children operator
481: 	if (dependent_join->type == LogicalOperatorType::LOGICAL_MATERIALIZED_CTE) {
482: 		plan_columns = dependent_join->children[1]->GetColumnBindings();
483: 	}
484: 
485: 	// now create the join conditions
486: 	// start off with the conditions that were passed in (if any)
487: 	D_ASSERT(delim_join->conditions.empty());
488: 	delim_join->conditions = std::move(conditions);
489: 	// then add the delim join conditions
490: 	CreateDelimJoinConditions(*delim_join, correlated, plan_columns, flatten.delim_offset, perform_delim);
491: 	delim_join->AddChild(std::move(dependent_join));
492: 
493: 	// check if there are any arbitrary expressions left
494: 	if (!arbitrary_expressions.empty()) {
495: 		// we can only evaluate scalar arbitrary expressions for inner joins
496: 		if (join_type != JoinType::INNER) {
497: 			throw BinderException(
498: 			    "Join condition for non-inner LATERAL JOIN must be a comparison between the left and right side");
499: 		}
500: 		auto filter = make_uniq<LogicalFilter>();
501: 		filter->expressions = std::move(arbitrary_expressions);
502: 		filter->AddChild(std::move(delim_join));
503: 		return std::move(filter);
504: 	}
505: 	return std::move(delim_join);
506: }
507: 
508: } // namespace duckdb
[end of src/planner/binder/query_node/plan_subquery.cpp]
[start of src/planner/binder/statement/bind_create_table.cpp]
1: #include "duckdb/parser/constraints/list.hpp"
2: #include "duckdb/parser/expression/cast_expression.hpp"
3: #include "duckdb/planner/binder.hpp"
4: #include "duckdb/planner/constraints/list.hpp"
5: #include "duckdb/planner/expression/bound_constant_expression.hpp"
6: #include "duckdb/planner/expression/bound_function_expression.hpp"
7: #include "duckdb/planner/expression_binder/check_binder.hpp"
8: #include "duckdb/planner/expression_binder/constant_binder.hpp"
9: #include "duckdb/planner/parsed_data/bound_create_table_info.hpp"
10: #include "duckdb/catalog/catalog_entry/type_catalog_entry.hpp"
11: #include "duckdb/catalog/dependency_manager.hpp"
12: #include "duckdb/function/table/table_scan.hpp"
13: #include "duckdb/planner/operator/logical_get.hpp"
14: #include "duckdb/common/string.hpp"
15: #include "duckdb/common/queue.hpp"
16: #include "duckdb/parser/expression/list.hpp"
17: #include "duckdb/common/index_map.hpp"
18: #include "duckdb/planner/expression_iterator.hpp"
19: #include "duckdb/planner/expression_binder/index_binder.hpp"
20: #include "duckdb/parser/parsed_data/create_index_info.hpp"
21: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
22: 
23: namespace duckdb {
24: 
25: static void CreateColumnDependencyManager(BoundCreateTableInfo &info) {
26: 	auto &base = info.base->Cast<CreateTableInfo>();
27: 	for (auto &col : base.columns.Logical()) {
28: 		if (!col.Generated()) {
29: 			continue;
30: 		}
31: 		info.column_dependency_manager.AddGeneratedColumn(col, base.columns);
32: 	}
33: }
34: 
35: vector<unique_ptr<BoundConstraint>> Binder::BindConstraints(ClientContext &context,
36:                                                             const vector<unique_ptr<Constraint>> &constraints,
37:                                                             const string &table_name, const ColumnList &columns) {
38: 	auto binder = Binder::CreateBinder(context);
39: 	return binder->BindConstraints(constraints, table_name, columns);
40: }
41: 
42: vector<unique_ptr<BoundConstraint>> Binder::BindConstraints(const TableCatalogEntry &table) {
43: 	return BindConstraints(table.GetConstraints(), table.name, table.GetColumns());
44: }
45: 
46: vector<unique_ptr<BoundConstraint>> Binder::BindConstraints(const vector<unique_ptr<Constraint>> &constraints,
47:                                                             const string &table_name, const ColumnList &columns) {
48: 	vector<unique_ptr<BoundConstraint>> bound_constraints;
49: 	for (const auto &constr : constraints) {
50: 		bound_constraints.push_back(BindConstraint(*constr, table_name, columns));
51: 	}
52: 	return bound_constraints;
53: }
54: 
55: vector<unique_ptr<BoundConstraint>> Binder::BindNewConstraints(vector<unique_ptr<Constraint>> &constraints,
56:                                                                const string &table_name, const ColumnList &columns) {
57: 	auto bound_constraints = BindConstraints(constraints, table_name, columns);
58: 
59: 	// Handle PK and NOT NULL constraints.
60: 	bool has_primary_key = false;
61: 	physical_index_set_t not_null_columns;
62: 	vector<PhysicalIndex> primary_keys;
63: 
64: 	for (const auto &bound_constr : bound_constraints) {
65: 		switch (bound_constr->type) {
66: 		case ConstraintType::NOT_NULL: {
67: 			auto &not_null = bound_constr->Cast<BoundNotNullConstraint>();
68: 			not_null_columns.insert(not_null.index);
69: 			break;
70: 		}
71: 		case ConstraintType::UNIQUE: {
72: 			const auto &unique = bound_constr->Cast<BoundUniqueConstraint>();
73: 			if (unique.is_primary_key) {
74: 				if (has_primary_key) {
75: 					throw ParserException("table \"%s\" has more than one primary key", table_name);
76: 				}
77: 				has_primary_key = true;
78: 				primary_keys = unique.keys;
79: 			}
80: 			break;
81: 		}
82: 		default:
83: 			break;
84: 		}
85: 	}
86: 
87: 	if (has_primary_key) {
88: 		// Create a PK constraint, and a NOT NULL constraint for each indexed column.
89: 		for (auto &column_index : primary_keys) {
90: 			if (not_null_columns.count(column_index) != 0) {
91: 				continue;
92: 			}
93: 
94: 			auto logical_index = columns.PhysicalToLogical(column_index);
95: 			constraints.push_back(make_uniq<NotNullConstraint>(logical_index));
96: 			bound_constraints.push_back(make_uniq<BoundNotNullConstraint>(column_index));
97: 		}
98: 	}
99: 
100: 	return bound_constraints;
101: }
102: 
103: unique_ptr<BoundConstraint> BindCheckConstraint(Binder &binder, Constraint &constraint, const string &table,
104:                                                 const ColumnList &columns) {
105: 	auto bound_constraint = make_uniq<BoundCheckConstraint>();
106: 	auto &bound_check = bound_constraint->Cast<BoundCheckConstraint>();
107: 
108: 	// Bind the CHECK expression.
109: 	CheckBinder check_binder(binder, binder.context, table, columns, bound_check.bound_columns);
110: 	auto &check = constraint.Cast<CheckConstraint>();
111: 
112: 	// Create a copy of the unbound expression because binding can invalidate it.
113: 	auto unbound_expression = check.expression->Copy();
114: 
115: 	// Bind the constraint and reset the original expression.
116: 	bound_check.expression = check_binder.Bind(check.expression);
117: 	check.expression = std::move(unbound_expression);
118: 	return std::move(bound_constraint);
119: }
120: 
121: unique_ptr<BoundConstraint> Binder::BindUniqueConstraint(Constraint &constraint, const string &table,
122:                                                          const ColumnList &columns) {
123: 	auto &unique = constraint.Cast<UniqueConstraint>();
124: 
125: 	// Resolve the columns.
126: 	vector<PhysicalIndex> indexes;
127: 	physical_index_set_t index_set;
128: 
129: 	// HasIndex refers to a column index, not an index(-structure).
130: 	// If set, then the UNIQUE constraint is defined on a single column.
131: 	if (unique.HasIndex()) {
132: 		auto &col = columns.GetColumn(unique.GetIndex());
133: 		unique.SetColumnName(col.Name());
134: 		indexes.push_back(col.Physical());
135: 		index_set.insert(col.Physical());
136: 		return make_uniq<BoundUniqueConstraint>(std::move(indexes), std::move(index_set), unique.IsPrimaryKey());
137: 	}
138: 
139: 	// The UNIQUE constraint is defined on a list of columns.
140: 	for (auto &col_name : unique.GetColumnNames()) {
141: 		if (!columns.ColumnExists(col_name)) {
142: 			throw CatalogException("table \"%s\" does not have a column named \"%s\"", table, col_name);
143: 		}
144: 		auto &col = columns.GetColumn(col_name);
145: 		if (col.Generated()) {
146: 			throw BinderException("cannot create a PRIMARY KEY on a generated column: %s", col.GetName());
147: 		}
148: 
149: 		auto physical_index = col.Physical();
150: 		if (index_set.find(physical_index) != index_set.end()) {
151: 			throw ParserException("column \"%s\" appears twice in primary key constraint", col_name);
152: 		}
153: 		indexes.push_back(physical_index);
154: 		index_set.insert(physical_index);
155: 	}
156: 
157: 	return make_uniq<BoundUniqueConstraint>(std::move(indexes), std::move(index_set), unique.IsPrimaryKey());
158: }
159: 
160: unique_ptr<BoundConstraint> BindForeignKey(Constraint &constraint) {
161: 	auto &fk = constraint.Cast<ForeignKeyConstraint>();
162: 	D_ASSERT((fk.info.type == ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE && !fk.info.pk_keys.empty()) ||
163: 	         (fk.info.type == ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE && !fk.info.pk_keys.empty()) ||
164: 	         fk.info.type == ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE);
165: 
166: 	physical_index_set_t pk_key_set;
167: 	for (auto &pk_key : fk.info.pk_keys) {
168: 		if (pk_key_set.find(pk_key) != pk_key_set.end()) {
169: 			throw ParserException("duplicate primary key referenced in FOREIGN KEY constraint");
170: 		}
171: 		pk_key_set.insert(pk_key);
172: 	}
173: 
174: 	physical_index_set_t fk_key_set;
175: 	for (auto &fk_key : fk.info.fk_keys) {
176: 		if (fk_key_set.find(fk_key) != fk_key_set.end()) {
177: 			throw ParserException("duplicate key specified in FOREIGN KEY constraint");
178: 		}
179: 		fk_key_set.insert(fk_key);
180: 	}
181: 
182: 	return make_uniq<BoundForeignKeyConstraint>(fk.info, std::move(pk_key_set), std::move(fk_key_set));
183: }
184: 
185: unique_ptr<BoundConstraint> Binder::BindConstraint(Constraint &constraint, const string &table,
186:                                                    const ColumnList &columns) {
187: 	switch (constraint.type) {
188: 	case ConstraintType::CHECK: {
189: 		return BindCheckConstraint(*this, constraint, table, columns);
190: 	}
191: 	case ConstraintType::NOT_NULL: {
192: 		auto &not_null = constraint.Cast<NotNullConstraint>();
193: 		auto &col = columns.GetColumn(not_null.index);
194: 		return make_uniq<BoundNotNullConstraint>(col.Physical());
195: 	}
196: 	case ConstraintType::UNIQUE: {
197: 		return BindUniqueConstraint(constraint, table, columns);
198: 	}
199: 	case ConstraintType::FOREIGN_KEY: {
200: 		return BindForeignKey(constraint);
201: 	}
202: 	default:
203: 		throw NotImplementedException("unrecognized constraint type in bind");
204: 	}
205: }
206: 
207: void Binder::BindGeneratedColumns(BoundCreateTableInfo &info) {
208: 	auto &base = info.base->Cast<CreateTableInfo>();
209: 
210: 	vector<string> names;
211: 	vector<LogicalType> types;
212: 
213: 	D_ASSERT(base.type == CatalogType::TABLE_ENTRY);
214: 	for (auto &col : base.columns.Logical()) {
215: 		names.push_back(col.Name());
216: 		types.push_back(col.Type());
217: 	}
218: 	auto table_index = GenerateTableIndex();
219: 
220: 	// Create a new binder because we dont need (or want) these bindings in this scope
221: 	auto binder = Binder::CreateBinder(context);
222: 	binder->SetCatalogLookupCallback(entry_retriever.GetCallback());
223: 	binder->bind_context.AddGenericBinding(table_index, base.table, names, types);
224: 	auto expr_binder = ExpressionBinder(*binder, context);
225: 	ErrorData ignore;
226: 	auto table_binding = binder->bind_context.GetBinding(base.table, ignore);
227: 	D_ASSERT(table_binding && !ignore.HasError());
228: 
229: 	auto bind_order = info.column_dependency_manager.GetBindOrder(base.columns);
230: 	logical_index_set_t bound_indices;
231: 
232: 	while (!bind_order.empty()) {
233: 		auto i = bind_order.top();
234: 		bind_order.pop();
235: 		auto &col = base.columns.GetColumnMutable(i);
236: 
237: 		//! Already bound this previously
238: 		//! This can not be optimized out of the GetBindOrder function
239: 		//! These occurrences happen because we need to make sure that ALL dependencies of a column are resolved before
240: 		//! it gets resolved
241: 		if (bound_indices.count(i)) {
242: 			continue;
243: 		}
244: 		D_ASSERT(col.Generated());
245: 		auto expression = col.GeneratedExpression().Copy();
246: 
247: 		auto bound_expression = expr_binder.Bind(expression);
248: 		D_ASSERT(bound_expression);
249: 		if (bound_expression->HasSubquery()) {
250: 			throw BinderException("Failed to bind generated column '%s' because the expression contains a subquery",
251: 			                      col.Name());
252: 		}
253: 		if (col.Type().id() == LogicalTypeId::ANY) {
254: 			// Do this before changing the type, so we know it's the first time the type is set
255: 			col.ChangeGeneratedExpressionType(bound_expression->return_type);
256: 			col.SetType(bound_expression->return_type);
257: 
258: 			// Update the type in the binding, for future expansions
259: 			table_binding->types[i.index] = col.Type();
260: 		}
261: 		bound_indices.insert(i);
262: 	}
263: }
264: 
265: void Binder::BindDefaultValues(const ColumnList &columns, vector<unique_ptr<Expression>> &bound_defaults) {
266: 	for (auto &column : columns.Physical()) {
267: 		unique_ptr<Expression> bound_default;
268: 		if (column.HasDefaultValue()) {
269: 			// we bind a copy of the DEFAULT value because binding is destructive
270: 			// and we want to keep the original expression around for serialization
271: 			auto default_copy = column.DefaultValue().Copy();
272: 			if (default_copy->HasParameter()) {
273: 				throw BinderException("DEFAULT values cannot contain parameters");
274: 			}
275: 			ConstantBinder default_binder(*this, context, "DEFAULT value");
276: 			default_binder.target_type = column.Type();
277: 			bound_default = default_binder.Bind(default_copy);
278: 		} else {
279: 			// no default value specified: push a default value of constant null
280: 			bound_default = make_uniq<BoundConstantExpression>(Value(column.Type()));
281: 		}
282: 		bound_defaults.push_back(std::move(bound_default));
283: 	}
284: }
285: 
286: static void ExtractExpressionDependencies(Expression &expr, LogicalDependencyList &dependencies) {
287: 	if (expr.type == ExpressionType::BOUND_FUNCTION) {
288: 		auto &function = expr.Cast<BoundFunctionExpression>();
289: 		if (function.function.dependency) {
290: 			function.function.dependency(function, dependencies);
291: 		}
292: 	}
293: 	ExpressionIterator::EnumerateChildren(
294: 	    expr, [&](Expression &child) { ExtractExpressionDependencies(child, dependencies); });
295: }
296: 
297: static void ExtractDependencies(BoundCreateTableInfo &info, vector<unique_ptr<Expression>> &defaults,
298:                                 vector<unique_ptr<BoundConstraint>> &constraints) {
299: 	for (auto &default_value : defaults) {
300: 		if (default_value) {
301: 			ExtractExpressionDependencies(*default_value, info.dependencies);
302: 		}
303: 	}
304: 	for (auto &constraint : constraints) {
305: 		if (constraint->type == ConstraintType::CHECK) {
306: 			auto &bound_check = constraint->Cast<BoundCheckConstraint>();
307: 			ExtractExpressionDependencies(*bound_check.expression, info.dependencies);
308: 		}
309: 	}
310: }
311: 
312: unique_ptr<BoundCreateTableInfo> Binder::BindCreateTableInfo(unique_ptr<CreateInfo> info, SchemaCatalogEntry &schema) {
313: 	vector<unique_ptr<Expression>> bound_defaults;
314: 	return BindCreateTableInfo(std::move(info), schema, bound_defaults);
315: }
316: 
317: unique_ptr<BoundCreateTableInfo> Binder::BindCreateTableCheckpoint(unique_ptr<CreateInfo> info,
318:                                                                    SchemaCatalogEntry &schema) {
319: 	auto result = make_uniq<BoundCreateTableInfo>(schema, std::move(info));
320: 	CreateColumnDependencyManager(*result);
321: 	return result;
322: }
323: 
324: unique_ptr<BoundCreateTableInfo> Binder::BindCreateTableInfo(unique_ptr<CreateInfo> info, SchemaCatalogEntry &schema,
325:                                                              vector<unique_ptr<Expression>> &bound_defaults) {
326: 	auto &base = info->Cast<CreateTableInfo>();
327: 	auto result = make_uniq<BoundCreateTableInfo>(schema, std::move(info));
328: 	auto &dependencies = result->dependencies;
329: 
330: 	vector<unique_ptr<BoundConstraint>> bound_constraints;
331: 	if (base.query) {
332: 		// construct the result object
333: 		auto query_obj = Bind(*base.query);
334: 		base.query.reset();
335: 		result->query = std::move(query_obj.plan);
336: 
337: 		// construct the set of columns based on the names and types of the query
338: 		auto &names = query_obj.names;
339: 		auto &sql_types = query_obj.types;
340: 		// e.g. create table (col1 ,col2) as QUERY
341: 		// col1 and col2 are the target_col_names
342: 		auto target_col_names = base.columns.GetColumnNames();
343: 		// TODO check  types and target_col_names are mismatch in size
344: 		D_ASSERT(names.size() == sql_types.size());
345: 		base.columns.SetAllowDuplicates(true);
346: 		if (!target_col_names.empty()) {
347: 			if (target_col_names.size() > sql_types.size()) {
348: 				throw BinderException("Target table has more colum names than query result.");
349: 			} else if (target_col_names.size() < sql_types.size()) {
350: 				// filled the target_col_names with the name of query names
351: 				for (idx_t i = target_col_names.size(); i < sql_types.size(); i++) {
352: 					target_col_names.push_back(names[i]);
353: 				}
354: 			}
355: 			ColumnList new_colums;
356: 			for (idx_t i = 0; i < target_col_names.size(); i++) {
357: 				new_colums.AddColumn(ColumnDefinition(target_col_names[i], sql_types[i]));
358: 			}
359: 			base.columns = std::move(new_colums);
360: 		} else {
361: 			for (idx_t i = 0; i < names.size(); i++) {
362: 				base.columns.AddColumn(ColumnDefinition(names[i], sql_types[i]));
363: 			}
364: 		}
365: 	} else {
366: 		SetCatalogLookupCallback([&dependencies, &schema](CatalogEntry &entry) {
367: 			if (&schema.ParentCatalog() != &entry.ParentCatalog()) {
368: 				// Don't register dependencies between catalogs
369: 				return;
370: 			}
371: 			dependencies.AddDependency(entry);
372: 		});
373: 		CreateColumnDependencyManager(*result);
374: 		// bind the generated column expressions
375: 		BindGeneratedColumns(*result);
376: 		// bind any constraints
377: 		bound_constraints = BindNewConstraints(base.constraints, base.table, base.columns);
378: 		// bind the default values
379: 		BindDefaultValues(base.columns, bound_defaults);
380: 	}
381: 	// extract dependencies from any default values or CHECK constraints
382: 	ExtractDependencies(*result, bound_defaults, bound_constraints);
383: 
384: 	if (base.columns.PhysicalColumnCount() == 0) {
385: 		throw BinderException("Creating a table without physical (non-generated) columns is not supported");
386: 	}
387: 	// bind collations to detect any unsupported collation errors
388: 	for (idx_t i = 0; i < base.columns.PhysicalColumnCount(); i++) {
389: 		auto &column = base.columns.GetColumnMutable(PhysicalIndex(i));
390: 		if (column.Type().id() == LogicalTypeId::VARCHAR) {
391: 			ExpressionBinder::TestCollation(context, StringType::GetCollation(column.Type()));
392: 		}
393: 		BindLogicalType(column.TypeMutable(), &result->schema.catalog, result->schema.name);
394: 	}
395: 	result->dependencies.VerifyDependencies(schema.catalog, result->Base().table);
396: 
397: 	auto &properties = GetStatementProperties();
398: 	properties.allow_stream_result = false;
399: 	return result;
400: }
401: 
402: unique_ptr<BoundCreateTableInfo> Binder::BindCreateTableInfo(unique_ptr<CreateInfo> info) {
403: 	auto &base = info->Cast<CreateTableInfo>();
404: 	auto &schema = BindCreateSchema(base);
405: 	return BindCreateTableInfo(std::move(info), schema);
406: }
407: 
408: } // namespace duckdb
[end of src/planner/binder/statement/bind_create_table.cpp]
[start of src/planner/binder/statement/bind_insert.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: #include "duckdb/parser/expression/constant_expression.hpp"
3: #include "duckdb/parser/expression/function_expression.hpp"
4: #include "duckdb/parser/statement/insert_statement.hpp"
5: #include "duckdb/parser/query_node/select_node.hpp"
6: #include "duckdb/parser/tableref/expressionlistref.hpp"
7: #include "duckdb/planner/binder.hpp"
8: #include "duckdb/planner/expression_binder/insert_binder.hpp"
9: #include "duckdb/planner/operator/logical_insert.hpp"
10: #include "duckdb/planner/operator/logical_get.hpp"
11: #include "duckdb/common/string_util.hpp"
12: #include "duckdb/function/table/table_scan.hpp"
13: #include "duckdb/planner/operator/logical_dummy_scan.hpp"
14: #include "duckdb/planner/operator/logical_projection.hpp"
15: #include "duckdb/planner/expression_iterator.hpp"
16: #include "duckdb/planner/expression_binder/where_binder.hpp"
17: #include "duckdb/planner/expression_binder/update_binder.hpp"
18: #include "duckdb/parser/statement/update_statement.hpp"
19: #include "duckdb/planner/expression/bound_default_expression.hpp"
20: #include "duckdb/catalog/catalog_entry/index_catalog_entry.hpp"
21: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
22: #include "duckdb/planner/bound_tableref.hpp"
23: #include "duckdb/planner/tableref/bound_basetableref.hpp"
24: #include "duckdb/planner/tableref/bound_dummytableref.hpp"
25: #include "duckdb/parser/parsed_expression_iterator.hpp"
26: #include "duckdb/storage/table_storage_info.hpp"
27: #include "duckdb/parser/tableref/basetableref.hpp"
28: 
29: namespace duckdb {
30: 
31: static void CheckInsertColumnCountMismatch(idx_t expected_columns, idx_t result_columns, bool columns_provided,
32:                                            const char *tname) {
33: 	if (result_columns != expected_columns) {
34: 		string msg = StringUtil::Format(!columns_provided ? "table %s has %lld columns but %lld values were supplied"
35: 		                                                  : "Column name/value mismatch for insert on %s: "
36: 		                                                    "expected %lld columns but %lld values were supplied",
37: 		                                tname, expected_columns, result_columns);
38: 		throw BinderException(msg);
39: 	}
40: }
41: 
42: unique_ptr<ParsedExpression> ExpandDefaultExpression(const ColumnDefinition &column) {
43: 	if (column.HasDefaultValue()) {
44: 		return column.DefaultValue().Copy();
45: 	} else {
46: 		return make_uniq<ConstantExpression>(Value(column.Type()));
47: 	}
48: }
49: 
50: void ReplaceDefaultExpression(unique_ptr<ParsedExpression> &expr, const ColumnDefinition &column) {
51: 	D_ASSERT(expr->type == ExpressionType::VALUE_DEFAULT);
52: 	expr = ExpandDefaultExpression(column);
53: }
54: 
55: void ExpressionBinder::DoUpdateSetQualifyInLambda(FunctionExpression &function, const string &table_name,
56:                                                   vector<unordered_set<string>> &lambda_params) {
57: 
58: 	for (auto &child : function.children) {
59: 		if (child->expression_class != ExpressionClass::LAMBDA) {
60: 			DoUpdateSetQualify(child, table_name, lambda_params);
61: 			continue;
62: 		}
63: 
64: 		// Special-handling for LHS lambda parameters.
65: 		// We do not qualify them, and we add them to the lambda_params vector.
66: 		auto &lambda_expr = child->Cast<LambdaExpression>();
67: 		string error_message;
68: 		auto column_ref_expressions = lambda_expr.ExtractColumnRefExpressions(error_message);
69: 
70: 		if (!error_message.empty()) {
71: 			// Possibly a JSON function, qualify both LHS and RHS.
72: 			ParsedExpressionIterator::EnumerateChildren(*lambda_expr.lhs, [&](unique_ptr<ParsedExpression> &child) {
73: 				DoUpdateSetQualify(child, table_name, lambda_params);
74: 			});
75: 			ParsedExpressionIterator::EnumerateChildren(*lambda_expr.expr, [&](unique_ptr<ParsedExpression> &child) {
76: 				DoUpdateSetQualify(child, table_name, lambda_params);
77: 			});
78: 			continue;
79: 		}
80: 
81: 		// Push the lambda parameter names of this level.
82: 		lambda_params.emplace_back();
83: 		for (const auto &column_ref_expr : column_ref_expressions) {
84: 			const auto &column_ref = column_ref_expr.get().Cast<ColumnRefExpression>();
85: 			lambda_params.back().emplace(column_ref.GetName());
86: 		}
87: 
88: 		// Only qualify in the RHS of the expression.
89: 		ParsedExpressionIterator::EnumerateChildren(*lambda_expr.expr, [&](unique_ptr<ParsedExpression> &child) {
90: 			DoUpdateSetQualify(child, table_name, lambda_params);
91: 		});
92: 
93: 		lambda_params.pop_back();
94: 	}
95: }
96: 
97: void ExpressionBinder::DoUpdateSetQualify(unique_ptr<ParsedExpression> &expr, const string &table_name,
98:                                           vector<unordered_set<string>> &lambda_params) {
99: 
100: 	// We avoid ambiguity with EXCLUDED columns by qualifying all column references.
101: 	switch (expr->GetExpressionClass()) {
102: 	case ExpressionClass::COLUMN_REF: {
103: 		auto &col_ref = expr->Cast<ColumnRefExpression>();
104: 		if (col_ref.IsQualified()) {
105: 			return;
106: 		}
107: 
108: 		// Don't qualify lambda parameters.
109: 		if (LambdaExpression::IsLambdaParameter(lambda_params, col_ref.GetName())) {
110: 			return;
111: 		}
112: 
113: 		// Qualify the column reference.
114: 		expr = make_uniq<ColumnRefExpression>(col_ref.GetColumnName(), table_name);
115: 		return;
116: 	}
117: 	case ExpressionClass::FUNCTION: {
118: 		// Special-handling for lambdas, which are inside function expressions.
119: 		auto &function = expr->Cast<FunctionExpression>();
120: 		if (function.IsLambdaFunction()) {
121: 			return DoUpdateSetQualifyInLambda(function, table_name, lambda_params);
122: 		}
123: 		break;
124: 	}
125: 	case ExpressionClass::SUBQUERY: {
126: 		throw BinderException("DO UPDATE SET clause cannot contain a subquery");
127: 	}
128: 	default:
129: 		break;
130: 	}
131: 
132: 	ParsedExpressionIterator::EnumerateChildren(
133: 	    *expr, [&](unique_ptr<ParsedExpression> &child) { DoUpdateSetQualify(child, table_name, lambda_params); });
134: }
135: 
136: // Replace binding.table_index with 'dest' if it's 'source'
137: void ReplaceColumnBindings(Expression &expr, idx_t source, idx_t dest) {
138: 	if (expr.type == ExpressionType::BOUND_COLUMN_REF) {
139: 		auto &bound_columnref = expr.Cast<BoundColumnRefExpression>();
140: 		if (bound_columnref.binding.table_index == source) {
141: 			bound_columnref.binding.table_index = dest;
142: 		}
143: 	}
144: 	ExpressionIterator::EnumerateChildren(
145: 	    expr, [&](unique_ptr<Expression> &child) { ReplaceColumnBindings(*child, source, dest); });
146: }
147: 
148: void Binder::BindDoUpdateSetExpressions(const string &table_alias, LogicalInsert &insert, UpdateSetInfo &set_info,
149:                                         TableCatalogEntry &table, TableStorageInfo &storage_info) {
150: 	D_ASSERT(insert.children.size() == 1);
151: 	D_ASSERT(insert.children[0]->type == LogicalOperatorType::LOGICAL_PROJECTION);
152: 
153: 	vector<column_t> logical_column_ids;
154: 	vector<string> column_names;
155: 	D_ASSERT(set_info.columns.size() == set_info.expressions.size());
156: 
157: 	for (idx_t i = 0; i < set_info.columns.size(); i++) {
158: 		auto &colname = set_info.columns[i];
159: 		auto &expr = set_info.expressions[i];
160: 		if (!table.ColumnExists(colname)) {
161: 			throw BinderException("Referenced update column %s not found in table!", colname);
162: 		}
163: 		auto &column = table.GetColumn(colname);
164: 		if (column.Generated()) {
165: 			throw BinderException("Cant update column \"%s\" because it is a generated column!", column.Name());
166: 		}
167: 		if (std::find(insert.set_columns.begin(), insert.set_columns.end(), column.Physical()) !=
168: 		    insert.set_columns.end()) {
169: 			throw BinderException("Multiple assignments to same column \"%s\"", colname);
170: 		}
171: 		insert.set_columns.push_back(column.Physical());
172: 		logical_column_ids.push_back(column.Oid());
173: 		insert.set_types.push_back(column.Type());
174: 		column_names.push_back(colname);
175: 		if (expr->type == ExpressionType::VALUE_DEFAULT) {
176: 			expr = ExpandDefaultExpression(column);
177: 		}
178: 
179: 		// Qualify and bind the ON CONFLICT DO UPDATE SET expression.
180: 		UpdateBinder update_binder(*this, context);
181: 		update_binder.target_type = column.Type();
182: 
183: 		// Avoid ambiguity between existing table columns and EXCLUDED columns.
184: 		vector<unordered_set<string>> lambda_params;
185: 		update_binder.DoUpdateSetQualify(expr, table_alias, lambda_params);
186: 
187: 		auto bound_expr = update_binder.Bind(expr);
188: 		D_ASSERT(bound_expr);
189: 		insert.expressions.push_back(std::move(bound_expr));
190: 	}
191: 
192: 	// Figure out which columns are indexed on
193: 	unordered_set<column_t> indexed_columns;
194: 	for (auto &index : storage_info.index_info) {
195: 		for (auto &column_id : index.column_set) {
196: 			indexed_columns.insert(column_id);
197: 		}
198: 	}
199: 
200: 	// Verify that none of the columns that are targeted with a SET expression are indexed on
201: 	for (idx_t i = 0; i < logical_column_ids.size(); i++) {
202: 		auto &column = logical_column_ids[i];
203: 		if (indexed_columns.count(column)) {
204: 			throw BinderException("Can not assign to column '%s' because it has a UNIQUE/PRIMARY KEY constraint or is "
205: 			                      "referenced by an INDEX",
206: 			                      column_names[i]);
207: 		}
208: 	}
209: }
210: 
211: unique_ptr<UpdateSetInfo> CreateSetInfoForReplace(TableCatalogEntry &table, InsertStatement &insert,
212:                                                   TableStorageInfo &storage_info) {
213: 	auto set_info = make_uniq<UpdateSetInfo>();
214: 
215: 	auto &columns = set_info->columns;
216: 	// Figure out which columns are indexed on
217: 
218: 	unordered_set<column_t> indexed_columns;
219: 	for (auto &index : storage_info.index_info) {
220: 		for (auto &column_id : index.column_set) {
221: 			indexed_columns.insert(column_id);
222: 		}
223: 	}
224: 
225: 	auto &column_list = table.GetColumns();
226: 	if (insert.columns.empty()) {
227: 		for (auto &column : column_list.Physical()) {
228: 			auto &name = column.Name();
229: 			// FIXME: can these column names be aliased somehow?
230: 			if (indexed_columns.count(column.Oid())) {
231: 				continue;
232: 			}
233: 			columns.push_back(name);
234: 		}
235: 	} else {
236: 		// a list of columns was explicitly supplied, only update those
237: 		for (auto &name : insert.columns) {
238: 			auto &column = column_list.GetColumn(name);
239: 			if (indexed_columns.count(column.Oid())) {
240: 				continue;
241: 			}
242: 			columns.push_back(name);
243: 		}
244: 	}
245: 
246: 	// Create 'excluded' qualified column references of these columns
247: 	for (auto &column : columns) {
248: 		set_info->expressions.push_back(make_uniq<ColumnRefExpression>(column, "excluded"));
249: 	}
250: 
251: 	return set_info;
252: }
253: 
254: void Binder::BindOnConflictClause(LogicalInsert &insert, TableCatalogEntry &table, InsertStatement &stmt) {
255: 	if (!stmt.on_conflict_info) {
256: 		insert.action_type = OnConflictAction::THROW;
257: 		return;
258: 	}
259: 	D_ASSERT(stmt.table_ref->type == TableReferenceType::BASE_TABLE);
260: 
261: 	// visit the table reference
262: 	auto bound_table = Bind(*stmt.table_ref);
263: 	if (bound_table->type != TableReferenceType::BASE_TABLE) {
264: 		throw BinderException("Can only update base table!");
265: 	}
266: 
267: 	auto &table_ref = stmt.table_ref->Cast<BaseTableRef>();
268: 	const string &table_alias = !table_ref.alias.empty() ? table_ref.alias : table_ref.table_name;
269: 
270: 	auto &on_conflict = *stmt.on_conflict_info;
271: 	D_ASSERT(on_conflict.action_type != OnConflictAction::THROW);
272: 	insert.action_type = on_conflict.action_type;
273: 
274: 	// obtain the table storage info
275: 	auto storage_info = table.GetStorageInfo(context);
276: 
277: 	auto &columns = table.GetColumns();
278: 	if (!on_conflict.indexed_columns.empty()) {
279: 		// Bind the ON CONFLICT (<columns>)
280: 
281: 		// create a mapping of (list index) -> (column index)
282: 		case_insensitive_map_t<idx_t> specified_columns;
283: 		for (idx_t i = 0; i < on_conflict.indexed_columns.size(); i++) {
284: 			specified_columns[on_conflict.indexed_columns[i]] = i;
285: 			auto column_index = table.GetColumnIndex(on_conflict.indexed_columns[i]);
286: 			if (column_index.index == COLUMN_IDENTIFIER_ROW_ID) {
287: 				throw BinderException("Cannot specify ROWID as ON CONFLICT target");
288: 			}
289: 			auto &col = columns.GetColumn(column_index);
290: 			if (col.Generated()) {
291: 				throw BinderException("Cannot specify a generated column as ON CONFLICT target");
292: 			}
293: 		}
294: 		for (auto &col : columns.Physical()) {
295: 			auto entry = specified_columns.find(col.Name());
296: 			if (entry != specified_columns.end()) {
297: 				// column was specified, set to the index
298: 				insert.on_conflict_filter.insert(col.Physical().index);
299: 			}
300: 		}
301: 		bool index_references_columns = false;
302: 		for (auto &index : storage_info.index_info) {
303: 			if (!index.is_unique) {
304: 				continue;
305: 			}
306: 			bool index_matches = insert.on_conflict_filter == index.column_set;
307: 			if (index_matches) {
308: 				index_references_columns = true;
309: 				break;
310: 			}
311: 		}
312: 		if (!index_references_columns) {
313: 			// Same as before, this is essentially a no-op, turning this into a DO THROW instead
314: 			// But since this makes no logical sense, it's probably better to throw an error
315: 			throw BinderException("The specified columns as conflict target are not referenced by a UNIQUE/PRIMARY KEY "
316: 			                      "CONSTRAINT or INDEX");
317: 		}
318: 	} else {
319: 		// When omitting the conflict target, the ON CONFLICT applies to every UNIQUE/PRIMARY KEY on the table
320: 
321: 		// We check if there are any constraints on the table, if there aren't we throw an error.
322: 		idx_t found_matching_indexes = 0;
323: 		for (auto &index : storage_info.index_info) {
324: 			if (!index.is_unique) {
325: 				continue;
326: 			}
327: 			auto &indexed_columns = index.column_set;
328: 			bool matches = false;
329: 			for (auto &column : table.GetColumns().Physical()) {
330: 				if (indexed_columns.count(column.Physical().index)) {
331: 					matches = true;
332: 					break;
333: 				}
334: 			}
335: 			found_matching_indexes += matches;
336: 		}
337: 
338: 		if (!found_matching_indexes) {
339: 			throw BinderException(
340: 			    "There are no UNIQUE/PRIMARY KEY Indexes that refer to this table, ON CONFLICT is a no-op");
341: 		} else if (found_matching_indexes != 1) {
342: 			if (insert.action_type != OnConflictAction::NOTHING) {
343: 				// When no conflict target is provided, and the action type is UPDATE,
344: 				// we only allow the operation when only a single Index exists
345: 				throw BinderException("Conflict target has to be provided for a DO UPDATE operation when the table has "
346: 				                      "multiple UNIQUE/PRIMARY KEY constraints");
347: 			}
348: 		}
349: 	}
350: 
351: 	// add the 'excluded' dummy table binding
352: 	AddTableName("excluded");
353: 	// add a bind context entry for it
354: 	auto excluded_index = GenerateTableIndex();
355: 	insert.excluded_table_index = excluded_index;
356: 	vector<string> table_column_names;
357: 	vector<LogicalType> table_column_types;
358: 	for (auto &col : columns.Physical()) {
359: 		table_column_names.push_back(col.Name());
360: 		table_column_types.push_back(col.Type());
361: 	}
362: 	bind_context.AddGenericBinding(excluded_index, "excluded", table_column_names, table_column_types);
363: 
364: 	if (on_conflict.condition) {
365: 		WhereBinder where_binder(*this, context);
366: 
367: 		// Avoid ambiguity between existing table columns and EXCLUDED columns.
368: 		vector<unordered_set<string>> lambda_params;
369: 		where_binder.DoUpdateSetQualify(on_conflict.condition, table_alias, lambda_params);
370: 
371: 		// Bind the ON CONFLICT ... WHERE clause.
372: 		auto condition = where_binder.Bind(on_conflict.condition);
373: 		insert.on_conflict_condition = std::move(condition);
374: 	}
375: 
376: 	optional_idx projection_index;
377: 	reference<vector<unique_ptr<LogicalOperator>>> insert_child_operators = insert.children;
378: 	while (!projection_index.IsValid()) {
379: 		if (insert_child_operators.get().empty()) {
380: 			// No further children to visit
381: 			break;
382: 		}
383: 		auto &current_child = insert_child_operators.get()[0];
384: 		auto table_indices = current_child->GetTableIndex();
385: 		if (table_indices.empty()) {
386: 			// This operator does not have a table index to refer to, we have to visit its children
387: 			insert_child_operators = current_child->children;
388: 			continue;
389: 		}
390: 		projection_index = table_indices[0];
391: 	}
392: 	if (!projection_index.IsValid()) {
393: 		throw InternalException("Could not locate a table_index from the children of the insert");
394: 	}
395: 
396: 	ErrorData unused;
397: 	auto original_binding = bind_context.GetBinding(table_alias, unused);
398: 	D_ASSERT(original_binding && !unused.HasError());
399: 
400: 	auto table_index = original_binding->index;
401: 
402: 	// Replace any column bindings to refer to the projection table_index, rather than the source table
403: 	if (insert.on_conflict_condition) {
404: 		ReplaceColumnBindings(*insert.on_conflict_condition, table_index, projection_index.GetIndex());
405: 	}
406: 
407: 	if (insert.action_type == OnConflictAction::REPLACE) {
408: 		D_ASSERT(on_conflict.set_info == nullptr);
409: 		on_conflict.set_info = CreateSetInfoForReplace(table, stmt, storage_info);
410: 		insert.action_type = OnConflictAction::UPDATE;
411: 	}
412: 	if (on_conflict.set_info && on_conflict.set_info->columns.empty()) {
413: 		// if we are doing INSERT OR REPLACE on a table with no columns outside of the primary key column
414: 		// convert to INSERT OR IGNORE
415: 		insert.action_type = OnConflictAction::NOTHING;
416: 	}
417: 	if (insert.action_type == OnConflictAction::NOTHING) {
418: 		if (!insert.on_conflict_condition) {
419: 			return;
420: 		}
421: 		// Get the column_ids we need to fetch later on from the conflicting tuples
422: 		// of the original table, to execute the expressions
423: 		D_ASSERT(original_binding->binding_type == BindingType::TABLE);
424: 		auto &table_binding = original_binding->Cast<TableBinding>();
425: 		insert.columns_to_fetch = table_binding.GetBoundColumnIds();
426: 		return;
427: 	}
428: 
429: 	D_ASSERT(on_conflict.set_info);
430: 	auto &set_info = *on_conflict.set_info;
431: 	D_ASSERT(set_info.columns.size() == set_info.expressions.size());
432: 
433: 	if (set_info.condition) {
434: 		WhereBinder where_binder(*this, context);
435: 
436: 		// Avoid ambiguity between existing table columns and EXCLUDED columns.
437: 		vector<unordered_set<string>> lambda_params;
438: 		where_binder.DoUpdateSetQualify(set_info.condition, table_alias, lambda_params);
439: 
440: 		// Bind the SET ... WHERE clause.
441: 		auto condition = where_binder.Bind(set_info.condition);
442: 		insert.do_update_condition = std::move(condition);
443: 	}
444: 
445: 	BindDoUpdateSetExpressions(table_alias, insert, set_info, table, storage_info);
446: 
447: 	// Get the column_ids we need to fetch later on from the conflicting tuples
448: 	// of the original table, to execute the expressions
449: 	D_ASSERT(original_binding->binding_type == BindingType::TABLE);
450: 	auto &table_binding = original_binding->Cast<TableBinding>();
451: 	insert.columns_to_fetch = table_binding.GetBoundColumnIds();
452: 
453: 	// Replace the column bindings to refer to the child operator
454: 	for (auto &expr : insert.expressions) {
455: 		// Change the non-excluded column references to refer to the projection index
456: 		ReplaceColumnBindings(*expr, table_index, projection_index.GetIndex());
457: 	}
458: 	// Do the same for the (optional) DO UPDATE condition
459: 	if (insert.do_update_condition) {
460: 		ReplaceColumnBindings(*insert.do_update_condition, table_index, projection_index.GetIndex());
461: 	}
462: }
463: 
464: BoundStatement Binder::Bind(InsertStatement &stmt) {
465: 	BoundStatement result;
466: 	result.names = {"Count"};
467: 	result.types = {LogicalType::BIGINT};
468: 
469: 	BindSchemaOrCatalog(stmt.catalog, stmt.schema);
470: 	auto &table = Catalog::GetEntry<TableCatalogEntry>(context, stmt.catalog, stmt.schema, stmt.table);
471: 	if (!table.temporary) {
472: 		// inserting into a non-temporary table: alters underlying database
473: 		auto &properties = GetStatementProperties();
474: 		properties.RegisterDBModify(table.catalog, context);
475: 	}
476: 
477: 	auto insert = make_uniq<LogicalInsert>(table, GenerateTableIndex());
478: 	// Add CTEs as bindable
479: 	AddCTEMap(stmt.cte_map);
480: 
481: 	auto values_list = stmt.GetValuesList();
482: 
483: 	// bind the root select node (if any)
484: 	BoundStatement root_select;
485: 	if (stmt.column_order == InsertColumnOrder::INSERT_BY_NAME) {
486: 		if (values_list) {
487: 			throw BinderException("INSERT BY NAME can only be used when inserting from a SELECT statement");
488: 		}
489: 		if (!stmt.columns.empty()) {
490: 			throw BinderException("INSERT BY NAME cannot be combined with an explicit column list");
491: 		}
492: 		D_ASSERT(stmt.select_statement);
493: 		// INSERT BY NAME - generate the columns from the names of the SELECT statement
494: 		auto select_binder = Binder::CreateBinder(context, this);
495: 		root_select = select_binder->Bind(*stmt.select_statement);
496: 		MoveCorrelatedExpressions(*select_binder);
497: 
498: 		stmt.columns = root_select.names;
499: 	}
500: 
501: 	vector<LogicalIndex> named_column_map;
502: 	if (!stmt.columns.empty() || stmt.default_values) {
503: 		// insertion statement specifies column list
504: 
505: 		// create a mapping of (list index) -> (column index)
506: 		case_insensitive_map_t<idx_t> column_name_map;
507: 		for (idx_t i = 0; i < stmt.columns.size(); i++) {
508: 			auto entry = column_name_map.insert(make_pair(stmt.columns[i], i));
509: 			if (!entry.second) {
510: 				throw BinderException("Duplicate column name \"%s\" in INSERT", stmt.columns[i]);
511: 			}
512: 			auto column_index = table.GetColumnIndex(stmt.columns[i]);
513: 			if (column_index.index == COLUMN_IDENTIFIER_ROW_ID) {
514: 				throw BinderException("Cannot explicitly insert values into rowid column");
515: 			}
516: 			auto &col = table.GetColumn(column_index);
517: 			if (col.Generated()) {
518: 				throw BinderException("Cannot insert into a generated column");
519: 			}
520: 			insert->expected_types.push_back(col.Type());
521: 			named_column_map.push_back(column_index);
522: 		}
523: 		for (auto &col : table.GetColumns().Physical()) {
524: 			auto entry = column_name_map.find(col.Name());
525: 			if (entry == column_name_map.end()) {
526: 				// column not specified, set index to DConstants::INVALID_INDEX
527: 				insert->column_index_map.push_back(DConstants::INVALID_INDEX);
528: 			} else {
529: 				// column was specified, set to the index
530: 				insert->column_index_map.push_back(entry->second);
531: 			}
532: 		}
533: 	} else {
534: 		// insert by position and no columns specified - insertion into all columns of the table
535: 		// intentionally don't populate 'column_index_map' as an indication of this
536: 		for (auto &col : table.GetColumns().Physical()) {
537: 			named_column_map.push_back(col.Logical());
538: 			insert->expected_types.push_back(col.Type());
539: 		}
540: 	}
541: 
542: 	// bind the default values
543: 	BindDefaultValues(table.GetColumns(), insert->bound_defaults);
544: 	insert->bound_constraints = BindConstraints(table);
545: 	if (!stmt.select_statement && !stmt.default_values) {
546: 		result.plan = std::move(insert);
547: 		return result;
548: 	}
549: 	// Exclude the generated columns from this amount
550: 	idx_t expected_columns = stmt.columns.empty() ? table.GetColumns().PhysicalColumnCount() : stmt.columns.size();
551: 
552: 	// special case: check if we are inserting from a VALUES statement
553: 	if (values_list) {
554: 		auto &expr_list = values_list->Cast<ExpressionListRef>();
555: 		expr_list.expected_types.resize(expected_columns);
556: 		expr_list.expected_names.resize(expected_columns);
557: 
558: 		D_ASSERT(!expr_list.values.empty());
559: 		CheckInsertColumnCountMismatch(expected_columns, expr_list.values[0].size(), !stmt.columns.empty(),
560: 		                               table.name.c_str());
561: 
562: 		// VALUES list!
563: 		for (idx_t col_idx = 0; col_idx < expected_columns; col_idx++) {
564: 			D_ASSERT(named_column_map.size() >= col_idx);
565: 			auto &table_col_idx = named_column_map[col_idx];
566: 
567: 			// set the expected types as the types for the INSERT statement
568: 			auto &column = table.GetColumn(table_col_idx);
569: 			expr_list.expected_types[col_idx] = column.Type();
570: 			expr_list.expected_names[col_idx] = column.Name();
571: 
572: 			// now replace any DEFAULT values with the corresponding default expression
573: 			for (idx_t list_idx = 0; list_idx < expr_list.values.size(); list_idx++) {
574: 				if (expr_list.values[list_idx][col_idx]->type == ExpressionType::VALUE_DEFAULT) {
575: 					// DEFAULT value! replace the entry
576: 					ReplaceDefaultExpression(expr_list.values[list_idx][col_idx], column);
577: 				}
578: 			}
579: 		}
580: 	}
581: 
582: 	// parse select statement and add to logical plan
583: 	unique_ptr<LogicalOperator> root;
584: 	if (stmt.select_statement) {
585: 		if (stmt.column_order == InsertColumnOrder::INSERT_BY_POSITION) {
586: 			auto select_binder = Binder::CreateBinder(context, this);
587: 			root_select = select_binder->Bind(*stmt.select_statement);
588: 			MoveCorrelatedExpressions(*select_binder);
589: 		}
590: 		// inserting from a select - check if the column count matches
591: 		CheckInsertColumnCountMismatch(expected_columns, root_select.types.size(), !stmt.columns.empty(),
592: 		                               table.name.c_str());
593: 
594: 		root = CastLogicalOperatorToTypes(root_select.types, insert->expected_types, std::move(root_select.plan));
595: 	} else {
596: 		root = make_uniq<LogicalDummyScan>(GenerateTableIndex());
597: 	}
598: 	insert->AddChild(std::move(root));
599: 
600: 	BindOnConflictClause(*insert, table, stmt);
601: 
602: 	if (!stmt.returning_list.empty()) {
603: 		insert->return_chunk = true;
604: 		result.types.clear();
605: 		result.names.clear();
606: 		auto insert_table_index = GenerateTableIndex();
607: 		insert->table_index = insert_table_index;
608: 		unique_ptr<LogicalOperator> index_as_logicaloperator = std::move(insert);
609: 
610: 		return BindReturning(std::move(stmt.returning_list), table, stmt.table_ref ? stmt.table_ref->alias : string(),
611: 		                     insert_table_index, std::move(index_as_logicaloperator), std::move(result));
612: 	}
613: 
614: 	D_ASSERT(result.types.size() == result.names.size());
615: 	result.plan = std::move(insert);
616: 
617: 	auto &properties = GetStatementProperties();
618: 	properties.allow_stream_result = false;
619: 	properties.return_type = StatementReturnType::CHANGED_ROWS;
620: 	return result;
621: }
622: 
623: } // namespace duckdb
[end of src/planner/binder/statement/bind_insert.cpp]
[start of src/planner/binder/statement/bind_pragma.cpp]
1: #include "duckdb/planner/binder.hpp"
2: #include "duckdb/parser/statement/pragma_statement.hpp"
3: #include "duckdb/planner/operator/logical_pragma.hpp"
4: #include "duckdb/catalog/catalog_entry/pragma_function_catalog_entry.hpp"
5: #include "duckdb/catalog/catalog.hpp"
6: #include "duckdb/function/function_binder.hpp"
7: #include "duckdb/planner/expression_binder/constant_binder.hpp"
8: #include "duckdb/execution/expression_executor.hpp"
9: 
10: namespace duckdb {
11: 
12: unique_ptr<BoundPragmaInfo> Binder::BindPragma(PragmaInfo &info, QueryErrorContext error_context) {
13: 	vector<Value> params;
14: 	named_parameter_map_t named_parameters;
15: 
16: 	// resolve the parameters
17: 	ConstantBinder pragma_binder(*this, context, "PRAGMA value");
18: 	for (auto &param : info.parameters) {
19: 		auto bound_value = pragma_binder.Bind(param);
20: 		auto value = ExpressionExecutor::EvaluateScalar(context, *bound_value, true);
21: 		params.push_back(std::move(value));
22: 	}
23: 
24: 	for (auto &entry : info.named_parameters) {
25: 		auto bound_value = pragma_binder.Bind(entry.second);
26: 		auto value = ExpressionExecutor::EvaluateScalar(context, *bound_value, true);
27: 		named_parameters.insert(make_pair(entry.first, std::move(value)));
28: 	}
29: 
30: 	// bind the pragma function
31: 	auto &entry = Catalog::GetEntry<PragmaFunctionCatalogEntry>(context, INVALID_CATALOG, DEFAULT_SCHEMA, info.name);
32: 	FunctionBinder function_binder(context);
33: 	ErrorData error;
34: 	auto bound_idx = function_binder.BindFunction(entry.name, entry.functions, params, error);
35: 	if (!bound_idx.IsValid()) {
36: 		D_ASSERT(error.HasError());
37: 		error.AddQueryLocation(error_context);
38: 		error.Throw();
39: 	}
40: 	auto bound_function = entry.functions.GetFunctionByOffset(bound_idx.GetIndex());
41: 	// bind and check named params
42: 	BindNamedParameters(bound_function.named_parameters, named_parameters, error_context, bound_function.name);
43: 	return make_uniq<BoundPragmaInfo>(std::move(bound_function), std::move(params), std::move(named_parameters));
44: }
45: 
46: BoundStatement Binder::Bind(PragmaStatement &stmt) {
47: 	// bind the pragma function
48: 	QueryErrorContext error_context(stmt.stmt_location);
49: 	auto bound_info = BindPragma(*stmt.info, error_context);
50: 	if (!bound_info->function.function) {
51: 		throw BinderException("PRAGMA function does not have a function specified");
52: 	}
53: 
54: 	BoundStatement result;
55: 	result.names = {"Success"};
56: 	result.types = {LogicalType::BOOLEAN};
57: 	result.plan = make_uniq<LogicalPragma>(std::move(bound_info));
58: 
59: 	auto &properties = GetStatementProperties();
60: 	properties.return_type = StatementReturnType::QUERY_RESULT;
61: 	return result;
62: }
63: 
64: } // namespace duckdb
[end of src/planner/binder/statement/bind_pragma.cpp]
[start of src/planner/binder/statement/bind_update.cpp]
1: #include "duckdb/parser/expression/columnref_expression.hpp"
2: #include "duckdb/parser/statement/update_statement.hpp"
3: #include "duckdb/planner/binder.hpp"
4: #include "duckdb/planner/tableref/bound_joinref.hpp"
5: #include "duckdb/planner/bound_tableref.hpp"
6: #include "duckdb/planner/constraints/bound_check_constraint.hpp"
7: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
8: #include "duckdb/planner/expression/bound_default_expression.hpp"
9: #include "duckdb/planner/expression_binder/update_binder.hpp"
10: #include "duckdb/planner/expression_binder/where_binder.hpp"
11: #include "duckdb/planner/operator/logical_filter.hpp"
12: #include "duckdb/planner/operator/logical_get.hpp"
13: #include "duckdb/planner/operator/logical_projection.hpp"
14: #include "duckdb/planner/operator/logical_update.hpp"
15: #include "duckdb/planner/tableref/bound_basetableref.hpp"
16: #include "duckdb/catalog/catalog_entry/duck_table_entry.hpp"
17: #include "duckdb/storage/data_table.hpp"
18: 
19: #include <algorithm>
20: 
21: namespace duckdb {
22: 
23: // This creates a LogicalProjection and moves 'root' into it as a child
24: // unless there are no expressions to project, in which case it just returns 'root'
25: unique_ptr<LogicalOperator> Binder::BindUpdateSet(LogicalOperator &op, unique_ptr<LogicalOperator> root,
26:                                                   UpdateSetInfo &set_info, TableCatalogEntry &table,
27:                                                   vector<PhysicalIndex> &columns) {
28: 	auto proj_index = GenerateTableIndex();
29: 
30: 	vector<unique_ptr<Expression>> projection_expressions;
31: 	D_ASSERT(set_info.columns.size() == set_info.expressions.size());
32: 	for (idx_t i = 0; i < set_info.columns.size(); i++) {
33: 		auto &colname = set_info.columns[i];
34: 		auto &expr = set_info.expressions[i];
35: 		if (!table.ColumnExists(colname)) {
36: 			throw BinderException("Referenced update column %s not found in table!", colname);
37: 		}
38: 		auto &column = table.GetColumn(colname);
39: 		if (column.Generated()) {
40: 			throw BinderException("Cant update column \"%s\" because it is a generated column!", column.Name());
41: 		}
42: 		if (std::find(columns.begin(), columns.end(), column.Physical()) != columns.end()) {
43: 			throw BinderException("Multiple assignments to same column \"%s\"", colname);
44: 		}
45: 		columns.push_back(column.Physical());
46: 		if (expr->type == ExpressionType::VALUE_DEFAULT) {
47: 			op.expressions.push_back(make_uniq<BoundDefaultExpression>(column.Type()));
48: 		} else {
49: 			UpdateBinder binder(*this, context);
50: 			binder.target_type = column.Type();
51: 			auto bound_expr = binder.Bind(expr);
52: 			PlanSubqueries(bound_expr, root);
53: 
54: 			op.expressions.push_back(make_uniq<BoundColumnRefExpression>(
55: 			    bound_expr->return_type, ColumnBinding(proj_index, projection_expressions.size())));
56: 			projection_expressions.push_back(std::move(bound_expr));
57: 		}
58: 	}
59: 	if (op.type != LogicalOperatorType::LOGICAL_UPDATE && projection_expressions.empty()) {
60: 		return root;
61: 	}
62: 	// now create the projection
63: 	auto proj = make_uniq<LogicalProjection>(proj_index, std::move(projection_expressions));
64: 	proj->AddChild(std::move(root));
65: 	return unique_ptr_cast<LogicalProjection, LogicalOperator>(std::move(proj));
66: }
67: 
68: BoundStatement Binder::Bind(UpdateStatement &stmt) {
69: 	BoundStatement result;
70: 	unique_ptr<LogicalOperator> root;
71: 
72: 	// visit the table reference
73: 	auto bound_table = Bind(*stmt.table);
74: 	if (bound_table->type != TableReferenceType::BASE_TABLE) {
75: 		throw BinderException("Can only update base table!");
76: 	}
77: 	auto &table_binding = bound_table->Cast<BoundBaseTableRef>();
78: 	auto &table = table_binding.table;
79: 
80: 	// Add CTEs as bindable
81: 	AddCTEMap(stmt.cte_map);
82: 
83: 	optional_ptr<LogicalGet> get;
84: 	if (stmt.from_table) {
85: 		auto from_binder = Binder::CreateBinder(context, this);
86: 		BoundJoinRef bound_crossproduct(JoinRefType::CROSS);
87: 		bound_crossproduct.left = std::move(bound_table);
88: 		bound_crossproduct.right = from_binder->Bind(*stmt.from_table);
89: 		root = CreatePlan(bound_crossproduct);
90: 		get = &root->children[0]->Cast<LogicalGet>();
91: 		bind_context.AddContext(std::move(from_binder->bind_context));
92: 	} else {
93: 		root = CreatePlan(*bound_table);
94: 		get = &root->Cast<LogicalGet>();
95: 	}
96: 
97: 	if (!table.temporary) {
98: 		// update of persistent table: not read only!
99: 		auto &properties = GetStatementProperties();
100: 		properties.RegisterDBModify(table.catalog, context);
101: 	}
102: 	auto update = make_uniq<LogicalUpdate>(table);
103: 
104: 	// set return_chunk boolean early because it needs uses update_is_del_and_insert logic
105: 	if (!stmt.returning_list.empty()) {
106: 		update->return_chunk = true;
107: 	}
108: 	// bind the default values
109: 	BindDefaultValues(table.GetColumns(), update->bound_defaults);
110: 	update->bound_constraints = BindConstraints(table);
111: 
112: 	// project any additional columns required for the condition/expressions
113: 	if (stmt.set_info->condition) {
114: 		WhereBinder binder(*this, context);
115: 		auto condition = binder.Bind(stmt.set_info->condition);
116: 
117: 		PlanSubqueries(condition, root);
118: 		auto filter = make_uniq<LogicalFilter>(std::move(condition));
119: 		filter->AddChild(std::move(root));
120: 		root = std::move(filter);
121: 	}
122: 
123: 	D_ASSERT(stmt.set_info);
124: 	D_ASSERT(stmt.set_info->columns.size() == stmt.set_info->expressions.size());
125: 
126: 	auto proj_tmp = BindUpdateSet(*update, std::move(root), *stmt.set_info, table, update->columns);
127: 	D_ASSERT(proj_tmp->type == LogicalOperatorType::LOGICAL_PROJECTION);
128: 	auto proj = unique_ptr_cast<LogicalOperator, LogicalProjection>(std::move(proj_tmp));
129: 
130: 	// bind any extra columns necessary for CHECK constraints or indexes
131: 	table.BindUpdateConstraints(*this, *get, *proj, *update, context);
132: 
133: 	// finally add the row id column to the projection list
134: 	auto &column_ids = get->GetColumnIds();
135: 	proj->expressions.push_back(
136: 	    make_uniq<BoundColumnRefExpression>(LogicalType::ROW_TYPE, ColumnBinding(get->table_index, column_ids.size())));
137: 	get->AddColumnId(COLUMN_IDENTIFIER_ROW_ID);
138: 
139: 	// set the projection as child of the update node and finalize the result
140: 	update->AddChild(std::move(proj));
141: 
142: 	auto update_table_index = GenerateTableIndex();
143: 	update->table_index = update_table_index;
144: 	if (!stmt.returning_list.empty()) {
145: 		unique_ptr<LogicalOperator> update_as_logicaloperator = std::move(update);
146: 
147: 		return BindReturning(std::move(stmt.returning_list), table, stmt.table->alias, update_table_index,
148: 		                     std::move(update_as_logicaloperator), std::move(result));
149: 	}
150: 
151: 	result.names = {"Count"};
152: 	result.types = {LogicalType::BIGINT};
153: 	result.plan = std::move(update);
154: 
155: 	auto &properties = GetStatementProperties();
156: 	properties.allow_stream_result = false;
157: 	properties.return_type = StatementReturnType::CHANGED_ROWS;
158: 	return result;
159: }
160: 
161: } // namespace duckdb
[end of src/planner/binder/statement/bind_update.cpp]
[start of src/planner/binder/tableref/bind_table_function.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: #include "duckdb/catalog/catalog_entry/table_macro_catalog_entry.hpp"
3: #include "duckdb/common/algorithm.hpp"
4: #include "duckdb/execution/expression_executor.hpp"
5: #include "duckdb/parser/expression/columnref_expression.hpp"
6: #include "duckdb/parser/expression/comparison_expression.hpp"
7: #include "duckdb/parser/expression/function_expression.hpp"
8: #include "duckdb/parser/expression/subquery_expression.hpp"
9: #include "duckdb/parser/query_node/select_node.hpp"
10: #include "duckdb/parser/tableref/emptytableref.hpp"
11: #include "duckdb/parser/tableref/table_function_ref.hpp"
12: #include "duckdb/planner/binder.hpp"
13: #include "duckdb/planner/expression_binder/table_function_binder.hpp"
14: #include "duckdb/planner/expression_binder/select_binder.hpp"
15: #include "duckdb/planner/operator/logical_get.hpp"
16: #include "duckdb/planner/query_node/bound_select_node.hpp"
17: #include "duckdb/planner/tableref/bound_subqueryref.hpp"
18: #include "duckdb/planner/tableref/bound_table_function.hpp"
19: #include "duckdb/function/function_binder.hpp"
20: #include "duckdb/catalog/catalog_entry/table_function_catalog_entry.hpp"
21: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
22: #include "duckdb/function/table/read_csv.hpp"
23: 
24: namespace duckdb {
25: 
26: enum class TableFunctionBindType { STANDARD_TABLE_FUNCTION, TABLE_IN_OUT_FUNCTION, TABLE_PARAMETER_FUNCTION };
27: 
28: static TableFunctionBindType GetTableFunctionBindType(TableFunctionCatalogEntry &table_function,
29:                                                       vector<unique_ptr<ParsedExpression>> &expressions) {
30: 	// first check if all expressions are scalar
31: 	// if they are we always bind as a standard table function
32: 	bool all_scalar = true;
33: 	for (auto &expr : expressions) {
34: 		if (!expr->IsScalar()) {
35: 			all_scalar = false;
36: 			break;
37: 		}
38: 	}
39: 	if (all_scalar) {
40: 		return TableFunctionBindType::STANDARD_TABLE_FUNCTION;
41: 	}
42: 	// if we have non-scalar parameters - we need to look at the function definition to decide how to bind
43: 	// if a function does not have an in_out_function defined, we need to bind as a standard table function regardless
44: 	bool has_in_out_function = false;
45: 	bool has_standard_table_function = false;
46: 	bool has_table_parameter = false;
47: 	for (idx_t function_idx = 0; function_idx < table_function.functions.Size(); function_idx++) {
48: 		const auto &function = table_function.functions.GetFunctionReferenceByOffset(function_idx);
49: 		for (auto &arg : function.arguments) {
50: 			if (arg.id() == LogicalTypeId::TABLE) {
51: 				has_table_parameter = true;
52: 			}
53: 		}
54: 		if (function.in_out_function) {
55: 			has_in_out_function = true;
56: 		} else if (function.function || function.bind_replace) {
57: 			has_standard_table_function = true;
58: 		} else {
59: 			throw InternalException("Function \"%s\" has neither in_out_function nor function defined",
60: 			                        table_function.name);
61: 		}
62: 	}
63: 	if (has_table_parameter) {
64: 		if (table_function.functions.Size() != 1) {
65: 			throw InternalException(
66: 			    "Function \"%s\" has a TABLE parameter, and multiple function overloads - this is not supported",
67: 			    table_function.name);
68: 		}
69: 		return TableFunctionBindType::TABLE_PARAMETER_FUNCTION;
70: 	}
71: 	if (has_in_out_function && has_standard_table_function) {
72: 		throw InternalException("Function \"%s\" is both an in_out_function and a table function", table_function.name);
73: 	}
74: 	return has_in_out_function ? TableFunctionBindType::TABLE_IN_OUT_FUNCTION
75: 	                           : TableFunctionBindType::STANDARD_TABLE_FUNCTION;
76: }
77: 
78: void Binder::BindTableInTableOutFunction(vector<unique_ptr<ParsedExpression>> &expressions,
79:                                          unique_ptr<BoundSubqueryRef> &subquery) {
80: 	auto binder = Binder::CreateBinder(this->context, this);
81: 	unique_ptr<QueryNode> subquery_node;
82: 	// generate a subquery and bind that (i.e. UNNEST([1,2,3]) becomes UNNEST((SELECT [1,2,3]))
83: 	auto select_node = make_uniq<SelectNode>();
84: 	select_node->select_list = std::move(expressions);
85: 	select_node->from_table = make_uniq<EmptyTableRef>();
86: 	subquery_node = std::move(select_node);
87: 	binder->can_contain_nulls = true;
88: 	auto node = binder->BindNode(*subquery_node);
89: 	subquery = make_uniq<BoundSubqueryRef>(std::move(binder), std::move(node));
90: 	MoveCorrelatedExpressions(*subquery->binder);
91: }
92: 
93: bool Binder::BindTableFunctionParameters(TableFunctionCatalogEntry &table_function,
94:                                          vector<unique_ptr<ParsedExpression>> &expressions,
95:                                          vector<LogicalType> &arguments, vector<Value> &parameters,
96:                                          named_parameter_map_t &named_parameters,
97:                                          unique_ptr<BoundSubqueryRef> &subquery, ErrorData &error) {
98: 	auto bind_type = GetTableFunctionBindType(table_function, expressions);
99: 	if (bind_type == TableFunctionBindType::TABLE_IN_OUT_FUNCTION) {
100: 		// bind table in-out function
101: 		BindTableInTableOutFunction(expressions, subquery);
102: 		// fetch the arguments from the subquery
103: 		arguments = subquery->subquery->types;
104: 		return true;
105: 	}
106: 	bool seen_subquery = false;
107: 	for (auto &child : expressions) {
108: 		string parameter_name;
109: 
110: 		// hack to make named parameters work
111: 		if (child->type == ExpressionType::COMPARE_EQUAL) {
112: 			// comparison, check if the LHS is a columnref
113: 			auto &comp = child->Cast<ComparisonExpression>();
114: 			if (comp.left->type == ExpressionType::COLUMN_REF) {
115: 				auto &colref = comp.left->Cast<ColumnRefExpression>();
116: 				if (!colref.IsQualified()) {
117: 					parameter_name = colref.GetColumnName();
118: 					child = std::move(comp.right);
119: 				}
120: 			}
121: 		} else if (!child->alias.empty()) {
122: 			// <name> => <expression> will set the alias of <expression> to <name>
123: 			parameter_name = child->alias;
124: 		}
125: 		if (bind_type == TableFunctionBindType::TABLE_PARAMETER_FUNCTION && child->type == ExpressionType::SUBQUERY) {
126: 			D_ASSERT(table_function.functions.Size() == 1);
127: 			auto fun = table_function.functions.GetFunctionByOffset(0);
128: 			if (table_function.functions.Size() != 1 || fun.arguments.empty() ||
129: 			    fun.arguments[0].id() != LogicalTypeId::TABLE) {
130: 				throw BinderException(
131: 				    "Only table-in-out functions can have subquery parameters - %s only accepts constant parameters",
132: 				    fun.name);
133: 			}
134: 			if (seen_subquery) {
135: 				error = ErrorData("Table function can have at most one subquery parameter");
136: 				return false;
137: 			}
138: 			auto binder = Binder::CreateBinder(this->context, this);
139: 			binder->can_contain_nulls = true;
140: 			auto &se = child->Cast<SubqueryExpression>();
141: 			auto node = binder->BindNode(*se.subquery->node);
142: 			subquery = make_uniq<BoundSubqueryRef>(std::move(binder), std::move(node));
143: 			MoveCorrelatedExpressions(*subquery->binder);
144: 			seen_subquery = true;
145: 			arguments.emplace_back(LogicalTypeId::TABLE);
146: 			parameters.emplace_back(Value());
147: 			continue;
148: 		}
149: 
150: 		TableFunctionBinder binder(*this, context, table_function.name);
151: 		LogicalType sql_type;
152: 		auto expr = binder.Bind(child, &sql_type);
153: 		if (expr->HasParameter()) {
154: 			throw ParameterNotResolvedException();
155: 		}
156: 		if (!expr->IsScalar()) {
157: 			// should have been eliminated before
158: 			throw InternalException("Table function requires a constant parameter");
159: 		}
160: 		auto constant = ExpressionExecutor::EvaluateScalar(context, *expr, true);
161: 		if (parameter_name.empty()) {
162: 			// unnamed parameter
163: 			if (!named_parameters.empty()) {
164: 				error = ErrorData("Unnamed parameters cannot come after named parameters");
165: 				return false;
166: 			}
167: 			arguments.emplace_back(constant.IsNull() ? LogicalType::SQLNULL : sql_type);
168: 			parameters.emplace_back(std::move(constant));
169: 		} else {
170: 			named_parameters[parameter_name] = std::move(constant);
171: 		}
172: 	}
173: 	return true;
174: }
175: 
176: static string GetAlias(const TableFunctionRef &ref) {
177: 	if (!ref.alias.empty()) {
178: 		return ref.alias;
179: 	}
180: 	if (ref.function && ref.function->type == ExpressionType::FUNCTION) {
181: 		auto &function_expr = ref.function->Cast<FunctionExpression>();
182: 		return function_expr.function_name;
183: 	}
184: 	return string();
185: }
186: 
187: unique_ptr<LogicalOperator> Binder::BindTableFunctionInternal(TableFunction &table_function,
188:                                                               const TableFunctionRef &ref, vector<Value> parameters,
189:                                                               named_parameter_map_t named_parameters,
190:                                                               vector<LogicalType> input_table_types,
191:                                                               vector<string> input_table_names) {
192: 	auto function_name = GetAlias(ref);
193: 	auto &column_name_alias = ref.column_name_alias;
194: 
195: 	auto bind_index = GenerateTableIndex();
196: 	// perform the binding
197: 	unique_ptr<FunctionData> bind_data;
198: 	vector<LogicalType> return_types;
199: 	vector<string> return_names;
200: 	if (table_function.bind || table_function.bind_replace) {
201: 		TableFunctionBindInput bind_input(parameters, named_parameters, input_table_types, input_table_names,
202: 		                                  table_function.function_info.get(), this, table_function, ref);
203: 		if (table_function.bind_replace) {
204: 			auto new_plan = table_function.bind_replace(context, bind_input);
205: 			if (new_plan != nullptr) {
206: 				return CreatePlan(*Bind(*new_plan));
207: 			} else if (!table_function.bind) {
208: 				throw BinderException("Failed to bind \"%s\": nullptr returned from bind_replace without bind function",
209: 				                      table_function.name);
210: 			}
211: 		}
212: 		bind_data = table_function.bind(context, bind_input, return_types, return_names);
213: 	} else {
214: 		throw InvalidInputException("Cannot call function \"%s\" directly - it has no bind function",
215: 		                            table_function.name);
216: 	}
217: 	if (return_types.size() != return_names.size()) {
218: 		throw InternalException("Failed to bind \"%s\": return_types/names must have same size", table_function.name);
219: 	}
220: 	if (return_types.empty()) {
221: 		throw InternalException("Failed to bind \"%s\": Table function must return at least one column",
222: 		                        table_function.name);
223: 	}
224: 	// overwrite the names with any supplied aliases
225: 	for (idx_t i = 0; i < column_name_alias.size() && i < return_names.size(); i++) {
226: 		return_names[i] = column_name_alias[i];
227: 	}
228: 	for (idx_t i = 0; i < return_names.size(); i++) {
229: 		if (return_names[i].empty()) {
230: 			return_names[i] = "C" + to_string(i);
231: 		}
232: 	}
233: 
234: 	auto get = make_uniq<LogicalGet>(bind_index, table_function, std::move(bind_data), return_types, return_names);
235: 	get->parameters = parameters;
236: 	get->named_parameters = named_parameters;
237: 	get->input_table_types = input_table_types;
238: 	get->input_table_names = input_table_names;
239: 	if (table_function.in_out_function && !table_function.projection_pushdown) {
240: 		for (idx_t i = 0; i < return_types.size(); i++) {
241: 			get->AddColumnId(i);
242: 		}
243: 	}
244: 	// now add the table function to the bind context so its columns can be bound
245: 	bind_context.AddTableFunction(bind_index, function_name, return_names, return_types, get->GetMutableColumnIds(),
246: 	                              get->GetTable().get());
247: 	return std::move(get);
248: }
249: 
250: unique_ptr<LogicalOperator> Binder::BindTableFunction(TableFunction &function, vector<Value> parameters) {
251: 	named_parameter_map_t named_parameters;
252: 	vector<LogicalType> input_table_types;
253: 	vector<string> input_table_names;
254: 
255: 	TableFunctionRef ref;
256: 	ref.alias = function.name;
257: 	D_ASSERT(!ref.alias.empty());
258: 	return BindTableFunctionInternal(function, ref, std::move(parameters), std::move(named_parameters),
259: 	                                 std::move(input_table_types), std::move(input_table_names));
260: }
261: 
262: unique_ptr<BoundTableRef> Binder::Bind(TableFunctionRef &ref) {
263: 	QueryErrorContext error_context(ref.query_location);
264: 
265: 	D_ASSERT(ref.function->type == ExpressionType::FUNCTION);
266: 	auto &fexpr = ref.function->Cast<FunctionExpression>();
267: 
268: 	// fetch the function from the catalog
269: 	auto &func_catalog = *GetCatalogEntry(CatalogType::TABLE_FUNCTION_ENTRY, fexpr.catalog, fexpr.schema,
270: 	                                      fexpr.function_name, OnEntryNotFound::THROW_EXCEPTION, error_context);
271: 
272: 	if (func_catalog.type == CatalogType::TABLE_MACRO_ENTRY) {
273: 		auto &macro_func = func_catalog.Cast<TableMacroCatalogEntry>();
274: 		auto query_node = BindTableMacro(fexpr, macro_func, 0);
275: 		D_ASSERT(query_node);
276: 
277: 		auto binder = Binder::CreateBinder(context, this);
278: 		binder->can_contain_nulls = true;
279: 
280: 		binder->alias = ref.alias.empty() ? "unnamed_query" : ref.alias;
281: 		auto query = binder->BindNode(*query_node);
282: 
283: 		idx_t bind_index = query->GetRootIndex();
284: 		// string alias;
285: 		string alias = (ref.alias.empty() ? "unnamed_query" + to_string(bind_index) : ref.alias);
286: 
287: 		auto result = make_uniq<BoundSubqueryRef>(std::move(binder), std::move(query));
288: 		// remember ref here is TableFunctionRef and NOT base class
289: 		bind_context.AddSubquery(bind_index, alias, ref, *result->subquery);
290: 		MoveCorrelatedExpressions(*result->binder);
291: 		return std::move(result);
292: 	}
293: 	D_ASSERT(func_catalog.type == CatalogType::TABLE_FUNCTION_ENTRY);
294: 	auto &function = func_catalog.Cast<TableFunctionCatalogEntry>();
295: 
296: 	// evaluate the input parameters to the function
297: 	vector<LogicalType> arguments;
298: 	vector<Value> parameters;
299: 	named_parameter_map_t named_parameters;
300: 	unique_ptr<BoundSubqueryRef> subquery;
301: 	ErrorData error;
302: 	if (!BindTableFunctionParameters(function, fexpr.children, arguments, parameters, named_parameters, subquery,
303: 	                                 error)) {
304: 		error.AddQueryLocation(ref);
305: 		error.Throw();
306: 	}
307: 
308: 	// select the function based on the input parameters
309: 	FunctionBinder function_binder(context);
310: 	auto best_function_idx = function_binder.BindFunction(function.name, function.functions, arguments, error);
311: 	if (!best_function_idx.IsValid()) {
312: 		error.AddQueryLocation(ref);
313: 		error.Throw();
314: 	}
315: 	auto table_function = function.functions.GetFunctionByOffset(best_function_idx.GetIndex());
316: 
317: 	// now check the named parameters
318: 	BindNamedParameters(table_function.named_parameters, named_parameters, error_context, table_function.name);
319: 
320: 	vector<LogicalType> input_table_types;
321: 	vector<string> input_table_names;
322: 
323: 	if (subquery) {
324: 		input_table_types = subquery->subquery->types;
325: 		input_table_names = subquery->subquery->names;
326: 	} else if (table_function.in_out_function) {
327: 		for (auto &param : parameters) {
328: 			input_table_types.push_back(param.type());
329: 			input_table_names.push_back(string());
330: 		}
331: 	}
332: 	if (!parameters.empty()) {
333: 		// cast the parameters to the type of the function
334: 		for (idx_t i = 0; i < arguments.size(); i++) {
335: 			auto target_type =
336: 			    i < table_function.arguments.size() ? table_function.arguments[i] : table_function.varargs;
337: 
338: 			if (target_type != LogicalType::ANY && target_type != LogicalType::POINTER &&
339: 			    target_type.id() != LogicalTypeId::LIST && target_type != LogicalType::TABLE) {
340: 				parameters[i] = parameters[i].CastAs(context, target_type);
341: 			}
342: 		}
343: 	} else if (subquery) {
344: 		for (idx_t i = 0; i < arguments.size(); i++) {
345: 			auto target_type =
346: 			    i < table_function.arguments.size() ? table_function.arguments[i] : table_function.varargs;
347: 
348: 			if (target_type != LogicalType::ANY && target_type != LogicalType::POINTER &&
349: 			    target_type.id() != LogicalTypeId::LIST) {
350: 				input_table_types[i] = target_type;
351: 			}
352: 		}
353: 	}
354: 
355: 	auto get = BindTableFunctionInternal(table_function, ref, std::move(parameters), std::move(named_parameters),
356: 	                                     std::move(input_table_types), std::move(input_table_names));
357: 	auto table_function_ref = make_uniq<BoundTableFunction>(std::move(get));
358: 	table_function_ref->subquery = std::move(subquery);
359: 	return std::move(table_function_ref);
360: }
361: 
362: } // namespace duckdb
[end of src/planner/binder/tableref/bind_table_function.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: