You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
(Nightly Build) Fuzzer: DuckDB Internal Error with the LEAST function
### What happens?

DuckDB with the nightly build throws an internal error with the LEAST function.

### To Reproduce

PoC (Any of the following can trigger this internal error):
```sql
SELECT LEAST('');
SELECT GREATEST('');
SELECT LEAST('abc');
```

Output:
```
INTERNAL Error: Function greatest returned a STRING_LITERAL or INTEGER_LITERAL type - return an explicit type instead
```

The internal error seems to occur when there is only one string argument with the LEAST/GREATEST function.

### OS:

Ubuntu 20.04

### DuckDB Version:

v1.0.1-dev3548 and v1.0.1-dev3542

### DuckDB Client:

Cli and Python

### Full Name:

Jingzhou Fu

### Affiliation:

Wingtecher Lab of Tsinghua University and ShuiMuYuLin Ltd.

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a source build

### Did you include all relevant data sets for reproducing the issue?

Not applicable - the reproduction does not require a data set

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://www.duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/common/extra_type_info.cpp]
1: #include "duckdb/common/extra_type_info.hpp"
2: #include "duckdb/common/serializer/deserializer.hpp"
3: #include "duckdb/common/enum_util.hpp"
4: #include "duckdb/common/numeric_utils.hpp"
5: #include "duckdb/common/serializer/serializer.hpp"
6: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
7: #include "duckdb/common/string_map_set.hpp"
8: 
9: namespace duckdb {
10: 
11: //===--------------------------------------------------------------------===//
12: // Extra Type Info
13: //===--------------------------------------------------------------------===//
14: ExtraTypeInfo::ExtraTypeInfo(ExtraTypeInfoType type) : type(type) {
15: }
16: ExtraTypeInfo::ExtraTypeInfo(ExtraTypeInfoType type, string alias) : type(type), alias(std::move(alias)) {
17: }
18: ExtraTypeInfo::~ExtraTypeInfo() {
19: }
20: shared_ptr<ExtraTypeInfo> ExtraTypeInfo::Copy() const {
21: 	return make_shared_ptr<ExtraTypeInfo>(*this);
22: }
23: 
24: static bool CompareModifiers(const vector<Value> &left, const vector<Value> &right) {
25: 	// Check if the common prefix of the properties is the same for both types
26: 	auto common_props = MinValue(left.size(), right.size());
27: 	for (idx_t i = 0; i < common_props; i++) {
28: 		if (left[i].type() != right[i].type()) {
29: 			return false;
30: 		}
31: 		// Special case for nulls:
32: 		// For type modifiers, NULL is equivalent to ANY
33: 		if (left[i].IsNull() || right[i].IsNull()) {
34: 			continue;
35: 		}
36: 		if (left[i] != right[i]) {
37: 			return false;
38: 		}
39: 	}
40: 	return true;
41: }
42: 
43: bool ExtraTypeInfo::Equals(ExtraTypeInfo *other_p) const {
44: 	if (type == ExtraTypeInfoType::INVALID_TYPE_INFO || type == ExtraTypeInfoType::STRING_TYPE_INFO ||
45: 	    type == ExtraTypeInfoType::GENERIC_TYPE_INFO) {
46: 		if (!other_p) {
47: 			if (!alias.empty()) {
48: 				return false;
49: 			}
50: 			//! We only need to compare aliases when both types have them in this case
51: 			return true;
52: 		}
53: 		if (alias != other_p->alias) {
54: 			return false;
55: 		}
56: 		if (!CompareModifiers(modifiers, other_p->modifiers)) {
57: 			return false;
58: 		}
59: 		return true;
60: 	}
61: 	if (!other_p) {
62: 		return false;
63: 	}
64: 	if (type != other_p->type) {
65: 		return false;
66: 	}
67: 	if (alias != other_p->alias) {
68: 		return false;
69: 	}
70: 	if (!CompareModifiers(modifiers, other_p->modifiers)) {
71: 		return false;
72: 	}
73: 	return EqualsInternal(other_p);
74: }
75: 
76: bool ExtraTypeInfo::EqualsInternal(ExtraTypeInfo *other_p) const {
77: 	// Do nothing
78: 	return true;
79: }
80: 
81: //===--------------------------------------------------------------------===//
82: // Decimal Type Info
83: //===--------------------------------------------------------------------===//
84: DecimalTypeInfo::DecimalTypeInfo() : ExtraTypeInfo(ExtraTypeInfoType::DECIMAL_TYPE_INFO) {
85: }
86: 
87: DecimalTypeInfo::DecimalTypeInfo(uint8_t width_p, uint8_t scale_p)
88:     : ExtraTypeInfo(ExtraTypeInfoType::DECIMAL_TYPE_INFO), width(width_p), scale(scale_p) {
89: 	D_ASSERT(width_p >= scale_p);
90: }
91: 
92: bool DecimalTypeInfo::EqualsInternal(ExtraTypeInfo *other_p) const {
93: 	auto &other = other_p->Cast<DecimalTypeInfo>();
94: 	return width == other.width && scale == other.scale;
95: }
96: 
97: shared_ptr<ExtraTypeInfo> DecimalTypeInfo::Copy() const {
98: 	return make_shared_ptr<DecimalTypeInfo>(*this);
99: }
100: 
101: //===--------------------------------------------------------------------===//
102: // String Type Info
103: //===--------------------------------------------------------------------===//
104: StringTypeInfo::StringTypeInfo() : ExtraTypeInfo(ExtraTypeInfoType::STRING_TYPE_INFO) {
105: }
106: 
107: StringTypeInfo::StringTypeInfo(string collation_p)
108:     : ExtraTypeInfo(ExtraTypeInfoType::STRING_TYPE_INFO), collation(std::move(collation_p)) {
109: }
110: 
111: bool StringTypeInfo::EqualsInternal(ExtraTypeInfo *other_p) const {
112: 	// collation info has no impact on equality
113: 	return true;
114: }
115: 
116: shared_ptr<ExtraTypeInfo> StringTypeInfo::Copy() const {
117: 	return make_shared_ptr<StringTypeInfo>(*this);
118: }
119: 
120: //===--------------------------------------------------------------------===//
121: // List Type Info
122: //===--------------------------------------------------------------------===//
123: ListTypeInfo::ListTypeInfo() : ExtraTypeInfo(ExtraTypeInfoType::LIST_TYPE_INFO) {
124: }
125: 
126: ListTypeInfo::ListTypeInfo(LogicalType child_type_p)
127:     : ExtraTypeInfo(ExtraTypeInfoType::LIST_TYPE_INFO), child_type(std::move(child_type_p)) {
128: }
129: 
130: bool ListTypeInfo::EqualsInternal(ExtraTypeInfo *other_p) const {
131: 	auto &other = other_p->Cast<ListTypeInfo>();
132: 	return child_type == other.child_type;
133: }
134: 
135: shared_ptr<ExtraTypeInfo> ListTypeInfo::Copy() const {
136: 	return make_shared_ptr<ListTypeInfo>(*this);
137: }
138: 
139: //===--------------------------------------------------------------------===//
140: // Struct Type Info
141: //===--------------------------------------------------------------------===//
142: StructTypeInfo::StructTypeInfo() : ExtraTypeInfo(ExtraTypeInfoType::STRUCT_TYPE_INFO) {
143: }
144: 
145: StructTypeInfo::StructTypeInfo(child_list_t<LogicalType> child_types_p)
146:     : ExtraTypeInfo(ExtraTypeInfoType::STRUCT_TYPE_INFO), child_types(std::move(child_types_p)) {
147: }
148: 
149: bool StructTypeInfo::EqualsInternal(ExtraTypeInfo *other_p) const {
150: 	auto &other = other_p->Cast<StructTypeInfo>();
151: 	return child_types == other.child_types;
152: }
153: 
154: shared_ptr<ExtraTypeInfo> StructTypeInfo::Copy() const {
155: 	return make_shared_ptr<StructTypeInfo>(*this);
156: }
157: 
158: //===--------------------------------------------------------------------===//
159: // Aggregate State Type Info
160: //===--------------------------------------------------------------------===//
161: AggregateStateTypeInfo::AggregateStateTypeInfo() : ExtraTypeInfo(ExtraTypeInfoType::AGGREGATE_STATE_TYPE_INFO) {
162: }
163: 
164: AggregateStateTypeInfo::AggregateStateTypeInfo(aggregate_state_t state_type_p)
165:     : ExtraTypeInfo(ExtraTypeInfoType::AGGREGATE_STATE_TYPE_INFO), state_type(std::move(state_type_p)) {
166: }
167: 
168: bool AggregateStateTypeInfo::EqualsInternal(ExtraTypeInfo *other_p) const {
169: 	auto &other = other_p->Cast<AggregateStateTypeInfo>();
170: 	return state_type.function_name == other.state_type.function_name &&
171: 	       state_type.return_type == other.state_type.return_type &&
172: 	       state_type.bound_argument_types == other.state_type.bound_argument_types;
173: }
174: 
175: shared_ptr<ExtraTypeInfo> AggregateStateTypeInfo::Copy() const {
176: 	return make_shared_ptr<AggregateStateTypeInfo>(*this);
177: }
178: 
179: //===--------------------------------------------------------------------===//
180: // User Type Info
181: //===--------------------------------------------------------------------===//
182: UserTypeInfo::UserTypeInfo() : ExtraTypeInfo(ExtraTypeInfoType::USER_TYPE_INFO) {
183: }
184: 
185: UserTypeInfo::UserTypeInfo(string name_p)
186:     : ExtraTypeInfo(ExtraTypeInfoType::USER_TYPE_INFO), user_type_name(std::move(name_p)) {
187: }
188: 
189: UserTypeInfo::UserTypeInfo(string name_p, vector<Value> modifiers_p)
190:     : ExtraTypeInfo(ExtraTypeInfoType::USER_TYPE_INFO), user_type_name(std::move(name_p)),
191:       user_type_modifiers(std::move(modifiers_p)) {
192: }
193: 
194: UserTypeInfo::UserTypeInfo(string catalog_p, string schema_p, string name_p, vector<Value> modifiers_p)
195:     : ExtraTypeInfo(ExtraTypeInfoType::USER_TYPE_INFO), catalog(std::move(catalog_p)), schema(std::move(schema_p)),
196:       user_type_name(std::move(name_p)), user_type_modifiers(std::move(modifiers_p)) {
197: }
198: 
199: bool UserTypeInfo::EqualsInternal(ExtraTypeInfo *other_p) const {
200: 	auto &other = other_p->Cast<UserTypeInfo>();
201: 	return other.user_type_name == user_type_name;
202: }
203: 
204: shared_ptr<ExtraTypeInfo> UserTypeInfo::Copy() const {
205: 	return make_shared_ptr<UserTypeInfo>(*this);
206: }
207: 
208: //===--------------------------------------------------------------------===//
209: // Enum Type Info
210: //===--------------------------------------------------------------------===//
211: PhysicalType EnumTypeInfo::DictType(idx_t size) {
212: 	if (size <= NumericLimits<uint8_t>::Maximum()) {
213: 		return PhysicalType::UINT8;
214: 	} else if (size <= NumericLimits<uint16_t>::Maximum()) {
215: 		return PhysicalType::UINT16;
216: 	} else if (size <= NumericLimits<uint32_t>::Maximum()) {
217: 		return PhysicalType::UINT32;
218: 	} else {
219: 		throw InternalException("Enum size must be lower than " + std::to_string(NumericLimits<uint32_t>::Maximum()));
220: 	}
221: }
222: 
223: template <class T>
224: struct EnumTypeInfoTemplated : public EnumTypeInfo {
225: 	explicit EnumTypeInfoTemplated(Vector &values_insert_order_p, idx_t size_p)
226: 	    : EnumTypeInfo(values_insert_order_p, size_p) {
227: 		D_ASSERT(values_insert_order_p.GetType().InternalType() == PhysicalType::VARCHAR);
228: 
229: 		UnifiedVectorFormat vdata;
230: 		values_insert_order.ToUnifiedFormat(size_p, vdata);
231: 
232: 		auto data = UnifiedVectorFormat::GetData<string_t>(vdata);
233: 		for (idx_t i = 0; i < size_p; i++) {
234: 			auto idx = vdata.sel->get_index(i);
235: 			if (!vdata.validity.RowIsValid(idx)) {
236: 				throw InternalException("Attempted to create ENUM type with NULL value");
237: 			}
238: 			if (values.count(data[idx]) > 0) {
239: 				throw InvalidInputException("Attempted to create ENUM type with duplicate value %s",
240: 				                            data[idx].GetString());
241: 			}
242: 			values[data[idx]] = UnsafeNumericCast<T>(i);
243: 		}
244: 	}
245: 
246: 	static shared_ptr<EnumTypeInfoTemplated> Deserialize(Deserializer &deserializer, uint32_t size) {
247: 		Vector values_insert_order(LogicalType::VARCHAR, size);
248: 		auto strings = FlatVector::GetData<string_t>(values_insert_order);
249: 
250: 		deserializer.ReadList(201, "values", [&](Deserializer::List &list, idx_t i) {
251: 			strings[i] = StringVector::AddStringOrBlob(values_insert_order, list.ReadElement<string>());
252: 		});
253: 		return make_shared_ptr<EnumTypeInfoTemplated>(values_insert_order, size);
254: 	}
255: 
256: 	const string_map_t<T> &GetValues() const {
257: 		return values;
258: 	}
259: 
260: 	EnumTypeInfoTemplated(const EnumTypeInfoTemplated &) = delete;
261: 	EnumTypeInfoTemplated &operator=(const EnumTypeInfoTemplated &) = delete;
262: 
263: private:
264: 	string_map_t<T> values;
265: };
266: 
267: EnumTypeInfo::EnumTypeInfo(Vector &values_insert_order_p, idx_t dict_size_p)
268:     : ExtraTypeInfo(ExtraTypeInfoType::ENUM_TYPE_INFO), values_insert_order(values_insert_order_p),
269:       dict_type(EnumDictType::VECTOR_DICT), dict_size(dict_size_p) {
270: }
271: 
272: const EnumDictType &EnumTypeInfo::GetEnumDictType() const {
273: 	return dict_type;
274: }
275: 
276: const Vector &EnumTypeInfo::GetValuesInsertOrder() const {
277: 	return values_insert_order;
278: }
279: 
280: const idx_t &EnumTypeInfo::GetDictSize() const {
281: 	return dict_size;
282: }
283: 
284: LogicalType EnumTypeInfo::CreateType(Vector &ordered_data, idx_t size) {
285: 	// Generate EnumTypeInfo
286: 	shared_ptr<ExtraTypeInfo> info;
287: 	auto enum_internal_type = EnumTypeInfo::DictType(size);
288: 	switch (enum_internal_type) {
289: 	case PhysicalType::UINT8:
290: 		info = make_shared_ptr<EnumTypeInfoTemplated<uint8_t>>(ordered_data, size);
291: 		break;
292: 	case PhysicalType::UINT16:
293: 		info = make_shared_ptr<EnumTypeInfoTemplated<uint16_t>>(ordered_data, size);
294: 		break;
295: 	case PhysicalType::UINT32:
296: 		info = make_shared_ptr<EnumTypeInfoTemplated<uint32_t>>(ordered_data, size);
297: 		break;
298: 	default:
299: 		throw InternalException("Invalid Physical Type for ENUMs");
300: 	}
301: 	// Generate Actual Enum Type
302: 	return LogicalType(LogicalTypeId::ENUM, info);
303: }
304: 
305: template <class T>
306: int64_t TemplatedGetPos(const string_map_t<T> &map, const string_t &key) {
307: 	auto it = map.find(key);
308: 	if (it == map.end()) {
309: 		return -1;
310: 	}
311: 	return it->second;
312: }
313: 
314: int64_t EnumType::GetPos(const LogicalType &type, const string_t &key) {
315: 	auto info = type.AuxInfo();
316: 	switch (type.InternalType()) {
317: 	case PhysicalType::UINT8:
318: 		return TemplatedGetPos(info->Cast<EnumTypeInfoTemplated<uint8_t>>().GetValues(), key);
319: 	case PhysicalType::UINT16:
320: 		return TemplatedGetPos(info->Cast<EnumTypeInfoTemplated<uint16_t>>().GetValues(), key);
321: 	case PhysicalType::UINT32:
322: 		return TemplatedGetPos(info->Cast<EnumTypeInfoTemplated<uint32_t>>().GetValues(), key);
323: 	default:
324: 		throw InternalException("ENUM can only have unsigned integers (except UINT64) as physical types");
325: 	}
326: }
327: 
328: string_t EnumType::GetString(const LogicalType &type, idx_t pos) {
329: 	D_ASSERT(pos < EnumType::GetSize(type));
330: 	return FlatVector::GetData<string_t>(EnumType::GetValuesInsertOrder(type))[pos];
331: }
332: 
333: shared_ptr<ExtraTypeInfo> EnumTypeInfo::Deserialize(Deserializer &deserializer) {
334: 	auto values_count = deserializer.ReadProperty<idx_t>(200, "values_count");
335: 	auto enum_internal_type = EnumTypeInfo::DictType(values_count);
336: 	switch (enum_internal_type) {
337: 	case PhysicalType::UINT8:
338: 		return EnumTypeInfoTemplated<uint8_t>::Deserialize(deserializer, NumericCast<uint32_t>(values_count));
339: 	case PhysicalType::UINT16:
340: 		return EnumTypeInfoTemplated<uint16_t>::Deserialize(deserializer, NumericCast<uint32_t>(values_count));
341: 	case PhysicalType::UINT32:
342: 		return EnumTypeInfoTemplated<uint32_t>::Deserialize(deserializer, NumericCast<uint32_t>(values_count));
343: 	default:
344: 		throw InternalException("Invalid Physical Type for ENUMs");
345: 	}
346: }
347: 
348: // Equalities are only used in enums with different catalog entries
349: bool EnumTypeInfo::EqualsInternal(ExtraTypeInfo *other_p) const {
350: 	auto &other = other_p->Cast<EnumTypeInfo>();
351: 	if (dict_type != other.dict_type) {
352: 		return false;
353: 	}
354: 	D_ASSERT(dict_type == EnumDictType::VECTOR_DICT);
355: 	// We must check if both enums have the same size
356: 	if (other.dict_size != dict_size) {
357: 		return false;
358: 	}
359: 	auto other_vector_ptr = FlatVector::GetData<string_t>(other.values_insert_order);
360: 	auto this_vector_ptr = FlatVector::GetData<string_t>(values_insert_order);
361: 
362: 	// Now we must check if all strings are the same
363: 	for (idx_t i = 0; i < dict_size; i++) {
364: 		if (!Equals::Operation(other_vector_ptr[i], this_vector_ptr[i])) {
365: 			return false;
366: 		}
367: 	}
368: 	return true;
369: }
370: 
371: void EnumTypeInfo::Serialize(Serializer &serializer) const {
372: 	ExtraTypeInfo::Serialize(serializer);
373: 
374: 	// Enums are special in that we serialize their values as a list instead of dumping the whole vector
375: 	auto strings = FlatVector::GetData<string_t>(values_insert_order);
376: 	serializer.WriteProperty(200, "values_count", dict_size);
377: 	serializer.WriteList(201, "values", dict_size,
378: 	                     [&](Serializer::List &list, idx_t i) { list.WriteElement(strings[i]); });
379: }
380: 
381: shared_ptr<ExtraTypeInfo> EnumTypeInfo::Copy() const {
382: 	Vector values_insert_order_copy(LogicalType::VARCHAR, false, false, 0);
383: 	values_insert_order_copy.Reference(values_insert_order);
384: 	return make_shared_ptr<EnumTypeInfo>(values_insert_order_copy, dict_size);
385: }
386: 
387: //===--------------------------------------------------------------------===//
388: // ArrayTypeInfo
389: //===--------------------------------------------------------------------===//
390: 
391: ArrayTypeInfo::ArrayTypeInfo(LogicalType child_type_p, uint32_t size_p)
392:     : ExtraTypeInfo(ExtraTypeInfoType::ARRAY_TYPE_INFO), child_type(std::move(child_type_p)), size(size_p) {
393: }
394: 
395: bool ArrayTypeInfo::EqualsInternal(ExtraTypeInfo *other_p) const {
396: 	auto &other = other_p->Cast<ArrayTypeInfo>();
397: 	return child_type == other.child_type && size == other.size;
398: }
399: 
400: shared_ptr<ExtraTypeInfo> ArrayTypeInfo::Copy() const {
401: 	return make_shared_ptr<ArrayTypeInfo>(*this);
402: }
403: 
404: //===--------------------------------------------------------------------===//
405: // Any Type Info
406: //===--------------------------------------------------------------------===//
407: AnyTypeInfo::AnyTypeInfo() : ExtraTypeInfo(ExtraTypeInfoType::ANY_TYPE_INFO) {
408: }
409: 
410: AnyTypeInfo::AnyTypeInfo(LogicalType target_type_p, idx_t cast_score_p)
411:     : ExtraTypeInfo(ExtraTypeInfoType::ANY_TYPE_INFO), target_type(std::move(target_type_p)), cast_score(cast_score_p) {
412: }
413: 
414: bool AnyTypeInfo::EqualsInternal(ExtraTypeInfo *other_p) const {
415: 	auto &other = other_p->Cast<AnyTypeInfo>();
416: 	return target_type == other.target_type && cast_score == other.cast_score;
417: }
418: 
419: shared_ptr<ExtraTypeInfo> AnyTypeInfo::Copy() const {
420: 	return make_shared_ptr<AnyTypeInfo>(*this);
421: }
422: 
423: //===--------------------------------------------------------------------===//
424: // Integer Literal Type Info
425: //===--------------------------------------------------------------------===//
426: IntegerLiteralTypeInfo::IntegerLiteralTypeInfo() : ExtraTypeInfo(ExtraTypeInfoType::INTEGER_LITERAL_TYPE_INFO) {
427: }
428: 
429: IntegerLiteralTypeInfo::IntegerLiteralTypeInfo(Value constant_value_p)
430:     : ExtraTypeInfo(ExtraTypeInfoType::INTEGER_LITERAL_TYPE_INFO), constant_value(std::move(constant_value_p)) {
431: }
432: 
433: bool IntegerLiteralTypeInfo::EqualsInternal(ExtraTypeInfo *other_p) const {
434: 	auto &other = other_p->Cast<IntegerLiteralTypeInfo>();
435: 	return constant_value == other.constant_value;
436: }
437: 
438: shared_ptr<ExtraTypeInfo> IntegerLiteralTypeInfo::Copy() const {
439: 	return make_shared_ptr<IntegerLiteralTypeInfo>(*this);
440: }
441: 
442: } // namespace duckdb
[end of src/common/extra_type_info.cpp]
[start of src/core_functions/scalar/generic/least.cpp]
1: #include "duckdb/common/operator/comparison_operators.hpp"
2: #include "duckdb/core_functions/scalar/generic_functions.hpp"
3: #include "duckdb/core_functions/create_sort_key.hpp"
4: #include "duckdb/planner/expression/bound_function_expression.hpp"
5: 
6: namespace duckdb {
7: 
8: template <class OP>
9: struct LeastOperator {
10: 	template <class T>
11: 	static T Operation(T left, T right) {
12: 		return OP::Operation(left, right) ? left : right;
13: 	}
14: };
15: 
16: struct LeastGreatestSortKeyState : public FunctionLocalState {
17: 	explicit LeastGreatestSortKeyState(idx_t column_count)
18: 	    : intermediate(LogicalType::BLOB), modifiers(OrderType::ASCENDING, OrderByNullType::NULLS_LAST) {
19: 		vector<LogicalType> types;
20: 		// initialize sort key chunk
21: 		for (idx_t i = 0; i < column_count; i++) {
22: 			types.push_back(LogicalType::BLOB);
23: 		}
24: 		sort_keys.Initialize(Allocator::DefaultAllocator(), types);
25: 	}
26: 
27: 	DataChunk sort_keys;
28: 	Vector intermediate;
29: 	OrderModifiers modifiers;
30: };
31: 
32: unique_ptr<FunctionLocalState> LeastGreatestSortKeyInit(ExpressionState &state, const BoundFunctionExpression &expr,
33:                                                         FunctionData *bind_data) {
34: 	return make_uniq<LeastGreatestSortKeyState>(expr.children.size());
35: }
36: 
37: template <bool STRING>
38: struct StandardLeastGreatest {
39: 	static constexpr bool IS_STRING = STRING;
40: 
41: 	static DataChunk &Prepare(DataChunk &args, ExpressionState &) {
42: 		return args;
43: 	}
44: 
45: 	static Vector &TargetVector(Vector &result, ExpressionState &) {
46: 		return result;
47: 	}
48: 
49: 	static void FinalizeResult(idx_t rows, bool result_has_value[], Vector &result, ExpressionState &) {
50: 		auto &result_mask = FlatVector::Validity(result);
51: 		for (idx_t i = 0; i < rows; i++) {
52: 			if (!result_has_value[i]) {
53: 				result_mask.SetInvalid(i);
54: 			}
55: 		}
56: 	}
57: };
58: 
59: struct SortKeyLeastGreatest {
60: 	static constexpr bool IS_STRING = false;
61: 
62: 	static DataChunk &Prepare(DataChunk &args, ExpressionState &state) {
63: 		auto &lstate = ExecuteFunctionState::GetFunctionState(state)->Cast<LeastGreatestSortKeyState>();
64: 		lstate.sort_keys.Reset();
65: 		for (idx_t c_idx = 0; c_idx < args.ColumnCount(); c_idx++) {
66: 			CreateSortKeyHelpers::CreateSortKey(args.data[c_idx], args.size(), lstate.modifiers,
67: 			                                    lstate.sort_keys.data[c_idx]);
68: 		}
69: 		lstate.sort_keys.SetCardinality(args.size());
70: 		return lstate.sort_keys;
71: 	}
72: 
73: 	static Vector &TargetVector(Vector &result, ExpressionState &state) {
74: 		auto &lstate = ExecuteFunctionState::GetFunctionState(state)->Cast<LeastGreatestSortKeyState>();
75: 		return lstate.intermediate;
76: 	}
77: 
78: 	static void FinalizeResult(idx_t rows, bool result_has_value[], Vector &result, ExpressionState &state) {
79: 		auto &lstate = ExecuteFunctionState::GetFunctionState(state)->Cast<LeastGreatestSortKeyState>();
80: 		auto result_keys = FlatVector::GetData<string_t>(lstate.intermediate);
81: 		auto &result_mask = FlatVector::Validity(result);
82: 		for (idx_t i = 0; i < rows; i++) {
83: 			if (!result_has_value[i]) {
84: 				result_mask.SetInvalid(i);
85: 			} else {
86: 				CreateSortKeyHelpers::DecodeSortKey(result_keys[i], result, i, lstate.modifiers);
87: 			}
88: 		}
89: 	}
90: };
91: 
92: template <class T, class OP, class BASE_OP = StandardLeastGreatest<false>>
93: static void LeastGreatestFunction(DataChunk &args, ExpressionState &state, Vector &result) {
94: 	if (args.ColumnCount() == 1) {
95: 		// single input: nop
96: 		result.Reference(args.data[0]);
97: 		return;
98: 	}
99: 	auto &input = BASE_OP::Prepare(args, state);
100: 	auto &result_vector = BASE_OP::TargetVector(result, state);
101: 
102: 	auto result_type = VectorType::CONSTANT_VECTOR;
103: 	for (idx_t col_idx = 0; col_idx < input.ColumnCount(); col_idx++) {
104: 		if (args.data[col_idx].GetVectorType() != VectorType::CONSTANT_VECTOR) {
105: 			// non-constant input: result is not a constant vector
106: 			result_type = VectorType::FLAT_VECTOR;
107: 		}
108: 		if (BASE_OP::IS_STRING) {
109: 			// for string vectors we add a reference to the heap of the children
110: 			StringVector::AddHeapReference(result_vector, input.data[col_idx]);
111: 		}
112: 	}
113: 
114: 	auto result_data = FlatVector::GetData<T>(result_vector);
115: 	bool result_has_value[STANDARD_VECTOR_SIZE] {false};
116: 	// perform the operation column-by-column
117: 	for (idx_t col_idx = 0; col_idx < input.ColumnCount(); col_idx++) {
118: 		if (input.data[col_idx].GetVectorType() == VectorType::CONSTANT_VECTOR &&
119: 		    ConstantVector::IsNull(input.data[col_idx])) {
120: 			// ignore null vector
121: 			continue;
122: 		}
123: 
124: 		UnifiedVectorFormat vdata;
125: 		input.data[col_idx].ToUnifiedFormat(input.size(), vdata);
126: 
127: 		auto input_data = UnifiedVectorFormat::GetData<T>(vdata);
128: 		if (!vdata.validity.AllValid()) {
129: 			// potential new null entries: have to check the null mask
130: 			for (idx_t i = 0; i < input.size(); i++) {
131: 				auto vindex = vdata.sel->get_index(i);
132: 				if (vdata.validity.RowIsValid(vindex)) {
133: 					// not a null entry: perform the operation and add to new set
134: 					auto ivalue = input_data[vindex];
135: 					if (!result_has_value[i] || OP::template Operation<T>(ivalue, result_data[i])) {
136: 						result_has_value[i] = true;
137: 						result_data[i] = ivalue;
138: 					}
139: 				}
140: 			}
141: 		} else {
142: 			// no new null entries: only need to perform the operation
143: 			for (idx_t i = 0; i < input.size(); i++) {
144: 				auto vindex = vdata.sel->get_index(i);
145: 
146: 				auto ivalue = input_data[vindex];
147: 				if (!result_has_value[i] || OP::template Operation<T>(ivalue, result_data[i])) {
148: 					result_has_value[i] = true;
149: 					result_data[i] = ivalue;
150: 				}
151: 			}
152: 		}
153: 	}
154: 	BASE_OP::FinalizeResult(input.size(), result_has_value, result, state);
155: 	result.SetVectorType(result_type);
156: }
157: 
158: template <class OP>
159: unique_ptr<FunctionData> BindLeastGreatest(ClientContext &context, ScalarFunction &bound_function,
160:                                            vector<unique_ptr<Expression>> &arguments) {
161: 	LogicalType child_type = ExpressionBinder::GetExpressionReturnType(*arguments[0]);
162: 	for (idx_t i = 1; i < arguments.size(); i++) {
163: 		auto arg_type = ExpressionBinder::GetExpressionReturnType(*arguments[i]);
164: 		if (!LogicalType::TryGetMaxLogicalType(context, child_type, arg_type, child_type)) {
165: 			throw BinderException(arguments[i]->query_location,
166: 			                      "Cannot combine types of %s and %s - an explicit cast is required",
167: 			                      child_type.ToString(), arg_type.ToString());
168: 		}
169: 	}
170: 	switch (child_type.id()) {
171: 	case LogicalTypeId::UNKNOWN:
172: 		throw ParameterNotResolvedException();
173: 	case LogicalTypeId::INTEGER_LITERAL:
174: 		child_type = IntegerLiteral::GetType(child_type);
175: 		break;
176: 	default:
177: 		break;
178: 	}
179: 	switch (child_type.InternalType()) {
180: 	case PhysicalType::BOOL:
181: 	case PhysicalType::INT8:
182: 		bound_function.function = LeastGreatestFunction<int8_t, OP>;
183: 		break;
184: 	case PhysicalType::INT16:
185: 		bound_function.function = LeastGreatestFunction<int16_t, OP>;
186: 		break;
187: 	case PhysicalType::INT32:
188: 		bound_function.function = LeastGreatestFunction<int32_t, OP>;
189: 		break;
190: 	case PhysicalType::INT64:
191: 		bound_function.function = LeastGreatestFunction<int64_t, OP>;
192: 		break;
193: 	case PhysicalType::INT128:
194: 		bound_function.function = LeastGreatestFunction<hugeint_t, OP>;
195: 		break;
196: 	case PhysicalType::DOUBLE:
197: 		bound_function.function = LeastGreatestFunction<double, OP>;
198: 		break;
199: 	case PhysicalType::VARCHAR:
200: 		bound_function.function = LeastGreatestFunction<string_t, OP, StandardLeastGreatest<true>>;
201: 		break;
202: 	default:
203: 		// fallback with sort keys
204: 		bound_function.function = LeastGreatestFunction<string_t, OP, SortKeyLeastGreatest>;
205: 		bound_function.init_local_state = LeastGreatestSortKeyInit;
206: 		break;
207: 	}
208: 	bound_function.arguments[0] = child_type;
209: 	bound_function.varargs = child_type;
210: 	bound_function.return_type = child_type;
211: 	return nullptr;
212: }
213: 
214: template <class OP>
215: ScalarFunction GetLeastGreatestFunction() {
216: 	return ScalarFunction({LogicalType::ANY}, LogicalType::ANY, nullptr, BindLeastGreatest<OP>, nullptr, nullptr,
217: 	                      nullptr, LogicalType::ANY, FunctionStability::CONSISTENT,
218: 	                      FunctionNullHandling::SPECIAL_HANDLING);
219: }
220: 
221: template <class OP>
222: static ScalarFunctionSet GetLeastGreatestFunctions() {
223: 	ScalarFunctionSet fun_set;
224: 	fun_set.AddFunction(GetLeastGreatestFunction<OP>());
225: 	return fun_set;
226: }
227: 
228: ScalarFunctionSet LeastFun::GetFunctions() {
229: 	return GetLeastGreatestFunctions<LessThan>();
230: }
231: 
232: ScalarFunctionSet GreatestFun::GetFunctions() {
233: 	return GetLeastGreatestFunctions<GreaterThan>();
234: }
235: 
236: } // namespace duckdb
[end of src/core_functions/scalar/generic/least.cpp]
[start of src/core_functions/scalar/union/union_extract.cpp]
1: #include "duckdb/core_functions/scalar/union_functions.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/execution/expression_executor.hpp"
4: #include "duckdb/planner/expression/bound_function_expression.hpp"
5: #include "duckdb/planner/expression/bound_parameter_expression.hpp"
6: 
7: namespace duckdb {
8: 
9: struct UnionExtractBindData : public FunctionData {
10: 	UnionExtractBindData(string key, idx_t index, LogicalType type)
11: 	    : key(std::move(key)), index(index), type(std::move(type)) {
12: 	}
13: 
14: 	string key;
15: 	idx_t index;
16: 	LogicalType type;
17: 
18: public:
19: 	unique_ptr<FunctionData> Copy() const override {
20: 		return make_uniq<UnionExtractBindData>(key, index, type);
21: 	}
22: 	bool Equals(const FunctionData &other_p) const override {
23: 		auto &other = other_p.Cast<UnionExtractBindData>();
24: 		return key == other.key && index == other.index && type == other.type;
25: 	}
26: };
27: 
28: static void UnionExtractFunction(DataChunk &args, ExpressionState &state, Vector &result) {
29: 	auto &func_expr = state.expr.Cast<BoundFunctionExpression>();
30: 	auto &info = func_expr.bind_info->Cast<UnionExtractBindData>();
31: 
32: 	// this should be guaranteed by the binder
33: 	auto &vec = args.data[0];
34: 	vec.Verify(args.size());
35: 
36: 	D_ASSERT(info.index < UnionType::GetMemberCount(vec.GetType()));
37: 	auto &member = UnionVector::GetMember(vec, info.index);
38: 	result.Reference(member);
39: 	result.Verify(args.size());
40: }
41: 
42: static unique_ptr<FunctionData> UnionExtractBind(ClientContext &context, ScalarFunction &bound_function,
43:                                                  vector<unique_ptr<Expression>> &arguments) {
44: 	D_ASSERT(bound_function.arguments.size() == 2);
45: 	if (arguments[0]->return_type.id() == LogicalTypeId::UNKNOWN) {
46: 		throw ParameterNotResolvedException();
47: 	}
48: 	D_ASSERT(LogicalTypeId::UNION == arguments[0]->return_type.id());
49: 	idx_t union_member_count = UnionType::GetMemberCount(arguments[0]->return_type);
50: 	if (union_member_count == 0) {
51: 		throw InternalException("Can't extract something from an empty union");
52: 	}
53: 	bound_function.arguments[0] = arguments[0]->return_type;
54: 
55: 	auto &key_child = arguments[1];
56: 	if (key_child->HasParameter()) {
57: 		throw ParameterNotResolvedException();
58: 	}
59: 
60: 	if (key_child->return_type.id() != LogicalTypeId::VARCHAR || !key_child->IsFoldable()) {
61: 		throw BinderException("Key name for union_extract needs to be a constant string");
62: 	}
63: 	Value key_val = ExpressionExecutor::EvaluateScalar(context, *key_child);
64: 	D_ASSERT(key_val.type().id() == LogicalTypeId::VARCHAR);
65: 	auto &key_str = StringValue::Get(key_val);
66: 	if (key_val.IsNull() || key_str.empty()) {
67: 		throw BinderException("Key name for union_extract needs to be neither NULL nor empty");
68: 	}
69: 	string key = StringUtil::Lower(key_str);
70: 
71: 	LogicalType return_type;
72: 	idx_t key_index = 0;
73: 	bool found_key = false;
74: 
75: 	for (size_t i = 0; i < union_member_count; i++) {
76: 		auto &member_name = UnionType::GetMemberName(arguments[0]->return_type, i);
77: 		if (StringUtil::Lower(member_name) == key) {
78: 			found_key = true;
79: 			key_index = i;
80: 			return_type = UnionType::GetMemberType(arguments[0]->return_type, i);
81: 			break;
82: 		}
83: 	}
84: 
85: 	if (!found_key) {
86: 		vector<string> candidates;
87: 		candidates.reserve(union_member_count);
88: 		for (idx_t i = 0; i < union_member_count; i++) {
89: 			candidates.push_back(UnionType::GetMemberName(arguments[0]->return_type, i));
90: 		}
91: 		auto closest_settings = StringUtil::TopNJaroWinkler(candidates, key);
92: 		auto message = StringUtil::CandidatesMessage(closest_settings, "Candidate Entries");
93: 		throw BinderException("Could not find key \"%s\" in union\n%s", key, message);
94: 	}
95: 
96: 	bound_function.return_type = return_type;
97: 	return make_uniq<UnionExtractBindData>(key, key_index, return_type);
98: }
99: 
100: ScalarFunction UnionExtractFun::GetFunction() {
101: 	// the arguments and return types are actually set in the binder function
102: 	return ScalarFunction({LogicalTypeId::UNION, LogicalType::VARCHAR}, LogicalType::ANY, UnionExtractFunction,
103: 	                      UnionExtractBind, nullptr, nullptr);
104: }
105: 
106: } // namespace duckdb
[end of src/core_functions/scalar/union/union_extract.cpp]
[start of src/planner/binder/expression/bind_comparison_expression.cpp]
1: #include "duckdb/parser/expression/comparison_expression.hpp"
2: #include "duckdb/planner/expression/bound_cast_expression.hpp"
3: #include "duckdb/planner/expression/bound_constant_expression.hpp"
4: #include "duckdb/planner/expression/bound_comparison_expression.hpp"
5: #include "duckdb/planner/expression/bound_function_expression.hpp"
6: #include "duckdb/planner/expression/bound_parameter_expression.hpp"
7: #include "duckdb/planner/expression_binder.hpp"
8: #include "duckdb/catalog/catalog_entry/collate_catalog_entry.hpp"
9: #include "duckdb/common/string_util.hpp"
10: 
11: #include "duckdb/function/scalar/string_functions.hpp"
12: 
13: #include "duckdb/common/types/decimal.hpp"
14: #include "duckdb/planner/collation_binding.hpp"
15: 
16: namespace duckdb {
17: 
18: bool ExpressionBinder::PushCollation(ClientContext &context, unique_ptr<Expression> &source,
19:                                      const LogicalType &sql_type) {
20: 	auto &collation_binding = CollationBinding::Get(context);
21: 	return collation_binding.PushCollation(context, source, sql_type);
22: }
23: 
24: void ExpressionBinder::TestCollation(ClientContext &context, const string &collation) {
25: 	auto expr = make_uniq_base<Expression, BoundConstantExpression>(Value(""));
26: 	PushCollation(context, expr, LogicalType::VARCHAR_COLLATION(collation));
27: }
28: 
29: static bool SwitchVarcharComparison(const LogicalType &type) {
30: 	switch (type.id()) {
31: 	case LogicalTypeId::TINYINT:
32: 	case LogicalTypeId::SMALLINT:
33: 	case LogicalTypeId::INTEGER:
34: 	case LogicalTypeId::BIGINT:
35: 	case LogicalTypeId::HUGEINT:
36: 	case LogicalTypeId::FLOAT:
37: 	case LogicalTypeId::DOUBLE:
38: 	case LogicalTypeId::DECIMAL:
39: 	case LogicalTypeId::UTINYINT:
40: 	case LogicalTypeId::USMALLINT:
41: 	case LogicalTypeId::UINTEGER:
42: 	case LogicalTypeId::UBIGINT:
43: 	case LogicalTypeId::UHUGEINT:
44: 	case LogicalTypeId::DATE:
45: 	case LogicalTypeId::TIME:
46: 	case LogicalTypeId::TIMESTAMP_SEC:
47: 	case LogicalTypeId::TIMESTAMP_MS:
48: 	case LogicalTypeId::TIMESTAMP:
49: 	case LogicalTypeId::TIMESTAMP_NS:
50: 	case LogicalTypeId::INTERVAL:
51: 	case LogicalTypeId::TIMESTAMP_TZ:
52: 	case LogicalTypeId::TIME_TZ:
53: 	case LogicalTypeId::INTEGER_LITERAL:
54: 		return true;
55: 	default:
56: 		return false;
57: 	}
58: }
59: 
60: bool BoundComparisonExpression::TryBindComparison(ClientContext &context, const LogicalType &left_type,
61:                                                   const LogicalType &right_type, LogicalType &result_type,
62:                                                   ExpressionType comparison_type) {
63: 	LogicalType res;
64: 	bool is_equality;
65: 	switch (comparison_type) {
66: 	case ExpressionType::COMPARE_EQUAL:
67: 	case ExpressionType::COMPARE_NOTEQUAL:
68: 	case ExpressionType::COMPARE_IN:
69: 	case ExpressionType::COMPARE_NOT_IN:
70: 	case ExpressionType::COMPARE_DISTINCT_FROM:
71: 	case ExpressionType::COMPARE_NOT_DISTINCT_FROM:
72: 		is_equality = true;
73: 		break;
74: 	default:
75: 		is_equality = false;
76: 		break;
77: 	}
78: 	if (is_equality) {
79: 		res = LogicalType::ForceMaxLogicalType(left_type, right_type);
80: 	} else {
81: 		if (!LogicalType::TryGetMaxLogicalType(context, left_type, right_type, res)) {
82: 			return false;
83: 		}
84: 	}
85: 	switch (res.id()) {
86: 	case LogicalTypeId::DECIMAL: {
87: 		// result is a decimal: we need the maximum width and the maximum scale over width
88: 		vector<LogicalType> argument_types = {left_type, right_type};
89: 		uint8_t max_width = 0, max_scale = 0, max_width_over_scale = 0;
90: 		for (idx_t i = 0; i < argument_types.size(); i++) {
91: 			uint8_t width, scale;
92: 			auto can_convert = argument_types[i].GetDecimalProperties(width, scale);
93: 			if (!can_convert) {
94: 				result_type = res;
95: 				return true;
96: 			}
97: 			max_width = MaxValue<uint8_t>(width, max_width);
98: 			max_scale = MaxValue<uint8_t>(scale, max_scale);
99: 			max_width_over_scale = MaxValue<uint8_t>(width - scale, max_width_over_scale);
100: 		}
101: 		max_width = MaxValue<uint8_t>(max_scale + max_width_over_scale, max_width);
102: 		if (max_width > Decimal::MAX_WIDTH_DECIMAL) {
103: 			// target width does not fit in decimal: truncate the scale (if possible) to try and make it fit
104: 			max_width = Decimal::MAX_WIDTH_DECIMAL;
105: 		}
106: 		res = LogicalType::DECIMAL(max_width, max_scale);
107: 		break;
108: 	}
109: 	case LogicalTypeId::VARCHAR:
110: 		// for comparison with strings, we prefer to bind to the numeric types
111: 		if (left_type.id() != LogicalTypeId::VARCHAR && SwitchVarcharComparison(left_type)) {
112: 			res = LogicalType::NormalizeType(left_type);
113: 		} else if (right_type.id() != LogicalTypeId::VARCHAR && SwitchVarcharComparison(right_type)) {
114: 			res = LogicalType::NormalizeType(right_type);
115: 		} else {
116: 			// else: check if collations are compatible
117: 			auto left_collation = StringType::GetCollation(left_type);
118: 			auto right_collation = StringType::GetCollation(right_type);
119: 			if (!left_collation.empty() && !right_collation.empty() && left_collation != right_collation) {
120: 				throw BinderException("Cannot combine types with different collation!");
121: 			}
122: 		}
123: 		break;
124: 	default:
125: 		break;
126: 	}
127: 	result_type = res;
128: 	return true;
129: }
130: 
131: LogicalType BoundComparisonExpression::BindComparison(ClientContext &context, const LogicalType &left_type,
132:                                                       const LogicalType &right_type, ExpressionType comparison_type) {
133: 	LogicalType result_type;
134: 	if (!BoundComparisonExpression::TryBindComparison(context, left_type, right_type, result_type, comparison_type)) {
135: 		throw BinderException("Cannot mix values of type %s and %s - an explicit cast is required",
136: 		                      left_type.ToString(), right_type.ToString());
137: 	}
138: 	return result_type;
139: }
140: 
141: LogicalType ExpressionBinder::GetExpressionReturnType(const Expression &expr) {
142: 	if (expr.expression_class == ExpressionClass::BOUND_CONSTANT) {
143: 		if (expr.return_type == LogicalTypeId::VARCHAR && StringType::GetCollation(expr.return_type).empty()) {
144: 			return LogicalTypeId::STRING_LITERAL;
145: 		}
146: 		if (expr.return_type.IsIntegral()) {
147: 			auto &constant = expr.Cast<BoundConstantExpression>();
148: 			return LogicalType::INTEGER_LITERAL(constant.value);
149: 		}
150: 	}
151: 	return expr.return_type;
152: }
153: 
154: BindResult ExpressionBinder::BindExpression(ComparisonExpression &expr, idx_t depth) {
155: 	// first try to bind the children of the case expression
156: 	ErrorData error;
157: 	BindChild(expr.left, depth, error);
158: 	BindChild(expr.right, depth, error);
159: 	if (error.HasError()) {
160: 		return BindResult(std::move(error));
161: 	}
162: 
163: 	// the children have been successfully resolved
164: 	auto &left = BoundExpression::GetExpression(*expr.left);
165: 	auto &right = BoundExpression::GetExpression(*expr.right);
166: 	auto left_sql_type = ExpressionBinder::GetExpressionReturnType(*left);
167: 	auto right_sql_type = ExpressionBinder::GetExpressionReturnType(*right);
168: 	// cast the input types to the same type
169: 	// now obtain the result type of the input types
170: 	LogicalType input_type;
171: 	if (!BoundComparisonExpression::TryBindComparison(context, left_sql_type, right_sql_type, input_type, expr.type)) {
172: 		return BindResult(BinderException(expr,
173: 		                                  "Cannot compare values of type %s and type %s - an explicit cast is required",
174: 		                                  left_sql_type.ToString(), right_sql_type.ToString()));
175: 	}
176: 	// add casts (if necessary)
177: 	left = BoundCastExpression::AddCastToType(context, std::move(left), input_type,
178: 	                                          input_type.id() == LogicalTypeId::ENUM);
179: 	right = BoundCastExpression::AddCastToType(context, std::move(right), input_type,
180: 	                                           input_type.id() == LogicalTypeId::ENUM);
181: 
182: 	PushCollation(context, left, input_type);
183: 	PushCollation(context, right, input_type);
184: 
185: 	// now create the bound comparison expression
186: 	return BindResult(make_uniq<BoundComparisonExpression>(expr.type, std::move(left), std::move(right)));
187: }
188: 
189: } // namespace duckdb
[end of src/planner/binder/expression/bind_comparison_expression.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: