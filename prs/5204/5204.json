{
  "repo": "duckdb/duckdb",
  "pull_number": 5204,
  "instance_id": "duckdb__duckdb-5204",
  "issue_numbers": [
    "5063",
    "5145"
  ],
  "base_commit": "866efc2db6632bbccd281a8f47be5e4dfde530a7",
  "patch": "diff --git a/extension/json/include/json_common.hpp b/extension/json/include/json_common.hpp\nindex 26733a444914..f8030e5a7c14 100644\n--- a/extension/json/include/json_common.hpp\n+++ b/extension/json/include/json_common.hpp\n@@ -221,7 +221,7 @@ struct JSONCommon {\n \t\t}\n \t\tdefault:\n \t\t\tauto str = \"/\" + string(ptr, len);\n-\t\t\treturn GetPointerUnsafe<YYJSON_VAL_T>(root, str.c_str(), len);\n+\t\t\treturn GetPointerUnsafe<YYJSON_VAL_T>(root, str.c_str(), len + 1);\n \t\t}\n \t}\n \ndiff --git a/src/parser/expression/lambda_expression.cpp b/src/parser/expression/lambda_expression.cpp\nindex 82843592daef..eb369a358966 100644\n--- a/src/parser/expression/lambda_expression.cpp\n+++ b/src/parser/expression/lambda_expression.cpp\n@@ -18,7 +18,6 @@ bool LambdaExpression::Equals(const LambdaExpression *a, const LambdaExpression\n }\n \n hash_t LambdaExpression::Hash() const {\n-\n \thash_t result = lhs->Hash();\n \tParsedExpression::Hash();\n \tresult = CombineHash(result, expr->Hash());\n@@ -26,7 +25,9 @@ hash_t LambdaExpression::Hash() const {\n }\n \n unique_ptr<ParsedExpression> LambdaExpression::Copy() const {\n-\treturn make_unique<LambdaExpression>(lhs->Copy(), expr->Copy());\n+\tauto copy = make_unique<LambdaExpression>(lhs->Copy(), expr->Copy());\n+\tcopy->CopyProperties(*this);\n+\treturn move(copy);\n }\n \n void LambdaExpression::Serialize(FieldWriter &writer) const {\ndiff --git a/src/storage/buffer_manager.cpp b/src/storage/buffer_manager.cpp\nindex 9c10e1df7ee5..07de643af938 100644\n--- a/src/storage/buffer_manager.cpp\n+++ b/src/storage/buffer_manager.cpp\n@@ -4,8 +4,8 @@\n #include \"duckdb/common/exception.hpp\"\n #include \"duckdb/common/set.hpp\"\n #include \"duckdb/parallel/concurrentqueue.hpp\"\n-#include \"duckdb/storage/storage_manager.hpp\"\n #include \"duckdb/storage/in_memory_block_manager.hpp\"\n+#include \"duckdb/storage/storage_manager.hpp\"\n \n namespace duckdb {\n \n@@ -57,7 +57,7 @@ BlockHandle::BlockHandle(BlockManager &block_manager, block_id_t block_id_p, uni\n       unswizzled(nullptr) {\n \tbuffer = move(buffer_p);\n \tstate = BlockState::BLOCK_LOADED;\n-\tmemory_usage = buffer->AllocSize();\n+\tmemory_usage = block_size;\n \tmemory_charge = move(reservation);\n }\n \n@@ -333,7 +333,7 @@ shared_ptr<BlockHandle> BufferManager::RegisterMemory(idx_t block_size, bool can\n \tauto buffer = ConstructManagedBuffer(block_size, move(reusable_buffer));\n \n \t// create a new block pointer for this block\n-\treturn make_shared<BlockHandle>(*temp_block_manager, ++temporary_id, move(buffer), can_destroy, block_size,\n+\treturn make_shared<BlockHandle>(*temp_block_manager, ++temporary_id, move(buffer), can_destroy, alloc_size,\n \t                                move(res));\n }\n \n",
  "test_patch": "diff --git a/test/sql/json/test_json_extract.test b/test/sql/json/test_json_extract.test\nindex 80c3281aebe6..7a20fd45e613 100644\n--- a/test/sql/json/test_json_extract.test\n+++ b/test/sql/json/test_json_extract.test\n@@ -251,3 +251,19 @@ query T\n SELECT x::JSON->'$.settings.layer2.\"tris.legomenon\".\"summary.report\"' FROM t12;\n ----\n false\n+\n+# can't deal with force reload / force storage (#5132)\n+\n+require skip_reload\n+\n+# test issue #5063\n+statement ok\n+create table test5063 as select '{\"a\": 1, \"b\": 2}' js\n+\n+statement ok\n+prepare q1 as SELECT js->CAST(? AS STRING) FROM test5063\n+\n+query T\n+execute q1('a')\n+----\n+1\ndiff --git a/test/sql/storage/test_buffer_manager.cpp b/test/sql/storage/test_buffer_manager.cpp\nindex c54078d16e8e..5e267a91cb8b 100644\n--- a/test/sql/storage/test_buffer_manager.cpp\n+++ b/test/sql/storage/test_buffer_manager.cpp\n@@ -285,3 +285,22 @@ TEST_CASE(\"Test buffer reallocation\", \"[storage][.]\") {\n \t\tD_ASSERT(buffer_manager.GetUsedMemory() == align(requested_size + Storage::BLOCK_HEADER_SIZE));\n \t}\n }\n+\n+TEST_CASE(\"Test buffer manager variable size allocations\", \"[storage][.]\") {\n+\tauto storage_database = TestCreatePath(\"storage_test\");\n+\tauto config = GetTestConfig();\n+\t// make sure the database does not exist\n+\tDeleteDatabase(storage_database);\n+\tDuckDB db(storage_database, config.get());\n+\tConnection con(db);\n+\n+\tauto &buffer_manager = BufferManager::GetBufferManager(*con.context);\n+\tD_ASSERT(buffer_manager.GetUsedMemory() == 0);\n+\n+\tidx_t requested_size = 424242;\n+\tauto block = buffer_manager.RegisterMemory(requested_size, false);\n+\tD_ASSERT(buffer_manager.GetUsedMemory() >= requested_size + Storage::BLOCK_HEADER_SIZE);\n+\n+\tblock.reset();\n+\tD_ASSERT(buffer_manager.GetUsedMemory() == 0);\n+}\n",
  "problem_statement": "JSON extract (`->`) sometimes doesn't work if path is parametrized\n### What happens?\n\nThe behavior of the JSON extract operator (`->`) varies if the path is parametrized or a literal.\n\n### To Reproduce\n\nThis script reproduces the issue. I've run it on both 5.1 and dev.\r\n\r\n```python\r\nimport duckdb\r\n\r\ncon = duckdb.connect()\r\n\r\ncon.execute(\"CREATE TABLE test(js JSON);\")\r\ncon.execute('INSERT INTO test VALUES (\\'{\"a\": 1, \"b\": 2}\\')')\r\n\r\n# Literal: OK\r\nres = con.execute(\"SELECT js->'a' FROM test\").fetchall()\r\nprint(res)\r\n\r\n# Literal with cast: OK\r\nres = con.execute(\"SELECT js->CAST('a' AS STRING) FROM test\").fetchall()\r\nprint(res)\r\n\r\n# Parameter: OK\r\nres = con.execute(\"SELECT js->? FROM test\", (\"a\",)).fetchall()\r\nprint(res)\r\n\r\n# Parameter with Cast: Broken\r\nres = con.execute(\"SELECT js->CAST(? AS STRING) FROM test\", (\"a\",)).fetchall()\r\nprint(res)\r\n\r\n# Parameter with Cast and 2nd parameter: OK\r\nres = con.execute(\"SELECT js->CAST(? AS STRING), ? FROM test\", (\"a\", 2)).fetchall()\r\nprint(res)\r\n```\r\n\r\nOutput:\r\n\r\n```\r\n[('1',)]\r\n[('1',)]\r\n[('1',)]\r\n[('{\"a\":1,\"b\":2}',)]\r\n[('1', 2)]\r\n```\n\n### OS:\n\nlinux\n\n### DuckDB Version:\n\n0.5.1\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nJim Crist-Harif\n\n### Affiliation:\n\nVoltron Data\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\nBug in current_memory calculation of buffer manager\n### What happens?\r\n\r\nWhen running a query involving sort code, then the current_memory size increases by 24 bytes, even though it should not change.\r\n\r\n### To Reproduce\r\n\r\n```c++\r\nTEST_CASE(\"Test buffer manager\", \"[art][.]\") {\r\n\tauto storage_database = TestCreatePath(\"storage_test\");\r\n\tauto config = GetTestConfig();\r\n\t// make sure the database does not exist\r\n\tDeleteDatabase(storage_database);\r\n\tDuckDB db(storage_database, config.get());\r\n\tConnection con(db);\r\n\r\n\tidx_t current_memory = 0;\r\n\tauto &buffer_manager = BufferManager::GetBufferManager(*con.context);\r\n\tD_ASSERT(buffer_manager.GetUsedMemory() == current_memory);\r\n\r\n\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE leaf AS SELECT 42 AS id FROM range(42);\"));\r\n\tcurrent_memory = buffer_manager.GetUsedMemory();\r\n\r\n\tREQUIRE_NO_FAIL(con.Query(\"SELECT * FROM leaf ORDER BY 1;\"));\r\n\tD_ASSERT(buffer_manager.GetUsedMemory() == current_memory);\r\n}\r\n```\r\n\r\n### OS:\r\n\r\niOS\r\n\r\n### DuckDB Version:\r\n\r\nMaster\r\n\r\n### DuckDB Client:\r\n\r\nCLI/ test runner\r\n\r\n### Full Name:\r\n\r\nTania Bogatsch\r\n\r\n### Affiliation:\r\n\r\nDuckDB Labs\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "Thanks for the report. I will look into this when I get the time.\nIs it possible that the sort (temporarily) requires extra memory, and that's the footprint we're seeing?",
  "created_at": "2022-11-04T14:54:20Z"
}