diff --git a/extension/icu/icu-extension.cpp b/extension/icu/icu-extension.cpp
index 240772402422..07245f0f60af 100644
--- a/extension/icu/icu-extension.cpp
+++ b/extension/icu/icu-extension.cpp
@@ -87,7 +87,7 @@ void ICUExtension::Load(DuckDB &db) {
 		}
 		collation = StringUtil::Lower(collation);
 
-		CreateCollationInfo info(collation, get_icu_function(collation), false);
+		CreateCollationInfo info(collation, get_icu_function(collation), false, true);
 		info.on_conflict = OnCreateConflict::IGNORE;
 		db.catalog->CreateCollation(*con.context, &info);
 	}
diff --git a/src/execution/expression_executor/execute_function.cpp b/src/execution/expression_executor/execute_function.cpp
index 94b6aecb3c81..a4bc9f3887f8 100644
--- a/src/execution/expression_executor/execute_function.cpp
+++ b/src/execution/expression_executor/execute_function.cpp
@@ -36,11 +36,7 @@ void ExpressionExecutor::Execute(BoundFunctionExpression &expr, ExpressionState
 			Execute(*expr.children[i], state->child_states[i].get(), sel, count, arguments.data[i]);
 #ifdef DEBUG
 			if (expr.arguments[i].id == SQLTypeId::VARCHAR) {
-				if (sel) {
-					arguments.data[i].UTFVerify(*sel, count);
-				} else {
-					arguments.data[i].UTFVerify(count);
-				}
+				arguments.data[i].UTFVerify(count);
 			}
 #endif
 		}
diff --git a/src/function/aggregate/algebraic/stddev.cpp b/src/function/aggregate/algebraic/stddev.cpp
index 82cd8160d264..5cefefa6824e 100644
--- a/src/function/aggregate/algebraic/stddev.cpp
+++ b/src/function/aggregate/algebraic/stddev.cpp
@@ -69,6 +69,9 @@ struct VarSampOperation : public STDDevBaseOperation {
 			nullmask[idx] = true;
 		} else {
 			target[idx] = state->count > 1 ? (state->dsquared / (state->count - 1)) : 0;
+			if (!Value::DoubleIsValid(target[idx])) {
+				throw OutOfRangeException("VARSAMP is out of range!");
+			}
 		}
 	}
 };
@@ -80,6 +83,9 @@ struct VarPopOperation : public STDDevBaseOperation {
 			nullmask[idx] = true;
 		} else {
 			target[idx] = state->count > 1 ? (state->dsquared / state->count) : 0;
+			if (!Value::DoubleIsValid(target[idx])) {
+				throw OutOfRangeException("VARPOP is out of range!");
+			}
 		}
 	}
 };
@@ -91,6 +97,9 @@ struct STDDevSampOperation : public STDDevBaseOperation {
 			nullmask[idx] = true;
 		} else {
 			target[idx] = state->count > 1 ? sqrt(state->dsquared / (state->count - 1)) : 0;
+			if (!Value::DoubleIsValid(target[idx])) {
+				throw OutOfRangeException("STDDEV_SAMP is out of range!");
+			}
 		}
 	}
 };
@@ -102,6 +111,9 @@ struct STDDevPopOperation : public STDDevBaseOperation {
 			nullmask[idx] = true;
 		} else {
 			target[idx] = state->count > 1 ? sqrt(state->dsquared / state->count) : 0;
+			if (!Value::DoubleIsValid(target[idx])) {
+				throw OutOfRangeException("STDDEV_POP is out of range!");
+			}
 		}
 	}
 };
diff --git a/src/function/function.cpp b/src/function/function.cpp
index d734ee18c38a..0a7adf9fe506 100644
--- a/src/function/function.cpp
+++ b/src/function/function.cpp
@@ -43,8 +43,8 @@ void BuiltinFunctions::Initialize() {
 BuiltinFunctions::BuiltinFunctions(ClientContext &context, Catalog &catalog) : context(context), catalog(catalog) {
 }
 
-void BuiltinFunctions::AddCollation(string name, ScalarFunction function, bool combinable) {
-	CreateCollationInfo info(move(name), move(function), combinable);
+void BuiltinFunctions::AddCollation(string name, ScalarFunction function, bool combinable, bool not_required_for_equality) {
+	CreateCollationInfo info(move(name), move(function), combinable, not_required_for_equality);
 	catalog.CreateCollation(context, &info);
 }
 
diff --git a/src/include/duckdb/catalog/catalog_entry/collate_catalog_entry.hpp b/src/include/duckdb/catalog/catalog_entry/collate_catalog_entry.hpp
index e7fe0bf3d4ec..768620fcdc68 100644
--- a/src/include/duckdb/catalog/catalog_entry/collate_catalog_entry.hpp
+++ b/src/include/duckdb/catalog/catalog_entry/collate_catalog_entry.hpp
@@ -19,10 +19,14 @@ class CollateCatalogEntry : public StandardEntry {
 public:
 	CollateCatalogEntry(Catalog *catalog, SchemaCatalogEntry *schema, CreateCollationInfo *info)
 	    : StandardEntry(CatalogType::COLLATION, schema, catalog, info->name), function(info->function),
-	      combinable(info->combinable) {
+	      combinable(info->combinable), not_required_for_equality(info->not_required_for_equality) {
 	}
 
+	//! The collation function to push in case collation is required
 	ScalarFunction function;
+	//! Whether or not the collation can be combined with other collations.
 	bool combinable;
+	//! Whether or not the collation is required for equality comparisons or not. For many collations a binary comparison for equality comparisons is correct, allowing us to skip the collation in these cases which greatly speeds up processing.
+	bool not_required_for_equality;
 };
 } // namespace duckdb
diff --git a/src/include/duckdb/function/function.hpp b/src/include/duckdb/function/function.hpp
index 8eed1867ab21..d46aad2e366c 100644
--- a/src/include/duckdb/function/function.hpp
+++ b/src/include/duckdb/function/function.hpp
@@ -111,7 +111,7 @@ class BuiltinFunctions {
 	void AddFunction(vector<string> names, ScalarFunction function);
 	void AddFunction(TableFunction function);
 
-	void AddCollation(string name, ScalarFunction function, bool combinable = false);
+	void AddCollation(string name, ScalarFunction function, bool combinable = false, bool not_required_for_equality = false);
 
 private:
 	ClientContext &context;
diff --git a/src/include/duckdb/parser/parsed_data/create_collation_info.hpp b/src/include/duckdb/parser/parsed_data/create_collation_info.hpp
index a0cfb11e7aeb..87d193b84926 100644
--- a/src/include/duckdb/parser/parsed_data/create_collation_info.hpp
+++ b/src/include/duckdb/parser/parsed_data/create_collation_info.hpp
@@ -14,14 +14,19 @@
 namespace duckdb {
 
 struct CreateCollationInfo : public CreateInfo {
-	CreateCollationInfo(string name_p, ScalarFunction function_p, bool combinable_p)
-	    : CreateInfo(CatalogType::COLLATION), function(move(function_p)), combinable(combinable_p) {
+	CreateCollationInfo(string name_p, ScalarFunction function_p, bool combinable_p, bool not_required_for_equality_p)
+	    : CreateInfo(CatalogType::COLLATION), function(move(function_p)), combinable(combinable_p), not_required_for_equality(not_required_for_equality_p) {
 		this->name = move(name_p);
 	}
 
+	//! The name of the collation
 	string name;
+	//! The collation function to push in case collation is required
 	ScalarFunction function;
+	//! Whether or not the collation can be combined with other collations.
 	bool combinable;
+	//! Whether or not the collation is required for equality comparisons or not. For many collations a binary comparison for equality comparisons is correct, allowing us to skip the collation in these cases which greatly speeds up processing.
+	bool not_required_for_equality;
 };
 
 } // namespace duckdb
diff --git a/src/include/duckdb/planner/expression_binder.hpp b/src/include/duckdb/planner/expression_binder.hpp
index 51662ffeac24..2838eadcdb72 100644
--- a/src/include/duckdb/planner/expression_binder.hpp
+++ b/src/include/duckdb/planner/expression_binder.hpp
@@ -57,7 +57,7 @@ class ExpressionBinder {
 	// Bind table names to ColumnRefExpressions
 	static void BindTableNames(Binder &binder, ParsedExpression &expr);
 	static unique_ptr<Expression> PushCollation(ClientContext &context, unique_ptr<Expression> source,
-	                                            string collation);
+	                                            string collation, bool equality_only = false);
 
 	bool BindCorrelatedColumns(unique_ptr<ParsedExpression> &expr);
 
diff --git a/src/planner/binder/expression/bind_comparison_expression.cpp b/src/planner/binder/expression/bind_comparison_expression.cpp
index 7d11e7222713..dc053e8dfb99 100644
--- a/src/planner/binder/expression/bind_comparison_expression.cpp
+++ b/src/planner/binder/expression/bind_comparison_expression.cpp
@@ -14,7 +14,7 @@ using namespace duckdb;
 using namespace std;
 
 unique_ptr<Expression> ExpressionBinder::PushCollation(ClientContext &context, unique_ptr<Expression> source,
-                                                       string collation) {
+                                                       string collation, bool equality_only) {
 	// replace default collation with system collation
 	if (collation.empty()) {
 		collation = context.db.collation;
@@ -40,6 +40,9 @@ unique_ptr<Expression> ExpressionBinder::PushCollation(ClientContext &context, u
 		}
 	}
 	for (auto &collation_entry : entries) {
+		if (equality_only && collation_entry->not_required_for_equality) {
+			continue;
+		}
 		auto function = make_unique<BoundFunctionExpression>(TypeId::VARCHAR, collation_entry->function);
 		function->children.push_back(move(source));
 		function->arguments.push_back({SQLType::VARCHAR});
@@ -88,8 +91,8 @@ BindResult ExpressionBinder::BindExpression(ComparisonExpression &expr, idx_t de
 	right.expr = BoundCastExpression::AddCastToType(move(right.expr), right.sql_type, input_type);
 	if (input_type.id == SQLTypeId::VARCHAR) {
 		// handle collation
-		left.expr = PushCollation(context, move(left.expr), input_type.collation);
-		right.expr = PushCollation(context, move(right.expr), input_type.collation);
+		left.expr = PushCollation(context, move(left.expr), input_type.collation, expr.type == ExpressionType::COMPARE_EQUAL);
+		right.expr = PushCollation(context, move(right.expr), input_type.collation, expr.type == ExpressionType::COMPARE_EQUAL);
 	}
 	// now create the bound comparison expression
 	return BindResult(make_unique<BoundComparisonExpression>(expr.type, move(left.expr), move(right.expr)),
diff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp
index d1d10c6d5192..c967a4902728 100644
--- a/src/planner/binder/query_node/bind_select_node.cpp
+++ b/src/planner/binder/query_node/bind_select_node.cpp
@@ -137,7 +137,7 @@ void Binder::BindModifierTypes(BoundQueryNode &result, const vector<SQLType> &sq
 				auto &bound_colref = (BoundColumnRefExpression &)*distinct.target_distincts[i];
 				auto sql_type = sql_types[bound_colref.binding.column_index];
 				if (sql_type.id == SQLTypeId::VARCHAR) {
-					distinct.target_distincts[i] = ExpressionBinder::PushCollation(context, move(distinct.target_distincts[i]), sql_type.collation);
+					distinct.target_distincts[i] = ExpressionBinder::PushCollation(context, move(distinct.target_distincts[i]), sql_type.collation, true);
 				}
 			}
 			break;
@@ -240,6 +240,8 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {
 			auto bound_expr = group_binder.Bind(statement.groups[i], &group_type);
 			assert(bound_expr->return_type != TypeId::INVALID);
 			info.group_types.push_back(group_type);
+			// push a potential collation, if necessary
+			bound_expr = ExpressionBinder::PushCollation(context, move(bound_expr), group_type.collation, true);
 			result->groups.push_back(move(bound_expr));
 
 			// in the unbound expression we DO bind the table names of any ColumnRefs
diff --git a/src/storage/string_segment.cpp b/src/storage/string_segment.cpp
index eb1d8ff17139..c30bd083f884 100644
--- a/src/storage/string_segment.cpp
+++ b/src/storage/string_segment.cpp
@@ -682,9 +682,7 @@ string_update_info_t StringSegment::CreateStringUpdate(SegmentStatistics &stats,
 		if (!update_nullmask[i]) {
 			auto min = (char *)stats.minimum.get();
 			auto max = (char *)stats.maximum.get();
-			for (idx_t i = 0; i < count; i++) {
-				update_min_max(strings[i].GetData(), min, max);
-			}
+			update_min_max(strings[i].GetData(), min, max);
 			WriteString(strings[i], info->block_ids[i], info->offsets[i]);
 		} else {
 			info->block_ids[i] = INVALID_BLOCK;
diff --git a/third_party/libpg_query/pg_functions.cpp b/third_party/libpg_query/pg_functions.cpp
index 2cc4d23f2b83..d495cefee2f4 100644
--- a/third_party/libpg_query/pg_functions.cpp
+++ b/third_party/libpg_query/pg_functions.cpp
@@ -161,7 +161,7 @@ void* palloc0fast(size_t n) { // very fast
     return palloc(n);
 }
 void* repalloc(void* ptr, size_t n) {
-    throw std::runtime_error("repalloc NOT IMPLEMENTED");
+	return palloc(n);
 }
 char *NameListToString(PGList *names) {
     throw std::runtime_error("NameListToString NOT IMPLEMENTED");
