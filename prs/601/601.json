{
  "repo": "duckdb/duckdb",
  "pull_number": 601,
  "instance_id": "duckdb__duckdb-601",
  "issue_numbers": [
    "603"
  ],
  "base_commit": "c0fe270145e2ade0c0bfe38220aca06d2012f2d9",
  "patch": "diff --git a/extension/icu/icu-extension.cpp b/extension/icu/icu-extension.cpp\nindex 240772402422..07245f0f60af 100644\n--- a/extension/icu/icu-extension.cpp\n+++ b/extension/icu/icu-extension.cpp\n@@ -87,7 +87,7 @@ void ICUExtension::Load(DuckDB &db) {\n \t\t}\n \t\tcollation = StringUtil::Lower(collation);\n \n-\t\tCreateCollationInfo info(collation, get_icu_function(collation), false);\n+\t\tCreateCollationInfo info(collation, get_icu_function(collation), false, true);\n \t\tinfo.on_conflict = OnCreateConflict::IGNORE;\n \t\tdb.catalog->CreateCollation(*con.context, &info);\n \t}\ndiff --git a/src/execution/expression_executor/execute_function.cpp b/src/execution/expression_executor/execute_function.cpp\nindex 94b6aecb3c81..a4bc9f3887f8 100644\n--- a/src/execution/expression_executor/execute_function.cpp\n+++ b/src/execution/expression_executor/execute_function.cpp\n@@ -36,11 +36,7 @@ void ExpressionExecutor::Execute(BoundFunctionExpression &expr, ExpressionState\n \t\t\tExecute(*expr.children[i], state->child_states[i].get(), sel, count, arguments.data[i]);\n #ifdef DEBUG\n \t\t\tif (expr.arguments[i].id == SQLTypeId::VARCHAR) {\n-\t\t\t\tif (sel) {\n-\t\t\t\t\targuments.data[i].UTFVerify(*sel, count);\n-\t\t\t\t} else {\n-\t\t\t\t\targuments.data[i].UTFVerify(count);\n-\t\t\t\t}\n+\t\t\t\targuments.data[i].UTFVerify(count);\n \t\t\t}\n #endif\n \t\t}\ndiff --git a/src/function/aggregate/algebraic/stddev.cpp b/src/function/aggregate/algebraic/stddev.cpp\nindex 82cd8160d264..5cefefa6824e 100644\n--- a/src/function/aggregate/algebraic/stddev.cpp\n+++ b/src/function/aggregate/algebraic/stddev.cpp\n@@ -69,6 +69,9 @@ struct VarSampOperation : public STDDevBaseOperation {\n \t\t\tnullmask[idx] = true;\n \t\t} else {\n \t\t\ttarget[idx] = state->count > 1 ? (state->dsquared / (state->count - 1)) : 0;\n+\t\t\tif (!Value::DoubleIsValid(target[idx])) {\n+\t\t\t\tthrow OutOfRangeException(\"VARSAMP is out of range!\");\n+\t\t\t}\n \t\t}\n \t}\n };\n@@ -80,6 +83,9 @@ struct VarPopOperation : public STDDevBaseOperation {\n \t\t\tnullmask[idx] = true;\n \t\t} else {\n \t\t\ttarget[idx] = state->count > 1 ? (state->dsquared / state->count) : 0;\n+\t\t\tif (!Value::DoubleIsValid(target[idx])) {\n+\t\t\t\tthrow OutOfRangeException(\"VARPOP is out of range!\");\n+\t\t\t}\n \t\t}\n \t}\n };\n@@ -91,6 +97,9 @@ struct STDDevSampOperation : public STDDevBaseOperation {\n \t\t\tnullmask[idx] = true;\n \t\t} else {\n \t\t\ttarget[idx] = state->count > 1 ? sqrt(state->dsquared / (state->count - 1)) : 0;\n+\t\t\tif (!Value::DoubleIsValid(target[idx])) {\n+\t\t\t\tthrow OutOfRangeException(\"STDDEV_SAMP is out of range!\");\n+\t\t\t}\n \t\t}\n \t}\n };\n@@ -102,6 +111,9 @@ struct STDDevPopOperation : public STDDevBaseOperation {\n \t\t\tnullmask[idx] = true;\n \t\t} else {\n \t\t\ttarget[idx] = state->count > 1 ? sqrt(state->dsquared / state->count) : 0;\n+\t\t\tif (!Value::DoubleIsValid(target[idx])) {\n+\t\t\t\tthrow OutOfRangeException(\"STDDEV_POP is out of range!\");\n+\t\t\t}\n \t\t}\n \t}\n };\ndiff --git a/src/function/function.cpp b/src/function/function.cpp\nindex d734ee18c38a..0a7adf9fe506 100644\n--- a/src/function/function.cpp\n+++ b/src/function/function.cpp\n@@ -43,8 +43,8 @@ void BuiltinFunctions::Initialize() {\n BuiltinFunctions::BuiltinFunctions(ClientContext &context, Catalog &catalog) : context(context), catalog(catalog) {\n }\n \n-void BuiltinFunctions::AddCollation(string name, ScalarFunction function, bool combinable) {\n-\tCreateCollationInfo info(move(name), move(function), combinable);\n+void BuiltinFunctions::AddCollation(string name, ScalarFunction function, bool combinable, bool not_required_for_equality) {\n+\tCreateCollationInfo info(move(name), move(function), combinable, not_required_for_equality);\n \tcatalog.CreateCollation(context, &info);\n }\n \ndiff --git a/src/include/duckdb/catalog/catalog_entry/collate_catalog_entry.hpp b/src/include/duckdb/catalog/catalog_entry/collate_catalog_entry.hpp\nindex e7fe0bf3d4ec..768620fcdc68 100644\n--- a/src/include/duckdb/catalog/catalog_entry/collate_catalog_entry.hpp\n+++ b/src/include/duckdb/catalog/catalog_entry/collate_catalog_entry.hpp\n@@ -19,10 +19,14 @@ class CollateCatalogEntry : public StandardEntry {\n public:\n \tCollateCatalogEntry(Catalog *catalog, SchemaCatalogEntry *schema, CreateCollationInfo *info)\n \t    : StandardEntry(CatalogType::COLLATION, schema, catalog, info->name), function(info->function),\n-\t      combinable(info->combinable) {\n+\t      combinable(info->combinable), not_required_for_equality(info->not_required_for_equality) {\n \t}\n \n+\t//! The collation function to push in case collation is required\n \tScalarFunction function;\n+\t//! Whether or not the collation can be combined with other collations.\n \tbool combinable;\n+\t//! Whether or not the collation is required for equality comparisons or not. For many collations a binary comparison for equality comparisons is correct, allowing us to skip the collation in these cases which greatly speeds up processing.\n+\tbool not_required_for_equality;\n };\n } // namespace duckdb\ndiff --git a/src/include/duckdb/function/function.hpp b/src/include/duckdb/function/function.hpp\nindex 8eed1867ab21..d46aad2e366c 100644\n--- a/src/include/duckdb/function/function.hpp\n+++ b/src/include/duckdb/function/function.hpp\n@@ -111,7 +111,7 @@ class BuiltinFunctions {\n \tvoid AddFunction(vector<string> names, ScalarFunction function);\n \tvoid AddFunction(TableFunction function);\n \n-\tvoid AddCollation(string name, ScalarFunction function, bool combinable = false);\n+\tvoid AddCollation(string name, ScalarFunction function, bool combinable = false, bool not_required_for_equality = false);\n \n private:\n \tClientContext &context;\ndiff --git a/src/include/duckdb/parser/parsed_data/create_collation_info.hpp b/src/include/duckdb/parser/parsed_data/create_collation_info.hpp\nindex a0cfb11e7aeb..87d193b84926 100644\n--- a/src/include/duckdb/parser/parsed_data/create_collation_info.hpp\n+++ b/src/include/duckdb/parser/parsed_data/create_collation_info.hpp\n@@ -14,14 +14,19 @@\n namespace duckdb {\n \n struct CreateCollationInfo : public CreateInfo {\n-\tCreateCollationInfo(string name_p, ScalarFunction function_p, bool combinable_p)\n-\t    : CreateInfo(CatalogType::COLLATION), function(move(function_p)), combinable(combinable_p) {\n+\tCreateCollationInfo(string name_p, ScalarFunction function_p, bool combinable_p, bool not_required_for_equality_p)\n+\t    : CreateInfo(CatalogType::COLLATION), function(move(function_p)), combinable(combinable_p), not_required_for_equality(not_required_for_equality_p) {\n \t\tthis->name = move(name_p);\n \t}\n \n+\t//! The name of the collation\n \tstring name;\n+\t//! The collation function to push in case collation is required\n \tScalarFunction function;\n+\t//! Whether or not the collation can be combined with other collations.\n \tbool combinable;\n+\t//! Whether or not the collation is required for equality comparisons or not. For many collations a binary comparison for equality comparisons is correct, allowing us to skip the collation in these cases which greatly speeds up processing.\n+\tbool not_required_for_equality;\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/planner/expression_binder.hpp b/src/include/duckdb/planner/expression_binder.hpp\nindex 51662ffeac24..2838eadcdb72 100644\n--- a/src/include/duckdb/planner/expression_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder.hpp\n@@ -57,7 +57,7 @@ class ExpressionBinder {\n \t// Bind table names to ColumnRefExpressions\n \tstatic void BindTableNames(Binder &binder, ParsedExpression &expr);\n \tstatic unique_ptr<Expression> PushCollation(ClientContext &context, unique_ptr<Expression> source,\n-\t                                            string collation);\n+\t                                            string collation, bool equality_only = false);\n \n \tbool BindCorrelatedColumns(unique_ptr<ParsedExpression> &expr);\n \ndiff --git a/src/planner/binder/expression/bind_comparison_expression.cpp b/src/planner/binder/expression/bind_comparison_expression.cpp\nindex 7d11e7222713..dc053e8dfb99 100644\n--- a/src/planner/binder/expression/bind_comparison_expression.cpp\n+++ b/src/planner/binder/expression/bind_comparison_expression.cpp\n@@ -14,7 +14,7 @@ using namespace duckdb;\n using namespace std;\n \n unique_ptr<Expression> ExpressionBinder::PushCollation(ClientContext &context, unique_ptr<Expression> source,\n-                                                       string collation) {\n+                                                       string collation, bool equality_only) {\n \t// replace default collation with system collation\n \tif (collation.empty()) {\n \t\tcollation = context.db.collation;\n@@ -40,6 +40,9 @@ unique_ptr<Expression> ExpressionBinder::PushCollation(ClientContext &context, u\n \t\t}\n \t}\n \tfor (auto &collation_entry : entries) {\n+\t\tif (equality_only && collation_entry->not_required_for_equality) {\n+\t\t\tcontinue;\n+\t\t}\n \t\tauto function = make_unique<BoundFunctionExpression>(TypeId::VARCHAR, collation_entry->function);\n \t\tfunction->children.push_back(move(source));\n \t\tfunction->arguments.push_back({SQLType::VARCHAR});\n@@ -88,8 +91,8 @@ BindResult ExpressionBinder::BindExpression(ComparisonExpression &expr, idx_t de\n \tright.expr = BoundCastExpression::AddCastToType(move(right.expr), right.sql_type, input_type);\n \tif (input_type.id == SQLTypeId::VARCHAR) {\n \t\t// handle collation\n-\t\tleft.expr = PushCollation(context, move(left.expr), input_type.collation);\n-\t\tright.expr = PushCollation(context, move(right.expr), input_type.collation);\n+\t\tleft.expr = PushCollation(context, move(left.expr), input_type.collation, expr.type == ExpressionType::COMPARE_EQUAL);\n+\t\tright.expr = PushCollation(context, move(right.expr), input_type.collation, expr.type == ExpressionType::COMPARE_EQUAL);\n \t}\n \t// now create the bound comparison expression\n \treturn BindResult(make_unique<BoundComparisonExpression>(expr.type, move(left.expr), move(right.expr)),\ndiff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp\nindex d1d10c6d5192..c967a4902728 100644\n--- a/src/planner/binder/query_node/bind_select_node.cpp\n+++ b/src/planner/binder/query_node/bind_select_node.cpp\n@@ -137,7 +137,7 @@ void Binder::BindModifierTypes(BoundQueryNode &result, const vector<SQLType> &sq\n \t\t\t\tauto &bound_colref = (BoundColumnRefExpression &)*distinct.target_distincts[i];\n \t\t\t\tauto sql_type = sql_types[bound_colref.binding.column_index];\n \t\t\t\tif (sql_type.id == SQLTypeId::VARCHAR) {\n-\t\t\t\t\tdistinct.target_distincts[i] = ExpressionBinder::PushCollation(context, move(distinct.target_distincts[i]), sql_type.collation);\n+\t\t\t\t\tdistinct.target_distincts[i] = ExpressionBinder::PushCollation(context, move(distinct.target_distincts[i]), sql_type.collation, true);\n \t\t\t\t}\n \t\t\t}\n \t\t\tbreak;\n@@ -240,6 +240,8 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {\n \t\t\tauto bound_expr = group_binder.Bind(statement.groups[i], &group_type);\n \t\t\tassert(bound_expr->return_type != TypeId::INVALID);\n \t\t\tinfo.group_types.push_back(group_type);\n+\t\t\t// push a potential collation, if necessary\n+\t\t\tbound_expr = ExpressionBinder::PushCollation(context, move(bound_expr), group_type.collation, true);\n \t\t\tresult->groups.push_back(move(bound_expr));\n \n \t\t\t// in the unbound expression we DO bind the table names of any ColumnRefs\ndiff --git a/src/storage/string_segment.cpp b/src/storage/string_segment.cpp\nindex eb1d8ff17139..c30bd083f884 100644\n--- a/src/storage/string_segment.cpp\n+++ b/src/storage/string_segment.cpp\n@@ -682,9 +682,7 @@ string_update_info_t StringSegment::CreateStringUpdate(SegmentStatistics &stats,\n \t\tif (!update_nullmask[i]) {\n \t\t\tauto min = (char *)stats.minimum.get();\n \t\t\tauto max = (char *)stats.maximum.get();\n-\t\t\tfor (idx_t i = 0; i < count; i++) {\n-\t\t\t\tupdate_min_max(strings[i].GetData(), min, max);\n-\t\t\t}\n+\t\t\tupdate_min_max(strings[i].GetData(), min, max);\n \t\t\tWriteString(strings[i], info->block_ids[i], info->offsets[i]);\n \t\t} else {\n \t\t\tinfo->block_ids[i] = INVALID_BLOCK;\ndiff --git a/third_party/libpg_query/pg_functions.cpp b/third_party/libpg_query/pg_functions.cpp\nindex 2cc4d23f2b83..d495cefee2f4 100644\n--- a/third_party/libpg_query/pg_functions.cpp\n+++ b/third_party/libpg_query/pg_functions.cpp\n@@ -161,7 +161,7 @@ void* palloc0fast(size_t n) { // very fast\n     return palloc(n);\n }\n void* repalloc(void* ptr, size_t n) {\n-    throw std::runtime_error(\"repalloc NOT IMPLEMENTED\");\n+\treturn palloc(n);\n }\n char *NameListToString(PGList *names) {\n     throw std::runtime_error(\"NameListToString NOT IMPLEMENTED\");\n",
  "test_patch": "diff --git a/test/rigger/test_rigger.cpp b/test/rigger/test_rigger.cpp\nindex 41b3f0c567b5..4dd1be33e206 100644\n--- a/test/rigger/test_rigger.cpp\n+++ b/test/rigger/test_rigger.cpp\n@@ -637,4 +637,33 @@ TEST_CASE(\"Tests found by Rigger\", \"[rigger]\") {\n \t\tresult = con.Query(\"SELECT * FROM t0 WHERE c0 LIKE '' AND c0 < true;\");\n \t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n \t}\n+\tSECTION(\"596\") {\n+\t\t// STDDEV_POP unexpectedly does not fetch any rows\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 DOUBLE);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES(1E200), (0);\"));\n+\t\tREQUIRE_FAIL(con.Query(\"SELECT STDDEV_POP(c0) FROM t0;\"));\n+\t}\n+\tSECTION(\"599\") {\n+\t\t// UPDATE results in crash or ASan error\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT, c1 VARCHAR);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0 VALUES (0, 0), (NULL, 0);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"UPDATE t0 SET c1 = c0;\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0 ORDER BY 1\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {Value(), 0}));\n+\t\tREQUIRE(CHECK_COLUMN(result, 1, {Value(), \"0\"}));\n+\t}\n+\tSECTION(\"602\") {\n+\t\t// GROUP BY does not take COLLATE into account\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 VARCHAR COLLATE NOCASE);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES ('a'), ('A');\"));\n+\t\tresult = con.Query(\"SELECT t0.c0 FROM t0 GROUP BY t0.c0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {\"a\"}));\n+\t}\n+\tSECTION(\"603\") {\n+\t\t// BETWEEN with COLLATE NOACCENT.NOCASE expression results in a segfault/ASan failure\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 DATE, c1 VARCHAR);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (NULL), ('2000-01-01');\"));\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE 'a' BETWEEN c0 AND c1 COLLATE NOACCENT.NOCASE;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t}\n }\ndiff --git a/test/sql/simple/test_inserts.cpp b/test/sql/simple/test_inserts.cpp\nindex 1ef4d559e8c7..6eade2e428af 100644\n--- a/test/sql/simple/test_inserts.cpp\n+++ b/test/sql/simple/test_inserts.cpp\n@@ -199,3 +199,13 @@ TEST_CASE(\"Test insert with too few or too many cols\", \"[simpleinserts]\") {\n \t// also with queries\n \tREQUIRE_FAIL(con.Query(\"INSERT INTO a SELECT 42\"));\n }\n+\n+TEST_CASE(\"Test insert with long string constant\", \"[simpleinserts]\") {\n+\tunique_ptr<QueryResult> result;\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\n+\t// found by Pedro Holanda\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE IF NOT EXISTS presentations(presentation_date Date NOT NULL UNIQUE, author VARCHAR NOT NULL, title VARCHAR NOT NULL, bio VARCHAR, abstract VARCHAR, zoom_link VARCHAR);\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"insert into presentations values ('2020-05-29', 'Eduardo Pena', 'Analytical Query Processing Based on Continuous Compression of Intermediates', NULL, 'Modern in-memory column-stores are widely accepted as the adequate database architecture for the efficient processing of complex analytical queries over large relational data volumes. These systems keep their entire data in main memory and typically employ lightweight compression to address the bottleneck between main memory and CPU. Numerous lightweight compression algorithms have been proposed in the past years, but none of them is suitable in all cases. While lightweight compression is already well established for base data, the efficient representation of intermediate results generated during query processing has attracted insufficient attention so far, although in in-memory systems, accessing intermeFdiates is as expensive as accessing base data. Thus, our vision is a continuous use of lightweight compression for all intermediates in a query execution plan, whereby a suitable compression algorithm should be selected for each intermediate. In this talk, I will provide an overview of our research in the context of this vision, including an experimental survey of lightweight compression algorithms, our compression-enabled processing model, and our compression-aware query optimization strategies.', 'https://zoom.us/j/7845983526');\"));\n+}\n",
  "problem_statement": "BETWEEN with COLLATE NOACCENT.NOCASE expression results in a segfault/ASan failure\nConsider the following statements:\r\n```sql\r\nCREATE TABLE t0(c0 DATE, c1 VARCHAR);\r\nINSERT INTO t0(c0) VALUES (NULL), ('2000-01-01');\r\nSELECT * FROM t0 WHERE 'a' BETWEEN c0 AND c1 COLLATE NOACCENT.NOCASE; -- segfault\r\n```\r\nUnexpectedly, the `SELECT` causes an ASan failure (the initial test case crashed the JVM when using the JDBC driver):\r\n```\r\nAddressSanitizer:DEADLYSIGNAL\r\n=================================================================\r\n==27945==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x561f1a6c2d18 bp 0x7ffccd196060 sp 0x7ffccd196040 T0)\r\n==27945==The signal is caused by a READ memory access.\r\n==27945==Hint: address points to the zero page.\r\n    #0 0x561f1a6c2d17 in duckdb::Utf8Proc::Analyze(char const*, unsigned long) /duckdb/third_party/utf8proc/utf8proc_wrapper.cpp:28\r\n    #1 0x561f1a6d60b8 in duckdb::string_t::Verify() /duckdb/src/common/types/string_type.cpp:13\r\n    #2 0x561f1a6edcf7 in duckdb::Vector::UTFVerify(duckdb::SelectionVector const&, unsigned long) /duckdb/src/common/types/vector.cpp:605\r\n    #3 0x561f1ae3a88a in duckdb::ExpressionExecutor::Execute(duckdb::BoundFunctionExpression&, duckdb::ExpressionState*, duckdb::SelectionVector const*, unsigned long, duckdb::Vector&) /duckdb/src/execution/expression_executor/execute_function.cpp:40\r\n    #4 0x561f1a97fccc in duckdb::ExpressionExecutor::Execute(duckdb::Expression&, duckdb::ExpressionState*, duckdb::SelectionVector const*, unsigned long, duckdb::Vector&) /duckdb/src/execution/expression_executor.cpp:146\r\n    #5 0x561f1ae38070 in duckdb::ExpressionExecutor::Select(duckdb::BoundComparisonExpression&, duckdb::ExpressionState*, duckdb::SelectionVector const*, unsigned long, duckdb::SelectionVector*, duckdb::SelectionVector*) /duckdb/src/execution/expression_executor/execute_comparison.cpp:82\r\n    #6 0x561f1a98008d in duckdb::ExpressionExecutor::Select(duckdb::Expression&, duckdb::ExpressionState*, duckdb::SelectionVector const*, unsigned long, duckdb::SelectionVector*, duckdb::SelectionVector*) /duckdb/src/execution/expression_executor.cpp:171\r\n    #7 0x561f1ae39719 in duckdb::ExpressionExecutor::Select(duckdb::BoundConjunctionExpression&, duckdb::ExpressionState*, duckdb::SelectionVector const*, unsigned long, duckdb::SelectionVector*, duckdb::SelectionVector*) /duckdb/src/execution/expression_executor/execute_conjunction.cpp:80\r\n    #8 0x561f1a9800c0 in duckdb::ExpressionExecutor::Select(duckdb::Expression&, duckdb::ExpressionState*, duckdb::SelectionVector const*, unsigned long, duckdb::SelectionVector*, duckdb::SelectionVector*) /duckdb/src/execution/expression_executor.cpp:173\r\n    #9 0x561f1a97ed10 in duckdb::ExpressionExecutor::SelectExpression(duckdb::DataChunk&, duckdb::SelectionVector&) /duckdb/src/execution/expression_executor.cpp:60\r\n    #10 0x561f1b1d62f1 in duckdb::PhysicalFilter::GetChunkInternal(duckdb::ClientContext&, duckdb::DataChunk&, duckdb::PhysicalOperatorState*) /duckdb/src/execution/operator/filter/physical_filter.cpp:44\r\n    #11 0x561f1a98a87b in duckdb::PhysicalOperator::GetChunk(duckdb::ClientContext&, duckdb::DataChunk&, duckdb::PhysicalOperatorState*) /duckdb/src/execution/physical_operator.cpp:45\r\n    #12 0x561f1b219a54 in duckdb::PhysicalProjection::GetChunkInternal(duckdb::ClientContext&, duckdb::DataChunk&, duckdb::PhysicalOperatorState*) /duckdb/src/execution/operator/projection/physical_projection.cpp:22\r\n    #13 0x561f1a98a87b in duckdb::PhysicalOperator::GetChunk(duckdb::ClientContext&, duckdb::DataChunk&, duckdb::PhysicalOperatorState*) /duckdb/src/execution/physical_operator.cpp:45\r\n    #14 0x561f1b1d70f6 in duckdb::PhysicalExecute::GetChunkInternal(duckdb::ClientContext&, duckdb::DataChunk&, duckdb::PhysicalOperatorState*) /duckdb/src/execution/operator/helper/physical_execute.cpp:8\r\n    #15 0x561f1a98a87b in duckdb::PhysicalOperator::GetChunk(duckdb::ClientContext&, duckdb::DataChunk&, duckdb::PhysicalOperatorState*) /duckdb/src/execution/physical_operator.cpp:45\r\n    #16 0x561f1a9d84fd in duckdb::ClientContext::FetchInternal() /duckdb/src/main/client_context.cpp:153\r\n    #17 0x561f1a9d9d98 in duckdb::ClientContext::ExecutePreparedStatement(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, duckdb::PreparedStatementData&, std::vector<duckdb::Value, std::allocator<duckdb::Value> >, bool) /duckdb/src/main/client_context.cpp:232\r\n    #18 0x561f1a9dc751 in duckdb::ClientContext::RunStatementInternal(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >, bool) /duckdb/src/main/client_context.cpp:340\r\n    #19 0x561f1a9dd0d7 in duckdb::ClientContext::RunStatement(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >, bool) /duckdb/src/main/client_context.cpp:367\r\n    #20 0x561f1a9dbb49 in duckdb::ClientContext::Execute(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<duckdb::Value, std::allocator<duckdb::Value> >&, bool, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >) /duckdb/src/main/client_context.cpp:311\r\n    #21 0x561f1a9f542b in duckdb::PreparedStatement::Execute(std::vector<duckdb::Value, std::allocator<duckdb::Value> >&, bool) /duckdb/src/main/prepared_statement.cpp:37\r\n    #22 0x561f1a6a2810 in sqlite3_step /duckdb/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:195\r\n    #23 0x561f1a67c1d7 in exec_prepared_stmt /duckdb/tools/shell/shell.c:9899\r\n    #24 0x561f1a67dfb7 in shell_exec /duckdb/tools/shell/shell.c:10187\r\n    #25 0x561f1a69739d in runOneSqlLine /duckdb/tools/shell/shell.c:15047\r\n    #26 0x561f1a697cd7 in process_input /duckdb/tools/shell/shell.c:15149\r\n    #27 0x561f1a69a3e4 in main /duckdb/tools/shell/shell.c:15817\r\n    #28 0x7f6e102a7b6a in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x26b6a)\r\n    #29 0x561f1a6577c9 in _start (/duckdb/build/debug/duckdb_cli+0x9067c9)\r\n```\r\nI found this based on commit 22a5f36ee41542c915c73dc44d90d29fcbe9cbcb.\n",
  "hints_text": "",
  "created_at": "2020-04-29T13:26:08Z"
}