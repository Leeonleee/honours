You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
bug: StructFilter::ToExpression not yet supported
### What happens?

I was trying to reproduce an example from overture maps and duckdb, I'm on duckdb `'1.0.1-dev3196'` and when I run the code I get `NotImplementedException: Not implemented Error: StructFilter::ToExpression not yet supported`

For the record this doesn't happen in duckdb=1.0.0 . I need the nightly because I need this https://github.com/duckdb/duckdb/pull/12503

### To Reproduce

```python
import duckdb 
duckdb.sql("load spatial;")

sql = """SELECT
      id,
      names.primary as primary_name,
      height,
      geometry
    FROM read_parquet('s3://overturemaps-us-west-2/release/2024-06-13-beta.1/theme=buildings/type=*/*', filename=true, hive_partitioning=1)
    WHERE primary_name IS NOT NULL
    AND bbox.xmin > -84.36
    AND bbox.xmax < -82.42
    AND bbox.ymin > 41.71
    AND bbox.ymax < 43.33;
"""

tdb = duckdb.sql(sql)
duckdb.sql("SELECT * FROM tdb LIMIT 10;")
```

```python-traceback
---------------------------------------------------------------------------
NotImplementedException                   Traceback (most recent call last)
File [~/mambaforge/envs/ibis-dev/lib/python3.11/site-packages/IPython/core/formatters.py:711](http://localhost:8888/lab/tree/~/mambaforge/envs/ibis-dev/lib/python3.11/site-packages/IPython/core/formatters.py#line=710), in PlainTextFormatter.__call__(self, obj)
    704 stream = StringIO()
    705 printer = pretty.RepresentationPrinter(stream, self.verbose,
    706     self.max_width, self.newline,
    707     max_seq_length=self.max_seq_length,
    708     singleton_pprinters=self.singleton_printers,
    709     type_pprinters=self.type_printers,
    710     deferred_pprinters=self.deferred_printers)
--> 711 printer.pretty(obj)
    712 printer.flush()
    713 return stream.getvalue()

File [~/mambaforge/envs/ibis-dev/lib/python3.11/site-packages/IPython/lib/pretty.py:411](http://localhost:8888/lab/tree/~/mambaforge/envs/ibis-dev/lib/python3.11/site-packages/IPython/lib/pretty.py#line=410), in RepresentationPrinter.pretty(self, obj)
    408                         return meth(obj, self, cycle)
    409                 if cls is not object \
    410                         and callable(cls.__dict__.get('__repr__')):
--> 411                     return _repr_pprint(obj, self, cycle)
    413     return _default_pprint(obj, self, cycle)
    414 finally:

File [~/mambaforge/envs/ibis-dev/lib/python3.11/site-packages/IPython/lib/pretty.py:779](http://localhost:8888/lab/tree/~/mambaforge/envs/ibis-dev/lib/python3.11/site-packages/IPython/lib/pretty.py#line=778), in _repr_pprint(obj, p, cycle)
    777 """A pprint that just redirects to the normal repr function."""
    778 # Find newlines and replace them with p.break_()
--> 779 output = repr(obj)
    780 lines = output.splitlines()
    781 with p.group():

NotImplementedException: Not implemented Error: StructFilter::ToExpression not yet supported

```

### OS:

MacOS - Sonoma 14.5

### DuckDB Version:

1.0.1-dev3196

### DuckDB Client:

Python

### Full Name:

Naty Clementi

### Affiliation:

Voltron Data

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a nightly build

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have
bug: StructFilter::ToExpression not yet supported
### What happens?

I was trying to reproduce an example from overture maps and duckdb, I'm on duckdb `'1.0.1-dev3196'` and when I run the code I get `NotImplementedException: Not implemented Error: StructFilter::ToExpression not yet supported`

For the record this doesn't happen in duckdb=1.0.0 . I need the nightly because I need this https://github.com/duckdb/duckdb/pull/12503

### To Reproduce

```python
import duckdb 
duckdb.sql("load spatial;")

sql = """SELECT
      id,
      names.primary as primary_name,
      height,
      geometry
    FROM read_parquet('s3://overturemaps-us-west-2/release/2024-06-13-beta.1/theme=buildings/type=*/*', filename=true, hive_partitioning=1)
    WHERE primary_name IS NOT NULL
    AND bbox.xmin > -84.36
    AND bbox.xmax < -82.42
    AND bbox.ymin > 41.71
    AND bbox.ymax < 43.33;
"""

tdb = duckdb.sql(sql)
duckdb.sql("SELECT * FROM tdb LIMIT 10;")
```

```python-traceback
---------------------------------------------------------------------------
NotImplementedException                   Traceback (most recent call last)
File [~/mambaforge/envs/ibis-dev/lib/python3.11/site-packages/IPython/core/formatters.py:711](http://localhost:8888/lab/tree/~/mambaforge/envs/ibis-dev/lib/python3.11/site-packages/IPython/core/formatters.py#line=710), in PlainTextFormatter.__call__(self, obj)
    704 stream = StringIO()
    705 printer = pretty.RepresentationPrinter(stream, self.verbose,
    706     self.max_width, self.newline,
    707     max_seq_length=self.max_seq_length,
    708     singleton_pprinters=self.singleton_printers,
    709     type_pprinters=self.type_printers,
    710     deferred_pprinters=self.deferred_printers)
--> 711 printer.pretty(obj)
    712 printer.flush()
    713 return stream.getvalue()

File [~/mambaforge/envs/ibis-dev/lib/python3.11/site-packages/IPython/lib/pretty.py:411](http://localhost:8888/lab/tree/~/mambaforge/envs/ibis-dev/lib/python3.11/site-packages/IPython/lib/pretty.py#line=410), in RepresentationPrinter.pretty(self, obj)
    408                         return meth(obj, self, cycle)
    409                 if cls is not object \
    410                         and callable(cls.__dict__.get('__repr__')):
--> 411                     return _repr_pprint(obj, self, cycle)
    413     return _default_pprint(obj, self, cycle)
    414 finally:

File [~/mambaforge/envs/ibis-dev/lib/python3.11/site-packages/IPython/lib/pretty.py:779](http://localhost:8888/lab/tree/~/mambaforge/envs/ibis-dev/lib/python3.11/site-packages/IPython/lib/pretty.py#line=778), in _repr_pprint(obj, p, cycle)
    777 """A pprint that just redirects to the normal repr function."""
    778 # Find newlines and replace them with p.break_()
--> 779 output = repr(obj)
    780 lines = output.splitlines()
    781 with p.group():

NotImplementedException: Not implemented Error: StructFilter::ToExpression not yet supported

```

### OS:

MacOS - Sonoma 14.5

### DuckDB Version:

1.0.1-dev3196

### DuckDB Client:

Python

### Full Name:

Naty Clementi

### Affiliation:

Voltron Data

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a nightly build

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://www.duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/function/scalar/struct/struct_extract.cpp]
1: #include "duckdb/common/string_util.hpp"
2: #include "duckdb/execution/expression_executor.hpp"
3: #include "duckdb/function/scalar/nested_functions.hpp"
4: #include "duckdb/planner/expression/bound_function_expression.hpp"
5: #include "duckdb/planner/expression/bound_parameter_expression.hpp"
6: #include "duckdb/storage/statistics/struct_stats.hpp"
7: 
8: namespace duckdb {
9: 
10: struct StructExtractBindData : public FunctionData {
11: 	explicit StructExtractBindData(idx_t index) : index(index) {
12: 	}
13: 
14: 	idx_t index;
15: 
16: public:
17: 	unique_ptr<FunctionData> Copy() const override {
18: 		return make_uniq<StructExtractBindData>(index);
19: 	}
20: 	bool Equals(const FunctionData &other_p) const override {
21: 		auto &other = other_p.Cast<StructExtractBindData>();
22: 		return index == other.index;
23: 	}
24: };
25: 
26: static void StructExtractFunction(DataChunk &args, ExpressionState &state, Vector &result) {
27: 	auto &func_expr = state.expr.Cast<BoundFunctionExpression>();
28: 	auto &info = func_expr.bind_info->Cast<StructExtractBindData>();
29: 
30: 	// this should be guaranteed by the binder
31: 	auto &vec = args.data[0];
32: 
33: 	vec.Verify(args.size());
34: 	auto &children = StructVector::GetEntries(vec);
35: 	D_ASSERT(info.index < children.size());
36: 	auto &struct_child = children[info.index];
37: 	result.Reference(*struct_child);
38: 	result.Verify(args.size());
39: }
40: 
41: static unique_ptr<FunctionData> StructExtractBind(ClientContext &context, ScalarFunction &bound_function,
42:                                                   vector<unique_ptr<Expression>> &arguments) {
43: 	D_ASSERT(bound_function.arguments.size() == 2);
44: 	auto &child_type = arguments[0]->return_type;
45: 	if (child_type.id() == LogicalTypeId::UNKNOWN) {
46: 		throw ParameterNotResolvedException();
47: 	}
48: 	D_ASSERT(LogicalTypeId::STRUCT == child_type.id());
49: 	auto &struct_children = StructType::GetChildTypes(child_type);
50: 	if (struct_children.empty()) {
51: 		throw InternalException("Can't extract something from an empty struct");
52: 	}
53: 	if (StructType::IsUnnamed(child_type)) {
54: 		throw BinderException(
55: 		    "struct_extract with a string key cannot be used on an unnamed struct, use a numeric index instead");
56: 	}
57: 	bound_function.arguments[0] = child_type;
58: 
59: 	auto &key_child = arguments[1];
60: 	if (key_child->HasParameter()) {
61: 		throw ParameterNotResolvedException();
62: 	}
63: 
64: 	if (key_child->return_type.id() != LogicalTypeId::VARCHAR || !key_child->IsFoldable()) {
65: 		throw BinderException("Key name for struct_extract needs to be a constant string");
66: 	}
67: 	Value key_val = ExpressionExecutor::EvaluateScalar(context, *key_child);
68: 	D_ASSERT(key_val.type().id() == LogicalTypeId::VARCHAR);
69: 	auto &key_str = StringValue::Get(key_val);
70: 	if (key_val.IsNull() || key_str.empty()) {
71: 		throw BinderException("Key name for struct_extract needs to be neither NULL nor empty");
72: 	}
73: 	string key = StringUtil::Lower(key_str);
74: 
75: 	LogicalType return_type;
76: 	idx_t key_index = 0;
77: 	bool found_key = false;
78: 
79: 	for (size_t i = 0; i < struct_children.size(); i++) {
80: 		auto &child = struct_children[i];
81: 		if (StringUtil::Lower(child.first) == key) {
82: 			found_key = true;
83: 			key_index = i;
84: 			return_type = child.second;
85: 			break;
86: 		}
87: 	}
88: 
89: 	if (!found_key) {
90: 		vector<string> candidates;
91: 		candidates.reserve(struct_children.size());
92: 		for (auto &struct_child : struct_children) {
93: 			candidates.push_back(struct_child.first);
94: 		}
95: 		auto closest_settings = StringUtil::TopNJaroWinkler(candidates, key);
96: 		auto message = StringUtil::CandidatesMessage(closest_settings, "Candidate Entries");
97: 		throw BinderException("Could not find key \"%s\" in struct\n%s", key, message);
98: 	}
99: 
100: 	bound_function.return_type = std::move(return_type);
101: 	return make_uniq<StructExtractBindData>(key_index);
102: }
103: 
104: static unique_ptr<FunctionData> StructExtractBindIndex(ClientContext &context, ScalarFunction &bound_function,
105:                                                        vector<unique_ptr<Expression>> &arguments) {
106: 	D_ASSERT(bound_function.arguments.size() == 2);
107: 	auto &child_type = arguments[0]->return_type;
108: 	if (child_type.id() == LogicalTypeId::UNKNOWN) {
109: 		throw ParameterNotResolvedException();
110: 	}
111: 	D_ASSERT(LogicalTypeId::STRUCT == child_type.id());
112: 	auto &struct_children = StructType::GetChildTypes(child_type);
113: 	if (struct_children.empty()) {
114: 		throw InternalException("Can't extract something from an empty struct");
115: 	}
116: 	if (!StructType::IsUnnamed(child_type)) {
117: 		throw BinderException(
118: 		    "struct_extract with an integer key can only be used on unnamed structs, use a string key instead");
119: 	}
120: 	bound_function.arguments[0] = child_type;
121: 
122: 	auto &key_child = arguments[1];
123: 	if (key_child->HasParameter()) {
124: 		throw ParameterNotResolvedException();
125: 	}
126: 
127: 	if (!key_child->IsFoldable()) {
128: 		throw BinderException("Key index for struct_extract needs to be a constant value");
129: 	}
130: 	Value key_val = ExpressionExecutor::EvaluateScalar(context, *key_child);
131: 	auto index = key_val.GetValue<int64_t>();
132: 	if (index <= 0 || idx_t(index) > struct_children.size()) {
133: 		throw BinderException("Key index %lld for struct_extract out of range - expected an index between 1 and %llu",
134: 		                      index, struct_children.size());
135: 	}
136: 	bound_function.return_type = struct_children[NumericCast<idx_t>(index - 1)].second;
137: 	return make_uniq<StructExtractBindData>(NumericCast<idx_t>(index - 1));
138: }
139: 
140: static unique_ptr<BaseStatistics> PropagateStructExtractStats(ClientContext &context, FunctionStatisticsInput &input) {
141: 	auto &child_stats = input.child_stats;
142: 	auto &bind_data = input.bind_data;
143: 
144: 	auto &info = bind_data->Cast<StructExtractBindData>();
145: 	auto struct_child_stats = StructStats::GetChildStats(child_stats[0]);
146: 	return struct_child_stats[info.index].ToUnique();
147: }
148: 
149: ScalarFunction StructExtractFun::KeyExtractFunction() {
150: 	return ScalarFunction("struct_extract", {LogicalTypeId::STRUCT, LogicalType::VARCHAR}, LogicalType::ANY,
151: 	                      StructExtractFunction, StructExtractBind, nullptr, PropagateStructExtractStats);
152: }
153: 
154: ScalarFunction StructExtractFun::IndexExtractFunction() {
155: 	return ScalarFunction("struct_extract", {LogicalTypeId::STRUCT, LogicalType::BIGINT}, LogicalType::ANY,
156: 	                      StructExtractFunction, StructExtractBindIndex);
157: }
158: 
159: ScalarFunctionSet StructExtractFun::GetFunctions() {
160: 	ScalarFunctionSet functions("struct_extract");
161: 	functions.AddFunction(KeyExtractFunction());
162: 	functions.AddFunction(IndexExtractFunction());
163: 	return functions;
164: }
165: 
166: void StructExtractFun::RegisterFunction(BuiltinFunctions &set) {
167: 	// the arguments and return types are actually set in the binder function
168: 	set.AddFunction(GetFunctions());
169: }
170: 
171: } // namespace duckdb
[end of src/function/scalar/struct/struct_extract.cpp]
[start of src/include/duckdb/function/scalar/nested_functions.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/function/scalar/nested_functions.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/function/function_set.hpp"
12: #include "duckdb/function/scalar_function.hpp"
13: #include "duckdb/common/map.hpp"
14: #include "duckdb/common/unordered_map.hpp"
15: #include "duckdb/function/built_in_functions.hpp"
16: #include "duckdb/function/scalar/list/contains_or_position.hpp"
17: #include "duckdb/common/serializer/serializer.hpp"
18: #include "duckdb/common/serializer/deserializer.hpp"
19: 
20: namespace duckdb {
21: 
22: struct ListArgFunctor {
23: 	static Vector &GetList(Vector &list) {
24: 		return list;
25: 	}
26: 	static idx_t GetListSize(Vector &list) {
27: 		return ListVector::GetListSize(list);
28: 	}
29: 	static Vector &GetEntry(Vector &list) {
30: 		return ListVector::GetEntry(list);
31: 	}
32: };
33: 
34: struct ContainsFunctor {
35: 	static inline bool Initialize() {
36: 		return false;
37: 	}
38: 	static inline bool UpdateResultEntries(idx_t child_idx) {
39: 		return true;
40: 	}
41: };
42: 
43: struct PositionFunctor {
44: 	static inline int32_t Initialize() {
45: 		return 0;
46: 	}
47: 	static inline int32_t UpdateResultEntries(idx_t child_idx) {
48: 		return UnsafeNumericCast<int32_t>(child_idx + 1);
49: 	}
50: };
51: 
52: struct MapUtil {
53: 	static void ReinterpretMap(Vector &target, Vector &other, idx_t count);
54: };
55: 
56: struct VariableReturnBindData : public FunctionData {
57: 	LogicalType stype;
58: 
59: 	explicit VariableReturnBindData(LogicalType stype_p) : stype(std::move(stype_p)) {
60: 	}
61: 
62: 	unique_ptr<FunctionData> Copy() const override {
63: 		return make_uniq<VariableReturnBindData>(stype);
64: 	}
65: 	bool Equals(const FunctionData &other_p) const override {
66: 		auto &other = other_p.Cast<VariableReturnBindData>();
67: 		return stype == other.stype;
68: 	}
69: 	static void Serialize(Serializer &serializer, const optional_ptr<FunctionData> bind_data,
70: 	                      const ScalarFunction &function) {
71: 		auto &info = bind_data->Cast<VariableReturnBindData>();
72: 		serializer.WriteProperty(100, "variable_return_type", info.stype);
73: 	}
74: 
75: 	static unique_ptr<FunctionData> Deserialize(Deserializer &deserializer, ScalarFunction &bound_function) {
76: 		auto stype = deserializer.ReadProperty<LogicalType>(100, "variable_return_type");
77: 		return make_uniq<VariableReturnBindData>(std::move(stype));
78: 	}
79: };
80: 
81: template <class T, class MAP_TYPE = map<T, idx_t>>
82: struct HistogramAggState {
83: 	MAP_TYPE *hist;
84: };
85: 
86: struct ListExtractFun {
87: 	static void RegisterFunction(BuiltinFunctions &set);
88: };
89: 
90: struct ListConcatFun {
91: 	static ScalarFunction GetFunction();
92: 	static void RegisterFunction(BuiltinFunctions &set);
93: };
94: 
95: struct ListContainsFun {
96: 	static ScalarFunction GetFunction();
97: 	static void RegisterFunction(BuiltinFunctions &set);
98: };
99: 
100: struct ListPositionFun {
101: 	static ScalarFunction GetFunction();
102: 	static void RegisterFunction(BuiltinFunctions &set);
103: };
104: 
105: struct ListResizeFun {
106: 	static void RegisterFunction(BuiltinFunctions &set);
107: };
108: 
109: struct ListZipFun {
110: 	static ScalarFunction GetFunction();
111: 	static void RegisterFunction(BuiltinFunctions &set);
112: };
113: 
114: struct ListSelectFun {
115: 	static ScalarFunction GetFunction();
116: 	static void RegisterFunction(BuiltinFunctions &set);
117: };
118: 
119: struct ListWhereFun {
120: 	static ScalarFunction GetFunction();
121: 	static void RegisterFunction(BuiltinFunctions &set);
122: };
123: 
124: struct StructExtractFun {
125: 	static ScalarFunction KeyExtractFunction();
126: 	static ScalarFunction IndexExtractFunction();
127: 	static ScalarFunctionSet GetFunctions();
128: 	static void RegisterFunction(BuiltinFunctions &set);
129: };
130: 
131: } // namespace duckdb
[end of src/include/duckdb/function/scalar/nested_functions.hpp]
[start of src/planner/filter/struct_filter.cpp]
1: #include "duckdb/planner/filter/struct_filter.hpp"
2: #include "duckdb/storage/statistics/base_statistics.hpp"
3: #include "duckdb/storage/statistics/struct_stats.hpp"
4: #include "duckdb/common/string_util.hpp"
5: #include "duckdb/planner/expression/bound_function_expression.hpp"
6: 
7: namespace duckdb {
8: 
9: StructFilter::StructFilter(idx_t child_idx_p, string child_name_p, unique_ptr<TableFilter> child_filter_p)
10:     : TableFilter(TableFilterType::STRUCT_EXTRACT), child_idx(child_idx_p), child_name(std::move(child_name_p)),
11:       child_filter(std::move(child_filter_p)) {
12: }
13: 
14: FilterPropagateResult StructFilter::CheckStatistics(BaseStatistics &stats) {
15: 	D_ASSERT(stats.GetType().id() == LogicalTypeId::STRUCT);
16: 	// Check the child statistics
17: 	auto &child_stats = StructStats::GetChildStats(stats, child_idx);
18: 	return child_filter->CheckStatistics(child_stats);
19: }
20: 
21: string StructFilter::ToString(const string &column_name) {
22: 	return child_filter->ToString(column_name + "." + child_name);
23: }
24: 
25: bool StructFilter::Equals(const TableFilter &other_p) const {
26: 	if (!TableFilter::Equals(other_p)) {
27: 		return false;
28: 	}
29: 	auto &other = other_p.Cast<StructFilter>();
30: 	return other.child_idx == child_idx && StringUtil::CIEquals(other.child_name, child_name) &&
31: 	       other.child_filter->Equals(*child_filter);
32: }
33: 
34: unique_ptr<TableFilter> StructFilter::Copy() const {
35: 	return make_uniq<StructFilter>(child_idx, child_name, child_filter->Copy());
36: }
37: 
38: unique_ptr<Expression> StructFilter::ToExpression(const Expression &column) const {
39: 	throw NotImplementedException("StructFilter::ToExpression not yet supported");
40: }
41: } // namespace duckdb
[end of src/planner/filter/struct_filter.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: