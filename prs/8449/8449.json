{
  "repo": "duckdb/duckdb",
  "pull_number": 8449,
  "instance_id": "duckdb__duckdb-8449",
  "issue_numbers": [
    "8381"
  ],
  "base_commit": "525b948821318b9b7701256b199fd0f0a84c40ef",
  "patch": "diff --git a/scripts/generate_serialization.py b/scripts/generate_serialization.py\nindex 8d7732362397..53fbb2e7715d 100644\n--- a/scripts/generate_serialization.py\n+++ b/scripts/generate_serialization.py\n@@ -492,6 +492,23 @@ def generate_class_code(class_entry):\n     return class_generation\n \n \n+def check_children_for_duplicate_members(node, parents: list, seen: set):\n+    # Check for duplicate names\n+    if node.members is not None:\n+        for member in node.members:\n+            if member.name in seen:\n+                # Print the inheritance tree\n+                print(\n+                    f\"Duplicate member name \\\"{member.name}\\\" in class \\\"{node.name}\\\" ({' -> '.join(map(lambda x: x.name, parents))} -> {node.name})\"\n+                )\n+                exit()\n+            seen.add(member.name)\n+\n+    # Recurse\n+    for child in node.children.values():\n+        check_children_for_duplicate_members(child, parents + [node], seen.copy())\n+\n+\n for entry in file_list:\n     source_path = entry['source']\n     target_path = entry['target']\n@@ -529,6 +546,12 @@ def generate_class_code(class_entry):\n                     raise Exception(f\"Duplicate enum entry \\\"{enum_entry}\\\"\")\n                 base_class_object.children[enum_entry] = new_class\n \n+    # Ensure that there are no duplicate names in the inheritance tree\n+    for base_class in base_classes:\n+        if base_class.base is None:\n+            # Root base class, now traverse the children\n+            check_children_for_duplicate_members(base_class, [], set())\n+\n     with open(target_path, 'w+') as f:\n         f.write(\n             header.replace('${INCLUDE_LIST}', ''.join([include_base.replace('${FILENAME}', x) for x in include_list]))\ndiff --git a/src/include/duckdb/storage/object_cache.hpp b/src/include/duckdb/storage/object_cache.hpp\nindex 170c0041f842..6829dc4212ee 100644\n--- a/src/include/duckdb/storage/object_cache.hpp\n+++ b/src/include/duckdb/storage/object_cache.hpp\n@@ -48,7 +48,7 @@ class ObjectCache {\n \t}\n \n \ttemplate <class T, class... Args>\n-\tshared_ptr<T> GetOrCreate(const string &key, Args &&...args) {\n+\tshared_ptr<T> GetOrCreate(const string &key, Args &&... args) {\n \t\tlock_guard<mutex> glock(lock);\n \n \t\tauto entry = cache.find(key);\ndiff --git a/src/include/duckdb/storage/serialization/constraint.json b/src/include/duckdb/storage/serialization/constraint.json\nindex 0aae5b9ccdc5..cdc142b397a6 100644\n--- a/src/include/duckdb/storage/serialization/constraint.json\n+++ b/src/include/duckdb/storage/serialization/constraint.json\n@@ -50,7 +50,7 @@\n         \"type\": \"vector<string>\"\n       },\n       {\n-        \"name\": \"type\",\n+        \"name\": \"fk_type\",\n         \"type\": \"ForeignKeyType\",\n         \"property\": \"info.type\"\n       },\ndiff --git a/src/include/duckdb/storage/serialization/create_info.json b/src/include/duckdb/storage/serialization/create_info.json\nindex 6dd26665cf39..5f260ccf3b67 100644\n--- a/src/include/duckdb/storage/serialization/create_info.json\n+++ b/src/include/duckdb/storage/serialization/create_info.json\n@@ -152,7 +152,8 @@\n         \"type\": \"string\"\n       },\n       {\n-        \"name\": \"type\",\n+        \"name\": \"logical_type\",\n+        \"property\": \"type\",\n         \"type\": \"LogicalType\"\n       }\n     ]\ndiff --git a/src/include/duckdb/storage/serialization/parse_info.json b/src/include/duckdb/storage/serialization/parse_info.json\nindex fea65a4c750f..763e04562c59 100644\n--- a/src/include/duckdb/storage/serialization/parse_info.json\n+++ b/src/include/duckdb/storage/serialization/parse_info.json\n@@ -184,7 +184,8 @@\n         \"type\": \"vector<PhysicalIndex>\"\n       },\n       {\n-        \"name\": \"type\",\n+        \"name\": \"alter_fk_type\",\n+        \"property\": \"type\",\n         \"type\": \"AlterForeignKeyType\"\n       }\n     ]\ndiff --git a/src/include/duckdb/storage/serialization/tableref.json b/src/include/duckdb/storage/serialization/tableref.json\nindex a7d9cf4f1632..ad66c16c72b6 100644\n--- a/src/include/duckdb/storage/serialization/tableref.json\n+++ b/src/include/duckdb/storage/serialization/tableref.json\n@@ -63,7 +63,8 @@\n         \"optional\": true\n       },\n       {\n-        \"name\": \"type\",\n+        \"name\": \"join_type\",\n+        \"property\": \"type\",\n         \"type\": \"JoinType\"\n       },\n       {\n@@ -100,10 +101,6 @@\n         \"name\": \"function\",\n         \"type\": \"ParsedExpression*\"\n       },\n-      {\n-        \"name\": \"alias\",\n-        \"type\": \"string\"\n-      },\n       {\n         \"name\": \"column_name_alias\",\n         \"type\": \"vector<string>\"\ndiff --git a/src/storage/serialization/serialize_constraint.cpp b/src/storage/serialization/serialize_constraint.cpp\nindex 2f75c6c44b37..fe833f5e1aa6 100644\n--- a/src/storage/serialization/serialize_constraint.cpp\n+++ b/src/storage/serialization/serialize_constraint.cpp\n@@ -50,7 +50,7 @@ void ForeignKeyConstraint::FormatSerialize(FormatSerializer &serializer) const {\n \tConstraint::FormatSerialize(serializer);\n \tserializer.WriteProperty(\"pk_columns\", pk_columns);\n \tserializer.WriteProperty(\"fk_columns\", fk_columns);\n-\tserializer.WriteProperty(\"type\", info.type);\n+\tserializer.WriteProperty(\"fk_type\", info.type);\n \tserializer.WriteProperty(\"schema\", info.schema);\n \tserializer.WriteProperty(\"table\", info.table);\n \tserializer.WriteProperty(\"pk_keys\", info.pk_keys);\n@@ -61,7 +61,7 @@ unique_ptr<Constraint> ForeignKeyConstraint::FormatDeserialize(FormatDeserialize\n \tauto result = duckdb::unique_ptr<ForeignKeyConstraint>(new ForeignKeyConstraint());\n \tdeserializer.ReadProperty(\"pk_columns\", result->pk_columns);\n \tdeserializer.ReadProperty(\"fk_columns\", result->fk_columns);\n-\tdeserializer.ReadProperty(\"type\", result->info.type);\n+\tdeserializer.ReadProperty(\"fk_type\", result->info.type);\n \tdeserializer.ReadProperty(\"schema\", result->info.schema);\n \tdeserializer.ReadProperty(\"table\", result->info.table);\n \tdeserializer.ReadProperty(\"pk_keys\", result->info.pk_keys);\ndiff --git a/src/storage/serialization/serialize_create_info.cpp b/src/storage/serialization/serialize_create_info.cpp\nindex 8faeae6a12fe..9c3016711b29 100644\n--- a/src/storage/serialization/serialize_create_info.cpp\n+++ b/src/storage/serialization/serialize_create_info.cpp\n@@ -160,13 +160,13 @@ unique_ptr<CreateInfo> CreateTableInfo::FormatDeserialize(FormatDeserializer &de\n void CreateTypeInfo::FormatSerialize(FormatSerializer &serializer) const {\n \tCreateInfo::FormatSerialize(serializer);\n \tserializer.WriteProperty(\"name\", name);\n-\tserializer.WriteProperty(\"type\", type);\n+\tserializer.WriteProperty(\"logical_type\", type);\n }\n \n unique_ptr<CreateInfo> CreateTypeInfo::FormatDeserialize(FormatDeserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<CreateTypeInfo>(new CreateTypeInfo());\n \tdeserializer.ReadProperty(\"name\", result->name);\n-\tdeserializer.ReadProperty(\"type\", result->type);\n+\tdeserializer.ReadProperty(\"logical_type\", result->type);\n \treturn std::move(result);\n }\n \ndiff --git a/src/storage/serialization/serialize_parse_info.cpp b/src/storage/serialization/serialize_parse_info.cpp\nindex 4cd3f5a48336..97dd887e71a5 100644\n--- a/src/storage/serialization/serialize_parse_info.cpp\n+++ b/src/storage/serialization/serialize_parse_info.cpp\n@@ -176,7 +176,7 @@ void AlterForeignKeyInfo::FormatSerialize(FormatSerializer &serializer) const {\n \tserializer.WriteProperty(\"fk_columns\", fk_columns);\n \tserializer.WriteProperty(\"pk_keys\", pk_keys);\n \tserializer.WriteProperty(\"fk_keys\", fk_keys);\n-\tserializer.WriteProperty(\"type\", type);\n+\tserializer.WriteProperty(\"alter_fk_type\", type);\n }\n \n unique_ptr<AlterTableInfo> AlterForeignKeyInfo::FormatDeserialize(FormatDeserializer &deserializer) {\n@@ -186,7 +186,7 @@ unique_ptr<AlterTableInfo> AlterForeignKeyInfo::FormatDeserialize(FormatDeserial\n \tdeserializer.ReadProperty(\"fk_columns\", result->fk_columns);\n \tdeserializer.ReadProperty(\"pk_keys\", result->pk_keys);\n \tdeserializer.ReadProperty(\"fk_keys\", result->fk_keys);\n-\tdeserializer.ReadProperty(\"type\", result->type);\n+\tdeserializer.ReadProperty(\"alter_fk_type\", result->type);\n \treturn std::move(result);\n }\n \ndiff --git a/src/storage/serialization/serialize_tableref.cpp b/src/storage/serialization/serialize_tableref.cpp\nindex 06e8dd6ae403..38b7468354ec 100644\n--- a/src/storage/serialization/serialize_tableref.cpp\n+++ b/src/storage/serialization/serialize_tableref.cpp\n@@ -96,7 +96,7 @@ void JoinRef::FormatSerialize(FormatSerializer &serializer) const {\n \tserializer.WriteProperty(\"left\", *left);\n \tserializer.WriteProperty(\"right\", *right);\n \tserializer.WriteOptionalProperty(\"condition\", condition);\n-\tserializer.WriteProperty(\"type\", type);\n+\tserializer.WriteProperty(\"join_type\", type);\n \tserializer.WriteProperty(\"ref_type\", ref_type);\n \tserializer.WriteProperty(\"using_columns\", using_columns);\n }\n@@ -106,7 +106,7 @@ unique_ptr<TableRef> JoinRef::FormatDeserialize(FormatDeserializer &deserializer\n \tdeserializer.ReadProperty(\"left\", result->left);\n \tdeserializer.ReadProperty(\"right\", result->right);\n \tdeserializer.ReadOptionalProperty(\"condition\", result->condition);\n-\tdeserializer.ReadProperty(\"type\", result->type);\n+\tdeserializer.ReadProperty(\"join_type\", result->type);\n \tdeserializer.ReadProperty(\"ref_type\", result->ref_type);\n \tdeserializer.ReadProperty(\"using_columns\", result->using_columns);\n \treturn std::move(result);\n@@ -151,14 +151,12 @@ unique_ptr<TableRef> SubqueryRef::FormatDeserialize(FormatDeserializer &deserial\n void TableFunctionRef::FormatSerialize(FormatSerializer &serializer) const {\n \tTableRef::FormatSerialize(serializer);\n \tserializer.WriteProperty(\"function\", *function);\n-\tserializer.WriteProperty(\"alias\", alias);\n \tserializer.WriteProperty(\"column_name_alias\", column_name_alias);\n }\n \n unique_ptr<TableRef> TableFunctionRef::FormatDeserialize(FormatDeserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<TableFunctionRef>(new TableFunctionRef());\n \tdeserializer.ReadProperty(\"function\", result->function);\n-\tdeserializer.ReadProperty(\"alias\", result->alias);\n \tdeserializer.ReadProperty(\"column_name_alias\", result->column_name_alias);\n \treturn std::move(result);\n }\n",
  "test_patch": "diff --git a/test/sql/json/test_serialize_sql.test b/test/sql/json/test_serialize_sql.test\nindex 98dbc9112482..a7f26fb97f07 100644\n--- a/test/sql/json/test_serialize_sql.test\n+++ b/test/sql/json/test_serialize_sql.test\n@@ -88,4 +88,11 @@ PRAGMA json_execute_serialized_sql(\n statement error\n SELECT * FROM json_execute_serialized_sql(json_serialize_sql('SELECT * FROM tbl2', skip_null := true, skip_empty := true));\n ----\n-Parser Error: Expected but did not find property 'modifiers' in json object: '{\"type\":\"SELECT_NODE\",\"select_list\":[{\"class\":\"STAR\",\"type\":\"STAR\",\"columns\":false}],\"from_table\":{\"type\":\"BASE_TABLE\",\"table_name\":\"tbl2\"},\"aggregate_handling\":\"STANDARD_HANDLING\"}'\n\\ No newline at end of file\n+Parser Error: Expected but did not find property 'modifiers' in json object: '{\"type\":\"SELECT_NODE\",\"select_list\":[{\"class\":\"STAR\",\"type\":\"STAR\",\"columns\":false}],\"from_table\":{\"type\":\"BASE_TABLE\",\"table_name\":\"tbl2\"},\"aggregate_handling\":\"STANDARD_HANDLING\"}'\n+\n+\n+# Test execute json serialized sql with multiple nested type tags\n+query II\n+SELECT * FROM json_execute_serialized_sql(json_serialize_sql('WITH a(i) as (SELECT 1) SELECT a1.i as i1, a2.i as i2 FROM a as a1, a as a2'));\n+----\n+1\t1\n",
  "problem_statement": " json_deserialize_sql could not round-trip parsed results from json_serialize_sql\n### What happens?\r\n\r\njson_deserialize_sql seems could not handle certain parsed node types \r\n==\r\n```\r\nv0.8.2-dev2133 726b6d1566\r\nEnter \".help\" for usage hints.\r\nConnected to a transient in-memory database.\r\nUse \".open FILENAME\" to reopen on a persistent database.\r\nD  select json_deserialize_sql(json_serialize_sql('\r\n> SELECT\r\n>     DATE_TRUNC(''month'', p.time) AS cohort_month,\r\n>     COUNT(DISTINCT p.company_id) AS active_users,\r\n>     SUM(p.amount) AS total_purchase_amount\r\n> FROM\r\n>     Purchase p\r\n> JOIN\r\n>     (SELECT\r\n>         user_id,\r\n>         MIN(time) AS first_purchase_time\r\n>      FROM\r\n>         Purchase\r\n>      GROUP BY\r\n>         user_id) fp\r\n> ON\r\n>     p.user_id = fp.user_id\r\n>     AND DATE_TRUNC(''month'', p.time) = DATE_TRUNC(''month'', fp.first_purchase_time)\r\n> GROUP BY\r\n>     DATE_TRUNC(''month'', p.time)\r\n> ORDER BY\r\n>     cohort_month;\r\n> '));\r\nError: Not implemented Error: Enum value: 'JOIN' not implemented\r\n```\r\n\r\n### To Reproduce\r\n1. Start Duckdb CLI\r\n2. Cut-n-paste \r\n```\r\n select json_deserialize_sql(json_serialize_sql('\r\nSELECT\r\n    DATE_TRUNC(''month'', p.time) AS cohort_month,\r\n    COUNT(DISTINCT p.company_id) AS active_users,\r\n    SUM(p.amount) AS total_purchase_amount\r\nFROM\r\n    Purchase p\r\nJOIN\r\n    (SELECT\r\n        user_id,\r\n        MIN(time) AS first_purchase_time\r\n     FROM\r\n        Purchase\r\n     GROUP BY\r\n        user_id) fp\r\nON\r\n    p.user_id = fp.user_id\r\n    AND DATE_TRUNC(''month'', p.time) = DATE_TRUNC(''month'', fp.first_purchase_time)\r\nGROUP BY\r\n    DATE_TRUNC(''month'', p.time)\r\nORDER BY\r\n    cohort_month;\r\n'));\r\n```\r\n\r\n### OS:\r\n\r\nMac OS\r\n\r\n### DuckDB Version:\r\n\r\nv0.8.2-dev2133 726b6d1566 (private build from source)\r\n\r\n### DuckDB Client:\r\n\r\nDuckDB CLI\r\n\r\n### Full Name:\r\n\r\nMin Wei\r\n\r\n### Affiliation:\r\n\r\nNone\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "@min-mwei thanks for opening this issue! Could you please turn the query that reproduces the issue into a minimal working example and [format it as code](https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/creating-and-highlighting-code-blocks)?\nThis is a regression from 0.8.1, the new generated serialization code produces two fields with tag \"type\" for JoinRefs, since a JoinRef is both a subclass of TableRef (with a type field) and a base class itself (with a type field). This is probably not the only inheritance chain where this problem occurs and we should add a check for it in the serialization generation code.",
  "created_at": "2023-08-02T12:39:22Z"
}