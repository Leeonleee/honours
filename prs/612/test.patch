diff --git a/scripts/test_compile.py b/scripts/test_compile.py
index 786c4361eb57..51827c6ef391 100644
--- a/scripts/test_compile.py
+++ b/scripts/test_compile.py
@@ -1,20 +1,51 @@
-import os, sys, amalgamation, pickle
+import os
+import sys
+import amalgamation
+import pickle
+import subprocess
 
-# where to cache which files have already been compiled, only used for --compile --resume
+# where to cache which files have already been compiled
 cache_file = 'amalgamation.cache'
+ignored_files = ['utf8proc_data.cpp']
 
-resume = False
+RESUME_AUTO = 0
+RESUME_ALWAYS = 1
+RESUME_NEVER = 2
 
+# resume behavior
+# by default, we resume if the previous test_compile was run on the same commit hash as this one
+resume = RESUME_AUTO
 for arg in sys.argv:
 	if arg == '--resume':
-		resume = True
+		resume = RESUME_ALWAYS
+	elif arg == '--restart':
+		cache = RESUME_NEVER
 
-if not resume:
+if resume == RESUME_NEVER:
 	try:
 		os.remove(cache_file)
 	except:
 		pass
 
+def get_git_hash():
+	proc = subprocess.Popen(['git', 'rev-parse', 'HEAD'], stdout=subprocess.PIPE)
+	return proc.stdout.read().strip()
+
+current_hash = get_git_hash()
+
+# load the cache, and check the commit hash
+try:
+	with open(cache_file, 'rb') as cf:
+		cache = pickle.load(cf)
+	if resume == RESUME_AUTO:
+		# auto resume, check
+		if cache['commit_hash'] != current_hash:
+			cache = {}
+except:
+	cache = {}
+
+cache['commit_hash'] = current_hash
+
 def try_compilation(fpath, cache):
 	if fpath in cache:
 		return
@@ -32,7 +63,7 @@ def compile_dir(dir, cache):
 	files = os.listdir(dir)
 	files.sort()
 	for fname in files:
-		if fname in amalgamation.excluded_compilation_files:
+		if fname in amalgamation.excluded_compilation_files or fname in ignored_files:
 			continue
 		fpath = os.path.join(dir, fname)
 		if os.path.isdir(fpath):
@@ -40,14 +71,7 @@ def compile_dir(dir, cache):
 		elif fname.endswith('.cpp') or fname.endswith('.hpp') or fname.endswith('.c') or fname.endswith('.cc'):
 			try_compilation(fpath, cache)
 
-# compilation pass only
 # compile all files in the src directory (including headers!) individually
-try:
-	with open(cache_file, 'rb') as cf:
-		cache = pickle.load(cf)
-except:
-	cache = {}
-
 for cdir in amalgamation.compile_directories:
 	compile_dir(cdir, cache)
 
diff --git a/test/rigger/test_rigger.cpp b/test/rigger/test_rigger.cpp
index 4dd1be33e206..37644302d706 100644
--- a/test/rigger/test_rigger.cpp
+++ b/test/rigger/test_rigger.cpp
@@ -630,9 +630,9 @@ TEST_CASE("Tests found by Rigger", "[rigger]") {
 		result = con.Query("SELECT (- 41756167 + '1969-12-11 032657' ::DATE)::VARCHAR;");
 		REQUIRE(CHECK_COLUMN(result, 0, {"112356-06-10 (BC)"}));
 	}
-	SECTION("592"){
-	    // Expression with LIKE and comparison causes an assertion failure
-	    REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 VARCHAR);"));
+	SECTION("592") {
+		// Expression with LIKE and comparison causes an assertion failure
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 VARCHAR);"));
 		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0 VALUES (0);"));
 		result = con.Query("SELECT * FROM t0 WHERE c0 LIKE '' AND c0 < true;");
 		REQUIRE(CHECK_COLUMN(result, 0, {}));
@@ -666,4 +666,16 @@ TEST_CASE("Tests found by Rigger", "[rigger]") {
 		result = con.Query("SELECT * FROM t0 WHERE 'a' BETWEEN c0 AND c1 COLLATE NOACCENT.NOCASE;");
 		REQUIRE(CHECK_COLUMN(result, 0, {}));
 	}
+	SECTION("609") {
+		// Incorrect result for MIN() on expression involving rowid
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE t0(c0 INT, c1 INT);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO t0(c0) VALUES (0), (0), (0), (0), (0), (0), (0), (0), (0), (0), (0), "
+		                          "(0), (0), (0), (0), (0),  (0), (0), (0), (0), (0), (0), (NULL), (NULL);"));
+		REQUIRE_NO_FAIL(con.Query("CREATE INDEX b ON t0(c1);"));
+		REQUIRE_NO_FAIL(con.Query("UPDATE t0 SET c1 = NULL;"));
+		result = con.Query("SELECT MIN(100000000000000000<<t0.rowid) FROM t0;");
+		REQUIRE(CHECK_COLUMN(result, 0, {Value::BIGINT(-9223372036854775807LL - 1)}));
+		result = con.Query("SELECT MIN(100000000000000000<<t0.rowid) FROM t0 WHERE NOT c0;");
+		REQUIRE(CHECK_COLUMN(result, 0, {Value::BIGINT(-8802109549835190272LL)}));
+	}
 }
diff --git a/test/sql/aggregate/test_aggregate.cpp b/test/sql/aggregate/test_aggregate.cpp
index 702d8a9e7f62..6d5d7429f40d 100644
--- a/test/sql/aggregate/test_aggregate.cpp
+++ b/test/sql/aggregate/test_aggregate.cpp
@@ -1,5 +1,6 @@
 #include "catch.hpp"
 #include "test_helpers.hpp"
+#include "duckdb/main/appender.hpp"
 
 using namespace duckdb;
 using namespace std;
@@ -329,12 +330,14 @@ TEST_CASE("Test STRING_AGG operator with many groups", "[aggregate][.]") {
 	REQUIRE_NO_FAIL(con.Query("CREATE TABLE strings(g INTEGER, x VARCHAR);"));
 	vector<Value> expected_g, expected_h;
 	string expected_large_value;
+	Appender appender(con, "strings");
 	for (idx_t i = 0; i < 10000; i++) {
-		REQUIRE_NO_FAIL(con.Query("INSERT INTO strings VALUES (?, ?);", (int)i, "hello"));
+		appender.AppendRow((int)i, "hello");
 		expected_g.push_back(Value::INTEGER(i));
 		expected_h.push_back(Value("hello"));
 		expected_large_value += (i > 0 ? "," : "") + string("hello");
 	}
+	appender.Close();
 	REQUIRE_NO_FAIL(con.Query("COMMIT;"));
 
 	// many small groups
@@ -511,9 +514,12 @@ TEST_CASE("Test GROUP BY with many groups", "[aggregate][.]") {
 	Connection con(db);
 
 	REQUIRE_NO_FAIL(con.Query("CREATE TABLE integers(i INTEGER, j INTEGER);"));
+	Appender appender(con, "integers");
 	for (idx_t i = 0; i < 10000; i++) {
-		REQUIRE_NO_FAIL(con.Query("INSERT INTO integers VALUES (" + to_string(i) + ", 1), (" + to_string(i) + ", 2);"));
+		appender.AppendRow((int)i, (int)1);
+		appender.AppendRow((int)i, (int)2);
 	}
+	appender.Close();
 	result = con.Query("SELECT SUM(i), SUM(sums) FROM (SELECT i, SUM(j) AS sums FROM integers GROUP BY i) tbl1");
 	REQUIRE(CHECK_COLUMN(result, 0, {49995000}));
 	REQUIRE(CHECK_COLUMN(result, 1, {30000}));
diff --git a/test/sql/alter/test_alter.cpp b/test/sql/alter/test_alter.cpp
index 66eab0a64cf4..68e0a96cc929 100644
--- a/test/sql/alter/test_alter.cpp
+++ b/test/sql/alter/test_alter.cpp
@@ -131,15 +131,643 @@ TEST_CASE("Test ALTER TABLE RENAME COLUMN on a table with constraints", "[alter]
 	DuckDB db(nullptr);
 	Connection con(db);
 
-	// create a table with a check constraint referencing the to-be-renamed column
-	REQUIRE_NO_FAIL(con.Query("CREATE TABLE test(i INTEGER CHECK(i < 10), j INTEGER)"));
-	// insert some elements
-	REQUIRE_NO_FAIL(con.Query("INSERT INTO test (i, j) VALUES (1, 2), (2, 3)"));
-	REQUIRE_FAIL(con.Query("INSERT INTO test (i, j) VALUES (100, 2)"));
-	// now alter the column name
-	// currently, we don't support altering tables with constraints
-	REQUIRE_FAIL(con.Query("ALTER TABLE test RENAME COLUMN i TO k"));
-	// the check should still work after the alter table
-	// REQUIRE_NO_FAIL(con.Query("INSERT INTO test (k, j) VALUES (1, 2), (2, 3)"));
-	// REQUIRE_FAIL(con.Query("INSERT INTO test (k, j) VALUES (100, 2)"));
+	SECTION("CHECK constraint") {
+		// create a table with a check constraint referencing the to-be-renamed column
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE test(i INTEGER CHECK(i < 10), j INTEGER)"));
+		// insert some elements
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test (i, j) VALUES (1, 2), (2, 3)"));
+		REQUIRE_FAIL(con.Query("INSERT INTO test (i, j) VALUES (100, 2)"));
+		// now alter the column name
+		// currently, we don't support altering tables with constraints
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test RENAME COLUMN i TO k"));
+		// the check should still work after the alter table
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test (k, j) VALUES (1, 2), (2, 3)"));
+		REQUIRE_FAIL(con.Query("INSERT INTO test (k, j) VALUES (100, 2)"));
+	}
+	SECTION("NOT NULL constraint") {
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE test(i INTEGER NOT NULL, j INTEGER)"));
+		// insert some elements
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test (i, j) VALUES (1, 2), (2, 3)"));
+		REQUIRE_FAIL(con.Query("INSERT INTO test (i, j) VALUES (NULL, 2)"));
+		// now alter the column name
+		// currently, we don't support altering tables with constraints
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test RENAME COLUMN i TO k"));
+		// the check should still work after the alter table
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test (k, j) VALUES (1, 2), (2, 3)"));
+		REQUIRE_FAIL(con.Query("INSERT INTO test (k, j) VALUES (NULL, 2)"));
+	}
+	SECTION("UNIQUE constraint") {
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE test(i INTEGER, j INTEGER, PRIMARY KEY(i, j))"));
+		// insert some elements
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test (i, j) VALUES (1, 1), (2, 2)"));
+		REQUIRE_FAIL(con.Query("INSERT INTO test (i, j) VALUES (1, 1)"));
+		// now alter the column name
+		// currently, we don't support altering tables with constraints
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test RENAME COLUMN i TO k"));
+		// the check should still work after the alter table
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test (k, j) VALUES (3, 3), (4, 4)"));
+		REQUIRE_FAIL(con.Query("INSERT INTO test (k, j) VALUES (1, 1)"));
+	}
+}
+
+TEST_CASE("Test ALTER TABLE ADD COLUMN", "[alter]") {
+	unique_ptr<QueryResult> result;
+	DuckDB db(nullptr);
+	Connection con(db);
+
+	REQUIRE_NO_FAIL(con.Query("CREATE TABLE test(i INTEGER, j INTEGER)"));
+	REQUIRE_NO_FAIL(con.Query("INSERT INTO test VALUES (1, 1), (2, 2)"));
+
+	SECTION("Standard ADD COLUMN") {
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ADD COLUMN k INTEGER"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 2, {Value(), Value()}));
+	}
+	SECTION("ADD COLUMN with default value") {
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ADD COLUMN l INTEGER DEFAULT 3"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 2, {3, 3}));
+	}
+	SECTION("ADD COLUMN with sequence as default value") {
+		REQUIRE_NO_FAIL(con.Query("CREATE SEQUENCE seq"));
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ADD COLUMN m INTEGER DEFAULT nextval('seq')"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 2, {1, 2}));
+	}
+	SECTION("ADD COLUMN with data inside local storage") {
+		REQUIRE_NO_FAIL(con.Query("BEGIN TRANSACTION"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test VALUES (3, 3)"));
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ADD COLUMN k INTEGER"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2, 3}));
+		REQUIRE(CHECK_COLUMN(result, 2, {Value(), Value(), Value()}));
+
+		REQUIRE_NO_FAIL(con.Query("ROLLBACK"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+		REQUIRE(result->names.size() == 2);
+
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test VALUES (3, 3)"));
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2, 3}));
+	}
+	SECTION("multiple ADD COLUMN in the same transaction") {
+		REQUIRE_NO_FAIL(con.Query("BEGIN TRANSACTION"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test VALUES (3, 3)"));
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ADD COLUMN k INTEGER"));
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ADD COLUMN l INTEGER"));
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ADD COLUMN m INTEGER DEFAULT 3"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2, 3}));
+		REQUIRE(CHECK_COLUMN(result, 2, {Value(), Value(), Value()}));
+		REQUIRE(CHECK_COLUMN(result, 3, {Value(), Value(), Value()}));
+		REQUIRE(CHECK_COLUMN(result, 4, {3, 3, 3}));
+
+		REQUIRE_NO_FAIL(con.Query("ROLLBACK"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+		REQUIRE(result->names.size() == 2);
+	}
+	SECTION("ADD COLUMN with index") {
+		// what if we create an index on the new column, then rollback
+		REQUIRE_NO_FAIL(con.Query("BEGIN TRANSACTION"));
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ADD COLUMN k INTEGER DEFAULT 2"));
+		REQUIRE_NO_FAIL(con.Query("CREATE INDEX i_index ON test(k)"));
+		REQUIRE_NO_FAIL(con.Query("COMMIT"));
+
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test VALUES (3, 3, 3)"));
+
+		result = con.Query("SELECT * FROM test WHERE k=2");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 2, {2, 2}));
+
+		result = con.Query("SELECT * FROM test WHERE k=3");
+		REQUIRE(CHECK_COLUMN(result, 0, {3}));
+		REQUIRE(CHECK_COLUMN(result, 1, {3}));
+		REQUIRE(CHECK_COLUMN(result, 2, {3}));
+	}
+	SECTION("ADD COLUMN rollback with index") {
+		// what if we create an index on the new column, then rollback
+		REQUIRE_NO_FAIL(con.Query("BEGIN TRANSACTION"));
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ADD COLUMN k INTEGER"));
+		REQUIRE_NO_FAIL(con.Query("CREATE INDEX i_index ON test(k)"));
+		REQUIRE_NO_FAIL(con.Query("ROLLBACK"));
+
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test VALUES (3, 3)"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2, 3}));
+	}
+	SECTION("Incorrect usage") {
+		// cannot add a column that already exists!
+		REQUIRE_FAIL(con.Query("ALTER TABLE test ADD COLUMN i INTEGER"));
+	}
+}
+
+TEST_CASE("Test ALTER TABLE ADD COLUMN with multiple transactions", "[alter]") {
+	unique_ptr<QueryResult> result;
+	DuckDB db(nullptr);
+	Connection con(db), con2(db);
+
+	REQUIRE_NO_FAIL(con.Query("CREATE TABLE test(i INTEGER, j INTEGER)"));
+	REQUIRE_NO_FAIL(con.Query("INSERT INTO test VALUES (1, 1), (2, 2)"));
+
+	SECTION("Only one pending table alter can be active at a time") {
+		REQUIRE_NO_FAIL(con.Query("BEGIN TRANSACTION"));
+		// con adds a column to test
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ADD COLUMN k INTEGER"));
+		// con2 cannot add a new column now!
+		REQUIRE_FAIL(con2.Query("ALTER TABLE test ADD COLUMN l INTEGER"));
+		REQUIRE_NO_FAIL(con.Query("COMMIT"));
+		// after a commit, con2 can add a new column again
+		REQUIRE_NO_FAIL(con2.Query("ALTER TABLE test ADD COLUMN l INTEGER"));
+	}
+	SECTION("Can only append to newest table") {
+		REQUIRE_NO_FAIL(con.Query("BEGIN TRANSACTION"));
+		// con adds a column to test
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ADD COLUMN k INTEGER"));
+
+		// con2 cannot append now!
+		REQUIRE_FAIL(con2.Query("INSERT INTO test (i, j) VALUES (3, 3)"));
+		// but we can delete rows!
+		REQUIRE_NO_FAIL(con2.Query("DELETE FROM test WHERE i=1"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 2, {Value(), Value()}));
+
+		result = con2.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {2}));
+
+		// we can also update rows
+		REQUIRE_NO_FAIL(con2.Query("UPDATE test SET j=100"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 2, {Value(), Value()}));
+
+		result = con2.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {100}));
+
+		REQUIRE_NO_FAIL(con.Query("COMMIT"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {100}));
+		REQUIRE(CHECK_COLUMN(result, 2, {Value()}));
+	}
+	SECTION("Alter table while other transaction still has pending appends") {
+		REQUIRE_NO_FAIL(con2.Query("BEGIN TRANSACTION"));
+		REQUIRE_NO_FAIL(con2.Query("INSERT INTO test VALUES (3, 3)"));
+
+		// now con adds a column
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ADD COLUMN k INTEGER"));
+
+		// cannot commit con2! conflict on append
+		REQUIRE_FAIL(con2.Query("COMMIT"));
+	}
+}
+
+TEST_CASE("Test ALTER TABLE DROP COLUMN", "[alter]") {
+	unique_ptr<QueryResult> result;
+	DuckDB db(nullptr);
+	Connection con(db);
+
+	REQUIRE_NO_FAIL(con.Query("CREATE TABLE test(i INTEGER, j INTEGER)"));
+	REQUIRE_NO_FAIL(con.Query("INSERT INTO test VALUES (1, 1), (2, 2)"));
+
+	SECTION("Standard DROP COLUMN") {
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test DROP COLUMN j"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+		REQUIRE(result->names.size() == 1);
+	}
+	SECTION("Rollback of DROP COLUMN") {
+		REQUIRE_NO_FAIL(con.Query("BEGIN TRANSACTION"));
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test DROP COLUMN j"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+		REQUIRE(result->names.size() == 1);
+		REQUIRE_NO_FAIL(con.Query("ROLLBACK"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+		REQUIRE(result->names.size() == 2);
+	}
+	SECTION("Cannot DROP COLUMN which has an index built on it") {
+		REQUIRE_NO_FAIL(con.Query("CREATE INDEX i_index ON test(j)"));
+		REQUIRE_FAIL(con.Query("ALTER TABLE test DROP COLUMN j"));
+
+		// we can remove the column after dropping the index
+		REQUIRE_NO_FAIL(con.Query("DROP INDEX i_index"));
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test DROP COLUMN j"));
+	}
+	SECTION("DROP COLUMN with check constraint on single column") {
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE test2(i INTEGER, j INTEGER CHECK(j < 10))"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test2 VALUES (1, 1), (2, 2)"));
+		result = con.Query("SELECT * FROM test2");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+
+		// we can drop a column that has a single check constraint on it
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test2 DROP COLUMN j"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test2 VALUES (3)"));
+
+		result = con.Query("SELECT * FROM test2");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3}));
+		REQUIRE(result->names.size() == 1);
+	}
+	SECTION("DROP COLUMN with check constraint on multiple columns") {
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE test2(i INTEGER, j INTEGER CHECK(i+j < 10))"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test2 VALUES (1, 1), (2, 2)"));
+		result = con.Query("SELECT * FROM test2");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+
+		// we CANNOT drop one of the columns, because the CHECK constraint depends on both
+		REQUIRE_FAIL(con.Query("ALTER TABLE test2 DROP COLUMN j"));
+	}
+	SECTION("DROP COLUMN with NOT NULL constraint") {
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE test2(i INTEGER, j INTEGER NOT NULL)"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test2 VALUES (1, 1), (2, 2)"));
+		result = con.Query("SELECT * FROM test2");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test2 DROP COLUMN j"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test2 VALUES (3)"));
+
+		result = con.Query("SELECT * FROM test2");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3}));
+		REQUIRE(result->names.size() == 1);
+	}
+	SECTION("DROP COLUMN with check constraint on subsequent column") {
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE test2(i INTEGER, j INTEGER CHECK(j < 10))"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test2 VALUES (1, 1), (2, 2)"));
+		result = con.Query("SELECT * FROM test2");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+
+		// we can drop a column that has a single check constraint on it
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test2 DROP COLUMN i"));
+		REQUIRE_FAIL(con.Query("INSERT INTO test2 VALUES (20)"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test2 VALUES (3)"));
+
+		result = con.Query("SELECT * FROM test2");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3}));
+		REQUIRE(result->names.size() == 1);
+	}
+	SECTION("DROP COLUMN with NOT NULL constraint on subsequent column") {
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE test2(i INTEGER, j INTEGER, k INTEGER NOT NULL)"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test2 VALUES (1, 1, 11), (2, 2, 12)"));
+		result = con.Query("SELECT * FROM test2");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 2, {11, 12}));
+
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test2 DROP COLUMN j"));
+		REQUIRE_FAIL(con.Query("INSERT INTO test2 VALUES (3, NULL)"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test2 VALUES (3, 13)"));
+
+		result = con.Query("SELECT * FROM test2");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3}));
+		REQUIRE(CHECK_COLUMN(result, 1, {11, 12, 13}));
+		REQUIRE(result->names.size() == 2);
+	}
+	SECTION("DROP COLUMN with index built on subsequent column") {
+		REQUIRE_NO_FAIL(con.Query("CREATE INDEX i_index ON test(j)"));
+
+		// cannot drop indexed column
+		REQUIRE_FAIL(con.Query("ALTER TABLE test DROP COLUMN j"));
+		// we also cannot drop the column i (for now) because an index depends on a subsequent column
+		REQUIRE_FAIL(con.Query("ALTER TABLE test DROP COLUMN i"));
+	}
+	SECTION("DROP COLUMN from table with primary key constraint") {
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE test2(i INTEGER PRIMARY KEY, j INTEGER)"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test2 VALUES (1, 1), (2, 2)"));
+
+		// cannot drop primary key column
+		REQUIRE_FAIL(con.Query("ALTER TABLE test2 DROP COLUMN i"));
+		// but we can drop column "i"
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test2 DROP COLUMN j"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test2 VALUES (3)"));
+
+		result = con.Query("SELECT * FROM test2");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3}));
+		REQUIRE(result->names.size() == 1);
+	}
+	SECTION("DROP COLUMN errors") {
+		// cannot drop column which does not exist
+		REQUIRE_FAIL(con.Query("ALTER TABLE test DROP COLUMN blabla"));
+		// unless IF EXISTS is specified
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test DROP COLUMN IF EXISTS blabla"));
+
+		// cannot drop ALL columns of a table
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test DROP COLUMN i"));
+		REQUIRE_FAIL(con.Query("ALTER TABLE test DROP COLUMN j"));
+	}
+}
+
+TEST_CASE("Test ALTER TABLE DROP COLUMN with multiple transactions", "[alter]") {
+	unique_ptr<QueryResult> result;
+	DuckDB db(nullptr);
+	Connection con(db), con2(db);
+
+	REQUIRE_NO_FAIL(con.Query("CREATE TABLE test(i INTEGER, j INTEGER)"));
+	REQUIRE_NO_FAIL(con.Query("INSERT INTO test VALUES (1, 1), (2, 2)"));
+
+	SECTION("Only one pending table alter can be active at a time") {
+		REQUIRE_NO_FAIL(con.Query("BEGIN TRANSACTION"));
+		// con removes a column to test
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test DROP COLUMN j"));
+		// con2 cannot add a new column now!
+		REQUIRE_FAIL(con2.Query("ALTER TABLE test ADD COLUMN k INTEGER"));
+		REQUIRE_NO_FAIL(con.Query("COMMIT"));
+		// we can add the column after the commit
+		REQUIRE_NO_FAIL(con2.Query("ALTER TABLE test ADD COLUMN k INTEGER"));
+	}
+	SECTION("Can only append to newest table") {
+		REQUIRE_NO_FAIL(con.Query("BEGIN TRANSACTION"));
+		// con removes a column from test
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test DROP COLUMN i"));
+
+		// con2 cannot append now!
+		REQUIRE_FAIL(con2.Query("INSERT INTO test (i, j) VALUES (3, 3)"));
+		// but we can delete rows!
+		REQUIRE_NO_FAIL(con2.Query("DELETE FROM test WHERE i=1"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+
+		result = con2.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {2}));
+
+		// we can also update rows
+		REQUIRE_NO_FAIL(con2.Query("UPDATE test SET j=100"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+
+		result = con2.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {100}));
+
+		REQUIRE_NO_FAIL(con.Query("COMMIT"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {100}));
+	}
+	SECTION("Alter table while other transaction still has pending appends") {
+		REQUIRE_NO_FAIL(con2.Query("BEGIN TRANSACTION"));
+		REQUIRE_NO_FAIL(con2.Query("INSERT INTO test VALUES (3, 3)"));
+
+		// now con adds a column
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test DROP COLUMN i"));
+
+		// cannot commit con2! conflict on append
+		REQUIRE_FAIL(con2.Query("COMMIT"));
+	}
+	SECTION("Create index on column that has been removed by other transaction") {
+		// con2 removes a column
+		REQUIRE_NO_FAIL(con2.Query("BEGIN TRANSACTION"));
+		REQUIRE_NO_FAIL(con2.Query("ALTER TABLE test DROP COLUMN j"));
+
+		// now con tries to add an index to that column: this should fail
+		REQUIRE_FAIL(con.Query("CREATE INDEX i_index ON test(j"));
+	}
+}
+
+TEST_CASE("Test ALTER TABLE SET DEFAULT", "[alter]") {
+	unique_ptr<QueryResult> result;
+	DuckDB db(nullptr);
+	Connection con(db);
+
+	REQUIRE_NO_FAIL(con.Query("CREATE TABLE test(i INTEGER, j INTEGER)"));
+	REQUIRE_NO_FAIL(con.Query("INSERT INTO test VALUES (1, 1), (2, 2)"));
+
+	REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ALTER j SET DEFAULT 3"));
+
+	REQUIRE_NO_FAIL(con.Query("INSERT INTO test (i) VALUES (3)"));
+	result = con.Query("SELECT * FROM test");
+	REQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3}));
+	REQUIRE(CHECK_COLUMN(result, 1, {1, 2, 3}));
+
+	REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ALTER COLUMN j DROP DEFAULT"));
+	REQUIRE_NO_FAIL(con.Query("INSERT INTO test (i) VALUES (4)"));
+	result = con.Query("SELECT * FROM test");
+	REQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3, 4}));
+	REQUIRE(CHECK_COLUMN(result, 1, {1, 2, 3, Value()}));
+
+	REQUIRE_NO_FAIL(con.Query("CREATE SEQUENCE seq"));
+	REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ALTER j SET DEFAULT nextval('seq')"));
+	REQUIRE_NO_FAIL(con.Query("INSERT INTO test (i) VALUES (5), (6)"));
+	result = con.Query("SELECT * FROM test");
+	REQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3, 4, 5, 6}));
+	REQUIRE(CHECK_COLUMN(result, 1, {1, 2, 3, Value(), 1, 2}));
+
+	// fail when column does not exist
+	REQUIRE_FAIL(con.Query("ALTER TABLE test ALTER blabla SET DEFAULT 3"));
+	REQUIRE_FAIL(con.Query("ALTER TABLE test ALTER blabla DROP DEFAULT"));
+}
+
+TEST_CASE("Test ALTER TABLE ALTER TYPE", "[alter]") {
+	unique_ptr<QueryResult> result;
+	DuckDB db(nullptr);
+	Connection con(db);
+
+	REQUIRE_NO_FAIL(con.Query("CREATE TABLE test(i INTEGER, j INTEGER)"));
+	REQUIRE_NO_FAIL(con.Query("INSERT INTO test VALUES (1, 1), (2, 2)"));
+
+	SECTION("Standard ALTER TYPE") {
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ALTER i SET DATA TYPE VARCHAR"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {"1", "2"}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+	}
+	SECTION("ALTER TYPE with expression") {
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ALTER i TYPE BIGINT USING i+100"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {101, 102}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+	}
+	SECTION("Rollback ALTER TYPE") {
+		REQUIRE_NO_FAIL(con.Query("BEGIN TRANSACTION"));
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ALTER i SET DATA TYPE VARCHAR"));
+		REQUIRE_NO_FAIL(con.Query("UPDATE test SET i='hello'"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {"hello", "hello"}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+		REQUIRE_NO_FAIL(con.Query("ROLLBACK"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+	}
+	SECTION("ALTER TYPE with transaction local data") {
+		REQUIRE_NO_FAIL(con.Query("BEGIN TRANSACTION"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test VALUES (3, 3)"));
+		// not currently supported
+		REQUIRE_FAIL(con.Query("ALTER TABLE test ALTER i SET DATA TYPE BIGINT"));
+	}
+	SECTION("ALTER TYPE with expression using multiple columns") {
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ALTER i TYPE INTEGER USING 2*(i+j)"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {4, 8}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+	}
+	SECTION("ALTER TYPE with NOT NULL constraint") {
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE test2(i INTEGER NOT NULL, j INTEGER)"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test2 VALUES (1, 1), (2, 2)"));
+		REQUIRE_FAIL(con.Query("INSERT INTO test2 VALUES (NULL, 4)"));
+
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test2 ALTER i SET DATA TYPE VARCHAR"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test2 VALUES ('hello', 3)"));
+		REQUIRE_FAIL(con.Query("INSERT INTO test2 VALUES (NULL, 4)"));
+
+		result = con.Query("SELECT * FROM test2");
+		REQUIRE(CHECK_COLUMN(result, 0, {"1", "2", "hello"}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2, 3}));
+	}
+	SECTION("ALTER TYPE with CHECK constraint") {
+		// we disallow ALTER TYPE on a column with a CHECK constraint
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE test2(i INTEGER CHECK(i < 10), j INTEGER)"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test2 VALUES (1, 1), (2, 2)"));
+
+		REQUIRE_FAIL(con.Query("ALTER TABLE test2 ALTER i SET DATA TYPE VARCHAR"));
+	}
+	SECTION("ALTER TYPE with UNIQUE constraint") {
+		// we disallow ALTER TYPE on a column with a UNIQUE constraint
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE test2(i INTEGER UNIQUE, j INTEGER)"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test2 VALUES (1, 1), (2, 2)"));
+
+		REQUIRE_FAIL(con.Query("ALTER TABLE test2 ALTER i SET DATA TYPE VARCHAR"));
+		// but we CAN change the other column
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test2 ALTER j SET DATA TYPE VARCHAR"));
+		result = con.Query("SELECT * FROM test2");
+		REQUIRE(CHECK_COLUMN(result, 0, {1, 2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {"1", "2"}));
+	}
+	SECTION("ALTER TYPE with INDEX") {
+		// we disallow ALTER TYPE on a column with an index on it
+		REQUIRE_NO_FAIL(con.Query("CREATE INDEX i_index ON test(i)"));
+		REQUIRE_FAIL(con.Query("ALTER TABLE test ALTER i SET DATA TYPE VARCHAR"));
+
+		// we can alter the table after the index is dropped, however
+		REQUIRE_NO_FAIL(con.Query("DROP INDEX i_index"));
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ALTER i SET DATA TYPE VARCHAR"));
+	}
+	SECTION("ALTER TYPE with unknown columns") {
+		REQUIRE_FAIL(con.Query("ALTER TABLE test ALTER blabla SET TYPE VARCHAR"));
+		REQUIRE_FAIL(con.Query("ALTER TABLE test ALTER i SET TYPE VARCHAR USING blabla"));
+		// cannot use aggregates or window functions
+		REQUIRE_FAIL(con.Query("ALTER TABLE test ALTER i SET TYPE VARCHAR USING SUM(i)"));
+		REQUIRE_FAIL(con.Query("ALTER TABLE test ALTER i SET TYPE VARCHAR USING row_id() OVER ()"));
+	}
+}
+
+TEST_CASE("Test ALTER TABLE ALTER TYPE with multiple transactions", "[alter]") {
+	unique_ptr<QueryResult> result;
+	DuckDB db(nullptr);
+	Connection con(db), con2(db);
+
+	REQUIRE_NO_FAIL(con.Query("CREATE TABLE test(i INTEGER, j INTEGER)"));
+	REQUIRE_NO_FAIL(con.Query("INSERT INTO test VALUES (1, 1), (2, 2)"));
+
+	SECTION("Only one pending table alter can be active at a time") {
+		REQUIRE_NO_FAIL(con.Query("BEGIN TRANSACTION"));
+		// con alters a column to test
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ALTER j TYPE VARCHAR"));
+		// con2 cannot alter another column now!
+		REQUIRE_FAIL(con2.Query("ALTER TABLE test ALTER i TYPE VARCHAR"));
+		REQUIRE_NO_FAIL(con.Query("COMMIT"));
+		// we can alter the column after the commit
+		REQUIRE_NO_FAIL(con2.Query("ALTER TABLE test ALTER i TYPE VARCHAR"));
+	}
+	SECTION("Can only append to newest table") {
+		REQUIRE_NO_FAIL(con.Query("BEGIN TRANSACTION"));
+		// con removes a column from test
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ALTER i TYPE VARCHAR"));
+
+		// con2 cannot append now!
+		REQUIRE_FAIL(con2.Query("INSERT INTO test (i, j) VALUES (3, 3)"));
+		// but we can delete rows!
+		REQUIRE_NO_FAIL(con2.Query("DELETE FROM test WHERE i=1"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {"1", "2"}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+
+		result = con2.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {2}));
+		REQUIRE(CHECK_COLUMN(result, 1, {2}));
+
+		// we can also update rows, but updates to i will not be seen...
+		// should we check this somehow?
+		REQUIRE_NO_FAIL(con2.Query("UPDATE test SET i=1000"));
+		REQUIRE_NO_FAIL(con2.Query("UPDATE test SET j=100"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {"1", "2"}));
+		REQUIRE(CHECK_COLUMN(result, 1, {1, 2}));
+
+		result = con2.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {1000}));
+		REQUIRE(CHECK_COLUMN(result, 1, {100}));
+
+		REQUIRE_NO_FAIL(con.Query("COMMIT"));
+
+		result = con.Query("SELECT * FROM test");
+		REQUIRE(CHECK_COLUMN(result, 0, {"2"}));
+		REQUIRE(CHECK_COLUMN(result, 1, {100}));
+	}
+	SECTION("Alter table while other transaction still has pending appends") {
+		REQUIRE_NO_FAIL(con2.Query("BEGIN TRANSACTION"));
+		REQUIRE_NO_FAIL(con2.Query("INSERT INTO test VALUES (3, 3)"));
+
+		// now con adds a column
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ALTER i TYPE VARCHAR"));
+
+		// cannot commit con2! conflict on append
+		REQUIRE_FAIL(con2.Query("COMMIT"));
+	}
+	SECTION("Create index on column that has been altered by other transaction") {
+		// con2 removes a column
+		REQUIRE_NO_FAIL(con2.Query("BEGIN TRANSACTION"));
+		REQUIRE_NO_FAIL(con2.Query("ALTER TABLE test ALTER j TYPE VARCHAR"));
+
+		// now con tries to add an index to that column: this should fail
+		REQUIRE_FAIL(con.Query("CREATE INDEX i_index ON test(j"));
+	}
 }
diff --git a/test/sql/storage/test_store_alter.cpp b/test/sql/storage/test_store_alter.cpp
index 334f0868400a..1e36a816487b 100644
--- a/test/sql/storage/test_store_alter.cpp
+++ b/test/sql/storage/test_store_alter.cpp
@@ -5,7 +5,7 @@
 using namespace duckdb;
 using namespace std;
 
-TEST_CASE("Test storage of alter table", "[storage]") {
+TEST_CASE("Test storage of alter table rename column", "[storage]") {
 	unique_ptr<QueryResult> result;
 	auto storage_database = TestCreatePath("storage_test");
 	auto config = GetTestConfig();
@@ -40,3 +40,142 @@ TEST_CASE("Test storage of alter table", "[storage]") {
 	}
 	DeleteDatabase(storage_database);
 }
+
+TEST_CASE("Test storage of alter table add column", "[storage]") {
+	unique_ptr<QueryResult> result;
+	auto storage_database = TestCreatePath("storage_test");
+	auto config = GetTestConfig();
+
+	// make sure the database does not exist
+	DeleteDatabase(storage_database);
+	{
+		// create a database and insert values
+		DuckDB db(storage_database, config.get());
+		Connection con(db);
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE test (a INTEGER, b INTEGER);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test VALUES (11, 22), (13, 22), (12, 21)"));
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ADD COLUMN k INTEGER DEFAULT 2"));
+
+		result = con.Query("SELECT k FROM test ORDER BY k");
+		REQUIRE(CHECK_COLUMN(result, 0, {2, 2, 2}));
+	}
+	// reload the database from disk
+	for (idx_t i = 0; i < 2; i++) {
+		DuckDB db(storage_database, config.get());
+		Connection con(db);
+		result = con.Query("SELECT k FROM test ORDER BY k");
+		REQUIRE(CHECK_COLUMN(result, 0, {2, 2, 2}));
+	}
+	DeleteDatabase(storage_database);
+}
+
+TEST_CASE("Add column to persistent table", "[storage]") {
+	unique_ptr<QueryResult> result;
+	auto storage_database = TestCreatePath("storage_test");
+	auto config = GetTestConfig();
+
+	// make sure the database does not exist
+	DeleteDatabase(storage_database);
+	{
+		// create a database and insert values
+		DuckDB db(storage_database, config.get());
+		Connection con(db);
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE test (a INTEGER, b INTEGER);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test VALUES (11, 22), (13, 22), (12, 21)"));
+	}
+	// reload and alter
+	{
+		DuckDB db(storage_database, config.get());
+		Connection con(db);
+
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ADD COLUMN k INTEGER DEFAULT 2"));
+
+		result = con.Query("SELECT k FROM test ORDER BY k");
+		REQUIRE(CHECK_COLUMN(result, 0, {2, 2, 2}));
+	}
+	// now reload
+	for (idx_t i = 0; i < 2; i++) {
+		DuckDB db(storage_database, config.get());
+		Connection con(db);
+
+		result = con.Query("SELECT k FROM test ORDER BY k");
+		REQUIRE(CHECK_COLUMN(result, 0, {2, 2, 2}));
+	}
+	DeleteDatabase(storage_database);
+}
+
+TEST_CASE("Remove column from persistent table", "[storage]") {
+	unique_ptr<QueryResult> result;
+	auto storage_database = TestCreatePath("storage_test");
+	auto config = GetTestConfig();
+
+	// make sure the database does not exist
+	DeleteDatabase(storage_database);
+	{
+		// create a database and insert values
+		DuckDB db(storage_database, config.get());
+		Connection con(db);
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE test (a INTEGER, b INTEGER);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test VALUES (11, 22), (13, 22), (12, 21)"));
+	}
+	// reload and alter
+	{
+		DuckDB db(storage_database, config.get());
+		Connection con(db);
+
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test DROP COLUMN b"));
+
+		result = con.Query("SELECT * FROM test ORDER BY 1");
+		REQUIRE(CHECK_COLUMN(result, 0, {11, 12, 13}));
+		REQUIRE(result->names.size() == 1);
+	}
+	// now reload
+	for (idx_t i = 0; i < 2; i++) {
+		DuckDB db(storage_database, config.get());
+		Connection con(db);
+
+		result = con.Query("SELECT * FROM test ORDER BY 1");
+		REQUIRE(CHECK_COLUMN(result, 0, {11, 12, 13}));
+		REQUIRE(result->names.size() == 1);
+	}
+	DeleteDatabase(storage_database);
+}
+
+TEST_CASE("Alter column type of persistent table", "[storage]") {
+	unique_ptr<QueryResult> result;
+	auto storage_database = TestCreatePath("storage_test");
+	auto config = GetTestConfig();
+
+	// make sure the database does not exist
+	DeleteDatabase(storage_database);
+	{
+		// create a database and insert values
+		DuckDB db(storage_database, config.get());
+		Connection con(db);
+		REQUIRE_NO_FAIL(con.Query("CREATE TABLE test (a INTEGER, b INTEGER);"));
+		REQUIRE_NO_FAIL(con.Query("INSERT INTO test VALUES (11, 22), (13, 22), (12, 21)"));
+	}
+	// reload and alter
+	{
+		DuckDB db(storage_database, config.get());
+		Connection con(db);
+
+		REQUIRE_NO_FAIL(con.Query("ALTER TABLE test ALTER b TYPE VARCHAR"));
+
+		result = con.Query("SELECT * FROM test ORDER BY 1");
+		REQUIRE(CHECK_COLUMN(result, 0, {11, 12, 13}));
+		REQUIRE(CHECK_COLUMN(result, 1, {"22", "21", "22"}));
+		REQUIRE(result->names.size() == 2);
+	}
+	// now reload
+	for (idx_t i = 0; i < 2; i++) {
+		DuckDB db(storage_database, config.get());
+		Connection con(db);
+
+		result = con.Query("SELECT * FROM test ORDER BY 1");
+		REQUIRE(CHECK_COLUMN(result, 0, {11, 12, 13}));
+		REQUIRE(CHECK_COLUMN(result, 1, {"22", "21", "22"}));
+		REQUIRE(result->names.size() == 2);
+	}
+	DeleteDatabase(storage_database);
+}
diff --git a/tools/pythonpkg/tests/test_dbapi09.py b/tools/pythonpkg/tests/test_dbapi09.py
index 82b665da0dc8..a58997e7607a 100644
--- a/tools/pythonpkg/tests/test_dbapi09.py
+++ b/tools/pythonpkg/tests/test_dbapi09.py
@@ -1,6 +1,6 @@
 # date type
 
-import numpy 
+import numpy
 import datetime
 import pandas
 
diff --git a/tools/pythonpkg/tests/test_dbapi13.py b/tools/pythonpkg/tests/test_dbapi13.py
new file mode 100644
index 000000000000..39733e2c4f23
--- /dev/null
+++ b/tools/pythonpkg/tests/test_dbapi13.py
@@ -0,0 +1,21 @@
+# time type
+
+import numpy
+import datetime
+import pandas
+
+class TestNumpyTime(object):
+    def test_fetchall_date(self, duckdb_cursor):
+        res = duckdb_cursor.execute("SELECT TIME '13:06:40' as test_time").fetchall()
+        assert res == [(datetime.time(13, 6, 40),)]
+
+    def test_fetchnumpy_date(self, duckdb_cursor):
+        res = duckdb_cursor.execute("SELECT TIME '13:06:40' as test_time").fetchnumpy()
+        arr = numpy.array(['13:06:40'], dtype="object")
+        arr = numpy.ma.masked_array(arr)
+        numpy.testing.assert_array_equal(res['test_time'], arr)
+
+    def test_fetchdf_date(self, duckdb_cursor):
+        res = duckdb_cursor.execute("SELECT TIME '13:06:40' as test_time").fetchdf()
+        ser = pandas.Series(numpy.array(['13:06:40'], dtype="object"), name="test_time")
+        pandas.testing.assert_series_equal(res['test_time'], ser)
