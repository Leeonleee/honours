You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Python UDF with struct return type has incorrect result
### What happens?

The results of a Python UDF returning a struct seem to sometimes have the struct fields and values shuffled.

### To Reproduce

```python
import duckdb


con = duckdb.connect()


def example():
    return {
        "country": "country",
        "postal_code": "postal_code",
        "state": "state",
        "city": "city",
        "street2": "street2",
        "street1": "street1",
    }


return_type = """
STRUCT(
    "street1" STRING,
    "street2" STRING,
    "city" STRING,
    "state" STRING,
    "postal_code" STRING,
    "country" STRING
)
"""

con.create_function("example", example, return_type=return_type)


sol = example()
(res,) = con.sql("SELECT example()").fetchone()

assert res == sol
```

### OS:

Linux x86

### DuckDB Version:

1.0.0

### DuckDB Client:

Python

### Full Name:

Jim Crist-Harif

### Affiliation:

Voltron Data

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Not applicable - the reproduction does not require a data set

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://www.duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of tools/pythonpkg/src/native/python_conversion.cpp]
1: #include "duckdb_python/python_conversion.hpp"
2: #include "duckdb_python/pybind11/pybind_wrapper.hpp"
3: 
4: #include "duckdb_python/pyrelation.hpp"
5: #include "duckdb_python/pyconnection/pyconnection.hpp"
6: #include "duckdb_python/pyresult.hpp"
7: #include "duckdb/common/types.hpp"
8: #include "duckdb/common/exception/conversion_exception.hpp"
9: 
10: #include "datetime.h" //From Python
11: 
12: #include "duckdb/common/limits.hpp"
13: 
14: namespace duckdb {
15: 
16: Value TransformListValue(py::handle ele);
17: 
18: static Value EmptyMapValue() {
19: 	auto map_type = LogicalType::MAP(LogicalType::SQLNULL, LogicalType::SQLNULL);
20: 	return Value::MAP(ListType::GetChildType(map_type), vector<Value>());
21: }
22: 
23: vector<string> TransformStructKeys(py::handle keys, idx_t size, const LogicalType &type = LogicalType::UNKNOWN) {
24: 	vector<string> res;
25: 	if (type.id() == LogicalTypeId::STRUCT) {
26: 		auto &struct_keys = StructType::GetChildTypes(type);
27: 		res.reserve(struct_keys.size());
28: 		for (idx_t i = 0; i < struct_keys.size(); i++) {
29: 			res.push_back(struct_keys[i].first);
30: 		}
31: 		return res;
32: 	}
33: 	res.reserve(size);
34: 	for (idx_t i = 0; i < size; i++) {
35: 		res.emplace_back(py::str(keys.attr("__getitem__")(i)));
36: 	}
37: 	return res;
38: }
39: 
40: static bool IsValidMapComponent(const py::handle &component) {
41: 	// The component is either NULL
42: 	if (py::none().is(component)) {
43: 		return true;
44: 	}
45: 	if (!py::hasattr(component, "__getitem__")) {
46: 		return false;
47: 	}
48: 	if (!py::hasattr(component, "__len__")) {
49: 		return false;
50: 	}
51: 	return true;
52: }
53: 
54: bool DictionaryHasMapFormat(const PyDictionary &dict) {
55: 	if (dict.len != 2) {
56: 		return false;
57: 	}
58: 
59: 	//{ 'key': [ .. keys .. ], 'value': [ .. values .. ]}
60: 	auto keys_key = py::str("key");
61: 	auto values_key = py::str("value");
62: 	auto keys = dict[keys_key];
63: 	auto values = dict[values_key];
64: 	if (!keys || !values) {
65: 		return false;
66: 	}
67: 
68: 	if (!IsValidMapComponent(keys)) {
69: 		return false;
70: 	}
71: 	if (!IsValidMapComponent(values)) {
72: 		return false;
73: 	}
74: 
75: 	// If either of the components is NULL, return early
76: 	if (py::none().is(keys) || py::none().is(values)) {
77: 		return true;
78: 	}
79: 
80: 	// Verify that both the keys and values are of the same length
81: 	auto size = py::len(keys);
82: 	if (size != py::len(values)) {
83: 		return false;
84: 	}
85: 	return true;
86: }
87: 
88: Value TransformDictionaryToStruct(const PyDictionary &dict, const LogicalType &target_type = LogicalType::UNKNOWN) {
89: 	auto struct_keys = TransformStructKeys(dict.keys, dict.len, target_type);
90: 
91: 	bool struct_target = target_type.id() == LogicalTypeId::STRUCT;
92: 	if (struct_target && dict.len != StructType::GetChildCount(target_type)) {
93: 		throw InvalidInputException("We could not convert the object %s to the desired target type (%s)",
94: 		                            dict.ToString(), target_type.ToString());
95: 	}
96: 
97: 	child_list_t<Value> struct_values;
98: 	for (idx_t i = 0; i < dict.len; i++) {
99: 		auto &child_type = struct_target ? StructType::GetChildType(target_type, i) : LogicalType::UNKNOWN;
100: 		auto val = TransformPythonValue(dict.values.attr("__getitem__")(i), child_type);
101: 		struct_values.emplace_back(make_pair(std::move(struct_keys[i]), std::move(val)));
102: 	}
103: 	return Value::STRUCT(std::move(struct_values));
104: }
105: 
106: Value TransformStructFormatDictionaryToMap(const PyDictionary &dict, const LogicalType &target_type) {
107: 	if (dict.len == 0) {
108: 		return EmptyMapValue();
109: 	}
110: 
111: 	if (target_type.id() != LogicalTypeId::MAP) {
112: 		throw InvalidInputException("Please provide a valid target type for transform from Python to Value");
113: 	}
114: 
115: 	if (py::none().is(dict.keys) || py::none().is(dict.values)) {
116: 		return Value(LogicalType::MAP(LogicalTypeId::SQLNULL, LogicalTypeId::SQLNULL));
117: 	}
118: 
119: 	auto size = py::len(dict.keys);
120: 	D_ASSERT(size == py::len(dict.values));
121: 
122: 	auto key_target = MapType::KeyType(target_type);
123: 	auto value_target = MapType::ValueType(target_type);
124: 
125: 	LogicalType key_type = LogicalType::SQLNULL;
126: 	LogicalType value_type = LogicalType::SQLNULL;
127: 
128: 	vector<Value> elements;
129: 	for (idx_t i = 0; i < size; i++) {
130: 
131: 		Value new_key = TransformPythonValue(dict.keys.attr("__getitem__")(i), key_target);
132: 		Value new_value = TransformPythonValue(dict.values.attr("__getitem__")(i), value_target);
133: 
134: 		key_type = LogicalType::ForceMaxLogicalType(key_type, new_key.type());
135: 		value_type = LogicalType::ForceMaxLogicalType(value_type, new_value.type());
136: 
137: 		child_list_t<Value> struct_values;
138: 		struct_values.emplace_back(make_pair("key", std::move(new_key)));
139: 		struct_values.emplace_back(make_pair("value", std::move(new_value)));
140: 
141: 		elements.push_back(Value::STRUCT(std::move(struct_values)));
142: 	}
143: 	if (key_type.id() == LogicalTypeId::SQLNULL) {
144: 		key_type = key_target;
145: 	}
146: 	if (value_type.id() == LogicalTypeId::SQLNULL) {
147: 		value_type = value_target;
148: 	}
149: 
150: 	LogicalType map_type = LogicalType::MAP(key_type, value_type);
151: 
152: 	return Value::MAP(ListType::GetChildType(map_type), std::move(elements));
153: }
154: 
155: Value TransformDictionaryToMap(const PyDictionary &dict, const LogicalType &target_type = LogicalType::UNKNOWN) {
156: 	if (target_type.id() != LogicalTypeId::UNKNOWN && !DictionaryHasMapFormat(dict)) {
157: 		// dict == { 'k1': v1, 'k2': v2, ..., 'kn': vn }
158: 		return TransformStructFormatDictionaryToMap(dict, target_type);
159: 	}
160: 
161: 	auto keys = dict.values.attr("__getitem__")(0);
162: 	auto values = dict.values.attr("__getitem__")(1);
163: 
164: 	if (py::none().is(keys) || py::none().is(values)) {
165: 		// Either 'key' or 'value' is None, return early with a NULL value
166: 		return Value(LogicalType::MAP(LogicalTypeId::SQLNULL, LogicalTypeId::SQLNULL));
167: 	}
168: 
169: 	auto key_size = py::len(keys);
170: 	D_ASSERT(key_size == py::len(values));
171: 	if (key_size == 0) {
172: 		// dict == { 'key': [], 'value': [] }
173: 		return EmptyMapValue();
174: 	}
175: 
176: 	// dict == { 'key': [ ... ], 'value' : [ ... ] }
177: 	LogicalType key_target = LogicalTypeId::UNKNOWN;
178: 	LogicalType value_target = LogicalTypeId::UNKNOWN;
179: 
180: 	if (target_type.id() != LogicalTypeId::UNKNOWN) {
181: 		key_target = LogicalType::LIST(MapType::KeyType(target_type));
182: 		value_target = LogicalType::LIST(MapType::ValueType(target_type));
183: 	}
184: 
185: 	auto key_list = TransformPythonValue(keys, key_target);
186: 	auto value_list = TransformPythonValue(values, value_target);
187: 
188: 	LogicalType key_type = LogicalType::SQLNULL;
189: 	LogicalType value_type = LogicalType::SQLNULL;
190: 
191: 	vector<Value> elements;
192: 	for (idx_t i = 0; i < key_size; i++) {
193: 
194: 		Value new_key = ListValue::GetChildren(key_list)[i];
195: 		Value new_value = ListValue::GetChildren(value_list)[i];
196: 
197: 		key_type = LogicalType::ForceMaxLogicalType(key_type, new_key.type());
198: 		value_type = LogicalType::ForceMaxLogicalType(value_type, new_value.type());
199: 
200: 		child_list_t<Value> struct_values;
201: 		struct_values.emplace_back(make_pair("key", std::move(new_key)));
202: 		struct_values.emplace_back(make_pair("value", std::move(new_value)));
203: 
204: 		elements.push_back(Value::STRUCT(std::move(struct_values)));
205: 	}
206: 
207: 	LogicalType map_type = LogicalType::MAP(key_type, value_type);
208: 
209: 	return Value::MAP(ListType::GetChildType(map_type), std::move(elements));
210: }
211: 
212: Value TransformTupleToStruct(py::handle ele, const LogicalType &target_type = LogicalType::UNKNOWN) {
213: 	auto tuple = py::cast<py::tuple>(ele);
214: 	auto size = py::len(tuple);
215: 
216: 	D_ASSERT(target_type.id() == LogicalTypeId::STRUCT);
217: 	auto child_types = StructType::GetChildTypes(target_type);
218: 	auto child_count = child_types.size();
219: 	if (size != child_count) {
220: 		throw InvalidInputException("Tried to create a STRUCT value from a tuple containing %d elements, but the "
221: 		                            "STRUCT consists of %d children",
222: 		                            size, child_count);
223: 	}
224: 	child_list_t<Value> children;
225: 	for (idx_t i = 0; i < child_count; i++) {
226: 		auto &type = child_types[i].second;
227: 		auto &name = StructType::GetChildName(target_type, i);
228: 		auto element = py::handle(tuple[i]);
229: 		auto converted_value = TransformPythonValue(element, type);
230: 		children.emplace_back(make_pair(name, std::move(converted_value)));
231: 	}
232: 	auto result = Value::STRUCT(std::move(children));
233: 	return result;
234: }
235: 
236: Value TransformListValue(py::handle ele, const LogicalType &target_type = LogicalType::UNKNOWN) {
237: 	auto size = py::len(ele);
238: 
239: 	if (size == 0) {
240: 		return Value::EMPTYLIST(LogicalType::SQLNULL);
241: 	}
242: 
243: 	vector<Value> values;
244: 	values.reserve(size);
245: 
246: 	bool list_target = target_type.id() == LogicalTypeId::LIST;
247: 
248: 	LogicalType element_type = LogicalType::SQLNULL;
249: 	for (idx_t i = 0; i < size; i++) {
250: 		auto &child_type = list_target ? ListType::GetChildType(target_type) : LogicalType::UNKNOWN;
251: 		Value new_value = TransformPythonValue(ele.attr("__getitem__")(i), child_type);
252: 		element_type = LogicalType::ForceMaxLogicalType(element_type, new_value.type());
253: 		values.push_back(std::move(new_value));
254: 	}
255: 
256: 	return Value::LIST(element_type, values);
257: }
258: 
259: Value TransformArrayValue(py::handle ele, const LogicalType &target_type = LogicalType::UNKNOWN) {
260: 	auto size = py::len(ele);
261: 
262: 	if (size == 0) {
263: 		return Value::EMPTYARRAY(LogicalType::SQLNULL, size);
264: 	}
265: 
266: 	vector<Value> values;
267: 	values.reserve(size);
268: 
269: 	bool array_target = target_type.id() == LogicalTypeId::ARRAY;
270: 	auto &child_type = array_target ? ArrayType::GetChildType(target_type) : LogicalType::UNKNOWN;
271: 
272: 	LogicalType element_type = LogicalType::SQLNULL;
273: 	for (idx_t i = 0; i < size; i++) {
274: 		Value new_value = TransformPythonValue(ele.attr("__getitem__")(i), child_type);
275: 		element_type = LogicalType::ForceMaxLogicalType(element_type, new_value.type());
276: 		values.push_back(std::move(new_value));
277: 	}
278: 
279: 	return Value::ARRAY(element_type, std::move(values));
280: }
281: 
282: Value TransformDictionary(const PyDictionary &dict) {
283: 	//! DICT -> MAP FORMAT
284: 	// keys() = [key, value]
285: 	// values() = [ [n keys] ], [ [n values] ]
286: 
287: 	//! DICT -> STRUCT FORMAT
288: 	// keys() = ['a', .., 'n']
289: 	// values() = [ val1, .., valn]
290: 	if (dict.len == 0) {
291: 		// dict == {}
292: 		return EmptyMapValue();
293: 	}
294: 
295: 	if (DictionaryHasMapFormat(dict)) {
296: 		return TransformDictionaryToMap(dict);
297: 	}
298: 	return TransformDictionaryToStruct(dict);
299: }
300: 
301: bool TryTransformPythonIntegerToDouble(Value &res, py::handle ele) {
302: 	double number = PyLong_AsDouble(ele.ptr());
303: 	if (number == -1.0 && PyErr_Occurred()) {
304: 		PyErr_Clear();
305: 		return false;
306: 	}
307: 	res = Value::DOUBLE(number);
308: 	return true;
309: }
310: 
311: void TransformPythonUnsigned(uint64_t value, Value &res) {
312: 	if (value > (uint64_t)std::numeric_limits<uint32_t>::max()) {
313: 		res = Value::UBIGINT(value);
314: 	} else if (value > (int64_t)std::numeric_limits<uint16_t>::max()) {
315: 		res = Value::UINTEGER(value);
316: 	} else if (value > (int64_t)std::numeric_limits<uint16_t>::max()) {
317: 		res = Value::USMALLINT(value);
318: 	} else {
319: 		res = Value::UTINYINT(value);
320: 	}
321: }
322: 
323: bool TrySniffPythonNumeric(Value &res, int64_t value) {
324: 	if (value < (int64_t)std::numeric_limits<int32_t>::min() || value > (int64_t)std::numeric_limits<int32_t>::max()) {
325: 		res = Value::BIGINT(value);
326: 	} else {
327: 		// To match default duckdb behavior, numeric values without a specified type should not become a smaller type
328: 		// than INT32
329: 		res = Value::INTEGER(value);
330: 	}
331: 	return true;
332: }
333: 
334: // TODO: add support for HUGEINT
335: bool TryTransformPythonNumeric(Value &res, py::handle ele, const LogicalType &target_type) {
336: 	auto ptr = ele.ptr();
337: 
338: 	int overflow;
339: 	int64_t value = PyLong_AsLongLongAndOverflow(ptr, &overflow);
340: 	if (overflow == -1) {
341: 		PyErr_Clear();
342: 		if (target_type.id() == LogicalTypeId::BIGINT) {
343: 			throw InvalidInputException(StringUtil::Format("Failed to cast value: Python value '%s' to INT64",
344: 			                                               std::string(pybind11::str(ele))));
345: 		}
346: 		auto cast_as = target_type.id() == LogicalTypeId::UNKNOWN ? LogicalType::HUGEINT : target_type;
347: 		auto numeric_string = std::string(py::str(ele));
348: 		res = Value(numeric_string).DefaultCastAs(cast_as);
349: 		return true;
350: 	} else if (overflow == 1) {
351: 		if (target_type.InternalType() == PhysicalType::INT64) {
352: 			throw InvalidInputException(StringUtil::Format("Failed to cast value: Python value '%s' to INT64",
353: 			                                               std::string(pybind11::str(ele))));
354: 		}
355: 		uint64_t unsigned_value = PyLong_AsUnsignedLongLong(ptr);
356: 		if (PyErr_Occurred()) {
357: 			PyErr_Clear();
358: 			return TryTransformPythonIntegerToDouble(res, ele);
359: 		} else {
360: 			TransformPythonUnsigned(unsigned_value, res);
361: 		}
362: 		PyErr_Clear();
363: 		return true;
364: 	} else if (value == -1 && PyErr_Occurred()) {
365: 		return false;
366: 	}
367: 
368: 	// The value is int64_t or smaller
369: 
370: 	switch (target_type.id()) {
371: 	case LogicalTypeId::UNKNOWN:
372: 		return TrySniffPythonNumeric(res, value);
373: 	case LogicalTypeId::HUGEINT: {
374: 		res = Value::HUGEINT(value);
375: 		return true;
376: 	}
377: 	case LogicalTypeId::UHUGEINT: {
378: 		if (value < 0) {
379: 			return false;
380: 		}
381: 		res = Value::UHUGEINT(value);
382: 		return true;
383: 	}
384: 	case LogicalTypeId::BIGINT: {
385: 		res = Value::BIGINT(value);
386: 		return true;
387: 	}
388: 	case LogicalTypeId::INTEGER: {
389: 		if (value < NumericLimits<int32_t>::Minimum() || value > NumericLimits<int32_t>::Maximum()) {
390: 			return false;
391: 		}
392: 		res = Value::INTEGER(value);
393: 		return true;
394: 	}
395: 	case LogicalTypeId::SMALLINT: {
396: 		if (value < NumericLimits<int16_t>::Minimum() || value > NumericLimits<int16_t>::Maximum()) {
397: 			return false;
398: 		}
399: 		res = Value::SMALLINT(value);
400: 		return true;
401: 	}
402: 	case LogicalTypeId::TINYINT: {
403: 		if (value < NumericLimits<int8_t>::Minimum() || value > NumericLimits<int8_t>::Maximum()) {
404: 			return false;
405: 		}
406: 		res = Value::TINYINT(value);
407: 		return true;
408: 	}
409: 	case LogicalTypeId::UBIGINT: {
410: 		if (value < 0) {
411: 			return false;
412: 		}
413: 		res = Value::UBIGINT(value);
414: 		return true;
415: 	}
416: 	case LogicalTypeId::UINTEGER: {
417: 		if (value < 0 || value > (int64_t)NumericLimits<uint32_t>::Maximum()) {
418: 			return false;
419: 		}
420: 		res = Value::UINTEGER(value);
421: 		return true;
422: 	}
423: 	case LogicalTypeId::USMALLINT: {
424: 		if (value < 0 || value > (int64_t)NumericLimits<uint16_t>::Maximum()) {
425: 			return false;
426: 		}
427: 		res = Value::USMALLINT(value);
428: 		return true;
429: 	}
430: 	case LogicalTypeId::UTINYINT: {
431: 		if (value < 0 || value > (int64_t)NumericLimits<uint8_t>::Maximum()) {
432: 			return false;
433: 		}
434: 		res = Value::UTINYINT(value);
435: 		return true;
436: 	}
437: 	default: {
438: 		if (!TrySniffPythonNumeric(res, value)) {
439: 			return false;
440: 		}
441: 		res = res.DefaultCastAs(target_type, true);
442: 		return true;
443: 	}
444: 	}
445: }
446: 
447: PythonObjectType GetPythonObjectType(py::handle &ele) {
448: 	auto &import_cache = *DuckDBPyConnection::ImportCache();
449: 
450: 	if (ele.is_none()) {
451: 		return PythonObjectType::None;
452: 	} else if (ele.is(import_cache.pandas.NaT())) {
453: 		return PythonObjectType::None;
454: 	} else if (ele.is(import_cache.pandas.NA())) {
455: 		return PythonObjectType::None;
456: 	} else if (py::isinstance<py::bool_>(ele)) {
457: 		return PythonObjectType::Bool;
458: 	} else if (py::isinstance<py::int_>(ele)) {
459: 		return PythonObjectType::Integer;
460: 	} else if (py::isinstance<py::float_>(ele)) {
461: 		return PythonObjectType::Float;
462: 	} else if (py::isinstance(ele, import_cache.decimal.Decimal())) {
463: 		return PythonObjectType::Decimal;
464: 	} else if (py::isinstance(ele, import_cache.uuid.UUID())) {
465: 		return PythonObjectType::Uuid;
466: 	} else if (py::isinstance(ele, import_cache.datetime.datetime())) {
467: 		return PythonObjectType::Datetime;
468: 	} else if (py::isinstance(ele, import_cache.datetime.time())) {
469: 		return PythonObjectType::Time;
470: 	} else if (py::isinstance(ele, import_cache.datetime.date())) {
471: 		return PythonObjectType::Date;
472: 	} else if (py::isinstance(ele, import_cache.datetime.timedelta())) {
473: 		return PythonObjectType::Timedelta;
474: 	} else if (py::isinstance<py::str>(ele)) {
475: 		return PythonObjectType::String;
476: 	} else if (py::isinstance<py::bytearray>(ele)) {
477: 		return PythonObjectType::ByteArray;
478: 	} else if (py::isinstance<py::memoryview>(ele)) {
479: 		return PythonObjectType::MemoryView;
480: 	} else if (py::isinstance<py::bytes>(ele)) {
481: 		return PythonObjectType::Bytes;
482: 	} else if (py::isinstance<py::list>(ele)) {
483: 		return PythonObjectType::List;
484: 	} else if (py::isinstance<py::tuple>(ele)) {
485: 		return PythonObjectType::Tuple;
486: 	} else if (py::isinstance<py::dict>(ele)) {
487: 		return PythonObjectType::Dict;
488: 	} else if (ele.is(import_cache.numpy.ma.masked())) {
489: 		return PythonObjectType::None;
490: 	} else if (py::isinstance(ele, import_cache.numpy.ndarray())) {
491: 		return PythonObjectType::NdArray;
492: 	} else if (py::isinstance(ele, import_cache.numpy.datetime64())) {
493: 		return PythonObjectType::NdDatetime;
494: 	} else if (py::isinstance(ele, import_cache.duckdb.Value())) {
495: 		return PythonObjectType::Value;
496: 	} else {
497: 		return PythonObjectType::Other;
498: 	}
499: }
500: 
501: Value TransformPythonValue(py::handle ele, const LogicalType &target_type, bool nan_as_null) {
502: 	auto object_type = GetPythonObjectType(ele);
503: 
504: 	switch (object_type) {
505: 	case PythonObjectType::None:
506: 		return Value();
507: 	case PythonObjectType::Bool:
508: 		return Value::BOOLEAN(ele.cast<bool>());
509: 	case PythonObjectType::Integer: {
510: 		Value integer;
511: 		if (!TryTransformPythonNumeric(integer, ele, target_type)) {
512: 			throw InvalidInputException("An error occurred attempting to convert a python integer");
513: 		}
514: 		return integer;
515: 	}
516: 	case PythonObjectType::Float:
517: 		if (nan_as_null && std::isnan(PyFloat_AsDouble(ele.ptr()))) {
518: 			return Value();
519: 		}
520: 		switch (target_type.id()) {
521: 		case LogicalTypeId::UNKNOWN:
522: 		case LogicalTypeId::DOUBLE: {
523: 			return Value::DOUBLE(ele.cast<double>());
524: 		}
525: 		case LogicalTypeId::FLOAT: {
526: 			return Value::FLOAT(ele.cast<float>());
527: 		}
528: 		case LogicalTypeId::DECIMAL: {
529: 			throw ConversionException("Can't losslessly convert from object of float to type %s",
530: 			                          target_type.ToString());
531: 		}
532: 		default:
533: 			throw ConversionException("Could not convert 'float' to type %s", target_type.ToString());
534: 		}
535: 	case PythonObjectType::Decimal: {
536: 		PyDecimal decimal(ele);
537: 		return decimal.ToDuckValue();
538: 	}
539: 	case PythonObjectType::Uuid: {
540: 		auto string_val = py::str(ele).cast<string>();
541: 		return Value::UUID(string_val);
542: 	}
543: 	case PythonObjectType::Datetime: {
544: 		auto &import_cache = *DuckDBPyConnection::ImportCache();
545: 		bool is_nat = false;
546: 		if (import_cache.pandas.isnull(false)) {
547: 			auto isnull_result = import_cache.pandas.isnull()(ele);
548: 			is_nat = string(py::str(isnull_result)) == "True";
549: 		}
550: 		if (is_nat) {
551: 			return Value();
552: 		}
553: 		auto datetime = PyDateTime(ele);
554: 		return datetime.ToDuckValue(target_type);
555: 	}
556: 	case PythonObjectType::Time: {
557: 		auto time = PyTime(ele);
558: 		return time.ToDuckValue();
559: 	}
560: 	case PythonObjectType::Date: {
561: 		auto date = PyDate(ele);
562: 		return date.ToDuckValue();
563: 	}
564: 	case PythonObjectType::Timedelta: {
565: 		auto timedelta = PyTimeDelta(ele);
566: 		return Value::INTERVAL(timedelta.ToInterval());
567: 	}
568: 	case PythonObjectType::String: {
569: 		auto stringified = ele.cast<string>();
570: 		if (target_type.id() == LogicalTypeId::UNKNOWN) {
571: 			return Value(stringified);
572: 		}
573: 		return Value(stringified).DefaultCastAs(target_type);
574: 	}
575: 	case PythonObjectType::ByteArray: {
576: 		auto byte_array = ele;
577: 		const_data_ptr_t bytes = const_data_ptr_cast(PyByteArray_AsString(byte_array.ptr())); // NOLINT
578: 		idx_t byte_length = PyUtil::PyByteArrayGetSize(byte_array);                           // NOLINT
579: 		return Value::BLOB(bytes, byte_length);
580: 	}
581: 	case PythonObjectType::MemoryView: {
582: 		py::memoryview py_view = ele.cast<py::memoryview>();
583: 		Py_buffer *py_buf = PyUtil::PyMemoryViewGetBuffer(py_view); // NOLINT
584: 		return Value::BLOB(const_data_ptr_t(py_buf->buf), idx_t(py_buf->len));
585: 	}
586: 	case PythonObjectType::Bytes: {
587: 		const string &ele_string = ele.cast<string>();
588: 		switch (target_type.id()) {
589: 		case LogicalTypeId::UNKNOWN:
590: 		case LogicalTypeId::BLOB:
591: 			return Value::BLOB(const_data_ptr_t(ele_string.data()), ele_string.size());
592: 		case LogicalTypeId::BIT: {
593: 			return Value::BIT(ele_string);
594: 		default:
595: 			throw ConversionException("Could not convert 'bytes' to type %s", target_type.ToString());
596: 		}
597: 		}
598: 	}
599: 	case PythonObjectType::List:
600: 		if (target_type.id() == LogicalTypeId::ARRAY) {
601: 			return TransformArrayValue(ele, target_type);
602: 		} else {
603: 			return TransformListValue(ele, target_type);
604: 		}
605: 	case PythonObjectType::Dict: {
606: 		PyDictionary dict = PyDictionary(py::reinterpret_borrow<py::object>(ele));
607: 		switch (target_type.id()) {
608: 		case LogicalTypeId::STRUCT:
609: 			return TransformDictionaryToStruct(dict, target_type);
610: 		case LogicalTypeId::MAP:
611: 			return TransformDictionaryToMap(dict, target_type);
612: 		default:
613: 			return TransformDictionary(dict);
614: 		}
615: 	}
616: 	case PythonObjectType::Tuple: {
617: 		switch (target_type.id()) {
618: 		case LogicalTypeId::STRUCT:
619: 			return TransformTupleToStruct(ele, target_type);
620: 		case LogicalTypeId::UNKNOWN:
621: 		case LogicalTypeId::LIST:
622: 			return TransformListValue(ele, target_type);
623: 		case LogicalTypeId::ARRAY:
624: 			return TransformArrayValue(ele, target_type);
625: 		default:
626: 			throw InvalidInputException("Can't convert tuple to a Value of type %s", target_type.ToString());
627: 		}
628: 	}
629: 	case PythonObjectType::NdArray:
630: 	case PythonObjectType::NdDatetime:
631: 		return TransformPythonValue(ele.attr("tolist")(), target_type, nan_as_null);
632: 	case PythonObjectType::Value: {
633: 		// Extract the internal object and the type from the Value instance
634: 		auto object = ele.attr("object");
635: 		auto type = ele.attr("type");
636: 		shared_ptr<DuckDBPyType> internal_type;
637: 		if (!py::try_cast<shared_ptr<DuckDBPyType>>(type, internal_type)) {
638: 			string actual_type = py::str(type.get_type());
639: 			throw InvalidInputException("The 'type' of a Value should be of type DuckDBPyType, not '%s'", actual_type);
640: 		}
641: 		return TransformPythonValue(object, internal_type->Type());
642: 	}
643: 	case PythonObjectType::Other:
644: 		throw NotImplementedException("Unable to transform python value of type '%s' to DuckDB LogicalType",
645: 		                              py::str(ele.get_type()).cast<string>());
646: 	default:
647: 		throw InternalException("Object type recognized but not implemented!");
648: 	}
649: }
650: 
651: } // namespace duckdb
[end of tools/pythonpkg/src/native/python_conversion.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: