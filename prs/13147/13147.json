{
  "repo": "duckdb/duckdb",
  "pull_number": 13147,
  "instance_id": "duckdb__duckdb-13147",
  "issue_numbers": [
    "13135"
  ],
  "base_commit": "d116ac51ad9b1fcafe45c2ce1e6647132ffae72a",
  "patch": "diff --git a/tools/pythonpkg/src/native/python_conversion.cpp b/tools/pythonpkg/src/native/python_conversion.cpp\nindex 40d56bb9f3c5..624a4e9a237f 100644\n--- a/tools/pythonpkg/src/native/python_conversion.cpp\n+++ b/tools/pythonpkg/src/native/python_conversion.cpp\n@@ -22,14 +22,6 @@ static Value EmptyMapValue() {\n \n vector<string> TransformStructKeys(py::handle keys, idx_t size, const LogicalType &type = LogicalType::UNKNOWN) {\n \tvector<string> res;\n-\tif (type.id() == LogicalTypeId::STRUCT) {\n-\t\tauto &struct_keys = StructType::GetChildTypes(type);\n-\t\tres.reserve(struct_keys.size());\n-\t\tfor (idx_t i = 0; i < struct_keys.size(); i++) {\n-\t\t\tres.push_back(struct_keys[i].first);\n-\t\t}\n-\t\treturn res;\n-\t}\n \tres.reserve(size);\n \tfor (idx_t i = 0; i < size; i++) {\n \t\tres.emplace_back(py::str(keys.attr(\"__getitem__\")(i)));\n@@ -94,11 +86,18 @@ Value TransformDictionaryToStruct(const PyDictionary &dict, const LogicalType &t\n \t\t                            dict.ToString(), target_type.ToString());\n \t}\n \n+\tcase_insensitive_map_t<idx_t> key_mapping;\n+\tfor (idx_t i = 0; i < struct_keys.size(); i++) {\n+\t\tkey_mapping[struct_keys[i]] = i;\n+\t}\n+\n \tchild_list_t<Value> struct_values;\n \tfor (idx_t i = 0; i < dict.len; i++) {\n+\t\tauto &key = struct_target ? StructType::GetChildName(target_type, i) : struct_keys[i];\n+\t\tauto value_index = key_mapping[key];\n \t\tauto &child_type = struct_target ? StructType::GetChildType(target_type, i) : LogicalType::UNKNOWN;\n-\t\tauto val = TransformPythonValue(dict.values.attr(\"__getitem__\")(i), child_type);\n-\t\tstruct_values.emplace_back(make_pair(std::move(struct_keys[i]), std::move(val)));\n+\t\tauto val = TransformPythonValue(dict.values.attr(\"__getitem__\")(value_index), child_type);\n+\t\tstruct_values.emplace_back(make_pair(std::move(key), std::move(val)));\n \t}\n \treturn Value::STRUCT(std::move(struct_values));\n }\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/pandas/test_df_recursive_nested.py b/tools/pythonpkg/tests/fast/pandas/test_df_recursive_nested.py\nindex e8ca7a6b5808..b8de512ad673 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_df_recursive_nested.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_df_recursive_nested.py\n@@ -64,31 +64,31 @@ def test_recursive_struct(self, duckdb_cursor, pandas):\n             Value(\n                 data,\n                 \"\"\"\n-        \tSTRUCT(\n-\t\t\t\tA STRUCT(\n-\t\t\t\t\ta STRUCT(\n-\t\t\t\t\t\t\"1\" INTEGER[]\n-\t\t\t\t\t),\n-\t\t\t\t\tb STRUCT(\n-\t\t\t\t\t\t\"1\" INTEGER[]\n-\t\t\t\t\t),\n-\t\t\t\t\tc STRUCT(\n-\t\t\t\t\t\t\"1\" INTEGER[]\n-\t\t\t\t\t)\n-\t\t\t\t),\n-\t\t\t\tB STRUCT(\n-\t\t\t\t\ta STRUCT(\n-\t\t\t\t\t\t\"1\" INTEGER[]\n-\t\t\t\t\t),\n-\t\t\t\t\tb STRUCT(\n-\t\t\t\t\t\t\"1\" INTEGER[]\n-\t\t\t\t\t),\n-\t\t\t\t\tc STRUCT(\n-\t\t\t\t\t\t\"1\" INTEGER[]\n-\t\t\t\t\t)\n-\t\t\t\t)\n-\t\t\t)\n-\t\t\"\"\",\n+            STRUCT(\n+                A STRUCT(\n+                    a STRUCT(\n+                        \"1\" INTEGER[]\n+                    ),\n+                    b STRUCT(\n+                        \"1\" INTEGER[]\n+                    ),\n+                    c STRUCT(\n+                        \"1\" INTEGER[]\n+                    )\n+                ),\n+                B STRUCT(\n+                    a STRUCT(\n+                        \"1\" INTEGER[]\n+                    ),\n+                    b STRUCT(\n+                        \"1\" INTEGER[]\n+                    ),\n+                    c STRUCT(\n+                        \"1\" INTEGER[]\n+                    )\n+                )\n+            )\n+        \"\"\",\n             ),\n         )\n \n@@ -116,30 +116,21 @@ def test_recursive_map(self, duckdb_cursor, pandas):\n \n     @pytest.mark.parametrize('pandas', [NumpyPandas(), ArrowPandas()])\n     def test_recursive_stresstest(self, duckdb_cursor, pandas):\n-        # LIST(\n-        # \tSTRUCT(\n-        # \t\tMAP(\n-        # \t\t\tSTRUCT(\n-        # \t\t\t\tLIST(\n-        # \t\t\t\t\tINTEGER\n-        # \t\t\t\t)\n-        # \t\t\t)\n-        # \t\t\tLIST(\n-        # \t\t\t\tSTRUCT(\n-        # \t\t\t\t\tVARCHAR\n-        # \t\t\t\t)\n-        # \t\t\t)\n-        # \t\t)\n-        # \t)\n-        # )\n         data = [\n             {\n                 'a': {\n                     'key': [\n+                        # key 1\n                         {'1': [5, 4, 3], '2': [8, 7, 6], '3': [1, 2, 3]},\n+                        # key 2\n                         {'1': [], '2': NULL, '3': [NULL, 0, NULL]},\n                     ],\n-                    'value': [[{'A': 'abc', 'B': 'def', 'C': NULL}], [NULL]],\n+                    'value': [\n+                        # value 1\n+                        [{'A': 'abc', 'B': 'def', 'C': NULL}],\n+                        # value 2\n+                        [NULL],\n+                    ],\n                 },\n                 'b': NULL,\n                 'c': {'key': [], 'value': []},\n@@ -147,12 +138,30 @@ def test_recursive_stresstest(self, duckdb_cursor, pandas):\n         ]\n         reference_query = create_reference_query()\n         df = pandas.DataFrame([{'a': data}])\n+        duckdb_type = \"\"\"\n+            STRUCT(\n+                a MAP(\n+                    STRUCT(\n+                        \"1\" INTEGER[],\n+                        \"2\" INTEGER[],\n+                        \"3\" INTEGER[]\n+                    ),\n+                    STRUCT(\n+                        A VARCHAR,\n+                        B VARCHAR,\n+                        C VARCHAR\n+                    )[]\n+                ),\n+                b INTEGER,\n+                c MAP(VARCHAR, VARCHAR)\n+            )[]\n+        \"\"\"\n         check_equal(\n             duckdb_cursor,\n             df,\n             reference_query,\n             Value(\n                 data,\n-                type='STRUCT(a MAP(STRUCT(\"1\" INTEGER[], \"2\" INTEGER, \"3\" INTEGER), STRUCT(A VARCHAR, B VARCHAR, C VARCHAR)[]), b INTEGER, c MAP(VARCHAR, VARCHAR))[]',\n+                type=duckdb_type,\n             ),\n         )\ndiff --git a/tools/pythonpkg/tests/fast/udf/test_scalar_native.py b/tools/pythonpkg/tests/fast/udf/test_scalar_native.py\nindex b11a479a0831..df58f6a40bb6 100644\n--- a/tools/pythonpkg/tests/fast/udf/test_scalar_native.py\n+++ b/tools/pythonpkg/tests/fast/udf/test_scalar_native.py\n@@ -169,7 +169,7 @@ def return_overflow():\n     def test_structs(self):\n         def add_extra_column(original):\n             original['a'] = 200\n-            original['bb'] = 0\n+            original['c'] = 0\n             return original\n \n         con = duckdb.connect()\n@@ -192,11 +192,16 @@ def add_extra_column(original):\n         res.fetchall()\n \n         def swap_keys(dict):\n+            reversed_keys = list(dict.keys())[::-1]  # Reverse the keys\n+            keys = list(dict.keys())  # Original keys\n             result = {}\n-            reversed_keys = list(dict.keys())\n-            reversed_keys.reverse()\n-            for item in reversed_keys:\n-                result[item] = dict[item]\n+\n+            halfway = len(keys) // 2\n+            for i in range(halfway):\n+                item1 = reversed_keys[i]\n+                item2 = keys[i]\n+                result[item1] = dict[item2]\n+                result[item2] = dict[item1]\n             return result\n \n         con.create_function(\n@@ -211,3 +216,32 @@ def swap_keys(dict):\n         \"\"\"\n         ).fetchall()\n         assert res == [({'a': 'answer_to_life', 'b': 42},)]\n+\n+    def test_struct_different_field_order(self, duckdb_cursor):\n+        def example():\n+            return {\n+                \"country\": \"country\",\n+                \"postal_code\": \"postal_code\",\n+                \"state\": \"state\",\n+                \"city\": \"city\",\n+                \"street2\": \"street2\",\n+                \"street1\": \"street1\",\n+            }\n+\n+        # The order in which the fields are provided is intentionally different\n+        return_type = \"\"\"\n+        STRUCT(\n+            \"street1\" STRING,\n+            \"street2\" STRING,\n+            \"city\" STRING,\n+            \"state\" STRING,\n+            \"postal_code\" STRING,\n+            \"country\" STRING\n+        )\n+        \"\"\"\n+\n+        duckdb_cursor.create_function(\"example\", example, return_type=return_type)\n+\n+        (res,) = duckdb_cursor.sql(\"SELECT example()\").fetchone()\n+        for key, val in res.items():\n+            assert key == val\n",
  "problem_statement": "Python UDF with struct return type has incorrect result\n### What happens?\n\nThe results of a Python UDF returning a struct seem to sometimes have the struct fields and values shuffled.\n\n### To Reproduce\n\n```python\r\nimport duckdb\r\n\r\n\r\ncon = duckdb.connect()\r\n\r\n\r\ndef example():\r\n    return {\r\n        \"country\": \"country\",\r\n        \"postal_code\": \"postal_code\",\r\n        \"state\": \"state\",\r\n        \"city\": \"city\",\r\n        \"street2\": \"street2\",\r\n        \"street1\": \"street1\",\r\n    }\r\n\r\n\r\nreturn_type = \"\"\"\r\nSTRUCT(\r\n    \"street1\" STRING,\r\n    \"street2\" STRING,\r\n    \"city\" STRING,\r\n    \"state\" STRING,\r\n    \"postal_code\" STRING,\r\n    \"country\" STRING\r\n)\r\n\"\"\"\r\n\r\ncon.create_function(\"example\", example, return_type=return_type)\r\n\r\n\r\nsol = example()\r\n(res,) = con.sql(\"SELECT example()\").fetchone()\r\n\r\nassert res == sol\r\n```\n\n### OS:\n\nLinux x86\n\n### DuckDB Version:\n\n1.0.0\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nJim Crist-Harif\n\n### Affiliation:\n\nVoltron Data\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nNot applicable - the reproduction does not require a data set\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "Wasn't really clear from your issue what the actual problem was, it sounded like the items didn't appear in the order you expected them to, but yea this is indeed not working correctly:\r\n```\r\nfor item in zip(sol.items(), res.items()):\r\n    print(item)\r\n```\r\n\r\n```\r\n(('country', 'country'), ('street1', 'country'))\r\n(('postal_code', 'postal_code'), ('street2', 'postal_code'))\r\n(('state', 'state'), ('city', 'state'))\r\n(('city', 'city'), ('state', 'city'))\r\n(('street2', 'street2'), ('postal_code', 'street2'))\r\n(('street1', 'street1'), ('country', 'street1'))\r\n```",
  "created_at": "2024-07-24T12:47:18Z"
}