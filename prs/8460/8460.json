{
  "repo": "duckdb/duckdb",
  "pull_number": 8460,
  "instance_id": "duckdb__duckdb-8460",
  "issue_numbers": [
    "8459"
  ],
  "base_commit": "4c2de0a942a80879ace9a9bbc2b81f8acf1960b8",
  "patch": "diff --git a/src/common/types.cpp b/src/common/types.cpp\nindex 51cafd5e6c63..daf9eeaf3367 100644\n--- a/src/common/types.cpp\n+++ b/src/common/types.cpp\n@@ -927,7 +927,24 @@ LogicalType LogicalType::AGGREGATE_STATE(aggregate_state_t state_type) { // NOLI\n //===--------------------------------------------------------------------===//\n // Map Type\n //===--------------------------------------------------------------------===//\n-LogicalType LogicalType::MAP(const LogicalType &child) {\n+LogicalType LogicalType::MAP(const LogicalType &child_p) {\n+\tD_ASSERT(child_p.id() == LogicalTypeId::STRUCT);\n+\tauto &children = StructType::GetChildTypes(child_p);\n+\tD_ASSERT(children.size() == 2);\n+\n+\t// We do this to enforce that for every MAP created, the keys are called \"key\"\n+\t// and the values are called \"value\"\n+\n+\t// This is done because for Vector the keys of the STRUCT are used in equality checks.\n+\t// Vector::Reference will throw if the types don't match\n+\tchild_list_t<LogicalType> new_children(2);\n+\tnew_children[0] = children[0];\n+\tnew_children[0].first = \"key\";\n+\n+\tnew_children[1] = children[1];\n+\tnew_children[1].first = \"value\";\n+\n+\tauto child = LogicalType::STRUCT(std::move(new_children));\n \tauto info = make_shared<ListTypeInfo>(child);\n \treturn LogicalType(LogicalTypeId::MAP, std::move(info));\n }\ndiff --git a/src/common/types/value.cpp b/src/common/types/value.cpp\nindex 5624df80b6bb..e1ef77492f80 100644\n--- a/src/common/types/value.cpp\n+++ b/src/common/types/value.cpp\n@@ -663,6 +663,20 @@ Value Value::MAP(const LogicalType &child_type, vector<Value> values) {\n \n \tresult.type_ = LogicalType::MAP(child_type);\n \tresult.is_null = false;\n+\tfor (auto &val : values) {\n+\t\tD_ASSERT(val.type().InternalType() == PhysicalType::STRUCT);\n+\t\tauto &children = StructValue::GetChildren(val);\n+\n+\t\t// Ensure that the field containing the keys is called 'key'\n+\t\t// and that the field containing the values is called 'value'\n+\t\t// this is required to make equality checks work\n+\t\tD_ASSERT(children.size() == 2);\n+\t\tchild_list_t<Value> new_children;\n+\t\tnew_children.reserve(2);\n+\t\tnew_children.push_back(std::make_pair(\"key\", children[0]));\n+\t\tnew_children.push_back(std::make_pair(\"value\", children[1]));\n+\t\tval = Value::STRUCT(std::move(new_children));\n+\t}\n \tresult.value_info_ = make_shared<NestedValueInfo>(std::move(values));\n \treturn result;\n }\ndiff --git a/src/common/types/vector.cpp b/src/common/types/vector.cpp\nindex 8371820c371b..eb687f468c75 100644\n--- a/src/common/types/vector.cpp\n+++ b/src/common/types/vector.cpp\n@@ -1286,6 +1286,11 @@ void Vector::UTFVerify(idx_t count) {\n void Vector::VerifyMap(Vector &vector_p, const SelectionVector &sel_p, idx_t count) {\n #ifdef DEBUG\n \tD_ASSERT(vector_p.GetType().id() == LogicalTypeId::MAP);\n+\tauto &child = ListType::GetChildType(vector_p.GetType());\n+\tD_ASSERT(StructType::GetChildCount(child) == 2);\n+\tD_ASSERT(StructType::GetChildName(child, 0) == \"key\");\n+\tD_ASSERT(StructType::GetChildName(child, 1) == \"value\");\n+\n \tauto valid_check = MapVector::CheckMapValidity(vector_p, count, sel_p);\n \tD_ASSERT(valid_check == MapInvalidReason::VALID);\n #endif // DEBUG\n@@ -1410,9 +1415,6 @@ void Vector::Verify(Vector &vector_p, const SelectionVector &sel_p, idx_t count)\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif (vector->GetType().id() == LogicalTypeId::MAP) {\n-\t\t\tVerifyMap(*vector, *sel, count);\n-\t\t}\n \n \t\tif (vector->GetType().id() == LogicalTypeId::UNION) {\n \t\t\tVerifyUnion(*vector, *sel, count);\n@@ -1460,6 +1462,10 @@ void Vector::Verify(Vector &vector_p, const SelectionVector &sel_p, idx_t count)\n \t\t\t}\n \t\t\tVector::Verify(child, child_sel, child_count);\n \t\t}\n+\n+\t\tif (vector->GetType().id() == LogicalTypeId::MAP) {\n+\t\t\tVerifyMap(*vector, *sel, count);\n+\t\t}\n \t}\n #endif\n }\ndiff --git a/src/core_functions/aggregate/nested/histogram.cpp b/src/core_functions/aggregate/nested/histogram.cpp\nindex fa61fd7608a5..b50c535e29e1 100644\n--- a/src/core_functions/aggregate/nested/histogram.cpp\n+++ b/src/core_functions/aggregate/nested/histogram.cpp\n@@ -142,6 +142,7 @@ static void HistogramFinalizeFunction(Vector &state_vector, AggregateInputData &\n \t\tlist_struct_data[rid].offset = old_len;\n \t\told_len += list_struct_data[rid].length;\n \t}\n+\tresult.Verify(count);\n }\n \n unique_ptr<FunctionData> HistogramBindFunction(ClientContext &context, AggregateFunction &function,\ndiff --git a/src/core_functions/scalar/map/map_entries.cpp b/src/core_functions/scalar/map/map_entries.cpp\nindex b4829d391750..caaeccee2bba 100644\n--- a/src/core_functions/scalar/map/map_entries.cpp\n+++ b/src/core_functions/scalar/map/map_entries.cpp\n@@ -42,8 +42,8 @@ static unique_ptr<FunctionData> MapEntriesBind(ClientContext &context, ScalarFun\n \tauto &key_type = MapType::KeyType(map);\n \tauto &value_type = MapType::ValueType(map);\n \n-\tchild_types.push_back(make_pair(\"k\", key_type));\n-\tchild_types.push_back(make_pair(\"v\", value_type));\n+\tchild_types.push_back(make_pair(\"key\", key_type));\n+\tchild_types.push_back(make_pair(\"value\", value_type));\n \n \tauto row_type = LogicalType::STRUCT(child_types);\n \ndiff --git a/src/execution/operator/projection/physical_unnest.cpp b/src/execution/operator/projection/physical_unnest.cpp\nindex cdd5988e4c9c..d5632f80e36f 100644\n--- a/src/execution/operator/projection/physical_unnest.cpp\n+++ b/src/execution/operator/projection/physical_unnest.cpp\n@@ -308,40 +308,37 @@ OperatorResultType PhysicalUnnest::ExecuteInternal(ExecutionContext &context, Da\n \t\t\t\t// UNNEST(NULL)\n \t\t\t\tchunk.SetCardinality(0);\n \t\t\t\tbreak;\n+\t\t\t}\n \n-\t\t\t} else {\n-\n-\t\t\t\tauto &vector_data = state.list_vector_data[col_idx];\n-\t\t\t\tauto current_idx = vector_data.sel->get_index(state.current_row);\n-\n-\t\t\t\tif (!vector_data.validity.RowIsValid(current_idx)) {\n-\t\t\t\t\tUnnestNull(0, this_chunk_len, result_vector);\n+\t\t\tauto &vector_data = state.list_vector_data[col_idx];\n+\t\t\tauto current_idx = vector_data.sel->get_index(state.current_row);\n \n-\t\t\t\t} else {\n+\t\t\tif (!vector_data.validity.RowIsValid(current_idx)) {\n+\t\t\t\tUnnestNull(0, this_chunk_len, result_vector);\n+\t\t\t\tcontinue;\n+\t\t\t}\n \n-\t\t\t\t\tauto list_data = UnifiedVectorFormat::GetData<list_entry_t>(vector_data);\n-\t\t\t\t\tauto list_entry = list_data[current_idx];\n+\t\t\tauto list_data = UnifiedVectorFormat::GetData<list_entry_t>(vector_data);\n+\t\t\tauto list_entry = list_data[current_idx];\n \n-\t\t\t\t\tidx_t list_count = 0;\n-\t\t\t\t\tif (state.list_position < list_entry.length) {\n-\t\t\t\t\t\t// there are still list_count elements to unnest\n-\t\t\t\t\t\tlist_count = MinValue<idx_t>(this_chunk_len, list_entry.length - state.list_position);\n+\t\t\tidx_t list_count = 0;\n+\t\t\tif (state.list_position < list_entry.length) {\n+\t\t\t\t// there are still list_count elements to unnest\n+\t\t\t\tlist_count = MinValue<idx_t>(this_chunk_len, list_entry.length - state.list_position);\n \n-\t\t\t\t\t\tauto &list_vector = state.list_data.data[col_idx];\n-\t\t\t\t\t\tauto &child_vector = ListVector::GetEntry(list_vector);\n-\t\t\t\t\t\tauto list_size = ListVector::GetListSize(list_vector);\n-\t\t\t\t\t\tauto &child_vector_data = state.list_child_data[col_idx];\n+\t\t\t\tauto &list_vector = state.list_data.data[col_idx];\n+\t\t\t\tauto &child_vector = ListVector::GetEntry(list_vector);\n+\t\t\t\tauto list_size = ListVector::GetListSize(list_vector);\n+\t\t\t\tauto &child_vector_data = state.list_child_data[col_idx];\n \n-\t\t\t\t\t\tauto base_offset = list_entry.offset + state.list_position;\n-\t\t\t\t\t\tUnnestVector(child_vector_data, child_vector, list_size, base_offset, base_offset + list_count,\n-\t\t\t\t\t\t             result_vector);\n-\t\t\t\t\t}\n+\t\t\t\tauto base_offset = list_entry.offset + state.list_position;\n+\t\t\t\tUnnestVector(child_vector_data, child_vector, list_size, base_offset, base_offset + list_count,\n+\t\t\t\t             result_vector);\n+\t\t\t}\n \n-\t\t\t\t\t// fill the rest with NULLs\n-\t\t\t\t\tif (list_count != this_chunk_len) {\n-\t\t\t\t\t\tUnnestNull(list_count, this_chunk_len, result_vector);\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t// fill the rest with NULLs\n+\t\t\tif (list_count != this_chunk_len) {\n+\t\t\t\tUnnestNull(list_count, this_chunk_len, result_vector);\n \t\t\t}\n \t\t}\n \n",
  "test_patch": "diff --git a/test/sql/types/nested/map/test_map_entries.test b/test/sql/types/nested/map/test_map_entries.test\nindex 6a14912c2735..dc6afe8e4bcc 100644\n--- a/test/sql/types/nested/map/test_map_entries.test\n+++ b/test/sql/types/nested/map/test_map_entries.test\n@@ -15,7 +15,7 @@ select map_entries(MAP())\n query I\n SELECT map_entries(map_from_entries([('a', 5)]));\n ----\n-[{'k': a, 'v': 5}]\n+[{'key': a, 'value': 5}]\n \n # Multiple elements\n query I\n@@ -23,13 +23,13 @@ SELECT map_entries(map_from_entries([\n \t('a', 5), ('b', 6), ('x', 21), ('abc', 0)\n ]));\n ----\n-[{'k': a, 'v': 5}, {'k': b, 'v': 6}, {'k': x, 'v': 21}, {'k': abc, 'v': 0}]\n+[{'key': a, 'value': 5}, {'key': b, 'value': 6}, {'key': x, 'value': 21}, {'key': abc, 'value': 0}]\n \n # Value NULL\n query I\n SELECT map_entries(map([5], [NULL]))\n ----\n-[{'k': 5, 'v': NULL}]\n+[{'key': 5, 'value': NULL}]\n \n # Mixed NULLs\n query I\n@@ -42,7 +42,7 @@ SELECT map_entries(map_from_entries(\n \t]\n ));\n ----\n-[{'k': a, 'v': 5}, {'k': b, 'v': 6}, {'k': x, 'v': 21}, {'k': abc, 'v': 0}]\n+[{'key': a, 'value': 5}, {'key': b, 'value': 6}, {'key': x, 'value': 21}, {'key': abc, 'value': 0}]\n \n # Empty\n query I\n@@ -54,7 +54,7 @@ select map_entries(MAP())\n query I\n SELECT map_entries(map_from_entries([('a', 5)]));\n ----\n-[{'k': a, 'v': 5}]\n+[{'key': a, 'value': 5}]\n \n # Multiple elements\n query I\n@@ -62,13 +62,13 @@ SELECT map_entries(map_from_entries([\n \t('a', 5), ('b', 6), ('x', 21), ('abc', 0)\n ]));\n ----\n-[{'k': a, 'v': 5}, {'k': b, 'v': 6}, {'k': x, 'v': 21}, {'k': abc, 'v': 0}]\n+[{'key': a, 'value': 5}, {'key': b, 'value': 6}, {'key': x, 'value': 21}, {'key': abc, 'value': 0}]\n \n # Value NULL\n query I\n SELECT map_entries(map([5], [NULL]))\n ----\n-[{'k': 5, 'v': NULL}]\n+[{'key': 5, 'value': NULL}]\n \n # Mixed NULLs\n query I\n@@ -81,4 +81,4 @@ SELECT map_entries(map_from_entries(\n \t]\n ));\n ----\n-[{'k': a, 'v': 5}, {'k': b, 'v': 6}, {'k': x, 'v': 21}, {'k': abc, 'v': 0}]\n\\ No newline at end of file\n+[{'key': a, 'value': 5}, {'key': b, 'value': 6}, {'key': x, 'value': 21}, {'key': abc, 'value': 0}]\n\\ No newline at end of file\ndiff --git a/test/sql/types/struct/struct_equality_bug.test b/test/sql/types/struct/struct_equality_bug.test\nnew file mode 100644\nindex 000000000000..b8b110680130\n--- /dev/null\n+++ b/test/sql/types/struct/struct_equality_bug.test\n@@ -0,0 +1,21 @@\n+# name: test/sql/types/struct/struct_equality_bug.test\n+# description: Test struct equality bug\n+# group: [struct]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+create table integers(i integer);\n+\n+statement ok\n+INSERT INTO integers VALUES (1),(1),(3),(20),(20),(20);\n+\n+# This is where the bug manifested, map_entries created 'k' and 'v' child names.\n+# map keys should always be named \"key\" and values \"value\"\n+query I\n+select unnest(map_entries(histogram(i))) FROM integers;\n+----\n+{'key': 1, 'value': 2}\n+{'key': 3, 'value': 1}\n+{'key': 20, 'value': 3}\n",
  "problem_statement": "[Unnest] Internal Exception triggered by simple query involving a MAP\n### What happens?\n\nBelow query causes the following exception:\r\n```\r\nError: INTERNAL Error: Assertion triggered in file \"/root/Source/cpp/duckdb/src/execution/operator/projection/physical_unnest.cpp\" on line 136: child_vector.GetType() == result.GetType()\r\n```\n\n### To Reproduce\n\n```sql\r\ncreate table integers(i integer);\r\nINSERT INTO integers VALUES (1),(1),(3),(20),(20),(20);\r\nselect unnest(map_entries(histogram(i))) FROM integers; \r\n```\n\n### OS:\n\nMacOS\n\n### DuckDB Version:\n\nmaster\n\n### DuckDB Client:\n\n-\n\n### Full Name:\n\nThijs Bruineman\n\n### Affiliation:\n\nDuckDB Labs\n\n### Have you tried this on the latest `master` branch?\n\nI have tested with a master build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2023-08-03T15:45:25Z"
}