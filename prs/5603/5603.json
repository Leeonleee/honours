{
  "repo": "duckdb/duckdb",
  "pull_number": 5603,
  "instance_id": "duckdb__duckdb-5603",
  "issue_numbers": [
    "4998"
  ],
  "base_commit": "237ada33dbbf5955e7ed1f4f8184721147ba292d",
  "patch": "diff --git a/extension/httpfs/httpfs-extension.cpp b/extension/httpfs/httpfs-extension.cpp\nindex 10eac42aaf94..0d1784cc5a98 100644\n--- a/extension/httpfs/httpfs-extension.cpp\n+++ b/extension/httpfs/httpfs-extension.cpp\n@@ -18,32 +18,37 @@ static void LoadInternal(DatabaseInstance &instance) {\n \n \t// Global HTTP config\n \t// Single timeout value is used for all 4 types of timeouts, we could split it into 4 if users need that\n-\tconfig.AddExtensionOption(\"http_timeout\", \"HTTP connection timeout (default 30000ms)\", LogicalType::UBIGINT);\n-\tconfig.AddExtensionOption(\"http_retries\", \"HTTP retries on I/O error (default 3)\", LogicalType::UBIGINT);\n-\tconfig.AddExtensionOption(\"http_retry_wait_ms\", \"Time between retries (default 100ms)\", LogicalType::UBIGINT);\n+\tconfig.AddExtensionOption(\"http_timeout\", \"HTTP timeout read/write/connection/retry (default 30000ms)\",\n+\t                          LogicalType::UBIGINT, Value(30000));\n+\tconfig.AddExtensionOption(\"http_retries\", \"HTTP retries on I/O error (default 3)\", LogicalType::UBIGINT, Value(3));\n+\tconfig.AddExtensionOption(\"http_retry_wait_ms\", \"Time between retries (default 100ms)\", LogicalType::UBIGINT,\n+\t                          Value(100));\n \t// Reduces the number of requests made while waiting, for example retry_wait_ms of 50 and backoff factor of 2 will\n \t// result in wait times of  0 50 100 200 400...etc.\n \tconfig.AddExtensionOption(\"http_retry_backoff\",\n \t                          \"Backoff factor for exponentially increasing retry wait time (default 4)\",\n-\t                          LogicalType::FLOAT);\n+\t                          LogicalType::FLOAT, Value(4));\n \n \t// Global S3 config\n \tconfig.AddExtensionOption(\"s3_region\", \"S3 Region\", LogicalType::VARCHAR);\n \tconfig.AddExtensionOption(\"s3_access_key_id\", \"S3 Access Key ID\", LogicalType::VARCHAR);\n \tconfig.AddExtensionOption(\"s3_secret_access_key\", \"S3 Access Key\", LogicalType::VARCHAR);\n \tconfig.AddExtensionOption(\"s3_session_token\", \"S3 Session Token\", LogicalType::VARCHAR);\n-\tconfig.AddExtensionOption(\"s3_endpoint\", \"S3 Endpoint (default 's3.amazonaws.com')\", LogicalType::VARCHAR);\n-\tconfig.AddExtensionOption(\"s3_url_style\", \"S3 url style ('vhost' (default) or 'path')\", LogicalType::VARCHAR);\n-\tconfig.AddExtensionOption(\"s3_use_ssl\", \"S3 use SSL (default true)\", LogicalType::BOOLEAN);\n+\tconfig.AddExtensionOption(\"s3_endpoint\", \"S3 Endpoint (default 's3.amazonaws.com')\", LogicalType::VARCHAR,\n+\t                          Value(\"s3.amazonaws.com\"));\n+\tconfig.AddExtensionOption(\"s3_url_style\", \"S3 url style ('vhost' (default) or 'path')\", LogicalType::VARCHAR,\n+\t                          Value(\"vhost\"));\n+\tconfig.AddExtensionOption(\"s3_use_ssl\", \"S3 use SSL (default true)\", LogicalType::BOOLEAN, Value(true));\n \n \t// S3 Uploader config\n \tconfig.AddExtensionOption(\"s3_uploader_max_filesize\",\n-\t                          \"S3 Uploader max filesize (between 50GB and 5TB, default 800GB)\", LogicalType::VARCHAR);\n+\t                          \"S3 Uploader max filesize (between 50GB and 5TB, default 800GB)\", LogicalType::VARCHAR,\n+\t                          \"800GB\");\n \tconfig.AddExtensionOption(\"s3_uploader_max_parts_per_file\",\n \t                          \"S3 Uploader max parts per file (between 1 and 10000, default 10000)\",\n-\t                          LogicalType::UBIGINT);\n+\t                          LogicalType::UBIGINT, Value(10000));\n \tconfig.AddExtensionOption(\"s3_uploader_thread_limit\", \"S3 Uploader global thread limit (default 50)\",\n-\t                          LogicalType::UBIGINT);\n+\t                          LogicalType::UBIGINT, Value(50));\n \n \tauto provider = make_unique<AWSEnvironmentCredentialsProvider>(config);\n \tprovider->SetAll();\ndiff --git a/extension/icu/icu-extension.cpp b/extension/icu/icu-extension.cpp\nindex 987803a05370..f1d31c666a65 100644\n--- a/extension/icu/icu-extension.cpp\n+++ b/extension/icu/icu-extension.cpp\n@@ -253,12 +253,12 @@ void ICUExtension::Load(DuckDB &db) {\n \n \t// Time Zones\n \tauto &config = DBConfig::GetConfig(*db.instance);\n-\tconfig.AddExtensionOption(\"TimeZone\", \"The current time zone\", LogicalType::VARCHAR, SetICUTimeZone);\n \tstd::unique_ptr<icu::TimeZone> tz(icu::TimeZone::createDefault());\n \ticu::UnicodeString tz_id;\n \tstd::string tz_string;\n \ttz->getID(tz_id).toUTF8String(tz_string);\n-\tconfig.options.set_variables[\"TimeZone\"] = Value(tz_string);\n+\tconfig.AddExtensionOption(\"TimeZone\", \"The current time zone\", LogicalType::VARCHAR, Value(tz_string),\n+\t                          SetICUTimeZone);\n \n \tRegisterICUDateAddFunctions(*con.context);\n \tRegisterICUDatePartFunctions(*con.context);\n@@ -269,10 +269,10 @@ void ICUExtension::Load(DuckDB &db) {\n \tRegisterICUTimeZoneFunctions(*con.context);\n \n \t// Calendars\n-\tconfig.AddExtensionOption(\"Calendar\", \"The current calendar\", LogicalType::VARCHAR, SetICUCalendar);\n \tUErrorCode status = U_ZERO_ERROR;\n \tstd::unique_ptr<icu::Calendar> cal(icu::Calendar::createInstance(status));\n-\tconfig.options.set_variables[\"Calendar\"] = Value(cal->getType());\n+\tconfig.AddExtensionOption(\"Calendar\", \"The current calendar\", LogicalType::VARCHAR, Value(cal->getType()),\n+\t                          SetICUCalendar);\n \n \tTableFunction cal_names(\"icu_calendar_names\", {}, ICUCalendarFunction, ICUCalendarBind, ICUCalendarInit);\n \tCreateTableFunctionInfo cal_names_info(move(cal_names));\ndiff --git a/src/catalog/catalog_search_path.cpp b/src/catalog/catalog_search_path.cpp\nindex cd712a582302..a5448f89c170 100644\n--- a/src/catalog/catalog_search_path.cpp\n+++ b/src/catalog/catalog_search_path.cpp\n@@ -9,6 +9,10 @@\n namespace duckdb {\n \n CatalogSearchPath::CatalogSearchPath(ClientContext &context_p) : context(context_p) {\n+\tReset();\n+}\n+\n+void CatalogSearchPath::Reset() {\n \tSetPaths(ParsePaths(\"\"));\n }\n \ndiff --git a/src/common/enums/compression_type.cpp b/src/common/enums/compression_type.cpp\nindex 4b8d858db02e..267c2253e074 100644\n--- a/src/common/enums/compression_type.cpp\n+++ b/src/common/enums/compression_type.cpp\n@@ -5,6 +5,17 @@\n namespace duckdb {\n \n // LCOV_EXCL_START\n+\n+vector<string> ListCompressionTypes(void) {\n+\tvector<string> compression_types;\n+\tuint8_t amount_of_compression_options = (uint8_t)CompressionType::COMPRESSION_COUNT;\n+\tcompression_types.reserve(amount_of_compression_options);\n+\tfor (uint8_t i = 0; i < amount_of_compression_options; i++) {\n+\t\tcompression_types.push_back(CompressionTypeToString((CompressionType)i));\n+\t}\n+\treturn compression_types;\n+}\n+\n CompressionType CompressionTypeFromString(const string &str) {\n \tauto compression = StringUtil::Lower(str);\n \tif (compression == \"uncompressed\") {\ndiff --git a/src/common/enums/logical_operator_type.cpp b/src/common/enums/logical_operator_type.cpp\nindex eb02790885b8..43127e1a4ff3 100644\n--- a/src/common/enums/logical_operator_type.cpp\n+++ b/src/common/enums/logical_operator_type.cpp\n@@ -106,6 +106,8 @@ string LogicalOperatorToString(LogicalOperatorType type) {\n \t\treturn \"EXPORT\";\n \tcase LogicalOperatorType::LOGICAL_SET:\n \t\treturn \"SET\";\n+\tcase LogicalOperatorType::LOGICAL_RESET:\n+\t\treturn \"RESET\";\n \tcase LogicalOperatorType::LOGICAL_LOAD:\n \t\treturn \"LOAD\";\n \tcase LogicalOperatorType::LOGICAL_INVALID:\ndiff --git a/src/common/enums/physical_operator_type.cpp b/src/common/enums/physical_operator_type.cpp\nindex 08435925400e..e2ab77234e61 100644\n--- a/src/common/enums/physical_operator_type.cpp\n+++ b/src/common/enums/physical_operator_type.cpp\n@@ -119,6 +119,8 @@ string PhysicalOperatorToString(PhysicalOperatorType type) {\n \t\treturn \"EXPORT\";\n \tcase PhysicalOperatorType::SET:\n \t\treturn \"SET\";\n+\tcase PhysicalOperatorType::RESET:\n+\t\treturn \"RESET\";\n \tcase PhysicalOperatorType::LOAD:\n \t\treturn \"LOAD\";\n \tcase PhysicalOperatorType::INOUT_FUNCTION:\ndiff --git a/src/execution/operator/helper/CMakeLists.txt b/src/execution/operator/helper/CMakeLists.txt\nindex 38986766854d..57479ca679be 100644\n--- a/src/execution/operator/helper/CMakeLists.txt\n+++ b/src/execution/operator/helper/CMakeLists.txt\n@@ -13,6 +13,7 @@ add_library_unity(\n   physical_reservoir_sample.cpp\n   physical_result_collector.cpp\n   physical_set.cpp\n+  physical_reset.cpp\n   physical_streaming_limit.cpp\n   physical_streaming_sample.cpp\n   physical_transaction.cpp\ndiff --git a/src/execution/operator/helper/physical_reset.cpp b/src/execution/operator/helper/physical_reset.cpp\nnew file mode 100644\nindex 000000000000..e7b9fa80ddc4\n--- /dev/null\n+++ b/src/execution/operator/helper/physical_reset.cpp\n@@ -0,0 +1,76 @@\n+#include \"duckdb/execution/operator/helper/physical_reset.hpp\"\n+\n+#include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/main/database.hpp\"\n+#include \"duckdb/main/client_context.hpp\"\n+\n+namespace duckdb {\n+\n+void PhysicalReset::ResetExtensionVariable(ExecutionContext &context, DBConfig &config,\n+                                           ExtensionOption &extension_option) const {\n+\tif (extension_option.set_function) {\n+\t\textension_option.set_function(context.client, scope, extension_option.default_value);\n+\t}\n+\tif (scope == SetScope::GLOBAL) {\n+\t\tconfig.ResetOption(name);\n+\t} else {\n+\t\tauto &client_config = ClientConfig::GetConfig(context.client);\n+\t\tclient_config.set_variables[name] = extension_option.default_value;\n+\t}\n+}\n+\n+void PhysicalReset::GetData(ExecutionContext &context, DataChunk &chunk, GlobalSourceState &gstate,\n+                            LocalSourceState &lstate) const {\n+\tauto option = DBConfig::GetOptionByName(name);\n+\tif (!option) {\n+\t\t// check if this is an extra extension variable\n+\t\tauto &config = DBConfig::GetConfig(context.client);\n+\t\tauto entry = config.extension_parameters.find(name);\n+\t\tif (entry == config.extension_parameters.end()) {\n+\t\t\t// it is not!\n+\t\t\t// get a list of all options\n+\t\t\tvector<string> potential_names = DBConfig::GetOptionNames();\n+\t\t\tfor (auto &entry : config.extension_parameters) {\n+\t\t\t\tpotential_names.push_back(entry.first);\n+\t\t\t}\n+\n+\t\t\tthrow CatalogException(\"unrecognized configuration parameter \\\"%s\\\"\\n%s\", name,\n+\t\t\t                       StringUtil::CandidatesErrorMessage(potential_names, name, \"Did you mean\"));\n+\t\t}\n+\t\tResetExtensionVariable(context, config, entry->second);\n+\t\treturn;\n+\t}\n+\n+\t// Transform scope\n+\tSetScope variable_scope = scope;\n+\tif (variable_scope == SetScope::AUTOMATIC) {\n+\t\tif (option->set_local) {\n+\t\t\tvariable_scope = SetScope::SESSION;\n+\t\t} else {\n+\t\t\tD_ASSERT(option->set_global);\n+\t\t\tvariable_scope = SetScope::GLOBAL;\n+\t\t}\n+\t}\n+\n+\tswitch (variable_scope) {\n+\tcase SetScope::GLOBAL: {\n+\t\tif (!option->set_global) {\n+\t\t\tthrow CatalogException(\"option \\\"%s\\\" cannot be reset globally\", name);\n+\t\t}\n+\t\tauto &db = DatabaseInstance::GetDatabase(context.client);\n+\t\tauto &config = DBConfig::GetConfig(context.client);\n+\t\tconfig.ResetOption(&db, *option);\n+\t\tbreak;\n+\t}\n+\tcase SetScope::SESSION:\n+\t\tif (!option->reset_local) {\n+\t\t\tthrow CatalogException(\"option \\\"%s\\\" cannot be reset locally\", name);\n+\t\t}\n+\t\toption->reset_local(context.client);\n+\t\tbreak;\n+\tdefault:\n+\t\tthrow InternalException(\"Unsupported SetScope for variable\");\n+\t}\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/execution/operator/helper/physical_set.cpp b/src/execution/operator/helper/physical_set.cpp\nindex 82693167c11e..31b8d85b5bef 100644\n--- a/src/execution/operator/helper/physical_set.cpp\n+++ b/src/execution/operator/helper/physical_set.cpp\n@@ -6,6 +6,21 @@\n \n namespace duckdb {\n \n+void PhysicalSet::SetExtensionVariable(ExecutionContext &context, DBConfig &config,\n+                                       ExtensionOption &extension_option) const {\n+\tauto &target_type = extension_option.type;\n+\tValue target_value = value.CastAs(context.client, target_type);\n+\tif (extension_option.set_function) {\n+\t\textension_option.set_function(context.client, scope, target_value);\n+\t}\n+\tif (scope == SetScope::GLOBAL) {\n+\t\tconfig.SetOption(name, move(target_value));\n+\t} else {\n+\t\tauto &client_config = ClientConfig::GetConfig(context.client);\n+\t\tclient_config.set_variables[name] = move(target_value);\n+\t}\n+}\n+\n void PhysicalSet::GetData(ExecutionContext &context, DataChunk &chunk, GlobalSourceState &gstate,\n                           LocalSourceState &lstate) const {\n \tauto option = DBConfig::GetOptionByName(name);\n@@ -24,19 +39,7 @@ void PhysicalSet::GetData(ExecutionContext &context, DataChunk &chunk, GlobalSou\n \t\t\tthrow CatalogException(\"unrecognized configuration parameter \\\"%s\\\"\\n%s\", name,\n \t\t\t                       StringUtil::CandidatesErrorMessage(potential_names, name, \"Did you mean\"));\n \t\t}\n-\t\t//! it is!\n-\t\tauto &extension_option = entry->second;\n-\t\tauto &target_type = extension_option.type;\n-\t\tValue target_value = value.CastAs(context.client, target_type);\n-\t\tif (extension_option.set_function) {\n-\t\t\textension_option.set_function(context.client, scope, target_value);\n-\t\t}\n-\t\tif (scope == SetScope::GLOBAL) {\n-\t\t\tconfig.SetOption(name, move(target_value));\n-\t\t} else {\n-\t\t\tauto &client_config = ClientConfig::GetConfig(context.client);\n-\t\t\tclient_config.set_variables[name] = move(target_value);\n-\t\t}\n+\t\tSetExtensionVariable(context, config, entry->second);\n \t\treturn;\n \t}\n \tSetScope variable_scope = scope;\ndiff --git a/src/execution/physical_plan/CMakeLists.txt b/src/execution/physical_plan/CMakeLists.txt\nindex 32895589a00a..10fc8b028b50 100644\n--- a/src/execution/physical_plan/CMakeLists.txt\n+++ b/src/execution/physical_plan/CMakeLists.txt\n@@ -30,6 +30,7 @@ add_library_unity(\n   plan_projection.cpp\n   plan_set_operation.cpp\n   plan_set.cpp\n+  plan_reset.cpp\n   plan_sample.cpp\n   plan_show_select.cpp\n   plan_simple.cpp\ndiff --git a/src/execution/physical_plan/plan_reset.cpp b/src/execution/physical_plan/plan_reset.cpp\nnew file mode 100644\nindex 000000000000..172b7735cd88\n--- /dev/null\n+++ b/src/execution/physical_plan/plan_reset.cpp\n@@ -0,0 +1,11 @@\n+#include \"duckdb/execution/physical_plan_generator.hpp\"\n+#include \"duckdb/planner/operator/logical_reset.hpp\"\n+#include \"duckdb/execution/operator/helper/physical_reset.hpp\"\n+\n+namespace duckdb {\n+\n+unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalReset &op) {\n+\treturn make_unique<PhysicalReset>(op.name, op.scope, op.estimated_cardinality);\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/execution/physical_plan_generator.cpp b/src/execution/physical_plan_generator.cpp\nindex f02f88fe1d07..9dbabe8fbece 100644\n--- a/src/execution/physical_plan_generator.cpp\n+++ b/src/execution/physical_plan_generator.cpp\n@@ -194,6 +194,9 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalOperator &\n \tcase LogicalOperatorType::LOGICAL_SET:\n \t\tplan = CreatePlan((LogicalSet &)op);\n \t\tbreak;\n+\tcase LogicalOperatorType::LOGICAL_RESET:\n+\t\tplan = CreatePlan((LogicalReset &)op);\n+\t\tbreak;\n \tcase LogicalOperatorType::LOGICAL_EXTENSION_OPERATOR:\n \t\tplan = ((LogicalExtensionOperator &)op).CreatePlan(context, *this);\n \ndiff --git a/src/include/duckdb/catalog/catalog_search_path.hpp b/src/include/duckdb/catalog/catalog_search_path.hpp\nindex 23803572a88e..97dd29ef2bed 100644\n--- a/src/include/duckdb/catalog/catalog_search_path.hpp\n+++ b/src/include/duckdb/catalog/catalog_search_path.hpp\n@@ -26,6 +26,7 @@ class CatalogSearchPath {\n \n \tDUCKDB_API void Set(const string &new_value, bool is_set_schema);\n \tDUCKDB_API void Set(vector<string> &new_paths, bool is_set_schema = false);\n+\tDUCKDB_API void Reset();\n \n \tDUCKDB_API const vector<string> &Get();\n \tDUCKDB_API const vector<string> &GetSetPaths() {\ndiff --git a/src/include/duckdb/common/enums/compression_type.hpp b/src/include/duckdb/common/enums/compression_type.hpp\nindex d9fa34dae2ac..e884d52a5969 100644\n--- a/src/include/duckdb/common/enums/compression_type.hpp\n+++ b/src/include/duckdb/common/enums/compression_type.hpp\n@@ -9,6 +9,7 @@\n #pragma once\n \n #include \"duckdb/common/constants.hpp\"\n+#include \"duckdb/common/vector.hpp\"\n \n namespace duckdb {\n \n@@ -22,9 +23,11 @@ enum class CompressionType : uint8_t {\n \tCOMPRESSION_BITPACKING = 6,\n \tCOMPRESSION_FSST = 7,\n \tCOMPRESSION_CHIMP = 8,\n-\tCOMPRESSION_PATAS = 9\n+\tCOMPRESSION_PATAS = 9,\n+\tCOMPRESSION_COUNT // This has to stay the last entry of the type!\n };\n \n+vector<string> ListCompressionTypes(void);\n CompressionType CompressionTypeFromString(const string &str);\n string CompressionTypeToString(CompressionType type);\n \ndiff --git a/src/include/duckdb/common/enums/logical_operator_type.hpp b/src/include/duckdb/common/enums/logical_operator_type.hpp\nindex 5ea001d07b53..97843e3a7b1b 100644\n--- a/src/include/duckdb/common/enums/logical_operator_type.hpp\n+++ b/src/include/duckdb/common/enums/logical_operator_type.hpp\n@@ -97,6 +97,7 @@ enum class LogicalOperatorType : uint8_t {\n \tLOGICAL_VACUUM = 178,\n \tLOGICAL_SET = 179,\n \tLOGICAL_LOAD = 180,\n+\tLOGICAL_RESET = 181,\n \n \tLOGICAL_EXTENSION_OPERATOR = 255\n };\ndiff --git a/src/include/duckdb/common/enums/physical_operator_type.hpp b/src/include/duckdb/common/enums/physical_operator_type.hpp\nindex 6aeb6e9ee706..19f26df1f875 100644\n--- a/src/include/duckdb/common/enums/physical_operator_type.hpp\n+++ b/src/include/duckdb/common/enums/physical_operator_type.hpp\n@@ -98,7 +98,8 @@ enum class PhysicalOperatorType : uint8_t {\n \tSET,\n \tLOAD,\n \tINOUT_FUNCTION,\n-\tRESULT_COLLECTOR\n+\tRESULT_COLLECTOR,\n+\tRESET\n };\n \n string PhysicalOperatorToString(PhysicalOperatorType type);\ndiff --git a/src/include/duckdb/common/enums/set_type.hpp b/src/include/duckdb/common/enums/set_type.hpp\nnew file mode 100644\nindex 000000000000..0b5eedd2000f\n--- /dev/null\n+++ b/src/include/duckdb/common/enums/set_type.hpp\n@@ -0,0 +1,17 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/enums/set_type.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/common/constants.hpp\"\n+\n+namespace duckdb {\n+\n+enum class SetType : uint8_t { SET = 0, RESET = 1 };\n+\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/execution/operator/helper/physical_reset.hpp b/src/include/duckdb/execution/operator/helper/physical_reset.hpp\nnew file mode 100644\nindex 000000000000..59a133577c8c\n--- /dev/null\n+++ b/src/include/duckdb/execution/operator/helper/physical_reset.hpp\n@@ -0,0 +1,41 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/execution/operator/helper/physical_reset.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/common/enums/set_scope.hpp\"\n+#include \"duckdb/execution/physical_operator.hpp\"\n+#include \"duckdb/parser/parsed_data/vacuum_info.hpp\"\n+\n+namespace duckdb {\n+\n+struct DBConfig;\n+struct ExtensionOption;\n+\n+//! PhysicalReset represents a RESET operation (e.g. RESET a = 42)\n+class PhysicalReset : public PhysicalOperator {\n+public:\n+\tPhysicalReset(const std::string &name_p, SetScope scope_p, idx_t estimated_cardinality)\n+\t    : PhysicalOperator(PhysicalOperatorType::RESET, {LogicalType::BOOLEAN}, estimated_cardinality), name(name_p),\n+\t      scope(scope_p) {\n+\t}\n+\n+public:\n+\t// Source interface\n+\tvoid GetData(ExecutionContext &context, DataChunk &chunk, GlobalSourceState &gstate,\n+\t             LocalSourceState &lstate) const override;\n+\n+public:\n+\tconst std::string name;\n+\tconst SetScope scope;\n+\n+private:\n+\tvoid ResetExtensionVariable(ExecutionContext &context, DBConfig &config, ExtensionOption &extension_option) const;\n+};\n+\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/execution/operator/helper/physical_set.hpp b/src/include/duckdb/execution/operator/helper/physical_set.hpp\nindex 0aeb076cd13b..b3fc04349cdc 100644\n--- a/src/include/duckdb/execution/operator/helper/physical_set.hpp\n+++ b/src/include/duckdb/execution/operator/helper/physical_set.hpp\n@@ -14,6 +14,9 @@\n \n namespace duckdb {\n \n+struct DBConfig;\n+struct ExtensionOption;\n+\n //! PhysicalSet represents a SET operation (e.g. SET a = 42)\n class PhysicalSet : public PhysicalOperator {\n public:\n@@ -31,6 +34,9 @@ class PhysicalSet : public PhysicalOperator {\n \tconst std::string name;\n \tconst Value value;\n \tconst SetScope scope;\n+\n+private:\n+\tvoid SetExtensionVariable(ExecutionContext &context, DBConfig &config, ExtensionOption &extension_option) const;\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/execution/physical_plan_generator.hpp b/src/include/duckdb/execution/physical_plan_generator.hpp\nindex 70fb1acdaabb..0e0bad4ac2b2 100644\n--- a/src/include/duckdb/execution/physical_plan_generator.hpp\n+++ b/src/include/duckdb/execution/physical_plan_generator.hpp\n@@ -79,6 +79,7 @@ class PhysicalPlanGenerator {\n \tunique_ptr<PhysicalOperator> CreatePlan(LogicalPragma &op);\n \tunique_ptr<PhysicalOperator> CreatePlan(LogicalSample &op);\n \tunique_ptr<PhysicalOperator> CreatePlan(LogicalSet &op);\n+\tunique_ptr<PhysicalOperator> CreatePlan(LogicalReset &op);\n \tunique_ptr<PhysicalOperator> CreatePlan(LogicalShow &op);\n \tunique_ptr<PhysicalOperator> CreatePlan(LogicalSimple &op);\n \tunique_ptr<PhysicalOperator> CreatePlan(LogicalUnnest &op);\ndiff --git a/src/include/duckdb/main/config.hpp b/src/include/duckdb/main/config.hpp\nindex 599e4f4693fe..9060c8f3cc54 100644\n--- a/src/include/duckdb/main/config.hpp\n+++ b/src/include/duckdb/main/config.hpp\n@@ -50,6 +50,8 @@ enum class CheckpointAbort : uint8_t {\n \n typedef void (*set_global_function_t)(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n typedef void (*set_local_function_t)(ClientContext &context, const Value &parameter);\n+typedef void (*reset_global_function_t)(DatabaseInstance *db, DBConfig &config);\n+typedef void (*reset_local_function_t)(ClientContext &context);\n typedef Value (*get_setting_function_t)(ClientContext &context);\n \n struct ConfigurationOption {\n@@ -58,19 +60,24 @@ struct ConfigurationOption {\n \tLogicalTypeId parameter_type;\n \tset_global_function_t set_global;\n \tset_local_function_t set_local;\n+\treset_global_function_t reset_global;\n+\treset_local_function_t reset_local;\n \tget_setting_function_t get_setting;\n };\n \n typedef void (*set_option_callback_t)(ClientContext &context, SetScope scope, Value &parameter);\n \n struct ExtensionOption {\n-\tExtensionOption(string description_p, LogicalType type_p, set_option_callback_t set_function_p)\n-\t    : description(move(description_p)), type(move(type_p)), set_function(set_function_p) {\n+\tExtensionOption(string description_p, LogicalType type_p, set_option_callback_t set_function_p,\n+\t                Value default_value_p)\n+\t    : description(move(description_p)), type(move(type_p)), set_function(set_function_p),\n+\t      default_value(move(default_value_p)) {\n \t}\n \n \tstring description;\n \tLogicalType type;\n \tset_option_callback_t set_function;\n+\tValue default_value;\n };\n \n struct DBConfigOptions {\n@@ -127,6 +134,8 @@ struct DBConfigOptions {\n \tbool preserve_insertion_order = true;\n \t//! Database configuration variables as controlled by SET\n \tcase_insensitive_map_t<Value> set_variables;\n+\t//! Database configuration variable default values;\n+\tcase_insensitive_map_t<Value> set_variable_defaults;\n \t//! Whether unsigned extensions should be loaded\n \tbool allow_unsigned_extensions = false;\n \t//! Enable emitting FSST Vectors\n@@ -182,8 +191,8 @@ struct DBConfig {\n \tDUCKDB_API static idx_t GetOptionCount();\n \tDUCKDB_API static vector<string> GetOptionNames();\n \n-\tDUCKDB_API void AddExtensionOption(string name, string description, LogicalType parameter,\n-\t                                   set_option_callback_t function = nullptr);\n+\tDUCKDB_API void AddExtensionOption(const string &name, string description, LogicalType parameter,\n+\t                                   const Value &default_value = Value(), set_option_callback_t function = nullptr);\n \t//! Fetch an option by index. Returns a pointer to the option, or nullptr if out of range\n \tDUCKDB_API static ConfigurationOption *GetOptionByIndex(idx_t index);\n \t//! Fetch an option by name. Returns a pointer to the option, or nullptr if none exists.\n@@ -191,7 +200,9 @@ struct DBConfig {\n \n \tDUCKDB_API void SetOption(const ConfigurationOption &option, const Value &value);\n \tDUCKDB_API void SetOption(DatabaseInstance *db, const ConfigurationOption &option, const Value &value);\n+\tDUCKDB_API void ResetOption(DatabaseInstance *db, const ConfigurationOption &option);\n \tDUCKDB_API void SetOption(const string &name, Value value);\n+\tDUCKDB_API void ResetOption(const string &name);\n \n \tDUCKDB_API static idx_t ParseMemoryLimit(const string &arg);\n \n@@ -204,6 +215,8 @@ struct DBConfig {\n \tbool operator!=(const DBConfig &other);\n \n \tDUCKDB_API CastFunctionSet &GetCastFunctions();\n+\tvoid SetDefaultMaxThreads();\n+\tvoid SetDefaultMaxMemory();\n \n private:\n \tunique_ptr<CompressionFunctionSet> compression_functions;\ndiff --git a/src/include/duckdb/main/query_profiler.hpp b/src/include/duckdb/main/query_profiler.hpp\nindex b4c5fb9b63f3..6ee18e79a8e1 100644\n--- a/src/include/duckdb/main/query_profiler.hpp\n+++ b/src/include/duckdb/main/query_profiler.hpp\n@@ -232,10 +232,12 @@ class QueryProfiler {\n //! The QueryProfilerHistory can be used to access the profiler of previous queries\n class QueryProfilerHistory {\n private:\n+\tstatic constexpr uint64_t DEFAULT_SIZE = 20;\n+\n \t//! Previous Query profilers\n \tdeque<pair<transaction_t, shared_ptr<QueryProfiler>>> prev_profilers;\n \t//! Previous Query profilers size\n-\tuint64_t prev_profilers_size = 20;\n+\tuint64_t prev_profilers_size = DEFAULT_SIZE;\n \n public:\n \tdeque<pair<transaction_t, shared_ptr<QueryProfiler>>> &GetPrevProfilers() {\n@@ -255,5 +257,8 @@ class QueryProfilerHistory {\n \tvoid SetProfilerHistorySize(uint64_t size) {\n \t\tthis->prev_profilers_size = size;\n \t}\n+\tvoid ResetProfilerHistorySize() {\n+\t\tthis->prev_profilers_size = DEFAULT_SIZE;\n+\t}\n };\n } // namespace duckdb\ndiff --git a/src/include/duckdb/main/settings.hpp b/src/include/duckdb/main/settings.hpp\nindex 1e031f147ec1..7102197a38f1 100644\n--- a/src/include/duckdb/main/settings.hpp\n+++ b/src/include/duckdb/main/settings.hpp\n@@ -21,6 +21,7 @@ struct AccessModeSetting {\n \tstatic constexpr const char *Description = \"Access mode of the database (AUTOMATIC, READ_ONLY or READ_WRITE)\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -30,6 +31,7 @@ struct CheckpointThresholdSetting {\n \t    \"The WAL size threshold at which to automatically trigger a checkpoint (e.g. 1GB)\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -39,6 +41,7 @@ struct DebugCheckpointAbort {\n \t    \"DEBUG SETTING: trigger an abort while checkpointing for testing purposes\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -48,6 +51,7 @@ struct DebugForceExternal {\n \t    \"DEBUG SETTING: force out-of-core computation for operators that support it, used for testing\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;\n \tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic void ResetLocal(ClientContext &context);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -57,6 +61,7 @@ struct DebugForceNoCrossProduct {\n \t    \"DEBUG SETTING: Force disable cross product generation when hyper graph isn't connected, used for testing\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;\n \tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic void ResetLocal(ClientContext &context);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -65,6 +70,7 @@ struct DebugWindowMode {\n \tstatic constexpr const char *Description = \"DEBUG SETTING: switch window mode to use\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -73,7 +79,9 @@ struct DefaultCollationSetting {\n \tstatic constexpr const char *Description = \"The collation setting used when none is specified\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic void ResetLocal(ClientContext &context);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -82,6 +90,7 @@ struct DefaultOrderSetting {\n \tstatic constexpr const char *Description = \"The order type used when none is specified (ASC or DESC)\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -90,6 +99,7 @@ struct DefaultNullOrderSetting {\n \tstatic constexpr const char *Description = \"Null ordering used when none is specified (NULLS_FIRST or NULLS_LAST)\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -98,6 +108,7 @@ struct DisabledOptimizersSetting {\n \tstatic constexpr const char *Description = \"DEBUG SETTING: disable a specific set of optimizers (comma separated)\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -108,6 +119,7 @@ struct EnableExternalAccessSetting {\n \t    \"readers, pandas replacement scans, etc)\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -117,6 +129,7 @@ struct EnableFSSTVectors {\n \t    \"Allow scans on FSST compressed segments to emit compressed vectors to utilize late decompression\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -125,6 +138,7 @@ struct AllowUnsignedExtensionsSetting {\n \tstatic constexpr const char *Description = \"Allow to load extensions with invalid or missing signatures\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -133,6 +147,7 @@ struct EnableObjectCacheSetting {\n \tstatic constexpr const char *Description = \"Whether or not object cache is used to cache e.g. Parquet metadata\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -140,6 +155,7 @@ struct EnableHTTPMetadataCacheSetting {\n \tstatic constexpr const char *Name = \"enable_http_metadata_cache\";\n \tstatic constexpr const char *Description = \"Whether or not the global http metadata is used to cache HTTP metadata\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n \tstatic Value GetSetting(ClientContext &context);\n };\n@@ -150,6 +166,7 @@ struct EnableProfilingSetting {\n \t    \"Enables profiling, and sets the output format (JSON, QUERY_TREE, QUERY_TREE_OPTIMIZER)\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic void ResetLocal(ClientContext &context);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -159,6 +176,7 @@ struct EnableProgressBarSetting {\n \t    \"Enables the progress bar, printing progress to the terminal for long queries\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;\n \tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic void ResetLocal(ClientContext &context);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -167,6 +185,7 @@ struct ExperimentalParallelCSVSetting {\n \tstatic constexpr const char *Description = \"Whether or not to use the experimental parallel CSV reader\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -175,6 +194,7 @@ struct ExplainOutputSetting {\n \tstatic constexpr const char *Description = \"Output of EXPLAIN statements (ALL, OPTIMIZED_ONLY, PHYSICAL_ONLY)\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic void ResetLocal(ClientContext &context);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -183,6 +203,7 @@ struct ExternalThreadsSetting {\n \tstatic constexpr const char *Description = \"The number of external threads that work on DuckDB tasks.\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -191,6 +212,7 @@ struct FileSearchPathSetting {\n \tstatic constexpr const char *Description = \"A comma separated list of directories to search for input files\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic void ResetLocal(ClientContext &context);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -199,6 +221,7 @@ struct ForceCompressionSetting {\n \tstatic constexpr const char *Description = \"DEBUG SETTING: forces a specific compression method to be used\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -207,6 +230,7 @@ struct ForceBitpackingModeSetting {\n \tstatic constexpr const char *Description = \"DEBUG SETTING: forces a specific bitpacking mode\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -215,6 +239,7 @@ struct HomeDirectorySetting {\n \tstatic constexpr const char *Description = \"Sets the home directory used by the system\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic void ResetLocal(ClientContext &context);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -224,6 +249,7 @@ struct LogQueryPathSetting {\n \t    \"Specifies the path to which queries should be logged (default: empty string, queries are not logged)\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic void ResetLocal(ClientContext &context);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -234,6 +260,7 @@ struct MaximumExpressionDepthSetting {\n \t    \"expressions might lead to stack overflow errors.\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::UBIGINT;\n \tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic void ResetLocal(ClientContext &context);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -242,6 +269,7 @@ struct MaximumMemorySetting {\n \tstatic constexpr const char *Description = \"The maximum memory of the system (e.g. 1GB)\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -250,6 +278,7 @@ struct PasswordSetting {\n \tstatic constexpr const char *Description = \"The password to use. Ignored for legacy compatibility.\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -258,6 +287,7 @@ struct PerfectHashThresholdSetting {\n \tstatic constexpr const char *Description = \"Threshold in bytes for when to use a perfect hash table (default: 12)\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;\n \tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic void ResetLocal(ClientContext &context);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -267,6 +297,7 @@ struct PreserveIdentifierCase {\n \t    \"Whether or not to preserve the identifier case, instead of always lowercasing all non-quoted identifiers\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;\n \tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic void ResetLocal(ClientContext &context);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -277,6 +308,7 @@ struct PreserveInsertionOrder {\n \t    \"that do not contain ORDER BY clauses.\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -285,6 +317,7 @@ struct ProfilerHistorySize {\n \tstatic constexpr const char *Description = \"Sets the profiler history size\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;\n \tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic void ResetLocal(ClientContext &context);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -294,6 +327,7 @@ struct ProfileOutputSetting {\n \t    \"The file to which profile output should be saved, or empty to print to the terminal\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic void ResetLocal(ClientContext &context);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -302,6 +336,7 @@ struct ProfilingModeSetting {\n \tstatic constexpr const char *Description = \"The profiling mode (STANDARD or DETAILED)\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic void ResetLocal(ClientContext &context);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -311,6 +346,7 @@ struct ProgressBarTimeSetting {\n \t    \"Sets the time (in milliseconds) how long a query needs to take before we start printing a progress bar\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;\n \tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic void ResetLocal(ClientContext &context);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -320,6 +356,7 @@ struct SchemaSetting {\n \t    \"Sets the default search schema. Equivalent to setting search_path to a single value.\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic void ResetLocal(ClientContext &context);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -329,6 +366,7 @@ struct SearchPathSetting {\n \t    \"Sets the default search search path as a comma-separated list of values\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetLocal(ClientContext &context, const Value &parameter);\n+\tstatic void ResetLocal(ClientContext &context);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -337,6 +375,7 @@ struct TempDirectorySetting {\n \tstatic constexpr const char *Description = \"Set the directory to which to write temp files\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -345,6 +384,7 @@ struct ThreadsSetting {\n \tstatic constexpr const char *Description = \"The number of total threads used by the system.\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n@@ -353,6 +393,7 @@ struct UsernameSetting {\n \tstatic constexpr const char *Description = \"The username to use. Ignored for legacy compatibility.\";\n \tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;\n \tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n+\tstatic void ResetGlobal(DatabaseInstance *db, DBConfig &config);\n \tstatic Value GetSetting(ClientContext &context);\n };\n \ndiff --git a/src/include/duckdb/parser/statement/set_statement.hpp b/src/include/duckdb/parser/statement/set_statement.hpp\nindex 423f35e67014..5b0c4f1bb637 100644\n--- a/src/include/duckdb/parser/statement/set_statement.hpp\n+++ b/src/include/duckdb/parser/statement/set_statement.hpp\n@@ -9,23 +9,46 @@\n #pragma once\n \n #include \"duckdb/common/enums/set_scope.hpp\"\n+#include \"duckdb/common/enums/set_type.hpp\"\n #include \"duckdb/parser/sql_statement.hpp\"\n #include \"duckdb/common/types/value.hpp\"\n \n namespace duckdb {\n \n class SetStatement : public SQLStatement {\n-public:\n-\tSetStatement(std::string name_p, Value value_p, SetScope scope_p);\n-\n protected:\n+\tSetStatement(std::string name_p, SetScope scope_p, SetType type_p);\n \tSetStatement(const SetStatement &other) = default;\n \n public:\n \tunique_ptr<SQLStatement> Copy() const override;\n \n+public:\n \tstd::string name;\n-\tValue value;\n \tSetScope scope;\n+\tSetType set_type;\n };\n+\n+class SetVariableStatement : public SetStatement {\n+public:\n+\tSetVariableStatement(std::string name_p, Value value_p, SetScope scope_p);\n+\n+protected:\n+\tSetVariableStatement(const SetVariableStatement &other) = default;\n+\n+public:\n+\tunique_ptr<SQLStatement> Copy() const override;\n+\n+public:\n+\tValue value;\n+};\n+\n+class ResetVariableStatement : public SetStatement {\n+public:\n+\tResetVariableStatement(std::string name_p, SetScope scope_p);\n+\n+protected:\n+\tResetVariableStatement(const ResetVariableStatement &other) = default;\n+};\n+\n } // namespace duckdb\ndiff --git a/src/include/duckdb/parser/tokens.hpp b/src/include/duckdb/parser/tokens.hpp\nindex bca1fcda878b..7ca192e54334 100644\n--- a/src/include/duckdb/parser/tokens.hpp\n+++ b/src/include/duckdb/parser/tokens.hpp\n@@ -35,6 +35,8 @@ class ExportStatement;\n class VacuumStatement;\n class RelationStatement;\n class SetStatement;\n+class SetVariableStatement;\n+class ResetVariableStatement;\n class LoadStatement;\n class LogicalPlanStatement;\n \ndiff --git a/src/include/duckdb/parser/transformer.hpp b/src/include/duckdb/parser/transformer.hpp\nindex 8ef5ef3f7ec7..5a040cf947ac 100644\n--- a/src/include/duckdb/parser/transformer.hpp\n+++ b/src/include/duckdb/parser/transformer.hpp\n@@ -123,7 +123,14 @@ class Transformer {\n \tunique_ptr<ExecuteStatement> TransformExecute(duckdb_libpgquery::PGNode *node);\n \tunique_ptr<CallStatement> TransformCall(duckdb_libpgquery::PGNode *node);\n \tunique_ptr<DropStatement> TransformDeallocate(duckdb_libpgquery::PGNode *node);\n+\n+\t//===--------------------------------------------------------------------===//\n+\t// SetStatement Transform\n+\t//===--------------------------------------------------------------------===//\n \tunique_ptr<SetStatement> TransformSet(duckdb_libpgquery::PGNode *node);\n+\tunique_ptr<SetStatement> TransformSetVariable(duckdb_libpgquery::PGVariableSetStmt *stmt);\n+\tunique_ptr<SetStatement> TransformResetVariable(duckdb_libpgquery::PGVariableSetStmt *stmt);\n+\n \tunique_ptr<SQLStatement> TransformCheckpoint(duckdb_libpgquery::PGNode *node);\n \tunique_ptr<LoadStatement> TransformLoad(duckdb_libpgquery::PGNode *node);\n \ndiff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex 372a99806cf2..638169f7db49 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -223,6 +223,8 @@ class Binder : public std::enable_shared_from_this<Binder> {\n \tBoundStatement Bind(ExportStatement &stmt);\n \tBoundStatement Bind(ExtensionStatement &stmt);\n \tBoundStatement Bind(SetStatement &stmt);\n+\tBoundStatement Bind(SetVariableStatement &stmt);\n+\tBoundStatement Bind(ResetVariableStatement &stmt);\n \tBoundStatement Bind(LoadStatement &stmt);\n \tBoundStatement Bind(LogicalPlanStatement &stmt);\n \ndiff --git a/src/include/duckdb/planner/logical_tokens.hpp b/src/include/duckdb/planner/logical_tokens.hpp\nindex ce351c5449dc..63ba07e8cf09 100644\n--- a/src/include/duckdb/planner/logical_tokens.hpp\n+++ b/src/include/duckdb/planner/logical_tokens.hpp\n@@ -48,6 +48,7 @@ class LogicalSample;\n class LogicalShow;\n class LogicalSimple;\n class LogicalSet;\n+class LogicalReset;\n class LogicalTopN;\n class LogicalUnnest;\n class LogicalUpdate;\ndiff --git a/src/include/duckdb/planner/operator/list.hpp b/src/include/duckdb/planner/operator/list.hpp\nindex 04dacff94c47..69a06578563a 100644\n--- a/src/include/duckdb/planner/operator/list.hpp\n+++ b/src/include/duckdb/planner/operator/list.hpp\n@@ -31,6 +31,7 @@\n #include \"duckdb/planner/operator/logical_recursive_cte.hpp\"\n #include \"duckdb/planner/operator/logical_sample.hpp\"\n #include \"duckdb/planner/operator/logical_set.hpp\"\n+#include \"duckdb/planner/operator/logical_reset.hpp\"\n #include \"duckdb/planner/operator/logical_set_operation.hpp\"\n #include \"duckdb/planner/operator/logical_show.hpp\"\n #include \"duckdb/planner/operator/logical_simple.hpp\"\ndiff --git a/src/include/duckdb/planner/operator/logical_reset.hpp b/src/include/duckdb/planner/operator/logical_reset.hpp\nnew file mode 100644\nindex 000000000000..945f90760f0e\n--- /dev/null\n+++ b/src/include/duckdb/planner/operator/logical_reset.hpp\n@@ -0,0 +1,38 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/planner/operator/logical_reset.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/common/enums/set_scope.hpp\"\n+#include \"duckdb/parser/parsed_data/copy_info.hpp\"\n+#include \"duckdb/planner/logical_operator.hpp\"\n+#include \"duckdb/function/copy_function.hpp\"\n+\n+namespace duckdb {\n+\n+class LogicalReset : public LogicalOperator {\n+public:\n+\tLogicalReset(std::string name_p, SetScope scope_p)\n+\t    : LogicalOperator(LogicalOperatorType::LOGICAL_RESET), name(name_p), scope(scope_p) {\n+\t}\n+\n+\tstd::string name;\n+\tSetScope scope;\n+\n+public:\n+\tvoid Serialize(FieldWriter &writer) const override;\n+\tstatic unique_ptr<LogicalOperator> Deserialize(LogicalDeserializationState &state, FieldReader &reader);\n+\tidx_t EstimateCardinality(ClientContext &context) override;\n+\n+protected:\n+\tvoid ResolveTypes() override {\n+\t\ttypes.emplace_back(LogicalType::BOOLEAN);\n+\t}\n+};\n+\n+} // namespace duckdb\ndiff --git a/src/main/config.cpp b/src/main/config.cpp\nindex f33f279da8ef..faade4271b2e 100644\n--- a/src/main/config.cpp\n+++ b/src/main/config.cpp\n@@ -4,24 +4,46 @@\n #include \"duckdb/common/string_util.hpp\"\n #include \"duckdb/main/settings.hpp\"\n \n+#ifndef DUCKDB_NO_THREADS\n+#include \"duckdb/common/thread.hpp\"\n+#endif\n+\n namespace duckdb {\n \n #define DUCKDB_GLOBAL(_PARAM)                                                                                          \\\n-\t{ _PARAM::Name, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, nullptr, _PARAM::GetSetting }\n+\t{                                                                                                                  \\\n+\t\t_PARAM::Name, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, nullptr, _PARAM::ResetGlobal,         \\\n+\t\t    nullptr, _PARAM::GetSetting                                                                                \\\n+\t}\n #define DUCKDB_GLOBAL_ALIAS(_ALIAS, _PARAM)                                                                            \\\n-\t{ _ALIAS, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, nullptr, _PARAM::GetSetting }\n+\t{                                                                                                                  \\\n+\t\t_ALIAS, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, nullptr, _PARAM::ResetGlobal, nullptr,      \\\n+\t\t    _PARAM::GetSetting                                                                                         \\\n+\t}\n \n #define DUCKDB_LOCAL(_PARAM)                                                                                           \\\n-\t{ _PARAM::Name, _PARAM::Description, _PARAM::InputType, nullptr, _PARAM::SetLocal, _PARAM::GetSetting }\n+\t{                                                                                                                  \\\n+\t\t_PARAM::Name, _PARAM::Description, _PARAM::InputType, nullptr, _PARAM::SetLocal, nullptr, _PARAM::ResetLocal,  \\\n+\t\t    _PARAM::GetSetting                                                                                         \\\n+\t}\n #define DUCKDB_LOCAL_ALIAS(_ALIAS, _PARAM)                                                                             \\\n-\t{ _ALIAS, _PARAM::Description, _PARAM::InputType, nullptr, _PARAM::SetLocal, _PARAM::GetSetting }\n+\t{                                                                                                                  \\\n+\t\t_ALIAS, _PARAM::Description, _PARAM::InputType, nullptr, _PARAM::SetLocal, nullptr, _PARAM::ResetLocal,        \\\n+\t\t    _PARAM::GetSetting                                                                                         \\\n+\t}\n \n #define DUCKDB_GLOBAL_LOCAL(_PARAM)                                                                                    \\\n-\t{ _PARAM::Name, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, _PARAM::SetLocal, _PARAM::GetSetting }\n+\t{                                                                                                                  \\\n+\t\t_PARAM::Name, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, _PARAM::SetLocal,                     \\\n+\t\t    _PARAM::ResetGlobal, _PARAM::ResetLocal, _PARAM::GetSetting                                                \\\n+\t}\n #define DUCKDB_GLOBAL_LOCAL_ALIAS(_ALIAS, _PARAM)                                                                      \\\n-\t{ _ALIAS, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, _PARAM::SetLocal, _PARAM::GetSetting }\n+\t{                                                                                                                  \\\n+\t\t_ALIAS, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, _PARAM::SetLocal, _PARAM::ResetGlobal,      \\\n+\t\t    _PARAM::ResetLocal, _PARAM::GetSetting                                                                     \\\n+\t}\n #define FINAL_SETTING                                                                                                  \\\n-\t{ nullptr, nullptr, LogicalTypeId::INVALID, nullptr, nullptr, nullptr }\n+\t{ nullptr, nullptr, LogicalTypeId::INVALID, nullptr, nullptr, nullptr, nullptr, nullptr }\n \n static ConfigurationOption internal_options[] = {DUCKDB_GLOBAL(AccessModeSetting),\n                                                  DUCKDB_GLOBAL(CheckpointThresholdSetting),\n@@ -124,24 +146,68 @@ void DBConfig::SetOption(DatabaseInstance *db, const ConfigurationOption &option\n \tif (!option.set_global) {\n \t\tthrow InternalException(\"Could not set option \\\"%s\\\" as a global option\", option.name);\n \t}\n+\tD_ASSERT(option.reset_global);\n \tValue input = value.DefaultCastAs(option.parameter_type);\n \toption.set_global(db, *this, input);\n }\n \n+void DBConfig::ResetOption(DatabaseInstance *db, const ConfigurationOption &option) {\n+\tlock_guard<mutex> l(config_lock);\n+\tif (!option.reset_global) {\n+\t\tthrow InternalException(\"Could not reset option \\\"%s\\\" as a global option\", option.name);\n+\t}\n+\tD_ASSERT(option.set_global);\n+\toption.reset_global(db, *this);\n+}\n+\n void DBConfig::SetOption(const string &name, Value value) {\n \tlock_guard<mutex> l(config_lock);\n \toptions.set_variables[name] = move(value);\n }\n \n-void DBConfig::AddExtensionOption(string name, string description, LogicalType parameter,\n-                                  set_option_callback_t function) {\n-\textension_parameters.insert(make_pair(move(name), ExtensionOption(move(description), move(parameter), function)));\n+void DBConfig::ResetOption(const string &name) {\n+\tlock_guard<mutex> l(config_lock);\n+\tauto extension_option = extension_parameters.find(name);\n+\tD_ASSERT(extension_option != extension_parameters.end());\n+\tauto &default_value = extension_option->second.default_value;\n+\tif (!default_value.IsNull()) {\n+\t\t// Default is not NULL, override the setting\n+\t\toptions.set_variables[name] = default_value;\n+\t} else {\n+\t\t// Otherwise just remove it from the 'set_variables' map\n+\t\toptions.set_variables.erase(name);\n+\t}\n+}\n+\n+void DBConfig::AddExtensionOption(const string &name, string description, LogicalType parameter,\n+                                  const Value &default_value, set_option_callback_t function) {\n+\textension_parameters.insert(\n+\t    make_pair(name, ExtensionOption(move(description), move(parameter), function, default_value)));\n+\tif (!default_value.IsNull()) {\n+\t\t// Default value is set, insert it into the 'set_variables' list\n+\t\toptions.set_variables[name] = default_value;\n+\t}\n }\n \n CastFunctionSet &DBConfig::GetCastFunctions() {\n \treturn *cast_functions;\n }\n \n+void DBConfig::SetDefaultMaxMemory() {\n+\tauto memory = FileSystem::GetAvailableMemory();\n+\tif (memory != DConstants::INVALID_INDEX) {\n+\t\toptions.maximum_memory = memory * 8 / 10;\n+\t}\n+}\n+\n+void DBConfig::SetDefaultMaxThreads() {\n+#ifndef DUCKDB_NO_THREADS\n+\toptions.maximum_threads = std::thread::hardware_concurrency();\n+#else\n+\toptions.maximum_threads = 1;\n+#endif\n+}\n+\n idx_t DBConfig::ParseMemoryLimit(const string &arg) {\n \tif (arg[0] == '-' || arg == \"null\" || arg == \"none\") {\n \t\treturn DConstants::INVALID_INDEX;\ndiff --git a/src/main/database.cpp b/src/main/database.cpp\nindex 2627035a45be..4787bc0483a3 100644\n--- a/src/main/database.cpp\n+++ b/src/main/database.cpp\n@@ -252,17 +252,10 @@ void DatabaseInstance::Configure(DBConfig &new_config) {\n \t\tconfig.file_system = make_unique<VirtualFileSystem>();\n \t}\n \tif (config.options.maximum_memory == (idx_t)-1) {\n-\t\tauto memory = FileSystem::GetAvailableMemory();\n-\t\tif (memory != DConstants::INVALID_INDEX) {\n-\t\t\tconfig.options.maximum_memory = memory * 8 / 10;\n-\t\t}\n+\t\tconfig.SetDefaultMaxMemory();\n \t}\n \tif (new_config.options.maximum_threads == (idx_t)-1) {\n-#ifndef DUCKDB_NO_THREADS\n-\t\tconfig.options.maximum_threads = std::thread::hardware_concurrency();\n-#else\n-\t\tconfig.options.maximum_threads = 1;\n-#endif\n+\t\tconfig.SetDefaultMaxThreads();\n \t}\n \tconfig.allocator = move(new_config.allocator);\n \tif (!config.allocator) {\ndiff --git a/src/main/settings/settings.cpp b/src/main/settings/settings.cpp\nindex 91a74d4c58da..f84b4fa7ad1c 100644\n--- a/src/main/settings/settings.cpp\n+++ b/src/main/settings/settings.cpp\n@@ -32,6 +32,10 @@ void AccessModeSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const\n \t}\n }\n \n+void AccessModeSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.options.access_mode = DBConfig().options.access_mode;\n+}\n+\n Value AccessModeSetting::GetSetting(ClientContext &context) {\n \tauto &config = DBConfig::GetConfig(context);\n \tswitch (config.options.access_mode) {\n@@ -54,6 +58,10 @@ void CheckpointThresholdSetting::SetGlobal(DatabaseInstance *db, DBConfig &confi\n \tconfig.options.checkpoint_wal_size = new_limit;\n }\n \n+void CheckpointThresholdSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.options.checkpoint_wal_size = DBConfig().options.checkpoint_wal_size;\n+}\n+\n Value CheckpointThresholdSetting::GetSetting(ClientContext &context) {\n \tauto &config = DBConfig::GetConfig(context);\n \treturn Value(StringUtil::BytesToHumanReadableString(config.options.checkpoint_wal_size));\n@@ -78,13 +86,35 @@ void DebugCheckpointAbort::SetGlobal(DatabaseInstance *db, DBConfig &config, con\n \t}\n }\n \n+void DebugCheckpointAbort::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.options.checkpoint_abort = DBConfig().options.checkpoint_abort;\n+}\n+\n Value DebugCheckpointAbort::GetSetting(ClientContext &context) {\n-\treturn Value();\n+\tauto &config = DBConfig::GetConfig(*context.db);\n+\tauto setting = config.options.checkpoint_abort;\n+\tswitch (setting) {\n+\tcase CheckpointAbort::NO_ABORT:\n+\t\treturn \"none\";\n+\tcase CheckpointAbort::DEBUG_ABORT_BEFORE_TRUNCATE:\n+\t\treturn \"before_truncate\";\n+\tcase CheckpointAbort::DEBUG_ABORT_BEFORE_HEADER:\n+\t\treturn \"before_header\";\n+\tcase CheckpointAbort::DEBUG_ABORT_AFTER_FREE_LIST_WRITE:\n+\t\treturn \"after_free_list_write\";\n+\tdefault:\n+\t\tthrow InternalException(\"Type not implemented for CheckpointAbort\");\n+\t}\n }\n \n //===--------------------------------------------------------------------===//\n // Debug Force External\n //===--------------------------------------------------------------------===//\n+\n+void DebugForceExternal::ResetLocal(ClientContext &context) {\n+\tClientConfig::GetConfig(context).force_external = ClientConfig().force_external;\n+}\n+\n void DebugForceExternal::SetLocal(ClientContext &context, const Value &input) {\n \tClientConfig::GetConfig(context).force_external = input.GetValue<bool>();\n }\n@@ -96,6 +126,11 @@ Value DebugForceExternal::GetSetting(ClientContext &context) {\n //===--------------------------------------------------------------------===//\n // Debug Force NoCrossProduct\n //===--------------------------------------------------------------------===//\n+\n+void DebugForceNoCrossProduct::ResetLocal(ClientContext &context) {\n+\tClientConfig::GetConfig(context).force_no_cross_product = ClientConfig().force_no_cross_product;\n+}\n+\n void DebugForceNoCrossProduct::SetLocal(ClientContext &context, const Value &input) {\n \tClientConfig::GetConfig(context).force_no_cross_product = input.GetValue<bool>();\n }\n@@ -120,6 +155,10 @@ void DebugWindowMode::SetGlobal(DatabaseInstance *db, DBConfig &config, const Va\n \t}\n }\n \n+void DebugWindowMode::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.options.window_mode = DBConfig().options.window_mode;\n+}\n+\n Value DebugWindowMode::GetSetting(ClientContext &context) {\n \treturn Value();\n }\n@@ -132,6 +171,15 @@ void DefaultCollationSetting::SetGlobal(DatabaseInstance *db, DBConfig &config,\n \tconfig.options.collation = parameter;\n }\n \n+void DefaultCollationSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.options.collation = DBConfig().options.collation;\n+}\n+\n+void DefaultCollationSetting::ResetLocal(ClientContext &context) {\n+\tauto &config = DBConfig::GetConfig(context);\n+\tconfig.options.collation = DBConfig().options.collation;\n+}\n+\n void DefaultCollationSetting::SetLocal(ClientContext &context, const Value &input) {\n \tauto parameter = input.ToString();\n \t// bind the collation to verify that it exists\n@@ -160,6 +208,10 @@ void DefaultOrderSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, cons\n \t}\n }\n \n+void DefaultOrderSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.options.default_order_type = DBConfig().options.default_order_type;\n+}\n+\n Value DefaultOrderSetting::GetSetting(ClientContext &context) {\n \tauto &config = DBConfig::GetConfig(context);\n \tswitch (config.options.default_order_type) {\n@@ -190,6 +242,10 @@ void DefaultNullOrderSetting::SetGlobal(DatabaseInstance *db, DBConfig &config,\n \t}\n }\n \n+void DefaultNullOrderSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.options.default_null_order = DBConfig().options.default_null_order;\n+}\n+\n Value DefaultNullOrderSetting::GetSetting(ClientContext &context) {\n \tauto &config = DBConfig::GetConfig(context);\n \tswitch (config.options.default_null_order) {\n@@ -219,6 +275,10 @@ void DisabledOptimizersSetting::SetGlobal(DatabaseInstance *db, DBConfig &config\n \tconfig.options.disabled_optimizers = move(disabled_optimizers);\n }\n \n+void DisabledOptimizersSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.options.disabled_optimizers = DBConfig().options.disabled_optimizers;\n+}\n+\n Value DisabledOptimizersSetting::GetSetting(ClientContext &context) {\n \tauto &config = DBConfig::GetConfig(context);\n \tstring result;\n@@ -242,6 +302,13 @@ void EnableExternalAccessSetting::SetGlobal(DatabaseInstance *db, DBConfig &conf\n \tconfig.options.enable_external_access = new_value;\n }\n \n+void EnableExternalAccessSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tif (db) {\n+\t\tthrow InvalidInputException(\"Cannot change enable_external_access setting while database is running\");\n+\t}\n+\tconfig.options.enable_external_access = DBConfig().options.enable_external_access;\n+}\n+\n Value EnableExternalAccessSetting::GetSetting(ClientContext &context) {\n \tauto &config = DBConfig::GetConfig(context);\n \treturn Value::BOOLEAN(config.options.enable_external_access);\n@@ -254,6 +321,10 @@ void EnableFSSTVectors::SetGlobal(DatabaseInstance *db, DBConfig &config, const\n \tconfig.options.enable_fsst_vectors = input.GetValue<bool>();\n }\n \n+void EnableFSSTVectors::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.options.enable_fsst_vectors = DBConfig().options.enable_fsst_vectors;\n+}\n+\n Value EnableFSSTVectors::GetSetting(ClientContext &context) {\n \tauto &config = DBConfig::GetConfig(context);\n \treturn Value::BOOLEAN(config.options.enable_fsst_vectors);\n@@ -270,6 +341,13 @@ void AllowUnsignedExtensionsSetting::SetGlobal(DatabaseInstance *db, DBConfig &c\n \tconfig.options.allow_unsigned_extensions = new_value;\n }\n \n+void AllowUnsignedExtensionsSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tif (db) {\n+\t\tthrow InvalidInputException(\"Cannot change allow_unsigned_extensions setting while database is running\");\n+\t}\n+\tconfig.options.allow_unsigned_extensions = DBConfig().options.allow_unsigned_extensions;\n+}\n+\n Value AllowUnsignedExtensionsSetting::GetSetting(ClientContext &context) {\n \tauto &config = DBConfig::GetConfig(context);\n \treturn Value::BOOLEAN(config.options.allow_unsigned_extensions);\n@@ -282,6 +360,10 @@ void EnableObjectCacheSetting::SetGlobal(DatabaseInstance *db, DBConfig &config,\n \tconfig.options.object_cache_enable = input.GetValue<bool>();\n }\n \n+void EnableObjectCacheSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.options.object_cache_enable = DBConfig().options.object_cache_enable;\n+}\n+\n Value EnableObjectCacheSetting::GetSetting(ClientContext &context) {\n \tauto &config = DBConfig::GetConfig(context);\n \treturn Value::BOOLEAN(config.options.object_cache_enable);\n@@ -294,6 +376,10 @@ void EnableHTTPMetadataCacheSetting::SetGlobal(DatabaseInstance *db, DBConfig &c\n \tconfig.options.http_metadata_cache_enable = input.GetValue<bool>();\n }\n \n+void EnableHTTPMetadataCacheSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.options.http_metadata_cache_enable = DBConfig().options.http_metadata_cache_enable;\n+}\n+\n Value EnableHTTPMetadataCacheSetting::GetSetting(ClientContext &context) {\n \tauto &config = DBConfig::GetConfig(context);\n \treturn Value::BOOLEAN(config.options.http_metadata_cache_enable);\n@@ -302,6 +388,14 @@ Value EnableHTTPMetadataCacheSetting::GetSetting(ClientContext &context) {\n //===--------------------------------------------------------------------===//\n // Enable Profiling\n //===--------------------------------------------------------------------===//\n+\n+void EnableProfilingSetting::ResetLocal(ClientContext &context) {\n+\tauto &config = ClientConfig::GetConfig(context);\n+\tconfig.profiler_print_format = ClientConfig().profiler_print_format;\n+\tconfig.enable_profiler = ClientConfig().enable_profiler;\n+\tconfig.emit_profiler_output = ClientConfig().emit_profiler_output;\n+}\n+\n void EnableProfilingSetting::SetLocal(ClientContext &context, const Value &input) {\n \tauto parameter = StringUtil::Lower(input.ToString());\n \n@@ -340,6 +434,11 @@ Value EnableProfilingSetting::GetSetting(ClientContext &context) {\n //===--------------------------------------------------------------------===//\n // Enable Progress Bar\n //===--------------------------------------------------------------------===//\n+\n+void EnableProgressBarSetting::ResetLocal(ClientContext &context) {\n+\tClientConfig::GetConfig(context).enable_progress_bar = ClientConfig().enable_progress_bar;\n+}\n+\n void EnableProgressBarSetting::SetLocal(ClientContext &context, const Value &input) {\n \tClientConfig::GetConfig(context).enable_progress_bar = input.GetValue<bool>();\n }\n@@ -355,6 +454,10 @@ void ExperimentalParallelCSVSetting::SetGlobal(DatabaseInstance *db, DBConfig &c\n \tconfig.options.experimental_parallel_csv_reader = input.GetValue<bool>();\n }\n \n+void ExperimentalParallelCSVSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.options.experimental_parallel_csv_reader = DBConfig().options.experimental_parallel_csv_reader;\n+}\n+\n Value ExperimentalParallelCSVSetting::GetSetting(ClientContext &context) {\n \tauto &config = DBConfig::GetConfig(context);\n \treturn Value::BIGINT(config.options.experimental_parallel_csv_reader);\n@@ -363,6 +466,11 @@ Value ExperimentalParallelCSVSetting::GetSetting(ClientContext &context) {\n //===--------------------------------------------------------------------===//\n // Explain Output\n //===--------------------------------------------------------------------===//\n+\n+void ExplainOutputSetting::ResetLocal(ClientContext &context) {\n+\tClientConfig::GetConfig(context).explain_output_type = ClientConfig().explain_output_type;\n+}\n+\n void ExplainOutputSetting::SetLocal(ClientContext &context, const Value &input) {\n \tauto parameter = StringUtil::Lower(input.ToString());\n \tif (parameter == \"all\") {\n@@ -397,6 +505,10 @@ void ExternalThreadsSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, c\n \tconfig.options.external_threads = input.GetValue<int64_t>();\n }\n \n+void ExternalThreadsSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.options.external_threads = DBConfig().options.external_threads;\n+}\n+\n Value ExternalThreadsSetting::GetSetting(ClientContext &context) {\n \tauto &config = DBConfig::GetConfig(context);\n \treturn Value::BIGINT(config.options.external_threads);\n@@ -405,6 +517,12 @@ Value ExternalThreadsSetting::GetSetting(ClientContext &context) {\n //===--------------------------------------------------------------------===//\n // File Search Path\n //===--------------------------------------------------------------------===//\n+\n+void FileSearchPathSetting::ResetLocal(ClientContext &context) {\n+\tauto &client_data = ClientData::Get(context);\n+\tclient_data.file_search_path.clear();\n+}\n+\n void FileSearchPathSetting::SetLocal(ClientContext &context, const Value &input) {\n \tauto parameter = input.ToString();\n \tauto &client_data = ClientData::Get(context);\n@@ -421,20 +539,25 @@ Value FileSearchPathSetting::GetSetting(ClientContext &context) {\n //===--------------------------------------------------------------------===//\n void ForceCompressionSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {\n \tauto compression = StringUtil::Lower(input.ToString());\n-\tif (compression == \"none\") {\n+\tif (compression == \"none\" || compression == \"auto\") {\n \t\tconfig.options.force_compression = CompressionType::COMPRESSION_AUTO;\n \t} else {\n \t\tauto compression_type = CompressionTypeFromString(compression);\n \t\tif (compression_type == CompressionType::COMPRESSION_AUTO) {\n-\t\t\tthrow ParserException(\"Unrecognized option for force_compression, expected none, uncompressed, rle, \"\n-\t\t\t                      \"dictionary, pfor, chimp, patas, bitpacking or fsst\");\n+\t\t\tauto compression_types = StringUtil::Join(ListCompressionTypes(), \", \");\n+\t\t\tthrow ParserException(\"Unrecognized option for PRAGMA force_compression, expected %s\", compression_types);\n \t\t}\n \t\tconfig.options.force_compression = compression_type;\n \t}\n }\n \n+void ForceCompressionSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.options.force_compression = DBConfig().options.force_compression;\n+}\n+\n Value ForceCompressionSetting::GetSetting(ClientContext &context) {\n-\treturn Value(CompressionTypeToString(context.db->config.options.force_compression));\n+\tauto &config = DBConfig::GetConfig(*context.db);\n+\treturn CompressionTypeToString(config.options.force_compression);\n }\n \n //===--------------------------------------------------------------------===//\n@@ -455,6 +578,10 @@ void ForceBitpackingModeSetting::SetGlobal(DatabaseInstance *db, DBConfig &confi\n \t}\n }\n \n+void ForceBitpackingModeSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.options.force_bitpacking_mode = DBConfig().options.force_bitpacking_mode;\n+}\n+\n Value ForceBitpackingModeSetting::GetSetting(ClientContext &context) {\n \treturn Value(BitpackingModeToString(context.db->config.options.force_bitpacking_mode));\n }\n@@ -462,6 +589,11 @@ Value ForceBitpackingModeSetting::GetSetting(ClientContext &context) {\n //===--------------------------------------------------------------------===//\n // Home Directory\n //===--------------------------------------------------------------------===//\n+\n+void HomeDirectorySetting::ResetLocal(ClientContext &context) {\n+\tClientConfig::GetConfig(context).home_directory = ClientConfig().home_directory;\n+}\n+\n void HomeDirectorySetting::SetLocal(ClientContext &context, const Value &input) {\n \tauto &config = ClientConfig::GetConfig(context);\n \tconfig.home_directory = input.IsNull() ? string() : input.ToString();\n@@ -475,6 +607,13 @@ Value HomeDirectorySetting::GetSetting(ClientContext &context) {\n //===--------------------------------------------------------------------===//\n // Log Query Path\n //===--------------------------------------------------------------------===//\n+\n+void LogQueryPathSetting::ResetLocal(ClientContext &context) {\n+\tauto &client_data = ClientData::Get(context);\n+\t// TODO: verify that this does the right thing\n+\tclient_data.log_query_writer = move(ClientData(context).log_query_writer);\n+}\n+\n void LogQueryPathSetting::SetLocal(ClientContext &context, const Value &input) {\n \tauto &client_data = ClientData::Get(context);\n \tauto path = input.ToString();\n@@ -496,6 +635,11 @@ Value LogQueryPathSetting::GetSetting(ClientContext &context) {\n //===--------------------------------------------------------------------===//\n // Maximum Expression Depth\n //===--------------------------------------------------------------------===//\n+\n+void MaximumExpressionDepthSetting::ResetLocal(ClientContext &context) {\n+\tClientConfig::GetConfig(context).max_expression_depth = ClientConfig().max_expression_depth;\n+}\n+\n void MaximumExpressionDepthSetting::SetLocal(ClientContext &context, const Value &input) {\n \tClientConfig::GetConfig(context).max_expression_depth = input.GetValue<uint64_t>();\n }\n@@ -514,6 +658,10 @@ void MaximumMemorySetting::SetGlobal(DatabaseInstance *db, DBConfig &config, con\n \t}\n }\n \n+void MaximumMemorySetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.SetDefaultMaxMemory();\n+}\n+\n Value MaximumMemorySetting::GetSetting(ClientContext &context) {\n \tauto &config = DBConfig::GetConfig(context);\n \treturn Value(StringUtil::BytesToHumanReadableString(config.options.maximum_memory));\n@@ -526,6 +674,10 @@ void PasswordSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Va\n \t// nop\n }\n \n+void PasswordSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\t// nop\n+}\n+\n Value PasswordSetting::GetSetting(ClientContext &context) {\n \treturn Value();\n }\n@@ -533,6 +685,11 @@ Value PasswordSetting::GetSetting(ClientContext &context) {\n //===--------------------------------------------------------------------===//\n // Perfect Hash Threshold\n //===--------------------------------------------------------------------===//\n+\n+void PerfectHashThresholdSetting::ResetLocal(ClientContext &context) {\n+\tClientConfig::GetConfig(context).perfect_ht_threshold = ClientConfig().perfect_ht_threshold;\n+}\n+\n void PerfectHashThresholdSetting::SetLocal(ClientContext &context, const Value &input) {\n \tauto bits = input.GetValue<int32_t>();\n \tif (bits < 0 || bits > 32) {\n@@ -548,6 +705,11 @@ Value PerfectHashThresholdSetting::GetSetting(ClientContext &context) {\n //===--------------------------------------------------------------------===//\n // PreserveIdentifierCase\n //===--------------------------------------------------------------------===//\n+\n+void PreserveIdentifierCase::ResetLocal(ClientContext &context) {\n+\tClientConfig::GetConfig(context).preserve_identifier_case = ClientConfig().preserve_identifier_case;\n+}\n+\n void PreserveIdentifierCase::SetLocal(ClientContext &context, const Value &input) {\n \tClientConfig::GetConfig(context).preserve_identifier_case = input.GetValue<bool>();\n }\n@@ -563,6 +725,10 @@ void PreserveInsertionOrder::SetGlobal(DatabaseInstance *db, DBConfig &config, c\n \tconfig.options.preserve_insertion_order = input.GetValue<bool>();\n }\n \n+void PreserveInsertionOrder::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.options.preserve_insertion_order = DBConfig().options.preserve_insertion_order;\n+}\n+\n Value PreserveInsertionOrder::GetSetting(ClientContext &context) {\n \tauto &config = DBConfig::GetConfig(context);\n \treturn Value::BOOLEAN(config.options.preserve_insertion_order);\n@@ -571,6 +737,12 @@ Value PreserveInsertionOrder::GetSetting(ClientContext &context) {\n //===--------------------------------------------------------------------===//\n // Profiler History Size\n //===--------------------------------------------------------------------===//\n+\n+void ProfilerHistorySize::ResetLocal(ClientContext &context) {\n+\tauto &client_data = ClientData::Get(context);\n+\tclient_data.query_profiler_history->ResetProfilerHistorySize();\n+}\n+\n void ProfilerHistorySize::SetLocal(ClientContext &context, const Value &input) {\n \tauto size = input.GetValue<int64_t>();\n \tif (size <= 0) {\n@@ -587,6 +759,11 @@ Value ProfilerHistorySize::GetSetting(ClientContext &context) {\n //===--------------------------------------------------------------------===//\n // Profile Output\n //===--------------------------------------------------------------------===//\n+\n+void ProfileOutputSetting::ResetLocal(ClientContext &context) {\n+\tClientConfig::GetConfig(context).profiler_save_location = ClientConfig().profiler_save_location;\n+}\n+\n void ProfileOutputSetting::SetLocal(ClientContext &context, const Value &input) {\n \tauto &config = ClientConfig::GetConfig(context);\n \tauto parameter = input.ToString();\n@@ -601,6 +778,13 @@ Value ProfileOutputSetting::GetSetting(ClientContext &context) {\n //===--------------------------------------------------------------------===//\n // Profiling Mode\n //===--------------------------------------------------------------------===//\n+\n+void ProfilingModeSetting::ResetLocal(ClientContext &context) {\n+\tClientConfig::GetConfig(context).enable_profiler = ClientConfig().enable_profiler;\n+\tClientConfig::GetConfig(context).enable_detailed_profiling = ClientConfig().enable_detailed_profiling;\n+\tClientConfig::GetConfig(context).emit_profiler_output = ClientConfig().emit_profiler_output;\n+}\n+\n void ProfilingModeSetting::SetLocal(ClientContext &context, const Value &input) {\n \tauto parameter = StringUtil::Lower(input.ToString());\n \tauto &config = ClientConfig::GetConfig(context);\n@@ -628,6 +812,12 @@ Value ProfilingModeSetting::GetSetting(ClientContext &context) {\n //===--------------------------------------------------------------------===//\n // Progress Bar Time\n //===--------------------------------------------------------------------===//\n+\n+void ProgressBarTimeSetting::ResetLocal(ClientContext &context) {\n+\tClientConfig::GetConfig(context).wait_time = ClientConfig().wait_time;\n+\tClientConfig::GetConfig(context).enable_progress_bar = ClientConfig().enable_progress_bar;\n+}\n+\n void ProgressBarTimeSetting::SetLocal(ClientContext &context, const Value &input) {\n \tClientConfig::GetConfig(context).wait_time = input.GetValue<int32_t>();\n \tClientConfig::GetConfig(context).enable_progress_bar = true;\n@@ -640,6 +830,13 @@ Value ProgressBarTimeSetting::GetSetting(ClientContext &context) {\n //===--------------------------------------------------------------------===//\n // Schema\n //===--------------------------------------------------------------------===//\n+\n+void SchemaSetting::ResetLocal(ClientContext &context) {\n+\t// FIXME: catalog_search_path is controlled by both SchemaSetting and SearchPathSetting\n+\tauto &client_data = ClientData::Get(context);\n+\tclient_data.catalog_search_path->Reset();\n+}\n+\n void SchemaSetting::SetLocal(ClientContext &context, const Value &input) {\n \tauto parameter = input.ToString();\n \tauto &client_data = ClientData::Get(context);\n@@ -653,6 +850,13 @@ Value SchemaSetting::GetSetting(ClientContext &context) {\n //===--------------------------------------------------------------------===//\n // Search Path\n //===--------------------------------------------------------------------===//\n+\n+void SearchPathSetting::ResetLocal(ClientContext &context) {\n+\t// FIXME: catalog_search_path is controlled by both SchemaSetting and SearchPathSetting\n+\tauto &client_data = ClientData::Get(context);\n+\tclient_data.catalog_search_path->Reset();\n+}\n+\n void SearchPathSetting::SetLocal(ClientContext &context, const Value &input) {\n \tauto parameter = input.ToString();\n \tauto &client_data = ClientData::Get(context);\n@@ -676,6 +880,15 @@ void TempDirectorySetting::SetGlobal(DatabaseInstance *db, DBConfig &config, con\n \t}\n }\n \n+void TempDirectorySetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.options.temporary_directory = DBConfig().options.temporary_directory;\n+\tconfig.options.use_temporary_directory = DBConfig().options.use_temporary_directory;\n+\tif (db) {\n+\t\tauto &buffer_manager = BufferManager::GetBufferManager(*db);\n+\t\tbuffer_manager.SetTemporaryDirectory(config.options.temporary_directory);\n+\t}\n+}\n+\n Value TempDirectorySetting::GetSetting(ClientContext &context) {\n \tauto &buffer_manager = BufferManager::GetBufferManager(context);\n \treturn Value(buffer_manager.GetTemporaryDirectory());\n@@ -691,6 +904,10 @@ void ThreadsSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Val\n \t}\n }\n \n+void ThreadsSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\tconfig.SetDefaultMaxThreads();\n+}\n+\n Value ThreadsSetting::GetSetting(ClientContext &context) {\n \tauto &config = DBConfig::GetConfig(context);\n \treturn Value::BIGINT(config.options.maximum_threads);\n@@ -703,6 +920,10 @@ void UsernameSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Va\n \t// nop\n }\n \n+void UsernameSetting::ResetGlobal(DatabaseInstance *db, DBConfig &config) {\n+\t// nop\n+}\n+\n Value UsernameSetting::GetSetting(ClientContext &context) {\n \treturn Value();\n }\ndiff --git a/src/parser/statement/set_statement.cpp b/src/parser/statement/set_statement.cpp\nindex a4c0560b7ca9..94ab303ae33c 100644\n--- a/src/parser/statement/set_statement.cpp\n+++ b/src/parser/statement/set_statement.cpp\n@@ -2,12 +2,28 @@\n \n namespace duckdb {\n \n-SetStatement::SetStatement(std::string name_p, Value value_p, SetScope scope_p)\n-    : SQLStatement(StatementType::SET_STATEMENT), name(move(name_p)), value(move(value_p)), scope(scope_p) {\n+SetStatement::SetStatement(std::string name_p, SetScope scope_p, SetType type_p)\n+    : SQLStatement(StatementType::SET_STATEMENT), name(move(name_p)), scope(scope_p), set_type(type_p) {\n }\n \n unique_ptr<SQLStatement> SetStatement::Copy() const {\n \treturn unique_ptr<SetStatement>(new SetStatement(*this));\n }\n \n+// Set Variable\n+\n+SetVariableStatement::SetVariableStatement(std::string name_p, Value value_p, SetScope scope_p)\n+    : SetStatement(move(name_p), scope_p, SetType::SET), value(move(value_p)) {\n+}\n+\n+unique_ptr<SQLStatement> SetVariableStatement::Copy() const {\n+\treturn unique_ptr<SetVariableStatement>(new SetVariableStatement(*this));\n+}\n+\n+// Reset Variable\n+\n+ResetVariableStatement::ResetVariableStatement(std::string name_p, SetScope scope_p)\n+    : SetStatement(move(name_p), scope_p, SetType::RESET) {\n+}\n+\n } // namespace duckdb\ndiff --git a/src/parser/transform/statement/transform_pragma.cpp b/src/parser/transform/statement/transform_pragma.cpp\nindex e55c210b8140..a370dccea2fb 100644\n--- a/src/parser/transform/statement/transform_pragma.cpp\n+++ b/src/parser/transform/statement/transform_pragma.cpp\n@@ -63,7 +63,7 @@ unique_ptr<SQLStatement> Transformer::TransformPragma(duckdb_libpgquery::PGNode\n \t\tif (sqlite_compat_pragmas.find(info.name) != sqlite_compat_pragmas.end()) {\n \t\t\tbreak;\n \t\t}\n-\t\tauto set_statement = make_unique<SetStatement>(info.name, info.parameters[0], SetScope::AUTOMATIC);\n+\t\tauto set_statement = make_unique<SetVariableStatement>(info.name, info.parameters[0], SetScope::AUTOMATIC);\n \t\treturn move(set_statement);\n \t}\n \tcase duckdb_libpgquery::PG_PRAGMA_TYPE_CALL:\ndiff --git a/src/parser/transform/statement/transform_set.cpp b/src/parser/transform/statement/transform_set.cpp\nindex dfb23f55975c..b7ecc0b1f04d 100644\n--- a/src/parser/transform/statement/transform_set.cpp\n+++ b/src/parser/transform/statement/transform_set.cpp\n@@ -22,15 +22,21 @@ SetScope ToSetScope(duckdb_libpgquery::VariableSetScope pg_scope) {\n \t}\n }\n \n-} // namespace\n+SetType ToSetType(duckdb_libpgquery::VariableSetKind pg_kind) {\n+\tswitch (pg_kind) {\n+\tcase duckdb_libpgquery::VariableSetKind::VAR_SET_VALUE:\n+\t\treturn SetType::SET;\n+\tcase duckdb_libpgquery::VariableSetKind::VAR_RESET:\n+\t\treturn SetType::RESET;\n+\tdefault:\n+\t\tthrow NotImplementedException(\"Can only SET or RESET a variable\");\n+\t}\n+}\n \n-unique_ptr<SetStatement> Transformer::TransformSet(duckdb_libpgquery::PGNode *node) {\n-\tD_ASSERT(node->type == duckdb_libpgquery::T_PGVariableSetStmt);\n-\tauto stmt = reinterpret_cast<duckdb_libpgquery::PGVariableSetStmt *>(node);\n+} // namespace\n \n-\tif (stmt->kind != duckdb_libpgquery::VariableSetKind::VAR_SET_VALUE) {\n-\t\tthrow ParserException(\"Can only SET a variable to a value\");\n-\t}\n+unique_ptr<SetStatement> Transformer::TransformSetVariable(duckdb_libpgquery::PGVariableSetStmt *stmt) {\n+\tD_ASSERT(stmt->kind == duckdb_libpgquery::VariableSetKind::VAR_SET_VALUE);\n \n \tif (stmt->scope == duckdb_libpgquery::VariableSetScope::VAR_SET_SCOPE_LOCAL) {\n \t\tthrow NotImplementedException(\"SET LOCAL is not implemented.\");\n@@ -46,7 +52,36 @@ unique_ptr<SetStatement> Transformer::TransformSet(duckdb_libpgquery::PGNode *no\n \n \tauto value = TransformValue(((duckdb_libpgquery::PGAConst *)stmt->args->head->data.ptr_value)->val)->value;\n \n-\treturn make_unique<SetStatement>(name, value, ToSetScope(stmt->scope));\n+\treturn make_unique<SetVariableStatement>(name, value, ToSetScope(stmt->scope));\n+}\n+\n+unique_ptr<SetStatement> Transformer::TransformResetVariable(duckdb_libpgquery::PGVariableSetStmt *stmt) {\n+\tD_ASSERT(stmt->kind == duckdb_libpgquery::VariableSetKind::VAR_RESET);\n+\n+\tif (stmt->scope == duckdb_libpgquery::VariableSetScope::VAR_SET_SCOPE_LOCAL) {\n+\t\tthrow NotImplementedException(\"RESET LOCAL is not implemented.\");\n+\t}\n+\n+\tauto name = std::string(stmt->name);\n+\tD_ASSERT(!name.empty()); // parser protect us!\n+\n+\treturn make_unique<ResetVariableStatement>(name, ToSetScope(stmt->scope));\n+}\n+\n+unique_ptr<SetStatement> Transformer::TransformSet(duckdb_libpgquery::PGNode *node) {\n+\tD_ASSERT(node->type == duckdb_libpgquery::T_PGVariableSetStmt);\n+\tauto stmt = reinterpret_cast<duckdb_libpgquery::PGVariableSetStmt *>(node);\n+\n+\tSetType set_type = ToSetType(stmt->kind);\n+\n+\tswitch (set_type) {\n+\tcase SetType::SET:\n+\t\treturn TransformSetVariable(stmt);\n+\tcase SetType::RESET:\n+\t\treturn TransformResetVariable(stmt);\n+\tdefault:\n+\t\tthrow NotImplementedException(\"Type not implemented for SetType\");\n+\t}\n }\n \n } // namespace duckdb\ndiff --git a/src/planner/binder/statement/bind_set.cpp b/src/planner/binder/statement/bind_set.cpp\nindex c300541390d1..d64c111663b7 100644\n--- a/src/planner/binder/statement/bind_set.cpp\n+++ b/src/planner/binder/statement/bind_set.cpp\n@@ -1,11 +1,12 @@\n #include \"duckdb/parser/statement/set_statement.hpp\"\n #include \"duckdb/planner/binder.hpp\"\n #include \"duckdb/planner/operator/logical_set.hpp\"\n+#include \"duckdb/planner/operator/logical_reset.hpp\"\n #include <algorithm>\n \n namespace duckdb {\n \n-BoundStatement Binder::Bind(SetStatement &stmt) {\n+BoundStatement Binder::Bind(SetVariableStatement &stmt) {\n \tBoundStatement result;\n \tresult.types = {LogicalType::BOOLEAN};\n \tresult.names = {\"Success\"};\n@@ -15,4 +16,29 @@ BoundStatement Binder::Bind(SetStatement &stmt) {\n \treturn result;\n }\n \n+BoundStatement Binder::Bind(ResetVariableStatement &stmt) {\n+\tBoundStatement result;\n+\tresult.types = {LogicalType::BOOLEAN};\n+\tresult.names = {\"Success\"};\n+\n+\tresult.plan = make_unique<LogicalReset>(stmt.name, stmt.scope);\n+\tproperties.return_type = StatementReturnType::NOTHING;\n+\treturn result;\n+}\n+\n+BoundStatement Binder::Bind(SetStatement &stmt) {\n+\tswitch (stmt.set_type) {\n+\tcase SetType::SET: {\n+\t\tauto &set_stmt = (SetVariableStatement &)stmt;\n+\t\treturn Bind(set_stmt);\n+\t}\n+\tcase SetType::RESET: {\n+\t\tauto &set_stmt = (ResetVariableStatement &)stmt;\n+\t\treturn Bind(set_stmt);\n+\t}\n+\tdefault:\n+\t\tthrow NotImplementedException(\"Type not implemented for SetType\");\n+\t}\n+}\n+\n } // namespace duckdb\ndiff --git a/src/planner/logical_operator.cpp b/src/planner/logical_operator.cpp\nindex c73bfea100bf..a23bbc21712b 100644\n--- a/src/planner/logical_operator.cpp\n+++ b/src/planner/logical_operator.cpp\n@@ -336,6 +336,9 @@ unique_ptr<LogicalOperator> LogicalOperator::Deserialize(Deserializer &deseriali\n \tcase LogicalOperatorType::LOGICAL_SET:\n \t\tresult = LogicalSet::Deserialize(state, reader);\n \t\tbreak;\n+\tcase LogicalOperatorType::LOGICAL_RESET:\n+\t\tresult = LogicalReset::Deserialize(state, reader);\n+\t\tbreak;\n \tcase LogicalOperatorType::LOGICAL_LOAD:\n \t\tresult = LogicalSimple::Deserialize(state, reader);\n \t\tbreak;\ndiff --git a/src/planner/operator/CMakeLists.txt b/src/planner/operator/CMakeLists.txt\nindex 963966eb413b..f6f7b2a1e8e9 100644\n--- a/src/planner/operator/CMakeLists.txt\n+++ b/src/planner/operator/CMakeLists.txt\n@@ -35,6 +35,7 @@ add_library_unity(\n   logical_recursive_cte.cpp\n   logical_sample.cpp\n   logical_set.cpp\n+  logical_reset.cpp\n   logical_set_operation.cpp\n   logical_show.cpp\n   logical_simple.cpp\ndiff --git a/src/planner/operator/logical_reset.cpp b/src/planner/operator/logical_reset.cpp\nnew file mode 100644\nindex 000000000000..bf670857b7a5\n--- /dev/null\n+++ b/src/planner/operator/logical_reset.cpp\n@@ -0,0 +1,21 @@\n+#include \"duckdb/common/field_writer.hpp\"\n+#include \"duckdb/planner/operator/logical_reset.hpp\"\n+\n+namespace duckdb {\n+\n+void LogicalReset::Serialize(FieldWriter &writer) const {\n+\twriter.WriteString(name);\n+\twriter.WriteField(scope);\n+}\n+\n+unique_ptr<LogicalOperator> LogicalReset::Deserialize(LogicalDeserializationState &state, FieldReader &reader) {\n+\tauto name = reader.ReadRequired<std::string>();\n+\tauto scope = reader.ReadRequired<SetScope>();\n+\treturn make_unique<LogicalReset>(name, scope);\n+}\n+\n+idx_t LogicalReset::EstimateCardinality(ClientContext &context) {\n+\treturn 1;\n+}\n+\n+} // namespace duckdb\ndiff --git a/third_party/libpg_query/grammar/statements/variable_reset.y b/third_party/libpg_query/grammar/statements/variable_reset.y\nindex f7ff4956dbc4..1366e5b86539 100644\n--- a/third_party/libpg_query/grammar/statements/variable_reset.y\n+++ b/third_party/libpg_query/grammar/statements/variable_reset.y\n@@ -8,6 +8,7 @@ generic_reset:\n \t\t\t\t{\n \t\t\t\t\tPGVariableSetStmt *n = makeNode(PGVariableSetStmt);\n \t\t\t\t\tn->kind = VAR_RESET;\n+\t\t\t\t\tn->scope = VAR_SET_SCOPE_GLOBAL;\n \t\t\t\t\tn->name = $1;\n \t\t\t\t\t$$ = n;\n \t\t\t\t}\n@@ -15,6 +16,7 @@ generic_reset:\n \t\t\t\t{\n \t\t\t\t\tPGVariableSetStmt *n = makeNode(PGVariableSetStmt);\n \t\t\t\t\tn->kind = VAR_RESET_ALL;\n+\t\t\t\t\tn->scope = VAR_SET_SCOPE_GLOBAL;\n \t\t\t\t\t$$ = n;\n \t\t\t\t}\n \t\t;\ndiff --git a/third_party/libpg_query/src_backend_parser_gram.cpp b/third_party/libpg_query/src_backend_parser_gram.cpp\nindex abe865e08c17..83329de24eec 100644\n--- a/third_party/libpg_query/src_backend_parser_gram.cpp\n+++ b/third_party/libpg_query/src_backend_parser_gram.cpp\n@@ -2540,7 +2540,7 @@ static const yytype_uint16 yyrline[] =\n      148,     7,    14,    20,    28,    29,     8,    22,    36,    48,\n       56,    70,    71,    72,    73,    74,    87,    88,    93,    94,\n       98,    99,     7,    18,    31,    35,    42,    53,    54,    60,\n-      61,     9,    19,     2,     7,    14,    24,    25,    32,     3,\n+      61,     9,    19,     2,     7,    15,    26,    27,    34,     3,\n       10,    17,    24,    31,    38,    45,    52,    61,    61,    63,\n       64,    68,    69,     6,     8,    21,    34,    52,    74,    75,\n       76,    77,    11,    24,    37,    54,    55,    56,    61,    74,\n@@ -26321,27 +26321,29 @@ YYLTYPE yylloc;\n     {\n \t\t\t\t\tPGVariableSetStmt *n = makeNode(PGVariableSetStmt);\n \t\t\t\t\tn->kind = VAR_RESET;\n+\t\t\t\t\tn->scope = VAR_SET_SCOPE_GLOBAL;\n \t\t\t\t\tn->name = (yyvsp[(1) - (1)].str);\n \t\t\t\t\t(yyval.vsetstmt) = n;\n \t\t\t\t;}\n     break;\n \n   case 1295:\n-#line 15 \"third_party/libpg_query/grammar/statements/variable_reset.y\"\n+#line 16 \"third_party/libpg_query/grammar/statements/variable_reset.y\"\n     {\n \t\t\t\t\tPGVariableSetStmt *n = makeNode(PGVariableSetStmt);\n \t\t\t\t\tn->kind = VAR_RESET_ALL;\n+\t\t\t\t\tn->scope = VAR_SET_SCOPE_GLOBAL;\n \t\t\t\t\t(yyval.vsetstmt) = n;\n \t\t\t\t;}\n     break;\n \n   case 1296:\n-#line 24 \"third_party/libpg_query/grammar/statements/variable_reset.y\"\n+#line 26 \"third_party/libpg_query/grammar/statements/variable_reset.y\"\n     { (yyval.vsetstmt) = (yyvsp[(1) - (1)].vsetstmt); ;}\n     break;\n \n   case 1297:\n-#line 26 \"third_party/libpg_query/grammar/statements/variable_reset.y\"\n+#line 28 \"third_party/libpg_query/grammar/statements/variable_reset.y\"\n     {\n \t\t\t\t\tPGVariableSetStmt *n = makeNode(PGVariableSetStmt);\n \t\t\t\t\tn->kind = VAR_RESET;\n@@ -26351,7 +26353,7 @@ YYLTYPE yylloc;\n     break;\n \n   case 1298:\n-#line 33 \"third_party/libpg_query/grammar/statements/variable_reset.y\"\n+#line 35 \"third_party/libpg_query/grammar/statements/variable_reset.y\"\n     {\n \t\t\t\t\tPGVariableSetStmt *n = makeNode(PGVariableSetStmt);\n \t\t\t\t\tn->kind = VAR_RESET;\n@@ -26639,7 +26641,7 @@ YYLTYPE yylloc;\n \n \n /* Line 1267 of yacc.c.  */\n-#line 26643 \"third_party/libpg_query/grammar/grammar_out.cpp\"\n+#line 26645 \"third_party/libpg_query/grammar/grammar_out.cpp\"\n       default: break;\n     }\n   YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 76b47462f52f..d7975caf5150 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -706,8 +706,7 @@ void CreateNewInstance(DuckDBPyConnection &res, const string &database, DBConfig\n \tauto &db_config = res.database->instance->config;\n \tdb_config.AddExtensionOption(\"pandas_analyze_sample\",\n \t                             \"The maximum number of rows to sample when analyzing a pandas object column.\",\n-\t                             LogicalType::UBIGINT);\n-\tdb_config.options.set_variables[\"pandas_analyze_sample\"] = Value::UBIGINT(1000);\n+\t                             LogicalType::UBIGINT, Value::UBIGINT(1000));\n \tif (db_config.options.enable_external_access) {\n \t\tdb_config.replacement_scans.emplace_back(ScanReplacement);\n \t}\n",
  "test_patch": "diff --git a/test/api/CMakeLists.txt b/test/api/CMakeLists.txt\nindex 2830f7197f95..e1e9b3fa7c96 100644\n--- a/test/api/CMakeLists.txt\n+++ b/test/api/CMakeLists.txt\n@@ -6,6 +6,7 @@ set(TEST_API_OBJECTS\n     test_config.cpp\n     test_custom_allocator.cpp\n     test_results.cpp\n+    test_reset.cpp\n     test_get_table_names.cpp\n     test_prepared_api.cpp\n     test_table_info.cpp\ndiff --git a/test/api/test_reset.cpp b/test/api/test_reset.cpp\nnew file mode 100644\nindex 000000000000..4b8486ed914c\n--- /dev/null\n+++ b/test/api/test_reset.cpp\n@@ -0,0 +1,164 @@\n+#include \"catch.hpp\"\n+#include \"test_helpers.hpp\"\n+\n+#include <set>\n+#include <map>\n+\n+#include <iostream>\n+\n+using namespace duckdb;\n+using namespace std;\n+\n+struct OptionValuePair {\n+\tValue input;\n+\tValue output;\n+};\n+\n+void RequireValuDiff(ConfigurationOption *op, const Value &left, const Value &right, int line);\n+#define REQUIRE_VALUE_DIFF(op, lhs, rhs) RequireValueDiff(op, lhs, rhs, __LINE__)\n+\n+void RequireValueEqual(ConfigurationOption *op, const Value &left, const Value &right, int line);\n+#define REQUIRE_VALUE_EQUAL(op, lhs, rhs) RequireValueEqual(op, lhs, rhs, __LINE__)\n+\n+OptionValuePair &GetValueForOption(const string &name) {\n+\tstatic unordered_map<string, OptionValuePair> value_map = {\n+\t    {\"access_mode\", {Value(\"READ_ONLY\"), Value(\"read_only\")}},\n+\t    {\"threads\", {Value::BIGINT(42), Value::BIGINT(42)}},\n+\t    {\"checkpoint_threshold\", {\"4.2GB\", \"4.2GB\"}},\n+\t    {\"debug_checkpoint_abort\", {\"before_header\", \"before_header\"}},\n+\t    {\"default_collation\", {\"nocase\", \"nocase\"}},\n+\t    {\"default_order\", {\"desc\", \"desc\"}},\n+\t    {\"default_null_order\", {\"nulls_last\", \"nulls_last\"}},\n+\t    {\"disabled_optimizers\", {\"extension\", \"extension\"}},\n+\t    {\"enable_fsst_vectors\", {true, true}},\n+\t    {\"enable_object_cache\", {true, true}},\n+\t    {\"enable_profiling\", {\"json\", \"json\"}},\n+\t    {\"enable_progress_bar\", {true, true}},\n+\t    {\"experimental_parallel_csv\", {true, true}},\n+\t    {\"explain_output\", {true, true}},\n+\t    {\"external_threads\", {8, 8}},\n+\t    {\"file_search_path\", {\"test\", \"test\"}},\n+\t    {\"force_compression\", {\"uncompressed\", \"Uncompressed\"}},\n+\t    {\"home_directory\", {\"test\", \"test\"}},\n+\t    {\"log_query_path\", {\"test\", \"test\"}},\n+\t    {\"max_expression_depth\", {50, 50}},\n+\t    {\"max_memory\", {\"4.2GB\", \"4.2GB\"}},\n+\t    {\"memory_limit\", {\"4.2GB\", \"4.2GB\"}},\n+\t    {\"null_order\", {\"nulls_last\", \"nulls_last\"}},\n+\t    {\"perfect_ht_threshold\", {0, 0}},\n+\t    {\"preserve_identifier_case\", {false, false}},\n+\t    {\"preserve_insertion_order\", {false, false}},\n+\t    {\"profiler_history_size\", {0, 0}},\n+\t    {\"profile_output\", {\"test\", \"test\"}},\n+\t    {\"profiling_mode\", {\"detailed\", \"detailed\"}},\n+\t    {\"progress_bar_time\", {0, 0}},\n+\t    {\"temp_directory\", {\"tmp\", \"tmp\"}},\n+\t    {\"wal_autocheckpoint\", {\"4.2GB\", \"4.2GB\"}},\n+\t    {\"worker_threads\", {42, 42}},\n+\t    {\"enable_http_metadata_cache\", {true, true}},\n+\t    {\"force_bitpacking_mode\", {\"constant\", \"constant\"}},\n+\t};\n+\t// Every option that's not excluded has to be part of this map\n+\tif (!value_map.count(name)) {\n+\t\tREQUIRE(name == \"MISSING_FROM_MAP\");\n+\t}\n+\treturn value_map[name];\n+}\n+\n+bool OptionIsExcludedFromTest(const string &name) {\n+\tstatic unordered_set<string> excluded_options = {\n+\t    \"schema\",\n+\t    \"search_path\",\n+\t    \"debug_force_external\",\n+\t    \"debug_force_no_cross_product\",\n+\t    \"debug_window_mode\",\n+\t    \"enable_external_access\",    // cant change this while db is running\n+\t    \"allow_unsigned_extensions\", // cant change this while db is running\n+\t    \"password\",\n+\t    \"username\",\n+\t    \"user\",\n+\t    \"profiling_output\", // just an alias\n+\t};\n+\treturn excluded_options.count(name) == 1;\n+}\n+\n+bool ValueEqual(const Value &left, const Value &right) {\n+\tif (left.IsNull() != right.IsNull()) {\n+\t\t// Only one is NULL\n+\t\treturn false;\n+\t}\n+\tif (!left.IsNull() && !right.IsNull()) {\n+\t\t// Neither are NULL\n+\t\treturn left == right;\n+\t}\n+\t// Both are NULL\n+\treturn true;\n+}\n+\n+void RequireValueDiff(ConfigurationOption *op, const Value &left, const Value &right, int line) {\n+\tif (!ValueEqual(left, right)) {\n+\t\treturn;\n+\t}\n+\tauto error = StringUtil::Format(\"\\nLINE[%d] (Option:%s) | Expected left:'%s' and right:'%s' to be different\", line,\n+\t                                op->name, left.ToString(), right.ToString());\n+\tcerr << error << endl;\n+\tREQUIRE(false);\n+}\n+\n+void RequireValueEqual(ConfigurationOption *op, const Value &left, const Value &right, int line) {\n+\tif (ValueEqual(left, right)) {\n+\t\treturn;\n+\t}\n+\tauto error = StringUtil::Format(\"\\nLINE[%d] (Option:%s) | Expected left:'%s' and right:'%s' to be equal\", line,\n+\t                                op->name, left.ToString(), right.ToString());\n+\tcerr << error << endl;\n+\tREQUIRE(false);\n+}\n+\n+//! New options should be added to the value_map in GetValueForOption\n+//! Or added to the 'excluded_options' in OptionIsExcludedFromTest\n+TEST_CASE(\"Test RESET statement for ClientConfig options\", \"[api]\") {\n+\n+\t// Create a connection\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\n+\tauto &config = DBConfig::GetConfig(*db.instance);\n+\t// Get all configuration options\n+\tauto options = config.GetOptions();\n+\n+\t// Test RESET for every option\n+\tfor (auto &option : options) {\n+\t\tif (OptionIsExcludedFromTest(option.name)) {\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tauto op = config.GetOptionByName(option.name);\n+\t\tREQUIRE(op);\n+\n+\t\t// Get the current value of the option\n+\t\tauto original_value = op->get_setting(*con.context);\n+\t\t// Get the new value for the option\n+\t\tauto &value_pair = GetValueForOption(option.name);\n+\n+\t\t// Verify that the new value is different, so we can test RESET\n+\t\tREQUIRE_VALUE_DIFF(op, original_value, value_pair.output);\n+\n+\t\tif (!op->set_global) {\n+\t\t\t// TODO: add testing for local (client-config) settings\n+\t\t\tcontinue;\n+\t\t}\n+\t\t// Set the new option\n+\t\top->set_global(db.instance.get(), config, value_pair.input);\n+\n+\t\t// Get the value of the option again\n+\t\tauto changed_value = op->get_setting(*con.context);\n+\t\tREQUIRE_VALUE_EQUAL(op, changed_value, value_pair.output);\n+\n+\t\top->reset_global(db.instance.get(), config);\n+\n+\t\t// Get the reset value of the option\n+\t\tauto reset_value = op->get_setting(*con.context);\n+\t\tREQUIRE_VALUE_EQUAL(op, reset_value, original_value);\n+\t}\n+}\ndiff --git a/test/sql/settings/reset/reset_threads.test b/test/sql/settings/reset/reset_threads.test\nnew file mode 100644\nindex 000000000000..129e9352014b\n--- /dev/null\n+++ b/test/sql/settings/reset/reset_threads.test\n@@ -0,0 +1,19 @@\n+# name: test/sql/settings/reset/reset_threads.test\n+# description: Test RESET setting for 'threads'\n+# group: [reset]\n+\n+# Check default value of threads\n+query I nosort default_value\n+select current_setting('threads')\n+----\n+\n+# Set the 'threads' setting to something else\n+statement ok\n+pragma threads=42\n+\n+statement ok\n+RESET threads;\n+\n+# Verify that the result is the same as the default\n+query I nosort default_value\n+select current_setting('threads')\n",
  "problem_statement": "How to unset an already SET configuration?\n### What happens?\r\n\r\nI am doing a wrapper around a duckdb client and I need to overwrite a setting and then putting it back to what the original client had.\r\n\r\npseudo code:\r\n```py\r\ntry:\r\n  old_s3_region = execute(\"SELECT current_setting('s3_region')\")\r\nraise:\r\n  # if it was not set originally\r\n  old_s3_region = None\r\n\r\nexecute(\"SET s3_region = 'my_temp_value'\")\r\n\r\n# reset it back\r\nif old_s3_region:\r\n  execute(f\"SET s3_region = '{old_s3_region}'\")\r\nelse:\r\n  # *** I don't know what to do here ***\r\n  execute(\"???\")\r\n```\r\n\r\nI tried\r\n\r\n```\r\nD set s3_region=null;\r\nError: Parser Error: syntax error at or near \"null\"\r\nLINE 1: set s3_region=null;\r\n```\r\n\r\n```\r\nD set s3_region=;\r\nError: Parser Error: syntax error at or near \";\"\r\nLINE 1: set s3_region=;\r\n```\r\n\r\n```\r\nD unset s3_region;\r\nError: Parser Error: syntax error at or near \"unset\"\r\nLINE 1: unset s3_region;\r\n``` \r\n\r\n### To Reproduce\r\n\r\nI have not installed master because this feature is not documented at all, so I guess it is not there.\r\nI know this is a bug report form, but I did not find where to add feature requests in [CONTRIBUTING](https://github.com/duckdb/duckdb/blob/master/CONTRIBUTING.md).\r\n\r\n### OS:\r\n\r\nmacos: Darwin 21.6.0 Darwin Kernel Version 21.6.0: Mon Aug 22 20:20:07 PDT 2022; root:xnu-8020.140.49~2/RELEASE_ARM64_T8110 arm64\r\n\r\n### DuckDB Version:\r\n\r\nv0.5.1 7c111322d\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nMatteo Ferrando\r\n\r\n### Affiliation:\r\n\r\nfal.ai\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "Hello! Installing from master is documented here:\r\nhttps://duckdb.org/docs/installation/\n> Hello! Installing from master is documented here: https://duckdb.org/docs/installation/\r\n\r\nI meant that the feature to `unset` is not documented at all, so I did not try on master because I did not think it would be there.\r\n\r\nEdited to reflect that.",
  "created_at": "2022-12-05T16:06:36Z"
}