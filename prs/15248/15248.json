{
  "repo": "duckdb/duckdb",
  "pull_number": 15248,
  "instance_id": "duckdb__duckdb-15248",
  "issue_numbers": [
    "15051",
    "15051"
  ],
  "base_commit": "82abc6a40de7ed102c86d12ed5ec09bfa207d559",
  "patch": "diff --git a/src/parser/transform/expression/transform_subquery.cpp b/src/parser/transform/expression/transform_subquery.cpp\nindex 9d93b54851ee..194ee5e1d4e8 100644\n--- a/src/parser/transform/expression/transform_subquery.cpp\n+++ b/src/parser/transform/expression/transform_subquery.cpp\n@@ -74,16 +74,30 @@ unique_ptr<ParsedExpression> Transformer::TransformSubquery(duckdb_libpgquery::P\n \tcase duckdb_libpgquery::PG_ARRAY_SUBLINK: {\n \t\t// ARRAY expression\n \t\t// wrap subquery into\n-\t\t// \"SELECT CASE WHEN ARRAY_AGG(COLUMNS(*)) IS NULL THEN [] ELSE ARRAY_AGG(COLUMNS(*)) END FROM (...) tbl\"\n+\t\t// \"SELECT CASE WHEN ARRAY_AGG(col) IS NULL THEN [] ELSE ARRAY_AGG(col) END FROM (...) tbl\"\n \t\tauto select_node = make_uniq<SelectNode>();\n \n-\t\t// COLUMNS(*)\n-\t\tauto columns_star = make_uniq<StarExpression>();\n-\t\tcolumns_star->columns = true;\n+\t\tunique_ptr<ParsedExpression> array_agg_child;\n+\t\toptional_ptr<SelectNode> sub_select;\n+\t\tif (subquery_expr->subquery->node->type == QueryNodeType::SELECT_NODE) {\n+\t\t\t// easy case - subquery is a SELECT\n+\t\t\tsub_select = subquery_expr->subquery->node->Cast<SelectNode>();\n+\t\t\tif (sub_select->select_list.size() != 1) {\n+\t\t\t\tthrow BinderException(*subquery_expr, \"Subquery returns %zu columns - expected 1\",\n+\t\t\t\t                      sub_select->select_list.size());\n+\t\t\t}\n+\t\t\tarray_agg_child = make_uniq<PositionalReferenceExpression>(1ULL);\n+\t\t} else {\n+\t\t\t// subquery is not a SELECT but a UNION or CTE\n+\t\t\t// we can still support this but it is more challenging since we can't push columns for the ORDER BY\n+\t\t\tauto columns_star = make_uniq<StarExpression>();\n+\t\t\tcolumns_star->columns = true;\n+\t\t\tarray_agg_child = std::move(columns_star);\n+\t\t}\n \n \t\t// ARRAY_AGG(COLUMNS(*))\n \t\tvector<unique_ptr<ParsedExpression>> children;\n-\t\tchildren.push_back(std::move(columns_star));\n+\t\tchildren.push_back(std::move(array_agg_child));\n \t\tauto aggr = make_uniq<FunctionExpression>(\"array_agg\", std::move(children));\n \t\t// push ORDER BY modifiers into the array_agg\n \t\tfor (auto &modifier : subquery_expr->subquery->node->modifiers) {\n@@ -104,7 +118,12 @@ unique_ptr<ParsedExpression> Transformer::TransformSubquery(duckdb_libpgquery::P\n \t\t\t\t\t\tidx_t positional_index = order_index < 0 ? NumericLimits<idx_t>::Maximum() : idx_t(order_index);\n \t\t\t\t\t\torder.expression = make_uniq<PositionalReferenceExpression>(positional_index);\n \t\t\t\t\t}\n+\t\t\t\t} else if (sub_select) {\n+\t\t\t\t\t// if we have a SELECT we can push the ORDER BY clause into the SELECT list and reference it\n+\t\t\t\t\tsub_select->select_list.push_back(std::move(order.expression));\n+\t\t\t\t\torder.expression = make_uniq<PositionalReferenceExpression>(sub_select->select_list.size() - 1);\n \t\t\t\t} else {\n+\t\t\t\t\t// otherwise we remove order qualifications\n \t\t\t\t\tRemoveOrderQualificationRecursive(order.expression);\n \t\t\t\t}\n \t\t\t}\n",
  "test_patch": "diff --git a/test/sql/subquery/scalar/array_order_subquery.test b/test/sql/subquery/scalar/array_order_subquery.test\nindex 6e1f36f7e086..a0ca2fb4c7d0 100644\n--- a/test/sql/subquery/scalar/array_order_subquery.test\n+++ b/test/sql/subquery/scalar/array_order_subquery.test\n@@ -36,6 +36,18 @@ select array(select unnest(l) AS i order by i desc nulls first) as a from (value\n []\n [12, 11, 10]\n \n+# row id\n+query I\n+SELECT ARRAY(SELECT i FROM t ORDER BY rowid DESC)\n+----\n+[4, 4, 3, 2, 1]\n+\n+# qualified name\n+query I\n+SELECT ARRAY(SELECT i FROM t ORDER BY t.rowid)\n+----\n+[1, 2, 3, 4, 4]\n+\n # use integer literals\n query I\n SELECT ARRAY\n",
  "problem_statement": "Cannot use `rowid` or `row_number() OVER ()` in `ARRAY`\n### What happens?\r\n\r\nIt isn't possible to use the `rowid` pseudo-column or a `row_number()` window function to work  around the fact that the `ARRAY` operator doesn't preserve order (see https://github.com/duckdb/duckdb/issues/15011).\r\n\r\n### To Reproduce\r\n\r\n```sql\r\nCREATE OR REPLACE TABLE df AS (\r\n    FROM range(1_000_000) SELECT range AS x\r\n);\r\n```\r\nThen\r\n\r\n```sql\r\nSELECT ARRAY(FROM df SELECT x ORDER BY row_number() OVER ());\r\n```\r\n```\r\nBinderException: Binder Error: aggregate function calls cannot contain window function calls\r\n```\r\n\r\n```sql\r\nSELECT ARRAY(FROM df SELECT x ORDER BY rowid);\r\n```\r\n```\r\nBinderException: Binder Error: Referenced column \"rowid\" not found in FROM clause!\r\nCandidate bindings: \"unnamed_subquery.x\"\r\n```\r\n\r\nDespite both queries within the `ARRAY` operator working on their own:\r\n\r\n```sql\r\nFROM df SELECT x ORDER BY rowid;\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502           x            \u2502\r\n\u2502         int64          \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502                      0 \u2502\r\n\u2502                      1 \u2502\r\n\u2502                      2 \u2502\r\n\u2502                      3 \u2502\r\n\u2502                      4 \u2502\r\n\u2502                      5 \u2502\r\n\u2502                      6 \u2502\r\n\u2502                      7 \u2502\r\n\u2502                      8 \u2502\r\n\u2502                      9 \u2502\r\n\u2502                      \u00b7 \u2502\r\n\u2502                      \u00b7 \u2502\r\n```\r\n\r\nand \r\n\r\n```sql\r\nFROM df SELECT x ORDER BY row_number() OVER ()\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502           x            \u2502\r\n\u2502         int64          \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502                      0 \u2502\r\n\u2502                      1 \u2502\r\n\u2502                      2 \u2502\r\n\u2502                      3 \u2502\r\n\u2502                      4 \u2502\r\n\u2502                      5 \u2502\r\n\u2502                      6 \u2502\r\n\u2502                      7 \u2502\r\n\u2502                      8 \u2502\r\n\u2502                      9 \u2502\r\n\u2502                      \u00b7 \u2502\r\n```\r\n\r\n\r\nPS:\r\n\r\nIt is possible to workaround all of this via\r\n\r\n```sql\r\nSELECT ARRAY(SELECT x FROM (SELECT x FROM df ORDER BY row_number() OVER ()));\r\n```\r\n\r\nbut I don't understand why (if `ARRAY` generally preserved order, I wouldn't have this problem to begin with, so why does it preserve the order from within a nested subquery?)\r\nand confusingly it's not possible to use the seemingly equivalent\r\n\r\n\r\n```sql\r\nSELECT ARRAY(SELECT x FROM (SELECT x FROM df ORDER BY rowid));\r\n```\r\n\r\nI've opened a separate issue about this (#15052).\r\n\r\n\r\n### OS:\r\n\r\nLinux\r\n\r\n### DuckDB Version:\r\n\r\n1.1.0\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Hardware:\r\n\r\ni5, x64\r\n\r\n### Full Name:\r\n\r\nSoeren Wolfers\r\n\r\n### Affiliation:\r\n\r\nG-Research\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNot applicable - the reproduction does not require a data set\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\nCannot use `rowid` or `row_number() OVER ()` in `ARRAY`\n### What happens?\r\n\r\nIt isn't possible to use the `rowid` pseudo-column or a `row_number()` window function to work  around the fact that the `ARRAY` operator doesn't preserve order (see https://github.com/duckdb/duckdb/issues/15011).\r\n\r\n### To Reproduce\r\n\r\n```sql\r\nCREATE OR REPLACE TABLE df AS (\r\n    FROM range(1_000_000) SELECT range AS x\r\n);\r\n```\r\nThen\r\n\r\n```sql\r\nSELECT ARRAY(FROM df SELECT x ORDER BY row_number() OVER ());\r\n```\r\n```\r\nBinderException: Binder Error: aggregate function calls cannot contain window function calls\r\n```\r\n\r\n```sql\r\nSELECT ARRAY(FROM df SELECT x ORDER BY rowid);\r\n```\r\n```\r\nBinderException: Binder Error: Referenced column \"rowid\" not found in FROM clause!\r\nCandidate bindings: \"unnamed_subquery.x\"\r\n```\r\n\r\nDespite both queries within the `ARRAY` operator working on their own:\r\n\r\n```sql\r\nFROM df SELECT x ORDER BY rowid;\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502           x            \u2502\r\n\u2502         int64          \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502                      0 \u2502\r\n\u2502                      1 \u2502\r\n\u2502                      2 \u2502\r\n\u2502                      3 \u2502\r\n\u2502                      4 \u2502\r\n\u2502                      5 \u2502\r\n\u2502                      6 \u2502\r\n\u2502                      7 \u2502\r\n\u2502                      8 \u2502\r\n\u2502                      9 \u2502\r\n\u2502                      \u00b7 \u2502\r\n\u2502                      \u00b7 \u2502\r\n```\r\n\r\nand \r\n\r\n```sql\r\nFROM df SELECT x ORDER BY row_number() OVER ()\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502           x            \u2502\r\n\u2502         int64          \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502                      0 \u2502\r\n\u2502                      1 \u2502\r\n\u2502                      2 \u2502\r\n\u2502                      3 \u2502\r\n\u2502                      4 \u2502\r\n\u2502                      5 \u2502\r\n\u2502                      6 \u2502\r\n\u2502                      7 \u2502\r\n\u2502                      8 \u2502\r\n\u2502                      9 \u2502\r\n\u2502                      \u00b7 \u2502\r\n```\r\n\r\n\r\nPS:\r\n\r\nIt is possible to workaround all of this via\r\n\r\n```sql\r\nSELECT ARRAY(SELECT x FROM (SELECT x FROM df ORDER BY row_number() OVER ()));\r\n```\r\n\r\nbut I don't understand why (if `ARRAY` generally preserved order, I wouldn't have this problem to begin with, so why does it preserve the order from within a nested subquery?)\r\nand confusingly it's not possible to use the seemingly equivalent\r\n\r\n\r\n```sql\r\nSELECT ARRAY(SELECT x FROM (SELECT x FROM df ORDER BY rowid));\r\n```\r\n\r\nI've opened a separate issue about this (#15052).\r\n\r\n\r\n### OS:\r\n\r\nLinux\r\n\r\n### DuckDB Version:\r\n\r\n1.1.0\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Hardware:\r\n\r\ni5, x64\r\n\r\n### Full Name:\r\n\r\nSoeren Wolfers\r\n\r\n### Affiliation:\r\n\r\nG-Research\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNot applicable - the reproduction does not require a data set\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "\n",
  "created_at": "2024-12-10T15:10:58Z"
}