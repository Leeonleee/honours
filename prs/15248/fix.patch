diff --git a/src/parser/transform/expression/transform_subquery.cpp b/src/parser/transform/expression/transform_subquery.cpp
index 9d93b54851ee..194ee5e1d4e8 100644
--- a/src/parser/transform/expression/transform_subquery.cpp
+++ b/src/parser/transform/expression/transform_subquery.cpp
@@ -74,16 +74,30 @@ unique_ptr<ParsedExpression> Transformer::TransformSubquery(duckdb_libpgquery::P
 	case duckdb_libpgquery::PG_ARRAY_SUBLINK: {
 		// ARRAY expression
 		// wrap subquery into
-		// "SELECT CASE WHEN ARRAY_AGG(COLUMNS(*)) IS NULL THEN [] ELSE ARRAY_AGG(COLUMNS(*)) END FROM (...) tbl"
+		// "SELECT CASE WHEN ARRAY_AGG(col) IS NULL THEN [] ELSE ARRAY_AGG(col) END FROM (...) tbl"
 		auto select_node = make_uniq<SelectNode>();
 
-		// COLUMNS(*)
-		auto columns_star = make_uniq<StarExpression>();
-		columns_star->columns = true;
+		unique_ptr<ParsedExpression> array_agg_child;
+		optional_ptr<SelectNode> sub_select;
+		if (subquery_expr->subquery->node->type == QueryNodeType::SELECT_NODE) {
+			// easy case - subquery is a SELECT
+			sub_select = subquery_expr->subquery->node->Cast<SelectNode>();
+			if (sub_select->select_list.size() != 1) {
+				throw BinderException(*subquery_expr, "Subquery returns %zu columns - expected 1",
+				                      sub_select->select_list.size());
+			}
+			array_agg_child = make_uniq<PositionalReferenceExpression>(1ULL);
+		} else {
+			// subquery is not a SELECT but a UNION or CTE
+			// we can still support this but it is more challenging since we can't push columns for the ORDER BY
+			auto columns_star = make_uniq<StarExpression>();
+			columns_star->columns = true;
+			array_agg_child = std::move(columns_star);
+		}
 
 		// ARRAY_AGG(COLUMNS(*))
 		vector<unique_ptr<ParsedExpression>> children;
-		children.push_back(std::move(columns_star));
+		children.push_back(std::move(array_agg_child));
 		auto aggr = make_uniq<FunctionExpression>("array_agg", std::move(children));
 		// push ORDER BY modifiers into the array_agg
 		for (auto &modifier : subquery_expr->subquery->node->modifiers) {
@@ -104,7 +118,12 @@ unique_ptr<ParsedExpression> Transformer::TransformSubquery(duckdb_libpgquery::P
 						idx_t positional_index = order_index < 0 ? NumericLimits<idx_t>::Maximum() : idx_t(order_index);
 						order.expression = make_uniq<PositionalReferenceExpression>(positional_index);
 					}
+				} else if (sub_select) {
+					// if we have a SELECT we can push the ORDER BY clause into the SELECT list and reference it
+					sub_select->select_list.push_back(std::move(order.expression));
+					order.expression = make_uniq<PositionalReferenceExpression>(sub_select->select_list.size() - 1);
 				} else {
+					// otherwise we remove order qualifications
 					RemoveOrderQualificationRecursive(order.expression);
 				}
 			}
