You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Joining 3 arrow tables
If I have 3 pandas dataframes I can register 3 dataframes and can write execute sql to join all 3 tables and thinking of how to do the same with arrow table.
Example for pandas
db= duckdb.connect(database=":memory:")
db.register("a",dataframe_a)
db.register("b",dataframe_b)
db.register("c",dataframe_c)
db.execute("select * from a inner join b on a.col1=b.col1 inner join c on b.col2=c.col1").arrow()

I see duckdb.from_arrow_table but it seems Ilike standalone table unlike  pandas dataframe

</issue>
<code>
[start of README.md]
1: <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
2: 
3: ![.github/workflows/main.yml](https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master)
4: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
5: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
6: 
7: 
8: ## Installation
9: If you just want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
10: 
11: ## Development
12: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
13: 
14: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
15: 
16: 
[end of README.md]
[start of src/catalog/catalog_entry/view_catalog_entry.cpp]
1: #include "duckdb/catalog/catalog_entry/view_catalog_entry.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
4: #include "duckdb/common/exception.hpp"
5: #include "duckdb/common/serializer.hpp"
6: #include "duckdb/parser/parsed_data/alter_table_info.hpp"
7: #include "duckdb/parser/parsed_data/create_view_info.hpp"
8: #include "duckdb/common/limits.hpp"
9: 
10: #include <algorithm>
11: 
12: namespace duckdb {
13: 
14: void ViewCatalogEntry::Initialize(CreateViewInfo *info) {
15: 	query = move(info->query);
16: 	this->aliases = info->aliases;
17: 	this->types = info->types;
18: 	this->temporary = info->temporary;
19: 	this->sql = info->sql;
20: 	this->internal = info->internal;
21: }
22: 
23: ViewCatalogEntry::ViewCatalogEntry(Catalog *catalog, SchemaCatalogEntry *schema, CreateViewInfo *info)
24:     : StandardEntry(CatalogType::VIEW_ENTRY, schema, catalog, info->view_name) {
25: 	Initialize(info);
26: }
27: 
28: unique_ptr<CatalogEntry> ViewCatalogEntry::AlterEntry(ClientContext &context, AlterInfo *info) {
29: 	if (internal) {
30: 		throw CatalogException("Cannot use ALTER VIEW to alter a system view");
31: 	}
32: 	if (info->type != AlterType::ALTER_VIEW) {
33: 		throw CatalogException("Can only modify view with ALTER VIEW statement");
34: 	}
35: 	auto view_info = (AlterViewInfo *)info;
36: 	switch (view_info->alter_view_type) {
37: 	case AlterViewType::RENAME_VIEW: {
38: 		auto rename_info = (RenameViewInfo *)view_info;
39: 		auto copied_view = Copy(context);
40: 		copied_view->name = rename_info->new_view_name;
41: 		return copied_view;
42: 	}
43: 	default:
44: 		throw InternalException("Unrecognized alter view type!");
45: 	}
46: }
47: 
48: void ViewCatalogEntry::Serialize(Serializer &serializer) {
49: 	D_ASSERT(!internal);
50: 	serializer.WriteString(schema->name);
51: 	serializer.WriteString(name);
52: 	serializer.WriteString(sql);
53: 	query->Serialize(serializer);
54: 	D_ASSERT(aliases.size() <= NumericLimits<uint32_t>::Maximum());
55: 	serializer.Write<uint32_t>((uint32_t)aliases.size());
56: 	for (auto &alias : aliases) {
57: 		serializer.WriteString(alias);
58: 	}
59: 	serializer.Write<uint32_t>((uint32_t)types.size());
60: 	for (auto &sql_type : types) {
61: 		sql_type.Serialize(serializer);
62: 	}
63: }
64: 
65: unique_ptr<CreateViewInfo> ViewCatalogEntry::Deserialize(Deserializer &source) {
66: 	auto info = make_unique<CreateViewInfo>();
67: 	info->schema = source.Read<string>();
68: 	info->view_name = source.Read<string>();
69: 	info->sql = source.Read<string>();
70: 	info->query = SelectStatement::Deserialize(source);
71: 	auto alias_count = source.Read<uint32_t>();
72: 	for (uint32_t i = 0; i < alias_count; i++) {
73: 		info->aliases.push_back(source.Read<string>());
74: 	}
75: 	auto type_count = source.Read<uint32_t>();
76: 	for (uint32_t i = 0; i < type_count; i++) {
77: 		info->types.push_back(LogicalType::Deserialize(source));
78: 	}
79: 	return info;
80: }
81: 
82: string ViewCatalogEntry::ToSQL() {
83: 	if (sql.empty()) {
84: 		throw NotImplementedException("Cannot convert VIEW to SQL because it was not created with a SQL statement");
85: 	}
86: 	return sql + "\n;";
87: }
88: 
89: unique_ptr<CatalogEntry> ViewCatalogEntry::Copy(ClientContext &context) {
90: 	D_ASSERT(!internal);
91: 	auto create_info = make_unique<CreateViewInfo>(schema->name, name);
92: 	create_info->query = unique_ptr_cast<SQLStatement, SelectStatement>(query->Copy());
93: 	for (idx_t i = 0; i < aliases.size(); i++) {
94: 		create_info->aliases.push_back(aliases[i]);
95: 	}
96: 	for (idx_t i = 0; i < types.size(); i++) {
97: 		create_info->types.push_back(types[i]);
98: 	}
99: 	create_info->temporary = temporary;
100: 	create_info->sql = sql;
101: 
102: 	return make_unique<ViewCatalogEntry>(catalog, schema, create_info.get());
103: }
104: 
105: } // namespace duckdb
[end of src/catalog/catalog_entry/view_catalog_entry.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: