diff --git a/src/catalog/catalog_entry/macro_catalog_entry.cpp b/src/catalog/catalog_entry/macro_catalog_entry.cpp
index f888221b3a71..3bd003aa76a6 100644
--- a/src/catalog/catalog_entry/macro_catalog_entry.cpp
+++ b/src/catalog/catalog_entry/macro_catalog_entry.cpp
@@ -4,7 +4,14 @@
 
 namespace duckdb {
 
+MacroCatalogEntry::MacroCatalogEntry(Catalog *catalog, SchemaCatalogEntry *schema, CreateMacroInfo *info)
+    : StandardEntry(CatalogType::MACRO_ENTRY, schema, catalog, info->name), function(move(info->function)) {
+	this->temporary = info->temporary;
+	this->internal = info->internal;
+}
+
 void MacroCatalogEntry::Serialize(Serializer &serializer) {
+	D_ASSERT(!internal);
 	serializer.WriteString(schema->name);
 	serializer.WriteString(name);
 	function->expression->Serialize(serializer);
diff --git a/src/catalog/catalog_entry/table_catalog_entry.cpp b/src/catalog/catalog_entry/table_catalog_entry.cpp
index 9f14bdf2d102..1f8d94006599 100644
--- a/src/catalog/catalog_entry/table_catalog_entry.cpp
+++ b/src/catalog/catalog_entry/table_catalog_entry.cpp
@@ -400,6 +400,7 @@ vector<LogicalType> TableCatalogEntry::GetTypes() {
 }
 
 void TableCatalogEntry::Serialize(Serializer &serializer) {
+	D_ASSERT(!internal);
 	serializer.WriteString(schema->name);
 	serializer.WriteString(name);
 	D_ASSERT(columns.size() <= NumericLimits<uint32_t>::Maximum());
diff --git a/src/include/duckdb/catalog/catalog_entry/macro_catalog_entry.hpp b/src/include/duckdb/catalog/catalog_entry/macro_catalog_entry.hpp
index 2386a1eee624..0d02a71ebb87 100644
--- a/src/include/duckdb/catalog/catalog_entry/macro_catalog_entry.hpp
+++ b/src/include/duckdb/catalog/catalog_entry/macro_catalog_entry.hpp
@@ -18,9 +18,7 @@ namespace duckdb {
 //! A macro function in the catalog
 class MacroCatalogEntry : public StandardEntry {
 public:
-	MacroCatalogEntry(Catalog *catalog, SchemaCatalogEntry *schema, CreateMacroInfo *info)
-	    : StandardEntry(CatalogType::MACRO_ENTRY, schema, catalog, info->name), function(move(info->function)) {
-	}
+	MacroCatalogEntry(Catalog *catalog, SchemaCatalogEntry *schema, CreateMacroInfo *info);
 
 	//! The macro function
 	unique_ptr<MacroFunction> function;
diff --git a/src/storage/checkpoint_manager.cpp b/src/storage/checkpoint_manager.cpp
index 537456e7d559..6ac5220d21d0 100644
--- a/src/storage/checkpoint_manager.cpp
+++ b/src/storage/checkpoint_manager.cpp
@@ -131,6 +131,9 @@ void CheckpointManager::WriteSchema(SchemaCatalogEntry &schema) {
 	vector<TableCatalogEntry *> tables;
 	vector<ViewCatalogEntry *> views;
 	schema.Scan(CatalogType::TABLE_ENTRY, [&](CatalogEntry *entry) {
+		if (entry->internal) {
+			return;
+		}
 		if (entry->type == CatalogType::TABLE_ENTRY) {
 			tables.push_back((TableCatalogEntry *)entry);
 		} else if (entry->type == CatalogType::VIEW_ENTRY) {
@@ -140,11 +143,16 @@ void CheckpointManager::WriteSchema(SchemaCatalogEntry &schema) {
 		}
 	});
 	vector<SequenceCatalogEntry *> sequences;
-	schema.Scan(CatalogType::SEQUENCE_ENTRY,
-	            [&](CatalogEntry *entry) { sequences.push_back((SequenceCatalogEntry *)entry); });
+	schema.Scan(CatalogType::SEQUENCE_ENTRY, [&](CatalogEntry *entry) {
+		D_ASSERT(!entry->internal);
+		sequences.push_back((SequenceCatalogEntry *)entry);
+	});
 
 	vector<MacroCatalogEntry *> macros;
 	schema.Scan(CatalogType::SCALAR_FUNCTION_ENTRY, [&](CatalogEntry *entry) {
+		if (entry->internal) {
+			return;
+		}
 		if (entry->type == CatalogType::MACRO_ENTRY) {
 			macros.push_back((MacroCatalogEntry *)entry);
 		}
