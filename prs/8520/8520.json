{
  "repo": "duckdb/duckdb",
  "pull_number": 8520,
  "instance_id": "duckdb__duckdb-8520",
  "issue_numbers": [
    "3170",
    "3170"
  ],
  "base_commit": "acbbfe0e79fdfef712a8dc317af407c12006814f",
  "patch": "diff --git a/src/storage/table/update_segment.cpp b/src/storage/table/update_segment.cpp\nindex 3c342d611625..125906e1cc77 100644\n--- a/src/storage/table/update_segment.cpp\n+++ b/src/storage/table/update_segment.cpp\n@@ -427,7 +427,7 @@ void UpdateSegment::FetchRow(TransactionData transaction, idx_t row_id, Vector &\n \tif (!root->info[vector_index]) {\n \t\treturn;\n \t}\n-\tidx_t row_in_vector = row_id - vector_index * STANDARD_VECTOR_SIZE;\n+\tidx_t row_in_vector = (row_id - column_data.start) - vector_index * STANDARD_VECTOR_SIZE;\n \tfetch_row_function(transaction.start_time, transaction.transaction_id, root->info[vector_index]->info.get(),\n \t                   row_in_vector, result, result_idx);\n }\n",
  "test_patch": "diff --git a/test/sql/update/test_update_issue_3170.test b/test/sql/update/test_update_issue_3170.test\nnew file mode 100644\nindex 000000000000..12b8ea50cfe5\n--- /dev/null\n+++ b/test/sql/update/test_update_issue_3170.test\n@@ -0,0 +1,110 @@\n+# name: test/sql/update/test_update_issue_3170.test\n+# description: Update indexed table rows with large row_id ( > 122879) which cross the first segment/row_group.\n+# group: [update]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# create a table\n+statement ok\n+CREATE TABLE student(id INTEGER,name VARCHAR,PRIMARY KEY(id));\n+\n+statement ok\n+INSERT INTO student SELECT i, 'creator' FROM RANGE(260001) tbl(i)\n+\n+# read\n+# rowgroup 0\n+query I\n+SELECT name FROM student WHERE id = 122879\n+----\n+creator\n+\n+# rowgroup 1\n+query I\n+SELECT name FROM student WHERE id = 122881\n+----\n+creator\n+\n+# rowgroup 2\n+query I\n+SELECT name FROM student WHERE id = 245780\n+----\n+creator\n+\n+# rowgroup 1 vector > 0\n+query I\n+SELECT name FROM student WHERE id = 150881\n+----\n+creator\n+\n+# Update\n+# rowgroup 0\n+statement ok\n+UPDATE student SET name = 'updator0' WHERE id = 122879\n+\n+# rowgroup 1\n+statement ok\n+UPDATE student SET name = 'updator1' WHERE id = 122881\n+\n+# rowgroup 2 \n+statement ok\n+UPDATE student SET name = 'updator2' WHERE id = 245780\n+\n+# rowgroup 1 vector > 0\n+statement ok\n+UPDATE student SET name = 'updator3' WHERE id = 150881\n+\n+\n+# read again\n+# rowgroup 0\n+query I\n+SELECT name FROM student WHERE id = 122879\n+----\n+updator0\n+\n+# rowgroup 1\n+query I\n+SELECT name FROM student WHERE id = 122881\n+----\n+updator1\n+\n+# rowgroup 2\n+query I\n+SELECT name FROM student WHERE id = 245780\n+----\n+updator2\n+\n+# rowgroup 1 vector > 0\n+query I\n+SELECT name FROM student WHERE id = 150881\n+----\n+updator3\n+\n+# original issue\n+load __TEST_DIR__/list_index_compression.db\n+\n+statement ok\n+CREATE TABLE student(id INTEGER,name VARCHAR,PRIMARY KEY(id));\n+\n+statement ok\n+insert into student select i, 'creator' from range(130001) tbl(i);\n+\n+query II\n+select id, name from student where id=122881;\n+----\n+122881\tcreator\n+\n+statement ok\n+update student set name = 'updator' where id = 122881;\n+\n+query II\n+select id, name from student where id=122881;\n+----\n+122881\tupdator\n+\n+restart\n+\n+query II\n+select id, name from student where id=122881;\n+----\n+122881\tupdator\n",
  "problem_statement": "update error\n#### What happens?\r\nwhen id bigger than 122880 update successful but get older value.\r\n\r\n#### To Reproduce\r\n`@Test \r\n   public void duckDBUpdateFailTest() throws SQLException { \r\n\r\n       try (DuckDBConnection conn = (DuckDBConnection) DriverManager.getConnection(\"jdbc:duckdb:\")) { \r\n           Statement stmt = conn.createStatement(); \r\n           stmt.execute(\"CREATE SCHEMA IF NOT EXISTS mydb\"); \r\n           stmt.execute(\"CREATE TABLE IF NOT EXISTS mydb.student(id INTEGER,name VARCHAR,PRIMARY KEY(id))\"); \r\n           DuckDBAppender appender = conn.createAppender(\"mydb\", \"student\"); \r\n           for (int i = 0; i < 130001; i++) { \r\n               appender.beginRow(); \r\n               appender.append(i); \r\n               appender.append(\"creator\"); \r\n               appender.endRow(); \r\n               if (i % 10000 == 0) { \r\n                   appender.flush(); \r\n               } \r\n           } \r\n           appender.close(); \r\n\r\n           int id = 122881; \r\n           System.out.println(\"=================id=\" + id + \"===================\"); \r\n           String selectSql = \"select * from mydb.student where id = %d\"; \r\n           ResultSet rs = stmt.executeQuery(String.format(selectSql, id)); \r\n           System.out.println(\"=================before update===================\"); \r\n           while (rs.next()) { \r\n               for (int i = 1; i <= rs.getMetaData().getColumnCount(); i++) { \r\n                   System.out.print(rs.getObject(i)); \r\n                   System.out.print(\"\\t\"); \r\n               } \r\n           } \r\n\r\n           //update \r\n           System.out.println(\"\\n\"); \r\n           System.out.println(\"update mydb.student set name = updator where id = \" + id); \r\n           String upadteSql = \"update mydb.student set name = ? where id = ?\"; \r\n           PreparedStatement updateStmt = conn.prepareStatement(upadteSql); \r\n           updateStmt.setObject(1, \"updator\"); \r\n           updateStmt.setObject(2, id); \r\n           int updateResult = updateStmt.executeUpdate(); \r\n           System.out.println(\"\\n\"); \r\n           System.out.println(\"==============update result:\" + updateResult); \r\n           //update \r\n           rs = stmt.executeQuery(String.format(selectSql, id)); \r\n           System.out.println(\"=================after update===================\"); \r\n           while (rs.next()) { \r\n               for (int i = 1; i <= rs.getMetaData().getColumnCount(); i++) { \r\n                   System.out.print(rs.getObject(i)); \r\n                   System.out.print(\"\\t\"); \r\n               } \r\n           } \r\n       } \r\n\r\n\r\n   }\r\n=================id=122881===================\r\n=================before update=================== \r\n122881     creator      \r\n\r\nupdate mydb.student set name = updator where id = 122881 \r\n\r\n\r\n==============update result:1 \r\n=================after update=================== \r\n122881     creator\r\n\r\n=================id=122879===================\r\n=================before update=================== \r\n122879     creator      \r\n\r\nupdate mydb.student set name = updator where id = 122879 \r\n\r\n\r\n==============update result:1 \r\n=================after update=================== \r\n122879     updator      \r\n      \r\n\r\n`\r\n\r\n#### Environment (please complete the following information):\r\n - OS: windows\r\n - DuckDB Version: 0.3.1\r\n - DuckDB Client: jdbc 0.3.1\r\n\r\n\nupdate error\n#### What happens?\r\nwhen id bigger than 122880 update successful but get older value.\r\n\r\n#### To Reproduce\r\n`@Test \r\n   public void duckDBUpdateFailTest() throws SQLException { \r\n\r\n       try (DuckDBConnection conn = (DuckDBConnection) DriverManager.getConnection(\"jdbc:duckdb:\")) { \r\n           Statement stmt = conn.createStatement(); \r\n           stmt.execute(\"CREATE SCHEMA IF NOT EXISTS mydb\"); \r\n           stmt.execute(\"CREATE TABLE IF NOT EXISTS mydb.student(id INTEGER,name VARCHAR,PRIMARY KEY(id))\"); \r\n           DuckDBAppender appender = conn.createAppender(\"mydb\", \"student\"); \r\n           for (int i = 0; i < 130001; i++) { \r\n               appender.beginRow(); \r\n               appender.append(i); \r\n               appender.append(\"creator\"); \r\n               appender.endRow(); \r\n               if (i % 10000 == 0) { \r\n                   appender.flush(); \r\n               } \r\n           } \r\n           appender.close(); \r\n\r\n           int id = 122881; \r\n           System.out.println(\"=================id=\" + id + \"===================\"); \r\n           String selectSql = \"select * from mydb.student where id = %d\"; \r\n           ResultSet rs = stmt.executeQuery(String.format(selectSql, id)); \r\n           System.out.println(\"=================before update===================\"); \r\n           while (rs.next()) { \r\n               for (int i = 1; i <= rs.getMetaData().getColumnCount(); i++) { \r\n                   System.out.print(rs.getObject(i)); \r\n                   System.out.print(\"\\t\"); \r\n               } \r\n           } \r\n\r\n           //update \r\n           System.out.println(\"\\n\"); \r\n           System.out.println(\"update mydb.student set name = updator where id = \" + id); \r\n           String upadteSql = \"update mydb.student set name = ? where id = ?\"; \r\n           PreparedStatement updateStmt = conn.prepareStatement(upadteSql); \r\n           updateStmt.setObject(1, \"updator\"); \r\n           updateStmt.setObject(2, id); \r\n           int updateResult = updateStmt.executeUpdate(); \r\n           System.out.println(\"\\n\"); \r\n           System.out.println(\"==============update result:\" + updateResult); \r\n           //update \r\n           rs = stmt.executeQuery(String.format(selectSql, id)); \r\n           System.out.println(\"=================after update===================\"); \r\n           while (rs.next()) { \r\n               for (int i = 1; i <= rs.getMetaData().getColumnCount(); i++) { \r\n                   System.out.print(rs.getObject(i)); \r\n                   System.out.print(\"\\t\"); \r\n               } \r\n           } \r\n       } \r\n\r\n\r\n   }\r\n=================id=122881===================\r\n=================before update=================== \r\n122881     creator      \r\n\r\nupdate mydb.student set name = updator where id = 122881 \r\n\r\n\r\n==============update result:1 \r\n=================after update=================== \r\n122881     creator\r\n\r\n=================id=122879===================\r\n=================before update=================== \r\n122879     creator      \r\n\r\nupdate mydb.student set name = updator where id = 122879 \r\n\r\n\r\n==============update result:1 \r\n=================after update=================== \r\n122879     updator      \r\n      \r\n\r\n`\r\n\r\n#### Environment (please complete the following information):\r\n - OS: windows\r\n - DuckDB Version: 0.3.1\r\n - DuckDB Client: jdbc 0.3.1\r\n\r\n\n",
  "hints_text": "Thanks for the report! I can confirm there is a bug here. It seems to be related to the primary key index.\r\n\r\nThis does not work (bug)\r\n```sql\r\nCREATE SCHEMA IF NOT EXISTS mydb;\r\nCREATE TABLE IF NOT EXISTS mydb.student(id INTEGER,name VARCHAR,PRIMARY KEY(id));\r\ninsert into mydb.student select i, 'creator' from range(130001) tbl(i);\r\nselect * from mydb.student where id=122881;\r\n-- \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n-- \u2502   id   \u2502  name   \u2502\r\n-- \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n-- \u2502 122881 \u2502 creator \u2502\r\n-- \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nupdate mydb.student set name = 'updator' where id = 122881;\r\nselect * from mydb.student where id=122881;\r\n-- \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n-- \u2502   id   \u2502  name   \u2502\r\n-- \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n-- \u2502 122881 \u2502 creator \u2502\r\n-- \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nWithout the primary key index, this works as expected:\r\n\r\n```sql\r\n\r\nCREATE SCHEMA IF NOT EXISTS mydb;\r\nCREATE TABLE IF NOT EXISTS mydb.student(id INTEGER,name VARCHAR);\r\ninsert into mydb.student select i, 'creator' from range(130001) tbl(i);\r\nselect * from mydb.student where id=122881;\r\n-- \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n-- \u2502   id   \u2502  name   \u2502\r\n-- \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n-- \u2502 122881 \u2502 creator \u2502\r\n-- \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nupdate mydb.student set name = 'updator' where id = 122881;\r\nselect * from mydb.student where id=122881;\r\n-- \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n-- \u2502   id   \u2502  name   \u2502\r\n-- \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n-- \u2502 122881 \u2502 updator \u2502\r\n-- \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\nThis behavior is still the case. I had a go at attempting to fix it and found that the fix won't be trivial and is related to our [known index limitations](https://duckdb.org/docs/sql/indexes#index-limitations).\r\n\r\nIf an update touches any indexed columns, then we rewrite it into an insert + delete. In this case, **the update does not touch the indexed column**, so we perform a normal update. By performing a normal update we do not alter the ART. In a subsequent index scan, we then retrieve the old row ID from the ART, which points to the row that was deleted during the update, and which still contains the old value. Without the index scan, we retrieve the new value. We actually have some tests in DuckDB that should also fail, but mask this behavior by not performing an index scan, for example `test/sql/update/update_delete_wal.test`.\r\n\r\nAlso, when restarting the database, the ART is valid again (see SQL below).\r\n\r\nI had an initial go at fixing this by simply rewriting any update that touches an indexed table into an insert + delete. However, with this change, we then hit our problem of a over-eager constraint evaluation, because the key does not change during these updates. Maybe, another possible solution is to create a mapping containing `[key - old_row_id - new_row_id]` and using that to update the ART, since the keys themselve do not change (we do not touch the indexed columns)...\r\n\r\n```sql\r\nbuild/release/duckdb testdb  \r\nv0.1.1-dev26304 0d946c04df\r\nEnter \".help\" for usage hints.\r\nD CREATE SCHEMA IF NOT EXISTS mydb;\r\nD CREATE TABLE IF NOT EXISTS mydb.student(id INTEGER,name VARCHAR,PRIMARY KEY(id));\r\nD insert into mydb.student select i, 'creator' from range(130001) tbl(i);\r\nD select * from mydb.student where id=122881;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   id   \u2502  name   \u2502\r\n\u2502 int32  \u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 122881 \u2502 creator \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nD update mydb.student set name = 'updator' where id = 122881;\r\nD select rowid, * from mydb.student where id=122881;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 rowid  \u2502   id   \u2502  name   \u2502\r\n\u2502 int64  \u2502 int32  \u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 122881 \u2502 122881 \u2502 creator \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nD .q\r\nbuild/release/duckdb testdb\r\nv0.1.1-dev26304 0d946c04df\r\nEnter \".help\" for usage hints.\r\nD select rowid, * from mydb.student where id=122881;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 rowid  \u2502   id   \u2502  name   \u2502\r\n\u2502 int64  \u2502 int32  \u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 122881 \u2502 122881 \u2502 updator \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nI added this issue to our list of issues addressing our [known index limitations](https://duckdb.org/docs/sql/indexes#index-limitations). I will close it as of now, as it is the intended behavior, and fixing this properly is not trivial.\nThanks for the report! I can confirm there is a bug here. It seems to be related to the primary key index.\r\n\r\nThis does not work (bug)\r\n```sql\r\nCREATE SCHEMA IF NOT EXISTS mydb;\r\nCREATE TABLE IF NOT EXISTS mydb.student(id INTEGER,name VARCHAR,PRIMARY KEY(id));\r\ninsert into mydb.student select i, 'creator' from range(130001) tbl(i);\r\nselect * from mydb.student where id=122881;\r\n-- \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n-- \u2502   id   \u2502  name   \u2502\r\n-- \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n-- \u2502 122881 \u2502 creator \u2502\r\n-- \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nupdate mydb.student set name = 'updator' where id = 122881;\r\nselect * from mydb.student where id=122881;\r\n-- \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n-- \u2502   id   \u2502  name   \u2502\r\n-- \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n-- \u2502 122881 \u2502 creator \u2502\r\n-- \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nWithout the primary key index, this works as expected:\r\n\r\n```sql\r\n\r\nCREATE SCHEMA IF NOT EXISTS mydb;\r\nCREATE TABLE IF NOT EXISTS mydb.student(id INTEGER,name VARCHAR);\r\ninsert into mydb.student select i, 'creator' from range(130001) tbl(i);\r\nselect * from mydb.student where id=122881;\r\n-- \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n-- \u2502   id   \u2502  name   \u2502\r\n-- \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n-- \u2502 122881 \u2502 creator \u2502\r\n-- \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nupdate mydb.student set name = 'updator' where id = 122881;\r\nselect * from mydb.student where id=122881;\r\n-- \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n-- \u2502   id   \u2502  name   \u2502\r\n-- \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n-- \u2502 122881 \u2502 updator \u2502\r\n-- \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\nThis behavior is still the case. I had a go at attempting to fix it and found that the fix won't be trivial and is related to our [known index limitations](https://duckdb.org/docs/sql/indexes#index-limitations).\r\n\r\nIf an update touches any indexed columns, then we rewrite it into an insert + delete. In this case, **the update does not touch the indexed column**, so we perform a normal update. By performing a normal update we do not alter the ART. In a subsequent index scan, we then retrieve the old row ID from the ART, which points to the row that was deleted during the update, and which still contains the old value. Without the index scan, we retrieve the new value. We actually have some tests in DuckDB that should also fail, but mask this behavior by not performing an index scan, for example `test/sql/update/update_delete_wal.test`.\r\n\r\nAlso, when restarting the database, the ART is valid again (see SQL below).\r\n\r\nI had an initial go at fixing this by simply rewriting any update that touches an indexed table into an insert + delete. However, with this change, we then hit our problem of a over-eager constraint evaluation, because the key does not change during these updates. Maybe, another possible solution is to create a mapping containing `[key - old_row_id - new_row_id]` and using that to update the ART, since the keys themselve do not change (we do not touch the indexed columns)...\r\n\r\n```sql\r\nbuild/release/duckdb testdb  \r\nv0.1.1-dev26304 0d946c04df\r\nEnter \".help\" for usage hints.\r\nD CREATE SCHEMA IF NOT EXISTS mydb;\r\nD CREATE TABLE IF NOT EXISTS mydb.student(id INTEGER,name VARCHAR,PRIMARY KEY(id));\r\nD insert into mydb.student select i, 'creator' from range(130001) tbl(i);\r\nD select * from mydb.student where id=122881;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   id   \u2502  name   \u2502\r\n\u2502 int32  \u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 122881 \u2502 creator \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nD update mydb.student set name = 'updator' where id = 122881;\r\nD select rowid, * from mydb.student where id=122881;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 rowid  \u2502   id   \u2502  name   \u2502\r\n\u2502 int64  \u2502 int32  \u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 122881 \u2502 122881 \u2502 creator \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nD .q\r\nbuild/release/duckdb testdb\r\nv0.1.1-dev26304 0d946c04df\r\nEnter \".help\" for usage hints.\r\nD select rowid, * from mydb.student where id=122881;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 rowid  \u2502   id   \u2502  name   \u2502\r\n\u2502 int64  \u2502 int32  \u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 122881 \u2502 122881 \u2502 updator \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nI added this issue to our list of issues addressing our [known index limitations](https://duckdb.org/docs/sql/indexes#index-limitations). I will close it as of now, as it is the intended behavior, and fixing this properly is not trivial.",
  "created_at": "2023-08-09T11:11:40Z"
}