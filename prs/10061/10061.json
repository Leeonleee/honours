{
  "repo": "duckdb/duckdb",
  "pull_number": 10061,
  "instance_id": "duckdb__duckdb-10061",
  "issue_numbers": [
    "10058",
    "10058"
  ],
  "base_commit": "a491470b039c54fe2f0adfe1d161b14c7fe64642",
  "patch": "diff --git a/src/optimizer/rule/regex_optimizations.cpp b/src/optimizer/rule/regex_optimizations.cpp\nindex 00f332ea8d13..5aa4401c3f40 100644\n--- a/src/optimizer/rule/regex_optimizations.cpp\n+++ b/src/optimizer/rule/regex_optimizations.cpp\n@@ -5,6 +5,7 @@\n #include \"duckdb/planner/expression/bound_constant_expression.hpp\"\n #include \"duckdb/function/scalar/string_functions.hpp\"\n #include \"duckdb/function/scalar/regexp.hpp\"\n+#include \"utf8proc_wrapper.hpp\"\n \n #include \"re2/re2.h\"\n #include \"re2/regexp.h\"\n@@ -39,6 +40,19 @@ static void AddCharacter(char chr, LikeString &ret, bool contains) {\n \tret.like_string += run_as_str;\n }\n \n+static void AddCodepoint(int32_t codepoint, LikeString &ret, bool contains) {\n+\tint sz = 0;\n+\tchar utf8_str[4];\n+\tif (!Utf8Proc::CodepointToUtf8(codepoint, sz, utf8_str)) {\n+\t\t// invalid codepoint\n+\t\tret.exists = false;\n+\t\treturn;\n+\t}\n+\tfor (idx_t i = 0; i < idx_t(sz); i++) {\n+\t\tAddCharacter(utf8_str[i], ret, contains);\n+\t}\n+}\n+\n static LikeString GetLikeStringEscaped(duckdb_re2::Regexp *regexp, bool contains = false) {\n \tD_ASSERT(regexp->op() == duckdb_re2::kRegexpLiteralString || regexp->op() == duckdb_re2::kRegexpLiteral);\n \tLikeString ret;\n@@ -57,16 +71,14 @@ static LikeString GetLikeStringEscaped(duckdb_re2::Regexp *regexp, bool contains\n \t\tauto nrunes = (idx_t)regexp->nrunes();\n \t\tauto runes = regexp->runes();\n \t\tfor (idx_t i = 0; i < nrunes; i++) {\n-\t\t\tchar chr = toascii(runes[i]);\n-\t\t\tAddCharacter(chr, ret, contains);\n+\t\t\tAddCodepoint(runes[i], ret, contains);\n \t\t\tif (!ret.exists) {\n \t\t\t\treturn ret;\n \t\t\t}\n \t\t}\n \t} else {\n \t\tauto rune = regexp->rune();\n-\t\tchar chr = toascii(rune);\n-\t\tAddCharacter(chr, ret, contains);\n+\t\tAddCodepoint(rune, ret, contains);\n \t}\n \tD_ASSERT(ret.like_string.size() >= 1 || !ret.exists);\n \treturn ret;\n",
  "test_patch": "diff --git a/test/sql/function/string/regexp_unicode_literal.test b/test/sql/function/string/regexp_unicode_literal.test\nnew file mode 100644\nindex 000000000000..66dc439d0f1b\n--- /dev/null\n+++ b/test/sql/function/string/regexp_unicode_literal.test\n@@ -0,0 +1,55 @@\n+# name: test/sql/function/string/regexp_unicode_literal.test\n+# description: Issue #10058: Regex match turns non-breakable space into regular space\n+# group: [string]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE data(wsc INT, zipcode VARCHAR)\n+\n+statement ok\n+INSERT INTO data VALUES (32, '00' || chr(32) || '001'), (160, '00' || chr(160) || '001'), (0, '00\ud83e\udd86001');\n+\n+query II\n+from data\n+where regexp_matches(zipcode, '^00\\x{0020}001$')\n+----\n+32\t00 001\n+\n+query II\n+from data\n+where regexp_matches(zipcode, '^00\\x{00A0}001$')\n+----\n+160\t00\u00a0001\n+\n+query II\n+from data\n+where regexp_matches(zipcode, '\\x{00A0}001$')\n+----\n+160\t00\u00a0001\n+\n+query II\n+from data\n+where regexp_matches(zipcode, '^00\\x{1F986}001$')\n+----\n+0\t00\ud83e\udd86001\n+\n+query II\n+from data\n+where regexp_matches(zipcode, '\\x{1F986}')\n+----\n+0\t00\ud83e\udd86001\n+\n+query II\n+select *\n+from data\n+where regexp_matches(zipcode, '^00\\x{00A0}001$')\n+and regexp_matches(zipcode, '^00\\x{0020}001$')\n+----\n+\n+\n+statement error\n+select regexp_matches(zipcode, '^00\\x{FFFFFFFF}001$') from data\n+----\n+invalid escape sequence\n",
  "problem_statement": "Regex match turns non-breakable space into regular space\n### What happens?\n\nWhen trying to use regex to match specific character by providing unicode code it seems that non-breakable space (chr: 160) is converted to regular space (chr: 32).\r\n\r\nThe RE2 engine seems to supports this fine: https://regex101.com/r/7SjXN9/1\n\n### To Reproduce\n\n```sql\r\nwith\r\ndata(wsc, zipcode) as (\r\nvalues (32, '00' || chr(32) || '001'), (160, '00' || chr(160) || '001')\r\n)\r\nselect *\r\nfrom data\r\nwhere 1=1\r\nand regexp_matches(zipcode, '^00\\x{00A0}001$')\r\nand regexp_matches(zipcode, '^00\\x{0020}001$')\r\n```\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\n0.9.2\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nTomasz Tara\u015b\n\n### Affiliation:\n\nOrsted\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a release build (and could not test with a main build)\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\nRegex match turns non-breakable space into regular space\n### What happens?\n\nWhen trying to use regex to match specific character by providing unicode code it seems that non-breakable space (chr: 160) is converted to regular space (chr: 32).\r\n\r\nThe RE2 engine seems to supports this fine: https://regex101.com/r/7SjXN9/1\n\n### To Reproduce\n\n```sql\r\nwith\r\ndata(wsc, zipcode) as (\r\nvalues (32, '00' || chr(32) || '001'), (160, '00' || chr(160) || '001')\r\n)\r\nselect *\r\nfrom data\r\nwhere 1=1\r\nand regexp_matches(zipcode, '^00\\x{00A0}001$')\r\nand regexp_matches(zipcode, '^00\\x{0020}001$')\r\n```\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\n0.9.2\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nTomasz Tara\u015b\n\n### Affiliation:\n\nOrsted\n\n### Have you tried this on the latest `main` branch?\n\nI have tested with a release build (and could not test with a main build)\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "\n",
  "created_at": "2023-12-22T11:48:22Z"
}