{
  "repo": "duckdb/duckdb",
  "pull_number": 8978,
  "instance_id": "duckdb__duckdb-8978",
  "issue_numbers": [
    "8287"
  ],
  "base_commit": "97f33b8d94f26adeb1549646c3cef8986aba3d2d",
  "patch": "diff --git a/src/include/duckdb/planner/expression_binder/base_select_binder.hpp b/src/include/duckdb/planner/expression_binder/base_select_binder.hpp\nindex a745f583b1da..c05e1d8d99f1 100644\n--- a/src/include/duckdb/planner/expression_binder/base_select_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/base_select_binder.hpp\n@@ -21,6 +21,7 @@ class BoundSelectNode;\n struct BoundGroupInformation {\n \tparsed_expression_map_t<idx_t> map;\n \tcase_insensitive_map_t<idx_t> alias_map;\n+\tunordered_map<idx_t, idx_t> collated_groups;\n };\n \n //! The BaseSelectBinder is the base binder of the SELECT, HAVING and QUALIFY binders. It can bind aggregates and window\ndiff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp\nindex 4bcc264fa7e6..6a052a3057c8 100644\n--- a/src/planner/binder/query_node/bind_select_node.cpp\n+++ b/src/planner/binder/query_node/bind_select_node.cpp\n@@ -1,25 +1,29 @@\n #include \"duckdb/common/limits.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n #include \"duckdb/execution/expression_executor.hpp\"\n+#include \"duckdb/function/aggregate/distributive_functions.hpp\"\n+#include \"duckdb/function/function_binder.hpp\"\n #include \"duckdb/main/config.hpp\"\n #include \"duckdb/parser/expression/columnref_expression.hpp\"\n #include \"duckdb/parser/expression/comparison_expression.hpp\"\n+#include \"duckdb/parser/expression/conjunction_expression.hpp\"\n #include \"duckdb/parser/expression/constant_expression.hpp\"\n-#include \"duckdb/parser/expression/subquery_expression.hpp\"\n #include \"duckdb/parser/expression/star_expression.hpp\"\n+#include \"duckdb/parser/expression/subquery_expression.hpp\"\n #include \"duckdb/parser/query_node/select_node.hpp\"\n #include \"duckdb/parser/tableref/joinref.hpp\"\n #include \"duckdb/planner/binder.hpp\"\n+#include \"duckdb/planner/expression/bound_aggregate_expression.hpp\"\n #include \"duckdb/planner/expression_binder/column_alias_binder.hpp\"\n #include \"duckdb/planner/expression_binder/constant_binder.hpp\"\n #include \"duckdb/planner/expression_binder/group_binder.hpp\"\n #include \"duckdb/planner/expression_binder/having_binder.hpp\"\n-#include \"duckdb/planner/expression_binder/qualify_binder.hpp\"\n #include \"duckdb/planner/expression_binder/order_binder.hpp\"\n+#include \"duckdb/planner/expression_binder/qualify_binder.hpp\"\n #include \"duckdb/planner/expression_binder/select_binder.hpp\"\n #include \"duckdb/planner/expression_binder/where_binder.hpp\"\n+#include \"duckdb/planner/expression_iterator.hpp\"\n #include \"duckdb/planner/query_node/bound_select_node.hpp\"\n-#include \"duckdb/parser/expression/conjunction_expression.hpp\"\n \n namespace duckdb {\n \n@@ -380,10 +384,28 @@ unique_ptr<BoundQueryNode> Binder::BindSelectNode(SelectNode &statement, unique_\n \t\t\tauto bound_expr = group_binder.Bind(group_expressions[i], &group_type);\n \t\t\tD_ASSERT(bound_expr->return_type.id() != LogicalTypeId::INVALID);\n \n+\t\t\t// find out whether the expression contains a subquery, it can't be copied if so\n+\t\t\tauto &bound_expr_ref = *bound_expr;\n+\t\t\tbool contains_subquery = bound_expr_ref.HasSubquery();\n+\n \t\t\t// push a potential collation, if necessary\n-\t\t\tbound_expr = ExpressionBinder::PushCollation(context, std::move(bound_expr),\n-\t\t\t                                             StringType::GetCollation(group_type), true);\n-\t\t\tresult->groups.group_expressions.push_back(std::move(bound_expr));\n+\t\t\tauto collated_expr = ExpressionBinder::PushCollation(context, std::move(bound_expr),\n+\t\t\t                                                     StringType::GetCollation(group_type), true);\n+\t\t\tif (!contains_subquery && !collated_expr->Equals(bound_expr_ref)) {\n+\t\t\t\t// if there is a collation on a group x, we should group by the collated expr,\n+\t\t\t\t// but also push a first(x) aggregate in case x is selected (uncollated)\n+\t\t\t\tinfo.collated_groups[i] = result->aggregates.size();\n+\n+\t\t\t\tauto first_fun = FirstFun::GetFunction(LogicalType::VARCHAR);\n+\t\t\t\tvector<unique_ptr<Expression>> first_children;\n+\t\t\t\t// FIXME: would be better to just refer to this expression, but for now we copy\n+\t\t\t\tfirst_children.push_back(bound_expr_ref.Copy());\n+\n+\t\t\t\tFunctionBinder function_binder(context);\n+\t\t\t\tauto function = function_binder.BindAggregateFunction(first_fun, std::move(first_children));\n+\t\t\t\tresult->aggregates.push_back(std::move(function));\n+\t\t\t}\n+\t\t\tresult->groups.group_expressions.push_back(std::move(collated_expr));\n \n \t\t\t// in the unbound expression we DO bind the table names of any ColumnRefs\n \t\t\t// we do this to make sure that \"table.a\" and \"a\" are treated the same\ndiff --git a/src/planner/binder/statement/bind_drop.cpp b/src/planner/binder/statement/bind_drop.cpp\nindex 2c7bd0a940e7..700aa167ea69 100644\n--- a/src/planner/binder/statement/bind_drop.cpp\n+++ b/src/planner/binder/statement/bind_drop.cpp\n@@ -39,6 +39,9 @@ BoundStatement Binder::Bind(DropStatement &stmt) {\n \t\tif (!entry) {\n \t\t\tbreak;\n \t\t}\n+\t\tif (entry->internal) {\n+\t\t\tthrow CatalogException(\"Cannot drop internal catalog entry \\\"%s\\\"!\", entry->name);\n+\t\t}\n \t\tstmt.info->catalog = entry->ParentCatalog().GetName();\n \t\tif (!entry->temporary) {\n \t\t\t// we can only drop temporary tables in read-only mode\ndiff --git a/src/planner/expression_binder/base_select_binder.cpp b/src/planner/expression_binder/base_select_binder.cpp\nindex 25af231d2cbb..542bfa52625d 100644\n--- a/src/planner/expression_binder/base_select_binder.cpp\n+++ b/src/planner/expression_binder/base_select_binder.cpp\n@@ -1,15 +1,15 @@\n #include \"duckdb/planner/expression_binder/base_select_binder.hpp\"\n \n+#include \"duckdb/common/string_util.hpp\"\n #include \"duckdb/parser/expression/columnref_expression.hpp\"\n+#include \"duckdb/parser/expression/operator_expression.hpp\"\n #include \"duckdb/parser/expression/window_expression.hpp\"\n #include \"duckdb/parser/parsed_expression_iterator.hpp\"\n+#include \"duckdb/planner/binder.hpp\"\n #include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n #include \"duckdb/planner/expression/bound_window_expression.hpp\"\n #include \"duckdb/planner/expression_binder/aggregate_binder.hpp\"\n #include \"duckdb/planner/query_node/bound_select_node.hpp\"\n-#include \"duckdb/parser/expression/operator_expression.hpp\"\n-#include \"duckdb/common/string_util.hpp\"\n-#include \"duckdb/planner/binder.hpp\"\n \n namespace duckdb {\n \n@@ -138,9 +138,17 @@ BindResult BaseSelectBinder::BindGroupingFunction(OperatorExpression &op, idx_t\n }\n \n BindResult BaseSelectBinder::BindGroup(ParsedExpression &expr, idx_t depth, idx_t group_index) {\n-\tauto &group = node.groups.group_expressions[group_index];\n-\treturn BindResult(make_uniq<BoundColumnRefExpression>(expr.GetName(), group->return_type,\n-\t                                                      ColumnBinding(node.group_index, group_index), depth));\n+\tauto it = info.collated_groups.find(group_index);\n+\tif (it != info.collated_groups.end()) {\n+\t\t// This is an implicitly collated group, so we need to refer to the first() aggregate\n+\t\tconst auto &aggr_index = it->second;\n+\t\treturn BindResult(make_uniq<BoundColumnRefExpression>(expr.GetName(), node.aggregates[aggr_index]->return_type,\n+\t\t                                                      ColumnBinding(node.aggregate_index, aggr_index), depth));\n+\t} else {\n+\t\tauto &group = node.groups.group_expressions[group_index];\n+\t\treturn BindResult(make_uniq<BoundColumnRefExpression>(expr.GetName(), group->return_type,\n+\t\t                                                      ColumnBinding(node.group_index, group_index), depth));\n+\t}\n }\n \n bool BaseSelectBinder::QualifyColumnAlias(const ColumnRefExpression &colref) {\n",
  "test_patch": "diff --git a/test/issues/general/test_3821.test b/test/issues/general/test_3821.test\nnew file mode 100644\nindex 000000000000..21d9d331ce3b\n--- /dev/null\n+++ b/test/issues/general/test_3821.test\n@@ -0,0 +1,50 @@\n+# name: test/issues/general/test_3821.test\n+# description: Issue 3821: Setting default_collation=NOCASE modifies values of GROUP BY queries\n+# group: [general]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE t AS (SELECT 'hello' AS x UNION ALL SELECT 'WORLD' AS x UNION ALL SELECT 'WoRlD' AS x);\n+\n+# 3 groups because no collation\n+query I rowsort\n+SELECT x FROM t GROUP BY 1;\n+----\n+WORLD\n+WoRlD\n+hello\n+\n+query I rowsort\n+SELECT x COLLATE NOCASE FROM t GROUP BY 1;\n+----\n+WORLD\n+hello\n+\n+query I\n+SELECT COUNT(*) FROM t GROUP BY x COLLATE NOCASE ORDER BY ALL;\n+----\n+1\n+2\n+\n+statement ok\n+CREATE TABLE t_schema(x VARCHAR COLLATE NOCASE);\n+\n+statement ok\n+INSERT INTO t_schema VALUES ('hello'), ('WORLD'), ('WoRlD');\n+\n+query I rowsort\n+SELECT x FROM t_schema GROUP BY x;\n+----\n+WORLD\n+hello\n+\n+statement ok\n+PRAGMA default_collation=NOCASE;\n+\n+query I rowsort\n+SELECT x FROM t GROUP BY 1;\n+----\n+WORLD\n+hello\ndiff --git a/test/issues/general/test_8287.test b/test/issues/general/test_8287.test\nnew file mode 100644\nindex 000000000000..42568c3a3fd1\n--- /dev/null\n+++ b/test/issues/general/test_8287.test\n@@ -0,0 +1,11 @@\n+# name: test/issues/general/test_8287.test\n+# description: Issue 8287: Internal Exception when dropping system catalog function as if it were a Macro\n+# group: [general]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement error\n+drop macro sum;\n+----\n+Catalog Error: Cannot drop internal catalog entry \"sum\"!\n",
  "problem_statement": "Internal Exception when dropping system catalog function as if it were a Macro\n### What happens?\n\nWhen trying to drop macro `sum` (without creating it), an internal exception is thrown.\n\n### To Reproduce\n\n```\r\n$ duckdb\r\n-- Loading resources from /Users/laurens/.duckdbrc\r\nv0.8.1-dev1402 aada97ec5f\r\nEnter \".help\" for usage hints.\r\nConnected to a transient in-memory database.\r\nUse \".open FILENAME\" to reopen on a persistent database.\r\nD drop macro sum;\r\nABORT THROWN BY INTERNAL EXCEPTION: Database \"system\" not found\r\n^C[1]    53269 abort (core dumped)  duckdb\r\n```\n\n### OS:\n\nMacOS\n\n### DuckDB Version:\n\nMaster\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nLaurens Kuiper\n\n### Affiliation:\n\nDuckDB Labs\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "",
  "created_at": "2023-09-18T12:50:44Z"
}