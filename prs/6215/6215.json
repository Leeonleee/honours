{
  "repo": "duckdb/duckdb",
  "pull_number": 6215,
  "instance_id": "duckdb__duckdb-6215",
  "issue_numbers": [
    "657"
  ],
  "base_commit": "2eb46acc6eb2bdc7fa24afe773006a4cede65101",
  "patch": "diff --git a/tools/pythonpkg/setup.py b/tools/pythonpkg/setup.py\nindex 9eff4f247340..510726134d70 100755\n--- a/tools/pythonpkg/setup.py\n+++ b/tools/pythonpkg/setup.py\n@@ -153,11 +153,6 @@ def __str__(self):\n         import pybind11\n         return pybind11.get_include(self.user)\n \n-class get_numpy_include(object):\n-    def __str__(self):\n-        import numpy\n-        return numpy.get_include()\n-\n extra_files = []\n header_files = []\n \n@@ -169,7 +164,7 @@ def list_source_files(directory):\n main_include_path = os.path.join(script_path, 'src', 'include')\n main_source_path = os.path.join(script_path, 'src')\n main_source_files = ['duckdb_python.cpp'] + list_source_files(main_source_path)\n-include_directories = [main_include_path, get_numpy_include(), get_pybind_include(), get_pybind_include(user=True)]\n+include_directories = [main_include_path, get_pybind_include(), get_pybind_include(user=True)]\n \n if len(existing_duckdb_dir) == 0:\n     # no existing library supplied: compile everything from source\n@@ -285,16 +280,13 @@ def setup_data_files(data_files):\n     url=\"https://www.duckdb.org\",\n     long_description = 'See here for an introduction: https://duckdb.org/docs/api/python/overview',\n     license='MIT',\n-    install_requires=[ # these version is still available for Python 2, newer ones aren't\n-         'numpy>=1.14'\n-    ],\n     data_files = data_files,\n     packages=[\n         'duckdb_query_graph',\n         'duckdb-stubs'\n     ],\n     include_package_data=True,\n-    setup_requires=setup_requires + [\"setuptools_scm<7.0.0\", 'numpy>=1.14', 'pybind11>=2.6.0'],\n+    setup_requires=setup_requires + [\"setuptools_scm<7.0.0\", 'pybind11>=2.6.0'],\n     use_scm_version = setuptools_scm_conf,\n     tests_require=['google-cloud-storage', 'mypy', 'pytest'],\n     classifiers = [\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache.hpp b/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache.hpp\nindex 44da715a5268..355bf3ffad8a 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/import_cache/python_import_cache.hpp\n@@ -19,17 +19,6 @@ namespace duckdb {\n struct PythonImportCache {\n public:\n \texplicit PythonImportCache() {\n-#ifdef WIN32\n-\t\tpy::gil_scoped_acquire acquire;\n-\t\tnumpy();\n-\t\tdatetime();\n-\t\tdecimal();\n-\t\tuuid();\n-\t\tpandas();\n-\t\tarrow();\n-\t\tIPython();\n-\t\tipywidgets();\n-#endif\n \t}\n \t~PythonImportCache();\n \n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/conftest.py b/tools/pythonpkg/tests/conftest.py\nindex 13efb59e20a5..d481f7912a33 100644\n--- a/tools/pythonpkg/tests/conftest.py\n+++ b/tools/pythonpkg/tests/conftest.py\n@@ -1,4 +1,3 @@\n-import numpy\n import os\n import pytest\n import shutil\n",
  "problem_statement": "Optional NumPy dependency\nWe could make the NumPy/Pandas dependency in the Python client optional, and drop the features associated with them (fetchnumpy, fetchpandas, scanning df) if the libraries are not there. Thoughts?\n",
  "hints_text": "We could remove for sure but right now Pandas/Numpy are the only ways to get larger amounts of data out of DuckDB. I guess NumPy alone is enough to do that though, so pandas could be optional indeed. Otherwise we could work around with raw byte arrays? What triggered this proposal?\n[This guy on HackerNews asked for it](https://news.ycombinator.com/item?id=23290840). Not all workloads require large result import/export, and for a drop-in SQLite replacement it is sufficient to only use the standard DB protocol for which we need no dependencies. I would say it depends on how easy it is to drop the required dependency or how ugly it would end up being.\r\n\r\nIf we can make it so the dependency is only checked when an actual method is called (i.e. calling fetchnumpy will fail if numpy is not installed) then that could be quite an elegant solution. \nIs it possible to avoid NumPy/Pandas dependencies by adding a method `fetchdict() -> Dict[str, List]` that outputs virtually the same data structure as returned by `fetchnumpy()`, but using the built-in Python types only? I see that masks are used, but cannot they be replaced by `Optional[T]` values?\nYes, certainly. However, constructing and consuming very large Python lists is very slow and we should probably avoid it. I think its either use the Python DB API (`fetchone` and friends) or use the bulk api with `fetchnumpy` and `fetchdf`\nAlthough I have never dived deeply into the CPython's code, [they say](https://docs.python.org/3.8/faq/design.html#how-are-lists-implemented-in-cpython) that the lists are contiguous arrays of references to other objects. As far as I understand, this is technically equivalent to NumPy's `dtype=object`. The numeric values can be handled with the built-in [array](https://docs.python.org/3/library/array.html) type that has a smaller overhead. A small wrapper container class can provide enough abstraction for read-only purposes. Also, pybind11 can expose STL containers as native Python objects, which can be even cheaper than NumPy.\nThats just the thing, arrays of objects are pretty horrible performance-wise. This is why NumPy uses arrays of native types (e.g. integer) instead of them for most types (except strings, notably). So I don't think that will make a great difference to `fetch()` and friends.\nPython has the buffer protocol [link](https://docs.python.org/3/c-api/buffer.html) this leads to Python support multidimensional heterogeneous arrays out of the box without any dependencies. \r\n\r\nNumpy will access any object supporting the buffer protocol without overhead.\r\nIt is also support in other libraries like PIL/Pillow and therfore  will be more general solution\r\nto access the data.\r\n\r\nIt seems pybind11 support this also [link](https://pybind11-rtdtest.readthedocs.io/en/stable/advanced.html#buffer-protocol)\r\n\r\nAs for the import of numpy/pandas. Can this be done lazily inside the functions/method when invoked?\nIndeed I was not aware of this Buffer protocol. That seems like a good compromise. Happy to review a PR!\nI could give it a try, but my skills in C++ is not very great and therefore no promises.\r\n\nThe last time I wrote a C++ code was a home task more than ten years ago. While writing a wrapper could be a fun exercise, I cannot estimate how much time I would need for this.\nPR #720 will partially address this by removing the fixed Pandas dependency",
  "created_at": "2023-02-11T16:02:20Z"
}