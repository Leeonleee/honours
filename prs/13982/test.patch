diff --git a/test/issues/general/test_13938.test b/test/issues/general/test_13938.test
new file mode 100644
index 000000000000..0d91b3f296f4
--- /dev/null
+++ b/test/issues/general/test_13938.test
@@ -0,0 +1,45 @@
+# name: test/issues/general/test_13938.test
+# description: Issue 13938 - INTERNAL Error: Attempted to dereference unique_ptr that is NULL
+# group: [general]
+
+statement ok
+CREATE TABLE t0(c0 TIMESTAMP, c1 VARCHAR[]);
+
+statement ok
+CREATE TABLE t1(c0 FLOAT, c1 TIMESTAMP, c2 FLOAT);
+
+statement ok
+INSERT INTO t0 VALUES('2023-10-10 00:00:00+00:00', NULL);
+
+statement ok
+INSERT INTO t0 VALUES('2025-12-25 12:00:00+02:00', []), ('2004-07-27 10:00:00+02', []);
+
+statement ok
+INSERT INTO t0(c1, c0) VALUES([], '2023-01-01 00:00:00+00:00'), ([], '2021-01-01 00:00:00+01');
+
+statement ok
+INSERT INTO t0(c1, c0) VALUES([], '2021-01-01 00:00:00+00');
+
+statement ok
+INSERT INTO t1 VALUES(2.71, '1999-12-31 23:59:59', 1.41421356237);
+
+statement ok
+INSERT INTO t1 VALUES(1.61803, '1970-01-01 00:00:00', 1.61803);
+
+statement ok
+INSERT INTO t1(c0) VALUES(1064961652.34), (123.45);
+
+statement ok
+INSERT INTO t1(c0) VALUES('514332609.12');
+
+statement ok
+INSERT INTO t1(c0, c2, c1) VALUES(2.71828, 2.345, '1995-05-23 08:45:00'), ('1308880808', 12.34, '2021-01-01 15:30:45');
+
+statement ok
+INSERT INTO t1(c0) VALUES(92857950), (840458867);
+
+statement ok
+INSERT INTO t1 VALUES('3.14', '1999-12-31 23:59:59', 3.1415);
+
+statement ok
+SELECT * FROM t0 RIGHT JOIN t1 ON(CAST(t1.c1 AS TIMESTAMP) BETWEEN t0.c0 AND t0.c0);
diff --git a/test/sql/cte/materialized/annotated_and_auto_materialized.test b/test/sql/cte/materialized/annotated_and_auto_materialized.test
new file mode 100644
index 000000000000..6ba4008d512c
--- /dev/null
+++ b/test/sql/cte/materialized/annotated_and_auto_materialized.test
@@ -0,0 +1,39 @@
+# name: test/sql/cte/materialized/annotated_and_auto_materialized.test
+# description: Issue 13850 - Binder error when manually materializing a CTE
+# group: [materialized]
+
+statement ok
+create table batch (
+    entity text,
+    start_ts timestamp,
+    duration interval
+);
+
+statement ok
+create table active_events (
+    entity text,
+    start_ts timestamp,
+    end_ts timestamp
+);
+
+statement ok
+explain create table new_active_events as
+with
+  new_events as materialized (  -- Does not make much sense in this example, but my original query was a union of a bunch of things
+      select * from batch
+  ), combined_deduplicated_events as (
+      select
+          entity,
+          min(start_ts) as start_ts,
+          max(end_ts) as end_ts
+      from
+          active_events
+      group by
+          entity
+  ), all_events as (
+      select  * from combined_deduplicated_events
+  )
+select
+  *
+from
+  new_events;
\ No newline at end of file
diff --git a/test/sql/json/issues/issue13948.test b/test/sql/json/issues/issue13948.test
new file mode 100644
index 000000000000..827ead417d4f
--- /dev/null
+++ b/test/sql/json/issues/issue13948.test
@@ -0,0 +1,79 @@
+# name: test/sql/json/issues/issue13948.test
+# description: Test issue 13948 - Json property name with special characters produce inconsistent results with json -> 'propertyname' and json_extract
+# group: [issues]
+
+require json
+
+statement ok
+pragma enable_verification
+
+query I
+SELECT '{"Status / SubStatus": "test"}' -> 'Status / SubStatus';
+----
+"test"
+
+query I
+WITH path AS (
+    SELECT 'Status / SubStatus' p
+)
+SELECT '{"Status / SubStatus": "test"}' -> p
+FROM path
+----
+"test"
+
+# TODO at some point we should escape supplied JSON paths automatically so that this works
+query I
+SELECT '{"\"Status / SubStatus\"": "test"}' -> '"Status / SubStatus"';
+----
+NULL
+
+query I
+WITH path AS (
+    SELECT NULL p
+)
+SELECT '{"\"Status / SubStatus\"": "test"}' -> p
+FROM path
+----
+NULL
+
+query I
+SELECT '{"Status / SubStatus": "test"}' -> '$."Status / SubStatus"';
+----
+"test"
+
+query I
+WITH path AS (
+    SELECT '$."Status / SubStatus"' p
+)
+SELECT '{"Status / SubStatus": "test"}' -> p
+FROM path
+----
+"test"
+
+query I
+SELECT '[1, 2, 3]'->0
+----
+1
+
+query I
+WITH path AS (
+    SELECT 0 p
+)
+SELECT '[1, 2, 3]' -> p
+FROM path
+----
+1
+
+query I
+SELECT '[1, 2, 3]'->'0'
+----
+NULL
+
+query I
+WITH path AS (
+    SELECT '0' p
+)
+SELECT '[1, 2, 3]' -> p
+FROM path
+----
+NULL
diff --git a/test/sql/json/scalar/test_json_extract.test b/test/sql/json/scalar/test_json_extract.test
index d41b6a4e909e..276cfc229e31 100644
--- a/test/sql/json/scalar/test_json_extract.test
+++ b/test/sql/json/scalar/test_json_extract.test
@@ -85,7 +85,7 @@ select '{"my_field": {"my_nested_field": ["goose", "duckduckduckduck"]}}'::JSON-
 duckduckduckduck
 
 query T
-select json_extract('[1, 2, 42]', '2')
+select json_extract('[1, 2, 42]', 2)
 ----
 42
 
diff --git a/test/sql/json/scalar/test_json_value.test b/test/sql/json/scalar/test_json_value.test
index 30e0c1acd873..d0ae5622b542 100644
--- a/test/sql/json/scalar/test_json_value.test
+++ b/test/sql/json/scalar/test_json_value.test
@@ -39,7 +39,7 @@ select json_value('{"my_field": {"my_nested_field": ["goose", "duckduckduckduck"
 "duckduckduckduck"
 
 query T
-select json_value('[1, 2, 42]', '2')
+select json_value('[1, 2, 42]', 2)
 ----
 42
 
diff --git a/test/sql/optimizer/plan/test_filter_pushdown_materialized_cte.test b/test/sql/optimizer/plan/test_filter_pushdown_materialized_cte.test
new file mode 100644
index 000000000000..d71d18a78a75
--- /dev/null
+++ b/test/sql/optimizer/plan/test_filter_pushdown_materialized_cte.test
@@ -0,0 +1,34 @@
+# name: test/sql/optimizer/plan/test_filter_pushdown_materialized_cte.test
+# description: Test filter pushdown in materialized CTEs (internal issue #3041)
+# group: [plan]
+
+require tpcds
+
+statement ok
+call dsdgen(sf=0.01)
+
+statement ok
+pragma explain_output='OPTIMIZED_ONLY'
+
+query II
+EXPLAIN WITH ss AS MATERIALIZED
+  ( SELECT i_manufact_id,
+           sum(ss_ext_sales_price) total_sales
+   FROM store_sales,
+        date_dim,
+        customer_address,
+        item
+   WHERE i_manufact_id IN
+       (SELECT i_manufact_id
+        FROM item
+        WHERE i_category IN ('Electronics'))
+     AND ss_item_sk = i_item_sk
+     AND ss_sold_date_sk = d_date_sk
+     AND d_year = 1998
+     AND d_moy = 5
+     AND ss_addr_sk = ca_address_sk
+     AND ca_gmt_offset = -5
+   GROUP BY i_manufact_id)
+FROM ss
+----
+logical_opt	<!REGEX>:.*CROSS_PRODUCT.*
