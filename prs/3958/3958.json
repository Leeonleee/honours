{
  "repo": "duckdb/duckdb",
  "pull_number": 3958,
  "instance_id": "duckdb__duckdb-3958",
  "issue_numbers": [
    "3955",
    "3955"
  ],
  "base_commit": "26d123fdc57273903573c72b1ddafc52f365e378",
  "patch": "diff --git a/src/common/types.cpp b/src/common/types.cpp\nindex 2d5fa8df4494..f39ab54ce7a1 100644\n--- a/src/common/types.cpp\n+++ b/src/common/types.cpp\n@@ -93,7 +93,7 @@ PhysicalType LogicalType::GetInternalType() {\n \t\t} else if (width <= Decimal::MAX_WIDTH_INT128) {\n \t\t\treturn PhysicalType::INT128;\n \t\t} else {\n-\t\t\tthrow InternalException(\"Widths bigger than 38 are not supported\");\n+\t\t\tthrow InternalException(\"Widths bigger than %d are not supported\", DecimalType::MaxWidth());\n \t\t}\n \t}\n \tcase LogicalTypeId::VARCHAR:\n@@ -643,9 +643,20 @@ LogicalType LogicalType::MaxLogicalType(const LogicalType &left, const LogicalTy\n \t\t\t\treturn right;\n \t\t\t}\n \t\t} else if (type_id == LogicalTypeId::DECIMAL) {\n-\t\t\t// use max width/scale of the two types\n-\t\t\tauto width = MaxValue<uint8_t>(DecimalType::GetWidth(left), DecimalType::GetWidth(right));\n+\t\t\t// unify the width/scale so that the resulting decimal always fits\n+\t\t\t// \"width - scale\" gives us the number of digits on the left side of the decimal point\n+\t\t\t// \"scale\" gives us the number of digits allowed on the right of the deciaml point\n+\t\t\t// using the max of these of the two types gives us the new decimal size\n+\t\t\tauto extra_width_left = DecimalType::GetWidth(left) - DecimalType::GetScale(left);\n+\t\t\tauto extra_width_right = DecimalType::GetWidth(right) - DecimalType::GetScale(right);\n+\t\t\tauto extra_width = MaxValue<uint8_t>(extra_width_left, extra_width_right);\n \t\t\tauto scale = MaxValue<uint8_t>(DecimalType::GetScale(left), DecimalType::GetScale(right));\n+\t\t\tauto width = extra_width + scale;\n+\t\t\tif (width > DecimalType::MaxWidth()) {\n+\t\t\t\t// if the resulting decimal does not fit, we truncate the scale\n+\t\t\t\twidth = DecimalType::MaxWidth();\n+\t\t\t\tscale = width - extra_width;\n+\t\t\t}\n \t\t\treturn LogicalType::DECIMAL(width, scale);\n \t\t} else if (type_id == LogicalTypeId::LIST) {\n \t\t\t// list: perform max recursively on child type\n@@ -842,6 +853,10 @@ uint8_t DecimalType::GetScale(const LogicalType &type) {\n \treturn ((DecimalTypeInfo &)*info).scale;\n }\n \n+uint8_t DecimalType::MaxWidth() {\n+\treturn 38;\n+}\n+\n LogicalType LogicalType::DECIMAL(int width, int scale) {\n \tauto type_info = make_shared<DecimalTypeInfo>(width, scale);\n \treturn LogicalType(LogicalTypeId::DECIMAL, move(type_info));\ndiff --git a/src/include/duckdb/common/types.hpp b/src/include/duckdb/common/types.hpp\nindex fbdb6aed3f72..0570aa9d5cca 100644\n--- a/src/include/duckdb/common/types.hpp\n+++ b/src/include/duckdb/common/types.hpp\n@@ -512,6 +512,7 @@ struct LogicalType {\n struct DecimalType {\n \tDUCKDB_API static uint8_t GetWidth(const LogicalType &type);\n \tDUCKDB_API static uint8_t GetScale(const LogicalType &type);\n+\tDUCKDB_API static uint8_t MaxWidth();\n };\n \n struct StringType {\n",
  "test_patch": "diff --git a/test/sql/types/decimal/decimal_automatic_cast.test b/test/sql/types/decimal/decimal_automatic_cast.test\nnew file mode 100644\nindex 000000000000..d614c83c0b9b\n--- /dev/null\n+++ b/test/sql/types/decimal/decimal_automatic_cast.test\n@@ -0,0 +1,30 @@\n+# name: test/sql/types/decimal/decimal_automatic_cast.test\n+# description: Test automatic decimal casting\n+# group: [decimal]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query I\n+SELECT [1.33, 10.0]\n+----\n+[1.33, 10.00]\n+\n+query I\n+SELECT [0.1, 1.33, 10.0, 9999999.999999999]\n+----\n+[0.100000000, 1.330000000, 10.000000000, 9999999.999999999]\n+\n+query I\n+SELECT [99999999999999999999999999999999999.9, 9.99999999999999999999999999999999999]\n+----\n+[99999999999999999999999999999999999.900, 9.999]\n+\n+statement ok\n+CREATE TABLE foo\n+ (my_struct STRUCT(my_double DOUBLE)[]);\n+\n+statement ok\n+INSERT INTO foo VALUES\n+  ([{'my_double': 1.33},\n+    {'my_double': 10.0}]);\n",
  "problem_statement": "Inserting nested datatypes causes unexpected conversion of numerical type\n#### What happens?\r\nIf I create a table column with type `STRUCT(some_field DOUBLE)[]`, attempting to insert a row can trigger a SQLException complaining about a failed cast to `DECIMAL`.\r\n\r\n#### To Reproduce\r\nExecuting the following two statements via the JDBC interface triggers a SQLException:\r\n```sql\r\nCREATE TABLE foo\r\n (my_struct STRUCT(my_double DOUBLE)[]);\r\n```\r\n\r\n```sql\r\nINSERT INTO foo VALUES\r\n  ([{'my_double': 1.33},\r\n    {'my_double': 10.0}]);\r\n```\r\n\r\n```java.sql.SQLException: Conversion Error: Casting value \"10.0\" to type DECIMAL(3,2) failed: value is out of range!```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: OS X (intel)\r\n - DuckDB Version: 0.4.0\r\n - DuckDB Client: Java\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\nTested using [this master build](https://github.com/duckdb/duckdb/actions/runs/2555154383). \r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\r\nThis doesn't seem to be Java specific: I get the same behavior using the CLI client.\nInserting nested datatypes causes unexpected conversion of numerical type\n#### What happens?\r\nIf I create a table column with type `STRUCT(some_field DOUBLE)[]`, attempting to insert a row can trigger a SQLException complaining about a failed cast to `DECIMAL`.\r\n\r\n#### To Reproduce\r\nExecuting the following two statements via the JDBC interface triggers a SQLException:\r\n```sql\r\nCREATE TABLE foo\r\n (my_struct STRUCT(my_double DOUBLE)[]);\r\n```\r\n\r\n```sql\r\nINSERT INTO foo VALUES\r\n  ([{'my_double': 1.33},\r\n    {'my_double': 10.0}]);\r\n```\r\n\r\n```java.sql.SQLException: Conversion Error: Casting value \"10.0\" to type DECIMAL(3,2) failed: value is out of range!```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: OS X (intel)\r\n - DuckDB Version: 0.4.0\r\n - DuckDB Client: Java\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\nTested using [this master build](https://github.com/duckdb/duckdb/actions/runs/2555154383). \r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\r\nThis doesn't seem to be Java specific: I get the same behavior using the CLI client.\n",
  "hints_text": "\n",
  "created_at": "2022-06-24T20:25:40Z"
}