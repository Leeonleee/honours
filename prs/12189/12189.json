{
  "repo": "duckdb/duckdb",
  "pull_number": 12189,
  "instance_id": "duckdb__duckdb-12189",
  "issue_numbers": [
    "12181"
  ],
  "base_commit": "70fd6a8a2450c1e2a7d0547d4c0666a649dc378e",
  "patch": "diff --git a/src/optimizer/rule/move_constants.cpp b/src/optimizer/rule/move_constants.cpp\nindex 636265ff9131..29404164f7d2 100644\n--- a/src/optimizer/rule/move_constants.cpp\n+++ b/src/optimizer/rule/move_constants.cpp\n@@ -41,6 +41,10 @@ unique_ptr<Expression> MoveConstantsRule::Apply(LogicalOperator &op, vector<refe\n \tD_ASSERT(arithmetic.return_type.IsIntegral());\n \tD_ASSERT(arithmetic.children[0]->return_type.IsIntegral());\n \tif (inner_constant.value.IsNull() || outer_constant.value.IsNull()) {\n+\t\tif (comparison.type == ExpressionType::COMPARE_DISTINCT_FROM ||\n+\t\t    comparison.type == ExpressionType::COMPARE_NOT_DISTINCT_FROM) {\n+\t\t\treturn nullptr;\n+\t\t}\n \t\treturn make_uniq<BoundConstantExpression>(Value(comparison.return_type));\n \t}\n \tauto &constant_type = outer_constant.return_type;\n",
  "test_patch": "diff --git a/test/optimizer/issue_12181.test b/test/optimizer/issue_12181.test\nnew file mode 100644\nindex 000000000000..873b90cde7e6\n--- /dev/null\n+++ b/test/optimizer/issue_12181.test\n@@ -0,0 +1,22 @@\n+# name: test/optimizer/issue_12181.test\n+# description: Test move constants optimization involving DISTINCT FROM comparison\n+# group: [optimizer]\n+\n+statement ok\n+CREATE TABLE t0(c0 INT)\n+\n+statement ok\n+CREATE TABLE t1(c0 INT, c1 INT)\n+\n+statement ok\n+INSERT INTO t1(c0, c1) VALUES (0, 1)\n+\n+query I\n+SELECT NULL IS DISTINCT FROM (1 + t1.c1) FROM t1 NATURAL LEFT JOIN t0\n+----\n+true\n+\n+query II\n+SELECT * FROM t0 NATURAL RIGHT JOIN t1 WHERE (CASE t0.c0 WHEN t0.c0 THEN 1 ELSE NULL END) IS DISTINCT FROM (1 + (CASE t1.c1 WHEN t1.c1 THEN 2 ELSE NULL END))\n+----\n+0\t1\n",
  "problem_statement": "Unexpected Result When Using `IS DISTINCT FROM` and `CASE WHEN` in a JOIN clause\n### What happens?\n\nThe query involving the `IS DISTINCT FROM` operator with a `NATURAL RIGHT JOIN` returns an empty table when it should return one row. The expected behavior is that the `WHERE` condition would evaluate to `TRUE` (as the second query) and thus include the joined row in the result set.\n\n### To Reproduce\n\n```sql\r\n\r\nCREATE TABLE t1(c0 INT, c1 INT);\r\nCREATE TABLE t0(c0 INT);\r\nINSERT INTO t1 (c0, c1) VALUES (0, 1);\r\n\r\nSELECT * FROM t0 NATURAL RIGHT JOIN t1; -- 0 1\r\nSELECT ((CASE t0.c0 WHEN t0.c0 THEN 1 ELSE NULL END )IS DISTINCT FROM((1+(CASE t1.c1 WHEN t1.c1 THEN 2 ELSE NULL END )))) FROM t0 NATURAL RIGHT JOIN t1; -- true\r\nSELECT * FROM t0 NATURAL RIGHT JOIN t1 WHERE ((CASE t0.c0 WHEN t0.c0 THEN 1 ELSE NULL END )IS DISTINCT FROM((1+(CASE t1.c1 WHEN t1.c1 THEN 2 ELSE NULL END ))));\r\n-- Expected: 0 1\r\n-- Actual: empty table\r\n```\n\n### OS:\n\nubuntu 22.04\n\n### DuckDB Version:\n\nv0.10.3-dev1500 202ebd80f4\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nSuyang Zhong\n\n### Affiliation:\n\nNUS\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a nightly build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-05-22T14:12:33Z",
  "modified_files": [
    "src/optimizer/rule/move_constants.cpp"
  ]
}