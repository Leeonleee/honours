{
  "repo": "duckdb/duckdb",
  "pull_number": 16732,
  "instance_id": "duckdb__duckdb-16732",
  "issue_numbers": [
    "16662",
    "16662"
  ],
  "base_commit": "09bf1d736d031fb7c49a56201a436a390545c16e",
  "patch": "diff --git a/src/planner/binder/tableref/bind_basetableref.cpp b/src/planner/binder/tableref/bind_basetableref.cpp\nindex d0302a1086e5..a8cf487f4e84 100644\n--- a/src/planner/binder/tableref/bind_basetableref.cpp\n+++ b/src/planner/binder/tableref/bind_basetableref.cpp\n@@ -92,6 +92,16 @@ vector<CatalogSearchEntry> Binder::GetSearchPath(Catalog &catalog, const string\n \treturn view_search_path;\n }\n \n+static vector<LogicalType> ExchangeAllNullTypes(const vector<LogicalType> &types) {\n+\tvector<LogicalType> result = types;\n+\tfor (auto &type : result) {\n+\t\tif (ExpressionBinder::ContainsNullType(type)) {\n+\t\t\ttype = ExpressionBinder::ExchangeNullType(type);\n+\t\t}\n+\t}\n+\treturn result;\n+}\n+\n unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {\n \tQueryErrorContext error_context(ref.query_location);\n \t// CTEs and views are also referred to using BaseTableRefs, hence need to distinguish here\n@@ -305,9 +315,14 @@ unique_ptr<BoundTableRef> Binder::Bind(BaseTableRef &ref) {\n \t\t// verify that the types and names match up with the expected types and names\n \t\tauto &bound_subquery = bound_child->Cast<BoundSubqueryRef>();\n \t\tif (GetBindingMode() != BindingMode::EXTRACT_NAMES) {\n-\t\t\tif (bound_subquery.subquery->types != view_catalog_entry.types) {\n-\t\t\t\tauto actual_types = StringUtil::ToString(bound_subquery.subquery->types, \", \");\n-\t\t\t\tauto expected_types = StringUtil::ToString(view_catalog_entry.types, \", \");\n+\t\t\t// we bind the view subquery and the original view with different \"can_contain_nulls\",\n+\t\t\t// but we don't want to throw an error when SQLNULL does not match up with INTEGER,\n+\t\t\t// so we exchange all SQLNULL with INTEGER here before comparing\n+\t\t\tauto bound_types = ExchangeAllNullTypes(bound_subquery.subquery->types);\n+\t\t\tauto view_types = ExchangeAllNullTypes(view_catalog_entry.types);\n+\t\t\tif (bound_types != view_types) {\n+\t\t\t\tauto actual_types = StringUtil::ToString(bound_types, \", \");\n+\t\t\t\tauto expected_types = StringUtil::ToString(view_types, \", \");\n \t\t\t\tthrow BinderException(\n \t\t\t\t    \"Contents of view were altered: types don't match! Expected [%s], but found [%s] instead\",\n \t\t\t\t    expected_types, actual_types);\n",
  "test_patch": "diff --git a/test/issues/general/test_16662.test b/test/issues/general/test_16662.test\nnew file mode 100644\nindex 000000000000..d18c37d8c16d\n--- /dev/null\n+++ b/test/issues/general/test_16662.test\n@@ -0,0 +1,63 @@\n+# name: test/issues/general/test_16662.test\n+# description: Issue 16662 - Unexpected binder error when using a CTE multiple times\n+# group: [general]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement ok\n+CREATE VIEW\n+  \"tbl1\" AS\n+  -- End of EXAMPLE 4 (pt1)\n+WITH\n+  data_infra as (\n+    select\n+      'a' as AMES,\n+      'b' as TONG\n+      -- Example 6: Unomment out the following line to see it work\n+      -- If there is more than one resulting row in the group by then there is not error\n+      -- union all\n+      -- select\n+      --   'c' as AMES,\n+      --   'b' as TONG\n+      --End Example 6\n+      -- Example 5: Comment out the following line to see it work\n+      -- If there is no group by then there is an error\n+    group by\n+      1\n+      -- End of Example 5\n+  )\n+SELECT\n+  -- Example 1: Comment the following lines to see it work\n+  -- If the CTE is used only once then there is no error\n+  case\n+    when 'b' in (\n+      select\n+        TONG\n+      from\n+        data_infra\n+    ) then 'tong'\n+    else 'Various'\n+  end as collapsed_TONG,\n+  --- End of Example 1\n+  -- Example 2: Comment the following lines to see it work\n+  -- If the CTE is used only once then there is no error\n+  case\n+    when 'ba' in (\n+      select\n+        TONG\n+      from\n+        data_infra\n+    ) then 'ames'\n+    else null\n+  end as collapsed_AMES,\n+  --- End of Example 2\n+  -- Example 3: Delete this line to see it work\n+  -- If there is no null column there is no error\n+  NULL AS NULL_COL;\n+\n+statement ok\n+SELECT\n+  *\n+FROM\n+  \"tbl1\";\n",
  "problem_statement": "Unexpected binder error when using a CTE multiple times\n### What happens?\n\nWe think we found a very specific edge case when upgrading from 1.0.0 to 1.1.0 or 1.2.0. \n\nThe following reproduction sql produces this error and the error can be avoided with any of the changes I have listed in the sql block.  \n\n```\nBinder Error:\nContents of view were altered: types don't match! Expected [VARCHAR, VARCHAR, INTEGER], but found [VARCHAR, VARCHAR, \"NULL\"] instead\n```\n\nWe believe the specific case that causes this error is sql which:\n- creates a view with a null column\n- uses a CTE multiple times\n- the CTE in question needs to have `group by` which results in only a single group (in this example we use group by 1 and have a single row)\n\nThanks so much! \n\n### To Reproduce\n\n```\n-- EXAMPLE 4 (pt1): Comment the following lines to see it work\n-- If you don't create a view then there is no error\nCREATE VIEW\n  \"tbl1\" AS\n  -- End of EXAMPLE 4 (pt1)\nWITH\n  data_infra as (\n    select\n      'a' as AMES,\n      'b' as TONG\n      -- Example 6: Unomment out the following line to see it work\n      -- If there is more than one resulting row in the group by then there is not error\n      -- union all\n      -- select\n      --   'c' as AMES,\n      --   'b' as TONG\n      --End Example 6\n      -- Example 5: Comment out the following line to see it work\n      -- If there is no group by then there is an error\n    group by\n      1\n      -- End of Example 5\n  )\nSELECT\n  -- Example 1: Comment the following lines to see it work\n  -- If the CTE is used only once then there is no error\n  case\n    when 'b' in (\n      select\n        TONG\n      from\n        data_infra\n    ) then 'tong'\n    else 'Various'\n  end as collapsed_TONG,\n  --- End of Example 1\n  -- Example 2: Comment the following lines to see it work\n  -- If the CTE is used only once then there is no error\n  case\n    when 'ba' in (\n      select\n        TONG\n      from\n        data_infra\n    ) then 'ames'\n    else null\n  end as collapsed_AMES,\n  --- End of Example 2\n  -- Example 3: Delete this line to see it work\n  -- If there is no null column there is no error\n  NULL AS NULL_COL;\n\n-- Example 4 (pt2): Comment out the following line to see it work\nSELECT\n  *\nFROM\n  \"tbl1\";\n\n-- End of EXAMPLE 4 (pt2)Exam\n```\n\n### OS:\n\nosx arm64\n\n### DuckDB Version:\n\n1.1.0 or 1.2.0\n\n### DuckDB Client:\n\nCLI\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nAmes Holm\n\n### Affiliation:\n\nWatershed\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nNot applicable - the reproduction does not require a data set\n\n### Did you include all code required to reproduce the issue?\n\n- [x] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [x] Yes, I have\nUnexpected binder error when using a CTE multiple times\n### What happens?\n\nWe think we found a very specific edge case when upgrading from 1.0.0 to 1.1.0 or 1.2.0. \n\nThe following reproduction sql produces this error and the error can be avoided with any of the changes I have listed in the sql block.  \n\n```\nBinder Error:\nContents of view were altered: types don't match! Expected [VARCHAR, VARCHAR, INTEGER], but found [VARCHAR, VARCHAR, \"NULL\"] instead\n```\n\nWe believe the specific case that causes this error is sql which:\n- creates a view with a null column\n- uses a CTE multiple times\n- the CTE in question needs to have `group by` which results in only a single group (in this example we use group by 1 and have a single row)\n\nThanks so much! \n\n### To Reproduce\n\n```\n-- EXAMPLE 4 (pt1): Comment the following lines to see it work\n-- If you don't create a view then there is no error\nCREATE VIEW\n  \"tbl1\" AS\n  -- End of EXAMPLE 4 (pt1)\nWITH\n  data_infra as (\n    select\n      'a' as AMES,\n      'b' as TONG\n      -- Example 6: Unomment out the following line to see it work\n      -- If there is more than one resulting row in the group by then there is not error\n      -- union all\n      -- select\n      --   'c' as AMES,\n      --   'b' as TONG\n      --End Example 6\n      -- Example 5: Comment out the following line to see it work\n      -- If there is no group by then there is an error\n    group by\n      1\n      -- End of Example 5\n  )\nSELECT\n  -- Example 1: Comment the following lines to see it work\n  -- If the CTE is used only once then there is no error\n  case\n    when 'b' in (\n      select\n        TONG\n      from\n        data_infra\n    ) then 'tong'\n    else 'Various'\n  end as collapsed_TONG,\n  --- End of Example 1\n  -- Example 2: Comment the following lines to see it work\n  -- If the CTE is used only once then there is no error\n  case\n    when 'ba' in (\n      select\n        TONG\n      from\n        data_infra\n    ) then 'ames'\n    else null\n  end as collapsed_AMES,\n  --- End of Example 2\n  -- Example 3: Delete this line to see it work\n  -- If there is no null column there is no error\n  NULL AS NULL_COL;\n\n-- Example 4 (pt2): Comment out the following line to see it work\nSELECT\n  *\nFROM\n  \"tbl1\";\n\n-- End of EXAMPLE 4 (pt2)Exam\n```\n\n### OS:\n\nosx arm64\n\n### DuckDB Version:\n\n1.1.0 or 1.2.0\n\n### DuckDB Client:\n\nCLI\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nAmes Holm\n\n### Affiliation:\n\nWatershed\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nNot applicable - the reproduction does not require a data set\n\n### Did you include all code required to reproduce the issue?\n\n- [x] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [x] Yes, I have\n",
  "hints_text": "Thanks for the bug report! I can confirm that this issue was introduced somewhere between v1.0.0 and v1.1.0. I will look into the cause and try to fix.\nAs a workaround, you can do:\n```sql\nSET disabled_optimizers TO 'MATERIALIZED_CTE';\n```\nThanks for the bug report! I can confirm that this issue was introduced somewhere between v1.0.0 and v1.1.0. I will look into the cause and try to fix.\nAs a workaround, you can do:\n```sql\nSET disabled_optimizers TO 'MATERIALIZED_CTE';\n```",
  "created_at": "2025-03-19T16:05:33Z"
}