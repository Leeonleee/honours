{
  "repo": "duckdb/duckdb",
  "pull_number": 1901,
  "instance_id": "duckdb__duckdb-1901",
  "issue_numbers": [
    "1902"
  ],
  "base_commit": "94a0cf9f8db01293c65eb963811e38d44473afa3",
  "patch": "diff --git a/src/catalog/catalog_entry/table_catalog_entry.cpp b/src/catalog/catalog_entry/table_catalog_entry.cpp\nindex ae83e4588ae9..8d71e1f3edd1 100644\n--- a/src/catalog/catalog_entry/table_catalog_entry.cpp\n+++ b/src/catalog/catalog_entry/table_catalog_entry.cpp\n@@ -354,7 +354,7 @@ unique_ptr<CatalogEntry> TableCatalogEntry::ChangeColumnType(ClientContext &cont\n \t\t\tbreak;\n \t\tcase ConstraintType::UNIQUE: {\n \t\t\tauto &bound_unique = (BoundUniqueConstraint &)*bound_constraints[i];\n-\t\t\tif (bound_unique.keys.find(change_idx) != bound_unique.keys.end()) {\n+\t\t\tif (bound_unique.key_set.find(change_idx) != bound_unique.key_set.end()) {\n \t\t\t\tthrow BinderException(\n \t\t\t\t    \"Cannot change the type of a column that has a UNIQUE or PRIMARY KEY constraint specified\");\n \t\t\t}\ndiff --git a/src/execution/index/art/art.cpp b/src/execution/index/art/art.cpp\nindex a486c3095e0d..59b9e9b0ad66 100644\n--- a/src/execution/index/art/art.cpp\n+++ b/src/execution/index/art/art.cpp\n@@ -275,8 +275,16 @@ void ART::VerifyAppend(DataChunk &chunk) {\n \t\t\tcontinue;\n \t\t}\n \t\tif (Lookup(tree, *keys[i], 0) != nullptr) {\n+\t\t\tstring key_name;\n+\t\t\tfor (idx_t k = 0; k < expression_result.ColumnCount(); k++) {\n+\t\t\t\tif (k > 0) {\n+\t\t\t\t\tkey_name += \", \";\n+\t\t\t\t}\n+\t\t\t\tkey_name += unbound_expressions[k]->GetName() + \": \" + expression_result.data[k].GetValue(i).ToString();\n+\t\t\t}\n \t\t\t// node already exists in tree\n-\t\t\tthrow ConstraintException(\"duplicate key value violates primary key or unique constraint\");\n+\t\t\tthrow ConstraintException(\"duplicate key \\\"%s\\\" violates %s constraint\", key_name,\n+\t\t\t                          is_primary ? \"primary key\" : \"unique\");\n \t\t}\n \t}\n }\n@@ -380,6 +388,15 @@ void ART::Delete(IndexLock &state, DataChunk &input, Vector &row_ids) {\n \t\t\tcontinue;\n \t\t}\n \t\tErase(tree, *keys[i], 0, row_identifiers[i]);\n+#ifdef DEBUG\n+\t\tauto node = Lookup(tree, *keys[i], 0);\n+\t\tif (node) {\n+\t\t\tauto leaf = static_cast<Leaf *>(node);\n+\t\t\tfor (idx_t k = 0; k < leaf->num_elements; k++) {\n+\t\t\t\tD_ASSERT(leaf->GetRowId(k) != row_identifiers[i]);\n+\t\t\t}\n+\t\t}\n+#endif\n \t}\n }\n \ndiff --git a/src/function/table/system/pragma_table_info.cpp b/src/function/table/system/pragma_table_info.cpp\nindex 92c4ea9fdd72..08c01a7dcd15 100644\n--- a/src/function/table/system/pragma_table_info.cpp\n+++ b/src/function/table/system/pragma_table_info.cpp\n@@ -80,7 +80,7 @@ static void CheckConstraints(TableCatalogEntry *table, idx_t oid, bool &out_not_\n \t\t}\n \t\tcase ConstraintType::UNIQUE: {\n \t\t\tauto &unique = (BoundUniqueConstraint &)*constraint;\n-\t\t\tif (unique.is_primary_key && unique.keys.find(oid) != unique.keys.end()) {\n+\t\t\tif (unique.is_primary_key && unique.key_set.find(oid) != unique.key_set.end()) {\n \t\t\t\tout_pk = true;\n \t\t\t}\n \t\t\tbreak;\ndiff --git a/src/include/duckdb/planner/constraints/bound_unique_constraint.hpp b/src/include/duckdb/planner/constraints/bound_unique_constraint.hpp\nindex 24d756819eb7..753778218df3 100644\n--- a/src/include/duckdb/planner/constraints/bound_unique_constraint.hpp\n+++ b/src/include/duckdb/planner/constraints/bound_unique_constraint.hpp\n@@ -15,12 +15,19 @@ namespace duckdb {\n \n class BoundUniqueConstraint : public BoundConstraint {\n public:\n-\tBoundUniqueConstraint(unordered_set<idx_t> keys, bool is_primary_key)\n-\t    : BoundConstraint(ConstraintType::UNIQUE), keys(keys), is_primary_key(is_primary_key) {\n+\tBoundUniqueConstraint(vector<idx_t> keys, unordered_set<idx_t> key_set, bool is_primary_key)\n+\t    : BoundConstraint(ConstraintType::UNIQUE), keys(move(keys)), key_set(move(key_set)),\n+\t      is_primary_key(is_primary_key) {\n+\t\tD_ASSERT(keys.size() == key_set.size());\n+\t\tfor (auto &key : keys) {\n+\t\t\tD_ASSERT(key_set.find(key) != key_set.end());\n+\t\t}\n \t}\n \n-\t//! The same keys but represented as an unordered set\n-\tunordered_set<idx_t> keys;\n+\t//! The keys that define the unique constraint\n+\tvector<idx_t> keys;\n+\t//! The same keys but stored as an unordered set\n+\tunordered_set<idx_t> key_set;\n \t//! Whether or not the unique constraint is a primary key\n \tbool is_primary_key;\n };\ndiff --git a/src/planner/binder/statement/bind_create_table.cpp b/src/planner/binder/statement/bind_create_table.cpp\nindex 402a6eeea89d..65f98745fa1c 100644\n--- a/src/planner/binder/statement/bind_create_table.cpp\n+++ b/src/planner/binder/statement/bind_create_table.cpp\n@@ -29,7 +29,7 @@ static void BindConstraints(Binder &binder, BoundCreateTableInfo &info) {\n \tauto &base = (CreateTableInfo &)*info.base;\n \n \tbool has_primary_key = false;\n-\tunordered_set<idx_t> primary_keys;\n+\tvector<idx_t> primary_keys;\n \tfor (idx_t i = 0; i < base.constraints.size(); i++) {\n \t\tauto &cond = base.constraints[i];\n \t\tswitch (cond->type) {\n@@ -55,12 +55,14 @@ static void BindConstraints(Binder &binder, BoundCreateTableInfo &info) {\n \t\tcase ConstraintType::UNIQUE: {\n \t\t\tauto &unique = (UniqueConstraint &)*cond;\n \t\t\t// have to resolve columns of the unique constraint\n-\t\t\tunordered_set<idx_t> keys;\n+\t\t\tvector<idx_t> keys;\n+\t\t\tunordered_set<idx_t> key_set;\n \t\t\tif (unique.index != INVALID_INDEX) {\n \t\t\t\tD_ASSERT(unique.index < base.columns.size());\n \t\t\t\t// unique constraint is given by single index\n \t\t\t\tunique.columns.push_back(base.columns[unique.index].name);\n-\t\t\t\tkeys.insert(unique.index);\n+\t\t\t\tkeys.push_back(unique.index);\n+\t\t\t\tkey_set.insert(unique.index);\n \t\t\t} else {\n \t\t\t\t// unique constraint is given by list of names\n \t\t\t\t// have to resolve names\n@@ -70,12 +72,13 @@ static void BindConstraints(Binder &binder, BoundCreateTableInfo &info) {\n \t\t\t\t\tif (entry == info.name_map.end()) {\n \t\t\t\t\t\tthrow ParserException(\"column \\\"%s\\\" named in key does not exist\", keyname);\n \t\t\t\t\t}\n-\t\t\t\t\tif (keys.find(entry->second) != keys.end()) {\n+\t\t\t\t\tif (key_set.find(entry->second) != key_set.end()) {\n \t\t\t\t\t\tthrow ParserException(\"column \\\"%s\\\" appears twice in \"\n \t\t\t\t\t\t                      \"primary key constraint\",\n \t\t\t\t\t\t                      keyname);\n \t\t\t\t\t}\n-\t\t\t\t\tkeys.insert(entry->second);\n+\t\t\t\t\tkeys.push_back(entry->second);\n+\t\t\t\t\tkey_set.insert(entry->second);\n \t\t\t\t}\n \t\t\t}\n \n@@ -87,7 +90,8 @@ static void BindConstraints(Binder &binder, BoundCreateTableInfo &info) {\n \t\t\t\thas_primary_key = true;\n \t\t\t\tprimary_keys = keys;\n \t\t\t}\n-\t\t\tinfo.bound_constraints.push_back(make_unique<BoundUniqueConstraint>(keys, unique.is_primary_key));\n+\t\t\tinfo.bound_constraints.push_back(\n+\t\t\t    make_unique<BoundUniqueConstraint>(move(keys), move(key_set), unique.is_primary_key));\n \t\t\tbreak;\n \t\t}\n \t\tdefault:\ndiff --git a/src/storage/data_table.cpp b/src/storage/data_table.cpp\nindex a8a86b50ad39..0ffc6f85efb6 100644\n--- a/src/storage/data_table.cpp\n+++ b/src/storage/data_table.cpp\n@@ -480,6 +480,7 @@ void DataTable::Append(Transaction &transaction, DataChunk &chunk, TableAppendSt\n \tD_ASSERT(chunk.ColumnCount() == types.size());\n \tchunk.Verify();\n \n+\tidx_t append_count = chunk.size();\n \tidx_t remaining = chunk.size();\n \twhile (true) {\n \t\tauto current_row_group = state.row_group_append_state.row_group;\n@@ -519,7 +520,7 @@ void DataTable::Append(Transaction &transaction, DataChunk &chunk, TableAppendSt\n \t\t\tbreak;\n \t\t}\n \t}\n-\tstate.current_row += chunk.size();\n+\tstate.current_row += append_count;\n }\n \n void DataTable::ScanTableSegment(idx_t row_start, idx_t count, const std::function<void(DataChunk &chunk)> &function) {\n",
  "test_patch": "diff --git a/test/sql/index/art/index_large_abort.test b/test/sql/index/art/index_large_abort.test\nnew file mode 100644\nindex 000000000000..55f06803cdb9\n--- /dev/null\n+++ b/test/sql/index/art/index_large_abort.test\n@@ -0,0 +1,57 @@\n+# name: test/sql/index/art/index_large_abort.test\n+# description: Test abort of large insertion of negative values into index and verify that all elements are correctly deleted\n+# group: [art]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE a(id INTEGER PRIMARY KEY, c INT);\n+\n+statement ok\n+INSERT INTO a VALUES (1, 4)\n+\n+statement ok\n+BEGIN TRANSACTION\n+\n+statement ok\n+INSERT INTO a SELECT i id, NULL c FROM range(-2, -250000, -1) tbl(i)\n+\n+statement error\n+INSERT INTO a VALUES (1, 5)\n+\n+statement ok\n+ROLLBACK\n+\n+query I\n+SELECT c FROM a WHERE id=1\n+----\n+4\n+\n+query II\n+SELECT * FROM a\n+----\n+1\t4\n+\n+# now with non-null values\n+statement ok\n+BEGIN TRANSACTION\n+\n+statement ok\n+INSERT INTO a SELECT i id, -i c FROM range(-2, -250000, -1) tbl(i)\n+\n+statement error\n+INSERT INTO a VALUES (1, 5)\n+\n+statement ok\n+ROLLBACK\n+\n+query I\n+SELECT c FROM a WHERE id=1\n+----\n+4\n+\n+query II\n+SELECT * FROM a\n+----\n+1\t4\n",
  "problem_statement": "ART not correctly deleting values when dealing with many negative values\nThe ART index does not appear to correctly remove values when there are many negative values stored. See the test case below. In the test we create a table with a single entry (1), and then insert a large number of values. Then within the same transaction we insert a duplicate value, which causes us to force a rollback.\r\n\r\nThis works, but leaves some dangling entries in the ART index, which causes the next batch of the test to fail. This also trips the assertion added in #1901. The specific violating value seems to be `-122882`. \r\n\r\n\r\n```sql\r\n# name: test/sql/index/art/index_large_abort.test\r\n# description: Test abort of large insertion of negative values into index and verify that all elements are correctly deleted\r\n# group: [art]\r\n\r\nstatement ok\r\nPRAGMA enable_verification\r\n\r\nstatement ok\r\nCREATE TABLE a(id INTEGER PRIMARY KEY, c INT);\r\n\r\nstatement ok\r\nINSERT INTO a VALUES (1, 4)\r\n\r\nstatement ok\r\nBEGIN TRANSACTION\r\n\r\nstatement ok\r\nINSERT INTO a SELECT i id, NULL c FROM range(-2, -250000, -1) tbl(i)\r\n\r\nstatement error\r\nINSERT INTO a VALUES (1, 5)\r\n\r\nstatement ok\r\nROLLBACK\r\n\r\nquery I\r\nSELECT c FROM a WHERE id=1\r\n----\r\n4\r\n\r\nquery II\r\nSELECT * FROM a\r\n----\r\n1\t4\r\n\r\n# now with non-null values\r\nstatement ok\r\nBEGIN TRANSACTION\r\n\r\nstatement ok\r\nINSERT INTO a SELECT i id, -i c FROM range(-2, -250000, -1) tbl(i)\r\n\r\nstatement error\r\nINSERT INTO a VALUES (1, 5)\r\n\r\nstatement ok\r\nROLLBACK\r\n\r\nquery I\r\nSELECT c FROM a WHERE id=1\r\n----\r\n4\r\n\r\nquery II\r\nSELECT * FROM a\r\n----\r\n1\t4\r\n\r\n```\n",
  "hints_text": "",
  "created_at": "2021-06-24T06:49:06Z"
}