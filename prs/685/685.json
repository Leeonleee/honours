{
  "repo": "duckdb/duckdb",
  "pull_number": 685,
  "instance_id": "duckdb__duckdb-685",
  "issue_numbers": [
    "673"
  ],
  "base_commit": "2d2996573f217a961f016ec6cdef27ab31738cba",
  "patch": "diff --git a/src/catalog/catalog_entry/table_catalog_entry.cpp b/src/catalog/catalog_entry/table_catalog_entry.cpp\nindex b037f5c976b5..f54964267717 100644\n--- a/src/catalog/catalog_entry/table_catalog_entry.cpp\n+++ b/src/catalog/catalog_entry/table_catalog_entry.cpp\n@@ -24,15 +24,39 @@\n \n #include <algorithm>\n \n-using namespace duckdb;\n using namespace std;\n \n+namespace duckdb {\n+\n+void TableCatalogEntry::AddLowerCaseAliases(unordered_map<string, column_t> &name_map) {\n+\tunordered_map<string, column_t> extra_lowercase_names;\n+\tfor(auto &entry : name_map) {\n+\t\tauto lcase = StringUtil::Lower(entry.first);\n+\t\t// check the lowercase name map if there already exists a lowercase version\n+\t\tif (extra_lowercase_names.find(lcase) == extra_lowercase_names.end()) {\n+\t\t\t// not yet: add the mapping\n+\t\t\textra_lowercase_names[lcase] = entry.second;\n+\t\t} else {\n+\t\t\t// the lowercase already exists: set it to invalid index\n+\t\t\textra_lowercase_names[lcase] = INVALID_INDEX;\n+\t\t}\n+\t}\n+\t// for any new lowercase names, add them to the original name map\n+\tfor(auto &entry : extra_lowercase_names) {\n+\t\tif (entry.second != INVALID_INDEX) {\n+\t\t\tname_map[entry.first] = entry.second;\n+\t\t}\n+\t}\n+}\n+\n TableCatalogEntry::TableCatalogEntry(Catalog *catalog, SchemaCatalogEntry *schema, BoundCreateTableInfo *info,\n                                      std::shared_ptr<DataTable> inherited_storage)\n     : StandardEntry(CatalogType::TABLE, schema, catalog, info->Base().table), storage(inherited_storage),\n       columns(move(info->Base().columns)), constraints(move(info->Base().constraints)),\n       bound_constraints(move(info->bound_constraints)), name_map(info->name_map) {\n \tthis->temporary = info->Base().temporary;\n+\t// add lower case aliases\n+\tAddLowerCaseAliases(name_map);\n \t// add the \"rowid\" alias, if there is no rowid column specified in the table\n \tif (name_map.find(\"rowid\") == name_map.end()) {\n \t\tname_map[\"rowid\"] = COLUMN_IDENTIFIER_ROW_ID;\n@@ -442,3 +466,5 @@ unique_ptr<CatalogEntry> TableCatalogEntry::Copy(ClientContext &context) {\n void TableCatalogEntry::SetAsRoot() {\n \tstorage->SetAsRoot();\n }\n+\n+}\ndiff --git a/src/include/duckdb/catalog/catalog_entry/table_catalog_entry.hpp b/src/include/duckdb/catalog/catalog_entry/table_catalog_entry.hpp\nindex 1a418b6625aa..f948952a20b7 100644\n--- a/src/include/duckdb/catalog/catalog_entry/table_catalog_entry.hpp\n+++ b/src/include/duckdb/catalog/catalog_entry/table_catalog_entry.hpp\n@@ -58,6 +58,9 @@ class TableCatalogEntry : public StandardEntry {\n \t//! Returns a list of types of the specified columns of the table\n \tvector<TypeId> GetTypes(const vector<column_t> &column_ids);\n \n+\t//! Add lower case aliases to a name map (e.g. \"Hello\" -> \"hello\" is also acceptable)\n+\tstatic void AddLowerCaseAliases(unordered_map<string, column_t> &name_map);\n+\n \t//! Serialize the meta information of the TableCatalogEntry a serializer\n \tvirtual void Serialize(Serializer &serializer);\n \t//! Deserializes to a CreateTableInfo\ndiff --git a/src/include/duckdb/planner/table_binding.hpp b/src/include/duckdb/planner/table_binding.hpp\nindex e93ff4348f87..516c2b8601c6 100644\n--- a/src/include/duckdb/planner/table_binding.hpp\n+++ b/src/include/duckdb/planner/table_binding.hpp\n@@ -65,7 +65,7 @@ struct GenericBinding : public Binding {\n \t//! Column names of the subquery\n \tvector<string> names;\n \t//! Name -> index for the names\n-\tunordered_map<string, uint64_t> name_map;\n+\tunordered_map<string, column_t> name_map;\n \n public:\n \tbool HasMatchingBinding(const string &column_name) override;\ndiff --git a/src/planner/table_binding.cpp b/src/planner/table_binding.cpp\nindex f7fc43b85e6d..baabb150f96b 100644\n--- a/src/planner/table_binding.cpp\n+++ b/src/planner/table_binding.cpp\n@@ -81,6 +81,7 @@ GenericBinding::GenericBinding(const string &alias, vector<SQLType> coltypes, ve\n \t\t}\n \t\tname_map[name] = i;\n \t}\n+\tTableCatalogEntry::AddLowerCaseAliases(name_map);\n }\n \n bool GenericBinding::HasMatchingBinding(const string &column_name) {\n",
  "test_patch": "diff --git a/test/sql/CMakeLists.txt b/test/sql/CMakeLists.txt\nindex 523825d63008..9efce803a435 100644\n--- a/test/sql/CMakeLists.txt\n+++ b/test/sql/CMakeLists.txt\n@@ -1,6 +1,7 @@\n add_subdirectory(aggregate)\n add_subdirectory(append)\n add_subdirectory(blob)\n+add_subdirectory(binder)\n add_subdirectory(catalog)\n add_subdirectory(collate)\n add_subdirectory(create)\ndiff --git a/test/sql/binder/CMakeLists.txt b/test/sql/binder/CMakeLists.txt\nnew file mode 100644\nindex 000000000000..af8c8f5d4b80\n--- /dev/null\n+++ b/test/sql/binder/CMakeLists.txt\n@@ -0,0 +1,4 @@\n+add_library_unity(test_sql_binder OBJECT test_case_insensitive_binding.cpp)\n+set(ALL_OBJECT_FILES\n+    ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:test_sql_binder>\n+    PARENT_SCOPE)\ndiff --git a/test/sql/binder/test_case_insensitive_binding.cpp b/test/sql/binder/test_case_insensitive_binding.cpp\nnew file mode 100644\nindex 000000000000..b942f2380bed\n--- /dev/null\n+++ b/test/sql/binder/test_case_insensitive_binding.cpp\n@@ -0,0 +1,79 @@\n+#include \"catch.hpp\"\n+#include \"test_helpers.hpp\"\n+\n+using namespace duckdb;\n+using namespace std;\n+\n+TEST_CASE(\"Test case insensitive binding of columns\", \"[binder]\") {\n+\tunique_ptr<QueryResult> result;\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\tcon.EnableQueryVerification();\n+\n+\t// we can bind case insensitive column names\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE test (\\\"HeLlO\\\" INTEGER)\"));\n+\n+\t// lowercase names are aliased\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT HeLlO FROM test\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT hello FROM test\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT \\\"HeLlO\\\" FROM test\"));\n+\t// specifying a different, non-lower, case does fail!\n+\tREQUIRE_FAIL(con.Query(\"SELECT \\\"HELLO\\\" FROM test\"));\n+\tREQUIRE_FAIL(con.Query(\"SELECT \\\"HELLo\\\" FROM test\"));\n+\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT test.HeLlO FROM test\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT test.hello FROM test\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT test.\\\"HeLlO\\\" FROM test\"));\n+\tREQUIRE_FAIL(con.Query(\"SELECT test.\\\"HELLO\\\" FROM test\"));\n+\tREQUIRE_FAIL(con.Query(\"SELECT test.\\\"HELLo\\\" FROM test\"));\n+\n+\tREQUIRE_NO_FAIL(con.Query(\"UPDATE test SET hello=3\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"UPDATE test SET HeLlO=3\"));\n+\n+\t// but ONLY if there are no conflicts!\n+\t// if the reference is ambiguous (e.g. hello -> HeLlO, HELLO) the name must match exactly\n+\tREQUIRE_NO_FAIL(con.Query(\"DROP TABLE test\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE test(\\\"HeLlO\\\" INTEGER, \\\"HELLO\\\" INTEGER)\"));\n+\n+\tREQUIRE_FAIL(con.Query(\"SELECT HeLlO FROM test\"));\n+\tREQUIRE_FAIL(con.Query(\"SELECT hello FROM test\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT \\\"HeLlO\\\" FROM test\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT \\\"HELLO\\\" FROM test\"));\n+\tREQUIRE_FAIL(con.Query(\"SELECT \\\"HELLo\\\" FROM test\"));\n+\tREQUIRE_FAIL(con.Query(\"UPDATE test SET hello = 3\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"UPDATE test SET \\\"HeLlO\\\" = 3\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"UPDATE test SET \\\"HELLO\\\" = 3\"));\n+\n+\tREQUIRE_FAIL(con.Query(\"SELECT test.HeLlO FROM test\"));\n+\tREQUIRE_FAIL(con.Query(\"SELECT test.hello FROM test\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT test.\\\"HeLlO\\\" FROM test\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT test.\\\"HELLO\\\" FROM test\"));\n+\tREQUIRE_FAIL(con.Query(\"SELECT test.\\\"HELLo\\\" FROM test\"));\n+\n+\t// conflicts can also come from different sources!\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE test1(\\\"HeLlO\\\" INTEGER)\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE test2(\\\"HELLO\\\" INTEGER)\"));\n+\n+\tREQUIRE_FAIL(con.Query(\"SELECT HeLlO FROM test1, test2\"));\n+\tREQUIRE_FAIL(con.Query(\"SELECT hello FROM test1, test2\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT \\\"HeLlO\\\" FROM test1, test2\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT \\\"HELLO\\\" FROM test1, test2\"));\n+\tREQUIRE_FAIL(con.Query(\"SELECT \\\"HELLo\\\" FROM test1, test2\"));\n+\n+\t// in this case we can eliminate the conflict by specifically selecting the source\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT test1.HeLlO FROM test1, test2\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT test1.hello FROM test1, test2\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT test1.\\\"HeLlO\\\" FROM test1, test2\"));\n+\tREQUIRE_FAIL(con.Query(\"SELECT test1.\\\"HELLO\\\" FROM test1, test2\"));\n+\tREQUIRE_FAIL(con.Query(\"SELECT test1.\\\"HELLo\\\" FROM test1, test2\"));\n+\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT test2.HeLlO FROM test1, test2\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT test2.hello FROM test1, test2\"));\n+\tREQUIRE_FAIL(con.Query(\"SELECT test2.\\\"HeLlO\\\" FROM test1, test2\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT test2.\\\"HELLO\\\" FROM test1, test2\"));\n+\tREQUIRE_FAIL(con.Query(\"SELECT test2.\\\"HELLo\\\" FROM test1, test2\"));\n+\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT * FROM test1 JOIN test2 USING (hello)\"));\n+\n+\tREQUIRE_NO_FAIL(con.Query(\"SELECT hello FROM (SELECT 42) tbl(\\\"HeLlO\\\")\"));\n+}\n",
  "problem_statement": "Case insensitivity for header names in read_csv_auto\nCurrently the header names in read_csv_auto are read as-is, which means case is preserved.  For example, consider this CSV file:\r\n\r\n**test.csv**\r\n```\r\nFlightDate|UniqueCarrier|OriginCityName|DestCityName\r\n1988-01-01|AA|New York, NY|Los Angeles, CA\r\n1988-01-02|AA|New York, NY|Los Angeles, CA\r\n1988-01-03|AA|New York, NY|Los Angeles, CA\r\n```\r\n\r\nThe file is correctly loaded:\r\n```sql\r\nSELECT * FROM read_csv_auto('test.csv');\r\n```\r\n\r\n|FlightDate|UniqueCarrier| OriginCityName  | DestCityName  |\r\n|---------:|------------:|----------------:|--------------:|\r\n|1988-01-01|AA           |New York, NY     |Los Angeles, CA|\r\n|1988-01-02|AA           |New York, NY     |Los Angeles, CA|\r\n|1988-01-03|AA           |New York, NY     |Los Angeles, CA|\r\n\r\nHowever, the names must be quoted to use them in the query:\r\n\r\n```sql\r\nSELECT flightdate FROM read_csv_auto('test.csv');\r\n-- error!\r\nSELECT FlightDate FROM read_csv_auto('test.csv');\r\n-- error!\r\nSELECT \"FlightDate\" FROM read_csv_auto('test.csv');\r\n-- correct\r\n```\r\n\r\nI think we should lowercase them before loading so the behavior is more \"as expected\".\r\n\n",
  "hints_text": "I just ran into this in my testing. I was about to report, but you beat me to it!\nAfter some discussion we have decided to solve this in a different manner: in table and column name binding we will now also consider case insensitive alternatives when there are no conflicts. Eg if we have a column name with \u201cFlightDate\u201d, the column \u201cflightdate\u201d will match it as long as no conflicting alternative exists (e.g. if \u201cFLIGHTDATE\u201d also exists we will throw an error). In case of existing conflicts the name must match exactly.",
  "created_at": "2020-06-15T18:18:20Z"
}