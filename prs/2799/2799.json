{
  "repo": "duckdb/duckdb",
  "pull_number": 2799,
  "instance_id": "duckdb__duckdb-2799",
  "issue_numbers": [
    "2791",
    "2791"
  ],
  "base_commit": "0f8960ac31b2e493d1e52ddd930fbb8fa100741b",
  "patch": "diff --git a/src/common/row_operations/row_gather.cpp b/src/common/row_operations/row_gather.cpp\nindex 3999a29da3cc..ce636289f04f 100644\n--- a/src/common/row_operations/row_gather.cpp\n+++ b/src/common/row_operations/row_gather.cpp\n@@ -47,8 +47,8 @@ static void GatherNestedVector(Vector &rows, const SelectionVector &row_sel, Vec\n \tauto ptrs = FlatVector::GetData<data_ptr_t>(rows);\n \n \t// Build the gather locations\n-\tdata_ptr_t data_locations[STANDARD_VECTOR_SIZE];\n-\tdata_ptr_t mask_locations[STANDARD_VECTOR_SIZE];\n+\tauto data_locations = unique_ptr<data_ptr_t[]>(new data_ptr_t[count]);\n+\tauto mask_locations = unique_ptr<data_ptr_t[]>(new data_ptr_t[count]);\n \tfor (idx_t i = 0; i < count; i++) {\n \t\tauto row_idx = row_sel.get_index(i);\n \t\tmask_locations[i] = ptrs[row_idx];\n@@ -56,7 +56,7 @@ static void GatherNestedVector(Vector &rows, const SelectionVector &row_sel, Vec\n \t}\n \n \t// Deserialise into the selected locations\n-\tRowOperations::HeapGather(col, count, col_sel, col_no, data_locations, mask_locations);\n+\tRowOperations::HeapGather(col, count, col_sel, col_no, data_locations.get(), mask_locations.get());\n }\n \n void RowOperations::Gather(Vector &rows, const SelectionVector &row_sel, Vector &col, const SelectionVector &col_sel,\n",
  "test_patch": "diff --git a/test/sql/join/inner/list_join.test b/test/sql/join/inner/list_join.test\nnew file mode 100644\nindex 000000000000..6a018c7329a6\n--- /dev/null\n+++ b/test/sql/join/inner/list_join.test\n@@ -0,0 +1,18 @@\n+# name: test/sql/join/inner/list_join.test\n+# description: Join on large lists\n+# group: [inner]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE test (id INTEGER, l VARCHAR[]);\n+\n+statement ok\n+INSERT INTO test SELECT i, case when (i/1000)%2=0 then ARRAY[1::VARCHAR, 1::VARCHAR, 1::VARCHAR] else ARRAY[2::VARCHAR, 2::VARCHAR] end FROM generate_series(0, 1999, 1) tbl(i);\n+\n+query IIII\n+SELECT * FROM test AS t1 LEFT JOIN test AS t2 ON t1.id=t2.id WHERE t1.l!=t2.l or t1.id!=t2.id;\n+----\n+\n+\n",
  "problem_statement": "out of bounds error in join query with filter on list column\nRan in v0.3.1 88aa81c6b in transient mode on an M1 Mac\r\n```\r\nCREATE TABLE test (id INTEGER, l VARCHAR[]);\r\nINSERT INTO test SELECT i, case when (i/1000)%2=0 then [1::VARCHAR, 1::VARCHAR, 1::VARCHAR] else [2::VARCHAR, 2::VARCHAR] end FROM range(2000) tbl(i);\r\nSELECT * FROM test AS t1 LEFT JOIN test AS t2 ON t1.id=t2.id WHERE t1.l!=t2.l or t1.id!=t2.id;\r\n```\r\n\r\nresult: ```[1]    90267 bus error  ./duckdb```\r\n\r\nexpected result: empty result set\r\n\r\nRunning in debug build I get the message: \r\n```/src/common/row_operations/row_gather.cpp:54:19: runtime error: index 1024 out of bounds for type 'data_t *[1024]'```\r\n\r\nThe problem seems to be that the GatherNestedVector function does not expect vectors with more than STANDARD_VECTOR_COUNT values, which happens in this query because of the filter on the list column\nout of bounds error in join query with filter on list column\nRan in v0.3.1 88aa81c6b in transient mode on an M1 Mac\r\n```\r\nCREATE TABLE test (id INTEGER, l VARCHAR[]);\r\nINSERT INTO test SELECT i, case when (i/1000)%2=0 then [1::VARCHAR, 1::VARCHAR, 1::VARCHAR] else [2::VARCHAR, 2::VARCHAR] end FROM range(2000) tbl(i);\r\nSELECT * FROM test AS t1 LEFT JOIN test AS t2 ON t1.id=t2.id WHERE t1.l!=t2.l or t1.id!=t2.id;\r\n```\r\n\r\nresult: ```[1]    90267 bus error  ./duckdb```\r\n\r\nexpected result: empty result set\r\n\r\nRunning in debug build I get the message: \r\n```/src/common/row_operations/row_gather.cpp:54:19: runtime error: index 1024 out of bounds for type 'data_t *[1024]'```\r\n\r\nThe problem seems to be that the GatherNestedVector function does not expect vectors with more than STANDARD_VECTOR_COUNT values, which happens in this query because of the filter on the list column\n",
  "hints_text": "I get same error on Suse12. \r\n  #### duckdb/build/debug> ./duckdb\r\n  v0.3.2-dev556 3c1a9e3b7\r\n  Enter \".help\" for usage hints.\r\n  Connected to a transient in-memory database.\r\n  Use \".open FILENAME\" to reopen on a persistent database.\r\n  D CREATE TABLE test (id INTEGER, l VARCHAR[]);\r\n  D INSERT INTO test SELECT i, case when (i/1000)%2=0 then [1::VARCHAR, 1::VARCHAR, 1::VARCHAR] else [2::VARCHAR, 2::VARCHAR] end FROM range(2000) tbl(i);\r\n  D SELECT * FROM test AS t1 LEFT JOIN test AS t2 ON t1.id=t2.id WHERE t1.l!=t2.l or t1.id!=t2.id;\r\n  #####/git/duckdb/src/common/row_operations/row_gather.cpp:54:19: runtime error: index 1024 out of bounds for type 'data_t *[1024]'\r\n\r\nFor release version, the query never stop. Got coredump once use strace to attach.\nI get same error on Suse12. \r\n  #### duckdb/build/debug> ./duckdb\r\n  v0.3.2-dev556 3c1a9e3b7\r\n  Enter \".help\" for usage hints.\r\n  Connected to a transient in-memory database.\r\n  Use \".open FILENAME\" to reopen on a persistent database.\r\n  D CREATE TABLE test (id INTEGER, l VARCHAR[]);\r\n  D INSERT INTO test SELECT i, case when (i/1000)%2=0 then [1::VARCHAR, 1::VARCHAR, 1::VARCHAR] else [2::VARCHAR, 2::VARCHAR] end FROM range(2000) tbl(i);\r\n  D SELECT * FROM test AS t1 LEFT JOIN test AS t2 ON t1.id=t2.id WHERE t1.l!=t2.l or t1.id!=t2.id;\r\n  #####/git/duckdb/src/common/row_operations/row_gather.cpp:54:19: runtime error: index 1024 out of bounds for type 'data_t *[1024]'\r\n\r\nFor release version, the query never stop. Got coredump once use strace to attach.",
  "created_at": "2021-12-15T14:28:34Z"
}