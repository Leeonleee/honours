You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
out of bounds error in join query with filter on list column
Ran in v0.3.1 88aa81c6b in transient mode on an M1 Mac
```
CREATE TABLE test (id INTEGER, l VARCHAR[]);
INSERT INTO test SELECT i, case when (i/1000)%2=0 then [1::VARCHAR, 1::VARCHAR, 1::VARCHAR] else [2::VARCHAR, 2::VARCHAR] end FROM range(2000) tbl(i);
SELECT * FROM test AS t1 LEFT JOIN test AS t2 ON t1.id=t2.id WHERE t1.l!=t2.l or t1.id!=t2.id;
```

result: ```[1]    90267 bus error  ./duckdb```

expected result: empty result set

Running in debug build I get the message: 
```/src/common/row_operations/row_gather.cpp:54:19: runtime error: index 1024 out of bounds for type 'data_t *[1024]'```

The problem seems to be that the GatherNestedVector function does not expect vectors with more than STANDARD_VECTOR_COUNT values, which happens in this query because of the filter on the list column
out of bounds error in join query with filter on list column
Ran in v0.3.1 88aa81c6b in transient mode on an M1 Mac
```
CREATE TABLE test (id INTEGER, l VARCHAR[]);
INSERT INTO test SELECT i, case when (i/1000)%2=0 then [1::VARCHAR, 1::VARCHAR, 1::VARCHAR] else [2::VARCHAR, 2::VARCHAR] end FROM range(2000) tbl(i);
SELECT * FROM test AS t1 LEFT JOIN test AS t2 ON t1.id=t2.id WHERE t1.l!=t2.l or t1.id!=t2.id;
```

result: ```[1]    90267 bus error  ./duckdb```

expected result: empty result set

Running in debug build I get the message: 
```/src/common/row_operations/row_gather.cpp:54:19: runtime error: index 1024 out of bounds for type 'data_t *[1024]'```

The problem seems to be that the GatherNestedVector function does not expect vectors with more than STANDARD_VECTOR_COUNT values, which happens in this query because of the filter on the list column

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16: </p>
17: 
18: ## DuckDB
19: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/docs/why_duckdb.html).
20: 
21: ## Installation
22: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
23: 
24: ## Data Import
25: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
26: 
27: ```sql
28: SELECT * FROM 'myfile.csv';
29: SELECT * FROM 'myfile.parquet';
30: ```
31: 
32: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
33: 
34: ## SQL Reference
35: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
36: 
37: ## Development
38: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
39: 
40: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
41: 
42: 
[end of README.md]
[start of src/common/row_operations/row_gather.cpp]
1: //===--------------------------------------------------------------------===//
2: // row_gather.cpp
3: // Description: This file contains the implementation of the gather operators
4: //===--------------------------------------------------------------------===//
5: 
6: #include "duckdb/common/exception.hpp"
7: #include "duckdb/common/operator/constant_operators.hpp"
8: #include "duckdb/common/row_operations/row_operations.hpp"
9: #include "duckdb/common/types/row_data_collection.hpp"
10: #include "duckdb/common/types/row_layout.hpp"
11: 
12: namespace duckdb {
13: 
14: using ValidityBytes = RowLayout::ValidityBytes;
15: 
16: template <class T>
17: static void TemplatedGatherLoop(Vector &rows, const SelectionVector &row_sel, Vector &col,
18:                                 const SelectionVector &col_sel, idx_t count, idx_t col_offset, idx_t col_no,
19:                                 idx_t build_size) {
20: 	// Precompute mask indexes
21: 	idx_t entry_idx;
22: 	idx_t idx_in_entry;
23: 	ValidityBytes::GetEntryIndex(col_no, entry_idx, idx_in_entry);
24: 
25: 	auto ptrs = FlatVector::GetData<data_ptr_t>(rows);
26: 	auto data = FlatVector::GetData<T>(col);
27: 	auto &col_mask = FlatVector::Validity(col);
28: 
29: 	for (idx_t i = 0; i < count; i++) {
30: 		auto row_idx = row_sel.get_index(i);
31: 		auto row = ptrs[row_idx];
32: 		auto col_idx = col_sel.get_index(i);
33: 		data[col_idx] = Load<T>(row + col_offset);
34: 		ValidityBytes row_mask(row);
35: 		if (!row_mask.RowIsValid(row_mask.GetValidityEntry(entry_idx), idx_in_entry)) {
36: 			if (build_size > STANDARD_VECTOR_SIZE && col_mask.AllValid()) {
37: 				//! We need to initialize the mask with the vector size.
38: 				col_mask.Initialize(build_size);
39: 			}
40: 			col_mask.SetInvalid(col_idx);
41: 		}
42: 	}
43: }
44: 
45: static void GatherNestedVector(Vector &rows, const SelectionVector &row_sel, Vector &col,
46:                                const SelectionVector &col_sel, idx_t count, idx_t col_offset, idx_t col_no) {
47: 	auto ptrs = FlatVector::GetData<data_ptr_t>(rows);
48: 
49: 	// Build the gather locations
50: 	data_ptr_t data_locations[STANDARD_VECTOR_SIZE];
51: 	data_ptr_t mask_locations[STANDARD_VECTOR_SIZE];
52: 	for (idx_t i = 0; i < count; i++) {
53: 		auto row_idx = row_sel.get_index(i);
54: 		mask_locations[i] = ptrs[row_idx];
55: 		data_locations[i] = Load<data_ptr_t>(ptrs[row_idx] + col_offset);
56: 	}
57: 
58: 	// Deserialise into the selected locations
59: 	RowOperations::HeapGather(col, count, col_sel, col_no, data_locations, mask_locations);
60: }
61: 
62: void RowOperations::Gather(Vector &rows, const SelectionVector &row_sel, Vector &col, const SelectionVector &col_sel,
63:                            const idx_t count, const idx_t col_offset, const idx_t col_no, const idx_t build_size) {
64: 	D_ASSERT(rows.GetVectorType() == VectorType::FLAT_VECTOR);
65: 	D_ASSERT(rows.GetType().id() == LogicalTypeId::POINTER); // "Cannot gather from non-pointer type!"
66: 
67: 	col.SetVectorType(VectorType::FLAT_VECTOR);
68: 	switch (col.GetType().InternalType()) {
69: 	case PhysicalType::UINT8:
70: 		TemplatedGatherLoop<uint8_t>(rows, row_sel, col, col_sel, count, col_offset, col_no, build_size);
71: 		break;
72: 	case PhysicalType::UINT16:
73: 		TemplatedGatherLoop<uint16_t>(rows, row_sel, col, col_sel, count, col_offset, col_no, build_size);
74: 		break;
75: 	case PhysicalType::UINT32:
76: 		TemplatedGatherLoop<uint32_t>(rows, row_sel, col, col_sel, count, col_offset, col_no, build_size);
77: 		break;
78: 	case PhysicalType::UINT64:
79: 		TemplatedGatherLoop<uint64_t>(rows, row_sel, col, col_sel, count, col_offset, col_no, build_size);
80: 		break;
81: 	case PhysicalType::BOOL:
82: 	case PhysicalType::INT8:
83: 		TemplatedGatherLoop<int8_t>(rows, row_sel, col, col_sel, count, col_offset, col_no, build_size);
84: 		break;
85: 	case PhysicalType::INT16:
86: 		TemplatedGatherLoop<int16_t>(rows, row_sel, col, col_sel, count, col_offset, col_no, build_size);
87: 		break;
88: 	case PhysicalType::INT32:
89: 		TemplatedGatherLoop<int32_t>(rows, row_sel, col, col_sel, count, col_offset, col_no, build_size);
90: 		break;
91: 	case PhysicalType::INT64:
92: 		TemplatedGatherLoop<int64_t>(rows, row_sel, col, col_sel, count, col_offset, col_no, build_size);
93: 		break;
94: 	case PhysicalType::INT128:
95: 		TemplatedGatherLoop<hugeint_t>(rows, row_sel, col, col_sel, count, col_offset, col_no, build_size);
96: 		break;
97: 	case PhysicalType::FLOAT:
98: 		TemplatedGatherLoop<float>(rows, row_sel, col, col_sel, count, col_offset, col_no, build_size);
99: 		break;
100: 	case PhysicalType::DOUBLE:
101: 		TemplatedGatherLoop<double>(rows, row_sel, col, col_sel, count, col_offset, col_no, build_size);
102: 		break;
103: 	case PhysicalType::INTERVAL:
104: 		TemplatedGatherLoop<interval_t>(rows, row_sel, col, col_sel, count, col_offset, col_no, build_size);
105: 		break;
106: 	case PhysicalType::VARCHAR:
107: 		TemplatedGatherLoop<string_t>(rows, row_sel, col, col_sel, count, col_offset, col_no, build_size);
108: 		break;
109: 	case PhysicalType::LIST:
110: 	case PhysicalType::MAP:
111: 	case PhysicalType::STRUCT:
112: 		GatherNestedVector(rows, row_sel, col, col_sel, count, col_offset, col_no);
113: 		break;
114: 	default:
115: 		throw InternalException("Unimplemented type for RowOperations::Gather");
116: 	}
117: }
118: 
119: template <class T>
120: static void TemplatedFullScanLoop(Vector &rows, Vector &col, idx_t count, idx_t col_offset, idx_t col_no) {
121: 	// Precompute mask indexes
122: 	idx_t entry_idx;
123: 	idx_t idx_in_entry;
124: 	ValidityBytes::GetEntryIndex(col_no, entry_idx, idx_in_entry);
125: 
126: 	auto ptrs = FlatVector::GetData<data_ptr_t>(rows);
127: 	auto data = FlatVector::GetData<T>(col);
128: 	//	auto &col_mask = FlatVector::Validity(col);
129: 
130: 	for (idx_t i = 0; i < count; i++) {
131: 		auto row = ptrs[i];
132: 		data[i] = Load<T>(row + col_offset);
133: 		ValidityBytes row_mask(row);
134: 		if (!row_mask.RowIsValid(row_mask.GetValidityEntry(entry_idx), idx_in_entry)) {
135: 			throw InternalException("Null value comparisons not implemented for perfect hash table yet");
136: 			//			col_mask.SetInvalid(i);
137: 		}
138: 	}
139: }
140: 
141: void RowOperations::FullScanColumn(const RowLayout &layout, Vector &rows, Vector &col, idx_t count, idx_t col_no) {
142: 	const auto col_offset = layout.GetOffsets()[col_no];
143: 	col.SetVectorType(VectorType::FLAT_VECTOR);
144: 	switch (col.GetType().InternalType()) {
145: 	case PhysicalType::UINT8:
146: 		TemplatedFullScanLoop<uint8_t>(rows, col, count, col_offset, col_no);
147: 		break;
148: 	case PhysicalType::UINT16:
149: 		TemplatedFullScanLoop<uint16_t>(rows, col, count, col_offset, col_no);
150: 		break;
151: 	case PhysicalType::UINT32:
152: 		TemplatedFullScanLoop<uint32_t>(rows, col, count, col_offset, col_no);
153: 		break;
154: 	case PhysicalType::UINT64:
155: 		TemplatedFullScanLoop<uint64_t>(rows, col, count, col_offset, col_no);
156: 		break;
157: 	case PhysicalType::INT8:
158: 		TemplatedFullScanLoop<int8_t>(rows, col, count, col_offset, col_no);
159: 		break;
160: 	case PhysicalType::INT16:
161: 		TemplatedFullScanLoop<int16_t>(rows, col, count, col_offset, col_no);
162: 		break;
163: 	case PhysicalType::INT32:
164: 		TemplatedFullScanLoop<int32_t>(rows, col, count, col_offset, col_no);
165: 		break;
166: 	case PhysicalType::INT64:
167: 		TemplatedFullScanLoop<int64_t>(rows, col, count, col_offset, col_no);
168: 		break;
169: 	default:
170: 		throw NotImplementedException("Unimplemented type for RowOperations::FullScanColumn");
171: 	}
172: }
173: 
174: } // namespace duckdb
[end of src/common/row_operations/row_gather.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: