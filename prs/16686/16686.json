{
  "repo": "duckdb/duckdb",
  "pull_number": 16686,
  "instance_id": "duckdb__duckdb-16686",
  "issue_numbers": [
    "16671"
  ],
  "base_commit": "2b273c839e3782d417d49d0101503b0151b3b9fd",
  "patch": "diff --git a/src/optimizer/pushdown/pushdown_projection.cpp b/src/optimizer/pushdown/pushdown_projection.cpp\nindex b10b60ae4c0b..4646b894e12a 100644\n--- a/src/optimizer/pushdown/pushdown_projection.cpp\n+++ b/src/optimizer/pushdown/pushdown_projection.cpp\n@@ -32,7 +32,11 @@ static unique_ptr<Expression> ReplaceProjectionBindings(LogicalProjection &proj,\n \t\tD_ASSERT(colref.binding.column_index < proj.expressions.size());\n \t\tD_ASSERT(colref.depth == 0);\n \t\t// replace the binding with a copy to the expression at the referenced index\n-\t\treturn proj.expressions[colref.binding.column_index]->Copy();\n+\t\tauto copy = proj.expressions[colref.binding.column_index]->Copy();\n+\t\tif (!colref.alias.empty()) {\n+\t\t\tcopy->alias = colref.alias;\n+\t\t}\n+\t\treturn copy;\n \t}\n \tExpressionIterator::EnumerateChildren(\n \t    *expr, [&](unique_ptr<Expression> &child) { child = ReplaceProjectionBindings(proj, std::move(child)); });\n",
  "test_patch": "diff --git a/test/optimizer/pushdown/issue_16671.test b/test/optimizer/pushdown/issue_16671.test\nnew file mode 100644\nindex 000000000000..1fc8c0d37bbb\n--- /dev/null\n+++ b/test/optimizer/pushdown/issue_16671.test\n@@ -0,0 +1,18 @@\n+# name: test/optimizer/pushdown/issue_16671.test\n+# description: Test keeping alias in filter pushdown\n+# group: [pushdown]\n+\n+require json\n+\n+statement ok\n+set variable W to '{\"a\":[1,2], \"b\":[2,4]}';\n+\n+query II\n+from (values (1,2),(2,3),(3,1),(1,2),(2,3),(2,4), (3,2))  test (a,b)\n+select *\n+where (getvariable('W') -> '/'||alias(columns(getvariable('W').json_keys())))\n+    .json_contains(columns(getvariable('W').json_keys()));\n+----\n+1\t2\n+1\t2\n+2\t4\n",
  "problem_statement": "Empty Table with Filter pushdown and columns(*)\n### What happens?\n\nthanks,\nI was trying to achieve some dynamic filtering and wrote the following.\nIt compute the expression correctly if it is not in where clause (you can see it by replacing the `where` with `,`) . \nAs soon as you put it in the where clause, it return an empty table. \nThe table is empty even if you put a `not` before the expression. \nIt works if I set  `SET disabled_optimizers = 'filter_pushdown';`\n\n### To Reproduce\n\n\n```\nset variable W to '{\"a\":[1,2], \"b\":[2,4]}';\nfrom (values (1,2),(2,3),(3,1),(1,2),(2,3),(2,4), (3,2))  test (a,b)\nselect *\nwhere (getvariable('W') -> '/'||alias(columns(getvariable('W').json_keys())))\n    .json_contains(columns(getvariable('W').json_keys()));\n```\n\nexpected result:\n| a | b |\n|--:|--:|\n| 1 | 2 |\n| 1 | 2 |\n| 2 | 4 |\n\nactual result: 0 row\n\nI hope I wrote the issue correctly, have a nice day!\n\n### OS:\n\nWindows\n\n### DuckDB Version:\n\nv1.2.1 8e52ec4395\n\n### DuckDB Client:\n\ncommand line\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nGiorgio Serravalle\n\n### Affiliation:\n\nhawkers\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [x] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [x] Yes, I have\n",
  "hints_text": "",
  "created_at": "2025-03-17T10:29:16Z"
}