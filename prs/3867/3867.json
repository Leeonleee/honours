{
  "repo": "duckdb/duckdb",
  "pull_number": 3867,
  "instance_id": "duckdb__duckdb-3867",
  "issue_numbers": [
    "3839"
  ],
  "base_commit": "7a3a5eb039c91c2dbd60f790f472f9c1584057d9",
  "patch": "diff --git a/src/execution/operator/persistent/physical_export.cpp b/src/execution/operator/persistent/physical_export.cpp\nindex 23ab136366d7..77e886f3781b 100644\n--- a/src/execution/operator/persistent/physical_export.cpp\n+++ b/src/execution/operator/persistent/physical_export.cpp\n@@ -1,11 +1,12 @@\n #include \"duckdb/execution/operator/persistent/physical_export.hpp\"\n+\n #include \"duckdb/catalog/catalog.hpp\"\n-#include \"duckdb/transaction/transaction.hpp\"\n-#include \"duckdb/common/file_system.hpp\"\n #include \"duckdb/catalog/catalog_entry/schema_catalog_entry.hpp\"\n+#include \"duckdb/common/file_system.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n-#include \"duckdb/parser/keyword_helper.hpp\"\n #include \"duckdb/parallel/pipeline.hpp\"\n+#include \"duckdb/parser/keyword_helper.hpp\"\n+#include \"duckdb/transaction/transaction.hpp\"\n \n #include <algorithm>\n #include <sstream>\n@@ -111,6 +112,7 @@ void PhysicalExport::GetData(ExecutionContext &context, DataChunk &chunk, Global\n \tvector<CatalogEntry *> tables;\n \tvector<CatalogEntry *> views;\n \tvector<CatalogEntry *> indexes;\n+\tvector<CatalogEntry *> macros;\n \n \tauto schema_list = Catalog::GetCatalog(ccontext).schemas->GetEntries<SchemaCatalogEntry>(context.client);\n \tfor (auto &schema : schema_list) {\n@@ -130,6 +132,16 @@ void PhysicalExport::GetData(ExecutionContext &context, DataChunk &chunk, Global\n \t\tschema->Scan(context.client, CatalogType::TYPE_ENTRY,\n \t\t             [&](CatalogEntry *entry) { custom_types.push_back(entry); });\n \t\tschema->Scan(context.client, CatalogType::INDEX_ENTRY, [&](CatalogEntry *entry) { indexes.push_back(entry); });\n+\t\tschema->Scan(context.client, CatalogType::MACRO_ENTRY, [&](CatalogEntry *entry) {\n+\t\t\tif (!entry->internal && entry->type == CatalogType::MACRO_ENTRY) {\n+\t\t\t\tmacros.push_back(entry);\n+\t\t\t}\n+\t\t});\n+\t\tschema->Scan(context.client, CatalogType::TABLE_MACRO_ENTRY, [&](CatalogEntry *entry) {\n+\t\t\tif (!entry->internal && entry->type == CatalogType::TABLE_MACRO_ENTRY) {\n+\t\t\t\tmacros.push_back(entry);\n+\t\t\t}\n+\t\t});\n \t}\n \n \t// consider the order of tables because of foreign key constraint\n@@ -137,6 +149,10 @@ void PhysicalExport::GetData(ExecutionContext &context, DataChunk &chunk, Global\n \t\ttables.push_back((CatalogEntry *)exported_tables.data[i].entry);\n \t}\n \n+\t// order macro's by timestamp so nested macro's are imported nicely\n+\tsort(macros.begin(), macros.end(),\n+\t     [](const CatalogEntry *lhs, const CatalogEntry *rhs) { return lhs->oid < rhs->oid; });\n+\n \t// write the schema.sql file\n \t// export order is SCHEMA -> SEQUENCE -> TABLE -> VIEW -> INDEX\n \n@@ -147,6 +163,7 @@ void PhysicalExport::GetData(ExecutionContext &context, DataChunk &chunk, Global\n \tWriteCatalogEntries(ss, tables);\n \tWriteCatalogEntries(ss, views);\n \tWriteCatalogEntries(ss, indexes);\n+\tWriteCatalogEntries(ss, macros);\n \n \tWriteStringStreamToFile(fs, opener, ss, fs.JoinPath(info->file_path, \"schema.sql\"));\n \ndiff --git a/src/function/macro_function.cpp b/src/function/macro_function.cpp\nindex f17e84246bb6..dbdfc5347c07 100644\n--- a/src/function/macro_function.cpp\n+++ b/src/function/macro_function.cpp\n@@ -1,10 +1,10 @@\n \n #include \"duckdb/function/macro_function.hpp\"\n-#include \"duckdb/function/scalar_macro_function.hpp\"\n \n-#include \"duckdb/catalog/catalog_entry/scalar_macro_catalog_entry.hpp\"\n #include \"duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp\"\n+#include \"duckdb/catalog/catalog_entry/scalar_macro_catalog_entry.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/function/scalar_macro_function.hpp\"\n #include \"duckdb/parser/expression/columnref_expression.hpp\"\n #include \"duckdb/parser/expression/comparison_expression.hpp\"\n #include \"duckdb/parser/expression/function_expression.hpp\"\n@@ -76,4 +76,16 @@ void MacroFunction::CopyProperties(MacroFunction &other) {\n \t}\n }\n \n+string MacroFunction::ToSQL(const string &schema, const string &name) {\n+\tvector<string> param_strings;\n+\tfor (auto &param : parameters) {\n+\t\tparam_strings.push_back(param->ToString());\n+\t}\n+\tfor (auto &named_param : default_parameters) {\n+\t\tparam_strings.push_back(StringUtil::Format(\"%s := %s\", named_param.first, named_param.second->ToString()));\n+\t}\n+\n+\treturn StringUtil::Format(\"CREATE MACRO %s.%s(%s) AS \", schema, name, StringUtil::Join(param_strings, \", \"));\n+}\n+\n } // namespace duckdb\ndiff --git a/src/function/scalar_macro_function.cpp b/src/function/scalar_macro_function.cpp\nindex ba94064ba051..76735a2eba69 100644\n--- a/src/function/scalar_macro_function.cpp\n+++ b/src/function/scalar_macro_function.cpp\n@@ -7,8 +7,10 @@\n //===----------------------------------------------------------------------===//\n \n #include \"duckdb/function/scalar_macro_function.hpp\"\n+\n #include \"duckdb/function/macro_function.hpp\"\n #include \"duckdb/parser/expression/constant_expression.hpp\"\n+#include \"duckdb/parser/parsed_expression_iterator.hpp\"\n \n namespace duckdb {\n \n@@ -27,4 +29,24 @@ unique_ptr<MacroFunction> ScalarMacroFunction::Copy() {\n \treturn move(result);\n }\n \n+void RemoveQualificationRecursive(unique_ptr<ParsedExpression> &expr) {\n+\tif (expr->GetExpressionType() == ExpressionType::COLUMN_REF) {\n+\t\tauto &col_ref = (ColumnRefExpression &)*expr;\n+\t\tauto &col_names = col_ref.column_names;\n+\t\tif (col_names.size() == 2 && col_names[0] == MacroBinding::MACRO_NAME) {\n+\t\t\tcol_names.erase(col_names.begin());\n+\t\t}\n+\t} else {\n+\t\tParsedExpressionIterator::EnumerateChildren(\n+\t\t    *expr, [](unique_ptr<ParsedExpression> &child) { RemoveQualificationRecursive(child); });\n+\t}\n+}\n+\n+string ScalarMacroFunction::ToSQL(const string &schema, const string &name) {\n+\t// In case of nested macro's we need to fix it a bit\n+\tauto expression_copy = expression->Copy();\n+\tRemoveQualificationRecursive(expression_copy);\n+\treturn MacroFunction::ToSQL(schema, name) + StringUtil::Format(\"(%s);\", expression_copy->ToString());\n+}\n+\n } // namespace duckdb\ndiff --git a/src/function/table_macro_function.cpp b/src/function/table_macro_function.cpp\nindex 020b1a73ece5..52e3309f3018 100644\n--- a/src/function/table_macro_function.cpp\n+++ b/src/function/table_macro_function.cpp\n@@ -7,8 +7,9 @@\n //===----------------------------------------------------------------------===//\n //! The SelectStatement of the view\n #include \"duckdb/function/table_macro_function.hpp\"\n-#include \"duckdb/parser/query_node.hpp\"\n+\n #include \"duckdb/parser/expression/constant_expression.hpp\"\n+#include \"duckdb/parser/query_node.hpp\"\n \n namespace duckdb {\n \n@@ -26,4 +27,8 @@ unique_ptr<MacroFunction> TableMacroFunction::Copy() {\n \treturn move(result);\n }\n \n+string TableMacroFunction::ToSQL(const string &schema, const string &name) {\n+\treturn MacroFunction::ToSQL(schema, name) + StringUtil::Format(\"TABLE (%s);\", query_node->ToString());\n+}\n+\n } // namespace duckdb\ndiff --git a/src/include/duckdb/catalog/catalog_entry/macro_catalog_entry.hpp b/src/include/duckdb/catalog/catalog_entry/macro_catalog_entry.hpp\nindex 777c130456a1..3c58b2a124ef 100644\n--- a/src/include/duckdb/catalog/catalog_entry/macro_catalog_entry.hpp\n+++ b/src/include/duckdb/catalog/catalog_entry/macro_catalog_entry.hpp\n@@ -25,6 +25,10 @@ class MacroCatalogEntry : public StandardEntry {\n public:\n \t//! Serialize the meta information\n \tvirtual void Serialize(Serializer &serializer) = 0;\n+\n+\tstring ToSQL() override {\n+\t\treturn function->ToSQL(schema->name, name);\n+\t}\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/function/macro_function.hpp b/src/include/duckdb/function/macro_function.hpp\nindex 89b90376356b..8786c2ae12e0 100644\n--- a/src/include/duckdb/function/macro_function.hpp\n+++ b/src/include/duckdb/function/macro_function.hpp\n@@ -7,7 +7,7 @@\n //===----------------------------------------------------------------------===//\n \n #pragma once\n-//! The SelectStatement of the view\n+\n #include \"duckdb/parser/query_node.hpp\"\n #include \"duckdb/function/function.hpp\"\n #include \"duckdb/main/client_context.hpp\"\n@@ -21,11 +21,9 @@ enum class MacroType : uint8_t { VOID_MACRO = 0, TABLE_MACRO = 1, SCALAR_MACRO =\n \n class MacroFunction {\n public:\n-\t// explicit MacroFunction(unique_ptr<ParsedExpression> expression);\n \tMacroFunction(MacroType type);\n \n-\t// MacroFunction(void);\n-\t// The type\n+\t//! The type\n \tMacroType type;\n \t//! The positional parameters\n \tvector<unique_ptr<ParsedExpression>> parameters;\n@@ -44,6 +42,8 @@ class MacroFunction {\n \t                                FunctionExpression &function_expr,\n \t                                vector<unique_ptr<ParsedExpression>> &positionals,\n \t                                unordered_map<string, unique_ptr<ParsedExpression>> &defaults);\n+\n+\tvirtual string ToSQL(const string &schema, const string &name);\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/function/scalar_macro_function.hpp b/src/include/duckdb/function/scalar_macro_function.hpp\nindex 8bf6cd3b0061..f02fc1bb56a7 100644\n--- a/src/include/duckdb/function/scalar_macro_function.hpp\n+++ b/src/include/duckdb/function/scalar_macro_function.hpp\n@@ -28,6 +28,8 @@ class ScalarMacroFunction : public MacroFunction {\n \n public:\n \tunique_ptr<MacroFunction> Copy() override;\n+\n+\tstring ToSQL(const string &schema, const string &name) override;\n };\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/function/table_macro_function.hpp b/src/include/duckdb/function/table_macro_function.hpp\nindex cb93354875e1..81c58838c6eb 100644\n--- a/src/include/duckdb/function/table_macro_function.hpp\n+++ b/src/include/duckdb/function/table_macro_function.hpp\n@@ -7,7 +7,7 @@\n //===----------------------------------------------------------------------===//\n \n #pragma once\n-//! The SelectStatement of the view\n+\n #include \"duckdb/function/macro_function.hpp\"\n #include \"duckdb/parser/query_node.hpp\"\n #include \"duckdb/function/function.hpp\"\n@@ -28,6 +28,8 @@ class TableMacroFunction : public MacroFunction {\n \n public:\n \tunique_ptr<MacroFunction> Copy() override;\n+\n+\tstring ToSQL(const string &schema, const string &name) override;\n };\n \n } // namespace duckdb\n",
  "test_patch": "diff --git a/test/sql/export/export_macros.test b/test/sql/export/export_macros.test\nnew file mode 100644\nindex 000000000000..592499c08488\n--- /dev/null\n+++ b/test/sql/export/export_macros.test\n@@ -0,0 +1,45 @@\n+# name: test/sql/export/export_macros.test\n+# description: Test export of macro's\n+# group: [export]\n+\n+statement ok\n+BEGIN TRANSACTION\n+\n+statement ok\n+CREATE SCHEMA my_schema\n+\n+# table macro\n+statement ok\n+CREATE MACRO my_schema.my_range(x, y := 7) AS TABLE SELECT range + x i FROM range(y)\n+\n+# scalar macro with the table macro nested in there\n+statement ok\n+CREATE MACRO my_schema.elaborate_macro(x, y := 7) AS x + y + (SELECT max(i) FROM my_schema.my_range(0, y := 10))\n+\n+# table macro with nested table macro\n+statement ok\n+CREATE MACRO my_schema.my_other_range(x) AS TABLE SELECT * FROM my_schema.my_range(x, y := 3)\n+\n+statement ok\n+EXPORT DATABASE '__TEST_DIR__/export_macros' (FORMAT CSV);\n+\n+statement ok\n+ROLLBACK\n+\n+statement ok\n+IMPORT DATABASE '__TEST_DIR__/export_macros'\n+\n+query T\n+SELECT my_schema.elaborate_macro(28, y := 5)\n+----\n+42\n+\n+query T\n+SELECT max(i) FROM my_schema.my_range(33, y := 10)\n+----\n+42\n+\n+query T\n+SELECT max(i) FROM my_schema.my_other_range(40)\n+----\n+42\n",
  "problem_statement": "Export database does not export macros\n#### What happens?\r\n\r\nMacros are not exported with 'EXPORT DATABASE'. This might be expected as MACROs are omitted from the list of exported things in the [documentation](https://duckdb.org/docs/sql/statements/export#syntax).\r\n\r\n#### To Reproduce\r\n\r\n```sql\r\nCREATE MACRO ADD(x,y) AS x+y;\r\nEXPORT DATABASE '/tmp/test';\r\n```\r\n\r\nwill produce an /tmp/test empty directory (though adding a table will produce the expected load.sql, schema.sql files).\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Linux\r\n - DuckDB Version: v0.3.4, 0.3.5.dev1206\r\n - DuckDB Client: cli,python\r\n\r\n#### Before Submitting\r\n\r\n- [X] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [X] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "@lnkuiper perhaps you could have a look at this issue?\nSure, I can have a go at this",
  "created_at": "2022-06-15T12:39:28Z"
}