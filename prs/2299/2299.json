{
  "repo": "duckdb/duckdb",
  "pull_number": 2299,
  "instance_id": "duckdb__duckdb-2299",
  "issue_numbers": [
    "2296"
  ],
  "base_commit": "7dd852e1dd7aa521e76cbf6f756da487e2e1a1cd",
  "patch": "diff --git a/src/common/local_file_system.cpp b/src/common/local_file_system.cpp\nindex 321c9df3036e..4cbd237dd0b8 100644\n--- a/src/common/local_file_system.cpp\n+++ b/src/common/local_file_system.cpp\n@@ -33,14 +33,18 @@ extern \"C\" WINBASEAPI BOOL WINAPI GetPhysicallyInstalledSystemMemory(PULONGLONG)\n namespace duckdb {\n \n static void AssertValidFileFlags(uint8_t flags) {\n-\t// cannot combine Read and Write flags\n-\tD_ASSERT(!(flags & FileFlags::FILE_FLAGS_READ && flags & FileFlags::FILE_FLAGS_WRITE));\n-\t// cannot combine Read and CREATE/Append flags\n-\tD_ASSERT(!(flags & FileFlags::FILE_FLAGS_READ && flags & FileFlags::FILE_FLAGS_APPEND));\n-\tD_ASSERT(!(flags & FileFlags::FILE_FLAGS_READ && flags & FileFlags::FILE_FLAGS_FILE_CREATE));\n-\tD_ASSERT(!(flags & FileFlags::FILE_FLAGS_READ && flags & FileFlags::FILE_FLAGS_FILE_CREATE_NEW));\n+#ifdef DEBUG\n+\tbool is_read = flags & FileFlags::FILE_FLAGS_READ;\n+\tbool is_write = flags & FileFlags::FILE_FLAGS_WRITE;\n+\t// require either READ or WRITE (or both)\n+\tD_ASSERT(is_read || is_write);\n+\t// CREATE/Append flags require writing\n+\tD_ASSERT(is_write || !(flags & FileFlags::FILE_FLAGS_APPEND));\n+\tD_ASSERT(is_write || !(flags & FileFlags::FILE_FLAGS_FILE_CREATE));\n+\tD_ASSERT(is_write || !(flags & FileFlags::FILE_FLAGS_FILE_CREATE_NEW));\n \t// cannot combine CREATE and CREATE_NEW flags\n \tD_ASSERT(!(flags & FileFlags::FILE_FLAGS_FILE_CREATE && flags & FileFlags::FILE_FLAGS_FILE_CREATE_NEW));\n+#endif\n }\n \n #ifndef _WIN32\n@@ -73,6 +77,31 @@ struct UnixFileHandle : public FileHandle {\n \tint fd;\n };\n \n+static FileType GetFileTypeInternal(int fd) {\n+\tstruct stat s;\n+\tif (fstat(fd, &s) == -1) {\n+\t\treturn FileType::FILE_TYPE_INVALID;\n+\t}\n+\tswitch (s.st_mode & S_IFMT) {\n+\tcase S_IFBLK:\n+\t\treturn FileType::FILE_TYPE_BLOCKDEV;\n+\tcase S_IFCHR:\n+\t\treturn FileType::FILE_TYPE_CHARDEV;\n+\tcase S_IFIFO:\n+\t\treturn FileType::FILE_TYPE_FIFO;\n+\tcase S_IFDIR:\n+\t\treturn FileType::FILE_TYPE_DIR;\n+\tcase S_IFLNK:\n+\t\treturn FileType::FILE_TYPE_LINK;\n+\tcase S_IFREG:\n+\t\treturn FileType::FILE_TYPE_REGULAR;\n+\tcase S_IFSOCK:\n+\t\treturn FileType::FILE_TYPE_SOCKET;\n+\tdefault:\n+\t\treturn FileType::FILE_TYPE_INVALID;\n+\t}\n+}\n+\n unique_ptr<FileHandle> LocalFileSystem::OpenFile(const string &path, uint8_t flags, FileLockType lock_type,\n                                                  FileCompressionType compression, FileOpener *opener) {\n \tif (compression != FileCompressionType::UNCOMPRESSED) {\n@@ -83,12 +112,21 @@ unique_ptr<FileHandle> LocalFileSystem::OpenFile(const string &path, uint8_t fla\n \n \tint open_flags = 0;\n \tint rc;\n-\tif (flags & FileFlags::FILE_FLAGS_READ) {\n+\tbool open_read = flags & FileFlags::FILE_FLAGS_READ;\n+\tbool open_write = flags & FileFlags::FILE_FLAGS_WRITE;\n+\tif (open_read && open_write) {\n+\t\topen_flags = O_RDWR;\n+\t} else if (open_read) {\n \t\topen_flags = O_RDONLY;\n+\t} else if (open_write) {\n+\t\topen_flags = O_WRONLY;\n \t} else {\n+\t\tthrow InternalException(\"READ, WRITE or both should be specified when opening a file\");\n+\t}\n+\tif (open_write) {\n \t\t// need Read or Write\n \t\tD_ASSERT(flags & FileFlags::FILE_FLAGS_WRITE);\n-\t\topen_flags = O_RDWR | O_CLOEXEC;\n+\t\topen_flags |= O_CLOEXEC;\n \t\tif (flags & FileFlags::FILE_FLAGS_FILE_CREATE) {\n \t\t\topen_flags |= O_CREAT;\n \t\t} else if (flags & FileFlags::FILE_FLAGS_FILE_CREATE_NEW) {\n@@ -124,15 +162,19 @@ unique_ptr<FileHandle> LocalFileSystem::OpenFile(const string &path, uint8_t fla\n \t// #endif\n \tif (lock_type != FileLockType::NO_LOCK) {\n \t\t// set lock on file\n-\t\tstruct flock fl;\n-\t\tmemset(&fl, 0, sizeof fl);\n-\t\tfl.l_type = lock_type == FileLockType::READ_LOCK ? F_RDLCK : F_WRLCK;\n-\t\tfl.l_whence = SEEK_SET;\n-\t\tfl.l_start = 0;\n-\t\tfl.l_len = 0;\n-\t\trc = fcntl(fd, F_SETLK, &fl);\n-\t\tif (rc == -1) {\n-\t\t\tthrow IOException(\"Could not set lock on file \\\"%s\\\": %s\", path, strerror(errno));\n+\t\t// but only if it is not an input/output stream\n+\t\tauto file_type = GetFileTypeInternal(fd);\n+\t\tif (file_type != FileType::FILE_TYPE_FIFO && file_type != FileType::FILE_TYPE_SOCKET) {\n+\t\t\tstruct flock fl;\n+\t\t\tmemset(&fl, 0, sizeof fl);\n+\t\t\tfl.l_type = lock_type == FileLockType::READ_LOCK ? F_RDLCK : F_WRLCK;\n+\t\t\tfl.l_whence = SEEK_SET;\n+\t\t\tfl.l_start = 0;\n+\t\t\tfl.l_len = 0;\n+\t\t\trc = fcntl(fd, F_SETLK, &fl);\n+\t\t\tif (rc == -1) {\n+\t\t\t\tthrow IOException(\"Could not set lock on file \\\"%s\\\": %s\", path, strerror(errno));\n+\t\t\t}\n \t\t}\n \t}\n \treturn make_unique<UnixFileHandle>(*this, path, fd);\n@@ -218,28 +260,7 @@ time_t LocalFileSystem::GetLastModifiedTime(FileHandle &handle) {\n \n FileType LocalFileSystem::GetFileType(FileHandle &handle) {\n \tint fd = ((UnixFileHandle &)handle).fd;\n-\tstruct stat s;\n-\tif (fstat(fd, &s) == -1) {\n-\t\treturn FileType::FILE_TYPE_INVALID;\n-\t}\n-\tswitch (s.st_mode & S_IFMT) {\n-\tcase S_IFBLK:\n-\t\treturn FileType::FILE_TYPE_BLOCKDEV;\n-\tcase S_IFCHR:\n-\t\treturn FileType::FILE_TYPE_CHARDEV;\n-\tcase S_IFIFO:\n-\t\treturn FileType::FILE_TYPE_FIFO;\n-\tcase S_IFDIR:\n-\t\treturn FileType::FILE_TYPE_DIR;\n-\tcase S_IFLNK:\n-\t\treturn FileType::FILE_TYPE_LINK;\n-\tcase S_IFREG:\n-\t\treturn FileType::FILE_TYPE_REGULAR;\n-\tcase S_IFSOCK:\n-\t\treturn FileType::FILE_TYPE_SOCKET;\n-\tdefault:\n-\t\treturn FileType::FILE_TYPE_INVALID;\n-\t}\n+\treturn GetFileTypeInternal(fd);\n }\n \n void LocalFileSystem::Truncate(FileHandle &handle, int64_t new_size) {\n@@ -442,14 +463,21 @@ unique_ptr<FileHandle> LocalFileSystem::OpenFile(const string &path, uint8_t fla\n \tDWORD share_mode;\n \tDWORD creation_disposition = OPEN_EXISTING;\n \tDWORD flags_and_attributes = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED;\n-\tif (flags & FileFlags::FILE_FLAGS_READ) {\n+\tbool open_read = flags & FileFlags::FILE_FLAGS_READ;\n+\tbool open_write = flags & FileFlags::FILE_FLAGS_WRITE;\n+\tif (open_read && open_write) {\n+\t\tdesired_access = GENERIC_READ | GENERIC_WRITE;\n+\t\tshare_mode = 0;\n+\t} else if (open_read) {\n \t\tdesired_access = GENERIC_READ;\n \t\tshare_mode = FILE_SHARE_READ;\n-\t} else {\n-\t\t// need Read or Write\n-\t\tD_ASSERT(flags & FileFlags::FILE_FLAGS_WRITE);\n-\t\tdesired_access = GENERIC_READ | GENERIC_WRITE;\n+\t} else if (open_write) {\n+\t\tdesired_access = GENERIC_WRITE;\n \t\tshare_mode = 0;\n+\t} else {\n+\t\tthrow InternalException(\"READ, WRITE or both should be specified when opening a file\");\n+\t}\n+\tif (open_write) {\n \t\tif (flags & FileFlags::FILE_FLAGS_FILE_CREATE) {\n \t\t\tcreation_disposition = OPEN_ALWAYS;\n \t\t} else if (flags & FileFlags::FILE_FLAGS_FILE_CREATE_NEW) {\ndiff --git a/src/storage/single_file_block_manager.cpp b/src/storage/single_file_block_manager.cpp\nindex 932922450e8e..237c5b935209 100644\n--- a/src/storage/single_file_block_manager.cpp\n+++ b/src/storage/single_file_block_manager.cpp\n@@ -79,7 +79,7 @@ SingleFileBlockManager::SingleFileBlockManager(DatabaseInstance &db, string path\n \t\tflags = FileFlags::FILE_FLAGS_READ;\n \t\tlock = FileLockType::READ_LOCK;\n \t} else {\n-\t\tflags = FileFlags::FILE_FLAGS_WRITE;\n+\t\tflags = FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_READ;\n \t\tlock = FileLockType::WRITE_LOCK;\n \t\tif (create_new) {\n \t\t\tflags |= FileFlags::FILE_FLAGS_FILE_CREATE;\n",
  "test_patch": "diff --git a/test/common/test_file_system.cpp b/test/common/test_file_system.cpp\nindex 47ad8723fb60..fcf06c87b41d 100644\n--- a/test/common/test_file_system.cpp\n+++ b/test/common/test_file_system.cpp\n@@ -113,8 +113,8 @@ TEST_CASE(\"Test file buffers for reading/writing to file\", \"[file_system]\") {\n \n \t// open file for writing\n \tREQUIRE_NOTHROW(handle = fs->OpenFile(fname,\n-\t                                      FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_FILE_CREATE |\n-\t                                          FileFlags::FILE_FLAGS_DIRECT_IO,\n+\t                                      FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_READ |\n+\t                                          FileFlags::FILE_FLAGS_FILE_CREATE | FileFlags::FILE_FLAGS_DIRECT_IO,\n \t                                      FileLockType::WRITE_LOCK));\n \t// write the buffer\n \tREQUIRE_NOTHROW(buf->Write(*handle, 0));\ndiff --git a/tools/shell/shell-test.py b/tools/shell/shell-test.py\nindex a9026d229187..4a957134f4eb 100644\n--- a/tools/shell/shell-test.py\n+++ b/tools/shell/shell-test.py\n@@ -539,3 +539,15 @@ def tf():\n      input_file='test/sql/copy/csv/data/test/test.csv',\n      out='''foo,bar,baz\n 0,0,\" test\"''')\n+\n+     test('''\n+     COPY (SELECT 42) TO '/dev/stdout' WITH (FORMAT 'csv');\n+     ''',\n+     extra_commands=['-csv', ':memory:'],\n+     out='''42''')\n+\n+     test('''\n+     COPY (SELECT 42) TO '/dev/stderr' WITH (FORMAT 'csv');\n+     ''',\n+     extra_commands=['-csv', ':memory:'],\n+     err='''42''')\n",
  "problem_statement": "COPY TO \"/dev/stdout\" (or pipe) fails\n**Writing to stdout/pipe?**\r\n\r\nDuckDB is not able to open `/dev/stdout` or a named pip (`mkfifo`) for writing when the output is redirected. \r\n\r\nSpecifying \"/dev/stdout\" as output file works and e.g. CSV data is printed on terminal, but whenever trying to redirect the output to file or pipe it, DuckDB fails to open the output \"file\". Reason being most probably that DuckDB tries to open the output with more permissions than plain write (\"w\").\r\n\r\nUse case could for example be to pipe Parquet through DuckDB without having to write data on disk.\r\n\r\nMaybe the pipe filesystem could be extended to support output pipes/stdout as well?\r\n\r\nOn OSX (`v0.2.9 1776611ab`):\r\n\r\n```\r\nduckdb :memory: \"COPY (SELECT * FROM 'input.parquet') TO '/dev/stdout' WITH (FORMAT 'Parquet');\" | \\\r\n    aws s3 cp - s3://bucket/out.parquet\r\nError: IO Error: Cannot open file \"/dev/stdout\": Permission denied\r\n```\n",
  "hints_text": "Why did you want to write a Parquet file to stdout again? \n> Why did you want to write a Parquet file to stdout again?\r\n\r\nI updated the example on the description to show how Parquet can be written directly to S3 with piping for example. No need to write it to disk and then copy from disk to S3. Alternative would be to add direct S3 write support.\nBut Parquet seems to be a good candidate for output streaming as the metadata comes in the end (no need to construct the full file before). So, to be able to stream write the output improves overall throughput time when you read from S3 and output to S3.",
  "created_at": "2021-09-20T11:36:16Z"
}