diff --git a/src/common/enums/logical_operator_type.cpp b/src/common/enums/logical_operator_type.cpp
index 1ffd96313b40..f737b603e16b 100644
--- a/src/common/enums/logical_operator_type.cpp
+++ b/src/common/enums/logical_operator_type.cpp
@@ -65,8 +65,6 @@ string LogicalOperatorToString(LogicalOperatorType type) {
 		return "UPDATE";
 	case LogicalOperatorType::PREPARE:
 		return "PREPARE";
-	case LogicalOperatorType::PRUNE_COLUMNS:
-		return "PRUNE";
 	case LogicalOperatorType::TABLE_FUNCTION:
 		return "TABLE_FUNCTION";
 	case LogicalOperatorType::CREATE_INDEX:
diff --git a/src/common/enums/physical_operator_type.cpp b/src/common/enums/physical_operator_type.cpp
index 61a303e9ec14..8cc63af1c822 100644
--- a/src/common/enums/physical_operator_type.cpp
+++ b/src/common/enums/physical_operator_type.cpp
@@ -74,8 +74,6 @@ string PhysicalOperatorToString(PhysicalOperatorType type) {
 		return "UPDATE";
 	case PhysicalOperatorType::EXPORT_EXTERNAL_FILE:
 		return "EXPORT_EXTERNAL_FILE";
-	case PhysicalOperatorType::PRUNE_COLUMNS:
-		return "PRUNE";
 	case PhysicalOperatorType::EMPTY_RESULT:
 		return "EMPTY_RESULT";
 	case PhysicalOperatorType::TABLE_FUNCTION:
diff --git a/src/execution/operator/helper/CMakeLists.txt b/src/execution/operator/helper/CMakeLists.txt
index 0e02c9bce0c3..04d39a6a6d60 100644
--- a/src/execution/operator/helper/CMakeLists.txt
+++ b/src/execution/operator/helper/CMakeLists.txt
@@ -4,7 +4,6 @@ add_library_unity(duckdb_operator_helper
                   physical_limit.cpp
                   physical_pragma.cpp
                   physical_prepare.cpp
-                  physical_prune_columns.cpp
                   physical_transaction.cpp
                   physical_vacuum.cpp)
 set(ALL_OBJECT_FILES ${ALL_OBJECT_FILES}
diff --git a/src/execution/operator/helper/physical_prune_columns.cpp b/src/execution/operator/helper/physical_prune_columns.cpp
deleted file mode 100644
index bd21f7ca24a9..000000000000
--- a/src/execution/operator/helper/physical_prune_columns.cpp
+++ /dev/null
@@ -1,20 +0,0 @@
-#include "duckdb/execution/operator/helper/physical_prune_columns.hpp"
-
-#include "duckdb/execution/expression_executor.hpp"
-
-using namespace duckdb;
-using namespace std;
-
-void PhysicalPruneColumns::GetChunkInternal(ClientContext &context, DataChunk &chunk, PhysicalOperatorState *state_) {
-	auto state = reinterpret_cast<PhysicalOperatorState *>(state_);
-
-	children[0]->GetChunk(context, state->child_chunk, state->child_state.get());
-	if (state->child_chunk.size() == 0) {
-		return;
-	}
-	assert(column_limit <= state->child_chunk.column_count());
-	chunk.SetCardinality(state->child_chunk.size());
-	for (idx_t i = 0; i < column_limit; i++) {
-		chunk.data[i].Reference(state->child_chunk.data[i]);
-	}
-}
diff --git a/src/execution/physical_plan/CMakeLists.txt b/src/execution/physical_plan/CMakeLists.txt
index 9207c1dd306b..b1d7d8d5a7bc 100644
--- a/src/execution/physical_plan/CMakeLists.txt
+++ b/src/execution/physical_plan/CMakeLists.txt
@@ -25,7 +25,6 @@ add_library_unity(duckdb_physical_plan
                   plan_order.cpp
                   plan_prepare.cpp
                   plan_projection.cpp
-                  plan_prune_columns.cpp
                   plan_set_operation.cpp
                   plan_simple.cpp
                   plan_table_function.cpp
diff --git a/src/execution/physical_plan/plan_order.cpp b/src/execution/physical_plan/plan_order.cpp
index 671b3d9ba6ea..27d61cc794b4 100644
--- a/src/execution/physical_plan/plan_order.cpp
+++ b/src/execution/physical_plan/plan_order.cpp
@@ -9,8 +9,10 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalOrder &op)
 	assert(op.children.size() == 1);
 
 	auto plan = CreatePlan(*op.children[0]);
-
-	auto order = make_unique<PhysicalOrder>(op.types, move(op.orders));
-	order->children.push_back(move(plan));
-	return move(order);
+	if (op.orders.size() > 0) {
+		auto order = make_unique<PhysicalOrder>(op.types, move(op.orders));
+		order->children.push_back(move(plan));
+		plan = move(order);
+	}
+	return plan;
 }
diff --git a/src/execution/physical_plan/plan_prune_columns.cpp b/src/execution/physical_plan/plan_prune_columns.cpp
deleted file mode 100644
index b7f4d702c188..000000000000
--- a/src/execution/physical_plan/plan_prune_columns.cpp
+++ /dev/null
@@ -1,19 +0,0 @@
-#include "duckdb/execution/operator/helper/physical_prune_columns.hpp"
-#include "duckdb/execution/physical_plan_generator.hpp"
-#include "duckdb/planner/operator/logical_prune_columns.hpp"
-
-using namespace duckdb;
-using namespace std;
-
-unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalPruneColumns &op) {
-	assert(op.children.size() == 1);
-
-	auto plan = CreatePlan(*op.children[0]);
-	if (plan->GetTypes().size() > op.column_limit) {
-		// only prune if we need to
-		auto node = make_unique<PhysicalPruneColumns>(op, op.column_limit);
-		node->children.push_back(move(plan));
-		plan = move(node);
-	}
-	return plan;
-}
diff --git a/src/execution/physical_plan_generator.cpp b/src/execution/physical_plan_generator.cpp
index 13d1702d3c1f..fa0e5559ffa0 100644
--- a/src/execution/physical_plan_generator.cpp
+++ b/src/execution/physical_plan_generator.cpp
@@ -112,8 +112,6 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalOperator &
 		return CreatePlan((LogicalExplain &)op);
 	case LogicalOperatorType::DISTINCT:
 		return CreatePlan((LogicalDistinct &)op);
-	case LogicalOperatorType::PRUNE_COLUMNS:
-		return CreatePlan((LogicalPruneColumns &)op);
 	case LogicalOperatorType::PREPARE:
 		return CreatePlan((LogicalPrepare &)op);
 	case LogicalOperatorType::EXECUTE:
diff --git a/src/function/aggregate/distributive/minmax.cpp b/src/function/aggregate/distributive/minmax.cpp
index 4de11a670040..eb4aa4c19ef0 100644
--- a/src/function/aggregate/distributive/minmax.cpp
+++ b/src/function/aggregate/distributive/minmax.cpp
@@ -15,17 +15,11 @@ struct MinMaxBase : public StandardDistributiveFunction {
 	static void ConstantOperation(STATE *state, INPUT_TYPE *input, nullmask_t &nullmask, idx_t count) {
 		assert(!nullmask[0]);
 		if (IsNullValue<INPUT_TYPE>(*state)) {
-			*state = input[0];
+			OP::template Assign<INPUT_TYPE, STATE>(state, input[0]);
 		} else {
 			OP::template Execute<INPUT_TYPE, STATE>(state, input[0]);
 		}
 	}
-
-	template <class T, class STATE>
-	static void Finalize(Vector &result, STATE *state, T *target, nullmask_t &nullmask, idx_t idx) {
-		nullmask[idx] = IsNullValue<T>(*state);
-		target[idx] = *state;
-	}
 };
 
 struct NumericMinMaxBase : public MinMaxBase {
@@ -33,6 +27,12 @@ struct NumericMinMaxBase : public MinMaxBase {
 	static void Assign(STATE *state, INPUT_TYPE input) {
 		*state = input;
 	}
+
+	template <class T, class STATE>
+	static void Finalize(Vector &result, STATE *state, T *target, nullmask_t &nullmask, idx_t idx) {
+		nullmask[idx] = IsNullValue<T>(*state);
+		target[idx] = *state;
+	}
 };
 
 struct MinOperation : public NumericMinMaxBase {
@@ -71,6 +71,15 @@ struct StringMinMaxBase : public MinMaxBase {
 			*state = string_t(ptr, len);
 		}
 	}
+
+	template <class T, class STATE>
+	static void Finalize(Vector &result, STATE *state, T *target, nullmask_t &nullmask, idx_t idx) {
+		if (IsNullValue<string_t>(*state)) {
+			nullmask[idx] = true;
+		} else {
+			target[idx] = StringVector::AddString(result, *state);
+		}
+	}
 };
 
 struct MinOperationString : public StringMinMaxBase {
diff --git a/src/function/scalar/operators/bitwise.cpp b/src/function/scalar/operators/bitwise.cpp
index bb75a8705aa0..497b7505e83e 100644
--- a/src/function/scalar/operators/bitwise.cpp
+++ b/src/function/scalar/operators/bitwise.cpp
@@ -63,9 +63,14 @@ void BitwiseXorFun::RegisterFunction(BuiltinFunctions &set) {
 //===--------------------------------------------------------------------===//
 // << [bitwise_left_shift]
 //===--------------------------------------------------------------------===//
+template<class T>
+bool ShiftInRange(T shift) {
+	return shift >= 0 && shift < (T)(sizeof(T) * 8);
+}
+
 struct BitwiseShiftLeftOperator {
-	template <class TA, class TB, class TR> static inline TR Operation(TA left, TB right) {
-		return right < 0 ? 0 : left << right;
+	template <class TA, class TB, class TR> static inline TR Operation(TA input, TB shift) {
+		return ShiftInRange(shift) ? input << shift : 0;
 	}
 };
 
@@ -82,8 +87,8 @@ void LeftShiftFun::RegisterFunction(BuiltinFunctions &set) {
 // >> [bitwise_right_shift]
 //===--------------------------------------------------------------------===//
 struct BitwiseShiftRightOperator {
-	template <class TA, class TB, class TR> static inline TR Operation(TA left, TB right) {
-		return right < 0 ? 0 : left >> right;
+	template <class TA, class TB, class TR> static inline TR Operation(TA input, TB shift) {
+		return ShiftInRange(shift) ? input >> shift : 0;
 	}
 };
 
diff --git a/src/include/duckdb/common/enums/logical_operator_type.hpp b/src/include/duckdb/common/enums/logical_operator_type.hpp
index de7fcc9305cc..de66bcdda998 100644
--- a/src/include/duckdb/common/enums/logical_operator_type.hpp
+++ b/src/include/duckdb/common/enums/logical_operator_type.hpp
@@ -83,7 +83,6 @@ enum class LogicalOperatorType : uint8_t {
 	// -----------------------------
 	// Helpers
 	// -----------------------------
-	PRUNE_COLUMNS,
 	PREPARE,
 	EXECUTE,
 	VACUUM
diff --git a/src/include/duckdb/common/enums/physical_operator_type.hpp b/src/include/duckdb/common/enums/physical_operator_type.hpp
index 75a4f3a702ae..48132bc7a15c 100644
--- a/src/include/duckdb/common/enums/physical_operator_type.hpp
+++ b/src/include/duckdb/common/enums/physical_operator_type.hpp
@@ -85,7 +85,6 @@ enum class PhysicalOperatorType : uint8_t {
 	// -----------------------------
 	// Helpers
 	// -----------------------------
-	PRUNE_COLUMNS,
 	EXPLAIN,
 	EMPTY_RESULT,
 	EXECUTE,
diff --git a/src/include/duckdb/execution/operator/helper/physical_prune_columns.hpp b/src/include/duckdb/execution/operator/helper/physical_prune_columns.hpp
deleted file mode 100644
index c81c8cf005e4..000000000000
--- a/src/include/duckdb/execution/operator/helper/physical_prune_columns.hpp
+++ /dev/null
@@ -1,27 +0,0 @@
-//===----------------------------------------------------------------------===//
-//                         DuckDB
-//
-// duckdb/execution/operator/helper/physical_prune_columns.hpp
-//
-//
-//===----------------------------------------------------------------------===//
-
-#pragma once
-
-#include "duckdb/execution/physical_operator.hpp"
-
-namespace duckdb {
-
-//! PhysicalPruneColumns prunes (removes) columns from its input
-class PhysicalPruneColumns : public PhysicalOperator {
-public:
-	PhysicalPruneColumns(LogicalOperator &op, idx_t column_limit)
-	    : PhysicalOperator(PhysicalOperatorType::PRUNE_COLUMNS, op.types), column_limit(column_limit) {
-	}
-
-	idx_t column_limit;
-
-public:
-	void GetChunkInternal(ClientContext &context, DataChunk &chunk, PhysicalOperatorState *state) override;
-};
-} // namespace duckdb
diff --git a/src/include/duckdb/execution/operator/list.hpp b/src/include/duckdb/execution/operator/list.hpp
index 45db0911178d..795ae844ecc6 100644
--- a/src/include/duckdb/execution/operator/list.hpp
+++ b/src/include/duckdb/execution/operator/list.hpp
@@ -6,7 +6,6 @@
 #include "duckdb/execution/operator/helper/physical_limit.hpp"
 #include "duckdb/execution/operator/helper/physical_pragma.hpp"
 #include "duckdb/execution/operator/helper/physical_prepare.hpp"
-#include "duckdb/execution/operator/helper/physical_prune_columns.hpp"
 #include "duckdb/execution/operator/helper/physical_transaction.hpp"
 #include "duckdb/execution/operator/helper/physical_vacuum.hpp"
 #include "duckdb/execution/operator/join/physical_blockwise_nl_join.hpp"
diff --git a/src/include/duckdb/execution/physical_plan_generator.hpp b/src/include/duckdb/execution/physical_plan_generator.hpp
index c54c0d9eb970..3f4ae5b2b5e4 100644
--- a/src/include/duckdb/execution/physical_plan_generator.hpp
+++ b/src/include/duckdb/execution/physical_plan_generator.hpp
@@ -65,7 +65,6 @@ class PhysicalPlanGenerator {
 	unique_ptr<PhysicalOperator> CreatePlan(LogicalSetOperation &op);
 	unique_ptr<PhysicalOperator> CreatePlan(LogicalUpdate &op);
 	unique_ptr<PhysicalOperator> CreatePlan(LogicalTableFunction &expr);
-	unique_ptr<PhysicalOperator> CreatePlan(LogicalPruneColumns &expr);
 	unique_ptr<PhysicalOperator> CreatePlan(LogicalPrepare &expr);
 	unique_ptr<PhysicalOperator> CreatePlan(LogicalWindow &expr);
 	unique_ptr<PhysicalOperator> CreatePlan(LogicalExecute &op);
diff --git a/src/include/duckdb/planner/logical_tokens.hpp b/src/include/duckdb/planner/logical_tokens.hpp
index 4b8100f79b15..1b3fd91fcae4 100644
--- a/src/include/duckdb/planner/logical_tokens.hpp
+++ b/src/include/duckdb/planner/logical_tokens.hpp
@@ -41,7 +41,6 @@ class LogicalLimit;
 class LogicalOrder;
 class LogicalPrepare;
 class LogicalProjection;
-class LogicalPruneColumns;
 class LogicalRecursiveCTE;
 class LogicalSetOperation;
 class LogicalSimple;
diff --git a/src/include/duckdb/planner/operator/list.hpp b/src/include/duckdb/planner/operator/list.hpp
index 8b8c6578bb5f..aba16c06cc5a 100644
--- a/src/include/duckdb/planner/operator/list.hpp
+++ b/src/include/duckdb/planner/operator/list.hpp
@@ -26,7 +26,6 @@
 #include "duckdb/planner/operator/logical_order.hpp"
 #include "duckdb/planner/operator/logical_prepare.hpp"
 #include "duckdb/planner/operator/logical_projection.hpp"
-#include "duckdb/planner/operator/logical_prune_columns.hpp"
 #include "duckdb/planner/operator/logical_recursive_cte.hpp"
 #include "duckdb/planner/operator/logical_set_operation.hpp"
 #include "duckdb/planner/operator/logical_simple.hpp"
diff --git a/src/include/duckdb/planner/operator/logical_prune_columns.hpp b/src/include/duckdb/planner/operator/logical_prune_columns.hpp
deleted file mode 100644
index a5fead8893a0..000000000000
--- a/src/include/duckdb/planner/operator/logical_prune_columns.hpp
+++ /dev/null
@@ -1,32 +0,0 @@
-//===----------------------------------------------------------------------===//
-//                         DuckDB
-//
-// duckdb/planner/operator/logical_prune_columns.hpp
-//
-//
-//===----------------------------------------------------------------------===//
-
-#pragma once
-
-#include "duckdb/planner/logical_operator.hpp"
-
-namespace duckdb {
-
-//! LogicalPruneColumns represents a node that prunes extra columns from its
-//! children
-class LogicalPruneColumns : public LogicalOperator {
-public:
-	LogicalPruneColumns(idx_t column_limit)
-	    : LogicalOperator(LogicalOperatorType::PRUNE_COLUMNS), column_limit(column_limit) {
-	}
-
-	idx_t column_limit;
-
-public:
-	vector<ColumnBinding> GetColumnBindings() override;
-
-protected:
-	void ResolveTypes() override;
-};
-
-} // namespace duckdb
diff --git a/src/include/duckdb/planner/query_node/bound_select_node.hpp b/src/include/duckdb/planner/query_node/bound_select_node.hpp
index 02c00d975a64..de712b190963 100644
--- a/src/include/duckdb/planner/query_node/bound_select_node.hpp
+++ b/src/include/duckdb/planner/query_node/bound_select_node.hpp
@@ -61,9 +61,12 @@ class BoundSelectNode : public BoundQueryNode {
 	//! Unnest expression
 	vector<unique_ptr<Expression>> unnests;
 
+	//! Index of pruned node
+	idx_t prune_index;
+	bool need_prune = false;
 public:
 	idx_t GetRootIndex() override {
-		return projection_index;
+		return need_prune ? prune_index : projection_index;
 	}
 };
 }; // namespace duckdb
diff --git a/src/optimizer/filter_pushdown.cpp b/src/optimizer/filter_pushdown.cpp
index b0d7a6bba1d1..2c0fae124e1b 100644
--- a/src/optimizer/filter_pushdown.cpp
+++ b/src/optimizer/filter_pushdown.cpp
@@ -29,8 +29,7 @@ unique_ptr<LogicalOperator> FilterPushdown::Rewrite(unique_ptr<LogicalOperator>
 	case LogicalOperatorType::UNION:
 		return PushdownSetOperation(move(op));
 	case LogicalOperatorType::DISTINCT:
-	case LogicalOperatorType::ORDER_BY:
-	case LogicalOperatorType::PRUNE_COLUMNS: {
+	case LogicalOperatorType::ORDER_BY: {
 		// we can just push directly through these operations without any rewriting
 		op->children[0] = Rewrite(move(op->children[0]));
 		return op;
diff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp
index 43013892f2ba..5fb733ddae9f 100644
--- a/src/planner/binder/query_node/bind_select_node.cpp
+++ b/src/planner/binder/query_node/bind_select_node.cpp
@@ -92,7 +92,9 @@ void Binder::BindModifiers(OrderBinder &order_binder, QueryNode &statement, Boun
 				}
 				bound_order->orders.push_back(move(node));
 			}
-			bound_modifier = move(bound_order);
+			if (bound_order->orders.size() > 0) {
+				bound_modifier = move(bound_order);
+			}
 			break;
 		}
 		case ResultModifierType::LIMIT_MODIFIER:
@@ -101,7 +103,9 @@ void Binder::BindModifiers(OrderBinder &order_binder, QueryNode &statement, Boun
 		default:
 			throw Exception("Unsupported result modifier");
 		}
-		result.modifiers.push_back(move(bound_modifier));
+		if (bound_modifier) {
+			result.modifiers.push_back(move(bound_modifier));
+		}
 	}
 }
 
@@ -158,6 +162,7 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {
 	result->aggregate_index = GenerateTableIndex();
 	result->window_index = GenerateTableIndex();
 	result->unnest_index = GenerateTableIndex();
+	result->prune_index = GenerateTableIndex();
 
 	// first bind the FROM table statement
 	result->from_table = Bind(*statement.from_table);
@@ -270,6 +275,8 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {
 			select_binder.ResetBindings();
 		}
 	}
+	result->need_prune = result->select_list.size() > result->column_count;
+
 	// in the normal select binder, we bind columns as if there is no aggregation
 	// i.e. in the query [SELECT i, SUM(i) FROM integers;] the "i" will be bound as a normal column
 	// since we have an aggregation, we need to either (1) throw an error, or (2) wrap the column in a FIRST() aggregate
diff --git a/src/planner/binder/query_node/plan_select_node.cpp b/src/planner/binder/query_node/plan_select_node.cpp
index c6c1cf5fb8f7..bd9f1ce040c7 100644
--- a/src/planner/binder/query_node/plan_select_node.cpp
+++ b/src/planner/binder/query_node/plan_select_node.cpp
@@ -2,6 +2,7 @@
 #include "duckdb/planner/operator/list.hpp"
 #include "duckdb/planner/query_node/bound_select_node.hpp"
 #include "duckdb/planner/operator/logical_expression_get.hpp"
+#include "duckdb/planner/expression/bound_columnref_expression.hpp"
 
 using namespace duckdb;
 using namespace std;
@@ -80,12 +81,9 @@ unique_ptr<LogicalOperator> Binder::CreatePlan(BoundSelectNode &statement) {
 		PlanSubqueries(&expr, &root);
 	}
 
-	// check if we need to prune extra columns that were introduced into the select list (by e.g. the ORDER BY or HAVING
-	// clauses)
-	bool prune_columns = statement.select_list.size() > statement.column_count;
-
 	// create the projection
 	auto proj = make_unique<LogicalProjection>(statement.projection_index, move(statement.select_list));
+	auto &projection = *proj;
 	proj->AddChild(move(root));
 	root = move(proj);
 
@@ -93,9 +91,13 @@ unique_ptr<LogicalOperator> Binder::CreatePlan(BoundSelectNode &statement) {
 	root = VisitQueryNode(statement, move(root));
 
 	// add a prune node if necessary
-	if (prune_columns) {
+	if (statement.need_prune) {
 		assert(root);
-		auto prune = make_unique<LogicalPruneColumns>(statement.column_count);
+		vector<unique_ptr<Expression>> prune_expressions;
+		for(idx_t i = 0; i < statement.column_count; i++) {
+			prune_expressions.push_back(make_unique<BoundColumnRefExpression>(projection.expressions[i]->return_type, ColumnBinding(statement.projection_index, i)));
+		}
+		auto prune = make_unique<LogicalProjection>(statement.prune_index, move(prune_expressions));
 		prune->AddChild(move(root));
 		root = move(prune);
 	}
diff --git a/src/planner/operator/CMakeLists.txt b/src/planner/operator/CMakeLists.txt
index d2aad00c2fbb..801abad051af 100644
--- a/src/planner/operator/CMakeLists.txt
+++ b/src/planner/operator/CMakeLists.txt
@@ -9,7 +9,6 @@ add_library_unity(duckdb_planner_operator
                   logical_get.cpp
                   logical_join.cpp
                   logical_projection.cpp
-                  logical_prune_columns.cpp
                   logical_table_function.cpp
                   logical_unnest.cpp
                   logical_window.cpp
diff --git a/src/planner/operator/logical_prune_columns.cpp b/src/planner/operator/logical_prune_columns.cpp
deleted file mode 100644
index a6c9f7456f66..000000000000
--- a/src/planner/operator/logical_prune_columns.cpp
+++ /dev/null
@@ -1,15 +0,0 @@
-#include "duckdb/planner/operator/logical_prune_columns.hpp"
-
-using namespace duckdb;
-using namespace std;
-
-vector<ColumnBinding> LogicalPruneColumns::GetColumnBindings() {
-	vector<ColumnBinding> result;
-	auto child_bindings = children[0]->GetColumnBindings();
-	result.insert(result.end(), child_bindings.begin(), child_bindings.begin() + column_limit);
-	return result;
-}
-
-void LogicalPruneColumns::ResolveTypes() {
-	types.insert(types.end(), children[0]->types.begin(), children[0]->types.begin() + column_limit);
-}
diff --git a/src/planner/subquery/flatten_dependent_join.cpp b/src/planner/subquery/flatten_dependent_join.cpp
index d8aa0c9c4a33..cf0008387dc3 100644
--- a/src/planner/subquery/flatten_dependent_join.cpp
+++ b/src/planner/subquery/flatten_dependent_join.cpp
@@ -303,7 +303,6 @@ unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal
 		setop.column_count += correlated_columns.size();
 		return plan;
 	}
-	case LogicalOperatorType::PRUNE_COLUMNS:
 	case LogicalOperatorType::DISTINCT:
 		plan->children[0] = PushDownDependentJoin(move(plan->children[0]));
 		return plan;
