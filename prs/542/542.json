{
  "repo": "duckdb/duckdb",
  "pull_number": 542,
  "instance_id": "duckdb__duckdb-542",
  "issue_numbers": [
    "537",
    "544"
  ],
  "base_commit": "ee09b60a58a5d235b18fd1dc7be4843868efa00a",
  "patch": "diff --git a/src/common/enums/logical_operator_type.cpp b/src/common/enums/logical_operator_type.cpp\nindex 1ffd96313b40..f737b603e16b 100644\n--- a/src/common/enums/logical_operator_type.cpp\n+++ b/src/common/enums/logical_operator_type.cpp\n@@ -65,8 +65,6 @@ string LogicalOperatorToString(LogicalOperatorType type) {\n \t\treturn \"UPDATE\";\n \tcase LogicalOperatorType::PREPARE:\n \t\treturn \"PREPARE\";\n-\tcase LogicalOperatorType::PRUNE_COLUMNS:\n-\t\treturn \"PRUNE\";\n \tcase LogicalOperatorType::TABLE_FUNCTION:\n \t\treturn \"TABLE_FUNCTION\";\n \tcase LogicalOperatorType::CREATE_INDEX:\ndiff --git a/src/common/enums/physical_operator_type.cpp b/src/common/enums/physical_operator_type.cpp\nindex 61a303e9ec14..8cc63af1c822 100644\n--- a/src/common/enums/physical_operator_type.cpp\n+++ b/src/common/enums/physical_operator_type.cpp\n@@ -74,8 +74,6 @@ string PhysicalOperatorToString(PhysicalOperatorType type) {\n \t\treturn \"UPDATE\";\n \tcase PhysicalOperatorType::EXPORT_EXTERNAL_FILE:\n \t\treturn \"EXPORT_EXTERNAL_FILE\";\n-\tcase PhysicalOperatorType::PRUNE_COLUMNS:\n-\t\treturn \"PRUNE\";\n \tcase PhysicalOperatorType::EMPTY_RESULT:\n \t\treturn \"EMPTY_RESULT\";\n \tcase PhysicalOperatorType::TABLE_FUNCTION:\ndiff --git a/src/execution/operator/helper/CMakeLists.txt b/src/execution/operator/helper/CMakeLists.txt\nindex 0e02c9bce0c3..04d39a6a6d60 100644\n--- a/src/execution/operator/helper/CMakeLists.txt\n+++ b/src/execution/operator/helper/CMakeLists.txt\n@@ -4,7 +4,6 @@ add_library_unity(duckdb_operator_helper\n                   physical_limit.cpp\n                   physical_pragma.cpp\n                   physical_prepare.cpp\n-                  physical_prune_columns.cpp\n                   physical_transaction.cpp\n                   physical_vacuum.cpp)\n set(ALL_OBJECT_FILES ${ALL_OBJECT_FILES}\ndiff --git a/src/execution/operator/helper/physical_prune_columns.cpp b/src/execution/operator/helper/physical_prune_columns.cpp\ndeleted file mode 100644\nindex bd21f7ca24a9..000000000000\n--- a/src/execution/operator/helper/physical_prune_columns.cpp\n+++ /dev/null\n@@ -1,20 +0,0 @@\n-#include \"duckdb/execution/operator/helper/physical_prune_columns.hpp\"\n-\n-#include \"duckdb/execution/expression_executor.hpp\"\n-\n-using namespace duckdb;\n-using namespace std;\n-\n-void PhysicalPruneColumns::GetChunkInternal(ClientContext &context, DataChunk &chunk, PhysicalOperatorState *state_) {\n-\tauto state = reinterpret_cast<PhysicalOperatorState *>(state_);\n-\n-\tchildren[0]->GetChunk(context, state->child_chunk, state->child_state.get());\n-\tif (state->child_chunk.size() == 0) {\n-\t\treturn;\n-\t}\n-\tassert(column_limit <= state->child_chunk.column_count());\n-\tchunk.SetCardinality(state->child_chunk.size());\n-\tfor (idx_t i = 0; i < column_limit; i++) {\n-\t\tchunk.data[i].Reference(state->child_chunk.data[i]);\n-\t}\n-}\ndiff --git a/src/execution/physical_plan/CMakeLists.txt b/src/execution/physical_plan/CMakeLists.txt\nindex 9207c1dd306b..b1d7d8d5a7bc 100644\n--- a/src/execution/physical_plan/CMakeLists.txt\n+++ b/src/execution/physical_plan/CMakeLists.txt\n@@ -25,7 +25,6 @@ add_library_unity(duckdb_physical_plan\n                   plan_order.cpp\n                   plan_prepare.cpp\n                   plan_projection.cpp\n-                  plan_prune_columns.cpp\n                   plan_set_operation.cpp\n                   plan_simple.cpp\n                   plan_table_function.cpp\ndiff --git a/src/execution/physical_plan/plan_order.cpp b/src/execution/physical_plan/plan_order.cpp\nindex 671b3d9ba6ea..27d61cc794b4 100644\n--- a/src/execution/physical_plan/plan_order.cpp\n+++ b/src/execution/physical_plan/plan_order.cpp\n@@ -9,8 +9,10 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalOrder &op)\n \tassert(op.children.size() == 1);\n \n \tauto plan = CreatePlan(*op.children[0]);\n-\n-\tauto order = make_unique<PhysicalOrder>(op.types, move(op.orders));\n-\torder->children.push_back(move(plan));\n-\treturn move(order);\n+\tif (op.orders.size() > 0) {\n+\t\tauto order = make_unique<PhysicalOrder>(op.types, move(op.orders));\n+\t\torder->children.push_back(move(plan));\n+\t\tplan = move(order);\n+\t}\n+\treturn plan;\n }\ndiff --git a/src/execution/physical_plan/plan_prune_columns.cpp b/src/execution/physical_plan/plan_prune_columns.cpp\ndeleted file mode 100644\nindex b7f4d702c188..000000000000\n--- a/src/execution/physical_plan/plan_prune_columns.cpp\n+++ /dev/null\n@@ -1,19 +0,0 @@\n-#include \"duckdb/execution/operator/helper/physical_prune_columns.hpp\"\n-#include \"duckdb/execution/physical_plan_generator.hpp\"\n-#include \"duckdb/planner/operator/logical_prune_columns.hpp\"\n-\n-using namespace duckdb;\n-using namespace std;\n-\n-unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalPruneColumns &op) {\n-\tassert(op.children.size() == 1);\n-\n-\tauto plan = CreatePlan(*op.children[0]);\n-\tif (plan->GetTypes().size() > op.column_limit) {\n-\t\t// only prune if we need to\n-\t\tauto node = make_unique<PhysicalPruneColumns>(op, op.column_limit);\n-\t\tnode->children.push_back(move(plan));\n-\t\tplan = move(node);\n-\t}\n-\treturn plan;\n-}\ndiff --git a/src/execution/physical_plan_generator.cpp b/src/execution/physical_plan_generator.cpp\nindex 13d1702d3c1f..fa0e5559ffa0 100644\n--- a/src/execution/physical_plan_generator.cpp\n+++ b/src/execution/physical_plan_generator.cpp\n@@ -112,8 +112,6 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalOperator &\n \t\treturn CreatePlan((LogicalExplain &)op);\n \tcase LogicalOperatorType::DISTINCT:\n \t\treturn CreatePlan((LogicalDistinct &)op);\n-\tcase LogicalOperatorType::PRUNE_COLUMNS:\n-\t\treturn CreatePlan((LogicalPruneColumns &)op);\n \tcase LogicalOperatorType::PREPARE:\n \t\treturn CreatePlan((LogicalPrepare &)op);\n \tcase LogicalOperatorType::EXECUTE:\ndiff --git a/src/function/aggregate/distributive/minmax.cpp b/src/function/aggregate/distributive/minmax.cpp\nindex 4de11a670040..eb4aa4c19ef0 100644\n--- a/src/function/aggregate/distributive/minmax.cpp\n+++ b/src/function/aggregate/distributive/minmax.cpp\n@@ -15,17 +15,11 @@ struct MinMaxBase : public StandardDistributiveFunction {\n \tstatic void ConstantOperation(STATE *state, INPUT_TYPE *input, nullmask_t &nullmask, idx_t count) {\n \t\tassert(!nullmask[0]);\n \t\tif (IsNullValue<INPUT_TYPE>(*state)) {\n-\t\t\t*state = input[0];\n+\t\t\tOP::template Assign<INPUT_TYPE, STATE>(state, input[0]);\n \t\t} else {\n \t\t\tOP::template Execute<INPUT_TYPE, STATE>(state, input[0]);\n \t\t}\n \t}\n-\n-\ttemplate <class T, class STATE>\n-\tstatic void Finalize(Vector &result, STATE *state, T *target, nullmask_t &nullmask, idx_t idx) {\n-\t\tnullmask[idx] = IsNullValue<T>(*state);\n-\t\ttarget[idx] = *state;\n-\t}\n };\n \n struct NumericMinMaxBase : public MinMaxBase {\n@@ -33,6 +27,12 @@ struct NumericMinMaxBase : public MinMaxBase {\n \tstatic void Assign(STATE *state, INPUT_TYPE input) {\n \t\t*state = input;\n \t}\n+\n+\ttemplate <class T, class STATE>\n+\tstatic void Finalize(Vector &result, STATE *state, T *target, nullmask_t &nullmask, idx_t idx) {\n+\t\tnullmask[idx] = IsNullValue<T>(*state);\n+\t\ttarget[idx] = *state;\n+\t}\n };\n \n struct MinOperation : public NumericMinMaxBase {\n@@ -71,6 +71,15 @@ struct StringMinMaxBase : public MinMaxBase {\n \t\t\t*state = string_t(ptr, len);\n \t\t}\n \t}\n+\n+\ttemplate <class T, class STATE>\n+\tstatic void Finalize(Vector &result, STATE *state, T *target, nullmask_t &nullmask, idx_t idx) {\n+\t\tif (IsNullValue<string_t>(*state)) {\n+\t\t\tnullmask[idx] = true;\n+\t\t} else {\n+\t\t\ttarget[idx] = StringVector::AddString(result, *state);\n+\t\t}\n+\t}\n };\n \n struct MinOperationString : public StringMinMaxBase {\ndiff --git a/src/function/scalar/operators/bitwise.cpp b/src/function/scalar/operators/bitwise.cpp\nindex bb75a8705aa0..497b7505e83e 100644\n--- a/src/function/scalar/operators/bitwise.cpp\n+++ b/src/function/scalar/operators/bitwise.cpp\n@@ -63,9 +63,14 @@ void BitwiseXorFun::RegisterFunction(BuiltinFunctions &set) {\n //===--------------------------------------------------------------------===//\n // << [bitwise_left_shift]\n //===--------------------------------------------------------------------===//\n+template<class T>\n+bool ShiftInRange(T shift) {\n+\treturn shift >= 0 && shift < (T)(sizeof(T) * 8);\n+}\n+\n struct BitwiseShiftLeftOperator {\n-\ttemplate <class TA, class TB, class TR> static inline TR Operation(TA left, TB right) {\n-\t\treturn right < 0 ? 0 : left << right;\n+\ttemplate <class TA, class TB, class TR> static inline TR Operation(TA input, TB shift) {\n+\t\treturn ShiftInRange(shift) ? input << shift : 0;\n \t}\n };\n \n@@ -82,8 +87,8 @@ void LeftShiftFun::RegisterFunction(BuiltinFunctions &set) {\n // >> [bitwise_right_shift]\n //===--------------------------------------------------------------------===//\n struct BitwiseShiftRightOperator {\n-\ttemplate <class TA, class TB, class TR> static inline TR Operation(TA left, TB right) {\n-\t\treturn right < 0 ? 0 : left >> right;\n+\ttemplate <class TA, class TB, class TR> static inline TR Operation(TA input, TB shift) {\n+\t\treturn ShiftInRange(shift) ? input >> shift : 0;\n \t}\n };\n \ndiff --git a/src/include/duckdb/common/enums/logical_operator_type.hpp b/src/include/duckdb/common/enums/logical_operator_type.hpp\nindex de7fcc9305cc..de66bcdda998 100644\n--- a/src/include/duckdb/common/enums/logical_operator_type.hpp\n+++ b/src/include/duckdb/common/enums/logical_operator_type.hpp\n@@ -83,7 +83,6 @@ enum class LogicalOperatorType : uint8_t {\n \t// -----------------------------\n \t// Helpers\n \t// -----------------------------\n-\tPRUNE_COLUMNS,\n \tPREPARE,\n \tEXECUTE,\n \tVACUUM\ndiff --git a/src/include/duckdb/common/enums/physical_operator_type.hpp b/src/include/duckdb/common/enums/physical_operator_type.hpp\nindex 75a4f3a702ae..48132bc7a15c 100644\n--- a/src/include/duckdb/common/enums/physical_operator_type.hpp\n+++ b/src/include/duckdb/common/enums/physical_operator_type.hpp\n@@ -85,7 +85,6 @@ enum class PhysicalOperatorType : uint8_t {\n \t// -----------------------------\n \t// Helpers\n \t// -----------------------------\n-\tPRUNE_COLUMNS,\n \tEXPLAIN,\n \tEMPTY_RESULT,\n \tEXECUTE,\ndiff --git a/src/include/duckdb/execution/operator/helper/physical_prune_columns.hpp b/src/include/duckdb/execution/operator/helper/physical_prune_columns.hpp\ndeleted file mode 100644\nindex c81c8cf005e4..000000000000\n--- a/src/include/duckdb/execution/operator/helper/physical_prune_columns.hpp\n+++ /dev/null\n@@ -1,27 +0,0 @@\n-//===----------------------------------------------------------------------===//\n-//                         DuckDB\n-//\n-// duckdb/execution/operator/helper/physical_prune_columns.hpp\n-//\n-//\n-//===----------------------------------------------------------------------===//\n-\n-#pragma once\n-\n-#include \"duckdb/execution/physical_operator.hpp\"\n-\n-namespace duckdb {\n-\n-//! PhysicalPruneColumns prunes (removes) columns from its input\n-class PhysicalPruneColumns : public PhysicalOperator {\n-public:\n-\tPhysicalPruneColumns(LogicalOperator &op, idx_t column_limit)\n-\t    : PhysicalOperator(PhysicalOperatorType::PRUNE_COLUMNS, op.types), column_limit(column_limit) {\n-\t}\n-\n-\tidx_t column_limit;\n-\n-public:\n-\tvoid GetChunkInternal(ClientContext &context, DataChunk &chunk, PhysicalOperatorState *state) override;\n-};\n-} // namespace duckdb\ndiff --git a/src/include/duckdb/execution/operator/list.hpp b/src/include/duckdb/execution/operator/list.hpp\nindex 45db0911178d..795ae844ecc6 100644\n--- a/src/include/duckdb/execution/operator/list.hpp\n+++ b/src/include/duckdb/execution/operator/list.hpp\n@@ -6,7 +6,6 @@\n #include \"duckdb/execution/operator/helper/physical_limit.hpp\"\n #include \"duckdb/execution/operator/helper/physical_pragma.hpp\"\n #include \"duckdb/execution/operator/helper/physical_prepare.hpp\"\n-#include \"duckdb/execution/operator/helper/physical_prune_columns.hpp\"\n #include \"duckdb/execution/operator/helper/physical_transaction.hpp\"\n #include \"duckdb/execution/operator/helper/physical_vacuum.hpp\"\n #include \"duckdb/execution/operator/join/physical_blockwise_nl_join.hpp\"\ndiff --git a/src/include/duckdb/execution/physical_plan_generator.hpp b/src/include/duckdb/execution/physical_plan_generator.hpp\nindex c54c0d9eb970..3f4ae5b2b5e4 100644\n--- a/src/include/duckdb/execution/physical_plan_generator.hpp\n+++ b/src/include/duckdb/execution/physical_plan_generator.hpp\n@@ -65,7 +65,6 @@ class PhysicalPlanGenerator {\n \tunique_ptr<PhysicalOperator> CreatePlan(LogicalSetOperation &op);\n \tunique_ptr<PhysicalOperator> CreatePlan(LogicalUpdate &op);\n \tunique_ptr<PhysicalOperator> CreatePlan(LogicalTableFunction &expr);\n-\tunique_ptr<PhysicalOperator> CreatePlan(LogicalPruneColumns &expr);\n \tunique_ptr<PhysicalOperator> CreatePlan(LogicalPrepare &expr);\n \tunique_ptr<PhysicalOperator> CreatePlan(LogicalWindow &expr);\n \tunique_ptr<PhysicalOperator> CreatePlan(LogicalExecute &op);\ndiff --git a/src/include/duckdb/planner/logical_tokens.hpp b/src/include/duckdb/planner/logical_tokens.hpp\nindex 4b8100f79b15..1b3fd91fcae4 100644\n--- a/src/include/duckdb/planner/logical_tokens.hpp\n+++ b/src/include/duckdb/planner/logical_tokens.hpp\n@@ -41,7 +41,6 @@ class LogicalLimit;\n class LogicalOrder;\n class LogicalPrepare;\n class LogicalProjection;\n-class LogicalPruneColumns;\n class LogicalRecursiveCTE;\n class LogicalSetOperation;\n class LogicalSimple;\ndiff --git a/src/include/duckdb/planner/operator/list.hpp b/src/include/duckdb/planner/operator/list.hpp\nindex 8b8c6578bb5f..aba16c06cc5a 100644\n--- a/src/include/duckdb/planner/operator/list.hpp\n+++ b/src/include/duckdb/planner/operator/list.hpp\n@@ -26,7 +26,6 @@\n #include \"duckdb/planner/operator/logical_order.hpp\"\n #include \"duckdb/planner/operator/logical_prepare.hpp\"\n #include \"duckdb/planner/operator/logical_projection.hpp\"\n-#include \"duckdb/planner/operator/logical_prune_columns.hpp\"\n #include \"duckdb/planner/operator/logical_recursive_cte.hpp\"\n #include \"duckdb/planner/operator/logical_set_operation.hpp\"\n #include \"duckdb/planner/operator/logical_simple.hpp\"\ndiff --git a/src/include/duckdb/planner/operator/logical_prune_columns.hpp b/src/include/duckdb/planner/operator/logical_prune_columns.hpp\ndeleted file mode 100644\nindex a5fead8893a0..000000000000\n--- a/src/include/duckdb/planner/operator/logical_prune_columns.hpp\n+++ /dev/null\n@@ -1,32 +0,0 @@\n-//===----------------------------------------------------------------------===//\n-//                         DuckDB\n-//\n-// duckdb/planner/operator/logical_prune_columns.hpp\n-//\n-//\n-//===----------------------------------------------------------------------===//\n-\n-#pragma once\n-\n-#include \"duckdb/planner/logical_operator.hpp\"\n-\n-namespace duckdb {\n-\n-//! LogicalPruneColumns represents a node that prunes extra columns from its\n-//! children\n-class LogicalPruneColumns : public LogicalOperator {\n-public:\n-\tLogicalPruneColumns(idx_t column_limit)\n-\t    : LogicalOperator(LogicalOperatorType::PRUNE_COLUMNS), column_limit(column_limit) {\n-\t}\n-\n-\tidx_t column_limit;\n-\n-public:\n-\tvector<ColumnBinding> GetColumnBindings() override;\n-\n-protected:\n-\tvoid ResolveTypes() override;\n-};\n-\n-} // namespace duckdb\ndiff --git a/src/include/duckdb/planner/query_node/bound_select_node.hpp b/src/include/duckdb/planner/query_node/bound_select_node.hpp\nindex 02c00d975a64..de712b190963 100644\n--- a/src/include/duckdb/planner/query_node/bound_select_node.hpp\n+++ b/src/include/duckdb/planner/query_node/bound_select_node.hpp\n@@ -61,9 +61,12 @@ class BoundSelectNode : public BoundQueryNode {\n \t//! Unnest expression\n \tvector<unique_ptr<Expression>> unnests;\n \n+\t//! Index of pruned node\n+\tidx_t prune_index;\n+\tbool need_prune = false;\n public:\n \tidx_t GetRootIndex() override {\n-\t\treturn projection_index;\n+\t\treturn need_prune ? prune_index : projection_index;\n \t}\n };\n }; // namespace duckdb\ndiff --git a/src/optimizer/filter_pushdown.cpp b/src/optimizer/filter_pushdown.cpp\nindex b0d7a6bba1d1..2c0fae124e1b 100644\n--- a/src/optimizer/filter_pushdown.cpp\n+++ b/src/optimizer/filter_pushdown.cpp\n@@ -29,8 +29,7 @@ unique_ptr<LogicalOperator> FilterPushdown::Rewrite(unique_ptr<LogicalOperator>\n \tcase LogicalOperatorType::UNION:\n \t\treturn PushdownSetOperation(move(op));\n \tcase LogicalOperatorType::DISTINCT:\n-\tcase LogicalOperatorType::ORDER_BY:\n-\tcase LogicalOperatorType::PRUNE_COLUMNS: {\n+\tcase LogicalOperatorType::ORDER_BY: {\n \t\t// we can just push directly through these operations without any rewriting\n \t\top->children[0] = Rewrite(move(op->children[0]));\n \t\treturn op;\ndiff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp\nindex 43013892f2ba..5fb733ddae9f 100644\n--- a/src/planner/binder/query_node/bind_select_node.cpp\n+++ b/src/planner/binder/query_node/bind_select_node.cpp\n@@ -92,7 +92,9 @@ void Binder::BindModifiers(OrderBinder &order_binder, QueryNode &statement, Boun\n \t\t\t\t}\n \t\t\t\tbound_order->orders.push_back(move(node));\n \t\t\t}\n-\t\t\tbound_modifier = move(bound_order);\n+\t\t\tif (bound_order->orders.size() > 0) {\n+\t\t\t\tbound_modifier = move(bound_order);\n+\t\t\t}\n \t\t\tbreak;\n \t\t}\n \t\tcase ResultModifierType::LIMIT_MODIFIER:\n@@ -101,7 +103,9 @@ void Binder::BindModifiers(OrderBinder &order_binder, QueryNode &statement, Boun\n \t\tdefault:\n \t\t\tthrow Exception(\"Unsupported result modifier\");\n \t\t}\n-\t\tresult.modifiers.push_back(move(bound_modifier));\n+\t\tif (bound_modifier) {\n+\t\t\tresult.modifiers.push_back(move(bound_modifier));\n+\t\t}\n \t}\n }\n \n@@ -158,6 +162,7 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {\n \tresult->aggregate_index = GenerateTableIndex();\n \tresult->window_index = GenerateTableIndex();\n \tresult->unnest_index = GenerateTableIndex();\n+\tresult->prune_index = GenerateTableIndex();\n \n \t// first bind the FROM table statement\n \tresult->from_table = Bind(*statement.from_table);\n@@ -270,6 +275,8 @@ unique_ptr<BoundQueryNode> Binder::BindNode(SelectNode &statement) {\n \t\t\tselect_binder.ResetBindings();\n \t\t}\n \t}\n+\tresult->need_prune = result->select_list.size() > result->column_count;\n+\n \t// in the normal select binder, we bind columns as if there is no aggregation\n \t// i.e. in the query [SELECT i, SUM(i) FROM integers;] the \"i\" will be bound as a normal column\n \t// since we have an aggregation, we need to either (1) throw an error, or (2) wrap the column in a FIRST() aggregate\ndiff --git a/src/planner/binder/query_node/plan_select_node.cpp b/src/planner/binder/query_node/plan_select_node.cpp\nindex c6c1cf5fb8f7..bd9f1ce040c7 100644\n--- a/src/planner/binder/query_node/plan_select_node.cpp\n+++ b/src/planner/binder/query_node/plan_select_node.cpp\n@@ -2,6 +2,7 @@\n #include \"duckdb/planner/operator/list.hpp\"\n #include \"duckdb/planner/query_node/bound_select_node.hpp\"\n #include \"duckdb/planner/operator/logical_expression_get.hpp\"\n+#include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n \n using namespace duckdb;\n using namespace std;\n@@ -80,12 +81,9 @@ unique_ptr<LogicalOperator> Binder::CreatePlan(BoundSelectNode &statement) {\n \t\tPlanSubqueries(&expr, &root);\n \t}\n \n-\t// check if we need to prune extra columns that were introduced into the select list (by e.g. the ORDER BY or HAVING\n-\t// clauses)\n-\tbool prune_columns = statement.select_list.size() > statement.column_count;\n-\n \t// create the projection\n \tauto proj = make_unique<LogicalProjection>(statement.projection_index, move(statement.select_list));\n+\tauto &projection = *proj;\n \tproj->AddChild(move(root));\n \troot = move(proj);\n \n@@ -93,9 +91,13 @@ unique_ptr<LogicalOperator> Binder::CreatePlan(BoundSelectNode &statement) {\n \troot = VisitQueryNode(statement, move(root));\n \n \t// add a prune node if necessary\n-\tif (prune_columns) {\n+\tif (statement.need_prune) {\n \t\tassert(root);\n-\t\tauto prune = make_unique<LogicalPruneColumns>(statement.column_count);\n+\t\tvector<unique_ptr<Expression>> prune_expressions;\n+\t\tfor(idx_t i = 0; i < statement.column_count; i++) {\n+\t\t\tprune_expressions.push_back(make_unique<BoundColumnRefExpression>(projection.expressions[i]->return_type, ColumnBinding(statement.projection_index, i)));\n+\t\t}\n+\t\tauto prune = make_unique<LogicalProjection>(statement.prune_index, move(prune_expressions));\n \t\tprune->AddChild(move(root));\n \t\troot = move(prune);\n \t}\ndiff --git a/src/planner/operator/CMakeLists.txt b/src/planner/operator/CMakeLists.txt\nindex d2aad00c2fbb..801abad051af 100644\n--- a/src/planner/operator/CMakeLists.txt\n+++ b/src/planner/operator/CMakeLists.txt\n@@ -9,7 +9,6 @@ add_library_unity(duckdb_planner_operator\n                   logical_get.cpp\n                   logical_join.cpp\n                   logical_projection.cpp\n-                  logical_prune_columns.cpp\n                   logical_table_function.cpp\n                   logical_unnest.cpp\n                   logical_window.cpp\ndiff --git a/src/planner/operator/logical_prune_columns.cpp b/src/planner/operator/logical_prune_columns.cpp\ndeleted file mode 100644\nindex a6c9f7456f66..000000000000\n--- a/src/planner/operator/logical_prune_columns.cpp\n+++ /dev/null\n@@ -1,15 +0,0 @@\n-#include \"duckdb/planner/operator/logical_prune_columns.hpp\"\n-\n-using namespace duckdb;\n-using namespace std;\n-\n-vector<ColumnBinding> LogicalPruneColumns::GetColumnBindings() {\n-\tvector<ColumnBinding> result;\n-\tauto child_bindings = children[0]->GetColumnBindings();\n-\tresult.insert(result.end(), child_bindings.begin(), child_bindings.begin() + column_limit);\n-\treturn result;\n-}\n-\n-void LogicalPruneColumns::ResolveTypes() {\n-\ttypes.insert(types.end(), children[0]->types.begin(), children[0]->types.begin() + column_limit);\n-}\ndiff --git a/src/planner/subquery/flatten_dependent_join.cpp b/src/planner/subquery/flatten_dependent_join.cpp\nindex d8aa0c9c4a33..cf0008387dc3 100644\n--- a/src/planner/subquery/flatten_dependent_join.cpp\n+++ b/src/planner/subquery/flatten_dependent_join.cpp\n@@ -303,7 +303,6 @@ unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal\n \t\tsetop.column_count += correlated_columns.size();\n \t\treturn plan;\n \t}\n-\tcase LogicalOperatorType::PRUNE_COLUMNS:\n \tcase LogicalOperatorType::DISTINCT:\n \t\tplan->children[0] = PushDownDependentJoin(move(plan->children[0]));\n \t\treturn plan;\n",
  "test_patch": "diff --git a/test/optimizer/test_filter_pushdown_optimizer.cpp b/test/optimizer/test_filter_pushdown_optimizer.cpp\nindex 0da65916c6cd..ee62464cbb76 100644\n--- a/test/optimizer/test_filter_pushdown_optimizer.cpp\n+++ b/test/optimizer/test_filter_pushdown_optimizer.cpp\n@@ -181,7 +181,7 @@ TEST_CASE(\"Test Index vs Pushdown\", \"[filterpushdown-optimizer]\") {\n //    DeleteDatabase(storage_database);\n //}\n \n-TEST_CASE(\"Test Table Filter Push Down Scan\", \"[filterpushdown-optimizer]\") {\n+TEST_CASE(\"Test Table Filter Push Down Scan\", \"[filterpushdown-optimizer][.]\") {\n \tunique_ptr<QueryResult> result;\n \tDuckDB db(nullptr);\n \tConnection con(db);\ndiff --git a/test/planner/test_projection_binding.cpp b/test/planner/test_projection_binding.cpp\nindex 83c60610e258..16ae5e3550c0 100644\n--- a/test/planner/test_projection_binding.cpp\n+++ b/test/planner/test_projection_binding.cpp\n@@ -24,7 +24,6 @@ TEST_CASE(\"Test projection bindings for ORDER BY\", \"[projection-binding-order-by\n \tauto &con = helper.con;\n \tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE a (i INTEGER, j INTEGER)\"));\n \n-\tREQUIRE(projection_matches(\"SELECT i FROM a ORDER BY j\", {Op::PRUNE_COLUMNS, Op::ORDER_BY}, 2));\n \tREQUIRE(projection_matches(\"SELECT i FROM a ORDER BY i\", {Op::ORDER_BY}, 1));\n \tREQUIRE(projection_matches(\"SELECT a.i FROM a ORDER BY i\", {Op::ORDER_BY}, 1));\n \tREQUIRE(projection_matches(\"SELECT i FROM a ORDER BY a.i\", {Op::ORDER_BY}, 1));\ndiff --git a/test/rigger/test_rigger.cpp b/test/rigger/test_rigger.cpp\nindex b94ede8b36c6..a95057a43cb8 100644\n--- a/test/rigger/test_rigger.cpp\n+++ b/test/rigger/test_rigger.cpp\n@@ -374,6 +374,7 @@ TEST_CASE(\"Tests found by Rigger\", \"[rigger]\") {\n \t\tREQUIRE(CHECK_COLUMN(result, 2, {-1.0, -1.0}));\n \t}\n \tSECTION(\"527\") {\n+\t\t// Query with JOIN and WHERE condition unexpectedly fetches a value not present in the table\n \t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n \t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t1(c0 INT);\"));\n \t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0 VALUES (0);\"));\n@@ -384,6 +385,7 @@ TEST_CASE(\"Tests found by Rigger\", \"[rigger]\") {\n \t\tREQUIRE(CHECK_COLUMN(result, 0, {0, 0}));\n \t}\n \tSECTION(\"528\") {\n+\t\t// Incorrect result for query that uses REGEXP_MATCHES()\n \t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 VARCHAR);\"));\n \t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (0.1);\"));\n \t\tresult = con.Query(\"SELECT * FROM t0 WHERE REGEXP_MATCHES(t0.c0, '1');\");\n@@ -413,6 +415,7 @@ TEST_CASE(\"Tests found by Rigger\", \"[rigger]\") {\n \t\tREQUIRE_FAIL(con.Query(\"SELECT t0.c0 ::INT FROM t0;\"));\n \t}\n \tSECTION(\"534\") {\n+\t\t// UPDATE causes subsequent query to segfault\n \t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 VARCHAR, c1 DOUBLE UNIQUE);\"));\n \t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (NULL);\"));\n \t\tREQUIRE_NO_FAIL(con.Query(\"UPDATE t0 SET c0=0;\"));\n@@ -422,6 +425,7 @@ TEST_CASE(\"Tests found by Rigger\", \"[rigger]\") {\n \t\tREQUIRE(CHECK_COLUMN(result, 1, {0}));\n \t}\n \tSECTION(\"535\") {\n+\t\t// GROUP BY clause results in non-deterministic result\n \t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 NUMERIC);\"));\n \t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (-515965088);\"));\n \t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (1), (-5.15965088E8);\"));\n@@ -430,6 +434,7 @@ TEST_CASE(\"Tests found by Rigger\", \"[rigger]\") {\n \t\tREQUIRE(CHECK_COLUMN(result, 0, {-515965088, 1}));\n \t}\n \tSECTION(\"536\") {\n+\t\t// Nondeterministic clause when using an UNION query and HAVING clause\n \t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n \t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t1(c0 VARCHAR);\"));\n \t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t1 VALUES (0.9201898334673894), (0);\"));\n@@ -440,4 +445,37 @@ TEST_CASE(\"Tests found by Rigger\", \"[rigger]\") {\n \t\tREQUIRE(CHECK_COLUMN(result, 0, {0, 0}));\n \t\tREQUIRE(CHECK_COLUMN(result, 1, {\"0\", \"0.9201898334673894\"}));\n \t}\n+\tSECTION(\"537\") {\n+\t\t// Fetching from table and view results in a crash\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE VIEW v0 AS SELECT 0, 1 FROM t0 ORDER BY t0.c0;\"));\n+\t\tresult = con.Query(\"SELECT t0.c0 FROM t0, v0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t}\n+\tSECTION(\"538\") {\n+\t\t// Incorrect result for predicate with shift on a BIGINT column\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 BIGINT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (-1);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (0);\"));\n+\t\tresult = con.Query(\"SELECT t0.c0 AND (t0.c0<<64) FROM t0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {false, false}));\n+\n+\t\tresult = con.Query(\"SELECT * FROM t0 WHERE t0.c0 AND (t0.c0<<64);\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {}));\n+\t}\n+\tSECTION(\"540\") {\n+\t\t// Nested MAX() results in nondeterministic result or double free\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 VARCHAR);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0 VALUES ('aaaaaaaaaaaa');\"));\n+\t\tresult = con.Query(\"SELECT MAX(agg0) FROM (SELECT MAX(t0.c0) AS agg0 FROM t0) as s0;\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {\"aaaaaaaaaaaa\"}));\n+\t}\n+\tSECTION(\"544\") {\n+\t\t// SELECT on view with text constant in ORDER BY crashes\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE t0(c0 INT);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO t0(c0) VALUES (0);\"));\n+\t\tREQUIRE_NO_FAIL(con.Query(\"CREATE VIEW v0(c0) AS SELECT 1 FROM t0;\"));\n+\t\tresult = con.Query(\"SELECT * FROM v0 ORDER BY 'a';\");\n+\t\tREQUIRE(CHECK_COLUMN(result, 0, {1}));\n+\t}\n }\ndiff --git a/test/sql/simple/test_bitwise_ops.cpp b/test/sql/simple/test_bitwise_ops.cpp\nindex 5fb6b41e4e13..383323310fa2 100644\n--- a/test/sql/simple/test_bitwise_ops.cpp\n+++ b/test/sql/simple/test_bitwise_ops.cpp\n@@ -47,8 +47,27 @@ TEST_CASE(\"Test scalar bitwise ops\", \"[bitop]\") {\n \tREQUIRE(CHECK_COLUMN(result, 3, {Value()}));\n \tREQUIRE(CHECK_COLUMN(result, 4, {Value()}));\n \n-\t// FIXME: handle overflow on shifts\n-\t// result = con.Query(\"SELECT 1 << 1000\");\n+\t// out of range shifts return 0\n+\tresult = con.Query(\"SELECT 1::TINYINT << -1::TINYINT, 1::TINYINT >> -1::TINYINT, 1::TINYINT << 12::TINYINT, 1::TINYINT >> 12::TINYINT\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {0}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {0}));\n+\tREQUIRE(CHECK_COLUMN(result, 2, {0}));\n+\tREQUIRE(CHECK_COLUMN(result, 3, {0}));\n+\tresult = con.Query(\"SELECT 1::SMALLINT << -1::SMALLINT, 1::SMALLINT >> -1::SMALLINT, 1::SMALLINT << 20::SMALLINT, 1::SMALLINT >> 20::SMALLINT\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {0}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {0}));\n+\tREQUIRE(CHECK_COLUMN(result, 2, {0}));\n+\tREQUIRE(CHECK_COLUMN(result, 3, {0}));\n+\tresult = con.Query(\"SELECT 1::INT << -1::INT, 1::INT >> -1::INT, 1::INT << 40::INT, 1::INT >> 40::INT\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {0}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {0}));\n+\tREQUIRE(CHECK_COLUMN(result, 2, {0}));\n+\tREQUIRE(CHECK_COLUMN(result, 3, {0}));\n+\tresult = con.Query(\"SELECT 1::BIGINT << -1::BIGINT, 1::BIGINT >> -1::BIGINT, 1::BIGINT << 1000::BIGINT, 1::BIGINT >> 1000::BIGINT\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {0}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {0}));\n+\tREQUIRE(CHECK_COLUMN(result, 2, {0}));\n+\tREQUIRE(CHECK_COLUMN(result, 3, {0}));\n }\n \n TEST_CASE(\"Test bitwise ops with tables and different types\", \"[bitop]\") {\ndiff --git a/test/sql/simple/test_window.cpp b/test/sql/simple/test_window.cpp\nindex 873b5ea50e75..3954ae62040d 100644\n--- a/test/sql/simple/test_window.cpp\n+++ b/test/sql/simple/test_window.cpp\n@@ -411,23 +411,23 @@ TEST_CASE(\"Expressions in boundaries\", \"[window]\") {\n \n \tresult = con.Query(\"SELECT sum(unique1) over (order by unique1 rows between 2 preceding and 2 following) su FROM \"\n \t                   \"tenk1 order by unique1\");\n-\tREQUIRE(result->types.size() == 1);\n \tREQUIRE(CHECK_COLUMN(result, 0, {3, 6, 10, 15, 20, 25, 30, 35, 30, 24}));\n+\tREQUIRE(result->types.size() == 1);\n \n \tresult = con.Query(\"SELECT sum(unique1) over (order by unique1 rows between 2 preceding and 1 preceding) su FROM \"\n \t                   \"tenk1 order by unique1\");\n-\tREQUIRE(result->types.size() == 1);\n \tREQUIRE(CHECK_COLUMN(result, 0, {Value(), 0, 1, 3, 5, 7, 9, 11, 13, 15}));\n+\tREQUIRE(result->types.size() == 1);\n \n \tresult = con.Query(\"SELECT sum(unique1) over (order by unique1 rows between 1 following and 3 following) su FROM \"\n \t                   \"tenk1 order by unique1\");\n-\tREQUIRE(result->types.size() == 1);\n \tREQUIRE(CHECK_COLUMN(result, 0, {6, 9, 12, 15, 18, 21, 24, 17, 9, Value()}));\n+\tREQUIRE(result->types.size() == 1);\n \n \tresult = con.Query(\"SELECT sum(unique1) over (order by unique1 rows between unbounded preceding and 1 following) \"\n \t                   \"su FROM tenk1 order by unique1\");\n-\tREQUIRE(result->types.size() == 1);\n \tREQUIRE(CHECK_COLUMN(result, 0, {1, 3, 6, 10, 15, 21, 28, 36, 45, 45}));\n+\tREQUIRE(result->types.size() == 1);\n }\n \n TEST_CASE(\"TPC-DS inspired micro benchmarks\", \"[window]\") {\n@@ -516,7 +516,6 @@ TEST_CASE(\"Ensure dbplyr crash with ORDER BY under window stays fixed\", \"[window\n \tresult =\n \t    con.Query(\"SELECT x, g FROM (SELECT x, g, SUM(x) OVER (PARTITION BY g ORDER BY x ROWS UNBOUNDED PRECEDING) AS \"\n \t              \"zzz67 FROM (SELECT x, g FROM dbplyr_052 ORDER BY x) dbplyr_053) dbplyr_054 WHERE (zzz67 > 3.0)\");\n-\tREQUIRE(result->success);\n \tREQUIRE(CHECK_COLUMN(result, 0, {3, 3, 4}));\n \tREQUIRE(CHECK_COLUMN(result, 1, {1.0, 2.0, 2.0}));\n \n@@ -524,7 +523,6 @@ TEST_CASE(\"Ensure dbplyr crash with ORDER BY under window stays fixed\", \"[window\n \tresult =\n \t    con.Query(\"SELECT x, g FROM (SELECT x, g, SUM(x) OVER (PARTITION BY g ORDER BY x ROWS UNBOUNDED PRECEDING) AS \"\n \t              \"zzz67 FROM (SELECT x, g FROM dbplyr_052 ORDER BY w) dbplyr_053) dbplyr_054 WHERE (zzz67 > 3.0)\");\n-\tREQUIRE(result->success);\n \tREQUIRE(CHECK_COLUMN(result, 0, {3, 3, 4}));\n \tREQUIRE(CHECK_COLUMN(result, 1, {1.0, 2.0, 2.0}));\n \n@@ -533,8 +531,6 @@ TEST_CASE(\"Ensure dbplyr crash with ORDER BY under window stays fixed\", \"[window\n \tresult =\n \t    con.Query(\"SELECT x, g FROM (SELECT x, g, SUM(x) OVER (PARTITION BY g ORDER BY x ROWS UNBOUNDED PRECEDING) AS \"\n \t              \"zzz67 FROM (SELECT * FROM dbplyr_052 ORDER BY x) dbplyr_053) dbplyr_054 WHERE (zzz67 > 3.0)\");\n-\tREQUIRE(result->success);\n-\n \tREQUIRE(CHECK_COLUMN(result, 0, {3, 3, 4}));\n \tREQUIRE(CHECK_COLUMN(result, 1, {1.0, 2.0, 2.0}));\n }\n",
  "problem_statement": "Fetching from table and view results in a crash\nConsider the following statements:\r\n\r\n```sql\r\nCREATE TABLE t0(c0 INT);\r\nCREATE VIEW v0 AS SELECT 0, 1 FROM t0 ORDER BY t0.c0;\r\nSELECT t0.c0 FROM t0, v0; -- Conversion: Invalid TypeId <int>\r\n```\r\nUnexpectedly, the type ID changes nondeterministically:\r\n```\r\nsqlite> SELECT t0.c0 FROM t0, v0;\r\nError: Conversion: Invalid TypeId 10\r\nsqlite> SELECT t0.c0 FROM t0, v0;\r\nError: Conversion: Invalid TypeId 54\r\nsqlite> SELECT t0.c0 FROM t0, v0;\r\nError: Conversion: Invalid TypeId 26\r\nsqlite> SELECT t0.c0 FROM t0, v0;\r\nError: Conversion: Invalid TypeId 33\r\nsqlite> SELECT t0.c0 FROM t0, v0;\r\nError: Conversion: Invalid TypeId 255\r\nsqlite> SELECT t0.c0 FROM t0, v0;\r\nError: Conversion: Invalid TypeId 10\r\n```\r\nThe original test case crashed SQLancer. I reduced the crash based on the debug build, where the current test case causes an ASan error:\r\n```\r\n==15622==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000007220 at pc 0x55944781b239 bp 0x7fff3cf78c60 sp 0x7fff3cf78c50\r\nREAD of size 16 at 0x602000007220 thread T0\r\n    #0 0x55944781b238 in void std::_Construct<duckdb::ColumnBinding, duckdb::ColumnBinding&>(duckdb::ColumnBinding*, duckdb::ColumnBinding&) /usr/include/c++/8/bits/stl_construct.h:75\r\n    #1 0x55944781ac9f in duckdb::ColumnBinding* std::__uninitialized_copy<false>::__uninit_copy<__gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > >, duckdb::ColumnBinding*>(__gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > >, __gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > >, duckdb::ColumnBinding*) /usr/include/c++/8/bits/stl_uninitialized.h:83\r\n    #2 0x55944781a1a8 in duckdb::ColumnBinding* std::uninitialized_copy<__gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > >, duckdb::ColumnBinding*>(__gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > >, __gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > >, duckdb::ColumnBinding*) /usr/include/c++/8/bits/stl_uninitialized.h:134\r\n    #3 0x559447818fc4 in duckdb::ColumnBinding* std::__uninitialized_copy_a<__gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > >, duckdb::ColumnBinding*, duckdb::ColumnBinding>(__gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > >, __gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > >, duckdb::ColumnBinding*, std::allocator<duckdb::ColumnBinding>&) /usr/include/c++/8/bits/stl_uninitialized.h:289\r\n    #4 0x55944781747f in void std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> >::_M_range_insert<__gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > > >(__gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > >, __gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > >, __gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > >, std::forward_iterator_tag) (/duckdb/build/debug/duckdb_cli+0xe1947f)\r\n    #5 0x55944781609c in void std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> >::_M_insert_dispatch<__gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > > >(__gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > >, __gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > >, __gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > >, std::__false_type) (/duckdb/build/debug/duckdb_cli+0xe1809c)\r\n    #6 0x559447814b2b in __gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > > std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> >::insert<__gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > >, void>(__gnu_cxx::__normal_iterator<duckdb::ColumnBinding const*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > >, __gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > >, __gnu_cxx::__normal_iterator<duckdb::ColumnBinding*, std::vector<duckdb::ColumnBinding, std::allocator<duckdb::ColumnBinding> > >) (/duckdb/build/debug/duckdb_cli+0xe16b2b)\r\n    #7 0x559447810f73 in duckdb::LogicalPruneColumns::GetColumnBindings() /duckdb/src/planner/operator/logical_prune_columns.cpp:9\r\n    #8 0x5594475a3485 in duckdb::ColumnBindingResolver::VisitOperator(duckdb::LogicalOperator&) /duckdb/src/execution/column_binding_resolver.cpp:69\r\n    #9 0x559447833ad2 in duckdb::LogicalOperatorVisitor::VisitOperatorChildren(duckdb::LogicalOperator&) /duckdb/src/planner/logical_operator_visitor.cpp:17\r\n    #10 0x5594475a339f in duckdb::ColumnBindingResolver::VisitOperator(duckdb::LogicalOperator&) /duckdb/src/execution/column_binding_resolver.cpp:65\r\n    #11 0x559447833ad2 in duckdb::LogicalOperatorVisitor::VisitOperatorChildren(duckdb::LogicalOperator&) /duckdb/src/planner/logical_operator_visitor.cpp:17\r\n    #12 0x5594475a339f in duckdb::ColumnBindingResolver::VisitOperator(duckdb::LogicalOperator&) /duckdb/src/execution/column_binding_resolver.cpp:65\r\n    #13 0x559447833ad2 in duckdb::LogicalOperatorVisitor::VisitOperatorChildren(duckdb::LogicalOperator&) /duckdb/src/planner/logical_operator_visitor.cpp:17\r\n    #14 0x5594475a339f in duckdb::ColumnBindingResolver::VisitOperator(duckdb::LogicalOperator&) /duckdb/src/execution/column_binding_resolver.cpp:65\r\n    #15 0x5594475b0c05 in duckdb::PhysicalPlanGenerator::CreatePlan(std::unique_ptr<duckdb::LogicalOperator, std::default_delete<duckdb::LogicalOperator> >) /duckdb/src/execution/physical_plan_generator.cpp:36\r\n    #16 0x5594475fde99 in duckdb::ClientContext::CreatePreparedStatement(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >) /duckdb/src/main/client_context.cpp:191\r\n    #17 0x55944760147e in duckdb::ClientContext::RunStatementInternal(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >, bool) /duckdb/src/main/client_context.cpp:329\r\n    #18 0x559447601ee7 in duckdb::ClientContext::RunStatement(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::unique_ptr<duckdb::SQLStatement, std::default_delete<duckdb::SQLStatement> >, bool) /duckdb/src/main/client_context.cpp:360\r\n    #19 0x5594475ffb26 in duckdb::ClientContext::Prepare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >) /duckdb/src/main/client_context.cpp:274\r\n    #20 0x55944760b449 in duckdb::Connection::Prepare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >) /duckdb/src/main/connection.cpp:71\r\n    #21 0x5594472db3c9 in sqlite3_prepare_v2 /duckdb/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp:140\r\n    #22 0x5594472b709f in shell_exec /duckdb/tools/shell/shell.c:10347\r\n    #23 0x5594472d122d in runOneSqlLine /duckdb/tools/shell/shell.c:15341\r\n    #24 0x5594472d1b67 in process_input /duckdb/tools/shell/shell.c:15442\r\n    #25 0x5594472d4274 in main /duckdb/tools/shell/shell.c:16107\r\n    #26 0x7f632ae13b6a in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x26b6a)\r\n    #27 0x559447291659 in _start (/duckdb/build/debug/duckdb_cli+0x893659)\r\n```\r\n\r\nI can reproduce this on the latest master (3f0eb5134512c6097805998ccc5eb44476534736).\nSELECT on view with text constant in ORDER BY crashes\nConsider the following statements:\r\n```sql\r\nCREATE TABLE t0(c0 INT);\r\nINSERT INTO t0(c0) VALUES (0);\r\nCREATE VIEW v0(c0) AS SELECT 1 FROM t0;\r\nSELECT * FROM v0 ORDER BY 'a'; --  Assertion `types.size() > 0' failed (original test case crashed)\r\n```\r\nUnexpectedly, the `SELECT` results in an assertion error when executing the debug build:\r\n```\r\n/build/debug$ ./duckdb_cli \r\nSQLite version DuckDB ee09b60a5\r\nEnter \".help\" for usage hints.\r\nConnected to a transient in-memory database.\r\nUse \".open FILENAME\" to reopen on a persistent database.\r\nsqlite> CREATE TABLE t0(c0 INT);\r\nsqlite> INSERT INTO t0(c0) VALUES (0);\r\nsqlite> CREATE VIEW v0(c0) AS SELECT 1 FROM t0;\r\nsqlite> SELECT * FROM v0 ORDER BY 'a'; -- crash or Assertion `types.size() > 0' failed\r\nduckdb_cli: /home/manuel/research/projects/duckdb_test/duckdb/src/common/types/data_chunk.cpp:25: void duckdb::DataChunk::Initialize(std::vector<duckdb::TypeId>&): Assertion `types.size() > 0' failed.\r\nAborted\r\n```\r\nThe original (larger) test cases resulted in a segfault in the release build. I reduced this test case based on the debug build. I found this based on commit ee09b60a58a5d235b18fd1dc7be4843868efa00a.\n",
  "hints_text": "\n",
  "created_at": "2020-04-13T13:17:58Z"
}