You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Large argument to RPAD results in std::bad_alloc
Consider the following statement:

```sql
SELECT RPAD('a', 100000000000000000, 0); -- Error: std::bad_alloc
```
The `SELECT` results in an error `std::bad_alloc`, after running for a while. Is this expected? I checked with MySQL, which seems to immediately return `NULL` for an overly large size argument.

I found this based on commit 11e51619d8402c649cdb45011944a1ca504060f9.

</issue>
<code>
[start of README.md]
1: <img align="left" src="logo/duckdb-logo.png" height="120">
2: 
3: # DuckDB, the SQLite for Analytics
4: [![Travis](https://api.travis-ci.org/cwida/duckdb.svg?branch=master)](https://travis-ci.org/cwida/duckdb)
5: [![CodeFactor](https://www.codefactor.io/repository/github/cwida/duckdb/badge)](https://www.codefactor.io/repository/github/cwida/duckdb)
6: [![Coverage Status](https://coveralls.io/repos/github/cwida/duckdb/badge.svg?branch=master)](https://coveralls.io/github/cwida/duckdb?branch=master)
7: 
8: <br>
9: 
10: 
11: # Requirements
12: DuckDB requires [CMake](https://cmake.org) to be installed and a `C++11` compliant compiler. GCC 4.9 and newer, Clang 3.9 and newer and VisualStudio 2017 are tested on each revision.
13: 
14: ## Compiling
15: Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You may run `make unit` and `make allunit` to verify that your version works properly after making changes.
16: 
17: # Usage
18: A command line utility based on `sqlite3` can be found in either `build/release/duckdb_cli` (release, the default) or `build/debug/duckdb_cli` (debug).
19: 
20: # Embedding
21: As DuckDB is an embedded database, there is no database server to launch or client to connect to a running server. However, the database server can be embedded directly into an application using the C or C++ bindings. The main build process creates the shared library `build/release/src/libduckdb.[so|dylib|dll]` that can be linked against. A static library is built as well.
22: 
23: For examples on how to embed DuckDB into your application, see the [examples](https://github.com/cwida/duckdb/tree/master/examples) folder.
24: 
25: ## Benchmarks
26: After compiling, benchmarks can be executed from the root directory by executing `./build/release/benchmark/benchmark_runner`.
27: 
28: ## Standing on the Shoulders of Giants
29: DuckDB is implemented in C++ 11, should compile with GCC and clang, uses CMake to build and [Catch2](https://github.com/catchorg/Catch2) for testing. DuckDB uses some components from various Open-Source databases and draws inspiration from scientific publications. Here is an overview:
30: 
31: * Parser: We use the PostgreSQL parser that was [repackaged as a stand-alone library](https://github.com/lfittl/libpg_query). The translation to our own parse tree is inspired by [Peloton](https://pelotondb.io).
32: * Shell: We have adapted the [SQLite shell](https://sqlite.org/cli.html) to work with DuckDB.
33: * Tests: We use the [SQL Logic Tests from SQLite](https://www.sqlite.org/sqllogictest/doc/trunk/about.wiki) to test DuckDB.
34: * Query fuzzing: We use [SQLsmith](https://github.com/anse1/sqlsmith) to generate random queries for additional testing.
35: * Date Math: We use the date math component from [MonetDB](https://www.monetdb.org).
36: * SQL Window Functions: DuckDB's window functions implementation uses Segment Tree Aggregation as described in the paper "Efficient Processing of Window Functions in Analytical SQL Queries" by Viktor Leis, Kan Kundhikanjana, Alfons Kemper and Thomas Neumann.
37: * Execution engine: The vectorized execution engine is inspired by the paper "MonetDB/X100: Hyper-Pipelining Query Execution" by Peter Boncz, Marcin Zukowski and Niels Nes.
38: * Optimizer: DuckDB's optimizer draws inspiration from the papers "Dynamic programming strikes back" by Guido Moerkotte and Thomas Neumman as well as "Unnesting Arbitrary Queries" by Thomas Neumann and Alfons Kemper.
39: * Concurrency control: Our MVCC implementation is inspired by the paper "Fast Serializable Multi-Version Concurrency Control for Main-Memory Database Systems" by Thomas Neumann, Tobias Mühlbauer and Alfons Kemper.
40: * Regular Expression: DuckDB uses Google's [RE2](https://github.com/google/re2) regular expression engine.
41: 
42: ## Other pages
43: * [Continuous Benchmarking (CB™)](https://www.duckdb.org/benchmarks/index.html), runs TPC-H, TPC-DS and some microbenchmarks on every commit
[end of README.md]
[start of src/function/scalar/string/pad.cpp]
1: #include "duckdb/function/scalar/string_functions.hpp"
2: 
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/vector_operations/vector_operations.hpp"
5: #include "duckdb/common/vector_operations/ternary_executor.hpp"
6: #include "utf8proc.hpp"
7: 
8: using namespace std;
9: 
10: namespace duckdb {
11: 
12: static pair<idx_t, idx_t> count_chars(const idx_t len, const char *data, const idx_t size) {
13: 	//  Count how much of str will fit in the output
14: 	auto str = reinterpret_cast<const utf8proc_uint8_t *>(data);
15: 	idx_t nbytes = 0;
16: 	idx_t nchars = 0;
17: 	for (; nchars < len && nbytes < size; ++nchars) {
18: 		utf8proc_int32_t codepoint;
19: 		const auto bytes = utf8proc_iterate(str + nbytes, size - nbytes, &codepoint);
20: 		assert(bytes > 0);
21: 		nbytes += bytes;
22: 	}
23: 
24: 	return pair<idx_t, idx_t>(nbytes, nchars);
25: }
26: 
27: static bool insert_padding(const idx_t len, const string_t &pad, vector<char> &result) {
28: 	//  Copy the padding until the output is long enough
29: 	const auto data = pad.GetData();
30: 	const auto size = pad.GetSize();
31: 
32: 	//  Check whether we need data that we don't have
33: 	if (len > 0 && size == 0) {
34: 		return false;
35: 	}
36: 
37: 	//  Insert characters until we have all we need.
38: 	auto str = reinterpret_cast<const utf8proc_uint8_t *>(data);
39: 	idx_t nbytes = 0;
40: 	for (idx_t nchars = 0; nchars < len; ++nchars) {
41: 		//  If we are at the end of the pad, flush all of it and loop back
42: 		if (nbytes >= size) {
43: 			result.insert(result.end(), data, data + size);
44: 			nbytes = 0;
45: 		}
46: 
47: 		//  Write the next character
48: 		utf8proc_int32_t codepoint;
49: 		const auto bytes = utf8proc_iterate(str + nbytes, size - nbytes, &codepoint);
50: 		assert(bytes > 0);
51: 		nbytes += bytes;
52: 	}
53: 
54: 	//  Flush the remaining pad
55: 	result.insert(result.end(), data, data + nbytes);
56: 
57: 	return true;
58: }
59: 
60: static string_t lpad(const string_t &str, const int64_t len, const string_t &pad, vector<char> &result) {
61: 	//  Reuse the buffer
62: 	result.clear();
63: 
64: 	// Get information about the base string
65: 	const auto data_str = str.GetData();
66: 	const auto size_str = str.GetSize();
67: 
68: 	//  Count how much of str will fit in the output
69: 	const auto written = count_chars(len, data_str, size_str);
70: 
71: 	//  Left pad by the number of characters still needed
72: 	if (!insert_padding(len - written.second, pad, result)) {
73: 		throw Exception("Insufficient padding in LPAD.");
74: 	}
75: 
76: 	//  Append as much of the original string as fits
77: 	result.insert(result.end(), data_str, data_str + written.first);
78: 
79: 	return string_t(result.data(), result.size());
80: }
81: 
82: struct LpadOperator {
83: 	static inline string_t Operation(const string_t &str, const int64_t len, const string_t &pad,
84: 	                                 vector<char> &result) {
85: 		return lpad(str, len, pad, result);
86: 	}
87: };
88: 
89: static string_t rpad(const string_t &str, const int64_t len, const string_t &pad, vector<char> &result) {
90: 	//  Reuse the buffer
91: 	result.clear();
92: 
93: 	// Get information about the base string
94: 	const auto data_str = str.GetData();
95: 	const auto size_str = str.GetSize();
96: 
97: 	//  Count how much of str will fit in the output
98: 	const auto written = count_chars(len, data_str, size_str);
99: 
100: 	//  Append as much of the original string as fits
101: 	result.insert(result.end(), data_str, data_str + written.first);
102: 
103: 	//  Right pad by the number of characters still needed
104: 	if (!insert_padding(len - written.second, pad, result)) {
105: 		throw Exception("Insufficient padding in RPAD.");
106: 	};
107: 
108: 	return string_t(result.data(), result.size());
109: }
110: 
111: struct RpadOperator {
112: 	static inline string_t Operation(const string_t &str, const int64_t len, const string_t &pad,
113: 	                                 vector<char> &result) {
114: 		return rpad(str, len, pad, result);
115: 	}
116: };
117: 
118: template <class Op> static void pad_function(DataChunk &args, ExpressionState &state, Vector &result) {
119: 	assert(args.column_count() == 3 && args.data[0].type == TypeId::VARCHAR && args.data[1].type == TypeId::INT64 &&
120: 	       args.data[2].type == TypeId::VARCHAR);
121: 	auto &str_vector = args.data[0];
122: 	auto &len_vector = args.data[1];
123: 	auto &pad_vector = args.data[2];
124: 
125: 	vector<char> buffer;
126: 	TernaryExecutor::Execute<string_t, int64_t, string_t, string_t>(
127: 	    str_vector, len_vector, pad_vector, result, args.size(), [&](string_t str, int64_t len, string_t pad) {
128: 		    len = max(len, int64_t(0));
129: 		    return StringVector::AddString(result, Op::Operation(str, len, pad, buffer));
130: 	    });
131: }
132: 
133: void LpadFun::RegisterFunction(BuiltinFunctions &set) {
134: 	set.AddFunction(ScalarFunction("lpad",                             // name of the function
135: 	                               {SQLType::VARCHAR, SQLType::BIGINT, // argument list
136: 	                                SQLType::VARCHAR},
137: 	                               SQLType::VARCHAR,             // return type
138: 	                               pad_function<LpadOperator>)); // pointer to function implementation
139: }
140: 
141: void RpadFun::RegisterFunction(BuiltinFunctions &set) {
142: 	set.AddFunction(ScalarFunction("rpad",                             // name of the function
143: 	                               {SQLType::VARCHAR, SQLType::BIGINT, // argument list
144: 	                                SQLType::VARCHAR},
145: 	                               SQLType::VARCHAR,             // return type
146: 	                               pad_function<RpadOperator>)); // pointer to function implementation
147: }
148: 
149: } // namespace duckdb
[end of src/function/scalar/string/pad.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: