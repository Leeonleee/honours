{
  "repo": "duckdb/duckdb",
  "pull_number": 611,
  "instance_id": "duckdb__duckdb-611",
  "issue_numbers": [
    "610"
  ],
  "base_commit": "11e51619d8402c649cdb45011944a1ca504060f9",
  "patch": "diff --git a/src/function/scalar/string/pad.cpp b/src/function/scalar/string/pad.cpp\nindex e7c40bdf8f61..34050f7433fd 100644\n--- a/src/function/scalar/string/pad.cpp\n+++ b/src/function/scalar/string/pad.cpp\n@@ -57,7 +57,7 @@ static bool insert_padding(const idx_t len, const string_t &pad, vector<char> &r\n \treturn true;\n }\n \n-static string_t lpad(const string_t &str, const int64_t len, const string_t &pad, vector<char> &result) {\n+static string_t lpad(const string_t &str, const int32_t len, const string_t &pad, vector<char> &result) {\n \t//  Reuse the buffer\n \tresult.clear();\n \n@@ -80,13 +80,13 @@ static string_t lpad(const string_t &str, const int64_t len, const string_t &pad\n }\n \n struct LpadOperator {\n-\tstatic inline string_t Operation(const string_t &str, const int64_t len, const string_t &pad,\n+\tstatic inline string_t Operation(const string_t &str, const int32_t len, const string_t &pad,\n \t                                 vector<char> &result) {\n \t\treturn lpad(str, len, pad, result);\n \t}\n };\n \n-static string_t rpad(const string_t &str, const int64_t len, const string_t &pad, vector<char> &result) {\n+static string_t rpad(const string_t &str, const int32_t len, const string_t &pad, vector<char> &result) {\n \t//  Reuse the buffer\n \tresult.clear();\n \n@@ -109,38 +109,38 @@ static string_t rpad(const string_t &str, const int64_t len, const string_t &pad\n }\n \n struct RpadOperator {\n-\tstatic inline string_t Operation(const string_t &str, const int64_t len, const string_t &pad,\n+\tstatic inline string_t Operation(const string_t &str, const int32_t len, const string_t &pad,\n \t                                 vector<char> &result) {\n \t\treturn rpad(str, len, pad, result);\n \t}\n };\n \n template <class Op> static void pad_function(DataChunk &args, ExpressionState &state, Vector &result) {\n-\tassert(args.column_count() == 3 && args.data[0].type == TypeId::VARCHAR && args.data[1].type == TypeId::INT64 &&\n+\tassert(args.column_count() == 3 && args.data[0].type == TypeId::VARCHAR && args.data[1].type == TypeId::INT32 &&\n \t       args.data[2].type == TypeId::VARCHAR);\n \tauto &str_vector = args.data[0];\n \tauto &len_vector = args.data[1];\n \tauto &pad_vector = args.data[2];\n \n \tvector<char> buffer;\n-\tTernaryExecutor::Execute<string_t, int64_t, string_t, string_t>(\n-\t    str_vector, len_vector, pad_vector, result, args.size(), [&](string_t str, int64_t len, string_t pad) {\n-\t\t    len = max(len, int64_t(0));\n+\tTernaryExecutor::Execute<string_t, int32_t, string_t, string_t>(\n+\t    str_vector, len_vector, pad_vector, result, args.size(), [&](string_t str, int32_t len, string_t pad) {\n+\t\t    len = max(len, int32_t(0));\n \t\t    return StringVector::AddString(result, Op::Operation(str, len, pad, buffer));\n \t    });\n }\n \n void LpadFun::RegisterFunction(BuiltinFunctions &set) {\n-\tset.AddFunction(ScalarFunction(\"lpad\",                             // name of the function\n-\t                               {SQLType::VARCHAR, SQLType::BIGINT, // argument list\n+\tset.AddFunction(ScalarFunction(\"lpad\",                              // name of the function\n+\t                               {SQLType::VARCHAR, SQLType::INTEGER, // argument list\n \t                                SQLType::VARCHAR},\n \t                               SQLType::VARCHAR,             // return type\n \t                               pad_function<LpadOperator>)); // pointer to function implementation\n }\n \n void RpadFun::RegisterFunction(BuiltinFunctions &set) {\n-\tset.AddFunction(ScalarFunction(\"rpad\",                             // name of the function\n-\t                               {SQLType::VARCHAR, SQLType::BIGINT, // argument list\n+\tset.AddFunction(ScalarFunction(\"rpad\",                              // name of the function\n+\t                               {SQLType::VARCHAR, SQLType::INTEGER, // argument list\n \t                                SQLType::VARCHAR},\n \t                               SQLType::VARCHAR,             // return type\n \t                               pad_function<RpadOperator>)); // pointer to function implementation\n",
  "test_patch": "diff --git a/test/sql/function/test_stringfunctions.cpp b/test/sql/function/test_stringfunctions.cpp\nindex 288594b810af..8602a2bfb95b 100644\n--- a/test/sql/function/test_stringfunctions.cpp\n+++ b/test/sql/function/test_stringfunctions.cpp\n@@ -274,11 +274,13 @@ TEST_CASE(\"LPAD/RPAD test\", \"[function]\") {\n \tREQUIRE_FAIL(con.Query(\"select LPAD(1)\"));\n \tREQUIRE_FAIL(con.Query(\"select LPAD(1, 2)\"));\n \tREQUIRE_FAIL(con.Query(\"select LPAD('Hello', 10, '')\"));\n+\tREQUIRE_FAIL(con.Query(\"select LPAD('a', 100000000000000000, 0)\"));\n \n \tREQUIRE_FAIL(con.Query(\"select RPAD()\"));\n \tREQUIRE_FAIL(con.Query(\"select RPAD(1)\"));\n \tREQUIRE_FAIL(con.Query(\"select RPAD(1, 2)\"));\n \tREQUIRE_FAIL(con.Query(\"select RPAD('Hello', 10, '')\"));\n+\tREQUIRE_FAIL(con.Query(\"select RPAD('a', 100000000000000000, 0)\"));\n }\n \n TEST_CASE(\"REPEAT test\", \"[function]\") {\n",
  "problem_statement": "Large argument to RPAD results in std::bad_alloc\nConsider the following statement:\r\n\r\n```sql\r\nSELECT RPAD('a', 100000000000000000, 0); -- Error: std::bad_alloc\r\n```\r\nThe `SELECT` results in an error `std::bad_alloc`, after running for a while. Is this expected? I checked with MySQL, which seems to immediately return `NULL` for an overly large size argument.\r\n\r\nI found this based on commit 11e51619d8402c649cdb45011944a1ca504060f9.\n",
  "hints_text": "",
  "created_at": "2020-05-01T22:39:34Z"
}