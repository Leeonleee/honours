{
  "repo": "duckdb/duckdb",
  "pull_number": 14610,
  "instance_id": "duckdb__duckdb-14610",
  "issue_numbers": [
    "14542",
    "14542"
  ],
  "base_commit": "4ba2e66277a7576f58318c1aac112faa67c47b11",
  "patch": "diff --git a/src/include/duckdb/optimizer/unnest_rewriter.hpp b/src/include/duckdb/optimizer/unnest_rewriter.hpp\nindex 3798cbd4bfde..842d5ef2c545 100644\n--- a/src/include/duckdb/optimizer/unnest_rewriter.hpp\n+++ b/src/include/duckdb/optimizer/unnest_rewriter.hpp\n@@ -8,8 +8,8 @@\n \n #pragma once\n \n-#include \"duckdb/planner/logical_operator.hpp\"\n #include \"duckdb/common/pair.hpp\"\n+#include \"duckdb/planner/logical_operator.hpp\"\n \n namespace duckdb {\n \n@@ -61,14 +61,14 @@ class UnnestRewriter {\n \n private:\n \t//! Find delim joins that contain an UNNEST\n-\tvoid FindCandidates(unique_ptr<LogicalOperator> *op_ptr, vector<unique_ptr<LogicalOperator> *> &candidates);\n+\tvoid FindCandidates(unique_ptr<LogicalOperator> &op, vector<reference<unique_ptr<LogicalOperator>>> &candidates);\n \t//! Rewrite a delim join that contains an UNNEST\n-\tbool RewriteCandidate(unique_ptr<LogicalOperator> *candidate);\n+\tbool RewriteCandidate(unique_ptr<LogicalOperator> &candidate);\n \t//! Update the bindings of the RHS sequence of LOGICAL_PROJECTION(s)\n-\tvoid UpdateRHSBindings(unique_ptr<LogicalOperator> *plan_ptr, unique_ptr<LogicalOperator> *candidate,\n+\tvoid UpdateRHSBindings(unique_ptr<LogicalOperator> &plan, unique_ptr<LogicalOperator> &candidate,\n \t                       UnnestRewriterPlanUpdater &updater);\n \t//! Update the bindings of the BOUND_UNNEST expression of the LOGICAL_UNNEST\n-\tvoid UpdateBoundUnnestBindings(UnnestRewriterPlanUpdater &updater, unique_ptr<LogicalOperator> *candidate);\n+\tvoid UpdateBoundUnnestBindings(UnnestRewriterPlanUpdater &updater, unique_ptr<LogicalOperator> &candidate);\n \n \t//! Store all delim columns of the delim join\n \tvoid GetDelimColumns(LogicalOperator &op);\ndiff --git a/src/optimizer/unnest_rewriter.cpp b/src/optimizer/unnest_rewriter.cpp\nindex f5d91061f3d2..796a9338b946 100644\n--- a/src/optimizer/unnest_rewriter.cpp\n+++ b/src/optimizer/unnest_rewriter.cpp\n@@ -1,13 +1,13 @@\n #include \"duckdb/optimizer/unnest_rewriter.hpp\"\n \n #include \"duckdb/common/pair.hpp\"\n-#include \"duckdb/planner/operator/logical_delim_get.hpp\"\n+#include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_unnest_expression.hpp\"\n #include \"duckdb/planner/operator/logical_comparison_join.hpp\"\n-#include \"duckdb/planner/operator/logical_unnest.hpp\"\n+#include \"duckdb/planner/operator/logical_delim_get.hpp\"\n #include \"duckdb/planner/operator/logical_projection.hpp\"\n+#include \"duckdb/planner/operator/logical_unnest.hpp\"\n #include \"duckdb/planner/operator/logical_window.hpp\"\n-#include \"duckdb/planner/expression/bound_unnest_expression.hpp\"\n-#include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n \n namespace duckdb {\n \n@@ -35,8 +35,8 @@ void UnnestRewriterPlanUpdater::VisitExpression(unique_ptr<Expression> *expressi\n unique_ptr<LogicalOperator> UnnestRewriter::Optimize(unique_ptr<LogicalOperator> op) {\n \n \tUnnestRewriterPlanUpdater updater;\n-\tvector<unique_ptr<LogicalOperator> *> candidates;\n-\tFindCandidates(&op, candidates);\n+\tvector<reference<unique_ptr<LogicalOperator>>> candidates;\n+\tFindCandidates(op, candidates);\n \n \t// rewrite the plan and update the bindings\n \tfor (auto &candidate : candidates) {\n@@ -47,7 +47,7 @@ unique_ptr<LogicalOperator> UnnestRewriter::Optimize(unique_ptr<LogicalOperator>\n \t\t\t// update the bindings of the BOUND_UNNEST expression\n \t\t\tUpdateBoundUnnestBindings(updater, candidate);\n \t\t\t// update the sequence of LOGICAL_PROJECTION(s)\n-\t\t\tUpdateRHSBindings(&op, candidate, updater);\n+\t\t\tUpdateRHSBindings(op, candidate, updater);\n \t\t\t// reset\n \t\t\tdelim_columns.clear();\n \t\t\tlhs_bindings.clear();\n@@ -57,12 +57,11 @@ unique_ptr<LogicalOperator> UnnestRewriter::Optimize(unique_ptr<LogicalOperator>\n \treturn op;\n }\n \n-void UnnestRewriter::FindCandidates(unique_ptr<LogicalOperator> *op_ptr,\n-                                    vector<unique_ptr<LogicalOperator> *> &candidates) {\n-\tauto op = op_ptr->get();\n+void UnnestRewriter::FindCandidates(unique_ptr<LogicalOperator> &op,\n+                                    vector<reference<unique_ptr<LogicalOperator>>> &candidates) {\n \t// search children before adding, so that we add candidates bottom-up\n \tfor (auto &child : op->children) {\n-\t\tFindCandidates(&child, candidates);\n+\t\tFindCandidates(child, candidates);\n \t}\n \n \t// search for operator that has a LOGICAL_DELIM_JOIN as its child\n@@ -100,14 +99,15 @@ void UnnestRewriter::FindCandidates(unique_ptr<LogicalOperator> *op_ptr,\n \t\tcurr_op = &curr_op->get()->children[0];\n \t}\n \n-\tif (curr_op->get()->type == LogicalOperatorType::LOGICAL_UNNEST) {\n-\t\tcandidates.push_back(op_ptr);\n+\tif (curr_op->get()->type == LogicalOperatorType::LOGICAL_UNNEST &&\n+\t    curr_op->get()->children[0]->type == LogicalOperatorType::LOGICAL_DELIM_GET) {\n+\t\tcandidates.push_back(op);\n \t}\n }\n \n-bool UnnestRewriter::RewriteCandidate(unique_ptr<LogicalOperator> *candidate) {\n+bool UnnestRewriter::RewriteCandidate(unique_ptr<LogicalOperator> &candidate) {\n \n-\tauto &topmost_op = (LogicalOperator &)**candidate;\n+\tauto &topmost_op = *candidate;\n \tif (topmost_op.type != LogicalOperatorType::LOGICAL_PROJECTION &&\n \t    topmost_op.type != LogicalOperatorType::LOGICAL_WINDOW &&\n \t    topmost_op.type != LogicalOperatorType::LOGICAL_FILTER &&\n@@ -158,10 +158,10 @@ bool UnnestRewriter::RewriteCandidate(unique_ptr<LogicalOperator> *candidate) {\n \treturn true;\n }\n \n-void UnnestRewriter::UpdateRHSBindings(unique_ptr<LogicalOperator> *plan_ptr, unique_ptr<LogicalOperator> *candidate,\n+void UnnestRewriter::UpdateRHSBindings(unique_ptr<LogicalOperator> &plan, unique_ptr<LogicalOperator> &candidate,\n                                        UnnestRewriterPlanUpdater &updater) {\n \n-\tauto &topmost_op = (LogicalOperator &)**candidate;\n+\tauto &topmost_op = *candidate;\n \tidx_t shift = lhs_bindings.size();\n \n \tvector<unique_ptr<LogicalOperator> *> path_to_unnest;\n@@ -189,7 +189,7 @@ void UnnestRewriter::UpdateRHSBindings(unique_ptr<LogicalOperator> *plan_ptr, un\n \t}\n \n \t// update all bindings by shifting them\n-\tupdater.VisitOperator(*plan_ptr->get());\n+\tupdater.VisitOperator(*plan);\n \tupdater.replace_bindings.clear();\n \n \t// update all bindings coming from the LHS to RHS bindings\n@@ -212,7 +212,7 @@ void UnnestRewriter::UpdateRHSBindings(unique_ptr<LogicalOperator> *plan_ptr, un\n \tunnest.expressions.clear();\n \tunnest.children.clear();\n \t// update the bindings of the plan\n-\tupdater.VisitOperator(*plan_ptr->get());\n+\tupdater.VisitOperator(*plan);\n \tupdater.replace_bindings.clear();\n \t// add the children again\n \tfor (auto &temp_bound_unnest : temp_bound_unnests) {\n@@ -253,9 +253,9 @@ void UnnestRewriter::UpdateRHSBindings(unique_ptr<LogicalOperator> *plan_ptr, un\n }\n \n void UnnestRewriter::UpdateBoundUnnestBindings(UnnestRewriterPlanUpdater &updater,\n-                                               unique_ptr<LogicalOperator> *candidate) {\n+                                               unique_ptr<LogicalOperator> &candidate) {\n \n-\tauto &topmost_op = (LogicalOperator &)**candidate;\n+\tauto &topmost_op = *candidate;\n \n \t// traverse LOGICAL_PROJECTION(s)\n \tauto curr_op = &topmost_op.children[0];\n",
  "test_patch": "diff --git a/test/optimizer/unnest_rewriter_issue_14542.test b/test/optimizer/unnest_rewriter_issue_14542.test\nnew file mode 100644\nindex 000000000000..d55199997da7\n--- /dev/null\n+++ b/test/optimizer/unnest_rewriter_issue_14542.test\n@@ -0,0 +1,28 @@\n+# name: test/optimizer/unnest_rewriter_issue_14542.test\n+# description: Test issue #14542: INTERNAL error when using a macro to expand json[] array (json_each)\n+# group: [optimizer]\n+\n+require json\n+\n+statement ok\n+CREATE OR REPLACE MACRO json_each(input) AS\n+TABLE (\n+  SELECT\n+      CASE json_type (val::json)\n+      WHEN 'ARRAY' THEN\n+          unnest(RANGE (json_array_length(val::json)::bigint)) ::varchar\n+      ELSE\n+          unnest(json_keys (val::json))\n+      END AS key,\n+      json_extract (val::json, key) AS value\n+  FROM (SELECT input as val)\n+);\n+\n+statement ok\n+FROM (SELECT '[1,2,3]' as message) CROSS JOIN json_each(message);\n+\n+statement ok\n+FROM (SELECT '[1,2,3]'::json as message) CROSS JOIN json_each(message);\n+\n+statement ok\n+FROM (SELECT '[1,2,3]'::json[] as message) CROSS JOIN json_each(message);\n",
  "problem_statement": "INTERNAL error when using a macro to expand json[] array (`json_each`)\n### What happens?\r\n\r\nWhen I use the macro defined below with a `json[]` column, it errors out, but text and json types convert correctly.\r\n\r\nINTERNAL Error: Failed to cast logical operator to type - logical operator type mismatch\r\nThis error signals an assertion failure within DuckDB. This usually occurs due to unexpected conditions or errors in the program's logic.\r\nFor more information, see https://duckdb.org/docs/dev/internal_errors\r\n\r\n### To Reproduce\r\n\r\nFrom the cli:\r\n```sh\r\nduckdb -c \"\r\n  CREATE OR REPLACE MACRO json_each(input) AS\r\n    TABLE (\r\n      SELECT\r\n          CASE json_type (val::json)\r\n          WHEN 'ARRAY' THEN\r\n              unnest(RANGE (json_array_length(val::json)::bigint)) ::varchar\r\n          ELSE\r\n              unnest(json_keys (val::json))\r\n          END AS key,\r\n          json_extract (val::json, key) AS value\r\n      FROM (SELECT input as val)\r\n    );\r\n\r\n  FROM (SELECT '[1,2,3]' as message) CROSS JOIN json_each(message);\r\n  FROM (SELECT '[1,2,3]'::json as message) CROSS JOIN json_each(message);\r\n  FROM (SELECT '[1,2,3]'::json[] as message) CROSS JOIN json_each(message);\r\n  \"\r\n```\r\n\r\nOutput:\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 message \u2502   key   \u2502 value \u2502\r\n\u2502 varchar \u2502 varchar \u2502 json  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 [1,2,3] \u2502 0       \u2502 1     \u2502\r\n\u2502 [1,2,3] \u2502 1       \u2502 2     \u2502\r\n\u2502 [1,2,3] \u2502 2       \u2502 3     \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 message \u2502   key   \u2502 value \u2502\r\n\u2502  json   \u2502 varchar \u2502 json  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 [1,2,3] \u2502 0       \u2502 1     \u2502\r\n\u2502 [1,2,3] \u2502 1       \u2502 2     \u2502\r\n\u2502 [1,2,3] \u2502 2       \u2502 3     \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nINTERNAL Error: Failed to cast logical operator to type - logical operator type mismatch\r\nThis error signals an assertion failure within DuckDB. This usually occurs due to unexpected conditions or errors in the program's logic.\r\nFor more information, see https://duckdb.org/docs/dev/internal_errors\r\n```\r\n\r\n### OS:\r\n\r\nlinux\r\n\r\n### DuckDB Version:\r\n\r\n1.0.0, 1.1.0\r\n\r\n### DuckDB Client:\r\n\r\nCLI\r\n\r\n### Hardware:\r\n\r\n_No response_\r\n\r\n### Full Name:\r\n\r\nAshkan Kiani\r\n\r\n### Affiliation:\r\n\r\nJane Street\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\nINTERNAL error when using a macro to expand json[] array (`json_each`)\n### What happens?\r\n\r\nWhen I use the macro defined below with a `json[]` column, it errors out, but text and json types convert correctly.\r\n\r\nINTERNAL Error: Failed to cast logical operator to type - logical operator type mismatch\r\nThis error signals an assertion failure within DuckDB. This usually occurs due to unexpected conditions or errors in the program's logic.\r\nFor more information, see https://duckdb.org/docs/dev/internal_errors\r\n\r\n### To Reproduce\r\n\r\nFrom the cli:\r\n```sh\r\nduckdb -c \"\r\n  CREATE OR REPLACE MACRO json_each(input) AS\r\n    TABLE (\r\n      SELECT\r\n          CASE json_type (val::json)\r\n          WHEN 'ARRAY' THEN\r\n              unnest(RANGE (json_array_length(val::json)::bigint)) ::varchar\r\n          ELSE\r\n              unnest(json_keys (val::json))\r\n          END AS key,\r\n          json_extract (val::json, key) AS value\r\n      FROM (SELECT input as val)\r\n    );\r\n\r\n  FROM (SELECT '[1,2,3]' as message) CROSS JOIN json_each(message);\r\n  FROM (SELECT '[1,2,3]'::json as message) CROSS JOIN json_each(message);\r\n  FROM (SELECT '[1,2,3]'::json[] as message) CROSS JOIN json_each(message);\r\n  \"\r\n```\r\n\r\nOutput:\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 message \u2502   key   \u2502 value \u2502\r\n\u2502 varchar \u2502 varchar \u2502 json  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 [1,2,3] \u2502 0       \u2502 1     \u2502\r\n\u2502 [1,2,3] \u2502 1       \u2502 2     \u2502\r\n\u2502 [1,2,3] \u2502 2       \u2502 3     \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 message \u2502   key   \u2502 value \u2502\r\n\u2502  json   \u2502 varchar \u2502 json  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 [1,2,3] \u2502 0       \u2502 1     \u2502\r\n\u2502 [1,2,3] \u2502 1       \u2502 2     \u2502\r\n\u2502 [1,2,3] \u2502 2       \u2502 3     \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\nINTERNAL Error: Failed to cast logical operator to type - logical operator type mismatch\r\nThis error signals an assertion failure within DuckDB. This usually occurs due to unexpected conditions or errors in the program's logic.\r\nFor more information, see https://duckdb.org/docs/dev/internal_errors\r\n```\r\n\r\n### OS:\r\n\r\nlinux\r\n\r\n### DuckDB Version:\r\n\r\n1.0.0, 1.1.0\r\n\r\n### DuckDB Client:\r\n\r\nCLI\r\n\r\n### Hardware:\r\n\r\n_No response_\r\n\r\n### Full Name:\r\n\r\nAshkan Kiani\r\n\r\n### Affiliation:\r\n\r\nJane Street\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nYes\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "I noticed that trying to cast it within the macro call, i.e. `json_each(obj::json)` also fails. Only casting it in a subquery before calling the macro seems to not error out.\r\n\r\nIt seems there's a conversion issue with json[]\nThanks for the issue and the additional context. I could reproduce this very easily.\nI noticed that trying to cast it within the macro call, i.e. `json_each(obj::json)` also fails. Only casting it in a subquery before calling the macro seems to not error out.\r\n\r\nIt seems there's a conversion issue with json[]\nThanks for the issue and the additional context. I could reproduce this very easily.",
  "created_at": "2024-10-29T14:25:23Z"
}