{
  "repo": "duckdb/duckdb",
  "pull_number": 2302,
  "instance_id": "duckdb__duckdb-2302",
  "issue_numbers": [
    "2301"
  ],
  "base_commit": "7dd852e1dd7aa521e76cbf6f756da487e2e1a1cd",
  "patch": "diff --git a/src/execution/index/art/leaf.cpp b/src/execution/index/art/leaf.cpp\nindex 68c5958dc8eb..cf131a00f144 100644\n--- a/src/execution/index/art/leaf.cpp\n+++ b/src/execution/index/art/leaf.cpp\n@@ -24,7 +24,6 @@ void Leaf::Insert(row_t row_id) {\n \trow_ids[num_elements++] = row_id;\n }\n \n-//! TODO: Maybe shrink array dynamically?\n void Leaf::Remove(row_t row_id) {\n \tidx_t entry_offset = INVALID_INDEX;\n \tfor (idx_t i = 0; i < num_elements; i++) {\n@@ -37,8 +36,19 @@ void Leaf::Remove(row_t row_id) {\n \t\treturn;\n \t}\n \tnum_elements--;\n-\tfor (idx_t j = entry_offset; j < num_elements; j++) {\n-\t\trow_ids[j] = row_ids[j + 1];\n+\tif (capacity > 2 && num_elements < capacity / 2) {\n+\t\t// Shrink array, if less than half full\n+\t\tauto new_row_id = unique_ptr<row_t[]>(new row_t[capacity / 2]);\n+\t\tmemcpy(new_row_id.get(), row_ids.get(), entry_offset * sizeof(row_t));\n+\t\tmemcpy(new_row_id.get() + entry_offset, row_ids.get() + entry_offset + 1,\n+\t\t       (num_elements - entry_offset) * sizeof(row_t));\n+\t\tcapacity /= 2;\n+\t\trow_ids = move(new_row_id);\n+\t} else {\n+\t\t// Copy the rest\n+\t\tfor (idx_t j = entry_offset; j < num_elements; j++) {\n+\t\t\trow_ids[j] = row_ids[j + 1];\n+\t\t}\n \t}\n }\n \ndiff --git a/src/execution/index/art/node16.cpp b/src/execution/index/art/node16.cpp\nindex 92f686ab3537..0a768c277e66 100644\n--- a/src/execution/index/art/node16.cpp\n+++ b/src/execution/index/art/node16.cpp\n@@ -10,7 +10,6 @@ Node16::Node16(ART &art, size_t compression_length) : Node(art, NodeType::N16, c\n \tmemset(key, 16, sizeof(key));\n }\n \n-// TODO : In the future this can be performed using SIMD (#include <emmintrin.h>  x86 SSE intrinsics)\n idx_t Node16::GetChildPos(uint8_t k) {\n \tfor (idx_t pos = 0; pos < count; pos++) {\n \t\tif (key[pos] == k) {\n",
  "test_patch": "diff --git a/test/sql/index/art/test_art_node_leaf_with_duplicates.test b/test/sql/index/art/test_art_node_leaf_with_duplicates.test\nnew file mode 100644\nindex 000000000000..3e5d9ec1cf4c\n--- /dev/null\n+++ b/test/sql/index/art/test_art_node_leaf_with_duplicates.test\n@@ -0,0 +1,167 @@\n+# name: test/sql/index/art/test_art_node_leaf_with_duplicates.test\n+# description: ART Node Leaf with removing duplicated keys\n+# group: [art]\n+\n+statement ok\n+CREATE TABLE integers(i integer)\n+\n+statement ok\n+CREATE INDEX i_index ON integers(i)\n+\n+# insert 4 elements\n+loop i 0 4\n+\n+statement ok\n+INSERT INTO integers VALUES (1);\n+\n+endloop\n+\n+# verify counts\n+\n+query I\n+SELECT COUNT(*) FROM integers WHERE i = 1\n+----\n+4\n+\n+# verify sums\n+\n+query I\n+SELECT sum(i) FROM integers WHERE i <= 2\n+----\n+4\n+\n+# now delete all elements\n+\n+statement ok\n+DELETE FROM integers WHERE i = 1\n+\n+# verify counts\n+\n+query I\n+SELECT COUNT(*) FROM integers WHERE i = 1\n+----\n+0\n+\n+query I\n+SELECT COUNT(*) FROM integers\n+----\n+0\n+\n+# insert 1024 elements\n+loop i 0 1024\n+\n+statement ok\n+INSERT INTO integers VALUES (1);\n+\n+endloop\n+\n+# verify counts\n+\n+query I\n+SELECT COUNT(*) FROM integers WHERE i = 1\n+----\n+1024\n+\n+# verify sums\n+\n+query I\n+SELECT sum(i) FROM integers WHERE i <= 2\n+----\n+1024\n+\n+# now delete all elements\n+\n+statement ok\n+DELETE FROM integers WHERE i = 1\n+\n+# verify counts\n+\n+query I\n+SELECT COUNT(*) FROM integers WHERE i = 1\n+----\n+0\n+\n+query I\n+SELECT COUNT(*) FROM integers\n+----\n+0\n+\n+# insert 3000 elements: 1\n+loop i 0 3000\n+\n+statement ok\n+INSERT INTO integers VALUES (1);\n+\n+endloop\n+\n+# insert 1024 elements: 2\n+loop i 0 1024\n+\n+statement ok\n+INSERT INTO integers VALUES (2);\n+\n+endloop\n+\n+# verify counts\n+\n+query I\n+SELECT COUNT(*) FROM integers WHERE i = 1\n+----\n+3000\n+\n+query I\n+SELECT COUNT(*) FROM integers WHERE i = 2\n+----\n+1024\n+\n+query I\n+SELECT COUNT(*) FROM integers WHERE i <= 2\n+----\n+4024\n+\n+# verify sums\n+\n+query I\n+SELECT sum(i) FROM integers WHERE i <= 2\n+----\n+5048\n+\n+# now delete all elements: 2\n+\n+statement ok\n+DELETE FROM integers WHERE i = 2\n+\n+# verify counts\n+\n+query I\n+SELECT COUNT(*) FROM integers WHERE i = 1\n+----\n+3000\n+\n+query I\n+SELECT COUNT(*) FROM integers\n+----\n+3000\n+\n+# now delete all elements: 1\n+\n+statement ok\n+DELETE FROM integers WHERE i = 1\n+\n+# verify counts\n+\n+query I\n+SELECT COUNT(*) FROM integers WHERE i = 1\n+----\n+0\n+\n+query I\n+SELECT COUNT(*) FROM integers\n+----\n+0\n+\n+statement ok\n+DROP INDEX i_index\n+\n+statement ok\n+DROP TABLE integers\ndiff --git a/test/sql/index/art/test_art_node_leaf_with_duplicates_multi_column.test b/test/sql/index/art/test_art_node_leaf_with_duplicates_multi_column.test\nnew file mode 100644\nindex 000000000000..32ba56f88e68\n--- /dev/null\n+++ b/test/sql/index/art/test_art_node_leaf_with_duplicates_multi_column.test\n@@ -0,0 +1,98 @@\n+# name: test/sql/index/art/test_art_node_leaf_with_duplicates_multi_column.test\n+# description: ART Node Leaf with removing duplicated keys from multi column table\n+# group: [art]\n+\n+statement ok\n+CREATE TABLE integers AS SELECT range a, 1 AS b, 1 AS c FROM range(1024)\n+\n+statement ok\n+CREATE INDEX b_index ON integers(b)\n+\n+# verify counts\n+\n+query I\n+SELECT sum(b) FROM integers\n+----\n+1024\n+\n+query I\n+SELECT sum(b) FROM integers WHERE b = 1\n+----\n+1024\n+\n+query I\n+SELECT sum(b) FROM integers\n+----\n+1024\n+\n+# now delete some elements\n+\n+statement ok\n+DELETE FROM integers WHERE a < 100\n+\n+# verify counts\n+\n+query I\n+SELECT COUNT(b) FROM integers\n+----\n+924\n+\n+query I\n+SELECT COUNT(b) FROM integers WHERE b = 1\n+----\n+924\n+\n+query I\n+SELECT sum(b) FROM integers\n+----\n+924\n+\n+# now delete more elements\n+\n+statement ok\n+DELETE FROM integers WHERE a < 600\n+\n+# verify counts\n+\n+query I\n+SELECT COUNT(b) FROM integers\n+----\n+424\n+\n+query I\n+SELECT COUNT(b) FROM integers WHERE b = 1\n+----\n+424\n+\n+query I\n+SELECT sum(b) FROM integers\n+----\n+424\n+\n+# now delete all elements\n+\n+statement ok\n+DELETE FROM integers WHERE a < 1024\n+\n+# verify counts\n+\n+query I\n+SELECT COUNT(*) FROM integers\n+----\n+0\n+\n+query I\n+SELECT COUNT(*) FROM integers WHERE b = 1\n+----\n+0\n+\n+query I\n+SELECT COUNT(*) FROM integers\n+----\n+0\n+\n+statement ok\n+DROP INDEX b_index\n+\n+statement ok\n+DROP TABLE integers\n",
  "problem_statement": "The Leaf Node of ART needs to be shrunk dynamically.\nFound in the comment: \r\n\r\nhttps://github.com/duckdb/duckdb/blob/7dd852e1dd7aa521e76cbf6f756da487e2e1a1cd/src/execution/index/art/leaf.cpp#L27\r\n\r\nThe leaf node is for the values having the same key. (each prefix byte of the key is the same).\r\nThe idea is similar to a C++'s STL `std::multimap`.\r\nHowever, it is not clear, how many duplicates can exist in a leaf node.\r\nThus, the leaf node should dynamically grow and shrink.\r\n(The dynamical grow part is a must and is already implemented.)\n",
  "hints_text": "",
  "created_at": "2021-09-20T13:01:43Z"
}