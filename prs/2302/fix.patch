diff --git a/src/execution/index/art/leaf.cpp b/src/execution/index/art/leaf.cpp
index 68c5958dc8eb..cf131a00f144 100644
--- a/src/execution/index/art/leaf.cpp
+++ b/src/execution/index/art/leaf.cpp
@@ -24,7 +24,6 @@ void Leaf::Insert(row_t row_id) {
 	row_ids[num_elements++] = row_id;
 }
 
-//! TODO: Maybe shrink array dynamically?
 void Leaf::Remove(row_t row_id) {
 	idx_t entry_offset = INVALID_INDEX;
 	for (idx_t i = 0; i < num_elements; i++) {
@@ -37,8 +36,19 @@ void Leaf::Remove(row_t row_id) {
 		return;
 	}
 	num_elements--;
-	for (idx_t j = entry_offset; j < num_elements; j++) {
-		row_ids[j] = row_ids[j + 1];
+	if (capacity > 2 && num_elements < capacity / 2) {
+		// Shrink array, if less than half full
+		auto new_row_id = unique_ptr<row_t[]>(new row_t[capacity / 2]);
+		memcpy(new_row_id.get(), row_ids.get(), entry_offset * sizeof(row_t));
+		memcpy(new_row_id.get() + entry_offset, row_ids.get() + entry_offset + 1,
+		       (num_elements - entry_offset) * sizeof(row_t));
+		capacity /= 2;
+		row_ids = move(new_row_id);
+	} else {
+		// Copy the rest
+		for (idx_t j = entry_offset; j < num_elements; j++) {
+			row_ids[j] = row_ids[j + 1];
+		}
 	}
 }
 
diff --git a/src/execution/index/art/node16.cpp b/src/execution/index/art/node16.cpp
index 92f686ab3537..0a768c277e66 100644
--- a/src/execution/index/art/node16.cpp
+++ b/src/execution/index/art/node16.cpp
@@ -10,7 +10,6 @@ Node16::Node16(ART &art, size_t compression_length) : Node(art, NodeType::N16, c
 	memset(key, 16, sizeof(key));
 }
 
-// TODO : In the future this can be performed using SIMD (#include <emmintrin.h>  x86 SSE intrinsics)
 idx_t Node16::GetChildPos(uint8_t k) {
 	for (idx_t pos = 0; pos < count; pos++) {
 		if (key[pos] == k) {
