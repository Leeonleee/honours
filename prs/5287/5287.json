{
  "repo": "duckdb/duckdb",
  "pull_number": 5287,
  "instance_id": "duckdb__duckdb-5287",
  "issue_numbers": [
    "5237"
  ],
  "base_commit": "80861d6b6f6430bbb9d4a6aff4195601d1b34395",
  "patch": "diff --git a/extension/icu/third_party/icu/i18n/erarules.cpp b/extension/icu/third_party/icu/i18n/erarules.cpp\nindex e375740bd6b1..d2dab97d5291 100644\n--- a/extension/icu/third_party/icu/i18n/erarules.cpp\n+++ b/extension/icu/third_party/icu/i18n/erarules.cpp\n@@ -54,7 +54,7 @@ static UBool isValidRuleStartDate(int32_t year, int32_t month, int32_t day) {\n  * @return  an encoded date.\n  */\n static int32_t encodeDate(int32_t year, int32_t month, int32_t day) {\n-    return year << 16 | month << 8 | day;\n+\treturn ((uint32_t)year) << 16 | month << 8 | day;\n }\n \n static void decodeDate(int32_t encodedDate, int32_t (&fields)[3]) {\ndiff --git a/extension/icu/third_party/icu/i18n/indiancal.cpp b/extension/icu/third_party/icu/i18n/indiancal.cpp\nindex c4cba6d2217b..695e1fe3edcb 100644\n--- a/extension/icu/third_party/icu/i18n/indiancal.cpp\n+++ b/extension/icu/third_party/icu/i18n/indiancal.cpp\n@@ -83,7 +83,6 @@ static const int32_t INDIANCAL_LIMITS[UCAL_FIELD_COUNT][4] = {\n     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // IS_LEAP_MONTH\n };\n \n-static const double JULIAN_EPOCH = 1721425.5;\n static const int32_t INDIAN_ERA_START  = 78;\n static const int32_t INDIAN_YEAR_START = 80;\n \n@@ -96,7 +95,7 @@ int32_t IndianCalendar::handleGetLimit(UCalendarDateFields field, ELimitType lim\n  */\n static UBool isGregorianLeap(int32_t year)\n {\n-    return ((year % 4) == 0) && (!(((year % 100) == 0) && ((year % 400) != 0)));\n+    return Grego::isLeapYear(year);\n }\n \n //----------------------------------------------------------------------\n@@ -137,56 +136,22 @@ int32_t IndianCalendar::handleGetYearLength(int32_t eyear) const {\n  * Returns the Julian Day corresponding to gregorian date\n  *\n  * @param year The Gregorian year\n- * @param month The month in Gregorian Year\n+ * @param month The month in Gregorian Year, 0 based.\n  * @param date The date in Gregorian day in month\n  */\n static double gregorianToJD(int32_t year, int32_t month, int32_t date) {\n-   double julianDay = (JULIAN_EPOCH - 1) +\n-      (365 * (year - 1)) +\n-      uprv_floor((year - 1) / 4) +\n-      (-uprv_floor((year - 1) / 100)) +\n-      uprv_floor((year - 1) / 400) +\n-      uprv_floor((((367 * month) - 362) / 12) +\n-            ((month <= 2) ? 0 :\n-             (isGregorianLeap(year) ? -1 : -2)\n-            ) +\n-            date);\n-\n-   return julianDay;\n+   return Grego::fieldsToDay(year, month, date) + kEpochStartAsJulianDay - 0.5;\n }\n \n /*\n  * Returns the Gregorian Date corresponding to a given Julian Day\n+ * Month is 0 based.\n  * @param jd The Julian Day\n  */\n static int32_t* jdToGregorian(double jd, int32_t gregorianDate[3]) {\n-   double wjd, depoch, quadricent, dqc, cent, dcent, quad, dquad, yindex, yearday, leapadj;\n-   int32_t year, month, day;\n-   wjd = uprv_floor(jd - 0.5) + 0.5;\n-   depoch = wjd - JULIAN_EPOCH;\n-   quadricent = uprv_floor(depoch / 146097);\n-   dqc = (int32_t)uprv_floor(depoch) % 146097;\n-   cent = uprv_floor(dqc / 36524);\n-   dcent = (int32_t)uprv_floor(dqc) % 36524;\n-   quad = uprv_floor(dcent / 1461);\n-   dquad = (int32_t)uprv_floor(dcent) % 1461;\n-   yindex = uprv_floor(dquad / 365);\n-   year = (int32_t)((quadricent * 400) + (cent * 100) + (quad * 4) + yindex);\n-   if (!((cent == 4) || (yindex == 4))) {\n-      year++;\n-   }\n-   yearday = wjd - gregorianToJD(year, 1, 1);\n-   leapadj = ((wjd < gregorianToJD(year, 3, 1)) ? 0\n-         :\n-         (isGregorianLeap(year) ? 1 : 2)\n-         );\n-   month = (int32_t)uprv_floor((((yearday + leapadj) * 12) + 373) / 367);\n-   day = (int32_t)(wjd - gregorianToJD(year, month, 1)) + 1;\n-\n-   gregorianDate[0] = year;\n-   gregorianDate[1] = month;\n-   gregorianDate[2] = day;\n-\n+   int32_t gdow;\n+   Grego::dayToFields(jd - kEpochStartAsJulianDay,\n+                      gregorianDate[0], gregorianDate[1], gregorianDate[2], gdow);\n    return gregorianDate;\n }\n \n@@ -203,11 +168,11 @@ static double IndianToJD(int32_t year, int32_t month, int32_t date) {\n \n    if(isGregorianLeap(gyear)) {\n       leapMonth = 31;\n-      start = gregorianToJD(gyear, 3, 21);\n+      start = gregorianToJD(gyear, 2 /* The third month in 0 based month */, 21);\n    }\n    else {\n       leapMonth = 30;\n-      start = gregorianToJD(gyear, 3, 22);\n+      start = gregorianToJD(gyear, 2 /* The third month in 0 based month */, 22);\n    }\n \n    if (month == 1) {\n@@ -243,7 +208,7 @@ int32_t IndianCalendar::handleComputeMonthStart(int32_t eyear, int32_t month, UB\n    //month is 0 based; converting it to 1-based\n    int32_t imonth;\n \n-    // If the month is out of range, adjust it into range, and adjust the extended eyar accordingly\n+    // If the month is out of range, adjust it into range, and adjust the extended year accordingly\n    if (month < 0 || month > 11) {\n       eyear += (int32_t)ClockMath::floorDivide(month, 12, month);\n    }\n@@ -297,7 +262,7 @@ void IndianCalendar::handleComputeFields(int32_t julianDay, UErrorCode&  /* stat\n \n     gregorianYear = jdToGregorian(julianDay, gd)[0];          // Gregorian date for Julian day\n     IndianYear = gregorianYear - INDIAN_ERA_START;            // Year in Saka era\n-    jdAtStartOfGregYear = gregorianToJD(gregorianYear, 1, 1); // JD at start of Gregorian year\n+    jdAtStartOfGregYear = gregorianToJD(gregorianYear, 0, 1); // JD at start of Gregorian year\n     yday = (int32_t)(julianDay - jdAtStartOfGregYear);        // Day number in Gregorian year (starting from 0)\n \n     if (yday < INDIAN_YEAR_START) {\ndiff --git a/extension/icu/third_party/icu/i18n/islamcal.cpp b/extension/icu/third_party/icu/i18n/islamcal.cpp\nindex 16e5e33622e8..40e99b96a8c6 100644\n--- a/extension/icu/third_party/icu/i18n/islamcal.cpp\n+++ b/extension/icu/third_party/icu/i18n/islamcal.cpp\n@@ -368,7 +368,7 @@ int32_t IslamicCalendar::yearStart(int32_t year) const{\n     if (cType == CIVIL || cType == TBLA ||\n         (cType == UMALQURA && (year < UMALQURA_YEAR_START || year > UMALQURA_YEAR_END)))\n     {\n-        return (year-1)*354 + ClockMath::floorDivide((3+11*year),30);\n+        return (year-1)*354 + ClockMath::floorDivide((3+11*(int64_t)year),(int64_t)30);\n     } else if(cType==ASTRONOMICAL){\n         return trueMonthStart(12*(year-1));\n     } else {\n@@ -391,7 +391,7 @@ int32_t IslamicCalendar::monthStart(int32_t year, int32_t month) const {\n     if (cType == CIVIL || cType == TBLA) {\n         // This does not handle months out of the range 0..11\n         return (int32_t)uprv_ceil(29.5*month)\n-            + (year-1)*354 + (int32_t)ClockMath::floorDivide((3+11*year),30);\n+            + (year-1)*354 + (int32_t)ClockMath::floorDivide((3+11*(int64_t)year),(int64_t)30);\n     } else if(cType==ASTRONOMICAL){\n         return trueMonthStart(12*(year-1) + month);\n     } else {\n@@ -447,7 +447,8 @@ int32_t IslamicCalendar::trueMonthStart(int32_t month) const\n                 }\n             } while (age < 0);\n         }\n-        start = (int32_t)ClockMath::floorDivide((origin - HIJRA_MILLIS), (double)kOneDay) + 1;\n+        start = (int32_t)(ClockMath::floorDivide(\n+            (int64_t)((int64_t)origin - HIJRA_MILLIS), (int64_t)kOneDay) + 1);\n         CalendarCache::put(&gMonthCache, month, start, status);\n     }\n trueMonthStartEnd :\n@@ -639,13 +640,14 @@ void IslamicCalendar::handleComputeFields(int32_t julianDay, UErrorCode &status)\n             months--;\n         }\n \n-        year = months / 12 + 1;\n-        month = months % 12;\n+        year = months >=  0 ? ((months / 12) + 1) : ((months + 1 ) / 12);\n+        month = ((months % 12) + 12 ) % 12;\n     } else if(cType == UMALQURA) {\n         int32_t umalquraStartdays = yearStart(UMALQURA_YEAR_START) ;\n         if( days < umalquraStartdays){\n                 //Use Civil calculation\n-                year  = (int)ClockMath::floorDivide( (double)(30 * days + 10646) , 10631.0 );\n+                year  = (int32_t)ClockMath::floorDivide(\n+                    (30 * (int64_t)days + 10646) , (int64_t)10631.0 );\n                 month = (int32_t)uprv_ceil((days - 29 - yearStart(year)) / 29.5 );\n                 month = month<11?month:11;\n                 startDate = monthStart(year, month);\ndiff --git a/scripts/format.py b/scripts/format.py\nindex 326fd1d4cfed..779f0cfa98ab 100644\n--- a/scripts/format.py\n+++ b/scripts/format.py\n@@ -26,7 +26,7 @@\n                        os.path.join('tools', 'pythonpkg', 'build'), os.path.join('tools', 'rpkg', 'src', 'duckdb'),\n                        os.path.join('tools', 'rpkg', 'inst', 'include', 'cpp11'),\n                        os.path.join('extension', 'tpcds', 'dsdgen'), os.path.join('extension', 'jemalloc', 'jemalloc'),\n-                       os.path.join('extension', 'json', 'yyjson')]\n+                       os.path.join('extension', 'json', 'yyjson'), os.path.join('extension', 'icu', 'third_party')]\n format_all = False\n check_only = True\n confirm = True\n",
  "test_patch": "diff --git a/test/sql/timezone/test_icu_calendar.test b/test/sql/timezone/test_icu_calendar.test\nindex 8f9a3cda037b..e635c7ebf4e2 100644\n--- a/test/sql/timezone/test_icu_calendar.test\n+++ b/test/sql/timezone/test_icu_calendar.test\n@@ -84,3 +84,31 @@ Showa\t1989-01-06 09:00:00+09\t{'era': 234, 'year': 64, 'month': 1, 'day': 6}\n Heisei\t1989-01-08 09:00:00+09\t{'era': 235, 'year': 1, 'month': 1, 'day': 8}\n Reiwa\t2019-05-01 09:00:00+09\t{'era': 236, 'year': 1, 'month': 5, 'day': 1}\n Reiwa\t2022-01-01 09:00:00+09\t{'era': 236, 'year': 4, 'month': 1, 'day': 1}\n+\n+# Issue #5234\n+statement ok\n+SET CALENDAR='islamic-umalqura';\n+\n+query I\n+SELECT strftime(TIMESTAMPTZ '-260722-3-4 0:3:52',TIMESTAMP '-285441-5-3 8:3:4');\n+----\n+285442-05-03 (BC) 08:03:04\n+\n+# Issue #5235\n+statement ok\n+SET CALENDAR='indian';\n+\n+query I\n+SELECT TIMESTAMPTZ '-276069-9-30 0:0:00 America/Whitehorse';\n+----\n+276070-10-01 (BC) 18:19:11+09:18\n+\n+# Issue #5237\n+statement ok\n+PRAGMA CALENDAR='japanese';\n+\n+query I\n+SELECT strftime(TIMESTAMPTZ '-23831-1-15 2:5:17 America/La_Paz',TIMETZ '0:8:29 America/Cayman');\n+----\n+00:08:29+00\n+\n",
  "problem_statement": "Fuzzer 54. Negative shift\n```sql\nPRAGMA CALENDAR='japanese';\nSELECT strftime(TIMESTAMPTZ '-23831-1-15 2:5:17 America/La_Paz',TIMETZ '0:8:29 America/Cayman');\n```\n",
  "hints_text": "",
  "created_at": "2022-11-10T17:18:52Z"
}