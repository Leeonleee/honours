{
  "repo": "duckdb/duckdb",
  "pull_number": 9028,
  "instance_id": "duckdb__duckdb-9028",
  "issue_numbers": [
    "7971"
  ],
  "base_commit": "463a5e51af1183b47deb3ee79e5977cc8227ca66",
  "patch": "diff --git a/src/include/duckdb/main/prepared_statement_data.hpp b/src/include/duckdb/main/prepared_statement_data.hpp\nindex eba4925e579e..ce0b7d1a1dd1 100644\n--- a/src/include/duckdb/main/prepared_statement_data.hpp\n+++ b/src/include/duckdb/main/prepared_statement_data.hpp\n@@ -14,6 +14,7 @@\n #include \"duckdb/common/unordered_set.hpp\"\n #include \"duckdb/common/winapi.hpp\"\n #include \"duckdb/planner/expression/bound_parameter_data.hpp\"\n+#include \"duckdb/planner/bound_parameter_map.hpp\"\n \n namespace duckdb {\n class CatalogEntry;\ndiff --git a/src/include/duckdb/planner/bound_parameter_map.hpp b/src/include/duckdb/planner/bound_parameter_map.hpp\nindex 5749b691a2da..ab5ef4108898 100644\n--- a/src/include/duckdb/planner/bound_parameter_map.hpp\n+++ b/src/include/duckdb/planner/bound_parameter_map.hpp\n@@ -10,12 +10,39 @@\n \n #include \"duckdb/common/types.hpp\"\n #include \"duckdb/common/unordered_map.hpp\"\n+#include \"duckdb/planner/expression/bound_parameter_data.hpp\"\n #include \"duckdb/common/case_insensitive_map.hpp\"\n \n namespace duckdb {\n \n-struct BoundParameterData;\n+class ParameterExpression;\n+class BoundParameterExpression;\n \n using bound_parameter_map_t = case_insensitive_map_t<shared_ptr<BoundParameterData>>;\n \n+struct BoundParameterMap {\n+public:\n+\texplicit BoundParameterMap(case_insensitive_map_t<BoundParameterData> &parameter_data);\n+\n+public:\n+\tLogicalType GetReturnType(const string &identifier);\n+\n+\tbound_parameter_map_t *GetParametersPtr();\n+\n+\tconst bound_parameter_map_t &GetParameters();\n+\n+\tconst case_insensitive_map_t<BoundParameterData> &GetParameterData();\n+\n+\tunique_ptr<BoundParameterExpression> BindParameterExpression(ParameterExpression &expr);\n+\n+private:\n+\tshared_ptr<BoundParameterData> CreateOrGetData(const string &identifier);\n+\tvoid CreateNewParameter(const string &id, const shared_ptr<BoundParameterData> &param_data);\n+\n+private:\n+\tbound_parameter_map_t parameters;\n+\t// Pre-provided parameter data if populated\n+\tcase_insensitive_map_t<BoundParameterData> &parameter_data;\n+};\n+\n } // namespace duckdb\ndiff --git a/src/include/duckdb/planner/expression/bound_parameter_data.hpp b/src/include/duckdb/planner/expression/bound_parameter_data.hpp\nindex a5477bacca47..b1cac717d514 100644\n--- a/src/include/duckdb/planner/expression/bound_parameter_data.hpp\n+++ b/src/include/duckdb/planner/expression/bound_parameter_data.hpp\n@@ -9,7 +9,6 @@\n #pragma once\n \n #include \"duckdb/common/types/value.hpp\"\n-#include \"duckdb/planner/bound_parameter_map.hpp\"\n #include \"duckdb/common/case_insensitive_map.hpp\"\n \n namespace duckdb {\n@@ -40,21 +39,4 @@ struct BoundParameterData {\n \tstatic shared_ptr<BoundParameterData> Deserialize(Deserializer &deserializer);\n };\n \n-struct BoundParameterMap {\n-\texplicit BoundParameterMap(case_insensitive_map_t<BoundParameterData> &parameter_data)\n-\t    : parameter_data(parameter_data) {\n-\t}\n-\n-\tbound_parameter_map_t parameters;\n-\tcase_insensitive_map_t<BoundParameterData> &parameter_data;\n-\n-\tLogicalType GetReturnType(const string &identifier) {\n-\t\tauto it = parameter_data.find(identifier);\n-\t\tif (it == parameter_data.end()) {\n-\t\t\treturn LogicalTypeId::UNKNOWN;\n-\t\t}\n-\t\treturn it->second.return_type;\n-\t}\n-};\n-\n } // namespace duckdb\ndiff --git a/src/include/duckdb/planner/expression/bound_parameter_expression.hpp b/src/include/duckdb/planner/expression/bound_parameter_expression.hpp\nindex 63b59153f313..77bfa03d6e6e 100644\n--- a/src/include/duckdb/planner/expression/bound_parameter_expression.hpp\n+++ b/src/include/duckdb/planner/expression/bound_parameter_expression.hpp\n@@ -9,7 +9,7 @@\n #pragma once\n \n #include \"duckdb/planner/expression.hpp\"\n-#include \"duckdb/planner/expression/bound_parameter_data.hpp\"\n+#include \"duckdb/planner/bound_parameter_map.hpp\"\n \n namespace duckdb {\n \ndiff --git a/src/include/duckdb/planner/planner.hpp b/src/include/duckdb/planner/planner.hpp\nindex cc9382f43ddf..98556783915f 100644\n--- a/src/include/duckdb/planner/planner.hpp\n+++ b/src/include/duckdb/planner/planner.hpp\n@@ -11,7 +11,7 @@\n #include \"duckdb/parser/sql_statement.hpp\"\n #include \"duckdb/planner/binder.hpp\"\n #include \"duckdb/planner/logical_operator.hpp\"\n-#include \"duckdb/planner/expression/bound_parameter_data.hpp\"\n+#include \"duckdb/planner/bound_parameter_map.hpp\"\n \n namespace duckdb {\n class ClientContext;\ndiff --git a/src/main/capi/prepared-c.cpp b/src/main/capi/prepared-c.cpp\nindex 8a7a6c5f3063..82b488b7a2d2 100644\n--- a/src/main/capi/prepared-c.cpp\n+++ b/src/main/capi/prepared-c.cpp\n@@ -124,10 +124,16 @@ duckdb_type duckdb_param_type(duckdb_prepared_statement prepared_statement, idx_\n \t}\n \tLogicalType param_type;\n \tauto identifier = std::to_string(param_idx);\n-\tif (!wrapper->statement->data->TryGetType(identifier, param_type)) {\n-\t\treturn DUCKDB_TYPE_INVALID;\n+\tif (wrapper->statement->data->TryGetType(identifier, param_type)) {\n+\t\treturn ConvertCPPTypeToC(param_type);\n+\t}\n+\t// The value_map is gone after executing the prepared statement\n+\t// See if this is the case and we still have a value registered for it\n+\tauto it = wrapper->values.find(identifier);\n+\tif (it != wrapper->values.end()) {\n+\t\treturn ConvertCPPTypeToC(it->second.type());\n \t}\n-\treturn ConvertCPPTypeToC(param_type);\n+\treturn DUCKDB_TYPE_INVALID;\n }\n \n duckdb_state duckdb_clear_bindings(duckdb_prepared_statement prepared_statement) {\ndiff --git a/src/planner/CMakeLists.txt b/src/planner/CMakeLists.txt\nindex 5b2646acf4b7..19f4c28a0758 100644\n--- a/src/planner/CMakeLists.txt\n+++ b/src/planner/CMakeLists.txt\n@@ -9,6 +9,7 @@ add_library_unity(\n   duckdb_planner\n   OBJECT\n   bound_result_modifier.cpp\n+  bound_parameter_map.cpp\n   expression_iterator.cpp\n   expression.cpp\n   table_binding.cpp\ndiff --git a/src/planner/binder/expression/bind_parameter_expression.cpp b/src/planner/binder/expression/bind_parameter_expression.cpp\nindex c5041416a5ec..d46cf0235f3a 100644\n--- a/src/planner/binder/expression/bind_parameter_expression.cpp\n+++ b/src/planner/binder/expression/bind_parameter_expression.cpp\n@@ -7,35 +7,25 @@\n namespace duckdb {\n \n BindResult ExpressionBinder::BindExpression(ParameterExpression &expr, idx_t depth) {\n-\tauto bound_parameter = make_uniq<BoundParameterExpression>(expr.identifier);\n-\tbound_parameter->alias = expr.alias;\n \tif (!binder.parameters) {\n \t\tthrow BinderException(\"Unexpected prepared parameter. This type of statement can't be prepared!\");\n \t}\n \tauto parameter_id = expr.identifier;\n-\t// check if a parameter value has already been supplied\n-\tif (binder.parameters->parameter_data.count(parameter_id)) {\n+\n+\tD_ASSERT(binder.parameters);\n+\t// Check if a parameter value has already been supplied\n+\tauto &parameter_data = binder.parameters->GetParameterData();\n+\tauto param_data_it = parameter_data.find(parameter_id);\n+\tif (param_data_it != parameter_data.end()) {\n \t\t// it has! emit a constant directly\n-\t\tauto &data = binder.parameters->parameter_data[parameter_id];\n+\t\tauto &data = param_data_it->second;\n \t\tauto constant = make_uniq<BoundConstantExpression>(data.GetValue());\n \t\tconstant->alias = expr.alias;\n+\t\tconstant->return_type = binder.parameters->GetReturnType(parameter_id);\n \t\treturn BindResult(std::move(constant));\n \t}\n \n-\tauto entry = binder.parameters->parameters.find(parameter_id);\n-\tif (entry == binder.parameters->parameters.end()) {\n-\t\t// no entry yet: create a new one\n-\t\tauto data = make_shared<BoundParameterData>();\n-\t\tdata->return_type = binder.parameters->GetReturnType(parameter_id);\n-\t\tbound_parameter->return_type = data->return_type;\n-\t\tbound_parameter->parameter_data = data;\n-\t\tbinder.parameters->parameters[parameter_id] = std::move(data);\n-\t} else {\n-\t\t// a prepared statement with this parameter index was already there: use it\n-\t\tauto &data = entry->second;\n-\t\tbound_parameter->parameter_data = data;\n-\t\tbound_parameter->return_type = binder.parameters->GetReturnType(parameter_id);\n-\t}\n+\tauto bound_parameter = binder.parameters->BindParameterExpression(expr);\n \treturn BindResult(std::move(bound_parameter));\n }\n \ndiff --git a/src/planner/bound_parameter_map.cpp b/src/planner/bound_parameter_map.cpp\nnew file mode 100644\nindex 000000000000..cd55830a0dfa\n--- /dev/null\n+++ b/src/planner/bound_parameter_map.cpp\n@@ -0,0 +1,67 @@\n+#include \"duckdb/planner/bound_parameter_map.hpp\"\n+#include \"duckdb/parser/expression/parameter_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_parameter_expression.hpp\"\n+\n+namespace duckdb {\n+\n+BoundParameterMap::BoundParameterMap(case_insensitive_map_t<BoundParameterData> &parameter_data)\n+    : parameter_data(parameter_data) {\n+}\n+\n+LogicalType BoundParameterMap::GetReturnType(const string &identifier) {\n+\tD_ASSERT(!identifier.empty());\n+\tauto it = parameter_data.find(identifier);\n+\tif (it == parameter_data.end()) {\n+\t\treturn LogicalTypeId::UNKNOWN;\n+\t}\n+\treturn it->second.return_type;\n+}\n+\n+bound_parameter_map_t *BoundParameterMap::GetParametersPtr() {\n+\treturn &parameters;\n+}\n+\n+const bound_parameter_map_t &BoundParameterMap::GetParameters() {\n+\treturn parameters;\n+}\n+\n+const case_insensitive_map_t<BoundParameterData> &BoundParameterMap::GetParameterData() {\n+\treturn parameter_data;\n+}\n+\n+shared_ptr<BoundParameterData> BoundParameterMap::CreateOrGetData(const string &identifier) {\n+\tauto entry = parameters.find(identifier);\n+\tif (entry == parameters.end()) {\n+\t\t// no entry yet: create a new one\n+\t\tauto data = make_shared<BoundParameterData>();\n+\t\tdata->return_type = GetReturnType(identifier);\n+\n+\t\tCreateNewParameter(identifier, data);\n+\t\treturn data;\n+\t}\n+\treturn entry->second;\n+}\n+\n+unique_ptr<BoundParameterExpression> BoundParameterMap::BindParameterExpression(ParameterExpression &expr) {\n+\tauto &identifier = expr.identifier;\n+\tauto return_type = GetReturnType(identifier);\n+\n+\tD_ASSERT(!parameter_data.count(identifier));\n+\n+\t// No value has been supplied yet,\n+\t// We return a shared pointer to an object that will get populated wtih a Value later\n+\t// When the BoundParameterExpression get executed, this will be used to get the corresponding value\n+\tauto param_data = CreateOrGetData(identifier);\n+\tauto bound_expr = make_uniq<BoundParameterExpression>(identifier);\n+\tbound_expr->parameter_data = param_data;\n+\tbound_expr->return_type = return_type;\n+\tbound_expr->alias = expr.alias;\n+\treturn bound_expr;\n+}\n+\n+void BoundParameterMap::CreateNewParameter(const string &id, const shared_ptr<BoundParameterData> &param_data) {\n+\tD_ASSERT(!parameters.count(id));\n+\tparameters.emplace(std::make_pair(id, param_data));\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/planner/planner.cpp b/src/planner/planner.cpp\nindex 6a648460e393..369e400f55bc 100644\n--- a/src/planner/planner.cpp\n+++ b/src/planner/planner.cpp\n@@ -78,10 +78,10 @@ void Planner::CreatePlan(SQLStatement &statement) {\n \tthis->properties.parameter_count = parameter_count;\n \tproperties.bound_all_parameters = parameters_resolved;\n \n-\tPlanner::VerifyPlan(context, plan, &bound_parameters.parameters);\n+\tPlanner::VerifyPlan(context, plan, bound_parameters.GetParametersPtr());\n \n \t// set up a map of parameter number -> value entries\n-\tfor (auto &kv : bound_parameters.parameters) {\n+\tfor (auto &kv : bound_parameters.GetParameters()) {\n \t\tauto &identifier = kv.first;\n \t\tauto &param = kv.second;\n \t\t// check if the type of the parameter could be resolved\n",
  "test_patch": "diff --git a/test/api/capi/test_capi_prepared.cpp b/test/api/capi/test_capi_prepared.cpp\nindex 077295c2476a..ae8ac4bca566 100644\n--- a/test/api/capi/test_capi_prepared.cpp\n+++ b/test/api/capi/test_capi_prepared.cpp\n@@ -281,6 +281,30 @@ TEST_CASE(\"Test prepared statements in C API\", \"[capi]\") {\n \tduckdb_destroy_prepare(&stmt);\n }\n \n+TEST_CASE(\"Test duckdb_param_type\", \"[capi]\") {\n+\tduckdb_database db;\n+\tduckdb_connection conn;\n+\tduckdb_prepared_statement stmt;\n+\n+\tREQUIRE(duckdb_open(\"\", &db) == DuckDBSuccess);\n+\tREQUIRE(duckdb_connect(db, &conn) == DuckDBSuccess);\n+\tREQUIRE(duckdb_prepare(conn, \"select $1::integer, $2::integer\", &stmt) == DuckDBSuccess);\n+\n+\tREQUIRE(duckdb_param_type(stmt, 2) == DUCKDB_TYPE_INTEGER);\n+\tREQUIRE(duckdb_bind_null(stmt, 1) == DuckDBSuccess);\n+\tREQUIRE(duckdb_bind_int32(stmt, 2, 10) == DuckDBSuccess);\n+\n+\tduckdb_result result;\n+\tREQUIRE(duckdb_execute_prepared(stmt, &result) == DuckDBSuccess);\n+\tREQUIRE(duckdb_param_type(stmt, 2) == DUCKDB_TYPE_INTEGER);\n+\tduckdb_clear_bindings(stmt);\n+\tduckdb_destroy_result(&result);\n+\n+\tduckdb_destroy_prepare(&stmt);\n+\tduckdb_disconnect(&conn);\n+\tduckdb_close(&db);\n+}\n+\n TEST_CASE(\"Test prepared statements with named parameters in C API\", \"[capi]\") {\n \tCAPITester tester;\n \tduckdb::unique_ptr<CAPIResult> result;\n",
  "problem_statement": "duckdb_param_type returns 0\n### What happens?\r\n\r\nThere are cases where the C API's duckdb_param_type will return the correct value and subsequent calls will return 0.\r\n\r\n### To Reproduce\r\n\r\nI believe that binding the parameter to `null` is the key to causing this to fail.\r\n\r\n```C\r\n#include <stdio.h>\r\n#include \"duckdb.h\"\r\n\r\nint main() {\r\n  duckdb_database db;\r\n  duckdb_connection conn;\r\n  duckdb_prepared_statement stmt;\r\n\r\n  if (duckdb_open(\"/tmp/test.duckdb\", &db) == DuckDBError) exit(1);\r\n  if (duckdb_connect(db, &conn) == DuckDBError) exit(2);\r\n  if (duckdb_prepare(conn, \"select $1::integer, $2::integer\", &stmt) == DuckDBError) exit(3);\r\n\r\n  printf(\"Parameter type = %d  (should be 4)\\n\", duckdb_param_type(stmt, 2));\r\n  if (duckdb_bind_null(stmt, 1) == DuckDBError) exit(5);\r\n  if (duckdb_bind_int32(stmt, 2, 10) == DuckDBError) exit(6);\r\n\r\n  duckdb_result result;\r\n  if (duckdb_execute_prepared(stmt, &result) == DuckDBError) {\r\n    exit(10);\r\n  }\r\n  duckdb_destroy_result(&result);\r\n  duckdb_clear_bindings(stmt);\r\n  printf(\"Parameter type = %d  (should be 4)\\n\", duckdb_param_type(stmt, 2));\r\n\r\n\r\n  duckdb_destroy_prepare(&stmt);\r\n  duckdb_disconnect(&conn);\r\n  duckdb_close(&db);\r\n}\r\n```\r\n\r\n### OS:\r\n\r\naarch64\r\n\r\n### DuckDB Version:\r\n\r\n0.8.1\r\n\r\n### DuckDB Client:\r\n\r\nn/a\r\n\r\n### Full Name:\r\n\r\nKarl Seguin\r\n\r\n### Affiliation:\r\n\r\nNone\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [x] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "It likely moves the internal bound parameter out of the statement object\nThis issue is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.\nProblem is still happening on master.",
  "created_at": "2023-09-21T12:43:32Z"
}