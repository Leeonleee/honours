{
  "repo": "duckdb/duckdb",
  "pull_number": 3472,
  "instance_id": "duckdb__duckdb-3472",
  "issue_numbers": [
    "3471",
    "3471"
  ],
  "base_commit": "f63df22eb8e75f682a6a05bf53627a5ad38c8398",
  "patch": "diff --git a/src/function/scalar/operators/subtract.cpp b/src/function/scalar/operators/subtract.cpp\nindex 601f95fb3878..2c395097f504 100644\n--- a/src/function/scalar/operators/subtract.cpp\n+++ b/src/function/scalar/operators/subtract.cpp\n@@ -158,6 +158,12 @@ bool TrySubtractOperator::Operation(int64_t left, int64_t right, int64_t &result\n \treturn true;\n }\n \n+template <>\n+bool TrySubtractOperator::Operation(hugeint_t left, hugeint_t right, hugeint_t &result) {\n+\tresult = left;\n+\treturn Hugeint::SubtractInPlace(result, right);\n+}\n+\n //===--------------------------------------------------------------------===//\n // subtract decimal with overflow check\n //===--------------------------------------------------------------------===//\ndiff --git a/src/include/duckdb/common/operator/subtract.hpp b/src/include/duckdb/common/operator/subtract.hpp\nindex 5792c5219fcf..2d22588a8bae 100644\n--- a/src/include/duckdb/common/operator/subtract.hpp\n+++ b/src/include/duckdb/common/operator/subtract.hpp\n@@ -61,6 +61,8 @@ template <>\n bool TrySubtractOperator::Operation(int32_t left, int32_t right, int32_t &result);\n template <>\n bool TrySubtractOperator::Operation(int64_t left, int64_t right, int64_t &result);\n+template <>\n+bool TrySubtractOperator::Operation(hugeint_t left, hugeint_t right, hugeint_t &result);\n \n struct SubtractOperatorOverflowCheck {\n \ttemplate <class TA, class TB, class TR>\ndiff --git a/src/optimizer/statistics/expression/propagate_and_compress.cpp b/src/optimizer/statistics/expression/propagate_and_compress.cpp\nindex 3f309b16d5fe..8b0af9ab9a5f 100644\n--- a/src/optimizer/statistics/expression/propagate_and_compress.cpp\n+++ b/src/optimizer/statistics/expression/propagate_and_compress.cpp\n@@ -10,28 +10,25 @@\n \n namespace duckdb {\n \n-unique_ptr<Expression> CastHugeintToSmallestType(unique_ptr<Expression> expr, NumericStatistics &num_stats) {\n-\t// Compute range\n-\tif (num_stats.min.IsNull() || num_stats.max.IsNull()) {\n-\t\treturn expr;\n-\t}\n-\n-\tauto min_val = num_stats.min.GetValue<hugeint_t>();\n-\tauto max_val = num_stats.max.GetValue<hugeint_t>();\n-\tif (max_val < min_val) {\n-\t\treturn expr;\n-\t}\n+template <class T>\n+bool GetCastType(T signed_range, LogicalType &cast_type) {\n+\tauto range = static_cast<typename std::make_unsigned<decltype(signed_range)>::type>(signed_range);\n \n-\t// Prevent overflow\n-\tif (min_val < NumericLimits<int64_t>().Minimum() && max_val > NumericLimits<int64_t>().Maximum()) {\n-\t\treturn expr;\n+\t// Check if this range fits in a smaller type\n+\tif (range < NumericLimits<uint8_t>::Maximum()) {\n+\t\tcast_type = LogicalType::UTINYINT;\n+\t} else if (sizeof(T) > sizeof(uint16_t) && range < NumericLimits<uint16_t>::Maximum()) {\n+\t\tcast_type = LogicalType::USMALLINT;\n+\t} else if (sizeof(T) > sizeof(uint32_t) && range < NumericLimits<uint32_t>::Maximum()) {\n+\t\tcast_type = LogicalType::UINTEGER;\n+\t} else {\n+\t\treturn false;\n \t}\n+\treturn true;\n+}\n \n-\t// Compute range\n-\tauto range = max_val - min_val;\n-\n-\t// Check if this range fits in a smaller type\n-\tLogicalType cast_type;\n+template <>\n+bool GetCastType(hugeint_t range, LogicalType &cast_type) {\n \tif (range < NumericLimits<uint8_t>().Maximum()) {\n \t\tcast_type = LogicalType::UTINYINT;\n \t} else if (range < NumericLimits<uint16_t>().Maximum()) {\n@@ -39,22 +36,11 @@ unique_ptr<Expression> CastHugeintToSmallestType(unique_ptr<Expression> expr, Nu\n \t} else if (range < NumericLimits<uint32_t>().Maximum()) {\n \t\tcast_type = LogicalType::UINTEGER;\n \t} else if (range < NumericLimits<uint64_t>().Maximum()) {\n-\t\tcast_type = LogicalTypeId::UBIGINT;\n+\t\tcast_type = LogicalType::UBIGINT;\n \t} else {\n-\t\treturn expr;\n+\t\treturn false;\n \t}\n-\n-\t// Create expression to map to a smaller range\n-\tauto input_type = expr->return_type;\n-\tauto minimum_expr = make_unique<BoundConstantExpression>(Value::CreateValue(min_val));\n-\tvector<unique_ptr<Expression>> arguments;\n-\targuments.push_back(move(expr));\n-\targuments.push_back(move(minimum_expr));\n-\tauto minus_expr = make_unique<BoundFunctionExpression>(input_type, SubtractFun::GetFunction(input_type, input_type),\n-\t                                                       move(arguments), nullptr, true);\n-\n-\t// Cast to smaller type\n-\treturn make_unique<BoundCastExpression>(move(minus_expr), cast_type);\n+\treturn true;\n }\n \n template <class T>\n@@ -72,21 +58,14 @@ unique_ptr<Expression> TemplatedCastToSmallestType(unique_ptr<Expression> expr,\n \n \t// Compute range, cast to unsigned to prevent comparing signed with unsigned\n \tT signed_range;\n-\tif (!TrySubtractOperator::Operation(signed_min_val, signed_max_val, signed_range)) {\n+\tif (!TrySubtractOperator::Operation(signed_max_val, signed_min_val, signed_range)) {\n \t\t// overflow in subtraction: cannot do any simplification\n \t\treturn expr;\n \t}\n-\tauto range = static_cast<typename std::make_unsigned<decltype(signed_range)>::type>(signed_range);\n \n \t// Check if this range fits in a smaller type\n \tLogicalType cast_type;\n-\tif (range < NumericLimits<uint8_t>::Maximum()) {\n-\t\tcast_type = LogicalType::UTINYINT;\n-\t} else if (sizeof(T) > sizeof(uint16_t) && range < NumericLimits<uint16_t>::Maximum()) {\n-\t\tcast_type = LogicalType::USMALLINT;\n-\t} else if (sizeof(T) > sizeof(uint32_t) && range < NumericLimits<uint32_t>::Maximum()) {\n-\t\tcast_type = LogicalType::UINTEGER;\n-\t} else {\n+\tif (!GetCastType(signed_range, cast_type)) {\n \t\treturn expr;\n \t}\n \n@@ -122,7 +101,7 @@ unique_ptr<Expression> CastToSmallestType(unique_ptr<Expression> expr, NumericSt\n \tcase PhysicalType::INT64:\n \t\treturn TemplatedCastToSmallestType<int64_t>(move(expr), num_stats);\n \tcase PhysicalType::INT128:\n-\t\treturn CastHugeintToSmallestType(move(expr), num_stats);\n+\t\treturn TemplatedCastToSmallestType<hugeint_t>(move(expr), num_stats);\n \tdefault:\n \t\tthrow NotImplementedException(\"Unknown integer type!\");\n \t}\n",
  "test_patch": "diff --git a/test/sql/order/hugeint_order_by_extremes.test b/test/sql/order/hugeint_order_by_extremes.test\nnew file mode 100644\nindex 000000000000..8d207cd5a5c5\n--- /dev/null\n+++ b/test/sql/order/hugeint_order_by_extremes.test\n@@ -0,0 +1,32 @@\n+# name: test/sql/order/hugeint_order_by_extremes.test\n+# description: Issue #3471: Select fails when ordering on hugeint column\n+# group: [order]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE test (a hugeint);\n+\n+statement ok\n+INSERT INTO test values (-170141183460469231731687303715884105727::hugeint), (-1111::hugeint), (-1::hugeint), (0::hugeint), (1::hugeint), (1111::hugeint);\n+\n+query I\n+SELECT * FROM test order by a;\n+----\n+-170141183460469231731687303715884105727\n+-1111\n+-1\n+0\n+1\n+1111\n+\n+query I\n+SELECT * FROM test order by a DESC;\n+----\n+1111\n+1\n+0\n+-1\n+-1111\n+-170141183460469231731687303715884105727\n",
  "problem_statement": "Select fails when ordering on hugeint column\n#### What happens?\r\n\r\nWhen you select on a table with a hugeint column it can fail when there is a minimal hugeint in it and you are ordering on that column.\r\n\r\n#### To Reproduce\r\nSteps to reproduce the behavior. Bonus points if those are only SQL queries.\r\n\r\n```c\r\nstatic void\r\nhugeint_test() {\r\n    duckdb_database db;\r\n    duckdb_connection con;\r\n    duckdb_result result;\r\n\r\n    printf(\"hugeint test\\n\");\r\n\r\n    if (duckdb_open(NULL, &db) == DuckDBError) {\r\n        printf(\"duckdb_open error\\n\");\r\n        return;\r\n    }\r\n\r\n    if (duckdb_connect(db, &con) == DuckDBError) {\r\n        printf(\"duckdb_connect error\\n\");\r\n        return;\r\n    }\r\n    \r\n    if(duckdb_query(con, \"CREATE TABLE test (a hugeint)\", &result) == DuckDBError) {\r\n        printf(\"ERROR: %s\\n\\r\", duckdb_result_error(&result));\r\n    }\r\n    duckdb_destroy_result(&result);\r\n\r\n\r\n    if(duckdb_query(con, \"INSERT INTO test values (-170141183460469231731687303715884105727::hugeint), (-1111::hugeint), (-1::hugeint), (0::hugeint), (1::hugeint), (1111::hugeint)\", &result) == DuckDBError) {\r\n        printf(\"INSERT ERROR: %s\\n\\r\", duckdb_result_error(&result));\r\n    }\r\n    duckdb_destroy_result(&result);\r\n\r\n    if(duckdb_query(con, \"SELECT * FROM test order by a\", &result) == DuckDBError) {\r\n        printf(\"SELECT ERROR: %s\\n\\r\", duckdb_result_error(&result));\r\n    } else {\r\n        printf(\"select * test table works\\n\\r\");\r\n    }\r\n    duckdb_destroy_result(&result);\r\n\r\n\r\n    return;\r\n}\r\n\r\n```\r\n\r\nOutput:\r\n\r\n```\r\nhugeint test\r\nSELECT ERROR: Out of Range Error: Underflow in HUGEINT addition\r\n```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: [macOS]\r\n - DuckDB Version: [v0.3.3]\r\n - DuckDB Client: [C] \r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\nmpile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\nSelect fails when ordering on hugeint column\n#### What happens?\r\n\r\nWhen you select on a table with a hugeint column it can fail when there is a minimal hugeint in it and you are ordering on that column.\r\n\r\n#### To Reproduce\r\nSteps to reproduce the behavior. Bonus points if those are only SQL queries.\r\n\r\n```c\r\nstatic void\r\nhugeint_test() {\r\n    duckdb_database db;\r\n    duckdb_connection con;\r\n    duckdb_result result;\r\n\r\n    printf(\"hugeint test\\n\");\r\n\r\n    if (duckdb_open(NULL, &db) == DuckDBError) {\r\n        printf(\"duckdb_open error\\n\");\r\n        return;\r\n    }\r\n\r\n    if (duckdb_connect(db, &con) == DuckDBError) {\r\n        printf(\"duckdb_connect error\\n\");\r\n        return;\r\n    }\r\n    \r\n    if(duckdb_query(con, \"CREATE TABLE test (a hugeint)\", &result) == DuckDBError) {\r\n        printf(\"ERROR: %s\\n\\r\", duckdb_result_error(&result));\r\n    }\r\n    duckdb_destroy_result(&result);\r\n\r\n\r\n    if(duckdb_query(con, \"INSERT INTO test values (-170141183460469231731687303715884105727::hugeint), (-1111::hugeint), (-1::hugeint), (0::hugeint), (1::hugeint), (1111::hugeint)\", &result) == DuckDBError) {\r\n        printf(\"INSERT ERROR: %s\\n\\r\", duckdb_result_error(&result));\r\n    }\r\n    duckdb_destroy_result(&result);\r\n\r\n    if(duckdb_query(con, \"SELECT * FROM test order by a\", &result) == DuckDBError) {\r\n        printf(\"SELECT ERROR: %s\\n\\r\", duckdb_result_error(&result));\r\n    } else {\r\n        printf(\"select * test table works\\n\\r\");\r\n    }\r\n    duckdb_destroy_result(&result);\r\n\r\n\r\n    return;\r\n}\r\n\r\n```\r\n\r\nOutput:\r\n\r\n```\r\nhugeint test\r\nSELECT ERROR: Out of Range Error: Underflow in HUGEINT addition\r\n```\r\n\r\n#### Environment (please complete the following information):\r\n - OS: [macOS]\r\n - DuckDB Version: [v0.3.3]\r\n - DuckDB Client: [C] \r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\nmpile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "\n",
  "created_at": "2022-04-21T09:41:13Z"
}