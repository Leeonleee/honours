You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Select fails when ordering on hugeint column
#### What happens?

When you select on a table with a hugeint column it can fail when there is a minimal hugeint in it and you are ordering on that column.

#### To Reproduce
Steps to reproduce the behavior. Bonus points if those are only SQL queries.

```c
static void
hugeint_test() {
    duckdb_database db;
    duckdb_connection con;
    duckdb_result result;

    printf("hugeint test\n");

    if (duckdb_open(NULL, &db) == DuckDBError) {
        printf("duckdb_open error\n");
        return;
    }

    if (duckdb_connect(db, &con) == DuckDBError) {
        printf("duckdb_connect error\n");
        return;
    }
    
    if(duckdb_query(con, "CREATE TABLE test (a hugeint)", &result) == DuckDBError) {
        printf("ERROR: %s\n\r", duckdb_result_error(&result));
    }
    duckdb_destroy_result(&result);


    if(duckdb_query(con, "INSERT INTO test values (-170141183460469231731687303715884105727::hugeint), (-1111::hugeint), (-1::hugeint), (0::hugeint), (1::hugeint), (1111::hugeint)", &result) == DuckDBError) {
        printf("INSERT ERROR: %s\n\r", duckdb_result_error(&result));
    }
    duckdb_destroy_result(&result);

    if(duckdb_query(con, "SELECT * FROM test order by a", &result) == DuckDBError) {
        printf("SELECT ERROR: %s\n\r", duckdb_result_error(&result));
    } else {
        printf("select * test table works\n\r");
    }
    duckdb_destroy_result(&result);


    return;
}

```

Output:

```
hugeint test
SELECT ERROR: Out of Range Error: Underflow in HUGEINT addition
```

#### Environment (please complete the following information):
 - OS: [macOS]
 - DuckDB Version: [v0.3.3]
 - DuckDB Client: [C] 

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
mpile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**

Select fails when ordering on hugeint column
#### What happens?

When you select on a table with a hugeint column it can fail when there is a minimal hugeint in it and you are ordering on that column.

#### To Reproduce
Steps to reproduce the behavior. Bonus points if those are only SQL queries.

```c
static void
hugeint_test() {
    duckdb_database db;
    duckdb_connection con;
    duckdb_result result;

    printf("hugeint test\n");

    if (duckdb_open(NULL, &db) == DuckDBError) {
        printf("duckdb_open error\n");
        return;
    }

    if (duckdb_connect(db, &con) == DuckDBError) {
        printf("duckdb_connect error\n");
        return;
    }
    
    if(duckdb_query(con, "CREATE TABLE test (a hugeint)", &result) == DuckDBError) {
        printf("ERROR: %s\n\r", duckdb_result_error(&result));
    }
    duckdb_destroy_result(&result);


    if(duckdb_query(con, "INSERT INTO test values (-170141183460469231731687303715884105727::hugeint), (-1111::hugeint), (-1::hugeint), (0::hugeint), (1::hugeint), (1111::hugeint)", &result) == DuckDBError) {
        printf("INSERT ERROR: %s\n\r", duckdb_result_error(&result));
    }
    duckdb_destroy_result(&result);

    if(duckdb_query(con, "SELECT * FROM test order by a", &result) == DuckDBError) {
        printf("SELECT ERROR: %s\n\r", duckdb_result_error(&result));
    } else {
        printf("select * test table works\n\r");
    }
    duckdb_destroy_result(&result);


    return;
}

```

Output:

```
hugeint test
SELECT ERROR: Out of Range Error: Underflow in HUGEINT addition
```

#### Environment (please complete the following information):
 - OS: [macOS]
 - DuckDB Version: [v0.3.3]
 - DuckDB Client: [C] 

#### Before Submitting

- [x] **Have you tried this on the latest `master` branch?**
mpile from source.

- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**


</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/cwida/duckdb/workflows/.github/workflows/main.yml/badge.svg?branch=master" alt=".github/workflows/main.yml">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`.
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of src/function/scalar/operators/subtract.cpp]
1: #include "duckdb/common/operator/subtract.hpp"
2: 
3: #include "duckdb/common/limits.hpp"
4: #include "duckdb/common/operator/add.hpp"
5: #include "duckdb/common/types/hugeint.hpp"
6: #include "duckdb/common/types/interval.hpp"
7: #include "duckdb/common/types/value.hpp"
8: 
9: #include <limits>
10: 
11: namespace duckdb {
12: 
13: //===--------------------------------------------------------------------===//
14: // - [subtract]
15: //===--------------------------------------------------------------------===//
16: template <>
17: float SubtractOperator::Operation(float left, float right) {
18: 	auto result = left - right;
19: 	if (!Value::FloatIsFinite(result)) {
20: 		throw OutOfRangeException("Overflow in subtraction of float!");
21: 	}
22: 	return result;
23: }
24: 
25: template <>
26: double SubtractOperator::Operation(double left, double right) {
27: 	auto result = left - right;
28: 	if (!Value::DoubleIsFinite(result)) {
29: 		throw OutOfRangeException("Overflow in subtraction of double!");
30: 	}
31: 	return result;
32: }
33: 
34: template <>
35: int64_t SubtractOperator::Operation(date_t left, date_t right) {
36: 	return int64_t(left.days) - int64_t(right.days);
37: }
38: 
39: template <>
40: date_t SubtractOperator::Operation(date_t left, int32_t right) {
41: 	int32_t result;
42: 	if (!TrySubtractOperator::Operation(left.days, right, result)) {
43: 		throw OutOfRangeException("Date out of range");
44: 	}
45: 	return date_t(result);
46: }
47: 
48: template <>
49: interval_t SubtractOperator::Operation(interval_t left, interval_t right) {
50: 	interval_t result;
51: 	result.months = left.months - right.months;
52: 	result.days = left.days - right.days;
53: 	result.micros = left.micros - right.micros;
54: 	return result;
55: }
56: 
57: template <>
58: date_t SubtractOperator::Operation(date_t left, interval_t right) {
59: 	right.months = -right.months;
60: 	right.days = -right.days;
61: 	right.micros = -right.micros;
62: 	return AddOperator::Operation<date_t, interval_t, date_t>(left, right);
63: }
64: 
65: template <>
66: timestamp_t SubtractOperator::Operation(timestamp_t left, interval_t right) {
67: 	right.months = -right.months;
68: 	right.days = -right.days;
69: 	right.micros = -right.micros;
70: 	return AddOperator::Operation<timestamp_t, interval_t, timestamp_t>(left, right);
71: }
72: 
73: template <>
74: interval_t SubtractOperator::Operation(timestamp_t left, timestamp_t right) {
75: 	return Interval::GetDifference(left, right);
76: }
77: 
78: //===--------------------------------------------------------------------===//
79: // - [subtract] with overflow check
80: //===--------------------------------------------------------------------===//
81: struct OverflowCheckedSubtract {
82: 	template <class SRCTYPE, class UTYPE>
83: 	static inline bool Operation(SRCTYPE left, SRCTYPE right, SRCTYPE &result) {
84: 		UTYPE uresult = SubtractOperator::Operation<UTYPE, UTYPE, UTYPE>(UTYPE(left), UTYPE(right));
85: 		if (uresult < NumericLimits<SRCTYPE>::Minimum() || uresult > NumericLimits<SRCTYPE>::Maximum()) {
86: 			return false;
87: 		}
88: 		result = SRCTYPE(uresult);
89: 		return true;
90: 	}
91: };
92: 
93: template <>
94: bool TrySubtractOperator::Operation(uint8_t left, uint8_t right, uint8_t &result) {
95: 	if (right > left) {
96: 		return false;
97: 	}
98: 	return OverflowCheckedSubtract::Operation<uint8_t, uint16_t>(left, right, result);
99: }
100: 
101: template <>
102: bool TrySubtractOperator::Operation(uint16_t left, uint16_t right, uint16_t &result) {
103: 	if (right > left) {
104: 		return false;
105: 	}
106: 	return OverflowCheckedSubtract::Operation<uint16_t, uint32_t>(left, right, result);
107: }
108: 
109: template <>
110: bool TrySubtractOperator::Operation(uint32_t left, uint32_t right, uint32_t &result) {
111: 	if (right > left) {
112: 		return false;
113: 	}
114: 	return OverflowCheckedSubtract::Operation<uint32_t, uint64_t>(left, right, result);
115: }
116: 
117: template <>
118: bool TrySubtractOperator::Operation(uint64_t left, uint64_t right, uint64_t &result) {
119: 	if (right > left) {
120: 		return false;
121: 	}
122: 	return OverflowCheckedSubtract::Operation<uint64_t, uint64_t>(left, right, result);
123: }
124: 
125: template <>
126: bool TrySubtractOperator::Operation(int8_t left, int8_t right, int8_t &result) {
127: 	return OverflowCheckedSubtract::Operation<int8_t, int16_t>(left, right, result);
128: }
129: 
130: template <>
131: bool TrySubtractOperator::Operation(int16_t left, int16_t right, int16_t &result) {
132: 	return OverflowCheckedSubtract::Operation<int16_t, int32_t>(left, right, result);
133: }
134: 
135: template <>
136: bool TrySubtractOperator::Operation(int32_t left, int32_t right, int32_t &result) {
137: 	return OverflowCheckedSubtract::Operation<int32_t, int64_t>(left, right, result);
138: }
139: 
140: template <>
141: bool TrySubtractOperator::Operation(int64_t left, int64_t right, int64_t &result) {
142: #if (__GNUC__ >= 5) || defined(__clang__)
143: 	if (__builtin_sub_overflow(left, right, &result)) {
144: 		return false;
145: 	}
146: #else
147: 	if (right < 0) {
148: 		if (NumericLimits<int64_t>::Maximum() + right < left) {
149: 			return false;
150: 		}
151: 	} else {
152: 		if (NumericLimits<int64_t>::Minimum() + right > left) {
153: 			return false;
154: 		}
155: 	}
156: 	result = left - right;
157: #endif
158: 	return true;
159: }
160: 
161: //===--------------------------------------------------------------------===//
162: // subtract decimal with overflow check
163: //===--------------------------------------------------------------------===//
164: template <class T, T min, T max>
165: bool TryDecimalSubtractTemplated(T left, T right, T &result) {
166: 	if (right < 0) {
167: 		if (max + right < left) {
168: 			return false;
169: 		}
170: 	} else {
171: 		if (min + right > left) {
172: 			return false;
173: 		}
174: 	}
175: 	result = left - right;
176: 	return true;
177: }
178: 
179: template <>
180: bool TryDecimalSubtract::Operation(int16_t left, int16_t right, int16_t &result) {
181: 	return TryDecimalSubtractTemplated<int16_t, -9999, 9999>(left, right, result);
182: }
183: 
184: template <>
185: bool TryDecimalSubtract::Operation(int32_t left, int32_t right, int32_t &result) {
186: 	return TryDecimalSubtractTemplated<int32_t, -999999999, 999999999>(left, right, result);
187: }
188: 
189: template <>
190: bool TryDecimalSubtract::Operation(int64_t left, int64_t right, int64_t &result) {
191: 	return TryDecimalSubtractTemplated<int64_t, -999999999999999999, 999999999999999999>(left, right, result);
192: }
193: 
194: template <>
195: bool TryDecimalSubtract::Operation(hugeint_t left, hugeint_t right, hugeint_t &result) {
196: 	result = left - right;
197: 	if (result <= -Hugeint::POWERS_OF_TEN[38] || result >= Hugeint::POWERS_OF_TEN[38]) {
198: 		return false;
199: 	}
200: 	return true;
201: }
202: 
203: template <>
204: hugeint_t DecimalSubtractOverflowCheck::Operation(hugeint_t left, hugeint_t right) {
205: 	hugeint_t result;
206: 	if (!TryDecimalSubtract::Operation(left, right, result)) {
207: 		throw OutOfRangeException("Overflow in subtract of DECIMAL(38) (%s - %s);", left.ToString(), right.ToString());
208: 	}
209: 	return result;
210: }
211: 
212: //===--------------------------------------------------------------------===//
213: // subtract time operator
214: //===--------------------------------------------------------------------===//
215: template <>
216: dtime_t SubtractTimeOperator::Operation(dtime_t left, interval_t right) {
217: 	right.micros = -right.micros;
218: 	return AddTimeOperator::Operation<dtime_t, interval_t, dtime_t>(left, right);
219: }
220: 
221: } // namespace duckdb
[end of src/function/scalar/operators/subtract.cpp]
[start of src/include/duckdb/common/operator/subtract.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/common/operator/subtract.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/types.hpp"
12: #include "duckdb/common/exception.hpp"
13: 
14: namespace duckdb {
15: 
16: struct SubtractOperator {
17: 	template <class TA, class TB, class TR>
18: 	static inline TR Operation(TA left, TB right) {
19: 		return left - right;
20: 	}
21: };
22: 
23: template <>
24: float SubtractOperator::Operation(float left, float right);
25: template <>
26: double SubtractOperator::Operation(double left, double right);
27: template <>
28: interval_t SubtractOperator::Operation(interval_t left, interval_t right);
29: template <>
30: int64_t SubtractOperator::Operation(date_t left, date_t right);
31: template <>
32: date_t SubtractOperator::Operation(date_t left, int32_t right);
33: template <>
34: date_t SubtractOperator::Operation(date_t left, interval_t right);
35: template <>
36: timestamp_t SubtractOperator::Operation(timestamp_t left, interval_t right);
37: template <>
38: interval_t SubtractOperator::Operation(timestamp_t left, timestamp_t right);
39: 
40: struct TrySubtractOperator {
41: 	template <class TA, class TB, class TR>
42: 	static inline bool Operation(TA left, TB right, TR &result) {
43: 		throw InternalException("Unimplemented type for TrySubtractOperator");
44: 	}
45: };
46: 
47: template <>
48: bool TrySubtractOperator::Operation(uint8_t left, uint8_t right, uint8_t &result);
49: template <>
50: bool TrySubtractOperator::Operation(uint16_t left, uint16_t right, uint16_t &result);
51: template <>
52: bool TrySubtractOperator::Operation(uint32_t left, uint32_t right, uint32_t &result);
53: template <>
54: bool TrySubtractOperator::Operation(uint64_t left, uint64_t right, uint64_t &result);
55: 
56: template <>
57: bool TrySubtractOperator::Operation(int8_t left, int8_t right, int8_t &result);
58: template <>
59: bool TrySubtractOperator::Operation(int16_t left, int16_t right, int16_t &result);
60: template <>
61: bool TrySubtractOperator::Operation(int32_t left, int32_t right, int32_t &result);
62: template <>
63: bool TrySubtractOperator::Operation(int64_t left, int64_t right, int64_t &result);
64: 
65: struct SubtractOperatorOverflowCheck {
66: 	template <class TA, class TB, class TR>
67: 	static inline TR Operation(TA left, TB right) {
68: 		TR result;
69: 		if (!TrySubtractOperator::Operation(left, right, result)) {
70: 			throw OutOfRangeException("Overflow in subtraction of %s (%d - %d)!", TypeIdToString(GetTypeId<TA>()), left,
71: 			                          right);
72: 		}
73: 		return result;
74: 	}
75: };
76: 
77: struct TryDecimalSubtract {
78: 	template <class TA, class TB, class TR>
79: 	static inline bool Operation(TA left, TB right, TR &result) {
80: 		throw InternalException("Unimplemented type for TryDecimalSubtract");
81: 	}
82: };
83: 
84: template <>
85: bool TryDecimalSubtract::Operation(int16_t left, int16_t right, int16_t &result);
86: template <>
87: bool TryDecimalSubtract::Operation(int32_t left, int32_t right, int32_t &result);
88: template <>
89: bool TryDecimalSubtract::Operation(int64_t left, int64_t right, int64_t &result);
90: template <>
91: bool TryDecimalSubtract::Operation(hugeint_t left, hugeint_t right, hugeint_t &result);
92: 
93: struct DecimalSubtractOverflowCheck {
94: 	template <class TA, class TB, class TR>
95: 	static inline TR Operation(TA left, TB right) {
96: 		TR result;
97: 		if (!TryDecimalSubtract::Operation<TA, TB, TR>(left, right, result)) {
98: 			throw OutOfRangeException("Overflow in subtract of DECIMAL(18) (%d - %d). You might want to add an "
99: 			                          "explicit cast to a bigger decimal.",
100: 			                          left, right);
101: 		}
102: 		return result;
103: 	}
104: };
105: 
106: template <>
107: hugeint_t DecimalSubtractOverflowCheck::Operation(hugeint_t left, hugeint_t right);
108: 
109: struct SubtractTimeOperator {
110: 	template <class TA, class TB, class TR>
111: 	static TR Operation(TA left, TB right);
112: };
113: 
114: template <>
115: dtime_t SubtractTimeOperator::Operation(dtime_t left, interval_t right);
116: 
117: } // namespace duckdb
[end of src/include/duckdb/common/operator/subtract.hpp]
[start of src/optimizer/statistics/expression/propagate_and_compress.cpp]
1: #include "duckdb/function/scalar/operators.hpp"
2: #include "duckdb/optimizer/statistics_propagator.hpp"
3: #include "duckdb/planner/bound_result_modifier.hpp"
4: #include "duckdb/planner/expression/bound_cast_expression.hpp"
5: #include "duckdb/planner/expression/bound_constant_expression.hpp"
6: #include "duckdb/planner/expression/bound_function_expression.hpp"
7: #include "duckdb/storage/statistics/base_statistics.hpp"
8: #include "duckdb/storage/statistics/numeric_statistics.hpp"
9: #include "duckdb/common/operator/subtract.hpp"
10: 
11: namespace duckdb {
12: 
13: unique_ptr<Expression> CastHugeintToSmallestType(unique_ptr<Expression> expr, NumericStatistics &num_stats) {
14: 	// Compute range
15: 	if (num_stats.min.IsNull() || num_stats.max.IsNull()) {
16: 		return expr;
17: 	}
18: 
19: 	auto min_val = num_stats.min.GetValue<hugeint_t>();
20: 	auto max_val = num_stats.max.GetValue<hugeint_t>();
21: 	if (max_val < min_val) {
22: 		return expr;
23: 	}
24: 
25: 	// Prevent overflow
26: 	if (min_val < NumericLimits<int64_t>().Minimum() && max_val > NumericLimits<int64_t>().Maximum()) {
27: 		return expr;
28: 	}
29: 
30: 	// Compute range
31: 	auto range = max_val - min_val;
32: 
33: 	// Check if this range fits in a smaller type
34: 	LogicalType cast_type;
35: 	if (range < NumericLimits<uint8_t>().Maximum()) {
36: 		cast_type = LogicalType::UTINYINT;
37: 	} else if (range < NumericLimits<uint16_t>().Maximum()) {
38: 		cast_type = LogicalType::USMALLINT;
39: 	} else if (range < NumericLimits<uint32_t>().Maximum()) {
40: 		cast_type = LogicalType::UINTEGER;
41: 	} else if (range < NumericLimits<uint64_t>().Maximum()) {
42: 		cast_type = LogicalTypeId::UBIGINT;
43: 	} else {
44: 		return expr;
45: 	}
46: 
47: 	// Create expression to map to a smaller range
48: 	auto input_type = expr->return_type;
49: 	auto minimum_expr = make_unique<BoundConstantExpression>(Value::CreateValue(min_val));
50: 	vector<unique_ptr<Expression>> arguments;
51: 	arguments.push_back(move(expr));
52: 	arguments.push_back(move(minimum_expr));
53: 	auto minus_expr = make_unique<BoundFunctionExpression>(input_type, SubtractFun::GetFunction(input_type, input_type),
54: 	                                                       move(arguments), nullptr, true);
55: 
56: 	// Cast to smaller type
57: 	return make_unique<BoundCastExpression>(move(minus_expr), cast_type);
58: }
59: 
60: template <class T>
61: unique_ptr<Expression> TemplatedCastToSmallestType(unique_ptr<Expression> expr, NumericStatistics &num_stats) {
62: 	// Compute range
63: 	if (num_stats.min.IsNull() || num_stats.max.IsNull()) {
64: 		return expr;
65: 	}
66: 
67: 	auto signed_min_val = num_stats.min.GetValue<T>();
68: 	auto signed_max_val = num_stats.max.GetValue<T>();
69: 	if (signed_max_val < signed_min_val) {
70: 		return expr;
71: 	}
72: 
73: 	// Compute range, cast to unsigned to prevent comparing signed with unsigned
74: 	T signed_range;
75: 	if (!TrySubtractOperator::Operation(signed_min_val, signed_max_val, signed_range)) {
76: 		// overflow in subtraction: cannot do any simplification
77: 		return expr;
78: 	}
79: 	auto range = static_cast<typename std::make_unsigned<decltype(signed_range)>::type>(signed_range);
80: 
81: 	// Check if this range fits in a smaller type
82: 	LogicalType cast_type;
83: 	if (range < NumericLimits<uint8_t>::Maximum()) {
84: 		cast_type = LogicalType::UTINYINT;
85: 	} else if (sizeof(T) > sizeof(uint16_t) && range < NumericLimits<uint16_t>::Maximum()) {
86: 		cast_type = LogicalType::USMALLINT;
87: 	} else if (sizeof(T) > sizeof(uint32_t) && range < NumericLimits<uint32_t>::Maximum()) {
88: 		cast_type = LogicalType::UINTEGER;
89: 	} else {
90: 		return expr;
91: 	}
92: 
93: 	// Create expression to map to a smaller range
94: 	auto input_type = expr->return_type;
95: 	auto minimum_expr = make_unique<BoundConstantExpression>(Value::CreateValue(signed_min_val));
96: 	vector<unique_ptr<Expression>> arguments;
97: 	arguments.push_back(move(expr));
98: 	arguments.push_back(move(minimum_expr));
99: 	auto minus_expr = make_unique<BoundFunctionExpression>(input_type, SubtractFun::GetFunction(input_type, input_type),
100: 	                                                       move(arguments), nullptr, true);
101: 
102: 	// Cast to smaller type
103: 	return make_unique<BoundCastExpression>(move(minus_expr), cast_type);
104: }
105: 
106: unique_ptr<Expression> CastToSmallestType(unique_ptr<Expression> expr, NumericStatistics &num_stats) {
107: 	auto physical_type = expr->return_type.InternalType();
108: 	switch (physical_type) {
109: 	case PhysicalType::UINT8:
110: 	case PhysicalType::INT8:
111: 		return expr;
112: 	case PhysicalType::UINT16:
113: 		return TemplatedCastToSmallestType<uint16_t>(move(expr), num_stats);
114: 	case PhysicalType::INT16:
115: 		return TemplatedCastToSmallestType<int16_t>(move(expr), num_stats);
116: 	case PhysicalType::UINT32:
117: 		return TemplatedCastToSmallestType<uint32_t>(move(expr), num_stats);
118: 	case PhysicalType::INT32:
119: 		return TemplatedCastToSmallestType<int32_t>(move(expr), num_stats);
120: 	case PhysicalType::UINT64:
121: 		return TemplatedCastToSmallestType<uint64_t>(move(expr), num_stats);
122: 	case PhysicalType::INT64:
123: 		return TemplatedCastToSmallestType<int64_t>(move(expr), num_stats);
124: 	case PhysicalType::INT128:
125: 		return CastHugeintToSmallestType(move(expr), num_stats);
126: 	default:
127: 		throw NotImplementedException("Unknown integer type!");
128: 	}
129: }
130: 
131: void StatisticsPropagator::PropagateAndCompress(unique_ptr<Expression> &expr, unique_ptr<BaseStatistics> &stats) {
132: 	stats = PropagateExpression(expr);
133: 	if (stats) {
134: 		if (expr->return_type.IsIntegral()) {
135: 			expr = CastToSmallestType(move(expr), (NumericStatistics &)*stats);
136: 		}
137: 	}
138: }
139: 
140: } // namespace duckdb
[end of src/optimizer/statistics/expression/propagate_and_compress.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: