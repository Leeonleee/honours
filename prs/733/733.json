{
  "repo": "duckdb/duckdb",
  "pull_number": 733,
  "instance_id": "duckdb__duckdb-733",
  "issue_numbers": [
    "692",
    "692"
  ],
  "base_commit": "d2348288fcb1cadde0757c7a5b78d1ee87c50ea4",
  "patch": "diff --git a/scripts/amalgamation.py b/scripts/amalgamation.py\nindex 2381c1b459da..2034c068b235 100644\n--- a/scripts/amalgamation.py\n+++ b/scripts/amalgamation.py\n@@ -153,6 +153,8 @@ def generate_amalgamation(source_file, header_file):\n \n     copy_if_different(temp_header, header_file)\n     copy_if_different(temp_source, source_file)\n+    os.remove(temp_header)\n+    os.remove(temp_source)\n \n \n \ndiff --git a/tools/pythonpkg/duckdb_python.cpp b/tools/pythonpkg/duckdb_python.cpp\nindex fe9d984085f8..64192546ed91 100644\n--- a/tools/pythonpkg/duckdb_python.cpp\n+++ b/tools/pythonpkg/duckdb_python.cpp\n@@ -227,13 +227,7 @@ struct PandasScanFunction : public TableFunction {\n \t\t\t\t\tif (PyUnicode_READY(val) != 0) {\n \t\t\t\t\t\tthrow runtime_error(\"failure in PyUnicode_READY\");\n \t\t\t\t\t}\n-\t\t\t\t\tif (PyUnicode_KIND(val) == PyUnicode_1BYTE_KIND) {\n-\t\t\t\t\t\tauto ucs1 = PyUnicode_1BYTE_DATA(val);\n-\t\t\t\t\t\tauto length = PyUnicode_GET_LENGTH(val);\n-\t\t\t\t\t\ttgt_ptr[row] = string_t((const char*) ucs1, length);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\ttgt_ptr[row] = StringVector::AddString(output.data[col_idx], ((py::object*) &val)->cast<string>());\n-\t\t\t\t\t}\n+\t\t\t\t\ttgt_ptr[row] = StringVector::AddString(output.data[col_idx], ((py::object*) &val)->cast<string>());\n #else\n \t\t\t\t\tif (!py::isinstance<py::str>(*((py::object*) &val))) {\n \t\t\t\t\t\tFlatVector::SetNull(output.data[col_idx], row, true);\ndiff --git a/tools/pythonpkg/setup.py b/tools/pythonpkg/setup.py\nindex 5a5a75194bf5..b7e925730825 100755\n--- a/tools/pythonpkg/setup.py\n+++ b/tools/pythonpkg/setup.py\n@@ -36,7 +36,8 @@\n \n \n toolchain_args = ['-std=c++11']\n-#toolchain_args = ['-std=c++11', '-Wall', '-O0', '-g']\n+if 'DUCKDEBUG' in os.environ:\n+    toolchain_args = ['-std=c++11', '-Wall', '-O0', '-g']\n \n if platform.system() == 'Darwin':\n     toolchain_args.extend(['-stdlib=libc++', '-mmacosx-version-min=10.7'])\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/test_unicode.py b/tools/pythonpkg/tests/test_unicode.py\nnew file mode 100644\nindex 000000000000..f88e4a092bec\n--- /dev/null\n+++ b/tools/pythonpkg/tests/test_unicode.py\n@@ -0,0 +1,13 @@\n+#!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n+\n+import duckdb\n+import pandas as pd\n+\n+\n+class TestUnicode(object):\n+    def test_unicode_pandas_scan(self, duckdb_cursor):\n+        con = duckdb.connect(database=':memory:', read_only=False)\n+        test_df = pd.DataFrame.from_dict({\"i\":[1, 2, 3], \"j\":[\"a\", \"c\", u\"\u00eb\"]})\n+        con.register('test_df_view', test_df)\n+        con.execute('SELECT i, j, LENGTH(j) FROM test_df_view').fetchall()\n",
  "problem_statement": "Handle special characters from Python API\nHi All!\r\nFirst off - DuckDB is flat out amazing - I love it. It's perfect for our use case.\r\n\r\nI had a small issue while benchmarking it - a registered trademark symbol in my DuckDB caused it to fail upon executing a select statement with the error:\r\n\"Runtime error: Could not allocate string object!\".\r\n\r\nI was planning to adjust the collation, but I couldn't find a function in the Python API to do it. How can I change the collation through Python?\r\n\r\nMany thanks!\r\n-Alex\nHandle special characters from Python API\nHi All!\r\nFirst off - DuckDB is flat out amazing - I love it. It's perfect for our use case.\r\n\r\nI had a small issue while benchmarking it - a registered trademark symbol in my DuckDB caused it to fail upon executing a select statement with the error:\r\n\"Runtime error: Could not allocate string object!\".\r\n\r\nI was planning to adjust the collation, but I couldn't find a function in the Python API to do it. How can I change the collation through Python?\r\n\r\nMany thanks!\r\n-Alex\n",
  "hints_text": "Glad you are enjoying DuckDB, and thanks for the bug report!\r\n\r\nThis seems to be a bug in the Python API - DuckDB always supports UTF8 characters. Collations are used only for comparisons and ordering (see [here](https://www.duckdb.org/docs/sql/expressions/collations) for a full explanation). \r\n\r\nCould you provide a (minimal) example of when you encounter the error? And which Python version are you using?\nAh - let me verify that it is a utf-8 character, and then I will certainly provide more details and an example. Thank you for the link on collations, that helps!\nIf it is not too much effort, could you provide an example that triggers this behavior in either case? Even if it's not a bug in the Python API directly the error message should be much more descriptive. I would like to improve that.\nHi, I ran into the same issue with a diffenrent error message: \r\n\r\n`UnicodeDecodeError: 'utf-8' codec can't decode byte 0xeb in position 0: unexpected end of data `\r\n\r\nHere's a testcase:\r\n\r\n    import duckdb\r\n    import pandas as pd\r\n\r\n    con = duckdb.connect(database=':memory:', read_only=False)\r\n    test_df = pd.DataFrame.from_dict({\"i\":[1, 2, 3], \"j\":[\"a\", \"c\", \"\u00eb\"]})\r\n    con.register('test_df_view', test_df)\r\n    con.execute('SELECT * FROM test_df_view')\r\n\r\n    print(con.fetchall())\r\n\r\nOn the code above, when I run `print(ord(test_df.iloc[2, 1]))` it prints: `235`\r\n\r\nI'm running on Windows 10 with python 3.7.4, duckdb 0.1.9 and pandas 1.0.3.\r\n\r\nThanks, Frans\r\n\r\n\nCan confirm this unexpectedly throws an exception, seems like a problem in the Python API's handling of strings. I will have a look.\nThanks for looking into this! I just pulled down duckdb 0.1.9 and replicated the issue I was seeing. I'm using Python 3.7.3 and Pandas 0.24.2. Here is a zipped Jupyter notebook that includes the error messages I'm seeing.\r\n\r\nThanks!\r\n-Alex\r\n\r\n[DuckDB Special Characters.zip](https://github.com/cwida/duckdb/files/4820899/DuckDB.Special.Characters.zip)\r\n\r\n\n#Test register method\r\ndb_path = ':memory:'\r\ntable_name = 'example_table'\r\ntry:\r\n    conn = duckdb.connect(db_path)\r\n    \r\n    conn.register(table_name,df)\r\n    query = \"select * from \" + table_name\r\n\r\n    result_df = conn.execute(query).fetchdf()\r\n\r\nfinally:\r\n    conn.close()\r\n\r\nprint(result_df.info())\r\nresult_df\r\n\r\n![image](https://user-images.githubusercontent.com/52226177/85434671-41ceef00-b53b-11ea-98da-d69f1399bea0.png)\r\n\nGlad you are enjoying DuckDB, and thanks for the bug report!\r\n\r\nThis seems to be a bug in the Python API - DuckDB always supports UTF8 characters. Collations are used only for comparisons and ordering (see [here](https://www.duckdb.org/docs/sql/expressions/collations) for a full explanation). \r\n\r\nCould you provide a (minimal) example of when you encounter the error? And which Python version are you using?\nAh - let me verify that it is a utf-8 character, and then I will certainly provide more details and an example. Thank you for the link on collations, that helps!\nIf it is not too much effort, could you provide an example that triggers this behavior in either case? Even if it's not a bug in the Python API directly the error message should be much more descriptive. I would like to improve that.\nHi, I ran into the same issue with a diffenrent error message: \r\n\r\n`UnicodeDecodeError: 'utf-8' codec can't decode byte 0xeb in position 0: unexpected end of data `\r\n\r\nHere's a testcase:\r\n\r\n    import duckdb\r\n    import pandas as pd\r\n\r\n    con = duckdb.connect(database=':memory:', read_only=False)\r\n    test_df = pd.DataFrame.from_dict({\"i\":[1, 2, 3], \"j\":[\"a\", \"c\", \"\u00eb\"]})\r\n    con.register('test_df_view', test_df)\r\n    con.execute('SELECT * FROM test_df_view')\r\n\r\n    print(con.fetchall())\r\n\r\nOn the code above, when I run `print(ord(test_df.iloc[2, 1]))` it prints: `235`\r\n\r\nI'm running on Windows 10 with python 3.7.4, duckdb 0.1.9 and pandas 1.0.3.\r\n\r\nThanks, Frans\r\n\r\n\nCan confirm this unexpectedly throws an exception, seems like a problem in the Python API's handling of strings. I will have a look.\nThanks for looking into this! I just pulled down duckdb 0.1.9 and replicated the issue I was seeing. I'm using Python 3.7.3 and Pandas 0.24.2. Here is a zipped Jupyter notebook that includes the error messages I'm seeing.\r\n\r\nThanks!\r\n-Alex\r\n\r\n[DuckDB Special Characters.zip](https://github.com/cwida/duckdb/files/4820899/DuckDB.Special.Characters.zip)\r\n\r\n\n#Test register method\r\ndb_path = ':memory:'\r\ntable_name = 'example_table'\r\ntry:\r\n    conn = duckdb.connect(db_path)\r\n    \r\n    conn.register(table_name,df)\r\n    query = \"select * from \" + table_name\r\n\r\n    result_df = conn.execute(query).fetchdf()\r\n\r\nfinally:\r\n    conn.close()\r\n\r\nprint(result_df.info())\r\nresult_df\r\n\r\n![image](https://user-images.githubusercontent.com/52226177/85434671-41ceef00-b53b-11ea-98da-d69f1399bea0.png)\r\n",
  "created_at": "2020-07-01T05:34:41Z"
}