{
  "repo": "duckdb/duckdb",
  "pull_number": 6125,
  "instance_id": "duckdb__duckdb-6125",
  "issue_numbers": [
    "4026"
  ],
  "base_commit": "5b9fd043c9794c8e4dcd84a0993fd302c9df54f9",
  "patch": "diff --git a/src/common/types/date.cpp b/src/common/types/date.cpp\nindex fb3acc595614..4dd5787d200f 100644\n--- a/src/common/types/date.cpp\n+++ b/src/common/types/date.cpp\n@@ -425,13 +425,18 @@ int64_t Date::Epoch(date_t date) {\n }\n \n int64_t Date::EpochNanoseconds(date_t date) {\n-\treturn ((int64_t)date.days) * (Interval::MICROS_PER_DAY * 1000);\n+\tint64_t result;\n+\tif (!TryMultiplyOperator::Operation<int64_t, int64_t, int64_t>(date.days, Interval::MICROS_PER_DAY * 1000,\n+\t                                                               result)) {\n+\t\tthrow ConversionException(\"Could not convert DATE (%s) to nanoseconds\", Date::ToString(date));\n+\t}\n+\treturn result;\n }\n \n int64_t Date::EpochMicroseconds(date_t date) {\n \tint64_t result;\n \tif (!TryMultiplyOperator::Operation<int64_t, int64_t, int64_t>(date.days, Interval::MICROS_PER_DAY, result)) {\n-\t\tthrow ConversionException(\"Could not convert DATE to microseconds\");\n+\t\tthrow ConversionException(\"Could not convert DATE (%s) to microseconds\", Date::ToString(date));\n \t}\n \treturn result;\n }\ndiff --git a/src/include/duckdb/common/limits.hpp b/src/include/duckdb/common/limits.hpp\nindex e6d998c22c59..f3db80680aac 100644\n--- a/src/include/duckdb/common/limits.hpp\n+++ b/src/include/duckdb/common/limits.hpp\n@@ -74,6 +74,7 @@ struct NumericLimits<int32_t> {\n \t\treturn 10;\n \t}\n };\n+\n template <>\n struct NumericLimits<int64_t> {\n \tDUCKDB_API static constexpr int64_t Minimum() {\n@@ -104,6 +105,7 @@ struct NumericLimits<hugeint_t> {\n \t\treturn 39;\n \t}\n };\n+\n template <>\n struct NumericLimits<uint8_t> {\n \tDUCKDB_API static constexpr uint8_t Minimum() {\n@@ -119,6 +121,7 @@ struct NumericLimits<uint8_t> {\n \t\treturn 3;\n \t}\n };\n+\n template <>\n struct NumericLimits<uint16_t> {\n \tDUCKDB_API static constexpr uint16_t Minimum() {\ndiff --git a/tools/pythonpkg/src/pyconnection.cpp b/tools/pythonpkg/src/pyconnection.cpp\nindex 21f4bac43835..fd8297b8fa2c 100644\n--- a/tools/pythonpkg/src/pyconnection.cpp\n+++ b/tools/pythonpkg/src/pyconnection.cpp\n@@ -509,8 +509,8 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadCSV(\n \t\t\tfor (auto &kv : dtype_dict) {\n \t\t\t\tstruct_fields.push_back(make_pair(py::str(kv.first), Value(py::str(kv.second))));\n \t\t\t}\n-\t\t\tauto dtype_struct = Value::STRUCT(move(struct_fields));\n-\t\t\tread_csv.AddNamedParameter(\"dtypes\", move(dtype_struct));\n+\t\t\tauto dtype_struct = Value::STRUCT(std::move(struct_fields));\n+\t\t\tread_csv.AddNamedParameter(\"dtypes\", std::move(dtype_struct));\n \t\t} else if (py::isinstance<py::list>(dtype)) {\n \t\t\tauto dtype_list = TransformPythonValue(py::list(dtype));\n \t\t\tD_ASSERT(dtype_list.type().id() == LogicalTypeId::LIST);\n@@ -520,7 +520,7 @@ unique_ptr<DuckDBPyRelation> DuckDBPyConnection::ReadCSV(\n \t\t\t\t\tthrow InvalidInputException(\"The types provided to 'dtype' have to be strings\");\n \t\t\t\t}\n \t\t\t}\n-\t\t\tread_csv.AddNamedParameter(\"dtypes\", move(dtype_list));\n+\t\t\tread_csv.AddNamedParameter(\"dtypes\", std::move(dtype_list));\n \t\t} else {\n \t\t\tthrow InvalidInputException(\"read_csv only accepts 'dtype' as a dictionary or a list of strings\");\n \t\t}\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/pandas/test_date_as_datetime.py b/tools/pythonpkg/tests/fast/pandas/test_date_as_datetime.py\nindex e9aa8941db0d..9227875e68c7 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_date_as_datetime.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_date_as_datetime.py\n@@ -1,6 +1,7 @@\n import pandas as pd\n import duckdb\n import datetime\n+import pytest\n \n def run_checks(df):\n     assert type(df['d'][0]) is datetime.date\ndiff --git a/tools/pythonpkg/tests/fast/pandas/test_datetime_time.py b/tools/pythonpkg/tests/fast/pandas/test_datetime_time.py\nindex abc0c7e7ca06..e40733e71972 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_datetime_time.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_datetime_time.py\n@@ -59,4 +59,13 @@ def test_time_timezone_positive_extreme(self, duckdb_cursor):\n             {'0': pd.Series(data=data, dtype='object')}\n         )\n         df_out = duckdb.query_df(df_in, \"df\", \"select * from df\").df()\n-        pd.testing.assert_frame_equal(df_out, duckdb_time)\n\\ No newline at end of file\n+        pd.testing.assert_frame_equal(df_out, duckdb_time)\n+\n+    def test_pandas_datetime_overflow(self):\n+        duckdb_con = duckdb.connect()\n+\n+        duckdb_con.execute(\"create table test (date DATE)\")\n+        duckdb_con.execute(\"INSERT INTO TEST VALUES ('2263-02-28')\")\n+\n+        with pytest.raises(duckdb.ConversionException):\n+            res = duckdb_con.execute(\"select * from test\").df()\ndiff --git a/tools/pythonpkg/tests/fast/test_all_types.py b/tools/pythonpkg/tests/fast/test_all_types.py\nindex 2a4e7c3b1347..8159afc936c5 100644\n--- a/tools/pythonpkg/tests/fast/test_all_types.py\n+++ b/tools/pythonpkg/tests/fast/test_all_types.py\n@@ -188,14 +188,6 @@ def test_fetchnumpy(self, duckdb_cursor):\n                 ],\n                 mask=[0, 0, 1],\n             ),\n-            'date': np.ma.array(\n-                [\n-                    np.datetime64(-5235121029329846272, \"ns\"),\n-                    np.datetime64(5235121029329846272, \"ns\"),\n-                    np.datetime64(\"1990-01-01T00:42\"),\n-                ],\n-                mask=[0, 0, 1],\n-            ),\n             # For timestamp_ns, the lowest value is out-of-range for numpy,\n             # such that the conversion yields \"Not a Time\"\n             'timestamp_ns': np.ma.array(\n@@ -314,6 +306,8 @@ def test_fetchnumpy(self, duckdb_cursor):\n         # - 'dec38_10'\n \n         # The following types lead to errors:\n+        # Conversion Error: Could not convert DATE to nanoseconds\n+        # - 'date'\n         # Conversion Error: Date out of range in timestamp conversion\n         # - 'timestamp_array'\n         # - 'timestamptz_array'\n@@ -329,11 +323,9 @@ def test_fetchnumpy(self, duckdb_cursor):\n         for cur_type in all_types:\n             if cur_type not in correct_answer_map:\n                 continue\n-\n             result = rel.project(cur_type).fetchnumpy()\n             result = result[cur_type]\n             correct_answer = correct_answer_map[cur_type]\n-\n             if isinstance(result, pd.Categorical) or result.dtype == object:\n                 assert recursive_equality(list(result), list(correct_answer))\n             else:\ndiff --git a/tools/pythonpkg/tests/fast/types/test_numpy.py b/tools/pythonpkg/tests/fast/types/test_numpy.py\nindex 4f9e4efcdbec..c7bfbe22cef0 100644\n--- a/tools/pythonpkg/tests/fast/types/test_numpy.py\n+++ b/tools/pythonpkg/tests/fast/types/test_numpy.py\n@@ -1,6 +1,7 @@\n import duckdb\n import numpy as np\n import datetime\n+import pytest\n \n class TestNumpyDatetime64(object):\n     def test_numpy_datetime64(self, duckdb_cursor):\n@@ -10,4 +11,11 @@ def test_numpy_datetime64(self, duckdb_cursor):\n         duckdb_con.execute(\"insert into tbl VALUES (CAST(? AS TIMESTAMP WITHOUT TIME ZONE))\", parameters=[np.datetime64('2022-02-08T06:01:38.761310')])\n         assert [(datetime.datetime(2022, 2, 8, 6, 1, 38, 761310),)] == duckdb_con.execute(\"select * from tbl\").fetchall()\n \n+    def test_numpy_datetime_overflow(self):\n+        duckdb_con = duckdb.connect()\n+\n+        duckdb_con.execute(\"create table test (date DATE)\")\n+        duckdb_con.execute(\"INSERT INTO TEST VALUES ('2263-02-28')\")\n \n+        with pytest.raises(duckdb.ConversionException):\n+            res1 = duckdb_con.execute(\"select * from test\").fetchnumpy()\n",
  "problem_statement": "TIME Value result -> Pandas Dataframe does not return datetime.time\n#### What happens?  \r\n\r\nWhen the result is of type TIME, exporting this result to a dataframe converts the value to a string, instead of an object of type `datetime.time`  \r\n```py\r\ntime = duckdb.query(\"SELECT make_time(23, 1, 34.234345) AS '0'\").df()\r\n----\r\n'23:01:34.234345'\r\n```\r\nWhereas exporting it as a tuple through `fetchone()` does create the expected result:\r\n```py\r\ntime = duckdb.query(\"SELECT make_time(23, 1, 34.234345) AS '0'\").fetchone()\r\n----\r\n(datetime.time(23, 1, 34, 234345),)\r\n```\r\n#### Environment (please complete the following information):\r\n - OS: (e.g. iOS)\r\n - DuckDB Version: [master:latest]\r\n - DuckDB Client: [Python]\r\n\r\n#### Identity Disclosure:\r\n - Full Name: [Thijs Bruineman]\r\n - Affiliation: [DuckDBLabs]\r\n\r\n#### Before Submitting\r\n\r\n- [x] **Have you tried this on the latest `master` branch?**\r\n* **Python**: `pip install duckdb --upgrade --pre`\r\n* **R**: `install.packages(\"https://github.com/duckdb/duckdb/releases/download/master-builds/duckdb_r_src.tar.gz\", repos = NULL)`\r\n* **Other Platforms**: You can find binaries [here](https://github.com/duckdb/duckdb/releases/tag/master-builds) or compile from source.\r\n\r\n- [x] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "Re-upping this with respect to dates out of bounds for pandas datetimens[64] format (i.e. https://pandas.pydata.org/docs/user_guide/timeseries.html#timeseries-oob)\r\n\r\nShortly, one gets different output from queries depending on the output method, .fetchall() or .fetchdf()/df(). \r\nWith out of bounds values, e.g. '9999-12-31', .fetchdf()/df() return wrong values due to datetime conversion.\r\n\r\nTested on \r\nWindows\r\nduckdb-0.6.2.dev1934\r\npython client\r\n\r\n```\r\n>>> import duckdb\r\n>>> c = duckdb.connect(':memory:')\r\n>>> c.execute(\"create table test (date DATE)\")\r\n<duckdb.DuckDBPyConnection object at 0x000002293E4816B0>\r\n>>> c.execute(\"INSERT INTO TEST VALUES ('9999-12-31')\")\r\n<duckdb.DuckDBPyConnection object at 0x000002293E4816B0>\r\n\r\n>>> c.execute(\"select * from test\").fetchall()\r\n[(datetime.date(9999, 12, 31),)]\r\n\r\n>>> c.execute(\"select * from test\").df(date_as_object=True)\r\n         date\r\n0  1816-03-29\r\n\r\n>>> c.execute(\"select * from test\").df()\r\n                           date\r\n0 1816-03-29 05:56:08.066277376\r\n```\r\n\r\n\nI'm looking into this now, but I'm not sure what the best action to take is\r\n\r\nWe use the same logic for both NumPy and Pandas here currently.\r\nPandas has a way to deal with this with the Period type, though that would likely be an `object`, which requires sampling the column before conversion to detect which physical type in the array to use.\r\n\r\nBut Numpy has no way of dealing with this, so maybe we just want to throw here in the case of `fetchnumpy`\r\n\r\n\nEither throwing or returning a correct datetime seems fine to me. Supporting these date ranges is likely not particularly important but we should at the very least catch the overflow.",
  "created_at": "2023-02-07T12:35:28Z"
}