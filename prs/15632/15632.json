{
  "repo": "duckdb/duckdb",
  "pull_number": 15632,
  "instance_id": "duckdb__duckdb-15632",
  "issue_numbers": [
    "15626"
  ],
  "base_commit": "f850786ddef96177354ca8183280bc0de62a66c0",
  "patch": "diff --git a/src/function/cast/struct_cast.cpp b/src/function/cast/struct_cast.cpp\nindex e5902b7522e2..051581c54231 100644\n--- a/src/function/cast/struct_cast.cpp\n+++ b/src/function/cast/struct_cast.cpp\n@@ -128,6 +128,7 @@ static bool StructToStructCast(Vector &source, Vector &result, idx_t count, Cast\n \tsource.Flatten(count);\n \tauto &result_validity = FlatVector::Validity(result);\n \tresult_validity = FlatVector::Validity(source);\n+\tresult.Verify(count);\n \treturn all_converted;\n }\n \ndiff --git a/src/function/table/arrow_conversion.cpp b/src/function/table/arrow_conversion.cpp\nindex 18daff2b9209..e09f81aac640 100644\n--- a/src/function/table/arrow_conversion.cpp\n+++ b/src/function/table/arrow_conversion.cpp\n@@ -725,6 +725,9 @@ static void ColumnArrowToDuckDBRunEndEncoded(Vector &vector, const ArrowArray &a\n \tD_ASSERT(vector.GetType() == values_type.GetDuckType());\n \n \tauto &scan_state = array_state.state;\n+\tif (vector.GetBuffer()) {\n+\t\tvector.GetBuffer()->SetAuxiliaryData(make_uniq<ArrowAuxiliaryData>(array_state.owned_data));\n+\t}\n \n \tD_ASSERT(run_ends_array.length == values_array.length);\n \tauto compressed_size = NumericCast<idx_t>(run_ends_array.length);\n@@ -766,6 +769,9 @@ static void ColumnArrowToDuckDB(Vector &vector, ArrowArray &array, ArrowArraySca\n \tauto &scan_state = array_state.state;\n \tD_ASSERT(!array.dictionary);\n \n+\tif (vector.GetBuffer()) {\n+\t\tvector.GetBuffer()->SetAuxiliaryData(make_uniq<ArrowAuxiliaryData>(array_state.owned_data));\n+\t}\n \tswitch (vector.GetType().id()) {\n \tcase LogicalTypeId::SQLNULL:\n \t\tvector.Reference(Value());\n@@ -1284,6 +1290,9 @@ static bool CanContainNull(const ArrowArray &array, const ValidityMask *parent_m\n static void ColumnArrowToDuckDBDictionary(Vector &vector, ArrowArray &array, ArrowArrayScanState &array_state,\n                                           idx_t size, const ArrowType &arrow_type, int64_t nested_offset,\n                                           const ValidityMask *parent_mask, uint64_t parent_offset) {\n+\tif (vector.GetBuffer()) {\n+\t\tvector.GetBuffer()->SetAuxiliaryData(make_uniq<ArrowAuxiliaryData>(array_state.owned_data));\n+\t}\n \tD_ASSERT(arrow_type.HasDictionary());\n \tauto &scan_state = array_state.state;\n \tconst bool has_nulls = CanContainNull(array, parent_mask);\n@@ -1384,7 +1393,6 @@ void ArrowTableFunction::ArrowToDuckDB(ArrowScanLocalState &scan_state, const ar\n \t\tif (!array_state.owned_data) {\n \t\t\tarray_state.owned_data = scan_state.chunk;\n \t\t}\n-\t\toutput.data[idx].GetBuffer()->SetAuxiliaryData(make_uniq<ArrowAuxiliaryData>(array_state.owned_data));\n \n \t\tauto array_physical_type = GetArrowArrayPhysicalType(arrow_type);\n \ndiff --git a/tools/pythonpkg/src/python_udf.cpp b/tools/pythonpkg/src/python_udf.cpp\nindex 7667c3ba21e4..dd55c8ffa8c6 100644\n--- a/tools/pythonpkg/src/python_udf.cpp\n+++ b/tools/pythonpkg/src/python_udf.cpp\n@@ -126,6 +126,7 @@ static void ConvertArrowTableToVector(const py::object &table, Vector &out, Clie\n \n \tVectorOperations::Cast(context, result.data[0], out, count);\n \tout.Flatten(count);\n+\tout.Verify(count);\n }\n \n static string NullHandlingError() {\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/udf/test_scalar_arrow.py b/tools/pythonpkg/tests/fast/udf/test_scalar_arrow.py\nindex 85fec00c8bfc..fd7f00f72e5b 100644\n--- a/tools/pythonpkg/tests/fast/udf/test_scalar_arrow.py\n+++ b/tools/pythonpkg/tests/fast/udf/test_scalar_arrow.py\n@@ -209,3 +209,14 @@ def return_five(x):\n         res = con.sql('select return_five(NULL) from range(10)').fetchall()\n         # Because we didn't specify 'special' null handling, these are all NULL\n         assert res == [(None,), (None,), (None,), (None,), (None,), (None,), (None,), (None,), (None,), (None,)]\n+\n+    def test_struct_with_non_inlined_string(self, duckdb_cursor):\n+        def func(data):\n+            return pa.array([{'x': 1, 'y': 'this is not an inlined string'}] * data.length())\n+\n+        duckdb_cursor.create_function(\n+            name=\"func\", function=func, return_type=\"STRUCT(x integer, y varchar)\", type=\"arrow\", side_effects=False\n+        )\n+\n+        res = duckdb_cursor.sql(\"select func(1).y\").fetchone()\n+        assert res == ('this is not an inlined string',)\n",
  "problem_statement": "Corrupt data in Python UDF using PyArrow\n### What happens?\n\nCalling a UDF in \"arrow\" mode with certain python return values reliably causes corrupt return in duckdb table.\r\n\r\nThis maybe should be in the 'arrow' repo but I'm not sure.\n\n### To Reproduce\n\nThis is with a build 1.1.4-dev3393 just now but also with release 1.1.3 ...\r\n\r\n```\r\nimport duckdb\r\nimport pyarrow\r\n\r\nprint(f\"VERSION: {duckdb.__version__}\")\r\n\r\ndef func(data):\r\n    return pyarrow.array([ { 'x': 1, 'y': 'g.[4T>A;9del]' } ] * data.length())\r\n\r\nddbc = duckdb.connect()\r\n\r\nddbc.create_function(\r\n    name=\"fnord\",\r\n    function=func,\r\n    return_type=\"STRUCT(x integer, y varchar)\",\r\n    type=\"arrow\",\r\n    side_effects=False\r\n)\r\n\r\nprint(ddbc.sql(\"select fnord(1).y\"))\r\n```\r\n\r\noutput from running the same code several times:\r\n\r\n```$ python test_duckdb_3.py \r\nVERSION: 1.1.4-dev3393\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502    (fnord(1)).y     \u2502\r\n\u2502       varchar       \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 ????INVALID VALUE\u2026  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n$ python test_duckdb_3.py \r\nVERSION: 1.1.4-dev3393\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502    (fnord(1)).y    \u2502\r\n\u2502      varchar       \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 ????INVALID VALU\u2026  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n$ python test_duckdb_3.py \r\nVERSION: 1.1.4-dev3393\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   (fnord(1)).y   \u2502\r\n\u2502     varchar      \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 @\\a\\2\u030e\\5\\0\\09del] \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n$ python test_duckdb_3.py \r\nVERSION: 1.1.4-dev3393\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   (fnord(1)).y    \u2502\r\n\u2502      varchar      \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 ????INVALID VAL\u2026  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n$ python test_duckdb_3.py \r\nVERSION: 1.1.4-dev3393\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502    (fnord(1)).y     \u2502\r\n\u2502       varchar       \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 @\\a\\2X\\3\\3\\0\\09del] \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n```\r\n\r\nnote that the \"invalid\" value varies a little, and it is sometimes a mess of ascii characters.\r\nThe value of that string seems to matter but I don't know why.\n\n### OS:\n\nLinux x86_64\n\n### DuckDB Version:\n\n1.1.3, 1.1.4-dev3393\n\n### DuckDB Client:\n\nPython\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nNick Moore\n\n### Affiliation:\n\nMnemote Pty Ltd\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a source build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "Seems to be any 13 or more character string, eg: 'helloworldab' is fine but 'helloworldabc' results in corruption.\r\nSometimes the corrupt string has the last few characters of the original string on the end, eg: \r\n```\r\n$ python test_duckdb_3.py \r\nVERSION: 1.1.4-dev3393\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502    (fnord(1)).y     \u2502\r\n\u2502       varchar       \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 @\\a\\2\\20\\4\\0\\0ldabc \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n$ python test_duckdb_3.py \r\nVERSION: 1.1.4-dev3393\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502     (fnord(1)).y     \u2502\r\n\u2502       varchar        \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 @\\a\\2\\28I\\4\\0\\0ldabc \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n* the exact corrupt value varies, but it is always wrong.\r\n* only seems to do it if 'x' is numeric, eg: `{ 'x': '1', 'y': 'helloworldabcde' }` is fine\r\n* doesn't seem to matter what the names of the fields are or what order they're in so long as there's at least one numeric one in addition to the varchar.\r\n* if you run it on more than one row, eg: `select fnord(1).y from (values (1), (2), (3))` only the first row is corrupted:\r\n```\r\n$ python test_duckdb_3.py \r\nVERSION: 1.1.4-dev3393\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502     (fnord(1)).y      \u2502\r\n\u2502        varchar        \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 ????INVALID VALUE -\u2026  \u2502\r\n\u2502 helloworldabcde       \u2502\r\n\u2502 helloworldabcde       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\nThanks for the report, here is great. The duckdb_arrow repo is for Arrow IPC mainly",
  "created_at": "2025-01-09T11:49:22Z"
}