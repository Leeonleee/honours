{
  "repo": "duckdb/duckdb",
  "pull_number": 12899,
  "instance_id": "duckdb__duckdb-12899",
  "issue_numbers": [
    "12688"
  ],
  "base_commit": "9eb0e58a02dfcc65695932a7611958994c25b65e",
  "patch": "diff --git a/tools/juliapkg/src/statement.jl b/tools/juliapkg/src/statement.jl\nindex 64f41248ff02..8914e85411a3 100644\n--- a/tools/juliapkg/src/statement.jl\n+++ b/tools/juliapkg/src/statement.jl\n@@ -49,10 +49,11 @@ duckdb_bind_internal(stmt::Stmt, i::Integer, val::DateTime) =\n     duckdb_bind_timestamp(stmt.handle, i, value_to_duckdb(val));\n duckdb_bind_internal(stmt::Stmt, i::Integer, val::Missing) = duckdb_bind_null(stmt.handle, i);\n duckdb_bind_internal(stmt::Stmt, i::Integer, val::Nothing) = duckdb_bind_null(stmt.handle, i);\n-duckdb_bind_internal(stmt::Stmt, i::Integer, val::AbstractString) = duckdb_bind_varchar(stmt.handle, i, val);\n+duckdb_bind_internal(stmt::Stmt, i::Integer, val::AbstractString) =\n+    duckdb_bind_varchar_length(stmt.handle, i, val, ncodeunits(val));\n duckdb_bind_internal(stmt::Stmt, i::Integer, val::Vector{UInt8}) = duckdb_bind_blob(stmt.handle, i, val, sizeof(val));\n duckdb_bind_internal(stmt::Stmt, i::Integer, val::WeakRefString{UInt8}) =\n-    duckdb_bind_varchar(stmt.handle, i, val.ptr, val.len);\n+    duckdb_bind_varchar_length(stmt.handle, i, val.ptr, val.len);\n \n function duckdb_bind_internal(stmt::Stmt, i::Integer, val::Any)\n     println(val)\n",
  "test_patch": "diff --git a/tools/juliapkg/test/test_basic_queries.jl b/tools/juliapkg/test/test_basic_queries.jl\nindex 74c1befec11c..16c6a89ab8de 100644\n--- a/tools/juliapkg/test/test_basic_queries.jl\n+++ b/tools/juliapkg/test/test_basic_queries.jl\n@@ -71,6 +71,11 @@ SELECT '\ud83e\udd86\ud83c\udf5e\ud83e\udd86'\n     @test size(df, 1) == 5\n     @test isequal(df.s, [\"hello world\", missing, \"this is a long string\", \"obligatory m\u00fchleisen\", \"\ud83e\udd86\ud83c\udf5e\ud83e\udd86\"])\n \n+    for s in [\"foo\", \"\ud83e\udd86DB\", SubString(\"foobar\", 1, 3), SubString(\"\ud83e\udd86ling\", 1, 6)]\n+        results = DBInterface.execute(con, \"SELECT length(?) as len\", [s])\n+        @test only(results).len == 3\n+    end\n+\n     DBInterface.close!(con)\n end\n \n",
  "problem_statement": "DuckDB.jl `execute` doesn't like non-null terminated strings\n### What happens?\n\n[If I call `DBInterface.execute` with some string bind parameters, that aren't null terminated (e.g., `SubString`s), the call doesn't work as expected. DuckDB ignores the stored length of the string, and parses the parameter up to the null termination (wherever that may be).\n\n### To Reproduce\n\nHere's a somewhat contrived MVP:\r\n\r\n```julia\r\njulia> using DuckDB\r\njulia> db = DuckDB.DB()\r\njulia> only(DBInterface.execute(db, \"SELECT length(?) as len\", [\"foo\"])).len\r\n3\r\n\r\njulia> only(DBInterface.execute(db, \"SELECT length(?) as len\", [SubString(\"foobar\", 1:3)])).len\r\n6\r\n```\r\n\r\nThe last call should also return 3.\r\n\r\nAs a workaround, one can explicitly cast the bind argument to `String`, which makes it null terminated:\r\n\r\n```julia\r\njulia> only(DBInterface.execute(db, \"SELECT length(?) as len\", [String(SubString(\"foobar\", 1:3))])).len\r\n3\r\n```\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\n1.0.0\n\n### DuckDB Client:\n\nJulia\n\n### Full Name:\n\nDavid Hanak\n\n### Affiliation:\n\nCursor Insight\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nNot applicable - the reproduction does not require a data set\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "There is a c api function `duckdb_bind_varchar_length` which maybe could be used inside `duckdb_bind_internal(stmt::Stmt, i::Integer, val::AbstractString)` instead of the  existing `duckdb_bind_varchar`.  \r\n\r\nAlternatively you could define a new duckdb_bind_internal for SubString{String} which would use `duckdb_bind_varchar_length` instead of `duckdb_bind_varchar`.  \r\n\r\nI think that is how the method for WeakStringRef was supposed to be implemented, but it looks like that implementation doesn't work because it passes the len argument to wrong function.\r\n\r\n\nHi @dhanak, thanks for opening this issue. Unfortunately the Julia client is not covered by [DuckDB's community support](https://duckdblabs.com/news/2023/10/02/support-policy#apis). Therefore, there are no plans to fix this issue at the moment. Of course, we very much welcome pull requests fixing the issue!\nHi Gabor! Noted, thanks. I'll see if I can submit a patch based on the comments above.",
  "created_at": "2024-07-08T14:53:52Z"
}