{
  "repo": "duckdb/duckdb",
  "pull_number": 11436,
  "instance_id": "duckdb__duckdb-11436",
  "issue_numbers": [
    "11393",
    "11393"
  ],
  "base_commit": "86e0f9ed812b5427b0b66893fb16ce528c4a9d31",
  "patch": "diff --git a/src/include/duckdb/planner/expression_binder/table_function_binder.hpp b/src/include/duckdb/planner/expression_binder/table_function_binder.hpp\nindex 46dbd1fddede..9e14a852e255 100644\n--- a/src/include/duckdb/planner/expression_binder/table_function_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder/table_function_binder.hpp\n@@ -15,14 +15,17 @@ namespace duckdb {\n //! The table function binder can bind standard table function parameters (i.e., non-table-in-out functions)\n class TableFunctionBinder : public ExpressionBinder {\n public:\n-\tTableFunctionBinder(Binder &binder, ClientContext &context);\n+\tTableFunctionBinder(Binder &binder, ClientContext &context, string table_function_name = string());\n \n protected:\n \tBindResult BindLambdaReference(LambdaRefExpression &expr, idx_t depth);\n-\tBindResult BindColumnReference(ColumnRefExpression &expr, idx_t depth, bool root_expression);\n+\tBindResult BindColumnReference(unique_ptr<ParsedExpression> &expr, idx_t depth, bool root_expression);\n \tBindResult BindExpression(unique_ptr<ParsedExpression> &expr, idx_t depth, bool root_expression = false) override;\n \n \tstring UnsupportedAggregateMessage() override;\n+\n+private:\n+\tstring table_function_name;\n };\n \n } // namespace duckdb\ndiff --git a/src/planner/binder/tableref/bind_table_function.cpp b/src/planner/binder/tableref/bind_table_function.cpp\nindex 2596243204a1..9d51bf08f52d 100644\n--- a/src/planner/binder/tableref/bind_table_function.cpp\n+++ b/src/planner/binder/tableref/bind_table_function.cpp\n@@ -102,7 +102,7 @@ bool Binder::BindTableFunctionParameters(TableFunctionCatalogEntry &table_functi\n \t\t\tcontinue;\n \t\t}\n \n-\t\tTableFunctionBinder binder(*this, context);\n+\t\tTableFunctionBinder binder(*this, context, table_function.name);\n \t\tLogicalType sql_type;\n \t\tauto expr = binder.Bind(child, &sql_type);\n \t\tif (expr->HasParameter()) {\ndiff --git a/src/planner/expression_binder/table_function_binder.cpp b/src/planner/expression_binder/table_function_binder.cpp\nindex 98a73ed364a2..7f20e9c36d15 100644\n--- a/src/planner/expression_binder/table_function_binder.cpp\n+++ b/src/planner/expression_binder/table_function_binder.cpp\n@@ -5,7 +5,8 @@\n \n namespace duckdb {\n \n-TableFunctionBinder::TableFunctionBinder(Binder &binder, ClientContext &context) : ExpressionBinder(binder, context) {\n+TableFunctionBinder::TableFunctionBinder(Binder &binder, ClientContext &context, string table_function_name_p)\n+    : ExpressionBinder(binder, context), table_function_name(std::move(table_function_name_p)) {\n }\n \n BindResult TableFunctionBinder::BindLambdaReference(LambdaRefExpression &expr, idx_t depth) {\n@@ -14,23 +15,34 @@ BindResult TableFunctionBinder::BindLambdaReference(LambdaRefExpression &expr, i\n \treturn (*lambda_bindings)[expr.lambda_idx].Bind(lambda_ref, depth);\n }\n \n-BindResult TableFunctionBinder::BindColumnReference(ColumnRefExpression &expr, idx_t depth, bool root_expression) {\n-\n+BindResult TableFunctionBinder::BindColumnReference(unique_ptr<ParsedExpression> &expr_ptr, idx_t depth,\n+                                                    bool root_expression) {\n \t// try binding as a lambda parameter\n-\tauto &col_ref = expr.Cast<ColumnRefExpression>();\n+\tauto &col_ref = expr_ptr->Cast<ColumnRefExpression>();\n \tif (!col_ref.IsQualified()) {\n \t\tauto lambda_ref = LambdaRefExpression::FindMatchingBinding(lambda_bindings, col_ref.GetName());\n \t\tif (lambda_ref) {\n \t\t\treturn BindLambdaReference(lambda_ref->Cast<LambdaRefExpression>(), depth);\n \t\t}\n \t}\n+\tauto column_names = col_ref.column_names;\n+\tauto result_name = StringUtil::Join(column_names, \".\");\n+\tif (!table_function_name.empty()) {\n+\t\t// check if this is a lateral join column/parameter\n+\t\tauto result = BindCorrelatedColumns(expr_ptr, ErrorData(\"error\"));\n+\t\tif (!result.HasError()) {\n+\t\t\t// it is a lateral join parameter - this is not supported in this type of table function\n+\t\t\tthrow BinderException(\"Table function \\\"%s\\\" does not support lateral join column parameters - cannot use \"\n+\t\t\t                      \"column \\\"%s\\\" in this context\",\n+\t\t\t                      table_function_name, result_name);\n+\t\t}\n+\t}\n \n-\tauto value_function = ExpressionBinder::GetSQLValueFunction(expr.GetColumnName());\n+\tauto value_function = ExpressionBinder::GetSQLValueFunction(column_names.back());\n \tif (value_function) {\n \t\treturn BindExpression(value_function, depth, root_expression);\n \t}\n \n-\tauto result_name = StringUtil::Join(expr.column_names, \".\");\n \treturn BindResult(make_uniq<BoundConstantExpression>(Value(result_name)));\n }\n \n@@ -41,7 +53,7 @@ BindResult TableFunctionBinder::BindExpression(unique_ptr<ParsedExpression> &exp\n \tcase ExpressionClass::LAMBDA_REF:\n \t\treturn BindLambdaReference(expr.Cast<LambdaRefExpression>(), depth);\n \tcase ExpressionClass::COLUMN_REF:\n-\t\treturn BindColumnReference(expr.Cast<ColumnRefExpression>(), depth, root_expression);\n+\t\treturn BindColumnReference(expr_ptr, depth, root_expression);\n \tcase ExpressionClass::SUBQUERY:\n \t\tthrow BinderException(\"Table function cannot contain subqueries\");\n \tcase ExpressionClass::DEFAULT:\n",
  "test_patch": "diff --git a/test/sql/table_function/lateral_table_function.test b/test/sql/table_function/lateral_table_function.test\nnew file mode 100644\nindex 000000000000..18a429222110\n--- /dev/null\n+++ b/test/sql/table_function/lateral_table_function.test\n@@ -0,0 +1,17 @@\n+# name: test/sql/table_function/lateral_table_function.test\n+# description: Test lateral join table function parameters for functions that do not support it\n+# group: [table_function]\n+\n+statement ok\n+pragma enable_verification\n+\n+statement error\n+SELECT * FROM read_csv(thisishopefullyanonexistentfile)\n+----\n+No files found that match the pattern\n+\n+# lateral join parameter\n+statement error\n+SELECT * FROM (SELECT 'myfile.csv' AS thisishopefullyanonexistentfile), read_csv(thisishopefullyanonexistentfile)\n+----\n+does not support lateral join column parameters\n",
  "problem_statement": "Cannot reference column from CTE in a set returning function\n### What happens?\n\nI want to call the `range` function on an integer that is produced by an expensive computation. This integer will also be used in other places as well, so I don't want to run the expensive computation multiple times. A CTE seemed like the right choice here, but I cannot reference the column from the CTE in `FROM`.\n\n### To Reproduce\n\nJust try to run this very minimal example (no setup is required):\r\n```\r\nWITH t1(a) AS (SELECT 7) SELECT * FROM t1, generate_series(1, a)\r\n```\r\nThis works fine on postgres & sqlite. But on duckdb, I get this error:\r\n```\r\nBinder Error: No function matches the given name and argument types 'generate_series(INTEGER, VARCHAR)'. You might need to add explicit type casts.\r\n\tCandidate functions:\r\n\tgenerate_series(BIGINT)\r\n\tgenerate_series(BIGINT, BIGINT)\r\n\tgenerate_series(BIGINT, BIGINT, BIGINT)\r\n\tgenerate_series(TIMESTAMP, TIMESTAMP, INTERVAL)\r\n\tgenerate_series(TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH TIME ZONE, INTERVAL)\r\n\r\nLINE 1: ... t1(a) AS (SELECT 7) SELECT * FROM t1, generate_series(1, a);\r\n                                                  ^\r\n```\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\nv0.10.1 4a89d97db8 & nightly v0.10.2-dev263 9247deefc8\n\n### DuckDB Client:\n\nduckdb shell\n\n### Full Name:\n\nJohn Doe\n\n### Affiliation:\n\nOracle\n\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\n\nI have tested with a nightly build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\nCannot reference column from CTE in a set returning function\n### What happens?\n\nI want to call the `range` function on an integer that is produced by an expensive computation. This integer will also be used in other places as well, so I don't want to run the expensive computation multiple times. A CTE seemed like the right choice here, but I cannot reference the column from the CTE in `FROM`.\n\n### To Reproduce\n\nJust try to run this very minimal example (no setup is required):\r\n```\r\nWITH t1(a) AS (SELECT 7) SELECT * FROM t1, generate_series(1, a)\r\n```\r\nThis works fine on postgres & sqlite. But on duckdb, I get this error:\r\n```\r\nBinder Error: No function matches the given name and argument types 'generate_series(INTEGER, VARCHAR)'. You might need to add explicit type casts.\r\n\tCandidate functions:\r\n\tgenerate_series(BIGINT)\r\n\tgenerate_series(BIGINT, BIGINT)\r\n\tgenerate_series(BIGINT, BIGINT, BIGINT)\r\n\tgenerate_series(TIMESTAMP, TIMESTAMP, INTERVAL)\r\n\tgenerate_series(TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH TIME ZONE, INTERVAL)\r\n\r\nLINE 1: ... t1(a) AS (SELECT 7) SELECT * FROM t1, generate_series(1, a);\r\n                                                  ^\r\n```\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\nv0.10.1 4a89d97db8 & nightly v0.10.2-dev263 9247deefc8\n\n### DuckDB Client:\n\nduckdb shell\n\n### Full Name:\n\nJohn Doe\n\n### Affiliation:\n\nOracle\n\n### Have you tried this on the latest [nightly build](https://duckdb.org/docs/installation/?version=main)?\n\nI have tested with a nightly build\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] Yes, I have\n",
  "hints_text": "An additional experiment: Since it is complaining that the second argument of `generate_series` is a `VARCHAR`, let's try to explicitly cast it to an `int`:\r\n```\r\n> WITH t1(a) AS (SELECT 7) SELECT * FROM t1, generate_series(1, a::int);\r\nConversion Error: Could not convert string 'a' to INT32\r\nLINE 1: ... SELECT * FROM t1, generate_series(1, a::int);\r\n                                                  ^\r\n```\r\nSo it thinks that the column name, i.e. `a`, is the string `'a'`!\nAlso:\r\n```\r\n> SELECT * FROM (SELECT 7 AS a) t1, generate_series(1, a);\r\nBinder Error: No function matches the given name and argument types 'generate_series(INTEGER, VARCHAR)'. You might need to add explicit type casts.\r\n\tCandidate functions:\r\n\tgenerate_series(BIGINT)\r\n\tgenerate_series(BIGINT, BIGINT)\r\n\tgenerate_series(BIGINT, BIGINT, BIGINT)\r\n\tgenerate_series(TIMESTAMP, TIMESTAMP, INTERVAL)\r\n\tgenerate_series(TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH TIME ZONE, INTERVAL)\r\n\r\nLINE 1: SELECT * FROM (SELECT 7 AS a) t1, generate_series(1, a);\r\n                                          ^\r\n```\r\nSo it is not specific to CTEs as I originally thought.\nThis is a known issue currently. See also: https://github.com/duckdb/duckdb/issues/10927. It is currently not possible to use columns of the (here: implicit) lateral join as input parameters.\n> I don't want to run the expensive computation multiple times. A CTE seemed like the right choice [...]\r\n\r\nA non-materialized CTE will not do what you are trying to achieve. You will have to use a materialized CTE:\r\n\r\n```\r\nWITH t1(a) AS MATERIALIZED [...]\r\n```\nAn additional experiment: Since it is complaining that the second argument of `generate_series` is a `VARCHAR`, let's try to explicitly cast it to an `int`:\r\n```\r\n> WITH t1(a) AS (SELECT 7) SELECT * FROM t1, generate_series(1, a::int);\r\nConversion Error: Could not convert string 'a' to INT32\r\nLINE 1: ... SELECT * FROM t1, generate_series(1, a::int);\r\n                                                  ^\r\n```\r\nSo it thinks that the column name, i.e. `a`, is the string `'a'`!\nAlso:\r\n```\r\n> SELECT * FROM (SELECT 7 AS a) t1, generate_series(1, a);\r\nBinder Error: No function matches the given name and argument types 'generate_series(INTEGER, VARCHAR)'. You might need to add explicit type casts.\r\n\tCandidate functions:\r\n\tgenerate_series(BIGINT)\r\n\tgenerate_series(BIGINT, BIGINT)\r\n\tgenerate_series(BIGINT, BIGINT, BIGINT)\r\n\tgenerate_series(TIMESTAMP, TIMESTAMP, INTERVAL)\r\n\tgenerate_series(TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH TIME ZONE, INTERVAL)\r\n\r\nLINE 1: SELECT * FROM (SELECT 7 AS a) t1, generate_series(1, a);\r\n                                          ^\r\n```\r\nSo it is not specific to CTEs as I originally thought.\nThis is a known issue currently. See also: https://github.com/duckdb/duckdb/issues/10927. It is currently not possible to use columns of the (here: implicit) lateral join as input parameters.\n> I don't want to run the expensive computation multiple times. A CTE seemed like the right choice [...]\r\n\r\nA non-materialized CTE will not do what you are trying to achieve. You will have to use a materialized CTE:\r\n\r\n```\r\nWITH t1(a) AS MATERIALIZED [...]\r\n```",
  "created_at": "2024-03-30T14:23:13Z"
}