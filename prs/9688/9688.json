{
  "repo": "duckdb/duckdb",
  "pull_number": 9688,
  "instance_id": "duckdb__duckdb-9688",
  "issue_numbers": [
    "9431"
  ],
  "base_commit": "c92602b864a09717b56843ae0811d85914509a9a",
  "patch": "diff --git a/src/core_functions/scalar/date/to_interval.cpp b/src/core_functions/scalar/date/to_interval.cpp\nindex 5227272b47e9..4a0ee656cc4f 100644\n--- a/src/core_functions/scalar/date/to_interval.cpp\n+++ b/src/core_functions/scalar/date/to_interval.cpp\n@@ -1,6 +1,7 @@\n #include \"duckdb/core_functions/scalar/date_functions.hpp\"\n #include \"duckdb/common/types/interval.hpp\"\n #include \"duckdb/common/operator/multiply.hpp\"\n+#include \"duckdb/core_functions/to_interval.hpp\"\n \n namespace duckdb {\n \n@@ -68,20 +69,6 @@ struct ToMinutesOperator {\n \t}\n };\n \n-struct ToSecondsOperator {\n-\ttemplate <class TA, class TR>\n-\tstatic inline TR Operation(TA input) {\n-\t\tinterval_t result;\n-\t\tresult.months = 0;\n-\t\tresult.days = 0;\n-\t\tif (!TryMultiplyOperator::Operation<int64_t, int64_t, int64_t>(input, Interval::MICROS_PER_SEC,\n-\t\t                                                               result.micros)) {\n-\t\t\tthrow OutOfRangeException(\"Interval value %d seconds out of range\", input);\n-\t\t}\n-\t\treturn result;\n-\t}\n-};\n-\n struct ToMilliSecondsOperator {\n \ttemplate <class TA, class TR>\n \tstatic inline TR Operation(TA input) {\ndiff --git a/src/include/duckdb/core_functions/to_interval.hpp b/src/include/duckdb/core_functions/to_interval.hpp\nnew file mode 100644\nindex 000000000000..300b5fc3b672\n--- /dev/null\n+++ b/src/include/duckdb/core_functions/to_interval.hpp\n@@ -0,0 +1,30 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/core_functions/to_interval.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/function/function_set.hpp\"\n+#include \"duckdb/common/operator/multiply.hpp\"\n+\n+namespace duckdb {\n+\n+struct ToSecondsOperator {\n+\ttemplate <class TA, class TR>\n+\tstatic inline TR Operation(TA input) {\n+\t\tinterval_t result;\n+\t\tresult.months = 0;\n+\t\tresult.days = 0;\n+\t\tif (!TryMultiplyOperator::Operation<int64_t, int64_t, int64_t>(input, Interval::MICROS_PER_SEC,\n+\t\t                                                               result.micros)) {\n+\t\t\tthrow OutOfRangeException(\"Interval value %d seconds out of range\", input);\n+\t\t}\n+\t\treturn result;\n+\t}\n+};\n+\n+} // namespace duckdb\ndiff --git a/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp b/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp\nindex 4ad5cfe26232..cda87259789c 100644\n--- a/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp\n+++ b/tools/pythonpkg/src/include/duckdb_python/python_objects.hpp\n@@ -110,8 +110,8 @@ struct PyDecimal {\n struct PyTimeDelta {\n public:\n \tPyTimeDelta(py::handle &obj);\n-\tint64_t days;\n-\tint64_t seconds;\n+\tint32_t days;\n+\tint32_t seconds;\n \tint64_t microseconds;\n \n public:\ndiff --git a/tools/pythonpkg/src/native/python_objects.cpp b/tools/pythonpkg/src/native/python_objects.cpp\nindex fc3e707774aa..fd2f06555f67 100644\n--- a/tools/pythonpkg/src/native/python_objects.cpp\n+++ b/tools/pythonpkg/src/native/python_objects.cpp\n@@ -7,6 +7,8 @@\n #include \"duckdb/common/types/cast_helpers.hpp\"\n #include \"duckdb/common/operator/cast_operators.hpp\"\n #include \"duckdb_python/pyconnection/pyconnection.hpp\"\n+#include \"duckdb/common/operator/add.hpp\"\n+#include \"duckdb/core_functions/to_interval.hpp\"\n \n #include \"datetime.h\" // Python datetime initialize #1\n \n@@ -26,19 +28,17 @@ PyTimeDelta::PyTimeDelta(py::handle &obj) {\n }\n \n interval_t PyTimeDelta::ToInterval() {\n-\tinterval_t interval;\n+\tinterval_t result;\n \n-\t// Timedelta stores any amount of seconds lower than a day only\n-\tD_ASSERT(seconds < Interval::SECS_PER_DAY);\n+\tauto micros_interval = Interval::FromMicro(microseconds);\n+\tauto days_interval = interval_t {/*months = */ 0,\n+\t                                 /*days = */ days,\n+\t                                 /*micros = */ 0};\n+\tauto seconds_interval = ToSecondsOperator::Operation<int64_t, interval_t>(seconds);\n \n-\t// Convert overflow of days to months\n-\tinterval.months = days / Interval::DAYS_PER_MONTH;\n-\tdays -= interval.months * Interval::DAYS_PER_MONTH;\n-\n-\tmicroseconds += seconds * Interval::MICROS_PER_SEC;\n-\tinterval.days = days;\n-\tinterval.micros = microseconds;\n-\treturn interval;\n+\tresult = AddOperator::Operation<interval_t, interval_t, interval_t>(micros_interval, days_interval);\n+\tresult = AddOperator::Operation<interval_t, interval_t, interval_t>(result, seconds_interval);\n+\treturn result;\n }\n \n int64_t PyTimeDelta::GetDays(py::handle &obj) {\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/pandas/test_timedelta.py b/tools/pythonpkg/tests/fast/pandas/test_timedelta.py\nindex 4737cfbe9b5f..c376cee6f565 100644\n--- a/tools/pythonpkg/tests/fast/pandas/test_timedelta.py\n+++ b/tools/pythonpkg/tests/fast/pandas/test_timedelta.py\n@@ -15,7 +15,7 @@ def test_timedelta_positive(self, duckdb_cursor):\n         df_out = duckdb.query_df(df_in, \"df\", \"select * from df\").df()\n         pd.testing.assert_frame_equal(df_out, duckdb_interval)\n \n-    def test_timedelta_coverage(self, duckdb_cursor):\n+    def test_timedelta_basic(self, duckdb_cursor):\n         duckdb_interval = duckdb.query(\n             \"SELECT '2290-08-30 23:53:40'::TIMESTAMP - '2000-02-01 01:56:00'::TIMESTAMP AS '0'\"\n         ).df()\n@@ -32,3 +32,52 @@ def test_timedelta_negative(self, duckdb_cursor):\n         df_in = pd.DataFrame({0: pd.Series(data=data, dtype='object')})\n         df_out = duckdb.query_df(df_in, \"df\", \"select * from df\").df()\n         pd.testing.assert_frame_equal(df_out, duckdb_interval)\n+\n+    @pytest.mark.parametrize('days', [1, 9999])\n+    @pytest.mark.parametrize('seconds', [0, 60])\n+    @pytest.mark.parametrize(\n+        'microseconds',\n+        [\n+            0,\n+            232493,\n+            999_999,\n+        ],\n+    )\n+    @pytest.mark.parametrize('milliseconds', [0, 999])\n+    @pytest.mark.parametrize('minutes', [0, 60])\n+    @pytest.mark.parametrize('hours', [0, 24])\n+    @pytest.mark.parametrize('weeks', [0, 51])\n+    def test_timedelta_coverage(self, duckdb_cursor, days, seconds, microseconds, milliseconds, minutes, hours, weeks):\n+        def create_duck_interval(days, seconds, microseconds, milliseconds, minutes, hours, weeks) -> str:\n+            instant = f\"\"\"\n+                (INTERVAL {days + (weeks * 7)} DAYS +\n+                INTERVAL {seconds} SECONDS +\n+                INTERVAL {microseconds} MICROSECONDS +\n+                INTERVAL {milliseconds} MILLISECONDS +\n+                INTERVAL {minutes} MINUTE +\n+                INTERVAL {hours} HOURS)\n+            \"\"\"\n+            return instant\n+\n+        def create_python_interval(\n+            days, seconds, microseconds, milliseconds, minutes, hours, weeks\n+        ) -> datetime.timedelta:\n+            return datetime.timedelta(days, seconds, microseconds, milliseconds, minutes, hours, weeks)\n+\n+        duck_interval = create_duck_interval(days, seconds, microseconds, milliseconds, minutes, hours, weeks)\n+\n+        query = \"select '1990/02/11'::DATE - {value}, '1990/02/11'::DATE - $1\"\n+        query = query.format(value=duck_interval)\n+\n+        val = create_python_interval(days, seconds, microseconds, milliseconds, minutes, hours, weeks)\n+        a, b = duckdb_cursor.execute(query, [val]).fetchone()\n+        assert a == b\n+\n+        equality = \"select {value} = $1, {value}, $1\"\n+        equality = equality.format(value=duck_interval)\n+        res, a, b = duckdb_cursor.execute(equality, [val]).fetchone()\n+        if res != True:\n+            # FIXME: in some cases intervals that are identical don't compare equal.\n+            assert a == b\n+        else:\n+            assert res == True\n",
  "problem_statement": "Python interval bindings gain extra days\n### What happens?\r\n\r\nUsing the python `datetime.timedelta` parameter binding results in longer intervals when compared to duckdb's built-in `INTERVAL`.\r\n\r\n### To Reproduce\r\n\r\n```python\r\nfrom datetime import timedelta\r\nimport duckdb\r\nc = duckdb.connect()\r\nc.execute(\"set timezone='UTC'\")\r\n```\r\n```\r\n<duckdb.duckdb.DuckDBPyConnection object at 0x10521fd70>\r\n```\r\n```python\r\na, b = c.execute(\"select current_date() - INTERVAL 5 days, current_date() - $1\", [timedelta(days=5)]).fetchone(); print(a-b)\r\n```\r\n```\r\n0:00:00\r\n```\r\n```python\r\na, b = c.execute(\"select current_date() - INTERVAL 70 days, current_date() - $1\", [timedelta(days=70)]).fetchone(); print(a-b)\r\n```\r\n```\r\n1 day, 0:00:00\r\n```\r\n```python\r\na, b = c.execute(\"select current_date() - INTERVAL 200 days, current_date() - $1\", [timedelta(days=200)]).fetchone(); print(a-b)\r\n```\r\n```\r\n3 days, 0:00:00\r\n```\r\n\r\nHowever just comparing the intervals directly shows no issue:\r\n```python\r\nc.execute(\"select (INTERVAL 200 days) - $1\", [timedelta(days=200)]).fetchone()\r\n```\r\n```\r\n(datetime.timedelta(0),)\r\n```\r\n\r\n### OS:\r\n\r\nMacOS 13.5.2\r\n\r\n### DuckDB Version:\r\n\r\n0.9.1\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nAlexander Vandenberg-Rodes\r\n\r\n### Affiliation:\r\n\r\nObsidian Security\r\n\r\n### Have you tried this on the latest `main` branch?\r\n\r\nI have tested with a main build\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2023-11-15T12:32:14Z"
}