{
  "repo": "duckdb/duckdb",
  "pull_number": 7718,
  "instance_id": "duckdb__duckdb-7718",
  "issue_numbers": [
    "7699"
  ],
  "base_commit": "d636ce2d5925285b976c536a65c1e274ae53e273",
  "patch": "diff --git a/src/function/table/arrow.cpp b/src/function/table/arrow.cpp\nindex 03aacbabf810..33058e7196c8 100644\n--- a/src/function/table/arrow.cpp\n+++ b/src/function/table/arrow.cpp\n@@ -206,8 +206,8 @@ unique_ptr<FunctionData> ArrowTableFunction::ArrowScanBind(ClientContext &contex\n \t\t\tthrow InvalidInputException(\"arrow_scan: released schema passed\");\n \t\t}\n \t\tif (schema.dictionary) {\n-\t\t\tres->arrow_convert_data[col_idx] =\n-\t\t\t    make_uniq<ArrowConvertData>(GetArrowLogicalType(schema, res->arrow_convert_data, col_idx));\n+\t\t\tauto logical_type = GetArrowLogicalType(schema, res->arrow_convert_data, col_idx);\n+\t\t\tres->arrow_convert_data[col_idx] = make_uniq<ArrowConvertData>(std::move(logical_type));\n \t\t\treturn_types.emplace_back(GetArrowLogicalType(*schema.dictionary, res->arrow_convert_data, col_idx));\n \t\t} else {\n \t\t\treturn_types.emplace_back(GetArrowLogicalType(schema, res->arrow_convert_data, col_idx));\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/arrow/test_7699.py b/tools/pythonpkg/tests/fast/arrow/test_7699.py\nnew file mode 100644\nindex 000000000000..8e3996026d51\n--- /dev/null\n+++ b/tools/pythonpkg/tests/fast/arrow/test_7699.py\n@@ -0,0 +1,22 @@\n+import duckdb\n+import pytest\n+import string\n+\n+pa = pytest.importorskip(\"pyarrow\")\n+pq = pytest.importorskip(\"pyarrow.parquet\")\n+pl = pytest.importorskip(\"polars\")\n+\n+class Test7699(object):\n+    def test_7699(self):\n+        pl_tbl = pl.DataFrame({\n+            \"col1\" : pl.Series([\n+                string.ascii_uppercase[ix+10] for ix in list(range(2)) + list(range(3))\n+            ]).cast(pl.Categorical),\n+        })\n+\n+        nickname = \"df1234\"\n+        duckdb.register(nickname, pl_tbl)\n+\n+        rel = duckdb.sql(\"select * from df1234\")\n+        res = rel.fetchall()\n+        assert res == [('K',), ('L',), ('K',), ('L',), ('M',)]\n",
  "problem_statement": "`duckdb.register` on aarch64: INTERNAL Error: Attempted to dereference unique_ptr that is NULL!\n### What happens?\n\nIn the Python interface, if I try to register a polars object having a column with categorical type in an aarch64 platform, DuckDB will throw an error about attempting to dereference a null pointer.\r\n\r\nSwapping the call from `duckdb.register` to `duckdb.query` with \"create view\" doesn't error out immediately, but produces an error later on once a selection query is executed on the view.\r\n\r\nExecuting the same code on an amd64 platform doesn't produce any error, but I'm not sure if it's because the prebuilt wheels disable safety macros or because there is no error.\n\n### To Reproduce\n\nCode to reproduce:\r\n```python\r\nimport polars as pl, duckdb, string\r\npl_tbl = pl.DataFrame({\r\n    \"col1\" : pl.Series([\r\n        string.ascii_uppercase[ix+10] for ix in list(range(2)) + list(range(3))\r\n    ]).cast(pl.Categorical),\r\n})\r\n\r\nnickname = \"df1234\"\r\nduckdb.register(nickname, pl_tbl)\r\n```\r\n\r\nIn case it helps, a Dockerfile to execute it on amd64 through qemu (assuming the file is saved as `crasher.py`):\r\n```\r\nFROM arm64v8/debian:bullseye\r\nSHELL [\"/bin/bash\", \"-c\"]\r\nRUN apt-get update && apt-get install python3 python3-pip gcc g++\r\nRUN python3 -m pip install polars pyarrow\r\nRUN python3 -m pip install --pre duckdb\r\nCOPY crasher.py /crasher.py\r\nENTRYPOINT [\"python3\", \"/crasher.py\"]\r\n```\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\n0.8.1.dev96\n\n### DuckDB Client:\n\nPython\n\n### Full Name:\n\nDavid Cortes\n\n### Affiliation:\n\nNone\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "> Executing the same code on an amd64 platform doesn't produce any error, but I'm not sure if it's because the prebuilt wheels disable safety macros or because there is no error.\r\n\r\nSince 0.8.0 we enable all safety macros in release builds, so that shouldn't be the case.",
  "created_at": "2023-05-28T12:55:49Z"
}