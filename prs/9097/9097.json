{
  "repo": "duckdb/duckdb",
  "pull_number": 9097,
  "instance_id": "duckdb__duckdb-9097",
  "issue_numbers": [
    "7709"
  ],
  "base_commit": "7ffdb9fd0e5e17d1638796c5352fbc839da4da5d",
  "patch": "diff --git a/extension/json/serialize_json.cpp b/extension/json/serialize_json.cpp\nindex b531d5c0c024..9802488a89ec 100644\n--- a/extension/json/serialize_json.cpp\n+++ b/extension/json/serialize_json.cpp\n@@ -12,51 +12,51 @@\n namespace duckdb {\n \n void BufferedJSONReaderOptions::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"format\", format);\n-\tserializer.WriteProperty(101, \"record_type\", record_type);\n-\tserializer.WriteProperty(102, \"compression\", compression);\n-\tserializer.WriteProperty(103, \"file_options\", file_options);\n+\tserializer.WriteProperty<JSONFormat>(100, \"format\", format);\n+\tserializer.WriteProperty<JSONRecordType>(101, \"record_type\", record_type);\n+\tserializer.WriteProperty<FileCompressionType>(102, \"compression\", compression);\n+\tserializer.WriteProperty<MultiFileReaderOptions>(103, \"file_options\", file_options);\n }\n \n BufferedJSONReaderOptions BufferedJSONReaderOptions::Deserialize(Deserializer &deserializer) {\n \tBufferedJSONReaderOptions result;\n-\tdeserializer.ReadProperty(100, \"format\", result.format);\n-\tdeserializer.ReadProperty(101, \"record_type\", result.record_type);\n-\tdeserializer.ReadProperty(102, \"compression\", result.compression);\n-\tdeserializer.ReadProperty(103, \"file_options\", result.file_options);\n+\tdeserializer.ReadProperty<JSONFormat>(100, \"format\", result.format);\n+\tdeserializer.ReadProperty<JSONRecordType>(101, \"record_type\", result.record_type);\n+\tdeserializer.ReadProperty<FileCompressionType>(102, \"compression\", result.compression);\n+\tdeserializer.ReadProperty<MultiFileReaderOptions>(103, \"file_options\", result.file_options);\n \treturn result;\n }\n \n void JSONScanData::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"json_type\", type);\n-\tserializer.WriteProperty(101, \"options\", options);\n-\tserializer.WriteProperty(102, \"reader_bind\", reader_bind);\n-\tserializer.WriteProperty(103, \"files\", files);\n-\tserializer.WriteProperty(104, \"ignore_errors\", ignore_errors);\n-\tserializer.WriteProperty(105, \"maximum_object_size\", maximum_object_size);\n-\tserializer.WriteProperty(106, \"auto_detect\", auto_detect);\n-\tserializer.WriteProperty(107, \"sample_size\", sample_size);\n-\tserializer.WriteProperty(108, \"max_depth\", max_depth);\n-\tserializer.WriteProperty(109, \"transform_options\", transform_options);\n-\tserializer.WriteProperty(110, \"names\", names);\n-\tserializer.WriteProperty(111, \"date_format\", GetDateFormat());\n-\tserializer.WriteProperty(112, \"timestamp_format\", GetTimestampFormat());\n+\tserializer.WriteProperty<JSONScanType>(100, \"json_type\", type);\n+\tserializer.WriteProperty<BufferedJSONReaderOptions>(101, \"options\", options);\n+\tserializer.WriteProperty<MultiFileReaderBindData>(102, \"reader_bind\", reader_bind);\n+\tserializer.WritePropertyWithDefault<vector<string>>(103, \"files\", files);\n+\tserializer.WritePropertyWithDefault<bool>(104, \"ignore_errors\", ignore_errors);\n+\tserializer.WritePropertyWithDefault<idx_t>(105, \"maximum_object_size\", maximum_object_size);\n+\tserializer.WritePropertyWithDefault<bool>(106, \"auto_detect\", auto_detect);\n+\tserializer.WritePropertyWithDefault<idx_t>(107, \"sample_size\", sample_size);\n+\tserializer.WritePropertyWithDefault<idx_t>(108, \"max_depth\", max_depth);\n+\tserializer.WriteProperty<JSONTransformOptions>(109, \"transform_options\", transform_options);\n+\tserializer.WritePropertyWithDefault<vector<string>>(110, \"names\", names);\n+\tserializer.WritePropertyWithDefault<string>(111, \"date_format\", GetDateFormat());\n+\tserializer.WritePropertyWithDefault<string>(112, \"timestamp_format\", GetTimestampFormat());\n }\n \n unique_ptr<JSONScanData> JSONScanData::Deserialize(Deserializer &deserializer) {\n \tauto type = deserializer.ReadProperty<JSONScanType>(100, \"json_type\");\n \tauto options = deserializer.ReadProperty<BufferedJSONReaderOptions>(101, \"options\");\n \tauto reader_bind = deserializer.ReadProperty<MultiFileReaderBindData>(102, \"reader_bind\");\n-\tauto files = deserializer.ReadProperty<vector<string>>(103, \"files\");\n-\tauto ignore_errors = deserializer.ReadProperty<bool>(104, \"ignore_errors\");\n-\tauto maximum_object_size = deserializer.ReadProperty<idx_t>(105, \"maximum_object_size\");\n-\tauto auto_detect = deserializer.ReadProperty<bool>(106, \"auto_detect\");\n-\tauto sample_size = deserializer.ReadProperty<idx_t>(107, \"sample_size\");\n-\tauto max_depth = deserializer.ReadProperty<idx_t>(108, \"max_depth\");\n+\tauto files = deserializer.ReadPropertyWithDefault<vector<string>>(103, \"files\");\n+\tauto ignore_errors = deserializer.ReadPropertyWithDefault<bool>(104, \"ignore_errors\");\n+\tauto maximum_object_size = deserializer.ReadPropertyWithDefault<idx_t>(105, \"maximum_object_size\");\n+\tauto auto_detect = deserializer.ReadPropertyWithDefault<bool>(106, \"auto_detect\");\n+\tauto sample_size = deserializer.ReadPropertyWithDefault<idx_t>(107, \"sample_size\");\n+\tauto max_depth = deserializer.ReadPropertyWithDefault<idx_t>(108, \"max_depth\");\n \tauto transform_options = deserializer.ReadProperty<JSONTransformOptions>(109, \"transform_options\");\n-\tauto names = deserializer.ReadProperty<vector<string>>(110, \"names\");\n-\tauto date_format = deserializer.ReadProperty<string>(111, \"date_format\");\n-\tauto timestamp_format = deserializer.ReadProperty<string>(112, \"timestamp_format\");\n+\tauto names = deserializer.ReadPropertyWithDefault<vector<string>>(110, \"names\");\n+\tauto date_format = deserializer.ReadPropertyWithDefault<string>(111, \"date_format\");\n+\tauto timestamp_format = deserializer.ReadPropertyWithDefault<string>(112, \"timestamp_format\");\n \tauto result = duckdb::unique_ptr<JSONScanData>(new JSONScanData(deserializer.Get<ClientContext &>(), std::move(files), std::move(date_format), std::move(timestamp_format)));\n \tresult->type = type;\n \tresult->options = options;\n@@ -72,20 +72,20 @@ unique_ptr<JSONScanData> JSONScanData::Deserialize(Deserializer &deserializer) {\n }\n \n void JSONTransformOptions::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"strict_cast\", strict_cast);\n-\tserializer.WriteProperty(101, \"error_duplicate_key\", error_duplicate_key);\n-\tserializer.WriteProperty(102, \"error_missing_key\", error_missing_key);\n-\tserializer.WriteProperty(103, \"error_unknown_key\", error_unknown_key);\n-\tserializer.WriteProperty(104, \"delay_error\", delay_error);\n+\tserializer.WritePropertyWithDefault<bool>(100, \"strict_cast\", strict_cast);\n+\tserializer.WritePropertyWithDefault<bool>(101, \"error_duplicate_key\", error_duplicate_key);\n+\tserializer.WritePropertyWithDefault<bool>(102, \"error_missing_key\", error_missing_key);\n+\tserializer.WritePropertyWithDefault<bool>(103, \"error_unknown_key\", error_unknown_key);\n+\tserializer.WritePropertyWithDefault<bool>(104, \"delay_error\", delay_error);\n }\n \n JSONTransformOptions JSONTransformOptions::Deserialize(Deserializer &deserializer) {\n \tJSONTransformOptions result;\n-\tdeserializer.ReadProperty(100, \"strict_cast\", result.strict_cast);\n-\tdeserializer.ReadProperty(101, \"error_duplicate_key\", result.error_duplicate_key);\n-\tdeserializer.ReadProperty(102, \"error_missing_key\", result.error_missing_key);\n-\tdeserializer.ReadProperty(103, \"error_unknown_key\", result.error_unknown_key);\n-\tdeserializer.ReadProperty(104, \"delay_error\", result.delay_error);\n+\tdeserializer.ReadPropertyWithDefault<bool>(100, \"strict_cast\", result.strict_cast);\n+\tdeserializer.ReadPropertyWithDefault<bool>(101, \"error_duplicate_key\", result.error_duplicate_key);\n+\tdeserializer.ReadPropertyWithDefault<bool>(102, \"error_missing_key\", result.error_missing_key);\n+\tdeserializer.ReadPropertyWithDefault<bool>(103, \"error_unknown_key\", result.error_unknown_key);\n+\tdeserializer.ReadPropertyWithDefault<bool>(104, \"delay_error\", result.delay_error);\n \treturn result;\n }\n \ndiff --git a/extension/parquet/serialize_parquet.cpp b/extension/parquet/serialize_parquet.cpp\nindex a9bba6b5f36e..5f0a0921f2a7 100644\n--- a/extension/parquet/serialize_parquet.cpp\n+++ b/extension/parquet/serialize_parquet.cpp\n@@ -10,16 +10,16 @@\n namespace duckdb {\n \n void ParquetOptions::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"binary_as_string\", binary_as_string);\n-\tserializer.WriteProperty(101, \"file_row_number\", file_row_number);\n-\tserializer.WriteProperty(102, \"file_options\", file_options);\n+\tserializer.WritePropertyWithDefault<bool>(100, \"binary_as_string\", binary_as_string);\n+\tserializer.WritePropertyWithDefault<bool>(101, \"file_row_number\", file_row_number);\n+\tserializer.WriteProperty<MultiFileReaderOptions>(102, \"file_options\", file_options);\n }\n \n ParquetOptions ParquetOptions::Deserialize(Deserializer &deserializer) {\n \tParquetOptions result;\n-\tdeserializer.ReadProperty(100, \"binary_as_string\", result.binary_as_string);\n-\tdeserializer.ReadProperty(101, \"file_row_number\", result.file_row_number);\n-\tdeserializer.ReadProperty(102, \"file_options\", result.file_options);\n+\tdeserializer.ReadPropertyWithDefault<bool>(100, \"binary_as_string\", result.binary_as_string);\n+\tdeserializer.ReadPropertyWithDefault<bool>(101, \"file_row_number\", result.file_row_number);\n+\tdeserializer.ReadProperty<MultiFileReaderOptions>(102, \"file_options\", result.file_options);\n \treturn result;\n }\n \ndiff --git a/scripts/generate_serialization.py b/scripts/generate_serialization.py\nindex b72261b6f1cf..2846c4bb59aa 100644\n--- a/scripts/generate_serialization.py\n+++ b/scripts/generate_serialization.py\n@@ -57,9 +57,7 @@\n ${MEMBERS}}\n '''\n \n-serialize_element = (\n-    '\\tserializer.WriteProperty(${PROPERTY_ID}, \"${PROPERTY_KEY}\", ${PROPERTY_NAME}${PROPERTY_DEFAULT});\\n'\n-)\n+serialize_element = '\\tserializer.WriteProperty<${PROPERTY_TYPE}>(${PROPERTY_ID}, \"${PROPERTY_KEY}\", ${PROPERTY_NAME}${PROPERTY_DEFAULT});\\n'\n \n base_serialize = '\\t${BASE_CLASS_NAME}::Serialize(serializer);\\n'\n \n@@ -91,7 +89,8 @@\n )\n \n deserialize_element = '\\tauto ${PROPERTY_NAME} = deserializer.ReadProperty<${PROPERTY_TYPE}>(${PROPERTY_ID}, \"${PROPERTY_KEY}\"${PROPERTY_DEFAULT});\\n'\n-deserialize_element_class = '\\tdeserializer.ReadProperty(${PROPERTY_ID}, \"${PROPERTY_KEY}\", result${ASSIGNMENT}${PROPERTY_NAME}${PROPERTY_DEFAULT});\\n'\n+deserialize_element_base = '\\tauto ${PROPERTY_NAME} = deserializer.ReadProperty<unique_ptr<${BASE_PROPERTY}>>(${PROPERTY_ID}, \"${PROPERTY_KEY}\"${PROPERTY_DEFAULT});\\n'\n+deserialize_element_class = '\\tdeserializer.ReadProperty<${PROPERTY_TYPE}>(${PROPERTY_ID}, \"${PROPERTY_KEY}\", result${ASSIGNMENT}${PROPERTY_NAME}${PROPERTY_DEFAULT});\\n'\n deserialize_element_class_base = '\\tauto ${PROPERTY_NAME} = deserializer.ReadProperty<unique_ptr<${BASE_PROPERTY}>>(${PROPERTY_ID}, \"${PROPERTY_KEY}\"${PROPERTY_DEFAULT});\\n\\tresult${ASSIGNMENT}${PROPERTY_NAME} = unique_ptr_cast<${BASE_PROPERTY}, ${DERIVED_PROPERTY}>(std::move(${PROPERTY_NAME}));\\n'\n \n move_list = [\n@@ -114,6 +113,23 @@ def is_pointer(type):\n     return type.endswith('*') or type.startswith('shared_ptr<')\n \n \n+def is_zeroable(type):\n+    return type in [\n+        'bool',\n+        'int8_t',\n+        'int16_t',\n+        'int32_t',\n+        'int64_t',\n+        'uint8_t',\n+        'uint16_t',\n+        'uint32_t',\n+        'uint64_t',\n+        'idx_t',\n+        'size_t',\n+        'int',\n+    ]\n+\n+\n def requires_move(type):\n     return is_container(type) or is_pointer(type) or type in move_list\n \n@@ -122,46 +138,73 @@ def replace_pointer(type):\n     return re.sub('([a-zA-Z0-9]+)[*]', 'unique_ptr<\\\\1>', type)\n \n \n-def get_serialize_element(property_name, property_id, property_key, property_type, is_optional, pointer_type):\n-    write_method = 'WriteProperty'\n+def get_serialize_element(\n+    property_name, property_id, property_key, property_type, has_default, default_value, is_deleted, pointer_type\n+):\n     assignment = '.' if pointer_type == 'none' else '->'\n-    default_argument = ''\n-    if is_optional:\n-        write_method = 'WritePropertyWithDefault'\n-        default_argument = f', {property_type}()'  # TODO: allow this to be passed\n+    default_argument = '' if default_value is None else f', {default_value}'\n+    template = serialize_element\n+    if is_deleted:\n+        template = \"\\t/* [Deleted] (${PROPERTY_TYPE}) \\\"${PROPERTY_NAME}\\\" */\\n\"\n+    elif has_default:\n+        template = template.replace('WriteProperty', 'WritePropertyWithDefault')\n     return (\n-        serialize_element.replace('${PROPERTY_NAME}', property_name)\n+        template.replace('${PROPERTY_NAME}', property_name)\n+        .replace('${PROPERTY_TYPE}', property_type)\n         .replace('${PROPERTY_ID}', str(property_id))\n         .replace('${PROPERTY_KEY}', property_key)\n         .replace('${PROPERTY_DEFAULT}', default_argument)\n-        .replace('WriteProperty', write_method)\n         .replace('${ASSIGNMENT}', assignment)\n     )\n \n \n def get_deserialize_element_template(\n-    template, property_name, property_key, property_id, property_type, is_optional, pointer_type\n+    template,\n+    property_name,\n+    property_key,\n+    property_id,\n+    property_type,\n+    has_default,\n+    default_value,\n+    is_deleted,\n+    pointer_type,\n ):\n-    read_method = 'ReadProperty'\n+    # read_method = 'ReadProperty'\n     assignment = '.' if pointer_type == 'none' else '->'\n-    default_argument = ''\n-    if is_optional:\n-        read_method = 'ReadPropertyWithDefault'\n-        default_argument = f', {property_type}()'  # TODO: allow this to be passed\n+    default_argument = '' if default_value is None else f', {default_value}'\n+    if is_deleted:\n+        template = template.replace(', result${ASSIGNMENT}${PROPERTY_NAME}', '').replace(\n+            'ReadProperty', 'ReadDeletedProperty'\n+        )\n+    elif has_default:\n+        template = template.replace('ReadProperty', 'ReadPropertyWithDefault')\n     return (\n         template.replace('${PROPERTY_NAME}', property_name)\n         .replace('${PROPERTY_KEY}', property_key)\n         .replace('${PROPERTY_ID}', str(property_id))\n         .replace('${PROPERTY_DEFAULT}', default_argument)\n-        .replace('ReadProperty', read_method)\n         .replace('${PROPERTY_TYPE}', property_type)\n         .replace('${ASSIGNMENT}', assignment)\n     )\n \n \n-def get_deserialize_element(property_name, property_key, property_id, property_type, is_optional, pointer_type):\n+def get_deserialize_element(\n+    property_name, property_key, property_id, property_type, has_default, default_value, is_deleted, base, pointer_type\n+):\n+    template = deserialize_element\n+    if base:\n+        template = deserialize_element_base.replace('${BASE_PROPERTY}', base.replace('*', ''))\n+\n     return get_deserialize_element_template(\n-        deserialize_element, property_name, property_key, property_id, property_type, is_optional, pointer_type\n+        template,\n+        property_name,\n+        property_key,\n+        property_id,\n+        property_type,\n+        has_default,\n+        default_value,\n+        is_deleted,\n+        pointer_type,\n     )\n \n \n@@ -200,18 +243,35 @@ def generate_return(class_entry):\n     'property',\n     'serialize_property',\n     'deserialize_property',\n-    'optional',\n     'base',\n+    'default',\n+    'deleted',\n ]\n \n \n+def has_default_by_default(type):\n+    if is_pointer(type):\n+        return True\n+    if is_container(type):\n+        if 'IndexVector' in type:\n+            return False\n+        return True\n+    if type == 'string':\n+        return True\n+    if is_zeroable(type):\n+        return True\n+    return False\n+\n+\n class MemberVariable:\n     def __init__(self, entry):\n         self.id = entry['id']\n         self.name = entry['name']\n         self.type = entry['type']\n         self.base = None\n-        self.optional = False\n+        self.has_default = False\n+        self.default = None\n+        self.deleted = False\n         if 'property' in entry:\n             self.serialize_property = entry['property']\n             self.deserialize_property = entry['property']\n@@ -222,8 +282,14 @@ def __init__(self, entry):\n             self.serialize_property = entry['serialize_property']\n         if 'deserialize_property' in entry:\n             self.deserialize_property = entry['deserialize_property']\n-        if 'optional' in entry:\n-            self.optional = entry['optional']\n+        if 'default' in entry:\n+            self.has_default = True\n+            self.default = entry['default']\n+        if 'deleted' in entry:\n+            self.deleted = entry['deleted']\n+        if self.default is None:\n+            # default default\n+            self.has_default = has_default_by_default(self.type)\n         if 'base' in entry:\n             self.base = entry['base']\n         for key in entry.keys():\n@@ -320,12 +386,27 @@ def generate_base_class_code(base_class):\n         type_name = replace_pointer(entry.type)\n         if entry.serialize_property == base_class.enum_value:\n             enum_type = entry.type\n-        is_optional = entry.optional\n+        default = entry.default\n         base_class_serialize += get_serialize_element(\n-            entry.serialize_property, entry.id, entry.name, type_name, is_optional, base_class.pointer_type\n+            entry.serialize_property,\n+            entry.id,\n+            entry.name,\n+            type_name,\n+            entry.has_default,\n+            default,\n+            entry.deleted,\n+            base_class.pointer_type,\n         )\n         base_class_deserialize += get_deserialize_element(\n-            entry.deserialize_property, entry.name, entry.id, type_name, is_optional, base_class.pointer_type\n+            entry.deserialize_property,\n+            entry.name,\n+            entry.id,\n+            type_name,\n+            entry.has_default,\n+            default,\n+            entry.deleted,\n+            None,\n+            base_class.pointer_type,\n         )\n     expressions = [x for x in base_class.children.items()]\n     expressions = sorted(expressions, key=lambda x: x[0])\n@@ -468,7 +549,15 @@ def generate_class_code(class_entry):\n         entry = class_entry.members[entry_idx]\n         type_name = replace_pointer(entry.type)\n         class_deserialize += get_deserialize_element(\n-            entry.deserialize_property, entry.name, entry.id, type_name, entry.optional, 'unique_ptr'\n+            entry.deserialize_property,\n+            entry.name,\n+            entry.id,\n+            type_name,\n+            entry.has_default,\n+            entry.default,\n+            entry.deleted,\n+            entry.base,\n+            'unique_ptr',\n         )\n \n     class_deserialize += generate_constructor(\n@@ -481,25 +570,22 @@ def generate_class_code(class_entry):\n         property_id = entry.id\n         property_key = entry.name\n         write_property_name = entry.serialize_property\n-        is_optional = entry.optional\n-        if is_pointer(entry.type):\n-            if not is_optional:\n-                # TODO: At ome point we should maybe add checks for non-optional pointers\n-                # for now nullable pointers are implicitly handled by providing default values\n-                pass\n-        elif is_optional:\n-            raise Exception(\n-                f\"Optional can only be combined with pointers (in {class_entry.name}, type {entry.type}, member {entry.type})\"\n-            )\n         deserialize_template_str = deserialize_element_class\n+        default_value = entry.default\n         if entry.base:\n-            write_property_name = f\"({entry.base} *)\" + write_property_name + \".get()\"\n             deserialize_template_str = deserialize_element_class_base.replace(\n                 '${BASE_PROPERTY}', entry.base.replace('*', '')\n             ).replace('${DERIVED_PROPERTY}', entry.type.replace('*', ''))\n         type_name = replace_pointer(entry.type)\n         class_serialize += get_serialize_element(\n-            write_property_name, property_id, property_key, type_name, is_optional, class_entry.pointer_type\n+            write_property_name,\n+            property_id,\n+            property_key,\n+            type_name,\n+            entry.has_default,\n+            default_value,\n+            entry.deleted,\n+            class_entry.pointer_type,\n         )\n         if entry_idx > last_constructor_index:\n             class_deserialize += get_deserialize_element_template(\n@@ -508,7 +594,9 @@ def generate_class_code(class_entry):\n                 property_key,\n                 property_id,\n                 type_name,\n-                is_optional,\n+                entry.has_default,\n+                default_value,\n+                entry.deleted,\n                 class_entry.pointer_type,\n             )\n         elif entry.name not in constructor_entries:\ndiff --git a/src/include/duckdb/common/serializer/deserializer.hpp b/src/include/duckdb/common/serializer/deserializer.hpp\nindex e0b56828180f..3014c51e9fdf 100644\n--- a/src/include/duckdb/common/serializer/deserializer.hpp\n+++ b/src/include/duckdb/common/serializer/deserializer.hpp\n@@ -63,6 +63,17 @@ class Deserializer {\n \t}\n \n \t// Default Value return\n+\ttemplate <typename T>\n+\tinline T ReadPropertyWithDefault(const field_id_t field_id, const char *tag) {\n+\t\tif (!OnOptionalPropertyBegin(field_id, tag)) {\n+\t\t\tOnOptionalPropertyEnd(false);\n+\t\t\treturn std::forward<T>(SerializationDefaultValue::GetDefault<T>());\n+\t\t}\n+\t\tauto ret = Read<T>();\n+\t\tOnOptionalPropertyEnd(true);\n+\t\treturn ret;\n+\t}\n+\n \ttemplate <typename T>\n \tinline T ReadPropertyWithDefault(const field_id_t field_id, const char *tag, T &&default_value) {\n \t\tif (!OnOptionalPropertyBegin(field_id, tag)) {\n@@ -75,6 +86,17 @@ class Deserializer {\n \t}\n \n \t// Default value in place\n+\ttemplate <typename T>\n+\tinline void ReadPropertyWithDefault(const field_id_t field_id, const char *tag, T &ret) {\n+\t\tif (!OnOptionalPropertyBegin(field_id, tag)) {\n+\t\t\tret = std::forward<T>(SerializationDefaultValue::GetDefault<T>());\n+\t\t\tOnOptionalPropertyEnd(false);\n+\t\t\treturn;\n+\t\t}\n+\t\tret = Read<T>();\n+\t\tOnOptionalPropertyEnd(true);\n+\t}\n+\n \ttemplate <typename T>\n \tinline void ReadPropertyWithDefault(const field_id_t field_id, const char *tag, T &ret, T &&default_value) {\n \t\tif (!OnOptionalPropertyBegin(field_id, tag)) {\n@@ -94,6 +116,19 @@ class Deserializer {\n \t\tOnPropertyEnd();\n \t}\n \n+\t// Try to read a property, if it is not present, continue, otherwise read and discard the value\n+\ttemplate <typename T>\n+\tinline void ReadDeletedProperty(const field_id_t field_id, const char *tag) {\n+\t\t// Try to read the property. If not present, great!\n+\t\tif (!OnOptionalPropertyBegin(field_id, tag)) {\n+\t\t\tOnOptionalPropertyEnd(false);\n+\t\t\treturn;\n+\t\t}\n+\t\t// Otherwise read and discard the value\n+\t\t(void)Read<T>();\n+\t\tOnOptionalPropertyEnd(true);\n+\t}\n+\n \t//! Set a serialization property\n \ttemplate <class T>\n \tvoid Set(T entry) {\ndiff --git a/src/include/duckdb/common/serializer/serialization_traits.hpp b/src/include/duckdb/common/serializer/serialization_traits.hpp\nindex fb313ee80ac1..4b079b63fec0 100644\n--- a/src/include/duckdb/common/serializer/serialization_traits.hpp\n+++ b/src/include/duckdb/common/serializer/serialization_traits.hpp\n@@ -8,6 +8,7 @@\n #include \"duckdb/common/set.hpp\"\n #include \"duckdb/common/shared_ptr.hpp\"\n #include \"duckdb/common/unique_ptr.hpp\"\n+#include \"duckdb/common/optional_ptr.hpp\"\n \n namespace duckdb {\n \n@@ -89,7 +90,6 @@ struct is_map<typename duckdb::map<Args...>> : std::true_type {\n \n template <typename T>\n struct is_unique_ptr : std::false_type {};\n-\n template <typename T>\n struct is_unique_ptr<unique_ptr<T>> : std::true_type {\n \ttypedef T ELEMENT_TYPE;\n@@ -97,15 +97,20 @@ struct is_unique_ptr<unique_ptr<T>> : std::true_type {\n \n template <typename T>\n struct is_shared_ptr : std::false_type {};\n-\n template <typename T>\n struct is_shared_ptr<shared_ptr<T>> : std::true_type {\n \ttypedef T ELEMENT_TYPE;\n };\n \n template <typename T>\n-struct is_pair : std::false_type {};\n+struct is_optional_ptr : std::false_type {};\n+template <typename T>\n+struct is_optional_ptr<optional_ptr<T>> : std::true_type {\n+\ttypedef T ELEMENT_TYPE;\n+};\n \n+template <typename T>\n+struct is_pair : std::false_type {};\n template <typename T, typename U>\n struct is_pair<std::pair<T, U>> : std::true_type {\n \ttypedef T FIRST_TYPE;\n@@ -130,4 +135,127 @@ struct is_set<duckdb::set<Args...>> : std::true_type {\n \ttypedef typename std::tuple_element<2, std::tuple<Args...>>::type EQUAL_TYPE;\n };\n \n+template <typename T>\n+struct is_atomic : std::false_type {};\n+\n+template <typename T>\n+struct is_atomic<std::atomic<T>> : std::true_type {\n+\ttypedef T TYPE;\n+};\n+\n+struct SerializationDefaultValue {\n+\n+\ttemplate <typename T = void>\n+\tstatic inline typename std::enable_if<is_atomic<T>::value, T>::type GetDefault() {\n+\t\tusing INNER = typename is_atomic<T>::TYPE;\n+\t\treturn static_cast<T>(GetDefault<INNER>());\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline bool IsDefault(const typename std::enable_if<is_atomic<T>::value, T>::type &value) {\n+\t\tusing INNER = typename is_atomic<T>::TYPE;\n+\t\treturn value == GetDefault<INNER>();\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline typename std::enable_if<std::is_arithmetic<T>::value, T>::type GetDefault() {\n+\t\treturn static_cast<T>(0);\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline bool IsDefault(const typename std::enable_if<std::is_arithmetic<T>::value, T>::type &value) {\n+\t\treturn value == static_cast<T>(0);\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline typename std::enable_if<is_unique_ptr<T>::value, T>::type GetDefault() {\n+\t\treturn T();\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline bool IsDefault(const typename std::enable_if<is_unique_ptr<T>::value, T>::type &value) {\n+\t\treturn !value;\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline typename std::enable_if<is_optional_ptr<T>::value, T>::type GetDefault() {\n+\t\treturn T();\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline bool IsDefault(const typename std::enable_if<is_optional_ptr<T>::value, T>::type &value) {\n+\t\treturn !value;\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline typename std::enable_if<is_shared_ptr<T>::value, T>::type GetDefault() {\n+\t\treturn T();\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline bool IsDefault(const typename std::enable_if<is_shared_ptr<T>::value, T>::type &value) {\n+\t\treturn !value;\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline typename std::enable_if<is_vector<T>::value, T>::type GetDefault() {\n+\t\treturn T();\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline bool IsDefault(const typename std::enable_if<is_vector<T>::value, T>::type &value) {\n+\t\treturn value.empty();\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline typename std::enable_if<is_unsafe_vector<T>::value, T>::type GetDefault() {\n+\t\treturn T();\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline bool IsDefault(const typename std::enable_if<is_unsafe_vector<T>::value, T>::type &value) {\n+\t\treturn value.empty();\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline typename std::enable_if<is_unordered_set<T>::value, T>::type GetDefault() {\n+\t\treturn T();\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline bool IsDefault(const typename std::enable_if<is_unordered_set<T>::value, T>::type &value) {\n+\t\treturn value.empty();\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline typename std::enable_if<is_unordered_map<T>::value, T>::type GetDefault() {\n+\t\treturn T();\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline bool IsDefault(const typename std::enable_if<is_unordered_map<T>::value, T>::type &value) {\n+\t\treturn value.empty();\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline typename std::enable_if<is_map<T>::value, T>::type GetDefault() {\n+\t\treturn T();\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline bool IsDefault(const typename std::enable_if<is_map<T>::value, T>::type &value) {\n+\t\treturn value.empty();\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline typename std::enable_if<std::is_same<T, string>::value, T>::type GetDefault() {\n+\t\treturn T();\n+\t}\n+\n+\ttemplate <typename T = void>\n+\tstatic inline bool IsDefault(const typename std::enable_if<std::is_same<T, string>::value, T>::type &value) {\n+\t\treturn value.empty();\n+\t}\n+};\n+\n } // namespace duckdb\ndiff --git a/src/include/duckdb/common/serializer/serializer.hpp b/src/include/duckdb/common/serializer/serializer.hpp\nindex bac6917dc442..db9f2d32828f 100644\n--- a/src/include/duckdb/common/serializer/serializer.hpp\n+++ b/src/include/duckdb/common/serializer/serializer.hpp\n@@ -54,6 +54,19 @@ class Serializer {\n \t}\n \n \t// Default value\n+\ttemplate <class T>\n+\tvoid WritePropertyWithDefault(const field_id_t field_id, const char *tag, const T &value) {\n+\t\t// If current value is default, don't write it\n+\t\tif (!serialize_default_values && SerializationDefaultValue::IsDefault<T>(value)) {\n+\t\t\tOnOptionalPropertyBegin(field_id, tag, false);\n+\t\t\tOnOptionalPropertyEnd(false);\n+\t\t\treturn;\n+\t\t}\n+\t\tOnOptionalPropertyBegin(field_id, tag, true);\n+\t\tWriteValue(value);\n+\t\tOnOptionalPropertyEnd(true);\n+\t}\n+\n \ttemplate <class T>\n \tvoid WritePropertyWithDefault(const field_id_t field_id, const char *tag, const T &value, const T &&default_value) {\n \t\t// If current value is default, don't write it\ndiff --git a/src/include/duckdb/storage/serialization/create_info.json b/src/include/duckdb/storage/serialization/create_info.json\nindex 27479b28229a..d4c213d058c9 100644\n--- a/src/include/duckdb/storage/serialization/create_info.json\n+++ b/src/include/duckdb/storage/serialization/create_info.json\n@@ -133,8 +133,7 @@\n       {\n         \"id\": 203,\n         \"name\": \"query\",\n-        \"type\": \"SelectStatement*\",\n-        \"optional\": true\n+        \"type\": \"SelectStatement*\"\n       }\n     ]\n   },\n@@ -174,8 +173,7 @@\n       {\n         \"id\": 203,\n         \"name\": \"query\",\n-        \"type\": \"SelectStatement*\",\n-        \"optional\": true\n+        \"type\": \"SelectStatement*\"\n       }\n     ]\n   },\ndiff --git a/src/include/duckdb/storage/serialization/logical_operator.json b/src/include/duckdb/storage/serialization/logical_operator.json\nindex 3c387d9d2b6f..43dd03999a9f 100644\n--- a/src/include/duckdb/storage/serialization/logical_operator.json\n+++ b/src/include/duckdb/storage/serialization/logical_operator.json\n@@ -94,7 +94,7 @@\n       {\n         \"id\": 206,\n         \"name\": \"grouping_functions\",\n-        \"type\": \"vector<vector<idx_t>>\"\n+        \"type\": \"vector<unsafe_vector<idx_t>>\"\n       }\n     ],\n     \"constructor\": [\"group_index\", \"aggregate_index\", \"expressions\"]\n@@ -153,14 +153,12 @@\n       {\n         \"id\": 202,\n         \"name\": \"limit\",\n-        \"type\": \"Expression*\",\n-        \"optional\": true\n+        \"type\": \"Expression*\"\n       },\n       {\n         \"id\": 203,\n         \"name\": \"offset\",\n-        \"type\": \"Expression*\",\n-        \"optional\": true\n+        \"type\": \"Expression*\"\n       }\n     ],\n     \"constructor\": [\"limit_val\", \"offset_val\", \"limit\", \"offset\"]\n@@ -224,8 +222,7 @@\n       {\n         \"id\": 202,\n         \"name\": \"order_by\",\n-        \"type\": \"BoundOrderModifier*\",\n-        \"optional\": true\n+        \"type\": \"BoundOrderModifier*\"\n       }\n     ],\n     \"constructor\": [\"distinct_targets\", \"distinct_type\"]\n@@ -238,7 +235,7 @@\n       {\n         \"id\": 200,\n         \"name\": \"sample_options\",\n-        \"type\": \"SampleOptions\"\n+        \"type\": \"SampleOptions*\"\n       }\n     ]\n   },\n@@ -260,14 +257,12 @@\n       {\n         \"id\": 202,\n         \"name\": \"limit\",\n-        \"type\": \"Expression*\",\n-        \"optional\": true\n+        \"type\": \"Expression*\"\n       },\n       {\n         \"id\": 203,\n         \"name\": \"offset\",\n-        \"type\": \"Expression*\",\n-        \"optional\": true\n+        \"type\": \"Expression*\"\n       }\n     ],\n     \"constructor\": [\"limit_percent\", \"offset_val\", \"limit\", \"offset\"]\n@@ -579,7 +574,7 @@\n       {\n         \"id\": 202,\n         \"name\": \"column_index_map\",\n-        \"type\": \"vector<idx_t>\"\n+        \"type\": \"IndexVector<idx_t, PhysicalIndex>\"\n       },\n       {\n         \"id\": 203,\n@@ -619,19 +614,17 @@\n       {\n         \"id\": 210,\n         \"name\": \"on_conflict_condition\",\n-        \"type\": \"Expression*\",\n-        \"optional\": true\n+        \"type\": \"Expression*\"\n       },\n       {\n         \"id\": 211,\n         \"name\": \"do_update_condition\",\n-        \"type\": \"Expression*\",\n-        \"optional\": true\n+        \"type\": \"Expression*\"\n       },\n       {\n         \"id\": 212,\n         \"name\": \"set_columns\",\n-        \"type\": \"vector<idx_t>\"\n+        \"type\": \"vector<PhysicalIndex>\"\n       },\n       {\n         \"id\": 213,\n@@ -897,7 +890,8 @@\n       {\n         \"id\": 200,\n         \"name\": \"info\",\n-        \"type\": \"CreateInfo*\"\n+        \"type\": \"CreateIndexInfo*\",\n+        \"base\": \"CreateInfo\"\n       },\n       {\n         \"id\": 201,\ndiff --git a/src/include/duckdb/storage/serialization/nodes.json b/src/include/duckdb/storage/serialization/nodes.json\nindex 98af35316ab4..7e22b2f3f279 100644\n--- a/src/include/duckdb/storage/serialization/nodes.json\n+++ b/src/include/duckdb/storage/serialization/nodes.json\n@@ -16,8 +16,7 @@\n         \"id\": 101,\n         \"name\": \"type_info\",\n         \"type\": \"shared_ptr<ExtraTypeInfo>\",\n-        \"serialize_property\": \"type_info_\",\n-        \"optional\": true\n+        \"serialize_property\": \"type_info_\"\n       }\n     ],\n     \"pointer_type\": \"none\",\n@@ -55,7 +54,7 @@\n       {\n         \"id\": 100,\n         \"name\": \"map\",\n-        \"type\": \"unordered_map<string, CommonTableExpressionInfo*>\"\n+        \"type\": \"case_insensitive_map_t<CommonTableExpressionInfo*>\"\n       }\n     ],\n     \"pointer_type\": \"none\"\n@@ -217,8 +216,7 @@\n       {\n         \"id\": 101,\n         \"name\": \"star_expr\",\n-        \"type\": \"ParsedExpression*\",\n-        \"optional\": true\n+        \"type\": \"ParsedExpression*\"\n       },\n       {\n         \"id\": 102,\n@@ -276,8 +274,7 @@\n       {\n         \"id\": 102,\n         \"name\": \"expression\",\n-        \"type\": \"ParsedExpression*\",\n-        \"optional\": true\n+        \"type\": \"ParsedExpression*\"\n       },\n       {\n         \"id\": 103,\n@@ -287,7 +284,7 @@\n       {\n         \"id\": 104,\n         \"name\": \"compression_type\",\n-        \"type\": \"CompressionType\"\n+        \"type\": \"duckdb::CompressionType\"\n       }\n     ],\n     \"constructor\": [\"name\", \"type\", \"expression\", \"category\"],\n@@ -438,7 +435,7 @@\n       {\n         \"id\": 105,\n         \"name\": \"hive_types_schema\",\n-        \"type\": \"unordered_map<string, LogicalType>\"\n+        \"type\": \"case_insensitive_map_t<LogicalType>\"\n       }\n     ],\n     \"pointer_type\": \"none\"\n@@ -620,11 +617,11 @@\n       },\n       {\"id\": 133,\n         \"name\": \"dialect_options.date_format\",\n-        \"type\": \"unordered_map<LogicalTypeId, StrpTimeFormat>\"\n+        \"type\": \"map<LogicalTypeId, StrpTimeFormat>\"\n       },\n       {\"id\": 134,\n         \"name\": \"dialect_options.has_format\",\n-        \"type\": \"unordered_map<bool, StrpTimeFormat>\"\n+        \"type\": \"map<LogicalTypeId, bool>\"\n       }\n     ],\n     \"pointer_type\": \"none\"\n@@ -683,7 +680,7 @@\n       {\n         \"id\": 106,\n         \"name\": \"options\",\n-        \"type\": \"BufferedCSVReaderOptions\"\n+        \"type\": \"CSVReaderOptions\"\n       },\n       {\n         \"id\": 107,\ndiff --git a/src/include/duckdb/storage/serialization/parse_info.json b/src/include/duckdb/storage/serialization/parse_info.json\nindex e4a02b5c442f..ae897505ca0b 100644\n--- a/src/include/duckdb/storage/serialization/parse_info.json\n+++ b/src/include/duckdb/storage/serialization/parse_info.json\n@@ -174,8 +174,7 @@\n       {\n         \"id\": 401,\n         \"name\": \"expression\",\n-        \"type\": \"ParsedExpression*\",\n-        \"optional\": true\n+        \"type\": \"ParsedExpression*\"\n       }\n     ]\n   },\n@@ -337,7 +336,7 @@\n       {\n         \"id\": 207,\n         \"name\": \"options\",\n-        \"type\": \"unordered_map<vector<Value>>\"\n+        \"type\": \"case_insensitive_map_t<vector<Value>>\"\n       }\n     ]\n   },\n@@ -452,7 +451,7 @@\n       {\n         \"id\": 202,\n         \"name\": \"named_parameters\",\n-        \"type\": \"unordered_map<string, Value>\"\n+        \"type\": \"named_parameter_map_t\"\n       }\n     ]\n   },\ndiff --git a/src/include/duckdb/storage/serialization/parsed_expression.json b/src/include/duckdb/storage/serialization/parsed_expression.json\nindex c1de51756924..a2c906119c7a 100644\n--- a/src/include/duckdb/storage/serialization/parsed_expression.json\n+++ b/src/include/duckdb/storage/serialization/parsed_expression.json\n@@ -57,7 +57,7 @@\n       {\n         \"id\": 200,\n         \"name\": \"case_checks\",\n-        \"type\": \"vector<CacheCheck>\"\n+        \"type\": \"vector<CaseCheck>\"\n       },\n       {\n         \"id\": 201,\n@@ -190,7 +190,6 @@\n       {\n         \"id\": 203,\n         \"name\": \"filter\",\n-        \"optional\": true,\n         \"type\": \"ParsedExpression*\"\n       },\n       {\n@@ -288,12 +287,12 @@\n       {\n         \"id\": 201,\n         \"name\": \"exclude_list\",\n-        \"type\": \"unordered_set<string>\"\n+        \"type\": \"case_insensitive_set_t\"\n       },\n       {\n         \"id\": 202,\n         \"name\": \"replace_list\",\n-        \"type\": \"unordered_set<ParsedExpression*>\"\n+        \"type\": \"case_insensitive_map_t<ParsedExpression*>\"\n       },\n       {\n         \"id\": 203,\n@@ -303,7 +302,6 @@\n       {\n         \"id\": 204,\n         \"name\": \"expr\",\n-        \"optional\": true,\n         \"type\": \"ParsedExpression*\"\n       }\n     ]\n@@ -321,12 +319,11 @@\n       {\n         \"id\": 201,\n         \"name\": \"subquery\",\n-        \"type\": \"SelectStatement\"\n+        \"type\": \"SelectStatement*\"\n       },\n       {\n         \"id\": 202,\n         \"name\": \"child\",\n-        \"optional\": true,\n         \"type\": \"ParsedExpression*\"\n       },\n       {\n@@ -384,25 +381,21 @@\n       {\n         \"id\": 208,\n         \"name\": \"start_expr\",\n-        \"optional\": true,\n         \"type\": \"ParsedExpression*\"\n       },\n       {\n         \"id\": 209,\n         \"name\": \"end_expr\",\n-        \"optional\": true,\n         \"type\": \"ParsedExpression*\"\n       },\n       {\n         \"id\": 210,\n         \"name\": \"offset_expr\",\n-        \"optional\": true,\n         \"type\": \"ParsedExpression*\"\n       },\n       {\n         \"id\": 211,\n         \"name\": \"default_expr\",\n-        \"optional\": true,\n         \"type\": \"ParsedExpression*\"\n       },\n       {\n@@ -413,7 +406,6 @@\n       {\n         \"id\": 213,\n         \"name\": \"filter_expr\",\n-        \"optional\": true,\n         \"type\": \"ParsedExpression*\"\n       }\n     ],\ndiff --git a/src/include/duckdb/storage/serialization/query_node.json b/src/include/duckdb/storage/serialization/query_node.json\nindex f8ae99314fcf..d6088bfbc212 100644\n--- a/src/include/duckdb/storage/serialization/query_node.json\n+++ b/src/include/duckdb/storage/serialization/query_node.json\n@@ -36,14 +36,12 @@\n       {\n         \"id\": 201,\n         \"name\": \"from_table\",\n-        \"type\": \"TableRef*\",\n-        \"optional\": true\n+        \"type\": \"TableRef*\"\n       },\n       {\n         \"id\": 202,\n         \"name\": \"where_clause\",\n-        \"type\": \"ParsedExpression*\",\n-        \"optional\": true\n+        \"type\": \"ParsedExpression*\"\n       },\n       {\n         \"id\": 203,\n@@ -54,7 +52,7 @@\n       {\n         \"id\": 204,\n         \"name\": \"group_sets\",\n-        \"type\": \"set<idx_t>\",\n+        \"type\": \"vector<GroupingSet>\",\n         \"property\": \"groups.grouping_sets\"\n       },\n       {\n@@ -65,20 +63,17 @@\n       {\n         \"id\": 206,\n         \"name\": \"having\",\n-        \"type\": \"ParsedExpression*\",\n-        \"optional\": true\n+        \"type\": \"ParsedExpression*\"\n       },\n       {\n         \"id\": 207,\n         \"name\": \"sample\",\n-        \"type\": \"SampleOptions*\",\n-        \"optional\": true\n+        \"type\": \"SampleOptions*\"\n       },\n       {\n         \"id\": 208,\n         \"name\": \"qualify\",\n-        \"type\": \"ParsedExpression*\",\n-        \"optional\": true\n+        \"type\": \"ParsedExpression*\"\n       }\n     ]\n   },\n@@ -118,7 +113,8 @@\n       {\n         \"id\": 201,\n         \"name\": \"union_all\",\n-        \"type\": \"bool\"\n+        \"type\": \"bool\",\n+        \"default\": \"false\"\n       },\n       {\n         \"id\": 202,\ndiff --git a/src/include/duckdb/storage/serialization/result_modifier.json b/src/include/duckdb/storage/serialization/result_modifier.json\nindex 351994f73a0a..443c32a48f6b 100644\n--- a/src/include/duckdb/storage/serialization/result_modifier.json\n+++ b/src/include/duckdb/storage/serialization/result_modifier.json\n@@ -21,14 +21,12 @@\n       {\n         \"id\": 200,\n         \"name\": \"limit\",\n-        \"type\": \"ParsedExpression*\",\n-        \"optional\": true\n+        \"type\": \"ParsedExpression*\"\n       },\n       {\n         \"id\": 201,\n         \"name\": \"offset\",\n-        \"type\": \"ParsedExpression*\",\n-        \"optional\": true\n+        \"type\": \"ParsedExpression*\"\n       }\n     ]\n   },\n@@ -64,14 +62,12 @@\n       {\n         \"id\": 200,\n         \"name\": \"limit\",\n-        \"type\": \"ParsedExpression*\",\n-        \"optional\": true\n+        \"type\": \"ParsedExpression*\"\n       },\n       {\n         \"id\": 201,\n         \"name\": \"offset\",\n-        \"type\": \"ParsedExpression*\",\n-        \"optional\": true\n+        \"type\": \"ParsedExpression*\"\n       }\n     ]\n   },\ndiff --git a/src/include/duckdb/storage/serialization/tableref.json b/src/include/duckdb/storage/serialization/tableref.json\nindex 50911056e65f..beebc4ab31b0 100644\n--- a/src/include/duckdb/storage/serialization/tableref.json\n+++ b/src/include/duckdb/storage/serialization/tableref.json\n@@ -19,8 +19,7 @@\n       {\n         \"id\": 102,\n         \"name\": \"sample\",\n-        \"type\": \"SampleOptions*\",\n-        \"optional\": true\n+        \"type\": \"SampleOptions*\"\n       }\n     ]\n   },\n@@ -69,8 +68,7 @@\n       {\n         \"id\": 202,\n         \"name\": \"condition\",\n-        \"type\": \"ParsedExpression*\",\n-        \"optional\": true\n+        \"type\": \"ParsedExpression*\"\n       },\n       {\n         \"id\": 203,\ndiff --git a/src/storage/checkpoint/write_overflow_strings_to_disk.cpp b/src/storage/checkpoint/write_overflow_strings_to_disk.cpp\nindex 855fa34d9917..3c0f08df5f82 100644\n--- a/src/storage/checkpoint/write_overflow_strings_to_disk.cpp\n+++ b/src/storage/checkpoint/write_overflow_strings_to_disk.cpp\n@@ -1,7 +1,6 @@\n #include \"duckdb/storage/checkpoint/write_overflow_strings_to_disk.hpp\"\n #include \"duckdb/storage/block_manager.hpp\"\n #include \"duckdb/storage/buffer_manager.hpp\"\n-#include \"miniz_wrapper.hpp\"\n \n namespace duckdb {\n \n@@ -50,24 +49,15 @@ void WriteOverflowStringsToDisk::WriteString(UncompressedStringSegmentState &sta\n \tresult_block = block_id;\n \tresult_offset = offset;\n \n-\t// GZIP the string\n-\tauto uncompressed_size = string.GetSize();\n-\tMiniZStream s;\n-\tsize_t compressed_size = 0;\n-\tcompressed_size = s.MaxCompressedLength(uncompressed_size);\n-\tauto compressed_buf = make_unsafe_uniq_array<data_t>(compressed_size);\n-\ts.Compress(string.GetData(), uncompressed_size, char_ptr_cast(compressed_buf.get()), &compressed_size);\n-\tstring_t compressed_string(const_char_ptr_cast(compressed_buf.get()), compressed_size);\n-\n-\t// store sizes\n+\t// write the length field\n \tauto data_ptr = handle.Ptr();\n-\tStore<uint32_t>(compressed_size, data_ptr + offset);\n-\tStore<uint32_t>(uncompressed_size, data_ptr + offset + sizeof(uint32_t));\n+\tauto string_length = string.GetSize();\n+\tStore<uint32_t>(string_length, data_ptr + offset);\n+\toffset += sizeof(uint32_t);\n \n \t// now write the remainder of the string\n-\toffset += 2 * sizeof(uint32_t);\n-\tauto strptr = compressed_string.GetData();\n-\tuint32_t remaining = compressed_size;\n+\tauto strptr = string.GetData();\n+\tuint32_t remaining = string_length;\n \twhile (remaining > 0) {\n \t\tuint32_t to_write = MinValue<uint32_t>(remaining, STRING_SPACE - offset);\n \t\tif (to_write > 0) {\ndiff --git a/src/storage/compression/string_uncompressed.cpp b/src/storage/compression/string_uncompressed.cpp\nindex 36cb32309756..4f7c6da24632 100644\n--- a/src/storage/compression/string_uncompressed.cpp\n+++ b/src/storage/compression/string_uncompressed.cpp\n@@ -2,7 +2,6 @@\n \n #include \"duckdb/common/pair.hpp\"\n #include \"duckdb/storage/checkpoint/write_overflow_strings_to_disk.hpp\"\n-#include \"miniz_wrapper.hpp\"\n #include \"duckdb/common/serializer/serializer.hpp\"\n #include \"duckdb/common/serializer/deserializer.hpp\"\n #include \"duckdb/storage/table/column_data.hpp\"\n@@ -335,52 +334,36 @@ string_t UncompressedStringStorage::ReadOverflowString(ColumnSegment &segment, V\n \t\tauto handle = buffer_manager.Pin(block_handle);\n \n \t\t// read header\n-\t\tuint32_t compressed_size = Load<uint32_t>(handle.Ptr() + offset);\n-\t\tuint32_t uncompressed_size = Load<uint32_t>(handle.Ptr() + offset + sizeof(uint32_t));\n-\t\tuint32_t remaining = compressed_size;\n-\t\toffset += 2 * sizeof(uint32_t);\n-\n-\t\tdata_ptr_t decompression_ptr;\n-\t\tunsafe_unique_array<data_t> decompression_buffer;\n-\n-\t\t// If string is in single block we decompress straight from it, else we copy first\n-\t\tif (remaining <= WriteOverflowStringsToDisk::STRING_SPACE - offset) {\n-\t\t\tdecompression_ptr = handle.Ptr() + offset;\n-\t\t} else {\n-\t\t\tdecompression_buffer = make_unsafe_uniq_array<data_t>(compressed_size);\n-\t\t\tauto target_ptr = decompression_buffer.get();\n-\n-\t\t\t// now append the string to the single buffer\n-\t\t\twhile (remaining > 0) {\n-\t\t\t\tidx_t to_write = MinValue<idx_t>(remaining, WriteOverflowStringsToDisk::STRING_SPACE - offset);\n-\t\t\t\tmemcpy(target_ptr, handle.Ptr() + offset, to_write);\n-\n-\t\t\t\tremaining -= to_write;\n-\t\t\t\toffset += to_write;\n-\t\t\t\ttarget_ptr += to_write;\n-\t\t\t\tif (remaining > 0) {\n-\t\t\t\t\t// read the next block\n-\t\t\t\t\tD_ASSERT(offset == WriteOverflowStringsToDisk::STRING_SPACE);\n-\t\t\t\t\tblock_id_t next_block = Load<block_id_t>(handle.Ptr() + WriteOverflowStringsToDisk::STRING_SPACE);\n-\t\t\t\t\tblock_handle = state.GetHandle(block_manager, next_block);\n-\t\t\t\t\thandle = buffer_manager.Pin(block_handle);\n-\t\t\t\t\toffset = 0;\n-\t\t\t\t}\n+\t\tuint32_t length = Load<uint32_t>(handle.Ptr() + offset);\n+\t\tuint32_t remaining = length;\n+\t\toffset += sizeof(uint32_t);\n+\n+\t\t// allocate a buffer to store the string\n+\t\tauto alloc_size = MaxValue<idx_t>(Storage::BLOCK_SIZE, length);\n+\t\t// allocate a buffer to store the compressed string\n+\t\t// TODO: profile this to check if we need to reuse buffer\n+\t\tauto target_handle = buffer_manager.Allocate(alloc_size);\n+\t\tauto target_ptr = target_handle.Ptr();\n+\n+\t\t// now append the string to the single buffer\n+\t\twhile (remaining > 0) {\n+\t\t\tidx_t to_write = MinValue<idx_t>(remaining, Storage::BLOCK_SIZE - sizeof(block_id_t) - offset);\n+\t\t\tmemcpy(target_ptr, handle.Ptr() + offset, to_write);\n+\t\t\tremaining -= to_write;\n+\t\t\toffset += to_write;\n+\t\t\ttarget_ptr += to_write;\n+\t\t\tif (remaining > 0) {\n+\t\t\t\t// read the next block\n+\t\t\t\tblock_id_t next_block = Load<block_id_t>(handle.Ptr() + offset);\n+\t\t\t\tblock_handle = state.GetHandle(block_manager, next_block);\n+\t\t\t\thandle = buffer_manager.Pin(block_handle);\n+\t\t\t\toffset = 0;\n \t\t\t}\n-\t\t\tdecompression_ptr = decompression_buffer.get();\n \t\t}\n \n-\t\t// overflow strings on disk are gzipped, decompress here\n-\t\tauto decompressed_target_handle =\n-\t\t    buffer_manager.Allocate(MaxValue<idx_t>(Storage::BLOCK_SIZE, uncompressed_size));\n-\t\tauto decompressed_target_ptr = decompressed_target_handle.Ptr();\n-\t\tMiniZStream s;\n-\t\ts.Decompress(const_char_ptr_cast(decompression_ptr), compressed_size, char_ptr_cast(decompressed_target_ptr),\n-\t\t             uncompressed_size);\n-\n-\t\tauto final_buffer = decompressed_target_handle.Ptr();\n-\t\tStringVector::AddHandle(result, std::move(decompressed_target_handle));\n-\t\treturn ReadString(final_buffer, 0, uncompressed_size);\n+\t\tauto final_buffer = target_handle.Ptr();\n+\t\tStringVector::AddHandle(result, std::move(target_handle));\n+\t\treturn ReadString(final_buffer, 0, length);\n \t} else {\n \t\t// read the overflow string from memory\n \t\t// first pin the handle, if it is not pinned yet\ndiff --git a/src/storage/serialization/serialize_constraint.cpp b/src/storage/serialization/serialize_constraint.cpp\nindex 8b26122daedd..9993a59ed119 100644\n--- a/src/storage/serialization/serialize_constraint.cpp\n+++ b/src/storage/serialization/serialize_constraint.cpp\n@@ -10,7 +10,7 @@\n namespace duckdb {\n \n void Constraint::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"type\", type);\n+\tserializer.WriteProperty<ConstraintType>(100, \"type\", type);\n }\n \n unique_ptr<Constraint> Constraint::Deserialize(Deserializer &deserializer) {\n@@ -37,41 +37,41 @@ unique_ptr<Constraint> Constraint::Deserialize(Deserializer &deserializer) {\n \n void CheckConstraint::Serialize(Serializer &serializer) const {\n \tConstraint::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"expression\", expression);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"expression\", expression);\n }\n \n unique_ptr<Constraint> CheckConstraint::Deserialize(Deserializer &deserializer) {\n-\tauto expression = deserializer.ReadProperty<unique_ptr<ParsedExpression>>(200, \"expression\");\n+\tauto expression = deserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"expression\");\n \tauto result = duckdb::unique_ptr<CheckConstraint>(new CheckConstraint(std::move(expression)));\n \treturn std::move(result);\n }\n \n void ForeignKeyConstraint::Serialize(Serializer &serializer) const {\n \tConstraint::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"pk_columns\", pk_columns);\n-\tserializer.WriteProperty(201, \"fk_columns\", fk_columns);\n-\tserializer.WriteProperty(202, \"fk_type\", info.type);\n-\tserializer.WriteProperty(203, \"schema\", info.schema);\n-\tserializer.WriteProperty(204, \"table\", info.table);\n-\tserializer.WriteProperty(205, \"pk_keys\", info.pk_keys);\n-\tserializer.WriteProperty(206, \"fk_keys\", info.fk_keys);\n+\tserializer.WritePropertyWithDefault<vector<string>>(200, \"pk_columns\", pk_columns);\n+\tserializer.WritePropertyWithDefault<vector<string>>(201, \"fk_columns\", fk_columns);\n+\tserializer.WriteProperty<ForeignKeyType>(202, \"fk_type\", info.type);\n+\tserializer.WritePropertyWithDefault<string>(203, \"schema\", info.schema);\n+\tserializer.WritePropertyWithDefault<string>(204, \"table\", info.table);\n+\tserializer.WritePropertyWithDefault<vector<PhysicalIndex>>(205, \"pk_keys\", info.pk_keys);\n+\tserializer.WritePropertyWithDefault<vector<PhysicalIndex>>(206, \"fk_keys\", info.fk_keys);\n }\n \n unique_ptr<Constraint> ForeignKeyConstraint::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<ForeignKeyConstraint>(new ForeignKeyConstraint());\n-\tdeserializer.ReadProperty(200, \"pk_columns\", result->pk_columns);\n-\tdeserializer.ReadProperty(201, \"fk_columns\", result->fk_columns);\n-\tdeserializer.ReadProperty(202, \"fk_type\", result->info.type);\n-\tdeserializer.ReadProperty(203, \"schema\", result->info.schema);\n-\tdeserializer.ReadProperty(204, \"table\", result->info.table);\n-\tdeserializer.ReadProperty(205, \"pk_keys\", result->info.pk_keys);\n-\tdeserializer.ReadProperty(206, \"fk_keys\", result->info.fk_keys);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(200, \"pk_columns\", result->pk_columns);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(201, \"fk_columns\", result->fk_columns);\n+\tdeserializer.ReadProperty<ForeignKeyType>(202, \"fk_type\", result->info.type);\n+\tdeserializer.ReadPropertyWithDefault<string>(203, \"schema\", result->info.schema);\n+\tdeserializer.ReadPropertyWithDefault<string>(204, \"table\", result->info.table);\n+\tdeserializer.ReadPropertyWithDefault<vector<PhysicalIndex>>(205, \"pk_keys\", result->info.pk_keys);\n+\tdeserializer.ReadPropertyWithDefault<vector<PhysicalIndex>>(206, \"fk_keys\", result->info.fk_keys);\n \treturn std::move(result);\n }\n \n void NotNullConstraint::Serialize(Serializer &serializer) const {\n \tConstraint::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"index\", index);\n+\tserializer.WriteProperty<LogicalIndex>(200, \"index\", index);\n }\n \n unique_ptr<Constraint> NotNullConstraint::Deserialize(Deserializer &deserializer) {\n@@ -82,16 +82,16 @@ unique_ptr<Constraint> NotNullConstraint::Deserialize(Deserializer &deserializer\n \n void UniqueConstraint::Serialize(Serializer &serializer) const {\n \tConstraint::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"is_primary_key\", is_primary_key);\n-\tserializer.WriteProperty(201, \"index\", index);\n-\tserializer.WriteProperty(202, \"columns\", columns);\n+\tserializer.WritePropertyWithDefault<bool>(200, \"is_primary_key\", is_primary_key);\n+\tserializer.WriteProperty<LogicalIndex>(201, \"index\", index);\n+\tserializer.WritePropertyWithDefault<vector<string>>(202, \"columns\", columns);\n }\n \n unique_ptr<Constraint> UniqueConstraint::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<UniqueConstraint>(new UniqueConstraint());\n-\tdeserializer.ReadProperty(200, \"is_primary_key\", result->is_primary_key);\n-\tdeserializer.ReadProperty(201, \"index\", result->index);\n-\tdeserializer.ReadProperty(202, \"columns\", result->columns);\n+\tdeserializer.ReadPropertyWithDefault<bool>(200, \"is_primary_key\", result->is_primary_key);\n+\tdeserializer.ReadProperty<LogicalIndex>(201, \"index\", result->index);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(202, \"columns\", result->columns);\n \treturn std::move(result);\n }\n \ndiff --git a/src/storage/serialization/serialize_create_info.cpp b/src/storage/serialization/serialize_create_info.cpp\nindex 186be2dc2f98..821c6cec5576 100644\n--- a/src/storage/serialization/serialize_create_info.cpp\n+++ b/src/storage/serialization/serialize_create_info.cpp\n@@ -17,23 +17,23 @@\n namespace duckdb {\n \n void CreateInfo::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"type\", type);\n-\tserializer.WriteProperty(101, \"catalog\", catalog);\n-\tserializer.WriteProperty(102, \"schema\", schema);\n-\tserializer.WriteProperty(103, \"temporary\", temporary);\n-\tserializer.WriteProperty(104, \"internal\", internal);\n-\tserializer.WriteProperty(105, \"on_conflict\", on_conflict);\n-\tserializer.WriteProperty(106, \"sql\", sql);\n+\tserializer.WriteProperty<CatalogType>(100, \"type\", type);\n+\tserializer.WritePropertyWithDefault<string>(101, \"catalog\", catalog);\n+\tserializer.WritePropertyWithDefault<string>(102, \"schema\", schema);\n+\tserializer.WritePropertyWithDefault<bool>(103, \"temporary\", temporary);\n+\tserializer.WritePropertyWithDefault<bool>(104, \"internal\", internal);\n+\tserializer.WriteProperty<OnCreateConflict>(105, \"on_conflict\", on_conflict);\n+\tserializer.WritePropertyWithDefault<string>(106, \"sql\", sql);\n }\n \n unique_ptr<CreateInfo> CreateInfo::Deserialize(Deserializer &deserializer) {\n \tauto type = deserializer.ReadProperty<CatalogType>(100, \"type\");\n-\tauto catalog = deserializer.ReadProperty<string>(101, \"catalog\");\n-\tauto schema = deserializer.ReadProperty<string>(102, \"schema\");\n-\tauto temporary = deserializer.ReadProperty<bool>(103, \"temporary\");\n-\tauto internal = deserializer.ReadProperty<bool>(104, \"internal\");\n+\tauto catalog = deserializer.ReadPropertyWithDefault<string>(101, \"catalog\");\n+\tauto schema = deserializer.ReadPropertyWithDefault<string>(102, \"schema\");\n+\tauto temporary = deserializer.ReadPropertyWithDefault<bool>(103, \"temporary\");\n+\tauto internal = deserializer.ReadPropertyWithDefault<bool>(104, \"internal\");\n \tauto on_conflict = deserializer.ReadProperty<OnCreateConflict>(105, \"on_conflict\");\n-\tauto sql = deserializer.ReadProperty<string>(106, \"sql\");\n+\tauto sql = deserializer.ReadPropertyWithDefault<string>(106, \"sql\");\n \tdeserializer.Set<CatalogType>(type);\n \tunique_ptr<CreateInfo> result;\n \tswitch (type) {\n@@ -76,43 +76,43 @@ unique_ptr<CreateInfo> CreateInfo::Deserialize(Deserializer &deserializer) {\n \n void CreateIndexInfo::Serialize(Serializer &serializer) const {\n \tCreateInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"name\", index_name);\n-\tserializer.WriteProperty(201, \"table\", table);\n-\tserializer.WriteProperty(202, \"index_type\", index_type);\n-\tserializer.WriteProperty(203, \"constraint_type\", constraint_type);\n-\tserializer.WriteProperty(204, \"parsed_expressions\", parsed_expressions);\n-\tserializer.WriteProperty(205, \"scan_types\", scan_types);\n-\tserializer.WriteProperty(206, \"names\", names);\n-\tserializer.WriteProperty(207, \"column_ids\", column_ids);\n-\tserializer.WriteProperty(208, \"options\", options);\n-\tserializer.WriteProperty(209, \"index_type_name\", index_type_name);\n+\tserializer.WritePropertyWithDefault<string>(200, \"name\", index_name);\n+\tserializer.WritePropertyWithDefault<string>(201, \"table\", table);\n+\tserializer.WriteProperty<IndexType>(202, \"index_type\", index_type);\n+\tserializer.WriteProperty<IndexConstraintType>(203, \"constraint_type\", constraint_type);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(204, \"parsed_expressions\", parsed_expressions);\n+\tserializer.WritePropertyWithDefault<vector<LogicalType>>(205, \"scan_types\", scan_types);\n+\tserializer.WritePropertyWithDefault<vector<string>>(206, \"names\", names);\n+\tserializer.WritePropertyWithDefault<vector<column_t>>(207, \"column_ids\", column_ids);\n+\tserializer.WritePropertyWithDefault<case_insensitive_map_t<Value>>(208, \"options\", options);\n+\tserializer.WritePropertyWithDefault<string>(209, \"index_type_name\", index_type_name);\n }\n \n unique_ptr<CreateInfo> CreateIndexInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<CreateIndexInfo>(new CreateIndexInfo());\n-\tdeserializer.ReadProperty(200, \"name\", result->index_name);\n-\tdeserializer.ReadProperty(201, \"table\", result->table);\n-\tdeserializer.ReadProperty(202, \"index_type\", result->index_type);\n-\tdeserializer.ReadProperty(203, \"constraint_type\", result->constraint_type);\n-\tdeserializer.ReadProperty(204, \"parsed_expressions\", result->parsed_expressions);\n-\tdeserializer.ReadProperty(205, \"scan_types\", result->scan_types);\n-\tdeserializer.ReadProperty(206, \"names\", result->names);\n-\tdeserializer.ReadProperty(207, \"column_ids\", result->column_ids);\n-\tdeserializer.ReadProperty(208, \"options\", result->options);\n-\tdeserializer.ReadProperty(209, \"index_type_name\", result->index_type_name);\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"name\", result->index_name);\n+\tdeserializer.ReadPropertyWithDefault<string>(201, \"table\", result->table);\n+\tdeserializer.ReadProperty<IndexType>(202, \"index_type\", result->index_type);\n+\tdeserializer.ReadProperty<IndexConstraintType>(203, \"constraint_type\", result->constraint_type);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(204, \"parsed_expressions\", result->parsed_expressions);\n+\tdeserializer.ReadPropertyWithDefault<vector<LogicalType>>(205, \"scan_types\", result->scan_types);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(206, \"names\", result->names);\n+\tdeserializer.ReadPropertyWithDefault<vector<column_t>>(207, \"column_ids\", result->column_ids);\n+\tdeserializer.ReadPropertyWithDefault<case_insensitive_map_t<Value>>(208, \"options\", result->options);\n+\tdeserializer.ReadPropertyWithDefault<string>(209, \"index_type_name\", result->index_type_name);\n \treturn std::move(result);\n }\n \n void CreateMacroInfo::Serialize(Serializer &serializer) const {\n \tCreateInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"name\", name);\n-\tserializer.WriteProperty(201, \"function\", function);\n+\tserializer.WritePropertyWithDefault<string>(200, \"name\", name);\n+\tserializer.WritePropertyWithDefault<unique_ptr<MacroFunction>>(201, \"function\", function);\n }\n \n unique_ptr<CreateInfo> CreateMacroInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<CreateMacroInfo>(new CreateMacroInfo(deserializer.Get<CatalogType>()));\n-\tdeserializer.ReadProperty(200, \"name\", result->name);\n-\tdeserializer.ReadProperty(201, \"function\", result->function);\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"name\", result->name);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<MacroFunction>>(201, \"function\", result->function);\n \treturn std::move(result);\n }\n \n@@ -127,71 +127,71 @@ unique_ptr<CreateInfo> CreateSchemaInfo::Deserialize(Deserializer &deserializer)\n \n void CreateSequenceInfo::Serialize(Serializer &serializer) const {\n \tCreateInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"name\", name);\n-\tserializer.WriteProperty(201, \"usage_count\", usage_count);\n-\tserializer.WriteProperty(202, \"increment\", increment);\n-\tserializer.WriteProperty(203, \"min_value\", min_value);\n-\tserializer.WriteProperty(204, \"max_value\", max_value);\n-\tserializer.WriteProperty(205, \"start_value\", start_value);\n-\tserializer.WriteProperty(206, \"cycle\", cycle);\n+\tserializer.WritePropertyWithDefault<string>(200, \"name\", name);\n+\tserializer.WritePropertyWithDefault<uint64_t>(201, \"usage_count\", usage_count);\n+\tserializer.WritePropertyWithDefault<int64_t>(202, \"increment\", increment);\n+\tserializer.WritePropertyWithDefault<int64_t>(203, \"min_value\", min_value);\n+\tserializer.WritePropertyWithDefault<int64_t>(204, \"max_value\", max_value);\n+\tserializer.WritePropertyWithDefault<int64_t>(205, \"start_value\", start_value);\n+\tserializer.WritePropertyWithDefault<bool>(206, \"cycle\", cycle);\n }\n \n unique_ptr<CreateInfo> CreateSequenceInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<CreateSequenceInfo>(new CreateSequenceInfo());\n-\tdeserializer.ReadProperty(200, \"name\", result->name);\n-\tdeserializer.ReadProperty(201, \"usage_count\", result->usage_count);\n-\tdeserializer.ReadProperty(202, \"increment\", result->increment);\n-\tdeserializer.ReadProperty(203, \"min_value\", result->min_value);\n-\tdeserializer.ReadProperty(204, \"max_value\", result->max_value);\n-\tdeserializer.ReadProperty(205, \"start_value\", result->start_value);\n-\tdeserializer.ReadProperty(206, \"cycle\", result->cycle);\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"name\", result->name);\n+\tdeserializer.ReadPropertyWithDefault<uint64_t>(201, \"usage_count\", result->usage_count);\n+\tdeserializer.ReadPropertyWithDefault<int64_t>(202, \"increment\", result->increment);\n+\tdeserializer.ReadPropertyWithDefault<int64_t>(203, \"min_value\", result->min_value);\n+\tdeserializer.ReadPropertyWithDefault<int64_t>(204, \"max_value\", result->max_value);\n+\tdeserializer.ReadPropertyWithDefault<int64_t>(205, \"start_value\", result->start_value);\n+\tdeserializer.ReadPropertyWithDefault<bool>(206, \"cycle\", result->cycle);\n \treturn std::move(result);\n }\n \n void CreateTableInfo::Serialize(Serializer &serializer) const {\n \tCreateInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"table\", table);\n-\tserializer.WriteProperty(201, \"columns\", columns);\n-\tserializer.WriteProperty(202, \"constraints\", constraints);\n-\tserializer.WritePropertyWithDefault(203, \"query\", query, unique_ptr<SelectStatement>());\n+\tserializer.WritePropertyWithDefault<string>(200, \"table\", table);\n+\tserializer.WriteProperty<ColumnList>(201, \"columns\", columns);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<Constraint>>>(202, \"constraints\", constraints);\n+\tserializer.WritePropertyWithDefault<unique_ptr<SelectStatement>>(203, \"query\", query);\n }\n \n unique_ptr<CreateInfo> CreateTableInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<CreateTableInfo>(new CreateTableInfo());\n-\tdeserializer.ReadProperty(200, \"table\", result->table);\n-\tdeserializer.ReadProperty(201, \"columns\", result->columns);\n-\tdeserializer.ReadProperty(202, \"constraints\", result->constraints);\n-\tdeserializer.ReadPropertyWithDefault(203, \"query\", result->query, unique_ptr<SelectStatement>());\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"table\", result->table);\n+\tdeserializer.ReadProperty<ColumnList>(201, \"columns\", result->columns);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<Constraint>>>(202, \"constraints\", result->constraints);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<SelectStatement>>(203, \"query\", result->query);\n \treturn std::move(result);\n }\n \n void CreateTypeInfo::Serialize(Serializer &serializer) const {\n \tCreateInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"name\", name);\n-\tserializer.WriteProperty(201, \"logical_type\", type);\n+\tserializer.WritePropertyWithDefault<string>(200, \"name\", name);\n+\tserializer.WriteProperty<LogicalType>(201, \"logical_type\", type);\n }\n \n unique_ptr<CreateInfo> CreateTypeInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<CreateTypeInfo>(new CreateTypeInfo());\n-\tdeserializer.ReadProperty(200, \"name\", result->name);\n-\tdeserializer.ReadProperty(201, \"logical_type\", result->type);\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"name\", result->name);\n+\tdeserializer.ReadProperty<LogicalType>(201, \"logical_type\", result->type);\n \treturn std::move(result);\n }\n \n void CreateViewInfo::Serialize(Serializer &serializer) const {\n \tCreateInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"view_name\", view_name);\n-\tserializer.WriteProperty(201, \"aliases\", aliases);\n-\tserializer.WriteProperty(202, \"types\", types);\n-\tserializer.WritePropertyWithDefault(203, \"query\", query, unique_ptr<SelectStatement>());\n+\tserializer.WritePropertyWithDefault<string>(200, \"view_name\", view_name);\n+\tserializer.WritePropertyWithDefault<vector<string>>(201, \"aliases\", aliases);\n+\tserializer.WritePropertyWithDefault<vector<LogicalType>>(202, \"types\", types);\n+\tserializer.WritePropertyWithDefault<unique_ptr<SelectStatement>>(203, \"query\", query);\n }\n \n unique_ptr<CreateInfo> CreateViewInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<CreateViewInfo>(new CreateViewInfo());\n-\tdeserializer.ReadProperty(200, \"view_name\", result->view_name);\n-\tdeserializer.ReadProperty(201, \"aliases\", result->aliases);\n-\tdeserializer.ReadProperty(202, \"types\", result->types);\n-\tdeserializer.ReadPropertyWithDefault(203, \"query\", result->query, unique_ptr<SelectStatement>());\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"view_name\", result->view_name);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(201, \"aliases\", result->aliases);\n+\tdeserializer.ReadPropertyWithDefault<vector<LogicalType>>(202, \"types\", result->types);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<SelectStatement>>(203, \"query\", result->query);\n \treturn std::move(result);\n }\n \ndiff --git a/src/storage/serialization/serialize_expression.cpp b/src/storage/serialization/serialize_expression.cpp\nindex cfbd987fe736..bc0b6e191efd 100644\n--- a/src/storage/serialization/serialize_expression.cpp\n+++ b/src/storage/serialization/serialize_expression.cpp\n@@ -10,15 +10,15 @@\n namespace duckdb {\n \n void Expression::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"expression_class\", expression_class);\n-\tserializer.WriteProperty(101, \"type\", type);\n-\tserializer.WriteProperty(102, \"alias\", alias);\n+\tserializer.WriteProperty<ExpressionClass>(100, \"expression_class\", expression_class);\n+\tserializer.WriteProperty<ExpressionType>(101, \"type\", type);\n+\tserializer.WritePropertyWithDefault<string>(102, \"alias\", alias);\n }\n \n unique_ptr<Expression> Expression::Deserialize(Deserializer &deserializer) {\n \tauto expression_class = deserializer.ReadProperty<ExpressionClass>(100, \"expression_class\");\n \tauto type = deserializer.ReadProperty<ExpressionType>(101, \"type\");\n-\tauto alias = deserializer.ReadProperty<string>(102, \"alias\");\n+\tauto alias = deserializer.ReadPropertyWithDefault<string>(102, \"alias\");\n \tdeserializer.Set<ExpressionType>(type);\n \tunique_ptr<Expression> result;\n \tswitch (expression_class) {\n@@ -83,95 +83,95 @@ unique_ptr<Expression> Expression::Deserialize(Deserializer &deserializer) {\n \n void BoundBetweenExpression::Serialize(Serializer &serializer) const {\n \tExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"input\", input);\n-\tserializer.WriteProperty(201, \"lower\", lower);\n-\tserializer.WriteProperty(202, \"upper\", upper);\n-\tserializer.WriteProperty(203, \"lower_inclusive\", lower_inclusive);\n-\tserializer.WriteProperty(204, \"upper_inclusive\", upper_inclusive);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(200, \"input\", input);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(201, \"lower\", lower);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(202, \"upper\", upper);\n+\tserializer.WritePropertyWithDefault<bool>(203, \"lower_inclusive\", lower_inclusive);\n+\tserializer.WritePropertyWithDefault<bool>(204, \"upper_inclusive\", upper_inclusive);\n }\n \n unique_ptr<Expression> BoundBetweenExpression::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<BoundBetweenExpression>(new BoundBetweenExpression());\n-\tdeserializer.ReadProperty(200, \"input\", result->input);\n-\tdeserializer.ReadProperty(201, \"lower\", result->lower);\n-\tdeserializer.ReadProperty(202, \"upper\", result->upper);\n-\tdeserializer.ReadProperty(203, \"lower_inclusive\", result->lower_inclusive);\n-\tdeserializer.ReadProperty(204, \"upper_inclusive\", result->upper_inclusive);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(200, \"input\", result->input);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(201, \"lower\", result->lower);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(202, \"upper\", result->upper);\n+\tdeserializer.ReadPropertyWithDefault<bool>(203, \"lower_inclusive\", result->lower_inclusive);\n+\tdeserializer.ReadPropertyWithDefault<bool>(204, \"upper_inclusive\", result->upper_inclusive);\n \treturn std::move(result);\n }\n \n void BoundCaseExpression::Serialize(Serializer &serializer) const {\n \tExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"return_type\", return_type);\n-\tserializer.WriteProperty(201, \"case_checks\", case_checks);\n-\tserializer.WriteProperty(202, \"else_expr\", else_expr);\n+\tserializer.WriteProperty<LogicalType>(200, \"return_type\", return_type);\n+\tserializer.WritePropertyWithDefault<vector<BoundCaseCheck>>(201, \"case_checks\", case_checks);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(202, \"else_expr\", else_expr);\n }\n \n unique_ptr<Expression> BoundCaseExpression::Deserialize(Deserializer &deserializer) {\n \tauto return_type = deserializer.ReadProperty<LogicalType>(200, \"return_type\");\n \tauto result = duckdb::unique_ptr<BoundCaseExpression>(new BoundCaseExpression(std::move(return_type)));\n-\tdeserializer.ReadProperty(201, \"case_checks\", result->case_checks);\n-\tdeserializer.ReadProperty(202, \"else_expr\", result->else_expr);\n+\tdeserializer.ReadPropertyWithDefault<vector<BoundCaseCheck>>(201, \"case_checks\", result->case_checks);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(202, \"else_expr\", result->else_expr);\n \treturn std::move(result);\n }\n \n void BoundCastExpression::Serialize(Serializer &serializer) const {\n \tExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"child\", child);\n-\tserializer.WriteProperty(201, \"return_type\", return_type);\n-\tserializer.WriteProperty(202, \"try_cast\", try_cast);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(200, \"child\", child);\n+\tserializer.WriteProperty<LogicalType>(201, \"return_type\", return_type);\n+\tserializer.WritePropertyWithDefault<bool>(202, \"try_cast\", try_cast);\n }\n \n unique_ptr<Expression> BoundCastExpression::Deserialize(Deserializer &deserializer) {\n-\tauto child = deserializer.ReadProperty<unique_ptr<Expression>>(200, \"child\");\n+\tauto child = deserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(200, \"child\");\n \tauto return_type = deserializer.ReadProperty<LogicalType>(201, \"return_type\");\n \tauto result = duckdb::unique_ptr<BoundCastExpression>(new BoundCastExpression(deserializer.Get<ClientContext &>(), std::move(child), std::move(return_type)));\n-\tdeserializer.ReadProperty(202, \"try_cast\", result->try_cast);\n+\tdeserializer.ReadPropertyWithDefault<bool>(202, \"try_cast\", result->try_cast);\n \treturn std::move(result);\n }\n \n void BoundColumnRefExpression::Serialize(Serializer &serializer) const {\n \tExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"return_type\", return_type);\n-\tserializer.WriteProperty(201, \"binding\", binding);\n-\tserializer.WriteProperty(202, \"depth\", depth);\n+\tserializer.WriteProperty<LogicalType>(200, \"return_type\", return_type);\n+\tserializer.WriteProperty<ColumnBinding>(201, \"binding\", binding);\n+\tserializer.WritePropertyWithDefault<idx_t>(202, \"depth\", depth);\n }\n \n unique_ptr<Expression> BoundColumnRefExpression::Deserialize(Deserializer &deserializer) {\n \tauto return_type = deserializer.ReadProperty<LogicalType>(200, \"return_type\");\n \tauto binding = deserializer.ReadProperty<ColumnBinding>(201, \"binding\");\n-\tauto depth = deserializer.ReadProperty<idx_t>(202, \"depth\");\n+\tauto depth = deserializer.ReadPropertyWithDefault<idx_t>(202, \"depth\");\n \tauto result = duckdb::unique_ptr<BoundColumnRefExpression>(new BoundColumnRefExpression(std::move(return_type), binding, depth));\n \treturn std::move(result);\n }\n \n void BoundComparisonExpression::Serialize(Serializer &serializer) const {\n \tExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"left\", left);\n-\tserializer.WriteProperty(201, \"right\", right);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(200, \"left\", left);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(201, \"right\", right);\n }\n \n unique_ptr<Expression> BoundComparisonExpression::Deserialize(Deserializer &deserializer) {\n-\tauto left = deserializer.ReadProperty<unique_ptr<Expression>>(200, \"left\");\n-\tauto right = deserializer.ReadProperty<unique_ptr<Expression>>(201, \"right\");\n+\tauto left = deserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(200, \"left\");\n+\tauto right = deserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(201, \"right\");\n \tauto result = duckdb::unique_ptr<BoundComparisonExpression>(new BoundComparisonExpression(deserializer.Get<ExpressionType>(), std::move(left), std::move(right)));\n \treturn std::move(result);\n }\n \n void BoundConjunctionExpression::Serialize(Serializer &serializer) const {\n \tExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"children\", children);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(200, \"children\", children);\n }\n \n unique_ptr<Expression> BoundConjunctionExpression::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<BoundConjunctionExpression>(new BoundConjunctionExpression(deserializer.Get<ExpressionType>()));\n-\tdeserializer.ReadProperty(200, \"children\", result->children);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(200, \"children\", result->children);\n \treturn std::move(result);\n }\n \n void BoundConstantExpression::Serialize(Serializer &serializer) const {\n \tExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"value\", value);\n+\tserializer.WriteProperty<Value>(200, \"value\", value);\n }\n \n unique_ptr<Expression> BoundConstantExpression::Deserialize(Deserializer &deserializer) {\n@@ -182,7 +182,7 @@ unique_ptr<Expression> BoundConstantExpression::Deserialize(Deserializer &deseri\n \n void BoundDefaultExpression::Serialize(Serializer &serializer) const {\n \tExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"return_type\", return_type);\n+\tserializer.WriteProperty<LogicalType>(200, \"return_type\", return_type);\n }\n \n unique_ptr<Expression> BoundDefaultExpression::Deserialize(Deserializer &deserializer) {\n@@ -193,17 +193,17 @@ unique_ptr<Expression> BoundDefaultExpression::Deserialize(Deserializer &deseria\n \n void BoundLambdaExpression::Serialize(Serializer &serializer) const {\n \tExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"return_type\", return_type);\n-\tserializer.WriteProperty(201, \"lambda_expr\", lambda_expr);\n-\tserializer.WriteProperty(202, \"captures\", captures);\n-\tserializer.WriteProperty(203, \"parameter_count\", parameter_count);\n+\tserializer.WriteProperty<LogicalType>(200, \"return_type\", return_type);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(201, \"lambda_expr\", lambda_expr);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(202, \"captures\", captures);\n+\tserializer.WritePropertyWithDefault<idx_t>(203, \"parameter_count\", parameter_count);\n }\n \n unique_ptr<Expression> BoundLambdaExpression::Deserialize(Deserializer &deserializer) {\n \tauto return_type = deserializer.ReadProperty<LogicalType>(200, \"return_type\");\n-\tauto lambda_expr = deserializer.ReadProperty<unique_ptr<Expression>>(201, \"lambda_expr\");\n-\tauto captures = deserializer.ReadProperty<vector<unique_ptr<Expression>>>(202, \"captures\");\n-\tauto parameter_count = deserializer.ReadProperty<idx_t>(203, \"parameter_count\");\n+\tauto lambda_expr = deserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(201, \"lambda_expr\");\n+\tauto captures = deserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(202, \"captures\");\n+\tauto parameter_count = deserializer.ReadPropertyWithDefault<idx_t>(203, \"parameter_count\");\n \tauto result = duckdb::unique_ptr<BoundLambdaExpression>(new BoundLambdaExpression(deserializer.Get<ExpressionType>(), std::move(return_type), std::move(lambda_expr), parameter_count));\n \tresult->captures = std::move(captures);\n \treturn std::move(result);\n@@ -211,72 +211,72 @@ unique_ptr<Expression> BoundLambdaExpression::Deserialize(Deserializer &deserial\n \n void BoundLambdaRefExpression::Serialize(Serializer &serializer) const {\n \tExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"return_type\", return_type);\n-\tserializer.WriteProperty(201, \"binding\", binding);\n-\tserializer.WriteProperty(202, \"lambda_index\", lambda_index);\n-\tserializer.WriteProperty(203, \"depth\", depth);\n+\tserializer.WriteProperty<LogicalType>(200, \"return_type\", return_type);\n+\tserializer.WriteProperty<ColumnBinding>(201, \"binding\", binding);\n+\tserializer.WritePropertyWithDefault<idx_t>(202, \"lambda_index\", lambda_index);\n+\tserializer.WritePropertyWithDefault<idx_t>(203, \"depth\", depth);\n }\n \n unique_ptr<Expression> BoundLambdaRefExpression::Deserialize(Deserializer &deserializer) {\n \tauto return_type = deserializer.ReadProperty<LogicalType>(200, \"return_type\");\n \tauto binding = deserializer.ReadProperty<ColumnBinding>(201, \"binding\");\n-\tauto lambda_index = deserializer.ReadProperty<idx_t>(202, \"lambda_index\");\n-\tauto depth = deserializer.ReadProperty<idx_t>(203, \"depth\");\n+\tauto lambda_index = deserializer.ReadPropertyWithDefault<idx_t>(202, \"lambda_index\");\n+\tauto depth = deserializer.ReadPropertyWithDefault<idx_t>(203, \"depth\");\n \tauto result = duckdb::unique_ptr<BoundLambdaRefExpression>(new BoundLambdaRefExpression(std::move(return_type), binding, lambda_index, depth));\n \treturn std::move(result);\n }\n \n void BoundOperatorExpression::Serialize(Serializer &serializer) const {\n \tExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"return_type\", return_type);\n-\tserializer.WriteProperty(201, \"children\", children);\n+\tserializer.WriteProperty<LogicalType>(200, \"return_type\", return_type);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(201, \"children\", children);\n }\n \n unique_ptr<Expression> BoundOperatorExpression::Deserialize(Deserializer &deserializer) {\n \tauto return_type = deserializer.ReadProperty<LogicalType>(200, \"return_type\");\n \tauto result = duckdb::unique_ptr<BoundOperatorExpression>(new BoundOperatorExpression(deserializer.Get<ExpressionType>(), std::move(return_type)));\n-\tdeserializer.ReadProperty(201, \"children\", result->children);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(201, \"children\", result->children);\n \treturn std::move(result);\n }\n \n void BoundParameterExpression::Serialize(Serializer &serializer) const {\n \tExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"identifier\", identifier);\n-\tserializer.WriteProperty(201, \"return_type\", return_type);\n-\tserializer.WriteProperty(202, \"parameter_data\", parameter_data);\n+\tserializer.WritePropertyWithDefault<string>(200, \"identifier\", identifier);\n+\tserializer.WriteProperty<LogicalType>(201, \"return_type\", return_type);\n+\tserializer.WritePropertyWithDefault<shared_ptr<BoundParameterData>>(202, \"parameter_data\", parameter_data);\n }\n \n unique_ptr<Expression> BoundParameterExpression::Deserialize(Deserializer &deserializer) {\n-\tauto identifier = deserializer.ReadProperty<string>(200, \"identifier\");\n+\tauto identifier = deserializer.ReadPropertyWithDefault<string>(200, \"identifier\");\n \tauto return_type = deserializer.ReadProperty<LogicalType>(201, \"return_type\");\n-\tauto parameter_data = deserializer.ReadProperty<shared_ptr<BoundParameterData>>(202, \"parameter_data\");\n+\tauto parameter_data = deserializer.ReadPropertyWithDefault<shared_ptr<BoundParameterData>>(202, \"parameter_data\");\n \tauto result = duckdb::unique_ptr<BoundParameterExpression>(new BoundParameterExpression(deserializer.Get<bound_parameter_map_t &>(), std::move(identifier), std::move(return_type), std::move(parameter_data)));\n \treturn std::move(result);\n }\n \n void BoundReferenceExpression::Serialize(Serializer &serializer) const {\n \tExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"return_type\", return_type);\n-\tserializer.WriteProperty(201, \"index\", index);\n+\tserializer.WriteProperty<LogicalType>(200, \"return_type\", return_type);\n+\tserializer.WritePropertyWithDefault<idx_t>(201, \"index\", index);\n }\n \n unique_ptr<Expression> BoundReferenceExpression::Deserialize(Deserializer &deserializer) {\n \tauto return_type = deserializer.ReadProperty<LogicalType>(200, \"return_type\");\n-\tauto index = deserializer.ReadProperty<idx_t>(201, \"index\");\n+\tauto index = deserializer.ReadPropertyWithDefault<idx_t>(201, \"index\");\n \tauto result = duckdb::unique_ptr<BoundReferenceExpression>(new BoundReferenceExpression(std::move(return_type), index));\n \treturn std::move(result);\n }\n \n void BoundUnnestExpression::Serialize(Serializer &serializer) const {\n \tExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"return_type\", return_type);\n-\tserializer.WriteProperty(201, \"child\", child);\n+\tserializer.WriteProperty<LogicalType>(200, \"return_type\", return_type);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(201, \"child\", child);\n }\n \n unique_ptr<Expression> BoundUnnestExpression::Deserialize(Deserializer &deserializer) {\n \tauto return_type = deserializer.ReadProperty<LogicalType>(200, \"return_type\");\n \tauto result = duckdb::unique_ptr<BoundUnnestExpression>(new BoundUnnestExpression(std::move(return_type)));\n-\tdeserializer.ReadProperty(201, \"child\", result->child);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(201, \"child\", result->child);\n \treturn std::move(result);\n }\n \ndiff --git a/src/storage/serialization/serialize_logical_operator.cpp b/src/storage/serialization/serialize_logical_operator.cpp\nindex ff8da4919bee..f64dcab5a95d 100644\n--- a/src/storage/serialization/serialize_logical_operator.cpp\n+++ b/src/storage/serialization/serialize_logical_operator.cpp\n@@ -12,13 +12,13 @@\n namespace duckdb {\n \n void LogicalOperator::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"type\", type);\n-\tserializer.WriteProperty(101, \"children\", children);\n+\tserializer.WriteProperty<LogicalOperatorType>(100, \"type\", type);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<LogicalOperator>>>(101, \"children\", children);\n }\n \n unique_ptr<LogicalOperator> LogicalOperator::Deserialize(Deserializer &deserializer) {\n \tauto type = deserializer.ReadProperty<LogicalOperatorType>(100, \"type\");\n-\tauto children = deserializer.ReadProperty<vector<unique_ptr<LogicalOperator>>>(101, \"children\");\n+\tauto children = deserializer.ReadPropertyWithDefault<vector<unique_ptr<LogicalOperator>>>(101, \"children\");\n \tdeserializer.Set<LogicalOperatorType>(type);\n \tunique_ptr<LogicalOperator> result;\n \tswitch (type) {\n@@ -191,60 +191,60 @@ unique_ptr<LogicalOperator> LogicalOperator::Deserialize(Deserializer &deseriali\n \n void LogicalAggregate::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"expressions\", expressions);\n-\tserializer.WriteProperty(201, \"group_index\", group_index);\n-\tserializer.WriteProperty(202, \"aggregate_index\", aggregate_index);\n-\tserializer.WriteProperty(203, \"groupings_index\", groupings_index);\n-\tserializer.WriteProperty(204, \"groups\", groups);\n-\tserializer.WriteProperty(205, \"grouping_sets\", grouping_sets);\n-\tserializer.WriteProperty(206, \"grouping_functions\", grouping_functions);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(200, \"expressions\", expressions);\n+\tserializer.WritePropertyWithDefault<idx_t>(201, \"group_index\", group_index);\n+\tserializer.WritePropertyWithDefault<idx_t>(202, \"aggregate_index\", aggregate_index);\n+\tserializer.WritePropertyWithDefault<idx_t>(203, \"groupings_index\", groupings_index);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(204, \"groups\", groups);\n+\tserializer.WritePropertyWithDefault<vector<GroupingSet>>(205, \"grouping_sets\", grouping_sets);\n+\tserializer.WritePropertyWithDefault<vector<unsafe_vector<idx_t>>>(206, \"grouping_functions\", grouping_functions);\n }\n \n unique_ptr<LogicalOperator> LogicalAggregate::Deserialize(Deserializer &deserializer) {\n-\tauto expressions = deserializer.ReadProperty<vector<unique_ptr<Expression>>>(200, \"expressions\");\n-\tauto group_index = deserializer.ReadProperty<idx_t>(201, \"group_index\");\n-\tauto aggregate_index = deserializer.ReadProperty<idx_t>(202, \"aggregate_index\");\n+\tauto expressions = deserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(200, \"expressions\");\n+\tauto group_index = deserializer.ReadPropertyWithDefault<idx_t>(201, \"group_index\");\n+\tauto aggregate_index = deserializer.ReadPropertyWithDefault<idx_t>(202, \"aggregate_index\");\n \tauto result = duckdb::unique_ptr<LogicalAggregate>(new LogicalAggregate(group_index, aggregate_index, std::move(expressions)));\n-\tdeserializer.ReadProperty(203, \"groupings_index\", result->groupings_index);\n-\tdeserializer.ReadProperty(204, \"groups\", result->groups);\n-\tdeserializer.ReadProperty(205, \"grouping_sets\", result->grouping_sets);\n-\tdeserializer.ReadProperty(206, \"grouping_functions\", result->grouping_functions);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(203, \"groupings_index\", result->groupings_index);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(204, \"groups\", result->groups);\n+\tdeserializer.ReadPropertyWithDefault<vector<GroupingSet>>(205, \"grouping_sets\", result->grouping_sets);\n+\tdeserializer.ReadPropertyWithDefault<vector<unsafe_vector<idx_t>>>(206, \"grouping_functions\", result->grouping_functions);\n \treturn std::move(result);\n }\n \n void LogicalAnyJoin::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"join_type\", join_type);\n-\tserializer.WriteProperty(201, \"mark_index\", mark_index);\n-\tserializer.WriteProperty(202, \"left_projection_map\", left_projection_map);\n-\tserializer.WriteProperty(203, \"right_projection_map\", right_projection_map);\n-\tserializer.WriteProperty(204, \"condition\", condition);\n+\tserializer.WriteProperty<JoinType>(200, \"join_type\", join_type);\n+\tserializer.WritePropertyWithDefault<idx_t>(201, \"mark_index\", mark_index);\n+\tserializer.WritePropertyWithDefault<vector<idx_t>>(202, \"left_projection_map\", left_projection_map);\n+\tserializer.WritePropertyWithDefault<vector<idx_t>>(203, \"right_projection_map\", right_projection_map);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(204, \"condition\", condition);\n }\n \n unique_ptr<LogicalOperator> LogicalAnyJoin::Deserialize(Deserializer &deserializer) {\n \tauto join_type = deserializer.ReadProperty<JoinType>(200, \"join_type\");\n \tauto result = duckdb::unique_ptr<LogicalAnyJoin>(new LogicalAnyJoin(join_type));\n-\tdeserializer.ReadProperty(201, \"mark_index\", result->mark_index);\n-\tdeserializer.ReadProperty(202, \"left_projection_map\", result->left_projection_map);\n-\tdeserializer.ReadProperty(203, \"right_projection_map\", result->right_projection_map);\n-\tdeserializer.ReadProperty(204, \"condition\", result->condition);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(201, \"mark_index\", result->mark_index);\n+\tdeserializer.ReadPropertyWithDefault<vector<idx_t>>(202, \"left_projection_map\", result->left_projection_map);\n+\tdeserializer.ReadPropertyWithDefault<vector<idx_t>>(203, \"right_projection_map\", result->right_projection_map);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(204, \"condition\", result->condition);\n \treturn std::move(result);\n }\n \n void LogicalCTERef::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"table_index\", table_index);\n-\tserializer.WriteProperty(201, \"cte_index\", cte_index);\n-\tserializer.WriteProperty(202, \"chunk_types\", chunk_types);\n-\tserializer.WriteProperty(203, \"bound_columns\", bound_columns);\n-\tserializer.WriteProperty(204, \"materialized_cte\", materialized_cte);\n+\tserializer.WritePropertyWithDefault<idx_t>(200, \"table_index\", table_index);\n+\tserializer.WritePropertyWithDefault<idx_t>(201, \"cte_index\", cte_index);\n+\tserializer.WritePropertyWithDefault<vector<LogicalType>>(202, \"chunk_types\", chunk_types);\n+\tserializer.WritePropertyWithDefault<vector<string>>(203, \"bound_columns\", bound_columns);\n+\tserializer.WriteProperty<CTEMaterialize>(204, \"materialized_cte\", materialized_cte);\n }\n \n unique_ptr<LogicalOperator> LogicalCTERef::Deserialize(Deserializer &deserializer) {\n-\tauto table_index = deserializer.ReadProperty<idx_t>(200, \"table_index\");\n-\tauto cte_index = deserializer.ReadProperty<idx_t>(201, \"cte_index\");\n-\tauto chunk_types = deserializer.ReadProperty<vector<LogicalType>>(202, \"chunk_types\");\n-\tauto bound_columns = deserializer.ReadProperty<vector<string>>(203, \"bound_columns\");\n+\tauto table_index = deserializer.ReadPropertyWithDefault<idx_t>(200, \"table_index\");\n+\tauto cte_index = deserializer.ReadPropertyWithDefault<idx_t>(201, \"cte_index\");\n+\tauto chunk_types = deserializer.ReadPropertyWithDefault<vector<LogicalType>>(202, \"chunk_types\");\n+\tauto bound_columns = deserializer.ReadPropertyWithDefault<vector<string>>(203, \"bound_columns\");\n \tauto materialized_cte = deserializer.ReadProperty<CTEMaterialize>(204, \"materialized_cte\");\n \tauto result = duckdb::unique_ptr<LogicalCTERef>(new LogicalCTERef(table_index, cte_index, std::move(chunk_types), std::move(bound_columns), materialized_cte));\n \treturn std::move(result);\n@@ -252,73 +252,73 @@ unique_ptr<LogicalOperator> LogicalCTERef::Deserialize(Deserializer &deserialize\n \n void LogicalColumnDataGet::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"table_index\", table_index);\n-\tserializer.WriteProperty(201, \"chunk_types\", chunk_types);\n-\tserializer.WriteProperty(202, \"collection\", collection);\n+\tserializer.WritePropertyWithDefault<idx_t>(200, \"table_index\", table_index);\n+\tserializer.WritePropertyWithDefault<vector<LogicalType>>(201, \"chunk_types\", chunk_types);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ColumnDataCollection>>(202, \"collection\", collection);\n }\n \n unique_ptr<LogicalOperator> LogicalColumnDataGet::Deserialize(Deserializer &deserializer) {\n-\tauto table_index = deserializer.ReadProperty<idx_t>(200, \"table_index\");\n-\tauto chunk_types = deserializer.ReadProperty<vector<LogicalType>>(201, \"chunk_types\");\n-\tauto collection = deserializer.ReadProperty<unique_ptr<ColumnDataCollection>>(202, \"collection\");\n+\tauto table_index = deserializer.ReadPropertyWithDefault<idx_t>(200, \"table_index\");\n+\tauto chunk_types = deserializer.ReadPropertyWithDefault<vector<LogicalType>>(201, \"chunk_types\");\n+\tauto collection = deserializer.ReadPropertyWithDefault<unique_ptr<ColumnDataCollection>>(202, \"collection\");\n \tauto result = duckdb::unique_ptr<LogicalColumnDataGet>(new LogicalColumnDataGet(table_index, std::move(chunk_types), std::move(collection)));\n \treturn std::move(result);\n }\n \n void LogicalComparisonJoin::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"join_type\", join_type);\n-\tserializer.WriteProperty(201, \"mark_index\", mark_index);\n-\tserializer.WriteProperty(202, \"left_projection_map\", left_projection_map);\n-\tserializer.WriteProperty(203, \"right_projection_map\", right_projection_map);\n-\tserializer.WriteProperty(204, \"conditions\", conditions);\n-\tserializer.WriteProperty(205, \"mark_types\", mark_types);\n-\tserializer.WriteProperty(206, \"duplicate_eliminated_columns\", duplicate_eliminated_columns);\n+\tserializer.WriteProperty<JoinType>(200, \"join_type\", join_type);\n+\tserializer.WritePropertyWithDefault<idx_t>(201, \"mark_index\", mark_index);\n+\tserializer.WritePropertyWithDefault<vector<idx_t>>(202, \"left_projection_map\", left_projection_map);\n+\tserializer.WritePropertyWithDefault<vector<idx_t>>(203, \"right_projection_map\", right_projection_map);\n+\tserializer.WritePropertyWithDefault<vector<JoinCondition>>(204, \"conditions\", conditions);\n+\tserializer.WritePropertyWithDefault<vector<LogicalType>>(205, \"mark_types\", mark_types);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(206, \"duplicate_eliminated_columns\", duplicate_eliminated_columns);\n }\n \n unique_ptr<LogicalOperator> LogicalComparisonJoin::Deserialize(Deserializer &deserializer) {\n \tauto join_type = deserializer.ReadProperty<JoinType>(200, \"join_type\");\n \tauto result = duckdb::unique_ptr<LogicalComparisonJoin>(new LogicalComparisonJoin(join_type, deserializer.Get<LogicalOperatorType>()));\n-\tdeserializer.ReadProperty(201, \"mark_index\", result->mark_index);\n-\tdeserializer.ReadProperty(202, \"left_projection_map\", result->left_projection_map);\n-\tdeserializer.ReadProperty(203, \"right_projection_map\", result->right_projection_map);\n-\tdeserializer.ReadProperty(204, \"conditions\", result->conditions);\n-\tdeserializer.ReadProperty(205, \"mark_types\", result->mark_types);\n-\tdeserializer.ReadProperty(206, \"duplicate_eliminated_columns\", result->duplicate_eliminated_columns);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(201, \"mark_index\", result->mark_index);\n+\tdeserializer.ReadPropertyWithDefault<vector<idx_t>>(202, \"left_projection_map\", result->left_projection_map);\n+\tdeserializer.ReadPropertyWithDefault<vector<idx_t>>(203, \"right_projection_map\", result->right_projection_map);\n+\tdeserializer.ReadPropertyWithDefault<vector<JoinCondition>>(204, \"conditions\", result->conditions);\n+\tdeserializer.ReadPropertyWithDefault<vector<LogicalType>>(205, \"mark_types\", result->mark_types);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(206, \"duplicate_eliminated_columns\", result->duplicate_eliminated_columns);\n \treturn std::move(result);\n }\n \n void LogicalCreate::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"info\", info);\n+\tserializer.WritePropertyWithDefault<unique_ptr<CreateInfo>>(200, \"info\", info);\n }\n \n unique_ptr<LogicalOperator> LogicalCreate::Deserialize(Deserializer &deserializer) {\n-\tauto info = deserializer.ReadProperty<unique_ptr<CreateInfo>>(200, \"info\");\n+\tauto info = deserializer.ReadPropertyWithDefault<unique_ptr<CreateInfo>>(200, \"info\");\n \tauto result = duckdb::unique_ptr<LogicalCreate>(new LogicalCreate(deserializer.Get<LogicalOperatorType>(), deserializer.Get<ClientContext &>(), std::move(info)));\n \treturn std::move(result);\n }\n \n void LogicalCreateIndex::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"info\", info);\n-\tserializer.WriteProperty(201, \"unbound_expressions\", unbound_expressions);\n+\tserializer.WritePropertyWithDefault<unique_ptr<CreateIndexInfo>>(200, \"info\", info);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(201, \"unbound_expressions\", unbound_expressions);\n }\n \n unique_ptr<LogicalOperator> LogicalCreateIndex::Deserialize(Deserializer &deserializer) {\n-\tauto info = deserializer.ReadProperty<unique_ptr<CreateInfo>>(200, \"info\");\n-\tauto unbound_expressions = deserializer.ReadProperty<vector<unique_ptr<Expression>>>(201, \"unbound_expressions\");\n+\tauto info = deserializer.ReadPropertyWithDefault<unique_ptr<CreateInfo>>(200, \"info\");\n+\tauto unbound_expressions = deserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(201, \"unbound_expressions\");\n \tauto result = duckdb::unique_ptr<LogicalCreateIndex>(new LogicalCreateIndex(deserializer.Get<ClientContext &>(), std::move(info), std::move(unbound_expressions)));\n \treturn std::move(result);\n }\n \n void LogicalCreateTable::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"info\", info->base);\n+\tserializer.WritePropertyWithDefault<unique_ptr<CreateInfo>>(200, \"info\", info->base);\n }\n \n unique_ptr<LogicalOperator> LogicalCreateTable::Deserialize(Deserializer &deserializer) {\n-\tauto info = deserializer.ReadProperty<unique_ptr<CreateInfo>>(200, \"info\");\n+\tauto info = deserializer.ReadPropertyWithDefault<unique_ptr<CreateInfo>>(200, \"info\");\n \tauto result = duckdb::unique_ptr<LogicalCreateTable>(new LogicalCreateTable(deserializer.Get<ClientContext &>(), std::move(info)));\n \treturn std::move(result);\n }\n@@ -334,235 +334,235 @@ unique_ptr<LogicalOperator> LogicalCrossProduct::Deserialize(Deserializer &deser\n \n void LogicalDelete::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"table_info\", table.GetInfo());\n-\tserializer.WriteProperty(201, \"table_index\", table_index);\n-\tserializer.WriteProperty(202, \"return_chunk\", return_chunk);\n-\tserializer.WriteProperty(203, \"expressions\", expressions);\n+\tserializer.WritePropertyWithDefault<unique_ptr<CreateInfo>>(200, \"table_info\", table.GetInfo());\n+\tserializer.WritePropertyWithDefault<idx_t>(201, \"table_index\", table_index);\n+\tserializer.WritePropertyWithDefault<bool>(202, \"return_chunk\", return_chunk);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(203, \"expressions\", expressions);\n }\n \n unique_ptr<LogicalOperator> LogicalDelete::Deserialize(Deserializer &deserializer) {\n-\tauto table_info = deserializer.ReadProperty<unique_ptr<CreateInfo>>(200, \"table_info\");\n+\tauto table_info = deserializer.ReadPropertyWithDefault<unique_ptr<CreateInfo>>(200, \"table_info\");\n \tauto result = duckdb::unique_ptr<LogicalDelete>(new LogicalDelete(deserializer.Get<ClientContext &>(), table_info));\n-\tdeserializer.ReadProperty(201, \"table_index\", result->table_index);\n-\tdeserializer.ReadProperty(202, \"return_chunk\", result->return_chunk);\n-\tdeserializer.ReadProperty(203, \"expressions\", result->expressions);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(201, \"table_index\", result->table_index);\n+\tdeserializer.ReadPropertyWithDefault<bool>(202, \"return_chunk\", result->return_chunk);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(203, \"expressions\", result->expressions);\n \treturn std::move(result);\n }\n \n void LogicalDelimGet::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"table_index\", table_index);\n-\tserializer.WriteProperty(201, \"chunk_types\", chunk_types);\n+\tserializer.WritePropertyWithDefault<idx_t>(200, \"table_index\", table_index);\n+\tserializer.WritePropertyWithDefault<vector<LogicalType>>(201, \"chunk_types\", chunk_types);\n }\n \n unique_ptr<LogicalOperator> LogicalDelimGet::Deserialize(Deserializer &deserializer) {\n-\tauto table_index = deserializer.ReadProperty<idx_t>(200, \"table_index\");\n-\tauto chunk_types = deserializer.ReadProperty<vector<LogicalType>>(201, \"chunk_types\");\n+\tauto table_index = deserializer.ReadPropertyWithDefault<idx_t>(200, \"table_index\");\n+\tauto chunk_types = deserializer.ReadPropertyWithDefault<vector<LogicalType>>(201, \"chunk_types\");\n \tauto result = duckdb::unique_ptr<LogicalDelimGet>(new LogicalDelimGet(table_index, std::move(chunk_types)));\n \treturn std::move(result);\n }\n \n void LogicalDistinct::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"distinct_type\", distinct_type);\n-\tserializer.WriteProperty(201, \"distinct_targets\", distinct_targets);\n-\tserializer.WritePropertyWithDefault(202, \"order_by\", order_by, unique_ptr<BoundOrderModifier>());\n+\tserializer.WriteProperty<DistinctType>(200, \"distinct_type\", distinct_type);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(201, \"distinct_targets\", distinct_targets);\n+\tserializer.WritePropertyWithDefault<unique_ptr<BoundOrderModifier>>(202, \"order_by\", order_by);\n }\n \n unique_ptr<LogicalOperator> LogicalDistinct::Deserialize(Deserializer &deserializer) {\n \tauto distinct_type = deserializer.ReadProperty<DistinctType>(200, \"distinct_type\");\n-\tauto distinct_targets = deserializer.ReadProperty<vector<unique_ptr<Expression>>>(201, \"distinct_targets\");\n+\tauto distinct_targets = deserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(201, \"distinct_targets\");\n \tauto result = duckdb::unique_ptr<LogicalDistinct>(new LogicalDistinct(std::move(distinct_targets), distinct_type));\n-\tdeserializer.ReadPropertyWithDefault(202, \"order_by\", result->order_by, unique_ptr<BoundOrderModifier>());\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<BoundOrderModifier>>(202, \"order_by\", result->order_by);\n \treturn std::move(result);\n }\n \n void LogicalDummyScan::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"table_index\", table_index);\n+\tserializer.WritePropertyWithDefault<idx_t>(200, \"table_index\", table_index);\n }\n \n unique_ptr<LogicalOperator> LogicalDummyScan::Deserialize(Deserializer &deserializer) {\n-\tauto table_index = deserializer.ReadProperty<idx_t>(200, \"table_index\");\n+\tauto table_index = deserializer.ReadPropertyWithDefault<idx_t>(200, \"table_index\");\n \tauto result = duckdb::unique_ptr<LogicalDummyScan>(new LogicalDummyScan(table_index));\n \treturn std::move(result);\n }\n \n void LogicalEmptyResult::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"return_types\", return_types);\n-\tserializer.WriteProperty(201, \"bindings\", bindings);\n+\tserializer.WritePropertyWithDefault<vector<LogicalType>>(200, \"return_types\", return_types);\n+\tserializer.WritePropertyWithDefault<vector<ColumnBinding>>(201, \"bindings\", bindings);\n }\n \n unique_ptr<LogicalOperator> LogicalEmptyResult::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<LogicalEmptyResult>(new LogicalEmptyResult());\n-\tdeserializer.ReadProperty(200, \"return_types\", result->return_types);\n-\tdeserializer.ReadProperty(201, \"bindings\", result->bindings);\n+\tdeserializer.ReadPropertyWithDefault<vector<LogicalType>>(200, \"return_types\", result->return_types);\n+\tdeserializer.ReadPropertyWithDefault<vector<ColumnBinding>>(201, \"bindings\", result->bindings);\n \treturn std::move(result);\n }\n \n void LogicalExplain::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"explain_type\", explain_type);\n-\tserializer.WriteProperty(201, \"physical_plan\", physical_plan);\n-\tserializer.WriteProperty(202, \"logical_plan_unopt\", logical_plan_unopt);\n-\tserializer.WriteProperty(203, \"logical_plan_opt\", logical_plan_opt);\n+\tserializer.WriteProperty<ExplainType>(200, \"explain_type\", explain_type);\n+\tserializer.WritePropertyWithDefault<string>(201, \"physical_plan\", physical_plan);\n+\tserializer.WritePropertyWithDefault<string>(202, \"logical_plan_unopt\", logical_plan_unopt);\n+\tserializer.WritePropertyWithDefault<string>(203, \"logical_plan_opt\", logical_plan_opt);\n }\n \n unique_ptr<LogicalOperator> LogicalExplain::Deserialize(Deserializer &deserializer) {\n \tauto explain_type = deserializer.ReadProperty<ExplainType>(200, \"explain_type\");\n \tauto result = duckdb::unique_ptr<LogicalExplain>(new LogicalExplain(explain_type));\n-\tdeserializer.ReadProperty(201, \"physical_plan\", result->physical_plan);\n-\tdeserializer.ReadProperty(202, \"logical_plan_unopt\", result->logical_plan_unopt);\n-\tdeserializer.ReadProperty(203, \"logical_plan_opt\", result->logical_plan_opt);\n+\tdeserializer.ReadPropertyWithDefault<string>(201, \"physical_plan\", result->physical_plan);\n+\tdeserializer.ReadPropertyWithDefault<string>(202, \"logical_plan_unopt\", result->logical_plan_unopt);\n+\tdeserializer.ReadPropertyWithDefault<string>(203, \"logical_plan_opt\", result->logical_plan_opt);\n \treturn std::move(result);\n }\n \n void LogicalExpressionGet::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"table_index\", table_index);\n-\tserializer.WriteProperty(201, \"expr_types\", expr_types);\n-\tserializer.WriteProperty(202, \"expressions\", expressions);\n+\tserializer.WritePropertyWithDefault<idx_t>(200, \"table_index\", table_index);\n+\tserializer.WritePropertyWithDefault<vector<LogicalType>>(201, \"expr_types\", expr_types);\n+\tserializer.WritePropertyWithDefault<vector<vector<unique_ptr<Expression>>>>(202, \"expressions\", expressions);\n }\n \n unique_ptr<LogicalOperator> LogicalExpressionGet::Deserialize(Deserializer &deserializer) {\n-\tauto table_index = deserializer.ReadProperty<idx_t>(200, \"table_index\");\n-\tauto expr_types = deserializer.ReadProperty<vector<LogicalType>>(201, \"expr_types\");\n-\tauto expressions = deserializer.ReadProperty<vector<vector<unique_ptr<Expression>>>>(202, \"expressions\");\n+\tauto table_index = deserializer.ReadPropertyWithDefault<idx_t>(200, \"table_index\");\n+\tauto expr_types = deserializer.ReadPropertyWithDefault<vector<LogicalType>>(201, \"expr_types\");\n+\tauto expressions = deserializer.ReadPropertyWithDefault<vector<vector<unique_ptr<Expression>>>>(202, \"expressions\");\n \tauto result = duckdb::unique_ptr<LogicalExpressionGet>(new LogicalExpressionGet(table_index, std::move(expr_types), std::move(expressions)));\n \treturn std::move(result);\n }\n \n void LogicalFilter::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"expressions\", expressions);\n-\tserializer.WriteProperty(201, \"projection_map\", projection_map);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(200, \"expressions\", expressions);\n+\tserializer.WritePropertyWithDefault<vector<idx_t>>(201, \"projection_map\", projection_map);\n }\n \n unique_ptr<LogicalOperator> LogicalFilter::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<LogicalFilter>(new LogicalFilter());\n-\tdeserializer.ReadProperty(200, \"expressions\", result->expressions);\n-\tdeserializer.ReadProperty(201, \"projection_map\", result->projection_map);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(200, \"expressions\", result->expressions);\n+\tdeserializer.ReadPropertyWithDefault<vector<idx_t>>(201, \"projection_map\", result->projection_map);\n \treturn std::move(result);\n }\n \n void LogicalInsert::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"table_info\", table.GetInfo());\n-\tserializer.WriteProperty(201, \"insert_values\", insert_values);\n-\tserializer.WriteProperty(202, \"column_index_map\", column_index_map);\n-\tserializer.WriteProperty(203, \"expected_types\", expected_types);\n-\tserializer.WriteProperty(204, \"table_index\", table_index);\n-\tserializer.WriteProperty(205, \"return_chunk\", return_chunk);\n-\tserializer.WriteProperty(206, \"bound_defaults\", bound_defaults);\n-\tserializer.WriteProperty(207, \"action_type\", action_type);\n-\tserializer.WriteProperty(208, \"expected_set_types\", expected_set_types);\n-\tserializer.WriteProperty(209, \"on_conflict_filter\", on_conflict_filter);\n-\tserializer.WritePropertyWithDefault(210, \"on_conflict_condition\", on_conflict_condition, unique_ptr<Expression>());\n-\tserializer.WritePropertyWithDefault(211, \"do_update_condition\", do_update_condition, unique_ptr<Expression>());\n-\tserializer.WriteProperty(212, \"set_columns\", set_columns);\n-\tserializer.WriteProperty(213, \"set_types\", set_types);\n-\tserializer.WriteProperty(214, \"excluded_table_index\", excluded_table_index);\n-\tserializer.WriteProperty(215, \"columns_to_fetch\", columns_to_fetch);\n-\tserializer.WriteProperty(216, \"source_columns\", source_columns);\n-\tserializer.WriteProperty(217, \"expressions\", expressions);\n+\tserializer.WritePropertyWithDefault<unique_ptr<CreateInfo>>(200, \"table_info\", table.GetInfo());\n+\tserializer.WritePropertyWithDefault<vector<vector<unique_ptr<Expression>>>>(201, \"insert_values\", insert_values);\n+\tserializer.WriteProperty<IndexVector<idx_t, PhysicalIndex>>(202, \"column_index_map\", column_index_map);\n+\tserializer.WritePropertyWithDefault<vector<LogicalType>>(203, \"expected_types\", expected_types);\n+\tserializer.WritePropertyWithDefault<idx_t>(204, \"table_index\", table_index);\n+\tserializer.WritePropertyWithDefault<bool>(205, \"return_chunk\", return_chunk);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(206, \"bound_defaults\", bound_defaults);\n+\tserializer.WriteProperty<OnConflictAction>(207, \"action_type\", action_type);\n+\tserializer.WritePropertyWithDefault<vector<LogicalType>>(208, \"expected_set_types\", expected_set_types);\n+\tserializer.WritePropertyWithDefault<unordered_set<idx_t>>(209, \"on_conflict_filter\", on_conflict_filter);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(210, \"on_conflict_condition\", on_conflict_condition);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(211, \"do_update_condition\", do_update_condition);\n+\tserializer.WritePropertyWithDefault<vector<PhysicalIndex>>(212, \"set_columns\", set_columns);\n+\tserializer.WritePropertyWithDefault<vector<LogicalType>>(213, \"set_types\", set_types);\n+\tserializer.WritePropertyWithDefault<idx_t>(214, \"excluded_table_index\", excluded_table_index);\n+\tserializer.WritePropertyWithDefault<vector<column_t>>(215, \"columns_to_fetch\", columns_to_fetch);\n+\tserializer.WritePropertyWithDefault<vector<column_t>>(216, \"source_columns\", source_columns);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(217, \"expressions\", expressions);\n }\n \n unique_ptr<LogicalOperator> LogicalInsert::Deserialize(Deserializer &deserializer) {\n-\tauto table_info = deserializer.ReadProperty<unique_ptr<CreateInfo>>(200, \"table_info\");\n+\tauto table_info = deserializer.ReadPropertyWithDefault<unique_ptr<CreateInfo>>(200, \"table_info\");\n \tauto result = duckdb::unique_ptr<LogicalInsert>(new LogicalInsert(deserializer.Get<ClientContext &>(), std::move(table_info)));\n-\tdeserializer.ReadProperty(201, \"insert_values\", result->insert_values);\n-\tdeserializer.ReadProperty(202, \"column_index_map\", result->column_index_map);\n-\tdeserializer.ReadProperty(203, \"expected_types\", result->expected_types);\n-\tdeserializer.ReadProperty(204, \"table_index\", result->table_index);\n-\tdeserializer.ReadProperty(205, \"return_chunk\", result->return_chunk);\n-\tdeserializer.ReadProperty(206, \"bound_defaults\", result->bound_defaults);\n-\tdeserializer.ReadProperty(207, \"action_type\", result->action_type);\n-\tdeserializer.ReadProperty(208, \"expected_set_types\", result->expected_set_types);\n-\tdeserializer.ReadProperty(209, \"on_conflict_filter\", result->on_conflict_filter);\n-\tdeserializer.ReadPropertyWithDefault(210, \"on_conflict_condition\", result->on_conflict_condition, unique_ptr<Expression>());\n-\tdeserializer.ReadPropertyWithDefault(211, \"do_update_condition\", result->do_update_condition, unique_ptr<Expression>());\n-\tdeserializer.ReadProperty(212, \"set_columns\", result->set_columns);\n-\tdeserializer.ReadProperty(213, \"set_types\", result->set_types);\n-\tdeserializer.ReadProperty(214, \"excluded_table_index\", result->excluded_table_index);\n-\tdeserializer.ReadProperty(215, \"columns_to_fetch\", result->columns_to_fetch);\n-\tdeserializer.ReadProperty(216, \"source_columns\", result->source_columns);\n-\tdeserializer.ReadProperty(217, \"expressions\", result->expressions);\n+\tdeserializer.ReadPropertyWithDefault<vector<vector<unique_ptr<Expression>>>>(201, \"insert_values\", result->insert_values);\n+\tdeserializer.ReadProperty<IndexVector<idx_t, PhysicalIndex>>(202, \"column_index_map\", result->column_index_map);\n+\tdeserializer.ReadPropertyWithDefault<vector<LogicalType>>(203, \"expected_types\", result->expected_types);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(204, \"table_index\", result->table_index);\n+\tdeserializer.ReadPropertyWithDefault<bool>(205, \"return_chunk\", result->return_chunk);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(206, \"bound_defaults\", result->bound_defaults);\n+\tdeserializer.ReadProperty<OnConflictAction>(207, \"action_type\", result->action_type);\n+\tdeserializer.ReadPropertyWithDefault<vector<LogicalType>>(208, \"expected_set_types\", result->expected_set_types);\n+\tdeserializer.ReadPropertyWithDefault<unordered_set<idx_t>>(209, \"on_conflict_filter\", result->on_conflict_filter);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(210, \"on_conflict_condition\", result->on_conflict_condition);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(211, \"do_update_condition\", result->do_update_condition);\n+\tdeserializer.ReadPropertyWithDefault<vector<PhysicalIndex>>(212, \"set_columns\", result->set_columns);\n+\tdeserializer.ReadPropertyWithDefault<vector<LogicalType>>(213, \"set_types\", result->set_types);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(214, \"excluded_table_index\", result->excluded_table_index);\n+\tdeserializer.ReadPropertyWithDefault<vector<column_t>>(215, \"columns_to_fetch\", result->columns_to_fetch);\n+\tdeserializer.ReadPropertyWithDefault<vector<column_t>>(216, \"source_columns\", result->source_columns);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(217, \"expressions\", result->expressions);\n \treturn std::move(result);\n }\n \n void LogicalLimit::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"limit_val\", limit_val);\n-\tserializer.WriteProperty(201, \"offset_val\", offset_val);\n-\tserializer.WritePropertyWithDefault(202, \"limit\", limit, unique_ptr<Expression>());\n-\tserializer.WritePropertyWithDefault(203, \"offset\", offset, unique_ptr<Expression>());\n+\tserializer.WritePropertyWithDefault<int64_t>(200, \"limit_val\", limit_val);\n+\tserializer.WritePropertyWithDefault<int64_t>(201, \"offset_val\", offset_val);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(202, \"limit\", limit);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(203, \"offset\", offset);\n }\n \n unique_ptr<LogicalOperator> LogicalLimit::Deserialize(Deserializer &deserializer) {\n-\tauto limit_val = deserializer.ReadProperty<int64_t>(200, \"limit_val\");\n-\tauto offset_val = deserializer.ReadProperty<int64_t>(201, \"offset_val\");\n-\tauto limit = deserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(202, \"limit\", unique_ptr<Expression>());\n-\tauto offset = deserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(203, \"offset\", unique_ptr<Expression>());\n+\tauto limit_val = deserializer.ReadPropertyWithDefault<int64_t>(200, \"limit_val\");\n+\tauto offset_val = deserializer.ReadPropertyWithDefault<int64_t>(201, \"offset_val\");\n+\tauto limit = deserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(202, \"limit\");\n+\tauto offset = deserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(203, \"offset\");\n \tauto result = duckdb::unique_ptr<LogicalLimit>(new LogicalLimit(limit_val, offset_val, std::move(limit), std::move(offset)));\n \treturn std::move(result);\n }\n \n void LogicalLimitPercent::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"limit_percent\", limit_percent);\n-\tserializer.WriteProperty(201, \"offset_val\", offset_val);\n-\tserializer.WritePropertyWithDefault(202, \"limit\", limit, unique_ptr<Expression>());\n-\tserializer.WritePropertyWithDefault(203, \"offset\", offset, unique_ptr<Expression>());\n+\tserializer.WriteProperty<double>(200, \"limit_percent\", limit_percent);\n+\tserializer.WritePropertyWithDefault<int64_t>(201, \"offset_val\", offset_val);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(202, \"limit\", limit);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(203, \"offset\", offset);\n }\n \n unique_ptr<LogicalOperator> LogicalLimitPercent::Deserialize(Deserializer &deserializer) {\n \tauto limit_percent = deserializer.ReadProperty<double>(200, \"limit_percent\");\n-\tauto offset_val = deserializer.ReadProperty<int64_t>(201, \"offset_val\");\n-\tauto limit = deserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(202, \"limit\", unique_ptr<Expression>());\n-\tauto offset = deserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(203, \"offset\", unique_ptr<Expression>());\n+\tauto offset_val = deserializer.ReadPropertyWithDefault<int64_t>(201, \"offset_val\");\n+\tauto limit = deserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(202, \"limit\");\n+\tauto offset = deserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(203, \"offset\");\n \tauto result = duckdb::unique_ptr<LogicalLimitPercent>(new LogicalLimitPercent(limit_percent, offset_val, std::move(limit), std::move(offset)));\n \treturn std::move(result);\n }\n \n void LogicalMaterializedCTE::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"table_index\", table_index);\n-\tserializer.WriteProperty(201, \"column_count\", column_count);\n-\tserializer.WriteProperty(202, \"ctename\", ctename);\n+\tserializer.WritePropertyWithDefault<idx_t>(200, \"table_index\", table_index);\n+\tserializer.WritePropertyWithDefault<idx_t>(201, \"column_count\", column_count);\n+\tserializer.WritePropertyWithDefault<string>(202, \"ctename\", ctename);\n }\n \n unique_ptr<LogicalOperator> LogicalMaterializedCTE::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<LogicalMaterializedCTE>(new LogicalMaterializedCTE());\n-\tdeserializer.ReadProperty(200, \"table_index\", result->table_index);\n-\tdeserializer.ReadProperty(201, \"column_count\", result->column_count);\n-\tdeserializer.ReadProperty(202, \"ctename\", result->ctename);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(200, \"table_index\", result->table_index);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(201, \"column_count\", result->column_count);\n+\tdeserializer.ReadPropertyWithDefault<string>(202, \"ctename\", result->ctename);\n \treturn std::move(result);\n }\n \n void LogicalOrder::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"orders\", orders);\n-\tserializer.WriteProperty(201, \"projections\", projections);\n+\tserializer.WritePropertyWithDefault<vector<BoundOrderByNode>>(200, \"orders\", orders);\n+\tserializer.WritePropertyWithDefault<vector<idx_t>>(201, \"projections\", projections);\n }\n \n unique_ptr<LogicalOperator> LogicalOrder::Deserialize(Deserializer &deserializer) {\n-\tauto orders = deserializer.ReadProperty<vector<BoundOrderByNode>>(200, \"orders\");\n+\tauto orders = deserializer.ReadPropertyWithDefault<vector<BoundOrderByNode>>(200, \"orders\");\n \tauto result = duckdb::unique_ptr<LogicalOrder>(new LogicalOrder(std::move(orders)));\n-\tdeserializer.ReadProperty(201, \"projections\", result->projections);\n+\tdeserializer.ReadPropertyWithDefault<vector<idx_t>>(201, \"projections\", result->projections);\n \treturn std::move(result);\n }\n \n void LogicalPivot::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"pivot_index\", pivot_index);\n-\tserializer.WriteProperty(201, \"bound_pivot\", bound_pivot);\n+\tserializer.WritePropertyWithDefault<idx_t>(200, \"pivot_index\", pivot_index);\n+\tserializer.WriteProperty<BoundPivotInfo>(201, \"bound_pivot\", bound_pivot);\n }\n \n unique_ptr<LogicalOperator> LogicalPivot::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<LogicalPivot>(new LogicalPivot());\n-\tdeserializer.ReadProperty(200, \"pivot_index\", result->pivot_index);\n-\tdeserializer.ReadProperty(201, \"bound_pivot\", result->bound_pivot);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(200, \"pivot_index\", result->pivot_index);\n+\tdeserializer.ReadProperty<BoundPivotInfo>(201, \"bound_pivot\", result->bound_pivot);\n \treturn std::move(result);\n }\n \n@@ -577,42 +577,42 @@ unique_ptr<LogicalOperator> LogicalPositionalJoin::Deserialize(Deserializer &des\n \n void LogicalProjection::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"table_index\", table_index);\n-\tserializer.WriteProperty(201, \"expressions\", expressions);\n+\tserializer.WritePropertyWithDefault<idx_t>(200, \"table_index\", table_index);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(201, \"expressions\", expressions);\n }\n \n unique_ptr<LogicalOperator> LogicalProjection::Deserialize(Deserializer &deserializer) {\n-\tauto table_index = deserializer.ReadProperty<idx_t>(200, \"table_index\");\n-\tauto expressions = deserializer.ReadProperty<vector<unique_ptr<Expression>>>(201, \"expressions\");\n+\tauto table_index = deserializer.ReadPropertyWithDefault<idx_t>(200, \"table_index\");\n+\tauto expressions = deserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(201, \"expressions\");\n \tauto result = duckdb::unique_ptr<LogicalProjection>(new LogicalProjection(table_index, std::move(expressions)));\n \treturn std::move(result);\n }\n \n void LogicalRecursiveCTE::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"union_all\", union_all);\n-\tserializer.WriteProperty(201, \"ctename\", ctename);\n-\tserializer.WriteProperty(202, \"table_index\", table_index);\n-\tserializer.WriteProperty(203, \"column_count\", column_count);\n+\tserializer.WritePropertyWithDefault<bool>(200, \"union_all\", union_all);\n+\tserializer.WritePropertyWithDefault<string>(201, \"ctename\", ctename);\n+\tserializer.WritePropertyWithDefault<idx_t>(202, \"table_index\", table_index);\n+\tserializer.WritePropertyWithDefault<idx_t>(203, \"column_count\", column_count);\n }\n \n unique_ptr<LogicalOperator> LogicalRecursiveCTE::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<LogicalRecursiveCTE>(new LogicalRecursiveCTE());\n-\tdeserializer.ReadProperty(200, \"union_all\", result->union_all);\n-\tdeserializer.ReadProperty(201, \"ctename\", result->ctename);\n-\tdeserializer.ReadProperty(202, \"table_index\", result->table_index);\n-\tdeserializer.ReadProperty(203, \"column_count\", result->column_count);\n+\tdeserializer.ReadPropertyWithDefault<bool>(200, \"union_all\", result->union_all);\n+\tdeserializer.ReadPropertyWithDefault<string>(201, \"ctename\", result->ctename);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(202, \"table_index\", result->table_index);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(203, \"column_count\", result->column_count);\n \treturn std::move(result);\n }\n \n void LogicalReset::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"name\", name);\n-\tserializer.WriteProperty(201, \"scope\", scope);\n+\tserializer.WritePropertyWithDefault<string>(200, \"name\", name);\n+\tserializer.WriteProperty<SetScope>(201, \"scope\", scope);\n }\n \n unique_ptr<LogicalOperator> LogicalReset::Deserialize(Deserializer &deserializer) {\n-\tauto name = deserializer.ReadProperty<string>(200, \"name\");\n+\tauto name = deserializer.ReadPropertyWithDefault<string>(200, \"name\");\n \tauto scope = deserializer.ReadProperty<SetScope>(201, \"scope\");\n \tauto result = duckdb::unique_ptr<LogicalReset>(new LogicalReset(std::move(name), scope));\n \treturn std::move(result);\n@@ -620,24 +620,24 @@ unique_ptr<LogicalOperator> LogicalReset::Deserialize(Deserializer &deserializer\n \n void LogicalSample::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"sample_options\", sample_options);\n+\tserializer.WritePropertyWithDefault<unique_ptr<SampleOptions>>(200, \"sample_options\", sample_options);\n }\n \n unique_ptr<LogicalOperator> LogicalSample::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<LogicalSample>(new LogicalSample());\n-\tdeserializer.ReadProperty(200, \"sample_options\", result->sample_options);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<SampleOptions>>(200, \"sample_options\", result->sample_options);\n \treturn std::move(result);\n }\n \n void LogicalSet::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"name\", name);\n-\tserializer.WriteProperty(201, \"value\", value);\n-\tserializer.WriteProperty(202, \"scope\", scope);\n+\tserializer.WritePropertyWithDefault<string>(200, \"name\", name);\n+\tserializer.WriteProperty<Value>(201, \"value\", value);\n+\tserializer.WriteProperty<SetScope>(202, \"scope\", scope);\n }\n \n unique_ptr<LogicalOperator> LogicalSet::Deserialize(Deserializer &deserializer) {\n-\tauto name = deserializer.ReadProperty<string>(200, \"name\");\n+\tauto name = deserializer.ReadPropertyWithDefault<string>(200, \"name\");\n \tauto value = deserializer.ReadProperty<Value>(201, \"value\");\n \tauto scope = deserializer.ReadProperty<SetScope>(202, \"scope\");\n \tauto result = duckdb::unique_ptr<LogicalSet>(new LogicalSet(std::move(name), value, scope));\n@@ -646,102 +646,102 @@ unique_ptr<LogicalOperator> LogicalSet::Deserialize(Deserializer &deserializer)\n \n void LogicalSetOperation::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"table_index\", table_index);\n-\tserializer.WriteProperty(201, \"column_count\", column_count);\n+\tserializer.WritePropertyWithDefault<idx_t>(200, \"table_index\", table_index);\n+\tserializer.WritePropertyWithDefault<idx_t>(201, \"column_count\", column_count);\n }\n \n unique_ptr<LogicalOperator> LogicalSetOperation::Deserialize(Deserializer &deserializer) {\n-\tauto table_index = deserializer.ReadProperty<idx_t>(200, \"table_index\");\n-\tauto column_count = deserializer.ReadProperty<idx_t>(201, \"column_count\");\n+\tauto table_index = deserializer.ReadPropertyWithDefault<idx_t>(200, \"table_index\");\n+\tauto column_count = deserializer.ReadPropertyWithDefault<idx_t>(201, \"column_count\");\n \tauto result = duckdb::unique_ptr<LogicalSetOperation>(new LogicalSetOperation(table_index, column_count, deserializer.Get<LogicalOperatorType>()));\n \treturn std::move(result);\n }\n \n void LogicalShow::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"types_select\", types_select);\n-\tserializer.WriteProperty(201, \"aliases\", aliases);\n+\tserializer.WritePropertyWithDefault<vector<LogicalType>>(200, \"types_select\", types_select);\n+\tserializer.WritePropertyWithDefault<vector<string>>(201, \"aliases\", aliases);\n }\n \n unique_ptr<LogicalOperator> LogicalShow::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<LogicalShow>(new LogicalShow());\n-\tdeserializer.ReadProperty(200, \"types_select\", result->types_select);\n-\tdeserializer.ReadProperty(201, \"aliases\", result->aliases);\n+\tdeserializer.ReadPropertyWithDefault<vector<LogicalType>>(200, \"types_select\", result->types_select);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(201, \"aliases\", result->aliases);\n \treturn std::move(result);\n }\n \n void LogicalSimple::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"info\", info);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParseInfo>>(200, \"info\", info);\n }\n \n unique_ptr<LogicalOperator> LogicalSimple::Deserialize(Deserializer &deserializer) {\n-\tauto info = deserializer.ReadProperty<unique_ptr<ParseInfo>>(200, \"info\");\n+\tauto info = deserializer.ReadPropertyWithDefault<unique_ptr<ParseInfo>>(200, \"info\");\n \tauto result = duckdb::unique_ptr<LogicalSimple>(new LogicalSimple(deserializer.Get<LogicalOperatorType>(), std::move(info)));\n \treturn std::move(result);\n }\n \n void LogicalTopN::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"orders\", orders);\n-\tserializer.WriteProperty(201, \"limit\", limit);\n-\tserializer.WriteProperty(202, \"offset\", offset);\n+\tserializer.WritePropertyWithDefault<vector<BoundOrderByNode>>(200, \"orders\", orders);\n+\tserializer.WritePropertyWithDefault<idx_t>(201, \"limit\", limit);\n+\tserializer.WritePropertyWithDefault<idx_t>(202, \"offset\", offset);\n }\n \n unique_ptr<LogicalOperator> LogicalTopN::Deserialize(Deserializer &deserializer) {\n-\tauto orders = deserializer.ReadProperty<vector<BoundOrderByNode>>(200, \"orders\");\n-\tauto limit = deserializer.ReadProperty<idx_t>(201, \"limit\");\n-\tauto offset = deserializer.ReadProperty<idx_t>(202, \"offset\");\n+\tauto orders = deserializer.ReadPropertyWithDefault<vector<BoundOrderByNode>>(200, \"orders\");\n+\tauto limit = deserializer.ReadPropertyWithDefault<idx_t>(201, \"limit\");\n+\tauto offset = deserializer.ReadPropertyWithDefault<idx_t>(202, \"offset\");\n \tauto result = duckdb::unique_ptr<LogicalTopN>(new LogicalTopN(std::move(orders), limit, offset));\n \treturn std::move(result);\n }\n \n void LogicalUnnest::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"unnest_index\", unnest_index);\n-\tserializer.WriteProperty(201, \"expressions\", expressions);\n+\tserializer.WritePropertyWithDefault<idx_t>(200, \"unnest_index\", unnest_index);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(201, \"expressions\", expressions);\n }\n \n unique_ptr<LogicalOperator> LogicalUnnest::Deserialize(Deserializer &deserializer) {\n-\tauto unnest_index = deserializer.ReadProperty<idx_t>(200, \"unnest_index\");\n+\tauto unnest_index = deserializer.ReadPropertyWithDefault<idx_t>(200, \"unnest_index\");\n \tauto result = duckdb::unique_ptr<LogicalUnnest>(new LogicalUnnest(unnest_index));\n-\tdeserializer.ReadProperty(201, \"expressions\", result->expressions);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(201, \"expressions\", result->expressions);\n \treturn std::move(result);\n }\n \n void LogicalUpdate::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"table_info\", table.GetInfo());\n-\tserializer.WriteProperty(201, \"table_index\", table_index);\n-\tserializer.WriteProperty(202, \"return_chunk\", return_chunk);\n-\tserializer.WriteProperty(203, \"expressions\", expressions);\n-\tserializer.WriteProperty(204, \"columns\", columns);\n-\tserializer.WriteProperty(205, \"bound_defaults\", bound_defaults);\n-\tserializer.WriteProperty(206, \"update_is_del_and_insert\", update_is_del_and_insert);\n+\tserializer.WritePropertyWithDefault<unique_ptr<CreateInfo>>(200, \"table_info\", table.GetInfo());\n+\tserializer.WritePropertyWithDefault<idx_t>(201, \"table_index\", table_index);\n+\tserializer.WritePropertyWithDefault<bool>(202, \"return_chunk\", return_chunk);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(203, \"expressions\", expressions);\n+\tserializer.WritePropertyWithDefault<vector<PhysicalIndex>>(204, \"columns\", columns);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(205, \"bound_defaults\", bound_defaults);\n+\tserializer.WritePropertyWithDefault<bool>(206, \"update_is_del_and_insert\", update_is_del_and_insert);\n }\n \n unique_ptr<LogicalOperator> LogicalUpdate::Deserialize(Deserializer &deserializer) {\n-\tauto table_info = deserializer.ReadProperty<unique_ptr<CreateInfo>>(200, \"table_info\");\n+\tauto table_info = deserializer.ReadPropertyWithDefault<unique_ptr<CreateInfo>>(200, \"table_info\");\n \tauto result = duckdb::unique_ptr<LogicalUpdate>(new LogicalUpdate(deserializer.Get<ClientContext &>(), table_info));\n-\tdeserializer.ReadProperty(201, \"table_index\", result->table_index);\n-\tdeserializer.ReadProperty(202, \"return_chunk\", result->return_chunk);\n-\tdeserializer.ReadProperty(203, \"expressions\", result->expressions);\n-\tdeserializer.ReadProperty(204, \"columns\", result->columns);\n-\tdeserializer.ReadProperty(205, \"bound_defaults\", result->bound_defaults);\n-\tdeserializer.ReadProperty(206, \"update_is_del_and_insert\", result->update_is_del_and_insert);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(201, \"table_index\", result->table_index);\n+\tdeserializer.ReadPropertyWithDefault<bool>(202, \"return_chunk\", result->return_chunk);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(203, \"expressions\", result->expressions);\n+\tdeserializer.ReadPropertyWithDefault<vector<PhysicalIndex>>(204, \"columns\", result->columns);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(205, \"bound_defaults\", result->bound_defaults);\n+\tdeserializer.ReadPropertyWithDefault<bool>(206, \"update_is_del_and_insert\", result->update_is_del_and_insert);\n \treturn std::move(result);\n }\n \n void LogicalWindow::Serialize(Serializer &serializer) const {\n \tLogicalOperator::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"window_index\", window_index);\n-\tserializer.WriteProperty(201, \"expressions\", expressions);\n+\tserializer.WritePropertyWithDefault<idx_t>(200, \"window_index\", window_index);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(201, \"expressions\", expressions);\n }\n \n unique_ptr<LogicalOperator> LogicalWindow::Deserialize(Deserializer &deserializer) {\n-\tauto window_index = deserializer.ReadProperty<idx_t>(200, \"window_index\");\n+\tauto window_index = deserializer.ReadPropertyWithDefault<idx_t>(200, \"window_index\");\n \tauto result = duckdb::unique_ptr<LogicalWindow>(new LogicalWindow(window_index));\n-\tdeserializer.ReadProperty(201, \"expressions\", result->expressions);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(201, \"expressions\", result->expressions);\n \treturn std::move(result);\n }\n \ndiff --git a/src/storage/serialization/serialize_macro_function.cpp b/src/storage/serialization/serialize_macro_function.cpp\nindex c27aa3b67ea7..79484d8084ed 100644\n--- a/src/storage/serialization/serialize_macro_function.cpp\n+++ b/src/storage/serialization/serialize_macro_function.cpp\n@@ -12,15 +12,15 @@\n namespace duckdb {\n \n void MacroFunction::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"type\", type);\n-\tserializer.WriteProperty(101, \"parameters\", parameters);\n-\tserializer.WriteProperty(102, \"default_parameters\", default_parameters);\n+\tserializer.WriteProperty<MacroType>(100, \"type\", type);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(101, \"parameters\", parameters);\n+\tserializer.WritePropertyWithDefault<unordered_map<string, unique_ptr<ParsedExpression>>>(102, \"default_parameters\", default_parameters);\n }\n \n unique_ptr<MacroFunction> MacroFunction::Deserialize(Deserializer &deserializer) {\n \tauto type = deserializer.ReadProperty<MacroType>(100, \"type\");\n-\tauto parameters = deserializer.ReadProperty<vector<unique_ptr<ParsedExpression>>>(101, \"parameters\");\n-\tauto default_parameters = deserializer.ReadProperty<unordered_map<string, unique_ptr<ParsedExpression>>>(102, \"default_parameters\");\n+\tauto parameters = deserializer.ReadPropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(101, \"parameters\");\n+\tauto default_parameters = deserializer.ReadPropertyWithDefault<unordered_map<string, unique_ptr<ParsedExpression>>>(102, \"default_parameters\");\n \tunique_ptr<MacroFunction> result;\n \tswitch (type) {\n \tcase MacroType::SCALAR_MACRO:\n@@ -39,23 +39,23 @@ unique_ptr<MacroFunction> MacroFunction::Deserialize(Deserializer &deserializer)\n \n void ScalarMacroFunction::Serialize(Serializer &serializer) const {\n \tMacroFunction::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"expression\", expression);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"expression\", expression);\n }\n \n unique_ptr<MacroFunction> ScalarMacroFunction::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<ScalarMacroFunction>(new ScalarMacroFunction());\n-\tdeserializer.ReadProperty(200, \"expression\", result->expression);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"expression\", result->expression);\n \treturn std::move(result);\n }\n \n void TableMacroFunction::Serialize(Serializer &serializer) const {\n \tMacroFunction::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"query_node\", query_node);\n+\tserializer.WritePropertyWithDefault<unique_ptr<QueryNode>>(200, \"query_node\", query_node);\n }\n \n unique_ptr<MacroFunction> TableMacroFunction::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<TableMacroFunction>(new TableMacroFunction());\n-\tdeserializer.ReadProperty(200, \"query_node\", result->query_node);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<QueryNode>>(200, \"query_node\", result->query_node);\n \treturn std::move(result);\n }\n \ndiff --git a/src/storage/serialization/serialize_nodes.cpp b/src/storage/serialization/serialize_nodes.cpp\nindex a5fc48a19a9a..1a8b50fc02fe 100644\n--- a/src/storage/serialization/serialize_nodes.cpp\n+++ b/src/storage/serialization/serialize_nodes.cpp\n@@ -33,426 +33,426 @@\n namespace duckdb {\n \n void BoundCaseCheck::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"when_expr\", when_expr);\n-\tserializer.WriteProperty(101, \"then_expr\", then_expr);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(100, \"when_expr\", when_expr);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(101, \"then_expr\", then_expr);\n }\n \n BoundCaseCheck BoundCaseCheck::Deserialize(Deserializer &deserializer) {\n \tBoundCaseCheck result;\n-\tdeserializer.ReadProperty(100, \"when_expr\", result.when_expr);\n-\tdeserializer.ReadProperty(101, \"then_expr\", result.then_expr);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(100, \"when_expr\", result.when_expr);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(101, \"then_expr\", result.then_expr);\n \treturn result;\n }\n \n void BoundOrderByNode::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"type\", type);\n-\tserializer.WriteProperty(101, \"null_order\", null_order);\n-\tserializer.WriteProperty(102, \"expression\", expression);\n+\tserializer.WriteProperty<OrderType>(100, \"type\", type);\n+\tserializer.WriteProperty<OrderByNullType>(101, \"null_order\", null_order);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(102, \"expression\", expression);\n }\n \n BoundOrderByNode BoundOrderByNode::Deserialize(Deserializer &deserializer) {\n \tauto type = deserializer.ReadProperty<OrderType>(100, \"type\");\n \tauto null_order = deserializer.ReadProperty<OrderByNullType>(101, \"null_order\");\n-\tauto expression = deserializer.ReadProperty<unique_ptr<Expression>>(102, \"expression\");\n+\tauto expression = deserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(102, \"expression\");\n \tBoundOrderByNode result(type, null_order, std::move(expression));\n \treturn result;\n }\n \n void BoundParameterData::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"value\", value);\n-\tserializer.WriteProperty(101, \"return_type\", return_type);\n+\tserializer.WriteProperty<Value>(100, \"value\", value);\n+\tserializer.WriteProperty<LogicalType>(101, \"return_type\", return_type);\n }\n \n shared_ptr<BoundParameterData> BoundParameterData::Deserialize(Deserializer &deserializer) {\n \tauto value = deserializer.ReadProperty<Value>(100, \"value\");\n \tauto result = duckdb::shared_ptr<BoundParameterData>(new BoundParameterData(value));\n-\tdeserializer.ReadProperty(101, \"return_type\", result->return_type);\n+\tdeserializer.ReadProperty<LogicalType>(101, \"return_type\", result->return_type);\n \treturn result;\n }\n \n void BoundPivotInfo::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"group_count\", group_count);\n-\tserializer.WriteProperty(101, \"types\", types);\n-\tserializer.WriteProperty(102, \"pivot_values\", pivot_values);\n-\tserializer.WriteProperty(103, \"aggregates\", aggregates);\n+\tserializer.WritePropertyWithDefault<idx_t>(100, \"group_count\", group_count);\n+\tserializer.WritePropertyWithDefault<vector<LogicalType>>(101, \"types\", types);\n+\tserializer.WritePropertyWithDefault<vector<string>>(102, \"pivot_values\", pivot_values);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<Expression>>>(103, \"aggregates\", aggregates);\n }\n \n BoundPivotInfo BoundPivotInfo::Deserialize(Deserializer &deserializer) {\n \tBoundPivotInfo result;\n-\tdeserializer.ReadProperty(100, \"group_count\", result.group_count);\n-\tdeserializer.ReadProperty(101, \"types\", result.types);\n-\tdeserializer.ReadProperty(102, \"pivot_values\", result.pivot_values);\n-\tdeserializer.ReadProperty(103, \"aggregates\", result.aggregates);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(100, \"group_count\", result.group_count);\n+\tdeserializer.ReadPropertyWithDefault<vector<LogicalType>>(101, \"types\", result.types);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(102, \"pivot_values\", result.pivot_values);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<Expression>>>(103, \"aggregates\", result.aggregates);\n \treturn result;\n }\n \n void CSVReaderOptions::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"has_delimiter\", has_delimiter);\n-\tserializer.WriteProperty(101, \"has_quote\", has_quote);\n-\tserializer.WriteProperty(102, \"has_escape\", has_escape);\n-\tserializer.WriteProperty(103, \"has_header\", has_header);\n-\tserializer.WriteProperty(104, \"ignore_errors\", ignore_errors);\n-\tserializer.WriteProperty(105, \"buffer_sample_size\", buffer_sample_size);\n-\tserializer.WriteProperty(106, \"null_str\", null_str);\n-\tserializer.WriteProperty(107, \"compression\", compression);\n-\tserializer.WriteProperty(108, \"allow_quoted_nulls\", allow_quoted_nulls);\n-\tserializer.WriteProperty(109, \"skip_rows_set\", skip_rows_set);\n-\tserializer.WriteProperty(110, \"maximum_line_size\", maximum_line_size);\n-\tserializer.WriteProperty(111, \"normalize_names\", normalize_names);\n-\tserializer.WriteProperty(112, \"force_not_null\", force_not_null);\n-\tserializer.WriteProperty(113, \"all_varchar\", all_varchar);\n-\tserializer.WriteProperty(114, \"sample_size_chunks\", sample_size_chunks);\n-\tserializer.WriteProperty(115, \"auto_detect\", auto_detect);\n-\tserializer.WriteProperty(116, \"file_path\", file_path);\n-\tserializer.WriteProperty(117, \"decimal_separator\", decimal_separator);\n-\tserializer.WriteProperty(118, \"null_padding\", null_padding);\n-\tserializer.WriteProperty(119, \"buffer_size\", buffer_size);\n-\tserializer.WriteProperty(120, \"file_options\", file_options);\n-\tserializer.WriteProperty(121, \"force_quote\", force_quote);\n-\tserializer.WriteProperty(122, \"rejects_table_name\", rejects_table_name);\n-\tserializer.WriteProperty(123, \"rejects_limit\", rejects_limit);\n-\tserializer.WriteProperty(124, \"rejects_recovery_columns\", rejects_recovery_columns);\n-\tserializer.WriteProperty(125, \"rejects_recovery_column_ids\", rejects_recovery_column_ids);\n-\tserializer.WriteProperty(126, \"dialect_options.state_machine_options.delimiter\", dialect_options.state_machine_options.delimiter);\n-\tserializer.WriteProperty(127, \"dialect_options.state_machine_options.quote\", dialect_options.state_machine_options.quote);\n-\tserializer.WriteProperty(128, \"dialect_options.state_machine_options.escape\", dialect_options.state_machine_options.escape);\n-\tserializer.WriteProperty(129, \"dialect_options.header\", dialect_options.header);\n-\tserializer.WriteProperty(130, \"dialect_options.num_cols\", dialect_options.num_cols);\n-\tserializer.WriteProperty(131, \"dialect_options.new_line\", dialect_options.new_line);\n-\tserializer.WriteProperty(132, \"dialect_options.skip_rows\", dialect_options.skip_rows);\n-\tserializer.WriteProperty(133, \"dialect_options.date_format\", dialect_options.date_format);\n-\tserializer.WriteProperty(134, \"dialect_options.has_format\", dialect_options.has_format);\n+\tserializer.WritePropertyWithDefault<bool>(100, \"has_delimiter\", has_delimiter);\n+\tserializer.WritePropertyWithDefault<bool>(101, \"has_quote\", has_quote);\n+\tserializer.WritePropertyWithDefault<bool>(102, \"has_escape\", has_escape);\n+\tserializer.WritePropertyWithDefault<bool>(103, \"has_header\", has_header);\n+\tserializer.WritePropertyWithDefault<bool>(104, \"ignore_errors\", ignore_errors);\n+\tserializer.WritePropertyWithDefault<idx_t>(105, \"buffer_sample_size\", buffer_sample_size);\n+\tserializer.WritePropertyWithDefault<string>(106, \"null_str\", null_str);\n+\tserializer.WriteProperty<FileCompressionType>(107, \"compression\", compression);\n+\tserializer.WritePropertyWithDefault<bool>(108, \"allow_quoted_nulls\", allow_quoted_nulls);\n+\tserializer.WritePropertyWithDefault<bool>(109, \"skip_rows_set\", skip_rows_set);\n+\tserializer.WritePropertyWithDefault<idx_t>(110, \"maximum_line_size\", maximum_line_size);\n+\tserializer.WritePropertyWithDefault<bool>(111, \"normalize_names\", normalize_names);\n+\tserializer.WritePropertyWithDefault<vector<bool>>(112, \"force_not_null\", force_not_null);\n+\tserializer.WritePropertyWithDefault<bool>(113, \"all_varchar\", all_varchar);\n+\tserializer.WritePropertyWithDefault<idx_t>(114, \"sample_size_chunks\", sample_size_chunks);\n+\tserializer.WritePropertyWithDefault<bool>(115, \"auto_detect\", auto_detect);\n+\tserializer.WritePropertyWithDefault<string>(116, \"file_path\", file_path);\n+\tserializer.WritePropertyWithDefault<string>(117, \"decimal_separator\", decimal_separator);\n+\tserializer.WritePropertyWithDefault<bool>(118, \"null_padding\", null_padding);\n+\tserializer.WritePropertyWithDefault<idx_t>(119, \"buffer_size\", buffer_size);\n+\tserializer.WriteProperty<MultiFileReaderOptions>(120, \"file_options\", file_options);\n+\tserializer.WritePropertyWithDefault<vector<bool>>(121, \"force_quote\", force_quote);\n+\tserializer.WritePropertyWithDefault<string>(122, \"rejects_table_name\", rejects_table_name);\n+\tserializer.WritePropertyWithDefault<idx_t>(123, \"rejects_limit\", rejects_limit);\n+\tserializer.WritePropertyWithDefault<vector<string>>(124, \"rejects_recovery_columns\", rejects_recovery_columns);\n+\tserializer.WritePropertyWithDefault<vector<idx_t>>(125, \"rejects_recovery_column_ids\", rejects_recovery_column_ids);\n+\tserializer.WriteProperty<char>(126, \"dialect_options.state_machine_options.delimiter\", dialect_options.state_machine_options.delimiter);\n+\tserializer.WriteProperty<char>(127, \"dialect_options.state_machine_options.quote\", dialect_options.state_machine_options.quote);\n+\tserializer.WriteProperty<char>(128, \"dialect_options.state_machine_options.escape\", dialect_options.state_machine_options.escape);\n+\tserializer.WritePropertyWithDefault<bool>(129, \"dialect_options.header\", dialect_options.header);\n+\tserializer.WritePropertyWithDefault<idx_t>(130, \"dialect_options.num_cols\", dialect_options.num_cols);\n+\tserializer.WriteProperty<NewLineIdentifier>(131, \"dialect_options.new_line\", dialect_options.new_line);\n+\tserializer.WritePropertyWithDefault<idx_t>(132, \"dialect_options.skip_rows\", dialect_options.skip_rows);\n+\tserializer.WritePropertyWithDefault<map<LogicalTypeId, StrpTimeFormat>>(133, \"dialect_options.date_format\", dialect_options.date_format);\n+\tserializer.WritePropertyWithDefault<map<LogicalTypeId, bool>>(134, \"dialect_options.has_format\", dialect_options.has_format);\n }\n \n CSVReaderOptions CSVReaderOptions::Deserialize(Deserializer &deserializer) {\n \tCSVReaderOptions result;\n-\tdeserializer.ReadProperty(100, \"has_delimiter\", result.has_delimiter);\n-\tdeserializer.ReadProperty(101, \"has_quote\", result.has_quote);\n-\tdeserializer.ReadProperty(102, \"has_escape\", result.has_escape);\n-\tdeserializer.ReadProperty(103, \"has_header\", result.has_header);\n-\tdeserializer.ReadProperty(104, \"ignore_errors\", result.ignore_errors);\n-\tdeserializer.ReadProperty(105, \"buffer_sample_size\", result.buffer_sample_size);\n-\tdeserializer.ReadProperty(106, \"null_str\", result.null_str);\n-\tdeserializer.ReadProperty(107, \"compression\", result.compression);\n-\tdeserializer.ReadProperty(108, \"allow_quoted_nulls\", result.allow_quoted_nulls);\n-\tdeserializer.ReadProperty(109, \"skip_rows_set\", result.skip_rows_set);\n-\tdeserializer.ReadProperty(110, \"maximum_line_size\", result.maximum_line_size);\n-\tdeserializer.ReadProperty(111, \"normalize_names\", result.normalize_names);\n-\tdeserializer.ReadProperty(112, \"force_not_null\", result.force_not_null);\n-\tdeserializer.ReadProperty(113, \"all_varchar\", result.all_varchar);\n-\tdeserializer.ReadProperty(114, \"sample_size_chunks\", result.sample_size_chunks);\n-\tdeserializer.ReadProperty(115, \"auto_detect\", result.auto_detect);\n-\tdeserializer.ReadProperty(116, \"file_path\", result.file_path);\n-\tdeserializer.ReadProperty(117, \"decimal_separator\", result.decimal_separator);\n-\tdeserializer.ReadProperty(118, \"null_padding\", result.null_padding);\n-\tdeserializer.ReadProperty(119, \"buffer_size\", result.buffer_size);\n-\tdeserializer.ReadProperty(120, \"file_options\", result.file_options);\n-\tdeserializer.ReadProperty(121, \"force_quote\", result.force_quote);\n-\tdeserializer.ReadProperty(122, \"rejects_table_name\", result.rejects_table_name);\n-\tdeserializer.ReadProperty(123, \"rejects_limit\", result.rejects_limit);\n-\tdeserializer.ReadProperty(124, \"rejects_recovery_columns\", result.rejects_recovery_columns);\n-\tdeserializer.ReadProperty(125, \"rejects_recovery_column_ids\", result.rejects_recovery_column_ids);\n-\tdeserializer.ReadProperty(126, \"dialect_options.state_machine_options.delimiter\", result.dialect_options.state_machine_options.delimiter);\n-\tdeserializer.ReadProperty(127, \"dialect_options.state_machine_options.quote\", result.dialect_options.state_machine_options.quote);\n-\tdeserializer.ReadProperty(128, \"dialect_options.state_machine_options.escape\", result.dialect_options.state_machine_options.escape);\n-\tdeserializer.ReadProperty(129, \"dialect_options.header\", result.dialect_options.header);\n-\tdeserializer.ReadProperty(130, \"dialect_options.num_cols\", result.dialect_options.num_cols);\n-\tdeserializer.ReadProperty(131, \"dialect_options.new_line\", result.dialect_options.new_line);\n-\tdeserializer.ReadProperty(132, \"dialect_options.skip_rows\", result.dialect_options.skip_rows);\n-\tdeserializer.ReadProperty(133, \"dialect_options.date_format\", result.dialect_options.date_format);\n-\tdeserializer.ReadProperty(134, \"dialect_options.has_format\", result.dialect_options.has_format);\n+\tdeserializer.ReadPropertyWithDefault<bool>(100, \"has_delimiter\", result.has_delimiter);\n+\tdeserializer.ReadPropertyWithDefault<bool>(101, \"has_quote\", result.has_quote);\n+\tdeserializer.ReadPropertyWithDefault<bool>(102, \"has_escape\", result.has_escape);\n+\tdeserializer.ReadPropertyWithDefault<bool>(103, \"has_header\", result.has_header);\n+\tdeserializer.ReadPropertyWithDefault<bool>(104, \"ignore_errors\", result.ignore_errors);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(105, \"buffer_sample_size\", result.buffer_sample_size);\n+\tdeserializer.ReadPropertyWithDefault<string>(106, \"null_str\", result.null_str);\n+\tdeserializer.ReadProperty<FileCompressionType>(107, \"compression\", result.compression);\n+\tdeserializer.ReadPropertyWithDefault<bool>(108, \"allow_quoted_nulls\", result.allow_quoted_nulls);\n+\tdeserializer.ReadPropertyWithDefault<bool>(109, \"skip_rows_set\", result.skip_rows_set);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(110, \"maximum_line_size\", result.maximum_line_size);\n+\tdeserializer.ReadPropertyWithDefault<bool>(111, \"normalize_names\", result.normalize_names);\n+\tdeserializer.ReadPropertyWithDefault<vector<bool>>(112, \"force_not_null\", result.force_not_null);\n+\tdeserializer.ReadPropertyWithDefault<bool>(113, \"all_varchar\", result.all_varchar);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(114, \"sample_size_chunks\", result.sample_size_chunks);\n+\tdeserializer.ReadPropertyWithDefault<bool>(115, \"auto_detect\", result.auto_detect);\n+\tdeserializer.ReadPropertyWithDefault<string>(116, \"file_path\", result.file_path);\n+\tdeserializer.ReadPropertyWithDefault<string>(117, \"decimal_separator\", result.decimal_separator);\n+\tdeserializer.ReadPropertyWithDefault<bool>(118, \"null_padding\", result.null_padding);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(119, \"buffer_size\", result.buffer_size);\n+\tdeserializer.ReadProperty<MultiFileReaderOptions>(120, \"file_options\", result.file_options);\n+\tdeserializer.ReadPropertyWithDefault<vector<bool>>(121, \"force_quote\", result.force_quote);\n+\tdeserializer.ReadPropertyWithDefault<string>(122, \"rejects_table_name\", result.rejects_table_name);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(123, \"rejects_limit\", result.rejects_limit);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(124, \"rejects_recovery_columns\", result.rejects_recovery_columns);\n+\tdeserializer.ReadPropertyWithDefault<vector<idx_t>>(125, \"rejects_recovery_column_ids\", result.rejects_recovery_column_ids);\n+\tdeserializer.ReadProperty<char>(126, \"dialect_options.state_machine_options.delimiter\", result.dialect_options.state_machine_options.delimiter);\n+\tdeserializer.ReadProperty<char>(127, \"dialect_options.state_machine_options.quote\", result.dialect_options.state_machine_options.quote);\n+\tdeserializer.ReadProperty<char>(128, \"dialect_options.state_machine_options.escape\", result.dialect_options.state_machine_options.escape);\n+\tdeserializer.ReadPropertyWithDefault<bool>(129, \"dialect_options.header\", result.dialect_options.header);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(130, \"dialect_options.num_cols\", result.dialect_options.num_cols);\n+\tdeserializer.ReadProperty<NewLineIdentifier>(131, \"dialect_options.new_line\", result.dialect_options.new_line);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(132, \"dialect_options.skip_rows\", result.dialect_options.skip_rows);\n+\tdeserializer.ReadPropertyWithDefault<map<LogicalTypeId, StrpTimeFormat>>(133, \"dialect_options.date_format\", result.dialect_options.date_format);\n+\tdeserializer.ReadPropertyWithDefault<map<LogicalTypeId, bool>>(134, \"dialect_options.has_format\", result.dialect_options.has_format);\n \treturn result;\n }\n \n void CaseCheck::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"when_expr\", when_expr);\n-\tserializer.WriteProperty(101, \"then_expr\", then_expr);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(100, \"when_expr\", when_expr);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(101, \"then_expr\", then_expr);\n }\n \n CaseCheck CaseCheck::Deserialize(Deserializer &deserializer) {\n \tCaseCheck result;\n-\tdeserializer.ReadProperty(100, \"when_expr\", result.when_expr);\n-\tdeserializer.ReadProperty(101, \"then_expr\", result.then_expr);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(100, \"when_expr\", result.when_expr);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(101, \"then_expr\", result.then_expr);\n \treturn result;\n }\n \n void ColumnBinding::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"table_index\", table_index);\n-\tserializer.WriteProperty(101, \"column_index\", column_index);\n+\tserializer.WritePropertyWithDefault<idx_t>(100, \"table_index\", table_index);\n+\tserializer.WritePropertyWithDefault<idx_t>(101, \"column_index\", column_index);\n }\n \n ColumnBinding ColumnBinding::Deserialize(Deserializer &deserializer) {\n \tColumnBinding result;\n-\tdeserializer.ReadProperty(100, \"table_index\", result.table_index);\n-\tdeserializer.ReadProperty(101, \"column_index\", result.column_index);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(100, \"table_index\", result.table_index);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(101, \"column_index\", result.column_index);\n \treturn result;\n }\n \n void ColumnDefinition::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"name\", name);\n-\tserializer.WriteProperty(101, \"type\", type);\n-\tserializer.WritePropertyWithDefault(102, \"expression\", expression, unique_ptr<ParsedExpression>());\n-\tserializer.WriteProperty(103, \"category\", category);\n-\tserializer.WriteProperty(104, \"compression_type\", compression_type);\n+\tserializer.WritePropertyWithDefault<string>(100, \"name\", name);\n+\tserializer.WriteProperty<LogicalType>(101, \"type\", type);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(102, \"expression\", expression);\n+\tserializer.WriteProperty<TableColumnType>(103, \"category\", category);\n+\tserializer.WriteProperty<duckdb::CompressionType>(104, \"compression_type\", compression_type);\n }\n \n ColumnDefinition ColumnDefinition::Deserialize(Deserializer &deserializer) {\n-\tauto name = deserializer.ReadProperty<string>(100, \"name\");\n+\tauto name = deserializer.ReadPropertyWithDefault<string>(100, \"name\");\n \tauto type = deserializer.ReadProperty<LogicalType>(101, \"type\");\n-\tauto expression = deserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(102, \"expression\", unique_ptr<ParsedExpression>());\n+\tauto expression = deserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(102, \"expression\");\n \tauto category = deserializer.ReadProperty<TableColumnType>(103, \"category\");\n \tColumnDefinition result(std::move(name), std::move(type), std::move(expression), category);\n-\tdeserializer.ReadProperty(104, \"compression_type\", result.compression_type);\n+\tdeserializer.ReadProperty<duckdb::CompressionType>(104, \"compression_type\", result.compression_type);\n \treturn result;\n }\n \n void ColumnInfo::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"names\", names);\n-\tserializer.WriteProperty(101, \"types\", types);\n+\tserializer.WritePropertyWithDefault<vector<string>>(100, \"names\", names);\n+\tserializer.WritePropertyWithDefault<vector<LogicalType>>(101, \"types\", types);\n }\n \n ColumnInfo ColumnInfo::Deserialize(Deserializer &deserializer) {\n \tColumnInfo result;\n-\tdeserializer.ReadProperty(100, \"names\", result.names);\n-\tdeserializer.ReadProperty(101, \"types\", result.types);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(100, \"names\", result.names);\n+\tdeserializer.ReadPropertyWithDefault<vector<LogicalType>>(101, \"types\", result.types);\n \treturn result;\n }\n \n void ColumnList::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"columns\", columns);\n+\tserializer.WritePropertyWithDefault<vector<ColumnDefinition>>(100, \"columns\", columns);\n }\n \n ColumnList ColumnList::Deserialize(Deserializer &deserializer) {\n-\tauto columns = deserializer.ReadProperty<vector<ColumnDefinition>>(100, \"columns\");\n+\tauto columns = deserializer.ReadPropertyWithDefault<vector<ColumnDefinition>>(100, \"columns\");\n \tColumnList result(std::move(columns));\n \treturn result;\n }\n \n void CommonTableExpressionInfo::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"aliases\", aliases);\n-\tserializer.WriteProperty(101, \"query\", query);\n-\tserializer.WriteProperty(102, \"materialized\", materialized);\n+\tserializer.WritePropertyWithDefault<vector<string>>(100, \"aliases\", aliases);\n+\tserializer.WritePropertyWithDefault<unique_ptr<SelectStatement>>(101, \"query\", query);\n+\tserializer.WriteProperty<CTEMaterialize>(102, \"materialized\", materialized);\n }\n \n unique_ptr<CommonTableExpressionInfo> CommonTableExpressionInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<CommonTableExpressionInfo>(new CommonTableExpressionInfo());\n-\tdeserializer.ReadProperty(100, \"aliases\", result->aliases);\n-\tdeserializer.ReadProperty(101, \"query\", result->query);\n-\tdeserializer.ReadProperty(102, \"materialized\", result->materialized);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(100, \"aliases\", result->aliases);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<SelectStatement>>(101, \"query\", result->query);\n+\tdeserializer.ReadProperty<CTEMaterialize>(102, \"materialized\", result->materialized);\n \treturn result;\n }\n \n void CommonTableExpressionMap::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"map\", map);\n+\tserializer.WritePropertyWithDefault<case_insensitive_map_t<unique_ptr<CommonTableExpressionInfo>>>(100, \"map\", map);\n }\n \n CommonTableExpressionMap CommonTableExpressionMap::Deserialize(Deserializer &deserializer) {\n \tCommonTableExpressionMap result;\n-\tdeserializer.ReadProperty(100, \"map\", result.map);\n+\tdeserializer.ReadPropertyWithDefault<case_insensitive_map_t<unique_ptr<CommonTableExpressionInfo>>>(100, \"map\", result.map);\n \treturn result;\n }\n \n void HivePartitioningIndex::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"value\", value);\n-\tserializer.WriteProperty(101, \"index\", index);\n+\tserializer.WritePropertyWithDefault<string>(100, \"value\", value);\n+\tserializer.WritePropertyWithDefault<idx_t>(101, \"index\", index);\n }\n \n HivePartitioningIndex HivePartitioningIndex::Deserialize(Deserializer &deserializer) {\n-\tauto value = deserializer.ReadProperty<string>(100, \"value\");\n-\tauto index = deserializer.ReadProperty<idx_t>(101, \"index\");\n+\tauto value = deserializer.ReadPropertyWithDefault<string>(100, \"value\");\n+\tauto index = deserializer.ReadPropertyWithDefault<idx_t>(101, \"index\");\n \tHivePartitioningIndex result(std::move(value), index);\n \treturn result;\n }\n \n void JoinCondition::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"left\", left);\n-\tserializer.WriteProperty(101, \"right\", right);\n-\tserializer.WriteProperty(102, \"comparison\", comparison);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(100, \"left\", left);\n+\tserializer.WritePropertyWithDefault<unique_ptr<Expression>>(101, \"right\", right);\n+\tserializer.WriteProperty<ExpressionType>(102, \"comparison\", comparison);\n }\n \n JoinCondition JoinCondition::Deserialize(Deserializer &deserializer) {\n \tJoinCondition result;\n-\tdeserializer.ReadProperty(100, \"left\", result.left);\n-\tdeserializer.ReadProperty(101, \"right\", result.right);\n-\tdeserializer.ReadProperty(102, \"comparison\", result.comparison);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(100, \"left\", result.left);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<Expression>>(101, \"right\", result.right);\n+\tdeserializer.ReadProperty<ExpressionType>(102, \"comparison\", result.comparison);\n \treturn result;\n }\n \n void LogicalType::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"id\", id_);\n-\tserializer.WritePropertyWithDefault(101, \"type_info\", type_info_, shared_ptr<ExtraTypeInfo>());\n+\tserializer.WriteProperty<LogicalTypeId>(100, \"id\", id_);\n+\tserializer.WritePropertyWithDefault<shared_ptr<ExtraTypeInfo>>(101, \"type_info\", type_info_);\n }\n \n LogicalType LogicalType::Deserialize(Deserializer &deserializer) {\n \tauto id = deserializer.ReadProperty<LogicalTypeId>(100, \"id\");\n-\tauto type_info = deserializer.ReadPropertyWithDefault<shared_ptr<ExtraTypeInfo>>(101, \"type_info\", shared_ptr<ExtraTypeInfo>());\n+\tauto type_info = deserializer.ReadPropertyWithDefault<shared_ptr<ExtraTypeInfo>>(101, \"type_info\");\n \tLogicalType result(id, std::move(type_info));\n \treturn result;\n }\n \n void MultiFileReaderBindData::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"filename_idx\", filename_idx);\n-\tserializer.WriteProperty(101, \"hive_partitioning_indexes\", hive_partitioning_indexes);\n+\tserializer.WritePropertyWithDefault<idx_t>(100, \"filename_idx\", filename_idx);\n+\tserializer.WritePropertyWithDefault<vector<HivePartitioningIndex>>(101, \"hive_partitioning_indexes\", hive_partitioning_indexes);\n }\n \n MultiFileReaderBindData MultiFileReaderBindData::Deserialize(Deserializer &deserializer) {\n \tMultiFileReaderBindData result;\n-\tdeserializer.ReadProperty(100, \"filename_idx\", result.filename_idx);\n-\tdeserializer.ReadProperty(101, \"hive_partitioning_indexes\", result.hive_partitioning_indexes);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(100, \"filename_idx\", result.filename_idx);\n+\tdeserializer.ReadPropertyWithDefault<vector<HivePartitioningIndex>>(101, \"hive_partitioning_indexes\", result.hive_partitioning_indexes);\n \treturn result;\n }\n \n void MultiFileReaderOptions::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"filename\", filename);\n-\tserializer.WriteProperty(101, \"hive_partitioning\", hive_partitioning);\n-\tserializer.WriteProperty(102, \"auto_detect_hive_partitioning\", auto_detect_hive_partitioning);\n-\tserializer.WriteProperty(103, \"union_by_name\", union_by_name);\n-\tserializer.WriteProperty(104, \"hive_types_autocast\", hive_types_autocast);\n-\tserializer.WriteProperty(105, \"hive_types_schema\", hive_types_schema);\n+\tserializer.WritePropertyWithDefault<bool>(100, \"filename\", filename);\n+\tserializer.WritePropertyWithDefault<bool>(101, \"hive_partitioning\", hive_partitioning);\n+\tserializer.WritePropertyWithDefault<bool>(102, \"auto_detect_hive_partitioning\", auto_detect_hive_partitioning);\n+\tserializer.WritePropertyWithDefault<bool>(103, \"union_by_name\", union_by_name);\n+\tserializer.WritePropertyWithDefault<bool>(104, \"hive_types_autocast\", hive_types_autocast);\n+\tserializer.WritePropertyWithDefault<case_insensitive_map_t<LogicalType>>(105, \"hive_types_schema\", hive_types_schema);\n }\n \n MultiFileReaderOptions MultiFileReaderOptions::Deserialize(Deserializer &deserializer) {\n \tMultiFileReaderOptions result;\n-\tdeserializer.ReadProperty(100, \"filename\", result.filename);\n-\tdeserializer.ReadProperty(101, \"hive_partitioning\", result.hive_partitioning);\n-\tdeserializer.ReadProperty(102, \"auto_detect_hive_partitioning\", result.auto_detect_hive_partitioning);\n-\tdeserializer.ReadProperty(103, \"union_by_name\", result.union_by_name);\n-\tdeserializer.ReadProperty(104, \"hive_types_autocast\", result.hive_types_autocast);\n-\tdeserializer.ReadProperty(105, \"hive_types_schema\", result.hive_types_schema);\n+\tdeserializer.ReadPropertyWithDefault<bool>(100, \"filename\", result.filename);\n+\tdeserializer.ReadPropertyWithDefault<bool>(101, \"hive_partitioning\", result.hive_partitioning);\n+\tdeserializer.ReadPropertyWithDefault<bool>(102, \"auto_detect_hive_partitioning\", result.auto_detect_hive_partitioning);\n+\tdeserializer.ReadPropertyWithDefault<bool>(103, \"union_by_name\", result.union_by_name);\n+\tdeserializer.ReadPropertyWithDefault<bool>(104, \"hive_types_autocast\", result.hive_types_autocast);\n+\tdeserializer.ReadPropertyWithDefault<case_insensitive_map_t<LogicalType>>(105, \"hive_types_schema\", result.hive_types_schema);\n \treturn result;\n }\n \n void OrderByNode::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"type\", type);\n-\tserializer.WriteProperty(101, \"null_order\", null_order);\n-\tserializer.WriteProperty(102, \"expression\", expression);\n+\tserializer.WriteProperty<OrderType>(100, \"type\", type);\n+\tserializer.WriteProperty<OrderByNullType>(101, \"null_order\", null_order);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(102, \"expression\", expression);\n }\n \n OrderByNode OrderByNode::Deserialize(Deserializer &deserializer) {\n \tauto type = deserializer.ReadProperty<OrderType>(100, \"type\");\n \tauto null_order = deserializer.ReadProperty<OrderByNullType>(101, \"null_order\");\n-\tauto expression = deserializer.ReadProperty<unique_ptr<ParsedExpression>>(102, \"expression\");\n+\tauto expression = deserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(102, \"expression\");\n \tOrderByNode result(type, null_order, std::move(expression));\n \treturn result;\n }\n \n void PivotColumn::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"pivot_expressions\", pivot_expressions);\n-\tserializer.WriteProperty(101, \"unpivot_names\", unpivot_names);\n-\tserializer.WriteProperty(102, \"entries\", entries);\n-\tserializer.WriteProperty(103, \"pivot_enum\", pivot_enum);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(100, \"pivot_expressions\", pivot_expressions);\n+\tserializer.WritePropertyWithDefault<vector<string>>(101, \"unpivot_names\", unpivot_names);\n+\tserializer.WritePropertyWithDefault<vector<PivotColumnEntry>>(102, \"entries\", entries);\n+\tserializer.WritePropertyWithDefault<string>(103, \"pivot_enum\", pivot_enum);\n }\n \n PivotColumn PivotColumn::Deserialize(Deserializer &deserializer) {\n \tPivotColumn result;\n-\tdeserializer.ReadProperty(100, \"pivot_expressions\", result.pivot_expressions);\n-\tdeserializer.ReadProperty(101, \"unpivot_names\", result.unpivot_names);\n-\tdeserializer.ReadProperty(102, \"entries\", result.entries);\n-\tdeserializer.ReadProperty(103, \"pivot_enum\", result.pivot_enum);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(100, \"pivot_expressions\", result.pivot_expressions);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(101, \"unpivot_names\", result.unpivot_names);\n+\tdeserializer.ReadPropertyWithDefault<vector<PivotColumnEntry>>(102, \"entries\", result.entries);\n+\tdeserializer.ReadPropertyWithDefault<string>(103, \"pivot_enum\", result.pivot_enum);\n \treturn result;\n }\n \n void PivotColumnEntry::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"values\", values);\n-\tserializer.WritePropertyWithDefault(101, \"star_expr\", star_expr, unique_ptr<ParsedExpression>());\n-\tserializer.WriteProperty(102, \"alias\", alias);\n+\tserializer.WritePropertyWithDefault<vector<Value>>(100, \"values\", values);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(101, \"star_expr\", star_expr);\n+\tserializer.WritePropertyWithDefault<string>(102, \"alias\", alias);\n }\n \n PivotColumnEntry PivotColumnEntry::Deserialize(Deserializer &deserializer) {\n \tPivotColumnEntry result;\n-\tdeserializer.ReadProperty(100, \"values\", result.values);\n-\tdeserializer.ReadPropertyWithDefault(101, \"star_expr\", result.star_expr, unique_ptr<ParsedExpression>());\n-\tdeserializer.ReadProperty(102, \"alias\", result.alias);\n+\tdeserializer.ReadPropertyWithDefault<vector<Value>>(100, \"values\", result.values);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(101, \"star_expr\", result.star_expr);\n+\tdeserializer.ReadPropertyWithDefault<string>(102, \"alias\", result.alias);\n \treturn result;\n }\n \n void ReadCSVData::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"files\", files);\n-\tserializer.WriteProperty(101, \"csv_types\", csv_types);\n-\tserializer.WriteProperty(102, \"csv_names\", csv_names);\n-\tserializer.WriteProperty(103, \"return_types\", return_types);\n-\tserializer.WriteProperty(104, \"return_names\", return_names);\n-\tserializer.WriteProperty(105, \"filename_col_idx\", filename_col_idx);\n-\tserializer.WriteProperty(106, \"options\", options);\n-\tserializer.WriteProperty(107, \"single_threaded\", single_threaded);\n-\tserializer.WriteProperty(108, \"reader_bind\", reader_bind);\n-\tserializer.WriteProperty(109, \"column_info\", column_info);\n+\tserializer.WritePropertyWithDefault<vector<string>>(100, \"files\", files);\n+\tserializer.WritePropertyWithDefault<vector<LogicalType>>(101, \"csv_types\", csv_types);\n+\tserializer.WritePropertyWithDefault<vector<string>>(102, \"csv_names\", csv_names);\n+\tserializer.WritePropertyWithDefault<vector<LogicalType>>(103, \"return_types\", return_types);\n+\tserializer.WritePropertyWithDefault<vector<string>>(104, \"return_names\", return_names);\n+\tserializer.WritePropertyWithDefault<idx_t>(105, \"filename_col_idx\", filename_col_idx);\n+\tserializer.WriteProperty<CSVReaderOptions>(106, \"options\", options);\n+\tserializer.WritePropertyWithDefault<bool>(107, \"single_threaded\", single_threaded);\n+\tserializer.WriteProperty<MultiFileReaderBindData>(108, \"reader_bind\", reader_bind);\n+\tserializer.WritePropertyWithDefault<vector<ColumnInfo>>(109, \"column_info\", column_info);\n }\n \n unique_ptr<ReadCSVData> ReadCSVData::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<ReadCSVData>(new ReadCSVData());\n-\tdeserializer.ReadProperty(100, \"files\", result->files);\n-\tdeserializer.ReadProperty(101, \"csv_types\", result->csv_types);\n-\tdeserializer.ReadProperty(102, \"csv_names\", result->csv_names);\n-\tdeserializer.ReadProperty(103, \"return_types\", result->return_types);\n-\tdeserializer.ReadProperty(104, \"return_names\", result->return_names);\n-\tdeserializer.ReadProperty(105, \"filename_col_idx\", result->filename_col_idx);\n-\tdeserializer.ReadProperty(106, \"options\", result->options);\n-\tdeserializer.ReadProperty(107, \"single_threaded\", result->single_threaded);\n-\tdeserializer.ReadProperty(108, \"reader_bind\", result->reader_bind);\n-\tdeserializer.ReadProperty(109, \"column_info\", result->column_info);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(100, \"files\", result->files);\n+\tdeserializer.ReadPropertyWithDefault<vector<LogicalType>>(101, \"csv_types\", result->csv_types);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(102, \"csv_names\", result->csv_names);\n+\tdeserializer.ReadPropertyWithDefault<vector<LogicalType>>(103, \"return_types\", result->return_types);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(104, \"return_names\", result->return_names);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(105, \"filename_col_idx\", result->filename_col_idx);\n+\tdeserializer.ReadProperty<CSVReaderOptions>(106, \"options\", result->options);\n+\tdeserializer.ReadPropertyWithDefault<bool>(107, \"single_threaded\", result->single_threaded);\n+\tdeserializer.ReadProperty<MultiFileReaderBindData>(108, \"reader_bind\", result->reader_bind);\n+\tdeserializer.ReadPropertyWithDefault<vector<ColumnInfo>>(109, \"column_info\", result->column_info);\n \treturn result;\n }\n \n void SampleOptions::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"sample_size\", sample_size);\n-\tserializer.WriteProperty(101, \"is_percentage\", is_percentage);\n-\tserializer.WriteProperty(102, \"method\", method);\n-\tserializer.WriteProperty(103, \"seed\", seed);\n+\tserializer.WriteProperty<Value>(100, \"sample_size\", sample_size);\n+\tserializer.WritePropertyWithDefault<bool>(101, \"is_percentage\", is_percentage);\n+\tserializer.WriteProperty<SampleMethod>(102, \"method\", method);\n+\tserializer.WritePropertyWithDefault<int64_t>(103, \"seed\", seed);\n }\n \n unique_ptr<SampleOptions> SampleOptions::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<SampleOptions>(new SampleOptions());\n-\tdeserializer.ReadProperty(100, \"sample_size\", result->sample_size);\n-\tdeserializer.ReadProperty(101, \"is_percentage\", result->is_percentage);\n-\tdeserializer.ReadProperty(102, \"method\", result->method);\n-\tdeserializer.ReadProperty(103, \"seed\", result->seed);\n+\tdeserializer.ReadProperty<Value>(100, \"sample_size\", result->sample_size);\n+\tdeserializer.ReadPropertyWithDefault<bool>(101, \"is_percentage\", result->is_percentage);\n+\tdeserializer.ReadProperty<SampleMethod>(102, \"method\", result->method);\n+\tdeserializer.ReadPropertyWithDefault<int64_t>(103, \"seed\", result->seed);\n \treturn result;\n }\n \n void StrpTimeFormat::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"format_specifier\", format_specifier);\n+\tserializer.WritePropertyWithDefault<string>(100, \"format_specifier\", format_specifier);\n }\n \n StrpTimeFormat StrpTimeFormat::Deserialize(Deserializer &deserializer) {\n-\tauto format_specifier = deserializer.ReadProperty<string>(100, \"format_specifier\");\n+\tauto format_specifier = deserializer.ReadPropertyWithDefault<string>(100, \"format_specifier\");\n \tStrpTimeFormat result(format_specifier);\n \treturn result;\n }\n \n void TableFilterSet::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"filters\", filters);\n+\tserializer.WritePropertyWithDefault<unordered_map<idx_t, unique_ptr<TableFilter>>>(100, \"filters\", filters);\n }\n \n TableFilterSet TableFilterSet::Deserialize(Deserializer &deserializer) {\n \tTableFilterSet result;\n-\tdeserializer.ReadProperty(100, \"filters\", result.filters);\n+\tdeserializer.ReadPropertyWithDefault<unordered_map<idx_t, unique_ptr<TableFilter>>>(100, \"filters\", result.filters);\n \treturn result;\n }\n \n void VacuumOptions::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"vacuum\", vacuum);\n-\tserializer.WriteProperty(101, \"analyze\", analyze);\n+\tserializer.WritePropertyWithDefault<bool>(100, \"vacuum\", vacuum);\n+\tserializer.WritePropertyWithDefault<bool>(101, \"analyze\", analyze);\n }\n \n VacuumOptions VacuumOptions::Deserialize(Deserializer &deserializer) {\n \tVacuumOptions result;\n-\tdeserializer.ReadProperty(100, \"vacuum\", result.vacuum);\n-\tdeserializer.ReadProperty(101, \"analyze\", result.analyze);\n+\tdeserializer.ReadPropertyWithDefault<bool>(100, \"vacuum\", result.vacuum);\n+\tdeserializer.ReadPropertyWithDefault<bool>(101, \"analyze\", result.analyze);\n \treturn result;\n }\n \n void interval_t::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(1, \"months\", months);\n-\tserializer.WriteProperty(2, \"days\", days);\n-\tserializer.WriteProperty(3, \"micros\", micros);\n+\tserializer.WritePropertyWithDefault<int32_t>(1, \"months\", months);\n+\tserializer.WritePropertyWithDefault<int32_t>(2, \"days\", days);\n+\tserializer.WritePropertyWithDefault<int64_t>(3, \"micros\", micros);\n }\n \n interval_t interval_t::Deserialize(Deserializer &deserializer) {\n \tinterval_t result;\n-\tdeserializer.ReadProperty(1, \"months\", result.months);\n-\tdeserializer.ReadProperty(2, \"days\", result.days);\n-\tdeserializer.ReadProperty(3, \"micros\", result.micros);\n+\tdeserializer.ReadPropertyWithDefault<int32_t>(1, \"months\", result.months);\n+\tdeserializer.ReadPropertyWithDefault<int32_t>(2, \"days\", result.days);\n+\tdeserializer.ReadPropertyWithDefault<int64_t>(3, \"micros\", result.micros);\n \treturn result;\n }\n \ndiff --git a/src/storage/serialization/serialize_parse_info.cpp b/src/storage/serialization/serialize_parse_info.cpp\nindex 97fab6dc0173..ec86b5fe6b9c 100644\n--- a/src/storage/serialization/serialize_parse_info.cpp\n+++ b/src/storage/serialization/serialize_parse_info.cpp\n@@ -20,7 +20,7 @@\n namespace duckdb {\n \n void ParseInfo::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"info_type\", info_type);\n+\tserializer.WriteProperty<ParseInfoType>(100, \"info_type\", info_type);\n }\n \n unique_ptr<ParseInfo> ParseInfo::Deserialize(Deserializer &deserializer) {\n@@ -62,21 +62,21 @@ unique_ptr<ParseInfo> ParseInfo::Deserialize(Deserializer &deserializer) {\n \n void AlterInfo::Serialize(Serializer &serializer) const {\n \tParseInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"type\", type);\n-\tserializer.WriteProperty(201, \"catalog\", catalog);\n-\tserializer.WriteProperty(202, \"schema\", schema);\n-\tserializer.WriteProperty(203, \"name\", name);\n-\tserializer.WriteProperty(204, \"if_not_found\", if_not_found);\n-\tserializer.WriteProperty(205, \"allow_internal\", allow_internal);\n+\tserializer.WriteProperty<AlterType>(200, \"type\", type);\n+\tserializer.WritePropertyWithDefault<string>(201, \"catalog\", catalog);\n+\tserializer.WritePropertyWithDefault<string>(202, \"schema\", schema);\n+\tserializer.WritePropertyWithDefault<string>(203, \"name\", name);\n+\tserializer.WriteProperty<OnEntryNotFound>(204, \"if_not_found\", if_not_found);\n+\tserializer.WritePropertyWithDefault<bool>(205, \"allow_internal\", allow_internal);\n }\n \n unique_ptr<ParseInfo> AlterInfo::Deserialize(Deserializer &deserializer) {\n \tauto type = deserializer.ReadProperty<AlterType>(200, \"type\");\n-\tauto catalog = deserializer.ReadProperty<string>(201, \"catalog\");\n-\tauto schema = deserializer.ReadProperty<string>(202, \"schema\");\n-\tauto name = deserializer.ReadProperty<string>(203, \"name\");\n+\tauto catalog = deserializer.ReadPropertyWithDefault<string>(201, \"catalog\");\n+\tauto schema = deserializer.ReadPropertyWithDefault<string>(202, \"schema\");\n+\tauto name = deserializer.ReadPropertyWithDefault<string>(203, \"name\");\n \tauto if_not_found = deserializer.ReadProperty<OnEntryNotFound>(204, \"if_not_found\");\n-\tauto allow_internal = deserializer.ReadProperty<bool>(205, \"allow_internal\");\n+\tauto allow_internal = deserializer.ReadPropertyWithDefault<bool>(205, \"allow_internal\");\n \tunique_ptr<AlterInfo> result;\n \tswitch (type) {\n \tcase AlterType::ALTER_TABLE:\n@@ -98,7 +98,7 @@ unique_ptr<ParseInfo> AlterInfo::Deserialize(Deserializer &deserializer) {\n \n void AlterTableInfo::Serialize(Serializer &serializer) const {\n \tAlterInfo::Serialize(serializer);\n-\tserializer.WriteProperty(300, \"alter_table_type\", alter_table_type);\n+\tserializer.WriteProperty<AlterTableType>(300, \"alter_table_type\", alter_table_type);\n }\n \n unique_ptr<AlterInfo> AlterTableInfo::Deserialize(Deserializer &deserializer) {\n@@ -140,7 +140,7 @@ unique_ptr<AlterInfo> AlterTableInfo::Deserialize(Deserializer &deserializer) {\n \n void AlterViewInfo::Serialize(Serializer &serializer) const {\n \tAlterInfo::Serialize(serializer);\n-\tserializer.WriteProperty(300, \"alter_view_type\", alter_view_type);\n+\tserializer.WriteProperty<AlterViewType>(300, \"alter_view_type\", alter_view_type);\n }\n \n unique_ptr<AlterInfo> AlterViewInfo::Deserialize(Deserializer &deserializer) {\n@@ -158,258 +158,258 @@ unique_ptr<AlterInfo> AlterViewInfo::Deserialize(Deserializer &deserializer) {\n \n void AddColumnInfo::Serialize(Serializer &serializer) const {\n \tAlterTableInfo::Serialize(serializer);\n-\tserializer.WriteProperty(400, \"new_column\", new_column);\n-\tserializer.WriteProperty(401, \"if_column_not_exists\", if_column_not_exists);\n+\tserializer.WriteProperty<ColumnDefinition>(400, \"new_column\", new_column);\n+\tserializer.WritePropertyWithDefault<bool>(401, \"if_column_not_exists\", if_column_not_exists);\n }\n \n unique_ptr<AlterTableInfo> AddColumnInfo::Deserialize(Deserializer &deserializer) {\n \tauto new_column = deserializer.ReadProperty<ColumnDefinition>(400, \"new_column\");\n \tauto result = duckdb::unique_ptr<AddColumnInfo>(new AddColumnInfo(std::move(new_column)));\n-\tdeserializer.ReadProperty(401, \"if_column_not_exists\", result->if_column_not_exists);\n+\tdeserializer.ReadPropertyWithDefault<bool>(401, \"if_column_not_exists\", result->if_column_not_exists);\n \treturn std::move(result);\n }\n \n void AlterForeignKeyInfo::Serialize(Serializer &serializer) const {\n \tAlterTableInfo::Serialize(serializer);\n-\tserializer.WriteProperty(400, \"fk_table\", fk_table);\n-\tserializer.WriteProperty(401, \"pk_columns\", pk_columns);\n-\tserializer.WriteProperty(402, \"fk_columns\", fk_columns);\n-\tserializer.WriteProperty(403, \"pk_keys\", pk_keys);\n-\tserializer.WriteProperty(404, \"fk_keys\", fk_keys);\n-\tserializer.WriteProperty(405, \"alter_fk_type\", type);\n+\tserializer.WritePropertyWithDefault<string>(400, \"fk_table\", fk_table);\n+\tserializer.WritePropertyWithDefault<vector<string>>(401, \"pk_columns\", pk_columns);\n+\tserializer.WritePropertyWithDefault<vector<string>>(402, \"fk_columns\", fk_columns);\n+\tserializer.WritePropertyWithDefault<vector<PhysicalIndex>>(403, \"pk_keys\", pk_keys);\n+\tserializer.WritePropertyWithDefault<vector<PhysicalIndex>>(404, \"fk_keys\", fk_keys);\n+\tserializer.WriteProperty<AlterForeignKeyType>(405, \"alter_fk_type\", type);\n }\n \n unique_ptr<AlterTableInfo> AlterForeignKeyInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<AlterForeignKeyInfo>(new AlterForeignKeyInfo());\n-\tdeserializer.ReadProperty(400, \"fk_table\", result->fk_table);\n-\tdeserializer.ReadProperty(401, \"pk_columns\", result->pk_columns);\n-\tdeserializer.ReadProperty(402, \"fk_columns\", result->fk_columns);\n-\tdeserializer.ReadProperty(403, \"pk_keys\", result->pk_keys);\n-\tdeserializer.ReadProperty(404, \"fk_keys\", result->fk_keys);\n-\tdeserializer.ReadProperty(405, \"alter_fk_type\", result->type);\n+\tdeserializer.ReadPropertyWithDefault<string>(400, \"fk_table\", result->fk_table);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(401, \"pk_columns\", result->pk_columns);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(402, \"fk_columns\", result->fk_columns);\n+\tdeserializer.ReadPropertyWithDefault<vector<PhysicalIndex>>(403, \"pk_keys\", result->pk_keys);\n+\tdeserializer.ReadPropertyWithDefault<vector<PhysicalIndex>>(404, \"fk_keys\", result->fk_keys);\n+\tdeserializer.ReadProperty<AlterForeignKeyType>(405, \"alter_fk_type\", result->type);\n \treturn std::move(result);\n }\n \n void AttachInfo::Serialize(Serializer &serializer) const {\n \tParseInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"name\", name);\n-\tserializer.WriteProperty(201, \"path\", path);\n-\tserializer.WriteProperty(202, \"options\", options);\n+\tserializer.WritePropertyWithDefault<string>(200, \"name\", name);\n+\tserializer.WritePropertyWithDefault<string>(201, \"path\", path);\n+\tserializer.WritePropertyWithDefault<unordered_map<string, Value>>(202, \"options\", options);\n }\n \n unique_ptr<ParseInfo> AttachInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<AttachInfo>(new AttachInfo());\n-\tdeserializer.ReadProperty(200, \"name\", result->name);\n-\tdeserializer.ReadProperty(201, \"path\", result->path);\n-\tdeserializer.ReadProperty(202, \"options\", result->options);\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"name\", result->name);\n+\tdeserializer.ReadPropertyWithDefault<string>(201, \"path\", result->path);\n+\tdeserializer.ReadPropertyWithDefault<unordered_map<string, Value>>(202, \"options\", result->options);\n \treturn std::move(result);\n }\n \n void ChangeColumnTypeInfo::Serialize(Serializer &serializer) const {\n \tAlterTableInfo::Serialize(serializer);\n-\tserializer.WriteProperty(400, \"column_name\", column_name);\n-\tserializer.WriteProperty(401, \"target_type\", target_type);\n-\tserializer.WriteProperty(402, \"expression\", expression);\n+\tserializer.WritePropertyWithDefault<string>(400, \"column_name\", column_name);\n+\tserializer.WriteProperty<LogicalType>(401, \"target_type\", target_type);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(402, \"expression\", expression);\n }\n \n unique_ptr<AlterTableInfo> ChangeColumnTypeInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<ChangeColumnTypeInfo>(new ChangeColumnTypeInfo());\n-\tdeserializer.ReadProperty(400, \"column_name\", result->column_name);\n-\tdeserializer.ReadProperty(401, \"target_type\", result->target_type);\n-\tdeserializer.ReadProperty(402, \"expression\", result->expression);\n+\tdeserializer.ReadPropertyWithDefault<string>(400, \"column_name\", result->column_name);\n+\tdeserializer.ReadProperty<LogicalType>(401, \"target_type\", result->target_type);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(402, \"expression\", result->expression);\n \treturn std::move(result);\n }\n \n void CopyInfo::Serialize(Serializer &serializer) const {\n \tParseInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"catalog\", catalog);\n-\tserializer.WriteProperty(201, \"schema\", schema);\n-\tserializer.WriteProperty(202, \"table\", table);\n-\tserializer.WriteProperty(203, \"select_list\", select_list);\n-\tserializer.WriteProperty(204, \"is_from\", is_from);\n-\tserializer.WriteProperty(205, \"format\", format);\n-\tserializer.WriteProperty(206, \"file_path\", file_path);\n-\tserializer.WriteProperty(207, \"options\", options);\n+\tserializer.WritePropertyWithDefault<string>(200, \"catalog\", catalog);\n+\tserializer.WritePropertyWithDefault<string>(201, \"schema\", schema);\n+\tserializer.WritePropertyWithDefault<string>(202, \"table\", table);\n+\tserializer.WritePropertyWithDefault<vector<string>>(203, \"select_list\", select_list);\n+\tserializer.WritePropertyWithDefault<bool>(204, \"is_from\", is_from);\n+\tserializer.WritePropertyWithDefault<string>(205, \"format\", format);\n+\tserializer.WritePropertyWithDefault<string>(206, \"file_path\", file_path);\n+\tserializer.WritePropertyWithDefault<case_insensitive_map_t<vector<Value>>>(207, \"options\", options);\n }\n \n unique_ptr<ParseInfo> CopyInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<CopyInfo>(new CopyInfo());\n-\tdeserializer.ReadProperty(200, \"catalog\", result->catalog);\n-\tdeserializer.ReadProperty(201, \"schema\", result->schema);\n-\tdeserializer.ReadProperty(202, \"table\", result->table);\n-\tdeserializer.ReadProperty(203, \"select_list\", result->select_list);\n-\tdeserializer.ReadProperty(204, \"is_from\", result->is_from);\n-\tdeserializer.ReadProperty(205, \"format\", result->format);\n-\tdeserializer.ReadProperty(206, \"file_path\", result->file_path);\n-\tdeserializer.ReadProperty(207, \"options\", result->options);\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"catalog\", result->catalog);\n+\tdeserializer.ReadPropertyWithDefault<string>(201, \"schema\", result->schema);\n+\tdeserializer.ReadPropertyWithDefault<string>(202, \"table\", result->table);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(203, \"select_list\", result->select_list);\n+\tdeserializer.ReadPropertyWithDefault<bool>(204, \"is_from\", result->is_from);\n+\tdeserializer.ReadPropertyWithDefault<string>(205, \"format\", result->format);\n+\tdeserializer.ReadPropertyWithDefault<string>(206, \"file_path\", result->file_path);\n+\tdeserializer.ReadPropertyWithDefault<case_insensitive_map_t<vector<Value>>>(207, \"options\", result->options);\n \treturn std::move(result);\n }\n \n void DetachInfo::Serialize(Serializer &serializer) const {\n \tParseInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"name\", name);\n-\tserializer.WriteProperty(201, \"if_not_found\", if_not_found);\n+\tserializer.WritePropertyWithDefault<string>(200, \"name\", name);\n+\tserializer.WriteProperty<OnEntryNotFound>(201, \"if_not_found\", if_not_found);\n }\n \n unique_ptr<ParseInfo> DetachInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<DetachInfo>(new DetachInfo());\n-\tdeserializer.ReadProperty(200, \"name\", result->name);\n-\tdeserializer.ReadProperty(201, \"if_not_found\", result->if_not_found);\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"name\", result->name);\n+\tdeserializer.ReadProperty<OnEntryNotFound>(201, \"if_not_found\", result->if_not_found);\n \treturn std::move(result);\n }\n \n void DropInfo::Serialize(Serializer &serializer) const {\n \tParseInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"type\", type);\n-\tserializer.WriteProperty(201, \"catalog\", catalog);\n-\tserializer.WriteProperty(202, \"schema\", schema);\n-\tserializer.WriteProperty(203, \"name\", name);\n-\tserializer.WriteProperty(204, \"if_not_found\", if_not_found);\n-\tserializer.WriteProperty(205, \"cascade\", cascade);\n-\tserializer.WriteProperty(206, \"allow_drop_internal\", allow_drop_internal);\n+\tserializer.WriteProperty<CatalogType>(200, \"type\", type);\n+\tserializer.WritePropertyWithDefault<string>(201, \"catalog\", catalog);\n+\tserializer.WritePropertyWithDefault<string>(202, \"schema\", schema);\n+\tserializer.WritePropertyWithDefault<string>(203, \"name\", name);\n+\tserializer.WriteProperty<OnEntryNotFound>(204, \"if_not_found\", if_not_found);\n+\tserializer.WritePropertyWithDefault<bool>(205, \"cascade\", cascade);\n+\tserializer.WritePropertyWithDefault<bool>(206, \"allow_drop_internal\", allow_drop_internal);\n }\n \n unique_ptr<ParseInfo> DropInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<DropInfo>(new DropInfo());\n-\tdeserializer.ReadProperty(200, \"type\", result->type);\n-\tdeserializer.ReadProperty(201, \"catalog\", result->catalog);\n-\tdeserializer.ReadProperty(202, \"schema\", result->schema);\n-\tdeserializer.ReadProperty(203, \"name\", result->name);\n-\tdeserializer.ReadProperty(204, \"if_not_found\", result->if_not_found);\n-\tdeserializer.ReadProperty(205, \"cascade\", result->cascade);\n-\tdeserializer.ReadProperty(206, \"allow_drop_internal\", result->allow_drop_internal);\n+\tdeserializer.ReadProperty<CatalogType>(200, \"type\", result->type);\n+\tdeserializer.ReadPropertyWithDefault<string>(201, \"catalog\", result->catalog);\n+\tdeserializer.ReadPropertyWithDefault<string>(202, \"schema\", result->schema);\n+\tdeserializer.ReadPropertyWithDefault<string>(203, \"name\", result->name);\n+\tdeserializer.ReadProperty<OnEntryNotFound>(204, \"if_not_found\", result->if_not_found);\n+\tdeserializer.ReadPropertyWithDefault<bool>(205, \"cascade\", result->cascade);\n+\tdeserializer.ReadPropertyWithDefault<bool>(206, \"allow_drop_internal\", result->allow_drop_internal);\n \treturn std::move(result);\n }\n \n void DropNotNullInfo::Serialize(Serializer &serializer) const {\n \tAlterTableInfo::Serialize(serializer);\n-\tserializer.WriteProperty(400, \"column_name\", column_name);\n+\tserializer.WritePropertyWithDefault<string>(400, \"column_name\", column_name);\n }\n \n unique_ptr<AlterTableInfo> DropNotNullInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<DropNotNullInfo>(new DropNotNullInfo());\n-\tdeserializer.ReadProperty(400, \"column_name\", result->column_name);\n+\tdeserializer.ReadPropertyWithDefault<string>(400, \"column_name\", result->column_name);\n \treturn std::move(result);\n }\n \n void LoadInfo::Serialize(Serializer &serializer) const {\n \tParseInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"filename\", filename);\n-\tserializer.WriteProperty(201, \"load_type\", load_type);\n-\tserializer.WriteProperty(202, \"repository\", repository);\n+\tserializer.WritePropertyWithDefault<string>(200, \"filename\", filename);\n+\tserializer.WriteProperty<LoadType>(201, \"load_type\", load_type);\n+\tserializer.WritePropertyWithDefault<string>(202, \"repository\", repository);\n }\n \n unique_ptr<ParseInfo> LoadInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<LoadInfo>(new LoadInfo());\n-\tdeserializer.ReadProperty(200, \"filename\", result->filename);\n-\tdeserializer.ReadProperty(201, \"load_type\", result->load_type);\n-\tdeserializer.ReadProperty(202, \"repository\", result->repository);\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"filename\", result->filename);\n+\tdeserializer.ReadProperty<LoadType>(201, \"load_type\", result->load_type);\n+\tdeserializer.ReadPropertyWithDefault<string>(202, \"repository\", result->repository);\n \treturn std::move(result);\n }\n \n void PragmaInfo::Serialize(Serializer &serializer) const {\n \tParseInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"name\", name);\n-\tserializer.WriteProperty(201, \"parameters\", parameters);\n-\tserializer.WriteProperty(202, \"named_parameters\", named_parameters);\n+\tserializer.WritePropertyWithDefault<string>(200, \"name\", name);\n+\tserializer.WritePropertyWithDefault<vector<Value>>(201, \"parameters\", parameters);\n+\tserializer.WriteProperty<named_parameter_map_t>(202, \"named_parameters\", named_parameters);\n }\n \n unique_ptr<ParseInfo> PragmaInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<PragmaInfo>(new PragmaInfo());\n-\tdeserializer.ReadProperty(200, \"name\", result->name);\n-\tdeserializer.ReadProperty(201, \"parameters\", result->parameters);\n-\tdeserializer.ReadProperty(202, \"named_parameters\", result->named_parameters);\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"name\", result->name);\n+\tdeserializer.ReadPropertyWithDefault<vector<Value>>(201, \"parameters\", result->parameters);\n+\tdeserializer.ReadProperty<named_parameter_map_t>(202, \"named_parameters\", result->named_parameters);\n \treturn std::move(result);\n }\n \n void RemoveColumnInfo::Serialize(Serializer &serializer) const {\n \tAlterTableInfo::Serialize(serializer);\n-\tserializer.WriteProperty(400, \"removed_column\", removed_column);\n-\tserializer.WriteProperty(401, \"if_column_exists\", if_column_exists);\n-\tserializer.WriteProperty(402, \"cascade\", cascade);\n+\tserializer.WritePropertyWithDefault<string>(400, \"removed_column\", removed_column);\n+\tserializer.WritePropertyWithDefault<bool>(401, \"if_column_exists\", if_column_exists);\n+\tserializer.WritePropertyWithDefault<bool>(402, \"cascade\", cascade);\n }\n \n unique_ptr<AlterTableInfo> RemoveColumnInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<RemoveColumnInfo>(new RemoveColumnInfo());\n-\tdeserializer.ReadProperty(400, \"removed_column\", result->removed_column);\n-\tdeserializer.ReadProperty(401, \"if_column_exists\", result->if_column_exists);\n-\tdeserializer.ReadProperty(402, \"cascade\", result->cascade);\n+\tdeserializer.ReadPropertyWithDefault<string>(400, \"removed_column\", result->removed_column);\n+\tdeserializer.ReadPropertyWithDefault<bool>(401, \"if_column_exists\", result->if_column_exists);\n+\tdeserializer.ReadPropertyWithDefault<bool>(402, \"cascade\", result->cascade);\n \treturn std::move(result);\n }\n \n void RenameColumnInfo::Serialize(Serializer &serializer) const {\n \tAlterTableInfo::Serialize(serializer);\n-\tserializer.WriteProperty(400, \"old_name\", old_name);\n-\tserializer.WriteProperty(401, \"new_name\", new_name);\n+\tserializer.WritePropertyWithDefault<string>(400, \"old_name\", old_name);\n+\tserializer.WritePropertyWithDefault<string>(401, \"new_name\", new_name);\n }\n \n unique_ptr<AlterTableInfo> RenameColumnInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<RenameColumnInfo>(new RenameColumnInfo());\n-\tdeserializer.ReadProperty(400, \"old_name\", result->old_name);\n-\tdeserializer.ReadProperty(401, \"new_name\", result->new_name);\n+\tdeserializer.ReadPropertyWithDefault<string>(400, \"old_name\", result->old_name);\n+\tdeserializer.ReadPropertyWithDefault<string>(401, \"new_name\", result->new_name);\n \treturn std::move(result);\n }\n \n void RenameTableInfo::Serialize(Serializer &serializer) const {\n \tAlterTableInfo::Serialize(serializer);\n-\tserializer.WriteProperty(400, \"new_table_name\", new_table_name);\n+\tserializer.WritePropertyWithDefault<string>(400, \"new_table_name\", new_table_name);\n }\n \n unique_ptr<AlterTableInfo> RenameTableInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<RenameTableInfo>(new RenameTableInfo());\n-\tdeserializer.ReadProperty(400, \"new_table_name\", result->new_table_name);\n+\tdeserializer.ReadPropertyWithDefault<string>(400, \"new_table_name\", result->new_table_name);\n \treturn std::move(result);\n }\n \n void RenameViewInfo::Serialize(Serializer &serializer) const {\n \tAlterViewInfo::Serialize(serializer);\n-\tserializer.WriteProperty(400, \"new_view_name\", new_view_name);\n+\tserializer.WritePropertyWithDefault<string>(400, \"new_view_name\", new_view_name);\n }\n \n unique_ptr<AlterViewInfo> RenameViewInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<RenameViewInfo>(new RenameViewInfo());\n-\tdeserializer.ReadProperty(400, \"new_view_name\", result->new_view_name);\n+\tdeserializer.ReadPropertyWithDefault<string>(400, \"new_view_name\", result->new_view_name);\n \treturn std::move(result);\n }\n \n void SetDefaultInfo::Serialize(Serializer &serializer) const {\n \tAlterTableInfo::Serialize(serializer);\n-\tserializer.WriteProperty(400, \"column_name\", column_name);\n-\tserializer.WritePropertyWithDefault(401, \"expression\", expression, unique_ptr<ParsedExpression>());\n+\tserializer.WritePropertyWithDefault<string>(400, \"column_name\", column_name);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(401, \"expression\", expression);\n }\n \n unique_ptr<AlterTableInfo> SetDefaultInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<SetDefaultInfo>(new SetDefaultInfo());\n-\tdeserializer.ReadProperty(400, \"column_name\", result->column_name);\n-\tdeserializer.ReadPropertyWithDefault(401, \"expression\", result->expression, unique_ptr<ParsedExpression>());\n+\tdeserializer.ReadPropertyWithDefault<string>(400, \"column_name\", result->column_name);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(401, \"expression\", result->expression);\n \treturn std::move(result);\n }\n \n void SetNotNullInfo::Serialize(Serializer &serializer) const {\n \tAlterTableInfo::Serialize(serializer);\n-\tserializer.WriteProperty(400, \"column_name\", column_name);\n+\tserializer.WritePropertyWithDefault<string>(400, \"column_name\", column_name);\n }\n \n unique_ptr<AlterTableInfo> SetNotNullInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<SetNotNullInfo>(new SetNotNullInfo());\n-\tdeserializer.ReadProperty(400, \"column_name\", result->column_name);\n+\tdeserializer.ReadPropertyWithDefault<string>(400, \"column_name\", result->column_name);\n \treturn std::move(result);\n }\n \n void TransactionInfo::Serialize(Serializer &serializer) const {\n \tParseInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"type\", type);\n+\tserializer.WriteProperty<TransactionType>(200, \"type\", type);\n }\n \n unique_ptr<ParseInfo> TransactionInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<TransactionInfo>(new TransactionInfo());\n-\tdeserializer.ReadProperty(200, \"type\", result->type);\n+\tdeserializer.ReadProperty<TransactionType>(200, \"type\", result->type);\n \treturn std::move(result);\n }\n \n void VacuumInfo::Serialize(Serializer &serializer) const {\n \tParseInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"options\", options);\n+\tserializer.WriteProperty<VacuumOptions>(200, \"options\", options);\n }\n \n unique_ptr<ParseInfo> VacuumInfo::Deserialize(Deserializer &deserializer) {\ndiff --git a/src/storage/serialization/serialize_parsed_expression.cpp b/src/storage/serialization/serialize_parsed_expression.cpp\nindex 53da3cda8733..39297311db4f 100644\n--- a/src/storage/serialization/serialize_parsed_expression.cpp\n+++ b/src/storage/serialization/serialize_parsed_expression.cpp\n@@ -10,15 +10,15 @@\n namespace duckdb {\n \n void ParsedExpression::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"class\", expression_class);\n-\tserializer.WriteProperty(101, \"type\", type);\n-\tserializer.WriteProperty(102, \"alias\", alias);\n+\tserializer.WriteProperty<ExpressionClass>(100, \"class\", expression_class);\n+\tserializer.WriteProperty<ExpressionType>(101, \"type\", type);\n+\tserializer.WritePropertyWithDefault<string>(102, \"alias\", alias);\n }\n \n unique_ptr<ParsedExpression> ParsedExpression::Deserialize(Deserializer &deserializer) {\n \tauto expression_class = deserializer.ReadProperty<ExpressionClass>(100, \"class\");\n \tauto type = deserializer.ReadProperty<ExpressionType>(101, \"type\");\n-\tauto alias = deserializer.ReadProperty<string>(102, \"alias\");\n+\tauto alias = deserializer.ReadPropertyWithDefault<string>(102, \"alias\");\n \tdeserializer.Set<ExpressionType>(type);\n \tunique_ptr<ParsedExpression> result;\n \tswitch (expression_class) {\n@@ -83,103 +83,103 @@ unique_ptr<ParsedExpression> ParsedExpression::Deserialize(Deserializer &deseria\n \n void BetweenExpression::Serialize(Serializer &serializer) const {\n \tParsedExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"input\", input);\n-\tserializer.WriteProperty(201, \"lower\", lower);\n-\tserializer.WriteProperty(202, \"upper\", upper);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"input\", input);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(201, \"lower\", lower);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(202, \"upper\", upper);\n }\n \n unique_ptr<ParsedExpression> BetweenExpression::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<BetweenExpression>(new BetweenExpression());\n-\tdeserializer.ReadProperty(200, \"input\", result->input);\n-\tdeserializer.ReadProperty(201, \"lower\", result->lower);\n-\tdeserializer.ReadProperty(202, \"upper\", result->upper);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"input\", result->input);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(201, \"lower\", result->lower);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(202, \"upper\", result->upper);\n \treturn std::move(result);\n }\n \n void CaseExpression::Serialize(Serializer &serializer) const {\n \tParsedExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"case_checks\", case_checks);\n-\tserializer.WriteProperty(201, \"else_expr\", else_expr);\n+\tserializer.WritePropertyWithDefault<vector<CaseCheck>>(200, \"case_checks\", case_checks);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(201, \"else_expr\", else_expr);\n }\n \n unique_ptr<ParsedExpression> CaseExpression::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<CaseExpression>(new CaseExpression());\n-\tdeserializer.ReadProperty(200, \"case_checks\", result->case_checks);\n-\tdeserializer.ReadProperty(201, \"else_expr\", result->else_expr);\n+\tdeserializer.ReadPropertyWithDefault<vector<CaseCheck>>(200, \"case_checks\", result->case_checks);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(201, \"else_expr\", result->else_expr);\n \treturn std::move(result);\n }\n \n void CastExpression::Serialize(Serializer &serializer) const {\n \tParsedExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"child\", child);\n-\tserializer.WriteProperty(201, \"cast_type\", cast_type);\n-\tserializer.WriteProperty(202, \"try_cast\", try_cast);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"child\", child);\n+\tserializer.WriteProperty<LogicalType>(201, \"cast_type\", cast_type);\n+\tserializer.WritePropertyWithDefault<bool>(202, \"try_cast\", try_cast);\n }\n \n unique_ptr<ParsedExpression> CastExpression::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<CastExpression>(new CastExpression());\n-\tdeserializer.ReadProperty(200, \"child\", result->child);\n-\tdeserializer.ReadProperty(201, \"cast_type\", result->cast_type);\n-\tdeserializer.ReadProperty(202, \"try_cast\", result->try_cast);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"child\", result->child);\n+\tdeserializer.ReadProperty<LogicalType>(201, \"cast_type\", result->cast_type);\n+\tdeserializer.ReadPropertyWithDefault<bool>(202, \"try_cast\", result->try_cast);\n \treturn std::move(result);\n }\n \n void CollateExpression::Serialize(Serializer &serializer) const {\n \tParsedExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"child\", child);\n-\tserializer.WriteProperty(201, \"collation\", collation);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"child\", child);\n+\tserializer.WritePropertyWithDefault<string>(201, \"collation\", collation);\n }\n \n unique_ptr<ParsedExpression> CollateExpression::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<CollateExpression>(new CollateExpression());\n-\tdeserializer.ReadProperty(200, \"child\", result->child);\n-\tdeserializer.ReadProperty(201, \"collation\", result->collation);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"child\", result->child);\n+\tdeserializer.ReadPropertyWithDefault<string>(201, \"collation\", result->collation);\n \treturn std::move(result);\n }\n \n void ColumnRefExpression::Serialize(Serializer &serializer) const {\n \tParsedExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"column_names\", column_names);\n+\tserializer.WritePropertyWithDefault<vector<string>>(200, \"column_names\", column_names);\n }\n \n unique_ptr<ParsedExpression> ColumnRefExpression::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<ColumnRefExpression>(new ColumnRefExpression());\n-\tdeserializer.ReadProperty(200, \"column_names\", result->column_names);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(200, \"column_names\", result->column_names);\n \treturn std::move(result);\n }\n \n void ComparisonExpression::Serialize(Serializer &serializer) const {\n \tParsedExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"left\", left);\n-\tserializer.WriteProperty(201, \"right\", right);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"left\", left);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(201, \"right\", right);\n }\n \n unique_ptr<ParsedExpression> ComparisonExpression::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<ComparisonExpression>(new ComparisonExpression(deserializer.Get<ExpressionType>()));\n-\tdeserializer.ReadProperty(200, \"left\", result->left);\n-\tdeserializer.ReadProperty(201, \"right\", result->right);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"left\", result->left);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(201, \"right\", result->right);\n \treturn std::move(result);\n }\n \n void ConjunctionExpression::Serialize(Serializer &serializer) const {\n \tParsedExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"children\", children);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(200, \"children\", children);\n }\n \n unique_ptr<ParsedExpression> ConjunctionExpression::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<ConjunctionExpression>(new ConjunctionExpression(deserializer.Get<ExpressionType>()));\n-\tdeserializer.ReadProperty(200, \"children\", result->children);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(200, \"children\", result->children);\n \treturn std::move(result);\n }\n \n void ConstantExpression::Serialize(Serializer &serializer) const {\n \tParsedExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"value\", value);\n+\tserializer.WriteProperty<Value>(200, \"value\", value);\n }\n \n unique_ptr<ParsedExpression> ConstantExpression::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<ConstantExpression>(new ConstantExpression());\n-\tdeserializer.ReadProperty(200, \"value\", result->value);\n+\tdeserializer.ReadProperty<Value>(200, \"value\", result->value);\n \treturn std::move(result);\n }\n \n@@ -194,148 +194,148 @@ unique_ptr<ParsedExpression> DefaultExpression::Deserialize(Deserializer &deseri\n \n void FunctionExpression::Serialize(Serializer &serializer) const {\n \tParsedExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"function_name\", function_name);\n-\tserializer.WriteProperty(201, \"schema\", schema);\n-\tserializer.WriteProperty(202, \"children\", children);\n-\tserializer.WritePropertyWithDefault(203, \"filter\", filter, unique_ptr<ParsedExpression>());\n-\tserializer.WriteProperty(204, \"order_bys\", (ResultModifier *)order_bys.get());\n-\tserializer.WriteProperty(205, \"distinct\", distinct);\n-\tserializer.WriteProperty(206, \"is_operator\", is_operator);\n-\tserializer.WriteProperty(207, \"export_state\", export_state);\n-\tserializer.WriteProperty(208, \"catalog\", catalog);\n+\tserializer.WritePropertyWithDefault<string>(200, \"function_name\", function_name);\n+\tserializer.WritePropertyWithDefault<string>(201, \"schema\", schema);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(202, \"children\", children);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(203, \"filter\", filter);\n+\tserializer.WritePropertyWithDefault<unique_ptr<OrderModifier>>(204, \"order_bys\", order_bys);\n+\tserializer.WritePropertyWithDefault<bool>(205, \"distinct\", distinct);\n+\tserializer.WritePropertyWithDefault<bool>(206, \"is_operator\", is_operator);\n+\tserializer.WritePropertyWithDefault<bool>(207, \"export_state\", export_state);\n+\tserializer.WritePropertyWithDefault<string>(208, \"catalog\", catalog);\n }\n \n unique_ptr<ParsedExpression> FunctionExpression::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<FunctionExpression>(new FunctionExpression());\n-\tdeserializer.ReadProperty(200, \"function_name\", result->function_name);\n-\tdeserializer.ReadProperty(201, \"schema\", result->schema);\n-\tdeserializer.ReadProperty(202, \"children\", result->children);\n-\tdeserializer.ReadPropertyWithDefault(203, \"filter\", result->filter, unique_ptr<ParsedExpression>());\n-\tauto order_bys = deserializer.ReadProperty<unique_ptr<ResultModifier>>(204, \"order_bys\");\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"function_name\", result->function_name);\n+\tdeserializer.ReadPropertyWithDefault<string>(201, \"schema\", result->schema);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(202, \"children\", result->children);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(203, \"filter\", result->filter);\n+\tauto order_bys = deserializer.ReadPropertyWithDefault<unique_ptr<ResultModifier>>(204, \"order_bys\");\n \tresult->order_bys = unique_ptr_cast<ResultModifier, OrderModifier>(std::move(order_bys));\n-\tdeserializer.ReadProperty(205, \"distinct\", result->distinct);\n-\tdeserializer.ReadProperty(206, \"is_operator\", result->is_operator);\n-\tdeserializer.ReadProperty(207, \"export_state\", result->export_state);\n-\tdeserializer.ReadProperty(208, \"catalog\", result->catalog);\n+\tdeserializer.ReadPropertyWithDefault<bool>(205, \"distinct\", result->distinct);\n+\tdeserializer.ReadPropertyWithDefault<bool>(206, \"is_operator\", result->is_operator);\n+\tdeserializer.ReadPropertyWithDefault<bool>(207, \"export_state\", result->export_state);\n+\tdeserializer.ReadPropertyWithDefault<string>(208, \"catalog\", result->catalog);\n \treturn std::move(result);\n }\n \n void LambdaExpression::Serialize(Serializer &serializer) const {\n \tParsedExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"lhs\", lhs);\n-\tserializer.WriteProperty(201, \"expr\", expr);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"lhs\", lhs);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(201, \"expr\", expr);\n }\n \n unique_ptr<ParsedExpression> LambdaExpression::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<LambdaExpression>(new LambdaExpression());\n-\tdeserializer.ReadProperty(200, \"lhs\", result->lhs);\n-\tdeserializer.ReadProperty(201, \"expr\", result->expr);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"lhs\", result->lhs);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(201, \"expr\", result->expr);\n \treturn std::move(result);\n }\n \n void OperatorExpression::Serialize(Serializer &serializer) const {\n \tParsedExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"children\", children);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(200, \"children\", children);\n }\n \n unique_ptr<ParsedExpression> OperatorExpression::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<OperatorExpression>(new OperatorExpression(deserializer.Get<ExpressionType>()));\n-\tdeserializer.ReadProperty(200, \"children\", result->children);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(200, \"children\", result->children);\n \treturn std::move(result);\n }\n \n void ParameterExpression::Serialize(Serializer &serializer) const {\n \tParsedExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"identifier\", identifier);\n+\tserializer.WritePropertyWithDefault<string>(200, \"identifier\", identifier);\n }\n \n unique_ptr<ParsedExpression> ParameterExpression::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<ParameterExpression>(new ParameterExpression());\n-\tdeserializer.ReadProperty(200, \"identifier\", result->identifier);\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"identifier\", result->identifier);\n \treturn std::move(result);\n }\n \n void PositionalReferenceExpression::Serialize(Serializer &serializer) const {\n \tParsedExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"index\", index);\n+\tserializer.WritePropertyWithDefault<idx_t>(200, \"index\", index);\n }\n \n unique_ptr<ParsedExpression> PositionalReferenceExpression::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<PositionalReferenceExpression>(new PositionalReferenceExpression());\n-\tdeserializer.ReadProperty(200, \"index\", result->index);\n+\tdeserializer.ReadPropertyWithDefault<idx_t>(200, \"index\", result->index);\n \treturn std::move(result);\n }\n \n void StarExpression::Serialize(Serializer &serializer) const {\n \tParsedExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"relation_name\", relation_name);\n-\tserializer.WriteProperty(201, \"exclude_list\", exclude_list);\n-\tserializer.WriteProperty(202, \"replace_list\", replace_list);\n-\tserializer.WriteProperty(203, \"columns\", columns);\n-\tserializer.WritePropertyWithDefault(204, \"expr\", expr, unique_ptr<ParsedExpression>());\n+\tserializer.WritePropertyWithDefault<string>(200, \"relation_name\", relation_name);\n+\tserializer.WriteProperty<case_insensitive_set_t>(201, \"exclude_list\", exclude_list);\n+\tserializer.WritePropertyWithDefault<case_insensitive_map_t<unique_ptr<ParsedExpression>>>(202, \"replace_list\", replace_list);\n+\tserializer.WritePropertyWithDefault<bool>(203, \"columns\", columns);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(204, \"expr\", expr);\n }\n \n unique_ptr<ParsedExpression> StarExpression::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<StarExpression>(new StarExpression());\n-\tdeserializer.ReadProperty(200, \"relation_name\", result->relation_name);\n-\tdeserializer.ReadProperty(201, \"exclude_list\", result->exclude_list);\n-\tdeserializer.ReadProperty(202, \"replace_list\", result->replace_list);\n-\tdeserializer.ReadProperty(203, \"columns\", result->columns);\n-\tdeserializer.ReadPropertyWithDefault(204, \"expr\", result->expr, unique_ptr<ParsedExpression>());\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"relation_name\", result->relation_name);\n+\tdeserializer.ReadProperty<case_insensitive_set_t>(201, \"exclude_list\", result->exclude_list);\n+\tdeserializer.ReadPropertyWithDefault<case_insensitive_map_t<unique_ptr<ParsedExpression>>>(202, \"replace_list\", result->replace_list);\n+\tdeserializer.ReadPropertyWithDefault<bool>(203, \"columns\", result->columns);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(204, \"expr\", result->expr);\n \treturn std::move(result);\n }\n \n void SubqueryExpression::Serialize(Serializer &serializer) const {\n \tParsedExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"subquery_type\", subquery_type);\n-\tserializer.WriteProperty(201, \"subquery\", subquery);\n-\tserializer.WritePropertyWithDefault(202, \"child\", child, unique_ptr<ParsedExpression>());\n-\tserializer.WriteProperty(203, \"comparison_type\", comparison_type);\n+\tserializer.WriteProperty<SubqueryType>(200, \"subquery_type\", subquery_type);\n+\tserializer.WritePropertyWithDefault<unique_ptr<SelectStatement>>(201, \"subquery\", subquery);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(202, \"child\", child);\n+\tserializer.WriteProperty<ExpressionType>(203, \"comparison_type\", comparison_type);\n }\n \n unique_ptr<ParsedExpression> SubqueryExpression::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<SubqueryExpression>(new SubqueryExpression());\n-\tdeserializer.ReadProperty(200, \"subquery_type\", result->subquery_type);\n-\tdeserializer.ReadProperty(201, \"subquery\", result->subquery);\n-\tdeserializer.ReadPropertyWithDefault(202, \"child\", result->child, unique_ptr<ParsedExpression>());\n-\tdeserializer.ReadProperty(203, \"comparison_type\", result->comparison_type);\n+\tdeserializer.ReadProperty<SubqueryType>(200, \"subquery_type\", result->subquery_type);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<SelectStatement>>(201, \"subquery\", result->subquery);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(202, \"child\", result->child);\n+\tdeserializer.ReadProperty<ExpressionType>(203, \"comparison_type\", result->comparison_type);\n \treturn std::move(result);\n }\n \n void WindowExpression::Serialize(Serializer &serializer) const {\n \tParsedExpression::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"function_name\", function_name);\n-\tserializer.WriteProperty(201, \"schema\", schema);\n-\tserializer.WriteProperty(202, \"catalog\", catalog);\n-\tserializer.WriteProperty(203, \"children\", children);\n-\tserializer.WriteProperty(204, \"partitions\", partitions);\n-\tserializer.WriteProperty(205, \"orders\", orders);\n-\tserializer.WriteProperty(206, \"start\", start);\n-\tserializer.WriteProperty(207, \"end\", end);\n-\tserializer.WritePropertyWithDefault(208, \"start_expr\", start_expr, unique_ptr<ParsedExpression>());\n-\tserializer.WritePropertyWithDefault(209, \"end_expr\", end_expr, unique_ptr<ParsedExpression>());\n-\tserializer.WritePropertyWithDefault(210, \"offset_expr\", offset_expr, unique_ptr<ParsedExpression>());\n-\tserializer.WritePropertyWithDefault(211, \"default_expr\", default_expr, unique_ptr<ParsedExpression>());\n-\tserializer.WriteProperty(212, \"ignore_nulls\", ignore_nulls);\n-\tserializer.WritePropertyWithDefault(213, \"filter_expr\", filter_expr, unique_ptr<ParsedExpression>());\n+\tserializer.WritePropertyWithDefault<string>(200, \"function_name\", function_name);\n+\tserializer.WritePropertyWithDefault<string>(201, \"schema\", schema);\n+\tserializer.WritePropertyWithDefault<string>(202, \"catalog\", catalog);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(203, \"children\", children);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(204, \"partitions\", partitions);\n+\tserializer.WritePropertyWithDefault<vector<OrderByNode>>(205, \"orders\", orders);\n+\tserializer.WriteProperty<WindowBoundary>(206, \"start\", start);\n+\tserializer.WriteProperty<WindowBoundary>(207, \"end\", end);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(208, \"start_expr\", start_expr);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(209, \"end_expr\", end_expr);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(210, \"offset_expr\", offset_expr);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(211, \"default_expr\", default_expr);\n+\tserializer.WritePropertyWithDefault<bool>(212, \"ignore_nulls\", ignore_nulls);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(213, \"filter_expr\", filter_expr);\n }\n \n unique_ptr<ParsedExpression> WindowExpression::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<WindowExpression>(new WindowExpression(deserializer.Get<ExpressionType>()));\n-\tdeserializer.ReadProperty(200, \"function_name\", result->function_name);\n-\tdeserializer.ReadProperty(201, \"schema\", result->schema);\n-\tdeserializer.ReadProperty(202, \"catalog\", result->catalog);\n-\tdeserializer.ReadProperty(203, \"children\", result->children);\n-\tdeserializer.ReadProperty(204, \"partitions\", result->partitions);\n-\tdeserializer.ReadProperty(205, \"orders\", result->orders);\n-\tdeserializer.ReadProperty(206, \"start\", result->start);\n-\tdeserializer.ReadProperty(207, \"end\", result->end);\n-\tdeserializer.ReadPropertyWithDefault(208, \"start_expr\", result->start_expr, unique_ptr<ParsedExpression>());\n-\tdeserializer.ReadPropertyWithDefault(209, \"end_expr\", result->end_expr, unique_ptr<ParsedExpression>());\n-\tdeserializer.ReadPropertyWithDefault(210, \"offset_expr\", result->offset_expr, unique_ptr<ParsedExpression>());\n-\tdeserializer.ReadPropertyWithDefault(211, \"default_expr\", result->default_expr, unique_ptr<ParsedExpression>());\n-\tdeserializer.ReadProperty(212, \"ignore_nulls\", result->ignore_nulls);\n-\tdeserializer.ReadPropertyWithDefault(213, \"filter_expr\", result->filter_expr, unique_ptr<ParsedExpression>());\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"function_name\", result->function_name);\n+\tdeserializer.ReadPropertyWithDefault<string>(201, \"schema\", result->schema);\n+\tdeserializer.ReadPropertyWithDefault<string>(202, \"catalog\", result->catalog);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(203, \"children\", result->children);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(204, \"partitions\", result->partitions);\n+\tdeserializer.ReadPropertyWithDefault<vector<OrderByNode>>(205, \"orders\", result->orders);\n+\tdeserializer.ReadProperty<WindowBoundary>(206, \"start\", result->start);\n+\tdeserializer.ReadProperty<WindowBoundary>(207, \"end\", result->end);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(208, \"start_expr\", result->start_expr);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(209, \"end_expr\", result->end_expr);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(210, \"offset_expr\", result->offset_expr);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(211, \"default_expr\", result->default_expr);\n+\tdeserializer.ReadPropertyWithDefault<bool>(212, \"ignore_nulls\", result->ignore_nulls);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(213, \"filter_expr\", result->filter_expr);\n \treturn std::move(result);\n }\n \ndiff --git a/src/storage/serialization/serialize_query_node.cpp b/src/storage/serialization/serialize_query_node.cpp\nindex 95692ccd22d0..f271ebc4a11e 100644\n--- a/src/storage/serialization/serialize_query_node.cpp\n+++ b/src/storage/serialization/serialize_query_node.cpp\n@@ -10,14 +10,14 @@\n namespace duckdb {\n \n void QueryNode::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"type\", type);\n-\tserializer.WriteProperty(101, \"modifiers\", modifiers);\n-\tserializer.WriteProperty(102, \"cte_map\", cte_map);\n+\tserializer.WriteProperty<QueryNodeType>(100, \"type\", type);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<ResultModifier>>>(101, \"modifiers\", modifiers);\n+\tserializer.WriteProperty<CommonTableExpressionMap>(102, \"cte_map\", cte_map);\n }\n \n unique_ptr<QueryNode> QueryNode::Deserialize(Deserializer &deserializer) {\n \tauto type = deserializer.ReadProperty<QueryNodeType>(100, \"type\");\n-\tauto modifiers = deserializer.ReadProperty<vector<unique_ptr<ResultModifier>>>(101, \"modifiers\");\n+\tauto modifiers = deserializer.ReadPropertyWithDefault<vector<unique_ptr<ResultModifier>>>(101, \"modifiers\");\n \tauto cte_map = deserializer.ReadProperty<CommonTableExpressionMap>(102, \"cte_map\");\n \tunique_ptr<QueryNode> result;\n \tswitch (type) {\n@@ -43,79 +43,79 @@ unique_ptr<QueryNode> QueryNode::Deserialize(Deserializer &deserializer) {\n \n void CTENode::Serialize(Serializer &serializer) const {\n \tQueryNode::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"cte_name\", ctename);\n-\tserializer.WriteProperty(201, \"query\", query);\n-\tserializer.WriteProperty(202, \"child\", child);\n-\tserializer.WriteProperty(203, \"aliases\", aliases);\n+\tserializer.WritePropertyWithDefault<string>(200, \"cte_name\", ctename);\n+\tserializer.WritePropertyWithDefault<unique_ptr<QueryNode>>(201, \"query\", query);\n+\tserializer.WritePropertyWithDefault<unique_ptr<QueryNode>>(202, \"child\", child);\n+\tserializer.WritePropertyWithDefault<vector<string>>(203, \"aliases\", aliases);\n }\n \n unique_ptr<QueryNode> CTENode::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<CTENode>(new CTENode());\n-\tdeserializer.ReadProperty(200, \"cte_name\", result->ctename);\n-\tdeserializer.ReadProperty(201, \"query\", result->query);\n-\tdeserializer.ReadProperty(202, \"child\", result->child);\n-\tdeserializer.ReadProperty(203, \"aliases\", result->aliases);\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"cte_name\", result->ctename);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<QueryNode>>(201, \"query\", result->query);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<QueryNode>>(202, \"child\", result->child);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(203, \"aliases\", result->aliases);\n \treturn std::move(result);\n }\n \n void RecursiveCTENode::Serialize(Serializer &serializer) const {\n \tQueryNode::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"cte_name\", ctename);\n-\tserializer.WriteProperty(201, \"union_all\", union_all);\n-\tserializer.WriteProperty(202, \"left\", left);\n-\tserializer.WriteProperty(203, \"right\", right);\n-\tserializer.WriteProperty(204, \"aliases\", aliases);\n+\tserializer.WritePropertyWithDefault<string>(200, \"cte_name\", ctename);\n+\tserializer.WritePropertyWithDefault<bool>(201, \"union_all\", union_all, false);\n+\tserializer.WritePropertyWithDefault<unique_ptr<QueryNode>>(202, \"left\", left);\n+\tserializer.WritePropertyWithDefault<unique_ptr<QueryNode>>(203, \"right\", right);\n+\tserializer.WritePropertyWithDefault<vector<string>>(204, \"aliases\", aliases);\n }\n \n unique_ptr<QueryNode> RecursiveCTENode::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<RecursiveCTENode>(new RecursiveCTENode());\n-\tdeserializer.ReadProperty(200, \"cte_name\", result->ctename);\n-\tdeserializer.ReadProperty(201, \"union_all\", result->union_all);\n-\tdeserializer.ReadProperty(202, \"left\", result->left);\n-\tdeserializer.ReadProperty(203, \"right\", result->right);\n-\tdeserializer.ReadProperty(204, \"aliases\", result->aliases);\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"cte_name\", result->ctename);\n+\tdeserializer.ReadPropertyWithDefault<bool>(201, \"union_all\", result->union_all, false);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<QueryNode>>(202, \"left\", result->left);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<QueryNode>>(203, \"right\", result->right);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(204, \"aliases\", result->aliases);\n \treturn std::move(result);\n }\n \n void SelectNode::Serialize(Serializer &serializer) const {\n \tQueryNode::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"select_list\", select_list);\n-\tserializer.WritePropertyWithDefault(201, \"from_table\", from_table, unique_ptr<TableRef>());\n-\tserializer.WritePropertyWithDefault(202, \"where_clause\", where_clause, unique_ptr<ParsedExpression>());\n-\tserializer.WriteProperty(203, \"group_expressions\", groups.group_expressions);\n-\tserializer.WriteProperty(204, \"group_sets\", groups.grouping_sets);\n-\tserializer.WriteProperty(205, \"aggregate_handling\", aggregate_handling);\n-\tserializer.WritePropertyWithDefault(206, \"having\", having, unique_ptr<ParsedExpression>());\n-\tserializer.WritePropertyWithDefault(207, \"sample\", sample, unique_ptr<SampleOptions>());\n-\tserializer.WritePropertyWithDefault(208, \"qualify\", qualify, unique_ptr<ParsedExpression>());\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(200, \"select_list\", select_list);\n+\tserializer.WritePropertyWithDefault<unique_ptr<TableRef>>(201, \"from_table\", from_table);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(202, \"where_clause\", where_clause);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(203, \"group_expressions\", groups.group_expressions);\n+\tserializer.WritePropertyWithDefault<vector<GroupingSet>>(204, \"group_sets\", groups.grouping_sets);\n+\tserializer.WriteProperty<AggregateHandling>(205, \"aggregate_handling\", aggregate_handling);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(206, \"having\", having);\n+\tserializer.WritePropertyWithDefault<unique_ptr<SampleOptions>>(207, \"sample\", sample);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(208, \"qualify\", qualify);\n }\n \n unique_ptr<QueryNode> SelectNode::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<SelectNode>(new SelectNode());\n-\tdeserializer.ReadProperty(200, \"select_list\", result->select_list);\n-\tdeserializer.ReadPropertyWithDefault(201, \"from_table\", result->from_table, unique_ptr<TableRef>());\n-\tdeserializer.ReadPropertyWithDefault(202, \"where_clause\", result->where_clause, unique_ptr<ParsedExpression>());\n-\tdeserializer.ReadProperty(203, \"group_expressions\", result->groups.group_expressions);\n-\tdeserializer.ReadProperty(204, \"group_sets\", result->groups.grouping_sets);\n-\tdeserializer.ReadProperty(205, \"aggregate_handling\", result->aggregate_handling);\n-\tdeserializer.ReadPropertyWithDefault(206, \"having\", result->having, unique_ptr<ParsedExpression>());\n-\tdeserializer.ReadPropertyWithDefault(207, \"sample\", result->sample, unique_ptr<SampleOptions>());\n-\tdeserializer.ReadPropertyWithDefault(208, \"qualify\", result->qualify, unique_ptr<ParsedExpression>());\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(200, \"select_list\", result->select_list);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<TableRef>>(201, \"from_table\", result->from_table);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(202, \"where_clause\", result->where_clause);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(203, \"group_expressions\", result->groups.group_expressions);\n+\tdeserializer.ReadPropertyWithDefault<vector<GroupingSet>>(204, \"group_sets\", result->groups.grouping_sets);\n+\tdeserializer.ReadProperty<AggregateHandling>(205, \"aggregate_handling\", result->aggregate_handling);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(206, \"having\", result->having);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<SampleOptions>>(207, \"sample\", result->sample);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(208, \"qualify\", result->qualify);\n \treturn std::move(result);\n }\n \n void SetOperationNode::Serialize(Serializer &serializer) const {\n \tQueryNode::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"setop_type\", setop_type);\n-\tserializer.WriteProperty(201, \"left\", left);\n-\tserializer.WriteProperty(202, \"right\", right);\n+\tserializer.WriteProperty<SetOperationType>(200, \"setop_type\", setop_type);\n+\tserializer.WritePropertyWithDefault<unique_ptr<QueryNode>>(201, \"left\", left);\n+\tserializer.WritePropertyWithDefault<unique_ptr<QueryNode>>(202, \"right\", right);\n }\n \n unique_ptr<QueryNode> SetOperationNode::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<SetOperationNode>(new SetOperationNode());\n-\tdeserializer.ReadProperty(200, \"setop_type\", result->setop_type);\n-\tdeserializer.ReadProperty(201, \"left\", result->left);\n-\tdeserializer.ReadProperty(202, \"right\", result->right);\n+\tdeserializer.ReadProperty<SetOperationType>(200, \"setop_type\", result->setop_type);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<QueryNode>>(201, \"left\", result->left);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<QueryNode>>(202, \"right\", result->right);\n \treturn std::move(result);\n }\n \ndiff --git a/src/storage/serialization/serialize_result_modifier.cpp b/src/storage/serialization/serialize_result_modifier.cpp\nindex ca71aec294c4..261f106c6226 100644\n--- a/src/storage/serialization/serialize_result_modifier.cpp\n+++ b/src/storage/serialization/serialize_result_modifier.cpp\n@@ -11,7 +11,7 @@\n namespace duckdb {\n \n void ResultModifier::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"type\", type);\n+\tserializer.WriteProperty<ResultModifierType>(100, \"type\", type);\n }\n \n unique_ptr<ResultModifier> ResultModifier::Deserialize(Deserializer &deserializer) {\n@@ -37,60 +37,60 @@ unique_ptr<ResultModifier> ResultModifier::Deserialize(Deserializer &deserialize\n }\n \n void BoundOrderModifier::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"orders\", orders);\n+\tserializer.WritePropertyWithDefault<vector<BoundOrderByNode>>(100, \"orders\", orders);\n }\n \n unique_ptr<BoundOrderModifier> BoundOrderModifier::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<BoundOrderModifier>(new BoundOrderModifier());\n-\tdeserializer.ReadProperty(100, \"orders\", result->orders);\n+\tdeserializer.ReadPropertyWithDefault<vector<BoundOrderByNode>>(100, \"orders\", result->orders);\n \treturn result;\n }\n \n void DistinctModifier::Serialize(Serializer &serializer) const {\n \tResultModifier::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"distinct_on_targets\", distinct_on_targets);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(200, \"distinct_on_targets\", distinct_on_targets);\n }\n \n unique_ptr<ResultModifier> DistinctModifier::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<DistinctModifier>(new DistinctModifier());\n-\tdeserializer.ReadProperty(200, \"distinct_on_targets\", result->distinct_on_targets);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(200, \"distinct_on_targets\", result->distinct_on_targets);\n \treturn std::move(result);\n }\n \n void LimitModifier::Serialize(Serializer &serializer) const {\n \tResultModifier::Serialize(serializer);\n-\tserializer.WritePropertyWithDefault(200, \"limit\", limit, unique_ptr<ParsedExpression>());\n-\tserializer.WritePropertyWithDefault(201, \"offset\", offset, unique_ptr<ParsedExpression>());\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"limit\", limit);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(201, \"offset\", offset);\n }\n \n unique_ptr<ResultModifier> LimitModifier::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<LimitModifier>(new LimitModifier());\n-\tdeserializer.ReadPropertyWithDefault(200, \"limit\", result->limit, unique_ptr<ParsedExpression>());\n-\tdeserializer.ReadPropertyWithDefault(201, \"offset\", result->offset, unique_ptr<ParsedExpression>());\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"limit\", result->limit);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(201, \"offset\", result->offset);\n \treturn std::move(result);\n }\n \n void LimitPercentModifier::Serialize(Serializer &serializer) const {\n \tResultModifier::Serialize(serializer);\n-\tserializer.WritePropertyWithDefault(200, \"limit\", limit, unique_ptr<ParsedExpression>());\n-\tserializer.WritePropertyWithDefault(201, \"offset\", offset, unique_ptr<ParsedExpression>());\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"limit\", limit);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(201, \"offset\", offset);\n }\n \n unique_ptr<ResultModifier> LimitPercentModifier::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<LimitPercentModifier>(new LimitPercentModifier());\n-\tdeserializer.ReadPropertyWithDefault(200, \"limit\", result->limit, unique_ptr<ParsedExpression>());\n-\tdeserializer.ReadPropertyWithDefault(201, \"offset\", result->offset, unique_ptr<ParsedExpression>());\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"limit\", result->limit);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(201, \"offset\", result->offset);\n \treturn std::move(result);\n }\n \n void OrderModifier::Serialize(Serializer &serializer) const {\n \tResultModifier::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"orders\", orders);\n+\tserializer.WritePropertyWithDefault<vector<OrderByNode>>(200, \"orders\", orders);\n }\n \n unique_ptr<ResultModifier> OrderModifier::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<OrderModifier>(new OrderModifier());\n-\tdeserializer.ReadProperty(200, \"orders\", result->orders);\n+\tdeserializer.ReadPropertyWithDefault<vector<OrderByNode>>(200, \"orders\", result->orders);\n \treturn std::move(result);\n }\n \ndiff --git a/src/storage/serialization/serialize_statement.cpp b/src/storage/serialization/serialize_statement.cpp\nindex 3af920a0087f..235ffd1e8b29 100644\n--- a/src/storage/serialization/serialize_statement.cpp\n+++ b/src/storage/serialization/serialize_statement.cpp\n@@ -10,12 +10,12 @@\n namespace duckdb {\n \n void SelectStatement::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"node\", node);\n+\tserializer.WritePropertyWithDefault<unique_ptr<QueryNode>>(100, \"node\", node);\n }\n \n unique_ptr<SelectStatement> SelectStatement::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<SelectStatement>(new SelectStatement());\n-\tdeserializer.ReadProperty(100, \"node\", result->node);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<QueryNode>>(100, \"node\", result->node);\n \treturn result;\n }\n \ndiff --git a/src/storage/serialization/serialize_storage.cpp b/src/storage/serialization/serialize_storage.cpp\nindex 27e6fad827f5..605d5a4166e8 100644\n--- a/src/storage/serialization/serialize_storage.cpp\n+++ b/src/storage/serialization/serialize_storage.cpp\n@@ -12,29 +12,29 @@\n namespace duckdb {\n \n void BlockPointer::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"block_id\", block_id);\n-\tserializer.WriteProperty(101, \"offset\", offset);\n+\tserializer.WriteProperty<block_id_t>(100, \"block_id\", block_id);\n+\tserializer.WritePropertyWithDefault<uint32_t>(101, \"offset\", offset);\n }\n \n BlockPointer BlockPointer::Deserialize(Deserializer &deserializer) {\n \tauto block_id = deserializer.ReadProperty<block_id_t>(100, \"block_id\");\n-\tauto offset = deserializer.ReadProperty<uint32_t>(101, \"offset\");\n+\tauto offset = deserializer.ReadPropertyWithDefault<uint32_t>(101, \"offset\");\n \tBlockPointer result(block_id, offset);\n \treturn result;\n }\n \n void DataPointer::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"row_start\", row_start);\n-\tserializer.WriteProperty(101, \"tuple_count\", tuple_count);\n-\tserializer.WriteProperty(102, \"block_pointer\", block_pointer);\n-\tserializer.WriteProperty(103, \"compression_type\", compression_type);\n-\tserializer.WriteProperty(104, \"statistics\", statistics);\n-\tserializer.WriteProperty(105, \"segment_state\", segment_state);\n+\tserializer.WritePropertyWithDefault<uint64_t>(100, \"row_start\", row_start);\n+\tserializer.WritePropertyWithDefault<uint64_t>(101, \"tuple_count\", tuple_count);\n+\tserializer.WriteProperty<BlockPointer>(102, \"block_pointer\", block_pointer);\n+\tserializer.WriteProperty<CompressionType>(103, \"compression_type\", compression_type);\n+\tserializer.WriteProperty<BaseStatistics>(104, \"statistics\", statistics);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ColumnSegmentState>>(105, \"segment_state\", segment_state);\n }\n \n DataPointer DataPointer::Deserialize(Deserializer &deserializer) {\n-\tauto row_start = deserializer.ReadProperty<uint64_t>(100, \"row_start\");\n-\tauto tuple_count = deserializer.ReadProperty<uint64_t>(101, \"tuple_count\");\n+\tauto row_start = deserializer.ReadPropertyWithDefault<uint64_t>(100, \"row_start\");\n+\tauto tuple_count = deserializer.ReadPropertyWithDefault<uint64_t>(101, \"tuple_count\");\n \tauto block_pointer = deserializer.ReadProperty<BlockPointer>(102, \"block_pointer\");\n \tauto compression_type = deserializer.ReadProperty<CompressionType>(103, \"compression_type\");\n \tauto statistics = deserializer.ReadProperty<BaseStatistics>(104, \"statistics\");\n@@ -44,33 +44,33 @@ DataPointer DataPointer::Deserialize(Deserializer &deserializer) {\n \tresult.block_pointer = block_pointer;\n \tresult.compression_type = compression_type;\n \tdeserializer.Set<CompressionType>(compression_type);\n-\tdeserializer.ReadProperty(105, \"segment_state\", result.segment_state);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ColumnSegmentState>>(105, \"segment_state\", result.segment_state);\n \tdeserializer.Unset<CompressionType>();\n \treturn result;\n }\n \n void DistinctStatistics::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"sample_count\", sample_count);\n-\tserializer.WriteProperty(101, \"total_count\", total_count);\n-\tserializer.WriteProperty(102, \"log\", log);\n+\tserializer.WritePropertyWithDefault<idx_t>(100, \"sample_count\", sample_count);\n+\tserializer.WritePropertyWithDefault<idx_t>(101, \"total_count\", total_count);\n+\tserializer.WritePropertyWithDefault<unique_ptr<HyperLogLog>>(102, \"log\", log);\n }\n \n unique_ptr<DistinctStatistics> DistinctStatistics::Deserialize(Deserializer &deserializer) {\n-\tauto sample_count = deserializer.ReadProperty<idx_t>(100, \"sample_count\");\n-\tauto total_count = deserializer.ReadProperty<idx_t>(101, \"total_count\");\n-\tauto log = deserializer.ReadProperty<unique_ptr<HyperLogLog>>(102, \"log\");\n+\tauto sample_count = deserializer.ReadPropertyWithDefault<idx_t>(100, \"sample_count\");\n+\tauto total_count = deserializer.ReadPropertyWithDefault<idx_t>(101, \"total_count\");\n+\tauto log = deserializer.ReadPropertyWithDefault<unique_ptr<HyperLogLog>>(102, \"log\");\n \tauto result = duckdb::unique_ptr<DistinctStatistics>(new DistinctStatistics(std::move(log), sample_count, total_count));\n \treturn result;\n }\n \n void MetaBlockPointer::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"block_pointer\", block_pointer);\n-\tserializer.WriteProperty(101, \"offset\", offset);\n+\tserializer.WritePropertyWithDefault<idx_t>(100, \"block_pointer\", block_pointer);\n+\tserializer.WritePropertyWithDefault<uint32_t>(101, \"offset\", offset);\n }\n \n MetaBlockPointer MetaBlockPointer::Deserialize(Deserializer &deserializer) {\n-\tauto block_pointer = deserializer.ReadProperty<idx_t>(100, \"block_pointer\");\n-\tauto offset = deserializer.ReadProperty<uint32_t>(101, \"offset\");\n+\tauto block_pointer = deserializer.ReadPropertyWithDefault<idx_t>(100, \"block_pointer\");\n+\tauto offset = deserializer.ReadPropertyWithDefault<uint32_t>(101, \"offset\");\n \tMetaBlockPointer result(block_pointer, offset);\n \treturn result;\n }\ndiff --git a/src/storage/serialization/serialize_table_filter.cpp b/src/storage/serialization/serialize_table_filter.cpp\nindex 944e3ad7bc39..ae065cdde7cf 100644\n--- a/src/storage/serialization/serialize_table_filter.cpp\n+++ b/src/storage/serialization/serialize_table_filter.cpp\n@@ -13,7 +13,7 @@\n namespace duckdb {\n \n void TableFilter::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"filter_type\", filter_type);\n+\tserializer.WriteProperty<TableFilterType>(100, \"filter_type\", filter_type);\n }\n \n unique_ptr<TableFilter> TableFilter::Deserialize(Deserializer &deserializer) {\n@@ -43,30 +43,30 @@ unique_ptr<TableFilter> TableFilter::Deserialize(Deserializer &deserializer) {\n \n void ConjunctionAndFilter::Serialize(Serializer &serializer) const {\n \tTableFilter::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"child_filters\", child_filters);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<TableFilter>>>(200, \"child_filters\", child_filters);\n }\n \n unique_ptr<TableFilter> ConjunctionAndFilter::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<ConjunctionAndFilter>(new ConjunctionAndFilter());\n-\tdeserializer.ReadProperty(200, \"child_filters\", result->child_filters);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<TableFilter>>>(200, \"child_filters\", result->child_filters);\n \treturn std::move(result);\n }\n \n void ConjunctionOrFilter::Serialize(Serializer &serializer) const {\n \tTableFilter::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"child_filters\", child_filters);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<TableFilter>>>(200, \"child_filters\", child_filters);\n }\n \n unique_ptr<TableFilter> ConjunctionOrFilter::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<ConjunctionOrFilter>(new ConjunctionOrFilter());\n-\tdeserializer.ReadProperty(200, \"child_filters\", result->child_filters);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<TableFilter>>>(200, \"child_filters\", result->child_filters);\n \treturn std::move(result);\n }\n \n void ConstantFilter::Serialize(Serializer &serializer) const {\n \tTableFilter::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"comparison_type\", comparison_type);\n-\tserializer.WriteProperty(201, \"constant\", constant);\n+\tserializer.WriteProperty<ExpressionType>(200, \"comparison_type\", comparison_type);\n+\tserializer.WriteProperty<Value>(201, \"constant\", constant);\n }\n \n unique_ptr<TableFilter> ConstantFilter::Deserialize(Deserializer &deserializer) {\ndiff --git a/src/storage/serialization/serialize_tableref.cpp b/src/storage/serialization/serialize_tableref.cpp\nindex f68e8ddf51f3..754457e5732e 100644\n--- a/src/storage/serialization/serialize_tableref.cpp\n+++ b/src/storage/serialization/serialize_tableref.cpp\n@@ -10,15 +10,15 @@\n namespace duckdb {\n \n void TableRef::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"type\", type);\n-\tserializer.WriteProperty(101, \"alias\", alias);\n-\tserializer.WritePropertyWithDefault(102, \"sample\", sample, unique_ptr<SampleOptions>());\n+\tserializer.WriteProperty<TableReferenceType>(100, \"type\", type);\n+\tserializer.WritePropertyWithDefault<string>(101, \"alias\", alias);\n+\tserializer.WritePropertyWithDefault<unique_ptr<SampleOptions>>(102, \"sample\", sample);\n }\n \n unique_ptr<TableRef> TableRef::Deserialize(Deserializer &deserializer) {\n \tauto type = deserializer.ReadProperty<TableReferenceType>(100, \"type\");\n-\tauto alias = deserializer.ReadProperty<string>(101, \"alias\");\n-\tauto sample = deserializer.ReadPropertyWithDefault<unique_ptr<SampleOptions>>(102, \"sample\", unique_ptr<SampleOptions>());\n+\tauto alias = deserializer.ReadPropertyWithDefault<string>(101, \"alias\");\n+\tauto sample = deserializer.ReadPropertyWithDefault<unique_ptr<SampleOptions>>(102, \"sample\");\n \tunique_ptr<TableRef> result;\n \tswitch (type) {\n \tcase TableReferenceType::BASE_TABLE:\n@@ -52,18 +52,18 @@ unique_ptr<TableRef> TableRef::Deserialize(Deserializer &deserializer) {\n \n void BaseTableRef::Serialize(Serializer &serializer) const {\n \tTableRef::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"schema_name\", schema_name);\n-\tserializer.WriteProperty(201, \"table_name\", table_name);\n-\tserializer.WriteProperty(202, \"column_name_alias\", column_name_alias);\n-\tserializer.WriteProperty(203, \"catalog_name\", catalog_name);\n+\tserializer.WritePropertyWithDefault<string>(200, \"schema_name\", schema_name);\n+\tserializer.WritePropertyWithDefault<string>(201, \"table_name\", table_name);\n+\tserializer.WritePropertyWithDefault<vector<string>>(202, \"column_name_alias\", column_name_alias);\n+\tserializer.WritePropertyWithDefault<string>(203, \"catalog_name\", catalog_name);\n }\n \n unique_ptr<TableRef> BaseTableRef::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<BaseTableRef>(new BaseTableRef());\n-\tdeserializer.ReadProperty(200, \"schema_name\", result->schema_name);\n-\tdeserializer.ReadProperty(201, \"table_name\", result->table_name);\n-\tdeserializer.ReadProperty(202, \"column_name_alias\", result->column_name_alias);\n-\tdeserializer.ReadProperty(203, \"catalog_name\", result->catalog_name);\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"schema_name\", result->schema_name);\n+\tdeserializer.ReadPropertyWithDefault<string>(201, \"table_name\", result->table_name);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(202, \"column_name_alias\", result->column_name_alias);\n+\tdeserializer.ReadPropertyWithDefault<string>(203, \"catalog_name\", result->catalog_name);\n \treturn std::move(result);\n }\n \n@@ -78,86 +78,86 @@ unique_ptr<TableRef> EmptyTableRef::Deserialize(Deserializer &deserializer) {\n \n void ExpressionListRef::Serialize(Serializer &serializer) const {\n \tTableRef::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"expected_names\", expected_names);\n-\tserializer.WriteProperty(201, \"expected_types\", expected_types);\n-\tserializer.WriteProperty(202, \"values\", values);\n+\tserializer.WritePropertyWithDefault<vector<string>>(200, \"expected_names\", expected_names);\n+\tserializer.WritePropertyWithDefault<vector<LogicalType>>(201, \"expected_types\", expected_types);\n+\tserializer.WritePropertyWithDefault<vector<vector<unique_ptr<ParsedExpression>>>>(202, \"values\", values);\n }\n \n unique_ptr<TableRef> ExpressionListRef::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<ExpressionListRef>(new ExpressionListRef());\n-\tdeserializer.ReadProperty(200, \"expected_names\", result->expected_names);\n-\tdeserializer.ReadProperty(201, \"expected_types\", result->expected_types);\n-\tdeserializer.ReadProperty(202, \"values\", result->values);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(200, \"expected_names\", result->expected_names);\n+\tdeserializer.ReadPropertyWithDefault<vector<LogicalType>>(201, \"expected_types\", result->expected_types);\n+\tdeserializer.ReadPropertyWithDefault<vector<vector<unique_ptr<ParsedExpression>>>>(202, \"values\", result->values);\n \treturn std::move(result);\n }\n \n void JoinRef::Serialize(Serializer &serializer) const {\n \tTableRef::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"left\", left);\n-\tserializer.WriteProperty(201, \"right\", right);\n-\tserializer.WritePropertyWithDefault(202, \"condition\", condition, unique_ptr<ParsedExpression>());\n-\tserializer.WriteProperty(203, \"join_type\", type);\n-\tserializer.WriteProperty(204, \"ref_type\", ref_type);\n-\tserializer.WriteProperty(205, \"using_columns\", using_columns);\n+\tserializer.WritePropertyWithDefault<unique_ptr<TableRef>>(200, \"left\", left);\n+\tserializer.WritePropertyWithDefault<unique_ptr<TableRef>>(201, \"right\", right);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(202, \"condition\", condition);\n+\tserializer.WriteProperty<JoinType>(203, \"join_type\", type);\n+\tserializer.WriteProperty<JoinRefType>(204, \"ref_type\", ref_type);\n+\tserializer.WritePropertyWithDefault<vector<string>>(205, \"using_columns\", using_columns);\n }\n \n unique_ptr<TableRef> JoinRef::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<JoinRef>(new JoinRef());\n-\tdeserializer.ReadProperty(200, \"left\", result->left);\n-\tdeserializer.ReadProperty(201, \"right\", result->right);\n-\tdeserializer.ReadPropertyWithDefault(202, \"condition\", result->condition, unique_ptr<ParsedExpression>());\n-\tdeserializer.ReadProperty(203, \"join_type\", result->type);\n-\tdeserializer.ReadProperty(204, \"ref_type\", result->ref_type);\n-\tdeserializer.ReadProperty(205, \"using_columns\", result->using_columns);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<TableRef>>(200, \"left\", result->left);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<TableRef>>(201, \"right\", result->right);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(202, \"condition\", result->condition);\n+\tdeserializer.ReadProperty<JoinType>(203, \"join_type\", result->type);\n+\tdeserializer.ReadProperty<JoinRefType>(204, \"ref_type\", result->ref_type);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(205, \"using_columns\", result->using_columns);\n \treturn std::move(result);\n }\n \n void PivotRef::Serialize(Serializer &serializer) const {\n \tTableRef::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"source\", source);\n-\tserializer.WriteProperty(201, \"aggregates\", aggregates);\n-\tserializer.WriteProperty(202, \"unpivot_names\", unpivot_names);\n-\tserializer.WriteProperty(203, \"pivots\", pivots);\n-\tserializer.WriteProperty(204, \"groups\", groups);\n-\tserializer.WriteProperty(205, \"column_name_alias\", column_name_alias);\n-\tserializer.WriteProperty(206, \"include_nulls\", include_nulls);\n+\tserializer.WritePropertyWithDefault<unique_ptr<TableRef>>(200, \"source\", source);\n+\tserializer.WritePropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(201, \"aggregates\", aggregates);\n+\tserializer.WritePropertyWithDefault<vector<string>>(202, \"unpivot_names\", unpivot_names);\n+\tserializer.WritePropertyWithDefault<vector<PivotColumn>>(203, \"pivots\", pivots);\n+\tserializer.WritePropertyWithDefault<vector<string>>(204, \"groups\", groups);\n+\tserializer.WritePropertyWithDefault<vector<string>>(205, \"column_name_alias\", column_name_alias);\n+\tserializer.WritePropertyWithDefault<bool>(206, \"include_nulls\", include_nulls);\n }\n \n unique_ptr<TableRef> PivotRef::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<PivotRef>(new PivotRef());\n-\tdeserializer.ReadProperty(200, \"source\", result->source);\n-\tdeserializer.ReadProperty(201, \"aggregates\", result->aggregates);\n-\tdeserializer.ReadProperty(202, \"unpivot_names\", result->unpivot_names);\n-\tdeserializer.ReadProperty(203, \"pivots\", result->pivots);\n-\tdeserializer.ReadProperty(204, \"groups\", result->groups);\n-\tdeserializer.ReadProperty(205, \"column_name_alias\", result->column_name_alias);\n-\tdeserializer.ReadProperty(206, \"include_nulls\", result->include_nulls);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<TableRef>>(200, \"source\", result->source);\n+\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<ParsedExpression>>>(201, \"aggregates\", result->aggregates);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(202, \"unpivot_names\", result->unpivot_names);\n+\tdeserializer.ReadPropertyWithDefault<vector<PivotColumn>>(203, \"pivots\", result->pivots);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(204, \"groups\", result->groups);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(205, \"column_name_alias\", result->column_name_alias);\n+\tdeserializer.ReadPropertyWithDefault<bool>(206, \"include_nulls\", result->include_nulls);\n \treturn std::move(result);\n }\n \n void SubqueryRef::Serialize(Serializer &serializer) const {\n \tTableRef::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"subquery\", subquery);\n-\tserializer.WriteProperty(201, \"column_name_alias\", column_name_alias);\n+\tserializer.WritePropertyWithDefault<unique_ptr<SelectStatement>>(200, \"subquery\", subquery);\n+\tserializer.WritePropertyWithDefault<vector<string>>(201, \"column_name_alias\", column_name_alias);\n }\n \n unique_ptr<TableRef> SubqueryRef::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<SubqueryRef>(new SubqueryRef());\n-\tdeserializer.ReadProperty(200, \"subquery\", result->subquery);\n-\tdeserializer.ReadProperty(201, \"column_name_alias\", result->column_name_alias);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<SelectStatement>>(200, \"subquery\", result->subquery);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(201, \"column_name_alias\", result->column_name_alias);\n \treturn std::move(result);\n }\n \n void TableFunctionRef::Serialize(Serializer &serializer) const {\n \tTableRef::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"function\", function);\n-\tserializer.WriteProperty(201, \"column_name_alias\", column_name_alias);\n+\tserializer.WritePropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"function\", function);\n+\tserializer.WritePropertyWithDefault<vector<string>>(201, \"column_name_alias\", column_name_alias);\n }\n \n unique_ptr<TableRef> TableFunctionRef::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::unique_ptr<TableFunctionRef>(new TableFunctionRef());\n-\tdeserializer.ReadProperty(200, \"function\", result->function);\n-\tdeserializer.ReadProperty(201, \"column_name_alias\", result->column_name_alias);\n+\tdeserializer.ReadPropertyWithDefault<unique_ptr<ParsedExpression>>(200, \"function\", result->function);\n+\tdeserializer.ReadPropertyWithDefault<vector<string>>(201, \"column_name_alias\", result->column_name_alias);\n \treturn std::move(result);\n }\n \ndiff --git a/src/storage/serialization/serialize_types.cpp b/src/storage/serialization/serialize_types.cpp\nindex 3356764b6c63..13b5b078778d 100644\n--- a/src/storage/serialization/serialize_types.cpp\n+++ b/src/storage/serialization/serialize_types.cpp\n@@ -10,13 +10,13 @@\n namespace duckdb {\n \n void ExtraTypeInfo::Serialize(Serializer &serializer) const {\n-\tserializer.WriteProperty(100, \"type\", type);\n-\tserializer.WriteProperty(101, \"alias\", alias);\n+\tserializer.WriteProperty<ExtraTypeInfoType>(100, \"type\", type);\n+\tserializer.WritePropertyWithDefault<string>(101, \"alias\", alias);\n }\n \n shared_ptr<ExtraTypeInfo> ExtraTypeInfo::Deserialize(Deserializer &deserializer) {\n \tauto type = deserializer.ReadProperty<ExtraTypeInfoType>(100, \"type\");\n-\tauto alias = deserializer.ReadProperty<string>(101, \"alias\");\n+\tauto alias = deserializer.ReadPropertyWithDefault<string>(101, \"alias\");\n \tshared_ptr<ExtraTypeInfo> result;\n \tswitch (type) {\n \tcase ExtraTypeInfoType::AGGREGATE_STATE_TYPE_INFO:\n@@ -54,73 +54,73 @@ shared_ptr<ExtraTypeInfo> ExtraTypeInfo::Deserialize(Deserializer &deserializer)\n \n void AggregateStateTypeInfo::Serialize(Serializer &serializer) const {\n \tExtraTypeInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"function_name\", state_type.function_name);\n-\tserializer.WriteProperty(201, \"return_type\", state_type.return_type);\n-\tserializer.WriteProperty(202, \"bound_argument_types\", state_type.bound_argument_types);\n+\tserializer.WritePropertyWithDefault<string>(200, \"function_name\", state_type.function_name);\n+\tserializer.WriteProperty<LogicalType>(201, \"return_type\", state_type.return_type);\n+\tserializer.WritePropertyWithDefault<vector<LogicalType>>(202, \"bound_argument_types\", state_type.bound_argument_types);\n }\n \n shared_ptr<ExtraTypeInfo> AggregateStateTypeInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::shared_ptr<AggregateStateTypeInfo>(new AggregateStateTypeInfo());\n-\tdeserializer.ReadProperty(200, \"function_name\", result->state_type.function_name);\n-\tdeserializer.ReadProperty(201, \"return_type\", result->state_type.return_type);\n-\tdeserializer.ReadProperty(202, \"bound_argument_types\", result->state_type.bound_argument_types);\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"function_name\", result->state_type.function_name);\n+\tdeserializer.ReadProperty<LogicalType>(201, \"return_type\", result->state_type.return_type);\n+\tdeserializer.ReadPropertyWithDefault<vector<LogicalType>>(202, \"bound_argument_types\", result->state_type.bound_argument_types);\n \treturn std::move(result);\n }\n \n void DecimalTypeInfo::Serialize(Serializer &serializer) const {\n \tExtraTypeInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"width\", width);\n-\tserializer.WriteProperty(201, \"scale\", scale);\n+\tserializer.WritePropertyWithDefault<uint8_t>(200, \"width\", width);\n+\tserializer.WritePropertyWithDefault<uint8_t>(201, \"scale\", scale);\n }\n \n shared_ptr<ExtraTypeInfo> DecimalTypeInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::shared_ptr<DecimalTypeInfo>(new DecimalTypeInfo());\n-\tdeserializer.ReadProperty(200, \"width\", result->width);\n-\tdeserializer.ReadProperty(201, \"scale\", result->scale);\n+\tdeserializer.ReadPropertyWithDefault<uint8_t>(200, \"width\", result->width);\n+\tdeserializer.ReadPropertyWithDefault<uint8_t>(201, \"scale\", result->scale);\n \treturn std::move(result);\n }\n \n void ListTypeInfo::Serialize(Serializer &serializer) const {\n \tExtraTypeInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"child_type\", child_type);\n+\tserializer.WriteProperty<LogicalType>(200, \"child_type\", child_type);\n }\n \n shared_ptr<ExtraTypeInfo> ListTypeInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::shared_ptr<ListTypeInfo>(new ListTypeInfo());\n-\tdeserializer.ReadProperty(200, \"child_type\", result->child_type);\n+\tdeserializer.ReadProperty<LogicalType>(200, \"child_type\", result->child_type);\n \treturn std::move(result);\n }\n \n void StringTypeInfo::Serialize(Serializer &serializer) const {\n \tExtraTypeInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"collation\", collation);\n+\tserializer.WritePropertyWithDefault<string>(200, \"collation\", collation);\n }\n \n shared_ptr<ExtraTypeInfo> StringTypeInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::shared_ptr<StringTypeInfo>(new StringTypeInfo());\n-\tdeserializer.ReadProperty(200, \"collation\", result->collation);\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"collation\", result->collation);\n \treturn std::move(result);\n }\n \n void StructTypeInfo::Serialize(Serializer &serializer) const {\n \tExtraTypeInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"child_types\", child_types);\n+\tserializer.WritePropertyWithDefault<child_list_t<LogicalType>>(200, \"child_types\", child_types);\n }\n \n shared_ptr<ExtraTypeInfo> StructTypeInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::shared_ptr<StructTypeInfo>(new StructTypeInfo());\n-\tdeserializer.ReadProperty(200, \"child_types\", result->child_types);\n+\tdeserializer.ReadPropertyWithDefault<child_list_t<LogicalType>>(200, \"child_types\", result->child_types);\n \treturn std::move(result);\n }\n \n void UserTypeInfo::Serialize(Serializer &serializer) const {\n \tExtraTypeInfo::Serialize(serializer);\n-\tserializer.WriteProperty(200, \"user_type_name\", user_type_name);\n+\tserializer.WritePropertyWithDefault<string>(200, \"user_type_name\", user_type_name);\n }\n \n shared_ptr<ExtraTypeInfo> UserTypeInfo::Deserialize(Deserializer &deserializer) {\n \tauto result = duckdb::shared_ptr<UserTypeInfo>(new UserTypeInfo());\n-\tdeserializer.ReadProperty(200, \"user_type_name\", result->user_type_name);\n+\tdeserializer.ReadPropertyWithDefault<string>(200, \"user_type_name\", result->user_type_name);\n \treturn std::move(result);\n }\n \ndiff --git a/src/storage/storage_info.cpp b/src/storage/storage_info.cpp\nindex 3aa553205cc5..e3f0fffc5956 100644\n--- a/src/storage/storage_info.cpp\n+++ b/src/storage/storage_info.cpp\n@@ -2,7 +2,7 @@\n \n namespace duckdb {\n \n-const uint64_t VERSION_NUMBER = 62;\n+const uint64_t VERSION_NUMBER = 64;\n \n struct StorageVersionInfo {\n \tconst char *version_name;\n",
  "test_patch": "diff --git a/test/serialize/serialization_test.cpp b/test/serialize/serialization_test.cpp\nindex fbf2d767e3a9..5640a12afab2 100644\n--- a/test/serialize/serialization_test.cpp\n+++ b/test/serialize/serialization_test.cpp\n@@ -78,4 +78,177 @@ TEST_CASE(\"Test default values\", \"[serialization]\") {\n \tREQUIRE(pos1 > pos2);\n }\n \n+//------------------------------------------------------\n+// Test deleted properties\n+//------------------------------------------------------\n+\n+struct Complex {\n+\tint c1;\n+\tstring c2;\n+\tComplex(int c1, string c2) : c1(c1), c2(c2) {\n+\t}\n+\tComplex() : c1(0), c2(\"\") {\n+\t}\n+\n+\tvoid Serialize(Serializer &serializer) const {\n+\t\tserializer.WriteProperty<int>(1, \"c1\", c1);\n+\t\tserializer.WriteProperty<string>(2, \"c2\", c2);\n+\t}\n+\n+\tstatic unique_ptr<Complex> Deserialize(Deserializer &deserializer) {\n+\t\tauto result = make_uniq<Complex>();\n+\t\tdeserializer.ReadProperty<int>(1, \"c1\", result->c1);\n+\t\tdeserializer.ReadProperty<string>(2, \"c2\", result->c2);\n+\t\treturn result;\n+\t}\n+};\n+\n+struct FooV1 {\n+\tint p1;\n+\tvector<unique_ptr<Complex>> p2;\n+\tint p3;\n+\tunique_ptr<Complex> p4;\n+\n+\tvoid Serialize(Serializer &serializer) const {\n+\t\tserializer.WriteProperty<int>(1, \"p1\", p1);\n+\t\tserializer.WritePropertyWithDefault<vector<unique_ptr<Complex>>>(2, \"p2\", p2);\n+\t\tserializer.WriteProperty<int>(3, \"p3\", p3);\n+\t\tserializer.WriteProperty<unique_ptr<Complex>>(4, \"p4\", p4);\n+\t}\n+\n+\tstatic unique_ptr<FooV1> Deserialize(Deserializer &deserializer) {\n+\t\tauto result = make_uniq<FooV1>();\n+\t\tdeserializer.ReadProperty<int>(1, \"p1\", result->p1);\n+\t\tdeserializer.ReadPropertyWithDefault<vector<unique_ptr<Complex>>>(2, \"p2\", result->p2);\n+\t\tdeserializer.ReadProperty<int>(3, \"p3\", result->p3);\n+\t\tdeserializer.ReadProperty<unique_ptr<Complex>>(4, \"p4\", result->p4);\n+\t\treturn result;\n+\t}\n+};\n+\n+struct FooV2 {\n+\tint p1;\n+\t/*vector<unique_ptr<Complex>> p2;*/ // In v2, this is deleted\n+\tint p3;\n+\tunique_ptr<Complex> p4;\n+\tunique_ptr<Complex> p5; // In v2, this is added\n+\n+\tvoid Serialize(Serializer &serializer) const {\n+\t\tserializer.WriteProperty<int>(1, \"p1\", p1);\n+\t\t// This field is deleted!\n+\t\t/* serializer.WriteDeletedProperty<vector<unique_ptr<Complex>>>(2, \"p2\"); */\n+\t\tserializer.WriteProperty<int>(3, \"p3\", p3);\n+\t\tserializer.WriteProperty<unique_ptr<Complex>>(4, \"p4\", p4);\n+\n+\t\t// Because this is a new field, we have to provide a default value\n+\t\t// to try to preserve backwards compatability (in best case)\n+\t\tserializer.WritePropertyWithDefault<unique_ptr<Complex>>(5, \"p5\", p5, (unique_ptr<Complex>)nullptr);\n+\t}\n+\n+\tstatic unique_ptr<FooV2> Deserialize(Deserializer &deserializer) {\n+\t\tauto result = make_uniq<FooV2>();\n+\t\tdeserializer.ReadProperty(1, \"p1\", result->p1);\n+\t\tdeserializer.ReadDeletedProperty<vector<unique_ptr<Complex>>>(2, \"p2\");\n+\t\tdeserializer.ReadProperty(3, \"p3\", result->p3);\n+\t\tdeserializer.ReadProperty(4, \"p4\", result->p4);\n+\t\tdeserializer.ReadPropertyWithDefault(5, \"p5\", result->p5, (unique_ptr<Complex>)nullptr);\n+\t\treturn result;\n+\t}\n+};\n+\n+TEST_CASE(\"Test deleted values\", \"[serialization]\") {\n+\tFooV1 v1_in = {1, {}, 6, make_uniq<Complex>(1, \"foo\")};\n+\tv1_in.p2.push_back(make_uniq<Complex>(2, \"3\"));\n+\tv1_in.p2.push_back(make_uniq<Complex>(4, \"5\"));\n+\n+\tFooV2 v2_in = {1, 3, make_uniq<Complex>(1, \"foo\"), nullptr};\n+\n+\tMemoryStream stream;\n+\t// First of, sanity check that foov1 <-> foov1 works\n+\tBinarySerializer::Serialize(v1_in, stream, false);\n+\t{\n+\t\tstream.Rewind();\n+\t\tauto v1_out_ptr = BinaryDeserializer::Deserialize<FooV1>(stream);\n+\t\tauto &v1_out = *v1_out_ptr.get();\n+\t\tREQUIRE(v1_in.p1 == v1_out.p1);\n+\t\tREQUIRE(v1_in.p2.size() == v1_out.p2.size());\n+\t\tREQUIRE(v1_in.p2[0]->c1 == v1_out.p2[0]->c1);\n+\t\tREQUIRE(v1_in.p2[0]->c2 == v1_out.p2[0]->c2);\n+\t\tREQUIRE(v1_in.p2[1]->c1 == v1_out.p2[1]->c1);\n+\t\tREQUIRE(v1_in.p2[1]->c2 == v1_out.p2[1]->c2);\n+\t\tREQUIRE(v1_in.p3 == v1_out.p3);\n+\t\tREQUIRE(v1_in.p4->c1 == v1_out.p4->c1);\n+\t\tREQUIRE(v1_in.p4->c2 == v1_out.p4->c2);\n+\t}\n+\n+\tstream.Rewind();\n+\n+\t// Also check that foov2 <-> foov2 works\n+\tBinarySerializer::Serialize(v2_in, stream, false);\n+\t{\n+\t\tstream.Rewind();\n+\t\tauto v2_out_ptr = BinaryDeserializer::Deserialize<FooV2>(stream);\n+\t\tauto &v2_out = *v2_out_ptr.get();\n+\t\tREQUIRE(v2_in.p1 == v2_out.p1);\n+\t\tREQUIRE(v2_in.p3 == v2_out.p3);\n+\t\tREQUIRE(v2_in.p4->c1 == v2_out.p4->c1);\n+\t\tREQUIRE(v2_in.p4->c2 == v2_out.p4->c2);\n+\t\tREQUIRE(v2_in.p5 == v2_out.p5);\n+\t}\n+\n+\t// Check that foov1 -> foov2 works (backwards compatible)\n+\tstream.Rewind();\n+\tBinarySerializer::Serialize(v1_in, stream, false);\n+\t{\n+\t\tstream.Rewind();\n+\t\tauto v2_out_ptr = BinaryDeserializer::Deserialize<FooV2>(stream);\n+\t\tauto &v2_out = *v2_out_ptr.get();\n+\t\tREQUIRE(v1_in.p1 == v2_out.p1);\n+\t\tREQUIRE(v1_in.p3 == v2_out.p3);\n+\t\tREQUIRE(v1_in.p4->c1 == v2_out.p4->c1);\n+\t\tREQUIRE(v1_in.p4->c2 == v2_out.p4->c2);\n+\t\tREQUIRE(v2_out.p5 == nullptr);\n+\t}\n+\n+\t// Check that foov2 -> foov1 works (forwards compatible)\n+\t// This should be ok, since the property we deleted was optional (had a default value)\n+\tstream.Rewind();\n+\tBinarySerializer::Serialize(v2_in, stream, false);\n+\t{\n+\t\tstream.Rewind();\n+\t\tauto v1_out_ptr = BinaryDeserializer::Deserialize<FooV1>(stream);\n+\t\tauto &v1_out = *v1_out_ptr.get();\n+\t\tREQUIRE(v2_in.p1 == v1_out.p1);\n+\t\tREQUIRE(v2_in.p3 == v1_out.p3);\n+\t\tREQUIRE(v2_in.p4->c1 == v1_out.p4->c1);\n+\t\tREQUIRE(v2_in.p4->c2 == v1_out.p4->c2);\n+\t\tREQUIRE(v1_out.p2.empty());\n+\t}\n+\n+\t// If we change the new value in foov2 to something thats not the default, we break forwards compatibility.\n+\t// But thats life. Tough shit.\n+\tstream.Rewind();\n+\tv2_in.p5 = make_uniq<Complex>(2, \"foo\");\n+\tBinarySerializer::Serialize(v2_in, stream, false);\n+\t{\n+\t\tstream.Rewind();\n+\t\tREQUIRE_THROWS(BinaryDeserializer::Deserialize<FooV1>(stream));\n+\t}\n+\n+\t// However, the new value should be read correctly!\n+\tstream.Rewind();\n+\tBinarySerializer::Serialize(v2_in, stream, false);\n+\t{\n+\t\tstream.Rewind();\n+\t\tauto v2_out_ptr = BinaryDeserializer::Deserialize<FooV2>(stream);\n+\t\tauto &v2_out = *v2_out_ptr.get();\n+\t\tREQUIRE(v2_in.p1 == v2_out.p1);\n+\t\tREQUIRE(v2_in.p3 == v2_out.p3);\n+\t\tREQUIRE(v2_in.p4->c1 == v2_out.p4->c1);\n+\t\tREQUIRE(v2_in.p4->c2 == v2_out.p4->c2);\n+\t\tREQUIRE(v2_out.p5->c1 == 2);\n+\t\tREQUIRE(v2_out.p5->c2 == \"foo\");\n+\t}\n+}\n+\n } // namespace duckdb\ndiff --git a/test/sql/json/test_serialize_sql.test b/test/sql/json/test_serialize_sql.test\nindex 81e7ec698fd6..a6ae61fe5191 100644\n--- a/test/sql/json/test_serialize_sql.test\n+++ b/test/sql/json/test_serialize_sql.test\n@@ -88,7 +88,7 @@ PRAGMA json_execute_serialized_sql(\n statement error\n SELECT * FROM json_execute_serialized_sql(json_serialize_sql('SELECT * FROM tbl2', skip_null := true, skip_empty := true));\n ----\n-Parser Error: Expected but did not find property 'modifiers' in json object: '{\"type\":\"SELECT_NODE\",\"select_list\":[{\"class\":\"STAR\",\"type\":\"STAR\",\"columns\":false}],\"from_table\":{\"type\":\"BASE_TABLE\",\"table_name\":\"tbl2\"},\"aggregate_handling\":\"STANDARD_HANDLING\"}'\n+Parser Error: Expected but did not find property 'cte_map' in json object: '{\"type\":\"SELECT_NODE\",\"select_list\":[{\"class\":\"STAR\",\"type\":\"STAR\",\"columns\":false}],\"from_table\":{\"type\":\"BASE_TABLE\",\"table_name\":\"tbl2\"},\"aggregate_handling\":\"STANDARD_HANDLING\"}'\n \n \n # Test execute json serialized sql with multiple nested type tags\ndiff --git a/test/sql/storage/overflow_strings/load_overflow_strings_slowly.test b/test/sql/storage/overflow_strings/load_overflow_strings_slowly.test\nindex 3525e2e82a53..2924638acf91 100644\n--- a/test/sql/storage/overflow_strings/load_overflow_strings_slowly.test\n+++ b/test/sql/storage/overflow_strings/load_overflow_strings_slowly.test\n@@ -26,7 +26,7 @@ SELECT COUNT(*) FROM pragma_storage_info('strings') WHERE contains(segment_info,\n 1\n \n query I\n-select total_blocks < 10 from pragma_database_size();\n+select total_blocks < 100 from pragma_database_size();\n ----\n true\n \ndiff --git a/test/sql/storage_version/storage_version.db b/test/sql/storage_version/storage_version.db\nindex 6869f03d40a7..c5ce147d0be3 100644\nBinary files a/test/sql/storage_version/storage_version.db and b/test/sql/storage_version/storage_version.db differ\n",
  "problem_statement": "Checkpointing is excessively slow, and gets slower with table size, when rows are large\n### What happens?\r\n\r\n`CHECKPOINT` sometimes takes time proportional to the size of the table, especially when individual rows are more than a few kilobytes. For example, if I repeatedly insert 1,000 rows of 10,000 bytes each and then `CHECKPOINT`:\r\n1. The first `CHECKPOINT` takes 3 seconds\r\n2. The second `CHECKPOINT` takes 6 seconds \r\n3. The third `CHECKPOINT` takes 9 seconds\r\n4. And so on\r\n\r\n### To Reproduce\r\n\r\n```python\r\nimport random\r\nimport duckdb\r\nimport pyarrow\r\nimport time\r\nfrom pathlib import Path\r\n\r\n\r\ndef main(*, n_txns, n_rows_per_txn, n_bytes_per_row):\r\n    db_file = Path(\"./ducktest.duckdb\")\r\n    if db_file.exists():\r\n        db_file.unlink()\r\n    db = duckdb.connect(str(db_file))\r\n    db.execute(\"CREATE TABLE test (test VARCHAR)\")\r\n    for i in range(n_txns):\r\n        data = pyarrow.table(\r\n            {\r\n                \"test\": pyarrow.array(\r\n                    [random.randbytes(n_bytes_per_row) for i in range(n_rows_per_txn)]\r\n                )\r\n            }\r\n        )\r\n        t0 = time.monotonic()\r\n        db.execute(\r\n            \"\"\"\r\n            INSERT INTO test\r\n            SELECT test\r\n            FROM data\r\n        \"\"\"\r\n        )\r\n        t1 = time.monotonic()\r\n        db.execute(\"CHECKPOINT\")\r\n        t2 = time.monotonic()\r\n        print(f\"execute={int((t1-t0)*1000)}ms checkpoint={int((t2-t1)*1000)}ms\")\r\n    db.close()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main(n_txns=100, n_rows_per_txn=1_000, n_bytes_per_row=10_000)\r\n```\r\n\r\nThis prints something like:\r\n```\r\nexecute=162ms checkpoint=2853ms\r\nexecute=232ms checkpoint=5995ms\r\nexecute=381ms checkpoint=9048ms\r\nexecute=228ms checkpoint=12221ms\r\n...\r\n```\r\n\r\n(Oddly, if I set `n_bytes_per_row=1000` and `n_rows_per_txn=10000`, then it runs significantly faster, even though the total data is the same size. In that scenario, the pattern is that checkpoint time gradually climbs from about 200ms to about 2000ms over the course of about 10 repetitions, then drops back down to 200ms, and the pattern repeats.)\r\n\r\n### OS:\r\n\r\nmacOS Ventura 13.4\r\n\r\n### DuckDB Version:\r\n\r\nduckdb-0.8.1.dev111\r\n\r\n### DuckDB Client:\r\n\r\nPython\r\n\r\n### Full Name:\r\n\r\nTimothy Maxwell\r\n\r\n### Affiliation:\r\n\r\nAnthropic\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\n",
  "hints_text": "fwiw: reproduced, but if you change it to create a new table for each iteration, the checkpoint time is constant. So, it seems more related to the size of the table than the size of the db: \r\n\r\nI changed only the execute call: \r\n```\r\ndb.execute(\r\n            f\"\"\"\r\n            create table test{i} as\r\n            SELECT test::varchar\r\n            FROM data\r\n        \"\"\"\r\n        )\r\n```\nAh, yes, whoops! I said \"database size\" but meant \"table size\". Edited the issue description.\nI modified the test to add a little more information: table size and row count, and realized all we're looking at is just that the checkpoint time increases up until STANDARD_ROW_GROUPS_SIZE (122880), which is as expected since the unit of checkpointing is the STANDARD_ROW_GROUPS_SIZE [22-duckdb.pdf](https://15721.courses.cs.cmu.edu/spring2023/slides/22-duckdb.pdf).\r\n\r\n(one of the devs/experts can probably confirm this, this is just my non-expert conclusion)\r\n\r\nedit: additional notes\r\n- 1x10KB (1 column filled with 10KB varchar's) was intolerably slow .... +30 seconds for the first iteration (after 10k rows). This presumably would take 6 minutes to checkpoint a single ~1.6GB column\r\n- 10x1KB was far better, presumably due to parallelism: +3 seconds per iteration. Final iteration was 49 seconds for 1.8GB. \r\n- Checkpoint time scaled linearly\r\n\r\n#### 10000 rows per iteration @ 1KB per column, 10 columns\r\n![image](https://github.com/duckdb/duckdb/assets/104510378/9224849e-8557-4c58-9566-789127f96378)\r\n\r\n\r\n#### 10000 rows per iteration @ 10 bytes per column, 1 column\r\n![image](https://github.com/duckdb/duckdb/assets/104510378/cccfadd9-16c3-4661-8a96-3a89ed42f456)\r\n\r\n#### 10000 rows per iteration @ 1000 bytes per column, 1 column\r\n![image](https://github.com/duckdb/duckdb/assets/104510378/37e54472-92cc-45d0-9b39-f9efc73fd468)\r\n\r\n#### Modified Test\r\n```\r\nimport random\r\nimport duckdb\r\nimport pyarrow\r\nimport time\r\nfrom pathlib import Path\r\nimport csv \r\n\r\nresults = []\r\n\r\ndef main(*, n_txns, n_rows_per_txn, n_bytes_per_row):\r\n    db_file = Path(\"./ducktest.duckdb\")\r\n    if db_file.exists():\r\n        db_file.unlink()\r\n    with duckdb.connect(str(db_file)) as db:\r\n        db.execute(\"CREATE TABLE test (test VARCHAR)\")\r\n        for i in range(n_txns):\r\n            data = pyarrow.table(\r\n                {\r\n                    \"test\": pyarrow.array(\r\n                        [random.randbytes(n_bytes_per_row) for i in range(n_rows_per_txn)]\r\n                    )\r\n                }\r\n            )\r\n            t0 = time.monotonic()\r\n            db.execute(\r\n                \"\"\"\r\n                INSERT INTO test\r\n                SELECT test\r\n                FROM data\r\n            \"\"\"\r\n            )\r\n            t1 = time.monotonic()\r\n            db.execute(\"CHECKPOINT\")\r\n            t2 = time.monotonic()\r\n            space = db.execute(\"SELECT format_bytes(COUNT(DISTINCT block_id) * 256000) AS storage_space, count(distinct block_id) FROM pragma_storage_info('test')\").df().iloc[0].values\r\n            #print(db.execute(\"pragma storage_info('test')\").df())\r\n            #print(space)\r\n            space = space[0]\r\n            numblocks = space[1]\r\n            numrows = db.execute(\"SELECT count(*) from test\").df().iloc[0].values[0]\r\n\r\n\r\n            newresult=(f\"{n_rows_per_txn} rows x {n_bytes_per_row} bytes\", int((t1-t0)*1000), int((t2-t1)*1000),space,numrows, numblocks)\r\n            results.append(newresult)\r\n            print(newresult)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main(n_txns=100, n_rows_per_txn=10000, n_bytes_per_row=1_000)\r\n\r\n\r\n    with open(\"results.csv\", 'a', newline='') as csvfile:\r\n        writer = csv.writer(csvfile)\r\n\r\n        writer.writerow((\"Test\", \"Execution\", \"CheckpointTime\", \"space\", \"numrows\", \"numblocks\"))\r\n        for row in results:\r\n            writer.writerow(row)\r\n```\nThanks for the report! As indicated by @paultiq this is somewhat expected as the row group will get re-checkpointed (as changes are made to it). However, the checkpoint time here is excessive. I think this is likely due to the fact that we use `gzip` to compress large strings individually which is very slow. I have a plan to switch this to `zstd` and to combine large strings together to speed this up significantly, which I will hopefully get to in the coming weeks.\nOh, this is interesting. I *thought* that because this data was random, and because `pragma storage_info` reports the column as uncompressed, that compression was not a factor. I had also checked with `pragma force_compression='uncompressed'` but misunderstood the result (not realizing there was another phase of compression at checkpoint time)\r\n\r\nGiven the checkpoint compression of large strings occurs only on VARCHARs, I ran two additional tests using 10k rows x 1 column x 10KB test. \r\n- Using BLOB instead of VARCHAR gave a 10x speedup: 30s => 3s\r\n- Similarly, using compressible text (via Faker) also gave about the same speedup: 30s => 3s\r\n- Therefore: if OP (@tmaxwell-anthropic) was truly writing incompressible data, perhaps switching to a BLOB... or if not incompressible, perhaps retest using a more realistic data pattern? \r\n\r\n@Mytherin Perhaps large string compression could be disabled for uncompressed columns, regardless of other optimizations? \nThe system still tries to compress the data in order to figure out how compressible the data is which still has a (in this cast large) cost. I think this can likely be reduced as well. I will investigate more.\nThis issue is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.\nThis is still an issue",
  "created_at": "2023-09-25T21:11:11Z"
}