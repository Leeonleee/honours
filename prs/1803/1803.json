{
  "repo": "duckdb/duckdb",
  "pull_number": 1803,
  "instance_id": "duckdb__duckdb-1803",
  "issue_numbers": [
    "1548"
  ],
  "base_commit": "ca29583f012fe513179a03872d612f72525d08ea",
  "patch": "diff --git a/tools/pythonpkg/src/pyresult.cpp b/tools/pythonpkg/src/pyresult.cpp\nindex 28d365bda7e4..50b7b955156e 100644\n--- a/tools/pythonpkg/src/pyresult.cpp\n+++ b/tools/pythonpkg/src/pyresult.cpp\n@@ -32,6 +32,102 @@ static SRC FetchScalar(Vector &src_vec, idx_t offset) {\n \treturn src_ptr[offset];\n }\n \n+py::object GetValueToPython(Value &val, const LogicalType &type) {\n+\tif (val.is_null) {\n+\t\treturn py::none();\n+\t}\n+\tswitch (type.id()) {\n+\tcase LogicalTypeId::BOOLEAN:\n+\t\treturn py::cast(val.GetValue<bool>());\n+\tcase LogicalTypeId::TINYINT:\n+\t\treturn py::cast(val.GetValue<int8_t>());\n+\tcase LogicalTypeId::SMALLINT:\n+\t\treturn py::cast(val.GetValue<int16_t>());\n+\tcase LogicalTypeId::INTEGER:\n+\t\treturn py::cast(val.GetValue<int32_t>());\n+\tcase LogicalTypeId::BIGINT:\n+\t\treturn py::cast(val.GetValue<int64_t>());\n+\tcase LogicalTypeId::UTINYINT:\n+\t\treturn py::cast(val.GetValue<uint8_t>());\n+\tcase LogicalTypeId::USMALLINT:\n+\t\treturn py::cast(val.GetValue<uint16_t>());\n+\tcase LogicalTypeId::UINTEGER:\n+\t\treturn py::cast(val.GetValue<uint32_t>());\n+\tcase LogicalTypeId::UBIGINT:\n+\t\treturn py::cast(val.GetValue<uint64_t>());\n+\tcase LogicalTypeId::HUGEINT:\n+\t\treturn py::cast<py::object>(PyLong_FromString((char *)val.GetValue<string>().c_str(), nullptr, 10));\n+\n+\tcase LogicalTypeId::FLOAT:\n+\t\treturn py::cast(val.GetValue<float>());\n+\tcase LogicalTypeId::DOUBLE:\n+\t\treturn py::cast(val.GetValue<double>());\n+\tcase LogicalTypeId::DECIMAL: {\n+\t\tpy::object decimal_py = py::module_::import(\"decimal\").attr(\"Decimal\");\n+\t\treturn decimal_py(val.ToString());\n+\t}\n+\tcase LogicalTypeId::VARCHAR:\n+\t\treturn py::cast(val.GetValue<string>());\n+\tcase LogicalTypeId::BLOB:\n+\t\treturn py::bytes(val.GetValueUnsafe<string>());\n+\tcase LogicalTypeId::TIMESTAMP:\n+\tcase LogicalTypeId::TIMESTAMP_MS:\n+\tcase LogicalTypeId::TIMESTAMP_NS:\n+\tcase LogicalTypeId::TIMESTAMP_SEC: {\n+\t\tD_ASSERT(type.InternalType() == PhysicalType::INT64);\n+\t\tauto timestamp = val.GetValueUnsafe<timestamp_t>();\n+\t\tif (type.id() == LogicalTypeId::TIMESTAMP_MS) {\n+\t\t\ttimestamp = Timestamp::FromEpochMs(timestamp.value);\n+\t\t} else if (type.id() == LogicalTypeId::TIMESTAMP_NS) {\n+\t\t\ttimestamp = Timestamp::FromEpochNanoSeconds(timestamp.value);\n+\t\t} else if (type.id() == LogicalTypeId::TIMESTAMP_SEC) {\n+\t\t\ttimestamp = Timestamp::FromEpochSeconds(timestamp.value);\n+\t\t}\n+\t\tint32_t year, month, day, hour, min, sec, micros;\n+\t\tdate_t date;\n+\t\tdtime_t time;\n+\t\tTimestamp::Convert(timestamp, date, time);\n+\t\tDate::Convert(date, year, month, day);\n+\t\tTime::Convert(time, hour, min, sec, micros);\n+\t\treturn py::cast<py::object>(PyDateTime_FromDateAndTime(year, month, day, hour, min, sec, micros));\n+\t}\n+\tcase LogicalTypeId::TIME: {\n+\t\tD_ASSERT(type.InternalType() == PhysicalType::INT64);\n+\n+\t\tint32_t hour, min, sec, microsec;\n+\t\tauto time = val.GetValueUnsafe<dtime_t>();\n+\t\tduckdb::Time::Convert(time, hour, min, sec, microsec);\n+\t\treturn py::cast<py::object>(PyTime_FromTime(hour, min, sec, microsec));\n+\t}\n+\tcase LogicalTypeId::DATE: {\n+\t\tD_ASSERT(type.InternalType() == PhysicalType::INT32);\n+\n+\t\tauto date = val.GetValueUnsafe<date_t>();\n+\t\tint32_t year, month, day;\n+\t\tduckdb::Date::Convert(date, year, month, day);\n+\t\treturn py::cast<py::object>(PyDate_FromDate(year, month, day));\n+\t}\n+\tcase LogicalTypeId::LIST: {\n+\t\tpy::list list;\n+\t\tfor (auto list_elem : val.list_value) {\n+\t\t\tlist.append(GetValueToPython(list_elem, type.child_types()[0].second));\n+\t\t}\n+\t\treturn std::move(list);\n+\t}\n+\tcase LogicalTypeId::MAP:\n+\tcase LogicalTypeId::STRUCT: {\n+\t\tpy::dict py_struct;\n+\t\tfor (idx_t i = 0; i < val.struct_value.size(); i++) {\n+\t\t\tpy_struct[type.child_types()[i].first.c_str()] =\n+\t\t\t    GetValueToPython(val.struct_value[i].second, type.child_types()[i].second);\n+\t\t}\n+\t\treturn std::move(py_struct);\n+\t}\n+\tdefault:\n+\t\tthrow std::runtime_error(\"unsupported type: \" + type.ToString());\n+\t}\n+}\n+\n py::object DuckDBPyResult::Fetchone() {\n \tif (!result) {\n \t\tthrow std::runtime_error(\"result closed\");\n@@ -52,99 +148,7 @@ py::object DuckDBPyResult::Fetchone() {\n \t\t\tcontinue;\n \t\t}\n \t\tauto val = current_chunk->data[col_idx].GetValue(chunk_offset);\n-\t\tswitch (result->types[col_idx].id()) {\n-\t\tcase LogicalTypeId::BOOLEAN:\n-\t\t\tres[col_idx] = val.GetValue<bool>();\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::TINYINT:\n-\t\t\tres[col_idx] = val.GetValue<int8_t>();\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::SMALLINT:\n-\t\t\tres[col_idx] = val.GetValue<int16_t>();\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::INTEGER:\n-\t\t\tres[col_idx] = val.GetValue<int32_t>();\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::BIGINT:\n-\t\t\tres[col_idx] = val.GetValue<int64_t>();\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::UTINYINT:\n-\t\t\tres[col_idx] = val.GetValue<uint8_t>();\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::USMALLINT:\n-\t\t\tres[col_idx] = val.GetValue<uint16_t>();\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::UINTEGER:\n-\t\t\tres[col_idx] = val.GetValue<uint32_t>();\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::UBIGINT:\n-\t\t\tres[col_idx] = val.GetValue<uint64_t>();\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::HUGEINT: {\n-\t\t\tauto hugeint_str = val.GetValue<string>();\n-\t\t\tres[col_idx] = PyLong_FromString((char *)hugeint_str.c_str(), nullptr, 10);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase LogicalTypeId::FLOAT:\n-\t\t\tres[col_idx] = val.GetValue<float>();\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::DOUBLE:\n-\t\t\tres[col_idx] = val.GetValue<double>();\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::DECIMAL: {\n-\t\t\tpy::object decimal_py = py::module_::import(\"decimal\").attr(\"Decimal\");\n-\t\t\tres[col_idx] = decimal_py(val.ToString());\n-\t\t} break;\n-\t\tcase LogicalTypeId::VARCHAR:\n-\t\t\tres[col_idx] = val.GetValue<string>();\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::BLOB:\n-\t\t\tres[col_idx] = py::bytes(val.GetValueUnsafe<string>());\n-\t\t\tbreak;\n-\t\tcase LogicalTypeId::TIMESTAMP:\n-\t\tcase LogicalTypeId::TIMESTAMP_MS:\n-\t\tcase LogicalTypeId::TIMESTAMP_NS:\n-\t\tcase LogicalTypeId::TIMESTAMP_SEC: {\n-\t\t\tD_ASSERT(result->types[col_idx].InternalType() == PhysicalType::INT64);\n-\t\t\tauto timestamp = val.GetValueUnsafe<timestamp_t>();\n-\t\t\tif (result->types[col_idx].id() == LogicalTypeId::TIMESTAMP_MS) {\n-\t\t\t\ttimestamp = Timestamp::FromEpochMs(timestamp.value);\n-\t\t\t} else if (result->types[col_idx].id() == LogicalTypeId::TIMESTAMP_NS) {\n-\t\t\t\ttimestamp = Timestamp::FromEpochNanoSeconds(timestamp.value);\n-\t\t\t} else if (result->types[col_idx].id() == LogicalTypeId::TIMESTAMP_SEC) {\n-\t\t\t\ttimestamp = Timestamp::FromEpochSeconds(timestamp.value);\n-\t\t\t}\n-\t\t\tint32_t year, month, day, hour, min, sec, micros;\n-\t\t\tdate_t date;\n-\t\t\tdtime_t time;\n-\t\t\tTimestamp::Convert(timestamp, date, time);\n-\t\t\tDate::Convert(date, year, month, day);\n-\t\t\tTime::Convert(time, hour, min, sec, micros);\n-\t\t\tres[col_idx] = PyDateTime_FromDateAndTime(year, month, day, hour, min, sec, micros);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase LogicalTypeId::TIME: {\n-\t\t\tD_ASSERT(result->types[col_idx].InternalType() == PhysicalType::INT64);\n-\n-\t\t\tint32_t hour, min, sec, microsec;\n-\t\t\tauto time = val.GetValueUnsafe<dtime_t>();\n-\t\t\tduckdb::Time::Convert(time, hour, min, sec, microsec);\n-\t\t\tres[col_idx] = PyTime_FromTime(hour, min, sec, microsec);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase LogicalTypeId::DATE: {\n-\t\t\tD_ASSERT(result->types[col_idx].InternalType() == PhysicalType::INT32);\n-\n-\t\t\tauto date = val.GetValueUnsafe<date_t>();\n-\t\t\tint32_t year, month, day;\n-\t\t\tduckdb::Date::Convert(date, year, month, day);\n-\t\t\tres[col_idx] = PyDate_FromDate(year, month, day);\n-\t\t\tbreak;\n-\t\t}\n-\n-\t\tdefault:\n-\t\t\tthrow std::runtime_error(\"unsupported type: \" + result->types[col_idx].ToString());\n-\t\t}\n+\t\tres[col_idx] = GetValueToPython(val, result->types[col_idx]);\n \t}\n \tchunk_offset++;\n \treturn move(res);\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/types/test_nested.py b/tools/pythonpkg/tests/types/test_nested.py\nnew file mode 100644\nindex 000000000000..48de3542ba6b\n--- /dev/null\n+++ b/tools/pythonpkg/tests/types/test_nested.py\n@@ -0,0 +1,53 @@\n+import duckdb\n+\n+\n+class TestNested(object):\n+\n+    def test_lists(self, duckdb_cursor):\n+        duckdb_conn = duckdb.connect()\n+        result = duckdb_conn.execute(\"SELECT LIST_VALUE(1, 2, 3, 4) \").fetchall()\n+        assert result == [([1, 2, 3, 4],)]\n+\n+        result = duckdb_conn.execute(\"SELECT LIST_VALUE() \").fetchall()\n+        assert result == [([],)]\n+\n+        result = duckdb_conn.execute(\"SELECT LIST_VALUE(1, 2, 3, NULL) \").fetchall()\n+        assert result == [([1, 2, 3, None],)]\n+\n+\n+    def test_nested_lists(self, duckdb_cursor):\n+        duckdb_conn = duckdb.connect()\n+        result = duckdb_conn.execute(\"SELECT LIST_VALUE(LIST_VALUE(1, 2, 3, 4), LIST_VALUE(1, 2, 3, 4)) \").fetchall()\n+        assert result == [([[1, 2, 3, 4], [1, 2, 3, 4]],)]\n+\n+        result = duckdb_conn.execute(\"SELECT LIST_VALUE(LIST_VALUE(1, 2, 3, 4), LIST_VALUE(1, 2, 3, NULL)) \").fetchall()\n+        assert result == [([[1, 2, 3, 4], [1, 2, 3, None]],)]\n+\n+    def test_struct(self, duckdb_cursor):\n+        duckdb_conn = duckdb.connect()\n+        result = duckdb_conn.execute(\"SELECT STRUCT_PACK(a := 42, b := 43)\").fetchall()\n+        assert result == [({'a': 42, 'b': 43},)]\n+\n+        result = duckdb_conn.execute(\"SELECT STRUCT_PACK(a := 42, b := NULL)\").fetchall()\n+        assert result == [({'a': 42, 'b': None},)]\n+       \n+\n+    def test_nested_struct(self, duckdb_cursor):\n+        duckdb_conn = duckdb.connect()\n+        result = duckdb_conn.execute(\"SELECT STRUCT_PACK(a := 42, b := LIST_VALUE(10, 9, 8, 7))\").fetchall()\n+        assert result == [({'a': 42, 'b': [10,9,8,7]},)]\n+\n+        result = duckdb_conn.execute(\"SELECT STRUCT_PACK(a := 42, b := LIST_VALUE(10, 9, 8, NULL))\").fetchall()\n+        assert result == [({'a': 42, 'b': [10,9,8,None]},)]\n+\n+    def test_map(self, duckdb_cursor):\n+        duckdb_conn = duckdb.connect()\n+        result = duckdb_conn.execute(\"select MAP(LIST_VALUE(1, 2, 3, 4),LIST_VALUE(10, 9, 8, 7))\").fetchall()\n+        assert result == [({'key': [1,2,3,4], 'value': [10,9,8,7]},)]\n+\n+        result = duckdb_conn.execute(\"select MAP(LIST_VALUE(1, 2, 3, 4),LIST_VALUE(10, 9, 8, NULL))\").fetchall()\n+        assert result == [({'key': [1,2,3,4], 'value': [10,9,8,None]},)]\n+\n+        result = duckdb_conn.execute(\"SELECT MAP() \").fetchall()\n+        assert result == [({'key': [], 'value': []},)]\n+        \n\\ No newline at end of file\n",
  "problem_statement": "Histogram function returns error on Python API\nThe following code:\r\n```python\r\ndef histogram(con, table, column, bins):\r\n    sql_code = f\"\"\"\r\n        SELECT histogram({column}) FROM {table}\r\n    \"\"\"\r\n    con.execute(sql_code)\r\n    return con.fetchall()\r\n```\r\n\r\nReturns the following error:\r\n`RuntimeError: unsupported type: LIST<STRUCT<bucket: INTEGER, count: UBIGINT>>`\n",
  "hints_text": "Lists are not supported in the Python client right now. As a work-around you could convert the result to a string before moving it to Python land, e.g.:\r\n\r\n```sql\r\nSELECT histogram({column})::STRING FROM {table}\r\n```\r\n\nWe should probably work on being able to return lists in the client APIs at some point\nI will give it a shot, might be able to fix this at least for the Python API.\r\nPointers on where to begin would be appreciated, but not necessary if there is no time for that.\n@pdet perhaps you would be interested in working on this together with @Manerone , as you are working on the Python API and have also recently worked on the lists.\nI'm happy to help, @Manerone  I can show you the ropes if you want.\r\nI'm implementing a map type, although conceptually is just a struct of lists. \r\nThe histogram function is already using it [map-branch](https://github.com/pdet/duckdb/tree/map).\r\n\r\n\nI tried building DuckDB using the following command:\r\n`BUILD_PYTHON=1 BUILD_FTS=1 make debug`\r\nHowever when I call `import duckdb` on Python I get:\r\n```\r\nTraceback (most recent call last):\r\n  File \"/Users/matheusan/Workspace/duckdb/bug.py\", line 1, in <module>\r\n    import duckdb\r\nImportError: dlopen(/usr/local/lib/python3.9/site-packages/duckdb-0.2.6.dev548+g59de07a92-py3.9-macosx-11-x86_64.egg/duckdb.cpython-39-darwin.so, 2): Symbol not found: __ZN6duckdb16utf8proc_iterateEPKhlPi\r\n  Referenced from: /usr/local/lib/python3.9/site-packages/duckdb-0.2.6.dev548+g59de07a92-py3.9-macosx-11-x86_64.egg/duckdb.cpython-39-darwin.so\r\n  Expected in: flat namespace\r\n in /usr/local/lib/python3.9/site-packages/duckdb-0.2.6.dev548+g59de07a92-py3.9-macosx-11-x86_64.egg/duckdb.cpython-39-darwin.so\r\n```\r\n\r\nI am still trying to find a solution, but maybe this happened before to someone.\r\nI also tried using virtualenv to isolate the package installation but the same thing happened.",
  "created_at": "2021-05-27T12:32:54Z"
}