{
  "repo": "duckdb/duckdb",
  "pull_number": 6110,
  "instance_id": "duckdb__duckdb-6110",
  "issue_numbers": [
    "6073"
  ],
  "base_commit": "01a87dafc6d04bbd2186c9788955b7a9729a4913",
  "patch": "diff --git a/tools/jdbc/src/jni/duckdb_java.cpp b/tools/jdbc/src/jni/duckdb_java.cpp\nindex dc071a541c2c..4e029a1b52ce 100644\n--- a/tools/jdbc/src/jni/duckdb_java.cpp\n+++ b/tools/jdbc/src/jni/duckdb_java.cpp\n@@ -445,6 +445,7 @@ JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1execute(JNI\n \tauto stmt_ref = (StatementHolder *)env->GetDirectBufferAddress(stmt_ref_buf);\n \tif (!stmt_ref) {\n \t\tenv->ThrowNew(J_SQLException, \"Invalid statement\");\n+\t\treturn nullptr;\n \t}\n \tauto res_ref = make_unique<ResultHolder>();\n \tvector<Value> duckdb_params;\n@@ -490,6 +491,18 @@ JNIEXPORT jobject JNICALL Java_org_duckdb_DuckDBNative_duckdb_1jdbc_1execute(JNI\n \t\t\t\tjint precision = env->CallIntMethod(param, J_Decimal_precision);\n \t\t\t\tjint scale = env->CallIntMethod(param, J_Decimal_scale);\n \n+\t\t\t\t// Java BigDecimal type can have scale that exceeds the precision\n+\t\t\t\t// Which our DECIMAL type does not support (assert(width >= scale))\n+\t\t\t\tif (scale > precision) {\n+\t\t\t\t\tprecision = scale;\n+\t\t\t\t}\n+\n+\t\t\t\t// DECIMAL scale is unsigned, so negative values are not supported\n+\t\t\t\tif (scale < 0) {\n+\t\t\t\t\tenv->ThrowNew(J_SQLException, \"Converting from a BigDecimal with negative scale is not supported\");\n+\t\t\t\t\treturn nullptr;\n+\t\t\t\t}\n+\n \t\t\t\tif (precision <= 18) { // normal sizes -> avoid string processing\n \t\t\t\t\tjobject no_point_dec = env->CallObjectMethod(param, J_Decimal_scaleByPowTen, scale);\n \t\t\t\t\tjlong result = env->CallLongMethod(no_point_dec, J_Decimal_longValue);\ndiff --git a/tools/jdbc/src/main/java/org/duckdb/DuckDBPreparedStatement.java b/tools/jdbc/src/main/java/org/duckdb/DuckDBPreparedStatement.java\nindex b7cac1f038de..84cdd7e5bc3b 100644\n--- a/tools/jdbc/src/main/java/org/duckdb/DuckDBPreparedStatement.java\n+++ b/tools/jdbc/src/main/java/org/duckdb/DuckDBPreparedStatement.java\n@@ -96,6 +96,9 @@ private void prepare(String sql) throws SQLException {\n \t\tmeta = null;\n \t\tparams = null;\n \n+\t\tif (select_result != null) {\n+\t\t\tselect_result.close();\n+\t\t}\n \t\tselect_result = null;\n \t\tupdate_result = 0;\n \n@@ -124,6 +127,9 @@ public boolean execute() throws SQLException {\n \t\t}\n \n \t\tByteBuffer result_ref = null;\n+\t\tif (select_result != null) {\n+\t\t\tselect_result.close();\n+\t\t}\n \t\tselect_result = null;\n \n \t\ttry {\n@@ -138,6 +144,7 @@ public boolean execute() throws SQLException {\n \t\t\t\tselect_result.close();\n \t\t\t}\n \t\t\telse if (result_ref != null) {\n+\t\t\t\tDuckDBNative.duckdb_jdbc_free_result(result_ref);\n \t\t\t\tresult_ref = null;\n \t\t\t}\n \t\t\tclose();\n",
  "test_patch": "diff --git a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\nindex e1ec0ac66aa6..ff6125f020a9 100644\n--- a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n+++ b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n@@ -1105,57 +1105,79 @@ public static void test_lots_of_timestamps() throws Exception {\n \tpublic static void test_lots_of_decimals() throws Exception {\n \t\tConnection conn = DriverManager.getConnection(\"jdbc:duckdb:\");\n \t\tStatement stmt = conn.createStatement();\n+\t\t// Create the table\n \t\tstmt.execute(\n-\t\t\t\t\"CREATE TABLE q (id DECIMAL(4,0), dec32 DECIMAL(9,4), dec64 DECIMAL(18,7), dec128 DECIMAL(38,10))\");\n+\t\t\t\"CREATE TABLE q (id\tDECIMAL(4,0),dec32 DECIMAL(9,4),dec64 DECIMAL(18,7),dec128 DECIMAL(38,10))\"\n+\t\t);\n \t\tstmt.close();\n \n+\t\t// Create the INSERT prepared statement we will use\n \t\tPreparedStatement ps1 = conn.prepareStatement(\"INSERT INTO q (id, dec32, dec64, dec128) VALUES (?, ?, ?, ?)\");\n-\t\tps1.setObject(1, new BigDecimal(\"1\"));\n \n+\t\t// Create the Java decimals we will be inserting\n+\t\tBigDecimal id_org = new BigDecimal(\"1\");\n \t\tBigDecimal dec32_org = new BigDecimal(\"99999.9999\");\n \t\tBigDecimal dec64_org = new BigDecimal(\"99999999999.9999999\");\n \t\tBigDecimal dec128_org = new BigDecimal(\"9999999999999999999999999999.9999999999\");\n \n+\t\t// Insert the initial values\n+\t\tps1.setObject(1, id_org);\n \t\tps1.setObject(2, dec32_org);\n \t\tps1.setObject(3, dec64_org);\n \t\tps1.setObject(4, dec128_org);\n-\t\tps1.execute();\n+\t\t// This does not have a result set\n+\t\tassertFalse(ps1.execute());\n \n+\t\t// Create the SELECT prepared statement we will use\n \t\tPreparedStatement ps2 = conn.prepareStatement(\"SELECT * FROM q WHERE id = ?\");\n \t\tBigDecimal multiplicant = new BigDecimal(\"0.987\");\n \n+\t\tBigDecimal dec32;\n+\t\tBigDecimal dec64;\n+\t\tBigDecimal dec128;\n+\n+\t\tResultSet select_result;\n+\n \t\tfor (int i = 2; i < 10000; i++) {\n \t\t\tps2.setObject(1, new BigDecimal(i - 1));\n-\t\t\tResultSet rs = ps2.executeQuery();\n-\t\t\tassertTrue(rs.next());\n \n-\t\t\tBigDecimal dec32 = rs.getObject(2, BigDecimal.class);\n-\t\t\tBigDecimal dec64 = rs.getObject(3, BigDecimal.class);\n-\t\t\tBigDecimal dec128 = rs.getObject(4, BigDecimal.class);\n+\t\t\t// Verify that both the 'getObject' and the 'getBigDecimal' methods return the same value\\\n+\n+\t\t\tselect_result = ps2.executeQuery();\n+\t\t\tassertTrue(select_result.next());\n+\t\t\tdec32 = select_result.getObject(2, BigDecimal.class);\n+\t\t\tdec64 = select_result.getObject(3, BigDecimal.class);\n+\t\t\tdec128 = select_result.getObject(4, BigDecimal.class);\n \t\t\tassertEquals(dec32_org, dec32);\n \t\t\tassertEquals(dec64_org, dec64);\n \t\t\tassertEquals(dec128_org, dec128);\n+\t\t\tselect_result.close();\n \n-\t\t\tdec32 = rs.getBigDecimal(2);\n-\t\t\tdec64 = rs.getBigDecimal(3);\n-\t\t\tdec128 = rs.getBigDecimal(4);\n+\t\t\tselect_result = ps2.executeQuery();\n+\t\t\tassertTrue(select_result.next());\n+\t\t\tdec32 = select_result.getBigDecimal(2);\n+\t\t\tdec64 = select_result.getBigDecimal(3);\n+\t\t\tdec128 = select_result.getBigDecimal(4);\n \t\t\tassertEquals(dec32_org, dec32);\n \t\t\tassertEquals(dec64_org, dec64);\n \t\t\tassertEquals(dec128_org, dec128);\n-\t\t\trs.close();\n+\t\t\tselect_result.close();\n+\n+\t\t\t// Apply the modification for the next iteration\n \n-\t\t\tdec32_org = dec32.multiply(multiplicant).setScale(4, java.math.RoundingMode.HALF_EVEN);\n-\t\t\tdec64_org = dec64.multiply(multiplicant).setScale(7, java.math.RoundingMode.HALF_EVEN);\n-\t\t\tdec128_org = dec128.multiply(multiplicant).setScale(10, java.math.RoundingMode.HALF_EVEN);\n+\t\t\tdec32_org = dec32_org.multiply(multiplicant).setScale(4, java.math.RoundingMode.HALF_EVEN);\n+\t\t\tdec64_org = dec64_org.multiply(multiplicant).setScale(7, java.math.RoundingMode.HALF_EVEN);\n+\t\t\tdec128_org = dec128_org.multiply(multiplicant).setScale(10, java.math.RoundingMode.HALF_EVEN);\n \n \t\t\tps1.clearParameters();\n \t\t\tps1.setObject(1, new BigDecimal(i));\n \t\t\tps1.setObject(2, dec32_org);\n \t\t\tps1.setObject(3, dec64_org);\n \t\t\tps1.setObject(4, dec128_org);\n-\t\t\tps1.execute();\n-\t\t}\n+\t\t\tassertFalse(ps1.execute());\n \n+\t\t\tps2.clearParameters();\n+\t\t}\n \t\tps1.close();\n \t\tps2.close();\n \t\tconn.close();\n",
  "problem_statement": "TestDuckDBJDBC::test_lots_of_decimals is broken\n### What happens?\n\n```\r\ntest_lots_of_decimals terminate called after throwing an instance of 'duckdb::InternalException'\r\n\r\n  what():  INTERNAL Error: Assertion triggered in file \"/home/anxing/Documents/duckdb/src/common/types.cpp\" on line 964: width >= scale\r\n\r\nAborted (core dumped)\r\n```\r\ntest_lots_of_decimals seems broken when i run `TestDuckDBJDBC` class. I assume core dumped is not the expected behaviour here, I did not touch any code, so I'm not sure what's happening here.\r\n\n\n### To Reproduce\n\nBuild DuckDB: \r\n`DISABLE_SANITIZER=1 BUILD_JDBC=1 BUILD_JSON=1 make debug -I/usr/lib/jvm/java-8-openjdk-amd64/include`\r\n`/usr/lib/jvm/java-8-openjdk-amd64/include` is my `JAVA_INCLUDE_DIR`\r\n\r\nRun TestDuckDBJDBC:\r\n `java -cp build/debug/tools/jdbc/duckdb_jdbc.jar org.duckdb.test.TestDuckDBJDBC`\r\n\r\n\n\n### OS:\n\nUbuntu amd64\n\n### DuckDB Version:\n\nlatest github code\n\n### DuckDB Client:\n\nJDBC\n\n### Full Name:\n\nSuri Zhang\n\n### Affiliation:\n\nNational University of Singapore, School of Computing\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "The scale and width of the decimal that is attempted to be created is:\r\n```\r\n(lldb) p width\r\np (int) $0 = 3\r\n(lldb) p scale \r\n(int) $1 = 4\r\n```\r\nThese originate from\r\n```c++\r\n                jint precision = env->CallIntMethod(param, J_Decimal_precision);\r\n                jint scale = env->CallIntMethod(param, J_Decimal_scale);\r\n```\r\nIn `duckdb_java.cpp:490`\r\n\r\nThis looks like it's caused by\r\n```java\r\ndec32_org = dec32.multiply(multiplicant).setScale(4, java.math.RoundingMode.HALF_EVEN);\r\n```\r\nIt seems `setScale` does not update the `precision`, making it possible for the `scale` to be bigger than the precision.\r\n\r\nIt looks like there's no direct relation between `precision` and our `width`\r\nI've added this *beautiful* fix, and it seems the tests pass, but I don't think this is the correct solution\r\n```c++\r\n\t\t\t\tif (scale > precision) {\r\n\t\t\t\t\tprecision = scale;\r\n\t\t\t\t}\r\n\nJava's BigDecimal allows precision < scale (\"The precision is the number of digits in the unscaled value.\"). In DuckDB's decimal type we have WIDTH. They are not equal. I think your fix is therefore correct.\r\n\r\nLooking at this I imagine that the scale could be a problem, too. BigDecimal may have negative values and DuckDB want's uint_8. Not sure how to handle this case - maybe throw an J_SQLException is the way to go here.\n> that the scale could be a problem, too. BigDecimal may have negative values and Duc\r\n\r\n@Jens-H do you think this is a bug in the logic, or just the test setting?\n@Jens-H Thanks for investigating, the fix looked very dumb to me so I appreciate the validation \ud83d\udc4d \r\nAlso you make a good point, negative scale is not handled, looking at the docs, negative scale is equivalent to an exponent.\r\nI think we could add support for this in the future, but for now I think throwing an exception is a better idea than letting it silently underflow\r\n```\r\npublic int scale()\r\nReturns the scale of this BigDecimal. If zero or positive, the scale is the number of digits to the right of the decimal point.  \r\nIf negative, the unscaled value of the number is multiplied by ten to the power of the negation of the scale. For example, a scale of -3 means the unscaled value is multiplied by 1000.\r\nReturns:\r\nthe scale of this BigDecimal.\r\n```",
  "created_at": "2023-02-06T14:10:11Z"
}