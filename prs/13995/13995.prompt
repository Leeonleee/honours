You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Cannot reference user defined type across schemas
### What happens?

When creating a type in a different schema, I cannot seem to reference it across schemas

### To Reproduce

```sql
CREATE SCHEMA s;
CREATE TYPE s.u AS STRUCT (a int, b int);
-- This works
CREATE TABLE s.t (
  u s.u
);

-- This doesn't work
CREATE TABLE main.t (
  u s.u
);
```

The error message is kind of ironic:

```
Catalog Error: Type with name u does not exist!
Did you mean "s.u"?
```

Related:

- https://github.com/duckdb/duckdb/issues/8836

### OS:

Microsoft Windows [Version 10.0.22631.4169]

### DuckDB Version:

1.1.0

### DuckDB Client:

JDBC

### Hardware:

_No response_

### Full Name:

Lukas Eder

### Affiliation:

Data Geekery

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <picture>
3:     <source media="(prefers-color-scheme: light)" srcset="logo/DuckDB_Logo-horizontal.svg">
4:     <source media="(prefers-color-scheme: dark)" srcset="logo/DuckDB_Logo-horizontal-dark-mode.svg">
5:     <img alt="DuckDB logo" src="logo/DuckDB_Logo-horizontal.svg" height="100">
6:   </picture>
7: </div>
8: <br>
9: 
10: <p align="center">
11:   <a href="https://github.com/duckdb/duckdb/actions"><img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=main" alt="Github Actions Badge"></a>
12:   <a href="https://discord.gg/tcvwpjfnZx"><img src="https://shields.io/discord/909674491309850675" alt="discord" /></a>
13:   <a href="https://github.com/duckdb/duckdb/releases/"><img src="https://img.shields.io/github/v/release/duckdb/duckdb?color=brightgreen&display_name=tag&logo=duckdb&logoColor=white" alt="Latest Release"></a>
14: </p>
15: 
16: ## DuckDB
17: 
18: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs, maps), and [several extensions designed to make SQL easier to use](https://duckdb.org/docs/guides/sql_features/friendly_sql).
19: 
20: DuckDB is available as a [standalone CLI application](https://duckdb.org/docs/api/cli/overview) and has clients for [Python](https://duckdb.org/docs/api/python/overview), [R](https://duckdb.org/docs/api/r), [Java](https://duckdb.org/docs/api/java), [Wasm](https://duckdb.org/docs/api/wasm/overview), etc., with deep integrations with packages such as [pandas](https://duckdb.org/docs/guides/python/sql_on_pandas) and [dplyr](https://duckdblabs.github.io/duckplyr/).
21: 
22: For more information on using DuckDB, please refer to the [DuckDB documentation](https://duckdb.org/docs/).
23: 
24: ## Installation
25: 
26: If you want to install DuckDB, please see [our installation page](https://duckdb.org/docs/installation) for instructions.
27: 
28: ## Data Import
29: 
30: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
31: 
32: ```sql
33: SELECT * FROM 'myfile.csv';
34: SELECT * FROM 'myfile.parquet';
35: ```
36: 
37: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
38: 
39: ## SQL Reference
40: 
41: The documentation contains a [SQL introduction and reference](https://duckdb.org/docs/sql/introduction).
42: 
43: ## Development
44: 
45: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The details of benchmarks are in our [Benchmark Guide](benchmark/README.md).
46: 
47: Please also refer to our [Build Guide](https://duckdb.org/dev/building) and [Contribution Guide](CONTRIBUTING.md).
48: 
49: ## Support
50: 
51: See the [Support Options](https://duckdblabs.com/support/) page.
[end of README.md]
[start of src/planner/binder/statement/bind_create.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: #include "duckdb/catalog/catalog_search_path.hpp"
3: #include "duckdb/catalog/catalog_entry/duck_table_entry.hpp"
4: #include "duckdb/catalog/catalog_entry/schema_catalog_entry.hpp"
5: #include "duckdb/catalog/catalog_entry/type_catalog_entry.hpp"
6: #include "duckdb/main/secret/secret_manager.hpp"
7: #include "duckdb/main/client_context.hpp"
8: #include "duckdb/main/database.hpp"
9: #include "duckdb/parser/expression/constant_expression.hpp"
10: #include "duckdb/parser/expression/function_expression.hpp"
11: #include "duckdb/parser/expression/subquery_expression.hpp"
12: #include "duckdb/planner/expression/bound_cast_expression.hpp"
13: #include "duckdb/planner/expression/bound_columnref_expression.hpp"
14: #include "duckdb/parser/parsed_data/create_index_info.hpp"
15: #include "duckdb/parser/parsed_data/create_macro_info.hpp"
16: #include "duckdb/parser/parsed_data/create_view_info.hpp"
17: #include "duckdb/parser/tableref/table_function_ref.hpp"
18: #include "duckdb/parser/parsed_data/create_secret_info.hpp"
19: #include "duckdb/parser/parsed_expression_iterator.hpp"
20: #include "duckdb/parser/statement/create_statement.hpp"
21: #include "duckdb/planner/binder.hpp"
22: #include "duckdb/planner/bound_query_node.hpp"
23: #include "duckdb/planner/expression_binder/index_binder.hpp"
24: #include "duckdb/planner/expression_binder/select_binder.hpp"
25: #include "duckdb/planner/operator/logical_create.hpp"
26: #include "duckdb/planner/operator/logical_create_index.hpp"
27: #include "duckdb/planner/operator/logical_create_table.hpp"
28: #include "duckdb/planner/operator/logical_get.hpp"
29: #include "duckdb/planner/operator/logical_projection.hpp"
30: #include "duckdb/planner/parsed_data/bound_create_table_info.hpp"
31: #include "duckdb/planner/query_node/bound_select_node.hpp"
32: #include "duckdb/planner/tableref/bound_basetableref.hpp"
33: #include "duckdb/parser/constraints/foreign_key_constraint.hpp"
34: #include "duckdb/function/scalar_macro_function.hpp"
35: #include "duckdb/storage/data_table.hpp"
36: #include "duckdb/storage/storage_extension.hpp"
37: #include "duckdb/main/client_data.hpp"
38: #include "duckdb/parser/constraints/unique_constraint.hpp"
39: #include "duckdb/parser/constraints/list.hpp"
40: #include "duckdb/main/database_manager.hpp"
41: #include "duckdb/main/attached_database.hpp"
42: #include "duckdb/catalog/duck_catalog.hpp"
43: #include "duckdb/function/table/table_scan.hpp"
44: #include "duckdb/parser/tableref/basetableref.hpp"
45: #include "duckdb/planner/expression_binder/select_bind_state.hpp"
46: 
47: namespace duckdb {
48: 
49: void Binder::BindSchemaOrCatalog(ClientContext &context, string &catalog, string &schema) {
50: 	if (catalog.empty() && !schema.empty()) {
51: 		// schema is specified - but catalog is not
52: 		// try searching for the catalog instead
53: 		auto &db_manager = DatabaseManager::Get(context);
54: 		auto database = db_manager.GetDatabase(context, schema);
55: 		if (database) {
56: 			// we have a database with this name
57: 			// check if there is a schema
58: 			auto &search_path = *context.client_data->catalog_search_path;
59: 			auto catalog_names = search_path.GetCatalogsForSchema(schema);
60: 			if (catalog_names.empty()) {
61: 				catalog_names.push_back(DatabaseManager::GetDefaultDatabase(context));
62: 			}
63: 			for (auto &catalog_name : catalog_names) {
64: 				auto &catalog = Catalog::GetCatalog(context, catalog_name);
65: 				if (catalog.CheckAmbiguousCatalogOrSchema(context, schema)) {
66: 					throw BinderException(
67: 					    "Ambiguous reference to catalog or schema \"%s\" - use a fully qualified path like \"%s.%s\"",
68: 					    schema, catalog_name, schema);
69: 				}
70: 			}
71: 			catalog = schema;
72: 			schema = string();
73: 		}
74: 	}
75: }
76: 
77: void Binder::BindSchemaOrCatalog(string &catalog, string &schema) {
78: 	BindSchemaOrCatalog(context, catalog, schema);
79: }
80: 
81: const string Binder::BindCatalog(string &catalog) {
82: 	auto &db_manager = DatabaseManager::Get(context);
83: 	optional_ptr<AttachedDatabase> database = db_manager.GetDatabase(context, catalog);
84: 	if (database) {
85: 		return db_manager.GetDatabase(context, catalog).get()->GetName();
86: 	} else {
87: 		return db_manager.GetDefaultDatabase(context);
88: 	}
89: }
90: 
91: SchemaCatalogEntry &Binder::BindSchema(CreateInfo &info) {
92: 	BindSchemaOrCatalog(info.catalog, info.schema);
93: 	if (IsInvalidCatalog(info.catalog) && info.temporary) {
94: 		info.catalog = TEMP_CATALOG;
95: 	}
96: 	auto &search_path = ClientData::Get(context).catalog_search_path;
97: 	if (IsInvalidCatalog(info.catalog) && IsInvalidSchema(info.schema)) {
98: 		auto &default_entry = search_path->GetDefault();
99: 		info.catalog = default_entry.catalog;
100: 		info.schema = default_entry.schema;
101: 	} else if (IsInvalidSchema(info.schema)) {
102: 		info.schema = search_path->GetDefaultSchema(info.catalog);
103: 	} else if (IsInvalidCatalog(info.catalog)) {
104: 		info.catalog = search_path->GetDefaultCatalog(info.schema);
105: 	}
106: 	if (IsInvalidCatalog(info.catalog)) {
107: 		info.catalog = DatabaseManager::GetDefaultDatabase(context);
108: 	}
109: 	if (!info.temporary) {
110: 		// non-temporary create: not read only
111: 		if (info.catalog == TEMP_CATALOG) {
112: 			throw ParserException("Only TEMPORARY table names can use the \"%s\" catalog", TEMP_CATALOG);
113: 		}
114: 	} else {
115: 		if (info.catalog != TEMP_CATALOG) {
116: 			throw ParserException("TEMPORARY table names can *only* use the \"%s\" catalog", TEMP_CATALOG);
117: 		}
118: 	}
119: 	// fetch the schema in which we want to create the object
120: 	auto &schema_obj = Catalog::GetSchema(context, info.catalog, info.schema);
121: 	D_ASSERT(schema_obj.type == CatalogType::SCHEMA_ENTRY);
122: 	info.schema = schema_obj.name;
123: 	if (!info.temporary) {
124: 		auto &properties = GetStatementProperties();
125: 		properties.RegisterDBModify(schema_obj.catalog, context);
126: 	}
127: 	return schema_obj;
128: }
129: 
130: SchemaCatalogEntry &Binder::BindCreateSchema(CreateInfo &info) {
131: 	auto &schema = BindSchema(info);
132: 	if (schema.catalog.IsSystemCatalog()) {
133: 		throw BinderException("Cannot create entry in system catalog");
134: 	}
135: 	return schema;
136: }
137: 
138: void Binder::SetCatalogLookupCallback(catalog_entry_callback_t callback) {
139: 	entry_retriever.SetCallback(std::move(callback));
140: }
141: 
142: void Binder::BindCreateViewInfo(CreateViewInfo &base) {
143: 	// bind the view as if it were a query so we can catch errors
144: 	// note that we bind the original, and replace the original with a copy
145: 	auto view_binder = Binder::CreateBinder(context);
146: 	auto &dependencies = base.dependencies;
147: 	auto &catalog = Catalog::GetCatalog(context, base.catalog);
148: 
149: 	auto &db_config = DBConfig::GetConfig(context);
150: 	auto should_create_dependencies = db_config.options.enable_view_dependencies;
151: 
152: 	if (should_create_dependencies) {
153: 		view_binder->SetCatalogLookupCallback([&dependencies, &catalog](CatalogEntry &entry) {
154: 			if (&catalog != &entry.ParentCatalog()) {
155: 				// Don't register dependencies between catalogs
156: 				return;
157: 			}
158: 			dependencies.AddDependency(entry);
159: 		});
160: 	}
161: 	view_binder->can_contain_nulls = true;
162: 
163: 	auto copy = base.query->Copy();
164: 	auto query_node = view_binder->Bind(*base.query);
165: 	base.query = unique_ptr_cast<SQLStatement, SelectStatement>(std::move(copy));
166: 	if (base.aliases.size() > query_node.names.size()) {
167: 		throw BinderException("More VIEW aliases than columns in query result");
168: 	}
169: 	base.types = query_node.types;
170: 	base.names = query_node.names;
171: }
172: 
173: SchemaCatalogEntry &Binder::BindCreateFunctionInfo(CreateInfo &info) {
174: 	auto &base = info.Cast<CreateMacroInfo>();
175: 
176: 	auto &dependencies = base.dependencies;
177: 	auto &catalog = Catalog::GetCatalog(context, info.catalog);
178: 	auto &db_config = DBConfig::GetConfig(context);
179: 	// try to bind each of the included functions
180: 	unordered_set<idx_t> positional_parameters;
181: 	for (auto &function : base.macros) {
182: 		auto &scalar_function = function->Cast<ScalarMacroFunction>();
183: 		if (scalar_function.expression->HasParameter()) {
184: 			throw BinderException("Parameter expressions within macro's are not supported!");
185: 		}
186: 		vector<LogicalType> dummy_types;
187: 		vector<string> dummy_names;
188: 		auto parameter_count = function->parameters.size();
189: 		if (positional_parameters.find(parameter_count) != positional_parameters.end()) {
190: 			throw BinderException(
191: 			    "Ambiguity in macro overloads - macro \"%s\" has multiple definitions with %llu parameters", base.name,
192: 			    parameter_count);
193: 		}
194: 		positional_parameters.insert(parameter_count);
195: 
196: 		// positional parameters
197: 		for (auto &param_expr : function->parameters) {
198: 			auto param = param_expr->Cast<ColumnRefExpression>();
199: 			if (param.IsQualified()) {
200: 				throw BinderException("Invalid parameter name '%s': must be unqualified", param.ToString());
201: 			}
202: 			dummy_types.emplace_back(LogicalType::SQLNULL);
203: 			dummy_names.push_back(param.GetColumnName());
204: 		}
205: 		// default parameters
206: 		for (auto &entry : function->default_parameters) {
207: 			auto &val = entry.second->Cast<ConstantExpression>();
208: 			dummy_types.push_back(val.value.type());
209: 			dummy_names.push_back(entry.first);
210: 		}
211: 		auto this_macro_binding = make_uniq<DummyBinding>(dummy_types, dummy_names, base.name);
212: 		macro_binding = this_macro_binding.get();
213: 
214: 		// create a copy of the expression because we do not want to alter the original
215: 		auto expression = scalar_function.expression->Copy();
216: 		ExpressionBinder::QualifyColumnNames(*this, expression);
217: 
218: 		// bind it to verify the function was defined correctly
219: 		BoundSelectNode sel_node;
220: 		BoundGroupInformation group_info;
221: 		SelectBinder binder(*this, context, sel_node, group_info);
222: 		auto should_create_dependencies = db_config.options.enable_macro_dependencies;
223: 
224: 		if (should_create_dependencies) {
225: 			binder.SetCatalogLookupCallback([&dependencies, &catalog](CatalogEntry &entry) {
226: 				if (&catalog != &entry.ParentCatalog()) {
227: 					// Don't register any cross-catalog dependencies
228: 					return;
229: 				}
230: 				// Register any catalog entry required to bind the macro function
231: 				dependencies.AddDependency(entry);
232: 			});
233: 		}
234: 		ErrorData error;
235: 		try {
236: 			error = binder.Bind(expression, 0, false);
237: 			if (error.HasError()) {
238: 				error.Throw();
239: 			}
240: 		} catch (const std::exception &ex) {
241: 			error = ErrorData(ex);
242: 		}
243: 		// if we cannot resolve parameters we postpone binding until the macro function is used
244: 		if (error.HasError() && error.Type() != ExceptionType::PARAMETER_NOT_RESOLVED) {
245: 			error.Throw();
246: 		}
247: 	}
248: 
249: 	return BindCreateSchema(info);
250: }
251: 
252: void Binder::BindLogicalType(LogicalType &type, optional_ptr<Catalog> catalog, const string &schema) {
253: 	if (type.id() == LogicalTypeId::LIST || type.id() == LogicalTypeId::MAP) {
254: 		auto child_type = ListType::GetChildType(type);
255: 		BindLogicalType(child_type, catalog, schema);
256: 		auto alias = type.GetAlias();
257: 		auto modifiers = type.GetModifiersCopy();
258: 		if (type.id() == LogicalTypeId::LIST) {
259: 			type = LogicalType::LIST(child_type);
260: 		} else {
261: 			D_ASSERT(child_type.id() == LogicalTypeId::STRUCT); // map must be list of structs
262: 			type = LogicalType::MAP(child_type);
263: 		}
264: 
265: 		type.SetAlias(alias);
266: 		type.SetModifiers(modifiers);
267: 	} else if (type.id() == LogicalTypeId::STRUCT) {
268: 		auto child_types = StructType::GetChildTypes(type);
269: 		for (auto &child_type : child_types) {
270: 			BindLogicalType(child_type.second, catalog, schema);
271: 		}
272: 		// Generate new Struct Type
273: 		auto alias = type.GetAlias();
274: 		auto modifiers = type.GetModifiersCopy();
275: 		type = LogicalType::STRUCT(child_types);
276: 		type.SetAlias(alias);
277: 		type.SetModifiers(modifiers);
278: 	} else if (type.id() == LogicalTypeId::ARRAY) {
279: 		auto child_type = ArrayType::GetChildType(type);
280: 		auto array_size = ArrayType::GetSize(type);
281: 		BindLogicalType(child_type, catalog, schema);
282: 		auto alias = type.GetAlias();
283: 		auto modifiers = type.GetModifiersCopy();
284: 		type = LogicalType::ARRAY(child_type, array_size);
285: 		type.SetAlias(alias);
286: 		type.SetModifiers(modifiers);
287: 	} else if (type.id() == LogicalTypeId::UNION) {
288: 		auto member_types = UnionType::CopyMemberTypes(type);
289: 		for (auto &member_type : member_types) {
290: 			BindLogicalType(member_type.second, catalog, schema);
291: 		}
292: 		// Generate new Union Type
293: 		auto alias = type.GetAlias();
294: 		auto modifiers = type.GetModifiersCopy();
295: 		type = LogicalType::UNION(member_types);
296: 		type.SetAlias(alias);
297: 		type.SetModifiers(modifiers);
298: 	} else if (type.id() == LogicalTypeId::USER) {
299: 		auto user_type_name = UserType::GetTypeName(type);
300: 		auto user_type_mods = UserType::GetTypeModifiers(type);
301: 
302: 		bind_type_modifiers_function_t user_bind_modifiers_func = nullptr;
303: 
304: 		if (catalog) {
305: 			// The search order is:
306: 			// 1) In the same schema as the table
307: 			// 2) In the same catalog
308: 			// 3) System catalog
309: 			auto entry = entry_retriever.GetEntry(CatalogType::TYPE_ENTRY, *catalog, schema, user_type_name,
310: 			                                      OnEntryNotFound::RETURN_NULL);
311: 			if (!entry || entry->Cast<TypeCatalogEntry>().user_type.id() == LogicalTypeId::INVALID) {
312: 				entry = entry_retriever.GetEntry(CatalogType::TYPE_ENTRY, *catalog, INVALID_SCHEMA, user_type_name,
313: 				                                 OnEntryNotFound::RETURN_NULL);
314: 				if (!entry || entry->Cast<TypeCatalogEntry>().user_type.id() == LogicalTypeId::INVALID) {
315: 					entry = entry_retriever.GetEntry(CatalogType::TYPE_ENTRY, INVALID_CATALOG, INVALID_SCHEMA,
316: 					                                 user_type_name, OnEntryNotFound::THROW_EXCEPTION);
317: 				}
318: 			}
319: 			auto &type_entry = entry->Cast<TypeCatalogEntry>();
320: 			type = type_entry.user_type;
321: 			user_bind_modifiers_func = type_entry.bind_modifiers;
322: 		} else {
323: 			string type_catalog = UserType::GetCatalog(type);
324: 			string type_schema = UserType::GetSchema(type);
325: 
326: 			BindSchemaOrCatalog(context, type_catalog, type_schema);
327: 			auto entry = entry_retriever.GetEntry(CatalogType::TYPE_ENTRY, type_catalog, type_schema, user_type_name);
328: 			auto &type_entry = entry->Cast<TypeCatalogEntry>();
329: 			type = type_entry.user_type;
330: 			user_bind_modifiers_func = type_entry.bind_modifiers;
331: 		}
332: 
333: 		BindLogicalType(type, catalog, schema);
334: 
335: 		// Apply the type modifiers (if any)
336: 		if (user_bind_modifiers_func) {
337: 			// If an explicit bind_modifiers function was provided, use that to set the type modifier
338: 			BindTypeModifiersInput input {context, type, user_type_mods};
339: 			type = user_bind_modifiers_func(input);
340: 		} else if (type.HasModifiers()) {
341: 			// If the type already has modifiers, try to replace them with the user-provided ones if they are compatible
342: 			// This enables registering custom types with "default" type modifiers that can be overridden, without
343: 			// having to provide a custom bind_modifiers function
344: 			auto type_mods_size = type.GetModifiers()->size();
345: 
346: 			// Are we trying to pass more type modifiers than the type has?
347: 			if (user_type_mods.size() > type_mods_size) {
348: 				throw BinderException(
349: 				    "Cannot apply '%d' type modifier(s) to type '%s' taking at most '%d' type modifier(s)",
350: 				    user_type_mods.size(), user_type_name, type_mods_size);
351: 			}
352: 
353: 			// Deep copy the type so that we can replace the type modifiers
354: 			type = type.DeepCopy();
355: 
356: 			// Re-fetch the type modifiers now that we've deduplicated the ExtraTypeInfo
357: 			auto &type_mods = *type.GetModifiers();
358: 
359: 			// Replace them in order, casting if necessary
360: 			for (idx_t i = 0; i < MinValue(type_mods.size(), user_type_mods.size()); i++) {
361: 				auto &type_mod = type_mods[i];
362: 				auto user_type_mod = user_type_mods[i];
363: 				if (type_mod.type() == user_type_mod.type()) {
364: 					type_mod = std::move(user_type_mod);
365: 				} else if (user_type_mod.DefaultTryCastAs(type_mod.type())) {
366: 					type_mod = std::move(user_type_mod);
367: 				} else {
368: 					throw BinderException("Cannot apply type modifier '%s' to type '%s', expected value of type '%s'",
369: 					                      user_type_mod.ToString(), user_type_name, type_mod.type().ToString());
370: 				}
371: 			}
372: 		} else if (!user_type_mods.empty()) {
373: 			// We're trying to pass type modifiers to a type that doesnt have any
374: 			throw BinderException("Type '%s' does not take any type modifiers", user_type_name);
375: 		}
376: 	}
377: }
378: 
379: static void FindMatchingPrimaryKeyColumns(const ColumnList &columns, const vector<unique_ptr<Constraint>> &constraints,
380:                                           ForeignKeyConstraint &fk) {
381: 	// find the matching primary key constraint
382: 	bool found_constraint = false;
383: 	// if no columns are defined, we will automatically try to bind to the primary key
384: 	bool find_primary_key = fk.pk_columns.empty();
385: 	for (auto &constr : constraints) {
386: 		if (constr->type != ConstraintType::UNIQUE) {
387: 			continue;
388: 		}
389: 		auto &unique = constr->Cast<UniqueConstraint>();
390: 		if (find_primary_key && !unique.IsPrimaryKey()) {
391: 			continue;
392: 		}
393: 		found_constraint = true;
394: 
395: 		vector<string> pk_names;
396: 		if (unique.HasIndex()) {
397: 			pk_names.push_back(columns.GetColumn(LogicalIndex(unique.GetIndex())).Name());
398: 		} else {
399: 			pk_names = unique.GetColumnNames();
400: 		}
401: 		if (find_primary_key) {
402: 			// found matching primary key
403: 			if (pk_names.size() != fk.fk_columns.size()) {
404: 				auto pk_name_str = StringUtil::Join(pk_names, ",");
405: 				auto fk_name_str = StringUtil::Join(fk.fk_columns, ",");
406: 				throw BinderException(
407: 				    "Failed to create foreign key: number of referencing (%s) and referenced columns (%s) differ",
408: 				    fk_name_str, pk_name_str);
409: 			}
410: 			fk.pk_columns = pk_names;
411: 			return;
412: 		}
413: 		if (pk_names.size() != fk.fk_columns.size()) {
414: 			// the number of referencing and referenced columns for foreign keys must be the same
415: 			continue;
416: 		}
417: 		bool equals = true;
418: 		for (idx_t i = 0; i < fk.pk_columns.size(); i++) {
419: 			if (!StringUtil::CIEquals(fk.pk_columns[i], pk_names[i])) {
420: 				equals = false;
421: 				break;
422: 			}
423: 		}
424: 		if (!equals) {
425: 			continue;
426: 		}
427: 		// found match
428: 		return;
429: 	}
430: 	// no match found! examine why
431: 	if (!found_constraint) {
432: 		// no unique constraint or primary key
433: 		string search_term = find_primary_key ? "primary key" : "primary key or unique constraint";
434: 		throw BinderException("Failed to create foreign key: there is no %s for referenced table \"%s\"", search_term,
435: 		                      fk.info.table);
436: 	}
437: 	// check if all the columns exist
438: 	for (auto &name : fk.pk_columns) {
439: 		bool found = columns.ColumnExists(name);
440: 		if (!found) {
441: 			throw BinderException(
442: 			    "Failed to create foreign key: referenced table \"%s\" does not have a column named \"%s\"",
443: 			    fk.info.table, name);
444: 		}
445: 	}
446: 	auto fk_names = StringUtil::Join(fk.pk_columns, ",");
447: 	throw BinderException("Failed to create foreign key: referenced table \"%s\" does not have a primary key or unique "
448: 	                      "constraint on the columns %s",
449: 	                      fk.info.table, fk_names);
450: }
451: 
452: static void FindForeignKeyIndexes(const ColumnList &columns, const vector<string> &names,
453:                                   vector<PhysicalIndex> &indexes) {
454: 	D_ASSERT(indexes.empty());
455: 	D_ASSERT(!names.empty());
456: 	for (auto &name : names) {
457: 		if (!columns.ColumnExists(name)) {
458: 			throw BinderException("column \"%s\" named in key does not exist", name);
459: 		}
460: 		auto &column = columns.GetColumn(name);
461: 		if (column.Generated()) {
462: 			throw BinderException("Failed to create foreign key: referenced column \"%s\" is a generated column",
463: 			                      column.Name());
464: 		}
465: 		indexes.push_back(column.Physical());
466: 	}
467: }
468: 
469: static void CheckForeignKeyTypes(const ColumnList &pk_columns, const ColumnList &fk_columns, ForeignKeyConstraint &fk) {
470: 	D_ASSERT(fk.info.pk_keys.size() == fk.info.fk_keys.size());
471: 	for (idx_t c_idx = 0; c_idx < fk.info.pk_keys.size(); c_idx++) {
472: 		auto &pk_col = pk_columns.GetColumn(fk.info.pk_keys[c_idx]);
473: 		auto &fk_col = fk_columns.GetColumn(fk.info.fk_keys[c_idx]);
474: 		if (pk_col.Type() != fk_col.Type()) {
475: 			throw BinderException("Failed to create foreign key: incompatible types between column \"%s\" (\"%s\") and "
476: 			                      "column \"%s\" (\"%s\")",
477: 			                      pk_col.Name(), pk_col.Type().ToString(), fk_col.Name(), fk_col.Type().ToString());
478: 		}
479: 	}
480: }
481: 
482: void ExpressionContainsGeneratedColumn(const ParsedExpression &expr, const unordered_set<string> &gcols,
483:                                        bool &contains_gcol) {
484: 	if (contains_gcol) {
485: 		return;
486: 	}
487: 	if (expr.type == ExpressionType::COLUMN_REF) {
488: 		auto &column_ref = expr.Cast<ColumnRefExpression>();
489: 		auto &name = column_ref.GetColumnName();
490: 		if (gcols.count(name)) {
491: 			contains_gcol = true;
492: 			return;
493: 		}
494: 	}
495: 	ParsedExpressionIterator::EnumerateChildren(
496: 	    expr, [&](const ParsedExpression &child) { ExpressionContainsGeneratedColumn(child, gcols, contains_gcol); });
497: }
498: 
499: static bool AnyConstraintReferencesGeneratedColumn(CreateTableInfo &table_info) {
500: 	unordered_set<string> generated_columns;
501: 	for (auto &col : table_info.columns.Logical()) {
502: 		if (!col.Generated()) {
503: 			continue;
504: 		}
505: 		generated_columns.insert(col.Name());
506: 	}
507: 	if (generated_columns.empty()) {
508: 		return false;
509: 	}
510: 
511: 	for (auto &constr : table_info.constraints) {
512: 		switch (constr->type) {
513: 		case ConstraintType::CHECK: {
514: 			auto &constraint = constr->Cast<CheckConstraint>();
515: 			auto &expr = constraint.expression;
516: 			bool contains_generated_column = false;
517: 			ExpressionContainsGeneratedColumn(*expr, generated_columns, contains_generated_column);
518: 			if (contains_generated_column) {
519: 				return true;
520: 			}
521: 			break;
522: 		}
523: 		case ConstraintType::NOT_NULL: {
524: 			auto &constraint = constr->Cast<NotNullConstraint>();
525: 			if (table_info.columns.GetColumn(constraint.index).Generated()) {
526: 				return true;
527: 			}
528: 			break;
529: 		}
530: 		case ConstraintType::UNIQUE: {
531: 			auto &constraint = constr->Cast<UniqueConstraint>();
532: 			if (!constraint.HasIndex()) {
533: 				for (auto &col : constraint.GetColumnNames()) {
534: 					if (generated_columns.count(col)) {
535: 						return true;
536: 					}
537: 				}
538: 			} else {
539: 				if (table_info.columns.GetColumn(constraint.GetIndex()).Generated()) {
540: 					return true;
541: 				}
542: 			}
543: 			break;
544: 		}
545: 		case ConstraintType::FOREIGN_KEY: {
546: 			// If it contained a generated column, an exception would have been thrown inside AddDataTableIndex earlier
547: 			break;
548: 		}
549: 		default: {
550: 			throw NotImplementedException("ConstraintType not implemented");
551: 		}
552: 		}
553: 	}
554: 	return false;
555: }
556: 
557: unique_ptr<LogicalOperator> DuckCatalog::BindCreateIndex(Binder &binder, CreateStatement &stmt,
558:                                                          TableCatalogEntry &table, unique_ptr<LogicalOperator> plan) {
559: 	D_ASSERT(plan->type == LogicalOperatorType::LOGICAL_GET);
560: 	auto &base = stmt.info->Cast<CreateIndexInfo>();
561: 
562: 	auto &get = plan->Cast<LogicalGet>();
563: 	// bind the index expressions
564: 	IndexBinder index_binder(binder, binder.context);
565: 	auto &dependencies = base.dependencies;
566: 	auto &catalog = Catalog::GetCatalog(binder.context, base.catalog);
567: 	index_binder.SetCatalogLookupCallback([&dependencies, &catalog](CatalogEntry &entry) {
568: 		if (&catalog != &entry.ParentCatalog()) {
569: 			// Don't register any cross-catalog dependencies
570: 			return;
571: 		}
572: 		dependencies.AddDependency(entry);
573: 	});
574: 	vector<unique_ptr<Expression>> expressions;
575: 	expressions.reserve(base.expressions.size());
576: 	for (auto &expr : base.expressions) {
577: 		expressions.push_back(index_binder.Bind(expr));
578: 	}
579: 
580: 	auto create_index_info = unique_ptr_cast<CreateInfo, CreateIndexInfo>(std::move(stmt.info));
581: 	auto &column_ids = get.GetColumnIds();
582: 	for (auto &column_id : column_ids) {
583: 		if (column_id == COLUMN_IDENTIFIER_ROW_ID) {
584: 			throw BinderException("Cannot create an index on the rowid!");
585: 		}
586: 		create_index_info->scan_types.push_back(get.returned_types[column_id]);
587: 	}
588: 	create_index_info->scan_types.emplace_back(LogicalType::ROW_TYPE);
589: 	create_index_info->names = get.names;
590: 	create_index_info->column_ids = column_ids;
591: 	create_index_info->schema = table.schema.name;
592: 	auto &bind_data = get.bind_data->Cast<TableScanBindData>();
593: 	bind_data.is_create_index = true;
594: 	get.AddColumnId(COLUMN_IDENTIFIER_ROW_ID);
595: 
596: 	// the logical CREATE INDEX also needs all fields to scan the referenced table
597: 	auto result = make_uniq<LogicalCreateIndex>(std::move(create_index_info), std::move(expressions), table);
598: 	result->children.push_back(std::move(plan));
599: 	return std::move(result);
600: }
601: 
602: BoundStatement Binder::Bind(CreateStatement &stmt) {
603: 	BoundStatement result;
604: 	result.names = {"Count"};
605: 	result.types = {LogicalType::BIGINT};
606: 
607: 	auto catalog_type = stmt.info->type;
608: 	auto &properties = GetStatementProperties();
609: 	switch (catalog_type) {
610: 	case CatalogType::SCHEMA_ENTRY: {
611: 		auto &base = stmt.info->Cast<CreateInfo>();
612: 		auto catalog = BindCatalog(base.catalog);
613: 		properties.RegisterDBModify(Catalog::GetCatalog(context, catalog), context);
614: 		result.plan = make_uniq<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_SCHEMA, std::move(stmt.info));
615: 		break;
616: 	}
617: 	case CatalogType::VIEW_ENTRY: {
618: 		auto &base = stmt.info->Cast<CreateViewInfo>();
619: 		// bind the schema
620: 		auto &schema = BindCreateSchema(*stmt.info);
621: 		BindCreateViewInfo(base);
622: 		result.plan = make_uniq<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_VIEW, std::move(stmt.info), &schema);
623: 		break;
624: 	}
625: 	case CatalogType::SEQUENCE_ENTRY: {
626: 		auto &schema = BindCreateSchema(*stmt.info);
627: 		result.plan =
628: 		    make_uniq<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_SEQUENCE, std::move(stmt.info), &schema);
629: 		break;
630: 	}
631: 	case CatalogType::TABLE_MACRO_ENTRY: {
632: 		auto &schema = BindCreateSchema(*stmt.info);
633: 		result.plan =
634: 		    make_uniq<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_MACRO, std::move(stmt.info), &schema);
635: 		break;
636: 	}
637: 	case CatalogType::MACRO_ENTRY: {
638: 		auto &schema = BindCreateFunctionInfo(*stmt.info);
639: 		auto logical_create =
640: 		    make_uniq<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_MACRO, std::move(stmt.info), &schema);
641: 		result.plan = std::move(logical_create);
642: 		break;
643: 	}
644: 	case CatalogType::INDEX_ENTRY: {
645: 		auto &base = stmt.info->Cast<CreateIndexInfo>();
646: 
647: 		// visit the table reference
648: 		auto table_ref = make_uniq<BaseTableRef>();
649: 		table_ref->catalog_name = base.catalog;
650: 		table_ref->schema_name = base.schema;
651: 		table_ref->table_name = base.table;
652: 
653: 		auto bound_table = Bind(*table_ref);
654: 		if (bound_table->type != TableReferenceType::BASE_TABLE) {
655: 			throw BinderException("Can only create an index over a base table!");
656: 		}
657: 		auto &table_binding = bound_table->Cast<BoundBaseTableRef>();
658: 		auto &table = table_binding.table;
659: 		if (table.temporary) {
660: 			stmt.info->temporary = true;
661: 		}
662: 		properties.RegisterDBModify(table.catalog, context);
663: 
664: 		// create a plan over the bound table
665: 		auto plan = CreatePlan(*bound_table);
666: 		if (plan->type != LogicalOperatorType::LOGICAL_GET) {
667: 			throw BinderException("Cannot create index on a view!");
668: 		}
669: 		result.plan = table.catalog.BindCreateIndex(*this, stmt, table, std::move(plan));
670: 		break;
671: 	}
672: 	case CatalogType::TABLE_ENTRY: {
673: 		auto &create_info = stmt.info->Cast<CreateTableInfo>();
674: 		// If there is a foreign key constraint, resolve primary key column's index from primary key column's name
675: 		reference_set_t<SchemaCatalogEntry> fk_schemas;
676: 		for (idx_t i = 0; i < create_info.constraints.size(); i++) {
677: 			auto &cond = create_info.constraints[i];
678: 			if (cond->type != ConstraintType::FOREIGN_KEY) {
679: 				continue;
680: 			}
681: 			auto &fk = cond->Cast<ForeignKeyConstraint>();
682: 			if (fk.info.type != ForeignKeyType::FK_TYPE_FOREIGN_KEY_TABLE) {
683: 				continue;
684: 			}
685: 			D_ASSERT(fk.info.pk_keys.empty());
686: 			D_ASSERT(fk.info.fk_keys.empty());
687: 			FindForeignKeyIndexes(create_info.columns, fk.fk_columns, fk.info.fk_keys);
688: 			if (StringUtil::CIEquals(create_info.table, fk.info.table)) {
689: 				// self-referential foreign key constraint
690: 				fk.info.type = ForeignKeyType::FK_TYPE_SELF_REFERENCE_TABLE;
691: 				FindMatchingPrimaryKeyColumns(create_info.columns, create_info.constraints, fk);
692: 				FindForeignKeyIndexes(create_info.columns, fk.pk_columns, fk.info.pk_keys);
693: 				CheckForeignKeyTypes(create_info.columns, create_info.columns, fk);
694: 			} else {
695: 				// have to resolve referenced table
696: 				auto table_entry =
697: 				    entry_retriever.GetEntry(CatalogType::TABLE_ENTRY, INVALID_CATALOG, fk.info.schema, fk.info.table);
698: 				auto &pk_table_entry_ptr = table_entry->Cast<TableCatalogEntry>();
699: 				fk_schemas.insert(pk_table_entry_ptr.schema);
700: 				FindMatchingPrimaryKeyColumns(pk_table_entry_ptr.GetColumns(), pk_table_entry_ptr.GetConstraints(), fk);
701: 				FindForeignKeyIndexes(pk_table_entry_ptr.GetColumns(), fk.pk_columns, fk.info.pk_keys);
702: 				CheckForeignKeyTypes(pk_table_entry_ptr.GetColumns(), create_info.columns, fk);
703: 				auto &storage = pk_table_entry_ptr.GetStorage();
704: 
705: 				if (!storage.HasForeignKeyIndex(fk.info.pk_keys, ForeignKeyType::FK_TYPE_PRIMARY_KEY_TABLE)) {
706: 					auto fk_column_names = StringUtil::Join(fk.pk_columns, ",");
707: 					throw BinderException("Failed to create foreign key on %s(%s): no UNIQUE or PRIMARY KEY constraint "
708: 					                      "present on these columns",
709: 					                      pk_table_entry_ptr.name, fk_column_names);
710: 				}
711: 			}
712: 			D_ASSERT(fk.info.pk_keys.size() == fk.info.fk_keys.size());
713: 			D_ASSERT(fk.info.pk_keys.size() == fk.pk_columns.size());
714: 			D_ASSERT(fk.info.fk_keys.size() == fk.fk_columns.size());
715: 		}
716: 		if (AnyConstraintReferencesGeneratedColumn(create_info)) {
717: 			throw BinderException("Constraints on generated columns are not supported yet");
718: 		}
719: 		auto bound_info = BindCreateTableInfo(std::move(stmt.info));
720: 		auto root = std::move(bound_info->query);
721: 		for (auto &fk_schema : fk_schemas) {
722: 			if (&fk_schema.get() != &bound_info->schema) {
723: 				throw BinderException("Creating foreign keys across different schemas or catalogs is not supported");
724: 			}
725: 		}
726: 
727: 		// create the logical operator
728: 		auto &schema = bound_info->schema;
729: 		auto create_table = make_uniq<LogicalCreateTable>(schema, std::move(bound_info));
730: 		if (root) {
731: 			// CREATE TABLE AS
732: 			properties.return_type = StatementReturnType::CHANGED_ROWS;
733: 			create_table->children.push_back(std::move(root));
734: 		}
735: 		result.plan = std::move(create_table);
736: 		break;
737: 	}
738: 	case CatalogType::TYPE_ENTRY: {
739: 		auto &schema = BindCreateSchema(*stmt.info);
740: 		auto &create_type_info = stmt.info->Cast<CreateTypeInfo>();
741: 		result.plan = make_uniq<LogicalCreate>(LogicalOperatorType::LOGICAL_CREATE_TYPE, std::move(stmt.info), &schema);
742: 
743: 		auto &catalog = Catalog::GetCatalog(context, create_type_info.catalog);
744: 		auto &dependencies = create_type_info.dependencies;
745: 		auto dependency_callback = [&dependencies, &catalog](CatalogEntry &entry) {
746: 			if (&catalog != &entry.ParentCatalog()) {
747: 				// Don't register any cross-catalog dependencies
748: 				return;
749: 			}
750: 			dependencies.AddDependency(entry);
751: 		};
752: 		if (create_type_info.query) {
753: 			// CREATE TYPE mood AS ENUM (SELECT 'happy')
754: 			auto query_obj = Bind(*create_type_info.query);
755: 			auto query = std::move(query_obj.plan);
756: 			create_type_info.query.reset();
757: 
758: 			auto &sql_types = query_obj.types;
759: 			if (sql_types.size() != 1) {
760: 				// add cast expression?
761: 				throw BinderException("The query must return a single column");
762: 			}
763: 			if (sql_types[0].id() != LogicalType::VARCHAR) {
764: 				// push a projection casting to varchar
765: 				vector<unique_ptr<Expression>> select_list;
766: 				auto ref = make_uniq<BoundColumnRefExpression>(sql_types[0], query->GetColumnBindings()[0]);
767: 				auto cast_expr = BoundCastExpression::AddCastToType(context, std::move(ref), LogicalType::VARCHAR);
768: 				select_list.push_back(std::move(cast_expr));
769: 				auto proj = make_uniq<LogicalProjection>(GenerateTableIndex(), std::move(select_list));
770: 				proj->AddChild(std::move(query));
771: 				query = std::move(proj);
772: 			}
773: 
774: 			result.plan->AddChild(std::move(query));
775: 		} else if (create_type_info.type.id() == LogicalTypeId::USER) {
776: 			SetCatalogLookupCallback(dependency_callback);
777: 			// two cases:
778: 			// 1: create a type with a non-existent type as source, Binder::BindLogicalType(...) will throw exception.
779: 			// 2: create a type alias with a custom type.
780: 			// eg. CREATE TYPE a AS INT; CREATE TYPE b AS a;
781: 			// We set b to be an alias for the underlying type of a
782: 			auto type_entry_p = entry_retriever.GetEntry(CatalogType::TYPE_ENTRY, schema.catalog.GetName(), schema.name,
783: 			                                             UserType::GetTypeName(create_type_info.type));
784: 			D_ASSERT(type_entry_p);
785: 			auto &type_entry = type_entry_p->Cast<TypeCatalogEntry>();
786: 			create_type_info.type = type_entry.user_type;
787: 		} else {
788: 			SetCatalogLookupCallback(dependency_callback);
789: 			// This is done so that if the type contains a USER type,
790: 			// we register this dependency
791: 			auto preserved_type = create_type_info.type;
792: 			BindLogicalType(create_type_info.type);
793: 			create_type_info.type = preserved_type;
794: 		}
795: 		break;
796: 	}
797: 	case CatalogType::SECRET_ENTRY: {
798: 		CatalogTransaction transaction = CatalogTransaction(Catalog::GetSystemCatalog(context), context);
799: 		properties.return_type = StatementReturnType::QUERY_RESULT;
800: 		return SecretManager::Get(context).BindCreateSecret(transaction, stmt.info->Cast<CreateSecretInfo>());
801: 	}
802: 	default:
803: 		throw InternalException("Unrecognized type!");
804: 	}
805: 	properties.return_type = StatementReturnType::NOTHING;
806: 	properties.allow_stream_result = false;
807: 	return result;
808: }
809: 
810: } // namespace duckdb
[end of src/planner/binder/statement/bind_create.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: