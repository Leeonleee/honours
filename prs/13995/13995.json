{
  "repo": "duckdb/duckdb",
  "pull_number": 13995,
  "instance_id": "duckdb__duckdb-13995",
  "issue_numbers": [
    "13981"
  ],
  "base_commit": "6b7d3ec9adbc10818eef760490f3966f08338e2d",
  "patch": "diff --git a/src/planner/binder/statement/bind_create.cpp b/src/planner/binder/statement/bind_create.cpp\nindex f03f260c4889..a35d6e13c802 100644\n--- a/src/planner/binder/statement/bind_create.cpp\n+++ b/src/planner/binder/statement/bind_create.cpp\n@@ -249,6 +249,13 @@ SchemaCatalogEntry &Binder::BindCreateFunctionInfo(CreateInfo &info) {\n \treturn BindCreateSchema(info);\n }\n \n+static bool IsValidUserType(optional_ptr<CatalogEntry> entry) {\n+\tif (!entry) {\n+\t\treturn false;\n+\t}\n+\treturn entry->Cast<TypeCatalogEntry>().user_type.id() != LogicalTypeId::INVALID;\n+}\n+\n void Binder::BindLogicalType(LogicalType &type, optional_ptr<Catalog> catalog, const string &schema) {\n \tif (type.id() == LogicalTypeId::LIST || type.id() == LogicalTypeId::MAP) {\n \t\tauto child_type = ListType::GetChildType(type);\n@@ -297,24 +304,34 @@ void Binder::BindLogicalType(LogicalType &type, optional_ptr<Catalog> catalog, c\n \t\ttype.SetModifiers(modifiers);\n \t} else if (type.id() == LogicalTypeId::USER) {\n \t\tauto user_type_name = UserType::GetTypeName(type);\n+\t\tauto user_type_schema = UserType::GetSchema(type);\n \t\tauto user_type_mods = UserType::GetTypeModifiers(type);\n \n \t\tbind_type_modifiers_function_t user_bind_modifiers_func = nullptr;\n \n \t\tif (catalog) {\n \t\t\t// The search order is:\n-\t\t\t// 1) In the same schema as the table\n-\t\t\t// 2) In the same catalog\n-\t\t\t// 3) System catalog\n-\t\t\tauto entry = entry_retriever.GetEntry(CatalogType::TYPE_ENTRY, *catalog, schema, user_type_name,\n-\t\t\t                                      OnEntryNotFound::RETURN_NULL);\n-\t\t\tif (!entry || entry->Cast<TypeCatalogEntry>().user_type.id() == LogicalTypeId::INVALID) {\n+\t\t\t// 1) In the explicitly set schema (my_schema.my_type)\n+\t\t\t// 2) In the same schema as the table\n+\t\t\t// 3) In the same catalog\n+\t\t\t// 4) System catalog\n+\n+\t\t\toptional_ptr<CatalogEntry> entry = nullptr;\n+\t\t\tif (!user_type_schema.empty()) {\n+\t\t\t\tentry = entry_retriever.GetEntry(CatalogType::TYPE_ENTRY, *catalog, user_type_schema, user_type_name,\n+\t\t\t\t                                 OnEntryNotFound::RETURN_NULL);\n+\t\t\t}\n+\t\t\tif (!IsValidUserType(entry)) {\n+\t\t\t\tentry = entry_retriever.GetEntry(CatalogType::TYPE_ENTRY, *catalog, schema, user_type_name,\n+\t\t\t\t                                 OnEntryNotFound::RETURN_NULL);\n+\t\t\t}\n+\t\t\tif (!IsValidUserType(entry)) {\n \t\t\t\tentry = entry_retriever.GetEntry(CatalogType::TYPE_ENTRY, *catalog, INVALID_SCHEMA, user_type_name,\n \t\t\t\t                                 OnEntryNotFound::RETURN_NULL);\n-\t\t\t\tif (!entry || entry->Cast<TypeCatalogEntry>().user_type.id() == LogicalTypeId::INVALID) {\n-\t\t\t\t\tentry = entry_retriever.GetEntry(CatalogType::TYPE_ENTRY, INVALID_CATALOG, INVALID_SCHEMA,\n-\t\t\t\t\t                                 user_type_name, OnEntryNotFound::THROW_EXCEPTION);\n-\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (!IsValidUserType(entry)) {\n+\t\t\t\tentry = entry_retriever.GetEntry(CatalogType::TYPE_ENTRY, INVALID_CATALOG, INVALID_SCHEMA,\n+\t\t\t\t                                 user_type_name, OnEntryNotFound::THROW_EXCEPTION);\n \t\t\t}\n \t\t\tauto &type_entry = entry->Cast<TypeCatalogEntry>();\n \t\t\ttype = type_entry.user_type;\n",
  "test_patch": "diff --git a/test/sql/types/alias/type_with_schema.test b/test/sql/types/alias/type_with_schema.test\nnew file mode 100644\nindex 000000000000..f142ad1960b7\n--- /dev/null\n+++ b/test/sql/types/alias/type_with_schema.test\n@@ -0,0 +1,20 @@\n+# name: test/sql/types/alias/type_with_schema.test\n+# group: [alias]\n+\n+statement ok\n+CREATE SCHEMA my_schema;\n+\n+statement ok\n+CREATE TYPE my_schema.my_type AS STRUCT (\n+\ta int, b int\n+);\n+\n+statement ok\n+CREATE TABLE my_schema.tbl (\n+\tc0 my_schema.my_type\n+);\n+\n+statement ok\n+CREATE TABLE main.tbl (\n+\tc0 my_schema.my_type\n+);\n",
  "problem_statement": "Cannot reference user defined type across schemas\n### What happens?\n\nWhen creating a type in a different schema, I cannot seem to reference it across schemas\n\n### To Reproduce\n\n```sql\r\nCREATE SCHEMA s;\r\nCREATE TYPE s.u AS STRUCT (a int, b int);\r\n-- This works\r\nCREATE TABLE s.t (\r\n  u s.u\r\n);\r\n\r\n-- This doesn't work\r\nCREATE TABLE main.t (\r\n  u s.u\r\n);\r\n```\r\n\r\nThe error message is kind of ironic:\r\n\r\n```\r\nCatalog Error: Type with name u does not exist!\r\nDid you mean \"s.u\"?\r\n```\r\n\r\nRelated:\r\n\r\n- https://github.com/duckdb/duckdb/issues/8836\n\n### OS:\n\nMicrosoft Windows [Version 10.0.22631.4169]\n\n### DuckDB Version:\n\n1.1.0\n\n### DuckDB Client:\n\nJDBC\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nLukas Eder\n\n### Affiliation:\n\nData Geekery\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nYes\n\n### Did you include all code required to reproduce the issue?\n\n- [X] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [X] Yes, I have\n",
  "hints_text": "",
  "created_at": "2024-09-17T14:12:54Z"
}