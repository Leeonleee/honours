{
  "repo": "duckdb/duckdb",
  "pull_number": 4044,
  "instance_id": "duckdb__duckdb-4044",
  "issue_numbers": [
    "3593",
    "3593"
  ],
  "base_commit": "f523e0555ebaa076c433573f92b2b9ce107aa918",
  "patch": "diff --git a/src/common/types/chunk_collection.cpp b/src/common/types/chunk_collection.cpp\nindex 4b43c1803925..cc0a3e5accdd 100644\n--- a/src/common/types/chunk_collection.cpp\n+++ b/src/common/types/chunk_collection.cpp\n@@ -454,6 +454,12 @@ bool ChunkCollection::Equals(ChunkCollection &other) {\n \tif (compare_equals) {\n \t\treturn true;\n \t}\n+\tfor (auto &type : types) {\n+\t\t// sort not supported\n+\t\tif (type.InternalType() == PhysicalType::LIST || type.InternalType() == PhysicalType::STRUCT) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n \t// if the results are not equal,\n \t// sort both chunk collections to ensure the comparison is not order insensitive\n \tvector<OrderType> desc(ColumnCount(), OrderType::DESCENDING);\ndiff --git a/src/execution/operator/join/physical_nested_loop_join.cpp b/src/execution/operator/join/physical_nested_loop_join.cpp\nindex 0ed0b5f32ad6..c1ecc9e426c5 100644\n--- a/src/execution/operator/join/physical_nested_loop_join.cpp\n+++ b/src/execution/operator/join/physical_nested_loop_join.cpp\n@@ -105,6 +105,16 @@ void PhysicalJoin::ConstructMarkJoinResult(DataChunk &join_keys, DataChunk &left\n \t}\n }\n \n+bool PhysicalNestedLoopJoin::IsSupported(const vector<JoinCondition> &conditions) {\n+\tfor (auto &cond : conditions) {\n+\t\tif (cond.left->return_type.InternalType() == PhysicalType::STRUCT ||\n+\t\t    cond.left->return_type.InternalType() == PhysicalType::LIST) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\treturn true;\n+}\n+\n //===--------------------------------------------------------------------===//\n // Sink\n //===--------------------------------------------------------------------===//\ndiff --git a/src/execution/physical_plan/plan_comparison_join.cpp b/src/execution/physical_plan/plan_comparison_join.cpp\nindex 39d4e764dcb6..f3fcda002d98 100644\n--- a/src/execution/physical_plan/plan_comparison_join.cpp\n+++ b/src/execution/physical_plan/plan_comparison_join.cpp\n@@ -14,6 +14,8 @@\n #include \"duckdb/transaction/transaction.hpp\"\n #include \"duckdb/execution/operator/join/physical_hash_join.hpp\"\n #include \"duckdb/common/operator/subtract.hpp\"\n+#include \"duckdb/execution/operator/join/physical_blockwise_nl_join.hpp\"\n+#include \"duckdb/planner/expression_iterator.hpp\"\n \n namespace duckdb {\n \n@@ -157,6 +159,14 @@ void TransformIndexJoin(ClientContext &context, LogicalComparisonJoin &op, Index\n \t}\n }\n \n+static void RewriteJoinCondition(Expression &expr, idx_t offset) {\n+\tif (expr.type == ExpressionType::BOUND_REF) {\n+\t\tauto &ref = (BoundReferenceExpression &)expr;\n+\t\tref.index += offset;\n+\t}\n+\tExpressionIterator::EnumerateChildren(expr, [&](Expression &child) { RewriteJoinCondition(child, offset); });\n+}\n+\n unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalComparisonJoin &op) {\n \t// now visit the children\n \tD_ASSERT(op.children.size() == 2);\n@@ -242,10 +252,17 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalComparison\n \t\t\t// range join: use piecewise merge join\n \t\t\tplan = make_unique<PhysicalPiecewiseMergeJoin>(op, move(left), move(right), move(op.conditions),\n \t\t\t                                               op.join_type, op.estimated_cardinality);\n-\t\t} else {\n+\t\t} else if (PhysicalNestedLoopJoin::IsSupported(op.conditions)) {\n \t\t\t// inequality join: use nested loop\n \t\t\tplan = make_unique<PhysicalNestedLoopJoin>(op, move(left), move(right), move(op.conditions), op.join_type,\n \t\t\t                                           op.estimated_cardinality);\n+\t\t} else {\n+\t\t\tfor (auto &cond : op.conditions) {\n+\t\t\t\tRewriteJoinCondition(*cond.right, left->types.size());\n+\t\t\t}\n+\t\t\tauto condition = JoinCondition::CreateExpression(move(op.conditions));\n+\t\t\tplan = make_unique<PhysicalBlockwiseNLJoin>(op, move(left), move(right), move(condition), op.join_type,\n+\t\t\t                                            op.estimated_cardinality);\n \t\t}\n \t}\n \treturn plan;\ndiff --git a/src/include/duckdb/execution/operator/join/physical_nested_loop_join.hpp b/src/include/duckdb/execution/operator/join/physical_nested_loop_join.hpp\nindex 3dddc751004a..09d73f9a3ef1 100644\n--- a/src/include/duckdb/execution/operator/join/physical_nested_loop_join.hpp\n+++ b/src/include/duckdb/execution/operator/join/physical_nested_loop_join.hpp\n@@ -67,6 +67,8 @@ class PhysicalNestedLoopJoin : public PhysicalComparisonJoin {\n \t\treturn true;\n \t}\n \n+\tstatic bool IsSupported(const vector<JoinCondition> &conditions);\n+\n private:\n \t// resolve joins that output max N elements (SEMI, ANTI, MARK)\n \tvoid ResolveSimpleJoin(ExecutionContext &context, DataChunk &input, DataChunk &chunk, OperatorState &state) const;\ndiff --git a/src/include/duckdb/parser/transformer.hpp b/src/include/duckdb/parser/transformer.hpp\nindex 5ca62368fae8..7b178cc4086b 100644\n--- a/src/include/duckdb/parser/transformer.hpp\n+++ b/src/include/duckdb/parser/transformer.hpp\n@@ -150,6 +150,7 @@ class Transformer {\n \tunique_ptr<ConstantExpression> TransformValue(duckdb_libpgquery::PGValue val);\n \t//! Transform a Postgres operator into an Expression\n \tunique_ptr<ParsedExpression> TransformAExpr(duckdb_libpgquery::PGAExpr *root);\n+\tunique_ptr<ParsedExpression> TransformAExprInternal(duckdb_libpgquery::PGAExpr *root);\n \t//! Transform a Postgres abstract expression into an Expression\n \tunique_ptr<ParsedExpression> TransformExpression(duckdb_libpgquery::PGNode *node);\n \t//! Transform a Postgres function call into an Expression\ndiff --git a/src/include/duckdb/planner/binder.hpp b/src/include/duckdb/planner/binder.hpp\nindex 3a54647dde2e..276670494d6f 100644\n--- a/src/include/duckdb/planner/binder.hpp\n+++ b/src/include/duckdb/planner/binder.hpp\n@@ -45,8 +45,11 @@ struct CorrelatedColumnInfo {\n \tstring name;\n \tidx_t depth;\n \n+\tCorrelatedColumnInfo(ColumnBinding binding, LogicalType type_p, string name_p, idx_t depth)\n+\t    : binding(binding), type(move(type_p)), name(move(name_p)), depth(depth) {\n+\t}\n \texplicit CorrelatedColumnInfo(BoundColumnRefExpression &expr)\n-\t    : binding(expr.binding), type(expr.return_type), name(expr.GetName()), depth(expr.depth) {\n+\t    : CorrelatedColumnInfo(expr.binding, expr.return_type, expr.GetName(), expr.depth) {\n \t}\n \n \tbool operator==(const CorrelatedColumnInfo &rhs) const {\ndiff --git a/src/include/duckdb/planner/joinside.hpp b/src/include/duckdb/planner/joinside.hpp\nindex 9695e7fe8be5..eadc9bef6d44 100644\n--- a/src/include/duckdb/planner/joinside.hpp\n+++ b/src/include/duckdb/planner/joinside.hpp\n@@ -22,6 +22,7 @@ struct JoinCondition {\n \t//! Turns the JoinCondition into an expression; note that this destroys the JoinCondition as the expression inherits\n \t//! the left/right expressions\n \tstatic unique_ptr<Expression> CreateExpression(JoinCondition cond);\n+\tstatic unique_ptr<Expression> CreateExpression(vector<JoinCondition> conditions);\n \n public:\n \tunique_ptr<Expression> left;\ndiff --git a/src/include/duckdb/planner/logical_operator.hpp b/src/include/duckdb/planner/logical_operator.hpp\nindex 7f276e9945ba..7c1153153dbc 100644\n--- a/src/include/duckdb/planner/logical_operator.hpp\n+++ b/src/include/duckdb/planner/logical_operator.hpp\n@@ -24,13 +24,9 @@ namespace duckdb {\n //! logical query tree\n class LogicalOperator {\n public:\n-\texplicit LogicalOperator(LogicalOperatorType type) : type(type) {\n-\t}\n-\tLogicalOperator(LogicalOperatorType type, vector<unique_ptr<Expression>> expressions)\n-\t    : type(type), expressions(move(expressions)) {\n-\t}\n-\tvirtual ~LogicalOperator() {\n-\t}\n+\texplicit LogicalOperator(LogicalOperatorType type);\n+\tLogicalOperator(LogicalOperatorType type, vector<unique_ptr<Expression>> expressions);\n+\tvirtual ~LogicalOperator();\n \n \t//! The type of the logical operator\n \tLogicalOperatorType type;\n@@ -44,9 +40,7 @@ class LogicalOperator {\n \tidx_t estimated_cardinality = 0;\n \n public:\n-\tvirtual vector<ColumnBinding> GetColumnBindings() {\n-\t\treturn {ColumnBinding(0, 0)};\n-\t}\n+\tvirtual vector<ColumnBinding> GetColumnBindings();\n \tstatic vector<ColumnBinding> GenerateColumnBindings(idx_t table_idx, idx_t column_count);\n \tstatic vector<LogicalType> MapTypes(const vector<LogicalType> &types, const vector<idx_t> &projection_map);\n \tstatic vector<ColumnBinding> MapBindings(const vector<ColumnBinding> &types, const vector<idx_t> &projection_map);\n@@ -61,18 +55,9 @@ class LogicalOperator {\n \t//! Debug method: verify that the integrity of expressions & child nodes are maintained\n \tvirtual void Verify();\n \n-\tvoid AddChild(unique_ptr<LogicalOperator> child) {\n-\t\tchildren.push_back(move(child));\n-\t}\n+\tvoid AddChild(unique_ptr<LogicalOperator> child);\n \n-\tvirtual idx_t EstimateCardinality(ClientContext &context) {\n-\t\t// simple estimator, just take the max of the children\n-\t\tidx_t max_cardinality = 0;\n-\t\tfor (auto &child : children) {\n-\t\t\tmax_cardinality = MaxValue(child->EstimateCardinality(context), max_cardinality);\n-\t\t}\n-\t\treturn max_cardinality;\n-\t}\n+\tvirtual idx_t EstimateCardinality(ClientContext &context);\n \n protected:\n \t//! Resolve types for this specific operator\ndiff --git a/src/include/duckdb/planner/subquery/flatten_dependent_join.hpp b/src/include/duckdb/planner/subquery/flatten_dependent_join.hpp\nindex 017fa91f7ff2..022fc2859475 100644\n--- a/src/include/duckdb/planner/subquery/flatten_dependent_join.hpp\n+++ b/src/include/duckdb/planner/subquery/flatten_dependent_join.hpp\n@@ -18,7 +18,8 @@ namespace duckdb {\n //! The FlattenDependentJoins class is responsible for pushing the dependent join down into the plan to create a\n //! flattened subquery\n struct FlattenDependentJoins {\n-\tFlattenDependentJoins(Binder &binder, const vector<CorrelatedColumnInfo> &correlated, bool any_join = false);\n+\tFlattenDependentJoins(Binder &binder, const vector<CorrelatedColumnInfo> &correlated, bool perform_delim = true,\n+\t                      bool any_join = false);\n \n \t//! Detects which Logical Operators have correlated expressions that they are dependent upon, filling the\n \t//! has_correlated_expressions map.\n@@ -37,6 +38,7 @@ struct FlattenDependentJoins {\n \tconst vector<CorrelatedColumnInfo> &correlated_columns;\n \tvector<LogicalType> delim_types;\n \n+\tbool perform_delim;\n \tbool any_join;\n \n private:\ndiff --git a/src/parser/transform/expression/transform_operator.cpp b/src/parser/transform/expression/transform_operator.cpp\nindex 77c9aed24404..29c31985c5a0 100644\n--- a/src/parser/transform/expression/transform_operator.cpp\n+++ b/src/parser/transform/expression/transform_operator.cpp\n@@ -57,7 +57,7 @@ unique_ptr<ParsedExpression> Transformer::TransformBinaryOperator(const string &\n \t}\n }\n \n-unique_ptr<ParsedExpression> Transformer::TransformAExpr(duckdb_libpgquery::PGAExpr *root) {\n+unique_ptr<ParsedExpression> Transformer::TransformAExprInternal(duckdb_libpgquery::PGAExpr *root) {\n \tD_ASSERT(root);\n \tauto name = string((reinterpret_cast<duckdb_libpgquery::PGValue *>(root->name->head->data.ptr_value))->val.str);\n \n@@ -205,4 +205,12 @@ unique_ptr<ParsedExpression> Transformer::TransformAExpr(duckdb_libpgquery::PGAE\n \t}\n }\n \n+unique_ptr<ParsedExpression> Transformer::TransformAExpr(duckdb_libpgquery::PGAExpr *root) {\n+\tauto result = TransformAExprInternal(root);\n+\tif (result) {\n+\t\tresult->query_location = root->location;\n+\t}\n+\treturn result;\n+}\n+\n } // namespace duckdb\ndiff --git a/src/planner/binder/query_node/plan_subquery.cpp b/src/planner/binder/query_node/plan_subquery.cpp\nindex 6ec72d119994..0d8f573fe1de 100644\n--- a/src/planner/binder/query_node/plan_subquery.cpp\n+++ b/src/planner/binder/query_node/plan_subquery.cpp\n@@ -11,6 +11,9 @@\n #include \"duckdb/planner/operator/list.hpp\"\n #include \"duckdb/planner/subquery/flatten_dependent_join.hpp\"\n #include \"duckdb/function/aggregate/distributive_functions.hpp\"\n+#include \"duckdb/planner/operator/logical_window.hpp\"\n+#include \"duckdb/planner/expression/bound_window_expression.hpp\"\n+#include \"duckdb/main/client_config.hpp\"\n \n namespace duckdb {\n \n@@ -133,8 +136,25 @@ static unique_ptr<Expression> PlanUncorrelatedSubquery(Binder &binder, BoundSubq\n }\n \n static unique_ptr<LogicalDelimJoin> CreateDuplicateEliminatedJoin(vector<CorrelatedColumnInfo> &correlated_columns,\n-                                                                  JoinType join_type) {\n+                                                                  JoinType join_type,\n+                                                                  unique_ptr<LogicalOperator> original_plan,\n+                                                                  bool perform_delim) {\n \tauto delim_join = make_unique<LogicalDelimJoin>(join_type);\n+\tif (!perform_delim) {\n+\t\t// if we are not performing a delim join, we push a row_number() OVER() window operator on the LHS\n+\t\t// and perform all duplicate elimination on that row number instead\n+\t\tD_ASSERT(correlated_columns[0].type.id() == LogicalTypeId::BIGINT);\n+\t\tauto window = make_unique<LogicalWindow>(correlated_columns[0].binding.table_index);\n+\t\tauto row_number = make_unique<BoundWindowExpression>(ExpressionType::WINDOW_ROW_NUMBER, LogicalType::BIGINT,\n+\t\t                                                     nullptr, nullptr);\n+\t\trow_number->start = WindowBoundary::UNBOUNDED_PRECEDING;\n+\t\trow_number->end = WindowBoundary::CURRENT_ROW_ROWS;\n+\t\trow_number->alias = \"delim_index\";\n+\t\twindow->expressions.push_back(move(row_number));\n+\t\twindow->AddChild(move(original_plan));\n+\t\toriginal_plan = move(window);\n+\t}\n+\tdelim_join->AddChild(move(original_plan));\n \tfor (idx_t i = 0; i < correlated_columns.size(); i++) {\n \t\tauto &col = correlated_columns[i];\n \t\tdelim_join->duplicate_eliminated_columns.push_back(\n@@ -145,8 +165,9 @@ static unique_ptr<LogicalDelimJoin> CreateDuplicateEliminatedJoin(vector<Correla\n }\n \n static void CreateDelimJoinConditions(LogicalDelimJoin &delim_join, vector<CorrelatedColumnInfo> &correlated_columns,\n-                                      vector<ColumnBinding> bindings, idx_t base_offset) {\n-\tfor (idx_t i = 0; i < correlated_columns.size(); i++) {\n+                                      vector<ColumnBinding> bindings, idx_t base_offset, bool perform_delim) {\n+\tauto col_count = perform_delim ? correlated_columns.size() : 1;\n+\tfor (idx_t i = 0; i < col_count; i++) {\n \t\tauto &col = correlated_columns[i];\n \t\tJoinCondition cond;\n \t\tcond.left = make_unique<BoundColumnRefExpression>(col.name, col.type, col.binding);\n@@ -156,10 +177,50 @@ static void CreateDelimJoinConditions(LogicalDelimJoin &delim_join, vector<Corre\n \t}\n }\n \n+static bool PerformDelimOnType(const LogicalType &type) {\n+\tif (type.InternalType() == PhysicalType::LIST) {\n+\t\treturn false;\n+\t}\n+\tif (type.InternalType() == PhysicalType::STRUCT) {\n+\t\tfor (auto &entry : StructType::GetChildTypes(type)) {\n+\t\t\tif (!PerformDelimOnType(entry.second)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn true;\n+}\n+\n+static bool PerformDuplicateElimination(Binder &binder, vector<CorrelatedColumnInfo> &correlated_columns) {\n+\tif (!ClientConfig::GetConfig(binder.context).enable_optimizer) {\n+\t\t// if optimizations are disabled we always do a delim join\n+\t\treturn true;\n+\t}\n+\tbool perform_delim = true;\n+\tfor (auto &col : correlated_columns) {\n+\t\tif (!PerformDelimOnType(col.type)) {\n+\t\t\tperform_delim = false;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\tif (perform_delim) {\n+\t\treturn true;\n+\t}\n+\tauto binding = ColumnBinding(binder.GenerateTableIndex(), 0);\n+\tauto type = LogicalType::BIGINT;\n+\tauto name = \"delim_index\";\n+\tCorrelatedColumnInfo info(binding, type, name, 0);\n+\tcorrelated_columns.insert(correlated_columns.begin(), move(info));\n+\treturn false;\n+}\n+\n static unique_ptr<Expression> PlanCorrelatedSubquery(Binder &binder, BoundSubqueryExpression &expr,\n                                                      unique_ptr<LogicalOperator> &root,\n                                                      unique_ptr<LogicalOperator> plan) {\n \tauto &correlated_columns = expr.binder->correlated_columns;\n+\t// FIXME: there should be a way of disabling decorrelation for ANY queries as well, but not for now...\n+\tbool perform_delim =\n+\t    expr.subquery_type == SubqueryType::ANY ? true : PerformDuplicateElimination(binder, correlated_columns);\n \tD_ASSERT(expr.IsCorrelated());\n \t// correlated subquery\n \t// for a more in-depth explanation of this code, read the paper \"Unnesting Arbitrary Subqueries\"\n@@ -176,15 +237,15 @@ static unique_ptr<Expression> PlanCorrelatedSubquery(Binder &binder, BoundSubque\n \t\t// NULL values are equal in this join because we join on the correlated columns ONLY\n \t\t// and e.g. in the query: SELECT (SELECT 42 FROM integers WHERE i1.i IS NULL LIMIT 1) FROM integers i1;\n \t\t// the input value NULL will generate the value 42, and we need to join NULL on the LHS with NULL on the RHS\n-\t\tauto delim_join = CreateDuplicateEliminatedJoin(correlated_columns, JoinType::SINGLE);\n-\n \t\t// the left side is the original plan\n \t\t// this is the side that will be duplicate eliminated and pushed into the RHS\n-\t\tdelim_join->AddChild(move(root));\n+\t\tauto delim_join =\n+\t\t    CreateDuplicateEliminatedJoin(correlated_columns, JoinType::SINGLE, move(root), perform_delim);\n+\n \t\t// the right side initially is a DEPENDENT join between the duplicate eliminated scan and the subquery\n \t\t// HOWEVER: we do not explicitly create the dependent join\n \t\t// instead, we eliminate the dependent join by pushing it down into the right side of the plan\n-\t\tFlattenDependentJoins flatten(binder, correlated_columns);\n+\t\tFlattenDependentJoins flatten(binder, correlated_columns, perform_delim);\n \n \t\t// first we check which logical operators have correlated expressions in the first place\n \t\tflatten.DetectCorrelatedExpressions(plan.get());\n@@ -197,7 +258,7 @@ static unique_ptr<Expression> PlanCorrelatedSubquery(Binder &binder, BoundSubque\n \t\tauto plan_columns = dependent_join->GetColumnBindings();\n \n \t\t// now create the join conditions\n-\t\tCreateDelimJoinConditions(*delim_join, correlated_columns, plan_columns, flatten.delim_offset);\n+\t\tCreateDelimJoinConditions(*delim_join, correlated_columns, plan_columns, flatten.delim_offset, perform_delim);\n \t\tdelim_join->AddChild(move(dependent_join));\n \t\troot = move(delim_join);\n \t\t// finally push the BoundColumnRefExpression referring to the data element returned by the join\n@@ -208,12 +269,10 @@ static unique_ptr<Expression> PlanCorrelatedSubquery(Binder &binder, BoundSubque\n \t\t// correlated EXISTS query\n \t\t// this query is similar to the correlated SCALAR query, except we use a MARK join here\n \t\tidx_t mark_index = binder.GenerateTableIndex();\n-\t\tauto delim_join = CreateDuplicateEliminatedJoin(correlated_columns, JoinType::MARK);\n+\t\tauto delim_join = CreateDuplicateEliminatedJoin(correlated_columns, JoinType::MARK, move(root), perform_delim);\n \t\tdelim_join->mark_index = mark_index;\n-\t\t// LHS\n-\t\tdelim_join->AddChild(move(root));\n \t\t// RHS\n-\t\tFlattenDependentJoins flatten(binder, correlated_columns);\n+\t\tFlattenDependentJoins flatten(binder, correlated_columns, perform_delim);\n \t\tflatten.DetectCorrelatedExpressions(plan.get());\n \t\tauto dependent_join = flatten.PushDownDependentJoin(move(plan));\n \n@@ -221,7 +280,7 @@ static unique_ptr<Expression> PlanCorrelatedSubquery(Binder &binder, BoundSubque\n \t\tauto plan_columns = dependent_join->GetColumnBindings();\n \n \t\t// now we create the join conditions between the dependent join and the original table\n-\t\tCreateDelimJoinConditions(*delim_join, correlated_columns, plan_columns, flatten.delim_offset);\n+\t\tCreateDelimJoinConditions(*delim_join, correlated_columns, plan_columns, flatten.delim_offset, perform_delim);\n \t\tdelim_join->AddChild(move(dependent_join));\n \t\troot = move(delim_join);\n \t\t// finally push the BoundColumnRefExpression referring to the marker\n@@ -237,10 +296,8 @@ static unique_ptr<Expression> PlanCorrelatedSubquery(Binder &binder, BoundSubque\n \t\t// as the MARK join has one extra join condition (the original condition, of the ANY expression, e.g.\n \t\t// [i=ANY(...)])\n \t\tidx_t mark_index = binder.GenerateTableIndex();\n-\t\tauto delim_join = CreateDuplicateEliminatedJoin(correlated_columns, JoinType::MARK);\n+\t\tauto delim_join = CreateDuplicateEliminatedJoin(correlated_columns, JoinType::MARK, move(root), perform_delim);\n \t\tdelim_join->mark_index = mark_index;\n-\t\t// LHS\n-\t\tdelim_join->AddChild(move(root));\n \t\t// RHS\n \t\tFlattenDependentJoins flatten(binder, correlated_columns, true);\n \t\tflatten.DetectCorrelatedExpressions(plan.get());\n@@ -250,7 +307,7 @@ static unique_ptr<Expression> PlanCorrelatedSubquery(Binder &binder, BoundSubque\n \t\tauto plan_columns = dependent_join->GetColumnBindings();\n \n \t\t// now we create the join conditions between the dependent join and the original table\n-\t\tCreateDelimJoinConditions(*delim_join, correlated_columns, plan_columns, flatten.delim_offset);\n+\t\tCreateDelimJoinConditions(*delim_join, correlated_columns, plan_columns, flatten.delim_offset, perform_delim);\n \t\t// add the actual condition based on the ANY/ALL predicate\n \t\tJoinCondition compare_cond;\n \t\tcompare_cond.left = move(expr.child);\n@@ -274,9 +331,11 @@ class RecursiveSubqueryPlanner : public LogicalOperatorVisitor {\n \tvoid VisitOperator(LogicalOperator &op) override {\n \t\tif (!op.children.empty()) {\n \t\t\troot = move(op.children[0]);\n+\t\t\tD_ASSERT(root);\n \t\t\tVisitOperatorExpressions(op);\n \t\t\top.children[0] = move(root);\n \t\t\tfor (idx_t i = 0; i < op.children.size(); i++) {\n+\t\t\t\tD_ASSERT(op.children[i]);\n \t\t\t\tVisitOperator(*op.children[i]);\n \t\t\t}\n \t\t}\ndiff --git a/src/planner/joinside.cpp b/src/planner/joinside.cpp\nindex dc4b46c4c4ea..846b70623966 100644\n--- a/src/planner/joinside.cpp\n+++ b/src/planner/joinside.cpp\n@@ -2,6 +2,7 @@\n \n #include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n #include \"duckdb/planner/expression/bound_comparison_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_conjunction_expression.hpp\"\n #include \"duckdb/planner/expression/bound_subquery_expression.hpp\"\n #include \"duckdb/planner/expression_iterator.hpp\"\n \n@@ -12,6 +13,21 @@ unique_ptr<Expression> JoinCondition::CreateExpression(JoinCondition cond) {\n \treturn move(bound_comparison);\n }\n \n+unique_ptr<Expression> JoinCondition::CreateExpression(vector<JoinCondition> conditions) {\n+\tunique_ptr<Expression> result;\n+\tfor (auto &cond : conditions) {\n+\t\tauto expr = CreateExpression(move(cond));\n+\t\tif (!result) {\n+\t\t\tresult = move(expr);\n+\t\t} else {\n+\t\t\tauto conj =\n+\t\t\t    make_unique<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND, move(expr), move(result));\n+\t\t\tresult = move(conj);\n+\t\t}\n+\t}\n+\treturn result;\n+}\n+\n JoinSide JoinSide::CombineJoinSide(JoinSide left, JoinSide right) {\n \tif (left == JoinSide::NONE) {\n \t\treturn right;\ndiff --git a/src/planner/logical_operator.cpp b/src/planner/logical_operator.cpp\nindex ba67af22393f..0c626f12ba2e 100644\n--- a/src/planner/logical_operator.cpp\n+++ b/src/planner/logical_operator.cpp\n@@ -7,6 +7,20 @@\n \n namespace duckdb {\n \n+LogicalOperator::LogicalOperator(LogicalOperatorType type) : type(type) {\n+}\n+\n+LogicalOperator::LogicalOperator(LogicalOperatorType type, vector<unique_ptr<Expression>> expressions)\n+    : type(type), expressions(move(expressions)) {\n+}\n+\n+LogicalOperator::~LogicalOperator() {\n+}\n+\n+vector<ColumnBinding> LogicalOperator::GetColumnBindings() {\n+\treturn {ColumnBinding(0, 0)};\n+}\n+\n string LogicalOperator::GetName() const {\n \treturn LogicalOperatorToString(type);\n }\n@@ -110,6 +124,20 @@ void LogicalOperator::Verify() {\n #endif\n }\n \n+void LogicalOperator::AddChild(unique_ptr<LogicalOperator> child) {\n+\tD_ASSERT(child);\n+\tchildren.push_back(move(child));\n+}\n+\n+idx_t LogicalOperator::EstimateCardinality(ClientContext &context) {\n+\t// simple estimator, just take the max of the children\n+\tidx_t max_cardinality = 0;\n+\tfor (auto &child : children) {\n+\t\tmax_cardinality = MaxValue(child->EstimateCardinality(context), max_cardinality);\n+\t}\n+\treturn max_cardinality;\n+}\n+\n void LogicalOperator::Print() {\n \tPrinter::Print(ToString());\n }\ndiff --git a/src/planner/subquery/flatten_dependent_join.cpp b/src/planner/subquery/flatten_dependent_join.cpp\nindex 5f482f3f7378..1e00cb002171 100644\n--- a/src/planner/subquery/flatten_dependent_join.cpp\n+++ b/src/planner/subquery/flatten_dependent_join.cpp\n@@ -14,8 +14,8 @@\n namespace duckdb {\n \n FlattenDependentJoins::FlattenDependentJoins(Binder &binder, const vector<CorrelatedColumnInfo> &correlated,\n-                                             bool any_join)\n-    : binder(binder), correlated_columns(correlated), any_join(any_join) {\n+                                             bool perform_delim, bool any_join)\n+    : binder(binder), correlated_columns(correlated), perform_delim(perform_delim), any_join(any_join) {\n \tfor (idx_t i = 0; i < correlated_columns.size(); i++) {\n \t\tauto &col = correlated_columns[i];\n \t\tcorrelated_map[col.binding] = i;\n@@ -115,8 +115,9 @@ unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal\n \t\t// now we add all the columns of the delim_scan to the projection list\n \t\tauto proj = (LogicalProjection *)plan.get();\n \t\tfor (idx_t i = 0; i < correlated_columns.size(); i++) {\n+\t\t\tauto &col = correlated_columns[i];\n \t\t\tauto colref = make_unique<BoundColumnRefExpression>(\n-\t\t\t    correlated_columns[i].type, ColumnBinding(base_binding.table_index, base_binding.column_index + i));\n+\t\t\t    col.name, col.type, ColumnBinding(base_binding.table_index, base_binding.column_index + i));\n \t\t\tplan->expressions.push_back(move(colref));\n \t\t}\n \n@@ -137,15 +138,42 @@ unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal\n \t\tRewriteCorrelatedExpressions rewriter(base_binding, correlated_map);\n \t\trewriter.VisitOperator(*plan);\n \t\t// now we add all the columns of the delim_scan to the grouping operators AND the projection list\n-\t\tfor (idx_t i = 0; i < correlated_columns.size(); i++) {\n+\t\tidx_t delim_table_index;\n+\t\tidx_t delim_column_offset;\n+\t\tidx_t delim_data_offset;\n+\t\tauto new_group_count = perform_delim ? correlated_columns.size() : 1;\n+\t\tfor (idx_t i = 0; i < new_group_count; i++) {\n+\t\t\tauto &col = correlated_columns[i];\n \t\t\tauto colref = make_unique<BoundColumnRefExpression>(\n-\t\t\t    correlated_columns[i].type, ColumnBinding(base_binding.table_index, base_binding.column_index + i));\n+\t\t\t    col.name, col.type, ColumnBinding(base_binding.table_index, base_binding.column_index + i));\n \t\t\tfor (auto &set : aggr.grouping_sets) {\n \t\t\t\tset.insert(aggr.groups.size());\n \t\t\t}\n \t\t\taggr.groups.push_back(move(colref));\n \t\t}\n-\t\tif (aggr.groups.size() == correlated_columns.size()) {\n+\t\tif (!perform_delim) {\n+\t\t\t// if we are not performing the duplicate elimination, we have only added the row_id column to the grouping\n+\t\t\t// operators in this case, we push a FIRST aggregate for each of the remaining expressions\n+\t\t\tdelim_table_index = aggr.aggregate_index;\n+\t\t\tdelim_column_offset = aggr.expressions.size();\n+\t\t\tdelim_data_offset = aggr.groups.size();\n+\t\t\tfor (idx_t i = 0; i < correlated_columns.size(); i++) {\n+\t\t\t\tauto &col = correlated_columns[i];\n+\t\t\t\tauto first_aggregate = FirstFun::GetFunction(col.type);\n+\t\t\t\tauto colref = make_unique<BoundColumnRefExpression>(\n+\t\t\t\t    col.name, col.type, ColumnBinding(base_binding.table_index, base_binding.column_index + i));\n+\t\t\t\tvector<unique_ptr<Expression>> aggr_children;\n+\t\t\t\taggr_children.push_back(move(colref));\n+\t\t\t\tauto first_fun = make_unique<BoundAggregateExpression>(move(first_aggregate), move(aggr_children),\n+\t\t\t\t                                                       nullptr, nullptr, false);\n+\t\t\t\taggr.expressions.push_back(move(first_fun));\n+\t\t\t}\n+\t\t} else {\n+\t\t\tdelim_table_index = aggr.group_index;\n+\t\t\tdelim_column_offset = aggr.groups.size() - correlated_columns.size();\n+\t\t\tdelim_data_offset = aggr.groups.size();\n+\t\t}\n+\t\tif (aggr.groups.size() == new_group_count) {\n \t\t\t// we have to perform a LEFT OUTER JOIN between the result of this aggregate and the delim scan\n \t\t\t// FIXME: this does not always have to be a LEFT OUTER JOIN, depending on whether aggr.expressions return\n \t\t\t// NULL or a value\n@@ -161,13 +189,12 @@ unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal\n \t\t\tauto delim_scan = make_unique<LogicalDelimGet>(left_index, delim_types);\n \t\t\tjoin->children.push_back(move(delim_scan));\n \t\t\tjoin->children.push_back(move(plan));\n-\t\t\tfor (idx_t i = 0; i < correlated_columns.size(); i++) {\n+\t\t\tfor (idx_t i = 0; i < new_group_count; i++) {\n+\t\t\t\tauto &col = correlated_columns[i];\n \t\t\t\tJoinCondition cond;\n-\t\t\t\tcond.left =\n-\t\t\t\t    make_unique<BoundColumnRefExpression>(correlated_columns[i].type, ColumnBinding(left_index, i));\n+\t\t\t\tcond.left = make_unique<BoundColumnRefExpression>(col.name, col.type, ColumnBinding(left_index, i));\n \t\t\t\tcond.right = make_unique<BoundColumnRefExpression>(\n-\t\t\t\t    correlated_columns[i].type,\n-\t\t\t\t    ColumnBinding(aggr.group_index, (aggr.groups.size() - correlated_columns.size()) + i));\n+\t\t\t\t    correlated_columns[i].type, ColumnBinding(delim_table_index, delim_column_offset + i));\n \t\t\t\tcond.comparison = ExpressionType::COMPARE_NOT_DISTINCT_FROM;\n \t\t\t\tjoin->conditions.push_back(move(cond));\n \t\t\t}\n@@ -183,16 +210,15 @@ unique_ptr<LogicalOperator> FlattenDependentJoins::PushDownDependentJoinInternal\n \t\t\t\t}\n \t\t\t}\n \t\t\t// now we update the delim_index\n-\n \t\t\tbase_binding.table_index = left_index;\n \t\t\tthis->delim_offset = base_binding.column_index = 0;\n \t\t\tthis->data_offset = 0;\n \t\t\treturn move(join);\n \t\t} else {\n \t\t\t// update the delim_index\n-\t\t\tbase_binding.table_index = aggr.group_index;\n-\t\t\tthis->delim_offset = base_binding.column_index = aggr.groups.size() - correlated_columns.size();\n-\t\t\tthis->data_offset = aggr.groups.size();\n+\t\t\tbase_binding.table_index = delim_table_index;\n+\t\t\tthis->delim_offset = base_binding.column_index = delim_column_offset;\n+\t\t\tthis->data_offset = delim_data_offset;\n \t\t\treturn plan;\n \t\t}\n \t}\n",
  "test_patch": "diff --git a/test/sql/subquery/complex/correlated_list_aggregate.test b/test/sql/subquery/complex/correlated_list_aggregate.test\nnew file mode 100644\nindex 000000000000..ce0a53639d6c\n--- /dev/null\n+++ b/test/sql/subquery/complex/correlated_list_aggregate.test\n@@ -0,0 +1,273 @@\n+# name: test/sql/subquery/complex/correlated_list_aggregate.test\n+# description: Test correlated aggregate subqueries\n+# group: [complex]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE lists(l INTEGER[]);\n+\n+statement ok\n+INSERT INTO lists VALUES (ARRAY[1]), (ARRAY[2]), (ARRAY[3]), (NULL), (ARRAY[NULL]::INT[]);\n+\n+# aggregate with correlation in final projection\n+query II\n+SELECT l, (SELECT MIN(l[1])+i1.l[1] FROM lists) FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t2\n+[2]\t3\n+[3]\t4\n+[NULL]\tNULL\n+\n+# aggregate with correlation inside aggregation\n+query II\n+SELECT l, (SELECT MIN(l[1]+2*i1.l[1]) FROM lists) FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t3\n+[2]\t5\n+[3]\t7\n+[NULL]\tNULL\n+\n+query IRR\n+SELECT l, SUM(l[1]), (SELECT SUM(l[1])+SUM(i1.l[1]) FROM lists) FROM lists i1 GROUP BY l ORDER BY l;\n+----\n+NULL\tNULL\tNULL\n+[1]\t1.000000\t7.000000\n+[2]\t2.000000\t8.000000\n+[3]\t3.000000\t9.000000\n+[NULL]\tNULL\tNULL\n+\n+query IRR\n+SELECT l, SUM(l[1]), (SELECT SUM(l[1])+COUNT(i1.l[1]) FROM lists) FROM lists i1 GROUP BY l ORDER BY l;\n+----\n+NULL\tNULL\t6.000000\n+[1]\t1.000000\t7.000000\n+[2]\t2.000000\t7.000000\n+[3]\t3.000000\t7.000000\n+[NULL]\tNULL\t6.000000\n+\n+# correlated COUNT(*)\n+query II\n+SELECT l, (SELECT COUNT(*) FROM lists i2 WHERE i2.l[1]>i1.l[1]) FROM lists i1 ORDER BY l;\n+----\n+NULL\t0\n+[1]\t2\n+[2]\t1\n+[3]\t0\n+[NULL]\t0\n+\n+# aggregate with correlation inside aggregation\n+query II\n+SELECT l, (SELECT MIN(l[1]+2*i1.l[1]) FROM lists) FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t3\n+[2]\t5\n+[3]\t7\n+[NULL]\tNULL\n+\n+# aggregate ONLY inside subquery\n+query R\n+SELECT (SELECT SUM(i1.l[1])) FROM lists i1;\n+----\n+6.000000\n+\n+# aggregate ONLY inside subquery, with column reference outside of subquery\n+query IR\n+SELECT MIN(l[1]), (SELECT SUM(i1.l[1])) FROM lists i1;\n+----\n+1\t6.000000\n+\n+# this will fail, because \"l[1]\" is not an aggregate but the SUM(i1.l[1]) turns this query into an aggregate\n+statement error\n+SELECT l, (SELECT SUM(i1.l[1])) FROM lists i1;\n+\n+statement error\n+SELECT l[1]+1, (SELECT SUM(i1.l[1])) FROM lists i1;\n+\n+query IR\n+SELECT MIN(l[1]), (SELECT SUM(i1.l[1])) FROM lists i1;\n+----\n+1\t6.000000\n+\n+query RR\n+SELECT (SELECT SUM(i1.l[1])), (SELECT SUM(i1.l[1])) FROM lists i1;\n+----\n+6.000000\t6.000000\n+\n+# subquery inside aggregation\n+query RR\n+SELECT SUM(l[1]), SUM((SELECT l[1] FROM lists WHERE l[1]=i1.l[1])) FROM lists i1;\n+----\n+6.000000\t6.000000\n+\n+query RR\n+SELECT SUM(l[1]), (SELECT SUM(l[1]) FROM lists WHERE l[1]>SUM(i1.l[1])) FROM lists i1;\n+----\n+6.000000\tNULL\n+\n+# subquery with aggregation inside aggregation should fail\n+statement error\n+SELECT SUM((SELECT SUM(l[1]))) FROM lists\n+\n+# aggregate with correlation in filter\n+query II\n+SELECT l, (SELECT MIN(l[1]) FROM lists WHERE l[1]>i1.l[1]) FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t2\n+[2]\t3\n+[3]\tNULL\n+[NULL]\tNULL\n+\n+# aggregate with correlation in both filter and projection\n+query II\n+SELECT l, (SELECT MIN(l[1])+i1.l[1] FROM lists WHERE l[1]>i1.l[1]) FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t3\n+[2]\t5\n+[3]\tNULL\n+[NULL]\tNULL\n+\n+# aggregate with correlation in GROUP BY\n+query II\n+SELECT l, (SELECT MIN(l[1]) FROM lists GROUP BY i1.l[1]) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\t1\n+[1]\t1\n+[2]\t1\n+[3]\t1\n+[NULL]\t1\n+\n+# aggregate with correlation in HAVING clause\n+query II\n+SELECT l, (SELECT l[1] FROM lists GROUP BY l[1] HAVING l[1]=i1.l[1]) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t1\n+[2]\t2\n+[3]\t3\n+[NULL]\tNULL\n+\n+# correlated subquery in HAVING\n+query IR\n+SELECT i1.l, SUM(l[1]) FROM lists i1 GROUP BY i1.l HAVING SUM(l[1])=(SELECT MIN(l[1]) FROM lists WHERE l[1]<>i1.l[1]+1) ORDER BY 1;\n+----\n+[1]\t1.000000\n+\n+query IR\n+SELECT l[1] % 2 AS j, SUM(l[1]) FROM lists i1 GROUP BY j HAVING SUM(l[1])=(SELECT SUM(l[1]) FROM lists WHERE l[1]<>j+1) ORDER BY 1;\n+----\n+1\t4.000000\n+\n+# aggregate query with non-aggregate subquery without group by\n+query R\n+SELECT (SELECT l[1]+SUM(i1.l[1]) FROM lists WHERE l[1]=1 LIMIT 1) FROM lists i1;\n+----\n+7.000000\n+\n+query R\n+SELECT (SELECT SUM(l[1])+SUM(i1.l[1]) FROM lists) FROM lists i1 ORDER BY 1;\n+----\n+12.000000\n+\n+# aggregate query with non-aggregate subquery with group by\n+query IR\n+SELECT l, (SELECT l[1]+SUM(i1.l[1]) FROM lists WHERE l[1]=1) FROM lists i1 GROUP BY l ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t2.000000\n+[2]\t3.000000\n+[3]\t4.000000\n+[NULL]\tNULL\n+\n+# subquery inside aggregate\n+query R\n+SELECT SUM((SELECT l[1]+i1.l[1] FROM lists WHERE l[1]=1)) FROM lists i1;\n+----\n+9.000000\n+\n+query IRR\n+SELECT l, SUM(i1.l[1]), (SELECT SUM(i1.l[1]) FROM lists) AS k FROM lists i1 GROUP BY l ORDER BY l;\n+----\n+NULL\tNULL\tNULL\n+[1]\t1.000000\t1.000000\n+[2]\t2.000000\t2.000000\n+[3]\t3.000000\t3.000000\n+[NULL]\tNULL\tNULL\n+\n+# aggregation of both entries inside subquery\n+# aggregate on group inside subquery\n+query IR\n+SELECT i1.l AS j, (SELECT SUM(j[1]+l[1]) FROM lists) AS k FROM lists i1 GROUP BY j ORDER BY j;\n+----\n+NULL\tNULL\n+[1]\t9.000000\n+[2]\t12.000000\n+[3]\t15.000000\n+[NULL]\tNULL\n+\n+query R\n+SELECT (SELECT SUM(i1.l[1]*l[1]) FROM lists) FROM lists i1 ORDER BY l;\n+----\n+NULL\n+6.000000\n+12.000000\n+18.000000\n+NULL\n+\n+# ORDER BY correlated subquery\n+query IR\n+SELECT l, SUM(i1.l[1]) FROM lists i1 GROUP BY l ORDER BY (SELECT SUM(i1.l[1]) FROM lists);\n+----\n+NULL\tNULL\n+[NULL]\tNULL\n+[1]\t1.000000\n+[2]\t2.000000\n+[3]\t3.000000\n+\n+# LIMIT 0 on correlated subquery\n+query IR\n+SELECT l, SUM((SELECT SUM(l[1])*i1.l[1] FROM lists LIMIT 0)) AS k FROM lists i1 GROUP BY l ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\tNULL\n+[2]\tNULL\n+[3]\tNULL\n+[NULL]\tNULL\n+\n+# GROUP BY correlated subquery\n+query IR\n+SELECT (SELECT l[1]+i1.l[1] FROM lists WHERE l[1]=1) AS k, SUM(l[1]) AS j FROM lists i1 GROUP BY k ORDER BY 1;\n+----\n+NULL\tNULL\n+2\t1.000000\n+3\t2.000000\n+4\t3.000000\n+\n+# correlated subquery in WHERE\n+query R\n+SELECT SUM(l[1]) FROM lists i1 WHERE l[1]>(SELECT (l[1]+i1.l[1])/2 FROM lists WHERE l[1]=1);\n+----\n+5.000000\n+\n+# correlated aggregate in WHERE\n+query R\n+SELECT SUM(l[1]) FROM lists i1 WHERE l[1]>(SELECT (SUM(l[1])+i1.l[1])/2 FROM lists WHERE l[1]=1);\n+----\n+5.000000\n+\n+# use scalar subquery as argument to ALL/ANY\n+query IT\n+SELECT l, (SELECT MIN(l[1]) FROM lists WHERE l[1]=i1.l[1]) >= ALL(SELECT l[1] FROM lists WHERE l[1] IS NOT NULL) FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t0\n+[2]\t0\n+[3]\t1\n+[NULL]\tNULL\n+\ndiff --git a/test/sql/subquery/complex/correlated_list_any_join.test b/test/sql/subquery/complex/correlated_list_any_join.test\nnew file mode 100644\nindex 000000000000..6702ff8e59c6\n--- /dev/null\n+++ b/test/sql/subquery/complex/correlated_list_any_join.test\n@@ -0,0 +1,79 @@\n+# name: test/sql/subquery/complex/correlated_list_any_join.test\n+# description: Test subqueries on ANY join with correlated lists\n+# group: [complex]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE lists(l INTEGER[]);\n+\n+statement ok\n+INSERT INTO lists VALUES (ARRAY[1]), (ARRAY[2]), (ARRAY[3]), (NULL);\n+\n+# correlated expressions in inner/left/right joins\n+query II\n+SELECT l, l IN (SELECT i1.l FROM (SELECT * FROM lists i1 WHERE i1.l=lists.l) i1 JOIN generate_series(1, 2, 1) tbl(s) ON i1.l=ARRAY[tbl.s]) FROM lists ORDER BY l NULLS LAST;\n+----\n+[1]\tTrue\n+[2]\tTrue\n+[3]\tFalse\n+NULL\tFalse\n+\n+query I\n+SELECT l IN (SELECT i1.l FROM (SELECT * FROM lists i1 WHERE i1.l=lists.l) i1 LEFT JOIN generate_series(1, 2, 1) tbl(s) ON i1.l=ARRAY[tbl.s]) FROM lists ORDER BY l NULLS LAST;\n+----\n+true\n+true\n+true\n+false\n+\n+query I\n+SELECT l IN (SELECT i1.l FROM (SELECT * FROM lists i1 WHERE i1.l=lists.l) i1 RIGHT JOIN generate_series(1, 2, 1) tbl(s) ON i1.l=ARRAY[tbl.s]) FROM lists ORDER BY l NULLS LAST;\n+----\n+true\n+true\n+NULL\n+NULL\n+\n+# other way around\n+query I\n+SELECT l IN (SELECT i1.l FROM generate_series(1, 2, 1) tbl(s) LEFT JOIN (SELECT * FROM lists i1 WHERE i1.l=lists.l) i1 ON i1.l=ARRAY[tbl.s]) FROM lists ORDER BY l NULLS LAST;\n+----\n+true\n+true\n+NULL\n+NULL\n+\n+query I\n+SELECT l IN (SELECT i1.l FROM generate_series(1, 2, 1) tbl(s) RIGHT JOIN (SELECT * FROM lists i1 WHERE i1.l=lists.l) i1 ON i1.l=ARRAY[tbl.s]) FROM lists ORDER BY l NULLS LAST;\n+----\n+true\n+true\n+true\n+false\n+\n+# complex join condition\n+query I\n+SELECT l IN (SELECT i1.l FROM (SELECT * FROM lists i1 WHERE i1.l IS NOT DISTINCT FROM lists.l) i1 JOIN generate_series(1, 2, 1) tbl(s) ON i1.l=ARRAY[tbl.s] OR (i1.l IS NULL AND tbl.s IS NULL)) FROM lists ORDER BY l NULLS LAST;\n+----\n+true\n+true\n+false\n+false\n+\n+query I\n+SELECT l IN (SELECT i1.l FROM (SELECT * FROM lists i1 WHERE i1.l IS NOT DISTINCT FROM lists.l) i1 LEFT JOIN generate_series(1, 2, 1) tbl(s) ON i1.l=ARRAY[tbl.s] OR (i1.l IS NULL AND tbl.s IS NULL)) FROM lists ORDER BY l NULLS LAST;\n+----\n+true\n+true\n+true\n+NULL\n+\n+query I\n+SELECT l IN (SELECT i1.l FROM (SELECT * FROM lists i1 WHERE i1.l IS NOT DISTINCT FROM lists.l) i1 RIGHT JOIN generate_series(1, 2, 1) tbl(s) ON i1.l=ARRAY[tbl.s] OR (i1.l IS NULL AND tbl.s IS NULL)) FROM lists ORDER BY l NULLS LAST;\n+----\n+true\n+true\n+NULL\n+NULL\ndiff --git a/test/sql/subquery/complex/expensive_deduplication_3593.test b/test/sql/subquery/complex/expensive_deduplication_3593.test\nnew file mode 100644\nindex 000000000000..8cbabd92f1d5\n--- /dev/null\n+++ b/test/sql/subquery/complex/expensive_deduplication_3593.test\n@@ -0,0 +1,75 @@\n+# name: test/sql/subquery/complex/expensive_deduplication_3593.test\n+# description: Issue #3593: Macros causes crash: memory consumption or recursion or something\n+# group: [complex]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query I\n+SELECT\n+(\n+  select count(*) as value\n+  FROM (\n+    SELECT UNNEST(array_agg(distinct id))\n+  ) a\n+)\n+  as total_seats\n+FROM (\n+SELECT gen_random_uuid() id, 1 as val FROM generate_series(0, 160)\n+) as m;\n+----\n+161\n+\n+query II\n+SELECT\n+z%2 AS k,\n+(\n+  select count(*) as value\n+  FROM (\n+    SELECT UNNEST(array_agg(distinct id))\n+  ) a\n+)\n+  as total_seats\n+FROM (\n+SELECT row_number() over () AS z, gen_random_uuid() id, 1 as val FROM generate_series(0, 160)\n+) as m\n+GROUP BY k\n+ORDER BY k;\n+----\n+0\t80\n+1\t81\n+\n+# disable verification for these queries, they are too slow to run without the deduplication\n+statement ok\n+PRAGMA disable_verification\n+\n+query I\n+SELECT\n+(\n+  select count(*) as value\n+  FROM (\n+    SELECT UNNEST(array_agg(distinct id))\n+  ) a\n+)\n+  as total_seats\n+FROM (\n+SELECT gen_random_uuid() id, 1 as val FROM generate_series(0, 100000)\n+) as m;\n+----\n+100001\n+\n+query I\n+SELECT\n+(\n+  select sum(a.val) as value\n+  FROM (\n+    SELECT UNNEST(list(distinct {key:m.id, val: m.val})) a\n+  ) x\n+)\n+  as total_seats\n+FROM (\n+SELECT gen_random_uuid() id, 1 as val FROM range(0, 100000)\n+) as m\n+cross join (select * FROM range(0,3)) as r\n+----\n+100000\ndiff --git a/test/sql/subquery/complex/nested_correlated_list.test b/test/sql/subquery/complex/nested_correlated_list.test\nnew file mode 100644\nindex 000000000000..1d0f4ef04ec4\n--- /dev/null\n+++ b/test/sql/subquery/complex/nested_correlated_list.test\n@@ -0,0 +1,329 @@\n+# name: test/sql/subquery/complex/nested_correlated_list.test\n+# description: Test nested correlated list subqueries\n+# group: [complex]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE lists(l INTEGER[]);\n+\n+statement ok\n+INSERT INTO lists VALUES (ARRAY[1]), (ARRAY[2]), (ARRAY[3]), (NULL);\n+\n+# nested correlated queries\n+query II\n+SELECT l, (SELECT (SELECT 42+i1.l[1])+42+i1.l[1]) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t86\n+[2]\t88\n+[3]\t90\n+\n+query II\n+SELECT l, (SELECT (SELECT (SELECT (SELECT 42+i1.l[1])++i1.l[1])+42+i1.l[1])+42+i1.l[1]) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t130\n+[2]\t134\n+[3]\t138\n+\n+query IR\n+SELECT l, (SELECT (SELECT i1.l[1]+SUM(i2.l[1])) FROM lists i2) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t7.000000\n+[2]\t8.000000\n+[3]\t9.000000\n+\n+# correlated query inside uncorrelated query\n+query II\n+SELECT l, (SELECT (SELECT (SELECT (SELECT i1.l[1]+i1.l[1]+i1.l[1]+i1.l[1]+i1.l[1])))) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t5\n+[2]\t10\n+[3]\t15\n+\n+query IR\n+SELECT l, (SELECT SUM(l[1])+(SELECT 42+i1.l[1]) FROM lists) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t49.000000\n+[2]\t50.000000\n+[3]\t51.000000\n+\n+query IR\n+SELECT l, (SELECT ((SELECT ((SELECT ((SELECT SUM(l[1])+SUM(i4.l[1])+SUM(i3.l[1])+SUM(i2.l[1])+SUM(i1.l[1]) FROM lists i5)) FROM lists i4)) FROM lists i3)) FROM lists i2) AS j FROM lists i1 GROUP BY l ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t25.000000\n+[2]\t26.000000\n+[3]\t27.000000\n+\n+query II\n+SELECT l, (SELECT (SELECT (SELECT (SELECT i1.l[1]+i1.l[1]+i1.l[1]+i1.l[1]+i1.l[1]+i2.l[1]) FROM lists i2 WHERE i2.l=i1.l))) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t6\n+[2]\t12\n+[3]\t18\n+\n+query R\n+SELECT (SELECT (SELECT SUM(i1.l[1])+SUM(i2.l[1])+SUM(i3.l[1]) FROM lists i3) FROM lists i2) FROM lists i1 ORDER BY 1\n+----\n+18.000000\n+\n+# explicit join on subquery\n+query IR\n+SELECT l, (SELECT SUM(s1.l[1]) FROM lists s1 INNER JOIN lists s2 ON (SELECT i1.l[1]+s1.l[1])=(SELECT i1.l[1]+s2.l[1])) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t6.000000\n+[2]\t6.000000\n+[3]\t6.000000\n+\n+# nested aggregate queries\n+query IRR\n+SELECT l, SUM(l[1]), (SELECT (SELECT SUM(l[1])+SUM(i1.l[1])+SUM(i2.l[1]) FROM lists) FROM lists i2) FROM lists i1 GROUP BY l ORDER BY l;\n+----\n+NULL\tNULL\tNULL\n+[1]\t1.000000\t13.000000\n+[2]\t2.000000\t14.000000\n+[3]\t3.000000\t15.000000\n+\n+# correlated ANY inside subquery\n+query IR\n+SELECT l, (SELECT SUM(ss1.l[1]) FROM (SELECT l FROM lists s1 WHERE l[1]>ANY(SELECT l[1] FROM lists WHERE l<>s1.l)) ss1) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\t5.000000\n+[1]\t5.000000\n+[2]\t5.000000\n+[3]\t5.000000\n+\n+query IR\n+SELECT l, (SELECT SUM(ss2.l[1]) FROM (SELECT l FROM lists s1 WHERE l=i1.l AND l=ANY(SELECT l FROM lists WHERE l=s1.l)) ss2) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t1.000000\n+[2]\t2.000000\n+[3]\t3.000000\n+\n+# left outer join on correlated subquery within subquery\n+# not supported yet: left outer join on JoinSide::BOTH\n+statement error\n+SELECT l, (SELECT SUM(s1.l[1]) FROM lists s1 LEFT OUTER JOIN lists s2 ON (SELECT i1.l[1]+s1.l[1])=(SELECT i1.l[1]+s2.l[1])) AS j FROM lists i1 ORDER BY l;\n+\n+# REQUIRE(CHECK_COLUMN(result, 0, {Value(), 1, 2, 3}));\n+# REQUIRE(CHECK_COLUMN(result, 1, {6, 6, 6, 6}));\n+query IR\n+SELECT l, (SELECT SUM(ss1.l[1])+SUM(ss2.l[1]) FROM (SELECT l FROM lists s1 WHERE l>ANY(SELECT l FROM lists WHERE l<>s1.l)) ss1 LEFT OUTER JOIN (SELECT l FROM lists s1 WHERE l=ANY(SELECT l FROM lists WHERE l=s1.l)) ss2 ON ss1.l=ss2.l) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\t10.000000\n+[1]\t10.000000\n+[2]\t10.000000\n+[3]\t10.000000\n+\n+# left outer join with correlation on LHS\n+query IR\n+SELECT l, (SELECT SUM(s1.l[1]) FROM (SELECT l FROM lists WHERE l=i1.l) s1 LEFT OUTER JOIN lists s2 ON s1.l=s2.l) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t1.000000\n+[2]\t2.000000\n+[3]\t3.000000\n+\n+query IR\n+SELECT l, (SELECT SUM(s1.l[1]) FROM (SELECT l FROM lists WHERE l<>i1.l) s1 LEFT OUTER JOIN lists s2 ON s1.l=s2.l) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t5.000000\n+[2]\t4.000000\n+[3]\t3.000000\n+\n+# left outer join with correlation on RHS\n+query IR\n+SELECT l, (SELECT SUM(s2.l[1]) FROM lists s1 LEFT OUTER JOIN (SELECT l FROM lists WHERE l=i1.l) s2 ON s1.l=s2.l) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t1.000000\n+[2]\t2.000000\n+[3]\t3.000000\n+\n+query IR\n+SELECT l, (SELECT SUM(s2.l[1]) FROM lists s1 LEFT OUTER JOIN (SELECT l FROM lists WHERE l<>i1.l) s2 ON s1.l=s2.l) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t5.000000\n+[2]\t4.000000\n+[3]\t3.000000\n+\n+query IR\n+SELECT l, (SELECT SUM(ss2.l[1]) FROM (SELECT l FROM lists s1 WHERE CASE WHEN (l=i1.l AND l=ANY(SELECT l FROM lists WHERE l=s1.l)) THEN true ELSE false END) ss2) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t1.000000\n+[2]\t2.000000\n+[3]\t3.000000\n+\n+query IR\n+SELECT l, (SELECT SUM(ss2.l[1]) FROM (SELECT l FROM lists s1 WHERE l=i1.l AND l=ANY(SELECT l FROM lists WHERE l=s1.l)) ss2) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t1.000000\n+[2]\t2.000000\n+[3]\t3.000000\n+\n+query IR\n+SELECT l, (SELECT SUM(ss2.l[1]) FROM (SELECT l FROM lists s1 WHERE l=i1.l) ss2) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t1.000000\n+[2]\t2.000000\n+[3]\t3.000000\n+\n+query IR\n+SELECT l, (SELECT SUM(ss2.l[1]) FROM (SELECT l FROM lists s1 WHERE l=ANY(SELECT l FROM lists WHERE l=s1.l)) ss2) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\t6.000000\n+[1]\t6.000000\n+[2]\t6.000000\n+[3]\t6.000000\n+\n+query IT\n+SELECT l, (SELECT l=ANY(SELECT l FROM lists WHERE l=s1.l) FROM lists s1 WHERE l=i1.l) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t1\n+[2]\t1\n+[3]\t1\n+\n+query IR\n+SELECT l, (SELECT SUM(ss2.l[1]) FROM (SELECT l FROM lists s1 WHERE l=i1.l OR l=ANY(SELECT l FROM lists WHERE l=s1.l)) ss2) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\t6.000000\n+[1]\t6.000000\n+[2]\t6.000000\n+[3]\t6.000000\n+\n+query IR\n+SELECT l, (SELECT SUM(ss2.l[1]) FROM (SELECT l FROM lists s1 WHERE CASE WHEN (l=i1.l AND l=ANY(SELECT l FROM lists WHERE l=s1.l)) THEN true ELSE false END) ss2) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t1.000000\n+[2]\t2.000000\n+[3]\t3.000000\n+\n+query IR\n+SELECT l, (SELECT SUM(ss2.l[1]) FROM (SELECT l FROM lists s1 WHERE l=i1.l AND EXISTS(SELECT l FROM lists WHERE l=s1.l)) ss2) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t1.000000\n+[2]\t2.000000\n+[3]\t3.000000\n+\n+# complex left outer join with correlation on RHS\n+query IR\n+SELECT l, (SELECT SUM(ss1.l[1]) FROM (SELECT l FROM lists s1 WHERE l>ANY(SELECT l FROM lists WHERE l<>s1.l)) ss1) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\t5.000000\n+[1]\t5.000000\n+[2]\t5.000000\n+[3]\t5.000000\n+\n+query IR\n+SELECT l, (SELECT SUM(ss1.l[1]) FROM (SELECT l FROM lists s1 WHERE l>ANY(SELECT l FROM lists WHERE l<>s1.l)) ss1 LEFT OUTER JOIN (SELECT l FROM lists s1 WHERE l=i1.l AND l=ANY(SELECT l FROM lists WHERE l=s1.l)) ss2 ON ss1.l=ss2.l) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\t5.000000\n+[1]\t5.000000\n+[2]\t5.000000\n+[3]\t5.000000\n+\n+query IR\n+SELECT l, (SELECT SUM(ss2.l[1]) FROM (SELECT l FROM lists s1 WHERE l>ANY(SELECT l FROM lists WHERE l<>s1.l)) ss1 LEFT OUTER JOIN (SELECT l FROM lists s1 WHERE l=i1.l AND l=ANY(SELECT l FROM lists WHERE l=s1.l)) ss2 ON ss1.l=ss2.l) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\tNULL\n+[2]\t2.000000\n+[3]\t3.000000\n+\n+query IR\n+SELECT l, (SELECT SUM(ss1.l[1])+SUM(ss2.l[1]) FROM (SELECT l FROM lists s1 WHERE l>ANY(SELECT l FROM lists WHERE l<>s1.l)) ss1 LEFT OUTER JOIN (SELECT l FROM lists s1 WHERE l=i1.l AND l=ANY(SELECT l FROM lists WHERE l=s1.l)) ss2 ON ss1.l=ss2.l) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\tNULL\n+[2]\t7.000000\n+[3]\t8.000000\n+\n+# complex left outer join with correlation on LHS\n+query IR\n+SELECT l, (SELECT SUM(ss1.l[1])+SUM(ss2.l[1]) FROM (SELECT l FROM lists s1 WHERE l=i1.l AND l>ANY(SELECT l FROM lists WHERE l<>s1.l)) ss1 LEFT OUTER JOIN (SELECT l FROM lists s1 WHERE l=ANY(SELECT l FROM lists WHERE l=s1.l)) ss2 ON ss1.l=ss2.l) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\tNULL\n+[2]\t4.000000\n+[3]\t6.000000\n+\n+# complex left outer join with correlation on both sides\n+query IR\n+SELECT l, (SELECT SUM(ss1.l[1])+SUM(ss2.l[1]) FROM (SELECT l FROM lists s1 WHERE l=i1.l AND l>ANY(SELECT l FROM lists WHERE l<>s1.l)) ss1 LEFT OUTER JOIN (SELECT l FROM lists s1 WHERE l<>i1.l OR l=ANY(SELECT l FROM lists WHERE l=s1.l)) ss2 ON ss1.l=ss2.l) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\tNULL\n+[2]\t4.000000\n+[3]\t6.000000\n+\n+# test correlated queries with correlated expressions inside FROM clause\n+# subquery\n+query II\n+SELECT l, (SELECT * FROM (SELECT (SELECT 42+i1.l[1])) s1) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t43\n+[2]\t44\n+[3]\t45\n+\n+# cross product\n+query II\n+SELECT l, (SELECT s1.k+s2.k FROM (SELECT (SELECT 42+i1.l[1]) AS k) s1, (SELECT (SELECT 42+i1.l[1]) AS k) s2) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t86\n+[2]\t88\n+[3]\t90\n+\n+# join\n+query II\n+SELECT l, (SELECT s1.k+s2.k FROM (SELECT (SELECT 42+i1.l[1]) AS k) s1 LEFT OUTER JOIN (SELECT (SELECT 42+i1.l[1]) AS k) s2 ON s1.k=s2.k) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t86\n+[2]\t88\n+[3]\t90\n+\n+# IN list inside correlated subquery\n+query IT\n+SELECT l, (SELECT i1.l[1] IN (1, 2, 3, 4, 5, 6, 7, 8)) AS j FROM lists i1 ORDER BY l;\n+----\n+NULL\tNULL\n+[1]\t1\n+[2]\t1\n+[3]\t1\n+\n+# nested correlated subqueries with multiple aggregate parameters\n+query R\n+SELECT (SELECT (SELECT COVAR_POP(i1.l[1], i3.l[1]) FROM lists i3) FROM lists i2 LIMIT 1) FROM lists i1 ORDER BY 1\n+----\n+NULL\n+0.000000\n+0.000000\n+0.000000\n+\n+query R\n+SELECT (SELECT (SELECT COVAR_POP(i2.l[1], i3.l[1]) FROM lists i3) FROM lists i2 LIMIT 1) FROM lists i1 ORDER BY 1\n+----\n+0.000000\n+0.000000\n+0.000000\n+0.000000\n+\ndiff --git a/test/sql/subquery/complex/nested_unnest_subquery.test b/test/sql/subquery/complex/nested_unnest_subquery.test\nnew file mode 100644\nindex 000000000000..943e928f2286\n--- /dev/null\n+++ b/test/sql/subquery/complex/nested_unnest_subquery.test\n@@ -0,0 +1,34 @@\n+# name: test/sql/subquery/complex/nested_unnest_subquery.test\n+# description: Test nested correlated unnest subqueries\n+# group: [complex]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+CREATE TABLE nested_lists(l INTEGER[][]);\n+\n+statement ok\n+INSERT INTO nested_lists VALUES (ARRAY[ARRAY[0], ARRAY[1]]), (ARRAY[ARRAY[2], ARRAY[NULL, 3]]), (ARRAY[ARRAY[4, 5], ARRAY[6, 7], ARRAY[], ARRAY[8]]), (NULL), (ARRAY[NULL]::INT[][]);\n+\n+query I\n+SELECT UNNEST(l) FROM nested_lists\n+----\n+[0]\n+[1]\n+[2]\n+[NULL, 3]\n+[4, 5]\n+[6, 7]\n+[]\n+[8]\n+NULL\n+\n+query II\n+SELECT l, (SELECT SUM(a) FROM (SELECT UNNEST(b) AS a FROM (SELECT UNNEST(l) AS b))) FROM nested_lists ORDER BY l\n+----\n+NULL\tNULL\n+[[0], [1]]\t1\n+[[2], [NULL, 3]]\t5\n+[[4, 5], [6, 7], [], [8]]\t30\n+[NULL]\tNULL\ndiff --git a/test/sql/subquery/scalar/test_correlated_side_effects.test b/test/sql/subquery/scalar/test_correlated_side_effects.test\nnew file mode 100644\nindex 000000000000..b22351cb1608\n--- /dev/null\n+++ b/test/sql/subquery/scalar/test_correlated_side_effects.test\n@@ -0,0 +1,18 @@\n+# name: test/sql/subquery/scalar/test_correlated_side_effects.test\n+# description: Test correlated subqueries with side effects\n+# group: [scalar]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# FIXME: we should not perform duplicate elimination for subqueries that have side-effects\n+\n+mode skip\n+\n+query I\n+SELECT COUNT(DISTINCT\n+\t(SELECT concat(gen_random_uuid()::VARCHAR, r::VARCHAR))\n+  ) as total_seats\n+FROM (SELECT 1 FROM generate_series(1, 100, 1)) AS t(r)\n+----\n+100\n\\ No newline at end of file\n",
  "problem_statement": "Macros causes crash:  memory consumption or recursion or something\nThe following code is used by Malloy to produce symmetric sums (sums that work regardless of join patterns).  This code works when I set the range to a relatively low number.  Raising the number to something larger (like 16000) will cause my machine to crash.  I'm not sure what is actually happening.\r\n\r\n```\r\ncreate macro sum_distinct(l) as  (\r\n  with cte as (\r\n    select unnest(l) x\r\n  )\r\n  select sum(x.val) as value FROM cte\r\n);\r\n\r\nselect\r\n  sum_distinct(list(distinct {key:m.id, val: m.val}))\r\n      as  unique_sum\r\nfrom (\r\n    select gen_random_uuid() id, 1 as val from range(0, 160) -- works for small number, big number crash my machine\r\n) as m\r\ncross join (select * FROM range(0,3)) as r\r\n```\nMacros causes crash:  memory consumption or recursion or something\nThe following code is used by Malloy to produce symmetric sums (sums that work regardless of join patterns).  This code works when I set the range to a relatively low number.  Raising the number to something larger (like 16000) will cause my machine to crash.  I'm not sure what is actually happening.\r\n\r\n```\r\ncreate macro sum_distinct(l) as  (\r\n  with cte as (\r\n    select unnest(l) x\r\n  )\r\n  select sum(x.val) as value FROM cte\r\n);\r\n\r\nselect\r\n  sum_distinct(list(distinct {key:m.id, val: m.val}))\r\n      as  unique_sum\r\nfrom (\r\n    select gen_random_uuid() id, 1 as val from range(0, 160) -- works for small number, big number crash my machine\r\n) as m\r\ncross join (select * FROM range(0,3)) as r\r\n```\n",
  "hints_text": "Here is a slightly better test case...\r\n\r\n```\r\n  SELECT\r\n    -- sum_distinct(list(distinct {key:m.id, val: m.val}))\r\n    (\r\n      select sum(a.val) as value\r\n      FROM (\r\n        SELECT UNNEST(list(distinct {key:m.id, val: m.val})) a\r\n      ) x\r\n    )\r\n      as total_seats\r\n  FROM (\r\n    SELECT gen_random_uuid() id, 1 as val FROM range(0, 1600)\r\n  ) as m\r\n  cross join (select * FROM range(0,3)) as r\r\n`\r\n```\nAh I was trying the first one and it runs forever!\nIt is still running forever, but the memory usage is not high (< 1GB) and there are only two cores in use. Does it happen on the current master?\nI don't know if this is helpful but on cloud shell it terminates, but the number of rows give non-linear results..\r\n![image](https://user-images.githubusercontent.com/1093458/167219285-050e9530-6e16-4b6b-9d58-4b903eb7e798.png)\r\n\nMaybe it is running once per row in the table or something?  Performance looks geometric.\nInterestingly, the results are correct.\n> Maybe it is running once per row in the table or something? Performance looks geometric.\r\n\r\nMight be. I was looking at the 16000 case, but was taking a lot more than 331.7s\nMaybe @lnkuiper can have a look?\nI've investigated this a bit, and as you already found out, this issue does not have anything to do with macro's.\r\n\r\nI've managed to run this query:\r\n```sql\r\nSELECT\r\n(\r\n  select sum(a.val) as value\r\n  FROM (\r\n    SELECT UNNEST(list(distinct {key:m.id, val: m.val})) a\r\n  ) x\r\n)\r\n  as total_seats\r\nFROM (\r\nSELECT gen_random_uuid() id, 1 as val FROM range(0, 1600)\r\n) as m\r\ncross join (select * FROM range(0,3)) as r\r\n```\r\nIn around 3.8 seconds on my machine. When I increased from 1600 to 3200, the query took around 36 seconds.\r\n\r\nWith `pragma enable_profiling;`, we see the culprit (plan snippet because the entire plan is a bit too big):\r\n```\r\n             ...\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \r\n\u2502       HASH_GROUP_BY       \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \r\n\u2502             #0            \u2502                             \r\n\u2502          sum(#1)          \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \r\n\u2502             1             \u2502                             \r\n\u2502          (35.75s)         \u2502                             \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \r\n\u2502         PROJECTION        \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \r\n\u2502             #1            \u2502                             \r\n\u2502  struct_extract(a, 'val') \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \r\n\u2502            3200           \u2502                             \r\n\u2502          (0.00s)          \u2502                             \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \r\n\u2502         PROJECTION        \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \r\n\u2502             a             \u2502                             \r\n\u2502             #0            \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \r\n\u2502            3200           \u2502                             \r\n\u2502          (0.00s)          \u2502                             \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \r\n\u2502           UNNEST          \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \r\n\u2502            3200           \u2502                             \r\n\u2502          (0.00s)          \u2502                             \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \r\n\u2502       CROSS_PRODUCT       \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \r\n\u2502             1             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \r\n\u2502          (0.00s)          \u2502              \u2502              \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502              \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502         DELIM_SCAN        \u2502\u2502         DUMMY_SCAN        \u2502\r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502             0             \u2502\u2502             1             \u2502\r\n\u2502          (0.00s)          \u2502\u2502          (0.00s)          \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nThe aggregation takes a long time, and almost all time is spent on `RowOperations::Match`.\r\n\r\nWe're grouping by a List column. In the hash table, we store data in a row format. For every tuple that is inserted, we compare the inserted list with the list that is already in the hash table. This requires serializing and deserializing the list from and to row format. This is taking all the time.\r\n\r\nUsing `memcmp` instead would be faster, but the incoming list is not yet in row format, so this is probably not an option. The main thing is that doing a distinct aggregation on a list column is generally going to be slow, because comparing lists is much, much more costly than comparing, say, an integer.\r\n\nI am not sure if I understand the query well enough to understand if the optimizer can re-order things and prevent the list distinct.\r\n\r\nThis is the plan:\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                                                                                                                              \r\n\u2502         PROJECTION        \u2502                                                                                                                                                                              \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                                                                                                              \r\n\u2502        total_seats        \u2502                                                                                                                                                                              \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                                                                                                              \r\n\u2502             1             \u2502                                                                                                                                                                              \r\n\u2502          (0.00s)          \u2502                                                                                                                                                                              \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                                                                                                                                                                           \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                                                                                                                              \r\n\u2502         DELIM_JOIN        \u2502                                                                                                                                                                              \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                                                                                                              \r\n\u2502           SINGLE          \u2502                                                                                                                                                                              \r\n\u2502 list(DISTINCT struct_pack \u2502                                                                                                                                                                              \r\n\u2502(key, val)) IS NOT DISTINCT\u2502                                                                                                                                                                              \r\n\u2502     FROM list(DISTINCT    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \r\n\u2502   struct_pack(key, val))  \u2502                                           \u2502                                                                                                                   \u2502              \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                           \u2502                                                                                                                   \u2502              \r\n\u2502             0             \u2502                                           \u2502                                                                                                                   \u2502              \r\n\u2502          (0.00s)          \u2502                                           \u2502                                                                                                                   \u2502              \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                           \u2502                                                                                                                   \u2502                                           \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502       HASH_GROUP_BY       \u2502                             \u2502         HASH_JOIN         \u2502                                                                                       \u2502       HASH_GROUP_BY       \u2502\r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502     list(DISTINCT #0)     \u2502                             \u2502           SINGLE          \u2502                                                                                       \u2502             #0            \u2502\r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502 list(DISTINCT struct_pack \u2502                                                                                       \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502             1             \u2502                             \u2502(key, val)) IS NOT DISTINCT\u2502                                                                                       \u2502             2             \u2502\r\n\u2502          (0.00s)          \u2502                             \u2502     FROM list(DISTINCT    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                        \u2502          (0.00s)          \u2502\r\n\u2502                           \u2502                             \u2502   struct_pack(key, val))  \u2502              \u2502                                                                        \u2502                           \u2502\r\n\u2502                           \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502              \u2502                                                                        \u2502                           \u2502\r\n\u2502                           \u2502                             \u2502             1             \u2502              \u2502                                                                        \u2502                           \u2502\r\n\u2502                           \u2502                             \u2502          (0.01s)          \u2502              \u2502                                                                        \u2502                           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502                                                                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                                       \r\n\u2502         PROJECTION        \u2502                             \u2502         CHUNK_SCAN        \u2502\u2502         PROJECTION        \u2502                                                                                       \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \r\n\u2502   struct_pack(key, val)   \u2502                             \u2502             1             \u2502\u2502           value           \u2502                                                                                       \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502          (0.00s)          \u2502\u2502             #2            \u2502                                                                                       \r\n\u2502            9600           \u2502                             \u2502                           \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \r\n\u2502          (0.00s)          \u2502                             \u2502                           \u2502\u2502             1             \u2502                                                                                       \r\n\u2502                           \u2502                             \u2502                           \u2502\u2502          (0.00s)          \u2502                                                                                       \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                                                                                    \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                                       \r\n\u2502       CROSS_PRODUCT       \u2502                                                          \u2502         HASH_JOIN         \u2502                                                                                       \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                          \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \r\n\u2502            9600           \u2502                                                          \u2502           RIGHT           \u2502                                                                                       \r\n\u2502          (0.00s)          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                           \u2502 #0 IS NOT DISTINCT FROM #0\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                           \r\n\u2502                           \u2502              \u2502                                           \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                           \u2502                                           \r\n\u2502                           \u2502              \u2502                                           \u2502             1             \u2502                                           \u2502                                           \r\n\u2502                           \u2502              \u2502                                           \u2502          (0.01s)          \u2502                                           \u2502                                           \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502                                           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                           \u2502                                                                        \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \r\n\u2502         PROJECTION        \u2502\u2502         PROJECTION        \u2502                             \u2502       HASH_GROUP_BY       \u2502                             \u2502         DELIM_SCAN        \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \r\n\u2502             id            \u2502\u2502             42            \u2502                             \u2502             #0            \u2502                             \u2502             0             \u2502                             \r\n\u2502            val            \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502          sum(#1)          \u2502                             \u2502          (0.00s)          \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\u2502             3             \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502                           \u2502                             \r\n\u2502            3200           \u2502\u2502          (0.00s)          \u2502                             \u2502             1             \u2502                             \u2502                           \u2502                             \r\n\u2502          (0.00s)          \u2502\u2502                           \u2502                             \u2502          (35.75s)         \u2502                             \u2502                           \u2502                             \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                          \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                                       \r\n\u2502         PROJECTION        \u2502\u2502         PROJECTION        \u2502                             \u2502         PROJECTION        \u2502                                                                                       \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \r\n\u2502             0             \u2502\u2502             0             \u2502                             \u2502             #1            \u2502                                                                                       \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502  struct_extract(a, 'val') \u2502                                                                                       \r\n\u2502            3200           \u2502\u2502             3             \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \r\n\u2502          (0.00s)          \u2502\u2502          (0.00s)          \u2502                             \u2502            3200           \u2502                                                                                       \r\n\u2502                           \u2502\u2502                           \u2502                             \u2502          (0.00s)          \u2502                                                                                       \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                                                                                    \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                                       \r\n\u2502           RANGE           \u2502\u2502           RANGE           \u2502                             \u2502         PROJECTION        \u2502                                                                                       \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \r\n\u2502            3200           \u2502\u2502             3             \u2502                             \u2502             a             \u2502                                                                                       \r\n\u2502          (0.00s)          \u2502\u2502          (0.00s)          \u2502                             \u2502             #0            \u2502                                                                                       \r\n\u2502                           \u2502\u2502                           \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \r\n\u2502                           \u2502\u2502                           \u2502                             \u2502            3200           \u2502                                                                                       \r\n\u2502                           \u2502\u2502                           \u2502                             \u2502          (0.00s)          \u2502                                                                                       \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                                                                                    \r\n                                                                                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                                       \r\n                                                                                       \u2502           UNNEST          \u2502                                                                                       \r\n                                                                                       \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \r\n                                                                                       \u2502            3200           \u2502                                                                                       \r\n                                                                                       \u2502          (0.00s)          \u2502                                                                                       \r\n                                                                                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                                                                                    \r\n                                                                                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                                       \r\n                                                                                       \u2502       CROSS_PRODUCT       \u2502                                                                                       \r\n                                                                                       \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \r\n                                                                                       \u2502             1             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                        \r\n                                                                                       \u2502          (0.00s)          \u2502              \u2502                                                                        \r\n                                                                                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502                                                                                                     \r\n                                                                                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                          \r\n                                                                                       \u2502         DELIM_SCAN        \u2502\u2502         DUMMY_SCAN        \u2502                                                          \r\n                                                                                       \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                          \r\n                                                                                       \u2502             0             \u2502\u2502             1             \u2502                                                          \r\n                                                                                       \u2502          (0.00s)          \u2502\u2502          (0.00s)          \u2502                                                          \r\n                                                                                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n> We're grouping by a List column.\r\n\r\nSo I think that is the problem. We should produce the  aggregate LIST(distinct id), and then run the UNNEST calculation only once (per result grouping). \r\n\r\nHere is an even more simple use case.\r\n```\r\nSELECT\r\n(\r\n  select count(*) as value\r\n  FROM (\r\n    SELECT UNNEST(list(distinct id)) a\r\n  )\r\n)\r\n  as total_seats\r\nFROM (\r\nSELECT gen_random_uuid() id, 1 as val FROM range(0, 160)\r\n) as m\r\n```\r\n\r\nIn this case the (SELECT COUNT ...) is not a correlated subquery, but a subquery that is run AFTER the list(distinct).  BigQuery makes you do this in a UDF, not sure about postgres.\nPG will run this query, with some minor syntactic changes:\r\n\r\n```sql\r\nSELECT\r\n(\r\n  select count(*) as value\r\n  FROM (\r\n    SELECT UNNEST(array_agg(distinct id))\r\n  ) a\r\n)\r\n  as total_seats\r\nFROM (\r\nSELECT gen_random_uuid() id, 1 as val FROM generate_series(0, 160)\r\n) as m;\r\n```\nThe PG plan seems much more sane:\r\n```\r\n Aggregate  (cost=4.03..4.24 rows=1 width=8) (actual time=0.873..0.874 rows=1 loops=1)\r\n   ->  Function Scan on generate_series  (cost=0.00..2.02 rows=161 width=20) (actual time=0.093..0.655 rows=161 loops=1)\r\n   SubPlan 1\r\n     ->  Aggregate  (cost=0.19..0.20 rows=1 width=8) (actual time=0.062..0.063 rows=1 loops=1)\r\n           ->  ProjectSet  (cost=0.00..0.07 rows=10 width=16) (actual time=0.005..0.037 rows=161 loops=1)\r\n                 ->  Result  (cost=0.00..0.01 rows=1 width=0) (actual time=0.001..0.001 rows=1 loops=1)\r\n```\r\n\r\nI think we should be able to create a better plan as well, but optimizer code is a bit daunting to me.\n@hawkfish Ignore that comment.  Pilot error.\nHere is a slightly better test case...\r\n\r\n```\r\n  SELECT\r\n    -- sum_distinct(list(distinct {key:m.id, val: m.val}))\r\n    (\r\n      select sum(a.val) as value\r\n      FROM (\r\n        SELECT UNNEST(list(distinct {key:m.id, val: m.val})) a\r\n      ) x\r\n    )\r\n      as total_seats\r\n  FROM (\r\n    SELECT gen_random_uuid() id, 1 as val FROM range(0, 1600)\r\n  ) as m\r\n  cross join (select * FROM range(0,3)) as r\r\n`\r\n```\nAh I was trying the first one and it runs forever!\nIt is still running forever, but the memory usage is not high (< 1GB) and there are only two cores in use. Does it happen on the current master?\nI don't know if this is helpful but on cloud shell it terminates, but the number of rows give non-linear results..\r\n![image](https://user-images.githubusercontent.com/1093458/167219285-050e9530-6e16-4b6b-9d58-4b903eb7e798.png)\r\n\nMaybe it is running once per row in the table or something?  Performance looks geometric.\nInterestingly, the results are correct.\n> Maybe it is running once per row in the table or something? Performance looks geometric.\r\n\r\nMight be. I was looking at the 16000 case, but was taking a lot more than 331.7s\nMaybe @lnkuiper can have a look?\nI've investigated this a bit, and as you already found out, this issue does not have anything to do with macro's.\r\n\r\nI've managed to run this query:\r\n```sql\r\nSELECT\r\n(\r\n  select sum(a.val) as value\r\n  FROM (\r\n    SELECT UNNEST(list(distinct {key:m.id, val: m.val})) a\r\n  ) x\r\n)\r\n  as total_seats\r\nFROM (\r\nSELECT gen_random_uuid() id, 1 as val FROM range(0, 1600)\r\n) as m\r\ncross join (select * FROM range(0,3)) as r\r\n```\r\nIn around 3.8 seconds on my machine. When I increased from 1600 to 3200, the query took around 36 seconds.\r\n\r\nWith `pragma enable_profiling;`, we see the culprit (plan snippet because the entire plan is a bit too big):\r\n```\r\n             ...\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \r\n\u2502       HASH_GROUP_BY       \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \r\n\u2502             #0            \u2502                             \r\n\u2502          sum(#1)          \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \r\n\u2502             1             \u2502                             \r\n\u2502          (35.75s)         \u2502                             \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \r\n\u2502         PROJECTION        \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \r\n\u2502             #1            \u2502                             \r\n\u2502  struct_extract(a, 'val') \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \r\n\u2502            3200           \u2502                             \r\n\u2502          (0.00s)          \u2502                             \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \r\n\u2502         PROJECTION        \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \r\n\u2502             a             \u2502                             \r\n\u2502             #0            \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \r\n\u2502            3200           \u2502                             \r\n\u2502          (0.00s)          \u2502                             \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \r\n\u2502           UNNEST          \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \r\n\u2502            3200           \u2502                             \r\n\u2502          (0.00s)          \u2502                             \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \r\n\u2502       CROSS_PRODUCT       \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \r\n\u2502             1             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \r\n\u2502          (0.00s)          \u2502              \u2502              \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502              \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502         DELIM_SCAN        \u2502\u2502         DUMMY_SCAN        \u2502\r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502             0             \u2502\u2502             1             \u2502\r\n\u2502          (0.00s)          \u2502\u2502          (0.00s)          \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nThe aggregation takes a long time, and almost all time is spent on `RowOperations::Match`.\r\n\r\nWe're grouping by a List column. In the hash table, we store data in a row format. For every tuple that is inserted, we compare the inserted list with the list that is already in the hash table. This requires serializing and deserializing the list from and to row format. This is taking all the time.\r\n\r\nUsing `memcmp` instead would be faster, but the incoming list is not yet in row format, so this is probably not an option. The main thing is that doing a distinct aggregation on a list column is generally going to be slow, because comparing lists is much, much more costly than comparing, say, an integer.\r\n\nI am not sure if I understand the query well enough to understand if the optimizer can re-order things and prevent the list distinct.\r\n\r\nThis is the plan:\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                                                                                                                              \r\n\u2502         PROJECTION        \u2502                                                                                                                                                                              \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                                                                                                              \r\n\u2502        total_seats        \u2502                                                                                                                                                                              \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                                                                                                              \r\n\u2502             1             \u2502                                                                                                                                                                              \r\n\u2502          (0.00s)          \u2502                                                                                                                                                                              \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                                                                                                                                                                           \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                                                                                                                              \r\n\u2502         DELIM_JOIN        \u2502                                                                                                                                                                              \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                                                                                                              \r\n\u2502           SINGLE          \u2502                                                                                                                                                                              \r\n\u2502 list(DISTINCT struct_pack \u2502                                                                                                                                                                              \r\n\u2502(key, val)) IS NOT DISTINCT\u2502                                                                                                                                                                              \r\n\u2502     FROM list(DISTINCT    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \r\n\u2502   struct_pack(key, val))  \u2502                                           \u2502                                                                                                                   \u2502              \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                           \u2502                                                                                                                   \u2502              \r\n\u2502             0             \u2502                                           \u2502                                                                                                                   \u2502              \r\n\u2502          (0.00s)          \u2502                                           \u2502                                                                                                                   \u2502              \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                           \u2502                                                                                                                   \u2502                                           \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502       HASH_GROUP_BY       \u2502                             \u2502         HASH_JOIN         \u2502                                                                                       \u2502       HASH_GROUP_BY       \u2502\r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502     list(DISTINCT #0)     \u2502                             \u2502           SINGLE          \u2502                                                                                       \u2502             #0            \u2502\r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502 list(DISTINCT struct_pack \u2502                                                                                       \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\r\n\u2502             1             \u2502                             \u2502(key, val)) IS NOT DISTINCT\u2502                                                                                       \u2502             2             \u2502\r\n\u2502          (0.00s)          \u2502                             \u2502     FROM list(DISTINCT    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                        \u2502          (0.00s)          \u2502\r\n\u2502                           \u2502                             \u2502   struct_pack(key, val))  \u2502              \u2502                                                                        \u2502                           \u2502\r\n\u2502                           \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502              \u2502                                                                        \u2502                           \u2502\r\n\u2502                           \u2502                             \u2502             1             \u2502              \u2502                                                                        \u2502                           \u2502\r\n\u2502                           \u2502                             \u2502          (0.01s)          \u2502              \u2502                                                                        \u2502                           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502                                                                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                                       \r\n\u2502         PROJECTION        \u2502                             \u2502         CHUNK_SCAN        \u2502\u2502         PROJECTION        \u2502                                                                                       \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \r\n\u2502   struct_pack(key, val)   \u2502                             \u2502             1             \u2502\u2502           value           \u2502                                                                                       \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502          (0.00s)          \u2502\u2502             #2            \u2502                                                                                       \r\n\u2502            9600           \u2502                             \u2502                           \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \r\n\u2502          (0.00s)          \u2502                             \u2502                           \u2502\u2502             1             \u2502                                                                                       \r\n\u2502                           \u2502                             \u2502                           \u2502\u2502          (0.00s)          \u2502                                                                                       \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                                                                                    \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                                       \r\n\u2502       CROSS_PRODUCT       \u2502                                                          \u2502         HASH_JOIN         \u2502                                                                                       \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                          \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \r\n\u2502            9600           \u2502                                                          \u2502           RIGHT           \u2502                                                                                       \r\n\u2502          (0.00s)          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                           \u2502 #0 IS NOT DISTINCT FROM #0\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                           \r\n\u2502                           \u2502              \u2502                                           \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                           \u2502                                           \r\n\u2502                           \u2502              \u2502                                           \u2502             1             \u2502                                           \u2502                                           \r\n\u2502                           \u2502              \u2502                                           \u2502          (0.01s)          \u2502                                           \u2502                                           \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502                                           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                           \u2502                                                                        \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \r\n\u2502         PROJECTION        \u2502\u2502         PROJECTION        \u2502                             \u2502       HASH_GROUP_BY       \u2502                             \u2502         DELIM_SCAN        \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \r\n\u2502             id            \u2502\u2502             42            \u2502                             \u2502             #0            \u2502                             \u2502             0             \u2502                             \r\n\u2502            val            \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502          sum(#1)          \u2502                             \u2502          (0.00s)          \u2502                             \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\u2502             3             \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502                           \u2502                             \r\n\u2502            3200           \u2502\u2502          (0.00s)          \u2502                             \u2502             1             \u2502                             \u2502                           \u2502                             \r\n\u2502          (0.00s)          \u2502\u2502                           \u2502                             \u2502          (35.75s)         \u2502                             \u2502                           \u2502                             \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                          \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                                       \r\n\u2502         PROJECTION        \u2502\u2502         PROJECTION        \u2502                             \u2502         PROJECTION        \u2502                                                                                       \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \r\n\u2502             0             \u2502\u2502             0             \u2502                             \u2502             #1            \u2502                                                                                       \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502  struct_extract(a, 'val') \u2502                                                                                       \r\n\u2502            3200           \u2502\u2502             3             \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \r\n\u2502          (0.00s)          \u2502\u2502          (0.00s)          \u2502                             \u2502            3200           \u2502                                                                                       \r\n\u2502                           \u2502\u2502                           \u2502                             \u2502          (0.00s)          \u2502                                                                                       \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                                                                                    \r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                                       \r\n\u2502           RANGE           \u2502\u2502           RANGE           \u2502                             \u2502         PROJECTION        \u2502                                                                                       \r\n\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \r\n\u2502            3200           \u2502\u2502             3             \u2502                             \u2502             a             \u2502                                                                                       \r\n\u2502          (0.00s)          \u2502\u2502          (0.00s)          \u2502                             \u2502             #0            \u2502                                                                                       \r\n\u2502                           \u2502\u2502                           \u2502                             \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \r\n\u2502                           \u2502\u2502                           \u2502                             \u2502            3200           \u2502                                                                                       \r\n\u2502                           \u2502\u2502                           \u2502                             \u2502          (0.00s)          \u2502                                                                                       \r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                                                                                    \r\n                                                                                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                                       \r\n                                                                                       \u2502           UNNEST          \u2502                                                                                       \r\n                                                                                       \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \r\n                                                                                       \u2502            3200           \u2502                                                                                       \r\n                                                                                       \u2502          (0.00s)          \u2502                                                                                       \r\n                                                                                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                                                                                    \r\n                                                                                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                                       \r\n                                                                                       \u2502       CROSS_PRODUCT       \u2502                                                                                       \r\n                                                                                       \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                                                       \r\n                                                                                       \u2502             1             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                        \r\n                                                                                       \u2502          (0.00s)          \u2502              \u2502                                                                        \r\n                                                                                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502                                                                                                     \r\n                                                                                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                          \r\n                                                                                       \u2502         DELIM_SCAN        \u2502\u2502         DUMMY_SCAN        \u2502                                                          \r\n                                                                                       \u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502\u2502   \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500   \u2502                                                          \r\n                                                                                       \u2502             0             \u2502\u2502             1             \u2502                                                          \r\n                                                                                       \u2502          (0.00s)          \u2502\u2502          (0.00s)          \u2502                                                          \r\n                                                                                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n> We're grouping by a List column.\r\n\r\nSo I think that is the problem. We should produce the  aggregate LIST(distinct id), and then run the UNNEST calculation only once (per result grouping). \r\n\r\nHere is an even more simple use case.\r\n```\r\nSELECT\r\n(\r\n  select count(*) as value\r\n  FROM (\r\n    SELECT UNNEST(list(distinct id)) a\r\n  )\r\n)\r\n  as total_seats\r\nFROM (\r\nSELECT gen_random_uuid() id, 1 as val FROM range(0, 160)\r\n) as m\r\n```\r\n\r\nIn this case the (SELECT COUNT ...) is not a correlated subquery, but a subquery that is run AFTER the list(distinct).  BigQuery makes you do this in a UDF, not sure about postgres.\nPG will run this query, with some minor syntactic changes:\r\n\r\n```sql\r\nSELECT\r\n(\r\n  select count(*) as value\r\n  FROM (\r\n    SELECT UNNEST(array_agg(distinct id))\r\n  ) a\r\n)\r\n  as total_seats\r\nFROM (\r\nSELECT gen_random_uuid() id, 1 as val FROM generate_series(0, 160)\r\n) as m;\r\n```\nThe PG plan seems much more sane:\r\n```\r\n Aggregate  (cost=4.03..4.24 rows=1 width=8) (actual time=0.873..0.874 rows=1 loops=1)\r\n   ->  Function Scan on generate_series  (cost=0.00..2.02 rows=161 width=20) (actual time=0.093..0.655 rows=161 loops=1)\r\n   SubPlan 1\r\n     ->  Aggregate  (cost=0.19..0.20 rows=1 width=8) (actual time=0.062..0.063 rows=1 loops=1)\r\n           ->  ProjectSet  (cost=0.00..0.07 rows=10 width=16) (actual time=0.005..0.037 rows=161 loops=1)\r\n                 ->  Result  (cost=0.00..0.01 rows=1 width=0) (actual time=0.001..0.001 rows=1 loops=1)\r\n```\r\n\r\nI think we should be able to create a better plan as well, but optimizer code is a bit daunting to me.\n@hawkfish Ignore that comment.  Pilot error.",
  "created_at": "2022-07-06T13:30:09Z"
}