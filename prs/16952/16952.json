{
  "repo": "duckdb/duckdb",
  "pull_number": 16952,
  "instance_id": "duckdb__duckdb-16952",
  "issue_numbers": [
    "16942"
  ],
  "base_commit": "1329f339b23287373d7bd9bb49ab44c61de0d3bd",
  "patch": "diff --git a/tools/pythonpkg/src/arrow/arrow_array_stream.cpp b/tools/pythonpkg/src/arrow/arrow_array_stream.cpp\nindex 2b13ddfc2451..3fbb9420e9ef 100644\n--- a/tools/pythonpkg/src/arrow/arrow_array_stream.cpp\n+++ b/tools/pythonpkg/src/arrow/arrow_array_stream.cpp\n@@ -302,6 +302,37 @@ py::object TransformFilterRecursive(TableFilter &filter, vector<string> column_r\n \t\tauto &constant_filter = filter.Cast<ConstantFilter>();\n \t\tauto constant_field = field(py::tuple(py::cast(column_ref)));\n \t\tauto constant_value = GetScalar(constant_filter.constant, timezone_config, type);\n+\n+\t\tbool is_nan = false;\n+\t\tauto &constant = constant_filter.constant;\n+\t\tauto &constant_type = constant.type();\n+\t\tif (constant_type.id() == LogicalTypeId::FLOAT) {\n+\t\t\tis_nan = Value::IsNan(constant.GetValue<float>());\n+\t\t} else if (constant_type.id() == LogicalTypeId::DOUBLE) {\n+\t\t\tis_nan = Value::IsNan(constant.GetValue<double>());\n+\t\t}\n+\n+\t\t// Special handling for NaN comparisons (to explicitly violate IEEE-754)\n+\t\tif (is_nan) {\n+\t\t\tswitch (constant_filter.comparison_type) {\n+\t\t\tcase ExpressionType::COMPARE_EQUAL:\n+\t\t\tcase ExpressionType::COMPARE_GREATERTHANOREQUALTO:\n+\t\t\t\treturn constant_field.attr(\"is_nan\")();\n+\t\t\tcase ExpressionType::COMPARE_LESSTHAN:\n+\t\t\tcase ExpressionType::COMPARE_NOTEQUAL:\n+\t\t\t\treturn constant_field.attr(\"is_nan\")().attr(\"__invert__\")();\n+\t\t\tcase ExpressionType::COMPARE_GREATERTHAN:\n+\t\t\t\t// Nothing is greater than NaN\n+\t\t\t\treturn import_cache.pyarrow.dataset().attr(\"scalar\")(false);\n+\t\t\tcase ExpressionType::COMPARE_LESSTHANOREQUALTO:\n+\t\t\t\t// Everything is less than or equal to NaN\n+\t\t\t\treturn import_cache.pyarrow.dataset().attr(\"scalar\")(true);\n+\t\t\tdefault:\n+\t\t\t\tthrow NotImplementedException(\"Unsupported comparison type (%s) for NaN values\",\n+\t\t\t\t                              EnumUtil::ToString(constant_filter.comparison_type));\n+\t\t\t}\n+\t\t}\n+\n \t\tswitch (constant_filter.comparison_type) {\n \t\tcase ExpressionType::COMPARE_EQUAL:\n \t\t\treturn constant_field.attr(\"__eq__\")(constant_value);\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/arrow/test_filter_pushdown.py b/tools/pythonpkg/tests/fast/arrow/test_filter_pushdown.py\nindex 142d1dace103..82cb4414b8f6 100644\n--- a/tools/pythonpkg/tests/fast/arrow/test_filter_pushdown.py\n+++ b/tools/pythonpkg/tests/fast/arrow/test_filter_pushdown.py\n@@ -986,3 +986,30 @@ def test_pushdown_of_optional_filter(self, duckdb_cursor):\n             ('product_code', 100),\n             ('price', 100),\n         ]\n+\n+    # DuckDB intentionally violates IEEE-754 when it comes to NaNs, ensuring a total ordering where NaN is the greatest value\n+    def test_nan_filter_pushdown(self, duckdb_cursor):\n+        duckdb_cursor.execute(\n+            \"\"\"\n+            create table test as select a::DOUBLE a from VALUES\n+                ('inf'),\n+                ('nan'),\n+                ('0.34234'),\n+                ('34234234.00005'),\n+                ('-nan')\n+            t(a);\n+        \"\"\"\n+        )\n+\n+        def assert_equal_results(con, arrow_table, query):\n+            duckdb_res = con.sql(query.format(table='test')).fetchall()\n+            arrow_res = con.sql(query.format(table='arrow_table')).fetchall()\n+            assert len(duckdb_res) == len(arrow_res)\n+\n+        arrow_table = duckdb_cursor.table('test').arrow()\n+        assert_equal_results(duckdb_cursor, arrow_table, \"select * from {table} where a > 'NaN'::FLOAT\")\n+        assert_equal_results(duckdb_cursor, arrow_table, \"select * from {table} where a >= 'NaN'::FLOAT\")\n+        assert_equal_results(duckdb_cursor, arrow_table, \"select * from {table} where a < 'NaN'::FLOAT\")\n+        assert_equal_results(duckdb_cursor, arrow_table, \"select * from {table} where a <= 'NaN'::FLOAT\")\n+        assert_equal_results(duckdb_cursor, arrow_table, \"select * from {table} where a = 'NaN'::FLOAT\")\n+        assert_equal_results(duckdb_cursor, arrow_table, \"select * from {table} where a != 'NaN'::FLOAT\")\n",
  "problem_statement": "Can't filter for NaN in polars replacement scan\n### What happens?\n\nDuckDB fails to filter for nan values in polars dataframe, even though it does display them correctly without filter (and it filters correctly on more complicated queries). The same problem happens with parquets (written in C# using ParquetSharp) but it's much harder to produce a MWE for that.\n\n### To Reproduce\n\n```python\nimport duckdb \nimport polars as pl\nimport numpy as np\ndf = pl.DataFrame({'number': [-np.nan, np.nan]})\nduckdb.query(\"\"\"FROM df\"\"\")\n```\n```\n# correct replacement scan\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 number \u2502\n\u2502 double \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   -nan \u2502\n\u2502    nan \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n```python\nduckdb.query(\"\"\"FROM df WHERE number = 'NaN'::FLOAT\"\"\")\n```\n```\n# incorrect, should show two rows because NaNs compare equal to all other NaNs in DuckDB according to https://duckdb.org/docs/stable/sql/dialect/sql_quirks#nan-values\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 number \u2502\n\u2502 double \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 0 rows \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n```python\nduckdb.query(\"\"\"SELECT DISTINCT * FROM df\"\"\")\n```\n```\n#correct, shows one rows because all nans are equal to each other\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 number \u2502\n\u2502 double \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    nan \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nIn pure DuckDB, `NaN` always compare equal:\n\n```sql\nCREATE OR REPLACE TABLE tbl AS (SELECT -'NaN'::FLOAT AS number UNION ALL SELECT 'NaN'::FLOAT);\nFROM tbl WHERE number = 'NaN'::FLOAT\n```\n```\n# correct\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 number \u2502\n\u2502 float  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   -nan \u2502\n\u2502    nan \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n\n### OS:\n\nLinux\n\n### DuckDB Version:\n\n'1.2.2-dev83'\n\n### DuckDB Client:\n\nPython\n\n### Hardware:\n\n.\n\n### Full Name:\n\nSoeren Wolfers\n\n### Affiliation:\n\nG-Research\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have not tested with any build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nNo - Other reason (please specify in the issue body)\n\n### Did you include all code required to reproduce the issue?\n\n- [x] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [x] Yes, I have\n",
  "hints_text": "Sounds like you're running into [this](https://duckdb.org/docs/stable/sql/dialect/sql_quirks#nan-values) ?\n\nFor example:\n```sql\nduckdb.query(\"\"\"FROM df WHERE isnan(number)\"\"\").show()\n```\n\ndoes work.\n@Tishj No, that link says that `NaN`s should always compare equal in DuckDB. I also edited the OP to show that that's the case in pure DuckDB.\nThanks, I missed that \ud83d\udc4d \n\nFigured out the issue, it's the pyarrow filter pushdown, see:\n```py\nimport duckdb \nimport polars as pl\nimport numpy as np\ndf = pl.DataFrame({'number': [-np.nan, np.nan]})\n\n# From capsule\npl_capsule = df.__arrow_c_stream__()\nduckdb.sql(\"select * from pl_capsule where number = 'NaN'::FLOAT\").show()\n\n# From Arrow\npl_arrow = df.to_arrow()\nduckdb.sql(\"select * from pl_arrow where number = 'NaN'::FLOAT\").show()\n```\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 number \u2502\n\u2502 double \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   -nan \u2502\n\u2502    nan \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 number \u2502\n\u2502 double \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 0 rows \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nWhen we scan from a pycapsule we intentionally dont push down filters using pyarrow, so that's why the result *is* correct when we fetch the capsule and scan that\nDo you also know how this could affect parquet reads? That's where I initially ran into this. \nThe issue in Parquet is most likely related to Parquet statistics not containing whether or not there are NaN values - which leads to the optimizer stripping comparisons against NaN values or pruning row groups that might contain NaN values - see e.g. https://github.com/duckdb/duckdb/issues/7803. We've seen that issue reported in the past but haven't fixed it yet.",
  "created_at": "2025-04-02T10:20:35Z"
}