{
  "repo": "duckdb/duckdb",
  "pull_number": 9242,
  "instance_id": "duckdb__duckdb-9242",
  "issue_numbers": [
    "8413",
    "8413"
  ],
  "base_commit": "7a084c953dda994c6a6a9381d41329fd46e301bc",
  "patch": "diff --git a/src/include/duckdb/planner/expression_binder.hpp b/src/include/duckdb/planner/expression_binder.hpp\nindex 11e5a882c937..6df014d16f7d 100644\n--- a/src/include/duckdb/planner/expression_binder.hpp\n+++ b/src/include/duckdb/planner/expression_binder.hpp\n@@ -90,8 +90,8 @@ class ExpressionBinder {\n \tvoid QualifyColumnNames(unique_ptr<ParsedExpression> &expr);\n \tstatic void QualifyColumnNames(Binder &binder, unique_ptr<ParsedExpression> &expr);\n \n-\tstatic unique_ptr<Expression> PushCollation(ClientContext &context, unique_ptr<Expression> source,\n-\t                                            const string &collation, bool equality_only = false);\n+\tstatic bool PushCollation(ClientContext &context, unique_ptr<Expression> &source, const LogicalType &sql_type,\n+\t                          bool equality_only = false);\n \tstatic void TestCollation(ClientContext &context, const string &collation);\n \n \tbool BindCorrelatedColumns(unique_ptr<ParsedExpression> &expr);\ndiff --git a/src/planner/binder/expression/bind_between_expression.cpp b/src/planner/binder/expression/bind_between_expression.cpp\nindex 1c82daef23ab..a44e5d3783f3 100644\n--- a/src/planner/binder/expression/bind_between_expression.cpp\n+++ b/src/planner/binder/expression/bind_between_expression.cpp\n@@ -34,13 +34,11 @@ BindResult ExpressionBinder::BindExpression(BetweenExpression &expr, idx_t depth\n \tinput = BoundCastExpression::AddCastToType(context, std::move(input), input_type);\n \tlower = BoundCastExpression::AddCastToType(context, std::move(lower), input_type);\n \tupper = BoundCastExpression::AddCastToType(context, std::move(upper), input_type);\n-\tif (input_type.id() == LogicalTypeId::VARCHAR) {\n-\t\t// handle collation\n-\t\tauto collation = StringType::GetCollation(input_type);\n-\t\tinput = PushCollation(context, std::move(input), collation, false);\n-\t\tlower = PushCollation(context, std::move(lower), collation, false);\n-\t\tupper = PushCollation(context, std::move(upper), collation, false);\n-\t}\n+\t// handle collation\n+\tPushCollation(context, input, input_type, false);\n+\tPushCollation(context, lower, input_type, false);\n+\tPushCollation(context, upper, input_type, false);\n+\n \tif (!input->HasSideEffects() && !input->HasParameter() && !input->HasSubquery()) {\n \t\t// the expression does not have side effects and can be copied: create two comparisons\n \t\t// the reason we do this is that individual comparisons are easier to handle in optimizers\ndiff --git a/src/planner/binder/expression/bind_collate_expression.cpp b/src/planner/binder/expression/bind_collate_expression.cpp\nindex cbe51e7d04d0..6682b5c947fc 100644\n--- a/src/planner/binder/expression/bind_collate_expression.cpp\n+++ b/src/planner/binder/expression/bind_collate_expression.cpp\n@@ -18,8 +18,10 @@ BindResult ExpressionBinder::BindExpression(CollateExpression &expr, idx_t depth\n \t\tthrow BinderException(\"collations are only supported for type varchar\");\n \t}\n \t// Validate the collation, but don't use it\n-\tPushCollation(context, child->Copy(), expr.collation, false);\n-\tchild->return_type = LogicalType::VARCHAR_COLLATION(expr.collation);\n+\tauto child_copy = child->Copy();\n+\tauto collation_type = LogicalType::VARCHAR_COLLATION(expr.collation);\n+\tPushCollation(context, child_copy, collation_type, false);\n+\tchild->return_type = collation_type;\n \treturn BindResult(std::move(child));\n }\n \ndiff --git a/src/planner/binder/expression/bind_comparison_expression.cpp b/src/planner/binder/expression/bind_comparison_expression.cpp\nindex 0a452f716556..0cff7da5bec9 100644\n--- a/src/planner/binder/expression/bind_comparison_expression.cpp\n+++ b/src/planner/binder/expression/bind_comparison_expression.cpp\n@@ -18,20 +18,25 @@\n \n namespace duckdb {\n \n-unique_ptr<Expression> ExpressionBinder::PushCollation(ClientContext &context, unique_ptr<Expression> source,\n-                                                       const string &collation_p, bool equality_only) {\n+bool ExpressionBinder::PushCollation(ClientContext &context, unique_ptr<Expression> &source,\n+                                     const LogicalType &sql_type, bool equality_only) {\n+\tif (sql_type.id() != LogicalTypeId::VARCHAR) {\n+\t\t// only VARCHAR columns require collation\n+\t\treturn false;\n+\t}\n \t// replace default collation with system collation\n+\tauto str_collation = StringType::GetCollation(sql_type);\n \tstring collation;\n-\tif (collation_p.empty()) {\n+\tif (str_collation.empty()) {\n \t\tcollation = DBConfig::GetConfig(context).options.collation;\n \t} else {\n-\t\tcollation = collation_p;\n+\t\tcollation = str_collation;\n \t}\n \tcollation = StringUtil::Lower(collation);\n \t// bind the collation\n \tif (collation.empty() || collation == \"binary\" || collation == \"c\" || collation == \"posix\") {\n-\t\t// binary collation: just skip\n-\t\treturn source;\n+\t\t// no collation or binary collation: skip\n+\t\treturn false;\n \t}\n \tauto &catalog = Catalog::GetSystemCatalog(context);\n \tauto splits = StringUtil::Split(StringUtil::Lower(collation), \".\");\n@@ -60,11 +65,12 @@ unique_ptr<Expression> ExpressionBinder::PushCollation(ClientContext &context, u\n \t\tauto function = function_binder.BindScalarFunction(collation_entry.function, std::move(children));\n \t\tsource = std::move(function);\n \t}\n-\treturn source;\n+\treturn true;\n }\n \n void ExpressionBinder::TestCollation(ClientContext &context, const string &collation) {\n-\tPushCollation(context, make_uniq<BoundConstantExpression>(Value(\"\")), collation);\n+\tauto expr = make_uniq_base<Expression, BoundConstantExpression>(Value(\"\"));\n+\tPushCollation(context, expr, LogicalType::VARCHAR_COLLATION(collation));\n }\n \n LogicalType BoundComparisonExpression::BindComparison(LogicalType left_type, LogicalType right_type) {\n@@ -134,12 +140,9 @@ BindResult ExpressionBinder::BindExpression(ComparisonExpression &expr, idx_t de\n \tright = BoundCastExpression::AddCastToType(context, std::move(right), input_type,\n \t                                           input_type.id() == LogicalTypeId::ENUM);\n \n-\tif (input_type.id() == LogicalTypeId::VARCHAR) {\n-\t\t// handle collation\n-\t\tauto collation = StringType::GetCollation(input_type);\n-\t\tleft = PushCollation(context, std::move(left), collation, expr.type == ExpressionType::COMPARE_EQUAL);\n-\t\tright = PushCollation(context, std::move(right), collation, expr.type == ExpressionType::COMPARE_EQUAL);\n-\t}\n+\tPushCollation(context, left, input_type, expr.type == ExpressionType::COMPARE_EQUAL);\n+\tPushCollation(context, right, input_type, expr.type == ExpressionType::COMPARE_EQUAL);\n+\n \t// now create the bound comparison expression\n \treturn BindResult(make_uniq<BoundComparisonExpression>(expr.type, std::move(left), std::move(right)));\n }\ndiff --git a/src/planner/binder/query_node/bind_select_node.cpp b/src/planner/binder/query_node/bind_select_node.cpp\nindex 6a052a3057c8..36d11109d945 100644\n--- a/src/planner/binder/query_node/bind_select_node.cpp\n+++ b/src/planner/binder/query_node/bind_select_node.cpp\n@@ -222,10 +222,7 @@ void Binder::BindModifierTypes(BoundQueryNode &result, const vector<LogicalType>\n \t\t\tfor (auto &target_distinct : distinct.target_distincts) {\n \t\t\t\tauto &bound_colref = target_distinct->Cast<BoundColumnRefExpression>();\n \t\t\t\tconst auto &sql_type = sql_types[bound_colref.binding.column_index];\n-\t\t\t\tif (sql_type.id() == LogicalTypeId::VARCHAR) {\n-\t\t\t\t\ttarget_distinct = ExpressionBinder::PushCollation(context, std::move(target_distinct),\n-\t\t\t\t\t                                                  StringType::GetCollation(sql_type), true);\n-\t\t\t\t}\n+\t\t\t\tExpressionBinder::PushCollation(context, target_distinct, sql_type, true);\n \t\t\t}\n \t\t\tbreak;\n \t\t}\n@@ -253,10 +250,7 @@ void Binder::BindModifierTypes(BoundQueryNode &result, const vector<LogicalType>\n \t\t\t\tD_ASSERT(bound_colref.binding.column_index < sql_types.size());\n \t\t\t\tconst auto &sql_type = sql_types[bound_colref.binding.column_index];\n \t\t\t\tbound_colref.return_type = sql_types[bound_colref.binding.column_index];\n-\t\t\t\tif (sql_type.id() == LogicalTypeId::VARCHAR) {\n-\t\t\t\t\torder_node.expression = ExpressionBinder::PushCollation(context, std::move(order_node.expression),\n-\t\t\t\t\t                                                        StringType::GetCollation(sql_type));\n-\t\t\t\t}\n+\t\t\t\tExpressionBinder::PushCollation(context, order_node.expression, sql_type);\n \t\t\t}\n \t\t\tbreak;\n \t\t}\n@@ -389,9 +383,8 @@ unique_ptr<BoundQueryNode> Binder::BindSelectNode(SelectNode &statement, unique_\n \t\t\tbool contains_subquery = bound_expr_ref.HasSubquery();\n \n \t\t\t// push a potential collation, if necessary\n-\t\t\tauto collated_expr = ExpressionBinder::PushCollation(context, std::move(bound_expr),\n-\t\t\t                                                     StringType::GetCollation(group_type), true);\n-\t\t\tif (!contains_subquery && !collated_expr->Equals(bound_expr_ref)) {\n+\t\t\tbool requires_collation = ExpressionBinder::PushCollation(context, bound_expr, group_type, true);\n+\t\t\tif (!contains_subquery && requires_collation) {\n \t\t\t\t// if there is a collation on a group x, we should group by the collated expr,\n \t\t\t\t// but also push a first(x) aggregate in case x is selected (uncollated)\n \t\t\t\tinfo.collated_groups[i] = result->aggregates.size();\n@@ -405,7 +398,7 @@ unique_ptr<BoundQueryNode> Binder::BindSelectNode(SelectNode &statement, unique_\n \t\t\t\tauto function = function_binder.BindAggregateFunction(first_fun, std::move(first_children));\n \t\t\t\tresult->aggregates.push_back(std::move(function));\n \t\t\t}\n-\t\t\tresult->groups.group_expressions.push_back(std::move(collated_expr));\n+\t\t\tresult->groups.group_expressions.push_back(std::move(bound_expr));\n \n \t\t\t// in the unbound expression we DO bind the table names of any ColumnRefs\n \t\t\t// we do this to make sure that \"table.a\" and \"a\" are treated the same\n",
  "test_patch": "diff --git a/test/sql/collate/collate_non_varchar.test b/test/sql/collate/collate_non_varchar.test\nnew file mode 100644\nindex 000000000000..e183c9219beb\n--- /dev/null\n+++ b/test/sql/collate/collate_non_varchar.test\n@@ -0,0 +1,14 @@\n+# name: test/sql/collate/collate_non_varchar.test\n+# description: Test collation of non-varchar columns\n+# group: [collate]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+PRAGMA default_collation=NOCASE;\n+\n+query I\n+select typeof(x) from (select 1::INT as x group by x);\n+----\n+INTEGER\n\\ No newline at end of file\n",
  "problem_statement": "ints are converted to strings by GROUP BY if default_collation=NOCASE\n### What happens?\n\n- Integer values are unexpected  converted to varchar in GROUP BY if default_collation=NOCASE.\r\n- ORDER BY does not convert\r\n\r\nExpected Result:\r\ninteger values are not converted to varchar by GROUP BY.\r\n\r\nObserved Result:\r\ninteger values are converted to varchar by GROUP BY.\r\n\r\n```\r\nPRAGMA default_collation=NOCASE;\r\nselect 1 as x group by x;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502    x    \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 1       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n\n### To Reproduce\n\n```\r\n.echo on\r\nPRAGMA default_collation=BINARY;\r\nselect 1 as x;\r\nselect 1 as x order by x;\r\nselect 1 as x group by x;\r\n                   \r\nPRAGMA default_collation=NOCASE;\r\nselect 1 as x;\r\nselect 1 as x order by x;\r\nselect 1 as x group by x;   -- x becomes a varchar only on this query\r\n```\n\n### OS:\n\nMacOS\n\n### DuckDB Version:\n\n0.8.1\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nMark Harrison\n\n### Affiliation:\n\nTigerEye\n\n### Have you tried this on the latest `master` branch?\n\n- [ ] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\nints are converted to strings by GROUP BY if default_collation=NOCASE\n### What happens?\n\n- Integer values are unexpected  converted to varchar in GROUP BY if default_collation=NOCASE.\r\n- ORDER BY does not convert\r\n\r\nExpected Result:\r\ninteger values are not converted to varchar by GROUP BY.\r\n\r\nObserved Result:\r\ninteger values are converted to varchar by GROUP BY.\r\n\r\n```\r\nPRAGMA default_collation=NOCASE;\r\nselect 1 as x group by x;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502    x    \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 1       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n\n### To Reproduce\n\n```\r\n.echo on\r\nPRAGMA default_collation=BINARY;\r\nselect 1 as x;\r\nselect 1 as x order by x;\r\nselect 1 as x group by x;\r\n                   \r\nPRAGMA default_collation=NOCASE;\r\nselect 1 as x;\r\nselect 1 as x order by x;\r\nselect 1 as x group by x;   -- x becomes a varchar only on this query\r\n```\n\n### OS:\n\nMacOS\n\n### DuckDB Version:\n\n0.8.1\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nMark Harrison\n\n### Affiliation:\n\nTigerEye\n\n### Have you tried this on the latest `master` branch?\n\n- [ ] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "This is the same bug for timestamp types and probably others\n@marhar did you ever get to the bottom of this?\nThis is the same bug for timestamp types and probably others\n@marhar did you ever get to the bottom of this?",
  "created_at": "2023-10-06T07:33:45Z"
}