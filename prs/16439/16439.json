{
  "repo": "duckdb/duckdb",
  "pull_number": 16439,
  "instance_id": "duckdb__duckdb-16439",
  "issue_numbers": [
    "16333",
    "15792"
  ],
  "base_commit": "b95a2a98d9fc321872d498134869d82b70927ce8",
  "patch": "diff --git a/.github/config/out_of_tree_extensions.cmake b/.github/config/out_of_tree_extensions.cmake\nindex 4aee4d773f9a..b1746d23b2a8 100644\n--- a/.github/config/out_of_tree_extensions.cmake\n+++ b/.github/config/out_of_tree_extensions.cmake\n@@ -53,18 +53,18 @@ endif()\n ################# DELTA\n # MinGW build is not available, and our current manylinux ci does not have enough storage space to run the rust build\n # for Delta\n-if (NOT MINGW AND NOT \"${OS_NAME}\" STREQUAL \"linux\" AND NOT ${WASM_ENABLED})\n-    duckdb_extension_load(delta\n-            GIT_URL https://github.com/duckdb/duckdb-delta\n-            GIT_TAG 846019edcc27000721ff9c4281e85a63d1aa10de\n-    )\n-endif()\n+#if (NOT MINGW AND NOT \"${OS_NAME}\" STREQUAL \"linux\" AND NOT ${WASM_ENABLED})\n+#    duckdb_extension_load(delta\n+#            GIT_URL https://github.com/duckdb/duckdb-delta\n+#            GIT_TAG 846019edcc27000721ff9c4281e85a63d1aa10de\n+#    )\n+#endif()\n \n ################# EXCEL\n duckdb_extension_load(excel\n     LOAD_TESTS\n     GIT_URL https://github.com/duckdb/duckdb-excel\n-    GIT_TAG 67a851738ec80e1f19148a3b37a25a83a5068195\n+    GIT_TAG f14e7c3beaf379c54b47b996aa896a1d814e1be8\n     INCLUDE_DIR src/excel/include\n     )\n \ndiff --git a/.github/workflows/InvokeCI.yml b/.github/workflows/InvokeCI.yml\nindex d17182450677..8bbba55f2677 100644\n--- a/.github/workflows/InvokeCI.yml\n+++ b/.github/workflows/InvokeCI.yml\n@@ -11,6 +11,8 @@ on:\n         type: string\n       run_all:\n         type: string\n+      twine_upload:\n+        type: string\n \n concurrency:\n   group: invokeci-${{ github.workflow }}-${{ github.ref }}-${{ github.head_ref || '' }}-${{ github.base_ref || '' }}-${{ github.ref != 'refs/heads/main' || github.sha }}-${{ inputs.override_git_describe }}-${{ inputs.git_ref }}-${{ inputs.skip_tests }}\n@@ -49,6 +51,7 @@ jobs:\n       git_ref: ${{ inputs.git_ref }}\n       skip_tests: ${{ inputs.skip_tests }}\n       run_all: ${{ inputs.run_all }}\n+      override_twine_upload: ${{ inputs.twine_upload }}\n \n   pyodide:\n     uses: ./.github/workflows/Pyodide.yml\ndiff --git a/.github/workflows/OnTag.yml b/.github/workflows/OnTag.yml\nindex 4f471b7dd40b..a6ddbd38c2b4 100644\n--- a/.github/workflows/OnTag.yml\n+++ b/.github/workflows/OnTag.yml\n@@ -14,6 +14,7 @@ jobs:\n     secrets: inherit\n     with:\n       override_git_describe: ${{ inputs.override_git_describe || github.ref_name }}\n+      twine_upload: 'true'\n \n   staged_upload:\n     uses: ./.github/workflows/StagedUpload.yml\ndiff --git a/.github/workflows/Python.yml b/.github/workflows/Python.yml\nindex 1876c81d7cbb..b63b0b82caf7 100644\n--- a/.github/workflows/Python.yml\n+++ b/.github/workflows/Python.yml\n@@ -10,6 +10,8 @@ on:\n         type: string\n       run_all:\n         type: string\n+      override_twine_upload:\n+        type: string\n   workflow_dispatch:\n     inputs:\n       override_git_describe:\n@@ -20,6 +22,8 @@ on:\n         type: string\n       run_all:\n         type: string\n+      override_twine_upload:\n+        type: string\n   push:\n     branches-ignore:\n       - 'main'\n@@ -462,8 +466,10 @@ jobs:\n       - win-python3\n       - linux-python3\n     # Note that want to run this by default ONLY if no override_git_describe is provided\n-    # This means we are not staging a release\n-    if: (( startsWith(github.ref, 'refs/tags/v') || github.ref == 'refs/heads/main' )) && (( inputs.override_git_describe == '' )) && (( github.repository == 'duckdb/duckdb' ))\n+    # This means we are not staging a release, or we explicitly set `twine_upload`\n+    # Why? If present, it means we are staging releases, and we want to do the upload manually\n+    if: (( startsWith(github.ref, 'refs/tags/v') || github.ref == 'refs/heads/main' || inputs.override_twine_upload == 'true' )) && (( inputs.override_git_describe == '' )) && (( github.repository == 'duckdb/duckdb' ))\n     uses: ./.github/workflows/TwineUpload.yml\n     secrets: inherit\n-    # Why? If present, it means we are staging releases, and we want to do the upload manually\n+    with:\n+      twine_upload: 'true'\ndiff --git a/.github/workflows/TwineUpload.yml b/.github/workflows/TwineUpload.yml\nindex 7dfd4e04f9dd..434fdf785a7c 100644\n--- a/.github/workflows/TwineUpload.yml\n+++ b/.github/workflows/TwineUpload.yml\n@@ -4,10 +4,14 @@ on:\n     inputs:\n       override_git_describe:\n         type: string\n+      twine_upload:\n+        type: string\n   workflow_dispatch:\n     inputs:\n       override_git_describe:\n         type: string\n+      twine_upload:\n+        type: string\n \n env:\n   GH_TOKEN: ${{ secrets.GH_TOKEN }}\n@@ -47,12 +51,13 @@ jobs:\n           aws s3 cp --recursive \"s3://duckdb-staging/$TARGET/$GITHUB_REPOSITORY/twine_upload\" to_be_uploaded --region us-east-2\n \n       - name: Deploy\n+        if: ${{ inputs.twine_upload == 'true' }}\n         env:\n           TWINE_USERNAME: '__token__'\n           TWINE_PASSWORD: ${{ secrets.TWINE_TOKEN }}\n         shell: bash\n         run: |\n           cd tools/pythonpkg\n-          if [[ \"$GITHUB_REF\" =~ ^(refs/heads/main|refs/tags/v.+)$ && \"$GITHUB_REPOSITORY\" = \"duckdb/duckdb\" ]] ; then\n+          if [[ \"$GITHUB_REPOSITORY\" = \"duckdb/duckdb\" ]] ; then\n             twine upload --non-interactive --disable-progress-bar --skip-existing to_be_uploaded/*\n           fi\ndiff --git a/data/csv/later_quotes.csv b/data/csv/later_quotes.csv\nnew file mode 100644\nindex 000000000000..657c4f93e861\n--- /dev/null\n+++ b/data/csv/later_quotes.csv\n@@ -0,0 +1,2050 @@\n+id,value\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+1,bla\n+2048,\"\"\",\"\ndiff --git a/data/csv/multi_quote.csv b/data/csv/multi_quote.csv\nnew file mode 100644\nindex 000000000000..b3afd621b814\n--- /dev/null\n+++ b/data/csv/multi_quote.csv\n@@ -0,0 +1,8 @@\n+datecol,textcol\n+1/1/19,\"text\"\n+1/2/19,\"text\"\n+1/3/19,\"text\"\n+1/4/19,\"text\"\n+1/5/19,\"text\"\n+1/6/19,\"text, with comma\"\n+1/9/19,'text'\n\\ No newline at end of file\ndiff --git a/extension/autocomplete/include/inlined_grammar.gram b/extension/autocomplete/include/inlined_grammar.gram\nnew file mode 100644\nindex 000000000000..2bdd82d9c3f9\n--- /dev/null\n+++ b/extension/autocomplete/include/inlined_grammar.gram\n@@ -0,0 +1,740 @@\n+\n+PivotStatement <- PivotKeyword TableRef PivotOn? PivotUsing? GroupByClause?\n+\n+PivotOn <- 'ON' PivotColumnList\n+PivotUsing <- 'USING' TargetList\n+\n+PivotColumnList <- List(Expression)\n+\n+PivotKeyword <- 'PIVOT'i / 'PIVOT_WIDER'i\n+UnpivotKeyword <- 'UNPIVOT'i / 'PIVOT_LONGER'i\n+\n+UnpivotStatement <- UnpivotKeyword TableRef 'ON' TargetList IntoNameValues?\n+\n+IntoNameValues <- 'INTO' 'NAME' Identifier ValueOrValues List(Identifier)\n+\n+ValueOrValues <- 'VALUE' / 'VALUES'\n+\n+IncludeExcludeNulls <- ('INCLUDE' / 'EXCLUDE') 'NULLS'\n+UnpivotHeader <- Identifier / Parens(List(Identifier))\n+\n+ColumnReference <- CatalogQualification? SchemaQualification? TableQualification? ColumnName\n+FunctionExpression <- FunctionIdentifier Parens(DistinctOrAll? List(FunctionArgument)? OrderByClause?) WithinGroupClause? FilterClause? ExportClause? OverClause?\n+FunctionIdentifier <- CatalogQualification? SchemaQualification? FunctionName\n+DistinctOrAll <- 'DISTINCT'i / 'ALL'i\n+ExportClause <- 'EXPORT_STATE'i\n+WithinGroupClause <- 'WITHIN'i 'GROUP'i Parens(OrderByClause)\n+FilterClause <- 'FILTER' Parens('WHERE'i? Expression)\n+\n+ParenthesisExpression <- Parens(List(Expression))\n+LiteralExpression <- StringLiteral / NumberLiteral / 'NULL'i / 'TRUE'i / 'FALSE'i\n+CastExpression <- CastOrTryCast Parens(Expression 'AS'i Type)\n+CastOrTryCast <- 'CAST'i / 'TRY_CAST'i\n+\n+StarExpression <- (Identifier '.')* '*'i ExcludeList? ReplaceList? RenameList?\n+ExcludeList <- 'EXCLUDE'i (Parens(List(ColumnReference)) / ColumnReference)\n+ReplaceList <- 'REPLACE'i (Parens(List(ReplaceEntry)) / ReplaceEntry)\n+ReplaceEntry <- Expression 'AS'i ColumnReference\n+RenameList <- 'RENAME'i (Parens(List(RenameEntry)) / RenameEntry)\n+RenameEntry <- ColumnReference 'AS'i Identifier\n+SubqueryExpression <- 'NOT'i? 'EXISTS'i? SubqueryReference\n+CaseExpression <- 'CASE'i ColumnReference? CaseWhenThen CaseWhenThen* CaseElse? 'END'i\n+CaseWhenThen <- 'WHEN'i Expression 'THEN'i Expression\n+CaseElse <- 'ELSE'i Expression\n+TypeLiteral <- Identifier StringLiteral\n+IntervalLiteral <- 'INTERVAL'i IntervalParameter IntervalUnit?\n+IntervalParameter <- StringLiteral / NumberLiteral / Parens(Expression)\n+IntervalUnit <- Identifier\n+FrameClause <- Framing FrameExtent WindowExcludeClause?\n+Framing <- 'ROWS'i / 'RANGE'i / 'GROUPS'i\n+FrameExtent <- FrameBound / ('BETWEEN'i FrameBound 'AND'i FrameBound)\n+FrameBound <- ('UNBOUNDED'i 'PRECEDING'i) / ('UNBOUNDED'i 'FOLLOWING'i) / ('CURRENT'i 'ROW'i) / (Expression 'PRECEDING'i) / (Expression 'FOLLOWING'i)\n+WindowExcludeClause <- 'EXCLUDE'i WindowExcludeElement\n+WindowExcludeElement <- ('CURRENT'i 'ROW'i) / 'GROUP'i / 'TIES'i / ('NO'i 'OTHERS'i)\n+OverClause <- 'OVER'i WindowFrame\n+WindowFrame <- WindowFrameDefinition / Identifier / Parens(Identifier)\n+WindowFrameDefinition <- Parens(WindowFrameContents)\n+WindowFrameContents <- WindowPartition? OrderByClause? FrameClause?\n+WindowPartition <- 'PARTITION'i 'BY'i List(Expression)\n+PrefixExpression <- PrefixOperator Expression\n+PrefixOperator <- 'NOT'i / '-' / '+'\n+ListExpression <- 'ARRAY'i? '[' List(Expression)? ']'\n+StructExpression <- '{' List(StructField) '}'\n+StructField <- Expression ':'i Expression\n+MapExpression <- 'MAP'i StructExpression\n+GroupingExpression <- GroupingOrGroupingId Parens(List(Expression))\n+GroupingOrGroupingId <- 'GROUPING'i / 'GROUPING_ID'i\n+Parameter <- '?' / NumberedParameter\n+NumberedParameter <- '$' NumberLiteral\n+PositionalExpression <- '#' NumberLiteral\n+DefaultExpression <- 'DEFAULT'i\n+\n+ListComprehensionExpression <- '['i Expression 'FOR'i List(Expression) ListComprehensionFilter? ']'\n+ListComprehensionFilter <- 'IF'i Expression\n+\n+SingleExpression <-\n+\tParameter /\n+    SubqueryExpression /\n+    SpecialFunctionExpression /\n+    ParenthesisExpression /\n+    IntervalLiteral /\n+    TypeLiteral /\n+    CaseExpression /\n+    StarExpression /\n+    CastExpression /\n+    GroupingExpression /\n+    FunctionExpression /\n+    ColumnReference /\n+    LiteralExpression /\n+    PrefixExpression /\n+    ListComprehensionExpression /\n+    ListExpression /\n+    StructExpression /\n+    MapExpression /\n+    PositionalExpression /\n+    DefaultExpression\n+\n+\n+\n+OperatorLiteral <- <[\\+\\-\\*\\/\\%\\^\\<\\>\\=\\~\\!\\@\\&\\|\\`]+>\n+LikeOperator <- 'NOT'i? LikeOrSimilarTo\n+LikeOrSimilarTo <- 'LIKE'i / 'ILIKE'i / 'GLOB'i / ('SIMILAR'i 'TO'i)\n+InOperator <- 'NOT'i? 'IN'i\n+IsOperator <- 'IS'i 'NOT'i? DistinctFrom?\n+DistinctFrom <- 'DISTINCT'i 'FROM'i\n+ConjunctionOperator <- 'OR'i / 'AND'i\n+ComparisonOperator <-  '=' / '<=' / '>=' / '<' / '>' / '<>' / '!=' / '=='\n+BetweenOperator <- 'NOT'i? 'BETWEEN'i\n+CollateOperator <- 'COLLATE'i\n+LambdaOperator <- '->'\n+EscapeOperator <- 'ESCAPE'i\n+AtTimeZoneOperator <- 'AT'i 'TIME'i 'ZONE'i\n+PostfixOperator <- '!'\n+AnyAllOperator <- ComparisonOperator AnyOrAll\n+AnyOrAll <- 'ANY' / 'ALL'\n+\n+Operator <-\n+\tAnyAllOperator /\n+    ConjunctionOperator /\n+    LikeOperator /\n+    InOperator /\n+    IsOperator /\n+    BetweenOperator /\n+    CollateOperator /\n+    LambdaOperator /\n+    EscapeOperator /\n+    AtTimeZoneOperator /\n+    OperatorLiteral\n+\n+CastOperator <- '::' Type\n+DotOperator <- '.' (FunctionExpression / Identifier)\n+NotNull <- 'NOT'i 'NULL'i\n+Indirection <- CastOperator / DotOperator / SliceExpression / NotNull / PostfixOperator\n+\n+BaseExpression <- SingleExpression Indirection*\n+Expression <- BaseExpression RecursiveExpression*\n+RecursiveExpression <- (Operator Expression)\n+SliceExpression <- '[' SliceBound ']'\n+SliceBound <- Expression? (':' Expression?)? (':' Expression?)?\n+\n+SpecialFunctionExpression <- CoalesceExpression / ColumnsExpression / ExtractExpression / NullIfExpression / PositionExpression / RowExpression / SubstringExpression / TrimExpression\n+CoalesceExpression <- 'COALESCE'i Parens(List(Expression))\n+ColumnsExpression <- '*'? 'COLUMNS'i Parens(Expression)\n+ExtractExpression <- 'EXTRACT'i Parens(Expression 'FROM'i Expression)\n+NullIfExpression <- 'NULLIF'i Parens(Expression ',' Expression)\n+PositionExpression <- 'POSITION'i Parens(Expression)\n+RowExpression <- 'ROW'i Parens(List(Expression))\n+SubstringExpression <- 'SUBSTRING'i Parens(SubstringParameters / List(Expression))\n+SubstringParameters <- Expression 'FROM'i NumberLiteral 'FOR'i NumberLiteral\n+TrimExpression <- 'TRIM'i Parens(TrimDirection? TrimSource? List(Expression))\n+\n+TrimDirection <- 'BOTH'i / 'LEADING'i / 'TRAILING'i\n+TrimSource <- Expression? 'FROM'i\n+\n+ExecuteStatement <- 'EXECUTE'i Identifier TableFunctionArguments?\n+CreateSecretStmt <- 'SECRET'i IfNotExists? SecretName? SecretStorageSpecifier? Parens(GenericCopyOptionList)\n+\n+SecretStorageSpecifier <- 'IN'i Identifier\n+\n+CreateViewStmt <- 'VIEW'i IfNotExists? QualifiedName InsertColumnList? 'AS'i SelectStatement\n+\n+DescribeStatement <- ShowSelect / ShowAllTables / ShowQualifiedName\n+\n+ShowSelect <- ShowOrDescribeOrSummarize SelectStatement\n+ShowAllTables <- ShowOrDescribe 'ALL'i 'TABLES'\n+ShowQualifiedName <- ShowOrDescribeOrSummarize (QualifiedName / StringLiteral)?\n+\n+ShowOrDescribeOrSummarize <- ShowOrDescribe / 'SUMMARIZE'i\n+ShowOrDescribe <- 'SHOW'i / 'DESCRIBE'i / 'DESC'i\n+\n+VacuumStatement <- 'VACUUM'i 'FULL'i? QualifiedName?\n+\n+PragmaStatement <- 'PRAGMA'i (PragmaAssign / PragmaFunction)\n+\n+PragmaAssign <- SettingName '=' VariableList\n+PragmaFunction <- PragmaName PragmaParameters?\n+PragmaParameters <- List(Expression)\n+\n+DeallocateStatement <- 'DEALLOCATE'i 'PREPARE'i? Identifier\n+\n+PrepareStatement <- 'PREPARE'i Identifier TypeList? 'AS'i Statement\n+\n+TypeList <- Parens(List(Type))\n+\n+CreateStatement <- 'CREATE'i OrReplace? Temporary? (CreateTableStmt / CreateMacroStmt / CreateSequenceStmt / CreateTypeStmt / CreateSchemaStmt / CreateViewStmt / CreateIndexStmt / CreateSecretStmt)\n+OrReplace <- 'OR'i 'REPLACE'i\n+Temporary <- 'TEMP'i / 'TEMPORARY'i / 'PERSISTENT'i\n+\n+CreateTableStmt <- 'TABLE'i IfNotExists? QualifiedName (CreateColumnList / CreateTableAs) CommitAction?\n+\n+CreateTableAs <- IdentifierList? 'AS'i SelectStatement\n+IdentifierList <- Parens(List(Identifier))\n+CreateColumnList <- Parens(CreateTableColumnList)\n+IfNotExists <- 'IF'i 'NOT'i 'EXISTS'i\n+QualifiedName <- CatalogQualification? SchemaQualification? Identifier\n+CatalogQualification <- CatalogName '.'\n+SchemaQualification <- SchemaName '.'\n+TableQualification <- TableName '.'\n+\n+CreateTableColumnList <- List(CreateTableColumnElement)\n+CreateTableColumnElement <- ColumnDefinition / TopLevelConstraint\n+ColumnDefinition <- Identifier TypeOrGenerated ColumnConstraint*\n+TypeOrGenerated <- Type? GeneratedColumn?\n+ColumnConstraint <- NotNullConstraint / UniqueConstraint / PrimaryKeyConstraint / DefaultValue / CheckConstraint / ForeignKeyConstraint / ColumnCollation / ColumnCompression\n+NotNullConstraint <- 'NOT'i 'NULL'i\n+UniqueConstraint <- 'UNIQUE'i\n+PrimaryKeyConstraint <- 'PRIMARY'i 'KEY'i\n+DefaultValue <- 'DEFAULT'i Expression\n+CheckConstraint <- 'CHECK'i Parens(Expression)\n+ForeignKeyConstraint <- 'REFERENCES'i BaseTableName Parens(ColumnList)? KeyActions?\n+ColumnCollation <- 'COLLATE'i Expression\n+ColumnCompression <- 'USING'i 'COMPRESSION'i Identifier\n+\n+KeyActions <- UpdateAction? DeleteAction?\n+UpdateAction <- 'ON' 'UPDATE' KeyAction\n+DeleteAction <- 'ON' 'DELETE' KeyAction\n+KeyAction <- ('NO'i 'ACTION'i) / 'RESTRICT'i / 'CASCADE'i / ('SET'i 'NULL'i) / ('SET'i 'DEFAULT'i)\n+\n+TopLevelConstraint <- ConstraintNameClause? TopLevelConstraintList\n+TopLevelConstraintList <- TopPrimaryKeyConstraint / CheckConstraint / TopUniqueConstraint / TopForeignKeyConstraint\n+ConstraintNameClause <- 'CONSTRAINT'i Identifier\n+TopPrimaryKeyConstraint <- 'PRIMARY'i 'KEY'i ColumnIdList\n+TopUniqueConstraint <- 'UNIQUE'i ColumnIdList\n+TopForeignKeyConstraint <- 'FOREIGN'i 'KEY'i ColumnIdList ForeignKeyConstraint\n+ColumnIdList <- Parens(List(Identifier))\n+\n+PlainIdentifier <-  !ReservedKeyword <[a-z_]i[a-z0-9_]i*>\n+QuotedIdentifier <- '\"' [^\"]* '\"'\n+Identifier <- QuotedIdentifier / PlainIdentifier\n+\n+GeneratedColumn <- Generated? 'AS'i Parens(Expression) GeneratedColumnType?\n+\n+Generated <- 'GENERATED'i AlwaysOrByDefault?\n+AlwaysOrByDefault <- 'ALWAYS'i / ('BY'i 'DEFAULT'i)\n+GeneratedColumnType <- 'VIRTUAL'i / 'STORED'i\n+\n+CommitAction <- 'ON'i 'COMMIT'i 'PRESERVE'i 'ROWS'i\n+\n+CreateIndexStmt <- Unique? 'INDEX'i IfNotExists? IndexName? 'ON'i BaseTableName IndexType? Parens(List(IndexElement))\n+\n+IndexElement <- Expression DescOrAsc? NullsFirstOrLast?\n+Unique <- 'UNIQUE'i\n+IndexType <- 'USING'i Identifier\n+\n+DropStatement <- 'DROP'i DropEntries DropBehavior?\n+\n+DropEntries <-\n+\tDropTable /\n+\tDropTableFunction /\n+\tDropFunction /\n+\tDropSchema /\n+\tDropIndex /\n+\tDropSequence /\n+\tDropCollation /\n+\tDropType /\n+\tDropSecret\n+\n+DropTable <- TableOrView IfExists? List(BaseTableName)\n+DropTableFunction <- 'MACRO'i 'TABLE'i IfExists? List(TableFunctionName)\n+DropFunction <- FunctionType IfExists? List(FunctionIdentifier)\n+DropSchema <- 'SCHEMA'i IfExists? List(QualifiedSchemaName)\n+DropIndex <- 'INDEX'i IfExists? List(IndexName)\n+DropSequence <- 'SEQUENCE'i IfExists? List(QualifiedSequenceName)\n+DropCollation <- 'COLLATION'i IfExists? List(CollationName)\n+DropType <- 'TYPE'i IfExists? List(QualifiedTypeName)\n+DropSecret <- Temporary? 'SECRET'i IfExists? SecretName DropSecretStorage?\n+\n+TableOrView <- 'TABLE'i / 'VIEW'i / ('MATERIALIZED'i 'VIEW'i)\n+FunctionType <- 'MACRO'i / 'FUNCTION'i\n+\n+DropBehavior <- 'CASCADE'i / 'RESTRICT'i\n+\n+IfExists <- 'IF'i 'EXISTS'i\n+QualifiedSchemaName <- CatalogQualification? SchemaName\n+\n+DropSecretStorage <- 'FROM'i Identifier\n+\n+UpdateStatement <- WithClause? 'UPDATE'i UpdateTarget 'SET'i UpdateSetClause FromClause? WhereClause? ReturningClause?\n+\n+UpdateTarget <- BaseTableName UpdateAlias?\n+UpdateAlias <- 'AS'i Identifier\n+UpdateSetClause <- List(UpdateSetElement)\n+UpdateSetElement <- Identifier '=' Expression\n+\n+InsertStatement <- WithClause? 'INSERT'i OrAction? 'INTO'i InsertTarget ByNameOrPosition? InsertColumnList? InsertValues OnConflictClause? ReturningClause?\n+\n+OrAction <- 'OR'i 'REPLACE'i / 'IGNORE'i\n+ByNameOrPosition <- 'BY'i 'NAME'i / 'POSITION'i\n+\n+InsertTarget <- BaseTableName InsertAlias?\n+InsertAlias <- 'AS'i Identifier\n+\n+ColumnList <- List(Identifier)\n+InsertColumnList <- Parens(ColumnList)\n+\n+InsertValues <- SelectStatement / DefaultValues\n+DefaultValues <- 'DEFAULT'i 'VALUES'i\n+\n+OnConflictClause <- 'ON'i 'CONFLICT'i OnConflictTarget? OnConflictAction\n+\n+OnConflictTarget <- OnConflictExpressionTarget / OnConflictIndexTarget\n+OnConflictExpressionTarget <- Parens(List(Identifier)) WhereClause?\n+OnConflictIndexTarget <- 'ON'i 'CONSTRAINT'i ConstraintName\n+\n+\n+OnConflictAction <- OnConflictUpdate / OnConflictNothing\n+\n+OnConflictUpdate <- 'DO'i 'UPDATE'i UpdateSetClause WhereClause?\n+OnConflictNothing <- 'DO'i 'NOTHING'i\n+\n+ReturningClause <- 'RETURNING'i TargetList\n+\n+CreateSchemaStmt <- 'SCHEMA'i IfNotExists? QualifiedName\n+\n+SelectStatement <- SelectOrParens (SetopClause SelectStatement)* ResultModifiers\n+\n+SetopClause <- ('UNION'i / 'EXCEPT'i / 'INTERSECT'i) DistinctOrAll? ByName?\n+ByName <- 'BY'i 'NAME'i\n+SelectOrParens <- BaseSelect / Parens(SelectStatement)\n+\n+BaseSelect <- WithClause? (SimpleSelect / ValuesClause / DescribeStatement / TableStatement / PivotStatement / UnpivotStatement) ResultModifiers\n+ResultModifiers <- OrderByClause? LimitClause? OffsetClause?\n+TableStatement <- 'TABLE' BaseTableName\n+\n+SimpleSelect <- SelectFrom WhereClause? GroupByClause? HavingClause? WindowClause? QualifyClause? SampleClause?\n+\n+SelectFrom <- (SelectClause FromClause?) / (FromClause SelectClause?)\n+WithStatement <- Identifier InsertColumnList? 'AS'i Materialized? SubqueryReference\n+Materialized <- 'NOT'i? 'MATERIALIZED'i\n+WithClause <- 'WITH'i Recursive? List(WithStatement)\n+Recursive <- 'RECURSIVE'i\n+SelectClause <- 'SELECT'i DistinctClause? TargetList\n+TargetList <- List(AliasedExpression)\n+ColumnAliases <- Parens(List(Identifier))\n+\n+DistinctClause <- ('DISTINCT'i DistinctOn?) / 'ALL'i\n+DistinctOn <- 'ON'i Parens(List(Expression))\n+\n+InnerTableRef <- ValuesRef / TableFunction / TableSubquery / BaseTableRef / ParensTableRef\n+\n+TableRef <- InnerTableRef JoinOrPivot*\n+TableSubquery <- Lateral? SubqueryReference TableAlias?\n+BaseTableRef <- BaseTableName TableAlias?\n+ValuesRef <- ValuesClause TableAlias?\n+ParensTableRef <- Parens(TableRef)\n+\n+\n+JoinOrPivot <- JoinClause / TablePivotClause / TableUnpivotClause\n+\n+TablePivotClause <- 'PIVOT' Parens(TargetList 'FOR' PivotValueLists GroupByClause?) TableAlias?\n+TableUnpivotClause <- 'UNPIVOT' IncludeExcludeNulls? Parens(UnpivotHeader 'FOR' PivotValueLists) TableAlias?\n+\n+PivotHeader <- BaseExpression\n+PivotValueLists <- PivotValueList PivotValueList*\n+PivotValueList <- PivotHeader 'IN' PivotTargetList\n+PivotTargetList <- Identifier / Parens(TargetList)\n+\n+Lateral <- 'LATERAL'i\n+\n+BaseTableName <- CatalogQualification? SchemaQualification? TableName\n+\n+TableFunction <- Lateral? QualifiedTableFunction TableFunctionArguments TableAlias?\n+QualifiedTableFunction <- CatalogQualification? SchemaQualification? TableFunctionName\n+TableFunctionArguments <- Parens(List(FunctionArgument)?)\n+FunctionArgument <- NamedParameter / Expression\n+NamedParameter <- Identifier NamedParameterAssignment Expression\n+NamedParameterAssignment <- ':=' / '=>'\n+\n+TableAlias <- 'AS'i? Identifier ColumnAliases?\n+\n+JoinClause <- RegularJoinClause / JoinWithoutOnClause\n+RegularJoinClause <- 'ASOF'i? JoinType? 'JOIN'i InnerTableRef JoinQualifier\n+JoinWithoutOnClause <- JoinPrefix 'JOIN'i InnerTableRef\n+JoinQualifier <- OnClause / UsingClause\n+OnClause <- 'ON'i Expression\n+UsingClause <- 'USING'i Parens(List(Identifier))\n+\n+OuterJoinType <- 'FULL'i / 'LEFT'i / 'RIGHT'i\n+JoinType <- (OuterJoinType 'OUTER'i?) / 'SEMI'i / 'ANTI'i / 'INNER'i\n+JoinPrefix <- 'CROSS'i / ('NATURAL'i JoinType?) / 'POSITIONAL'i\n+\n+FromClause <- 'FROM'i List(TableRef)\n+WhereClause <- 'WHERE'i Expression\n+GroupByClause <- 'GROUP'i 'BY'i GroupByExpressions\n+HavingClause <- 'HAVING'i Expression\n+QualifyClause <- 'QUALIFY'i Expression\n+SampleClause <- 'USING'i 'SAMPLE'i SampleEntry\n+WindowClause <- 'WINDOW'i List(WindowDefinition)\n+WindowDefinition <- Identifier 'AS'i WindowFrameDefinition\n+\n+SampleEntry <- SampleEntryCount / SampleEntryFunction RepeatableSample?\n+SampleEntryCount <- SampleCount Parens(SampleProperties)?\n+SampleEntryFunction <- SampleFunction? Parens(SampleCount)\n+SampleFunction <- Identifier\n+SampleProperties <- Identifier (',' NumberLiteral)\n+RepeatableSample <- 'REPEATABLE' Parens(NumberLiteral)\n+\n+SampleCount <- Expression SampleUnit?\n+SampleUnit <- '%' / 'PERCENT'i / 'ROWS'i\n+\n+GroupByExpressions <- GroupByList / 'ALL'i\n+GroupByList <- List(GroupByExpression)\n+GroupByExpression <- EmptyGroupingItem / CubeOrRollupClause / GroupingSetsClause / Expression\n+EmptyGroupingItem <- '(' ')'\n+CubeOrRollupClause <- CubeOrRollup Parens(List(Expression))\n+CubeOrRollup <- 'CUBE'i / 'ROLLUP'i\n+GroupingSetsClause <- 'GROUPING'i 'SETS'i Parens(GroupByList)\n+\n+SubqueryReference <- Parens(SelectStatement)\n+\n+OrderByExpression <- Expression DescOrAsc? NullsFirstOrLast?\n+DescOrAsc <- 'DESC'i / 'DESCENDING'i / 'ASC'i / 'ASCENDING'i\n+NullsFirstOrLast <- 'NULLS'i 'FIRST'i / 'LAST'i\n+OrderByClause <- 'ORDER'i 'BY'i OrderByExpressions\n+OrderByExpressions <- List(OrderByExpression) / OrderByAll\n+OrderByAll <- 'ALL'i DescOrAsc? NullsFirstOrLast?\n+\n+LimitClause <- 'LIMIT'i LimitValue\n+OffsetClause <- 'OFFSET'i LimitValue\n+LimitValue <- 'ALL'i / (NumberLiteral 'PERCENT'i) / (Expression '%'?)\n+\n+AliasedExpression <- Expression ('AS'i? Identifier)?\n+\n+ValuesClause <- 'VALUES'i List(ValuesExpressions)\n+ValuesExpressions <- Parens(List(Expression))\n+\n+TransactionStatement <- BeginTransaction / RollbackTransaction / CommitTransaction\n+\n+BeginTransaction <- StartOrBegin Transaction? ReadOrWrite?\n+RollbackTransaction <- AbortOrRollback Transaction?\n+CommitTransaction <- CommitOrEnd Transaction?\n+\n+StartOrBegin <- 'START'i / 'BEGIN'i\n+Transaction <- 'WORK'i / 'TRANSACTION'i\n+ReadOrWrite <- 'READ'i ('ONLY'i / 'WRITE'i)\n+AbortOrRollback <- 'ABORT'i / 'ROLLBACK'i\n+CommitOrEnd <- 'COMMIT'i / 'END'i\n+\n+DeleteStatement <- WithClause? 'DELETE'i 'FROM'i InsertTarget DeleteUsingClause? WhereClause? ReturningClause?\n+TruncateStatement <- 'TRUNCATE'i 'TABLE'i? BaseTableName\n+\n+DeleteUsingClause <- 'USING'i List(TableRef)\n+\n+CreateTypeStmt <- 'TYPE'i IfNotExists? QualifiedName 'AS'i Type\n+\n+SetStatement <- 'SET'i (StandardAssignment / SetTimeZone)\n+\n+StandardAssignment <- (SetVariable / SetSetting) SetAssignment\n+SetTimeZone <- 'TIME'i 'ZONE'i Expression\n+SetSetting <- SettingScope? SettingName\n+SetVariable <- 'VARIABLE'i Identifier\n+\n+SettingScope <- 'LOCAL'i / 'SESSION'i / 'GLOBAL'i\n+\n+SetAssignment <- VariableAssign VariableList\n+\n+VariableAssign <- '=' / 'TO'\n+VariableList <- List(Expression)\n+\n+ResetStatement <- 'RESET'i (SetSetting / SetVariable)\n+\n+ExportStatement <- 'EXPORT'i 'DATABASE'i ExportSource? StringLiteral Parens(GenericCopyOptionList)?\n+\n+ExportSource <- CatalogName 'TO'i\n+\n+ImportStatement <- 'IMPORT'i 'DATABASE'i StringLiteral\n+\n+CheckpointStatement <- 'FORCE'i? 'CHECKPOINT'i CatalogName?\n+\n+CopyStatement <- 'COPY'i (CopyTable / CopySelect / CopyFromDatabase)\n+\n+CopyTable <- BaseTableName InsertColumnList? FromOrTo CopyFileName CopyOptions?\n+FromOrTo <- 'FROM'i / 'TO'i\n+\n+CopySelect <- Parens(SelectStatement) 'TO'i CopyFileName CopyOptions?\n+\n+CopyFileName <- StringLiteral / Identifier\n+CopyOptions <- 'WITH'i? (Parens(GenericCopyOptionList) / (SpecializedOptions*))\n+SpecializedOptions <-\n+\t'BINARY'i / 'FREEZE'i / 'OIDS'i / 'CSV'i / 'HEADER'i /\n+\tSpecializedStringOption /\n+\t('ENCODING'i StringLiteral) /\n+\t('FORCE'i 'QUOTE'i StarOrColumnList) /\n+\t('PARTITION'i 'BY'i StarOrColumnList) /\n+\t('FORCE'i 'NOT'i? 'NULL'i ColumnList)\n+\n+SpecializedStringOption <- ('DELIMITER'i / 'NULL'i / 'QUOTE'i / 'ESCAPE'i) 'AS'i? StringLiteral\n+\n+StarOrColumnList <- '*' / ColumnList\n+\n+GenericCopyOptionList <- List(GenericCopyOption)\n+GenericCopyOption <- GenericCopyOptionName Expression?\n+# FIXME: should not need to hard-code options here\n+GenericCopyOptionName <- 'ARRAY'i / 'NULL'i / 'ANALYZE'i / CopyOptionName\n+\n+CopyFromDatabase <- 'FROM'i 'DATABASE'i Identifier 'TO'i Identifier CopyDatabaseFlag?\n+\n+CopyDatabaseFlag <- Parens(SchemaOrData)\n+SchemaOrData <- 'SCHEMA'i / 'DATA'i\n+\n+AlterStatement <- 'ALTER'i AlterOptions\n+\n+\n+AlterOptions <- AlterTableStmt / AlterViewStmt / AlterSequenceStmt\n+\n+AlterTableStmt <- 'TABLE'i IfExists? BaseTableName AlterTableOptions\n+\n+AlterTableOptions <- AddColumn / DropColumn / AlterColumn / AddConstraint / ChangeNullability / RenameColumn / RenameAlter\n+\n+AddConstraint <- 'ADD'i TopLevelConstraint\n+AddColumn <- 'ADD'i 'COLUMN'i? IfNotExists? ColumnDefinition\n+DropColumn <- 'DROP'i 'COLUMN'i? IfExists? ColumnName DropBehavior?\n+AlterColumn <- 'ALTER'i 'COLUMN'i? Identifier AlterColumnEntry\n+RenameColumn <- 'RENAME'i 'COLUMN'i? ColumnName 'TO'i Identifier\n+RenameAlter <- 'RENAME'i 'TO'i Identifier\n+\n+AlterColumnEntry <- AddOrDropDefault / ChangeNullability / AlterType\n+\n+AddOrDropDefault <- AddDefault / DropDefault\n+AddDefault <- 'SET'i 'DEFAULT'i Expression\n+DropDefault <- 'DROP'i 'DEFAULT'i\n+\n+ChangeNullability <- ('DROP'i / 'SET'i) 'NOT'i 'NULL'i\n+\n+AlterType <- SetData? 'TYPE'i Type? UsingExpression?\n+SetData <- 'SET'i 'DATA'i?\n+UsingExpression <- 'USING'i Expression\n+\n+AlterViewStmt <- 'VIEW'i IfExists? BaseTableName RenameAlter\n+\n+AlterSequenceStmt <- 'SEQUENCE'i IfExists? QualifiedSequenceName AlterSequenceOptions\n+\n+QualifiedSequenceName <- CatalogQualification? SchemaQualification? SequenceName\n+\n+AlterSequenceOptions <- RenameAlter / SetSequenceOption\n+SetSequenceOption <- List(SequenceOption)\n+CreateSequenceStmt <- 'SEQUENCE'i IfNotExists? QualifiedName SequenceOption*\n+\n+SequenceOption <-\n+\tSeqSetCycle /\n+\tSeqSetIncrement /\n+\tSeqSetMinMax /\n+\tSeqNoMinMax /\n+\tSeqStartWith /\n+\tSeqOwnedBy\n+\n+SeqSetCycle <- 'NO'i? 'CYCLE'i\n+SeqSetIncrement <- 'INCREMENT'i 'BY'i? Expression\n+SeqSetMinMax <- SeqMinOrMax Expression\n+SeqNoMinMax <- 'NO'i SeqMinOrMax\n+SeqStartWith <- 'START'i 'WITH'i? Expression\n+SeqOwnedBy <- 'OWNED'i 'BY'i QualifiedName\n+\n+\n+SeqMinOrMax <- 'MINVALUE'i / 'MAXVALUE'i\n+\n+\n+Statement <-\n+\tCreateStatement /\n+\tSelectStatement /\n+\tSetStatement /\n+\tPragmaStatement /\n+\tCallStatement /\n+\tInsertStatement /\n+\tDropStatement /\n+\tCopyStatement /\n+\tExplainStatement /\n+\tUpdateStatement /\n+\tPrepareStatement /\n+\tExecuteStatement /\n+\tAlterStatement /\n+\tTransactionStatement /\n+\tDeleteStatement /\n+\tAttachStatement /\n+\tUseStatement /\n+\tDetachStatement /\n+\tCheckpointStatement /\n+\tVacuumStatement /\n+\tResetStatement /\n+\tExportStatement /\n+\tImportStatement /\n+\tCommentStatement /\n+\tDeallocateStatement /\n+\tTruncateStatement\n+\n+TypeName <- Identifier\n+CatalogName <- Identifier\n+SchemaName <- Identifier\n+TableName <- Identifier\n+ColumnName <- Identifier\n+IndexName <- Identifier\n+FunctionName <- Identifier\n+SettingName <- Identifier\n+PragmaName <- Identifier\n+TableFunctionName <- Identifier\n+ConstraintName <- Identifier\n+SequenceName <- Identifier\n+CollationName <- Identifier\n+CopyOptionName <- Identifier\n+SecretName <- Identifier\n+\n+NumberLiteral <- < [+-]?[0-9]*([.][0-9]*)? >\n+StringLiteral <- '\\'' [^\\']* '\\''\n+\n+Type <- (TimeType / RowType / MapType / UnionType / DoubleType / SimpleType) ArrayBounds*\n+SimpleType <- QualifiedTypeName TypeModifiers?\n+DoubleType <- 'DOUBLE'i 'PRECISION'\n+QualifiedTypeName <- CatalogQualification? SchemaQualification? TypeName\n+TypeModifiers <- Parens(List(Expression))\n+RowType <- RowOrStruct Parens(List(IdentifierType))\n+UnionType <- 'UNION'i Parens(List(IdentifierType))\n+MapType <- 'MAP'i Parens(List(Type))\n+IdentifierType <- Identifier Type\n+ArrayBounds <- ('[' NumberLiteral? ']') / 'ARRAY'\n+TimeType <- TimeOrTimestamp TypeModifiers? TimeZone?\n+TimeOrTimestamp <- 'TIME'i / 'TIMESTAMP'i\n+TimeZone <- WithOrWithout 'TIME'i 'ZONE'i\n+WithOrWithout <- 'WITH'i / 'WITHOUT'i\n+\n+RowOrStruct <- 'ROW'i / 'STRUCT'i\n+\n+# keywords\n+ReservedKeyword <- 'ALL'i /\n+'ANALYSE'i /\n+'ANALYZE'i /\n+'AND'i /\n+'ANY'i /\n+'ARRAY'i /\n+'AS'i /\n+'ASC_P'i /\n+'ASYMMETRIC'i /\n+'BOTH'i /\n+'CASE'i /\n+'CAST'i /\n+'CHECK_P'i /\n+'COLLATE'i /\n+'COLUMN'i /\n+'CONSTRAINT'i /\n+'CREATE_P'i /\n+'DEFAULT'i /\n+'DEFERRABLE'i /\n+'DESC_P'i /\n+'DESCRIBE'i /\n+'DISTINCT'i /\n+'DO'i /\n+'ELSE'i /\n+'END_P'i /\n+'EXCEPT'i /\n+'FALSE_P'i /\n+'FETCH'i /\n+'FOR'i /\n+'FOREIGN'i /\n+'FROM'i /\n+'GRANT'i /\n+'GROUP_P'i /\n+'HAVING'i /\n+'QUALIFY'i /\n+'IN_P'i /\n+'INITIALLY'i /\n+'INTERSECT'i /\n+'INTO'i /\n+'LATERAL_P'i /\n+'LEADING'i /\n+'LIMIT'i /\n+'NOT'i /\n+'NULL_P'i /\n+'OFFSET'i /\n+'ON'i /\n+'ONLY'i /\n+'OR'i /\n+'ORDER'i /\n+'PIVOT'i /\n+'PIVOT_WIDER'i /\n+'PIVOT_LONGER'i /\n+'PLACING'i /\n+'PRIMARY'i /\n+'REFERENCES'i /\n+'RETURNING'i /\n+'SELECT'i /\n+'SHOW'i /\n+'SOME'i /\n+'SUMMARIZE'i /\n+'SYMMETRIC'i /\n+'TABLE'i /\n+'THEN'i /\n+'TO'i /\n+'TRAILING'i /\n+'TRUE_P'i /\n+'UNION'i /\n+'UNIQUE'i /\n+'UNPIVOT'i /\n+'USING'i /\n+'VARIADIC'i /\n+'WHEN'i /\n+'WHERE'i /\n+'WINDOW'i /\n+'WITH'i\n+\n+\n+# internal definitions\n+%whitespace <- [ \\t\\n\\r]*\n+List(D) <- D (',' D)* ','?\n+Parens(D) <- '(' D ')'\n+\n+ExplainStatement <- 'EXPLAIN'i 'ANALYZE'i? ExplainOptions? Statement\n+\n+ExplainOptions <- Parens(GenericCopyOptionList)\n+\n+CreateMacroStmt <- MacroOrFunction IfNotExists? QualifiedName List(MacroDefinition)\n+\n+MacroOrFunction <- 'MACRO'i / 'FUNCTION'i\n+\n+MacroDefinition <- Parens(MacroParameters?) 'AS'i (ScalarMacroDefinition / TableMacroDefinition)\n+\n+MacroParameters <- List(MacroParameter)\n+MacroParameter <- NamedParameter / Identifier\n+\n+ScalarMacroDefinition <- Expression\n+TableMacroDefinition <- 'TABLE'i SelectStatement\n+\n+CommentStatement <- 'COMMENT'i 'ON'i CommentOnType ColumnReference 'IS'i CommentValue\n+\n+\n+CommentOnType <- 'TABLE'i / 'SEQUENCE'i / 'FUNCTION'i / ('MACRO'i 'TABLE'i?) / 'VIEW'i / 'DATABASE'i / 'INDEX'i / 'SCHEMA'i / 'TYPE'i / 'COLUMN'i\n+CommentValue <- 'NULL'i / StringLiteral\n+\n+AttachStatement <- 'ATTACH'i IfNotExists? Database? DatabasePath AttachAlias? AttachOptions?\n+\n+Database <- 'DATABASE'i\n+DatabasePath <- StringLiteral\n+AttachAlias <- 'AS'i Identifier\n+AttachOptions <- Parens(GenericCopyOptionList)\n+\n+DetachStatement <- 'DETACH'i Database? IfExists? CatalogName\n+\n+UseStatement <- 'USE'i UseTarget\n+\n+UseTarget <- (CatalogName '.' SchemaName) / SchemaName / CatalogName\n+\n+CallStatement <- 'CALL'i TableFunctionName TableFunctionArguments\n+\ndiff --git a/extension/core_functions/lambda_functions.cpp b/extension/core_functions/lambda_functions.cpp\nindex b5549914a964..29e583591ee8 100644\n--- a/extension/core_functions/lambda_functions.cpp\n+++ b/extension/core_functions/lambda_functions.cpp\n@@ -223,17 +223,6 @@ void ExecuteExpression(const idx_t elem_cnt, const LambdaFunctions::ColumnInfo &\n // ListLambdaBindData\n //===--------------------------------------------------------------------===//\n \n-unique_ptr<FunctionData> ListLambdaBindData::Copy() const {\n-\tauto lambda_expr_copy = lambda_expr ? lambda_expr->Copy() : nullptr;\n-\treturn make_uniq<ListLambdaBindData>(return_type, std::move(lambda_expr_copy), has_index);\n-}\n-\n-bool ListLambdaBindData::Equals(const FunctionData &other_p) const {\n-\tauto &other = other_p.Cast<ListLambdaBindData>();\n-\treturn Expression::Equals(lambda_expr, other.lambda_expr) && return_type == other.return_type &&\n-\t       has_index == other.has_index;\n-}\n-\n void ListLambdaBindData::Serialize(Serializer &serializer, const optional_ptr<FunctionData> bind_data_p,\n                                    const ScalarFunction &) {\n \tauto &bind_data = bind_data_p->Cast<ListLambdaBindData>();\ndiff --git a/extension/icu/icu-datefunc.cpp b/extension/icu/icu-datefunc.cpp\nindex a8092b628de9..c744b6870a49 100644\n--- a/extension/icu/icu-datefunc.cpp\n+++ b/extension/icu/icu-datefunc.cpp\n@@ -71,13 +71,20 @@ unique_ptr<FunctionData> ICUDateFunc::Bind(ClientContext &context, ScalarFunctio\n \treturn make_uniq<BindData>(context);\n }\n \n-void ICUDateFunc::SetTimeZone(icu::Calendar *calendar, const string_t &tz_id) {\n+bool ICUDateFunc::TrySetTimeZone(icu::Calendar *calendar, const string_t &tz_id) {\n \tauto tz = icu::TimeZone::createTimeZone(icu::UnicodeString::fromUTF8(icu::StringPiece(tz_id.GetString())));\n \tif (*tz == icu::TimeZone::getUnknown()) {\n \t\tdelete tz;\n-\t\tthrow NotImplementedException(\"Unknown TimeZone '%s'\", tz_id.GetString());\n+\t\treturn false;\n \t}\n \tcalendar->adoptTimeZone(tz);\n+\treturn true;\n+}\n+\n+void ICUDateFunc::SetTimeZone(icu::Calendar *calendar, const string_t &tz_id) {\n+\tif (!TrySetTimeZone(calendar, tz_id)) {\n+\t\tthrow NotImplementedException(\"Unknown TimeZone '%s'\", tz_id.GetString());\n+\t}\n }\n \n timestamp_t ICUDateFunc::GetTimeUnsafe(icu::Calendar *calendar, uint64_t micros) {\ndiff --git a/extension/icu/icu-strptime.cpp b/extension/icu/icu-strptime.cpp\nindex d4a841d49560..298b0b2e5ff2 100644\n--- a/extension/icu/icu-strptime.cpp\n+++ b/extension/icu/icu-strptime.cpp\n@@ -12,6 +12,7 @@\n #include \"duckdb/function/scalar/strftime_format.hpp\"\n #include \"duckdb/main/client_context.hpp\"\n #include \"duckdb/planner/expression/bound_function_expression.hpp\"\n+#include \"duckdb/function/cast/default_casts.hpp\"\n #include \"duckdb/main/extension_util.hpp\"\n \n namespace duckdb {\n@@ -57,14 +58,7 @@ struct ICUStrptime : public ICUDateFunc {\n \t}\n \n \tstatic uint64_t ToMicros(icu::Calendar *calendar, const ParseResult &parsed, const StrpTimeFormat &format) {\n-\t\t// Set TZ first, if any.\n-\t\t// Note that empty TZ names are not allowed,\n-\t\t// but unknown names will map to GMT.\n-\t\tif (!parsed.tz.empty()) {\n-\t\t\tSetTimeZone(calendar, parsed.tz);\n-\t\t}\n-\n-\t\t// Now get the parts in the given time zone\n+\t\t// Get the parts in the current time zone\n \t\tuint64_t micros = parsed.GetMicros();\n \t\tcalendar->set(UCAL_EXTENDED_YEAR, parsed.data[0]); // strptime doesn't understand eras\n \t\tcalendar->set(UCAL_MONTH, parsed.data[1] - 1);\n@@ -107,6 +101,11 @@ struct ICUStrptime : public ICUDateFunc {\n \t\t\t\t\t\tif (parsed.is_special) {\n \t\t\t\t\t\t\treturn parsed.ToTimestamp();\n \t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t// Set TZ first, if any.\n+\t\t\t\t\t\t\tif (!parsed.tz.empty()) {\n+\t\t\t\t\t\t\t\tSetTimeZone(calendar, parsed.tz);\n+\t\t\t\t\t\t\t}\n+\n \t\t\t\t\t\t\treturn GetTime(calendar, ToMicros(calendar, parsed, format));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n@@ -140,7 +139,7 @@ struct ICUStrptime : public ICUDateFunc {\n \t\t\t\t\t    if (format.Parse(input, parsed)) {\n \t\t\t\t\t\t    if (parsed.is_special) {\n \t\t\t\t\t\t\t    return parsed.ToTimestamp();\n-\t\t\t\t\t\t    } else {\n+\t\t\t\t\t\t    } else if (parsed.tz.empty() || TrySetTimeZone(calendar, parsed.tz)) {\n \t\t\t\t\t\t\t    timestamp_t result;\n \t\t\t\t\t\t\t    if (TryGetTime(calendar, ToMicros(calendar, parsed, format), result)) {\n \t\t\t\t\t\t\t\t    return result;\ndiff --git a/extension/icu/include/icu-datefunc.hpp b/extension/icu/include/icu-datefunc.hpp\nindex 2c837f2f1ffd..cc14203242f7 100644\n--- a/extension/icu/include/icu-datefunc.hpp\n+++ b/extension/icu/include/icu-datefunc.hpp\n@@ -49,7 +49,9 @@ struct ICUDateFunc {\n \tstatic duckdb::unique_ptr<FunctionData> Bind(ClientContext &context, ScalarFunction &bound_function,\n \t                                             vector<duckdb::unique_ptr<Expression>> &arguments);\n \n-\t//! Sets the time zone for the calendar.\n+\t//! Tries to set the time zone for the calendar and returns false if it is not valid.\n+\tstatic bool TrySetTimeZone(icu::Calendar *calendar, const string_t &tz_id);\n+\t//! Sets the time zone for the calendar. Throws if it is not valid\n \tstatic void SetTimeZone(icu::Calendar *calendar, const string_t &tz_id);\n \t//! Gets the timestamp from the calendar, throwing if it is not in range.\n \tstatic bool TryGetTime(icu::Calendar *calendar, uint64_t micros, timestamp_t &result);\ndiff --git a/extension/parquet/include/writer/primitive_column_writer.hpp b/extension/parquet/include/writer/primitive_column_writer.hpp\nindex f3bea0323b1f..1093b7783e49 100644\n--- a/extension/parquet/include/writer/primitive_column_writer.hpp\n+++ b/extension/parquet/include/writer/primitive_column_writer.hpp\n@@ -20,6 +20,7 @@ struct PageInformation {\n \tidx_t row_count = 0;\n \tidx_t empty_count = 0;\n \tidx_t estimated_page_size = 0;\n+\tidx_t null_count = 0;\n };\n \n struct PageWriteInformation {\ndiff --git a/extension/parquet/include/writer/templated_column_writer.hpp b/extension/parquet/include/writer/templated_column_writer.hpp\nindex 7bf1fa205f9b..481c6881df6b 100644\n--- a/extension/parquet/include/writer/templated_column_writer.hpp\n+++ b/extension/parquet/include/writer/templated_column_writer.hpp\n@@ -131,7 +131,8 @@ class StandardColumnWriter : public PrimitiveColumnWriter {\n \t\tauto &state = state_p.Cast<StandardColumnWriterState<SRC, TGT, OP>>();\n \t\tconst auto &page_info = state_p.page_info[page_idx];\n \t\tauto result = make_uniq<StandardWriterPageState<SRC, TGT, OP>>(\n-\t\t    page_info.row_count - page_info.empty_count, state.total_string_size, state.encoding, state.dictionary);\n+\t\t    page_info.row_count - (page_info.empty_count + page_info.null_count), state.total_string_size,\n+\t\t    state.encoding, state.dictionary);\n \t\treturn std::move(result);\n \t}\n \ndiff --git a/extension/parquet/writer/primitive_column_writer.cpp b/extension/parquet/writer/primitive_column_writer.cpp\nindex d6a0a00f2cc5..c0c2367175be 100644\n--- a/extension/parquet/writer/primitive_column_writer.cpp\n+++ b/extension/parquet/writer/primitive_column_writer.cpp\n@@ -75,6 +75,8 @@ void PrimitiveColumnWriter::Prepare(ColumnWriterState &state_p, ColumnWriterStat\n \t\t\t\t\tstate.page_info.push_back(new_info);\n \t\t\t\t\tpage_info_ref = state.page_info.back();\n \t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tpage_info.null_count++;\n \t\t\t}\n \t\t\tvector_index++;\n \t\t}\ndiff --git a/scripts/generate_c_api.py b/scripts/generate_c_api.py\nindex 17fafcd6341b..b81e4c2c5a95 100644\n--- a/scripts/generate_c_api.py\n+++ b/scripts/generate_c_api.py\n@@ -296,7 +296,7 @@ def create_function_declaration(function_obj):\n     function_return_type = function_obj['return_type']\n \n     # Construct function declaration\n-    result += f'DUCKDB_API {function_return_type}'\n+    result += f'DUCKDB_C_API {function_return_type}'\n     if result[-1] != '*':\n         result += ' '\n     result += f'{function_name}('\ndiff --git a/scripts/generate_extensions_function.py b/scripts/generate_extensions_function.py\nindex eefd6dfffb06..75ec0a731798 100644\n--- a/scripts/generate_extensions_function.py\n+++ b/scripts/generate_extensions_function.py\n@@ -724,7 +724,8 @@ def write_header(data: ExtensionData):\n     \"postgres_scanner\",\n     \"tpcds\",\n     \"tpch\",\n-    \"uc_catalog\"\n+    \"uc_catalog\",\n+    \"ui\"\n }; // END_OF_AUTOLOADABLE_EXTENSIONS\n \n } // namespace duckdb\"\"\"\ndiff --git a/src/catalog/catalog.cpp b/src/catalog/catalog.cpp\nindex 7d7e52657629..6821de734f0a 100644\n--- a/src/catalog/catalog.cpp\n+++ b/src/catalog/catalog.cpp\n@@ -769,6 +769,12 @@ CatalogEntryLookup Catalog::TryLookupEntry(CatalogEntryRetriever &retriever, Cat\n \n \tif (if_not_found == OnEntryNotFound::RETURN_NULL) {\n \t\treturn {nullptr, nullptr, ErrorData()};\n+\t}\n+\t// Check if the default database is actually attached. CreateMissingEntryException will throw binder exception\n+\t// otherwise.\n+\tif (!GetCatalogEntry(context, GetDefaultCatalog(retriever))) {\n+\t\tauto except = CatalogException(\"%s with name %s does not exist!\", CatalogTypeToString(type), name);\n+\t\treturn {nullptr, nullptr, ErrorData(except)};\n \t} else {\n \t\tauto except = CreateMissingEntryException(retriever, name, type, schemas, error_context);\n \t\treturn {nullptr, nullptr, ErrorData(except)};\n@@ -805,6 +811,12 @@ CatalogEntryLookup Catalog::TryLookupEntry(CatalogEntryRetriever &retriever, vec\n \n \tif (if_not_found == OnEntryNotFound::RETURN_NULL) {\n \t\treturn {nullptr, nullptr, ErrorData()};\n+\t}\n+\t// Check if the default database is actually attached. CreateMissingEntryException will throw binder exception\n+\t// otherwise.\n+\tif (!GetCatalogEntry(context, GetDefaultCatalog(retriever))) {\n+\t\tauto except = CatalogException(\"%s with name %s does not exist!\", CatalogTypeToString(type), name);\n+\t\treturn {nullptr, nullptr, ErrorData(except)};\n \t} else {\n \t\tauto except = CreateMissingEntryException(retriever, name, type, schemas, error_context);\n \t\treturn {nullptr, nullptr, ErrorData(except)};\ndiff --git a/src/catalog/catalog_entry/duck_table_entry.cpp b/src/catalog/catalog_entry/duck_table_entry.cpp\nindex d12bc557e7aa..e2cd7110eb08 100644\n--- a/src/catalog/catalog_entry/duck_table_entry.cpp\n+++ b/src/catalog/catalog_entry/duck_table_entry.cpp\n@@ -863,7 +863,7 @@ unique_ptr<CatalogEntry> DuckTableEntry::Copy(ClientContext &context) const {\n \t}\n \n \tauto binder = Binder::CreateBinder(context);\n-\tauto bound_create_info = binder->BindCreateTableInfo(std::move(create_info), schema);\n+\tauto bound_create_info = binder->BindCreateTableCheckpoint(std::move(create_info), schema);\n \treturn make_uniq<DuckTableEntry>(catalog, schema, *bound_create_info, storage);\n }\n \ndiff --git a/src/execution/aggregate_hashtable.cpp b/src/execution/aggregate_hashtable.cpp\nindex 852e3aa4f900..2b9c5d82a7ca 100644\n--- a/src/execution/aggregate_hashtable.cpp\n+++ b/src/execution/aggregate_hashtable.cpp\n@@ -329,7 +329,7 @@ optional_idx GroupedAggregateHashTable::TryAddDictionaryGroups(DataChunk &groups\n \tif (dictionary_id.empty()) {\n \t\t// dictionary has no id, we can't cache across vectors\n \t\t// only use dictionary compression if there are fewer entries than groups\n-\t\tif (dict_size >= groups.size() * DICTIONARY_THRESHOLD) {\n+\t\tif (dict_size * DICTIONARY_THRESHOLD >= groups.size()) {\n \t\t\t// dictionary is too large - use regular aggregation\n \t\t\treturn optional_idx();\n \t\t}\ndiff --git a/src/execution/index/art/art.cpp b/src/execution/index/art/art.cpp\nindex 2d0f00301083..c47f7740b976 100644\n--- a/src/execution/index/art/art.cpp\n+++ b/src/execution/index/art/art.cpp\n@@ -1038,9 +1038,11 @@ string ART::GenerateConstraintErrorMessage(VerifyExistenceType verify_type, cons\n \t}\n \tcase VerifyExistenceType::DELETE_FK: {\n \t\t// DELETE_FK that still exists in a FK table, i.e., not a valid delete.\n-\t\treturn StringUtil::Format(\"Violates foreign key constraint because key \\\"%s\\\" is still referenced by a foreign \"\n-\t\t                          \"key in a different table\",\n-\t\t                          key_name);\n+\t\treturn StringUtil::Format(\n+\t\t    \"Violates foreign key constraint because key \\\"%s\\\" is still referenced by a foreign \"\n+\t\t    \"key in a different table. If this is an unexpected constraint violation, please refer to our \"\n+\t\t    \"foreign key limitations in the documentation\",\n+\t\t    key_name);\n \t}\n \tdefault:\n \t\tthrow NotImplementedException(\"Type not implemented for VerifyExistenceType\");\n@@ -1091,16 +1093,27 @@ void ART::VerifyLeaf(const Node &leaf, const ARTKey &key, optional_ptr<ART> dele\n \t\treturn;\n \t}\n \n+\t// Fast path for FOREIGN KEY constraints.\n+\t// Up to here, the above code paths work implicitly for FKs, as the leaf is inlined.\n \t// FIXME: proper foreign key + delete ART support.\n-\t// This implicitly works for foreign keys, as we do not have to consider the actual row IDs.\n-\t// We only need to know that there are conflicts (for now), as we still perform over-eager constraint checking.\n+\tif (index_constraint_type == IndexConstraintType::FOREIGN) {\n+\t\tD_ASSERT(!deleted_leaf);\n+\t\t// We don't handle FK conflicts in UPSERT, so the row ID should not matter.\n+\t\tif (manager.AddHit(i, MAX_ROW_ID)) {\n+\t\t\tconflict_idx = i;\n+\t\t}\n+\t\treturn;\n+\t}\n \n \t// Scan the two row IDs in the leaf.\n \tIterator it(*this);\n \tit.FindMinimum(leaf);\n \tARTKey empty_key = ARTKey();\n \tunsafe_vector<row_t> row_ids;\n-\tit.Scan(empty_key, 2, row_ids, false);\n+\tauto success = it.Scan(empty_key, 2, row_ids, false);\n+\tif (!success || row_ids.size() != 2) {\n+\t\tthrow InternalException(\"VerifyLeaf expects exactly two row IDs to be scanned\");\n+\t}\n \n \tif (!deleted_leaf) {\n \t\tif (manager.AddHit(i, row_ids[0]) || manager.AddHit(i, row_ids[1])) {\ndiff --git a/src/execution/operator/csv_scanner/sniffer/dialect_detection.cpp b/src/execution/operator/csv_scanner/sniffer/dialect_detection.cpp\nindex a6e9f915597d..7791e64b420d 100644\n--- a/src/execution/operator/csv_scanner/sniffer/dialect_detection.cpp\n+++ b/src/execution/operator/csv_scanner/sniffer/dialect_detection.cpp\n@@ -397,7 +397,13 @@ void CSVSniffer::AnalyzeDialectCandidate(unique_ptr<ColumnCountScanner> scanner,\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif (max_columns_found == num_cols && ignored_rows > min_ignored_rows) {\n+\t\tif (max_columns_found == num_cols && (ignored_rows > min_ignored_rows)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tif (max_columns_found > 1 && num_cols > max_columns_found && consistent_rows < best_consistent_rows / 2 &&\n+\t\t    options.null_padding) {\n+\t\t\t// When null_padding is true, we only give preference to a max number of columns if null padding is at least\n+\t\t\t// 50% as consistent as the best case scenario\n \t\t\treturn;\n \t\t}\n \t\tif (quoted && num_cols < max_columns_found) {\n@@ -436,28 +442,19 @@ void CSVSniffer::AnalyzeDialectCandidate(unique_ptr<ColumnCountScanner> scanner,\n \t    !require_more_padding && !invalid_padding && num_cols == max_columns_found && comments_are_acceptable) {\n \t\tauto &sniffing_state_machine = scanner->GetStateMachine();\n \n-\t\tbool same_quote_is_candidate = false;\n-\t\tfor (const auto &candidate : candidates) {\n-\t\t\tif (sniffing_state_machine.dialect_options.state_machine_options.quote ==\n-\t\t\t    candidate->GetStateMachine().dialect_options.state_machine_options.quote) {\n-\t\t\t\tsame_quote_is_candidate = true;\n-\t\t\t}\n-\t\t}\n-\t\tif (!same_quote_is_candidate) {\n-\t\t\tif (options.dialect_options.skip_rows.IsSetByUser()) {\n-\t\t\t\t// If skip rows is set by user, and we found dirty notes, we only accept it if either null_padding or\n-\t\t\t\t// ignore_errors is set\n-\t\t\t\tif (dirty_notes != 0 && !options.null_padding && !options.ignore_errors.GetValue()) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tsniffing_state_machine.dialect_options.skip_rows = options.dialect_options.skip_rows.GetValue();\n-\t\t\t} else if (!options.null_padding) {\n-\t\t\t\tsniffing_state_machine.dialect_options.skip_rows = dirty_notes;\n+\t\tif (options.dialect_options.skip_rows.IsSetByUser()) {\n+\t\t\t// If skip rows is set by user, and we found dirty notes, we only accept it if either null_padding or\n+\t\t\t// ignore_errors is set\n+\t\t\tif (dirty_notes != 0 && !options.null_padding && !options.ignore_errors.GetValue()) {\n+\t\t\t\treturn;\n \t\t\t}\n-\t\t\tsniffing_state_machine.dialect_options.num_cols = num_cols;\n-\t\t\tlines_sniffed = sniffed_column_counts.result_position;\n-\t\t\tcandidates.emplace_back(std::move(scanner));\n+\t\t\tsniffing_state_machine.dialect_options.skip_rows = options.dialect_options.skip_rows.GetValue();\n+\t\t} else if (!options.null_padding) {\n+\t\t\tsniffing_state_machine.dialect_options.skip_rows = dirty_notes;\n \t\t}\n+\t\tsniffing_state_machine.dialect_options.num_cols = num_cols;\n+\t\tlines_sniffed = sniffed_column_counts.result_position;\n+\t\tcandidates.emplace_back(std::move(scanner));\n \t}\n }\n \ndiff --git a/src/execution/operator/csv_scanner/util/csv_error.cpp b/src/execution/operator/csv_scanner/util/csv_error.cpp\nindex 6b3d5dcb357f..330cae1468a9 100644\n--- a/src/execution/operator/csv_scanner/util/csv_error.cpp\n+++ b/src/execution/operator/csv_scanner/util/csv_error.cpp\n@@ -316,6 +316,7 @@ CSVError CSVError::CastError(const CSVReaderOptions &options, const string &colu\n \t\t       \"correctly parse this column.\"\n \t\t    << '\\n';\n \t}\n+\thow_to_fix_it << \"* Check whether the null string value is set correctly (e.g., nullstr = 'N/A')\" << '\\n';\n \n \treturn CSVError(error.str(), CAST_ERROR, column_idx, csv_row, error_info, row_byte_position, byte_position, options,\n \t                how_to_fix_it.str(), current_path);\ndiff --git a/src/execution/operator/scan/physical_table_scan.cpp b/src/execution/operator/scan/physical_table_scan.cpp\nindex 2c821526cee6..cbccf9bdc38e 100644\n--- a/src/execution/operator/scan/physical_table_scan.cpp\n+++ b/src/execution/operator/scan/physical_table_scan.cpp\n@@ -109,7 +109,17 @@ SourceResultType PhysicalTableScan::GetData(ExecutionContext &context, DataChunk\n \tif (g_state.in_out_final) {\n \t\tfunction.in_out_function_final(context, data, chunk);\n \t}\n-\tfunction.in_out_function(context, data, g_state.input_chunk, chunk);\n+\tswitch (function.in_out_function(context, data, g_state.input_chunk, chunk)) {\n+\tcase OperatorResultType::BLOCKED: {\n+\t\tauto guard = g_state.Lock();\n+\t\treturn g_state.BlockSource(guard, input.interrupt_state);\n+\t}\n+\tdefault:\n+\t\t// FIXME: Handling for other cases (such as NEED_MORE_INPUT) breaks current functionality and extensions that\n+\t\t// might be relying on current behaviour. Needs a rework that is not in scope\n+\t\tbreak;\n+\t}\n+\n \tif (chunk.size() == 0 && function.in_out_function_final) {\n \t\tfunction.in_out_function_final(context, data, chunk);\n \t\tg_state.in_out_final = true;\ndiff --git a/src/execution/radix_partitioned_hashtable.cpp b/src/execution/radix_partitioned_hashtable.cpp\nindex a18cd008712b..8ef1dd519836 100644\n--- a/src/execution/radix_partitioned_hashtable.cpp\n+++ b/src/execution/radix_partitioned_hashtable.cpp\n@@ -97,6 +97,7 @@ struct RadixHTConfig {\n \tvoid SetRadixBits(const idx_t &radix_bits_p);\n \tbool SetRadixBitsToExternal();\n \tidx_t GetRadixBits() const;\n+\tidx_t GetMaximumSinkRadixBits() const;\n \tidx_t GetExternalRadixBits() const;\n \n private:\n@@ -161,7 +162,7 @@ class RadixHTGlobalSinkState : public GlobalSinkState {\n \tClientContext &context;\n \t//! Temporary memory state for managing this hash table's memory usage\n \tunique_ptr<TemporaryMemoryState> temporary_memory_state;\n-\tidx_t minimum_reservation;\n+\tatomic<idx_t> minimum_reservation;\n \n \t//! Whether we've called Finalize\n \tbool finalized;\n@@ -211,11 +212,11 @@ RadixHTGlobalSinkState::RadixHTGlobalSinkState(ClientContext &context_p, const R\n \tauto tuples_per_block = block_alloc_size / radix_ht.GetLayout().GetRowWidth();\n \tidx_t ht_count =\n \t    LossyNumericCast<idx_t>(static_cast<double>(config.sink_capacity) / GroupedAggregateHashTable::LOAD_FACTOR);\n-\tauto num_partitions = RadixPartitioning::NumberOfPartitions(config.GetExternalRadixBits());\n+\tauto num_partitions = RadixPartitioning::NumberOfPartitions(config.GetMaximumSinkRadixBits());\n \tauto count_per_partition = ht_count / num_partitions;\n-\tauto blocks_per_partition = (count_per_partition + tuples_per_block) / tuples_per_block + 1;\n+\tauto blocks_per_partition = (count_per_partition + tuples_per_block) / tuples_per_block;\n \tif (!radix_ht.GetLayout().AllConstant()) {\n-\t\tblocks_per_partition += 2;\n+\t\tblocks_per_partition += 1;\n \t}\n \tauto ht_size = num_partitions * blocks_per_partition * block_alloc_size + config.sink_capacity * sizeof(ht_entry_t);\n \n@@ -281,6 +282,10 @@ idx_t RadixHTConfig::GetRadixBits() const {\n \treturn sink_radix_bits;\n }\n \n+idx_t RadixHTConfig::GetMaximumSinkRadixBits() const {\n+\treturn maximum_sink_radix_bits;\n+}\n+\n idx_t RadixHTConfig::GetExternalRadixBits() const {\n \treturn MAXIMUM_FINAL_SINK_RADIX_BITS;\n }\n@@ -296,8 +301,12 @@ void RadixHTConfig::SetRadixBitsInternal(const idx_t radix_bits_p, bool external\n \t}\n \n \tif (external) {\n+\t\tconst auto partition_multiplier = RadixPartitioning::NumberOfPartitions(radix_bits_p) /\n+\t\t                                  RadixPartitioning::NumberOfPartitions(sink_radix_bits);\n+\t\tsink.minimum_reservation = sink.minimum_reservation * partition_multiplier;\n \t\tsink.external = true;\n \t}\n+\n \tsink_radix_bits = radix_bits_p;\n }\n \n@@ -590,7 +599,7 @@ idx_t RadixPartitionedHashTable::MaxThreads(GlobalSinkState &sink_p) const {\n \n \t// we cannot spill aggregate state memory\n \tconst auto usable_memory = sink.temporary_memory_state->GetReservation() > sink.stored_allocators_size\n-\t                               ? sink.temporary_memory_state->GetReservation() - sink.max_partition_size\n+\t                               ? sink.temporary_memory_state->GetReservation() - sink.stored_allocators_size\n \t                               : 0;\n \t// This many partitions will fit given our reservation (at least 1))\n \tconst auto partitions_fit = MaxValue<idx_t>(usable_memory / sink.max_partition_size, 1);\ndiff --git a/src/function/window/window_aggregate_states.cpp b/src/function/window/window_aggregate_states.cpp\nindex 2a673ec5458d..7c279cf5ed47 100644\n--- a/src/function/window/window_aggregate_states.cpp\n+++ b/src/function/window/window_aggregate_states.cpp\n@@ -7,6 +7,9 @@ WindowAggregateStates::WindowAggregateStates(const AggregateObject &aggr)\n }\n \n void WindowAggregateStates::Initialize(idx_t count) {\n+\t// Don't leak - every Initialize must be matched with a Destroy\n+\tD_ASSERT(states.empty());\n+\n \tstates.resize(count * state_size);\n \tauto state_ptr = states.data();\n \ndiff --git a/src/function/window/window_distinct_aggregator.cpp b/src/function/window/window_distinct_aggregator.cpp\nindex 77e00a02ee58..1c935826fe55 100644\n--- a/src/function/window/window_distinct_aggregator.cpp\n+++ b/src/function/window/window_distinct_aggregator.cpp\n@@ -744,6 +744,9 @@ void WindowDistinctAggregatorLocalState::Evaluate(const WindowDistinctAggregator\n \n \t//\tFinalise the result aggregates and write to the result\n \tstatef.Finalize(result);\n+\n+\t//\tDestruct any non-POD state\n+\tstatef.Destroy();\n }\n \n unique_ptr<WindowAggregatorState> WindowDistinctAggregator::GetLocalState(const WindowAggregatorState &gstate) const {\ndiff --git a/src/include/duckdb.h b/src/include/duckdb.h\nindex 0a75bd5531ed..3537ac5d6028 100644\n--- a/src/include/duckdb.h\n+++ b/src/include/duckdb.h\n@@ -13,20 +13,19 @@\n \n #pragma once\n \n-//! duplicate of duckdb/main/winapi.hpp\n-#ifndef DUCKDB_API\n+#ifndef DUCKDB_C_API\n #ifdef _WIN32\n #ifdef DUCKDB_STATIC_BUILD\n-#define DUCKDB_API\n+#define DUCKDB_C_API\n #else\n #if defined(DUCKDB_BUILD_LIBRARY) && !defined(DUCKDB_BUILD_LOADABLE_EXTENSION)\n-#define DUCKDB_API __declspec(dllexport)\n+#define DUCKDB_C_API __declspec(dllexport)\n #else\n-#define DUCKDB_API __declspec(dllimport)\n+#define DUCKDB_C_API __declspec(dllimport)\n #endif\n #endif\n #else\n-#define DUCKDB_API\n+#define DUCKDB_C_API\n #endif\n #endif\n \n@@ -696,7 +695,7 @@ process. Must be destroyed with 'duckdb_destroy_instance_cache'.\n \n * @return The database instance cache.\n */\n-DUCKDB_API duckdb_instance_cache duckdb_create_instance_cache();\n+DUCKDB_C_API duckdb_instance_cache duckdb_create_instance_cache();\n \n /*!\n Creates a new database instance in the instance cache, or retrieves an existing database instance.\n@@ -710,16 +709,16 @@ Must be closed with 'duckdb_close'.\n Note that the error message must be freed using `duckdb_free`.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_get_or_create_from_cache(duckdb_instance_cache instance_cache, const char *path,\n-                                                        duckdb_database *out_database, duckdb_config config,\n-                                                        char **out_error);\n+DUCKDB_C_API duckdb_state duckdb_get_or_create_from_cache(duckdb_instance_cache instance_cache, const char *path,\n+                                                          duckdb_database *out_database, duckdb_config config,\n+                                                          char **out_error);\n \n /*!\n Destroys an existing database instance cache and de-allocates its memory.\n \n * @param instance_cache The instance cache to destroy.\n */\n-DUCKDB_API void duckdb_destroy_instance_cache(duckdb_instance_cache *instance_cache);\n+DUCKDB_C_API void duckdb_destroy_instance_cache(duckdb_instance_cache *instance_cache);\n \n /*!\n Creates a new database or opens an existing database file stored at the given path.\n@@ -730,7 +729,7 @@ The database must be closed with 'duckdb_close'.\n * @param out_database The result database object.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_open(const char *path, duckdb_database *out_database);\n+DUCKDB_C_API duckdb_state duckdb_open(const char *path, duckdb_database *out_database);\n \n /*!\n Extended version of duckdb_open. Creates a new database or opens an existing database file stored at the given path.\n@@ -743,8 +742,8 @@ The database must be closed with 'duckdb_close'.\n Note that the error message must be freed using `duckdb_free`.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_open_ext(const char *path, duckdb_database *out_database, duckdb_config config,\n-                                        char **out_error);\n+DUCKDB_C_API duckdb_state duckdb_open_ext(const char *path, duckdb_database *out_database, duckdb_config config,\n+                                          char **out_error);\n \n /*!\n Closes the specified database and de-allocates all memory allocated for that database.\n@@ -754,7 +753,7 @@ Still, it is recommended to always correctly close a database object after you a\n \n * @param database The database object to shut down.\n */\n-DUCKDB_API void duckdb_close(duckdb_database *database);\n+DUCKDB_C_API void duckdb_close(duckdb_database *database);\n \n /*!\n Opens a connection to a database. Connections are required to query the database, and store transactional state\n@@ -765,14 +764,14 @@ The instantiated connection should be closed using 'duckdb_disconnect'.\n * @param out_connection The result connection object.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_connect(duckdb_database database, duckdb_connection *out_connection);\n+DUCKDB_C_API duckdb_state duckdb_connect(duckdb_database database, duckdb_connection *out_connection);\n \n /*!\n Interrupt running query\n \n * @param connection The connection to interrupt\n */\n-DUCKDB_API void duckdb_interrupt(duckdb_connection connection);\n+DUCKDB_C_API void duckdb_interrupt(duckdb_connection connection);\n \n /*!\n Get progress of the running query\n@@ -780,21 +779,21 @@ Get progress of the running query\n * @param connection The working connection\n * @return -1 if no progress or a percentage of the progress\n */\n-DUCKDB_API duckdb_query_progress_type duckdb_query_progress(duckdb_connection connection);\n+DUCKDB_C_API duckdb_query_progress_type duckdb_query_progress(duckdb_connection connection);\n \n /*!\n Closes the specified connection and de-allocates all memory allocated for that connection.\n \n * @param connection The connection to close.\n */\n-DUCKDB_API void duckdb_disconnect(duckdb_connection *connection);\n+DUCKDB_C_API void duckdb_disconnect(duckdb_connection *connection);\n \n /*!\n Returns the version of the linked DuckDB, with a version postfix for dev versions\n \n Usually used for developing C extensions that must return this for a compatibility check.\n */\n-DUCKDB_API const char *duckdb_library_version();\n+DUCKDB_C_API const char *duckdb_library_version();\n \n //===--------------------------------------------------------------------===//\n // Configuration\n@@ -813,7 +812,7 @@ Note that `duckdb_destroy_config` should always be called on the resulting confi\n * @param out_config The result configuration object.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_create_config(duckdb_config *out_config);\n+DUCKDB_C_API duckdb_state duckdb_create_config(duckdb_config *out_config);\n \n /*!\n This returns the total amount of configuration options available for usage with `duckdb_get_config_flag`.\n@@ -822,7 +821,7 @@ This should not be called in a loop as it internally loops over all the options.\n \n * @return The amount of config options available.\n */\n-DUCKDB_API size_t duckdb_config_count();\n+DUCKDB_C_API size_t duckdb_config_count();\n \n /*!\n Obtains a human-readable name and description of a specific configuration option. This can be used to e.g.\n@@ -835,7 +834,7 @@ The result name or description MUST NOT be freed.\n * @param out_description A description of the configuration flag.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_get_config_flag(size_t index, const char **out_name, const char **out_description);\n+DUCKDB_C_API duckdb_state duckdb_get_config_flag(size_t index, const char **out_name, const char **out_description);\n \n /*!\n Sets the specified option for the specified configuration. The configuration option is indicated by name.\n@@ -850,14 +849,14 @@ This can fail if either the name is invalid, or if the value provided for the op\n * @param option The value to set the configuration flag to.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_set_config(duckdb_config config, const char *name, const char *option);\n+DUCKDB_C_API duckdb_state duckdb_set_config(duckdb_config config, const char *name, const char *option);\n \n /*!\n Destroys the specified configuration object and de-allocates all memory allocated for the object.\n \n * @param config The configuration object to destroy.\n */\n-DUCKDB_API void duckdb_destroy_config(duckdb_config *config);\n+DUCKDB_C_API void duckdb_destroy_config(duckdb_config *config);\n \n //===--------------------------------------------------------------------===//\n // Query Execution\n@@ -876,14 +875,14 @@ query fails, otherwise the error stored within the result will not be freed corr\n * @param out_result The query result.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_query(duckdb_connection connection, const char *query, duckdb_result *out_result);\n+DUCKDB_C_API duckdb_state duckdb_query(duckdb_connection connection, const char *query, duckdb_result *out_result);\n \n /*!\n Closes the result and de-allocates all memory allocated for that connection.\n \n * @param result The result to destroy.\n */\n-DUCKDB_API void duckdb_destroy_result(duckdb_result *result);\n+DUCKDB_C_API void duckdb_destroy_result(duckdb_result *result);\n \n /*!\n Returns the column name of the specified column. The result should not need to be freed; the column names will\n@@ -895,7 +894,7 @@ Returns `NULL` if the column is out of range.\n * @param col The column index.\n * @return The column name of the specified column.\n */\n-DUCKDB_API const char *duckdb_column_name(duckdb_result *result, idx_t col);\n+DUCKDB_C_API const char *duckdb_column_name(duckdb_result *result, idx_t col);\n \n /*!\n Returns the column type of the specified column.\n@@ -906,7 +905,7 @@ Returns `DUCKDB_TYPE_INVALID` if the column is out of range.\n * @param col The column index.\n * @return The column type of the specified column.\n */\n-DUCKDB_API duckdb_type duckdb_column_type(duckdb_result *result, idx_t col);\n+DUCKDB_C_API duckdb_type duckdb_column_type(duckdb_result *result, idx_t col);\n \n /*!\n Returns the statement type of the statement that was executed\n@@ -914,7 +913,7 @@ Returns the statement type of the statement that was executed\n * @param result The result object to fetch the statement type from.\n * @return duckdb_statement_type value or DUCKDB_STATEMENT_TYPE_INVALID\n */\n-DUCKDB_API duckdb_statement_type duckdb_result_statement_type(duckdb_result result);\n+DUCKDB_C_API duckdb_statement_type duckdb_result_statement_type(duckdb_result result);\n \n /*!\n Returns the logical column type of the specified column.\n@@ -927,7 +926,7 @@ Returns `NULL` if the column is out of range.\n * @param col The column index.\n * @return The logical column type of the specified column.\n */\n-DUCKDB_API duckdb_logical_type duckdb_column_logical_type(duckdb_result *result, idx_t col);\n+DUCKDB_C_API duckdb_logical_type duckdb_column_logical_type(duckdb_result *result, idx_t col);\n \n /*!\n Returns the number of columns present in a the result object.\n@@ -935,7 +934,7 @@ Returns the number of columns present in a the result object.\n * @param result The result object.\n * @return The number of columns present in the result object.\n */\n-DUCKDB_API idx_t duckdb_column_count(duckdb_result *result);\n+DUCKDB_C_API idx_t duckdb_column_count(duckdb_result *result);\n \n #ifndef DUCKDB_API_NO_DEPRECATED\n /*!\n@@ -946,7 +945,7 @@ Returns the number of rows present in the result object.\n * @param result The result object.\n * @return The number of rows present in the result object.\n */\n-DUCKDB_API idx_t duckdb_row_count(duckdb_result *result);\n+DUCKDB_C_API idx_t duckdb_row_count(duckdb_result *result);\n \n #endif\n /*!\n@@ -956,7 +955,7 @@ queries. For other queries the rows_changed will be 0.\n * @param result The result object.\n * @return The number of rows changed.\n */\n-DUCKDB_API idx_t duckdb_rows_changed(duckdb_result *result);\n+DUCKDB_C_API idx_t duckdb_rows_changed(duckdb_result *result);\n \n #ifndef DUCKDB_API_NO_DEPRECATED\n /*!\n@@ -978,7 +977,7 @@ printf(\"Data for row %d: %d\\n\", row, data[row]);\n * @param col The column index.\n * @return The column data of the specified column.\n */\n-DUCKDB_API void *duckdb_column_data(duckdb_result *result, idx_t col);\n+DUCKDB_C_API void *duckdb_column_data(duckdb_result *result, idx_t col);\n \n /*!\n **DEPRECATED**: Prefer using `duckdb_result_get_chunk` instead.\n@@ -1001,7 +1000,7 @@ if (nullmask[row]) {\n * @param col The column index.\n * @return The nullmask of the specified column.\n */\n-DUCKDB_API bool *duckdb_nullmask_data(duckdb_result *result, idx_t col);\n+DUCKDB_C_API bool *duckdb_nullmask_data(duckdb_result *result, idx_t col);\n \n #endif\n /*!\n@@ -1012,7 +1011,7 @@ The result of this function must not be freed. It will be cleaned up when `duckd\n * @param result The result object to fetch the error from.\n * @return The error of the result.\n */\n-DUCKDB_API const char *duckdb_result_error(duckdb_result *result);\n+DUCKDB_C_API const char *duckdb_result_error(duckdb_result *result);\n \n /*!\n Returns the result error type contained within the result. The error is only set if `duckdb_query` returns\n@@ -1021,7 +1020,7 @@ Returns the result error type contained within the result. The error is only set\n * @param result The result object to fetch the error from.\n * @return The error type of the result.\n */\n-DUCKDB_API duckdb_error_type duckdb_result_error_type(duckdb_result *result);\n+DUCKDB_C_API duckdb_error_type duckdb_result_error_type(duckdb_result *result);\n \n //===--------------------------------------------------------------------===//\n // Result Functions\n@@ -1047,7 +1046,7 @@ Use `duckdb_result_chunk_count` to figure out how many chunks there are in the r\n * @param chunk_index The chunk index to fetch from.\n * @return The resulting data chunk. Returns `NULL` if the chunk index is out of bounds.\n */\n-DUCKDB_API duckdb_data_chunk duckdb_result_get_chunk(duckdb_result result, idx_t chunk_index);\n+DUCKDB_C_API duckdb_data_chunk duckdb_result_get_chunk(duckdb_result result, idx_t chunk_index);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n@@ -1057,7 +1056,7 @@ Checks if the type of the internal result is StreamQueryResult.\n * @param result The result object to check.\n * @return Whether or not the result object is of the type StreamQueryResult\n */\n-DUCKDB_API bool duckdb_result_is_streaming(duckdb_result result);\n+DUCKDB_C_API bool duckdb_result_is_streaming(duckdb_result result);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n@@ -1067,7 +1066,7 @@ Returns the number of data chunks present in the result.\n * @param result The result object\n * @return Number of data chunks present in the result.\n */\n-DUCKDB_API idx_t duckdb_result_chunk_count(duckdb_result result);\n+DUCKDB_C_API idx_t duckdb_result_chunk_count(duckdb_result result);\n \n #endif\n /*!\n@@ -1076,7 +1075,7 @@ Returns the return_type of the given result, or DUCKDB_RETURN_TYPE_INVALID on er\n * @param result The result object\n * @return The return_type\n */\n-DUCKDB_API duckdb_result_type duckdb_result_return_type(duckdb_result result);\n+DUCKDB_C_API duckdb_result_type duckdb_result_return_type(duckdb_result result);\n \n //===--------------------------------------------------------------------===//\n // Safe Fetch Functions\n@@ -1092,126 +1091,126 @@ DUCKDB_API duckdb_result_type duckdb_result_return_type(duckdb_result result);\n \n * @return The boolean value at the specified location, or false if the value cannot be converted.\n */\n-DUCKDB_API bool duckdb_value_boolean(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API bool duckdb_value_boolean(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n \n * @return The int8_t value at the specified location, or 0 if the value cannot be converted.\n */\n-DUCKDB_API int8_t duckdb_value_int8(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API int8_t duckdb_value_int8(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n \n * @return The int16_t value at the specified location, or 0 if the value cannot be converted.\n */\n-DUCKDB_API int16_t duckdb_value_int16(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API int16_t duckdb_value_int16(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n \n * @return The int32_t value at the specified location, or 0 if the value cannot be converted.\n */\n-DUCKDB_API int32_t duckdb_value_int32(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API int32_t duckdb_value_int32(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n \n * @return The int64_t value at the specified location, or 0 if the value cannot be converted.\n */\n-DUCKDB_API int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API int64_t duckdb_value_int64(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n \n * @return The duckdb_hugeint value at the specified location, or 0 if the value cannot be converted.\n */\n-DUCKDB_API duckdb_hugeint duckdb_value_hugeint(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API duckdb_hugeint duckdb_value_hugeint(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n \n * @return The duckdb_uhugeint value at the specified location, or 0 if the value cannot be converted.\n */\n-DUCKDB_API duckdb_uhugeint duckdb_value_uhugeint(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API duckdb_uhugeint duckdb_value_uhugeint(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n \n * @return The duckdb_decimal value at the specified location, or 0 if the value cannot be converted.\n */\n-DUCKDB_API duckdb_decimal duckdb_value_decimal(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API duckdb_decimal duckdb_value_decimal(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n \n * @return The uint8_t value at the specified location, or 0 if the value cannot be converted.\n */\n-DUCKDB_API uint8_t duckdb_value_uint8(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API uint8_t duckdb_value_uint8(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n \n * @return The uint16_t value at the specified location, or 0 if the value cannot be converted.\n */\n-DUCKDB_API uint16_t duckdb_value_uint16(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API uint16_t duckdb_value_uint16(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n \n * @return The uint32_t value at the specified location, or 0 if the value cannot be converted.\n */\n-DUCKDB_API uint32_t duckdb_value_uint32(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API uint32_t duckdb_value_uint32(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n \n * @return The uint64_t value at the specified location, or 0 if the value cannot be converted.\n */\n-DUCKDB_API uint64_t duckdb_value_uint64(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API uint64_t duckdb_value_uint64(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n \n * @return The float value at the specified location, or 0 if the value cannot be converted.\n */\n-DUCKDB_API float duckdb_value_float(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API float duckdb_value_float(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n \n * @return The double value at the specified location, or 0 if the value cannot be converted.\n */\n-DUCKDB_API double duckdb_value_double(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API double duckdb_value_double(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n \n * @return The duckdb_date value at the specified location, or 0 if the value cannot be converted.\n */\n-DUCKDB_API duckdb_date duckdb_value_date(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API duckdb_date duckdb_value_date(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n \n * @return The duckdb_time value at the specified location, or 0 if the value cannot be converted.\n */\n-DUCKDB_API duckdb_time duckdb_value_time(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API duckdb_time duckdb_value_time(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n \n * @return The duckdb_timestamp value at the specified location, or 0 if the value cannot be converted.\n */\n-DUCKDB_API duckdb_timestamp duckdb_value_timestamp(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API duckdb_timestamp duckdb_value_timestamp(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n \n * @return The duckdb_interval value at the specified location, or 0 if the value cannot be converted.\n */\n-DUCKDB_API duckdb_interval duckdb_value_interval(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API duckdb_interval duckdb_value_interval(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATED**: Use duckdb_value_string instead. This function does not work correctly if the string contains null\n@@ -1220,7 +1219,7 @@ bytes.\n * @return The text value at the specified location as a null-terminated string, or nullptr if the value cannot be\n converted. The result must be freed with `duckdb_free`.\n */\n-DUCKDB_API char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API char *duckdb_value_varchar(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n@@ -1230,7 +1229,7 @@ The resulting field \"string.data\" must be freed with `duckdb_free.`\n \n * @return The string value at the specified location. Attempts to cast the result value to string.\n */\n-DUCKDB_API duckdb_string duckdb_value_string(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API duckdb_string duckdb_value_string(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATED**: Use duckdb_value_string_internal instead. This function does not work correctly if the string contains\n@@ -1241,7 +1240,7 @@ If the column is NOT a VARCHAR column this function will return NULL.\n \n The result must NOT be freed.\n */\n-DUCKDB_API char *duckdb_value_varchar_internal(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API char *duckdb_value_varchar_internal(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATED**: Use duckdb_value_string_internal instead. This function does not work correctly if the string contains\n@@ -1251,7 +1250,7 @@ If the column is NOT a VARCHAR column this function will return NULL.\n \n The result must NOT be freed.\n */\n-DUCKDB_API duckdb_string duckdb_value_string_internal(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API duckdb_string duckdb_value_string_internal(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n@@ -1259,14 +1258,14 @@ DUCKDB_API duckdb_string duckdb_value_string_internal(duckdb_result *result, idx\n * @return The duckdb_blob value at the specified location. Returns a blob with blob.data set to nullptr if the\n value cannot be converted. The resulting field \"blob.data\" must be freed with `duckdb_free.`\n */\n-DUCKDB_API duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API duckdb_blob duckdb_value_blob(duckdb_result *result, idx_t col, idx_t row);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n \n * @return Returns true if the value at the specified index is NULL, and false otherwise.\n */\n-DUCKDB_API bool duckdb_value_is_null(duckdb_result *result, idx_t col, idx_t row);\n+DUCKDB_C_API bool duckdb_value_is_null(duckdb_result *result, idx_t col, idx_t row);\n \n #endif\n //===--------------------------------------------------------------------===//\n@@ -1280,7 +1279,7 @@ should be freed using `duckdb_free`.\n * @param size The number of bytes to allocate.\n * @return A pointer to the allocated memory region.\n */\n-DUCKDB_API void *duckdb_malloc(size_t size);\n+DUCKDB_C_API void *duckdb_malloc(size_t size);\n \n /*!\n Free a value returned from `duckdb_malloc`, `duckdb_value_varchar`, `duckdb_value_blob`, or\n@@ -1288,7 +1287,7 @@ Free a value returned from `duckdb_malloc`, `duckdb_value_varchar`, `duckdb_valu\n \n * @param ptr The memory region to de-allocate.\n */\n-DUCKDB_API void duckdb_free(void *ptr);\n+DUCKDB_C_API void duckdb_free(void *ptr);\n \n /*!\n The internal vector size used by DuckDB.\n@@ -1296,14 +1295,14 @@ This is the amount of tuples that will fit into a data chunk created by `duckdb_\n \n * @return The vector size.\n */\n-DUCKDB_API idx_t duckdb_vector_size();\n+DUCKDB_C_API idx_t duckdb_vector_size();\n \n /*!\n Whether or not the duckdb_string_t value is inlined.\n This means that the data of the string does not have a separate allocation.\n \n */\n-DUCKDB_API bool duckdb_string_is_inlined(duckdb_string_t string);\n+DUCKDB_C_API bool duckdb_string_is_inlined(duckdb_string_t string);\n \n /*!\n Get the string length of a string_t\n@@ -1311,7 +1310,7 @@ Get the string length of a string_t\n * @param string The string to get the length of.\n * @return The length.\n */\n-DUCKDB_API uint32_t duckdb_string_t_length(duckdb_string_t string);\n+DUCKDB_C_API uint32_t duckdb_string_t_length(duckdb_string_t string);\n \n /*!\n Get a pointer to the string data of a string_t\n@@ -1319,7 +1318,7 @@ Get a pointer to the string data of a string_t\n * @param string The string to get the pointer to.\n * @return The pointer.\n */\n-DUCKDB_API const char *duckdb_string_t_data(duckdb_string_t *string);\n+DUCKDB_C_API const char *duckdb_string_t_data(duckdb_string_t *string);\n \n //===--------------------------------------------------------------------===//\n // Date Time Timestamp Helpers\n@@ -1331,7 +1330,7 @@ Decompose a `duckdb_date` object into year, month and date (stored as `duckdb_da\n * @param date The date object, as obtained from a `DUCKDB_TYPE_DATE` column.\n * @return The `duckdb_date_struct` with the decomposed elements.\n */\n-DUCKDB_API duckdb_date_struct duckdb_from_date(duckdb_date date);\n+DUCKDB_C_API duckdb_date_struct duckdb_from_date(duckdb_date date);\n \n /*!\n Re-compose a `duckdb_date` from year, month and date (`duckdb_date_struct`).\n@@ -1339,7 +1338,7 @@ Re-compose a `duckdb_date` from year, month and date (`duckdb_date_struct`).\n * @param date The year, month and date stored in a `duckdb_date_struct`.\n * @return The `duckdb_date` element.\n */\n-DUCKDB_API duckdb_date duckdb_to_date(duckdb_date_struct date);\n+DUCKDB_C_API duckdb_date duckdb_to_date(duckdb_date_struct date);\n \n /*!\n Test a `duckdb_date` to see if it is a finite value.\n@@ -1347,7 +1346,7 @@ Test a `duckdb_date` to see if it is a finite value.\n * @param date The date object, as obtained from a `DUCKDB_TYPE_DATE` column.\n * @return True if the date is finite, false if it is \u00b1infinity.\n */\n-DUCKDB_API bool duckdb_is_finite_date(duckdb_date date);\n+DUCKDB_C_API bool duckdb_is_finite_date(duckdb_date date);\n \n /*!\n Decompose a `duckdb_time` object into hour, minute, second and microsecond (stored as `duckdb_time_struct`).\n@@ -1355,7 +1354,7 @@ Decompose a `duckdb_time` object into hour, minute, second and microsecond (stor\n * @param time The time object, as obtained from a `DUCKDB_TYPE_TIME` column.\n * @return The `duckdb_time_struct` with the decomposed elements.\n */\n-DUCKDB_API duckdb_time_struct duckdb_from_time(duckdb_time time);\n+DUCKDB_C_API duckdb_time_struct duckdb_from_time(duckdb_time time);\n \n /*!\n Create a `duckdb_time_tz` object from micros and a timezone offset.\n@@ -1364,7 +1363,7 @@ Create a `duckdb_time_tz` object from micros and a timezone offset.\n * @param offset The timezone offset component of the time.\n * @return The `duckdb_time_tz` element.\n */\n-DUCKDB_API duckdb_time_tz duckdb_create_time_tz(int64_t micros, int32_t offset);\n+DUCKDB_C_API duckdb_time_tz duckdb_create_time_tz(int64_t micros, int32_t offset);\n \n /*!\n Decompose a TIME_TZ objects into micros and a timezone offset.\n@@ -1373,7 +1372,7 @@ Use `duckdb_from_time` to further decompose the micros into hour, minute, second\n \n * @param micros The time object, as obtained from a `DUCKDB_TYPE_TIME_TZ` column.\n */\n-DUCKDB_API duckdb_time_tz_struct duckdb_from_time_tz(duckdb_time_tz micros);\n+DUCKDB_C_API duckdb_time_tz_struct duckdb_from_time_tz(duckdb_time_tz micros);\n \n /*!\n Re-compose a `duckdb_time` from hour, minute, second and microsecond (`duckdb_time_struct`).\n@@ -1381,7 +1380,7 @@ Re-compose a `duckdb_time` from hour, minute, second and microsecond (`duckdb_ti\n * @param time The hour, minute, second and microsecond in a `duckdb_time_struct`.\n * @return The `duckdb_time` element.\n */\n-DUCKDB_API duckdb_time duckdb_to_time(duckdb_time_struct time);\n+DUCKDB_C_API duckdb_time duckdb_to_time(duckdb_time_struct time);\n \n /*!\n Decompose a `duckdb_timestamp` object into a `duckdb_timestamp_struct`.\n@@ -1389,7 +1388,7 @@ Decompose a `duckdb_timestamp` object into a `duckdb_timestamp_struct`.\n * @param ts The ts object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.\n * @return The `duckdb_timestamp_struct` with the decomposed elements.\n */\n-DUCKDB_API duckdb_timestamp_struct duckdb_from_timestamp(duckdb_timestamp ts);\n+DUCKDB_C_API duckdb_timestamp_struct duckdb_from_timestamp(duckdb_timestamp ts);\n \n /*!\n Re-compose a `duckdb_timestamp` from a duckdb_timestamp_struct.\n@@ -1397,7 +1396,7 @@ Re-compose a `duckdb_timestamp` from a duckdb_timestamp_struct.\n * @param ts The de-composed elements in a `duckdb_timestamp_struct`.\n * @return The `duckdb_timestamp` element.\n */\n-DUCKDB_API duckdb_timestamp duckdb_to_timestamp(duckdb_timestamp_struct ts);\n+DUCKDB_C_API duckdb_timestamp duckdb_to_timestamp(duckdb_timestamp_struct ts);\n \n /*!\n Test a `duckdb_timestamp` to see if it is a finite value.\n@@ -1405,7 +1404,7 @@ Test a `duckdb_timestamp` to see if it is a finite value.\n * @param ts The duckdb_timestamp object, as obtained from a `DUCKDB_TYPE_TIMESTAMP` column.\n * @return True if the timestamp is finite, false if it is \u00b1infinity.\n */\n-DUCKDB_API bool duckdb_is_finite_timestamp(duckdb_timestamp ts);\n+DUCKDB_C_API bool duckdb_is_finite_timestamp(duckdb_timestamp ts);\n \n /*!\n Test a `duckdb_timestamp_s` to see if it is a finite value.\n@@ -1413,7 +1412,7 @@ Test a `duckdb_timestamp_s` to see if it is a finite value.\n * @param ts The duckdb_timestamp_s object, as obtained from a `DUCKDB_TYPE_TIMESTAMP_S` column.\n * @return True if the timestamp is finite, false if it is \u00b1infinity.\n */\n-DUCKDB_API bool duckdb_is_finite_timestamp_s(duckdb_timestamp_s ts);\n+DUCKDB_C_API bool duckdb_is_finite_timestamp_s(duckdb_timestamp_s ts);\n \n /*!\n Test a `duckdb_timestamp_ms` to see if it is a finite value.\n@@ -1421,7 +1420,7 @@ Test a `duckdb_timestamp_ms` to see if it is a finite value.\n * @param ts The duckdb_timestamp_ms object, as obtained from a `DUCKDB_TYPE_TIMESTAMP_MS` column.\n * @return True if the timestamp is finite, false if it is \u00b1infinity.\n */\n-DUCKDB_API bool duckdb_is_finite_timestamp_ms(duckdb_timestamp_ms ts);\n+DUCKDB_C_API bool duckdb_is_finite_timestamp_ms(duckdb_timestamp_ms ts);\n \n /*!\n Test a `duckdb_timestamp_ns` to see if it is a finite value.\n@@ -1429,7 +1428,7 @@ Test a `duckdb_timestamp_ns` to see if it is a finite value.\n * @param ts The duckdb_timestamp_ns object, as obtained from a `DUCKDB_TYPE_TIMESTAMP_NS` column.\n * @return True if the timestamp is finite, false if it is \u00b1infinity.\n */\n-DUCKDB_API bool duckdb_is_finite_timestamp_ns(duckdb_timestamp_ns ts);\n+DUCKDB_C_API bool duckdb_is_finite_timestamp_ns(duckdb_timestamp_ns ts);\n \n //===--------------------------------------------------------------------===//\n // Hugeint Helpers\n@@ -1441,7 +1440,7 @@ Converts a duckdb_hugeint object (as obtained from a `DUCKDB_TYPE_HUGEINT` colum\n * @param val The hugeint value.\n * @return The converted `double` element.\n */\n-DUCKDB_API double duckdb_hugeint_to_double(duckdb_hugeint val);\n+DUCKDB_C_API double duckdb_hugeint_to_double(duckdb_hugeint val);\n \n /*!\n Converts a double value to a duckdb_hugeint object.\n@@ -1451,7 +1450,7 @@ If the conversion fails because the double value is too big the result will be 0\n * @param val The double value.\n * @return The converted `duckdb_hugeint` element.\n */\n-DUCKDB_API duckdb_hugeint duckdb_double_to_hugeint(double val);\n+DUCKDB_C_API duckdb_hugeint duckdb_double_to_hugeint(double val);\n \n //===--------------------------------------------------------------------===//\n // Unsigned Hugeint Helpers\n@@ -1463,7 +1462,7 @@ Converts a duckdb_uhugeint object (as obtained from a `DUCKDB_TYPE_UHUGEINT` col\n * @param val The uhugeint value.\n * @return The converted `double` element.\n */\n-DUCKDB_API double duckdb_uhugeint_to_double(duckdb_uhugeint val);\n+DUCKDB_C_API double duckdb_uhugeint_to_double(duckdb_uhugeint val);\n \n /*!\n Converts a double value to a duckdb_uhugeint object.\n@@ -1473,7 +1472,7 @@ If the conversion fails because the double value is too big the result will be 0\n * @param val The double value.\n * @return The converted `duckdb_uhugeint` element.\n */\n-DUCKDB_API duckdb_uhugeint duckdb_double_to_uhugeint(double val);\n+DUCKDB_C_API duckdb_uhugeint duckdb_double_to_uhugeint(double val);\n \n //===--------------------------------------------------------------------===//\n // Decimal Helpers\n@@ -1487,7 +1486,7 @@ If the conversion fails because the double value is too big, or the width/scale\n * @param val The double value.\n * @return The converted `duckdb_decimal` element.\n */\n-DUCKDB_API duckdb_decimal duckdb_double_to_decimal(double val, uint8_t width, uint8_t scale);\n+DUCKDB_C_API duckdb_decimal duckdb_double_to_decimal(double val, uint8_t width, uint8_t scale);\n \n /*!\n Converts a duckdb_decimal object (as obtained from a `DUCKDB_TYPE_DECIMAL` column) into a double.\n@@ -1495,7 +1494,7 @@ Converts a duckdb_decimal object (as obtained from a `DUCKDB_TYPE_DECIMAL` colum\n * @param val The decimal value.\n * @return The converted `double` element.\n */\n-DUCKDB_API double duckdb_decimal_to_double(duckdb_decimal val);\n+DUCKDB_C_API double duckdb_decimal_to_double(duckdb_decimal val);\n \n //===--------------------------------------------------------------------===//\n // Prepared Statements\n@@ -1523,15 +1522,15 @@ If the prepare fails, `duckdb_prepare_error` can be called to obtain the reason\n * @param out_prepared_statement The resulting prepared statement object\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,\n-                                       duckdb_prepared_statement *out_prepared_statement);\n+DUCKDB_C_API duckdb_state duckdb_prepare(duckdb_connection connection, const char *query,\n+                                         duckdb_prepared_statement *out_prepared_statement);\n \n /*!\n Closes the prepared statement and de-allocates all memory allocated for the statement.\n \n * @param prepared_statement The prepared statement to destroy.\n */\n-DUCKDB_API void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement);\n+DUCKDB_C_API void duckdb_destroy_prepare(duckdb_prepared_statement *prepared_statement);\n \n /*!\n Returns the error message associated with the given prepared statement.\n@@ -1542,7 +1541,7 @@ The error message should not be freed. It will be de-allocated when `duckdb_dest\n * @param prepared_statement The prepared statement to obtain the error from.\n * @return The error message, or `nullptr` if there is none.\n */\n-DUCKDB_API const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement);\n+DUCKDB_C_API const char *duckdb_prepare_error(duckdb_prepared_statement prepared_statement);\n \n /*!\n Returns the number of parameters that can be provided to the given prepared statement.\n@@ -1551,7 +1550,7 @@ Returns 0 if the query was not successfully prepared.\n \n * @param prepared_statement The prepared statement to obtain the number of parameters for.\n */\n-DUCKDB_API idx_t duckdb_nparams(duckdb_prepared_statement prepared_statement);\n+DUCKDB_C_API idx_t duckdb_nparams(duckdb_prepared_statement prepared_statement);\n \n /*!\n Returns the name used to identify the parameter\n@@ -1561,7 +1560,7 @@ Returns NULL if the index is out of range for the provided prepared statement.\n \n * @param prepared_statement The prepared statement for which to get the parameter name from.\n */\n-DUCKDB_API const char *duckdb_parameter_name(duckdb_prepared_statement prepared_statement, idx_t index);\n+DUCKDB_C_API const char *duckdb_parameter_name(duckdb_prepared_statement prepared_statement, idx_t index);\n \n /*!\n Returns the parameter type for the parameter at the given index.\n@@ -1572,7 +1571,7 @@ Returns `DUCKDB_TYPE_INVALID` if the parameter index is out of range or the stat\n * @param param_idx The parameter index.\n * @return The parameter type\n */\n-DUCKDB_API duckdb_type duckdb_param_type(duckdb_prepared_statement prepared_statement, idx_t param_idx);\n+DUCKDB_C_API duckdb_type duckdb_param_type(duckdb_prepared_statement prepared_statement, idx_t param_idx);\n \n /*!\n Returns the logical type for the parameter at the given index.\n@@ -1585,12 +1584,13 @@ The return type of this call should be destroyed with `duckdb_destroy_logical_ty\n * @param param_idx The parameter index.\n * @return The logical type of the parameter\n */\n-DUCKDB_API duckdb_logical_type duckdb_param_logical_type(duckdb_prepared_statement prepared_statement, idx_t param_idx);\n+DUCKDB_C_API duckdb_logical_type duckdb_param_logical_type(duckdb_prepared_statement prepared_statement,\n+                                                           idx_t param_idx);\n \n /*!\n Clear the params bind to the prepared statement.\n */\n-DUCKDB_API duckdb_state duckdb_clear_bindings(duckdb_prepared_statement prepared_statement);\n+DUCKDB_C_API duckdb_state duckdb_clear_bindings(duckdb_prepared_statement prepared_statement);\n \n /*!\n Returns the statement type of the statement to be executed\n@@ -1598,7 +1598,7 @@ Returns the statement type of the statement to be executed\n * @param statement The prepared statement.\n * @return duckdb_statement_type value or DUCKDB_STATEMENT_TYPE_INVALID\n */\n-DUCKDB_API duckdb_statement_type duckdb_prepared_statement_type(duckdb_prepared_statement statement);\n+DUCKDB_C_API duckdb_statement_type duckdb_prepared_statement_type(duckdb_prepared_statement statement);\n \n //===--------------------------------------------------------------------===//\n // Bind Values To Prepared Statements\n@@ -1607,140 +1607,143 @@ DUCKDB_API duckdb_statement_type duckdb_prepared_statement_type(duckdb_prepared_\n /*!\n Binds a value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_value(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n-                                          duckdb_value val);\n+DUCKDB_C_API duckdb_state duckdb_bind_value(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                            duckdb_value val);\n \n /*!\n Retrieve the index of the parameter for the prepared statement, identified by name\n */\n-DUCKDB_API duckdb_state duckdb_bind_parameter_index(duckdb_prepared_statement prepared_statement, idx_t *param_idx_out,\n-                                                    const char *name);\n+DUCKDB_C_API duckdb_state duckdb_bind_parameter_index(duckdb_prepared_statement prepared_statement,\n+                                                      idx_t *param_idx_out, const char *name);\n \n /*!\n Binds a bool value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_boolean(duckdb_prepared_statement prepared_statement, idx_t param_idx, bool val);\n+DUCKDB_C_API duckdb_state duckdb_bind_boolean(duckdb_prepared_statement prepared_statement, idx_t param_idx, bool val);\n \n /*!\n Binds an int8_t value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val);\n+DUCKDB_C_API duckdb_state duckdb_bind_int8(duckdb_prepared_statement prepared_statement, idx_t param_idx, int8_t val);\n \n /*!\n Binds an int16_t value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val);\n+DUCKDB_C_API duckdb_state duckdb_bind_int16(duckdb_prepared_statement prepared_statement, idx_t param_idx, int16_t val);\n \n /*!\n Binds an int32_t value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val);\n+DUCKDB_C_API duckdb_state duckdb_bind_int32(duckdb_prepared_statement prepared_statement, idx_t param_idx, int32_t val);\n \n /*!\n Binds an int64_t value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val);\n+DUCKDB_C_API duckdb_state duckdb_bind_int64(duckdb_prepared_statement prepared_statement, idx_t param_idx, int64_t val);\n \n /*!\n Binds a duckdb_hugeint value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_hugeint(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n-                                            duckdb_hugeint val);\n+DUCKDB_C_API duckdb_state duckdb_bind_hugeint(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                              duckdb_hugeint val);\n \n /*!\n Binds an duckdb_uhugeint value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_uhugeint(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n-                                             duckdb_uhugeint val);\n+DUCKDB_C_API duckdb_state duckdb_bind_uhugeint(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                               duckdb_uhugeint val);\n \n /*!\n Binds a duckdb_decimal value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_decimal(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n-                                            duckdb_decimal val);\n+DUCKDB_C_API duckdb_state duckdb_bind_decimal(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                              duckdb_decimal val);\n \n /*!\n Binds an uint8_t value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint8_t val);\n+DUCKDB_C_API duckdb_state duckdb_bind_uint8(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint8_t val);\n \n /*!\n Binds an uint16_t value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint16_t val);\n+DUCKDB_C_API duckdb_state duckdb_bind_uint16(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                             uint16_t val);\n \n /*!\n Binds an uint32_t value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint32_t val);\n+DUCKDB_C_API duckdb_state duckdb_bind_uint32(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                             uint32_t val);\n \n /*!\n Binds an uint64_t value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx, uint64_t val);\n+DUCKDB_C_API duckdb_state duckdb_bind_uint64(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                             uint64_t val);\n \n /*!\n Binds a float value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val);\n+DUCKDB_C_API duckdb_state duckdb_bind_float(duckdb_prepared_statement prepared_statement, idx_t param_idx, float val);\n \n /*!\n Binds a double value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val);\n+DUCKDB_C_API duckdb_state duckdb_bind_double(duckdb_prepared_statement prepared_statement, idx_t param_idx, double val);\n \n /*!\n Binds a duckdb_date value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_date(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n-                                         duckdb_date val);\n+DUCKDB_C_API duckdb_state duckdb_bind_date(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                           duckdb_date val);\n \n /*!\n Binds a duckdb_time value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_time(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n-                                         duckdb_time val);\n+DUCKDB_C_API duckdb_state duckdb_bind_time(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                           duckdb_time val);\n \n /*!\n Binds a duckdb_timestamp value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_timestamp(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n-                                              duckdb_timestamp val);\n+DUCKDB_C_API duckdb_state duckdb_bind_timestamp(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                                duckdb_timestamp val);\n \n /*!\n Binds a duckdb_timestamp value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_timestamp_tz(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n-                                                 duckdb_timestamp val);\n+DUCKDB_C_API duckdb_state duckdb_bind_timestamp_tz(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                                   duckdb_timestamp val);\n \n /*!\n Binds a duckdb_interval value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_interval(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n-                                             duckdb_interval val);\n+DUCKDB_C_API duckdb_state duckdb_bind_interval(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                               duckdb_interval val);\n \n /*!\n Binds a null-terminated varchar value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n-                                            const char *val);\n+DUCKDB_C_API duckdb_state duckdb_bind_varchar(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                              const char *val);\n \n /*!\n Binds a varchar value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n-                                                   const char *val, idx_t length);\n+DUCKDB_C_API duckdb_state duckdb_bind_varchar_length(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                                     const char *val, idx_t length);\n \n /*!\n Binds a blob value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n-                                         const void *data, idx_t length);\n+DUCKDB_C_API duckdb_state duckdb_bind_blob(duckdb_prepared_statement prepared_statement, idx_t param_idx,\n+                                           const void *data, idx_t length);\n \n /*!\n Binds a NULL value to the prepared statement at the specified index.\n */\n-DUCKDB_API duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_statement, idx_t param_idx);\n+DUCKDB_C_API duckdb_state duckdb_bind_null(duckdb_prepared_statement prepared_statement, idx_t param_idx);\n \n //===--------------------------------------------------------------------===//\n // Execute Prepared Statements\n@@ -1758,8 +1761,8 @@ Note that the result must be freed with `duckdb_destroy_result`.\n * @param out_result The query result.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement,\n-                                                duckdb_result *out_result);\n+DUCKDB_C_API duckdb_state duckdb_execute_prepared(duckdb_prepared_statement prepared_statement,\n+                                                  duckdb_result *out_result);\n \n #ifndef DUCKDB_API_NO_DEPRECATED\n /*!\n@@ -1777,8 +1780,8 @@ Note that the result must be freed with `duckdb_destroy_result`.\n * @param out_result The query result.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_execute_prepared_streaming(duckdb_prepared_statement prepared_statement,\n-                                                          duckdb_result *out_result);\n+DUCKDB_C_API duckdb_state duckdb_execute_prepared_streaming(duckdb_prepared_statement prepared_statement,\n+                                                            duckdb_result *out_result);\n \n #endif\n //===--------------------------------------------------------------------===//\n@@ -1798,8 +1801,8 @@ If the extract fails, `duckdb_extract_statements_error` can be called to obtain\n * @param out_extracted_statements The resulting extracted statements object\n * @return The number of extracted statements or 0 on failure.\n */\n-DUCKDB_API idx_t duckdb_extract_statements(duckdb_connection connection, const char *query,\n-                                           duckdb_extracted_statements *out_extracted_statements);\n+DUCKDB_C_API idx_t duckdb_extract_statements(duckdb_connection connection, const char *query,\n+                                             duckdb_extracted_statements *out_extracted_statements);\n \n /*!\n Prepare an extracted statement.\n@@ -1814,10 +1817,10 @@ If the prepare fails, `duckdb_prepare_error` can be called to obtain the reason\n * @param out_prepared_statement The resulting prepared statement object\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_prepare_extracted_statement(duckdb_connection connection,\n-                                                           duckdb_extracted_statements extracted_statements,\n-                                                           idx_t index,\n-                                                           duckdb_prepared_statement *out_prepared_statement);\n+DUCKDB_C_API duckdb_state duckdb_prepare_extracted_statement(duckdb_connection connection,\n+                                                             duckdb_extracted_statements extracted_statements,\n+                                                             idx_t index,\n+                                                             duckdb_prepared_statement *out_prepared_statement);\n \n /*!\n Returns the error message contained within the extracted statements.\n@@ -1826,13 +1829,13 @@ The result of this function must not be freed. It will be cleaned up when `duckd\n * @param extracted_statements The extracted statements to fetch the error from.\n * @return The error of the extracted statements.\n */\n-DUCKDB_API const char *duckdb_extract_statements_error(duckdb_extracted_statements extracted_statements);\n+DUCKDB_C_API const char *duckdb_extract_statements_error(duckdb_extracted_statements extracted_statements);\n \n /*!\n De-allocates all memory allocated for the extracted statements.\n * @param extracted_statements The extracted statements to destroy.\n */\n-DUCKDB_API void duckdb_destroy_extracted(duckdb_extracted_statements *extracted_statements);\n+DUCKDB_C_API void duckdb_destroy_extracted(duckdb_extracted_statements *extracted_statements);\n \n //===--------------------------------------------------------------------===//\n // Pending Result Interface\n@@ -1850,8 +1853,8 @@ Note that after calling `duckdb_pending_prepared`, the pending result should alw\n * @param out_result The pending query result.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_pending_prepared(duckdb_prepared_statement prepared_statement,\n-                                                duckdb_pending_result *out_result);\n+DUCKDB_C_API duckdb_state duckdb_pending_prepared(duckdb_prepared_statement prepared_statement,\n+                                                  duckdb_pending_result *out_result);\n \n #ifndef DUCKDB_API_NO_DEPRECATED\n /*!\n@@ -1868,8 +1871,8 @@ Note that after calling `duckdb_pending_prepared_streaming`, the pending result\n * @param out_result The pending query result.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_pending_prepared_streaming(duckdb_prepared_statement prepared_statement,\n-                                                          duckdb_pending_result *out_result);\n+DUCKDB_C_API duckdb_state duckdb_pending_prepared_streaming(duckdb_prepared_statement prepared_statement,\n+                                                            duckdb_pending_result *out_result);\n \n #endif\n /*!\n@@ -1877,7 +1880,7 @@ Closes the pending result and de-allocates all memory allocated for the result.\n \n * @param pending_result The pending result to destroy.\n */\n-DUCKDB_API void duckdb_destroy_pending(duckdb_pending_result *pending_result);\n+DUCKDB_C_API void duckdb_destroy_pending(duckdb_pending_result *pending_result);\n \n /*!\n Returns the error message contained within the pending result.\n@@ -1887,7 +1890,7 @@ The result of this function must not be freed. It will be cleaned up when `duckd\n * @param pending_result The pending result to fetch the error from.\n * @return The error of the pending result.\n */\n-DUCKDB_API const char *duckdb_pending_error(duckdb_pending_result pending_result);\n+DUCKDB_C_API const char *duckdb_pending_error(duckdb_pending_result pending_result);\n \n /*!\n Executes a single task within the query, returning whether or not the query is ready.\n@@ -1901,7 +1904,7 @@ The error message can be obtained by calling duckdb_pending_error on the pending\n * @param pending_result The pending result to execute a task within.\n * @return The state of the pending result after the execution.\n */\n-DUCKDB_API duckdb_pending_state duckdb_pending_execute_task(duckdb_pending_result pending_result);\n+DUCKDB_C_API duckdb_pending_state duckdb_pending_execute_task(duckdb_pending_result pending_result);\n \n /*!\n If this returns DUCKDB_PENDING_RESULT_READY, the duckdb_execute_pending function can be called to obtain the result.\n@@ -1913,7 +1916,7 @@ The error message can be obtained by calling duckdb_pending_error on the pending\n * @param pending_result The pending result.\n * @return The state of the pending result.\n */\n-DUCKDB_API duckdb_pending_state duckdb_pending_execute_check_state(duckdb_pending_result pending_result);\n+DUCKDB_C_API duckdb_pending_state duckdb_pending_execute_check_state(duckdb_pending_result pending_result);\n \n /*!\n Fully execute a pending query result, returning the final query result.\n@@ -1927,7 +1930,7 @@ Note that the result must be freed with `duckdb_destroy_result`.\n * @param out_result The result object.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_execute_pending(duckdb_pending_result pending_result, duckdb_result *out_result);\n+DUCKDB_C_API duckdb_state duckdb_execute_pending(duckdb_pending_result pending_result, duckdb_result *out_result);\n \n /*!\n Returns whether a duckdb_pending_state is finished executing. For example if `pending_state` is\n@@ -1936,7 +1939,7 @@ DUCKDB_PENDING_RESULT_READY, this function will return true.\n * @param pending_state The pending state on which to decide whether to finish execution.\n * @return Boolean indicating pending execution should be considered finished.\n */\n-DUCKDB_API bool duckdb_pending_execution_is_finished(duckdb_pending_state pending_state);\n+DUCKDB_C_API bool duckdb_pending_execution_is_finished(duckdb_pending_state pending_state);\n \n //===--------------------------------------------------------------------===//\n // Value Interface\n@@ -1947,7 +1950,7 @@ Destroys the value and de-allocates all memory allocated for that type.\n \n * @param value The value to destroy.\n */\n-DUCKDB_API void duckdb_destroy_value(duckdb_value *value);\n+DUCKDB_C_API void duckdb_destroy_value(duckdb_value *value);\n \n /*!\n Creates a value from a null-terminated string\n@@ -1955,7 +1958,7 @@ Creates a value from a null-terminated string\n * @param text The null-terminated string\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_varchar(const char *text);\n+DUCKDB_C_API duckdb_value duckdb_create_varchar(const char *text);\n \n /*!\n Creates a value from a string\n@@ -1964,7 +1967,7 @@ Creates a value from a string\n * @param length The length of the text\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_varchar_length(const char *text, idx_t length);\n+DUCKDB_C_API duckdb_value duckdb_create_varchar_length(const char *text, idx_t length);\n \n /*!\n Creates a value from a boolean\n@@ -1972,7 +1975,7 @@ Creates a value from a boolean\n * @param input The boolean value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_bool(bool input);\n+DUCKDB_C_API duckdb_value duckdb_create_bool(bool input);\n \n /*!\n Creates a value from a int8_t (a tinyint)\n@@ -1980,7 +1983,7 @@ Creates a value from a int8_t (a tinyint)\n * @param input The tinyint value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_int8(int8_t input);\n+DUCKDB_C_API duckdb_value duckdb_create_int8(int8_t input);\n \n /*!\n Creates a value from a uint8_t (a utinyint)\n@@ -1988,7 +1991,7 @@ Creates a value from a uint8_t (a utinyint)\n * @param input The utinyint value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_uint8(uint8_t input);\n+DUCKDB_C_API duckdb_value duckdb_create_uint8(uint8_t input);\n \n /*!\n Creates a value from a int16_t (a smallint)\n@@ -1996,7 +1999,7 @@ Creates a value from a int16_t (a smallint)\n * @param input The smallint value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_int16(int16_t input);\n+DUCKDB_C_API duckdb_value duckdb_create_int16(int16_t input);\n \n /*!\n Creates a value from a uint16_t (a usmallint)\n@@ -2004,7 +2007,7 @@ Creates a value from a uint16_t (a usmallint)\n * @param input The usmallint value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_uint16(uint16_t input);\n+DUCKDB_C_API duckdb_value duckdb_create_uint16(uint16_t input);\n \n /*!\n Creates a value from a int32_t (an integer)\n@@ -2012,7 +2015,7 @@ Creates a value from a int32_t (an integer)\n * @param input The integer value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_int32(int32_t input);\n+DUCKDB_C_API duckdb_value duckdb_create_int32(int32_t input);\n \n /*!\n Creates a value from a uint32_t (a uinteger)\n@@ -2020,7 +2023,7 @@ Creates a value from a uint32_t (a uinteger)\n * @param input The uinteger value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_uint32(uint32_t input);\n+DUCKDB_C_API duckdb_value duckdb_create_uint32(uint32_t input);\n \n /*!\n Creates a value from a uint64_t (a ubigint)\n@@ -2028,14 +2031,14 @@ Creates a value from a uint64_t (a ubigint)\n * @param input The ubigint value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_uint64(uint64_t input);\n+DUCKDB_C_API duckdb_value duckdb_create_uint64(uint64_t input);\n \n /*!\n Creates a value from an int64\n \n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_int64(int64_t val);\n+DUCKDB_C_API duckdb_value duckdb_create_int64(int64_t val);\n \n /*!\n Creates a value from a hugeint\n@@ -2043,7 +2046,7 @@ Creates a value from a hugeint\n * @param input The hugeint value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_hugeint(duckdb_hugeint input);\n+DUCKDB_C_API duckdb_value duckdb_create_hugeint(duckdb_hugeint input);\n \n /*!\n Creates a value from a uhugeint\n@@ -2051,7 +2054,7 @@ Creates a value from a uhugeint\n * @param input The uhugeint value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_uhugeint(duckdb_uhugeint input);\n+DUCKDB_C_API duckdb_value duckdb_create_uhugeint(duckdb_uhugeint input);\n \n /*!\n Creates a VARINT value from a duckdb_varint\n@@ -2059,7 +2062,7 @@ Creates a VARINT value from a duckdb_varint\n * @param input The duckdb_varint value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_varint(duckdb_varint input);\n+DUCKDB_C_API duckdb_value duckdb_create_varint(duckdb_varint input);\n \n /*!\n Creates a DECIMAL value from a duckdb_decimal\n@@ -2067,7 +2070,7 @@ Creates a DECIMAL value from a duckdb_decimal\n * @param input The duckdb_decimal value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_decimal(duckdb_decimal input);\n+DUCKDB_C_API duckdb_value duckdb_create_decimal(duckdb_decimal input);\n \n /*!\n Creates a value from a float\n@@ -2075,7 +2078,7 @@ Creates a value from a float\n * @param input The float value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_float(float input);\n+DUCKDB_C_API duckdb_value duckdb_create_float(float input);\n \n /*!\n Creates a value from a double\n@@ -2083,7 +2086,7 @@ Creates a value from a double\n * @param input The double value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_double(double input);\n+DUCKDB_C_API duckdb_value duckdb_create_double(double input);\n \n /*!\n Creates a value from a date\n@@ -2091,7 +2094,7 @@ Creates a value from a date\n * @param input The date value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_date(duckdb_date input);\n+DUCKDB_C_API duckdb_value duckdb_create_date(duckdb_date input);\n \n /*!\n Creates a value from a time\n@@ -2099,7 +2102,7 @@ Creates a value from a time\n * @param input The time value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_time(duckdb_time input);\n+DUCKDB_C_API duckdb_value duckdb_create_time(duckdb_time input);\n \n /*!\n Creates a value from a time_tz.\n@@ -2108,7 +2111,7 @@ Not to be confused with `duckdb_create_time_tz`, which creates a duckdb_time_tz_\n * @param value The time_tz value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_time_tz_value(duckdb_time_tz value);\n+DUCKDB_C_API duckdb_value duckdb_create_time_tz_value(duckdb_time_tz value);\n \n /*!\n Creates a TIMESTAMP value from a duckdb_timestamp\n@@ -2116,7 +2119,7 @@ Creates a TIMESTAMP value from a duckdb_timestamp\n * @param input The duckdb_timestamp value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_timestamp(duckdb_timestamp input);\n+DUCKDB_C_API duckdb_value duckdb_create_timestamp(duckdb_timestamp input);\n \n /*!\n Creates a TIMESTAMP_TZ value from a duckdb_timestamp\n@@ -2124,7 +2127,7 @@ Creates a TIMESTAMP_TZ value from a duckdb_timestamp\n * @param input The duckdb_timestamp value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_timestamp_tz(duckdb_timestamp input);\n+DUCKDB_C_API duckdb_value duckdb_create_timestamp_tz(duckdb_timestamp input);\n \n /*!\n Creates a TIMESTAMP_S value from a duckdb_timestamp_s\n@@ -2132,7 +2135,7 @@ Creates a TIMESTAMP_S value from a duckdb_timestamp_s\n * @param input The duckdb_timestamp_s value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_timestamp_s(duckdb_timestamp_s input);\n+DUCKDB_C_API duckdb_value duckdb_create_timestamp_s(duckdb_timestamp_s input);\n \n /*!\n Creates a TIMESTAMP_MS value from a duckdb_timestamp_ms\n@@ -2140,7 +2143,7 @@ Creates a TIMESTAMP_MS value from a duckdb_timestamp_ms\n * @param input The duckdb_timestamp_ms value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_timestamp_ms(duckdb_timestamp_ms input);\n+DUCKDB_C_API duckdb_value duckdb_create_timestamp_ms(duckdb_timestamp_ms input);\n \n /*!\n Creates a TIMESTAMP_NS value from a duckdb_timestamp_ns\n@@ -2148,7 +2151,7 @@ Creates a TIMESTAMP_NS value from a duckdb_timestamp_ns\n * @param input The duckdb_timestamp_ns value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_timestamp_ns(duckdb_timestamp_ns input);\n+DUCKDB_C_API duckdb_value duckdb_create_timestamp_ns(duckdb_timestamp_ns input);\n \n /*!\n Creates a value from an interval\n@@ -2156,7 +2159,7 @@ Creates a value from an interval\n * @param input The interval value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_interval(duckdb_interval input);\n+DUCKDB_C_API duckdb_value duckdb_create_interval(duckdb_interval input);\n \n /*!\n Creates a value from a blob\n@@ -2165,7 +2168,7 @@ Creates a value from a blob\n * @param length The length of the blob data\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_blob(const uint8_t *data, idx_t length);\n+DUCKDB_C_API duckdb_value duckdb_create_blob(const uint8_t *data, idx_t length);\n \n /*!\n Creates a BIT value from a duckdb_bit\n@@ -2173,7 +2176,7 @@ Creates a BIT value from a duckdb_bit\n * @param input The duckdb_bit value\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_bit(duckdb_bit input);\n+DUCKDB_C_API duckdb_value duckdb_create_bit(duckdb_bit input);\n \n /*!\n Creates a UUID value from a uhugeint\n@@ -2181,7 +2184,7 @@ Creates a UUID value from a uhugeint\n * @param input The duckdb_uhugeint containing the UUID\n * @return The value. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_uuid(duckdb_uhugeint input);\n+DUCKDB_C_API duckdb_value duckdb_create_uuid(duckdb_uhugeint input);\n \n /*!\n Returns the boolean value of the given value.\n@@ -2189,7 +2192,7 @@ Returns the boolean value of the given value.\n * @param val A duckdb_value containing a boolean\n * @return A boolean, or false if the value cannot be converted\n */\n-DUCKDB_API bool duckdb_get_bool(duckdb_value val);\n+DUCKDB_C_API bool duckdb_get_bool(duckdb_value val);\n \n /*!\n Returns the int8_t value of the given value.\n@@ -2197,7 +2200,7 @@ Returns the int8_t value of the given value.\n * @param val A duckdb_value containing a tinyint\n * @return A int8_t, or MinValue<int8> if the value cannot be converted\n */\n-DUCKDB_API int8_t duckdb_get_int8(duckdb_value val);\n+DUCKDB_C_API int8_t duckdb_get_int8(duckdb_value val);\n \n /*!\n Returns the uint8_t value of the given value.\n@@ -2205,7 +2208,7 @@ Returns the uint8_t value of the given value.\n * @param val A duckdb_value containing a utinyint\n * @return A uint8_t, or MinValue<uint8> if the value cannot be converted\n */\n-DUCKDB_API uint8_t duckdb_get_uint8(duckdb_value val);\n+DUCKDB_C_API uint8_t duckdb_get_uint8(duckdb_value val);\n \n /*!\n Returns the int16_t value of the given value.\n@@ -2213,7 +2216,7 @@ Returns the int16_t value of the given value.\n * @param val A duckdb_value containing a smallint\n * @return A int16_t, or MinValue<int16> if the value cannot be converted\n */\n-DUCKDB_API int16_t duckdb_get_int16(duckdb_value val);\n+DUCKDB_C_API int16_t duckdb_get_int16(duckdb_value val);\n \n /*!\n Returns the uint16_t value of the given value.\n@@ -2221,7 +2224,7 @@ Returns the uint16_t value of the given value.\n * @param val A duckdb_value containing a usmallint\n * @return A uint16_t, or MinValue<uint16> if the value cannot be converted\n */\n-DUCKDB_API uint16_t duckdb_get_uint16(duckdb_value val);\n+DUCKDB_C_API uint16_t duckdb_get_uint16(duckdb_value val);\n \n /*!\n Returns the int32_t value of the given value.\n@@ -2229,7 +2232,7 @@ Returns the int32_t value of the given value.\n * @param val A duckdb_value containing a integer\n * @return A int32_t, or MinValue<int32> if the value cannot be converted\n */\n-DUCKDB_API int32_t duckdb_get_int32(duckdb_value val);\n+DUCKDB_C_API int32_t duckdb_get_int32(duckdb_value val);\n \n /*!\n Returns the uint32_t value of the given value.\n@@ -2237,7 +2240,7 @@ Returns the uint32_t value of the given value.\n * @param val A duckdb_value containing a uinteger\n * @return A uint32_t, or MinValue<uint32> if the value cannot be converted\n */\n-DUCKDB_API uint32_t duckdb_get_uint32(duckdb_value val);\n+DUCKDB_C_API uint32_t duckdb_get_uint32(duckdb_value val);\n \n /*!\n Returns the int64_t value of the given value.\n@@ -2245,7 +2248,7 @@ Returns the int64_t value of the given value.\n * @param val A duckdb_value containing a bigint\n * @return A int64_t, or MinValue<int64> if the value cannot be converted\n */\n-DUCKDB_API int64_t duckdb_get_int64(duckdb_value val);\n+DUCKDB_C_API int64_t duckdb_get_int64(duckdb_value val);\n \n /*!\n Returns the uint64_t value of the given value.\n@@ -2253,7 +2256,7 @@ Returns the uint64_t value of the given value.\n * @param val A duckdb_value containing a ubigint\n * @return A uint64_t, or MinValue<uint64> if the value cannot be converted\n */\n-DUCKDB_API uint64_t duckdb_get_uint64(duckdb_value val);\n+DUCKDB_C_API uint64_t duckdb_get_uint64(duckdb_value val);\n \n /*!\n Returns the hugeint value of the given value.\n@@ -2261,7 +2264,7 @@ Returns the hugeint value of the given value.\n * @param val A duckdb_value containing a hugeint\n * @return A duckdb_hugeint, or MinValue<hugeint> if the value cannot be converted\n */\n-DUCKDB_API duckdb_hugeint duckdb_get_hugeint(duckdb_value val);\n+DUCKDB_C_API duckdb_hugeint duckdb_get_hugeint(duckdb_value val);\n \n /*!\n Returns the uhugeint value of the given value.\n@@ -2269,7 +2272,7 @@ Returns the uhugeint value of the given value.\n * @param val A duckdb_value containing a uhugeint\n * @return A duckdb_uhugeint, or MinValue<uhugeint> if the value cannot be converted\n */\n-DUCKDB_API duckdb_uhugeint duckdb_get_uhugeint(duckdb_value val);\n+DUCKDB_C_API duckdb_uhugeint duckdb_get_uhugeint(duckdb_value val);\n \n /*!\n Returns the duckdb_varint value of the given value.\n@@ -2278,7 +2281,7 @@ The `data` field must be destroyed with `duckdb_free`.\n * @param val A duckdb_value containing a VARINT\n * @return A duckdb_varint. The `data` field must be destroyed with `duckdb_free`.\n */\n-DUCKDB_API duckdb_varint duckdb_get_varint(duckdb_value val);\n+DUCKDB_C_API duckdb_varint duckdb_get_varint(duckdb_value val);\n \n /*!\n Returns the duckdb_decimal value of the given value.\n@@ -2286,7 +2289,7 @@ Returns the duckdb_decimal value of the given value.\n * @param val A duckdb_value containing a DECIMAL\n * @return A duckdb_decimal, or MinValue<decimal> if the value cannot be converted\n */\n-DUCKDB_API duckdb_decimal duckdb_get_decimal(duckdb_value val);\n+DUCKDB_C_API duckdb_decimal duckdb_get_decimal(duckdb_value val);\n \n /*!\n Returns the float value of the given value.\n@@ -2294,7 +2297,7 @@ Returns the float value of the given value.\n * @param val A duckdb_value containing a float\n * @return A float, or NAN if the value cannot be converted\n */\n-DUCKDB_API float duckdb_get_float(duckdb_value val);\n+DUCKDB_C_API float duckdb_get_float(duckdb_value val);\n \n /*!\n Returns the double value of the given value.\n@@ -2302,7 +2305,7 @@ Returns the double value of the given value.\n * @param val A duckdb_value containing a double\n * @return A double, or NAN if the value cannot be converted\n */\n-DUCKDB_API double duckdb_get_double(duckdb_value val);\n+DUCKDB_C_API double duckdb_get_double(duckdb_value val);\n \n /*!\n Returns the date value of the given value.\n@@ -2310,7 +2313,7 @@ Returns the date value of the given value.\n * @param val A duckdb_value containing a date\n * @return A duckdb_date, or MinValue<date> if the value cannot be converted\n */\n-DUCKDB_API duckdb_date duckdb_get_date(duckdb_value val);\n+DUCKDB_C_API duckdb_date duckdb_get_date(duckdb_value val);\n \n /*!\n Returns the time value of the given value.\n@@ -2318,7 +2321,7 @@ Returns the time value of the given value.\n * @param val A duckdb_value containing a time\n * @return A duckdb_time, or MinValue<time> if the value cannot be converted\n */\n-DUCKDB_API duckdb_time duckdb_get_time(duckdb_value val);\n+DUCKDB_C_API duckdb_time duckdb_get_time(duckdb_value val);\n \n /*!\n Returns the time_tz value of the given value.\n@@ -2326,7 +2329,7 @@ Returns the time_tz value of the given value.\n * @param val A duckdb_value containing a time_tz\n * @return A duckdb_time_tz, or MinValue<time_tz> if the value cannot be converted\n */\n-DUCKDB_API duckdb_time_tz duckdb_get_time_tz(duckdb_value val);\n+DUCKDB_C_API duckdb_time_tz duckdb_get_time_tz(duckdb_value val);\n \n /*!\n Returns the TIMESTAMP value of the given value.\n@@ -2334,7 +2337,7 @@ Returns the TIMESTAMP value of the given value.\n * @param val A duckdb_value containing a TIMESTAMP\n * @return A duckdb_timestamp, or MinValue<timestamp> if the value cannot be converted\n */\n-DUCKDB_API duckdb_timestamp duckdb_get_timestamp(duckdb_value val);\n+DUCKDB_C_API duckdb_timestamp duckdb_get_timestamp(duckdb_value val);\n \n /*!\n Returns the TIMESTAMP_TZ value of the given value.\n@@ -2342,7 +2345,7 @@ Returns the TIMESTAMP_TZ value of the given value.\n * @param val A duckdb_value containing a TIMESTAMP_TZ\n * @return A duckdb_timestamp, or MinValue<timestamp_tz> if the value cannot be converted\n */\n-DUCKDB_API duckdb_timestamp duckdb_get_timestamp_tz(duckdb_value val);\n+DUCKDB_C_API duckdb_timestamp duckdb_get_timestamp_tz(duckdb_value val);\n \n /*!\n Returns the duckdb_timestamp_s value of the given value.\n@@ -2350,7 +2353,7 @@ Returns the duckdb_timestamp_s value of the given value.\n * @param val A duckdb_value containing a TIMESTAMP_S\n * @return A duckdb_timestamp_s, or MinValue<timestamp_s> if the value cannot be converted\n */\n-DUCKDB_API duckdb_timestamp_s duckdb_get_timestamp_s(duckdb_value val);\n+DUCKDB_C_API duckdb_timestamp_s duckdb_get_timestamp_s(duckdb_value val);\n \n /*!\n Returns the duckdb_timestamp_ms value of the given value.\n@@ -2358,7 +2361,7 @@ Returns the duckdb_timestamp_ms value of the given value.\n * @param val A duckdb_value containing a TIMESTAMP_MS\n * @return A duckdb_timestamp_ms, or MinValue<timestamp_ms> if the value cannot be converted\n */\n-DUCKDB_API duckdb_timestamp_ms duckdb_get_timestamp_ms(duckdb_value val);\n+DUCKDB_C_API duckdb_timestamp_ms duckdb_get_timestamp_ms(duckdb_value val);\n \n /*!\n Returns the duckdb_timestamp_ns value of the given value.\n@@ -2366,7 +2369,7 @@ Returns the duckdb_timestamp_ns value of the given value.\n * @param val A duckdb_value containing a TIMESTAMP_NS\n * @return A duckdb_timestamp_ns, or MinValue<timestamp_ns> if the value cannot be converted\n */\n-DUCKDB_API duckdb_timestamp_ns duckdb_get_timestamp_ns(duckdb_value val);\n+DUCKDB_C_API duckdb_timestamp_ns duckdb_get_timestamp_ns(duckdb_value val);\n \n /*!\n Returns the interval value of the given value.\n@@ -2374,7 +2377,7 @@ Returns the interval value of the given value.\n * @param val A duckdb_value containing a interval\n * @return A duckdb_interval, or MinValue<interval> if the value cannot be converted\n */\n-DUCKDB_API duckdb_interval duckdb_get_interval(duckdb_value val);\n+DUCKDB_C_API duckdb_interval duckdb_get_interval(duckdb_value val);\n \n /*!\n Returns the type of the given value. The type is valid as long as the value is not destroyed.\n@@ -2383,7 +2386,7 @@ The type itself must not be destroyed.\n * @param val A duckdb_value\n * @return A duckdb_logical_type.\n */\n-DUCKDB_API duckdb_logical_type duckdb_get_value_type(duckdb_value val);\n+DUCKDB_C_API duckdb_logical_type duckdb_get_value_type(duckdb_value val);\n \n /*!\n Returns the blob value of the given value.\n@@ -2391,7 +2394,7 @@ Returns the blob value of the given value.\n * @param val A duckdb_value containing a blob\n * @return A duckdb_blob\n */\n-DUCKDB_API duckdb_blob duckdb_get_blob(duckdb_value val);\n+DUCKDB_C_API duckdb_blob duckdb_get_blob(duckdb_value val);\n \n /*!\n Returns the duckdb_bit value of the given value.\n@@ -2400,7 +2403,7 @@ The `data` field must be destroyed with `duckdb_free`.\n * @param val A duckdb_value containing a BIT\n * @return A duckdb_bit\n */\n-DUCKDB_API duckdb_bit duckdb_get_bit(duckdb_value val);\n+DUCKDB_C_API duckdb_bit duckdb_get_bit(duckdb_value val);\n \n /*!\n Returns a duckdb_uhugeint representing the UUID value of the given value.\n@@ -2408,7 +2411,7 @@ Returns a duckdb_uhugeint representing the UUID value of the given value.\n * @param val A duckdb_value containing a UUID\n * @return A duckdb_uhugeint representing the UUID value\n */\n-DUCKDB_API duckdb_uhugeint duckdb_get_uuid(duckdb_value val);\n+DUCKDB_C_API duckdb_uhugeint duckdb_get_uuid(duckdb_value val);\n \n /*!\n Obtains a string representation of the given value.\n@@ -2417,7 +2420,7 @@ The result must be destroyed with `duckdb_free`.\n * @param value The value\n * @return The string value. This must be destroyed with `duckdb_free`.\n */\n-DUCKDB_API char *duckdb_get_varchar(duckdb_value value);\n+DUCKDB_C_API char *duckdb_get_varchar(duckdb_value value);\n \n /*!\n Creates a struct value from a type and an array of values. Must be destroyed with `duckdb_destroy_value`.\n@@ -2426,7 +2429,7 @@ Creates a struct value from a type and an array of values. Must be destroyed wit\n * @param values The values for the struct fields\n * @return The struct value, or nullptr, if any child type is `DUCKDB_TYPE_ANY` or `DUCKDB_TYPE_INVALID`.\n */\n-DUCKDB_API duckdb_value duckdb_create_struct_value(duckdb_logical_type type, duckdb_value *values);\n+DUCKDB_C_API duckdb_value duckdb_create_struct_value(duckdb_logical_type type, duckdb_value *values);\n \n /*!\n Creates a list value from a child (element) type and an array of values of length `value_count`.\n@@ -2437,7 +2440,7 @@ Must be destroyed with `duckdb_destroy_value`.\n * @param value_count The number of values in the list\n * @return The list value, or nullptr, if the child type is `DUCKDB_TYPE_ANY` or `DUCKDB_TYPE_INVALID`.\n */\n-DUCKDB_API duckdb_value duckdb_create_list_value(duckdb_logical_type type, duckdb_value *values, idx_t value_count);\n+DUCKDB_C_API duckdb_value duckdb_create_list_value(duckdb_logical_type type, duckdb_value *values, idx_t value_count);\n \n /*!\n Creates an array value from a child (element) type and an array of values of length `value_count`.\n@@ -2448,7 +2451,7 @@ Must be destroyed with `duckdb_destroy_value`.\n * @param value_count The number of values in the array\n * @return The array value, or nullptr, if the child type is `DUCKDB_TYPE_ANY` or `DUCKDB_TYPE_INVALID`.\n */\n-DUCKDB_API duckdb_value duckdb_create_array_value(duckdb_logical_type type, duckdb_value *values, idx_t value_count);\n+DUCKDB_C_API duckdb_value duckdb_create_array_value(duckdb_logical_type type, duckdb_value *values, idx_t value_count);\n \n /*!\n Returns the number of elements in a MAP value.\n@@ -2456,7 +2459,7 @@ Returns the number of elements in a MAP value.\n * @param value The MAP value.\n * @return The number of elements in the map.\n */\n-DUCKDB_API idx_t duckdb_get_map_size(duckdb_value value);\n+DUCKDB_C_API idx_t duckdb_get_map_size(duckdb_value value);\n \n /*!\n Returns the MAP key at index as a duckdb_value.\n@@ -2465,7 +2468,7 @@ Returns the MAP key at index as a duckdb_value.\n * @param index The index of the key.\n * @return The key as a duckdb_value.\n */\n-DUCKDB_API duckdb_value duckdb_get_map_key(duckdb_value value, idx_t index);\n+DUCKDB_C_API duckdb_value duckdb_get_map_key(duckdb_value value, idx_t index);\n \n /*!\n Returns the MAP value at index as a duckdb_value.\n@@ -2474,7 +2477,7 @@ Returns the MAP value at index as a duckdb_value.\n * @param index The index of the value.\n * @return The value as a duckdb_value.\n */\n-DUCKDB_API duckdb_value duckdb_get_map_value(duckdb_value value, idx_t index);\n+DUCKDB_C_API duckdb_value duckdb_get_map_value(duckdb_value value, idx_t index);\n \n /*!\n Returns whether the value's type is SQLNULL or not.\n@@ -2482,14 +2485,14 @@ Returns whether the value's type is SQLNULL or not.\n * @param value The value to check.\n * @return True, if the value's type is SQLNULL, otherwise false.\n */\n-DUCKDB_API bool duckdb_is_null_value(duckdb_value value);\n+DUCKDB_C_API bool duckdb_is_null_value(duckdb_value value);\n \n /*!\n Creates a value of type SQLNULL.\n \n * @return The duckdb_value representing SQLNULL. This must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_create_null_value();\n+DUCKDB_C_API duckdb_value duckdb_create_null_value();\n \n /*!\n Returns the number of elements in a LIST value.\n@@ -2497,7 +2500,7 @@ Returns the number of elements in a LIST value.\n * @param value The LIST value.\n * @return The number of elements in the list.\n */\n-DUCKDB_API idx_t duckdb_get_list_size(duckdb_value value);\n+DUCKDB_C_API idx_t duckdb_get_list_size(duckdb_value value);\n \n /*!\n Returns the LIST child at index as a duckdb_value.\n@@ -2506,7 +2509,7 @@ Returns the LIST child at index as a duckdb_value.\n * @param index The index of the child.\n * @return The child as a duckdb_value.\n */\n-DUCKDB_API duckdb_value duckdb_get_list_child(duckdb_value value, idx_t index);\n+DUCKDB_C_API duckdb_value duckdb_get_list_child(duckdb_value value, idx_t index);\n \n /*!\n Creates an enum value from a type and a value. Must be destroyed with `duckdb_destroy_value`.\n@@ -2515,7 +2518,7 @@ Creates an enum value from a type and a value. Must be destroyed with `duckdb_de\n * @param value The value for the enum\n * @return The enum value, or nullptr.\n */\n-DUCKDB_API duckdb_value duckdb_create_enum_value(duckdb_logical_type type, uint64_t value);\n+DUCKDB_C_API duckdb_value duckdb_create_enum_value(duckdb_logical_type type, uint64_t value);\n \n /*!\n Returns the enum value of the given value.\n@@ -2523,7 +2526,7 @@ Returns the enum value of the given value.\n * @param value A duckdb_value containing an enum\n * @return A uint64_t, or MinValue<uint64> if the value cannot be converted\n */\n-DUCKDB_API uint64_t duckdb_get_enum_value(duckdb_value value);\n+DUCKDB_C_API uint64_t duckdb_get_enum_value(duckdb_value value);\n \n /*!\n Returns the STRUCT child at index as a duckdb_value.\n@@ -2532,7 +2535,7 @@ Returns the STRUCT child at index as a duckdb_value.\n * @param index The index of the child.\n * @return The child as a duckdb_value.\n */\n-DUCKDB_API duckdb_value duckdb_get_struct_child(duckdb_value value, idx_t index);\n+DUCKDB_C_API duckdb_value duckdb_get_struct_child(duckdb_value value, idx_t index);\n \n //===--------------------------------------------------------------------===//\n // Logical Type Interface\n@@ -2548,7 +2551,7 @@ Returns an invalid logical type, if type is: `DUCKDB_TYPE_INVALID`, `DUCKDB_TYPE\n * @param type The primitive type to create.\n * @return The logical type.\n */\n-DUCKDB_API duckdb_logical_type duckdb_create_logical_type(duckdb_type type);\n+DUCKDB_C_API duckdb_logical_type duckdb_create_logical_type(duckdb_type type);\n \n /*!\n Returns the alias of a duckdb_logical_type, if set, else `nullptr`.\n@@ -2557,7 +2560,7 @@ The result must be destroyed with `duckdb_free`.\n * @param type The logical type\n * @return The alias or `nullptr`\n */\n-DUCKDB_API char *duckdb_logical_type_get_alias(duckdb_logical_type type);\n+DUCKDB_C_API char *duckdb_logical_type_get_alias(duckdb_logical_type type);\n \n /*!\n Sets the alias of a duckdb_logical_type.\n@@ -2565,7 +2568,7 @@ Sets the alias of a duckdb_logical_type.\n * @param type The logical type\n * @param alias The alias to set\n */\n-DUCKDB_API void duckdb_logical_type_set_alias(duckdb_logical_type type, const char *alias);\n+DUCKDB_C_API void duckdb_logical_type_set_alias(duckdb_logical_type type, const char *alias);\n \n /*!\n Creates a LIST type from its child type.\n@@ -2574,7 +2577,7 @@ The return type must be destroyed with `duckdb_destroy_logical_type`.\n * @param type The child type of the list\n * @return The logical type.\n */\n-DUCKDB_API duckdb_logical_type duckdb_create_list_type(duckdb_logical_type type);\n+DUCKDB_C_API duckdb_logical_type duckdb_create_list_type(duckdb_logical_type type);\n \n /*!\n Creates an ARRAY type from its child type.\n@@ -2584,7 +2587,7 @@ The return type must be destroyed with `duckdb_destroy_logical_type`.\n * @param array_size The number of elements in the array.\n * @return The logical type.\n */\n-DUCKDB_API duckdb_logical_type duckdb_create_array_type(duckdb_logical_type type, idx_t array_size);\n+DUCKDB_C_API duckdb_logical_type duckdb_create_array_type(duckdb_logical_type type, idx_t array_size);\n \n /*!\n Creates a MAP type from its key type and value type.\n@@ -2594,7 +2597,7 @@ The return type must be destroyed with `duckdb_destroy_logical_type`.\n * @param value_type The map's value type.\n * @return The logical type.\n */\n-DUCKDB_API duckdb_logical_type duckdb_create_map_type(duckdb_logical_type key_type, duckdb_logical_type value_type);\n+DUCKDB_C_API duckdb_logical_type duckdb_create_map_type(duckdb_logical_type key_type, duckdb_logical_type value_type);\n \n /*!\n Creates a UNION type from the passed arrays.\n@@ -2605,8 +2608,8 @@ The return type must be destroyed with `duckdb_destroy_logical_type`.\n * @param member_count The number of union members.\n * @return The logical type.\n */\n-DUCKDB_API duckdb_logical_type duckdb_create_union_type(duckdb_logical_type *member_types, const char **member_names,\n-                                                        idx_t member_count);\n+DUCKDB_C_API duckdb_logical_type duckdb_create_union_type(duckdb_logical_type *member_types, const char **member_names,\n+                                                          idx_t member_count);\n \n /*!\n Creates a STRUCT type based on the member types and names.\n@@ -2617,8 +2620,8 @@ The resulting type must be destroyed with `duckdb_destroy_logical_type`.\n * @param member_count The number of members of the struct.\n * @return The logical type.\n */\n-DUCKDB_API duckdb_logical_type duckdb_create_struct_type(duckdb_logical_type *member_types, const char **member_names,\n-                                                         idx_t member_count);\n+DUCKDB_C_API duckdb_logical_type duckdb_create_struct_type(duckdb_logical_type *member_types, const char **member_names,\n+                                                           idx_t member_count);\n \n /*!\n Creates an ENUM type from the passed member name array.\n@@ -2628,7 +2631,7 @@ The resulting type should be destroyed with `duckdb_destroy_logical_type`.\n * @param member_count The number of elements that were specified in the array.\n * @return The logical type.\n */\n-DUCKDB_API duckdb_logical_type duckdb_create_enum_type(const char **member_names, idx_t member_count);\n+DUCKDB_C_API duckdb_logical_type duckdb_create_enum_type(const char **member_names, idx_t member_count);\n \n /*!\n Creates a DECIMAL type with the specified width and scale.\n@@ -2638,7 +2641,7 @@ The resulting type should be destroyed with `duckdb_destroy_logical_type`.\n * @param scale The scale of the decimal type\n * @return The logical type.\n */\n-DUCKDB_API duckdb_logical_type duckdb_create_decimal_type(uint8_t width, uint8_t scale);\n+DUCKDB_C_API duckdb_logical_type duckdb_create_decimal_type(uint8_t width, uint8_t scale);\n \n /*!\n Retrieves the enum `duckdb_type` of a `duckdb_logical_type`.\n@@ -2646,7 +2649,7 @@ Retrieves the enum `duckdb_type` of a `duckdb_logical_type`.\n * @param type The logical type.\n * @return The `duckdb_type` id.\n */\n-DUCKDB_API duckdb_type duckdb_get_type_id(duckdb_logical_type type);\n+DUCKDB_C_API duckdb_type duckdb_get_type_id(duckdb_logical_type type);\n \n /*!\n Retrieves the width of a decimal type.\n@@ -2654,7 +2657,7 @@ Retrieves the width of a decimal type.\n * @param type The logical type object\n * @return The width of the decimal type\n */\n-DUCKDB_API uint8_t duckdb_decimal_width(duckdb_logical_type type);\n+DUCKDB_C_API uint8_t duckdb_decimal_width(duckdb_logical_type type);\n \n /*!\n Retrieves the scale of a decimal type.\n@@ -2662,7 +2665,7 @@ Retrieves the scale of a decimal type.\n * @param type The logical type object\n * @return The scale of the decimal type\n */\n-DUCKDB_API uint8_t duckdb_decimal_scale(duckdb_logical_type type);\n+DUCKDB_C_API uint8_t duckdb_decimal_scale(duckdb_logical_type type);\n \n /*!\n Retrieves the internal storage type of a decimal type.\n@@ -2670,7 +2673,7 @@ Retrieves the internal storage type of a decimal type.\n * @param type The logical type object\n * @return The internal type of the decimal type\n */\n-DUCKDB_API duckdb_type duckdb_decimal_internal_type(duckdb_logical_type type);\n+DUCKDB_C_API duckdb_type duckdb_decimal_internal_type(duckdb_logical_type type);\n \n /*!\n Retrieves the internal storage type of an enum type.\n@@ -2678,7 +2681,7 @@ Retrieves the internal storage type of an enum type.\n * @param type The logical type object\n * @return The internal type of the enum type\n */\n-DUCKDB_API duckdb_type duckdb_enum_internal_type(duckdb_logical_type type);\n+DUCKDB_C_API duckdb_type duckdb_enum_internal_type(duckdb_logical_type type);\n \n /*!\n Retrieves the dictionary size of the enum type.\n@@ -2686,7 +2689,7 @@ Retrieves the dictionary size of the enum type.\n * @param type The logical type object\n * @return The dictionary size of the enum type\n */\n-DUCKDB_API uint32_t duckdb_enum_dictionary_size(duckdb_logical_type type);\n+DUCKDB_C_API uint32_t duckdb_enum_dictionary_size(duckdb_logical_type type);\n \n /*!\n Retrieves the dictionary value at the specified position from the enum.\n@@ -2697,7 +2700,7 @@ The result must be freed with `duckdb_free`.\n * @param index The index in the dictionary\n * @return The string value of the enum type. Must be freed with `duckdb_free`.\n */\n-DUCKDB_API char *duckdb_enum_dictionary_value(duckdb_logical_type type, idx_t index);\n+DUCKDB_C_API char *duckdb_enum_dictionary_value(duckdb_logical_type type, idx_t index);\n \n /*!\n Retrieves the child type of the given LIST type. Also accepts MAP types.\n@@ -2706,7 +2709,7 @@ The result must be freed with `duckdb_destroy_logical_type`.\n * @param type The logical type, either LIST or MAP.\n * @return The child type of the LIST or MAP type.\n */\n-DUCKDB_API duckdb_logical_type duckdb_list_type_child_type(duckdb_logical_type type);\n+DUCKDB_C_API duckdb_logical_type duckdb_list_type_child_type(duckdb_logical_type type);\n \n /*!\n Retrieves the child type of the given ARRAY type.\n@@ -2716,7 +2719,7 @@ The result must be freed with `duckdb_destroy_logical_type`.\n * @param type The logical type. Must be ARRAY.\n * @return The child type of the ARRAY type.\n */\n-DUCKDB_API duckdb_logical_type duckdb_array_type_child_type(duckdb_logical_type type);\n+DUCKDB_C_API duckdb_logical_type duckdb_array_type_child_type(duckdb_logical_type type);\n \n /*!\n Retrieves the array size of the given array type.\n@@ -2724,7 +2727,7 @@ Retrieves the array size of the given array type.\n * @param type The logical type object\n * @return The fixed number of elements the values of this array type can store.\n */\n-DUCKDB_API idx_t duckdb_array_type_array_size(duckdb_logical_type type);\n+DUCKDB_C_API idx_t duckdb_array_type_array_size(duckdb_logical_type type);\n \n /*!\n Retrieves the key type of the given map type.\n@@ -2734,7 +2737,7 @@ The result must be freed with `duckdb_destroy_logical_type`.\n * @param type The logical type object\n * @return The key type of the map type. Must be destroyed with `duckdb_destroy_logical_type`.\n */\n-DUCKDB_API duckdb_logical_type duckdb_map_type_key_type(duckdb_logical_type type);\n+DUCKDB_C_API duckdb_logical_type duckdb_map_type_key_type(duckdb_logical_type type);\n \n /*!\n Retrieves the value type of the given map type.\n@@ -2744,7 +2747,7 @@ The result must be freed with `duckdb_destroy_logical_type`.\n * @param type The logical type object\n * @return The value type of the map type. Must be destroyed with `duckdb_destroy_logical_type`.\n */\n-DUCKDB_API duckdb_logical_type duckdb_map_type_value_type(duckdb_logical_type type);\n+DUCKDB_C_API duckdb_logical_type duckdb_map_type_value_type(duckdb_logical_type type);\n \n /*!\n Returns the number of children of a struct type.\n@@ -2752,7 +2755,7 @@ Returns the number of children of a struct type.\n * @param type The logical type object\n * @return The number of children of a struct type.\n */\n-DUCKDB_API idx_t duckdb_struct_type_child_count(duckdb_logical_type type);\n+DUCKDB_C_API idx_t duckdb_struct_type_child_count(duckdb_logical_type type);\n \n /*!\n Retrieves the name of the struct child.\n@@ -2763,7 +2766,7 @@ The result must be freed with `duckdb_free`.\n * @param index The child index\n * @return The name of the struct type. Must be freed with `duckdb_free`.\n */\n-DUCKDB_API char *duckdb_struct_type_child_name(duckdb_logical_type type, idx_t index);\n+DUCKDB_C_API char *duckdb_struct_type_child_name(duckdb_logical_type type, idx_t index);\n \n /*!\n Retrieves the child type of the given struct type at the specified index.\n@@ -2774,7 +2777,7 @@ The result must be freed with `duckdb_destroy_logical_type`.\n * @param index The child index\n * @return The child type of the struct type. Must be destroyed with `duckdb_destroy_logical_type`.\n */\n-DUCKDB_API duckdb_logical_type duckdb_struct_type_child_type(duckdb_logical_type type, idx_t index);\n+DUCKDB_C_API duckdb_logical_type duckdb_struct_type_child_type(duckdb_logical_type type, idx_t index);\n \n /*!\n Returns the number of members that the union type has.\n@@ -2782,7 +2785,7 @@ Returns the number of members that the union type has.\n * @param type The logical type (union) object\n * @return The number of members of a union type.\n */\n-DUCKDB_API idx_t duckdb_union_type_member_count(duckdb_logical_type type);\n+DUCKDB_C_API idx_t duckdb_union_type_member_count(duckdb_logical_type type);\n \n /*!\n Retrieves the name of the union member.\n@@ -2793,7 +2796,7 @@ The result must be freed with `duckdb_free`.\n * @param index The child index\n * @return The name of the union member. Must be freed with `duckdb_free`.\n */\n-DUCKDB_API char *duckdb_union_type_member_name(duckdb_logical_type type, idx_t index);\n+DUCKDB_C_API char *duckdb_union_type_member_name(duckdb_logical_type type, idx_t index);\n \n /*!\n Retrieves the child type of the given union member at the specified index.\n@@ -2804,14 +2807,14 @@ The result must be freed with `duckdb_destroy_logical_type`.\n * @param index The child index\n * @return The child type of the union member. Must be destroyed with `duckdb_destroy_logical_type`.\n */\n-DUCKDB_API duckdb_logical_type duckdb_union_type_member_type(duckdb_logical_type type, idx_t index);\n+DUCKDB_C_API duckdb_logical_type duckdb_union_type_member_type(duckdb_logical_type type, idx_t index);\n \n /*!\n Destroys the logical type and de-allocates all memory allocated for that type.\n \n * @param type The logical type to destroy.\n */\n-DUCKDB_API void duckdb_destroy_logical_type(duckdb_logical_type *type);\n+DUCKDB_C_API void duckdb_destroy_logical_type(duckdb_logical_type *type);\n \n /*!\n Registers a custom type within the given connection.\n@@ -2821,8 +2824,8 @@ The type must have an alias\n * @param type The custom type to register\n * @return Whether or not the registration was successful.\n */\n-DUCKDB_API duckdb_state duckdb_register_logical_type(duckdb_connection con, duckdb_logical_type type,\n-                                                     duckdb_create_type_info info);\n+DUCKDB_C_API duckdb_state duckdb_register_logical_type(duckdb_connection con, duckdb_logical_type type,\n+                                                       duckdb_create_type_info info);\n \n //===--------------------------------------------------------------------===//\n // Data Chunk Interface\n@@ -2836,14 +2839,14 @@ The result must be destroyed with `duckdb_destroy_data_chunk`.\n * @param column_count The number of columns.\n * @return The data chunk.\n */\n-DUCKDB_API duckdb_data_chunk duckdb_create_data_chunk(duckdb_logical_type *types, idx_t column_count);\n+DUCKDB_C_API duckdb_data_chunk duckdb_create_data_chunk(duckdb_logical_type *types, idx_t column_count);\n \n /*!\n Destroys the data chunk and de-allocates all memory allocated for that chunk.\n \n * @param chunk The data chunk to destroy.\n */\n-DUCKDB_API void duckdb_destroy_data_chunk(duckdb_data_chunk *chunk);\n+DUCKDB_C_API void duckdb_destroy_data_chunk(duckdb_data_chunk *chunk);\n \n /*!\n Resets a data chunk, clearing the validity masks and setting the cardinality of the data chunk to 0.\n@@ -2852,7 +2855,7 @@ data and validity pointers\n \n * @param chunk The data chunk to reset.\n */\n-DUCKDB_API void duckdb_data_chunk_reset(duckdb_data_chunk chunk);\n+DUCKDB_C_API void duckdb_data_chunk_reset(duckdb_data_chunk chunk);\n \n /*!\n Retrieves the number of columns in a data chunk.\n@@ -2860,7 +2863,7 @@ Retrieves the number of columns in a data chunk.\n * @param chunk The data chunk to get the data from\n * @return The number of columns in the data chunk\n */\n-DUCKDB_API idx_t duckdb_data_chunk_get_column_count(duckdb_data_chunk chunk);\n+DUCKDB_C_API idx_t duckdb_data_chunk_get_column_count(duckdb_data_chunk chunk);\n \n /*!\n Retrieves the vector at the specified column index in the data chunk.\n@@ -2871,7 +2874,7 @@ It does NOT need to be destroyed.\n * @param chunk The data chunk to get the data from\n * @return The vector\n */\n-DUCKDB_API duckdb_vector duckdb_data_chunk_get_vector(duckdb_data_chunk chunk, idx_t col_idx);\n+DUCKDB_C_API duckdb_vector duckdb_data_chunk_get_vector(duckdb_data_chunk chunk, idx_t col_idx);\n \n /*!\n Retrieves the current number of tuples in a data chunk.\n@@ -2879,7 +2882,7 @@ Retrieves the current number of tuples in a data chunk.\n * @param chunk The data chunk to get the data from\n * @return The number of tuples in the data chunk\n */\n-DUCKDB_API idx_t duckdb_data_chunk_get_size(duckdb_data_chunk chunk);\n+DUCKDB_C_API idx_t duckdb_data_chunk_get_size(duckdb_data_chunk chunk);\n \n /*!\n Sets the current number of tuples in a data chunk.\n@@ -2887,7 +2890,7 @@ Sets the current number of tuples in a data chunk.\n * @param chunk The data chunk to set the size in\n * @param size The number of tuples in the data chunk\n */\n-DUCKDB_API void duckdb_data_chunk_set_size(duckdb_data_chunk chunk, idx_t size);\n+DUCKDB_C_API void duckdb_data_chunk_set_size(duckdb_data_chunk chunk, idx_t size);\n \n //===--------------------------------------------------------------------===//\n // Vector Interface\n@@ -2901,7 +2904,7 @@ The result must be destroyed with `duckdb_destroy_logical_type`.\n * @param vector The vector get the data from\n * @return The type of the vector\n */\n-DUCKDB_API duckdb_logical_type duckdb_vector_get_column_type(duckdb_vector vector);\n+DUCKDB_C_API duckdb_logical_type duckdb_vector_get_column_type(duckdb_vector vector);\n \n /*!\n Retrieves the data pointer of the vector.\n@@ -2912,7 +2915,7 @@ How to read or write values depends on the type of the vector.\n * @param vector The vector to get the data from\n * @return The data pointer\n */\n-DUCKDB_API void *duckdb_vector_get_data(duckdb_vector vector);\n+DUCKDB_C_API void *duckdb_vector_get_data(duckdb_vector vector);\n \n /*!\n Retrieves the validity mask pointer of the specified vector.\n@@ -2934,7 +2937,7 @@ Alternatively, the (slower) duckdb_validity_row_is_valid function can be used.\n * @param vector The vector to get the data from\n * @return The pointer to the validity mask, or NULL if no validity mask is present\n */\n-DUCKDB_API uint64_t *duckdb_vector_get_validity(duckdb_vector vector);\n+DUCKDB_C_API uint64_t *duckdb_vector_get_validity(duckdb_vector vector);\n \n /*!\n Ensures the validity mask is writable by allocating it.\n@@ -2944,7 +2947,7 @@ This allows NULL values to be written to the vector, regardless of whether a val\n \n * @param vector The vector to alter\n */\n-DUCKDB_API void duckdb_vector_ensure_validity_writable(duckdb_vector vector);\n+DUCKDB_C_API void duckdb_vector_ensure_validity_writable(duckdb_vector vector);\n \n /*!\n Assigns a string element in the vector at the specified location.\n@@ -2953,7 +2956,7 @@ Assigns a string element in the vector at the specified location.\n * @param index The row position in the vector to assign the string to\n * @param str The null-terminated string\n */\n-DUCKDB_API void duckdb_vector_assign_string_element(duckdb_vector vector, idx_t index, const char *str);\n+DUCKDB_C_API void duckdb_vector_assign_string_element(duckdb_vector vector, idx_t index, const char *str);\n \n /*!\n Assigns a string element in the vector at the specified location. You may also use this function to assign BLOBs.\n@@ -2963,8 +2966,8 @@ Assigns a string element in the vector at the specified location. You may also u\n * @param str The string\n * @param str_len The length of the string (in bytes)\n */\n-DUCKDB_API void duckdb_vector_assign_string_element_len(duckdb_vector vector, idx_t index, const char *str,\n-                                                        idx_t str_len);\n+DUCKDB_C_API void duckdb_vector_assign_string_element_len(duckdb_vector vector, idx_t index, const char *str,\n+                                                          idx_t str_len);\n \n /*!\n Retrieves the child vector of a list vector.\n@@ -2974,7 +2977,7 @@ The resulting vector is valid as long as the parent vector is valid.\n * @param vector The vector\n * @return The child vector\n */\n-DUCKDB_API duckdb_vector duckdb_list_vector_get_child(duckdb_vector vector);\n+DUCKDB_C_API duckdb_vector duckdb_list_vector_get_child(duckdb_vector vector);\n \n /*!\n Returns the size of the child vector of the list.\n@@ -2982,7 +2985,7 @@ Returns the size of the child vector of the list.\n * @param vector The vector\n * @return The size of the child list\n */\n-DUCKDB_API idx_t duckdb_list_vector_get_size(duckdb_vector vector);\n+DUCKDB_C_API idx_t duckdb_list_vector_get_size(duckdb_vector vector);\n \n /*!\n Sets the total size of the underlying child-vector of a list vector.\n@@ -2991,7 +2994,7 @@ Sets the total size of the underlying child-vector of a list vector.\n * @param size The size of the child list.\n * @return The duckdb state. Returns DuckDBError if the vector is nullptr.\n */\n-DUCKDB_API duckdb_state duckdb_list_vector_set_size(duckdb_vector vector, idx_t size);\n+DUCKDB_C_API duckdb_state duckdb_list_vector_set_size(duckdb_vector vector, idx_t size);\n \n /*!\n Sets the total capacity of the underlying child-vector of a list.\n@@ -3003,7 +3006,7 @@ data and validity pointers\n * @param required_capacity the total capacity to reserve.\n * @return The duckdb state. Returns DuckDBError if the vector is nullptr.\n */\n-DUCKDB_API duckdb_state duckdb_list_vector_reserve(duckdb_vector vector, idx_t required_capacity);\n+DUCKDB_C_API duckdb_state duckdb_list_vector_reserve(duckdb_vector vector, idx_t required_capacity);\n \n /*!\n Retrieves the child vector of a struct vector.\n@@ -3014,7 +3017,7 @@ The resulting vector is valid as long as the parent vector is valid.\n * @param index The child index\n * @return The child vector\n */\n-DUCKDB_API duckdb_vector duckdb_struct_vector_get_child(duckdb_vector vector, idx_t index);\n+DUCKDB_C_API duckdb_vector duckdb_struct_vector_get_child(duckdb_vector vector, idx_t index);\n \n /*!\n Retrieves the child vector of a array vector.\n@@ -3025,7 +3028,7 @@ The resulting vector has the size of the parent vector multiplied by the array s\n * @param vector The vector\n * @return The child vector\n */\n-DUCKDB_API duckdb_vector duckdb_array_vector_get_child(duckdb_vector vector);\n+DUCKDB_C_API duckdb_vector duckdb_array_vector_get_child(duckdb_vector vector);\n \n //===--------------------------------------------------------------------===//\n // Validity Mask Functions\n@@ -3038,7 +3041,7 @@ Returns whether or not a row is valid (i.e. not NULL) in the given validity mask\n * @param row The row index\n * @return true if the row is valid, false otherwise\n */\n-DUCKDB_API bool duckdb_validity_row_is_valid(uint64_t *validity, idx_t row);\n+DUCKDB_C_API bool duckdb_validity_row_is_valid(uint64_t *validity, idx_t row);\n \n /*!\n In a validity mask, sets a specific row to either valid or invalid.\n@@ -3050,7 +3053,7 @@ to ensure that there is a validity mask to write to.\n * @param row The row index\n * @param valid Whether or not to set the row to valid, or invalid\n */\n-DUCKDB_API void duckdb_validity_set_row_validity(uint64_t *validity, idx_t row, bool valid);\n+DUCKDB_C_API void duckdb_validity_set_row_validity(uint64_t *validity, idx_t row, bool valid);\n \n /*!\n In a validity mask, sets a specific row to invalid.\n@@ -3060,7 +3063,7 @@ Equivalent to `duckdb_validity_set_row_validity` with valid set to false.\n * @param validity The validity mask\n * @param row The row index\n */\n-DUCKDB_API void duckdb_validity_set_row_invalid(uint64_t *validity, idx_t row);\n+DUCKDB_C_API void duckdb_validity_set_row_invalid(uint64_t *validity, idx_t row);\n \n /*!\n In a validity mask, sets a specific row to valid.\n@@ -3070,7 +3073,7 @@ Equivalent to `duckdb_validity_set_row_validity` with valid set to true.\n * @param validity The validity mask\n * @param row The row index\n */\n-DUCKDB_API void duckdb_validity_set_row_valid(uint64_t *validity, idx_t row);\n+DUCKDB_C_API void duckdb_validity_set_row_valid(uint64_t *validity, idx_t row);\n \n //===--------------------------------------------------------------------===//\n // Scalar Functions\n@@ -3083,14 +3086,14 @@ The return value should be destroyed with `duckdb_destroy_scalar_function`.\n \n * @return The scalar function object.\n */\n-DUCKDB_API duckdb_scalar_function duckdb_create_scalar_function();\n+DUCKDB_C_API duckdb_scalar_function duckdb_create_scalar_function();\n \n /*!\n Destroys the given scalar function object.\n \n * @param scalar_function The scalar function to destroy\n */\n-DUCKDB_API void duckdb_destroy_scalar_function(duckdb_scalar_function *scalar_function);\n+DUCKDB_C_API void duckdb_destroy_scalar_function(duckdb_scalar_function *scalar_function);\n \n /*!\n Sets the name of the given scalar function.\n@@ -3098,7 +3101,7 @@ Sets the name of the given scalar function.\n * @param scalar_function The scalar function\n * @param name The name of the scalar function\n */\n-DUCKDB_API void duckdb_scalar_function_set_name(duckdb_scalar_function scalar_function, const char *name);\n+DUCKDB_C_API void duckdb_scalar_function_set_name(duckdb_scalar_function scalar_function, const char *name);\n \n /*!\n Sets the parameters of the given scalar function to varargs. Does not require adding parameters with\n@@ -3108,7 +3111,7 @@ duckdb_scalar_function_add_parameter.\n * @param type The type of the arguments.\n * @return The parameter type. Cannot contain INVALID.\n */\n-DUCKDB_API void duckdb_scalar_function_set_varargs(duckdb_scalar_function scalar_function, duckdb_logical_type type);\n+DUCKDB_C_API void duckdb_scalar_function_set_varargs(duckdb_scalar_function scalar_function, duckdb_logical_type type);\n \n /*!\n Sets the parameters of the given scalar function to varargs. Does not require adding parameters with\n@@ -3116,7 +3119,7 @@ duckdb_scalar_function_add_parameter.\n \n * @param scalar_function The scalar function.\n */\n-DUCKDB_API void duckdb_scalar_function_set_special_handling(duckdb_scalar_function scalar_function);\n+DUCKDB_C_API void duckdb_scalar_function_set_special_handling(duckdb_scalar_function scalar_function);\n \n /*!\n Sets the Function Stability of the scalar function to VOLATILE, indicating the function should be re-run for every row.\n@@ -3124,7 +3127,7 @@ This limits optimization that can be performed for the function.\n \n * @param scalar_function The scalar function.\n */\n-DUCKDB_API void duckdb_scalar_function_set_volatile(duckdb_scalar_function scalar_function);\n+DUCKDB_C_API void duckdb_scalar_function_set_volatile(duckdb_scalar_function scalar_function);\n \n /*!\n Adds a parameter to the scalar function.\n@@ -3132,7 +3135,8 @@ Adds a parameter to the scalar function.\n * @param scalar_function The scalar function.\n * @param type The parameter type. Cannot contain INVALID.\n */\n-DUCKDB_API void duckdb_scalar_function_add_parameter(duckdb_scalar_function scalar_function, duckdb_logical_type type);\n+DUCKDB_C_API void duckdb_scalar_function_add_parameter(duckdb_scalar_function scalar_function,\n+                                                       duckdb_logical_type type);\n \n /*!\n Sets the return type of the scalar function.\n@@ -3140,8 +3144,8 @@ Sets the return type of the scalar function.\n * @param scalar_function The scalar function\n * @param type Cannot contain INVALID or ANY.\n */\n-DUCKDB_API void duckdb_scalar_function_set_return_type(duckdb_scalar_function scalar_function,\n-                                                       duckdb_logical_type type);\n+DUCKDB_C_API void duckdb_scalar_function_set_return_type(duckdb_scalar_function scalar_function,\n+                                                         duckdb_logical_type type);\n \n /*!\n Assigns extra information to the scalar function that can be fetched during binding, etc.\n@@ -3150,8 +3154,8 @@ Assigns extra information to the scalar function that can be fetched during bind\n * @param extra_info The extra information\n * @param destroy The callback that will be called to destroy the bind data (if any)\n */\n-DUCKDB_API void duckdb_scalar_function_set_extra_info(duckdb_scalar_function scalar_function, void *extra_info,\n-                                                      duckdb_delete_callback_t destroy);\n+DUCKDB_C_API void duckdb_scalar_function_set_extra_info(duckdb_scalar_function scalar_function, void *extra_info,\n+                                                        duckdb_delete_callback_t destroy);\n \n /*!\n Sets the main function of the scalar function.\n@@ -3159,8 +3163,8 @@ Sets the main function of the scalar function.\n * @param scalar_function The scalar function\n * @param function The function\n */\n-DUCKDB_API void duckdb_scalar_function_set_function(duckdb_scalar_function scalar_function,\n-                                                    duckdb_scalar_function_t function);\n+DUCKDB_C_API void duckdb_scalar_function_set_function(duckdb_scalar_function scalar_function,\n+                                                      duckdb_scalar_function_t function);\n \n /*!\n Register the scalar function object within the given connection.\n@@ -3173,7 +3177,8 @@ If the function is incomplete or a function with this name already exists DuckDB\n * @param scalar_function The function pointer\n * @return Whether or not the registration was successful.\n */\n-DUCKDB_API duckdb_state duckdb_register_scalar_function(duckdb_connection con, duckdb_scalar_function scalar_function);\n+DUCKDB_C_API duckdb_state duckdb_register_scalar_function(duckdb_connection con,\n+                                                          duckdb_scalar_function scalar_function);\n \n /*!\n Retrieves the extra info of the function as set in `duckdb_scalar_function_set_extra_info`.\n@@ -3181,7 +3186,7 @@ Retrieves the extra info of the function as set in `duckdb_scalar_function_set_e\n * @param info The info object.\n * @return The extra info.\n */\n-DUCKDB_API void *duckdb_scalar_function_get_extra_info(duckdb_function_info info);\n+DUCKDB_C_API void *duckdb_scalar_function_get_extra_info(duckdb_function_info info);\n \n /*!\n Report that an error has occurred while executing the scalar function.\n@@ -3189,7 +3194,7 @@ Report that an error has occurred while executing the scalar function.\n * @param info The info object.\n * @param error The error message\n */\n-DUCKDB_API void duckdb_scalar_function_set_error(duckdb_function_info info, const char *error);\n+DUCKDB_C_API void duckdb_scalar_function_set_error(duckdb_function_info info, const char *error);\n \n /*!\n Creates a new empty scalar function set.\n@@ -3198,13 +3203,13 @@ The return value should be destroyed with `duckdb_destroy_scalar_function_set`.\n \n * @return The scalar function set object.\n */\n-DUCKDB_API duckdb_scalar_function_set duckdb_create_scalar_function_set(const char *name);\n+DUCKDB_C_API duckdb_scalar_function_set duckdb_create_scalar_function_set(const char *name);\n \n /*!\n Destroys the given scalar function set object.\n \n */\n-DUCKDB_API void duckdb_destroy_scalar_function_set(duckdb_scalar_function_set *scalar_function_set);\n+DUCKDB_C_API void duckdb_destroy_scalar_function_set(duckdb_scalar_function_set *scalar_function_set);\n \n /*!\n Adds the scalar function as a new overload to the scalar function set.\n@@ -3214,8 +3219,8 @@ Returns DuckDBError if the function could not be added, for example if the overl\n * @param set The scalar function set\n * @param function The function to add\n */\n-DUCKDB_API duckdb_state duckdb_add_scalar_function_to_set(duckdb_scalar_function_set set,\n-                                                          duckdb_scalar_function function);\n+DUCKDB_C_API duckdb_state duckdb_add_scalar_function_to_set(duckdb_scalar_function_set set,\n+                                                            duckdb_scalar_function function);\n \n /*!\n Register the scalar function set within the given connection.\n@@ -3228,7 +3233,7 @@ If the set is incomplete or a function with this name already exists DuckDBError\n * @param set The function set to register\n * @return Whether or not the registration was successful.\n */\n-DUCKDB_API duckdb_state duckdb_register_scalar_function_set(duckdb_connection con, duckdb_scalar_function_set set);\n+DUCKDB_C_API duckdb_state duckdb_register_scalar_function_set(duckdb_connection con, duckdb_scalar_function_set set);\n \n //===--------------------------------------------------------------------===//\n // Aggregate Functions\n@@ -3241,13 +3246,13 @@ The return value should be destroyed with `duckdb_destroy_aggregate_function`.\n \n * @return The aggregate function object.\n */\n-DUCKDB_API duckdb_aggregate_function duckdb_create_aggregate_function();\n+DUCKDB_C_API duckdb_aggregate_function duckdb_create_aggregate_function();\n \n /*!\n Destroys the given aggregate function object.\n \n */\n-DUCKDB_API void duckdb_destroy_aggregate_function(duckdb_aggregate_function *aggregate_function);\n+DUCKDB_C_API void duckdb_destroy_aggregate_function(duckdb_aggregate_function *aggregate_function);\n \n /*!\n Sets the name of the given aggregate function.\n@@ -3255,7 +3260,7 @@ Sets the name of the given aggregate function.\n * @param aggregate_function The aggregate function\n * @param name The name of the aggregate function\n */\n-DUCKDB_API void duckdb_aggregate_function_set_name(duckdb_aggregate_function aggregate_function, const char *name);\n+DUCKDB_C_API void duckdb_aggregate_function_set_name(duckdb_aggregate_function aggregate_function, const char *name);\n \n /*!\n Adds a parameter to the aggregate function.\n@@ -3263,8 +3268,8 @@ Adds a parameter to the aggregate function.\n * @param aggregate_function The aggregate function.\n * @param type The parameter type. Cannot contain INVALID.\n */\n-DUCKDB_API void duckdb_aggregate_function_add_parameter(duckdb_aggregate_function aggregate_function,\n-                                                        duckdb_logical_type type);\n+DUCKDB_C_API void duckdb_aggregate_function_add_parameter(duckdb_aggregate_function aggregate_function,\n+                                                          duckdb_logical_type type);\n \n /*!\n Sets the return type of the aggregate function.\n@@ -3272,8 +3277,8 @@ Sets the return type of the aggregate function.\n * @param aggregate_function The aggregate function.\n * @param type The return type. Cannot contain INVALID or ANY.\n */\n-DUCKDB_API void duckdb_aggregate_function_set_return_type(duckdb_aggregate_function aggregate_function,\n-                                                          duckdb_logical_type type);\n+DUCKDB_C_API void duckdb_aggregate_function_set_return_type(duckdb_aggregate_function aggregate_function,\n+                                                            duckdb_logical_type type);\n \n /*!\n Sets the main functions of the aggregate function.\n@@ -3285,12 +3290,12 @@ Sets the main functions of the aggregate function.\n * @param combine combine states\n * @param finalize finalize states\n */\n-DUCKDB_API void duckdb_aggregate_function_set_functions(duckdb_aggregate_function aggregate_function,\n-                                                        duckdb_aggregate_state_size state_size,\n-                                                        duckdb_aggregate_init_t state_init,\n-                                                        duckdb_aggregate_update_t update,\n-                                                        duckdb_aggregate_combine_t combine,\n-                                                        duckdb_aggregate_finalize_t finalize);\n+DUCKDB_C_API void duckdb_aggregate_function_set_functions(duckdb_aggregate_function aggregate_function,\n+                                                          duckdb_aggregate_state_size state_size,\n+                                                          duckdb_aggregate_init_t state_init,\n+                                                          duckdb_aggregate_update_t update,\n+                                                          duckdb_aggregate_combine_t combine,\n+                                                          duckdb_aggregate_finalize_t finalize);\n \n /*!\n Sets the state destructor callback of the aggregate function (optional)\n@@ -3298,8 +3303,8 @@ Sets the state destructor callback of the aggregate function (optional)\n * @param aggregate_function The aggregate function\n * @param destroy state destroy callback\n */\n-DUCKDB_API void duckdb_aggregate_function_set_destructor(duckdb_aggregate_function aggregate_function,\n-                                                         duckdb_aggregate_destroy_t destroy);\n+DUCKDB_C_API void duckdb_aggregate_function_set_destructor(duckdb_aggregate_function aggregate_function,\n+                                                           duckdb_aggregate_destroy_t destroy);\n \n /*!\n Register the aggregate function object within the given connection.\n@@ -3311,15 +3316,15 @@ If the function is incomplete or a function with this name already exists DuckDB\n * @param con The connection to register it in.\n * @return Whether or not the registration was successful.\n */\n-DUCKDB_API duckdb_state duckdb_register_aggregate_function(duckdb_connection con,\n-                                                           duckdb_aggregate_function aggregate_function);\n+DUCKDB_C_API duckdb_state duckdb_register_aggregate_function(duckdb_connection con,\n+                                                             duckdb_aggregate_function aggregate_function);\n \n /*!\n Sets the NULL handling of the aggregate function to SPECIAL_HANDLING.\n \n * @param aggregate_function The aggregate function\n */\n-DUCKDB_API void duckdb_aggregate_function_set_special_handling(duckdb_aggregate_function aggregate_function);\n+DUCKDB_C_API void duckdb_aggregate_function_set_special_handling(duckdb_aggregate_function aggregate_function);\n \n /*!\n Assigns extra information to the scalar function that can be fetched during binding, etc.\n@@ -3328,8 +3333,8 @@ Assigns extra information to the scalar function that can be fetched during bind\n * @param extra_info The extra information\n * @param destroy The callback that will be called to destroy the bind data (if any)\n */\n-DUCKDB_API void duckdb_aggregate_function_set_extra_info(duckdb_aggregate_function aggregate_function, void *extra_info,\n-                                                         duckdb_delete_callback_t destroy);\n+DUCKDB_C_API void duckdb_aggregate_function_set_extra_info(duckdb_aggregate_function aggregate_function,\n+                                                           void *extra_info, duckdb_delete_callback_t destroy);\n \n /*!\n Retrieves the extra info of the function as set in `duckdb_aggregate_function_set_extra_info`.\n@@ -3337,7 +3342,7 @@ Retrieves the extra info of the function as set in `duckdb_aggregate_function_se\n * @param info The info object\n * @return The extra info\n */\n-DUCKDB_API void *duckdb_aggregate_function_get_extra_info(duckdb_function_info info);\n+DUCKDB_C_API void *duckdb_aggregate_function_get_extra_info(duckdb_function_info info);\n \n /*!\n Report that an error has occurred while executing the aggregate function.\n@@ -3345,7 +3350,7 @@ Report that an error has occurred while executing the aggregate function.\n * @param info The info object\n * @param error The error message\n */\n-DUCKDB_API void duckdb_aggregate_function_set_error(duckdb_function_info info, const char *error);\n+DUCKDB_C_API void duckdb_aggregate_function_set_error(duckdb_function_info info, const char *error);\n \n /*!\n Creates a new empty aggregate function set.\n@@ -3354,13 +3359,13 @@ The return value should be destroyed with `duckdb_destroy_aggregate_function_set\n \n * @return The aggregate function set object.\n */\n-DUCKDB_API duckdb_aggregate_function_set duckdb_create_aggregate_function_set(const char *name);\n+DUCKDB_C_API duckdb_aggregate_function_set duckdb_create_aggregate_function_set(const char *name);\n \n /*!\n Destroys the given aggregate function set object.\n \n */\n-DUCKDB_API void duckdb_destroy_aggregate_function_set(duckdb_aggregate_function_set *aggregate_function_set);\n+DUCKDB_C_API void duckdb_destroy_aggregate_function_set(duckdb_aggregate_function_set *aggregate_function_set);\n \n /*!\n Adds the aggregate function as a new overload to the aggregate function set.\n@@ -3370,8 +3375,8 @@ Returns DuckDBError if the function could not be added, for example if the overl\n * @param set The aggregate function set\n * @param function The function to add\n */\n-DUCKDB_API duckdb_state duckdb_add_aggregate_function_to_set(duckdb_aggregate_function_set set,\n-                                                             duckdb_aggregate_function function);\n+DUCKDB_C_API duckdb_state duckdb_add_aggregate_function_to_set(duckdb_aggregate_function_set set,\n+                                                               duckdb_aggregate_function function);\n \n /*!\n Register the aggregate function set within the given connection.\n@@ -3384,8 +3389,8 @@ If the set is incomplete or a function with this name already exists DuckDBError\n * @param set The function set to register\n * @return Whether or not the registration was successful.\n */\n-DUCKDB_API duckdb_state duckdb_register_aggregate_function_set(duckdb_connection con,\n-                                                               duckdb_aggregate_function_set set);\n+DUCKDB_C_API duckdb_state duckdb_register_aggregate_function_set(duckdb_connection con,\n+                                                                 duckdb_aggregate_function_set set);\n \n //===--------------------------------------------------------------------===//\n // Table Functions\n@@ -3398,14 +3403,14 @@ The return value should be destroyed with `duckdb_destroy_table_function`.\n \n * @return The table function object.\n */\n-DUCKDB_API duckdb_table_function duckdb_create_table_function();\n+DUCKDB_C_API duckdb_table_function duckdb_create_table_function();\n \n /*!\n Destroys the given table function object.\n \n * @param table_function The table function to destroy\n */\n-DUCKDB_API void duckdb_destroy_table_function(duckdb_table_function *table_function);\n+DUCKDB_C_API void duckdb_destroy_table_function(duckdb_table_function *table_function);\n \n /*!\n Sets the name of the given table function.\n@@ -3413,7 +3418,7 @@ Sets the name of the given table function.\n * @param table_function The table function\n * @param name The name of the table function\n */\n-DUCKDB_API void duckdb_table_function_set_name(duckdb_table_function table_function, const char *name);\n+DUCKDB_C_API void duckdb_table_function_set_name(duckdb_table_function table_function, const char *name);\n \n /*!\n Adds a parameter to the table function.\n@@ -3421,7 +3426,7 @@ Adds a parameter to the table function.\n * @param table_function The table function.\n * @param type The parameter type. Cannot contain INVALID.\n */\n-DUCKDB_API void duckdb_table_function_add_parameter(duckdb_table_function table_function, duckdb_logical_type type);\n+DUCKDB_C_API void duckdb_table_function_add_parameter(duckdb_table_function table_function, duckdb_logical_type type);\n \n /*!\n Adds a named parameter to the table function.\n@@ -3430,8 +3435,8 @@ Adds a named parameter to the table function.\n * @param name The parameter name.\n * @param type The parameter type. Cannot contain INVALID.\n */\n-DUCKDB_API void duckdb_table_function_add_named_parameter(duckdb_table_function table_function, const char *name,\n-                                                          duckdb_logical_type type);\n+DUCKDB_C_API void duckdb_table_function_add_named_parameter(duckdb_table_function table_function, const char *name,\n+                                                            duckdb_logical_type type);\n \n /*!\n Assigns extra information to the table function that can be fetched during binding, etc.\n@@ -3440,8 +3445,8 @@ Assigns extra information to the table function that can be fetched during bindi\n * @param extra_info The extra information\n * @param destroy The callback that will be called to destroy the bind data (if any)\n */\n-DUCKDB_API void duckdb_table_function_set_extra_info(duckdb_table_function table_function, void *extra_info,\n-                                                     duckdb_delete_callback_t destroy);\n+DUCKDB_C_API void duckdb_table_function_set_extra_info(duckdb_table_function table_function, void *extra_info,\n+                                                       duckdb_delete_callback_t destroy);\n \n /*!\n Sets the bind function of the table function.\n@@ -3449,7 +3454,8 @@ Sets the bind function of the table function.\n * @param table_function The table function\n * @param bind The bind function\n */\n-DUCKDB_API void duckdb_table_function_set_bind(duckdb_table_function table_function, duckdb_table_function_bind_t bind);\n+DUCKDB_C_API void duckdb_table_function_set_bind(duckdb_table_function table_function,\n+                                                 duckdb_table_function_bind_t bind);\n \n /*!\n Sets the init function of the table function.\n@@ -3457,7 +3463,8 @@ Sets the init function of the table function.\n * @param table_function The table function\n * @param init The init function\n */\n-DUCKDB_API void duckdb_table_function_set_init(duckdb_table_function table_function, duckdb_table_function_init_t init);\n+DUCKDB_C_API void duckdb_table_function_set_init(duckdb_table_function table_function,\n+                                                 duckdb_table_function_init_t init);\n \n /*!\n Sets the thread-local init function of the table function.\n@@ -3465,8 +3472,8 @@ Sets the thread-local init function of the table function.\n * @param table_function The table function\n * @param init The init function\n */\n-DUCKDB_API void duckdb_table_function_set_local_init(duckdb_table_function table_function,\n-                                                     duckdb_table_function_init_t init);\n+DUCKDB_C_API void duckdb_table_function_set_local_init(duckdb_table_function table_function,\n+                                                       duckdb_table_function_init_t init);\n \n /*!\n Sets the main function of the table function.\n@@ -3474,8 +3481,8 @@ Sets the main function of the table function.\n * @param table_function The table function\n * @param function The function\n */\n-DUCKDB_API void duckdb_table_function_set_function(duckdb_table_function table_function,\n-                                                   duckdb_table_function_t function);\n+DUCKDB_C_API void duckdb_table_function_set_function(duckdb_table_function table_function,\n+                                                     duckdb_table_function_t function);\n \n /*!\n Sets whether or not the given table function supports projection pushdown.\n@@ -3487,7 +3494,8 @@ If this is set to false (the default), the system will expect all columns to be\n * @param table_function The table function\n * @param pushdown True if the table function supports projection pushdown, false otherwise.\n */\n-DUCKDB_API void duckdb_table_function_supports_projection_pushdown(duckdb_table_function table_function, bool pushdown);\n+DUCKDB_C_API void duckdb_table_function_supports_projection_pushdown(duckdb_table_function table_function,\n+                                                                     bool pushdown);\n \n /*!\n Register the table function object within the given connection.\n@@ -3500,7 +3508,7 @@ If the function is incomplete or a function with this name already exists DuckDB\n * @param function The function pointer\n * @return Whether or not the registration was successful.\n */\n-DUCKDB_API duckdb_state duckdb_register_table_function(duckdb_connection con, duckdb_table_function function);\n+DUCKDB_C_API duckdb_state duckdb_register_table_function(duckdb_connection con, duckdb_table_function function);\n \n //===--------------------------------------------------------------------===//\n // Table Function Bind\n@@ -3512,7 +3520,7 @@ Retrieves the extra info of the function as set in `duckdb_table_function_set_ex\n * @param info The info object\n * @return The extra info\n */\n-DUCKDB_API void *duckdb_bind_get_extra_info(duckdb_bind_info info);\n+DUCKDB_C_API void *duckdb_bind_get_extra_info(duckdb_bind_info info);\n \n /*!\n Adds a result column to the output of the table function.\n@@ -3521,7 +3529,7 @@ Adds a result column to the output of the table function.\n * @param name The column name.\n * @param type The logical column type.\n */\n-DUCKDB_API void duckdb_bind_add_result_column(duckdb_bind_info info, const char *name, duckdb_logical_type type);\n+DUCKDB_C_API void duckdb_bind_add_result_column(duckdb_bind_info info, const char *name, duckdb_logical_type type);\n \n /*!\n Retrieves the number of regular (non-named) parameters to the function.\n@@ -3529,7 +3537,7 @@ Retrieves the number of regular (non-named) parameters to the function.\n * @param info The info object\n * @return The number of parameters\n */\n-DUCKDB_API idx_t duckdb_bind_get_parameter_count(duckdb_bind_info info);\n+DUCKDB_C_API idx_t duckdb_bind_get_parameter_count(duckdb_bind_info info);\n \n /*!\n Retrieves the parameter at the given index.\n@@ -3540,7 +3548,7 @@ The result must be destroyed with `duckdb_destroy_value`.\n * @param index The index of the parameter to get\n * @return The value of the parameter. Must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_bind_get_parameter(duckdb_bind_info info, idx_t index);\n+DUCKDB_C_API duckdb_value duckdb_bind_get_parameter(duckdb_bind_info info, idx_t index);\n \n /*!\n Retrieves a named parameter with the given name.\n@@ -3551,7 +3559,7 @@ The result must be destroyed with `duckdb_destroy_value`.\n * @param name The name of the parameter\n * @return The value of the parameter. Must be destroyed with `duckdb_destroy_value`.\n */\n-DUCKDB_API duckdb_value duckdb_bind_get_named_parameter(duckdb_bind_info info, const char *name);\n+DUCKDB_C_API duckdb_value duckdb_bind_get_named_parameter(duckdb_bind_info info, const char *name);\n \n /*!\n Sets the user-provided bind data in the bind object. This object can be retrieved again during execution.\n@@ -3560,7 +3568,7 @@ Sets the user-provided bind data in the bind object. This object can be retrieve\n * @param bind_data The bind data object.\n * @param destroy The callback that will be called to destroy the bind data (if any)\n */\n-DUCKDB_API void duckdb_bind_set_bind_data(duckdb_bind_info info, void *bind_data, duckdb_delete_callback_t destroy);\n+DUCKDB_C_API void duckdb_bind_set_bind_data(duckdb_bind_info info, void *bind_data, duckdb_delete_callback_t destroy);\n \n /*!\n Sets the cardinality estimate for the table function, used for optimization.\n@@ -3568,7 +3576,7 @@ Sets the cardinality estimate for the table function, used for optimization.\n * @param info The bind data object.\n * @param is_exact Whether or not the cardinality estimate is exact, or an approximation\n */\n-DUCKDB_API void duckdb_bind_set_cardinality(duckdb_bind_info info, idx_t cardinality, bool is_exact);\n+DUCKDB_C_API void duckdb_bind_set_cardinality(duckdb_bind_info info, idx_t cardinality, bool is_exact);\n \n /*!\n Report that an error has occurred while calling bind.\n@@ -3576,7 +3584,7 @@ Report that an error has occurred while calling bind.\n * @param info The info object\n * @param error The error message\n */\n-DUCKDB_API void duckdb_bind_set_error(duckdb_bind_info info, const char *error);\n+DUCKDB_C_API void duckdb_bind_set_error(duckdb_bind_info info, const char *error);\n \n //===--------------------------------------------------------------------===//\n // Table Function Init\n@@ -3588,7 +3596,7 @@ Retrieves the extra info of the function as set in `duckdb_table_function_set_ex\n * @param info The info object\n * @return The extra info\n */\n-DUCKDB_API void *duckdb_init_get_extra_info(duckdb_init_info info);\n+DUCKDB_C_API void *duckdb_init_get_extra_info(duckdb_init_info info);\n \n /*!\n Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.\n@@ -3599,7 +3607,7 @@ For tracking state, use the init data instead.\n * @param info The info object\n * @return The bind data object\n */\n-DUCKDB_API void *duckdb_init_get_bind_data(duckdb_init_info info);\n+DUCKDB_C_API void *duckdb_init_get_bind_data(duckdb_init_info info);\n \n /*!\n Sets the user-provided init data in the init object. This object can be retrieved again during execution.\n@@ -3608,7 +3616,7 @@ Sets the user-provided init data in the init object. This object can be retrieve\n * @param init_data The init data object.\n * @param destroy The callback that will be called to destroy the init data (if any)\n */\n-DUCKDB_API void duckdb_init_set_init_data(duckdb_init_info info, void *init_data, duckdb_delete_callback_t destroy);\n+DUCKDB_C_API void duckdb_init_set_init_data(duckdb_init_info info, void *init_data, duckdb_delete_callback_t destroy);\n \n /*!\n Returns the number of projected columns.\n@@ -3618,7 +3626,7 @@ This function must be used if projection pushdown is enabled to figure out which\n * @param info The info object\n * @return The number of projected columns.\n */\n-DUCKDB_API idx_t duckdb_init_get_column_count(duckdb_init_info info);\n+DUCKDB_C_API idx_t duckdb_init_get_column_count(duckdb_init_info info);\n \n /*!\n Returns the column index of the projected column at the specified position.\n@@ -3629,7 +3637,7 @@ This function must be used if projection pushdown is enabled to figure out which\n * @param column_index The index at which to get the projected column index, from 0..duckdb_init_get_column_count(info)\n * @return The column index of the projected column.\n */\n-DUCKDB_API idx_t duckdb_init_get_column_index(duckdb_init_info info, idx_t column_index);\n+DUCKDB_C_API idx_t duckdb_init_get_column_index(duckdb_init_info info, idx_t column_index);\n \n /*!\n Sets how many threads can process this table function in parallel (default: 1)\n@@ -3637,7 +3645,7 @@ Sets how many threads can process this table function in parallel (default: 1)\n * @param info The info object\n * @param max_threads The maximum amount of threads that can process this table function\n */\n-DUCKDB_API void duckdb_init_set_max_threads(duckdb_init_info info, idx_t max_threads);\n+DUCKDB_C_API void duckdb_init_set_max_threads(duckdb_init_info info, idx_t max_threads);\n \n /*!\n Report that an error has occurred while calling init.\n@@ -3645,7 +3653,7 @@ Report that an error has occurred while calling init.\n * @param info The info object\n * @param error The error message\n */\n-DUCKDB_API void duckdb_init_set_error(duckdb_init_info info, const char *error);\n+DUCKDB_C_API void duckdb_init_set_error(duckdb_init_info info, const char *error);\n \n //===--------------------------------------------------------------------===//\n // Table Function\n@@ -3657,7 +3665,7 @@ Retrieves the extra info of the function as set in `duckdb_table_function_set_ex\n * @param info The info object\n * @return The extra info\n */\n-DUCKDB_API void *duckdb_function_get_extra_info(duckdb_function_info info);\n+DUCKDB_C_API void *duckdb_function_get_extra_info(duckdb_function_info info);\n \n /*!\n Gets the bind data set by `duckdb_bind_set_bind_data` during the bind.\n@@ -3668,7 +3676,7 @@ For tracking state, use the init data instead.\n * @param info The info object\n * @return The bind data object\n */\n-DUCKDB_API void *duckdb_function_get_bind_data(duckdb_function_info info);\n+DUCKDB_C_API void *duckdb_function_get_bind_data(duckdb_function_info info);\n \n /*!\n Gets the init data set by `duckdb_init_set_init_data` during the init.\n@@ -3676,7 +3684,7 @@ Gets the init data set by `duckdb_init_set_init_data` during the init.\n * @param info The info object\n * @return The init data object\n */\n-DUCKDB_API void *duckdb_function_get_init_data(duckdb_function_info info);\n+DUCKDB_C_API void *duckdb_function_get_init_data(duckdb_function_info info);\n \n /*!\n Gets the thread-local init data set by `duckdb_init_set_init_data` during the local_init.\n@@ -3684,7 +3692,7 @@ Gets the thread-local init data set by `duckdb_init_set_init_data` during the lo\n * @param info The info object\n * @return The init data object\n */\n-DUCKDB_API void *duckdb_function_get_local_init_data(duckdb_function_info info);\n+DUCKDB_C_API void *duckdb_function_get_local_init_data(duckdb_function_info info);\n \n /*!\n Report that an error has occurred while executing the function.\n@@ -3692,7 +3700,7 @@ Report that an error has occurred while executing the function.\n * @param info The info object\n * @param error The error message\n */\n-DUCKDB_API void duckdb_function_set_error(duckdb_function_info info, const char *error);\n+DUCKDB_C_API void duckdb_function_set_error(duckdb_function_info info, const char *error);\n \n //===--------------------------------------------------------------------===//\n // Replacement Scans\n@@ -3706,8 +3714,8 @@ Add a replacement scan definition to the specified database.\n * @param extra_data Extra data that is passed back into the specified callback\n * @param delete_callback The delete callback to call on the extra data, if any\n */\n-DUCKDB_API void duckdb_add_replacement_scan(duckdb_database db, duckdb_replacement_callback_t replacement,\n-                                            void *extra_data, duckdb_delete_callback_t delete_callback);\n+DUCKDB_C_API void duckdb_add_replacement_scan(duckdb_database db, duckdb_replacement_callback_t replacement,\n+                                              void *extra_data, duckdb_delete_callback_t delete_callback);\n \n /*!\n Sets the replacement function name. If this function is called in the replacement callback,\n@@ -3716,7 +3724,8 @@ the replacement scan is performed. If it is not called, the replacement callback\n * @param info The info object\n * @param function_name The function name to substitute.\n */\n-DUCKDB_API void duckdb_replacement_scan_set_function_name(duckdb_replacement_scan_info info, const char *function_name);\n+DUCKDB_C_API void duckdb_replacement_scan_set_function_name(duckdb_replacement_scan_info info,\n+                                                            const char *function_name);\n \n /*!\n Adds a parameter to the replacement scan function.\n@@ -3724,7 +3733,7 @@ Adds a parameter to the replacement scan function.\n * @param info The info object\n * @param parameter The parameter to add.\n */\n-DUCKDB_API void duckdb_replacement_scan_add_parameter(duckdb_replacement_scan_info info, duckdb_value parameter);\n+DUCKDB_C_API void duckdb_replacement_scan_add_parameter(duckdb_replacement_scan_info info, duckdb_value parameter);\n \n /*!\n Report that an error has occurred while executing the replacement scan.\n@@ -3732,7 +3741,7 @@ Report that an error has occurred while executing the replacement scan.\n * @param info The info object\n * @param error The error message\n */\n-DUCKDB_API void duckdb_replacement_scan_set_error(duckdb_replacement_scan_info info, const char *error);\n+DUCKDB_C_API void duckdb_replacement_scan_set_error(duckdb_replacement_scan_info info, const char *error);\n \n //===--------------------------------------------------------------------===//\n // Profiling Info\n@@ -3744,7 +3753,7 @@ Returns the root node of the profiling information. Returns nullptr, if profilin\n * @param connection A connection object.\n * @return A profiling information object.\n */\n-DUCKDB_API duckdb_profiling_info duckdb_get_profiling_info(duckdb_connection connection);\n+DUCKDB_C_API duckdb_profiling_info duckdb_get_profiling_info(duckdb_connection connection);\n \n /*!\n Returns the value of the metric of the current profiling info node. Returns nullptr, if the metric does\n@@ -3755,7 +3764,7 @@ Returns the value of the metric of the current profiling info node. Returns null\n * @param key The name of the requested metric.\n * @return The value of the metric. Must be freed with `duckdb_destroy_value`\n */\n-DUCKDB_API duckdb_value duckdb_profiling_info_get_value(duckdb_profiling_info info, const char *key);\n+DUCKDB_C_API duckdb_value duckdb_profiling_info_get_value(duckdb_profiling_info info, const char *key);\n \n /*!\n Returns the key-value metric map of this profiling node as a MAP duckdb_value.\n@@ -3764,7 +3773,7 @@ The individual elements are accessible via the duckdb_value MAP functions.\n * @param info A profiling information object.\n * @return The key-value metric map as a MAP duckdb_value.\n */\n-DUCKDB_API duckdb_value duckdb_profiling_info_get_metrics(duckdb_profiling_info info);\n+DUCKDB_C_API duckdb_value duckdb_profiling_info_get_metrics(duckdb_profiling_info info);\n \n /*!\n Returns the number of children in the current profiling info node.\n@@ -3772,7 +3781,7 @@ Returns the number of children in the current profiling info node.\n * @param info A profiling information object.\n * @return The number of children in the current node.\n */\n-DUCKDB_API idx_t duckdb_profiling_info_get_child_count(duckdb_profiling_info info);\n+DUCKDB_C_API idx_t duckdb_profiling_info_get_child_count(duckdb_profiling_info info);\n \n /*!\n Returns the child node at the specified index.\n@@ -3781,7 +3790,7 @@ Returns the child node at the specified index.\n * @param index The index of the child node.\n * @return The child node at the specified index.\n */\n-DUCKDB_API duckdb_profiling_info duckdb_profiling_info_get_child(duckdb_profiling_info info, idx_t index);\n+DUCKDB_C_API duckdb_profiling_info duckdb_profiling_info_get_child(duckdb_profiling_info info, idx_t index);\n \n //===--------------------------------------------------------------------===//\n // Appender\n@@ -3812,8 +3821,8 @@ Note that the object must be destroyed with `duckdb_appender_destroy`.\n * @param out_appender The resulting appender object.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,\n-                                               duckdb_appender *out_appender);\n+DUCKDB_C_API duckdb_state duckdb_appender_create(duckdb_connection connection, const char *schema, const char *table,\n+                                                 duckdb_appender *out_appender);\n \n /*!\n Creates an appender object.\n@@ -3827,9 +3836,9 @@ Note that the object must be destroyed with `duckdb_appender_destroy`.\n * @param out_appender The resulting appender object.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_appender_create_ext(duckdb_connection connection, const char *catalog,\n-                                                   const char *schema, const char *table,\n-                                                   duckdb_appender *out_appender);\n+DUCKDB_C_API duckdb_state duckdb_appender_create_ext(duckdb_connection connection, const char *catalog,\n+                                                     const char *schema, const char *table,\n+                                                     duckdb_appender *out_appender);\n \n /*!\n Returns the number of columns that belong to the appender.\n@@ -3838,7 +3847,7 @@ If there is no active column list, then this equals the table's physical columns\n * @param appender The appender to get the column count from.\n * @return The number of columns in the data chunks.\n */\n-DUCKDB_API idx_t duckdb_appender_column_count(duckdb_appender appender);\n+DUCKDB_C_API idx_t duckdb_appender_column_count(duckdb_appender appender);\n \n /*!\n Returns the type of the column at the specified index. This is either a type in the active column list, or the same type\n@@ -3850,7 +3859,7 @@ Note: The resulting type must be destroyed with `duckdb_destroy_logical_type`.\n * @param col_idx The index of the column to get the type of.\n * @return The `duckdb_logical_type` of the column.\n */\n-DUCKDB_API duckdb_logical_type duckdb_appender_column_type(duckdb_appender appender, idx_t col_idx);\n+DUCKDB_C_API duckdb_logical_type duckdb_appender_column_type(duckdb_appender appender, idx_t col_idx);\n \n /*!\n Returns the error message associated with the given appender.\n@@ -3861,7 +3870,7 @@ The error message should not be freed. It will be de-allocated when `duckdb_appe\n * @param appender The appender to get the error from.\n * @return The error message, or `nullptr` if there is none.\n */\n-DUCKDB_API const char *duckdb_appender_error(duckdb_appender appender);\n+DUCKDB_C_API const char *duckdb_appender_error(duckdb_appender appender);\n \n /*!\n Flush the appender to the table, forcing the cache of the appender to be cleared. If flushing the data triggers a\n@@ -3872,7 +3881,7 @@ duckdb_appender_destroy to destroy the invalidated appender.\n * @param appender The appender to flush.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_appender_flush(duckdb_appender appender);\n+DUCKDB_C_API duckdb_state duckdb_appender_flush(duckdb_appender appender);\n \n /*!\n Closes the appender by flushing all intermediate states and closing it for further appends. If flushing the data\n@@ -3883,7 +3892,7 @@ appender.\n * @param appender The appender to flush and close.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_appender_close(duckdb_appender appender);\n+DUCKDB_C_API duckdb_state duckdb_appender_close(duckdb_appender appender);\n \n /*!\n Closes the appender by flushing all intermediate states to the table and destroying it. By destroying it, this function\n@@ -3895,7 +3904,7 @@ before destroying the appender, if you need insights into the specific error.\n * @param appender The appender to flush, close and destroy.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_appender_destroy(duckdb_appender *appender);\n+DUCKDB_C_API duckdb_state duckdb_appender_destroy(duckdb_appender *appender);\n \n /*!\n Appends a column to the active column list of the appender. Immediately flushes all previous data.\n@@ -3906,7 +3915,7 @@ with their default values, or NULL.\n * @param appender The appender to add the column to.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_appender_add_column(duckdb_appender appender, const char *name);\n+DUCKDB_C_API duckdb_state duckdb_appender_add_column(duckdb_appender appender, const char *name);\n \n /*!\n Removes all columns from the active column list of the appender, resetting the appender to treat all columns as active.\n@@ -3915,12 +3924,12 @@ Immediately flushes all previous data.\n * @param appender The appender to clear the columns from.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_appender_clear_columns(duckdb_appender appender);\n+DUCKDB_C_API duckdb_state duckdb_appender_clear_columns(duckdb_appender appender);\n \n /*!\n A nop function, provided for backwards compatibility reasons. Does nothing. Only `duckdb_appender_end_row` is required.\n */\n-DUCKDB_API duckdb_state duckdb_appender_begin_row(duckdb_appender appender);\n+DUCKDB_C_API duckdb_state duckdb_appender_begin_row(duckdb_appender appender);\n \n /*!\n Finish the current row of appends. After end_row is called, the next row can be appended.\n@@ -3928,12 +3937,12 @@ Finish the current row of appends. After end_row is called, the next row can be\n * @param appender The appender.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_appender_end_row(duckdb_appender appender);\n+DUCKDB_C_API duckdb_state duckdb_appender_end_row(duckdb_appender appender);\n \n /*!\n Append a DEFAULT value (NULL if DEFAULT not available for column) to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_default(duckdb_appender appender);\n+DUCKDB_C_API duckdb_state duckdb_append_default(duckdb_appender appender);\n \n /*!\n Append a DEFAULT value, at the specified row and column, (NULL if DEFAULT not available for column) to the chunk created\n@@ -3946,118 +3955,118 @@ like nextval('seq') or random() are not supported.\n * @param row The chunk row index to append the default value to.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_append_default_to_chunk(duckdb_appender appender, duckdb_data_chunk chunk, idx_t col,\n-                                                       idx_t row);\n+DUCKDB_C_API duckdb_state duckdb_append_default_to_chunk(duckdb_appender appender, duckdb_data_chunk chunk, idx_t col,\n+                                                         idx_t row);\n \n /*!\n Append a bool value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_bool(duckdb_appender appender, bool value);\n+DUCKDB_C_API duckdb_state duckdb_append_bool(duckdb_appender appender, bool value);\n \n /*!\n Append an int8_t value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_int8(duckdb_appender appender, int8_t value);\n+DUCKDB_C_API duckdb_state duckdb_append_int8(duckdb_appender appender, int8_t value);\n \n /*!\n Append an int16_t value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_int16(duckdb_appender appender, int16_t value);\n+DUCKDB_C_API duckdb_state duckdb_append_int16(duckdb_appender appender, int16_t value);\n \n /*!\n Append an int32_t value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_int32(duckdb_appender appender, int32_t value);\n+DUCKDB_C_API duckdb_state duckdb_append_int32(duckdb_appender appender, int32_t value);\n \n /*!\n Append an int64_t value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_int64(duckdb_appender appender, int64_t value);\n+DUCKDB_C_API duckdb_state duckdb_append_int64(duckdb_appender appender, int64_t value);\n \n /*!\n Append a duckdb_hugeint value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_hugeint(duckdb_appender appender, duckdb_hugeint value);\n+DUCKDB_C_API duckdb_state duckdb_append_hugeint(duckdb_appender appender, duckdb_hugeint value);\n \n /*!\n Append a uint8_t value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_uint8(duckdb_appender appender, uint8_t value);\n+DUCKDB_C_API duckdb_state duckdb_append_uint8(duckdb_appender appender, uint8_t value);\n \n /*!\n Append a uint16_t value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_uint16(duckdb_appender appender, uint16_t value);\n+DUCKDB_C_API duckdb_state duckdb_append_uint16(duckdb_appender appender, uint16_t value);\n \n /*!\n Append a uint32_t value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_uint32(duckdb_appender appender, uint32_t value);\n+DUCKDB_C_API duckdb_state duckdb_append_uint32(duckdb_appender appender, uint32_t value);\n \n /*!\n Append a uint64_t value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t value);\n+DUCKDB_C_API duckdb_state duckdb_append_uint64(duckdb_appender appender, uint64_t value);\n \n /*!\n Append a duckdb_uhugeint value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_uhugeint(duckdb_appender appender, duckdb_uhugeint value);\n+DUCKDB_C_API duckdb_state duckdb_append_uhugeint(duckdb_appender appender, duckdb_uhugeint value);\n \n /*!\n Append a float value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_float(duckdb_appender appender, float value);\n+DUCKDB_C_API duckdb_state duckdb_append_float(duckdb_appender appender, float value);\n \n /*!\n Append a double value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_double(duckdb_appender appender, double value);\n+DUCKDB_C_API duckdb_state duckdb_append_double(duckdb_appender appender, double value);\n \n /*!\n Append a duckdb_date value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_date(duckdb_appender appender, duckdb_date value);\n+DUCKDB_C_API duckdb_state duckdb_append_date(duckdb_appender appender, duckdb_date value);\n \n /*!\n Append a duckdb_time value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_time(duckdb_appender appender, duckdb_time value);\n+DUCKDB_C_API duckdb_state duckdb_append_time(duckdb_appender appender, duckdb_time value);\n \n /*!\n Append a duckdb_timestamp value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_timestamp(duckdb_appender appender, duckdb_timestamp value);\n+DUCKDB_C_API duckdb_state duckdb_append_timestamp(duckdb_appender appender, duckdb_timestamp value);\n \n /*!\n Append a duckdb_interval value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_interval(duckdb_appender appender, duckdb_interval value);\n+DUCKDB_C_API duckdb_state duckdb_append_interval(duckdb_appender appender, duckdb_interval value);\n \n /*!\n Append a varchar value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val);\n+DUCKDB_C_API duckdb_state duckdb_append_varchar(duckdb_appender appender, const char *val);\n \n /*!\n Append a varchar value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length);\n+DUCKDB_C_API duckdb_state duckdb_append_varchar_length(duckdb_appender appender, const char *val, idx_t length);\n \n /*!\n Append a blob value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length);\n+DUCKDB_C_API duckdb_state duckdb_append_blob(duckdb_appender appender, const void *data, idx_t length);\n \n /*!\n Append a NULL value to the appender (of any type).\n */\n-DUCKDB_API duckdb_state duckdb_append_null(duckdb_appender appender);\n+DUCKDB_C_API duckdb_state duckdb_append_null(duckdb_appender appender);\n \n /*!\n Append a duckdb_value to the appender.\n */\n-DUCKDB_API duckdb_state duckdb_append_value(duckdb_appender appender, duckdb_value value);\n+DUCKDB_C_API duckdb_state duckdb_append_value(duckdb_appender appender, duckdb_value value);\n \n /*!\n Appends a pre-filled data chunk to the specified appender.\n@@ -4067,7 +4076,7 @@ Appends a pre-filled data chunk to the specified appender.\n * @param chunk The data chunk to append.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_append_data_chunk(duckdb_appender appender, duckdb_data_chunk chunk);\n+DUCKDB_C_API duckdb_state duckdb_append_data_chunk(duckdb_appender appender, duckdb_data_chunk chunk);\n \n //===--------------------------------------------------------------------===//\n // Table Description\n@@ -4083,8 +4092,8 @@ resulting table_description, even if the function returns `DuckDBError`.\n * @param out The resulting table description object.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_table_description_create(duckdb_connection connection, const char *schema,\n-                                                        const char *table, duckdb_table_description *out);\n+DUCKDB_C_API duckdb_state duckdb_table_description_create(duckdb_connection connection, const char *schema,\n+                                                          const char *table, duckdb_table_description *out);\n \n /*!\n Creates a table description object. Note that `duckdb_table_description_destroy` must be called on the resulting\n@@ -4097,16 +4106,16 @@ table_description, even if the function returns `DuckDBError`.\n * @param out The resulting table description object.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_table_description_create_ext(duckdb_connection connection, const char *catalog,\n-                                                            const char *schema, const char *table,\n-                                                            duckdb_table_description *out);\n+DUCKDB_C_API duckdb_state duckdb_table_description_create_ext(duckdb_connection connection, const char *catalog,\n+                                                              const char *schema, const char *table,\n+                                                              duckdb_table_description *out);\n \n /*!\n Destroy the TableDescription object.\n \n * @param table_description The table_description to destroy.\n */\n-DUCKDB_API void duckdb_table_description_destroy(duckdb_table_description *table_description);\n+DUCKDB_C_API void duckdb_table_description_destroy(duckdb_table_description *table_description);\n \n /*!\n Returns the error message associated with the given table_description.\n@@ -4116,7 +4125,7 @@ The error message should not be freed. It will be de-allocated when `duckdb_tabl\n * @param table_description The table_description to get the error from.\n * @return The error message, or `nullptr` if there is none.\n */\n-DUCKDB_API const char *duckdb_table_description_error(duckdb_table_description table_description);\n+DUCKDB_C_API const char *duckdb_table_description_error(duckdb_table_description table_description);\n \n /*!\n Check if the column at 'index' index of the table has a DEFAULT expression.\n@@ -4126,7 +4135,7 @@ Check if the column at 'index' index of the table has a DEFAULT expression.\n * @param out The out-parameter used to store the result.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_column_has_default(duckdb_table_description table_description, idx_t index, bool *out);\n+DUCKDB_C_API duckdb_state duckdb_column_has_default(duckdb_table_description table_description, idx_t index, bool *out);\n \n /*!\n Obtain the column name at 'index'.\n@@ -4136,7 +4145,7 @@ The out result must be destroyed with `duckdb_free`.\n * @param index The index of the column to query.\n * @return The column name.\n */\n-DUCKDB_API char *duckdb_table_description_get_column_name(duckdb_table_description table_description, idx_t index);\n+DUCKDB_C_API char *duckdb_table_description_get_column_name(duckdb_table_description table_description, idx_t index);\n \n //===--------------------------------------------------------------------===//\n // Arrow Interface\n@@ -4158,7 +4167,7 @@ query fails, otherwise the error stored within the result will not be freed corr\n * @param out_result The query result.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result);\n+DUCKDB_C_API duckdb_state duckdb_query_arrow(duckdb_connection connection, const char *query, duckdb_arrow *out_result);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n@@ -4170,7 +4179,7 @@ ArrowSchema object.\n * @param out_schema The output schema.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema);\n+DUCKDB_C_API duckdb_state duckdb_query_arrow_schema(duckdb_arrow result, duckdb_arrow_schema *out_schema);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n@@ -4182,8 +4191,8 @@ ArrowSchema object.\n * @param out_schema The output schema.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_prepared_arrow_schema(duckdb_prepared_statement prepared,\n-                                                     duckdb_arrow_schema *out_schema);\n+DUCKDB_C_API duckdb_state duckdb_prepared_arrow_schema(duckdb_prepared_statement prepared,\n+                                                       duckdb_arrow_schema *out_schema);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n@@ -4195,7 +4204,8 @@ ArrowArray object.\n * @param chunk The data chunk to convert.\n * @param out_array The output array.\n */\n-DUCKDB_API void duckdb_result_arrow_array(duckdb_result result, duckdb_data_chunk chunk, duckdb_arrow_array *out_array);\n+DUCKDB_C_API void duckdb_result_arrow_array(duckdb_result result, duckdb_data_chunk chunk,\n+                                            duckdb_arrow_array *out_array);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n@@ -4210,7 +4220,7 @@ So consume the out_array before calling this function again.\n * @param out_array The output array.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array);\n+DUCKDB_C_API duckdb_state duckdb_query_arrow_array(duckdb_arrow result, duckdb_arrow_array *out_array);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n@@ -4220,7 +4230,7 @@ Returns the number of columns present in the arrow result object.\n * @param result The result object.\n * @return The number of columns present in the result object.\n */\n-DUCKDB_API idx_t duckdb_arrow_column_count(duckdb_arrow result);\n+DUCKDB_C_API idx_t duckdb_arrow_column_count(duckdb_arrow result);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n@@ -4230,7 +4240,7 @@ Returns the number of rows present in the arrow result object.\n * @param result The result object.\n * @return The number of rows present in the result object.\n */\n-DUCKDB_API idx_t duckdb_arrow_row_count(duckdb_arrow result);\n+DUCKDB_C_API idx_t duckdb_arrow_row_count(duckdb_arrow result);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n@@ -4241,7 +4251,7 @@ INSERT/UPDATE/DELETE queries. For other queries the rows_changed will be 0.\n * @param result The result object.\n * @return The number of rows changed.\n */\n-DUCKDB_API idx_t duckdb_arrow_rows_changed(duckdb_arrow result);\n+DUCKDB_C_API idx_t duckdb_arrow_rows_changed(duckdb_arrow result);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n@@ -4254,7 +4264,7 @@ The error message should not be freed. It will be de-allocated when `duckdb_dest\n * @param result The result object to fetch the error from.\n * @return The error of the result.\n */\n-DUCKDB_API const char *duckdb_query_arrow_error(duckdb_arrow result);\n+DUCKDB_C_API const char *duckdb_query_arrow_error(duckdb_arrow result);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n@@ -4263,7 +4273,7 @@ Closes the result and de-allocates all memory allocated for the arrow result.\n \n * @param result The result to destroy.\n */\n-DUCKDB_API void duckdb_destroy_arrow(duckdb_arrow *result);\n+DUCKDB_C_API void duckdb_destroy_arrow(duckdb_arrow *result);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n@@ -4272,7 +4282,7 @@ Releases the arrow array stream and de-allocates its memory.\n \n * @param stream_p The arrow array stream to destroy.\n */\n-DUCKDB_API void duckdb_destroy_arrow_stream(duckdb_arrow_stream *stream_p);\n+DUCKDB_C_API void duckdb_destroy_arrow_stream(duckdb_arrow_stream *stream_p);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n@@ -4284,8 +4294,8 @@ Note that after running `duckdb_execute_prepared_arrow`, `duckdb_destroy_arrow`\n * @param out_result The query result.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement,\n-                                                      duckdb_arrow *out_result);\n+DUCKDB_C_API duckdb_state duckdb_execute_prepared_arrow(duckdb_prepared_statement prepared_statement,\n+                                                        duckdb_arrow *out_result);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n@@ -4297,8 +4307,8 @@ Scans the Arrow stream and creates a view with the given name.\n * @param arrow Arrow stream wrapper.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_arrow_scan(duckdb_connection connection, const char *table_name,\n-                                          duckdb_arrow_stream arrow);\n+DUCKDB_C_API duckdb_state duckdb_arrow_scan(duckdb_connection connection, const char *table_name,\n+                                            duckdb_arrow_stream arrow);\n \n /*!\n **DEPRECATION NOTICE**: This method is scheduled for removal in a future release.\n@@ -4313,9 +4323,9 @@ Note that after running `duckdb_arrow_array_scan`, `duckdb_destroy_arrow_stream`\n * @param out_stream Output array stream that wraps around the passed schema, for releasing/deleting once done.\n * @return `DuckDBSuccess` on success or `DuckDBError` on failure.\n */\n-DUCKDB_API duckdb_state duckdb_arrow_array_scan(duckdb_connection connection, const char *table_name,\n-                                                duckdb_arrow_schema arrow_schema, duckdb_arrow_array arrow_array,\n-                                                duckdb_arrow_stream *out_stream);\n+DUCKDB_C_API duckdb_state duckdb_arrow_array_scan(duckdb_connection connection, const char *table_name,\n+                                                  duckdb_arrow_schema arrow_schema, duckdb_arrow_array arrow_array,\n+                                                  duckdb_arrow_stream *out_stream);\n \n #endif\n //===--------------------------------------------------------------------===//\n@@ -4330,7 +4340,7 @@ Will return after `max_tasks` have been executed, or if there are no more tasks\n * @param database The database object to execute tasks for\n * @param max_tasks The maximum amount of tasks to execute\n */\n-DUCKDB_API void duckdb_execute_tasks(duckdb_database database, idx_t max_tasks);\n+DUCKDB_C_API void duckdb_execute_tasks(duckdb_database database, idx_t max_tasks);\n \n /*!\n Creates a task state that can be used with duckdb_execute_tasks_state to execute tasks until\n@@ -4341,7 +4351,7 @@ Creates a task state that can be used with duckdb_execute_tasks_state to execute\n * @param database The database object to create the task state for\n * @return The task state that can be used with duckdb_execute_tasks_state.\n */\n-DUCKDB_API duckdb_task_state duckdb_create_task_state(duckdb_database database);\n+DUCKDB_C_API duckdb_task_state duckdb_create_task_state(duckdb_database database);\n \n /*!\n Execute DuckDB tasks on this thread.\n@@ -4351,7 +4361,7 @@ Multiple threads can share the same duckdb_task_state.\n \n * @param state The task state of the executor\n */\n-DUCKDB_API void duckdb_execute_tasks_state(duckdb_task_state state);\n+DUCKDB_C_API void duckdb_execute_tasks_state(duckdb_task_state state);\n \n /*!\n Execute DuckDB tasks on this thread.\n@@ -4365,14 +4375,14 @@ Multiple threads can share the same duckdb_task_state.\n * @param max_tasks The maximum amount of tasks to execute\n * @return The amount of tasks that have actually been executed\n */\n-DUCKDB_API idx_t duckdb_execute_n_tasks_state(duckdb_task_state state, idx_t max_tasks);\n+DUCKDB_C_API idx_t duckdb_execute_n_tasks_state(duckdb_task_state state, idx_t max_tasks);\n \n /*!\n Finish execution on a specific task.\n \n * @param state The task state to finish execution\n */\n-DUCKDB_API void duckdb_finish_execution(duckdb_task_state state);\n+DUCKDB_C_API void duckdb_finish_execution(duckdb_task_state state);\n \n /*!\n Check if the provided duckdb_task_state has finished execution\n@@ -4380,7 +4390,7 @@ Check if the provided duckdb_task_state has finished execution\n * @param state The task state to inspect\n * @return Whether or not duckdb_finish_execution has been called on the task state\n */\n-DUCKDB_API bool duckdb_task_state_is_finished(duckdb_task_state state);\n+DUCKDB_C_API bool duckdb_task_state_is_finished(duckdb_task_state state);\n \n /*!\n Destroys the task state returned from duckdb_create_task_state.\n@@ -4390,14 +4400,14 @@ on the task state.\n \n * @param state The task state to clean up\n */\n-DUCKDB_API void duckdb_destroy_task_state(duckdb_task_state state);\n+DUCKDB_C_API void duckdb_destroy_task_state(duckdb_task_state state);\n \n /*!\n Returns true if the execution of the current query is finished.\n \n * @param con The connection on which to check\n */\n-DUCKDB_API bool duckdb_execution_is_finished(duckdb_connection con);\n+DUCKDB_C_API bool duckdb_execution_is_finished(duckdb_connection con);\n \n //===--------------------------------------------------------------------===//\n // Streaming Result Interface\n@@ -4422,7 +4432,7 @@ It is not known beforehand how many chunks will be returned by this result.\n * @param result The result object to fetch the data chunk from.\n * @return The resulting data chunk. Returns `NULL` if the result has an error.\n */\n-DUCKDB_API duckdb_data_chunk duckdb_stream_fetch_chunk(duckdb_result result);\n+DUCKDB_C_API duckdb_data_chunk duckdb_stream_fetch_chunk(duckdb_result result);\n \n #endif\n /*!\n@@ -4435,7 +4445,7 @@ It is not known beforehand how many chunks will be returned by this result.\n * @param result The result object to fetch the data chunk from.\n * @return The resulting data chunk. Returns `NULL` if the result has an error.\n */\n-DUCKDB_API duckdb_data_chunk duckdb_fetch_chunk(duckdb_result result);\n+DUCKDB_C_API duckdb_data_chunk duckdb_fetch_chunk(duckdb_result result);\n \n //===--------------------------------------------------------------------===//\n // Cast Functions\n@@ -4446,7 +4456,7 @@ Creates a new cast function object.\n \n * @return The cast function object.\n */\n-DUCKDB_API duckdb_cast_function duckdb_create_cast_function();\n+DUCKDB_C_API duckdb_cast_function duckdb_create_cast_function();\n \n /*!\n Sets the source type of the cast function.\n@@ -4454,8 +4464,8 @@ Sets the source type of the cast function.\n * @param cast_function The cast function object.\n * @param source_type The source type to set.\n */\n-DUCKDB_API void duckdb_cast_function_set_source_type(duckdb_cast_function cast_function,\n-                                                     duckdb_logical_type source_type);\n+DUCKDB_C_API void duckdb_cast_function_set_source_type(duckdb_cast_function cast_function,\n+                                                       duckdb_logical_type source_type);\n \n /*!\n Sets the target type of the cast function.\n@@ -4463,8 +4473,8 @@ Sets the target type of the cast function.\n * @param cast_function The cast function object.\n * @param target_type The target type to set.\n */\n-DUCKDB_API void duckdb_cast_function_set_target_type(duckdb_cast_function cast_function,\n-                                                     duckdb_logical_type target_type);\n+DUCKDB_C_API void duckdb_cast_function_set_target_type(duckdb_cast_function cast_function,\n+                                                       duckdb_logical_type target_type);\n \n /*!\n Sets the \"cost\" of implicitly casting the source type to the target type using this function.\n@@ -4472,7 +4482,7 @@ Sets the \"cost\" of implicitly casting the source type to the target type using t\n * @param cast_function The cast function object.\n * @param cost The cost to set.\n */\n-DUCKDB_API void duckdb_cast_function_set_implicit_cast_cost(duckdb_cast_function cast_function, int64_t cost);\n+DUCKDB_C_API void duckdb_cast_function_set_implicit_cast_cost(duckdb_cast_function cast_function, int64_t cost);\n \n /*!\n Sets the actual cast function to use.\n@@ -4480,7 +4490,8 @@ Sets the actual cast function to use.\n * @param cast_function The cast function object.\n * @param function The function to set.\n */\n-DUCKDB_API void duckdb_cast_function_set_function(duckdb_cast_function cast_function, duckdb_cast_function_t function);\n+DUCKDB_C_API void duckdb_cast_function_set_function(duckdb_cast_function cast_function,\n+                                                    duckdb_cast_function_t function);\n \n /*!\n Assigns extra information to the cast function that can be fetched during execution, etc.\n@@ -4488,8 +4499,8 @@ Assigns extra information to the cast function that can be fetched during execut\n * @param extra_info The extra information\n * @param destroy The callback that will be called to destroy the extra information (if any)\n */\n-DUCKDB_API void duckdb_cast_function_set_extra_info(duckdb_cast_function cast_function, void *extra_info,\n-                                                    duckdb_delete_callback_t destroy);\n+DUCKDB_C_API void duckdb_cast_function_set_extra_info(duckdb_cast_function cast_function, void *extra_info,\n+                                                      duckdb_delete_callback_t destroy);\n \n /*!\n Retrieves the extra info of the function as set in `duckdb_cast_function_set_extra_info`.\n@@ -4497,7 +4508,7 @@ Retrieves the extra info of the function as set in `duckdb_cast_function_set_ext\n * @param info The info object.\n * @return The extra info.\n */\n-DUCKDB_API void *duckdb_cast_function_get_extra_info(duckdb_function_info info);\n+DUCKDB_C_API void *duckdb_cast_function_get_extra_info(duckdb_function_info info);\n \n /*!\n Get the cast execution mode from the given function info.\n@@ -4505,7 +4516,7 @@ Get the cast execution mode from the given function info.\n * @param info The info object.\n * @return The cast mode.\n */\n-DUCKDB_API duckdb_cast_mode duckdb_cast_function_get_cast_mode(duckdb_function_info info);\n+DUCKDB_C_API duckdb_cast_mode duckdb_cast_function_get_cast_mode(duckdb_function_info info);\n \n /*!\n Report that an error has occurred while executing the cast function.\n@@ -4513,7 +4524,7 @@ Report that an error has occurred while executing the cast function.\n * @param info The info object.\n * @param error The error message.\n */\n-DUCKDB_API void duckdb_cast_function_set_error(duckdb_function_info info, const char *error);\n+DUCKDB_C_API void duckdb_cast_function_set_error(duckdb_function_info info, const char *error);\n \n /*!\n Report that an error has occurred while executing the cast function, setting the corresponding output row to NULL.\n@@ -4523,8 +4534,8 @@ Report that an error has occurred while executing the cast function, setting the\n * @param row The index of the row within the output vector to set to NULL.\n * @param output The output vector.\n */\n-DUCKDB_API void duckdb_cast_function_set_row_error(duckdb_function_info info, const char *error, idx_t row,\n-                                                   duckdb_vector output);\n+DUCKDB_C_API void duckdb_cast_function_set_row_error(duckdb_function_info info, const char *error, idx_t row,\n+                                                     duckdb_vector output);\n \n /*!\n Registers a cast function within the given connection.\n@@ -4533,14 +4544,14 @@ Registers a cast function within the given connection.\n * @param cast_function The cast function to register.\n * @return Whether or not the registration was successful.\n */\n-DUCKDB_API duckdb_state duckdb_register_cast_function(duckdb_connection con, duckdb_cast_function cast_function);\n+DUCKDB_C_API duckdb_state duckdb_register_cast_function(duckdb_connection con, duckdb_cast_function cast_function);\n \n /*!\n Destroys the cast function object.\n \n * @param cast_function The cast function object.\n */\n-DUCKDB_API void duckdb_destroy_cast_function(duckdb_cast_function *cast_function);\n+DUCKDB_C_API void duckdb_destroy_cast_function(duckdb_cast_function *cast_function);\n \n #endif\n \ndiff --git a/src/include/duckdb/common/adbc/adbc-init.hpp b/src/include/duckdb/common/adbc/adbc-init.hpp\nindex 8a5ce110a827..c5c3a127cda2 100644\n--- a/src/include/duckdb/common/adbc/adbc-init.hpp\n+++ b/src/include/duckdb/common/adbc/adbc-init.hpp\n@@ -30,7 +30,7 @@ extern \"C\" {\n typedef uint8_t AdbcStatusCode;\n \n //! We gotta leak the symbols of the init function\n-DUCKDB_API AdbcStatusCode duckdb_adbc_init(int version, void *driver, struct AdbcError *error);\n+DUCKDB_C_API AdbcStatusCode duckdb_adbc_init(int version, void *driver, struct AdbcError *error);\n \n #ifdef __cplusplus\n }\ndiff --git a/src/include/duckdb/function/lambda_functions.hpp b/src/include/duckdb/function/lambda_functions.hpp\nindex a47894a39a55..802d96c5e03b 100644\n--- a/src/include/duckdb/function/lambda_functions.hpp\n+++ b/src/include/duckdb/function/lambda_functions.hpp\n@@ -17,7 +17,7 @@\n \n namespace duckdb {\n \n-struct ListLambdaBindData : public FunctionData {\n+struct ListLambdaBindData final : public FunctionData {\n public:\n \tListLambdaBindData(const LogicalType &return_type, unique_ptr<Expression> lambda_expr, const bool has_index = false)\n \t    : return_type(return_type), lambda_expr(std::move(lambda_expr)), has_index(has_index) {};\n@@ -30,8 +30,16 @@ struct ListLambdaBindData : public FunctionData {\n \tbool has_index;\n \n public:\n-\tbool Equals(const FunctionData &other_p) const override;\n-\tunique_ptr<FunctionData> Copy() const override;\n+\tunique_ptr<FunctionData> Copy() const override {\n+\t\tauto lambda_expr_copy = lambda_expr ? lambda_expr->Copy() : nullptr;\n+\t\treturn make_uniq<ListLambdaBindData>(return_type, std::move(lambda_expr_copy), has_index);\n+\t}\n+\n+\tbool Equals(const FunctionData &other_p) const override {\n+\t\tauto &other = other_p.Cast<ListLambdaBindData>();\n+\t\treturn Expression::Equals(lambda_expr, other.lambda_expr) && return_type == other.return_type &&\n+\t\t       has_index == other.has_index;\n+\t}\n \n \t//! Serializes a lambda function's bind data\n \tstatic void Serialize(Serializer &serializer, const optional_ptr<FunctionData> bind_data_p,\ndiff --git a/src/include/duckdb/main/capi/header_generation/header_base.hpp.template b/src/include/duckdb/main/capi/header_generation/header_base.hpp.template\nindex 042a0d2357b9..d9879eaa1fbe 100644\n--- a/src/include/duckdb/main/capi/header_generation/header_base.hpp.template\n+++ b/src/include/duckdb/main/capi/header_generation/header_base.hpp.template\n@@ -7,20 +7,19 @@\n \n #pragma once\n \n-//! duplicate of duckdb/main/winapi.hpp\n-#ifndef DUCKDB_API\n+#ifndef DUCKDB_C_API\n #ifdef _WIN32\n #ifdef DUCKDB_STATIC_BUILD\n-#define DUCKDB_API\n+#define DUCKDB_C_API\n #else\n #if defined(DUCKDB_BUILD_LIBRARY) && !defined(DUCKDB_BUILD_LOADABLE_EXTENSION)\n-#define DUCKDB_API __declspec(dllexport)\n+#define DUCKDB_C_API __declspec(dllexport)\n #else\n-#define DUCKDB_API __declspec(dllimport)\n+#define DUCKDB_C_API __declspec(dllimport)\n #endif\n #endif\n #else\n-#define DUCKDB_API\n+#define DUCKDB_C_API\n #endif\n #endif\n \ndiff --git a/src/include/duckdb/main/extension_entries.hpp b/src/include/duckdb/main/extension_entries.hpp\nindex 40d3429c529b..1e6ab3f90acb 100644\n--- a/src/include/duckdb/main/extension_entries.hpp\n+++ b/src/include/duckdb/main/extension_entries.hpp\n@@ -651,13 +651,15 @@ static constexpr ExtensionFunctionEntry EXTENSION_FUNCTIONS[] = {\n     {\"st_zmax\", \"spatial\", CatalogType::SCALAR_FUNCTION_ENTRY},\n     {\"st_zmflag\", \"spatial\", CatalogType::SCALAR_FUNCTION_ENTRY},\n     {\"st_zmin\", \"spatial\", CatalogType::SCALAR_FUNCTION_ENTRY},\n-    {\"start_ui\", \"motherduck\", CatalogType::TABLE_FUNCTION_ENTRY},\n+    {\"start_ui\", \"ui\", CatalogType::TABLE_FUNCTION_ENTRY},\n+    {\"start_ui_server\", \"ui\", CatalogType::TABLE_FUNCTION_ENTRY},\n     {\"starts_with\", \"core_functions\", CatalogType::SCALAR_FUNCTION_ENTRY},\n     {\"stats\", \"core_functions\", CatalogType::SCALAR_FUNCTION_ENTRY},\n     {\"stddev\", \"core_functions\", CatalogType::AGGREGATE_FUNCTION_ENTRY},\n     {\"stddev_pop\", \"core_functions\", CatalogType::AGGREGATE_FUNCTION_ENTRY},\n     {\"stddev_samp\", \"core_functions\", CatalogType::AGGREGATE_FUNCTION_ENTRY},\n     {\"stem\", \"fts\", CatalogType::SCALAR_FUNCTION_ENTRY},\n+    {\"stop_ui_server\", \"ui\", CatalogType::TABLE_FUNCTION_ENTRY},\n     {\"string_agg\", \"core_functions\", CatalogType::AGGREGATE_FUNCTION_ENTRY},\n     {\"strpos\", \"core_functions\", CatalogType::SCALAR_FUNCTION_ENTRY},\n     {\"struct_insert\", \"core_functions\", CatalogType::SCALAR_FUNCTION_ENTRY},\n@@ -701,6 +703,7 @@ static constexpr ExtensionFunctionEntry EXTENSION_FUNCTIONS[] = {\n     {\"trunc\", \"core_functions\", CatalogType::SCALAR_FUNCTION_ENTRY},\n     {\"txid_current\", \"core_functions\", CatalogType::SCALAR_FUNCTION_ENTRY},\n     {\"typeof\", \"core_functions\", CatalogType::SCALAR_FUNCTION_ENTRY},\n+    {\"ui_is_started\", \"ui\", CatalogType::TABLE_FUNCTION_ENTRY},\n     {\"unbin\", \"core_functions\", CatalogType::SCALAR_FUNCTION_ENTRY},\n     {\"unhex\", \"core_functions\", CatalogType::SCALAR_FUNCTION_ENTRY},\n     {\"unicode\", \"core_functions\", CatalogType::SCALAR_FUNCTION_ENTRY},\n@@ -989,6 +992,9 @@ static constexpr ExtensionEntry EXTENSION_SETTINGS[] = {\n     {\"sqlite_all_varchar\", \"sqlite_scanner\"},\n     {\"sqlite_debug_show_queries\", \"sqlite_scanner\"},\n     {\"timezone\", \"icu\"},\n+    {\"ui_local_port\", \"ui\"},\n+    {\"ui_polling_interval\", \"ui\"},\n+    {\"ui_remote_url\", \"ui\"},\n     {\"unsafe_enable_version_guessing\", \"iceberg\"},\n }; // END_OF_EXTENSION_SETTINGS\n \n@@ -1076,10 +1082,16 @@ static constexpr ExtensionEntry EXTENSION_SECRET_PROVIDERS[] = {\n     {\"mysql/config\", \"mysql_scanner\"},\n     {\"postgres/config\", \"postgres_scanner\"}}; // EXTENSION_SECRET_PROVIDERS\n \n-static constexpr const char *AUTOLOADABLE_EXTENSIONS[] = {\n-    \"aws\",        \"azure\",         \"autocomplete\", \"core_functions\", \"delta\",    \"excel\",\n-    \"fts\",        \"httpfs\",        \"iceberg\",      \"inet\",           \"icu\",      \"json\",\n-    \"motherduck\", \"mysql_scanner\", \"parquet\",      \"sqlite_scanner\", \"sqlsmith\", \"postgres_scanner\",\n-    \"tpcds\",      \"tpch\",          \"uc_catalog\"}; // END_OF_AUTOLOADABLE_EXTENSIONS\n+static constexpr const char *AUTOLOADABLE_EXTENSIONS[] = {\"aws\",          \"azure\",\n+                                                          \"autocomplete\", \"core_functions\",\n+                                                          \"delta\",        \"excel\",\n+                                                          \"fts\",          \"httpfs\",\n+                                                          \"iceberg\",      \"inet\",\n+                                                          \"icu\",          \"json\",\n+                                                          \"motherduck\",   \"mysql_scanner\",\n+                                                          \"parquet\",      \"sqlite_scanner\",\n+                                                          \"sqlsmith\",     \"postgres_scanner\",\n+                                                          \"tpcds\",        \"tpch\",\n+                                                          \"uc_catalog\",   \"ui\"}; // END_OF_AUTOLOADABLE_EXTENSIONS\n \n } // namespace duckdb\ndiff --git a/src/include/duckdb/planner/expression/bound_subquery_expression.hpp b/src/include/duckdb/planner/expression/bound_subquery_expression.hpp\nindex 31501dd8cfd0..aa07a67b9305 100644\n--- a/src/include/duckdb/planner/expression/bound_subquery_expression.hpp\n+++ b/src/include/duckdb/planner/expression/bound_subquery_expression.hpp\n@@ -40,7 +40,7 @@ class BoundSubqueryExpression : public Expression {\n \tvector<LogicalType> child_types;\n \t//! The target LogicalType of the subquery result (i.e. to which type it should be casted, if child_type <>\n \t//! child_target). Only used for ANY expressions.\n-\tLogicalType child_target;\n+\tvector<LogicalType> child_targets;\n \n public:\n \tbool HasSubquery() const override {\ndiff --git a/src/main/extension/extension_helper.cpp b/src/main/extension/extension_helper.cpp\nindex f42d43aa8571..1088f0f135dd 100644\n--- a/src/main/extension/extension_helper.cpp\n+++ b/src/main/extension/extension_helper.cpp\n@@ -121,6 +121,7 @@ static const DefaultExtension internal_extensions[] = {\n     {\"vss\", \"Adds indexing support to accelerate Vector Similarity Search\", false},\n     {\"delta\", \"Adds support for Delta Lake\", false},\n     {\"fts\", \"Adds support for Full-Text Search Indexes\", false},\n+    {\"ui\", \"Adds local UI for DuckDB\", false},\n     {nullptr, nullptr, false}};\n \n idx_t ExtensionHelper::DefaultExtensionCount() {\n@@ -139,7 +140,8 @@ DefaultExtension ExtensionHelper::GetDefaultExtension(idx_t index) {\n // Allow Auto-Install Extensions\n //===--------------------------------------------------------------------===//\n static const char *const auto_install[] = {\"motherduck\", \"postgres_scanner\", \"mysql_scanner\", \"sqlite_scanner\",\n-                                           \"delta\",      \"iceberg\",          \"uc_catalog\",    nullptr};\n+                                           \"delta\",      \"iceberg\",          \"uc_catalog\",    \"ui\",\n+                                           nullptr};\n \n // TODO: unify with new autoload mechanism\n bool ExtensionHelper::AllowAutoInstall(const string &extension) {\ndiff --git a/src/main/extension/extension_load.cpp b/src/main/extension/extension_load.cpp\nindex 5499665f1a27..6e4bb1879685 100644\n--- a/src/main/extension/extension_load.cpp\n+++ b/src/main/extension/extension_load.cpp\n@@ -123,8 +123,9 @@ struct ExtensionAccess {\n \t\t\tload_state.has_error = true;\n \t\t\tload_state.error_data =\n \t\t\t    ErrorData(ExceptionType::UNKNOWN_TYPE,\n-\t\t\t              StringUtil::Format(\"Unknown ABI Type '%s' found when loading extension '%s'\",\n-\t\t\t                                 load_state.init_result.abi_type, load_state.init_result.filename));\n+\t\t\t              StringUtil::Format(\"Unknown ABI Type of value '%d' found when loading extension '%s'\",\n+\t\t\t                                 static_cast<uint8_t>(load_state.init_result.abi_type),\n+\t\t\t                                 load_state.init_result.filename));\n \t\t\treturn nullptr;\n \t\t}\n \n@@ -588,7 +589,8 @@ void ExtensionHelper::LoadExternalExtension(DatabaseInstance &db, FileSystem &fs\n \t\treturn;\n \t}\n \n-\tthrow IOException(\"Unknown ABI type '%s' for extension '%s'\", extension_init_result.abi_type, extension);\n+\tthrow IOException(\"Unknown ABI type of value '%s' for extension '%s'\",\n+\t                  static_cast<uint8_t>(extension_init_result.abi_type), extension);\n #endif\n }\n \ndiff --git a/src/planner/binder/expression/bind_subquery_expression.cpp b/src/planner/binder/expression/bind_subquery_expression.cpp\nindex 45dc31a3326e..d413c88ed9e8 100644\n--- a/src/planner/binder/expression/bind_subquery_expression.cpp\n+++ b/src/planner/binder/expression/bind_subquery_expression.cpp\n@@ -153,7 +153,7 @@ BindResult ExpressionBinder::BindExpression(SubqueryExpression &expr, idx_t dept\n \t\t\t}\n \t\t\tchild = BoundCastExpression::AddCastToType(context, std::move(child), compare_type);\n \t\t\tresult->child_types.push_back(subquery_type);\n-\t\t\tresult->child_target = compare_type;\n+\t\t\tresult->child_targets.push_back(compare_type);\n \t\t\tresult->children.push_back(std::move(child));\n \t\t}\n \t}\ndiff --git a/src/planner/binder/query_node/plan_subquery.cpp b/src/planner/binder/query_node/plan_subquery.cpp\nindex 1e1c06c1e22e..b938f1f65417 100644\n--- a/src/planner/binder/query_node/plan_subquery.cpp\n+++ b/src/planner/binder/query_node/plan_subquery.cpp\n@@ -168,7 +168,8 @@ static unique_ptr<Expression> PlanUncorrelatedSubquery(Binder &binder, BoundSubq\n \t\t\tcond.left = std::move(expr.children[child_idx]);\n \t\t\tauto &child_type = expr.child_types[child_idx];\n \t\t\tcond.right = BoundCastExpression::AddDefaultCastToType(\n-\t\t\t    make_uniq<BoundColumnRefExpression>(child_type, plan_columns[child_idx]), expr.child_target);\n+\t\t\t    make_uniq<BoundColumnRefExpression>(child_type, plan_columns[child_idx]),\n+\t\t\t    expr.child_targets[child_idx]);\n \t\t\tcond.comparison = expr.comparison_type;\n \t\t\tjoin->conditions.push_back(std::move(cond));\n \t\t}\n@@ -371,7 +372,8 @@ static unique_ptr<Expression> PlanCorrelatedSubquery(Binder &binder, BoundSubque\n \t\t\tcompare_cond.left = std::move(expr.children[child_idx]);\n \t\t\tauto &child_type = expr.child_types[child_idx];\n \t\t\tcompare_cond.right = BoundCastExpression::AddDefaultCastToType(\n-\t\t\t    make_uniq<BoundColumnRefExpression>(child_type, plan_columns[child_idx]), expr.child_target);\n+\t\t\t    make_uniq<BoundColumnRefExpression>(child_type, plan_columns[child_idx]),\n+\t\t\t    expr.child_targets[child_idx]);\n \t\t\tcompare_cond.comparison = expr.comparison_type;\n \t\t\tdelim_join->conditions.push_back(std::move(compare_cond));\n \t\t}\ndiff --git a/src/planner/binder/statement/bind_create.cpp b/src/planner/binder/statement/bind_create.cpp\nindex 9f91922cca5d..67408ca91fc4 100644\n--- a/src/planner/binder/statement/bind_create.cpp\n+++ b/src/planner/binder/statement/bind_create.cpp\n@@ -46,6 +46,7 @@\n namespace duckdb {\n \n void Binder::BindSchemaOrCatalog(ClientContext &context, string &catalog, string &schema) {\n+\tCatalogEntryRetriever retriever(context);\n \tif (catalog.empty() && !schema.empty()) {\n \t\t// schema is specified - but catalog is not\n \t\t// try searching for the catalog instead\n@@ -60,8 +61,12 @@ void Binder::BindSchemaOrCatalog(ClientContext &context, string &catalog, string\n \t\t\t\tcatalog_names.push_back(DatabaseManager::GetDefaultDatabase(context));\n \t\t\t}\n \t\t\tfor (auto &catalog_name : catalog_names) {\n-\t\t\t\tauto &catalog = Catalog::GetCatalog(context, catalog_name);\n-\t\t\t\tif (catalog.CheckAmbiguousCatalogOrSchema(context, schema)) {\n+\t\t\t\tauto catalog = Catalog::GetCatalogEntry(retriever, catalog_name);\n+\t\t\t\tif (!catalog) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tif (catalog->CheckAmbiguousCatalogOrSchema(context, schema)) {\n+\n \t\t\t\t\tthrow BinderException(\n \t\t\t\t\t    \"Ambiguous reference to catalog or schema \\\"%s\\\" - use a fully qualified path like \\\"%s.%s\\\"\",\n \t\t\t\t\t    schema, catalog_name, schema);\ndiff --git a/src/storage/storage_info.cpp b/src/storage/storage_info.cpp\nindex 7083f66aec65..66c609a7073c 100644\n--- a/src/storage/storage_info.cpp\n+++ b/src/storage/storage_info.cpp\n@@ -77,6 +77,7 @@ static const StorageVersionInfo storage_version_info[] = {\n \t{\"v1.1.2\", 64},\n \t{\"v1.1.3\", 64},\n \t{\"v1.2.0\", 65},\n+\t{\"v1.2.1\", 65},\n \t{nullptr, 0}\n };\n // END OF STORAGE VERSION INFO\n@@ -96,6 +97,7 @@ static const SerializationVersionInfo serialization_version_info[] = {\n \t{\"v1.1.2\", 3},\n \t{\"v1.1.3\", 3},\n \t{\"v1.2.0\", 4},\n+\t{\"v1.2.1\", 4},\n \t{\"latest\", 4},\n \t{nullptr, 0}\n };\ndiff --git a/src/storage/version_map.json b/src/storage/version_map.json\nindex e6a73162da40..4a77e7187067 100644\n--- a/src/storage/version_map.json\n+++ b/src/storage/version_map.json\n@@ -49,7 +49,8 @@\n \t\t\"v1.1.1\": 64,\n \t\t\"v1.1.2\": 64,\n \t\t\"v1.1.3\": 64,\n-\t\t\"v1.2.0\": 65\n+\t\t\"v1.2.0\": 65,\n+\t\t\"v1.2.1\": 65\n \t},\n \t\"default\": 64\n },\n@@ -65,6 +66,7 @@\n \t\t\"v1.1.2\": 3,\n \t\t\"v1.1.3\": 3,\n \t\t\"v1.2.0\": 4,\n+\t\t\"v1.2.1\": 4,\n \t\t\"latest\": 4\n \t},\n \t\"default\": 1\ndiff --git a/tools/shell/shell.cpp b/tools/shell/shell.cpp\nindex 7fd3092bbea9..dd782ea65e9c 100644\n--- a/tools/shell/shell.cpp\n+++ b/tools/shell/shell.cpp\n@@ -3234,7 +3234,7 @@ MetadataResult SetColumnRendering(ShellState &state, const char **azArg, idx_t n\n }\n \n MetadataResult SetRowRendering(ShellState &state, const char **azArg, idx_t nArg) {\n-\tstate.columns = 1;\n+\tstate.columns = 0;\n \treturn MetadataResult::SUCCESS;\n }\n \n",
  "test_patch": "diff --git a/test/issues/general/test_16257.test_slow b/test/issues/general/test_16257.test_slow\nindex 6b3faf9a7ba4..df2a3ed75f9c 100644\n--- a/test/issues/general/test_16257.test_slow\n+++ b/test/issues/general/test_16257.test_slow\n@@ -21,5 +21,6 @@ CREATE OR REPLACE MACRO lorem_sentence(rand, words) AS lorem_sentence_util(list_\n statement ok\n SET preserve_insertion_order=false;\n \n+# added NULLs for issue #16306\n statement ok\n-COPY (SELECT lorem_sentence(random(), 20) FROM range(1_000_000)) TO '__TEST_DIR__/16257.parquet' (PARQUET_VERSION V2, ROW_GROUP_SIZE 2_000_000);\n+COPY (SELECT CASE WHEN random() < 0.01 THEN NULL ELSE lorem_sentence(random(), 20) END FROM range(1_000_000)) TO '__TEST_DIR__/16257.parquet' (PARQUET_VERSION V2, ROW_GROUP_SIZE 2_000_000);\ndiff --git a/test/sql/attach/attach_storage_version.test b/test/sql/attach/attach_storage_version.test\nindex 5115a597869d..7dcd4c338c8c 100644\n--- a/test/sql/attach/attach_storage_version.test\n+++ b/test/sql/attach/attach_storage_version.test\n@@ -14,7 +14,7 @@ ATTACH '__TEST_DIR__/version_1_2_0.db' (STORAGE_VERSION 'v1.2.0');\n query I\n SELECT tags['storage_version'] FROM duckdb_databases() WHERE database_name='version_1_2_0'\n ----\n-v1.2.0\n+v1.2.0 - v1.2.1\n \n statement ok\n DETACH version_1_2_0\n@@ -38,7 +38,7 @@ ATTACH '__TEST_DIR__/version_1_2_0.db' (STORAGE_VERSION 'v1.2.0');\n query I\n SELECT tags['storage_version'] FROM duckdb_databases() WHERE database_name='version_1_2_0'\n ----\n-v1.2.0\n+v1.2.0 - v1.2.1\n \n statement ok\n DETACH version_1_2_0\n@@ -51,7 +51,7 @@ ATTACH '__TEST_DIR__/version_1_2_0.db';\n query I\n SELECT tags['storage_version'] FROM duckdb_databases() WHERE database_name='version_1_2_0'\n ----\n-v1.2.0\n+v1.2.0 - v1.2.1\n \n statement ok\n DETACH version_1_2_0\n@@ -83,7 +83,7 @@ ATTACH '__TEST_DIR__/default_version.db' (STORAGE_VERSION 'v1.2.0');\n query I\n SELECT tags['storage_version'] FROM duckdb_databases() WHERE database_name='default_version'\n ----\n-v1.2.0\n+v1.2.0 - v1.2.1\n \n statement ok\n SET force_compression = 'zstd';\n@@ -105,7 +105,7 @@ ATTACH '__TEST_DIR__/default_version.db'\n query I\n SELECT tags['storage_version'] FROM duckdb_databases() WHERE database_name='default_version'\n ----\n-v1.2.0\n+v1.2.0 - v1.2.1\n \n query I\n FROM default_version.tbl\n@@ -151,4 +151,4 @@ ATTACH '__TEST_DIR__/modified_default_setting.db';\n query I\n SELECT tags['storage_version'] FROM duckdb_databases() WHERE database_name='modified_default_setting'\n ----\n-v1.2.0\n+v1.2.0 - v1.2.1\ndiff --git a/test/sql/attach/attach_wal_alter_sequence.test b/test/sql/attach/attach_wal_alter_sequence.test\nnew file mode 100644\nindex 000000000000..eb65f613b8c1\n--- /dev/null\n+++ b/test/sql/attach/attach_wal_alter_sequence.test\n@@ -0,0 +1,52 @@\n+# name: test/sql/attach/attach_wal_alter_sequence.test\n+# description: Test binding of a WAL with a sequence entry in it\n+# group: [attach]\n+\n+require skip_reload\n+\n+statement ok\n+PRAGMA disable_checkpoint_on_shutdown\n+\n+statement ok\n+PRAGMA wal_autocheckpoint='1TB';\n+\n+# create a table with hugeints\n+statement ok\n+attach '__TEST_DIR__/attach_wal_with_sequence.db' as db1;\n+\n+statement ok\n+CREATE SEQUENCE db1.seq;\n+\n+statement ok\n+CREATE TABLE db1.test (a INTEGER DEFAULT nextval('seq'), b INTEGER, c INTEGER DEFAULT currval('seq'));\n+\n+statement ok\n+INSERT INTO db1.test (b) VALUES (1);\n+\n+statement ok\n+alter table db1.test RENAME TO blubb;\n+\n+statement ok\n+INSERT INTO db1.blubb (b) VALUES (10);\n+\n+query III\n+SELECT * FROM db1.blubb\n+----\n+1\t1\t1\n+2\t10\t2\n+\n+statement ok\n+DETACH db1\n+\n+statement ok\n+attach '__TEST_DIR__/attach_wal_with_sequence.db' as db2;\n+\n+statement ok\n+INSERT INTO db2.blubb (b) VALUES (100);\n+\n+query III\n+SELECT * FROM db2.blubb\n+----\n+1\t1\t1\n+2\t10\t2\n+3\t100\t3\ndiff --git a/test/sql/catalog/test_querying_from_detached_catalog.test b/test/sql/catalog/test_querying_from_detached_catalog.test\nnew file mode 100644\nindex 000000000000..57e500291470\n--- /dev/null\n+++ b/test/sql/catalog/test_querying_from_detached_catalog.test\n@@ -0,0 +1,72 @@\n+# name: test/sql/catalog/test_querying_from_detached_catalog.test\n+# description: Test switching from detached catalog to another catalog\n+# group: [catalog]\n+\n+require skip_reload\n+\n+statement ok con1\n+ATTACH ':memory:' AS db1;\n+\n+statement ok con1\n+ATTACH ':memory:' AS db2;\n+\n+statement ok con1\n+CREATE TABLE db2.tbl (i INTEGER, j INTEGER);\n+\n+statement ok con1\n+INSERT INTO db2.tbl VALUES (1, 2), (3,4);\n+\n+statement ok con1\n+USE db1;\n+\n+query I con1\n+SELECT CURRENT_SETTING('search_path');\n+----\n+db1.main\n+\n+statement ok con2\n+USE db2;\n+\n+# drop catalog db1, which con1 is using\n+statement ok con2\n+DETACH db1;\n+\n+# querying to an attached catalog should work (with non-fully qualified name)\n+query II con1\n+FROM db2.tbl;\n+----\n+1\t2\n+3\t4\n+\n+# querying to an attached catalog should work (with fully qualified name)\n+query II con1\n+FROM db2.main.tbl;\n+----\n+1\t2\n+3\t4\n+\n+# creating a new table in db2 works\n+statement ok con1\n+CREATE TABLE db2.tbl2 AS SELECT 42;\n+\n+# error message should say that the table does not exist\n+statement error con1\n+FROM db2.non_existent_table;\n+----\n+Catalog Error: Table with name non_existent_table does not exist!\n+\n+# querying within the detached catalog fails\n+statement error con1\n+SHOW TABLES;\n+----\n+Binder Error: Catalog \"db1\" does not exist!\n+\n+# swithcing to another catalog should work\n+statement ok con1\n+USE db2;\n+\n+query I con1\n+SELECT CURRENT_SETTING('search_path');\n+----\n+db2.main\n+\ndiff --git a/test/sql/catalog/test_switching_from_detached_catalog.test b/test/sql/catalog/test_switching_from_detached_catalog.test\ndeleted file mode 100644\nindex 89111a05bda7..000000000000\n--- a/test/sql/catalog/test_switching_from_detached_catalog.test\n+++ /dev/null\n@@ -1,42 +0,0 @@\n-# name: test/sql/catalog/test_switching_from_detached_catalog.test\n-# description: Test switching from detached catalog to another catalog\n-# group: [catalog]\n-\n-require skip_reload\n-\n-statement ok con1\n-ATTACH ':memory:' AS db1;\n-\n-statement ok con1\n-ATTACH ':memory:' AS db2;\n-\n-statement ok con1\n-USE db1;\n-\n-query I con1\n-SELECT CURRENT_SETTING('search_path');\n-----\n-db1.main\n-\n-statement ok con2\n-USE db2;\n-\n-# drop catalog db1, which con1 is using\n-statement ok con2\n-DETACH db1;\n-\n-# querying within the detached catalog fails\n-statement error con1\n-SHOW TABLES;\n-----\n-Binder Error: Catalog \"db1\" does not exist!\n-\n-# swithcing to another catalog should work\n-statement ok con1\n-USE db2;\n-\n-query I con1\n-SELECT CURRENT_SETTING('search_path');\n-----\n-db2.main\n-\ndiff --git a/test/sql/constraints/foreignkey/test_fk_eager_constraint_checking.test b/test/sql/constraints/foreignkey/test_fk_eager_constraint_checking.test\nnew file mode 100644\nindex 000000000000..4b0b230a27be\n--- /dev/null\n+++ b/test/sql/constraints/foreignkey/test_fk_eager_constraint_checking.test\n@@ -0,0 +1,56 @@\n+# name: test/sql/constraints/foreignkey/test_fk_eager_constraint_checking.test\n+# description: Test over-eager constraint checking for foreign keys.\n+# group: [foreignkey]\n+\n+require noforcestorage\n+\n+require skip_reload\n+\n+statement ok\n+PRAGMA enable_verification;\n+\n+statement ok\n+SET storage_compatibility_version = 'v0.10.3';\n+\n+statement ok\n+ATTACH '__TEST_DIR__/test_fk_eager.db' AS fk_db;\n+\n+statement ok\n+USE fk_db;\n+\n+# We need a PK table with a column not supporting in-place updates.\n+statement ok\n+CREATE TABLE tbl_pk (i INT PRIMARY KEY, payload STRUCT(v VARCHAR, i INTEGER[]));\n+\n+# Let's insert two rows.\n+statement ok\n+INSERT INTO tbl_pk VALUES (1, {'v': 'hello', 'i': [42]}), (2, {'v': 'world', 'i': [43]});\n+\n+# Now, we need a FK table.\n+statement ok\n+CREATE TABLE tbl_fk (i INT REFERENCES tbl_pk(i));\n+\n+# Let's insert rows so that has the FK table has a nested leaf with more than two row IDs.\n+statement ok\n+INSERT INTO tbl_fk VALUES (1), (1), (1);\n+\n+statement ok\n+USE memory;\n+\n+# We also want the old LEAF representation serialized.\n+statement ok\n+CHECKPOINT fk_db;\n+\n+statement ok\n+DETACH fk_db;\n+\n+statement ok\n+ATTACH '__TEST_DIR__/test_fk_eager.db' AS fk_db;\n+\n+# Now, we try to update the PK table.\n+# The over-eager constraint checking fix is not yet supported for FKs, thus, we throw a constraint violation.\n+statement error\n+UPDATE fk_db.tbl_pk SET payload = {'v': 'new hello', 'i': [7]} WHERE i = 1;\n+----\n+<REGEX>:Constraint Error.*Violates foreign key constraint because.*\n+\ndiff --git a/test/sql/copy/csv/test_read_csv.test b/test/sql/copy/csv/test_read_csv.test\nindex 7f28bdec02cc..e54ecbd33efb 100644\n--- a/test/sql/copy/csv/test_read_csv.test\n+++ b/test/sql/copy/csv/test_read_csv.test\n@@ -5,6 +5,17 @@\n statement ok\n PRAGMA enable_verification\n \n+query II\n+FROM read_csv('data/csv/multi_quote.csv', null_padding = true)\n+----\n+2019-01-01\ttext\n+2019-02-01\ttext\n+2019-03-01\ttext\n+2019-04-01\ttext\n+2019-05-01\ttext\n+2019-06-01\ttext, with comma\n+2019-09-01\t'text'\n+\n query II\n FROM read_csv('data/csv/bad_escape.csv')\n ----\ndiff --git a/test/sql/copy/csv/test_sniff_csv.test b/test/sql/copy/csv/test_sniff_csv.test\nindex d94967405e8d..9bdb7a19ac8f 100644\n--- a/test/sql/copy/csv/test_sniff_csv.test\n+++ b/test/sql/copy/csv/test_sniff_csv.test\n@@ -8,6 +8,11 @@ PRAGMA enable_verification\n # requires notwindows because tests will return \\r\\n to be used in the parameters\n require notwindows\n \n+query III\n+SELECT escape,quote, delimiter from sniff_csv('data/csv/later_quotes.csv');\n+----\n+\"\t\"\t,\n+\n query I\n SELECT Prompt FROM sniff_csv('data/csv/real/lineitem_sample.csv');\n ----\ndiff --git a/test/sql/copy/return_files.test b/test/sql/copy/return_files.test\nindex 8c815bc4e9db..984c0652394d 100644\n--- a/test/sql/copy/return_files.test\n+++ b/test/sql/copy/return_files.test\n@@ -26,10 +26,12 @@ COPY integers TO '__TEST_DIR__/test_batch_copy_to_file.parquet' (RETURN_FILES TR\n statement ok\n SET threads=2;\n \n+# as mentioned in per_thread_output.test, the number of files do not necessarily match the number of threads\n+# here, we check if the number of rows are correct and at least one file has been written.\n query II\n COPY integers TO '__TEST_DIR__/test_per_thread_output' (RETURN_FILES, PER_THREAD_OUTPUT);\n ----\n-200000\t<REGEX>:.*data_0.csv.*data_1.csv.*\n+200000\t<REGEX>:.*data_0.csv.*\n \n require notwindows\n \ndiff --git a/test/sql/function/timestamp/test_icu_strptime.test b/test/sql/function/timestamp/test_icu_strptime.test\nindex d54eaa58594d..4b0902763032 100644\n--- a/test/sql/function/timestamp/test_icu_strptime.test\n+++ b/test/sql/function/timestamp/test_icu_strptime.test\n@@ -589,3 +589,9 @@ statement error\n SELECT TIMESTAMPTZ '294247-01-10 04:00:54.7758';\n ----\n Conversion Error: ICU date overflows timestamp range\n+\n+# Invalid time zones should produce NULL, not an error\n+query I\n+select try_strptime('2015-01-05 00:00:00 FNORD', '%Y-%m-%d %H:%M:%S %Z');\n+----\n+NULL\ndiff --git a/test/sql/storage/storage_version_65.test b/test/sql/storage/storage_version_65.test\nindex 3e9323ce8672..fcded07a9ce5 100644\n--- a/test/sql/storage/storage_version_65.test\n+++ b/test/sql/storage/storage_version_65.test\n@@ -17,7 +17,7 @@ ATTACH '__TEST_DIR__/storage_versions65.db'\n query I\n SELECT tags FROM duckdb_databases() WHERE database_name = 'storage_versions65';\n ----\n-{storage_version=v1.2.0}\n+{storage_version=v1.2.0 - v1.2.1}\n \n statement ok\n set storage_compatibility_version='v0.10.2'\ndiff --git a/test/sql/storage/storage_versions.test b/test/sql/storage/storage_versions.test\nindex 63be1b8b7623..113e61302493 100644\n--- a/test/sql/storage/storage_versions.test\n+++ b/test/sql/storage/storage_versions.test\n@@ -24,4 +24,4 @@ query I\n SELECT tags FROM duckdb_databases() WHERE database_name LIKE 'empty%' ORDER BY database_name;\n ----\n {storage_version=v1.0.0 - v1.1.3}\n-{storage_version=v1.2.0}\n+{storage_version=v1.2.0 - v1.2.1}\ndiff --git a/test/sql/subquery/scalar/subquery_row_in_any.test b/test/sql/subquery/scalar/subquery_row_in_any.test\nindex f0f700097beb..096f783fc9aa 100644\n--- a/test/sql/subquery/scalar/subquery_row_in_any.test\n+++ b/test/sql/subquery/scalar/subquery_row_in_any.test\n@@ -13,6 +13,12 @@ SELECT (1, 2) IN (SELECT i, i + 1 FROM integers)\n ----\n true\n \n+# mixed types\n+query I\n+SELECT (date '1992-01-02', 2) IN (SELECT date '1992-01-01' + interval (i) days, i + 1 FROM integers)\n+----\n+true\n+\n # it still works with the row inside the subquery\n query I\n SELECT (1, 2) IN (SELECT (i, i + 1) FROM integers)\ndiff --git a/test/sql/window/test_custom_spooling.test_slow b/test/sql/window/test_custom_spooling.test_slow\nindex f6d2fd9e0fd9..c8c64cfb6a74 100644\n--- a/test/sql/window/test_custom_spooling.test_slow\n+++ b/test/sql/window/test_custom_spooling.test_slow\n@@ -14,6 +14,10 @@ PRAGMA temp_directory='__TEST_DIR__/window_spooling'\n statement ok\n PRAGMA memory_limit='50MB'\n \n+# Limit threads to improve stability\n+statement ok\n+PRAGMA threads=4;\n+\n statement ok\n PRAGMA enable_verification\n \n@@ -25,13 +29,13 @@ FROM (\n \t\tSUM(l_extendedprice) OVER w AS s,\n \t\tQUANTILE(l_extendedprice, 0.5) OVER w AS q,\n \t\tMAD(l_extendedprice) OVER w AS m,\n-\t\tMODE(l_quantity) OVER w AS d,\n+\t\tMODE(l_linenumber) OVER w AS d,\n \tFROM lineitem\n \tWINDOW w AS (\n-\t\tPARTITION BY (l_linenumber = 1) \n-\t\tORDER BY l_orderkey, l_linenumber \n+\t\tPARTITION BY l_suppkey \n+\t\tORDER BY l_shipdate, l_orderkey, l_linenumber\n \t\tROWS BETWEEN 20 PRECEDING AND 20 FOLLOWING\n \t)\n ) t;\n ----\n-886221884732.62\t20709502135.61\t9898471727.97\t15330000\n+871183083803.67\t20718441622.70\t9873496927.55\t1050000.0\n",
  "problem_statement": "CLI \".rows\" switches to columns view (same as \".columns\")\n### What happens?\n\nUsing `.rows` in the CLI switches to columns mode (the same behavior as `.columns`) instead of switching to the default, expected behavior.\n\n### To Reproduce\n\nMinimal reproducer (Using a new DuckDB CLI session):\n```\n.rows\nFROM VALUES (1,2,3), (4,5,6) AS t(a,b,c);\n```\n\nA bit more explanatory of a typical use-case (Using a new DuckDB CLI session):\n```\n-- Default behavior (row-wise)\nFROM VALUES (1,2,3), (4,5,6) AS t(a,b,c);\n-- Observe bug: explicitly set to row-wise (this fails by going to columns instead)\n.rows\nFROM VALUES (1,2,3), (4,5,6) AS t(a,b,c);\n-- Switch to columns (nothing changes) then try to switch back (also doesn't work)\n.columns\nFROM VALUES (1,2,3), (4,5,6) AS t(a,b,c);\n.rows\nFROM VALUES (1,2,3), (4,5,6) AS t(a,b,c);\n```\n\n\n### OS:\n\nOSX 15.3 aarch64 and Ubuntu 22.04 x86_64\n\n### DuckDB Version:\n\n1.2.0\n\n### DuckDB Client:\n\nCLI\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nTeague Sterling\n\n### Affiliation:\n\n23andMe\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a stable release\n\n### Did you include all relevant data sets for reproducing the issue?\n\nNot applicable - the reproduction does not require a data set\n\n### Did you include all code required to reproduce the issue?\n\n- [x] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [x] Yes, I have\nwrong format specifier used when loading extension with bad header\n### What happens?\n\nWrong format specifier for unknown extension ABI, is `%s` should be `%d` (or have the enum be formatted manually)\n\n### To Reproduce\n\nI have not added any reproducing code, since I do not think it is important\n\n### OS:\n\nlinux\n\n### DuckDB Version:\n\nsource\n\n### DuckDB Client:\n\ncli\n\n### Hardware:\n\n_No response_\n\n### Full Name:\n\nJA\n\n### Affiliation:\n\nnone\n\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\n\nI have tested with a source build\n\n### Did you include all relevant data sets for reproducing the issue?\n\nNo - Other reason (please specify in the issue body)\n\n### Did you include all code required to reproduce the issue?\n\n- [x] Yes, I have\n\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\n\n- [x] Yes, I have\n",
  "hints_text": "\nhttps://github.com/duckdb/duckdb/blob/9c133491ada57fcc588d867d66ec815814f69c8c/src/main/extension/extension_load.cpp#L125-L130\nNice catch, I didn't think there would be multiple, but I was originally referring to https://github.com/duckdb/duckdb/blob/9c133491ada57fcc588d867d66ec815814f69c8c/src/main/extension/extension_load.cpp#L594",
  "created_at": "2025-02-27T06:56:54Z"
}