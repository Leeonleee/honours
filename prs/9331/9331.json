{
  "repo": "duckdb/duckdb",
  "pull_number": 9331,
  "instance_id": "duckdb__duckdb-9331",
  "issue_numbers": [
    "4812"
  ],
  "base_commit": "30c8ed4b36228d9cc5b0bef07f64782a9cd08bde",
  "patch": "diff --git a/src/common/arrow/appender/union_data.cpp b/src/common/arrow/appender/union_data.cpp\nindex cfe54f89b418..3adb8d05da54 100644\n--- a/src/common/arrow/appender/union_data.cpp\n+++ b/src/common/arrow/appender/union_data.cpp\n@@ -24,7 +24,7 @@ void ArrowUnionData::Append(ArrowAppendData &append_data, Vector &input, idx_t f\n \n \tduckdb::vector<Vector> child_vectors;\n \tfor (const auto &child : UnionType::CopyMemberTypes(input.GetType())) {\n-\t\tchild_vectors.emplace_back(child.second);\n+\t\tchild_vectors.emplace_back(child.second, size);\n \t}\n \n \tfor (idx_t input_idx = from; input_idx < to; input_idx++) {\ndiff --git a/src/function/table/arrow.cpp b/src/function/table/arrow.cpp\nindex 306e57d30dcc..f62449960166 100644\n--- a/src/function/table/arrow.cpp\n+++ b/src/function/table/arrow.cpp\n@@ -14,7 +14,7 @@\n \n namespace duckdb {\n \n-unique_ptr<ArrowType> ArrowTableFunction::GetArrowLogicalType(ArrowSchema &schema) {\n+static unique_ptr<ArrowType> GetArrowLogicalTypeNoDictionary(ArrowSchema &schema) {\n \tauto format = string(schema.format);\n \tif (format == \"n\") {\n \t\treturn make_uniq<ArrowType>(LogicalType::SQLNULL);\n@@ -87,13 +87,13 @@ unique_ptr<ArrowType> ArrowTableFunction::GetArrowLogicalType(ArrowSchema &schem\n \t} else if (format == \"tin\") {\n \t\treturn make_uniq<ArrowType>(LogicalType::INTERVAL, ArrowDateTimeType::MONTH_DAY_NANO);\n \t} else if (format == \"+l\") {\n-\t\tauto child_type = GetArrowLogicalType(*schema.children[0]);\n+\t\tauto child_type = ArrowTableFunction::GetArrowLogicalType(*schema.children[0]);\n \t\tauto list_type =\n \t\t    make_uniq<ArrowType>(LogicalType::LIST(child_type->GetDuckType()), ArrowVariableSizeType::NORMAL);\n \t\tlist_type->AddChild(std::move(child_type));\n \t\treturn list_type;\n \t} else if (format == \"+L\") {\n-\t\tauto child_type = GetArrowLogicalType(*schema.children[0]);\n+\t\tauto child_type = ArrowTableFunction::GetArrowLogicalType(*schema.children[0]);\n \t\tauto list_type =\n \t\t    make_uniq<ArrowType>(LogicalType::LIST(child_type->GetDuckType()), ArrowVariableSizeType::SUPER_SIZE);\n \t\tlist_type->AddChild(std::move(child_type));\n@@ -101,7 +101,7 @@ unique_ptr<ArrowType> ArrowTableFunction::GetArrowLogicalType(ArrowSchema &schem\n \t} else if (format[0] == '+' && format[1] == 'w') {\n \t\tstd::string parameters = format.substr(format.find(':') + 1);\n \t\tidx_t fixed_size = std::stoi(parameters);\n-\t\tauto child_type = GetArrowLogicalType(*schema.children[0]);\n+\t\tauto child_type = ArrowTableFunction::GetArrowLogicalType(*schema.children[0]);\n \t\tauto list_type = make_uniq<ArrowType>(LogicalType::LIST(child_type->GetDuckType()), fixed_size);\n \t\tlist_type->AddChild(std::move(child_type));\n \t\treturn list_type;\n@@ -109,7 +109,7 @@ unique_ptr<ArrowType> ArrowTableFunction::GetArrowLogicalType(ArrowSchema &schem\n \t\tchild_list_t<LogicalType> child_types;\n \t\tvector<unique_ptr<ArrowType>> children;\n \t\tfor (idx_t type_idx = 0; type_idx < (idx_t)schema.n_children; type_idx++) {\n-\t\t\tchildren.emplace_back(GetArrowLogicalType(*schema.children[type_idx]));\n+\t\t\tchildren.emplace_back(ArrowTableFunction::GetArrowLogicalType(*schema.children[type_idx]));\n \t\t\tchild_types.emplace_back(schema.children[type_idx]->name, children.back()->GetDuckType());\n \t\t}\n \t\tauto struct_type = make_uniq<ArrowType>(LogicalType::STRUCT(std::move(child_types)));\n@@ -130,7 +130,7 @@ unique_ptr<ArrowType> ArrowTableFunction::GetArrowLogicalType(ArrowSchema &schem\n \t\tfor (idx_t type_idx = 0; type_idx < (idx_t)schema.n_children; type_idx++) {\n \t\t\tauto type = schema.children[type_idx];\n \n-\t\t\tchildren.emplace_back(GetArrowLogicalType(*type));\n+\t\t\tchildren.emplace_back(ArrowTableFunction::GetArrowLogicalType(*type));\n \t\t\tmembers.emplace_back(type->name, children.back()->GetDuckType());\n \t\t}\n \n@@ -140,8 +140,8 @@ unique_ptr<ArrowType> ArrowTableFunction::GetArrowLogicalType(ArrowSchema &schem\n \t} else if (format == \"+m\") {\n \t\tauto &arrow_struct_type = *schema.children[0];\n \t\tD_ASSERT(arrow_struct_type.n_children == 2);\n-\t\tauto key_type = GetArrowLogicalType(*arrow_struct_type.children[0]);\n-\t\tauto value_type = GetArrowLogicalType(*arrow_struct_type.children[1]);\n+\t\tauto key_type = ArrowTableFunction::GetArrowLogicalType(*arrow_struct_type.children[0]);\n+\t\tauto value_type = ArrowTableFunction::GetArrowLogicalType(*arrow_struct_type.children[1]);\n \t\tauto map_type = make_uniq<ArrowType>(LogicalType::MAP(key_type->GetDuckType(), value_type->GetDuckType()),\n \t\t                                     ArrowVariableSizeType::NORMAL);\n \t\tchild_list_t<LogicalType> key_value;\n@@ -184,6 +184,15 @@ unique_ptr<ArrowType> ArrowTableFunction::GetArrowLogicalType(ArrowSchema &schem\n \t}\n }\n \n+unique_ptr<ArrowType> ArrowTableFunction::GetArrowLogicalType(ArrowSchema &schema) {\n+\tauto arrow_type = GetArrowLogicalTypeNoDictionary(schema);\n+\tif (schema.dictionary) {\n+\t\tauto dictionary = GetArrowLogicalType(*schema.dictionary);\n+\t\tarrow_type->SetDictionary(std::move(dictionary));\n+\t}\n+\treturn arrow_type;\n+}\n+\n void ArrowTableFunction::RenameArrowColumns(vector<string> &names) {\n \tunordered_map<string, idx_t> name_map;\n \tfor (auto &column_name : names) {\n@@ -216,15 +225,7 @@ void ArrowTableFunction::PopulateArrowTableType(ArrowTableType &arrow_table, Arr\n \t\t\tthrow InvalidInputException(\"arrow_scan: released schema passed\");\n \t\t}\n \t\tauto arrow_type = GetArrowLogicalType(schema);\n-\t\tif (schema.dictionary) {\n-\t\t\tauto logical_type = arrow_type->GetDuckType();\n-\t\t\tauto dictionary = GetArrowLogicalType(*schema.dictionary);\n-\t\t\treturn_types.emplace_back(dictionary->GetDuckType());\n-\t\t\t// The dictionary might have different attributes (size type, datetime precision, etc..)\n-\t\t\tarrow_type->SetDictionary(std::move(dictionary));\n-\t\t} else {\n-\t\t\treturn_types.emplace_back(arrow_type->GetDuckType());\n-\t\t}\n+\t\treturn_types.emplace_back(arrow_type->GetDuckType(true));\n \t\tarrow_table.AddColumn(col_idx, std::move(arrow_type));\n \t\tauto format = string(schema.format);\n \t\tauto name = string(schema.name);\ndiff --git a/src/function/table/arrow/CMakeLists.txt b/src/function/table/arrow/CMakeLists.txt\nindex 94eac4ffbecf..badf731a842e 100644\n--- a/src/function/table/arrow/CMakeLists.txt\n+++ b/src/function/table/arrow/CMakeLists.txt\n@@ -1,4 +1,5 @@\n-add_library_unity(duckdb_arrow_conversion OBJECT arrow_duck_schema.cpp)\n+add_library_unity(duckdb_arrow_conversion OBJECT arrow_duck_schema.cpp\n+                  arrow_array_scan_state.cpp)\n set(ALL_OBJECT_FILES\n     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_arrow_conversion>\n     PARENT_SCOPE)\ndiff --git a/src/function/table/arrow/arrow_array_scan_state.cpp b/src/function/table/arrow/arrow_array_scan_state.cpp\nnew file mode 100644\nindex 000000000000..88aa49bfa1db\n--- /dev/null\n+++ b/src/function/table/arrow/arrow_array_scan_state.cpp\n@@ -0,0 +1,32 @@\n+#include \"duckdb/function/table/arrow.hpp\"\n+\n+namespace duckdb {\n+\n+ArrowArrayScanState::ArrowArrayScanState(ArrowScanLocalState &state) : state(state) {\n+}\n+\n+ArrowArrayScanState &ArrowArrayScanState::GetChild(idx_t child_idx) {\n+\tauto it = children.find(child_idx);\n+\tif (it == children.end()) {\n+\t\tauto child_p = make_uniq<ArrowArrayScanState>(state);\n+\t\tauto &child = *child_p;\n+\t\tchildren.emplace(std::make_pair(child_idx, std::move(child_p)));\n+\t\treturn child;\n+\t}\n+\treturn *it->second;\n+}\n+\n+void ArrowArrayScanState::AddDictionary(unique_ptr<Vector> dictionary_p) {\n+\tthis->dictionary = std::move(dictionary_p);\n+}\n+\n+bool ArrowArrayScanState::HasDictionary() const {\n+\treturn dictionary != nullptr;\n+}\n+\n+Vector &ArrowArrayScanState::GetDictionary() {\n+\tD_ASSERT(HasDictionary());\n+\treturn *dictionary;\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/function/table/arrow/arrow_duck_schema.cpp b/src/function/table/arrow/arrow_duck_schema.cpp\nindex 42d04d2ebaf7..933c4da41ef9 100644\n--- a/src/function/table/arrow/arrow_duck_schema.cpp\n+++ b/src/function/table/arrow/arrow_duck_schema.cpp\n@@ -27,13 +27,57 @@ void ArrowType::SetDictionary(unique_ptr<ArrowType> dictionary) {\n \tdictionary_type = std::move(dictionary);\n }\n \n+bool ArrowType::HasDictionary() const {\n+\treturn dictionary_type != nullptr;\n+}\n+\n const ArrowType &ArrowType::GetDictionary() const {\n \tD_ASSERT(dictionary_type);\n \treturn *dictionary_type;\n }\n \n-const LogicalType &ArrowType::GetDuckType() const {\n-\treturn type;\n+LogicalType ArrowType::GetDuckType(bool use_dictionary) const {\n+\tif (use_dictionary && dictionary_type) {\n+\t\treturn dictionary_type->GetDuckType();\n+\t}\n+\tif (!use_dictionary) {\n+\t\treturn type;\n+\t}\n+\t// Dictionaries can exist in arbitrarily nested schemas\n+\t// have to reconstruct the type\n+\tauto id = type.id();\n+\tswitch (id) {\n+\tcase LogicalTypeId::STRUCT: {\n+\t\tchild_list_t<LogicalType> new_children;\n+\t\tfor (idx_t i = 0; i < children.size(); i++) {\n+\t\t\tauto &child = children[i];\n+\t\t\tauto &child_name = StructType::GetChildName(type, i);\n+\t\t\tnew_children.emplace_back(std::make_pair(child_name, child->GetDuckType(true)));\n+\t\t}\n+\t\treturn LogicalType::STRUCT(std::move(new_children));\n+\t}\n+\tcase LogicalTypeId::LIST: {\n+\t\tauto &child = children[0];\n+\t\treturn LogicalType::LIST(child->GetDuckType(true));\n+\t}\n+\tcase LogicalTypeId::MAP: {\n+\t\tauto &struct_child = children[0];\n+\t\tauto struct_type = struct_child->GetDuckType(true);\n+\t\treturn LogicalType::MAP(StructType::GetChildType(struct_type, 0), StructType::GetChildType(struct_type, 1));\n+\t}\n+\tcase LogicalTypeId::UNION: {\n+\t\tchild_list_t<LogicalType> new_children;\n+\t\tfor (idx_t i = 0; i < children.size(); i++) {\n+\t\t\tauto &child = children[i];\n+\t\t\tauto &child_name = UnionType::GetMemberName(type, i);\n+\t\t\tnew_children.emplace_back(std::make_pair(child_name, child->GetDuckType(true)));\n+\t\t}\n+\t\treturn LogicalType::UNION(std::move(new_children));\n+\t}\n+\tdefault: {\n+\t\treturn type;\n+\t}\n+\t}\n }\n \n ArrowVariableSizeType ArrowType::GetSizeType() const {\ndiff --git a/src/function/table/arrow_conversion.cpp b/src/function/table/arrow_conversion.cpp\nindex ba7d011ad3d9..204078357e43 100644\n--- a/src/function/table/arrow_conversion.cpp\n+++ b/src/function/table/arrow_conversion.cpp\n@@ -80,14 +80,20 @@ static void SetValidityMask(Vector &vector, ArrowArray &array, ArrowScanLocalSta\n \tGetValidityMask(mask, array, scan_state, size, nested_offset, add_null);\n }\n \n-static void ColumnArrowToDuckDB(Vector &vector, ArrowArray &array, ArrowScanLocalState &scan_state, idx_t size,\n+static void ColumnArrowToDuckDB(Vector &vector, ArrowArray &array, ArrowArrayScanState &array_state, idx_t size,\n                                 const ArrowType &arrow_type, int64_t nested_offset = -1,\n                                 ValidityMask *parent_mask = nullptr, uint64_t parent_offset = 0);\n \n-static void ArrowToDuckDBList(Vector &vector, ArrowArray &array, ArrowScanLocalState &scan_state, idx_t size,\n+static void ColumnArrowToDuckDBDictionary(Vector &vector, ArrowArray &array, ArrowArrayScanState &array_state,\n+                                          idx_t size, const ArrowType &arrow_type, int64_t nested_offset = -1,\n+                                          ValidityMask *parent_mask = nullptr, uint64_t parent_offset = 0);\n+\n+static void ArrowToDuckDBList(Vector &vector, ArrowArray &array, ArrowArrayScanState &array_state, idx_t size,\n                               const ArrowType &arrow_type, int64_t nested_offset, ValidityMask *parent_mask) {\n \tauto size_type = arrow_type.GetSizeType();\n \tidx_t list_size = 0;\n+\tauto &scan_state = array_state.state;\n+\n \tSetValidityMask(vector, array, scan_state, size, nested_offset);\n \tidx_t start_offset = 0;\n \tidx_t cur_offset = 0;\n@@ -152,10 +158,19 @@ static void ArrowToDuckDBList(Vector &vector, ArrowArray &array, ArrowScanLocalS\n \t\t\t}\n \t\t}\n \t}\n+\tauto &child_state = array_state.GetChild(0);\n+\tauto &child_array = *array.children[0];\n+\tauto &child_type = arrow_type[0];\n \tif (list_size == 0 && start_offset == 0) {\n-\t\tColumnArrowToDuckDB(child_vector, *array.children[0], scan_state, list_size, arrow_type[0], -1);\n+\t\tD_ASSERT(!child_array.dictionary);\n+\t\tColumnArrowToDuckDB(child_vector, child_array, child_state, list_size, child_type, -1);\n \t} else {\n-\t\tColumnArrowToDuckDB(child_vector, *array.children[0], scan_state, list_size, arrow_type[0], start_offset);\n+\t\tif (child_array.dictionary) {\n+\t\t\t// TODO: add support for offsets\n+\t\t\tColumnArrowToDuckDBDictionary(child_vector, child_array, child_state, list_size, child_type, start_offset);\n+\t\t} else {\n+\t\t\tColumnArrowToDuckDB(child_vector, child_array, child_state, list_size, child_type, start_offset);\n+\t\t}\n \t}\n }\n \n@@ -343,9 +358,11 @@ static void IntervalConversionMonthDayNanos(Vector &vector, ArrowArray &array, A\n \t}\n }\n \n-static void ColumnArrowToDuckDB(Vector &vector, ArrowArray &array, ArrowScanLocalState &scan_state, idx_t size,\n+static void ColumnArrowToDuckDB(Vector &vector, ArrowArray &array, ArrowArrayScanState &array_state, idx_t size,\n                                 const ArrowType &arrow_type, int64_t nested_offset, ValidityMask *parent_mask,\n                                 uint64_t parent_offset) {\n+\tauto &scan_state = array_state.state;\n+\tD_ASSERT(!array.dictionary);\n \tswitch (vector.GetType().id()) {\n \tcase LogicalTypeId::SQLNULL:\n \t\tvector.Reference(Value());\n@@ -601,11 +618,11 @@ static void ColumnArrowToDuckDB(Vector &vector, ArrowArray &array, ArrowScanLoca\n \t\tbreak;\n \t}\n \tcase LogicalTypeId::LIST: {\n-\t\tArrowToDuckDBList(vector, array, scan_state, size, arrow_type, nested_offset, parent_mask);\n+\t\tArrowToDuckDBList(vector, array, array_state, size, arrow_type, nested_offset, parent_mask);\n \t\tbreak;\n \t}\n \tcase LogicalTypeId::MAP: {\n-\t\tArrowToDuckDBList(vector, array, scan_state, size, arrow_type, nested_offset, parent_mask);\n+\t\tArrowToDuckDBList(vector, array, array_state, size, arrow_type, nested_offset, parent_mask);\n \t\tArrowToDuckDBMapVerify(vector, size);\n \t\tbreak;\n \t}\n@@ -613,18 +630,29 @@ static void ColumnArrowToDuckDB(Vector &vector, ArrowArray &array, ArrowScanLoca\n \t\t//! Fill the children\n \t\tauto &child_entries = StructVector::GetEntries(vector);\n \t\tauto &struct_validity_mask = FlatVector::Validity(vector);\n-\t\tfor (idx_t type_idx = 0; type_idx < static_cast<idx_t>(array.n_children); type_idx++) {\n-\t\t\tSetValidityMask(*child_entries[type_idx], *array.children[type_idx], scan_state, size, nested_offset);\n+\t\tfor (int64_t child_idx = 0; child_idx < array.n_children; child_idx++) {\n+\t\t\tauto &child_entry = *child_entries[child_idx];\n+\t\t\tauto &child_array = *array.children[child_idx];\n+\t\t\tauto &child_type = arrow_type[child_idx];\n+\t\t\tauto &child_state = array_state.GetChild(child_idx);\n+\n+\t\t\tSetValidityMask(child_entry, child_array, scan_state, size, nested_offset);\n \t\t\tif (!struct_validity_mask.AllValid()) {\n-\t\t\t\tauto &child_validity_mark = FlatVector::Validity(*child_entries[type_idx]);\n+\t\t\t\tauto &child_validity_mark = FlatVector::Validity(child_entry);\n \t\t\t\tfor (idx_t i = 0; i < size; i++) {\n \t\t\t\t\tif (!struct_validity_mask.RowIsValid(i)) {\n \t\t\t\t\t\tchild_validity_mark.SetInvalid(i);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\tColumnArrowToDuckDB(*child_entries[type_idx], *array.children[type_idx], scan_state, size,\n-\t\t\t                    arrow_type[type_idx], nested_offset, &struct_validity_mask, array.offset);\n+\t\t\tif (child_array.dictionary) {\n+\t\t\t\t// TODO: add support for offsets\n+\t\t\t\tColumnArrowToDuckDBDictionary(child_entry, child_array, child_state, size, child_type, nested_offset,\n+\t\t\t\t                              &struct_validity_mask, array.offset);\n+\t\t\t} else {\n+\t\t\t\tColumnArrowToDuckDB(child_entry, child_array, child_state, size, child_type, nested_offset,\n+\t\t\t\t                    &struct_validity_mask, array.offset);\n+\t\t\t}\n \t\t}\n \t\tbreak;\n \t}\n@@ -636,14 +664,19 @@ static void ColumnArrowToDuckDB(Vector &vector, ArrowArray &array, ArrowScanLoca\n \t\tauto &validity_mask = FlatVector::Validity(vector);\n \n \t\tduckdb::vector<Vector> children;\n-\t\tfor (idx_t type_idx = 0; type_idx < static_cast<idx_t>(array.n_children); type_idx++) {\n-\t\t\tVector child(members[type_idx].second);\n-\t\t\tauto arrow_array = array.children[type_idx];\n-\t\t\tauto &child_type = arrow_type[type_idx];\n+\t\tfor (int64_t child_idx = 0; child_idx < array.n_children; child_idx++) {\n+\t\t\tVector child(members[child_idx].second, size);\n+\t\t\tauto &child_array = *array.children[child_idx];\n+\t\t\tauto &child_state = array_state.GetChild(child_idx);\n+\t\t\tauto &child_type = arrow_type[child_idx];\n \n-\t\t\tSetValidityMask(child, *arrow_array, scan_state, size, nested_offset);\n+\t\t\tSetValidityMask(child, child_array, scan_state, size, nested_offset);\n \n-\t\t\tColumnArrowToDuckDB(child, *arrow_array, scan_state, size, child_type, nested_offset, &validity_mask);\n+\t\t\tif (child_array.dictionary) {\n+\t\t\t\tColumnArrowToDuckDBDictionary(child, child_array, child_state, size, child_type);\n+\t\t\t} else {\n+\t\t\t\tColumnArrowToDuckDB(child, child_array, child_state, size, child_type, nested_offset, &validity_mask);\n+\t\t\t}\n \n \t\t\tchildren.push_back(std::move(child));\n \t\t}\n@@ -790,30 +823,31 @@ static void SetSelectionVector(SelectionVector &sel, data_ptr_t indices_p, Logic\n \t}\n }\n \n-static void ColumnArrowToDuckDBDictionary(Vector &vector, ArrowArray &array, ArrowScanLocalState &scan_state,\n-                                          idx_t size, const ArrowType &arrow_type, idx_t col_idx) {\n+static void ColumnArrowToDuckDBDictionary(Vector &vector, ArrowArray &array, ArrowArrayScanState &array_state,\n+                                          idx_t size, const ArrowType &arrow_type, int64_t nested_offset,\n+                                          ValidityMask *parent_mask, uint64_t parent_offset) {\n \tSelectionVector sel;\n-\tauto &dict_vectors = scan_state.arrow_dictionary_vectors;\n-\tif (!dict_vectors.count(col_idx)) {\n+\tauto &scan_state = array_state.state;\n+\tif (!array_state.HasDictionary()) {\n \t\t//! We need to set the dictionary data for this column\n \t\tauto base_vector = make_uniq<Vector>(vector.GetType(), array.dictionary->length);\n \t\tSetValidityMask(*base_vector, *array.dictionary, scan_state, array.dictionary->length, 0, array.null_count > 0);\n-\t\tColumnArrowToDuckDB(*base_vector, *array.dictionary, scan_state, array.dictionary->length,\n+\t\tColumnArrowToDuckDB(*base_vector, *array.dictionary, array_state, array.dictionary->length,\n \t\t                    arrow_type.GetDictionary());\n-\t\tdict_vectors[col_idx] = std::move(base_vector);\n+\t\tarray_state.AddDictionary(std::move(base_vector));\n \t}\n-\tauto dictionary_type = arrow_type.GetDuckType();\n+\tauto offset_type = arrow_type.GetDuckType();\n \t//! Get Pointer to Indices of Dictionary\n \tauto indices = ArrowBufferData<data_t>(array, 1) +\n-\t               GetTypeIdSize(dictionary_type.InternalType()) * (scan_state.chunk_offset + array.offset);\n+\t               GetTypeIdSize(offset_type.InternalType()) * (scan_state.chunk_offset + array.offset);\n \tif (array.null_count > 0) {\n \t\tValidityMask indices_validity;\n \t\tGetValidityMask(indices_validity, array, scan_state, size);\n-\t\tSetSelectionVector(sel, indices, dictionary_type, size, &indices_validity, array.dictionary->length);\n+\t\tSetSelectionVector(sel, indices, offset_type, size, &indices_validity, array.dictionary->length);\n \t} else {\n-\t\tSetSelectionVector(sel, indices, dictionary_type, size);\n+\t\tSetSelectionVector(sel, indices, offset_type, size);\n \t}\n-\tvector.Slice(*dict_vectors[col_idx], sel, size);\n+\tvector.Slice(array_state.GetDictionary(), sel, size);\n }\n \n void ArrowTableFunction::ArrowToDuckDB(ArrowScanLocalState &scan_state, const arrow_column_map_t &arrow_convert_data,\n@@ -849,11 +883,13 @@ void ArrowTableFunction::ArrowToDuckDB(ArrowScanLocalState &scan_state, const ar\n \n \t\tD_ASSERT(arrow_convert_data.find(col_idx) != arrow_convert_data.end());\n \t\tauto &arrow_type = *arrow_convert_data.at(col_idx);\n+\t\tauto &array_state = scan_state.GetState(col_idx);\n+\n \t\tif (array.dictionary) {\n-\t\t\tColumnArrowToDuckDBDictionary(output.data[idx], array, scan_state, output.size(), arrow_type, col_idx);\n+\t\t\tColumnArrowToDuckDBDictionary(output.data[idx], array, array_state, output.size(), arrow_type);\n \t\t} else {\n \t\t\tSetValidityMask(output.data[idx], array, scan_state, output.size(), -1);\n-\t\t\tColumnArrowToDuckDB(output.data[idx], array, scan_state, output.size(), arrow_type);\n+\t\t\tColumnArrowToDuckDB(output.data[idx], array, array_state, output.size(), arrow_type);\n \t\t}\n \t}\n }\ndiff --git a/src/include/duckdb/function/table/arrow.hpp b/src/include/duckdb/function/table/arrow.hpp\nindex df6e49953835..86caf5889ee3 100644\n--- a/src/include/duckdb/function/table/arrow.hpp\n+++ b/src/include/duckdb/function/table/arrow.hpp\n@@ -63,10 +63,30 @@ struct ArrowScanFunctionData : public PyTableFunctionData {\n \tArrowTableType arrow_table;\n };\n \n+struct ArrowScanLocalState;\n+struct ArrowArrayScanState {\n+public:\n+\tArrowArrayScanState(ArrowScanLocalState &state);\n+\n+public:\n+\tArrowScanLocalState &state;\n+\tunordered_map<idx_t, unique_ptr<ArrowArrayScanState>> children;\n+\t// Cache the (optional) dictionary of this array\n+\tunique_ptr<Vector> dictionary;\n+\n+public:\n+\tArrowArrayScanState &GetChild(idx_t child_idx);\n+\tvoid AddDictionary(unique_ptr<Vector> dictionary_p);\n+\tbool HasDictionary() const;\n+\tVector &GetDictionary();\n+};\n+\n struct ArrowScanLocalState : public LocalTableFunctionState {\n+public:\n \texplicit ArrowScanLocalState(unique_ptr<ArrowArrayWrapper> current_chunk) : chunk(current_chunk.release()) {\n \t}\n \n+public:\n \tunique_ptr<ArrowArrayStreamWrapper> stream;\n \tshared_ptr<ArrowArrayWrapper> chunk;\n \t// This vector hold the Arrow Vectors owned by DuckDB to allow for zero-copy\n@@ -75,11 +95,22 @@ struct ArrowScanLocalState : public LocalTableFunctionState {\n \tidx_t chunk_offset = 0;\n \tidx_t batch_index = 0;\n \tvector<column_t> column_ids;\n-\t//! Store child vectors for Arrow Dictionary Vectors (col-idx,vector)\n-\tunordered_map<idx_t, unique_ptr<Vector>> arrow_dictionary_vectors;\n+\tunordered_map<idx_t, unique_ptr<ArrowArrayScanState>> array_states;\n \tTableFilterSet *filters = nullptr;\n \t//! The DataChunk containing all read columns (even filter columns that are immediately removed)\n \tDataChunk all_columns;\n+\n+public:\n+\tArrowArrayScanState &GetState(idx_t child_idx) {\n+\t\tauto it = array_states.find(child_idx);\n+\t\tif (it == array_states.end()) {\n+\t\t\tauto child_p = make_uniq<ArrowArrayScanState>(*this);\n+\t\t\tauto &child = *child_p;\n+\t\t\tarray_states.emplace(std::make_pair(child_idx, std::move(child_p)));\n+\t\t\treturn child;\n+\t\t}\n+\t\treturn *it->second;\n+\t}\n };\n \n struct ArrowScanGlobalState : public GlobalTableFunctionState {\n@@ -150,6 +181,8 @@ struct ArrowTableFunction {\n \t                            const GlobalTableFunctionState *global_state);\n \t//! Renames repeated columns and case sensitive columns\n \tstatic void RenameArrowColumns(vector<string> &names);\n+\n+public:\n \t//! Helper function to get the DuckDB logical type\n \tstatic unique_ptr<ArrowType> GetArrowLogicalType(ArrowSchema &schema);\n };\ndiff --git a/src/include/duckdb/function/table/arrow/arrow_duck_schema.hpp b/src/include/duckdb/function/table/arrow/arrow_duck_schema.hpp\nindex bd15f89dfaea..d475875f0db2 100644\n--- a/src/include/duckdb/function/table/arrow/arrow_duck_schema.hpp\n+++ b/src/include/duckdb/function/table/arrow/arrow_duck_schema.hpp\n@@ -57,7 +57,7 @@ class ArrowType {\n \n \tvoid AssignChildren(vector<unique_ptr<ArrowType>> children);\n \n-\tconst LogicalType &GetDuckType() const;\n+\tLogicalType GetDuckType(bool use_dictionary = false) const;\n \n \tArrowVariableSizeType GetSizeType() const;\n \n@@ -65,6 +65,8 @@ class ArrowType {\n \n \tvoid SetDictionary(unique_ptr<ArrowType> dictionary);\n \n+\tbool HasDictionary() const;\n+\n \tArrowDateTimeType GetDateTimeType() const;\n \n \tconst ArrowType &GetDictionary() const;\n",
  "test_patch": "diff --git a/tools/pythonpkg/tests/fast/arrow/test_dictionary_arrow.py b/tools/pythonpkg/tests/fast/arrow/test_dictionary_arrow.py\nindex f389836529fe..8b51daca339b 100644\n--- a/tools/pythonpkg/tests/fast/arrow/test_dictionary_arrow.py\n+++ b/tools/pythonpkg/tests/fast/arrow/test_dictionary_arrow.py\n@@ -1,27 +1,23 @@\n import duckdb\n \n-try:\n-    import pyarrow as pa\n-    import pyarrow.parquet\n-    import numpy as np\n-    from pandas import Timestamp\n-    import datetime\n-    import pandas as pd\n+import pytest\n \n-    can_run = True\n-except:\n-    can_run = False\n+pa = pytest.importorskip(\"pyarrow\")\n+pq = pytest.importorskip(\"pyarrow.parquet\")\n+np = pytest.importorskip(\"numpy\")\n+pd = pytest.importorskip(\"pandas\")\n+import datetime\n+\n+Timestamp = pd.Timestamp\n \n \n class TestArrowDictionary(object):\n     def test_dictionary(self, duckdb_cursor):\n-        if not can_run:\n-            return\n         indices = pa.array([0, 1, 0, 1, 2, 1, 0, 2])\n         dictionary = pa.array([10, 100, None])\n         dict_array = pa.DictionaryArray.from_arrays(indices, dictionary)\n         arrow_table = pa.Table.from_arrays([dict_array], ['a'])\n-        rel = duckdb.from_arrow(arrow_table)\n+        rel = duckdb_cursor.from_arrow(arrow_table)\n \n         assert rel.execute().fetchall() == [(10,), (100,), (10,), (100,), (None,), (100,), (10,), (None,)]\n \n@@ -31,25 +27,23 @@ def test_dictionary(self, duckdb_cursor):\n         dictionary = pa.array([10, 100, None, 999999])\n         dict_array = pa.DictionaryArray.from_arrays(indices, dictionary)\n         arrow_table = pa.Table.from_arrays([dict_array], ['a'])\n-        rel = duckdb.from_arrow(arrow_table)\n+        rel = duckdb_cursor.from_arrow(arrow_table)\n         result = [(10,), (100,), (10,), (100,), (None,), (100,), (10,), (None,), (999999,)] * 10000\n         assert rel.execute().fetchall() == result\n \n         # Table with dictionary and normal array\n \n         arrow_table = pa.Table.from_arrays([dict_array, pa.array(indices_list)], ['a', 'b'])\n-        rel = duckdb.from_arrow(arrow_table)\n+        rel = duckdb_cursor.from_arrow(arrow_table)\n         result = [(10, 0), (100, 1), (10, 0), (100, 1), (None, 2), (100, 1), (10, 0), (None, 2), (999999, 3)] * 10000\n         assert rel.execute().fetchall() == result\n \n     def test_dictionary_null_index(self, duckdb_cursor):\n-        if not can_run:\n-            return\n         indices = pa.array([None, 1, 0, 1, 2, 1, 0, 2])\n         dictionary = pa.array([10, 100, None])\n         dict_array = pa.DictionaryArray.from_arrays(indices, dictionary)\n         arrow_table = pa.Table.from_arrays([dict_array], ['a'])\n-        rel = duckdb.from_arrow(arrow_table)\n+        rel = duckdb_cursor.from_arrow(arrow_table)\n \n         assert rel.execute().fetchall() == [(None,), (100,), (10,), (100,), (None,), (100,), (10,), (None,)]\n \n@@ -57,7 +51,7 @@ def test_dictionary_null_index(self, duckdb_cursor):\n         dictionary = pa.array([10, 100, 100])\n         dict_array = pa.DictionaryArray.from_arrays(indices, dictionary)\n         arrow_table = pa.Table.from_arrays([dict_array], ['a'])\n-        rel = duckdb.from_arrow(arrow_table)\n+        rel = duckdb_cursor.from_arrow(arrow_table)\n         print(rel.execute().fetchall())\n         assert rel.execute().fetchall() == [(None,), (100,), (None,), (100,), (100,), (100,), (10,)]\n \n@@ -67,94 +61,147 @@ def test_dictionary_null_index(self, duckdb_cursor):\n         dictionary = pa.array([10, 100, 100])\n         dict_array = pa.DictionaryArray.from_arrays(indices, dictionary)\n         arrow_table = pa.Table.from_arrays([dict_array], ['a'])\n-        rel = duckdb.from_arrow(arrow_table)\n+        rel = duckdb_cursor.from_arrow(arrow_table)\n         result = [(None,), (100,), (None,), (100,), (100,), (100,), (10,)] * 1000\n         assert rel.execute().fetchall() == result\n \n         # Table with dictionary and normal array\n         arrow_table = pa.Table.from_arrays([dict_array, indices], ['a', 'b'])\n-        rel = duckdb.from_arrow(arrow_table)\n+        rel = duckdb_cursor.from_arrow(arrow_table)\n         result = [(None, None), (100, 1), (None, None), (100, 1), (100, 2), (100, 1), (10, 0)] * 1000\n         assert rel.execute().fetchall() == result\n \n-    def test_dictionary_batches(self, duckdb_cursor):\n-        if not can_run:\n-            return\n+    @pytest.mark.parametrize(\n+        'element',\n+        [\n+            # list\n+            \"\"\"\n+            ['hello'::ENUM('hello', 'bye')]\n+        \"\"\",\n+            # struct\n+            \"\"\"\n+            {'a': 'hello'::ENUM('hello', 'bye')}\n+        \"\"\",\n+            # union\n+            \"\"\"\n+            {'a': 'hello'::ENUM('hello', 'bye')}::UNION(a integer, b bool, c struct(a enum('hello', 'bye')))\n+        \"\"\",\n+            # map (key)\n+            \"\"\"\n+            map {'hello'::ENUM('hello', 'bye') : 'test'}\n+        \"\"\",\n+            # map (val)\n+            \"\"\"\n+            map {'test': 'hello'::ENUM('hello', 'bye')}\n+        \"\"\",\n+            # list of struct(enum)\n+            \"\"\"\n+            [{'a': 'hello'::ENUM('hello', 'bye')}]\n+        \"\"\",\n+            # list of union(enum)\n+            \"\"\"\n+            [{'a': 'hello'::ENUM('hello', 'bye')}::UNION(a integer, b bool, c struct(a enum('hello', 'bye')))]\n+        \"\"\",\n+            # list of list\n+            \"\"\"\n+            [['hello'::ENUM('hello', 'bye')], [], NULL, ['hello'::ENUM('hello', 'bye'), 'bye'::ENUM('hello', 'bye')]]\n+        \"\"\",\n+        ],\n+    )\n+    @pytest.mark.parametrize(\n+        'count',\n+        [\n+            1,\n+            10,\n+            1024,\n+            # 2048,\n+            # 2047,\n+            # 2049,\n+            # 4000,\n+            # 4096,\n+            5000,\n+        ],\n+    )\n+    @pytest.mark.parametrize('query', [\"select {} as a from range({})\", \"select [{} for x in range({})] as a\"])\n+    def test_dictionary_roundtrip(self, query, element, duckdb_cursor, count):\n+        query = query.format(element, count)\n+        original_rel = duckdb_cursor.sql(query)\n+        expected = original_rel.fetchall()\n+        arrow_res = original_rel.arrow()\n+\n+        roundtrip_rel = duckdb_cursor.sql('select * from arrow_res')\n+        actual = roundtrip_rel.fetchall()\n+        assert expected == actual\n+        assert original_rel.columns == roundtrip_rel.columns\n+        # Note: we can't check the types, because originally these are ENUM\n+        # but because the dictionary of the ENUM can not be known before execution we output VARCHAR instead.\n \n+    def test_dictionary_batches(self, duckdb_cursor):\n         indices_list = [None, 1, None, 1, 2, 1, 0]\n         indices = pa.array(indices_list * 10000)\n         dictionary = pa.array([10, 100, 100])\n         dict_array = pa.DictionaryArray.from_arrays(indices, dictionary)\n         arrow_table = pa.Table.from_arrays([dict_array], ['a'])\n-        batch_arrow_table = pyarrow.Table.from_batches(arrow_table.to_batches(10))\n-        rel = duckdb.from_arrow(batch_arrow_table)\n+        batch_arrow_table = pa.Table.from_batches(arrow_table.to_batches(10))\n+        rel = duckdb_cursor.from_arrow(batch_arrow_table)\n         result = [(None,), (100,), (None,), (100,), (100,), (100,), (10,)] * 10000\n         assert rel.execute().fetchall() == result\n \n         # Table with dictionary and normal array\n         arrow_table = pa.Table.from_arrays([dict_array, indices], ['a', 'b'])\n-        batch_arrow_table = pyarrow.Table.from_batches(arrow_table.to_batches(10))\n-        rel = duckdb.from_arrow(batch_arrow_table)\n+        batch_arrow_table = pa.Table.from_batches(arrow_table.to_batches(10))\n+        rel = duckdb_cursor.from_arrow(batch_arrow_table)\n         result = [(None, None), (100, 1), (None, None), (100, 1), (100, 2), (100, 1), (10, 0)] * 10000\n         assert rel.execute().fetchall() == result\n \n     def test_dictionary_batches_parallel(self, duckdb_cursor):\n-        if not can_run:\n-            return\n-\n-        duckdb_conn = duckdb.connect()\n-        duckdb_conn.execute(\"PRAGMA threads=4\")\n-        duckdb_conn.execute(\"PRAGMA verify_parallelism\")\n+        duckdb_cursor.execute(\"PRAGMA threads=4\")\n+        duckdb_cursor.execute(\"PRAGMA verify_parallelism\")\n \n         indices_list = [None, 1, None, 1, 2, 1, 0]\n         indices = pa.array(indices_list * 10000)\n         dictionary = pa.array([10, 100, 100])\n         dict_array = pa.DictionaryArray.from_arrays(indices, dictionary)\n         arrow_table = pa.Table.from_arrays([dict_array], ['a'])\n-        batch_arrow_table = pyarrow.Table.from_batches(arrow_table.to_batches(10))\n-        rel = duckdb_conn.from_arrow(batch_arrow_table)\n+        batch_arrow_table = pa.Table.from_batches(arrow_table.to_batches(10))\n+        rel = duckdb_cursor.from_arrow(batch_arrow_table)\n         result = [(None,), (100,), (None,), (100,), (100,), (100,), (10,)] * 10000\n         assert rel.execute().fetchall() == result\n \n         # Table with dictionary and normal array\n         arrow_table = pa.Table.from_arrays([dict_array, indices], ['a', 'b'])\n-        batch_arrow_table = pyarrow.Table.from_batches(arrow_table.to_batches(10))\n-        rel = duckdb_conn.from_arrow(batch_arrow_table)\n+        batch_arrow_table = pa.Table.from_batches(arrow_table.to_batches(10))\n+        rel = duckdb_cursor.from_arrow(batch_arrow_table)\n         result = [(None, None), (100, 1), (None, None), (100, 1), (100, 2), (100, 1), (10, 0)] * 10000\n         assert rel.execute().fetchall() == result\n \n     def test_dictionary_index_types(self, duckdb_cursor):\n-        if not can_run:\n-            return\n         indices_list = [None, 1, None, 1, 2, 1, 0]\n-        dictionary = pa.array([10, 100, 100], type=pyarrow.uint8())\n+        dictionary = pa.array([10, 100, 100], type=pa.uint8())\n         index_types = []\n-        index_types.append(pa.array(indices_list * 10000, type=pyarrow.uint8()))\n-        index_types.append(pa.array(indices_list * 10000, type=pyarrow.uint16()))\n-        index_types.append(pa.array(indices_list * 10000, type=pyarrow.uint32()))\n-        index_types.append(pa.array(indices_list * 10000, type=pyarrow.uint64()))\n-        index_types.append(pa.array(indices_list * 10000, type=pyarrow.int8()))\n-        index_types.append(pa.array(indices_list * 10000, type=pyarrow.int16()))\n-        index_types.append(pa.array(indices_list * 10000, type=pyarrow.int32()))\n-        index_types.append(pa.array(indices_list * 10000, type=pyarrow.int64()))\n+        index_types.append(pa.array(indices_list * 10000, type=pa.uint8()))\n+        index_types.append(pa.array(indices_list * 10000, type=pa.uint16()))\n+        index_types.append(pa.array(indices_list * 10000, type=pa.uint32()))\n+        index_types.append(pa.array(indices_list * 10000, type=pa.uint64()))\n+        index_types.append(pa.array(indices_list * 10000, type=pa.int8()))\n+        index_types.append(pa.array(indices_list * 10000, type=pa.int16()))\n+        index_types.append(pa.array(indices_list * 10000, type=pa.int32()))\n+        index_types.append(pa.array(indices_list * 10000, type=pa.int64()))\n \n         for index_type in index_types:\n             dict_array = pa.DictionaryArray.from_arrays(index_type, dictionary)\n             arrow_table = pa.Table.from_arrays([dict_array], ['a'])\n-            rel = duckdb.from_arrow(arrow_table)\n+            rel = duckdb_cursor.from_arrow(arrow_table)\n             result = [(None,), (100,), (None,), (100,), (100,), (100,), (10,)] * 10000\n             assert rel.execute().fetchall() == result\n \n     def test_dictionary_strings(self, duckdb_cursor):\n-        if not can_run:\n-            return\n-\n         indices_list = [None, 0, 1, 2, 3, 4, None]\n         indices = pa.array(indices_list * 1000)\n         dictionary = pa.array(['Matt Daaaaaaaaamon', 'Alec Baldwin', 'Sean Penn', 'Tim Robbins', 'Samuel L. Jackson'])\n         dict_array = pa.DictionaryArray.from_arrays(indices, dictionary)\n         arrow_table = pa.Table.from_arrays([dict_array], ['a'])\n-        rel = duckdb.from_arrow(arrow_table)\n+        rel = duckdb_cursor.from_arrow(arrow_table)\n         result = [\n             (None,),\n             ('Matt Daaaaaaaaamon',),\n@@ -167,8 +214,6 @@ def test_dictionary_strings(self, duckdb_cursor):\n         assert rel.execute().fetchall() == result\n \n     def test_dictionary_timestamps(self, duckdb_cursor):\n-        if not can_run:\n-            return\n         indices_list = [None, 0, 1, 2, None]\n         indices = pa.array(indices_list * 1000)\n         dictionary = pa.array(\n@@ -181,7 +226,7 @@ def test_dictionary_timestamps(self, duckdb_cursor):\n         )\n         dict_array = pa.DictionaryArray.from_arrays(indices, dictionary)\n         arrow_table = pa.Table.from_arrays([dict_array], ['a'])\n-        rel = duckdb.from_arrow(arrow_table)\n+        rel = duckdb_cursor.from_arrow(arrow_table)\n         print(rel.execute().fetchall())\n         expected = [\n             (None,),\n",
  "problem_statement": "Nested dictionary in Arrow integration\n### What happens?\n\nI have a computer vision dataset where each row corresponds to an image. One of the columns a list of detected object labels (arrow type: list<dict<int, str>>). If I run a label distribution query on it, the output are the integer indices rather than the str values. This is different from duckdb's output if the dict column is not nested.\n\n### To Reproduce\n\n```python\r\nimport pyarrow as pa\r\nimport duckdb\r\nimport pandas as pd\r\n\r\nvalues = pa.DictionaryArray.from_pandas(pd.Categorical(['dog', 'cat', 'horse'], categories=['cat', 'dog', 'horse']))\r\narr = pa.ListArray.from_arrays([0,1], values)\r\ntbl = pa.Table.from_arrays([arr], names=[\"list_of_dict\"])\r\n\r\nduckdb.query(\"\"\"\\\r\nSELECT label, COUNT(1) FROM (\r\n    SELECT UNNEST(list_of_dict) as label FROM tbl\r\n) GROUP BY 1\r\n\"\"\").to_df()\r\n```\r\n\r\nOutput:\r\n```\r\nOut[31]: \r\n   label  count(1)\r\n0      1         1\r\n```\r\n\n\n### OS:\n\nubuntu 22.04\n\n### DuckDB Version:\n\n0.5\n\n### DuckDB Client:\n\npython\n\n### Full Name:\n\nChang She\n\n### Affiliation:\n\nLance project\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "If you create a non-nested dictionary column then it works as expected:\r\n\r\n```\r\nIn [33]: tbl = pa.Table.from_arrays([values], names=[\"plain_dict\"])\r\n\r\nIn [34]: tbl\r\nOut[34]: \r\npyarrow.Table\r\nplain_dict: dictionary<values=string, indices=int8, ordered=0>\r\n----\r\nplain_dict: [  -- dictionary:\r\n[\"cat\",\"dog\",\"horse\"]  -- indices:\r\n[1,0,2]]\r\n\r\nIn [35]: duckdb.query(\"\"\"\\\r\n    ...: SELECT plain_dict, COUNT(1) FROM tbl GROUP BY 1\r\n    ...: \"\"\").to_df()\r\nOut[35]: \r\n  plain_dict  count(1)\r\n0        dog         1\r\n1        cat         1\r\n2      horse         1\r\n```\nThe main impact of the problem is that you can't filter it using the string value\nI just ran into this too. I am going to attempt to fix it. I _think_ the issue is the [check for dictionaries here](https://github.com/duckdb/duckdb/blob/e413e0b40dd788622f17d8223c4fea931bccd6cc/src/function/table/arrow.cpp#L207) does not get run when [recursing for nested types like we do here](https://github.com/duckdb/duckdb/blob/e413e0b40dd788622f17d8223c4fea931bccd6cc/src/function/table/arrow.cpp#L113)?\nThis issue is stale because it has been open 90 days with no activity. Remove stale label or comment or this will be closed in 30 days.\nThis issue was closed because it has been stale for 30 days with no activity.\nThis is still an issue\r\n```\r\n(lldb) p *schema.children[0]\r\n(ArrowSchema) $4 = {\r\n  format = 0x0000029220040380 \"c\"\r\n  name = 0x0000029220040398 \"item\"\r\n  metadata = 0x0000000000000000\r\n  flags = 2\r\n  n_children = 0\r\n  children = nullptr\r\n  dictionary = 0x00000292200403c8\r\n  release = 0x0000000110bd0f90 (libarrow.1200.dylib`arrow::(anonymous namespace)::ReleaseExportedSchema(ArrowSchema*))\r\n  private_data = 0x0000029220040380\r\n```\r\n\r\nThis is what the schema of the child of the list looks like\r\nwe ignore the dictionary currently.",
  "created_at": "2023-10-12T18:22:25Z"
}