diff --git a/benchmark/dbwrapper/sqlite_benchmark.cpp b/benchmark/dbwrapper/sqlite_benchmark.cpp
index 016693d3e120..863b3b20483a 100644
--- a/benchmark/dbwrapper/sqlite_benchmark.cpp
+++ b/benchmark/dbwrapper/sqlite_benchmark.cpp
@@ -39,6 +39,9 @@ void SQLiteBenchmark::Cleanup(BenchmarkState *state_) {
 
 string SQLiteBenchmark::Verify(BenchmarkState *state_) {
 	auto state = (SQLiteBenchmarkState *)state_;
+	if (!state->result) {
+		return "No result!";
+	}
 	return duckdb_benchmark->VerifyResult(state->result.get());
 }
 
diff --git a/src/function/aggregate/distributive/first.cpp b/src/function/aggregate/distributive/first.cpp
index a6de3824c2ce..68dff453ff42 100644
--- a/src/function/aggregate/distributive/first.cpp
+++ b/src/function/aggregate/distributive/first.cpp
@@ -12,11 +12,23 @@ template <class T> struct FirstState {
 	T value;
 };
 
-struct FirstFunction {
+struct FirstFunctionBase {
 	template <class STATE> static void Initialize(STATE *state) {
 		state->is_set = false;
 	}
 
+	template <class STATE, class OP> static void Combine(STATE source, STATE *target) {
+		if (!target->is_set) {
+			*target = source;
+		}
+	}
+
+	static bool IgnoreNull() {
+		return false;
+	}
+};
+
+struct FirstFunction : public FirstFunctionBase {
 	template <class INPUT_TYPE, class STATE, class OP>
 	static void Operation(STATE *state, INPUT_TYPE *input, nullmask_t &nullmask, idx_t idx) {
 		if (!state->is_set) {
@@ -34,23 +46,56 @@ struct FirstFunction {
 		Operation<INPUT_TYPE, STATE, OP>(state, input, nullmask, 0);
 	}
 
-	template <class STATE, class OP> static void Combine(STATE source, STATE *target) {
-		if (!target->is_set) {
-			*target = source;
+	template <class T, class STATE>
+	static void Finalize(Vector &result, STATE *state, T *target, nullmask_t &nullmask, idx_t idx) {
+		if (!state->is_set || IsNullValue<T>(state->value)) {
+			nullmask[idx] = true;
+		} else {
+			target[idx] = state->value;
+		}
+	}
+};
+
+struct FirstFunctionString : public FirstFunctionBase {
+	template <class INPUT_TYPE, class STATE, class OP>
+	static void Operation(STATE *state, INPUT_TYPE *input, nullmask_t &nullmask, idx_t idx) {
+		if (!state->is_set) {
+			state->is_set = true;
+			if (nullmask[idx]) {
+				state->value = NullValue<INPUT_TYPE>();
+			} else {
+				if (input[idx].IsInlined()) {
+					state->value = input[idx];
+				} else {
+					// non-inlined string, need to allocate space for it
+					auto len = input[idx].GetSize();
+					auto ptr = new char[len + 1];
+					memcpy(ptr, input[idx].GetData(), len + 1);
+
+					state->value = string_t(ptr, len);
+				}
+			}
 		}
 	}
 
+	template <class INPUT_TYPE, class STATE, class OP>
+	static void ConstantOperation(STATE *state, INPUT_TYPE *input, nullmask_t &nullmask, idx_t count) {
+		Operation<INPUT_TYPE, STATE, OP>(state, input, nullmask, 0);
+	}
+
 	template <class T, class STATE>
 	static void Finalize(Vector &result, STATE *state, T *target, nullmask_t &nullmask, idx_t idx) {
 		if (!state->is_set || IsNullValue<T>(state->value)) {
 			nullmask[idx] = true;
 		} else {
-			target[idx] = state->value;
+			target[idx] = StringVector::AddString(result, state->value);
 		}
 	}
 
-	static bool IgnoreNull() {
-		return false;
+	template <class STATE> static void Destroy(STATE *state) {
+		if (state->is_set && !state->value.IsInlined()) {
+			delete[] state->value.GetData();
+		}
 	}
 };
 
@@ -81,7 +126,7 @@ AggregateFunction FirstFun::GetFunction(SQLType type) {
 	case SQLTypeId::TIMESTAMP:
 		return GetFirstAggregateTemplated<timestamp_t>(type);
 	case SQLTypeId::VARCHAR:
-		return GetFirstAggregateTemplated<string_t>(type);
+		return AggregateFunction::UnaryAggregateDestructor<FirstState<string_t>, string_t, string_t, FirstFunctionString>(type, type);
 	default:
 		throw NotImplementedException("Unimplemented type for FIRST aggregate");
 	}
diff --git a/src/main/client_context.cpp b/src/main/client_context.cpp
index 58f61b403184..f08f17999b79 100644
--- a/src/main/client_context.cpp
+++ b/src/main/client_context.cpp
@@ -458,7 +458,10 @@ void ClientContext::Invalidate() {
 	if (open_result) {
 		open_result->is_open = false;
 	}
-	// and close any open appenders
+	// and close any open appenders and prepared statements
+	for (auto &statement : prepared_statement_objects) {
+		statement->is_invalidated = true;
+	}
 	for (auto &appender : appenders) {
 		appender->Invalidate("Database that this appender belongs to has been closed!", false);
 	}
diff --git a/tools/dbtransfer/sqlite_transfer.cpp b/tools/dbtransfer/sqlite_transfer.cpp
index 7412ae26f172..c4d2a4fea875 100644
--- a/tools/dbtransfer/sqlite_transfer.cpp
+++ b/tools/dbtransfer/sqlite_transfer.cpp
@@ -114,10 +114,13 @@ bool TransferDatabase(Connection &con, sqlite3 *sqlite) {
 
 unique_ptr<QueryResult> QueryDatabase(vector<SQLType> result_types, sqlite3 *sqlite, std::string query,
                                       volatile int &interrupt) {
+	if (!sqlite) {
+		return nullptr;
+	}
 	// prepare the SQL statement
 	sqlite3_stmt *stmt;
 	if (sqlite3_prepare_v2(sqlite, query.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {
-		return nullptr;
+		return make_unique<MaterializedQueryResult>(sqlite3_errmsg(sqlite));
 	}
 	int col_count = sqlite3_column_count(stmt);
 	vector<string> names;
