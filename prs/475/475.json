{
  "repo": "duckdb/duckdb",
  "pull_number": 475,
  "instance_id": "duckdb__duckdb-475",
  "issue_numbers": [
    "470"
  ],
  "base_commit": "17b18ef5a69b1965ddb25e015c8cc13cc6a940b8",
  "patch": "diff --git a/benchmark/dbwrapper/sqlite_benchmark.cpp b/benchmark/dbwrapper/sqlite_benchmark.cpp\nindex 016693d3e120..863b3b20483a 100644\n--- a/benchmark/dbwrapper/sqlite_benchmark.cpp\n+++ b/benchmark/dbwrapper/sqlite_benchmark.cpp\n@@ -39,6 +39,9 @@ void SQLiteBenchmark::Cleanup(BenchmarkState *state_) {\n \n string SQLiteBenchmark::Verify(BenchmarkState *state_) {\n \tauto state = (SQLiteBenchmarkState *)state_;\n+\tif (!state->result) {\n+\t\treturn \"No result!\";\n+\t}\n \treturn duckdb_benchmark->VerifyResult(state->result.get());\n }\n \ndiff --git a/src/function/aggregate/distributive/first.cpp b/src/function/aggregate/distributive/first.cpp\nindex a6de3824c2ce..68dff453ff42 100644\n--- a/src/function/aggregate/distributive/first.cpp\n+++ b/src/function/aggregate/distributive/first.cpp\n@@ -12,11 +12,23 @@ template <class T> struct FirstState {\n \tT value;\n };\n \n-struct FirstFunction {\n+struct FirstFunctionBase {\n \ttemplate <class STATE> static void Initialize(STATE *state) {\n \t\tstate->is_set = false;\n \t}\n \n+\ttemplate <class STATE, class OP> static void Combine(STATE source, STATE *target) {\n+\t\tif (!target->is_set) {\n+\t\t\t*target = source;\n+\t\t}\n+\t}\n+\n+\tstatic bool IgnoreNull() {\n+\t\treturn false;\n+\t}\n+};\n+\n+struct FirstFunction : public FirstFunctionBase {\n \ttemplate <class INPUT_TYPE, class STATE, class OP>\n \tstatic void Operation(STATE *state, INPUT_TYPE *input, nullmask_t &nullmask, idx_t idx) {\n \t\tif (!state->is_set) {\n@@ -34,23 +46,56 @@ struct FirstFunction {\n \t\tOperation<INPUT_TYPE, STATE, OP>(state, input, nullmask, 0);\n \t}\n \n-\ttemplate <class STATE, class OP> static void Combine(STATE source, STATE *target) {\n-\t\tif (!target->is_set) {\n-\t\t\t*target = source;\n+\ttemplate <class T, class STATE>\n+\tstatic void Finalize(Vector &result, STATE *state, T *target, nullmask_t &nullmask, idx_t idx) {\n+\t\tif (!state->is_set || IsNullValue<T>(state->value)) {\n+\t\t\tnullmask[idx] = true;\n+\t\t} else {\n+\t\t\ttarget[idx] = state->value;\n+\t\t}\n+\t}\n+};\n+\n+struct FirstFunctionString : public FirstFunctionBase {\n+\ttemplate <class INPUT_TYPE, class STATE, class OP>\n+\tstatic void Operation(STATE *state, INPUT_TYPE *input, nullmask_t &nullmask, idx_t idx) {\n+\t\tif (!state->is_set) {\n+\t\t\tstate->is_set = true;\n+\t\t\tif (nullmask[idx]) {\n+\t\t\t\tstate->value = NullValue<INPUT_TYPE>();\n+\t\t\t} else {\n+\t\t\t\tif (input[idx].IsInlined()) {\n+\t\t\t\t\tstate->value = input[idx];\n+\t\t\t\t} else {\n+\t\t\t\t\t// non-inlined string, need to allocate space for it\n+\t\t\t\t\tauto len = input[idx].GetSize();\n+\t\t\t\t\tauto ptr = new char[len + 1];\n+\t\t\t\t\tmemcpy(ptr, input[idx].GetData(), len + 1);\n+\n+\t\t\t\t\tstate->value = string_t(ptr, len);\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t}\n \n+\ttemplate <class INPUT_TYPE, class STATE, class OP>\n+\tstatic void ConstantOperation(STATE *state, INPUT_TYPE *input, nullmask_t &nullmask, idx_t count) {\n+\t\tOperation<INPUT_TYPE, STATE, OP>(state, input, nullmask, 0);\n+\t}\n+\n \ttemplate <class T, class STATE>\n \tstatic void Finalize(Vector &result, STATE *state, T *target, nullmask_t &nullmask, idx_t idx) {\n \t\tif (!state->is_set || IsNullValue<T>(state->value)) {\n \t\t\tnullmask[idx] = true;\n \t\t} else {\n-\t\t\ttarget[idx] = state->value;\n+\t\t\ttarget[idx] = StringVector::AddString(result, state->value);\n \t\t}\n \t}\n \n-\tstatic bool IgnoreNull() {\n-\t\treturn false;\n+\ttemplate <class STATE> static void Destroy(STATE *state) {\n+\t\tif (state->is_set && !state->value.IsInlined()) {\n+\t\t\tdelete[] state->value.GetData();\n+\t\t}\n \t}\n };\n \n@@ -81,7 +126,7 @@ AggregateFunction FirstFun::GetFunction(SQLType type) {\n \tcase SQLTypeId::TIMESTAMP:\n \t\treturn GetFirstAggregateTemplated<timestamp_t>(type);\n \tcase SQLTypeId::VARCHAR:\n-\t\treturn GetFirstAggregateTemplated<string_t>(type);\n+\t\treturn AggregateFunction::UnaryAggregateDestructor<FirstState<string_t>, string_t, string_t, FirstFunctionString>(type, type);\n \tdefault:\n \t\tthrow NotImplementedException(\"Unimplemented type for FIRST aggregate\");\n \t}\ndiff --git a/src/main/client_context.cpp b/src/main/client_context.cpp\nindex 58f61b403184..f08f17999b79 100644\n--- a/src/main/client_context.cpp\n+++ b/src/main/client_context.cpp\n@@ -458,7 +458,10 @@ void ClientContext::Invalidate() {\n \tif (open_result) {\n \t\topen_result->is_open = false;\n \t}\n-\t// and close any open appenders\n+\t// and close any open appenders and prepared statements\n+\tfor (auto &statement : prepared_statement_objects) {\n+\t\tstatement->is_invalidated = true;\n+\t}\n \tfor (auto &appender : appenders) {\n \t\tappender->Invalidate(\"Database that this appender belongs to has been closed!\", false);\n \t}\ndiff --git a/tools/dbtransfer/sqlite_transfer.cpp b/tools/dbtransfer/sqlite_transfer.cpp\nindex 7412ae26f172..c4d2a4fea875 100644\n--- a/tools/dbtransfer/sqlite_transfer.cpp\n+++ b/tools/dbtransfer/sqlite_transfer.cpp\n@@ -114,10 +114,13 @@ bool TransferDatabase(Connection &con, sqlite3 *sqlite) {\n \n unique_ptr<QueryResult> QueryDatabase(vector<SQLType> result_types, sqlite3 *sqlite, std::string query,\n                                       volatile int &interrupt) {\n+\tif (!sqlite) {\n+\t\treturn nullptr;\n+\t}\n \t// prepare the SQL statement\n \tsqlite3_stmt *stmt;\n \tif (sqlite3_prepare_v2(sqlite, query.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {\n-\t\treturn nullptr;\n+\t\treturn make_unique<MaterializedQueryResult>(sqlite3_errmsg(sqlite));\n \t}\n \tint col_count = sqlite3_column_count(stmt);\n \tvector<string> names;\n",
  "test_patch": "diff --git a/test/api/test_api.cpp b/test/api/test_api.cpp\nindex e11567facc6c..6646fcd6a9a4 100644\n--- a/test/api/test_api.cpp\n+++ b/test/api/test_api.cpp\n@@ -95,6 +95,19 @@ TEST_CASE(\"Test closing result after database is gone\", \"[api]\") {\n \tstreaming_result.reset();\n }\n \n+TEST_CASE(\"Test closing database with open prepared statements\", \"[api]\") {\n+\tauto db = make_unique<DuckDB>(nullptr);\n+\tauto conn = make_unique<Connection>(*db);\n+\n+\tauto p1 = conn->Prepare(\"CREATE TABLE a (i INTEGER)\");\n+\tp1->Execute();\n+\tauto p2 = conn->Prepare(\"INSERT INTO a VALUES (42)\");\n+\tp2->Execute();\n+\n+\tdb.reset();\n+\tconn.reset();\n+}\n+\n static void parallel_query(Connection *conn, bool *correct, size_t threadnr) {\n \tcorrect[threadnr] = true;\n \tfor (size_t i = 0; i < 100; i++) {\ndiff --git a/test/sql/aggregate/test_aggregate.cpp b/test/sql/aggregate/test_aggregate.cpp\nindex c3542b35bac9..04d672fc8b01 100644\n--- a/test/sql/aggregate/test_aggregate.cpp\n+++ b/test/sql/aggregate/test_aggregate.cpp\n@@ -392,3 +392,23 @@ TEST_CASE(\"Test GROUP BY with many groups\", \"[aggregate][.]\") {\n \tREQUIRE(CHECK_COLUMN(result, 0, {49995000}));\n \tREQUIRE(CHECK_COLUMN(result, 1, {30000}));\n }\n+\n+TEST_CASE(\"Test FIRST with non-inlined strings\", \"[aggregate]\") {\n+\tunique_ptr<QueryResult> result;\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE tbl(a INTEGER, b VARCHAR)\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"INSERT INTO tbl VALUES (1, NULL), (2, 'thisisalongstring'), (3, 'thisisalsoalongstring')\"));\n+\n+\t// non-grouped aggregate\n+\tresult = con.Query(\"SELECT FIRST(b) FROM tbl WHERE a=2\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {\"thisisalongstring\"}));\n+\tresult = con.Query(\"SELECT FIRST(b) FROM tbl WHERE a=1\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {Value()}));\n+\n+\t// grouped aggregate\n+\tresult = con.Query(\"SELECT a, FIRST(b) FROM tbl GROUP BY a ORDER BY a\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {1, 2, 3}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {Value(), \"thisisalongstring\", \"thisisalsoalongstring\"}));\n+}\n",
  "problem_statement": "Benchmark Runner without parameters\nThe Benchmark Runner crashes while running without parameters (e.g.  ./benchmark_runner), a segmentation fault happens in some sqlite tests, for example: sqlite_StringAggShort and sqlite_StringPrefix.\r\n\r\nFollows an output of the Valgrind:\r\n\r\n-------------------------\r\n|| sqlite_StringPrefix ||\r\n-------------------------\r\nCold run...DONE\r\n1/5...==25043== Invalid read of size 1\r\n==25043==    at 0x4A1030: StringPrefixBenchmark::VerifyResult(duckdb::QueryResult*) (in /home/tkepe/git/duckdb/build/release/benchmark/benchmark_runner)\r\n==25043==    by 0x49B4A4: duckdb::SQLiteBenchmark::Verify(duckdb::BenchmarkState*) (in /home/tkepe/git/duckdb/build/release/benchmark/benchmark_runner)\r\n==25043==    by 0x45C6CD: duckdb::BenchmarkRunner::RunBenchmark(duckdb::Benchmark*) (in /home/tkepe/git/duckdb/build/release/benchmark/benchmark_runner)\r\n==25043==    by 0x45CBCE: duckdb::BenchmarkRunner::RunBenchmarks() (in /home/tkepe/git/duckdb/build/release/benchmark/benchmark_runner)\r\n==25043==    by 0x461B6D: run_benchmarks(BenchmarkConfiguration const&) (in /home/tkepe/git/duckdb/build/release/benchmark/benchmark_runner)\r\n==25043==    by 0x44C8DE: main (in /home/tkepe/git/duckdb/build/release/benchmark/benchmark_runner)\r\n==25043==  Address 0x58 is not stack'd, malloc'd or (recently) free'd\r\n==25043== \r\n==25043== \r\n==25043== Process terminating with default action of signal 11 (SIGSEGV)\r\n==25043==  Access not within mapped region at address 0x58\r\n==25043==    at 0x4A1030: StringPrefixBenchmark::VerifyResult(duckdb::QueryResult*) (in /home/tkepe/git/duckdb/build/release/benchmark/benchmark_runner)\r\n==25043==    by 0x49B4A4: duckdb::SQLiteBenchmark::Verify(duckdb::BenchmarkState*) (in /home/tkepe/git/duckdb/build/release/benchmark/benchmark_runner)\r\n==25043==    by 0x45C6CD: duckdb::BenchmarkRunner::RunBenchmark(duckdb::Benchmark*) (in /home/tkepe/git/duckdb/build/release/benchmark/benchmark_runner)\r\n==25043==    by 0x45CBCE: duckdb::BenchmarkRunner::RunBenchmarks() (in /home/tkepe/git/duckdb/build/release/benchmark/benchmark_runner)\r\n==25043==    by 0x461B6D: run_benchmarks(BenchmarkConfiguration const&) (in /home/tkepe/git/duckdb/build/release/benchmark/benchmark_runner)\r\n==25043==    by 0x44C8DE: main (in /home/tkepe/git/duckdb/build/release/benchmark/benchmark_runner)\r\n==25043==  If you believe this happened as a result of a stack\r\n==25043==  overflow in your program's main thread (unlikely but\r\n==25043==  possible), you can try to increase the size of the\r\n==25043==  main thread stack using the --main-stacksize= flag.\r\n==25043==  The main thread stack size used in this run was 8388608.\r\n==25043== \r\n==25043== HEAP SUMMARY:\r\n==25043==     in use at exit: 1,954,037 bytes in 528 blocks\r\n==25043==   total heap usage: 3,043,022 allocs, 3,042,494 frees, 176,662,345 bytes allocated\r\n==25043== \r\n==25043== LEAK SUMMARY:\r\n==25043==    definitely lost: 0 bytes in 0 blocks\r\n==25043==    indirectly lost: 0 bytes in 0 blocks\r\n==25043==      possibly lost: 1,816,824 bytes in 416 blocks\r\n==25043==    still reachable: 137,213 bytes in 112 blocks\r\n==25043==                       of which reachable via heuristic:\r\n==25043==                         stdstring          : 1,605 bytes in 41 blocks\r\n==25043==                         length64           : 132,816 bytes in 47 blocks\r\n==25043==         suppressed: 0 bytes in 0 blocks\r\n==25043== Rerun with --leak-check=full to see details of leaked memory\r\n==25043== \r\n==25043== For counts of detected and suppressed errors, rerun with: -v\r\n==25043== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\n",
  "hints_text": "",
  "created_at": "2020-03-27T09:58:21Z"
}