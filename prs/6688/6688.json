{
  "repo": "duckdb/duckdb",
  "pull_number": 6688,
  "instance_id": "duckdb__duckdb-6688",
  "issue_numbers": [
    "6676",
    "6677"
  ],
  "base_commit": "6525767cf115f7996eaab67641a5eae3a41ab2fd",
  "patch": "diff --git a/extension/json/include/json_functions.hpp b/extension/json/include/json_functions.hpp\nindex 0c29fe6ba60e..5e065323914d 100644\n--- a/extension/json/include/json_functions.hpp\n+++ b/extension/json/include/json_functions.hpp\n@@ -54,6 +54,7 @@ struct JSONReadManyFunctionData : public FunctionData {\n \n struct JSONFunctionLocalState : public FunctionLocalState {\n public:\n+\texplicit JSONFunctionLocalState(Allocator &allocator);\n \texplicit JSONFunctionLocalState(ClientContext &context);\n \tstatic unique_ptr<FunctionLocalState> Init(ExpressionState &state, const BoundFunctionExpression &expr,\n \t                                           FunctionData *bind_data);\ndiff --git a/extension/json/json_functions.cpp b/extension/json/json_functions.cpp\nindex ff4e73c9e2a3..08ff7adf4cb8 100644\n--- a/extension/json/json_functions.cpp\n+++ b/extension/json/json_functions.cpp\n@@ -103,7 +103,10 @@ unique_ptr<FunctionData> JSONReadManyFunctionData::Bind(ClientContext &context,\n \treturn make_unique<JSONReadManyFunctionData>(std::move(paths), std::move(lens));\n }\n \n-JSONFunctionLocalState::JSONFunctionLocalState(ClientContext &context) : json_allocator(BufferAllocator::Get(context)) {\n+JSONFunctionLocalState::JSONFunctionLocalState(Allocator &allocator) : json_allocator(allocator) {\n+}\n+JSONFunctionLocalState::JSONFunctionLocalState(ClientContext &context)\n+    : JSONFunctionLocalState(BufferAllocator::Get(context)) {\n }\n \n unique_ptr<FunctionLocalState> JSONFunctionLocalState::Init(ExpressionState &state, const BoundFunctionExpression &expr,\n@@ -184,8 +187,12 @@ unique_ptr<TableRef> JSONFunctions::ReadJSONReplacement(ClientContext &context,\n \treturn std::move(table_function);\n }\n \n-static unique_ptr<FunctionLocalState> InitJSONCastLocalState(ClientContext &context) {\n-\treturn make_unique<JSONFunctionLocalState>(context);\n+static unique_ptr<FunctionLocalState> InitJSONCastLocalState(CastLocalStateParameters &parameters) {\n+\tif (parameters.context) {\n+\t\treturn make_unique<JSONFunctionLocalState>(*parameters.context);\n+\t} else {\n+\t\treturn make_unique<JSONFunctionLocalState>(Allocator::DefaultAllocator());\n+\t}\n }\n \n static bool CastVarcharToJSON(Vector &source, Vector &result, idx_t count, CastParameters &parameters) {\n@@ -208,9 +215,9 @@ static bool CastVarcharToJSON(Vector &source, Vector &result, idx_t count, CastP\n \t\t\t    mask.SetInvalid(idx);\n \t\t\t    success = false;\n \t\t    }\n-\n \t\t    return input;\n \t    });\n+\tresult.Reinterpret(source);\n \treturn success;\n }\n \ndiff --git a/src/common/vector_operations/vector_cast.cpp b/src/common/vector_operations/vector_cast.cpp\nindex b5505c105576..3893f74a458c 100644\n--- a/src/common/vector_operations/vector_cast.cpp\n+++ b/src/common/vector_operations/vector_cast.cpp\n@@ -11,7 +11,8 @@ bool VectorOperations::TryCast(CastFunctionSet &set, GetCastFunctionInput &input\n \tauto cast_function = set.GetCastFunction(source.GetType(), result.GetType(), input);\n \tunique_ptr<FunctionLocalState> local_state;\n \tif (cast_function.init_local_state) {\n-\t\tlocal_state = cast_function.init_local_state(*input.context);\n+\t\tCastLocalStateParameters lparameters(input.context, cast_function.cast_data);\n+\t\tlocal_state = cast_function.init_local_state(lparameters);\n \t}\n \tCastParameters parameters(cast_function.cast_data.get(), strict, error_message, local_state.get());\n \treturn cast_function.function(source, result, count, parameters);\ndiff --git a/src/execution/expression_executor/execute_cast.cpp b/src/execution/expression_executor/execute_cast.cpp\nindex c370736d648f..35dc72b088a3 100644\n--- a/src/execution/expression_executor/execute_cast.cpp\n+++ b/src/execution/expression_executor/execute_cast.cpp\n@@ -11,7 +11,8 @@ unique_ptr<ExpressionState> ExpressionExecutor::InitializeState(const BoundCastE\n \tresult->AddChild(expr.child.get());\n \tresult->Finalize();\n \tif (expr.bound_cast.init_local_state) {\n-\t\tresult->local_state = expr.bound_cast.init_local_state(root.executor->GetContext());\n+\t\tCastLocalStateParameters parameters(root.executor->GetContext(), expr.bound_cast.cast_data);\n+\t\tresult->local_state = expr.bound_cast.init_local_state(parameters);\n \t}\n \treturn std::move(result);\n }\ndiff --git a/src/function/cast/cast_function_set.cpp b/src/function/cast/cast_function_set.cpp\nindex 333182c7cf80..7b0b6b9db240 100644\n--- a/src/function/cast/cast_function_set.cpp\n+++ b/src/function/cast/cast_function_set.cpp\n@@ -6,7 +6,7 @@\n \n namespace duckdb {\n \n-BindCastInput::BindCastInput(CastFunctionSet &function_set, BindCastInfo *info, ClientContext *context)\n+BindCastInput::BindCastInput(CastFunctionSet &function_set, BindCastInfo *info, optional_ptr<ClientContext> context)\n     : function_set(function_set), info(info), context(context) {\n }\n \ndiff --git a/src/function/cast/enum_casts.cpp b/src/function/cast/enum_casts.cpp\nindex 749c89406701..dfc772166010 100644\n--- a/src/function/cast/enum_casts.cpp\n+++ b/src/function/cast/enum_casts.cpp\n@@ -109,17 +109,39 @@ unique_ptr<BoundCastData> BindEnumCast(BindCastInput &input, const LogicalType &\n \treturn make_unique<EnumBoundCastData>(std::move(to_varchar_cast), std::move(from_varchar_cast));\n }\n \n+struct EnumCastLocalState : public FunctionLocalState {\n+public:\n+\tunique_ptr<FunctionLocalState> to_varchar_local;\n+\tunique_ptr<FunctionLocalState> from_varchar_local;\n+};\n+\n+static unique_ptr<FunctionLocalState> InitEnumCastLocalState(CastLocalStateParameters &parameters) {\n+\tauto &cast_data = (EnumBoundCastData &)*parameters.cast_data;\n+\tauto result = make_unique<EnumCastLocalState>();\n+\n+\tif (cast_data.from_varchar_cast.init_local_state) {\n+\t\tCastLocalStateParameters from_varchar_params(parameters, cast_data.from_varchar_cast.cast_data);\n+\t\tresult->from_varchar_local = cast_data.from_varchar_cast.init_local_state(from_varchar_params);\n+\t}\n+\tif (cast_data.to_varchar_cast.init_local_state) {\n+\t\tCastLocalStateParameters from_varchar_params(parameters, cast_data.to_varchar_cast.cast_data);\n+\t\tresult->from_varchar_local = cast_data.to_varchar_cast.init_local_state(from_varchar_params);\n+\t}\n+\treturn std::move(result);\n+}\n+\n static bool EnumToAnyCast(Vector &source, Vector &result, idx_t count, CastParameters &parameters) {\n \tauto &cast_data = (EnumBoundCastData &)*parameters.cast_data;\n+\tauto &lstate = (EnumCastLocalState &)*parameters.local_state;\n \n \tVector varchar_cast(LogicalType::VARCHAR, count);\n \n \t// cast to varchar\n-\tCastParameters to_varchar_params(parameters, cast_data.to_varchar_cast.cast_data.get());\n+\tCastParameters to_varchar_params(parameters, cast_data.to_varchar_cast.cast_data, lstate.to_varchar_local);\n \tcast_data.to_varchar_cast.function(source, varchar_cast, count, to_varchar_params);\n \n \t// cast from varchar to the target\n-\tCastParameters from_varchar_params(parameters, cast_data.from_varchar_cast.cast_data.get());\n+\tCastParameters from_varchar_params(parameters, cast_data.from_varchar_cast.cast_data, lstate.from_varchar_local);\n \tcast_data.from_varchar_cast.function(varchar_cast, result, count, from_varchar_params);\n \treturn true;\n }\n@@ -152,7 +174,7 @@ BoundCastInfo DefaultCasts::EnumCastSwitch(BindCastInput &input, const LogicalTy\n \t\t\tthrow InternalException(\"ENUM can only have unsigned integers (except UINT64) as physical types\");\n \t\t}\n \tdefault: {\n-\t\treturn BoundCastInfo(EnumToAnyCast, BindEnumCast(input, source, target));\n+\t\treturn BoundCastInfo(EnumToAnyCast, BindEnumCast(input, source, target), InitEnumCastLocalState);\n \t}\n \t}\n }\ndiff --git a/src/function/cast/list_casts.cpp b/src/function/cast/list_casts.cpp\nindex e6d963c74ced..102572103e52 100644\n--- a/src/function/cast/list_casts.cpp\n+++ b/src/function/cast/list_casts.cpp\n@@ -1,5 +1,6 @@\n #include \"duckdb/function/cast/default_casts.hpp\"\n #include \"duckdb/function/cast/cast_function_set.hpp\"\n+#include \"duckdb/function/cast/bound_cast_data.hpp\"\n \n namespace duckdb {\n \n@@ -12,6 +13,15 @@ unique_ptr<BoundCastData> ListBoundCastData::BindListToListCast(BindCastInput &i\n \treturn make_unique<ListBoundCastData>(std::move(child_cast));\n }\n \n+unique_ptr<FunctionLocalState> ListBoundCastData::InitListLocalState(CastLocalStateParameters &parameters) {\n+\tauto &cast_data = (ListBoundCastData &)*parameters.cast_data;\n+\tif (!cast_data.child_cast_info.init_local_state) {\n+\t\treturn nullptr;\n+\t}\n+\tCastLocalStateParameters child_parameters(parameters, cast_data.child_cast_info.cast_data);\n+\treturn cast_data.child_cast_info.init_local_state(child_parameters);\n+}\n+\n bool ListCast::ListToListCast(Vector &source, Vector &result, idx_t count, CastParameters &parameters) {\n \tauto &cast_data = (ListBoundCastData &)*parameters.cast_data;\n \n@@ -40,7 +50,7 @@ bool ListCast::ListToListCast(Vector &source, Vector &result, idx_t count, CastP\n \tListVector::Reserve(result, source_size);\n \tauto &append_vector = ListVector::GetEntry(result);\n \n-\tCastParameters child_parameters(parameters, cast_data.child_cast_info.cast_data.get());\n+\tCastParameters child_parameters(parameters, cast_data.child_cast_info.cast_data, parameters.local_state);\n \tif (!cast_data.child_cast_info.function(source_cc, append_vector, source_size, child_parameters)) {\n \t\treturn false;\n \t}\n@@ -116,10 +126,13 @@ static bool ListToVarcharCast(Vector &source, Vector &result, idx_t count, CastP\n BoundCastInfo DefaultCasts::ListCastSwitch(BindCastInput &input, const LogicalType &source, const LogicalType &target) {\n \tswitch (target.id()) {\n \tcase LogicalTypeId::LIST:\n-\t\treturn BoundCastInfo(ListCast::ListToListCast, ListBoundCastData::BindListToListCast(input, source, target));\n+\t\treturn BoundCastInfo(ListCast::ListToListCast, ListBoundCastData::BindListToListCast(input, source, target),\n+\t\t                     ListBoundCastData::InitListLocalState);\n \tcase LogicalTypeId::VARCHAR:\n-\t\treturn BoundCastInfo(ListToVarcharCast, ListBoundCastData::BindListToListCast(\n-\t\t                                            input, source, LogicalType::LIST(LogicalType::VARCHAR)));\n+\t\treturn BoundCastInfo(\n+\t\t    ListToVarcharCast,\n+\t\t    ListBoundCastData::BindListToListCast(input, source, LogicalType::LIST(LogicalType::VARCHAR)),\n+\t\t    ListBoundCastData::InitListLocalState);\n \tdefault:\n \t\treturn DefaultCasts::TryVectorNullCast;\n \t}\ndiff --git a/src/function/cast/map_cast.cpp b/src/function/cast/map_cast.cpp\nindex 5649c39e22a3..940aa24efd57 100644\n--- a/src/function/cast/map_cast.cpp\n+++ b/src/function/cast/map_cast.cpp\n@@ -1,5 +1,6 @@\n #include \"duckdb/function/cast/default_casts.hpp\"\n #include \"duckdb/function/cast/cast_function_set.hpp\"\n+#include \"duckdb/function/cast/bound_cast_data.hpp\"\n \n namespace duckdb {\n \n@@ -78,10 +79,12 @@ static bool MapToVarcharCast(Vector &source, Vector &result, idx_t count, CastPa\n BoundCastInfo DefaultCasts::MapCastSwitch(BindCastInput &input, const LogicalType &source, const LogicalType &target) {\n \tswitch (target.id()) {\n \tcase LogicalTypeId::MAP:\n-\t\treturn BoundCastInfo(ListCast::ListToListCast, ListBoundCastData::BindListToListCast(input, source, target));\n+\t\treturn BoundCastInfo(ListCast::ListToListCast, ListBoundCastData::BindListToListCast(input, source, target),\n+\t\t                     ListBoundCastData::InitListLocalState);\n \tcase LogicalTypeId::VARCHAR: {\n \t\tauto varchar_type = LogicalType::MAP(LogicalType::VARCHAR, LogicalType::VARCHAR);\n-\t\treturn BoundCastInfo(MapToVarcharCast, ListBoundCastData::BindListToListCast(input, source, varchar_type));\n+\t\treturn BoundCastInfo(MapToVarcharCast, ListBoundCastData::BindListToListCast(input, source, varchar_type),\n+\t\t                     ListBoundCastData::InitListLocalState);\n \t}\n \tdefault:\n \t\treturn TryVectorNullCast;\ndiff --git a/src/function/cast/string_cast.cpp b/src/function/cast/string_cast.cpp\nindex 96c2a23d1e86..f6b6cb509be2 100644\n--- a/src/function/cast/string_cast.cpp\n+++ b/src/function/cast/string_cast.cpp\n@@ -3,6 +3,7 @@\n #include \"duckdb/common/pair.hpp\"\n #include \"duckdb/common/vector.hpp\"\n #include \"duckdb/function/scalar/nested_functions.hpp\"\n+#include \"duckdb/function/cast/bound_cast_data.hpp\"\n \n namespace duckdb {\n \n@@ -115,7 +116,9 @@ static BoundCastInfo VectorStringCastNumericSwitch(BindCastInput &input, const L\n \t}\n }\n \n+//===--------------------------------------------------------------------===//\n // string -> list casting\n+//===--------------------------------------------------------------------===//\n bool VectorStringToList::StringToNestedTypeCastLoop(string_t *source_data, ValidityMask &source_mask, Vector &result,\n                                                     ValidityMask &result_mask, idx_t count, CastParameters &parameters,\n                                                     const SelectionVector *sel) {\n@@ -163,7 +166,7 @@ bool VectorStringToList::StringToNestedTypeCastLoop(string_t *source_data, Valid\n \n \tauto &result_child = ListVector::GetEntry(result);\n \tauto &cast_data = (ListBoundCastData &)*parameters.cast_data;\n-\tCastParameters child_parameters(parameters, cast_data.child_cast_info.cast_data.get());\n+\tCastParameters child_parameters(parameters, cast_data.child_cast_info.cast_data, parameters.local_state);\n \treturn cast_data.child_cast_info.function(varchar_vector, result_child, total_list_size, child_parameters) &&\n \t       all_converted;\n }\n@@ -177,11 +180,12 @@ static LogicalType InitVarcharStructType(const LogicalType &target) {\n \treturn LogicalType::STRUCT(child_types);\n }\n \n+//===--------------------------------------------------------------------===//\n // string -> struct casting\n+//===--------------------------------------------------------------------===//\n bool VectorStringToStruct::StringToNestedTypeCastLoop(string_t *source_data, ValidityMask &source_mask, Vector &result,\n                                                       ValidityMask &result_mask, idx_t count,\n                                                       CastParameters &parameters, const SelectionVector *sel) {\n-\n \tauto varchar_struct_type = InitVarcharStructType(result.GetType());\n \tVector varchar_vector(varchar_struct_type, count);\n \tauto &child_vectors = StructVector::GetEntries(varchar_vector);\n@@ -216,21 +220,39 @@ bool VectorStringToStruct::StringToNestedTypeCastLoop(string_t *source_data, Val\n \t}\n \n \tauto &cast_data = (StructBoundCastData &)*parameters.cast_data;\n+\tauto &lstate = (StructCastLocalState &)*parameters.local_state;\n \tD_ASSERT(cast_data.child_cast_info.size() == result_children.size());\n \n \tfor (idx_t child_idx = 0; child_idx < result_children.size(); child_idx++) {\n-\t\tauto &varchar_vector = *child_vectors[child_idx];\n+\t\tauto &child_varchar_vector = *child_vectors[child_idx];\n \t\tauto &result_child_vector = *result_children[child_idx];\n \t\tauto &child_cast_info = cast_data.child_cast_info[child_idx];\n-\t\tCastParameters child_parameters(parameters, child_cast_info.cast_data.get());\n-\t\tif (!child_cast_info.function(varchar_vector, result_child_vector, count, child_parameters)) {\n+\t\tCastParameters child_parameters(parameters, child_cast_info.cast_data, lstate.local_states[child_idx]);\n+\t\tif (!child_cast_info.function(child_varchar_vector, result_child_vector, count, child_parameters)) {\n \t\t\tall_converted = false;\n \t\t}\n \t}\n \treturn all_converted;\n }\n \n+//===--------------------------------------------------------------------===//\n // string -> map casting\n+//===--------------------------------------------------------------------===//\n+unique_ptr<FunctionLocalState> InitMapCastLocalState(CastLocalStateParameters &parameters) {\n+\tauto &cast_data = (MapBoundCastData &)*parameters.cast_data;\n+\tauto result = make_unique<MapCastLocalState>();\n+\n+\tif (cast_data.key_cast.init_local_state) {\n+\t\tCastLocalStateParameters child_params(parameters, cast_data.key_cast.cast_data);\n+\t\tresult->key_state = cast_data.key_cast.init_local_state(child_params);\n+\t}\n+\tif (cast_data.value_cast.init_local_state) {\n+\t\tCastLocalStateParameters child_params(parameters, cast_data.value_cast.cast_data);\n+\t\tresult->value_state = cast_data.value_cast.init_local_state(child_params);\n+\t}\n+\treturn std::move(result);\n+}\n+\n bool VectorStringToMap::StringToNestedTypeCastLoop(string_t *source_data, ValidityMask &source_mask, Vector &result,\n                                                    ValidityMask &result_mask, idx_t count, CastParameters &parameters,\n                                                    const SelectionVector *sel) {\n@@ -282,12 +304,13 @@ bool VectorStringToMap::StringToNestedTypeCastLoop(string_t *source_data, Validi\n \tauto &result_key_child = MapVector::GetKeys(result);\n \tauto &result_val_child = MapVector::GetValues(result);\n \tauto &cast_data = (MapBoundCastData &)*parameters.cast_data;\n+\tauto &lstate = (MapCastLocalState &)*parameters.local_state;\n \n-\tCastParameters key_params(parameters, cast_data.key_cast.cast_data.get());\n+\tCastParameters key_params(parameters, cast_data.key_cast.cast_data, lstate.key_state);\n \tif (!cast_data.key_cast.function(varchar_key_vector, result_key_child, total_elements, key_params)) {\n \t\tall_converted = false;\n \t}\n-\tCastParameters val_params(parameters, cast_data.value_cast.cast_data.get());\n+\tCastParameters val_params(parameters, cast_data.value_cast.cast_data, lstate.value_state);\n \tif (!cast_data.value_cast.function(varchar_val_vector, result_val_child, total_elements, val_params)) {\n \t\tall_converted = false;\n \t}\n@@ -373,14 +396,17 @@ BoundCastInfo DefaultCasts::StringCastSwitch(BindCastInput &input, const Logical\n \t\t// the second argument allows for a secondary casting function to be passed in the CastParameters\n \t\treturn BoundCastInfo(\n \t\t    &StringToNestedTypeCast<VectorStringToList>,\n-\t\t    ListBoundCastData::BindListToListCast(input, LogicalType::LIST(LogicalType::VARCHAR), target));\n+\t\t    ListBoundCastData::BindListToListCast(input, LogicalType::LIST(LogicalType::VARCHAR), target),\n+\t\t    ListBoundCastData::InitListLocalState);\n \tcase LogicalTypeId::STRUCT:\n \t\treturn BoundCastInfo(&StringToNestedTypeCast<VectorStringToStruct>,\n-\t\t                     StructBoundCastData::BindStructToStructCast(input, InitVarcharStructType(target), target));\n+\t\t                     StructBoundCastData::BindStructToStructCast(input, InitVarcharStructType(target), target),\n+\t\t                     StructBoundCastData::InitStructCastLocalState);\n \tcase LogicalTypeId::MAP:\n \t\treturn BoundCastInfo(&StringToNestedTypeCast<VectorStringToMap>,\n \t\t                     MapBoundCastData::BindMapToMapCast(\n-\t\t                         input, LogicalType::MAP(LogicalType::VARCHAR, LogicalType::VARCHAR), target));\n+\t\t                         input, LogicalType::MAP(LogicalType::VARCHAR, LogicalType::VARCHAR), target),\n+\t\t                     InitMapCastLocalState);\n \tdefault:\n \t\treturn VectorStringCastNumericSwitch(input, source, target);\n \t}\ndiff --git a/src/function/cast/struct_cast.cpp b/src/function/cast/struct_cast.cpp\nindex ceccff4b3ce5..f5f7acb200fb 100644\n--- a/src/function/cast/struct_cast.cpp\n+++ b/src/function/cast/struct_cast.cpp\n@@ -1,5 +1,6 @@\n #include \"duckdb/function/cast/default_casts.hpp\"\n #include \"duckdb/function/cast/cast_function_set.hpp\"\n+#include \"duckdb/function/cast/bound_cast_data.hpp\"\n \n namespace duckdb {\n \n@@ -18,8 +19,24 @@ unique_ptr<BoundCastData> StructBoundCastData::BindStructToStructCast(BindCastIn\n \treturn make_unique<StructBoundCastData>(std::move(child_cast_info), target);\n }\n \n+unique_ptr<FunctionLocalState> StructBoundCastData::InitStructCastLocalState(CastLocalStateParameters &parameters) {\n+\tauto &cast_data = (StructBoundCastData &)*parameters.cast_data;\n+\tauto result = make_unique<StructCastLocalState>();\n+\n+\tfor (auto &entry : cast_data.child_cast_info) {\n+\t\tunique_ptr<FunctionLocalState> child_state;\n+\t\tif (entry.init_local_state) {\n+\t\t\tCastLocalStateParameters child_params(parameters, entry.cast_data);\n+\t\t\tchild_state = entry.init_local_state(child_params);\n+\t\t}\n+\t\tresult->local_states.push_back(std::move(child_state));\n+\t}\n+\treturn std::move(result);\n+}\n+\n static bool StructToStructCast(Vector &source, Vector &result, idx_t count, CastParameters &parameters) {\n \tauto &cast_data = (StructBoundCastData &)*parameters.cast_data;\n+\tauto &lstate = (StructCastLocalState &)*parameters.local_state;\n \tauto &source_child_types = StructType::GetChildTypes(source.GetType());\n \tauto &source_children = StructVector::GetEntries(source);\n \tD_ASSERT(source_children.size() == StructType::GetChildTypes(result.GetType()).size());\n@@ -29,7 +46,8 @@ static bool StructToStructCast(Vector &source, Vector &result, idx_t count, Cast\n \tfor (idx_t c_idx = 0; c_idx < source_child_types.size(); c_idx++) {\n \t\tauto &result_child_vector = *result_children[c_idx];\n \t\tauto &source_child_vector = *source_children[c_idx];\n-\t\tCastParameters child_parameters(parameters, cast_data.child_cast_info[c_idx].cast_data.get());\n+\t\tCastParameters child_parameters(parameters, cast_data.child_cast_info[c_idx].cast_data,\n+\t\t                                lstate.local_states[c_idx]);\n \t\tif (!cast_data.child_cast_info[c_idx].function(source_child_vector, result_child_vector, count,\n \t\t                                               child_parameters)) {\n \t\t\tall_converted = false;\n@@ -121,7 +139,8 @@ BoundCastInfo DefaultCasts::StructCastSwitch(BindCastInput &input, const Logical\n                                              const LogicalType &target) {\n \tswitch (target.id()) {\n \tcase LogicalTypeId::STRUCT:\n-\t\treturn BoundCastInfo(StructToStructCast, StructBoundCastData::BindStructToStructCast(input, source, target));\n+\t\treturn BoundCastInfo(StructToStructCast, StructBoundCastData::BindStructToStructCast(input, source, target),\n+\t\t                     StructBoundCastData::InitStructCastLocalState);\n \tcase LogicalTypeId::VARCHAR: {\n \t\t// bind a cast in which we convert all child entries to VARCHAR entries\n \t\tauto &struct_children = StructType::GetChildTypes(source);\n@@ -131,7 +150,8 @@ BoundCastInfo DefaultCasts::StructCastSwitch(BindCastInput &input, const Logical\n \t\t}\n \t\tauto varchar_type = LogicalType::STRUCT(varchar_children);\n \t\treturn BoundCastInfo(StructToVarcharCast,\n-\t\t                     StructBoundCastData::BindStructToStructCast(input, source, varchar_type));\n+\t\t                     StructBoundCastData::BindStructToStructCast(input, source, varchar_type),\n+\t\t                     StructBoundCastData::InitStructCastLocalState);\n \t}\n \tdefault:\n \t\treturn TryVectorNullCast;\ndiff --git a/src/function/cast/union_casts.cpp b/src/function/cast/union_casts.cpp\nindex ee412771aef8..81f901916589 100644\n--- a/src/function/cast/union_casts.cpp\n+++ b/src/function/cast/union_casts.cpp\n@@ -1,6 +1,6 @@\n #include \"duckdb/function/cast/cast_function_set.hpp\"\n #include \"duckdb/function/cast/default_casts.hpp\"\n-#include \"duckdb/function/cast/vector_cast_helpers.hpp\"\n+#include \"duckdb/function/cast/bound_cast_data.hpp\"\n \n #include <algorithm> // for std::sort\n \n@@ -98,12 +98,21 @@ unique_ptr<BoundCastData> BindToUnionCast(BindCastInput &input, const LogicalTyp\n \treturn make_unique<ToUnionBoundCastData>(std::move(selected_cast));\n }\n \n+unique_ptr<FunctionLocalState> InitToUnionLocalState(CastLocalStateParameters &parameters) {\n+\tauto &cast_data = (ToUnionBoundCastData &)*parameters.cast_data;\n+\tif (!cast_data.member_cast_info.init_local_state) {\n+\t\treturn nullptr;\n+\t}\n+\tCastLocalStateParameters child_parameters(parameters, cast_data.member_cast_info.cast_data);\n+\treturn cast_data.member_cast_info.init_local_state(child_parameters);\n+}\n+\n static bool ToUnionCast(Vector &source, Vector &result, idx_t count, CastParameters &parameters) {\n \tD_ASSERT(result.GetType().id() == LogicalTypeId::UNION);\n \tauto &cast_data = (ToUnionBoundCastData &)*parameters.cast_data;\n \tauto &selected_member_vector = UnionVector::GetMember(result, cast_data.tag);\n \n-\tCastParameters child_parameters(parameters, cast_data.member_cast_info.cast_data.get());\n+\tCastParameters child_parameters(parameters, cast_data.member_cast_info.cast_data, parameters.local_state);\n \tif (!cast_data.member_cast_info.function(source, selected_member_vector, count, child_parameters)) {\n \t\treturn false;\n \t}\n@@ -118,7 +127,7 @@ static bool ToUnionCast(Vector &source, Vector &result, idx_t count, CastParamet\n \n BoundCastInfo DefaultCasts::ImplicitToUnionCast(BindCastInput &input, const LogicalType &source,\n                                                 const LogicalType &target) {\n-\treturn BoundCastInfo(&ToUnionCast, BindToUnionCast(input, source, target));\n+\treturn BoundCastInfo(&ToUnionCast, BindToUnionCast(input, source, target), InitToUnionLocalState);\n }\n \n //--------------------------------------------------------------------------------------------------\n@@ -197,8 +206,24 @@ unique_ptr<BoundCastData> BindUnionToUnionCast(BindCastInput &input, const Logic\n \treturn make_unique<UnionToUnionBoundCastData>(tag_map, std::move(member_casts), target);\n }\n \n+unique_ptr<FunctionLocalState> InitUnionToUnionLocalState(CastLocalStateParameters &parameters) {\n+\tauto &cast_data = (UnionToUnionBoundCastData &)*parameters.cast_data;\n+\tauto result = make_unique<StructCastLocalState>();\n+\n+\tfor (auto &entry : cast_data.member_casts) {\n+\t\tunique_ptr<FunctionLocalState> child_state;\n+\t\tif (entry.init_local_state) {\n+\t\t\tCastLocalStateParameters child_params(parameters, entry.cast_data);\n+\t\t\tchild_state = entry.init_local_state(child_params);\n+\t\t}\n+\t\tresult->local_states.push_back(std::move(child_state));\n+\t}\n+\treturn std::move(result);\n+}\n+\n static bool UnionToUnionCast(Vector &source, Vector &result, idx_t count, CastParameters &parameters) {\n \tauto &cast_data = (UnionToUnionBoundCastData &)*parameters.cast_data;\n+\tauto &lstate = (StructCastLocalState &)*parameters.local_state;\n \n \tauto source_member_count = UnionType::GetMemberCount(source.GetType());\n \tauto target_member_count = UnionType::GetMemberCount(result.GetType());\n@@ -213,7 +238,7 @@ static bool UnionToUnionCast(Vector &source, Vector &result, idx_t count, CastPa\n \t\tauto &target_member_vector = UnionVector::GetMember(result, target_member_idx);\n \t\tauto &member_cast = cast_data.member_casts[member_idx];\n \n-\t\tCastParameters child_parameters(parameters, member_cast.cast_data.get());\n+\t\tCastParameters child_parameters(parameters, member_cast.cast_data, lstate.local_states[member_idx]);\n \t\tif (!member_cast.function(source_member_vector, target_member_vector, count, child_parameters)) {\n \t\t\treturn false;\n \t\t}\n@@ -339,10 +364,11 @@ BoundCastInfo DefaultCasts::UnionCastSwitch(BindCastInput &input, const LogicalT\n \t\t\tvarchar_members.push_back(make_pair(UnionType::GetMemberName(source, member_idx), LogicalType::VARCHAR));\n \t\t}\n \t\tauto varchar_type = LogicalType::UNION(std::move(varchar_members));\n-\t\treturn BoundCastInfo(UnionToVarcharCast, BindUnionToUnionCast(input, source, varchar_type));\n-\t} break;\n+\t\treturn BoundCastInfo(UnionToVarcharCast, BindUnionToUnionCast(input, source, varchar_type),\n+\t\t                     InitUnionToUnionLocalState);\n+\t}\n \tcase LogicalTypeId::UNION:\n-\t\treturn BoundCastInfo(UnionToUnionCast, BindUnionToUnionCast(input, source, target));\n+\t\treturn BoundCastInfo(UnionToUnionCast, BindUnionToUnionCast(input, source, target), InitUnionToUnionLocalState);\n \tdefault:\n \t\treturn TryVectorNullCast;\n \t}\ndiff --git a/src/include/duckdb/common/optional_ptr.hpp b/src/include/duckdb/common/optional_ptr.hpp\nnew file mode 100644\nindex 000000000000..53bef2702db1\n--- /dev/null\n+++ b/src/include/duckdb/common/optional_ptr.hpp\n@@ -0,0 +1,45 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/optional_ptr.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/common/exception.hpp\"\n+\n+namespace duckdb {\n+\n+template <class T>\n+class optional_ptr {\n+public:\n+\toptional_ptr() : ptr(nullptr) {\n+\t}\n+\toptional_ptr(T *ptr_p) : ptr(ptr_p) { // NOLINT: allow implicit creation from pointer\n+\t}\n+\toptional_ptr(const unique_ptr<T> &ptr_p) : ptr(ptr_p.get()) { // NOLINT: allow implicit creation from unique pointer\n+\t}\n+\n+\toperator bool() const {\n+\t\treturn ptr;\n+\t}\n+\tT &operator*() {\n+\t\tif (!ptr) {\n+\t\t\tthrow InternalException(\"Attempting to dereference an optional pointer that is not set\");\n+\t\t}\n+\t\treturn *ptr;\n+\t}\n+\tT *operator->() {\n+\t\tif (!ptr) {\n+\t\t\tthrow InternalException(\"Attempting to call a method on an optional pointer that is not set\");\n+\t\t}\n+\t\treturn ptr;\n+\t}\n+\n+private:\n+\tT *ptr;\n+};\n+\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/function/cast/bound_cast_data.hpp b/src/include/duckdb/function/cast/bound_cast_data.hpp\nnew file mode 100644\nindex 000000000000..36d2886b79cb\n--- /dev/null\n+++ b/src/include/duckdb/function/cast/bound_cast_data.hpp\n@@ -0,0 +1,84 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/function/cast/bound_cast_data.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/function/cast/default_casts.hpp\"\n+\n+namespace duckdb {\n+\n+struct ListBoundCastData : public BoundCastData {\n+\texplicit ListBoundCastData(BoundCastInfo child_cast) : child_cast_info(std::move(child_cast)) {\n+\t}\n+\n+\tBoundCastInfo child_cast_info;\n+\tstatic unique_ptr<BoundCastData> BindListToListCast(BindCastInput &input, const LogicalType &source,\n+\t                                                    const LogicalType &target);\n+\tstatic unique_ptr<FunctionLocalState> InitListLocalState(CastLocalStateParameters &parameters);\n+\n+public:\n+\tunique_ptr<BoundCastData> Copy() const override {\n+\t\treturn make_unique<ListBoundCastData>(child_cast_info.Copy());\n+\t}\n+};\n+\n+struct ListCast {\n+\tstatic bool ListToListCast(Vector &source, Vector &result, idx_t count, CastParameters &parameters);\n+};\n+\n+struct StructBoundCastData : public BoundCastData {\n+\tStructBoundCastData(vector<BoundCastInfo> child_casts, LogicalType target_p)\n+\t    : child_cast_info(std::move(child_casts)), target(std::move(target_p)) {\n+\t}\n+\n+\tvector<BoundCastInfo> child_cast_info;\n+\tLogicalType target;\n+\n+\tstatic unique_ptr<BoundCastData> BindStructToStructCast(BindCastInput &input, const LogicalType &source,\n+\t                                                        const LogicalType &target);\n+\tstatic unique_ptr<FunctionLocalState> InitStructCastLocalState(CastLocalStateParameters &parameters);\n+\n+public:\n+\tunique_ptr<BoundCastData> Copy() const override {\n+\t\tvector<BoundCastInfo> copy_info;\n+\t\tfor (auto &info : child_cast_info) {\n+\t\t\tcopy_info.push_back(info.Copy());\n+\t\t}\n+\t\treturn make_unique<StructBoundCastData>(std::move(copy_info), target);\n+\t}\n+};\n+\n+struct StructCastLocalState : public FunctionLocalState {\n+public:\n+\tvector<unique_ptr<FunctionLocalState>> local_states;\n+};\n+\n+struct MapBoundCastData : public BoundCastData {\n+\tMapBoundCastData(BoundCastInfo key_cast, BoundCastInfo value_cast)\n+\t    : key_cast(std::move(key_cast)), value_cast(std::move(value_cast)) {\n+\t}\n+\n+\tBoundCastInfo key_cast;\n+\tBoundCastInfo value_cast;\n+\n+\tstatic unique_ptr<BoundCastData> BindMapToMapCast(BindCastInput &input, const LogicalType &source,\n+\t                                                  const LogicalType &target);\n+\n+public:\n+\tunique_ptr<BoundCastData> Copy() const override {\n+\t\treturn make_unique<MapBoundCastData>(key_cast.Copy(), value_cast.Copy());\n+\t}\n+};\n+\n+struct MapCastLocalState : public FunctionLocalState {\n+public:\n+\tunique_ptr<FunctionLocalState> key_state;\n+\tunique_ptr<FunctionLocalState> value_state;\n+};\n+\n+} // namespace duckdb\ndiff --git a/src/include/duckdb/function/cast/cast_function_set.hpp b/src/include/duckdb/function/cast/cast_function_set.hpp\nindex 940c1ca90187..05c1037d7b89 100644\n--- a/src/include/duckdb/function/cast/cast_function_set.hpp\n+++ b/src/include/duckdb/function/cast/cast_function_set.hpp\n@@ -19,12 +19,12 @@ typedef BoundCastInfo (*bind_cast_function_t)(BindCastInput &input, const Logica\n typedef int64_t (*implicit_cast_cost_t)(const LogicalType &from, const LogicalType &to);\n \n struct GetCastFunctionInput {\n-\tGetCastFunctionInput(ClientContext *context = nullptr) : context(context) {\n+\tGetCastFunctionInput(optional_ptr<ClientContext> context = nullptr) : context(context) {\n \t}\n \tGetCastFunctionInput(ClientContext &context) : context(&context) {\n \t}\n \n-\tClientContext *context;\n+\toptional_ptr<ClientContext> context;\n };\n \n struct BindCastFunction {\ndiff --git a/src/include/duckdb/function/cast/default_casts.hpp b/src/include/duckdb/function/cast/default_casts.hpp\nindex c27e34af7ce7..dce67b95d834 100644\n--- a/src/include/duckdb/function/cast/default_casts.hpp\n+++ b/src/include/duckdb/function/cast/default_casts.hpp\n@@ -10,6 +10,8 @@\n \n #include \"duckdb/common/types.hpp\"\n #include \"duckdb/common/types/vector.hpp\"\n+#include \"duckdb/common/optional_ptr.hpp\"\n+#include \"duckdb/function/scalar_function.hpp\"\n \n namespace duckdb {\n \n@@ -31,25 +33,43 @@ struct BoundCastData {\n struct CastParameters {\n \tCastParameters() {\n \t}\n-\tCastParameters(BoundCastData *cast_data, bool strict, string *error_message, FunctionLocalState *local_state)\n+\tCastParameters(BoundCastData *cast_data, bool strict, string *error_message,\n+\t               optional_ptr<FunctionLocalState> local_state)\n \t    : cast_data(cast_data), strict(strict), error_message(error_message), local_state(local_state) {\n \t}\n-\tCastParameters(CastParameters &parent, BoundCastData *cast_data = nullptr)\n-\t    : cast_data(cast_data), strict(parent.strict), error_message(parent.error_message) {\n+\tCastParameters(CastParameters &parent, optional_ptr<BoundCastData> cast_data,\n+\t               optional_ptr<FunctionLocalState> local_state)\n+\t    : cast_data(cast_data), strict(parent.strict), error_message(parent.error_message), local_state(local_state) {\n \t}\n \n \t//! The bound cast data (if any)\n-\tBoundCastData *cast_data = nullptr;\n+\toptional_ptr<BoundCastData> cast_data;\n \t//! whether or not to enable strict casting\n \tbool strict = false;\n \t// out: error message in case cast has failed\n \tstring *error_message = nullptr;\n \t//! Local state\n-\tFunctionLocalState *local_state = nullptr;\n+\toptional_ptr<FunctionLocalState> local_state;\n+};\n+\n+struct CastLocalStateParameters {\n+\tCastLocalStateParameters(optional_ptr<ClientContext> context_p, optional_ptr<BoundCastData> cast_data_p)\n+\t    : context(context_p), cast_data(cast_data_p) {\n+\t}\n+\tCastLocalStateParameters(ClientContext &context_p, optional_ptr<BoundCastData> cast_data_p)\n+\t    : context(&context_p), cast_data(cast_data_p) {\n+\t}\n+\tCastLocalStateParameters(CastLocalStateParameters &parent, optional_ptr<BoundCastData> cast_data_p)\n+\t    : context(parent.context), cast_data(cast_data_p) {\n+\t}\n+\n+\toptional_ptr<ClientContext> context;\n+\t//! The bound cast data (if any)\n+\toptional_ptr<BoundCastData> cast_data;\n };\n \n typedef bool (*cast_function_t)(Vector &source, Vector &result, idx_t count, CastParameters &parameters);\n-typedef unique_ptr<FunctionLocalState> (*init_cast_local_state_t)(ClientContext &context);\n+typedef unique_ptr<FunctionLocalState> (*init_cast_local_state_t)(CastLocalStateParameters &parameters);\n \n struct BoundCastInfo {\n \tDUCKDB_API\n@@ -65,72 +85,16 @@ struct BoundCastInfo {\n };\n \n struct BindCastInput {\n-\tDUCKDB_API BindCastInput(CastFunctionSet &function_set, BindCastInfo *info, ClientContext *context);\n+\tDUCKDB_API BindCastInput(CastFunctionSet &function_set, BindCastInfo *info, optional_ptr<ClientContext> context);\n \n \tCastFunctionSet &function_set;\n \tBindCastInfo *info;\n-\tClientContext *context;\n+\toptional_ptr<ClientContext> context;\n \n public:\n \tDUCKDB_API BoundCastInfo GetCastFunction(const LogicalType &source, const LogicalType &target);\n };\n \n-struct ListBoundCastData : public BoundCastData {\n-\texplicit ListBoundCastData(BoundCastInfo child_cast) : child_cast_info(std::move(child_cast)) {\n-\t}\n-\n-\tBoundCastInfo child_cast_info;\n-\tstatic unique_ptr<BoundCastData> BindListToListCast(BindCastInput &input, const LogicalType &source,\n-\t                                                    const LogicalType &target);\n-\n-public:\n-\tunique_ptr<BoundCastData> Copy() const override {\n-\t\treturn make_unique<ListBoundCastData>(child_cast_info.Copy());\n-\t}\n-};\n-\n-struct ListCast {\n-\tstatic bool ListToListCast(Vector &source, Vector &result, idx_t count, CastParameters &parameters);\n-};\n-\n-struct StructBoundCastData : public BoundCastData {\n-\tStructBoundCastData(vector<BoundCastInfo> child_casts, LogicalType target_p)\n-\t    : child_cast_info(std::move(child_casts)), target(std::move(target_p)) {\n-\t}\n-\n-\tvector<BoundCastInfo> child_cast_info;\n-\tLogicalType target;\n-\n-\tstatic unique_ptr<BoundCastData> BindStructToStructCast(BindCastInput &input, const LogicalType &source,\n-\t                                                        const LogicalType &target);\n-\n-public:\n-\tunique_ptr<BoundCastData> Copy() const override {\n-\t\tvector<BoundCastInfo> copy_info;\n-\t\tfor (auto &info : child_cast_info) {\n-\t\t\tcopy_info.push_back(info.Copy());\n-\t\t}\n-\t\treturn make_unique<StructBoundCastData>(std::move(copy_info), target);\n-\t}\n-};\n-\n-struct MapBoundCastData : public BoundCastData {\n-\tMapBoundCastData(BoundCastInfo key_cast, BoundCastInfo value_cast)\n-\t    : key_cast(std::move(key_cast)), value_cast(std::move(value_cast)) {\n-\t}\n-\n-\tBoundCastInfo key_cast;\n-\tBoundCastInfo value_cast;\n-\n-\tstatic unique_ptr<BoundCastData> BindMapToMapCast(BindCastInput &input, const LogicalType &source,\n-\t                                                  const LogicalType &target);\n-\n-public:\n-\tunique_ptr<BoundCastData> Copy() const override {\n-\t\treturn make_unique<MapBoundCastData>(key_cast.Copy(), value_cast.Copy());\n-\t}\n-};\n-\n struct DefaultCasts {\n \tDUCKDB_API static BoundCastInfo GetDefaultCastFunction(BindCastInput &input, const LogicalType &source,\n \t                                                       const LogicalType &target);\n",
  "test_patch": "diff --git a/test/sql/json/json_nested_casts.test b/test/sql/json/json_nested_casts.test\nnew file mode 100644\nindex 000000000000..0031c9045f0a\n--- /dev/null\n+++ b/test/sql/json/json_nested_casts.test\n@@ -0,0 +1,97 @@\n+# name: test/sql/json/json_nested_casts.test\n+# description: Casts to and from nested types with JSON\n+# group: [json]\n+\n+require json\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+# list with varchar to json\n+statement ok\n+create table t2(blobs json[])\n+\n+statement ok\n+insert into t2 values(json('[1,2]'));\n+\n+query I\n+SELECT * FROM t2\n+----\n+[1, 2]\n+\n+# varchar to list of json\n+query I\n+select cast(json('[1,2]') as json[]);\n+----\n+[1, 2]\n+\n+statement error\n+select cast(['boom'] as json[]);\n+----\n+Malformed JSON\n+\n+query I\n+select cast(['[1, 2]', '[3, 4]'] as json[]);\n+----\n+[[1, 2], [3, 4]]\n+\n+# struct with varchar to json\n+query I\n+SELECT {'a': '[1, 2]'}::ROW(a JSON)\n+----\n+{'a': [1, 2]}\n+\n+query I\n+SELECT {'a': 42, 'b': '[1, 2]'}::ROW(a JSON, b JSON)\n+----\n+{'a': 42, 'b': [1, 2]}\n+\n+query I\n+SELECT {'a': 42, 'b': '[1, 2]'}::ROW(a JSON, b INT[])\n+----\n+{'a': 42, 'b': [1, 2]}\n+\n+statement error\n+SELECT {'a': 'boom', 'b': '[1, 2]'}::ROW(a JSON, b INT[])\n+----\n+Malformed JSON\n+\n+# varchar to struct of json\n+query I\n+SELECT '{a: [1, 2]}'::ROW(a JSON)\n+----\n+{'a': [1, 2]}\n+\n+# map with varchar to json\n+query I\n+SELECT MAP(['42'], ['88'])::MAP(JSON, JSON)\n+----\n+{42=88}\n+\n+# varchar to map of json\n+query I\n+SELECT '{42=88}'::MAP(JSON, JSON)\n+----\n+{42=88}\n+\n+# varchar to union with json\n+query I\n+SELECT '42'::UNION(u JSON)\n+----\n+42\n+\n+# union with varchar to union with json\n+query I\n+SELECT '42'::UNION(u VARCHAR)::UNION(u JSON)\n+----\n+42\n+\n+query I\n+SELECT ['42']::UNION(u JSON)[]\n+----\n+[42]\n+\n+query I\n+SELECT '42'::UNION(u VARCHAR)::JSON\n+----\n+42\n",
  "problem_statement": "Segfault casting json list to LIST\n### What happens?\r\n\r\nSegfault casting json list to LIST\r\n\r\n### To Reproduce\r\n\r\n```\r\nD create table t2(blobs json[]);\r\nD insert into t2 values(json('[1,2]'));\r\nzsh: segmentation fault  ./duckdb\r\n```\r\nor\r\n```\r\nD select cast(json('[1,2]') as json[]);\r\nzsh: segmentation fault  ./duckdb\r\n```\r\n\r\n### OS:\r\n\r\nmacos\r\n\r\n### DuckDB Version:\r\n\r\nv0.7.1 b00b93f0b1\r\n\r\n### DuckDB Client:\r\n\r\nduckdb_cli-osx-universal\r\n\r\n### Full Name:\r\n\r\nOliver Mannion\r\n\r\n### Affiliation:\r\n\r\nXero\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\nSegfault casting VARCHAR[] to JSON[]\n### What happens?\n\nSegfault casting VARCHAR[] to JSON[]\n\n### To Reproduce\n\n```\r\nD select cast(['boom'] as json[]);\r\nzsh: segmentation fault  ./duckdb\r\n```\n\n### OS:\n\nmacos\n\n### DuckDB Version:\n\nv0.7.1 b00b93f\n\n### DuckDB Client:\n\nduckdb_cli-osx-universal\n\n### Full Name:\n\nOliver Mannion\n\n### Affiliation:\n\nXero\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "\n",
  "created_at": "2023-03-12T10:03:25Z"
}