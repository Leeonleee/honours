diff --git a/src/common/row_operations/row_radix_scatter.cpp b/src/common/row_operations/row_radix_scatter.cpp
index 466221fffc99..74774926d5e2 100644
--- a/src/common/row_operations/row_radix_scatter.cpp
+++ b/src/common/row_operations/row_radix_scatter.cpp
@@ -102,6 +102,7 @@ void RadixScatterListVector(Vector &v, UnifiedVectorFormat &vdata, const Selecti
 	auto list_data = ListVector::GetData(v);
 	auto &child_vector = ListVector::GetEntry(v);
 	auto list_size = ListVector::GetListSize(v);
+	child_vector.Flatten(list_size);
 
 	// serialize null values
 	if (has_null) {
diff --git a/src/common/vector_operations/is_distinct_from.cpp b/src/common/vector_operations/is_distinct_from.cpp
index 577d4c0e6202..3017978bcb0f 100644
--- a/src/common/vector_operations/is_distinct_from.cpp
+++ b/src/common/vector_operations/is_distinct_from.cpp
@@ -564,8 +564,8 @@ static idx_t DistinctSelectList(Vector &left, Vector &right, idx_t count, const
 	SelectionVector lcursor(count);
 	SelectionVector rcursor(count);
 
-	ListVector::GetEntry(left).Flatten(count);
-	ListVector::GetEntry(right).Flatten(count);
+	ListVector::GetEntry(left).Flatten(ListVector::GetListSize(left));
+	ListVector::GetEntry(right).Flatten(ListVector::GetListSize(right));
 	Vector lchild(ListVector::GetEntry(left), lcursor, count);
 	Vector rchild(ListVector::GetEntry(right), rcursor, count);
 
diff --git a/src/function/scalar/list/contains_or_position.cpp b/src/function/scalar/list/contains_or_position.cpp
index 4d6e84bdcac4..716abb4bcea3 100644
--- a/src/function/scalar/list/contains_or_position.cpp
+++ b/src/function/scalar/list/contains_or_position.cpp
@@ -55,8 +55,8 @@ static void TemplatedContainsOrPosition(DataChunk &args, ExpressionState &state,
 	value_vector.ToUnifiedFormat(count, value_data);
 
 	// not required for a comparison of nested types
-	auto child_value = FlatVector::GetData<CHILD_TYPE>(child_vector);
-	auto values = FlatVector::GetData<CHILD_TYPE>(value_vector);
+	auto child_value = (CHILD_TYPE *)child_data.data;
+	auto values = (CHILD_TYPE *)value_data.data;
 
 	for (idx_t i = 0; i < count; i++) {
 		auto list_index = list_data.sel->get_index(i);
diff --git a/src/function/scalar/list/list_extract.cpp b/src/function/scalar/list/list_extract.cpp
index 027e239964b6..5e162583bee0 100644
--- a/src/function/scalar/list/list_extract.cpp
+++ b/src/function/scalar/list/list_extract.cpp
@@ -15,8 +15,8 @@ namespace duckdb {
 template <class T, bool HEAP_REF = false, bool VALIDITY_ONLY = false>
 void ListExtractTemplate(idx_t count, UnifiedVectorFormat &list_data, UnifiedVectorFormat &offsets_data,
                          Vector &child_vector, idx_t list_size, Vector &result) {
-	UnifiedVectorFormat child_data;
-	child_vector.ToUnifiedFormat(list_size, child_data);
+	UnifiedVectorFormat child_format;
+	child_vector.ToUnifiedFormat(list_size, child_format);
 
 	T *result_data;
 
@@ -33,40 +33,46 @@ void ListExtractTemplate(idx_t count, UnifiedVectorFormat &list_data, UnifiedVec
 
 	// this is lifted from ExecuteGenericLoop because we can't push the list child data into this otherwise
 	// should have gone with GetValue perhaps
+	auto child_data = (T *)child_format.data;
 	for (idx_t i = 0; i < count; i++) {
 		auto list_index = list_data.sel->get_index(i);
 		auto offsets_index = offsets_data.sel->get_index(i);
-		if (list_data.validity.RowIsValid(list_index) && offsets_data.validity.RowIsValid(offsets_index)) {
-			auto list_entry = ((list_entry_t *)list_data.data)[list_index];
-			auto offsets_entry = ((int64_t *)offsets_data.data)[offsets_index];
+		if (!list_data.validity.RowIsValid(list_index)) {
+			result_mask.SetInvalid(i);
+			continue;
+		}
+		if (!offsets_data.validity.RowIsValid(offsets_index)) {
+			result_mask.SetInvalid(i);
+			continue;
+		}
+		auto list_entry = ((list_entry_t *)list_data.data)[list_index];
+		auto offsets_entry = ((int64_t *)offsets_data.data)[offsets_index];
+
+		// 1-based indexing
+		if (offsets_entry == 0) {
+			result_mask.SetInvalid(i);
+			continue;
+		}
+		offsets_entry = (offsets_entry > 0) ? offsets_entry - 1 : offsets_entry;
 
-			// 1-based indexing
-			if (offsets_entry == 0) {
+		idx_t child_offset;
+		if (offsets_entry < 0) {
+			if ((idx_t)-offsets_entry > list_entry.length) {
 				result_mask.SetInvalid(i);
 				continue;
 			}
-			offsets_entry = (offsets_entry > 0) ? offsets_entry - 1 : offsets_entry;
-
-			idx_t child_offset;
-			if (offsets_entry < 0) {
-				if ((idx_t)-offsets_entry > list_entry.length) {
-					result_mask.SetInvalid(i);
-					continue;
-				}
-				child_offset = list_entry.offset + list_entry.length + offsets_entry;
-			} else {
-				if ((idx_t)offsets_entry >= list_entry.length) {
-					result_mask.SetInvalid(i);
-					continue;
-				}
-				child_offset = list_entry.offset + offsets_entry;
-			}
-			if (child_data.validity.RowIsValid(child_offset)) {
-				if (!VALIDITY_ONLY) {
-					result_data[i] = ((T *)child_data.data)[child_offset];
-				}
-			} else {
+			child_offset = list_entry.offset + list_entry.length + offsets_entry;
+		} else {
+			if ((idx_t)offsets_entry >= list_entry.length) {
 				result_mask.SetInvalid(i);
+				continue;
+			}
+			child_offset = list_entry.offset + offsets_entry;
+		}
+		auto child_index = child_format.sel->get_index(child_offset);
+		if (child_format.validity.RowIsValid(child_index)) {
+			if (!VALIDITY_ONLY) {
+				result_data[i] = child_data[child_index];
 			}
 		} else {
 			result_mask.SetInvalid(i);
diff --git a/src/function/scalar/list/list_lambdas.cpp b/src/function/scalar/list/list_lambdas.cpp
index b5577c538df5..47aa7aae695f 100644
--- a/src/function/scalar/list/list_lambdas.cpp
+++ b/src/function/scalar/list/list_lambdas.cpp
@@ -167,6 +167,7 @@ static void ListLambdaFunction(DataChunk &args, ExpressionState &state, Vector &
 	// get the child vector and child data
 	auto lists_size = ListVector::GetListSize(lists);
 	auto &child_vector = ListVector::GetEntry(lists);
+	child_vector.Flatten(lists_size);
 	UnifiedVectorFormat child_data;
 	child_vector.ToUnifiedFormat(lists_size, child_data);
 
@@ -251,10 +252,8 @@ static void ListLambdaFunction(DataChunk &args, ExpressionState &state, Vector &
 
 		// iterate list elements and create transformed expression columns
 		for (idx_t child_idx = 0; child_idx < list_entry.length; child_idx++) {
-
 			// reached STANDARD_VECTOR_SIZE elements
 			if (elem_cnt == STANDARD_VECTOR_SIZE) {
-
 				lambda_chunk.Reset();
 				ExecuteExpression(types, result_types, elem_cnt, sel, sel_vectors, input_chunk, lambda_chunk,
 				                  child_vector, args, expr_executor);
