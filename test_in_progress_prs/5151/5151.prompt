You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
"ERROR: AddressSanitizer: heap-buffer-overflow" when in on-disk mode (not in-memory) when working with arrays
### What happens?

JDBC and CLI fail when working with arrays. In the case of JDBC, JVM crashes (the crash reports are not very informative). I was able to reproduce the JDBC issue on mac and linux. To reproduce in CLI I used mac, client versions 0.5.1 and 0.4.0. With `make debug` on 0.4.0 the report looks like this:
```
=================================================================
==49159==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x61a0000005c0 at pc 0x000126c08f20 bp 0x70000702fa50 sp 0x70000702f218
READ of size 16 at 0x61a0000005c0 thread T1
    #0 0x126c08f1f in __asan_memcpy+0x1af (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x48f1f)
    #1 0x1127fc1dc in void duckdb::ListExtractTemplate<duckdb::string_t, true, false>(unsigned long long, duckdb::VectorData&, duckdb::VectorData&, duckdb::Vector&, unsigned long long, duckdb::Vector&) list_extract.cpp:66
    #2 0x1127ecf98 in duckdb::ExecuteListExtractInternal(unsigned long long, duckdb::VectorData&, duckdb::VectorData&, duckdb::Vector&, unsigned long long, duckdb::Vector&) list_extract.cpp:118
    #3 0x1127eb866 in duckdb::ExecuteListExtract(duckdb::Vector&, duckdb::Vector&, duckdb::Vector&, unsigned long long) list_extract.cpp:156
    #4 0x11274090c in duckdb::ListExtractFunction(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&) list_extract.cpp:184
    #5 0x112a5d10e in decltype(static_cast<void (*&>(fp)(static_cast<duckdb::DataChunk&>(fp0), static_cast<duckdb::ExpressionState&>(fp0), static_cast<duckdb::Vector&>(fp0))) std::__1::__invoke<void (*&)(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&), duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&>(void (*&)(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&), duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&) type_traits:3918
    #6 0x112a5ce94 in void std::__1::__invoke_void_return_wrapper<void, true>::__call<void (*&)(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&), duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&>(void (*&)(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&), duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&) invoke.h:61
    #7 0x112a5cb6c in std::__1::__function::__alloc_func<void (*)(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&), std::__1::allocator<void (*)(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&)>, void (duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&)>::operator()(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&) function.h:178
    #8 0x112a566c0 in std::__1::__function::__func<void (*)(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&), std::__1::allocator<void (*)(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&)>, void (duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&)>::operator()(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&) function.h:352
    #9 0x115469400 in std::__1::__function::__value_func<void (duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&)>::operator()(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&) const function.h:505
    #10 0x11505b7b0 in std::__1::function<void (duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&)>::operator()(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&) const function.h:1182
    #11 0x11505af2a in duckdb::ExpressionExecutor::Execute(duckdb::BoundFunctionExpression const&, duckdb::ExpressionState*, duckdb::SelectionVector const*, unsigned long long, duckdb::Vector&) execute_function.cpp:44
    #12 0x115e6b6e2 in duckdb::ExpressionExecutor::Execute(duckdb::Expression const&, duckdb::ExpressionState*, duckdb::SelectionVector const*, unsigned long long, duckdb::Vector&) expression_executor.cpp:173
    #13 0x115e68b0f in duckdb::ExpressionExecutor::ExecuteExpression(unsigned long long, duckdb::Vector&) expression_executor.cpp:75
    #14 0x115e680b0 in duckdb::ExpressionExecutor::Execute(duckdb::DataChunk*, duckdb::DataChunk&) expression_executor.cpp:46
    #15 0x116e65884 in duckdb::ExpressionExecutor::Execute(duckdb::DataChunk&, duckdb::DataChunk&) expression_executor.hpp:32
    #16 0x115b18160 in duckdb::PhysicalProjection::Execute(duckdb::ExecutionContext&, duckdb::DataChunk&, duckdb::DataChunk&, duckdb::GlobalOperatorState&, duckdb::OperatorState&) const physical_projection.cpp:29
    #17 0x11680c3b7 in duckdb::PipelineExecutor::Execute(duckdb::DataChunk&, duckdb::DataChunk&, unsigned long long) pipeline_executor.cpp:292
    #18 0x1168093a2 in duckdb::PipelineExecutor::ExecutePushInternal(duckdb::DataChunk&, unsigned long long) pipeline_executor.cpp:103
    #19 0x116807f80 in duckdb::PipelineExecutor::Execute(unsigned long long) pipeline_executor.cpp:64
    #20 0x11680b2c0 in duckdb::PipelineExecutor::Execute() pipeline_executor.cpp:78
    #21 0x1168b3d06 in duckdb::PipelineTask::ExecuteTask(duckdb::TaskExecutionMode) pipeline.cpp:43
    #22 0x1167cf946 in duckdb::ExecutorTask::Execute(duckdb::TaskExecutionMode) executor_task.cpp:17
    #23 0x116812360 in duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) task_scheduler.cpp:135
    #24 0x1168140c8 in duckdb::ThreadExecuteTasks(duckdb::TaskScheduler*, std::__1::atomic<bool>*) task_scheduler.cpp:166
    #25 0x116911872 in decltype(static_cast<void (*>(fp)(static_cast<duckdb::TaskScheduler*>(fp0), static_cast<std::__1::atomic<bool>*>(fp0))) std::__1::__invoke<void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>(void (*&&)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*&&, std::__1::atomic<bool>*&&) type_traits:3918
    #26 0x116911668 in void std::__1::__thread_execute<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*, 2ul, 3ul>(std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>&, std::__1::__tuple_indices<2ul, 3ul>) thread:287
    #27 0x11690ec06 in void* std::__1::__thread_proxy<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*> >(void*) thread:298
    #28 0x7ff8009504e0 in _pthread_start+0x7c (libsystem_pthread.dylib:x86_64+0x64e0)
    #29 0x7ff80094bf6a in thread_start+0xe (libsystem_pthread.dylib:x86_64+0x1f6a)

0x61a0000005c0 is located 0 bytes to the right of 1344-byte region [0x61a000000080,0x61a0000005c0)
allocated by thread T1 here:
    #0 0x126c1c2bd in wrap__Znam+0x7d (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x5c2bd)
    #1 0x113fc4ef4 in duckdb::VectorBuffer::VectorBuffer(unsigned long long) vector_buffer.hpp:56
    #2 0x113fc4510 in duckdb::VectorBuffer::VectorBuffer(unsigned long long) vector_buffer.hpp:54
    #3 0x113fc4347 in std::__1::__shared_ptr_emplace<duckdb::VectorBuffer, std::__1::allocator<duckdb::VectorBuffer> >::__shared_ptr_emplace<unsigned long long>(std::__1::allocator<duckdb::VectorBuffer>, unsigned long long&&) shared_ptr.h:298
    #4 0x113fc3630 in std::__1::__shared_ptr_emplace<duckdb::VectorBuffer, std::__1::allocator<duckdb::VectorBuffer> >::__shared_ptr_emplace<unsigned long long>(std::__1::allocator<duckdb::VectorBuffer>, unsigned long long&&) shared_ptr.h:292
    #5 0x113fc3212 in std::__1::shared_ptr<duckdb::VectorBuffer> std::__1::allocate_shared<duckdb::VectorBuffer, std::__1::allocator<duckdb::VectorBuffer>, unsigned long long, void>(std::__1::allocator<duckdb::VectorBuffer> const&, unsigned long long&&) shared_ptr.h:1106
    #6 0x113fc2f7a in std::__1::shared_ptr<duckdb::VectorBuffer> std::__1::make_shared<duckdb::VectorBuffer, unsigned long long, void>(unsigned long long&&) shared_ptr.h:1115
    #7 0x113e2407f in std::__1::shared_ptr<duckdb::VectorBuffer> duckdb::make_buffer<duckdb::VectorBuffer, unsigned long long>(unsigned long long&&) types.hpp:199
    #8 0x113e23f57 in duckdb::VectorBuffer::CreateStandardVector(duckdb::PhysicalType, unsigned long long) vector_buffer.cpp:12
    #9 0x113e24315 in duckdb::VectorBuffer::CreateStandardVector(duckdb::LogicalType const&, unsigned long long) vector_buffer.cpp:24
    #10 0x113e29c85 in duckdb::Vector::Initialize(bool, unsigned long long) vector.cpp:216
    #11 0x113e2951c in duckdb::Vector::Vector(duckdb::LogicalType, bool, bool, unsigned long long) vector.cpp:24
    #12 0x113e2a133 in duckdb::Vector::Vector(duckdb::LogicalType, bool, bool, unsigned long long) vector.cpp:22
    #13 0x113e1badd in duckdb::Vector::Vector(duckdb::LogicalType, unsigned long long) vector.cpp:28
    #14 0x116a81383 in std::__1::__shared_ptr_emplace<duckdb::Vector, std::__1::allocator<duckdb::Vector> >::__shared_ptr_emplace<duckdb::LogicalType&, unsigned int&>(std::__1::allocator<duckdb::Vector>, duckdb::LogicalType&, unsigned int&) shared_ptr.h:298
    #15 0x116a80588 in std::__1::__shared_ptr_emplace<duckdb::Vector, std::__1::allocator<duckdb::Vector> >::__shared_ptr_emplace<duckdb::LogicalType&, unsigned int&>(std::__1::allocator<duckdb::Vector>, duckdb::LogicalType&, unsigned int&) shared_ptr.h:292
    #16 0x116a80155 in std::__1::shared_ptr<duckdb::Vector> std::__1::allocate_shared<duckdb::Vector, std::__1::allocator<duckdb::Vector>, duckdb::LogicalType&, unsigned int&, void>(std::__1::allocator<duckdb::Vector> const&, duckdb::LogicalType&, unsigned int&) shared_ptr.h:1106
    #17 0x116a7fd6f in std::__1::shared_ptr<duckdb::Vector> std::__1::make_shared<duckdb::Vector, duckdb::LogicalType&, unsigned int&, void>(duckdb::LogicalType&, unsigned int&) shared_ptr.h:1115
    #18 0x116942557 in std::__1::shared_ptr<duckdb::Vector> duckdb::make_buffer<duckdb::Vector, duckdb::LogicalType&, unsigned int&>(duckdb::LogicalType&, unsigned int&) types.hpp:199
    #19 0x116940c9b in duckdb::DictionaryCompressionStorage::StringInitScan(duckdb::ColumnSegment&) dictionary_compression.cpp:435
    #20 0x116bbaa31 in duckdb::ColumnSegment::InitializeScan(duckdb::ColumnScanState&) column_segment.cpp:74
    #21 0x116bc3b98 in duckdb::ColumnData::ScanVector(duckdb::ColumnScanState&, duckdb::Vector&, unsigned long long) column_data.cpp:62
    #22 0x116bcce54 in duckdb::ColumnData::ScanCount(duckdb::ColumnScanState&, duckdb::Vector&, unsigned long long) column_data.cpp:153
    #23 0x116c6361c in duckdb::StandardColumnData::ScanCount(duckdb::ColumnScanState&, duckdb::Vector&, unsigned long long) standard_column_data.cpp:71
    #24 0x116c0cc71 in duckdb::ListColumnData::ScanCount(duckdb::ColumnScanState&, duckdb::Vector&, unsigned long long) list_column_data.cpp:110
    #25 0x116c0b367 in duckdb::ListColumnData::Scan(duckdb::Transaction&, unsigned long long, duckdb::ColumnScanState&, duckdb::Vector&) list_column_data.cpp:70
    #26 0x116c3917e in void duckdb::RowGroup::TemplatedScan<(duckdb::TableScanType)0>(duckdb::Transaction*, duckdb::RowGroupScanState&, duckdb::DataChunk&) row_group.cpp:345
    #27 0x116c37c18 in duckdb::RowGroup::Scan(duckdb::Transaction&, duckdb::RowGroupScanState&, duckdb::DataChunk&) row_group.cpp:430
    #28 0x116e408b0 in duckdb::DataTable::ScanBaseTable(duckdb::Transaction&, duckdb::DataChunk&, duckdb::TableScanState&) data_table.cpp:391
    #29 0x116e404d0 in duckdb::DataTable::Scan(duckdb::Transaction&, duckdb::DataChunk&, duckdb::TableScanState&, std::__1::vector<unsigned long long, std::__1::allocator<unsigned long long> >&) data_table.cpp:379

Thread T1 created by T0 here:
    #0 0x126c0493c in wrap_pthread_create+0x5c (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x4493c)
    #1 0x11690ea00 in std::__1::__libcpp_thread_create(_opaque_pthread_t**, void* (*)(void*), void*) __threading_support:421
    #2 0x11690e38f in std::__1::thread::thread<void (&)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*, void>(void (&)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*&&, std::__1::atomic<bool>*&&) thread:314
    #3 0x11690de10 in std::__1::thread::thread<void (&)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*, void>(void (&)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*&&, std::__1::atomic<bool>*&&) thread:306
    #4 0x116814000 in std::__1::unique_ptr<std::__1::thread, std::__1::default_delete<std::__1::thread> > duckdb::make_unique<std::__1::thread, void (&)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>(void (&)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*&&, std::__1::atomic<bool>*&&) helper.hpp:41
    #5 0x11681132c in duckdb::TaskScheduler::SetThreadsInternal(int) task_scheduler.cpp:214
    #6 0x116813664 in duckdb::TaskScheduler::SetThreads(int) task_scheduler.cpp:180
    #7 0x1163db569 in duckdb::DatabaseInstance::Initialize(char const*, duckdb::DBConfig*) database.cpp:137
    #8 0x1163de3bd in duckdb::DuckDB::DuckDB(char const*, duckdb::DBConfig*) database.cpp:141
    #9 0x1163de738 in duckdb::DuckDB::DuckDB(char const*, duckdb::DBConfig*) database.cpp:140
    #10 0x10ff708c8 in std::__1::unique_ptr<duckdb::DuckDB, std::__1::default_delete<duckdb::DuckDB> > duckdb::make_unique<duckdb::DuckDB, char const*&, duckdb::DBConfig*>(char const*&, duckdb::DBConfig*&&) helper.hpp:41
    #11 0x10ff6fe78 in sqlite3_open_v2 sqlite3_api_wrapper.cpp:97
    #12 0x10fe75789 in open_db shell.c:14246
    #13 0x10fe90933 in do_meta_command shell.c:18351
    #14 0x10feab1ad in process_input shell.c:20073
    #15 0x10fe72f2c in main shell.c:20900
    #16 0x126b0d52d in start+0x1cd (dyld:x86_64+0x552d)

SUMMARY: AddressSanitizer: heap-buffer-overflow (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x48f1f) in __asan_memcpy+0x1af
Shadow bytes around the buggy address:
  0x1c3400000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x1c3400000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x1c3400000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x1c3400000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x1c34000000a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x1c34000000b0: 00 00 00 00 00 00 00 00[fa]fa fa fa fa fa fa fa
  0x1c34000000c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x1c34000000d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x1c34000000e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x1c34000000f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x1c3400000100: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==49159==ABORTING

```

### To Reproduce

```sql
$ ./duckdb
.open db1

create table t1 as
select
	h1,
	h2,
	h3,
	LOWER(TRIM(s)) as s,
from
	read_csv_auto('jvm_crash3.csv', ALL_VARCHAR = 1);

create table t2 (
    h1 VARCHAR,
    h2 VARCHAR,
    h3 VARCHAR,
    s VARCHAR[],
    primary key(h1)
);

insert into	
	t2 
select
	h1,
	h2,
	h3,
	string_to_array(s, ',') as s
from t1;
drop table t1;

create table t3 as select s[1] from t2;
```

### OS:

Linux, MaxOS

### DuckDB Version:

0.4.0, 0.4.1, 0.5.1

### DuckDB Client:

CLI, JDBC

### Full Name:

Andrii Karaivanskyi

### Affiliation:

Indeed

### Have you tried this on the latest `master` branch?

- [X] I agree

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] I agree
"ERROR: AddressSanitizer: heap-buffer-overflow" when in on-disk mode (not in-memory) when working with arrays
### What happens?

JDBC and CLI fail when working with arrays. In the case of JDBC, JVM crashes (the crash reports are not very informative). I was able to reproduce the JDBC issue on mac and linux. To reproduce in CLI I used mac, client versions 0.5.1 and 0.4.0. With `make debug` on 0.4.0 the report looks like this:
```
=================================================================
==49159==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x61a0000005c0 at pc 0x000126c08f20 bp 0x70000702fa50 sp 0x70000702f218
READ of size 16 at 0x61a0000005c0 thread T1
    #0 0x126c08f1f in __asan_memcpy+0x1af (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x48f1f)
    #1 0x1127fc1dc in void duckdb::ListExtractTemplate<duckdb::string_t, true, false>(unsigned long long, duckdb::VectorData&, duckdb::VectorData&, duckdb::Vector&, unsigned long long, duckdb::Vector&) list_extract.cpp:66
    #2 0x1127ecf98 in duckdb::ExecuteListExtractInternal(unsigned long long, duckdb::VectorData&, duckdb::VectorData&, duckdb::Vector&, unsigned long long, duckdb::Vector&) list_extract.cpp:118
    #3 0x1127eb866 in duckdb::ExecuteListExtract(duckdb::Vector&, duckdb::Vector&, duckdb::Vector&, unsigned long long) list_extract.cpp:156
    #4 0x11274090c in duckdb::ListExtractFunction(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&) list_extract.cpp:184
    #5 0x112a5d10e in decltype(static_cast<void (*&>(fp)(static_cast<duckdb::DataChunk&>(fp0), static_cast<duckdb::ExpressionState&>(fp0), static_cast<duckdb::Vector&>(fp0))) std::__1::__invoke<void (*&)(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&), duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&>(void (*&)(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&), duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&) type_traits:3918
    #6 0x112a5ce94 in void std::__1::__invoke_void_return_wrapper<void, true>::__call<void (*&)(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&), duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&>(void (*&)(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&), duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&) invoke.h:61
    #7 0x112a5cb6c in std::__1::__function::__alloc_func<void (*)(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&), std::__1::allocator<void (*)(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&)>, void (duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&)>::operator()(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&) function.h:178
    #8 0x112a566c0 in std::__1::__function::__func<void (*)(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&), std::__1::allocator<void (*)(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&)>, void (duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&)>::operator()(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&) function.h:352
    #9 0x115469400 in std::__1::__function::__value_func<void (duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&)>::operator()(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&) const function.h:505
    #10 0x11505b7b0 in std::__1::function<void (duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&)>::operator()(duckdb::DataChunk&, duckdb::ExpressionState&, duckdb::Vector&) const function.h:1182
    #11 0x11505af2a in duckdb::ExpressionExecutor::Execute(duckdb::BoundFunctionExpression const&, duckdb::ExpressionState*, duckdb::SelectionVector const*, unsigned long long, duckdb::Vector&) execute_function.cpp:44
    #12 0x115e6b6e2 in duckdb::ExpressionExecutor::Execute(duckdb::Expression const&, duckdb::ExpressionState*, duckdb::SelectionVector const*, unsigned long long, duckdb::Vector&) expression_executor.cpp:173
    #13 0x115e68b0f in duckdb::ExpressionExecutor::ExecuteExpression(unsigned long long, duckdb::Vector&) expression_executor.cpp:75
    #14 0x115e680b0 in duckdb::ExpressionExecutor::Execute(duckdb::DataChunk*, duckdb::DataChunk&) expression_executor.cpp:46
    #15 0x116e65884 in duckdb::ExpressionExecutor::Execute(duckdb::DataChunk&, duckdb::DataChunk&) expression_executor.hpp:32
    #16 0x115b18160 in duckdb::PhysicalProjection::Execute(duckdb::ExecutionContext&, duckdb::DataChunk&, duckdb::DataChunk&, duckdb::GlobalOperatorState&, duckdb::OperatorState&) const physical_projection.cpp:29
    #17 0x11680c3b7 in duckdb::PipelineExecutor::Execute(duckdb::DataChunk&, duckdb::DataChunk&, unsigned long long) pipeline_executor.cpp:292
    #18 0x1168093a2 in duckdb::PipelineExecutor::ExecutePushInternal(duckdb::DataChunk&, unsigned long long) pipeline_executor.cpp:103
    #19 0x116807f80 in duckdb::PipelineExecutor::Execute(unsigned long long) pipeline_executor.cpp:64
    #20 0x11680b2c0 in duckdb::PipelineExecutor::Execute() pipeline_executor.cpp:78
    #21 0x1168b3d06 in duckdb::PipelineTask::ExecuteTask(duckdb::TaskExecutionMode) pipeline.cpp:43
    #22 0x1167cf946 in duckdb::ExecutorTask::Execute(duckdb::TaskExecutionMode) executor_task.cpp:17
    #23 0x116812360 in duckdb::TaskScheduler::ExecuteForever(std::__1::atomic<bool>*) task_scheduler.cpp:135
    #24 0x1168140c8 in duckdb::ThreadExecuteTasks(duckdb::TaskScheduler*, std::__1::atomic<bool>*) task_scheduler.cpp:166
    #25 0x116911872 in decltype(static_cast<void (*>(fp)(static_cast<duckdb::TaskScheduler*>(fp0), static_cast<std::__1::atomic<bool>*>(fp0))) std::__1::__invoke<void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>(void (*&&)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*&&, std::__1::atomic<bool>*&&) type_traits:3918
    #26 0x116911668 in void std::__1::__thread_execute<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*, 2ul, 3ul>(std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>&, std::__1::__tuple_indices<2ul, 3ul>) thread:287
    #27 0x11690ec06 in void* std::__1::__thread_proxy<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, void (*)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*> >(void*) thread:298
    #28 0x7ff8009504e0 in _pthread_start+0x7c (libsystem_pthread.dylib:x86_64+0x64e0)
    #29 0x7ff80094bf6a in thread_start+0xe (libsystem_pthread.dylib:x86_64+0x1f6a)

0x61a0000005c0 is located 0 bytes to the right of 1344-byte region [0x61a000000080,0x61a0000005c0)
allocated by thread T1 here:
    #0 0x126c1c2bd in wrap__Znam+0x7d (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x5c2bd)
    #1 0x113fc4ef4 in duckdb::VectorBuffer::VectorBuffer(unsigned long long) vector_buffer.hpp:56
    #2 0x113fc4510 in duckdb::VectorBuffer::VectorBuffer(unsigned long long) vector_buffer.hpp:54
    #3 0x113fc4347 in std::__1::__shared_ptr_emplace<duckdb::VectorBuffer, std::__1::allocator<duckdb::VectorBuffer> >::__shared_ptr_emplace<unsigned long long>(std::__1::allocator<duckdb::VectorBuffer>, unsigned long long&&) shared_ptr.h:298
    #4 0x113fc3630 in std::__1::__shared_ptr_emplace<duckdb::VectorBuffer, std::__1::allocator<duckdb::VectorBuffer> >::__shared_ptr_emplace<unsigned long long>(std::__1::allocator<duckdb::VectorBuffer>, unsigned long long&&) shared_ptr.h:292
    #5 0x113fc3212 in std::__1::shared_ptr<duckdb::VectorBuffer> std::__1::allocate_shared<duckdb::VectorBuffer, std::__1::allocator<duckdb::VectorBuffer>, unsigned long long, void>(std::__1::allocator<duckdb::VectorBuffer> const&, unsigned long long&&) shared_ptr.h:1106
    #6 0x113fc2f7a in std::__1::shared_ptr<duckdb::VectorBuffer> std::__1::make_shared<duckdb::VectorBuffer, unsigned long long, void>(unsigned long long&&) shared_ptr.h:1115
    #7 0x113e2407f in std::__1::shared_ptr<duckdb::VectorBuffer> duckdb::make_buffer<duckdb::VectorBuffer, unsigned long long>(unsigned long long&&) types.hpp:199
    #8 0x113e23f57 in duckdb::VectorBuffer::CreateStandardVector(duckdb::PhysicalType, unsigned long long) vector_buffer.cpp:12
    #9 0x113e24315 in duckdb::VectorBuffer::CreateStandardVector(duckdb::LogicalType const&, unsigned long long) vector_buffer.cpp:24
    #10 0x113e29c85 in duckdb::Vector::Initialize(bool, unsigned long long) vector.cpp:216
    #11 0x113e2951c in duckdb::Vector::Vector(duckdb::LogicalType, bool, bool, unsigned long long) vector.cpp:24
    #12 0x113e2a133 in duckdb::Vector::Vector(duckdb::LogicalType, bool, bool, unsigned long long) vector.cpp:22
    #13 0x113e1badd in duckdb::Vector::Vector(duckdb::LogicalType, unsigned long long) vector.cpp:28
    #14 0x116a81383 in std::__1::__shared_ptr_emplace<duckdb::Vector, std::__1::allocator<duckdb::Vector> >::__shared_ptr_emplace<duckdb::LogicalType&, unsigned int&>(std::__1::allocator<duckdb::Vector>, duckdb::LogicalType&, unsigned int&) shared_ptr.h:298
    #15 0x116a80588 in std::__1::__shared_ptr_emplace<duckdb::Vector, std::__1::allocator<duckdb::Vector> >::__shared_ptr_emplace<duckdb::LogicalType&, unsigned int&>(std::__1::allocator<duckdb::Vector>, duckdb::LogicalType&, unsigned int&) shared_ptr.h:292
    #16 0x116a80155 in std::__1::shared_ptr<duckdb::Vector> std::__1::allocate_shared<duckdb::Vector, std::__1::allocator<duckdb::Vector>, duckdb::LogicalType&, unsigned int&, void>(std::__1::allocator<duckdb::Vector> const&, duckdb::LogicalType&, unsigned int&) shared_ptr.h:1106
    #17 0x116a7fd6f in std::__1::shared_ptr<duckdb::Vector> std::__1::make_shared<duckdb::Vector, duckdb::LogicalType&, unsigned int&, void>(duckdb::LogicalType&, unsigned int&) shared_ptr.h:1115
    #18 0x116942557 in std::__1::shared_ptr<duckdb::Vector> duckdb::make_buffer<duckdb::Vector, duckdb::LogicalType&, unsigned int&>(duckdb::LogicalType&, unsigned int&) types.hpp:199
    #19 0x116940c9b in duckdb::DictionaryCompressionStorage::StringInitScan(duckdb::ColumnSegment&) dictionary_compression.cpp:435
    #20 0x116bbaa31 in duckdb::ColumnSegment::InitializeScan(duckdb::ColumnScanState&) column_segment.cpp:74
    #21 0x116bc3b98 in duckdb::ColumnData::ScanVector(duckdb::ColumnScanState&, duckdb::Vector&, unsigned long long) column_data.cpp:62
    #22 0x116bcce54 in duckdb::ColumnData::ScanCount(duckdb::ColumnScanState&, duckdb::Vector&, unsigned long long) column_data.cpp:153
    #23 0x116c6361c in duckdb::StandardColumnData::ScanCount(duckdb::ColumnScanState&, duckdb::Vector&, unsigned long long) standard_column_data.cpp:71
    #24 0x116c0cc71 in duckdb::ListColumnData::ScanCount(duckdb::ColumnScanState&, duckdb::Vector&, unsigned long long) list_column_data.cpp:110
    #25 0x116c0b367 in duckdb::ListColumnData::Scan(duckdb::Transaction&, unsigned long long, duckdb::ColumnScanState&, duckdb::Vector&) list_column_data.cpp:70
    #26 0x116c3917e in void duckdb::RowGroup::TemplatedScan<(duckdb::TableScanType)0>(duckdb::Transaction*, duckdb::RowGroupScanState&, duckdb::DataChunk&) row_group.cpp:345
    #27 0x116c37c18 in duckdb::RowGroup::Scan(duckdb::Transaction&, duckdb::RowGroupScanState&, duckdb::DataChunk&) row_group.cpp:430
    #28 0x116e408b0 in duckdb::DataTable::ScanBaseTable(duckdb::Transaction&, duckdb::DataChunk&, duckdb::TableScanState&) data_table.cpp:391
    #29 0x116e404d0 in duckdb::DataTable::Scan(duckdb::Transaction&, duckdb::DataChunk&, duckdb::TableScanState&, std::__1::vector<unsigned long long, std::__1::allocator<unsigned long long> >&) data_table.cpp:379

Thread T1 created by T0 here:
    #0 0x126c0493c in wrap_pthread_create+0x5c (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x4493c)
    #1 0x11690ea00 in std::__1::__libcpp_thread_create(_opaque_pthread_t**, void* (*)(void*), void*) __threading_support:421
    #2 0x11690e38f in std::__1::thread::thread<void (&)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*, void>(void (&)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*&&, std::__1::atomic<bool>*&&) thread:314
    #3 0x11690de10 in std::__1::thread::thread<void (&)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*, void>(void (&)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*&&, std::__1::atomic<bool>*&&) thread:306
    #4 0x116814000 in std::__1::unique_ptr<std::__1::thread, std::__1::default_delete<std::__1::thread> > duckdb::make_unique<std::__1::thread, void (&)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*, std::__1::atomic<bool>*>(void (&)(duckdb::TaskScheduler*, std::__1::atomic<bool>*), duckdb::TaskScheduler*&&, std::__1::atomic<bool>*&&) helper.hpp:41
    #5 0x11681132c in duckdb::TaskScheduler::SetThreadsInternal(int) task_scheduler.cpp:214
    #6 0x116813664 in duckdb::TaskScheduler::SetThreads(int) task_scheduler.cpp:180
    #7 0x1163db569 in duckdb::DatabaseInstance::Initialize(char const*, duckdb::DBConfig*) database.cpp:137
    #8 0x1163de3bd in duckdb::DuckDB::DuckDB(char const*, duckdb::DBConfig*) database.cpp:141
    #9 0x1163de738 in duckdb::DuckDB::DuckDB(char const*, duckdb::DBConfig*) database.cpp:140
    #10 0x10ff708c8 in std::__1::unique_ptr<duckdb::DuckDB, std::__1::default_delete<duckdb::DuckDB> > duckdb::make_unique<duckdb::DuckDB, char const*&, duckdb::DBConfig*>(char const*&, duckdb::DBConfig*&&) helper.hpp:41
    #11 0x10ff6fe78 in sqlite3_open_v2 sqlite3_api_wrapper.cpp:97
    #12 0x10fe75789 in open_db shell.c:14246
    #13 0x10fe90933 in do_meta_command shell.c:18351
    #14 0x10feab1ad in process_input shell.c:20073
    #15 0x10fe72f2c in main shell.c:20900
    #16 0x126b0d52d in start+0x1cd (dyld:x86_64+0x552d)

SUMMARY: AddressSanitizer: heap-buffer-overflow (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x48f1f) in __asan_memcpy+0x1af
Shadow bytes around the buggy address:
  0x1c3400000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x1c3400000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x1c3400000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x1c3400000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x1c34000000a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x1c34000000b0: 00 00 00 00 00 00 00 00[fa]fa fa fa fa fa fa fa
  0x1c34000000c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x1c34000000d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x1c34000000e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x1c34000000f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x1c3400000100: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==49159==ABORTING

```

### To Reproduce

```sql
$ ./duckdb
.open db1

create table t1 as
select
	h1,
	h2,
	h3,
	LOWER(TRIM(s)) as s,
from
	read_csv_auto('jvm_crash3.csv', ALL_VARCHAR = 1);

create table t2 (
    h1 VARCHAR,
    h2 VARCHAR,
    h3 VARCHAR,
    s VARCHAR[],
    primary key(h1)
);

insert into	
	t2 
select
	h1,
	h2,
	h3,
	string_to_array(s, ',') as s
from t1;
drop table t1;

create table t3 as select s[1] from t2;
```

### OS:

Linux, MaxOS

### DuckDB Version:

0.4.0, 0.4.1, 0.5.1

### DuckDB Client:

CLI, JDBC

### Full Name:

Andrii Karaivanskyi

### Affiliation:

Indeed

### Have you tried this on the latest `master` branch?

- [X] I agree

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] I agree

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=master" alt="Github Actions Badge">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The detail of benchmarks is in our [Benchmark Guide](benchmark/README.md).
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
[end of README.md]
[start of src/common/row_operations/row_radix_scatter.cpp]
1: #include "duckdb/common/helper.hpp"
2: #include "duckdb/common/radix.hpp"
3: #include "duckdb/common/row_operations/row_operations.hpp"
4: #include "duckdb/common/types/vector.hpp"
5: 
6: namespace duckdb {
7: 
8: template <class T>
9: void TemplatedRadixScatter(UnifiedVectorFormat &vdata, const SelectionVector &sel, idx_t add_count,
10:                            data_ptr_t *key_locations, const bool desc, const bool has_null, const bool nulls_first,
11:                            const idx_t offset) {
12: 	auto source = (T *)vdata.data;
13: 	if (has_null) {
14: 		auto &validity = vdata.validity;
15: 		const data_t valid = nulls_first ? 1 : 0;
16: 		const data_t invalid = 1 - valid;
17: 
18: 		for (idx_t i = 0; i < add_count; i++) {
19: 			auto idx = sel.get_index(i);
20: 			auto source_idx = vdata.sel->get_index(idx) + offset;
21: 			// write validity and according value
22: 			if (validity.RowIsValid(source_idx)) {
23: 				key_locations[i][0] = valid;
24: 				Radix::EncodeData<T>(key_locations[i] + 1, source[source_idx]);
25: 				// invert bits if desc
26: 				if (desc) {
27: 					for (idx_t s = 1; s < sizeof(T) + 1; s++) {
28: 						*(key_locations[i] + s) = ~*(key_locations[i] + s);
29: 					}
30: 				}
31: 			} else {
32: 				key_locations[i][0] = invalid;
33: 				memset(key_locations[i] + 1, '\0', sizeof(T));
34: 			}
35: 			key_locations[i] += sizeof(T) + 1;
36: 		}
37: 	} else {
38: 		for (idx_t i = 0; i < add_count; i++) {
39: 			auto idx = sel.get_index(i);
40: 			auto source_idx = vdata.sel->get_index(idx) + offset;
41: 			// write value
42: 			Radix::EncodeData<T>(key_locations[i], source[source_idx]);
43: 			// invert bits if desc
44: 			if (desc) {
45: 				for (idx_t s = 0; s < sizeof(T); s++) {
46: 					*(key_locations[i] + s) = ~*(key_locations[i] + s);
47: 				}
48: 			}
49: 			key_locations[i] += sizeof(T);
50: 		}
51: 	}
52: }
53: 
54: void RadixScatterStringVector(UnifiedVectorFormat &vdata, const SelectionVector &sel, idx_t add_count,
55:                               data_ptr_t *key_locations, const bool desc, const bool has_null, const bool nulls_first,
56:                               const idx_t prefix_len, idx_t offset) {
57: 	auto source = (string_t *)vdata.data;
58: 	if (has_null) {
59: 		auto &validity = vdata.validity;
60: 		const data_t valid = nulls_first ? 1 : 0;
61: 		const data_t invalid = 1 - valid;
62: 
63: 		for (idx_t i = 0; i < add_count; i++) {
64: 			auto idx = sel.get_index(i);
65: 			auto source_idx = vdata.sel->get_index(idx) + offset;
66: 			// write validity and according value
67: 			if (validity.RowIsValid(source_idx)) {
68: 				key_locations[i][0] = valid;
69: 				Radix::EncodeStringDataPrefix(key_locations[i] + 1, source[source_idx], prefix_len);
70: 				// invert bits if desc
71: 				if (desc) {
72: 					for (idx_t s = 1; s < prefix_len + 1; s++) {
73: 						*(key_locations[i] + s) = ~*(key_locations[i] + s);
74: 					}
75: 				}
76: 			} else {
77: 				key_locations[i][0] = invalid;
78: 				memset(key_locations[i] + 1, '\0', prefix_len);
79: 			}
80: 			key_locations[i] += prefix_len + 1;
81: 		}
82: 	} else {
83: 		for (idx_t i = 0; i < add_count; i++) {
84: 			auto idx = sel.get_index(i);
85: 			auto source_idx = vdata.sel->get_index(idx) + offset;
86: 			// write value
87: 			Radix::EncodeStringDataPrefix(key_locations[i], source[source_idx], prefix_len);
88: 			// invert bits if desc
89: 			if (desc) {
90: 				for (idx_t s = 0; s < prefix_len; s++) {
91: 					*(key_locations[i] + s) = ~*(key_locations[i] + s);
92: 				}
93: 			}
94: 			key_locations[i] += prefix_len;
95: 		}
96: 	}
97: }
98: 
99: void RadixScatterListVector(Vector &v, UnifiedVectorFormat &vdata, const SelectionVector &sel, idx_t add_count,
100:                             data_ptr_t *key_locations, const bool desc, const bool has_null, const bool nulls_first,
101:                             const idx_t prefix_len, const idx_t width, const idx_t offset) {
102: 	auto list_data = ListVector::GetData(v);
103: 	auto &child_vector = ListVector::GetEntry(v);
104: 	auto list_size = ListVector::GetListSize(v);
105: 
106: 	// serialize null values
107: 	if (has_null) {
108: 		auto &validity = vdata.validity;
109: 		const data_t valid = nulls_first ? 1 : 0;
110: 		const data_t invalid = 1 - valid;
111: 
112: 		for (idx_t i = 0; i < add_count; i++) {
113: 			auto idx = sel.get_index(i);
114: 			auto source_idx = vdata.sel->get_index(idx) + offset;
115: 			data_ptr_t key_location = key_locations[i] + 1;
116: 			// write validity and according value
117: 			if (validity.RowIsValid(source_idx)) {
118: 				key_locations[i][0] = valid;
119: 				key_locations[i]++;
120: 				auto &list_entry = list_data[source_idx];
121: 				if (list_entry.length > 0) {
122: 					// denote that the list is not empty with a 1
123: 					key_locations[i][0] = 1;
124: 					key_locations[i]++;
125: 					RowOperations::RadixScatter(child_vector, list_size, *FlatVector::IncrementalSelectionVector(), 1,
126: 					                            key_locations + i, false, true, false, prefix_len, width - 1,
127: 					                            list_entry.offset);
128: 				} else {
129: 					// denote that the list is empty with a 0
130: 					key_locations[i][0] = 0;
131: 					key_locations[i]++;
132: 					memset(key_locations[i], '\0', width - 2);
133: 				}
134: 				// invert bits if desc
135: 				if (desc) {
136: 					for (idx_t s = 0; s < width - 1; s++) {
137: 						*(key_location + s) = ~*(key_location + s);
138: 					}
139: 				}
140: 			} else {
141: 				key_locations[i][0] = invalid;
142: 				memset(key_locations[i] + 1, '\0', width - 1);
143: 				key_locations[i] += width;
144: 			}
145: 		}
146: 	} else {
147: 		for (idx_t i = 0; i < add_count; i++) {
148: 			auto idx = sel.get_index(i);
149: 			auto source_idx = vdata.sel->get_index(idx) + offset;
150: 			auto &list_entry = list_data[source_idx];
151: 			data_ptr_t key_location = key_locations[i];
152: 			if (list_entry.length > 0) {
153: 				// denote that the list is not empty with a 1
154: 				key_locations[i][0] = 1;
155: 				key_locations[i]++;
156: 				RowOperations::RadixScatter(child_vector, list_size, *FlatVector::IncrementalSelectionVector(), 1,
157: 				                            key_locations + i, false, true, false, prefix_len, width - 1,
158: 				                            list_entry.offset);
159: 			} else {
160: 				// denote that the list is empty with a 0
161: 				key_locations[i][0] = 0;
162: 				key_locations[i]++;
163: 				memset(key_locations[i], '\0', width - 1);
164: 			}
165: 			// invert bits if desc
166: 			if (desc) {
167: 				for (idx_t s = 0; s < width; s++) {
168: 					*(key_location + s) = ~*(key_location + s);
169: 				}
170: 			}
171: 		}
172: 	}
173: }
174: 
175: void RadixScatterStructVector(Vector &v, UnifiedVectorFormat &vdata, idx_t vcount, const SelectionVector &sel,
176:                               idx_t add_count, data_ptr_t *key_locations, const bool desc, const bool has_null,
177:                               const bool nulls_first, const idx_t prefix_len, idx_t width, const idx_t offset) {
178: 	// serialize null values
179: 	if (has_null) {
180: 		auto &validity = vdata.validity;
181: 		const data_t valid = nulls_first ? 1 : 0;
182: 		const data_t invalid = 1 - valid;
183: 
184: 		for (idx_t i = 0; i < add_count; i++) {
185: 			auto idx = sel.get_index(i);
186: 			auto source_idx = vdata.sel->get_index(idx) + offset;
187: 			// write validity and according value
188: 			if (validity.RowIsValid(source_idx)) {
189: 				key_locations[i][0] = valid;
190: 			} else {
191: 				key_locations[i][0] = invalid;
192: 			}
193: 			key_locations[i]++;
194: 		}
195: 		width--;
196: 	}
197: 	// serialize the struct
198: 	auto &child_vector = *StructVector::GetEntries(v)[0];
199: 	RowOperations::RadixScatter(child_vector, vcount, *FlatVector::IncrementalSelectionVector(), add_count,
200: 	                            key_locations, false, true, false, prefix_len, width, offset);
201: 	// invert bits if desc
202: 	if (desc) {
203: 		for (idx_t i = 0; i < add_count; i++) {
204: 			for (idx_t s = 0; s < width; s++) {
205: 				*(key_locations[i] - width + s) = ~*(key_locations[i] - width + s);
206: 			}
207: 		}
208: 	}
209: }
210: 
211: void RowOperations::RadixScatter(Vector &v, idx_t vcount, const SelectionVector &sel, idx_t ser_count,
212:                                  data_ptr_t *key_locations, bool desc, bool has_null, bool nulls_first,
213:                                  idx_t prefix_len, idx_t width, idx_t offset) {
214: 	UnifiedVectorFormat vdata;
215: 	v.ToUnifiedFormat(vcount, vdata);
216: 	switch (v.GetType().InternalType()) {
217: 	case PhysicalType::BOOL:
218: 	case PhysicalType::INT8:
219: 		TemplatedRadixScatter<int8_t>(vdata, sel, ser_count, key_locations, desc, has_null, nulls_first, offset);
220: 		break;
221: 	case PhysicalType::INT16:
222: 		TemplatedRadixScatter<int16_t>(vdata, sel, ser_count, key_locations, desc, has_null, nulls_first, offset);
223: 		break;
224: 	case PhysicalType::INT32:
225: 		TemplatedRadixScatter<int32_t>(vdata, sel, ser_count, key_locations, desc, has_null, nulls_first, offset);
226: 		break;
227: 	case PhysicalType::INT64:
228: 		TemplatedRadixScatter<int64_t>(vdata, sel, ser_count, key_locations, desc, has_null, nulls_first, offset);
229: 		break;
230: 	case PhysicalType::UINT8:
231: 		TemplatedRadixScatter<uint8_t>(vdata, sel, ser_count, key_locations, desc, has_null, nulls_first, offset);
232: 		break;
233: 	case PhysicalType::UINT16:
234: 		TemplatedRadixScatter<uint16_t>(vdata, sel, ser_count, key_locations, desc, has_null, nulls_first, offset);
235: 		break;
236: 	case PhysicalType::UINT32:
237: 		TemplatedRadixScatter<uint32_t>(vdata, sel, ser_count, key_locations, desc, has_null, nulls_first, offset);
238: 		break;
239: 	case PhysicalType::UINT64:
240: 		TemplatedRadixScatter<uint64_t>(vdata, sel, ser_count, key_locations, desc, has_null, nulls_first, offset);
241: 		break;
242: 	case PhysicalType::INT128:
243: 		TemplatedRadixScatter<hugeint_t>(vdata, sel, ser_count, key_locations, desc, has_null, nulls_first, offset);
244: 		break;
245: 	case PhysicalType::FLOAT:
246: 		TemplatedRadixScatter<float>(vdata, sel, ser_count, key_locations, desc, has_null, nulls_first, offset);
247: 		break;
248: 	case PhysicalType::DOUBLE:
249: 		TemplatedRadixScatter<double>(vdata, sel, ser_count, key_locations, desc, has_null, nulls_first, offset);
250: 		break;
251: 	case PhysicalType::INTERVAL:
252: 		TemplatedRadixScatter<interval_t>(vdata, sel, ser_count, key_locations, desc, has_null, nulls_first, offset);
253: 		break;
254: 	case PhysicalType::VARCHAR:
255: 		RadixScatterStringVector(vdata, sel, ser_count, key_locations, desc, has_null, nulls_first, prefix_len, offset);
256: 		break;
257: 	case PhysicalType::LIST:
258: 		RadixScatterListVector(v, vdata, sel, ser_count, key_locations, desc, has_null, nulls_first, prefix_len, width,
259: 		                       offset);
260: 		break;
261: 	case PhysicalType::STRUCT:
262: 		RadixScatterStructVector(v, vdata, vcount, sel, ser_count, key_locations, desc, has_null, nulls_first,
263: 		                         prefix_len, width, offset);
264: 		break;
265: 	default:
266: 		throw NotImplementedException("Cannot ORDER BY column with type %s", v.GetType().ToString());
267: 	}
268: }
269: 
270: } // namespace duckdb
[end of src/common/row_operations/row_radix_scatter.cpp]
[start of src/common/vector_operations/is_distinct_from.cpp]
1: #include "duckdb/common/vector_operations/vector_operations.hpp"
2: #include "duckdb/common/operator/comparison_operators.hpp"
3: 
4: namespace duckdb {
5: 
6: struct DistinctBinaryLambdaWrapper {
7: 	template <class OP, class LEFT_TYPE, class RIGHT_TYPE, class RESULT_TYPE>
8: 	static inline RESULT_TYPE Operation(LEFT_TYPE left, RIGHT_TYPE right, bool is_left_null, bool is_right_null) {
9: 		return OP::template Operation<LEFT_TYPE>(left, right, is_left_null, is_right_null);
10: 	}
11: };
12: 
13: template <class LEFT_TYPE, class RIGHT_TYPE, class RESULT_TYPE, class OP>
14: static void DistinctExecuteGenericLoop(LEFT_TYPE *__restrict ldata, RIGHT_TYPE *__restrict rdata,
15:                                        RESULT_TYPE *__restrict result_data, const SelectionVector *__restrict lsel,
16:                                        const SelectionVector *__restrict rsel, idx_t count, ValidityMask &lmask,
17:                                        ValidityMask &rmask, ValidityMask &result_mask) {
18: 	for (idx_t i = 0; i < count; i++) {
19: 		auto lindex = lsel->get_index(i);
20: 		auto rindex = rsel->get_index(i);
21: 		auto lentry = ldata[lindex];
22: 		auto rentry = rdata[rindex];
23: 		result_data[i] =
24: 		    OP::template Operation<LEFT_TYPE>(lentry, rentry, !lmask.RowIsValid(lindex), !rmask.RowIsValid(rindex));
25: 	}
26: }
27: 
28: template <class LEFT_TYPE, class RIGHT_TYPE, class RESULT_TYPE, class OP>
29: static void DistinctExecuteConstant(Vector &left, Vector &right, Vector &result) {
30: 	result.SetVectorType(VectorType::CONSTANT_VECTOR);
31: 
32: 	auto ldata = ConstantVector::GetData<LEFT_TYPE>(left);
33: 	auto rdata = ConstantVector::GetData<RIGHT_TYPE>(right);
34: 	auto result_data = ConstantVector::GetData<RESULT_TYPE>(result);
35: 	*result_data =
36: 	    OP::template Operation<LEFT_TYPE>(*ldata, *rdata, ConstantVector::IsNull(left), ConstantVector::IsNull(right));
37: }
38: 
39: template <class LEFT_TYPE, class RIGHT_TYPE, class RESULT_TYPE, class OP>
40: static void DistinctExecuteGeneric(Vector &left, Vector &right, Vector &result, idx_t count) {
41: 	if (left.GetVectorType() == VectorType::CONSTANT_VECTOR && right.GetVectorType() == VectorType::CONSTANT_VECTOR) {
42: 		DistinctExecuteConstant<LEFT_TYPE, RIGHT_TYPE, RESULT_TYPE, OP>(left, right, result);
43: 	} else {
44: 		UnifiedVectorFormat ldata, rdata;
45: 
46: 		left.ToUnifiedFormat(count, ldata);
47: 		right.ToUnifiedFormat(count, rdata);
48: 
49: 		result.SetVectorType(VectorType::FLAT_VECTOR);
50: 		auto result_data = FlatVector::GetData<RESULT_TYPE>(result);
51: 		DistinctExecuteGenericLoop<LEFT_TYPE, RIGHT_TYPE, RESULT_TYPE, OP>(
52: 		    (LEFT_TYPE *)ldata.data, (RIGHT_TYPE *)rdata.data, result_data, ldata.sel, rdata.sel, count, ldata.validity,
53: 		    rdata.validity, FlatVector::Validity(result));
54: 	}
55: }
56: 
57: template <class LEFT_TYPE, class RIGHT_TYPE, class RESULT_TYPE, class OP>
58: static void DistinctExecuteSwitch(Vector &left, Vector &right, Vector &result, idx_t count) {
59: 	DistinctExecuteGeneric<LEFT_TYPE, RIGHT_TYPE, RESULT_TYPE, OP>(left, right, result, count);
60: }
61: 
62: template <class LEFT_TYPE, class RIGHT_TYPE, class RESULT_TYPE, class OP>
63: static void DistinctExecute(Vector &left, Vector &right, Vector &result, idx_t count) {
64: 	DistinctExecuteSwitch<LEFT_TYPE, RIGHT_TYPE, RESULT_TYPE, OP>(left, right, result, count);
65: }
66: 
67: template <class LEFT_TYPE, class RIGHT_TYPE, class OP, bool NO_NULL, bool HAS_TRUE_SEL, bool HAS_FALSE_SEL>
68: static inline idx_t
69: DistinctSelectGenericLoop(LEFT_TYPE *__restrict ldata, RIGHT_TYPE *__restrict rdata,
70:                           const SelectionVector *__restrict lsel, const SelectionVector *__restrict rsel,
71:                           const SelectionVector *__restrict result_sel, idx_t count, ValidityMask &lmask,
72:                           ValidityMask &rmask, SelectionVector *true_sel, SelectionVector *false_sel) {
73: 	idx_t true_count = 0, false_count = 0;
74: 	for (idx_t i = 0; i < count; i++) {
75: 		auto result_idx = result_sel->get_index(i);
76: 		auto lindex = lsel->get_index(i);
77: 		auto rindex = rsel->get_index(i);
78: 		if (NO_NULL) {
79: 			if (OP::Operation(ldata[lindex], rdata[rindex], false, false)) {
80: 				if (HAS_TRUE_SEL) {
81: 					true_sel->set_index(true_count++, result_idx);
82: 				}
83: 			} else {
84: 				if (HAS_FALSE_SEL) {
85: 					false_sel->set_index(false_count++, result_idx);
86: 				}
87: 			}
88: 		} else {
89: 			if (OP::Operation(ldata[lindex], rdata[rindex], !lmask.RowIsValid(lindex), !rmask.RowIsValid(rindex))) {
90: 				if (HAS_TRUE_SEL) {
91: 					true_sel->set_index(true_count++, result_idx);
92: 				}
93: 			} else {
94: 				if (HAS_FALSE_SEL) {
95: 					false_sel->set_index(false_count++, result_idx);
96: 				}
97: 			}
98: 		}
99: 	}
100: 	if (HAS_TRUE_SEL) {
101: 		return true_count;
102: 	} else {
103: 		return count - false_count;
104: 	}
105: }
106: template <class LEFT_TYPE, class RIGHT_TYPE, class OP, bool NO_NULL>
107: static inline idx_t
108: DistinctSelectGenericLoopSelSwitch(LEFT_TYPE *__restrict ldata, RIGHT_TYPE *__restrict rdata,
109:                                    const SelectionVector *__restrict lsel, const SelectionVector *__restrict rsel,
110:                                    const SelectionVector *__restrict result_sel, idx_t count, ValidityMask &lmask,
111:                                    ValidityMask &rmask, SelectionVector *true_sel, SelectionVector *false_sel) {
112: 	if (true_sel && false_sel) {
113: 		return DistinctSelectGenericLoop<LEFT_TYPE, RIGHT_TYPE, OP, NO_NULL, true, true>(
114: 		    ldata, rdata, lsel, rsel, result_sel, count, lmask, rmask, true_sel, false_sel);
115: 	} else if (true_sel) {
116: 		return DistinctSelectGenericLoop<LEFT_TYPE, RIGHT_TYPE, OP, NO_NULL, true, false>(
117: 		    ldata, rdata, lsel, rsel, result_sel, count, lmask, rmask, true_sel, false_sel);
118: 	} else {
119: 		D_ASSERT(false_sel);
120: 		return DistinctSelectGenericLoop<LEFT_TYPE, RIGHT_TYPE, OP, NO_NULL, false, true>(
121: 		    ldata, rdata, lsel, rsel, result_sel, count, lmask, rmask, true_sel, false_sel);
122: 	}
123: }
124: 
125: template <class LEFT_TYPE, class RIGHT_TYPE, class OP>
126: static inline idx_t
127: DistinctSelectGenericLoopSwitch(LEFT_TYPE *__restrict ldata, RIGHT_TYPE *__restrict rdata,
128:                                 const SelectionVector *__restrict lsel, const SelectionVector *__restrict rsel,
129:                                 const SelectionVector *__restrict result_sel, idx_t count, ValidityMask &lmask,
130:                                 ValidityMask &rmask, SelectionVector *true_sel, SelectionVector *false_sel) {
131: 	if (!lmask.AllValid() || !rmask.AllValid()) {
132: 		return DistinctSelectGenericLoopSelSwitch<LEFT_TYPE, RIGHT_TYPE, OP, false>(
133: 		    ldata, rdata, lsel, rsel, result_sel, count, lmask, rmask, true_sel, false_sel);
134: 	} else {
135: 		return DistinctSelectGenericLoopSelSwitch<LEFT_TYPE, RIGHT_TYPE, OP, true>(
136: 		    ldata, rdata, lsel, rsel, result_sel, count, lmask, rmask, true_sel, false_sel);
137: 	}
138: }
139: 
140: template <class LEFT_TYPE, class RIGHT_TYPE, class OP>
141: static idx_t DistinctSelectGeneric(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
142:                                    SelectionVector *true_sel, SelectionVector *false_sel) {
143: 	UnifiedVectorFormat ldata, rdata;
144: 
145: 	left.ToUnifiedFormat(count, ldata);
146: 	right.ToUnifiedFormat(count, rdata);
147: 
148: 	return DistinctSelectGenericLoopSwitch<LEFT_TYPE, RIGHT_TYPE, OP>((LEFT_TYPE *)ldata.data, (RIGHT_TYPE *)rdata.data,
149: 	                                                                  ldata.sel, rdata.sel, sel, count, ldata.validity,
150: 	                                                                  rdata.validity, true_sel, false_sel);
151: }
152: template <class LEFT_TYPE, class RIGHT_TYPE, class OP, bool LEFT_CONSTANT, bool RIGHT_CONSTANT, bool NO_NULL,
153:           bool HAS_TRUE_SEL, bool HAS_FALSE_SEL>
154: static inline idx_t DistinctSelectFlatLoop(LEFT_TYPE *__restrict ldata, RIGHT_TYPE *__restrict rdata,
155:                                            const SelectionVector *sel, idx_t count, ValidityMask &lmask,
156:                                            ValidityMask &rmask, SelectionVector *true_sel, SelectionVector *false_sel) {
157: 	idx_t true_count = 0, false_count = 0;
158: 	for (idx_t i = 0; i < count; i++) {
159: 		idx_t result_idx = sel->get_index(i);
160: 		idx_t lidx = LEFT_CONSTANT ? 0 : i;
161: 		idx_t ridx = RIGHT_CONSTANT ? 0 : i;
162: 		const bool lnull = !lmask.RowIsValid(lidx);
163: 		const bool rnull = !rmask.RowIsValid(ridx);
164: 		bool comparison_result = OP::Operation(ldata[lidx], rdata[ridx], lnull, rnull);
165: 		if (HAS_TRUE_SEL) {
166: 			true_sel->set_index(true_count, result_idx);
167: 			true_count += comparison_result;
168: 		}
169: 		if (HAS_FALSE_SEL) {
170: 			false_sel->set_index(false_count, result_idx);
171: 			false_count += !comparison_result;
172: 		}
173: 	}
174: 	if (HAS_TRUE_SEL) {
175: 		return true_count;
176: 	} else {
177: 		return count - false_count;
178: 	}
179: }
180: 
181: template <class LEFT_TYPE, class RIGHT_TYPE, class OP, bool LEFT_CONSTANT, bool RIGHT_CONSTANT, bool NO_NULL>
182: static inline idx_t DistinctSelectFlatLoopSelSwitch(LEFT_TYPE *__restrict ldata, RIGHT_TYPE *__restrict rdata,
183:                                                     const SelectionVector *sel, idx_t count, ValidityMask &lmask,
184:                                                     ValidityMask &rmask, SelectionVector *true_sel,
185:                                                     SelectionVector *false_sel) {
186: 	if (true_sel && false_sel) {
187: 		return DistinctSelectFlatLoop<LEFT_TYPE, RIGHT_TYPE, OP, LEFT_CONSTANT, RIGHT_CONSTANT, NO_NULL, true, true>(
188: 		    ldata, rdata, sel, count, lmask, rmask, true_sel, false_sel);
189: 	} else if (true_sel) {
190: 		return DistinctSelectFlatLoop<LEFT_TYPE, RIGHT_TYPE, OP, LEFT_CONSTANT, RIGHT_CONSTANT, NO_NULL, true, false>(
191: 		    ldata, rdata, sel, count, lmask, rmask, true_sel, false_sel);
192: 	} else {
193: 		D_ASSERT(false_sel);
194: 		return DistinctSelectFlatLoop<LEFT_TYPE, RIGHT_TYPE, OP, LEFT_CONSTANT, RIGHT_CONSTANT, NO_NULL, false, true>(
195: 		    ldata, rdata, sel, count, lmask, rmask, true_sel, false_sel);
196: 	}
197: }
198: 
199: template <class LEFT_TYPE, class RIGHT_TYPE, class OP, bool LEFT_CONSTANT, bool RIGHT_CONSTANT>
200: static inline idx_t DistinctSelectFlatLoopSwitch(LEFT_TYPE *__restrict ldata, RIGHT_TYPE *__restrict rdata,
201:                                                  const SelectionVector *sel, idx_t count, ValidityMask &lmask,
202:                                                  ValidityMask &rmask, SelectionVector *true_sel,
203:                                                  SelectionVector *false_sel) {
204: 	return DistinctSelectFlatLoopSelSwitch<LEFT_TYPE, RIGHT_TYPE, OP, LEFT_CONSTANT, RIGHT_CONSTANT, true>(
205: 	    ldata, rdata, sel, count, lmask, rmask, true_sel, false_sel);
206: }
207: template <class LEFT_TYPE, class RIGHT_TYPE, class OP, bool LEFT_CONSTANT, bool RIGHT_CONSTANT>
208: static idx_t DistinctSelectFlat(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
209:                                 SelectionVector *true_sel, SelectionVector *false_sel) {
210: 	auto ldata = FlatVector::GetData<LEFT_TYPE>(left);
211: 	auto rdata = FlatVector::GetData<RIGHT_TYPE>(right);
212: 	if (LEFT_CONSTANT) {
213: 		ValidityMask validity;
214: 		if (ConstantVector::IsNull(left)) {
215: 			validity.SetAllInvalid(1);
216: 		}
217: 		return DistinctSelectFlatLoopSwitch<LEFT_TYPE, RIGHT_TYPE, OP, LEFT_CONSTANT, RIGHT_CONSTANT>(
218: 		    ldata, rdata, sel, count, validity, FlatVector::Validity(right), true_sel, false_sel);
219: 	} else if (RIGHT_CONSTANT) {
220: 		ValidityMask validity;
221: 		if (ConstantVector::IsNull(right)) {
222: 			validity.SetAllInvalid(1);
223: 		}
224: 		return DistinctSelectFlatLoopSwitch<LEFT_TYPE, RIGHT_TYPE, OP, LEFT_CONSTANT, RIGHT_CONSTANT>(
225: 		    ldata, rdata, sel, count, FlatVector::Validity(left), validity, true_sel, false_sel);
226: 	} else {
227: 		return DistinctSelectFlatLoopSwitch<LEFT_TYPE, RIGHT_TYPE, OP, LEFT_CONSTANT, RIGHT_CONSTANT>(
228: 		    ldata, rdata, sel, count, FlatVector::Validity(left), FlatVector::Validity(right), true_sel, false_sel);
229: 	}
230: }
231: template <class LEFT_TYPE, class RIGHT_TYPE, class OP>
232: static idx_t DistinctSelectConstant(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
233:                                     SelectionVector *true_sel, SelectionVector *false_sel) {
234: 	auto ldata = ConstantVector::GetData<LEFT_TYPE>(left);
235: 	auto rdata = ConstantVector::GetData<RIGHT_TYPE>(right);
236: 
237: 	// both sides are constant, return either 0 or the count
238: 	// in this case we do not fill in the result selection vector at all
239: 	if (!OP::Operation(*ldata, *rdata, ConstantVector::IsNull(left), ConstantVector::IsNull(right))) {
240: 		if (false_sel) {
241: 			for (idx_t i = 0; i < count; i++) {
242: 				false_sel->set_index(i, sel->get_index(i));
243: 			}
244: 		}
245: 		return 0;
246: 	} else {
247: 		if (true_sel) {
248: 			for (idx_t i = 0; i < count; i++) {
249: 				true_sel->set_index(i, sel->get_index(i));
250: 			}
251: 		}
252: 		return count;
253: 	}
254: }
255: 
256: template <class LEFT_TYPE, class RIGHT_TYPE, class OP>
257: static idx_t DistinctSelect(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
258:                             SelectionVector *true_sel, SelectionVector *false_sel) {
259: 	if (!sel) {
260: 		sel = FlatVector::IncrementalSelectionVector();
261: 	}
262: 	if (left.GetVectorType() == VectorType::CONSTANT_VECTOR && right.GetVectorType() == VectorType::CONSTANT_VECTOR) {
263: 		return DistinctSelectConstant<LEFT_TYPE, RIGHT_TYPE, OP>(left, right, sel, count, true_sel, false_sel);
264: 	} else if (left.GetVectorType() == VectorType::CONSTANT_VECTOR &&
265: 	           right.GetVectorType() == VectorType::FLAT_VECTOR) {
266: 		return DistinctSelectFlat<LEFT_TYPE, RIGHT_TYPE, OP, true, false>(left, right, sel, count, true_sel, false_sel);
267: 	} else if (left.GetVectorType() == VectorType::FLAT_VECTOR &&
268: 	           right.GetVectorType() == VectorType::CONSTANT_VECTOR) {
269: 		return DistinctSelectFlat<LEFT_TYPE, RIGHT_TYPE, OP, false, true>(left, right, sel, count, true_sel, false_sel);
270: 	} else if (left.GetVectorType() == VectorType::FLAT_VECTOR && right.GetVectorType() == VectorType::FLAT_VECTOR) {
271: 		return DistinctSelectFlat<LEFT_TYPE, RIGHT_TYPE, OP, false, false>(left, right, sel, count, true_sel,
272: 		                                                                   false_sel);
273: 	} else {
274: 		return DistinctSelectGeneric<LEFT_TYPE, RIGHT_TYPE, OP>(left, right, sel, count, true_sel, false_sel);
275: 	}
276: }
277: 
278: template <class OP>
279: static idx_t DistinctSelectNotNull(Vector &left, Vector &right, const idx_t count, idx_t &true_count,
280:                                    const SelectionVector &sel, SelectionVector &maybe_vec, OptionalSelection &true_opt,
281:                                    OptionalSelection &false_opt) {
282: 	UnifiedVectorFormat lvdata, rvdata;
283: 	left.ToUnifiedFormat(count, lvdata);
284: 	right.ToUnifiedFormat(count, rvdata);
285: 
286: 	auto &lmask = lvdata.validity;
287: 	auto &rmask = rvdata.validity;
288: 
289: 	idx_t remaining = 0;
290: 	if (lmask.AllValid() && rmask.AllValid()) {
291: 		//	None are NULL, distinguish values.
292: 		for (idx_t i = 0; i < count; ++i) {
293: 			const auto idx = sel.get_index(i);
294: 			maybe_vec.set_index(remaining++, idx);
295: 		}
296: 		return remaining;
297: 	}
298: 
299: 	// Slice the Vectors down to the rows that are not determined (i.e., neither is NULL)
300: 	SelectionVector slicer(count);
301: 	true_count = 0;
302: 	idx_t false_count = 0;
303: 	for (idx_t i = 0; i < count; ++i) {
304: 		const auto result_idx = sel.get_index(i);
305: 		const auto lidx = lvdata.sel->get_index(i);
306: 		const auto ridx = rvdata.sel->get_index(i);
307: 		const auto lnull = !lmask.RowIsValid(lidx);
308: 		const auto rnull = !rmask.RowIsValid(ridx);
309: 		if (lnull || rnull) {
310: 			// If either is NULL then we can major distinguish them
311: 			if (!OP::Operation(false, false, lnull, rnull)) {
312: 				false_opt.Append(false_count, result_idx);
313: 			} else {
314: 				true_opt.Append(true_count, result_idx);
315: 			}
316: 		} else {
317: 			//	Neither is NULL, distinguish values.
318: 			slicer.set_index(remaining, i);
319: 			maybe_vec.set_index(remaining++, result_idx);
320: 		}
321: 	}
322: 
323: 	true_opt.Advance(true_count);
324: 	false_opt.Advance(false_count);
325: 
326: 	if (remaining && remaining < count) {
327: 		left.Slice(slicer, remaining);
328: 		right.Slice(slicer, remaining);
329: 	}
330: 
331: 	return remaining;
332: }
333: 
334: struct PositionComparator {
335: 	// Select the rows that definitely match.
336: 	// Default to the same as the final row
337: 	template <typename OP>
338: 	static idx_t Definite(Vector &left, Vector &right, const SelectionVector &sel, idx_t count,
339: 	                      SelectionVector *true_sel, SelectionVector &false_sel) {
340: 		return Final<OP>(left, right, sel, count, true_sel, &false_sel);
341: 	}
342: 
343: 	// Select the possible rows that need further testing.
344: 	// Usually this means Is Not Distinct, as those are the semantics used by Postges
345: 	template <typename OP>
346: 	static idx_t Possible(Vector &left, Vector &right, const SelectionVector &sel, idx_t count,
347: 	                      SelectionVector &true_sel, SelectionVector *false_sel) {
348: 		return VectorOperations::NestedEquals(left, right, sel, count, &true_sel, false_sel);
349: 	}
350: 
351: 	// Select the matching rows for the final position.
352: 	// This needs to be specialised.
353: 	template <typename OP>
354: 	static idx_t Final(Vector &left, Vector &right, const SelectionVector &sel, idx_t count, SelectionVector *true_sel,
355: 	                   SelectionVector *false_sel) {
356: 		return 0;
357: 	}
358: 
359: 	// Tie-break based on length when one of the sides has been exhausted, returning true if the LHS matches.
360: 	// This essentially means that the existing positions compare equal.
361: 	// Default to the same semantics as the OP for idx_t. This works in most cases.
362: 	template <typename OP>
363: 	static bool TieBreak(const idx_t lpos, const idx_t rpos) {
364: 		return OP::Operation(lpos, rpos, false, false);
365: 	}
366: };
367: 
368: // NotDistinctFrom must always check every column
369: template <>
370: idx_t PositionComparator::Definite<duckdb::NotDistinctFrom>(Vector &left, Vector &right, const SelectionVector &sel,
371:                                                             idx_t count, SelectionVector *true_sel,
372:                                                             SelectionVector &false_sel) {
373: 	return 0;
374: }
375: 
376: template <>
377: idx_t PositionComparator::Final<duckdb::NotDistinctFrom>(Vector &left, Vector &right, const SelectionVector &sel,
378:                                                          idx_t count, SelectionVector *true_sel,
379:                                                          SelectionVector *false_sel) {
380: 	return VectorOperations::NestedEquals(left, right, sel, count, true_sel, false_sel);
381: }
382: 
383: // DistinctFrom must check everything that matched
384: template <>
385: idx_t PositionComparator::Possible<duckdb::DistinctFrom>(Vector &left, Vector &right, const SelectionVector &sel,
386:                                                          idx_t count, SelectionVector &true_sel,
387:                                                          SelectionVector *false_sel) {
388: 	return count;
389: }
390: 
391: template <>
392: idx_t PositionComparator::Final<duckdb::DistinctFrom>(Vector &left, Vector &right, const SelectionVector &sel,
393:                                                       idx_t count, SelectionVector *true_sel,
394:                                                       SelectionVector *false_sel) {
395: 	return VectorOperations::NestedNotEquals(left, right, sel, count, true_sel, false_sel);
396: }
397: 
398: // Non-strict inequalities must use strict comparisons for Definite
399: template <>
400: idx_t PositionComparator::Definite<duckdb::DistinctLessThanEquals>(Vector &left, Vector &right,
401:                                                                    const SelectionVector &sel, idx_t count,
402:                                                                    SelectionVector *true_sel,
403:                                                                    SelectionVector &false_sel) {
404: 	return VectorOperations::DistinctLessThan(left, right, &sel, count, true_sel, &false_sel);
405: }
406: 
407: template <>
408: idx_t PositionComparator::Final<duckdb::DistinctLessThanEquals>(Vector &left, Vector &right, const SelectionVector &sel,
409:                                                                 idx_t count, SelectionVector *true_sel,
410:                                                                 SelectionVector *false_sel) {
411: 	return VectorOperations::DistinctLessThanEquals(left, right, &sel, count, true_sel, false_sel);
412: }
413: 
414: template <>
415: idx_t PositionComparator::Definite<duckdb::DistinctGreaterThanEquals>(Vector &left, Vector &right,
416:                                                                       const SelectionVector &sel, idx_t count,
417:                                                                       SelectionVector *true_sel,
418:                                                                       SelectionVector &false_sel) {
419: 	return VectorOperations::DistinctGreaterThan(left, right, &sel, count, true_sel, &false_sel);
420: }
421: 
422: template <>
423: idx_t PositionComparator::Final<duckdb::DistinctGreaterThanEquals>(Vector &left, Vector &right,
424:                                                                    const SelectionVector &sel, idx_t count,
425:                                                                    SelectionVector *true_sel,
426:                                                                    SelectionVector *false_sel) {
427: 	return VectorOperations::DistinctGreaterThanEquals(left, right, &sel, count, true_sel, false_sel);
428: }
429: 
430: // Strict inequalities just use strict for both Definite and Final
431: template <>
432: idx_t PositionComparator::Final<duckdb::DistinctLessThan>(Vector &left, Vector &right, const SelectionVector &sel,
433:                                                           idx_t count, SelectionVector *true_sel,
434:                                                           SelectionVector *false_sel) {
435: 	return VectorOperations::DistinctLessThan(left, right, &sel, count, true_sel, false_sel);
436: }
437: 
438: template <>
439: idx_t PositionComparator::Final<duckdb::DistinctGreaterThan>(Vector &left, Vector &right, const SelectionVector &sel,
440:                                                              idx_t count, SelectionVector *true_sel,
441:                                                              SelectionVector *false_sel) {
442: 	return VectorOperations::DistinctGreaterThan(left, right, &sel, count, true_sel, false_sel);
443: }
444: 
445: using StructEntries = vector<unique_ptr<Vector>>;
446: 
447: static void ExtractNestedSelection(const SelectionVector &slice_sel, const idx_t count, const SelectionVector &sel,
448:                                    OptionalSelection &opt) {
449: 
450: 	for (idx_t i = 0; i < count;) {
451: 		const auto slice_idx = slice_sel.get_index(i);
452: 		const auto result_idx = sel.get_index(slice_idx);
453: 		opt.Append(i, result_idx);
454: 	}
455: 	opt.Advance(count);
456: }
457: 
458: static void DensifyNestedSelection(const SelectionVector &dense_sel, const idx_t count, SelectionVector &slice_sel) {
459: 	for (idx_t i = 0; i < count; ++i) {
460: 		slice_sel.set_index(i, dense_sel.get_index(i));
461: 	}
462: }
463: 
464: template <class OP>
465: static idx_t DistinctSelectStruct(Vector &left, Vector &right, idx_t count, const SelectionVector &sel,
466:                                   OptionalSelection &true_opt, OptionalSelection &false_opt) {
467: 	if (count == 0) {
468: 		return 0;
469: 	}
470: 
471: 	// Avoid allocating in the 99% of the cases where we don't need to.
472: 	StructEntries lsliced, rsliced;
473: 	auto &lchildren = StructVector::GetEntries(left);
474: 	auto &rchildren = StructVector::GetEntries(right);
475: 	D_ASSERT(lchildren.size() == rchildren.size());
476: 
477: 	// In order to reuse the comparators, we have to track what passed and failed internally.
478: 	// To do that, we need local SVs that we then merge back into the real ones after every pass.
479: 	const auto vcount = count;
480: 	SelectionVector slice_sel(count);
481: 	for (idx_t i = 0; i < count; ++i) {
482: 		slice_sel.set_index(i, i);
483: 	}
484: 
485: 	SelectionVector true_sel(count);
486: 	SelectionVector false_sel(count);
487: 
488: 	idx_t match_count = 0;
489: 	for (idx_t col_no = 0; col_no < lchildren.size(); ++col_no) {
490: 		// Slice the children to maintain density
491: 		Vector lchild(*lchildren[col_no]);
492: 		lchild.Flatten(vcount);
493: 		lchild.Slice(slice_sel, count);
494: 
495: 		Vector rchild(*rchildren[col_no]);
496: 		rchild.Flatten(vcount);
497: 		rchild.Slice(slice_sel, count);
498: 
499: 		// Find everything that definitely matches
500: 		auto true_count = PositionComparator::Definite<OP>(lchild, rchild, slice_sel, count, &true_sel, false_sel);
501: 		if (true_count > 0) {
502: 			auto false_count = count - true_count;
503: 
504: 			// Extract the definite matches into the true result
505: 			ExtractNestedSelection(false_count ? true_sel : slice_sel, true_count, sel, true_opt);
506: 
507: 			// Remove the definite matches from the slicing vector
508: 			DensifyNestedSelection(false_sel, false_count, slice_sel);
509: 
510: 			match_count += true_count;
511: 			count -= true_count;
512: 		}
513: 
514: 		if (col_no != lchildren.size() - 1) {
515: 			// Find what might match on the next position
516: 			true_count = PositionComparator::Possible<OP>(lchild, rchild, slice_sel, count, true_sel, &false_sel);
517: 			auto false_count = count - true_count;
518: 
519: 			// Extract the definite failures into the false result
520: 			ExtractNestedSelection(true_count ? false_sel : slice_sel, false_count, sel, false_opt);
521: 
522: 			// Remove any definite failures from the slicing vector
523: 			if (false_count) {
524: 				DensifyNestedSelection(true_sel, true_count, slice_sel);
525: 			}
526: 
527: 			count = true_count;
528: 		} else {
529: 			true_count = PositionComparator::Final<OP>(lchild, rchild, slice_sel, count, &true_sel, &false_sel);
530: 			auto false_count = count - true_count;
531: 
532: 			// Extract the definite matches into the true result
533: 			ExtractNestedSelection(false_count ? true_sel : slice_sel, true_count, sel, true_opt);
534: 
535: 			// Extract the definite failures into the false result
536: 			ExtractNestedSelection(true_count ? false_sel : slice_sel, false_count, sel, false_opt);
537: 
538: 			match_count += true_count;
539: 		}
540: 	}
541: 	return match_count;
542: }
543: 
544: static void PositionListCursor(SelectionVector &cursor, UnifiedVectorFormat &vdata, const idx_t pos,
545:                                const SelectionVector &slice_sel, const idx_t count) {
546: 	const auto data = (const list_entry_t *)vdata.data;
547: 	for (idx_t i = 0; i < count; ++i) {
548: 		const auto slice_idx = slice_sel.get_index(i);
549: 
550: 		const auto lidx = vdata.sel->get_index(slice_idx);
551: 		const auto &entry = data[lidx];
552: 		cursor.set_index(i, entry.offset + pos);
553: 	}
554: }
555: 
556: template <class OP>
557: static idx_t DistinctSelectList(Vector &left, Vector &right, idx_t count, const SelectionVector &sel,
558:                                 OptionalSelection &true_opt, OptionalSelection &false_opt) {
559: 	if (count == 0) {
560: 		return count;
561: 	}
562: 
563: 	// Create dictionary views of the children so we can vectorise the positional comparisons.
564: 	SelectionVector lcursor(count);
565: 	SelectionVector rcursor(count);
566: 
567: 	ListVector::GetEntry(left).Flatten(count);
568: 	ListVector::GetEntry(right).Flatten(count);
569: 	Vector lchild(ListVector::GetEntry(left), lcursor, count);
570: 	Vector rchild(ListVector::GetEntry(right), rcursor, count);
571: 
572: 	// To perform the positional comparison, we use a vectorisation of the following algorithm:
573: 	// bool CompareLists(T *left, idx_t nleft, T *right, nright) {
574: 	// 	for (idx_t pos = 0; ; ++pos) {
575: 	// 		if (nleft == pos || nright == pos)
576: 	// 			return OP::TieBreak(nleft, nright);
577: 	// 		if (OP::Definite(*left, *right))
578: 	// 			return true;
579: 	// 		if (!OP::Maybe(*left, *right))
580: 	// 			return false;
581: 	// 		}
582: 	//	 	++left, ++right;
583: 	// 	}
584: 	// }
585: 
586: 	// Get pointers to the list entries
587: 	UnifiedVectorFormat lvdata;
588: 	left.ToUnifiedFormat(count, lvdata);
589: 	const auto ldata = (const list_entry_t *)lvdata.data;
590: 
591: 	UnifiedVectorFormat rvdata;
592: 	right.ToUnifiedFormat(count, rvdata);
593: 	const auto rdata = (const list_entry_t *)rvdata.data;
594: 
595: 	// In order to reuse the comparators, we have to track what passed and failed internally.
596: 	// To do that, we need local SVs that we then merge back into the real ones after every pass.
597: 	SelectionVector slice_sel(count);
598: 	for (idx_t i = 0; i < count; ++i) {
599: 		slice_sel.set_index(i, i);
600: 	}
601: 
602: 	SelectionVector true_sel(count);
603: 	SelectionVector false_sel(count);
604: 
605: 	idx_t match_count = 0;
606: 	for (idx_t pos = 0; count > 0; ++pos) {
607: 		// Set up the cursors for the current position
608: 		PositionListCursor(lcursor, lvdata, pos, slice_sel, count);
609: 		PositionListCursor(rcursor, rvdata, pos, slice_sel, count);
610: 
611: 		// Tie-break the pairs where one of the LISTs is exhausted.
612: 		idx_t true_count = 0;
613: 		idx_t false_count = 0;
614: 		idx_t maybe_count = 0;
615: 		for (idx_t i = 0; i < count; ++i) {
616: 			const auto slice_idx = slice_sel.get_index(i);
617: 			const auto lidx = lvdata.sel->get_index(slice_idx);
618: 			const auto &lentry = ldata[lidx];
619: 			const auto ridx = rvdata.sel->get_index(slice_idx);
620: 			const auto &rentry = rdata[ridx];
621: 			if (lentry.length == pos || rentry.length == pos) {
622: 				const auto idx = sel.get_index(slice_idx);
623: 				if (PositionComparator::TieBreak<OP>(lentry.length, rentry.length)) {
624: 					true_opt.Append(true_count, idx);
625: 				} else {
626: 					false_opt.Append(false_count, idx);
627: 				}
628: 			} else {
629: 				true_sel.set_index(maybe_count++, slice_idx);
630: 			}
631: 		}
632: 		true_opt.Advance(true_count);
633: 		false_opt.Advance(false_count);
634: 		match_count += true_count;
635: 
636: 		// Redensify the list cursors
637: 		if (maybe_count < count) {
638: 			count = maybe_count;
639: 			DensifyNestedSelection(true_sel, count, slice_sel);
640: 			PositionListCursor(lcursor, lvdata, pos, slice_sel, count);
641: 			PositionListCursor(rcursor, rvdata, pos, slice_sel, count);
642: 		}
643: 
644: 		// Find everything that definitely matches
645: 		true_count = PositionComparator::Definite<OP>(lchild, rchild, slice_sel, count, &true_sel, false_sel);
646: 		if (true_count) {
647: 			false_count = count - true_count;
648: 			ExtractNestedSelection(false_count ? true_sel : slice_sel, true_count, sel, true_opt);
649: 			match_count += true_count;
650: 
651: 			// Redensify the list cursors
652: 			count -= true_count;
653: 			DensifyNestedSelection(false_sel, count, slice_sel);
654: 			PositionListCursor(lcursor, lvdata, pos, slice_sel, count);
655: 			PositionListCursor(rcursor, rvdata, pos, slice_sel, count);
656: 		}
657: 
658: 		// Find what might match on the next position
659: 		true_count = PositionComparator::Possible<OP>(lchild, rchild, slice_sel, count, true_sel, &false_sel);
660: 		false_count = count - true_count;
661: 		ExtractNestedSelection(true_count ? false_sel : slice_sel, false_count, sel, false_opt);
662: 
663: 		if (false_count) {
664: 			DensifyNestedSelection(true_sel, true_count, slice_sel);
665: 		}
666: 		count = true_count;
667: 	}
668: 
669: 	return match_count;
670: }
671: 
672: template <class OP, class OPNESTED>
673: static idx_t DistinctSelectNested(Vector &left, Vector &right, const SelectionVector *sel, const idx_t count,
674:                                   SelectionVector *true_sel, SelectionVector *false_sel) {
675: 	// The Select operations all use a dense pair of input vectors to partition
676: 	// a selection vector in a single pass. But to implement progressive comparisons,
677: 	// we have to make multiple passes, so we need to keep track of the original input positions
678: 	// and then scatter the output selections when we are done.
679: 	if (!sel) {
680: 		sel = FlatVector::IncrementalSelectionVector();
681: 	}
682: 
683: 	// Make buffered selections for progressive comparisons
684: 	// TODO: Remove unnecessary allocations
685: 	SelectionVector true_vec(count);
686: 	OptionalSelection true_opt(&true_vec);
687: 
688: 	SelectionVector false_vec(count);
689: 	OptionalSelection false_opt(&false_vec);
690: 
691: 	SelectionVector maybe_vec(count);
692: 
693: 	// Handle NULL nested values
694: 	Vector l_not_null(left);
695: 	Vector r_not_null(right);
696: 
697: 	idx_t match_count = 0;
698: 	auto unknown =
699: 	    DistinctSelectNotNull<OP>(l_not_null, r_not_null, count, match_count, *sel, maybe_vec, true_opt, false_opt);
700: 
701: 	if (PhysicalType::LIST == left.GetType().InternalType()) {
702: 		match_count += DistinctSelectList<OPNESTED>(l_not_null, r_not_null, unknown, maybe_vec, true_opt, false_opt);
703: 	} else {
704: 		match_count += DistinctSelectStruct<OPNESTED>(l_not_null, r_not_null, unknown, maybe_vec, true_opt, false_opt);
705: 	}
706: 
707: 	// Copy the buffered selections to the output selections
708: 	if (true_sel) {
709: 		DensifyNestedSelection(true_vec, match_count, *true_sel);
710: 	}
711: 
712: 	if (false_sel) {
713: 		DensifyNestedSelection(false_vec, count - match_count, *false_sel);
714: 	}
715: 
716: 	return match_count;
717: }
718: 
719: template <typename OP>
720: static void NestedDistinctExecute(Vector &left, Vector &right, Vector &result, idx_t count);
721: 
722: template <class T, class OP>
723: static inline void TemplatedDistinctExecute(Vector &left, Vector &right, Vector &result, idx_t count) {
724: 	DistinctExecute<T, T, bool, OP>(left, right, result, count);
725: }
726: template <class OP>
727: static void ExecuteDistinct(Vector &left, Vector &right, Vector &result, idx_t count) {
728: 	D_ASSERT(left.GetType() == right.GetType() && result.GetType() == LogicalType::BOOLEAN);
729: 	// the inplace loops take the result as the last parameter
730: 	switch (left.GetType().InternalType()) {
731: 	case PhysicalType::BOOL:
732: 	case PhysicalType::INT8:
733: 		TemplatedDistinctExecute<int8_t, OP>(left, right, result, count);
734: 		break;
735: 	case PhysicalType::INT16:
736: 		TemplatedDistinctExecute<int16_t, OP>(left, right, result, count);
737: 		break;
738: 	case PhysicalType::INT32:
739: 		TemplatedDistinctExecute<int32_t, OP>(left, right, result, count);
740: 		break;
741: 	case PhysicalType::INT64:
742: 		TemplatedDistinctExecute<int64_t, OP>(left, right, result, count);
743: 		break;
744: 	case PhysicalType::UINT8:
745: 		TemplatedDistinctExecute<uint8_t, OP>(left, right, result, count);
746: 		break;
747: 	case PhysicalType::UINT16:
748: 		TemplatedDistinctExecute<uint16_t, OP>(left, right, result, count);
749: 		break;
750: 	case PhysicalType::UINT32:
751: 		TemplatedDistinctExecute<uint32_t, OP>(left, right, result, count);
752: 		break;
753: 	case PhysicalType::UINT64:
754: 		TemplatedDistinctExecute<uint64_t, OP>(left, right, result, count);
755: 		break;
756: 	case PhysicalType::INT128:
757: 		TemplatedDistinctExecute<hugeint_t, OP>(left, right, result, count);
758: 		break;
759: 	case PhysicalType::FLOAT:
760: 		TemplatedDistinctExecute<float, OP>(left, right, result, count);
761: 		break;
762: 	case PhysicalType::DOUBLE:
763: 		TemplatedDistinctExecute<double, OP>(left, right, result, count);
764: 		break;
765: 	case PhysicalType::INTERVAL:
766: 		TemplatedDistinctExecute<interval_t, OP>(left, right, result, count);
767: 		break;
768: 	case PhysicalType::VARCHAR:
769: 		TemplatedDistinctExecute<string_t, OP>(left, right, result, count);
770: 		break;
771: 	case PhysicalType::LIST:
772: 	case PhysicalType::MAP:
773: 	case PhysicalType::STRUCT:
774: 		NestedDistinctExecute<OP>(left, right, result, count);
775: 		break;
776: 	default:
777: 		throw InternalException("Invalid type for distinct comparison");
778: 	}
779: }
780: 
781: template <class OP, class OPNESTED = OP>
782: static idx_t TemplatedDistinctSelectOperation(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
783:                                               SelectionVector *true_sel, SelectionVector *false_sel) {
784: 	// the inplace loops take the result as the last parameter
785: 	switch (left.GetType().InternalType()) {
786: 	case PhysicalType::BOOL:
787: 	case PhysicalType::INT8:
788: 		return DistinctSelect<int8_t, int8_t, OP>(left, right, sel, count, true_sel, false_sel);
789: 	case PhysicalType::INT16:
790: 		return DistinctSelect<int16_t, int16_t, OP>(left, right, sel, count, true_sel, false_sel);
791: 	case PhysicalType::INT32:
792: 		return DistinctSelect<int32_t, int32_t, OP>(left, right, sel, count, true_sel, false_sel);
793: 	case PhysicalType::INT64:
794: 		return DistinctSelect<int64_t, int64_t, OP>(left, right, sel, count, true_sel, false_sel);
795: 	case PhysicalType::UINT8:
796: 		return DistinctSelect<uint8_t, uint8_t, OP>(left, right, sel, count, true_sel, false_sel);
797: 	case PhysicalType::UINT16:
798: 		return DistinctSelect<uint16_t, uint16_t, OP>(left, right, sel, count, true_sel, false_sel);
799: 	case PhysicalType::UINT32:
800: 		return DistinctSelect<uint32_t, uint32_t, OP>(left, right, sel, count, true_sel, false_sel);
801: 	case PhysicalType::UINT64:
802: 		return DistinctSelect<uint64_t, uint64_t, OP>(left, right, sel, count, true_sel, false_sel);
803: 	case PhysicalType::INT128:
804: 		return DistinctSelect<hugeint_t, hugeint_t, OP>(left, right, sel, count, true_sel, false_sel);
805: 	case PhysicalType::FLOAT:
806: 		return DistinctSelect<float, float, OP>(left, right, sel, count, true_sel, false_sel);
807: 	case PhysicalType::DOUBLE:
808: 		return DistinctSelect<double, double, OP>(left, right, sel, count, true_sel, false_sel);
809: 	case PhysicalType::INTERVAL:
810: 		return DistinctSelect<interval_t, interval_t, OP>(left, right, sel, count, true_sel, false_sel);
811: 	case PhysicalType::VARCHAR:
812: 		return DistinctSelect<string_t, string_t, OP>(left, right, sel, count, true_sel, false_sel);
813: 	case PhysicalType::MAP:
814: 	case PhysicalType::STRUCT:
815: 	case PhysicalType::LIST:
816: 		return DistinctSelectNested<OP, OPNESTED>(left, right, sel, count, true_sel, false_sel);
817: 	default:
818: 		throw InternalException("Invalid type for distinct selection");
819: 	}
820: }
821: 
822: template <typename OP>
823: static void NestedDistinctExecute(Vector &left, Vector &right, Vector &result, idx_t count) {
824: 	const auto left_constant = left.GetVectorType() == VectorType::CONSTANT_VECTOR;
825: 	const auto right_constant = right.GetVectorType() == VectorType::CONSTANT_VECTOR;
826: 
827: 	if (left_constant && right_constant) {
828: 		// both sides are constant, so just compare one element.
829: 		result.SetVectorType(VectorType::CONSTANT_VECTOR);
830: 		auto result_data = ConstantVector::GetData<bool>(result);
831: 		SelectionVector true_sel(1);
832: 		auto match_count = TemplatedDistinctSelectOperation<OP>(left, right, nullptr, 1, &true_sel, nullptr);
833: 		result_data[0] = match_count > 0;
834: 		return;
835: 	}
836: 
837: 	SelectionVector true_sel(count);
838: 	SelectionVector false_sel(count);
839: 
840: 	// DISTINCT is either true or false
841: 	idx_t match_count = TemplatedDistinctSelectOperation<OP>(left, right, nullptr, count, &true_sel, &false_sel);
842: 
843: 	result.SetVectorType(VectorType::FLAT_VECTOR);
844: 	auto result_data = FlatVector::GetData<bool>(result);
845: 
846: 	for (idx_t i = 0; i < match_count; ++i) {
847: 		const auto idx = true_sel.get_index(i);
848: 		result_data[idx] = true;
849: 	}
850: 
851: 	const idx_t no_match_count = count - match_count;
852: 	for (idx_t i = 0; i < no_match_count; ++i) {
853: 		const auto idx = false_sel.get_index(i);
854: 		result_data[idx] = false;
855: 	}
856: }
857: 
858: void VectorOperations::DistinctFrom(Vector &left, Vector &right, Vector &result, idx_t count) {
859: 	ExecuteDistinct<duckdb::DistinctFrom>(left, right, result, count);
860: }
861: 
862: void VectorOperations::NotDistinctFrom(Vector &left, Vector &right, Vector &result, idx_t count) {
863: 	ExecuteDistinct<duckdb::NotDistinctFrom>(left, right, result, count);
864: }
865: 
866: // true := A != B with nulls being equal
867: idx_t VectorOperations::DistinctFrom(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
868:                                      SelectionVector *true_sel, SelectionVector *false_sel) {
869: 	return TemplatedDistinctSelectOperation<duckdb::DistinctFrom>(left, right, sel, count, true_sel, false_sel);
870: }
871: // true := A == B with nulls being equal
872: idx_t VectorOperations::NotDistinctFrom(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
873:                                         SelectionVector *true_sel, SelectionVector *false_sel) {
874: 	return TemplatedDistinctSelectOperation<duckdb::NotDistinctFrom>(left, right, sel, count, true_sel, false_sel);
875: }
876: 
877: // true := A > B with nulls being maximal
878: idx_t VectorOperations::DistinctGreaterThan(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
879:                                             SelectionVector *true_sel, SelectionVector *false_sel) {
880: 	return TemplatedDistinctSelectOperation<duckdb::DistinctGreaterThan>(left, right, sel, count, true_sel, false_sel);
881: }
882: 
883: // true := A > B with nulls being minimal
884: idx_t VectorOperations::DistinctGreaterThanNullsFirst(Vector &left, Vector &right, const SelectionVector *sel,
885:                                                       idx_t count, SelectionVector *true_sel,
886:                                                       SelectionVector *false_sel) {
887: 	return TemplatedDistinctSelectOperation<duckdb::DistinctGreaterThanNullsFirst, duckdb::DistinctGreaterThan>(
888: 	    left, right, sel, count, true_sel, false_sel);
889: }
890: // true := A >= B with nulls being maximal
891: idx_t VectorOperations::DistinctGreaterThanEquals(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
892:                                                   SelectionVector *true_sel, SelectionVector *false_sel) {
893: 	return TemplatedDistinctSelectOperation<duckdb::DistinctGreaterThanEquals>(left, right, sel, count, true_sel,
894: 	                                                                           false_sel);
895: }
896: // true := A < B with nulls being maximal
897: idx_t VectorOperations::DistinctLessThan(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
898:                                          SelectionVector *true_sel, SelectionVector *false_sel) {
899: 	return TemplatedDistinctSelectOperation<duckdb::DistinctLessThan>(left, right, sel, count, true_sel, false_sel);
900: }
901: 
902: // true := A < B with nulls being minimal
903: idx_t VectorOperations::DistinctLessThanNullsFirst(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
904:                                                    SelectionVector *true_sel, SelectionVector *false_sel) {
905: 	return TemplatedDistinctSelectOperation<duckdb::DistinctLessThanNullsFirst, duckdb::DistinctLessThan>(
906: 	    left, right, sel, count, true_sel, false_sel);
907: }
908: 
909: // true := A <= B with nulls being maximal
910: idx_t VectorOperations::DistinctLessThanEquals(Vector &left, Vector &right, const SelectionVector *sel, idx_t count,
911:                                                SelectionVector *true_sel, SelectionVector *false_sel) {
912: 	return TemplatedDistinctSelectOperation<duckdb::DistinctLessThanEquals>(left, right, sel, count, true_sel,
913: 	                                                                        false_sel);
914: }
915: 
916: // true := A != B with nulls being equal, inputs selected
917: idx_t VectorOperations::NestedNotEquals(Vector &left, Vector &right, const SelectionVector &sel, idx_t count,
918:                                         SelectionVector *true_sel, SelectionVector *false_sel) {
919: 	return TemplatedDistinctSelectOperation<duckdb::DistinctFrom>(left, right, &sel, count, true_sel, false_sel);
920: }
921: // true := A == B with nulls being equal, inputs selected
922: idx_t VectorOperations::NestedEquals(Vector &left, Vector &right, const SelectionVector &sel, idx_t count,
923:                                      SelectionVector *true_sel, SelectionVector *false_sel) {
924: 	return TemplatedDistinctSelectOperation<duckdb::NotDistinctFrom>(left, right, &sel, count, true_sel, false_sel);
925: }
926: 
927: } // namespace duckdb
[end of src/common/vector_operations/is_distinct_from.cpp]
[start of src/function/scalar/list/contains_or_position.cpp]
1: #include "duckdb/function/scalar/nested_functions.hpp"
2: #include "duckdb/planner/expression/bound_function_expression.hpp"
3: #include "duckdb/planner/expression_binder.hpp"
4: #include "duckdb/common/operator/comparison_operators.hpp"
5: 
6: namespace duckdb {
7: 
8: struct ContainsFunctor {
9: 	static inline bool Initialize() {
10: 		return false;
11: 	}
12: 	static inline bool UpdateResultEntries(idx_t child_idx) {
13: 		return true;
14: 	}
15: };
16: 
17: struct PositionFunctor {
18: 	static inline int32_t Initialize() {
19: 		return 0;
20: 	}
21: 	static inline int32_t UpdateResultEntries(idx_t child_idx) {
22: 		return child_idx + 1;
23: 	}
24: };
25: 
26: template <class CHILD_TYPE, class RETURN_TYPE, class OP>
27: static void TemplatedContainsOrPosition(DataChunk &args, ExpressionState &state, Vector &result,
28:                                         bool is_nested = false) {
29: 	D_ASSERT(args.ColumnCount() == 2);
30: 	auto count = args.size();
31: 	Vector &list = args.data[0];
32: 	Vector &value_vector = args.data[1];
33: 
34: 	// Create a result vector of type RETURN_TYPE
35: 	result.SetVectorType(VectorType::FLAT_VECTOR);
36: 	auto result_entries = FlatVector::GetData<RETURN_TYPE>(result);
37: 	auto &result_validity = FlatVector::Validity(result);
38: 
39: 	if (list.GetType().id() == LogicalTypeId::SQLNULL) {
40: 		result_validity.SetInvalid(0);
41: 		return;
42: 	}
43: 
44: 	auto list_size = ListVector::GetListSize(list);
45: 	auto &child_vector = ListVector::GetEntry(list);
46: 
47: 	UnifiedVectorFormat child_data;
48: 	child_vector.ToUnifiedFormat(list_size, child_data);
49: 
50: 	UnifiedVectorFormat list_data;
51: 	list.ToUnifiedFormat(count, list_data);
52: 	auto list_entries = (list_entry_t *)list_data.data;
53: 
54: 	UnifiedVectorFormat value_data;
55: 	value_vector.ToUnifiedFormat(count, value_data);
56: 
57: 	// not required for a comparison of nested types
58: 	auto child_value = FlatVector::GetData<CHILD_TYPE>(child_vector);
59: 	auto values = FlatVector::GetData<CHILD_TYPE>(value_vector);
60: 
61: 	for (idx_t i = 0; i < count; i++) {
62: 		auto list_index = list_data.sel->get_index(i);
63: 		auto value_index = value_data.sel->get_index(i);
64: 
65: 		if (!list_data.validity.RowIsValid(list_index) || !value_data.validity.RowIsValid(value_index)) {
66: 			result_validity.SetInvalid(i);
67: 			continue;
68: 		}
69: 
70: 		const auto &list_entry = list_entries[list_index];
71: 
72: 		result_entries[i] = OP::Initialize();
73: 		for (idx_t child_idx = 0; child_idx < list_entry.length; child_idx++) {
74: 
75: 			auto child_value_idx = child_data.sel->get_index(list_entry.offset + child_idx);
76: 			if (!child_data.validity.RowIsValid(child_value_idx)) {
77: 				continue;
78: 			}
79: 
80: 			if (!is_nested) {
81: 				if (Equals::Operation(child_value[child_value_idx], values[value_index])) {
82: 					result_entries[i] = OP::UpdateResultEntries(child_idx);
83: 					break; // Found value in list, no need to look further
84: 				}
85: 			} else {
86: 				// FIXME: using Value is less efficient than modifying the vector comparison code
87: 				// to more efficiently compare nested types
88: 				auto lvalue = child_vector.GetValue(child_value_idx);
89: 				auto rvalue = value_vector.GetValue(value_index);
90: 				if (Value::NotDistinctFrom(lvalue, rvalue)) {
91: 					result_entries[i] = OP::UpdateResultEntries(child_idx);
92: 					break; // Found value in list, no need to look further
93: 				}
94: 			}
95: 		}
96: 	}
97: 
98: 	if (args.AllConstant()) {
99: 		result.SetVectorType(VectorType::CONSTANT_VECTOR);
100: 	}
101: }
102: 
103: template <class T, class OP>
104: static void ListContainsOrPosition(DataChunk &args, ExpressionState &state, Vector &result) {
105: 	switch (args.data[1].GetType().InternalType()) {
106: 	case PhysicalType::BOOL:
107: 	case PhysicalType::INT8:
108: 		TemplatedContainsOrPosition<int8_t, T, OP>(args, state, result);
109: 		break;
110: 	case PhysicalType::INT16:
111: 		TemplatedContainsOrPosition<int16_t, T, OP>(args, state, result);
112: 		break;
113: 	case PhysicalType::INT32:
114: 		TemplatedContainsOrPosition<int32_t, T, OP>(args, state, result);
115: 		break;
116: 	case PhysicalType::INT64:
117: 		TemplatedContainsOrPosition<int64_t, T, OP>(args, state, result);
118: 		break;
119: 	case PhysicalType::INT128:
120: 		TemplatedContainsOrPosition<hugeint_t, T, OP>(args, state, result);
121: 		break;
122: 	case PhysicalType::UINT8:
123: 		TemplatedContainsOrPosition<uint8_t, T, OP>(args, state, result);
124: 		break;
125: 	case PhysicalType::UINT16:
126: 		TemplatedContainsOrPosition<uint16_t, T, OP>(args, state, result);
127: 		break;
128: 	case PhysicalType::UINT32:
129: 		TemplatedContainsOrPosition<uint32_t, T, OP>(args, state, result);
130: 		break;
131: 	case PhysicalType::UINT64:
132: 		TemplatedContainsOrPosition<uint64_t, T, OP>(args, state, result);
133: 		break;
134: 	case PhysicalType::FLOAT:
135: 		TemplatedContainsOrPosition<float, T, OP>(args, state, result);
136: 		break;
137: 	case PhysicalType::DOUBLE:
138: 		TemplatedContainsOrPosition<double, T, OP>(args, state, result);
139: 		break;
140: 	case PhysicalType::VARCHAR:
141: 		TemplatedContainsOrPosition<string_t, T, OP>(args, state, result);
142: 		break;
143: 	case PhysicalType::MAP:
144: 	case PhysicalType::STRUCT:
145: 	case PhysicalType::LIST:
146: 		TemplatedContainsOrPosition<int8_t, T, OP>(args, state, result, true);
147: 		break;
148: 	default:
149: 		throw NotImplementedException("This function has not been implemented for this type");
150: 	}
151: }
152: 
153: static void ListContainsFunction(DataChunk &args, ExpressionState &state, Vector &result) {
154: 	return ListContainsOrPosition<bool, ContainsFunctor>(args, state, result);
155: }
156: 
157: static void ListPositionFunction(DataChunk &args, ExpressionState &state, Vector &result) {
158: 	return ListContainsOrPosition<int32_t, PositionFunctor>(args, state, result);
159: }
160: 
161: template <LogicalTypeId RETURN_TYPE>
162: static unique_ptr<FunctionData> ListContainsOrPositionBind(ClientContext &context, ScalarFunction &bound_function,
163:                                                            vector<unique_ptr<Expression>> &arguments) {
164: 	D_ASSERT(bound_function.arguments.size() == 2);
165: 
166: 	const auto &list = arguments[0]->return_type; // change to list
167: 	const auto &value = arguments[1]->return_type;
168: 	if (list.id() == LogicalTypeId::UNKNOWN) {
169: 		bound_function.return_type = RETURN_TYPE;
170: 		if (value.id() != LogicalTypeId::UNKNOWN) {
171: 			// only list is a parameter, cast it to a list of value type
172: 			bound_function.arguments[0] = LogicalType::LIST(value);
173: 			bound_function.arguments[1] = value;
174: 		}
175: 	} else if (value.id() == LogicalTypeId::UNKNOWN) {
176: 		// only value is a parameter: we expect the child type of list
177: 		auto const &child_type = ListType::GetChildType(list);
178: 		bound_function.arguments[0] = list;
179: 		bound_function.arguments[1] = child_type;
180: 		bound_function.return_type = RETURN_TYPE;
181: 	} else {
182: 		auto const &child_type = ListType::GetChildType(list);
183: 		auto max_child_type = LogicalType::MaxLogicalType(child_type, value);
184: 		auto list_type = LogicalType::LIST(max_child_type);
185: 
186: 		bound_function.arguments[0] = list_type;
187: 		bound_function.arguments[1] = value == max_child_type ? value : max_child_type;
188: 
189: 		// list_contains and list_position only differ in their return type
190: 		bound_function.return_type = RETURN_TYPE;
191: 	}
192: 	return make_unique<VariableReturnBindData>(bound_function.return_type);
193: }
194: 
195: static unique_ptr<FunctionData> ListContainsBind(ClientContext &context, ScalarFunction &bound_function,
196:                                                  vector<unique_ptr<Expression>> &arguments) {
197: 	return ListContainsOrPositionBind<LogicalType::BOOLEAN>(context, bound_function, arguments);
198: }
199: 
200: static unique_ptr<FunctionData> ListPositionBind(ClientContext &context, ScalarFunction &bound_function,
201:                                                  vector<unique_ptr<Expression>> &arguments) {
202: 	return ListContainsOrPositionBind<LogicalType::INTEGER>(context, bound_function, arguments);
203: }
204: 
205: ScalarFunction ListContainsFun::GetFunction() {
206: 	return ScalarFunction({LogicalType::LIST(LogicalType::ANY), LogicalType::ANY}, // argument list
207: 	                      LogicalType::BOOLEAN,                                    // return type
208: 	                      ListContainsFunction, ListContainsBind, nullptr);
209: }
210: 
211: ScalarFunction ListPositionFun::GetFunction() {
212: 	return ScalarFunction({LogicalType::LIST(LogicalType::ANY), LogicalType::ANY}, // argument list
213: 	                      LogicalType::INTEGER,                                    // return type
214: 	                      ListPositionFunction, ListPositionBind, nullptr);
215: }
216: 
217: void ListContainsFun::RegisterFunction(BuiltinFunctions &set) {
218: 	set.AddFunction({"list_contains", "array_contains", "list_has", "array_has"}, GetFunction());
219: }
220: 
221: void ListPositionFun::RegisterFunction(BuiltinFunctions &set) {
222: 	set.AddFunction({"list_position", "list_indexof", "array_position", "array_indexof"}, GetFunction());
223: }
224: } // namespace duckdb
[end of src/function/scalar/list/contains_or_position.cpp]
[start of src/function/scalar/list/list_extract.cpp]
1: #include "duckdb/common/pair.hpp"
2: #include "duckdb/common/string_util.hpp"
3: #include "duckdb/common/types/chunk_collection.hpp"
4: #include "duckdb/common/types/data_chunk.hpp"
5: #include "duckdb/common/vector_operations/binary_executor.hpp"
6: #include "duckdb/function/scalar/nested_functions.hpp"
7: #include "duckdb/function/scalar/string_functions.hpp"
8: #include "duckdb/parser/expression/bound_expression.hpp"
9: #include "duckdb/planner/expression/bound_function_expression.hpp"
10: #include "duckdb/storage/statistics/list_statistics.hpp"
11: #include "duckdb/storage/statistics/validity_statistics.hpp"
12: 
13: namespace duckdb {
14: 
15: template <class T, bool HEAP_REF = false, bool VALIDITY_ONLY = false>
16: void ListExtractTemplate(idx_t count, UnifiedVectorFormat &list_data, UnifiedVectorFormat &offsets_data,
17:                          Vector &child_vector, idx_t list_size, Vector &result) {
18: 	UnifiedVectorFormat child_data;
19: 	child_vector.ToUnifiedFormat(list_size, child_data);
20: 
21: 	T *result_data;
22: 
23: 	result.SetVectorType(VectorType::FLAT_VECTOR);
24: 	if (!VALIDITY_ONLY) {
25: 		result_data = FlatVector::GetData<T>(result);
26: 	}
27: 	auto &result_mask = FlatVector::Validity(result);
28: 
29: 	// heap-ref once
30: 	if (HEAP_REF) {
31: 		StringVector::AddHeapReference(result, child_vector);
32: 	}
33: 
34: 	// this is lifted from ExecuteGenericLoop because we can't push the list child data into this otherwise
35: 	// should have gone with GetValue perhaps
36: 	for (idx_t i = 0; i < count; i++) {
37: 		auto list_index = list_data.sel->get_index(i);
38: 		auto offsets_index = offsets_data.sel->get_index(i);
39: 		if (list_data.validity.RowIsValid(list_index) && offsets_data.validity.RowIsValid(offsets_index)) {
40: 			auto list_entry = ((list_entry_t *)list_data.data)[list_index];
41: 			auto offsets_entry = ((int64_t *)offsets_data.data)[offsets_index];
42: 
43: 			// 1-based indexing
44: 			if (offsets_entry == 0) {
45: 				result_mask.SetInvalid(i);
46: 				continue;
47: 			}
48: 			offsets_entry = (offsets_entry > 0) ? offsets_entry - 1 : offsets_entry;
49: 
50: 			idx_t child_offset;
51: 			if (offsets_entry < 0) {
52: 				if ((idx_t)-offsets_entry > list_entry.length) {
53: 					result_mask.SetInvalid(i);
54: 					continue;
55: 				}
56: 				child_offset = list_entry.offset + list_entry.length + offsets_entry;
57: 			} else {
58: 				if ((idx_t)offsets_entry >= list_entry.length) {
59: 					result_mask.SetInvalid(i);
60: 					continue;
61: 				}
62: 				child_offset = list_entry.offset + offsets_entry;
63: 			}
64: 			if (child_data.validity.RowIsValid(child_offset)) {
65: 				if (!VALIDITY_ONLY) {
66: 					result_data[i] = ((T *)child_data.data)[child_offset];
67: 				}
68: 			} else {
69: 				result_mask.SetInvalid(i);
70: 			}
71: 		} else {
72: 			result_mask.SetInvalid(i);
73: 		}
74: 	}
75: 	if (count == 1) {
76: 		result.SetVectorType(VectorType::CONSTANT_VECTOR);
77: 	}
78: }
79: static void ExecuteListExtractInternal(const idx_t count, UnifiedVectorFormat &list, UnifiedVectorFormat &offsets,
80:                                        Vector &child_vector, idx_t list_size, Vector &result) {
81: 	D_ASSERT(child_vector.GetType() == result.GetType());
82: 	switch (result.GetType().InternalType()) {
83: 	case PhysicalType::BOOL:
84: 	case PhysicalType::INT8:
85: 		ListExtractTemplate<int8_t>(count, list, offsets, child_vector, list_size, result);
86: 		break;
87: 	case PhysicalType::INT16:
88: 		ListExtractTemplate<int16_t>(count, list, offsets, child_vector, list_size, result);
89: 		break;
90: 	case PhysicalType::INT32:
91: 		ListExtractTemplate<int32_t>(count, list, offsets, child_vector, list_size, result);
92: 		break;
93: 	case PhysicalType::INT64:
94: 		ListExtractTemplate<int64_t>(count, list, offsets, child_vector, list_size, result);
95: 		break;
96: 	case PhysicalType::INT128:
97: 		ListExtractTemplate<hugeint_t>(count, list, offsets, child_vector, list_size, result);
98: 		break;
99: 	case PhysicalType::UINT8:
100: 		ListExtractTemplate<uint8_t>(count, list, offsets, child_vector, list_size, result);
101: 		break;
102: 	case PhysicalType::UINT16:
103: 		ListExtractTemplate<uint16_t>(count, list, offsets, child_vector, list_size, result);
104: 		break;
105: 	case PhysicalType::UINT32:
106: 		ListExtractTemplate<uint32_t>(count, list, offsets, child_vector, list_size, result);
107: 		break;
108: 	case PhysicalType::UINT64:
109: 		ListExtractTemplate<uint64_t>(count, list, offsets, child_vector, list_size, result);
110: 		break;
111: 	case PhysicalType::FLOAT:
112: 		ListExtractTemplate<float>(count, list, offsets, child_vector, list_size, result);
113: 		break;
114: 	case PhysicalType::DOUBLE:
115: 		ListExtractTemplate<double>(count, list, offsets, child_vector, list_size, result);
116: 		break;
117: 	case PhysicalType::VARCHAR:
118: 		ListExtractTemplate<string_t, true>(count, list, offsets, child_vector, list_size, result);
119: 		break;
120: 	case PhysicalType::INTERVAL:
121: 		ListExtractTemplate<interval_t>(count, list, offsets, child_vector, list_size, result);
122: 		break;
123: 	case PhysicalType::STRUCT: {
124: 		auto &entries = StructVector::GetEntries(child_vector);
125: 		auto &result_entries = StructVector::GetEntries(result);
126: 		D_ASSERT(entries.size() == result_entries.size());
127: 		// extract the child entries of the struct
128: 		for (idx_t i = 0; i < entries.size(); i++) {
129: 			ExecuteListExtractInternal(count, list, offsets, *entries[i], list_size, *result_entries[i]);
130: 		}
131: 		// extract the validity mask
132: 		ListExtractTemplate<bool, false, true>(count, list, offsets, child_vector, list_size, result);
133: 		break;
134: 	}
135: 	case PhysicalType::LIST: {
136: 		// nested list: we have to reference the child
137: 		auto &child_child_list = ListVector::GetEntry(child_vector);
138: 
139: 		ListVector::GetEntry(result).Reference(child_child_list);
140: 		ListVector::SetListSize(result, ListVector::GetListSize(child_vector));
141: 		ListExtractTemplate<list_entry_t>(count, list, offsets, child_vector, list_size, result);
142: 		break;
143: 	}
144: 	default:
145: 		throw NotImplementedException("Unimplemented type for LIST_EXTRACT");
146: 	}
147: }
148: 
149: static void ExecuteListExtract(Vector &result, Vector &list, Vector &offsets, const idx_t count) {
150: 	D_ASSERT(list.GetType().id() == LogicalTypeId::LIST);
151: 	UnifiedVectorFormat list_data;
152: 	UnifiedVectorFormat offsets_data;
153: 
154: 	list.ToUnifiedFormat(count, list_data);
155: 	offsets.ToUnifiedFormat(count, offsets_data);
156: 	ExecuteListExtractInternal(count, list_data, offsets_data, ListVector::GetEntry(list),
157: 	                           ListVector::GetListSize(list), result);
158: 	result.Verify(count);
159: }
160: 
161: static void ExecuteStringExtract(Vector &result, Vector &input_vector, Vector &subscript_vector, const idx_t count) {
162: 	BinaryExecutor::Execute<string_t, int64_t, string_t>(
163: 	    input_vector, subscript_vector, result, count, [&](string_t input_string, int64_t subscript) {
164: 		    return SubstringFun::SubstringUnicode(result, input_string, subscript, 1);
165: 	    });
166: }
167: 
168: static void ListExtractFunction(DataChunk &args, ExpressionState &state, Vector &result) {
169: 	D_ASSERT(args.ColumnCount() == 2);
170: 	auto count = args.size();
171: 
172: 	result.SetVectorType(VectorType::CONSTANT_VECTOR);
173: 	for (idx_t i = 0; i < args.ColumnCount(); i++) {
174: 		if (args.data[i].GetVectorType() != VectorType::CONSTANT_VECTOR) {
175: 			result.SetVectorType(VectorType::FLAT_VECTOR);
176: 		}
177: 	}
178: 
179: 	Vector &base = args.data[0];
180: 	Vector &subscript = args.data[1];
181: 
182: 	switch (base.GetType().id()) {
183: 	case LogicalTypeId::LIST:
184: 		ExecuteListExtract(result, base, subscript, count);
185: 		break;
186: 	case LogicalTypeId::VARCHAR:
187: 		ExecuteStringExtract(result, base, subscript, count);
188: 		break;
189: 	case LogicalTypeId::SQLNULL:
190: 		result.SetVectorType(VectorType::CONSTANT_VECTOR);
191: 		ConstantVector::SetNull(result, true);
192: 		break;
193: 	default:
194: 		throw NotImplementedException("Specifier type not implemented");
195: 	}
196: }
197: 
198: static unique_ptr<FunctionData> ListExtractBind(ClientContext &context, ScalarFunction &bound_function,
199:                                                 vector<unique_ptr<Expression>> &arguments) {
200: 	D_ASSERT(bound_function.arguments.size() == 2);
201: 	D_ASSERT(LogicalTypeId::LIST == arguments[0]->return_type.id());
202: 	// list extract returns the child type of the list as return type
203: 	bound_function.return_type = ListType::GetChildType(arguments[0]->return_type);
204: 	return make_unique<VariableReturnBindData>(bound_function.return_type);
205: }
206: 
207: static unique_ptr<BaseStatistics> ListExtractStats(ClientContext &context, FunctionStatisticsInput &input) {
208: 	auto &child_stats = input.child_stats;
209: 	if (!child_stats[0]) {
210: 		return nullptr;
211: 	}
212: 	auto &list_stats = (ListStatistics &)*child_stats[0];
213: 	if (!list_stats.child_stats) {
214: 		return nullptr;
215: 	}
216: 	auto child_copy = list_stats.child_stats->Copy();
217: 	// list_extract always pushes a NULL, since if the offset is out of range for a list it inserts a null
218: 	child_copy->validity_stats = make_unique<ValidityStatistics>(true);
219: 	return child_copy;
220: }
221: 
222: void ListExtractFun::RegisterFunction(BuiltinFunctions &set) {
223: 	// the arguments and return types are actually set in the binder function
224: 	ScalarFunction lfun({LogicalType::LIST(LogicalType::ANY), LogicalType::BIGINT}, LogicalType::ANY,
225: 	                    ListExtractFunction, ListExtractBind, nullptr, ListExtractStats);
226: 
227: 	ScalarFunction sfun({LogicalType::VARCHAR, LogicalType::BIGINT}, LogicalType::VARCHAR, ListExtractFunction);
228: 
229: 	ScalarFunctionSet list_extract("list_extract");
230: 	list_extract.AddFunction(lfun);
231: 	list_extract.AddFunction(sfun);
232: 	set.AddFunction(list_extract);
233: 
234: 	ScalarFunctionSet list_element("list_element");
235: 	list_element.AddFunction(lfun);
236: 	list_element.AddFunction(sfun);
237: 	set.AddFunction(list_element);
238: 
239: 	ScalarFunctionSet array_extract("array_extract");
240: 	array_extract.AddFunction(lfun);
241: 	array_extract.AddFunction(sfun);
242: 	array_extract.AddFunction(StructExtractFun::GetFunction());
243: 	set.AddFunction(array_extract);
244: }
245: 
246: } // namespace duckdb
[end of src/function/scalar/list/list_extract.cpp]
[start of src/function/scalar/list/list_lambdas.cpp]
1: #include "duckdb/planner/expression/bound_function_expression.hpp"
2: #include "duckdb/function/scalar/nested_functions.hpp"
3: #include "duckdb/planner/expression_iterator.hpp"
4: #include "duckdb/planner/expression/bound_reference_expression.hpp"
5: #include "duckdb/execution/expression_executor.hpp"
6: #include "duckdb/planner/expression/bound_constant_expression.hpp"
7: #include "duckdb/planner/expression/bound_lambda_expression.hpp"
8: 
9: namespace duckdb {
10: 
11: struct ListLambdaBindData : public FunctionData {
12: 	ListLambdaBindData(const LogicalType &stype_p, unique_ptr<Expression> lambda_expr);
13: 	~ListLambdaBindData() override;
14: 
15: 	LogicalType stype;
16: 	unique_ptr<Expression> lambda_expr;
17: 
18: public:
19: 	bool Equals(const FunctionData &other_p) const override;
20: 	unique_ptr<FunctionData> Copy() const override;
21: 	static void Serialize(FieldWriter &writer, const FunctionData *bind_data_p, const ScalarFunction &function) {
22: 		throw NotImplementedException("FIXME: list lambda serialize");
23: 	}
24: 	static unique_ptr<FunctionData> Deserialize(ClientContext &context, FieldReader &reader,
25: 	                                            ScalarFunction &bound_function) {
26: 		throw NotImplementedException("FIXME: list lambda deserialize");
27: 	}
28: };
29: 
30: ListLambdaBindData::ListLambdaBindData(const LogicalType &stype_p, unique_ptr<Expression> lambda_expr_p)
31:     : stype(stype_p), lambda_expr(move(lambda_expr_p)) {
32: }
33: 
34: unique_ptr<FunctionData> ListLambdaBindData::Copy() const {
35: 	return make_unique<ListLambdaBindData>(stype, lambda_expr->Copy());
36: }
37: 
38: bool ListLambdaBindData::Equals(const FunctionData &other_p) const {
39: 	auto &other = (ListLambdaBindData &)other_p;
40: 	return lambda_expr->Equals(other.lambda_expr.get()) && stype == other.stype;
41: }
42: 
43: ListLambdaBindData::~ListLambdaBindData() {
44: }
45: 
46: static void AppendTransformedToResult(Vector &lambda_vector, idx_t &elem_cnt, Vector &result) {
47: 
48: 	// append the lambda_vector to the result list
49: 	UnifiedVectorFormat lambda_child_data;
50: 	lambda_vector.ToUnifiedFormat(elem_cnt, lambda_child_data);
51: 	ListVector::Append(result, lambda_vector, *lambda_child_data.sel, elem_cnt, 0);
52: }
53: 
54: static void AppendFilteredToResult(Vector &lambda_vector, list_entry_t *result_entries, idx_t &elem_cnt, Vector &result,
55:                                    idx_t &curr_list_len, idx_t &curr_list_offset, idx_t &appended_lists_cnt,
56:                                    vector<idx_t> &lists_len, idx_t &curr_original_list_len, DataChunk &input_chunk) {
57: 
58: 	idx_t true_count = 0;
59: 	SelectionVector true_sel(elem_cnt);
60: 	auto lambda_values = FlatVector::GetData<bool>(lambda_vector);
61: 	auto &lambda_validity = FlatVector::Validity(lambda_vector);
62: 
63: 	// compute the new lengths and offsets, and create a selection vector
64: 	for (idx_t i = 0; i < elem_cnt; i++) {
65: 
66: 		while (appended_lists_cnt < lists_len.size() && lists_len[appended_lists_cnt] == 0) {
67: 			result_entries[appended_lists_cnt].offset = curr_list_offset;
68: 			result_entries[appended_lists_cnt].length = 0;
69: 			appended_lists_cnt++;
70: 		}
71: 
72: 		// found a true value
73: 		if (lambda_validity.RowIsValid(i)) {
74: 			if (lambda_values[i] > 0) {
75: 				true_sel.set_index(true_count++, i);
76: 				curr_list_len++;
77: 			}
78: 		}
79: 		curr_original_list_len++;
80: 
81: 		if (lists_len[appended_lists_cnt] == curr_original_list_len) {
82: 			result_entries[appended_lists_cnt].offset = curr_list_offset;
83: 			result_entries[appended_lists_cnt].length = curr_list_len;
84: 			curr_list_offset += curr_list_len;
85: 			appended_lists_cnt++;
86: 			curr_list_len = 0;
87: 			curr_original_list_len = 0;
88: 		}
89: 	}
90: 
91: 	while (appended_lists_cnt < lists_len.size() && lists_len[appended_lists_cnt] == 0) {
92: 		result_entries[appended_lists_cnt].offset = curr_list_offset;
93: 		result_entries[appended_lists_cnt].length = 0;
94: 		appended_lists_cnt++;
95: 	}
96: 
97: 	// slice to get the new lists and append them to the result
98: 	Vector new_lists(input_chunk.data[0], true_sel, true_count);
99: 	new_lists.Flatten(true_count);
100: 	UnifiedVectorFormat new_lists_child_data;
101: 	new_lists.ToUnifiedFormat(true_count, new_lists_child_data);
102: 	ListVector::Append(result, new_lists, *new_lists_child_data.sel, true_count, 0);
103: }
104: 
105: static void ExecuteExpression(vector<LogicalType> &types, vector<LogicalType> &result_types, idx_t &elem_cnt,
106:                               SelectionVector &sel, vector<SelectionVector> &sel_vectors, DataChunk &input_chunk,
107:                               DataChunk &lambda_chunk, Vector &child_vector, DataChunk &args,
108:                               ExpressionExecutor &expr_executor) {
109: 
110: 	input_chunk.SetCardinality(elem_cnt);
111: 	lambda_chunk.SetCardinality(elem_cnt);
112: 
113: 	// set the list child vector
114: 	Vector slice(child_vector, sel, elem_cnt);
115: 	slice.Flatten(elem_cnt);
116: 	input_chunk.data[0].Reference(slice);
117: 
118: 	// set the other vectors
119: 	vector<Vector> slices;
120: 	for (idx_t col_idx = 0; col_idx < args.ColumnCount() - 1; col_idx++) {
121: 		slices.emplace_back(Vector(args.data[col_idx + 1], sel_vectors[col_idx], elem_cnt));
122: 		slices[col_idx].Flatten(elem_cnt);
123: 		input_chunk.data[col_idx + 1].Reference(slices[col_idx]);
124: 	}
125: 
126: 	// execute the lambda expression
127: 	expr_executor.Execute(input_chunk, lambda_chunk);
128: }
129: 
130: template <bool IS_TRANSFORM = true>
131: static void ListLambdaFunction(DataChunk &args, ExpressionState &state, Vector &result) {
132: 
133: 	// always at least the list argument
134: 	D_ASSERT(args.ColumnCount() >= 1);
135: 
136: 	auto count = args.size();
137: 	Vector &lists = args.data[0];
138: 
139: 	result.SetVectorType(VectorType::FLAT_VECTOR);
140: 	auto result_entries = FlatVector::GetData<list_entry_t>(result);
141: 	auto &result_validity = FlatVector::Validity(result);
142: 
143: 	if (lists.GetType().id() == LogicalTypeId::SQLNULL) {
144: 		result_validity.SetInvalid(0);
145: 		return;
146: 	}
147: 
148: 	// e.g. window functions in sub queries return dictionary vectors, which segfault on expression execution
149: 	// if not flattened first
150: 	for (idx_t i = 1; i < args.ColumnCount(); i++) {
151: 		if (args.data[i].GetVectorType() != VectorType::FLAT_VECTOR &&
152: 		    args.data[i].GetVectorType() != VectorType::CONSTANT_VECTOR) {
153: 			args.data[i].Flatten(count);
154: 		}
155: 	}
156: 
157: 	// get the lists data
158: 	UnifiedVectorFormat lists_data;
159: 	lists.ToUnifiedFormat(count, lists_data);
160: 	auto list_entries = (list_entry_t *)lists_data.data;
161: 
162: 	// get the lambda expression
163: 	auto &func_expr = (BoundFunctionExpression &)state.expr;
164: 	auto &info = (ListLambdaBindData &)*func_expr.bind_info;
165: 	auto &lambda_expr = info.lambda_expr;
166: 
167: 	// get the child vector and child data
168: 	auto lists_size = ListVector::GetListSize(lists);
169: 	auto &child_vector = ListVector::GetEntry(lists);
170: 	UnifiedVectorFormat child_data;
171: 	child_vector.ToUnifiedFormat(lists_size, child_data);
172: 
173: 	// to slice the child vector
174: 	SelectionVector sel(STANDARD_VECTOR_SIZE);
175: 
176: 	// this vector never contains more than one element
177: 	vector<LogicalType> result_types;
178: 	result_types.push_back(lambda_expr->return_type);
179: 
180: 	// non-lambda parameter columns
181: 	vector<UnifiedVectorFormat> columns;
182: 	vector<idx_t> indexes;
183: 	vector<SelectionVector> sel_vectors;
184: 
185: 	vector<LogicalType> types;
186: 	types.push_back(child_vector.GetType());
187: 
188: 	// skip the list column
189: 	for (idx_t i = 1; i < args.ColumnCount(); i++) {
190: 		columns.emplace_back(UnifiedVectorFormat());
191: 		args.data[i].ToUnifiedFormat(count, columns[i - 1]);
192: 		indexes.push_back(0);
193: 		sel_vectors.emplace_back(SelectionVector(STANDARD_VECTOR_SIZE));
194: 		types.push_back(args.data[i].GetType());
195: 	}
196: 
197: 	// get the expression executor
198: 	ExpressionExecutor expr_executor(Allocator::DefaultAllocator(), *lambda_expr);
199: 
200: 	// these are only for the list_filter
201: 	vector<idx_t> lists_len;
202: 	idx_t curr_list_len = 0;
203: 	idx_t curr_list_offset = 0;
204: 	idx_t appended_lists_cnt = 0;
205: 	idx_t curr_original_list_len = 0;
206: 
207: 	if (!IS_TRANSFORM) {
208: 		lists_len.reserve(count);
209: 	}
210: 
211: 	DataChunk input_chunk;
212: 	DataChunk lambda_chunk;
213: 	input_chunk.InitializeEmpty(types);
214: 	lambda_chunk.Initialize(Allocator::DefaultAllocator(), result_types);
215: 
216: 	// loop over the child entries and create chunks to be executed by the expression executor
217: 	idx_t elem_cnt = 0;
218: 	idx_t offset = 0;
219: 	for (idx_t row_idx = 0; row_idx < count; row_idx++) {
220: 
221: 		auto lists_index = lists_data.sel->get_index(row_idx);
222: 		const auto &list_entry = list_entries[lists_index];
223: 
224: 		// set the result to NULL for this row
225: 		if (!lists_data.validity.RowIsValid(lists_index)) {
226: 			result_validity.SetInvalid(row_idx);
227: 			if (!IS_TRANSFORM) {
228: 				lists_len.push_back(0);
229: 			}
230: 			continue;
231: 		}
232: 
233: 		// set the length and offset of the resulting lists of list_transform
234: 		if (IS_TRANSFORM) {
235: 			result_entries[row_idx].offset = offset;
236: 			result_entries[row_idx].length = list_entry.length;
237: 			offset += list_entry.length;
238: 		} else {
239: 			lists_len.push_back(list_entry.length);
240: 		}
241: 
242: 		// empty list, nothing to execute
243: 		if (list_entry.length == 0) {
244: 			continue;
245: 		}
246: 
247: 		// get the data indexes
248: 		for (idx_t col_idx = 0; col_idx < args.ColumnCount() - 1; col_idx++) {
249: 			indexes[col_idx] = columns[col_idx].sel->get_index(row_idx);
250: 		}
251: 
252: 		// iterate list elements and create transformed expression columns
253: 		for (idx_t child_idx = 0; child_idx < list_entry.length; child_idx++) {
254: 
255: 			// reached STANDARD_VECTOR_SIZE elements
256: 			if (elem_cnt == STANDARD_VECTOR_SIZE) {
257: 
258: 				lambda_chunk.Reset();
259: 				ExecuteExpression(types, result_types, elem_cnt, sel, sel_vectors, input_chunk, lambda_chunk,
260: 				                  child_vector, args, expr_executor);
261: 
262: 				auto &lambda_vector = lambda_chunk.data[0];
263: 
264: 				if (IS_TRANSFORM) {
265: 					AppendTransformedToResult(lambda_vector, elem_cnt, result);
266: 				} else {
267: 					AppendFilteredToResult(lambda_vector, result_entries, elem_cnt, result, curr_list_len,
268: 					                       curr_list_offset, appended_lists_cnt, lists_len, curr_original_list_len,
269: 					                       input_chunk);
270: 				}
271: 				elem_cnt = 0;
272: 			}
273: 
274: 			// to slice the child vector
275: 			auto source_idx = child_data.sel->get_index(list_entry.offset + child_idx);
276: 			sel.set_index(elem_cnt, source_idx);
277: 
278: 			// for each column, set the index of the selection vector to slice properly
279: 			for (idx_t col_idx = 0; col_idx < args.ColumnCount() - 1; col_idx++) {
280: 				sel_vectors[col_idx].set_index(elem_cnt, indexes[col_idx]);
281: 			}
282: 			elem_cnt++;
283: 		}
284: 	}
285: 
286: 	lambda_chunk.Reset();
287: 	ExecuteExpression(types, result_types, elem_cnt, sel, sel_vectors, input_chunk, lambda_chunk, child_vector, args,
288: 	                  expr_executor);
289: 	auto &lambda_vector = lambda_chunk.data[0];
290: 
291: 	if (IS_TRANSFORM) {
292: 		AppendTransformedToResult(lambda_vector, elem_cnt, result);
293: 	} else {
294: 		AppendFilteredToResult(lambda_vector, result_entries, elem_cnt, result, curr_list_len, curr_list_offset,
295: 		                       appended_lists_cnt, lists_len, curr_original_list_len, input_chunk);
296: 	}
297: 
298: 	if (args.AllConstant()) {
299: 		result.SetVectorType(VectorType::CONSTANT_VECTOR);
300: 	}
301: }
302: 
303: static void ListTransformFunction(DataChunk &args, ExpressionState &state, Vector &result) {
304: 	ListLambdaFunction<>(args, state, result);
305: }
306: 
307: static void ListFilterFunction(DataChunk &args, ExpressionState &state, Vector &result) {
308: 	ListLambdaFunction<false>(args, state, result);
309: }
310: 
311: template <int64_t LAMBDA_PARAM_CNT>
312: static unique_ptr<FunctionData> ListLambdaBind(ClientContext &context, ScalarFunction &bound_function,
313:                                                vector<unique_ptr<Expression>> &arguments) {
314: 
315: 	auto &bound_lambda_expr = (BoundLambdaExpression &)*arguments[1];
316: 	if (bound_lambda_expr.parameter_count != LAMBDA_PARAM_CNT) {
317: 		throw BinderException("Incorrect number of parameters in lambda function! " + bound_function.name +
318: 		                      " expects " + to_string(LAMBDA_PARAM_CNT) + " parameter(s).");
319: 	}
320: 
321: 	if (arguments[0]->return_type.id() == LogicalTypeId::SQLNULL) {
322: 		bound_function.arguments.pop_back();
323: 		bound_function.arguments[0] = LogicalType::SQLNULL;
324: 		bound_function.return_type = LogicalType::SQLNULL;
325: 		return make_unique<VariableReturnBindData>(bound_function.return_type);
326: 	}
327: 
328: 	if (arguments[0]->return_type.id() == LogicalTypeId::UNKNOWN) {
329: 		throw ParameterNotResolvedException();
330: 	}
331: 
332: 	D_ASSERT(arguments[0]->return_type.id() == LogicalTypeId::LIST);
333: 
334: 	// get the lambda expression and put it in the bind info
335: 	auto lambda_expr = move(bound_lambda_expr.lambda_expr);
336: 	return make_unique<ListLambdaBindData>(bound_function.return_type, move(lambda_expr));
337: }
338: 
339: static unique_ptr<FunctionData> ListTransformBind(ClientContext &context, ScalarFunction &bound_function,
340:                                                   vector<unique_ptr<Expression>> &arguments) {
341: 
342: 	// at least the list column and the lambda function
343: 	D_ASSERT(arguments.size() == 2);
344: 	if (arguments[1]->expression_class != ExpressionClass::BOUND_LAMBDA) {
345: 		throw BinderException("Invalid lambda expression!");
346: 	}
347: 
348: 	auto &bound_lambda_expr = (BoundLambdaExpression &)*arguments[1];
349: 	bound_function.return_type = LogicalType::LIST(bound_lambda_expr.lambda_expr->return_type);
350: 	return ListLambdaBind<1>(context, bound_function, arguments);
351: }
352: 
353: static unique_ptr<FunctionData> ListFilterBind(ClientContext &context, ScalarFunction &bound_function,
354:                                                vector<unique_ptr<Expression>> &arguments) {
355: 
356: 	// at least the list column and the lambda function
357: 	D_ASSERT(arguments.size() == 2);
358: 	if (arguments[1]->expression_class != ExpressionClass::BOUND_LAMBDA) {
359: 		throw BinderException("Invalid lambda expression!");
360: 	}
361: 	bound_function.return_type = arguments[0]->return_type;
362: 	return ListLambdaBind<1>(context, bound_function, arguments);
363: }
364: 
365: void ListTransformFun::RegisterFunction(BuiltinFunctions &set) {
366: 
367: 	ScalarFunction fun("list_transform", {LogicalType::LIST(LogicalType::ANY), LogicalType::LAMBDA},
368: 	                   LogicalType::LIST(LogicalType::ANY), ListTransformFunction, ListTransformBind, nullptr, nullptr);
369: 	fun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;
370: 	fun.serialize = ListLambdaBindData::Serialize;
371: 	fun.deserialize = ListLambdaBindData::Deserialize;
372: 	set.AddFunction(fun);
373: 
374: 	fun.name = "array_transform";
375: 	set.AddFunction(fun);
376: 	fun.name = "list_apply";
377: 	set.AddFunction(fun);
378: 	fun.name = "array_apply";
379: 	set.AddFunction(fun);
380: }
381: 
382: void ListFilterFun::RegisterFunction(BuiltinFunctions &set) {
383: 
384: 	ScalarFunction fun("list_filter", {LogicalType::LIST(LogicalType::ANY), LogicalType::LAMBDA},
385: 	                   LogicalType::LIST(LogicalType::ANY), ListFilterFunction, ListFilterBind, nullptr, nullptr);
386: 	fun.null_handling = FunctionNullHandling::SPECIAL_HANDLING;
387: 	fun.serialize = ListLambdaBindData::Serialize;
388: 	fun.deserialize = ListLambdaBindData::Deserialize;
389: 	set.AddFunction(fun);
390: 
391: 	fun.name = "array_filter";
392: 	set.AddFunction(fun);
393: }
394: 
395: } // namespace duckdb
[end of src/function/scalar/list/list_lambdas.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: