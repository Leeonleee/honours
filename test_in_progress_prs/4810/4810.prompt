You will be provided with a partial code base and an issue statement explaining a problem to resolve.

<issue>
[Julia API] Query returns AbstractString instead of String
### What happens?

Using the Julia API, queries including strings return as AbstractString but should probably be some concrete string type, such as String. 

### To Reproduce

```julia
using DuckDB, DBInterface
con = DBInterface.connect(DuckDB.DB, ":memory:")
DBInterface.execute(con, "CREATE TABLE test(a INT, b VARCHAR);")
DBInterface.execute(con, "INSERT INTO test VALUES (1, 'abc');")
df = DBInterface.execute(con, "SELECT * FROM test").df
typeof(df.b) # Vector{Union{Missing, AbstractString}}
```

### OS:

Windows 10

### DuckDB Version:

0.5.1

### DuckDB Client:

Julia

### Full Name:

Jakob Hoffmann

### Affiliation:

Heidelberg University

### Have you tried this on the latest `master` branch?

- [X] I agree

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] I agree

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=master" alt="Github Actions Badge">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The detail of benchmarks is in our [Benchmark Guide](benchmark/README.md).
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
44: 
45: 
[end of README.md]
[start of tools/juliapkg/src/ctypes.jl]
1: 
2: const duckdb_database = Ptr{Cvoid}
3: const duckdb_config = Ptr{Cvoid}
4: const duckdb_connection = Ptr{Cvoid}
5: const duckdb_prepared_statement = Ptr{Cvoid}
6: const duckdb_pending_result = Ptr{Cvoid}
7: const duckdb_logical_type = Ptr{Cvoid}
8: const duckdb_data_chunk = Ptr{Cvoid}
9: const duckdb_vector = Ptr{Cvoid}
10: const duckdb_appender = Ptr{Cvoid}
11: const duckdb_logical_type = Ptr{Cvoid}
12: const duckdb_value = Ptr{Cvoid}
13: const duckdb_table_function = Ptr{Cvoid}
14: const duckdb_bind_info = Ptr{Cvoid}
15: const duckdb_init_info = Ptr{Cvoid}
16: const duckdb_function_info = Ptr{Cvoid}
17: const duckdb_replacement_scan_info = Ptr{Cvoid}
18: const duckdb_task_state = Ptr{Cvoid}
19: 
20: const duckdb_state = Int32;
21: const DuckDBSuccess = 0;
22: const DuckDBError = 1;
23: 
24: const duckdb_pending_state = Int32;
25: const DUCKDB_PENDING_RESULT_READY = 0;
26: const DUCKDB_PENDING_RESULT_NOT_READY = 1;
27: const DUCKDB_PENDING_ERROR = 2;
28: 
29: 
30: @enum DUCKDB_TYPE_::UInt32 begin
31:     DUCKDB_TYPE_INVALID = 0
32:     DUCKDB_TYPE_BOOLEAN
33:     DUCKDB_TYPE_TINYINT
34:     DUCKDB_TYPE_SMALLINT
35:     DUCKDB_TYPE_INTEGER
36:     DUCKDB_TYPE_BIGINT
37:     DUCKDB_TYPE_UTINYINT
38:     DUCKDB_TYPE_USMALLINT
39:     DUCKDB_TYPE_UINTEGER
40:     DUCKDB_TYPE_UBIGINT
41:     DUCKDB_TYPE_FLOAT
42:     DUCKDB_TYPE_DOUBLE
43:     DUCKDB_TYPE_TIMESTAMP
44:     DUCKDB_TYPE_DATE
45:     DUCKDB_TYPE_TIME
46:     DUCKDB_TYPE_INTERVAL
47:     DUCKDB_TYPE_HUGEINT
48:     DUCKDB_TYPE_VARCHAR
49:     DUCKDB_TYPE_BLOB
50:     DUCKDB_TYPE_DECIMAL
51:     DUCKDB_TYPE_TIMESTAMP_S
52:     DUCKDB_TYPE_TIMESTAMP_MS
53:     DUCKDB_TYPE_TIMESTAMP_NS
54:     DUCKDB_TYPE_ENUM
55:     DUCKDB_TYPE_LIST
56:     DUCKDB_TYPE_STRUCT
57:     DUCKDB_TYPE_MAP
58:     DUCKDB_TYPE_UUID
59:     DUCKDB_TYPE_JSON
60: end
61: 
62: const DUCKDB_TYPE = DUCKDB_TYPE_
63: 
64: """
65: Days are stored as days since 1970-01-01\n
66: Use the duckdb_from_date/duckdb_to_date function to extract individual information
67: 
68: """
69: struct duckdb_date
70:     days::Int32
71: end
72: 
73: struct duckdb_date_struct
74:     year::Int32
75:     month::Int8
76:     day::Int8
77: end
78: 
79: """
80: Time is stored as microseconds since 00:00:00\n
81: Use the duckdb_from_time/duckdb_to_time function to extract individual information
82: 
83: """
84: struct duckdb_time
85:     micros::Int64
86: end
87: 
88: struct duckdb_time_struct
89:     hour::Int8
90:     min::Int8
91:     sec::Int8
92:     micros::Int32
93: end
94: 
95: """
96: Timestamps are stored as microseconds since 1970-01-01\n
97: Use the duckdb_from_timestamp/duckdb_to_timestamp function to extract individual information
98: 
99: """
100: struct duckdb_timestamp
101:     micros::Int64
102: end
103: 
104: struct duckdb_timestamp_struct
105:     date::Ref{duckdb_date_struct}
106:     time::Ref{duckdb_time_struct}
107: end
108: 
109: struct duckdb_interval
110:     months::Int32
111:     days::Int32
112:     micros::Int64
113: end
114: 
115: """
116: Hugeints are composed in a (lower, upper) component\n
117: The value of the hugeint is upper * 2^64 + lower\n
118: For easy usage, the functions duckdb_hugeint_to_double/duckdb_double_to_hugeint are recommended
119: 
120: """
121: struct duckdb_hugeint
122:     lower::UInt64
123:     upper::Int64
124: end
125: 
126: struct duckdb_string_t
127:     length::UInt32
128:     data::NTuple{12, UInt8}
129: end
130: 
131: struct duckdb_list_entry_t
132:     offset::UInt64
133:     length::UInt64
134: end
135: 
136: STRING_INLINE_LENGTH = 12
137: 
138: struct duckdb_column
139:     __deprecated_data::Ptr{Cvoid}
140:     __deprecated_nullmask::Ptr{UInt8}
141:     __deprecated_type::Ptr{DUCKDB_TYPE}
142:     __deprecated_name::Ptr{UInt8}
143:     internal_data::Ptr{Cvoid}
144: end
145: 
146: struct duckdb_result
147:     __deprecated_column_count::Ptr{UInt64}
148:     __deprecated_row_count::Ptr{UInt64}
149:     __deprecated_rows_changed::Ptr{UInt64}
150:     __deprecated_columns::Ptr{duckdb_column}
151:     __deprecated_error_message::Ptr{UInt8}
152:     internal_data::Ptr{Cvoid}
153: end
154: 
155: INTERNAL_TYPE_MAP = Dict(
156:     DUCKDB_TYPE_BOOLEAN => Bool,
157:     DUCKDB_TYPE_TINYINT => Int8,
158:     DUCKDB_TYPE_SMALLINT => Int16,
159:     DUCKDB_TYPE_INTEGER => Int32,
160:     DUCKDB_TYPE_BIGINT => Int64,
161:     DUCKDB_TYPE_UTINYINT => UInt8,
162:     DUCKDB_TYPE_USMALLINT => UInt16,
163:     DUCKDB_TYPE_UINTEGER => UInt32,
164:     DUCKDB_TYPE_UBIGINT => UInt64,
165:     DUCKDB_TYPE_FLOAT => Float32,
166:     DUCKDB_TYPE_DOUBLE => Float64,
167:     DUCKDB_TYPE_TIMESTAMP => Int64,
168:     DUCKDB_TYPE_TIMESTAMP_S => Int64,
169:     DUCKDB_TYPE_TIMESTAMP_MS => Int64,
170:     DUCKDB_TYPE_TIMESTAMP_NS => Int64,
171:     DUCKDB_TYPE_DATE => Int32,
172:     DUCKDB_TYPE_TIME => Int64,
173:     DUCKDB_TYPE_INTERVAL => duckdb_interval,
174:     DUCKDB_TYPE_HUGEINT => duckdb_hugeint,
175:     DUCKDB_TYPE_UUID => duckdb_hugeint,
176:     DUCKDB_TYPE_VARCHAR => duckdb_string_t,
177:     DUCKDB_TYPE_JSON => duckdb_string_t,
178:     DUCKDB_TYPE_BLOB => duckdb_string_t,
179:     DUCKDB_TYPE_UUID => duckdb_hugeint,
180:     DUCKDB_TYPE_LIST => duckdb_list_entry_t,
181:     DUCKDB_TYPE_STRUCT => Cvoid,
182:     DUCKDB_TYPE_MAP => Cvoid
183: )
184: 
185: JULIA_TYPE_MAP = Dict(
186:     DUCKDB_TYPE_INVALID => Missing,
187:     DUCKDB_TYPE_BOOLEAN => Bool,
188:     DUCKDB_TYPE_TINYINT => Int8,
189:     DUCKDB_TYPE_SMALLINT => Int16,
190:     DUCKDB_TYPE_INTEGER => Int32,
191:     DUCKDB_TYPE_BIGINT => Int64,
192:     DUCKDB_TYPE_HUGEINT => Int128,
193:     DUCKDB_TYPE_UTINYINT => UInt8,
194:     DUCKDB_TYPE_USMALLINT => UInt16,
195:     DUCKDB_TYPE_UINTEGER => UInt32,
196:     DUCKDB_TYPE_UBIGINT => UInt64,
197:     DUCKDB_TYPE_FLOAT => Float32,
198:     DUCKDB_TYPE_DOUBLE => Float64,
199:     DUCKDB_TYPE_DATE => Date,
200:     DUCKDB_TYPE_TIME => Time,
201:     DUCKDB_TYPE_TIMESTAMP => DateTime,
202:     DUCKDB_TYPE_TIMESTAMP_S => DateTime,
203:     DUCKDB_TYPE_TIMESTAMP_MS => DateTime,
204:     DUCKDB_TYPE_TIMESTAMP_NS => DateTime,
205:     DUCKDB_TYPE_INTERVAL => Dates.CompoundPeriod,
206:     DUCKDB_TYPE_UUID => UUID,
207:     DUCKDB_TYPE_VARCHAR => AbstractString,
208:     DUCKDB_TYPE_JSON => AbstractString,
209:     DUCKDB_TYPE_ENUM => AbstractString,
210:     DUCKDB_TYPE_BLOB => Base.CodeUnits{UInt8, String},
211:     DUCKDB_TYPE_MAP => Dict
212: )
213: 
214: # convert a DuckDB type into Julia equivalent
215: function duckdb_type_to_internal_type(x::DUCKDB_TYPE)
216:     if !haskey(INTERNAL_TYPE_MAP, x)
217:         throw(NotImplementedException(string("Unsupported type for duckdb_type_to_internal_type: ", x)))
218:     end
219:     return INTERNAL_TYPE_MAP[x]
220: end
221: 
222: function duckdb_type_to_julia_type(x)
223:     type_id = get_type_id(x)
224:     if type_id == DUCKDB_TYPE_DECIMAL
225:         internal_type_id = get_internal_type_id(x)
226:         scale = get_decimal_scale(x)
227:         if internal_type_id == DUCKDB_TYPE_SMALLINT
228:             return FixedDecimal{Int16, scale}
229:         elseif internal_type_id == DUCKDB_TYPE_INTEGER
230:             return FixedDecimal{Int32, scale}
231:         elseif internal_type_id == DUCKDB_TYPE_BIGINT
232:             return FixedDecimal{Int64, scale}
233:         elseif internal_type_id == DUCKDB_TYPE_HUGEINT
234:             return FixedDecimal{Int128, scale}
235:         else
236:             throw(NotImplementedException("Unimplemented internal type for decimal"))
237:         end
238:     elseif type_id == DUCKDB_TYPE_LIST
239:         return Vector{Union{Missing, duckdb_type_to_julia_type(get_list_child_type(x))}}
240:     elseif type_id == DUCKDB_TYPE_STRUCT
241:         child_count = get_struct_child_count(x)
242:         names::Vector{Symbol} = Vector()
243:         for i in 1:child_count
244:             child_name::Symbol = Symbol(get_struct_child_name(x, i))
245:             push!(names, child_name)
246:         end
247:         names_tuple = Tuple(x for x in names)
248:         return Union{Missing, NamedTuple{names_tuple}}
249:     end
250:     if !haskey(JULIA_TYPE_MAP, type_id)
251:         throw(NotImplementedException(string("Unsupported type for duckdb_type_to_julia_type: ", type_id)))
252:     end
253:     return JULIA_TYPE_MAP[type_id]
254: end
255: 
256: const ROUNDING_EPOCH_TO_UNIX_EPOCH_DAYS = 719528
257: const ROUNDING_EPOCH_TO_UNIX_EPOCH_MS = 62167219200000
258: 
259: sym(ptr) = ccall(:jl_symbol, Ref{Symbol}, (Ptr{UInt8},), ptr)
[end of tools/juliapkg/src/ctypes.jl]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: