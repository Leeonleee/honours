diff --git a/data/csv/empty_first_line.csv b/data/csv/empty_first_line.csv
new file mode 100644
index 000000000000..6cae03341e67
--- /dev/null
+++ b/data/csv/empty_first_line.csv
@@ -0,0 +1,4 @@
+
+a 1
+b 2
+c 3
diff --git a/src/execution/operator/persistent/buffered_csv_reader.cpp b/src/execution/operator/persistent/buffered_csv_reader.cpp
index 35e20494d7c0..359011d4c316 100644
--- a/src/execution/operator/persistent/buffered_csv_reader.cpp
+++ b/src/execution/operator/persistent/buffered_csv_reader.cpp
@@ -1937,6 +1937,9 @@ bool BufferedCSVReader::AddRow(DataChunk &insert_chunk, idx_t &column) {
 	if (row_empty) {
 		row_empty = false;
 		if (sql_types.size() != 1) {
+			if (mode == ParserMode::PARSING) {
+				FlatVector::SetNull(parse_chunk.data[0], parse_chunk.size(), false);
+			}
 			column = 0;
 			return false;
 		}
diff --git a/src/include/duckdb/main/prepared_statement_data.hpp b/src/include/duckdb/main/prepared_statement_data.hpp
index a1940c54e33f..7f34c1dd9485 100644
--- a/src/include/duckdb/main/prepared_statement_data.hpp
+++ b/src/include/duckdb/main/prepared_statement_data.hpp
@@ -54,6 +54,8 @@ class PreparedStatementData {
 	DUCKDB_API void Bind(vector<Value> values);
 	//! Get the expected SQL Type of the bound parameter
 	DUCKDB_API LogicalType GetType(idx_t param_index);
+	//! Try to get the expected SQL Type of the bound parameter
+	DUCKDB_API bool TryGetType(idx_t param_idx, LogicalType &result);
 };
 
 } // namespace duckdb
diff --git a/src/main/capi/prepared-c.cpp b/src/main/capi/prepared-c.cpp
index 010e0459920d..bc9ff0e6e2b8 100644
--- a/src/main/capi/prepared-c.cpp
+++ b/src/main/capi/prepared-c.cpp
@@ -6,6 +6,7 @@ using duckdb::Connection;
 using duckdb::date_t;
 using duckdb::dtime_t;
 using duckdb::hugeint_t;
+using duckdb::LogicalType;
 using duckdb::MaterializedQueryResult;
 using duckdb::PreparedStatementWrapper;
 using duckdb::QueryResultType;
@@ -45,11 +46,11 @@ duckdb_type duckdb_param_type(duckdb_prepared_statement prepared_statement, idx_
 	if (!wrapper || !wrapper->statement || wrapper->statement->HasError()) {
 		return DUCKDB_TYPE_INVALID;
 	}
-	auto entry = wrapper->statement->data->value_map.find(param_idx);
-	if (entry == wrapper->statement->data->value_map.end()) {
+	LogicalType param_type;
+	if (!wrapper->statement->data->TryGetType(param_idx, param_type)) {
 		return DUCKDB_TYPE_INVALID;
 	}
-	return ConvertCPPTypeToC(entry->second->return_type);
+	return ConvertCPPTypeToC(param_type);
 }
 
 duckdb_state duckdb_clear_bindings(duckdb_prepared_statement prepared_statement) {
diff --git a/src/main/prepared_statement_data.cpp b/src/main/prepared_statement_data.cpp
index d7fa06ab916a..4a351978208d 100644
--- a/src/main/prepared_statement_data.cpp
+++ b/src/main/prepared_statement_data.cpp
@@ -63,12 +63,25 @@ void PreparedStatementData::Bind(vector<Value> values) {
 	}
 }
 
-LogicalType PreparedStatementData::GetType(idx_t param_idx) {
+bool PreparedStatementData::TryGetType(idx_t param_idx, LogicalType &result) {
 	auto it = value_map.find(param_idx);
 	if (it == value_map.end()) {
+		return false;
+	}
+	if (it->second->return_type.id() != LogicalTypeId::INVALID) {
+		result = it->second->return_type;
+	} else {
+		result = it->second->value.type();
+	}
+	return true;
+}
+
+LogicalType PreparedStatementData::GetType(idx_t param_idx) {
+	LogicalType result;
+	if (!TryGetType(param_idx, result)) {
 		throw BinderException("Could not find parameter with index %llu", param_idx);
 	}
-	return it->second->return_type;
+	return result;
 }
 
 } // namespace duckdb
