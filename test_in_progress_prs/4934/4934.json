{
  "repo": "duckdb/duckdb",
  "pull_number": 4934,
  "instance_id": "duckdb__duckdb-4934",
  "issue_numbers": [
    "4917",
    "4933"
  ],
  "base_commit": "fcd036218b112caab3d38d1a67a7a24c97946d63",
  "patch": "diff --git a/data/csv/empty_first_line.csv b/data/csv/empty_first_line.csv\nnew file mode 100644\nindex 000000000000..6cae03341e67\n--- /dev/null\n+++ b/data/csv/empty_first_line.csv\n@@ -0,0 +1,4 @@\n+\n+a 1\n+b 2\n+c 3\ndiff --git a/src/execution/operator/persistent/buffered_csv_reader.cpp b/src/execution/operator/persistent/buffered_csv_reader.cpp\nindex 35e20494d7c0..359011d4c316 100644\n--- a/src/execution/operator/persistent/buffered_csv_reader.cpp\n+++ b/src/execution/operator/persistent/buffered_csv_reader.cpp\n@@ -1937,6 +1937,9 @@ bool BufferedCSVReader::AddRow(DataChunk &insert_chunk, idx_t &column) {\n \tif (row_empty) {\n \t\trow_empty = false;\n \t\tif (sql_types.size() != 1) {\n+\t\t\tif (mode == ParserMode::PARSING) {\n+\t\t\t\tFlatVector::SetNull(parse_chunk.data[0], parse_chunk.size(), false);\n+\t\t\t}\n \t\t\tcolumn = 0;\n \t\t\treturn false;\n \t\t}\ndiff --git a/src/include/duckdb/main/prepared_statement_data.hpp b/src/include/duckdb/main/prepared_statement_data.hpp\nindex a1940c54e33f..7f34c1dd9485 100644\n--- a/src/include/duckdb/main/prepared_statement_data.hpp\n+++ b/src/include/duckdb/main/prepared_statement_data.hpp\n@@ -54,6 +54,8 @@ class PreparedStatementData {\n \tDUCKDB_API void Bind(vector<Value> values);\n \t//! Get the expected SQL Type of the bound parameter\n \tDUCKDB_API LogicalType GetType(idx_t param_index);\n+\t//! Try to get the expected SQL Type of the bound parameter\n+\tDUCKDB_API bool TryGetType(idx_t param_idx, LogicalType &result);\n };\n \n } // namespace duckdb\ndiff --git a/src/main/capi/prepared-c.cpp b/src/main/capi/prepared-c.cpp\nindex 010e0459920d..bc9ff0e6e2b8 100644\n--- a/src/main/capi/prepared-c.cpp\n+++ b/src/main/capi/prepared-c.cpp\n@@ -6,6 +6,7 @@ using duckdb::Connection;\n using duckdb::date_t;\n using duckdb::dtime_t;\n using duckdb::hugeint_t;\n+using duckdb::LogicalType;\n using duckdb::MaterializedQueryResult;\n using duckdb::PreparedStatementWrapper;\n using duckdb::QueryResultType;\n@@ -45,11 +46,11 @@ duckdb_type duckdb_param_type(duckdb_prepared_statement prepared_statement, idx_\n \tif (!wrapper || !wrapper->statement || wrapper->statement->HasError()) {\n \t\treturn DUCKDB_TYPE_INVALID;\n \t}\n-\tauto entry = wrapper->statement->data->value_map.find(param_idx);\n-\tif (entry == wrapper->statement->data->value_map.end()) {\n+\tLogicalType param_type;\n+\tif (!wrapper->statement->data->TryGetType(param_idx, param_type)) {\n \t\treturn DUCKDB_TYPE_INVALID;\n \t}\n-\treturn ConvertCPPTypeToC(entry->second->return_type);\n+\treturn ConvertCPPTypeToC(param_type);\n }\n \n duckdb_state duckdb_clear_bindings(duckdb_prepared_statement prepared_statement) {\ndiff --git a/src/main/prepared_statement_data.cpp b/src/main/prepared_statement_data.cpp\nindex d7fa06ab916a..4a351978208d 100644\n--- a/src/main/prepared_statement_data.cpp\n+++ b/src/main/prepared_statement_data.cpp\n@@ -63,12 +63,25 @@ void PreparedStatementData::Bind(vector<Value> values) {\n \t}\n }\n \n-LogicalType PreparedStatementData::GetType(idx_t param_idx) {\n+bool PreparedStatementData::TryGetType(idx_t param_idx, LogicalType &result) {\n \tauto it = value_map.find(param_idx);\n \tif (it == value_map.end()) {\n+\t\treturn false;\n+\t}\n+\tif (it->second->return_type.id() != LogicalTypeId::INVALID) {\n+\t\tresult = it->second->return_type;\n+\t} else {\n+\t\tresult = it->second->value.type();\n+\t}\n+\treturn true;\n+}\n+\n+LogicalType PreparedStatementData::GetType(idx_t param_idx) {\n+\tLogicalType result;\n+\tif (!TryGetType(param_idx, result)) {\n \t\tthrow BinderException(\"Could not find parameter with index %llu\", param_idx);\n \t}\n-\treturn it->second->return_type;\n+\treturn result;\n }\n \n } // namespace duckdb\n",
  "test_patch": "diff --git a/test/api/capi/test_capi_prepared.cpp b/test/api/capi/test_capi_prepared.cpp\nindex db2484d6e9c6..0ba93cb41db0 100644\n--- a/test/api/capi/test_capi_prepared.cpp\n+++ b/test/api/capi/test_capi_prepared.cpp\n@@ -253,4 +253,13 @@ TEST_CASE(\"Test prepared statements in C API\", \"[capi]\") {\n \tmemcpy(malloced_data, \"hello\\0\", 6);\n \tREQUIRE(string((char *)malloced_data) == \"hello\");\n \tduckdb_free(malloced_data);\n+\n+\tstatus = duckdb_prepare(tester.connection, \"SELECT sum(i) FROM a WHERE i > ?\", &stmt);\n+\tREQUIRE(status == DuckDBSuccess);\n+\tREQUIRE(stmt != nullptr);\n+\tREQUIRE(duckdb_nparams(stmt) == 1);\n+\tREQUIRE(duckdb_param_type(nullptr, 0) == DUCKDB_TYPE_INVALID);\n+\tREQUIRE(duckdb_param_type(stmt, 1) == DUCKDB_TYPE_INTEGER);\n+\n+\tduckdb_destroy_prepare(&stmt);\n }\ndiff --git a/test/sql/copy/csv/empty_first_line.test b/test/sql/copy/csv/empty_first_line.test\nnew file mode 100644\nindex 000000000000..002706f84114\n--- /dev/null\n+++ b/test/sql/copy/csv/empty_first_line.test\n@@ -0,0 +1,20 @@\n+# name: test/sql/copy/csv/empty_first_line.test\n+# description: Issue #4933: Reading a CSV file with an empty header is problematic\n+# group: [csv]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+query II\n+SELECT * FROM read_csv_auto('data/csv/empty_first_line.csv', delim=' ');\n+----\n+a\t1\n+b\t2\n+c\t3\n+\n+query I\n+SELECT * FROM read_csv_auto('data/csv/empty_first_line.csv', delim='|');\n+----\n+a 1\n+b 2\n+c 3\n",
  "problem_statement": "duckdb_param_type returns 0\n### What happens?\n\nApologies as this may not have to do with duckdb C api and may be a result of the autogenerated Nim wrapper, but I wanted to mention it here. duckdb_prepare, and duckdb_nparams, bind and execute all seem to work as expected.  I'm using Nim 1.6.8\r\n\r\nI have a query like `SELECT sum(i) FROM integers WHERE i > ?` \r\n\r\nI expect duckdb_param_type(pStmt, 1) to return DUCKDB_TYPE_INTEGER.  Instead I get 0 or DUCKDB_TYPE_INVALID. \r\n\r\n``` nim\r\nproc getValue*(db: var DbConn, query: SqlQuery, args: varargs[string,\r\n    `$`]): string {.tags: [ReadDbEffect].} =\r\n  var\r\n    con: duckdb_connection\r\n    res: duckdb_result\r\n    pStmt: duckdb_prepared_statement\r\n  if (duckdb_connect(db, addr(con)) == DuckDBError):\r\n    raise newException(DbError, \"error occured when connecting to database\")\r\n\r\n  if (duckdb_prepare(con, cstring(query), addr(\r\n      pStmt)) == DuckDBError):\r\n    var msg = duckdb_prepare_error(pStmt)\r\n    duckdb_disconnect(addr(con))\r\n    raise newException(DbError, \"error occured when preparing statement: \" & $msg)\r\n\r\n  echo duckdb_param_type(pStmt, 1.idx_t)\r\n...\r\n\r\n```\r\nAny thoughts or suggestions are appreciated.\n\n### To Reproduce\n\nIn theory if you create nim file with this code, and make sure the dll and header file are found it should compile or be run with `nim r file.nim`\r\n\r\nThe first bit is generated by nimterop and does lots of things I don't fully grok.  \r\n\r\n```nim\r\n{.push hint[ConvFromXtoItselfNotNeeded]: off.}\r\nimport macros\r\n\r\nmacro defineEnum(typ: untyped): untyped =\r\n  result = newNimNode(nnkStmtList)\r\n\r\n  # Enum mapped to distinct cint\r\n  result.add quote do:\r\n    type `typ`* = distinct cint\r\n\r\n  for i in [\"+\", \"-\", \"*\", \"div\", \"mod\", \"shl\", \"shr\", \"or\", \"and\", \"xor\", \"<\",\r\n      \"<=\", \"==\", \">\", \">=\"]:\r\n    let\r\n      ni = newIdentNode(i)\r\n      typout = if i[0] in \"<=>\": newIdentNode(\"bool\") else: typ # comparisons return bool\r\n    if i[0] == '>': # cannot borrow `>` and `>=` from templates\r\n      let\r\n        nopp = if i.len == 2: newIdentNode(\"<=\") else: newIdentNode(\"<\")\r\n      result.add quote do:\r\n        proc `ni`*(x: `typ`, y: cint): `typout` = `nopp`(y, x)\r\n        proc `ni`*(x: cint, y: `typ`): `typout` = `nopp`(y, x)\r\n        proc `ni`*(x, y: `typ`): `typout` = `nopp`(y, x)\r\n    else:\r\n      result.add quote do:\r\n        proc `ni`*(x: `typ`, y: cint): `typout` {.borrow.}\r\n        proc `ni`*(x: cint, y: `typ`): `typout` {.borrow.}\r\n        proc `ni`*(x, y: `typ`): `typout` {.borrow.}\r\n    result.add quote do:\r\n      proc `ni`*(x: `typ`, y: int): `typout` = `ni`(x, y.cint)\r\n      proc `ni`*(x: int, y: `typ`): `typout` = `ni`(x.cint, y)\r\n\r\n  let\r\n    divop = newIdentNode(\"/\")   # `/`()\r\n    dlrop = newIdentNode(\"$\")   # `$`()\r\n    notop = newIdentNode(\"not\") # `not`()\r\n  result.add quote do:\r\n    proc `divop`*(x, y: `typ`): `typ` = `typ`((x.float / y.float).cint)\r\n    proc `divop`*(x: `typ`, y: cint): `typ` = `divop`(x, `typ`(y))\r\n    proc `divop`*(x: cint, y: `typ`): `typ` = `divop`(`typ`(x), y)\r\n    proc `divop`*(x: `typ`, y: int): `typ` = `divop`(x, y.cint)\r\n    proc `divop`*(x: int, y: `typ`): `typ` = `divop`(x.cint, y)\r\n\r\n    proc `dlrop`*(x: `typ`): string {.borrow.}\r\n    proc `notop`*(x: `typ`): `typ` {.borrow.}\r\n\r\n\r\n{.pragma: impduckdbHdr,\r\n  header: \"duckdb.h\".}\r\n{.pragma: impduckdbDyn, dynlib: \"duckdb.dll\".}\r\n{.experimental: \"codeReordering\".}\r\ndefineEnum(DUCKDB_TYPE)\r\ndefineEnum(duckdb_state)\r\ndefineEnum(duckdb_pending_state)\r\nconst\r\n  DUCKDB_API_0_3_1* = 1\r\n  DUCKDB_API_0_3_2* = 2\r\n  DUCKDB_TYPE_INVALID* = (0).DUCKDB_TYPE\r\n  DUCKDB_TYPE_BOOLEAN* = (DUCKDB_TYPE_INVALID + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_TINYINT* = (DUCKDB_TYPE_BOOLEAN + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_SMALLINT* = (DUCKDB_TYPE_TINYINT + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_INTEGER* = (DUCKDB_TYPE_SMALLINT + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_BIGINT* = (DUCKDB_TYPE_INTEGER + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_UTINYINT* = (DUCKDB_TYPE_BIGINT + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_USMALLINT* = (DUCKDB_TYPE_UTINYINT + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_UINTEGER* = (DUCKDB_TYPE_USMALLINT + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_UBIGINT* = (DUCKDB_TYPE_UINTEGER + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_FLOAT* = (DUCKDB_TYPE_UBIGINT + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_DOUBLE* = (DUCKDB_TYPE_FLOAT + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_TIMESTAMP* = (DUCKDB_TYPE_DOUBLE + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_DATE* = (DUCKDB_TYPE_TIMESTAMP + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_TIME* = (DUCKDB_TYPE_DATE + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_INTERVAL* = (DUCKDB_TYPE_TIME + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_HUGEINT* = (DUCKDB_TYPE_INTERVAL + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_VARCHAR* = (DUCKDB_TYPE_HUGEINT + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_BLOB* = (DUCKDB_TYPE_VARCHAR + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_DECIMAL* = (DUCKDB_TYPE_BLOB + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_TIMESTAMP_S* = (DUCKDB_TYPE_DECIMAL + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_TIMESTAMP_MS* = (DUCKDB_TYPE_TIMESTAMP_S + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_TIMESTAMP_NS* = (DUCKDB_TYPE_TIMESTAMP_MS + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_ENUM* = (DUCKDB_TYPE_TIMESTAMP_NS + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_LIST* = (DUCKDB_TYPE_ENUM + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_STRUCT* = (DUCKDB_TYPE_LIST + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_MAP* = (DUCKDB_TYPE_STRUCT + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_UUID* = (DUCKDB_TYPE_MAP + 1).DUCKDB_TYPE\r\n  DUCKDB_TYPE_JSON* = (DUCKDB_TYPE_UUID + 1).DUCKDB_TYPE\r\n  DuckDBSuccess* = (0).duckdb_state\r\n  DuckDBError* = (1).duckdb_state\r\n  DUCKDB_PENDING_RESULT_READY* = (0).duckdb_pending_state\r\n  DUCKDB_PENDING_RESULT_NOT_READY* = (1).duckdb_pending_state\r\n  DUCKDB_PENDING_ERROR* = (2).duckdb_pending_state\r\ntype\r\n  idx_t* {.importc, impduckdbHdr.} = uint64\r\n  duckdb_type* {.importc, impduckdbHdr.} = DUCKDB_TYPE\r\n  duckdb_date* {.bycopy, importc, impduckdbHdr.} = object\r\n    days*: int32\r\n\r\n  duckdb_date_struct* {.bycopy, importc, impduckdbHdr.} = object\r\n    year*: int32\r\n    month*: int8\r\n    day*: int8\r\n\r\n  duckdb_time* {.bycopy, importc, impduckdbHdr.} = object\r\n    micros*: int64\r\n\r\n  duckdb_time_struct* {.bycopy, importc, impduckdbHdr.} = object\r\n    hour*: int8\r\n    min*: int8\r\n    sec*: int8\r\n    micros*: int32\r\n\r\n  duckdb_timestamp* {.bycopy, importc, impduckdbHdr.} = object\r\n    micros*: int64\r\n\r\n  duckdb_timestamp_struct* {.bycopy, importc, impduckdbHdr.} = object\r\n    date*: duckdb_date_struct\r\n    time*: duckdb_time_struct\r\n\r\n  duckdb_interval* {.bycopy, importc, impduckdbHdr.} = object\r\n    months*: int32\r\n    days*: int32\r\n    micros*: int64\r\n\r\n  duckdb_hugeint* {.bycopy, importc, impduckdbHdr.} = object\r\n    lower*: uint64\r\n    upper*: int64\r\n\r\n  duckdb_decimal* {.bycopy, importc, impduckdbHdr.} = object\r\n    width*: uint8\r\n    scale*: uint8\r\n    value*: duckdb_hugeint\r\n\r\n  duckdb_blob* {.bycopy, importc, impduckdbHdr.} = object\r\n    data*: pointer\r\n    size*: idx_t\r\n\r\n  duckdb_column* {.bycopy, importc, impduckdbHdr.} = object\r\n    deprecated_data*: pointer\r\n    deprecated_nullmask*: ptr bool\r\n    deprecated_type*: duckdb_type\r\n    deprecated_name*: cstring\r\n    internal_data*: pointer\r\n\r\n  duckdb_result* {.bycopy, importc, impduckdbHdr.} = object\r\n    deprecated_column_count*: idx_t\r\n    deprecated_row_count*: idx_t\r\n    deprecated_rows_changed*: idx_t\r\n    deprecated_columns*: ptr duckdb_column\r\n    deprecated_error_message*: cstring\r\n    internal_data*: pointer\r\n\r\n  duckdb_database* {.importc, impduckdbHdr.} = pointer\r\n  duckdb_connection* {.importc, impduckdbHdr.} = pointer\r\n  duckdb_prepared_statement* {.importc, impduckdbHdr.} = pointer\r\n  duckdb_pending_result* {.importc, impduckdbHdr.} = pointer\r\n  duckdb_appender* {.importc, impduckdbHdr.} = pointer\r\n  duckdb_arrow* {.importc, impduckdbHdr.} = pointer\r\n  duckdb_config* {.importc, impduckdbHdr.} = pointer\r\n  duckdb_arrow_schema* {.importc, impduckdbHdr.} = pointer\r\n  duckdb_arrow_array* {.importc, impduckdbHdr.} = pointer\r\n  duckdb_logical_type* {.importc, impduckdbHdr.} = pointer\r\n  duckdb_data_chunk* {.importc, impduckdbHdr.} = pointer\r\n  duckdb_vector* {.importc, impduckdbHdr.} = pointer\r\n  duckdb_value* {.importc, impduckdbHdr.} = pointer\r\n  duckdb_table_function* {.importc, impduckdbHdr.} = pointer\r\n  duckdb_bind_info* {.importc, impduckdbHdr.} = pointer\r\n  duckdb_init_info* {.importc, impduckdbHdr.} = pointer\r\n  duckdb_function_info* {.importc, impduckdbHdr.} = pointer\r\n  duckdb_table_function_bind_t* {.importc, impduckdbHdr.} = proc (\r\n      info: duckdb_bind_info) {.cdecl.}\r\n  duckdb_table_function_init_t* {.importc, impduckdbHdr.} = proc (\r\n      info: duckdb_init_info) {.cdecl.}\r\n  duckdb_table_function_t* {.importc, impduckdbHdr.} = proc (\r\n      info: duckdb_function_info; output: duckdb_data_chunk) {.cdecl.}\r\n  duckdb_delete_callback_t* {.importc, impduckdbHdr.} = proc (data: pointer) {.\r\n      cdecl.}\r\n  duckdb_replacement_scan_info* {.importc, impduckdbHdr.} = pointer\r\n  duckdb_replacement_callback_t* {.importc, impduckdbHdr.} = proc (\r\n      info: duckdb_replacement_scan_info; table_name: cstring; data: pointer) {.\r\n      cdecl.}\r\n  duckdb_task_state* {.importc, impduckdbHdr.} = pointer\r\nproc duckdb_open*(path: cstring; out_database: ptr duckdb_database): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_open_ext*(path: cstring; out_database: ptr duckdb_database;\r\n                      config: duckdb_config;\r\n                          out_error: ptr cstring): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_close*(database: ptr duckdb_database) {.importc, cdecl, impduckdbDyn.}\r\nproc duckdb_connect*(database: duckdb_database;\r\n                     out_connection: ptr duckdb_connection): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_disconnect*(connection: ptr duckdb_connection) {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_create_config*(out_config: ptr duckdb_config): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_config_count*(): uint {.importc, cdecl, impduckdbDyn.}\r\nproc duckdb_get_config_flag*(index: uint; out_name: ptr cstring;\r\n                             out_description: ptr cstring): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_set_config*(config: duckdb_config; name: cstring;\r\n    option: cstring): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_destroy_config*(config: ptr duckdb_config) {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_query*(connection: duckdb_connection; query: cstring;\r\n                   out_result: ptr duckdb_result): duckdb_state {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_destroy_result*(result: ptr duckdb_result) {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_column_name*(result: ptr duckdb_result; col: idx_t): cstring {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_column_type*(result: ptr duckdb_result; col: idx_t): duckdb_type {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_column_logical_type*(result: ptr duckdb_result;\r\n    col: idx_t): duckdb_logical_type {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_column_count*(result: ptr duckdb_result): idx_t {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_row_count*(result: ptr duckdb_result): idx_t {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_rows_changed*(result: ptr duckdb_result): idx_t {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_column_data*(result: ptr duckdb_result; col: idx_t): pointer {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_nullmask_data*(result: ptr duckdb_result; col: idx_t): ptr bool {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_result_error*(result: ptr duckdb_result): cstring {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_result_get_chunk*(result: duckdb_result;\r\n    chunk_index: idx_t): duckdb_data_chunk {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_result_chunk_count*(result: duckdb_result): idx_t {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_value_boolean*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): bool {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_value_int8*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): int8 {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_value_int16*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): int16 {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_value_int32*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): int32 {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_value_int64*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): int64 {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_value_hugeint*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): duckdb_hugeint {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_value_decimal*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): duckdb_decimal {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_value_uint8*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): uint8 {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_value_uint16*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): uint16 {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_value_uint32*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): uint32 {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_value_uint64*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): uint64 {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_value_float*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): cfloat {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_value_double*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): cdouble {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_value_date*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): duckdb_date {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_value_time*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): duckdb_time {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_value_timestamp*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): duckdb_timestamp {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_value_interval*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): duckdb_interval {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_value_varchar*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): cstring {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_value_varchar_internal*(result: ptr duckdb_result; col: idx_t;\r\n                                    row: idx_t): cstring {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_value_blob*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): duckdb_blob {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_value_is_null*(result: ptr duckdb_result; col: idx_t;\r\n    row: idx_t): bool {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_malloc*(size: uint): pointer {.importc, cdecl, impduckdbDyn.}\r\nproc duckdb_free*(`ptr`: pointer) {.importc, cdecl, impduckdbDyn.}\r\nproc duckdb_vector_size*(): idx_t {.importc, cdecl, impduckdbDyn.}\r\nproc duckdb_from_date*(date: duckdb_date): duckdb_date_struct {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_to_date*(date: duckdb_date_struct): duckdb_date {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_from_time*(time: duckdb_time): duckdb_time_struct {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_to_time*(time: duckdb_time_struct): duckdb_time {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_from_timestamp*(ts: duckdb_timestamp): duckdb_timestamp_struct {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_to_timestamp*(ts: duckdb_timestamp_struct): duckdb_timestamp {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_hugeint_to_double*(val: duckdb_hugeint): cdouble {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_double_to_hugeint*(val: cdouble): duckdb_hugeint {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_decimal_to_double*(val: duckdb_decimal): cdouble {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_prepare*(connection: duckdb_connection; query: cstring;\r\n                     out_prepared_statement: ptr duckdb_prepared_statement): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_destroy_prepare*(prepared_statement: ptr duckdb_prepared_statement) {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_prepare_error*(prepared_statement: duckdb_prepared_statement): cstring {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_nparams*(prepared_statement: duckdb_prepared_statement): idx_t {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_param_type*(prepared_statement: duckdb_prepared_statement;\r\n                        param_idx: idx_t): duckdb_type {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_clear_bindings*(prepared_statement: duckdb_prepared_statement): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_bind_boolean*(prepared_statement: duckdb_prepared_statement;\r\n                          param_idx: idx_t; val: bool): duckdb_state {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_bind_int8*(prepared_statement: duckdb_prepared_statement;\r\n                       param_idx: idx_t; val: int8): duckdb_state {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_bind_int16*(prepared_statement: duckdb_prepared_statement;\r\n                        param_idx: idx_t; val: int16): duckdb_state {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_bind_int32*(prepared_statement: duckdb_prepared_statement;\r\n                        param_idx: idx_t; val: int32): duckdb_state {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_bind_int64*(prepared_statement: duckdb_prepared_statement;\r\n                        param_idx: idx_t; val: int64): duckdb_state {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_bind_hugeint*(prepared_statement: duckdb_prepared_statement;\r\n                          param_idx: idx_t;\r\n                              val: duckdb_hugeint): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_bind_uint8*(prepared_statement: duckdb_prepared_statement;\r\n                        param_idx: idx_t; val: uint8): duckdb_state {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_bind_uint16*(prepared_statement: duckdb_prepared_statement;\r\n                         param_idx: idx_t; val: uint16): duckdb_state {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_bind_uint32*(prepared_statement: duckdb_prepared_statement;\r\n                         param_idx: idx_t; val: uint32): duckdb_state {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_bind_uint64*(prepared_statement: duckdb_prepared_statement;\r\n                         param_idx: idx_t; val: uint64): duckdb_state {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_bind_float*(prepared_statement: duckdb_prepared_statement;\r\n                        param_idx: idx_t; val: cfloat): duckdb_state {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_bind_double*(prepared_statement: duckdb_prepared_statement;\r\n                         param_idx: idx_t; val: cdouble): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_bind_date*(prepared_statement: duckdb_prepared_statement;\r\n                       param_idx: idx_t; val: duckdb_date): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_bind_time*(prepared_statement: duckdb_prepared_statement;\r\n                       param_idx: idx_t; val: duckdb_time): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_bind_timestamp*(prepared_statement: duckdb_prepared_statement;\r\n                            param_idx: idx_t;\r\n                                val: duckdb_timestamp): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_bind_interval*(prepared_statement: duckdb_prepared_statement;\r\n                           param_idx: idx_t;\r\n                               val: duckdb_interval): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_bind_varchar*(prepared_statement: duckdb_prepared_statement;\r\n                          param_idx: idx_t; val: cstring): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_bind_varchar_length*(prepared_statement: duckdb_prepared_statement;\r\n                                 param_idx: idx_t; val: cstring;\r\n                                     length: idx_t): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_bind_blob*(prepared_statement: duckdb_prepared_statement;\r\n                       param_idx: idx_t; data: pointer;\r\n                           length: idx_t): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_bind_null*(prepared_statement: duckdb_prepared_statement;\r\n                       param_idx: idx_t): duckdb_state {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_execute_prepared*(prepared_statement: duckdb_prepared_statement;\r\n                              out_result: ptr duckdb_result): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_execute_prepared_arrow*(prepared_statement: duckdb_prepared_statement;\r\n                                    out_result: ptr duckdb_arrow): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_pending_prepared*(prepared_statement: duckdb_prepared_statement;\r\n                              out_result: ptr duckdb_pending_result): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_destroy_pending*(pending_result: ptr duckdb_pending_result) {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_pending_error*(pending_result: duckdb_pending_result): cstring {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_pending_execute_task*(pending_result: duckdb_pending_result): duckdb_pending_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_execute_pending*(pending_result: duckdb_pending_result;\r\n                             out_result: ptr duckdb_result): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_destroy_value*(value: ptr duckdb_value) {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_create_varchar*(text: cstring): duckdb_value {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_create_varchar_length*(text: cstring;\r\n    length: idx_t): duckdb_value {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_create_int64*(val: int64): duckdb_value {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_get_varchar*(value: duckdb_value): cstring {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_get_int64*(value: duckdb_value): int64 {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_create_logical_type*(`type`: duckdb_type): duckdb_logical_type {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_create_list_type*(`type`: duckdb_logical_type): duckdb_logical_type {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_create_map_type*(key_type: duckdb_logical_type;\r\n                             value_type: duckdb_logical_type): duckdb_logical_type {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_create_decimal_type*(width: uint8;\r\n    scale: uint8): duckdb_logical_type {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_get_type_id*(`type`: duckdb_logical_type): duckdb_type {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_decimal_width*(`type`: duckdb_logical_type): uint8 {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_decimal_scale*(`type`: duckdb_logical_type): uint8 {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_decimal_internal_type*(`type`: duckdb_logical_type): duckdb_type {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_enum_internal_type*(`type`: duckdb_logical_type): duckdb_type {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_enum_dictionary_size*(`type`: duckdb_logical_type): uint32 {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_enum_dictionary_value*(`type`: duckdb_logical_type;\r\n    index: idx_t): cstring {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_list_type_child_type*(`type`: duckdb_logical_type): duckdb_logical_type {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_map_type_key_type*(`type`: duckdb_logical_type): duckdb_logical_type {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_map_type_value_type*(`type`: duckdb_logical_type): duckdb_logical_type {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_struct_type_child_count*(`type`: duckdb_logical_type): idx_t {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_struct_type_child_name*(`type`: duckdb_logical_type;\r\n    index: idx_t): cstring {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_struct_type_child_type*(`type`: duckdb_logical_type;\r\n    index: idx_t): duckdb_logical_type {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_destroy_logical_type*(`type`: ptr duckdb_logical_type) {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_create_data_chunk*(types: ptr duckdb_logical_type;\r\n                               column_count: idx_t): duckdb_data_chunk {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_destroy_data_chunk*(chunk: ptr duckdb_data_chunk) {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_data_chunk_reset*(chunk: duckdb_data_chunk) {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_data_chunk_get_column_count*(chunk: duckdb_data_chunk): idx_t {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_data_chunk_get_vector*(chunk: duckdb_data_chunk;\r\n    col_idx: idx_t): duckdb_vector {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_data_chunk_get_size*(chunk: duckdb_data_chunk): idx_t {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_data_chunk_set_size*(chunk: duckdb_data_chunk; size: idx_t) {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_vector_get_column_type*(vector: duckdb_vector): duckdb_logical_type {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_vector_get_data*(vector: duckdb_vector): pointer {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_vector_get_validity*(vector: duckdb_vector): ptr uint64 {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_vector_ensure_validity_writable*(vector: duckdb_vector) {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_vector_assign_string_element*(vector: duckdb_vector; index: idx_t;\r\n    str: cstring) {.importc, cdecl, impduckdbDyn.}\r\nproc duckdb_vector_assign_string_element_len*(vector: duckdb_vector;\r\n    index: idx_t; str: cstring; str_len: idx_t) {.importc, cdecl, impduckdbDyn.}\r\nproc duckdb_list_vector_get_child*(vector: duckdb_vector): duckdb_vector {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_list_vector_get_size*(vector: duckdb_vector): idx_t {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_struct_vector_get_child*(vector: duckdb_vector;\r\n    index: idx_t): duckdb_vector {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_validity_row_is_valid*(validity: ptr uint64; row: idx_t): bool {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_validity_set_row_validity*(validity: ptr uint64; row: idx_t;\r\n                                       valid: bool) {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_validity_set_row_invalid*(validity: ptr uint64; row: idx_t) {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_validity_set_row_valid*(validity: ptr uint64; row: idx_t) {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_create_table_function*(): duckdb_table_function {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_destroy_table_function*(table_function: ptr duckdb_table_function) {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_table_function_set_name*(table_function: duckdb_table_function;\r\n                                     name: cstring) {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_table_function_add_parameter*(table_function: duckdb_table_function;\r\n    `type`: duckdb_logical_type) {.importc, cdecl, impduckdbDyn.}\r\nproc duckdb_table_function_set_extra_info*(\r\n    table_function: duckdb_table_function; extra_info: pointer;\r\n    destroy: duckdb_delete_callback_t) {.importc, cdecl, impduckdbDyn.}\r\nproc duckdb_table_function_set_bind*(table_function: duckdb_table_function;\r\n                                     `bind`: duckdb_table_function_bind_t) {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_table_function_set_init*(table_function: duckdb_table_function;\r\n                                     init: duckdb_table_function_init_t) {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_table_function_set_local_init*(\r\n    table_function: duckdb_table_function;\r\n        init: duckdb_table_function_init_t) {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_table_function_set_function*(table_function: duckdb_table_function;\r\n    function: duckdb_table_function_t) {.importc, cdecl, impduckdbDyn.}\r\nproc duckdb_table_function_supports_projection_pushdown*(\r\n    table_function: duckdb_table_function; pushdown: bool) {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_register_table_function*(con: duckdb_connection;\r\n                                     function: duckdb_table_function): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_bind_get_extra_info*(info: duckdb_bind_info): pointer {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_bind_add_result_column*(info: duckdb_bind_info; name: cstring;\r\n                                    `type`: duckdb_logical_type) {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_bind_get_parameter_count*(info: duckdb_bind_info): idx_t {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_bind_get_parameter*(info: duckdb_bind_info;\r\n    index: idx_t): duckdb_value {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_bind_set_bind_data*(info: duckdb_bind_info; bind_data: pointer;\r\n                                destroy: duckdb_delete_callback_t) {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_bind_set_cardinality*(info: duckdb_bind_info; cardinality: idx_t;\r\n                                  is_exact: bool) {.importc, cdecl, impduckdbDyn.}\r\nproc duckdb_bind_set_error*(info: duckdb_bind_info; error: cstring) {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_init_get_extra_info*(info: duckdb_init_info): pointer {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_init_get_bind_data*(info: duckdb_init_info): pointer {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_init_set_init_data*(info: duckdb_init_info; init_data: pointer;\r\n                                destroy: duckdb_delete_callback_t) {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_init_get_column_count*(info: duckdb_init_info): idx_t {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_init_get_column_index*(info: duckdb_init_info;\r\n    column_index: idx_t): idx_t {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_init_set_max_threads*(info: duckdb_init_info; max_threads: idx_t) {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_init_set_error*(info: duckdb_init_info; error: cstring) {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_function_get_extra_info*(info: duckdb_function_info): pointer {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_function_get_bind_data*(info: duckdb_function_info): pointer {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_function_get_init_data*(info: duckdb_function_info): pointer {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_function_get_local_init_data*(\r\n  info: duckdb_function_info): pointer {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_function_set_error*(info: duckdb_function_info; error: cstring) {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_add_replacement_scan*(db: duckdb_database;\r\n                                  replacement: duckdb_replacement_callback_t;\r\n                                  extra_data: pointer;\r\n                                  delete_callback: duckdb_delete_callback_t) {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_replacement_scan_set_function_name*(\r\n    info: duckdb_replacement_scan_info; function_name: cstring) {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_replacement_scan_add_parameter*(info: duckdb_replacement_scan_info;\r\n    parameter: duckdb_value) {.importc, cdecl, impduckdbDyn.}\r\nproc duckdb_appender_create*(connection: duckdb_connection; schema: cstring;\r\n                             table: cstring;\r\n                                 out_appender: ptr duckdb_appender): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_appender_error*(appender: duckdb_appender): cstring {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_appender_flush*(appender: duckdb_appender): duckdb_state {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_appender_close*(appender: duckdb_appender): duckdb_state {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_appender_destroy*(appender: ptr duckdb_appender): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_appender_begin_row*(appender: duckdb_appender): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_appender_end_row*(appender: duckdb_appender): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_append_bool*(appender: duckdb_appender;\r\n    value: bool): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_append_int8*(appender: duckdb_appender;\r\n    value: int8): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_append_int16*(appender: duckdb_appender;\r\n    value: int16): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_append_int32*(appender: duckdb_appender;\r\n    value: int32): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_append_int64*(appender: duckdb_appender;\r\n    value: int64): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_append_hugeint*(appender: duckdb_appender;\r\n    value: duckdb_hugeint): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_append_uint8*(appender: duckdb_appender;\r\n    value: uint8): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_append_uint16*(appender: duckdb_appender;\r\n    value: uint16): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_append_uint32*(appender: duckdb_appender;\r\n    value: uint32): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_append_uint64*(appender: duckdb_appender;\r\n    value: uint64): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_append_float*(appender: duckdb_appender;\r\n    value: cfloat): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_append_double*(appender: duckdb_appender;\r\n    value: cdouble): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_append_date*(appender: duckdb_appender;\r\n    value: duckdb_date): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_append_time*(appender: duckdb_appender;\r\n    value: duckdb_time): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_append_timestamp*(appender: duckdb_appender;\r\n    value: duckdb_timestamp): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_append_interval*(appender: duckdb_appender;\r\n    value: duckdb_interval): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_append_varchar*(appender: duckdb_appender;\r\n    val: cstring): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_append_varchar_length*(appender: duckdb_appender; val: cstring;\r\n                                   length: idx_t): duckdb_state {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_append_blob*(appender: duckdb_appender; data: pointer;\r\n    length: idx_t): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_append_null*(appender: duckdb_appender): duckdb_state {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_append_data_chunk*(appender: duckdb_appender;\r\n                               chunk: duckdb_data_chunk): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_query_arrow*(connection: duckdb_connection; query: cstring;\r\n                         out_result: ptr duckdb_arrow): duckdb_state {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_query_arrow_schema*(result: duckdb_arrow;\r\n                                out_schema: ptr duckdb_arrow_schema): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_query_arrow_array*(result: duckdb_arrow;\r\n                               out_array: ptr duckdb_arrow_array): duckdb_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_arrow_column_count*(result: duckdb_arrow): idx_t {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_arrow_row_count*(result: duckdb_arrow): idx_t {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_arrow_rows_changed*(result: duckdb_arrow): idx_t {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_query_arrow_error*(result: duckdb_arrow): cstring {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_destroy_arrow*(result: ptr duckdb_arrow) {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_execute_tasks*(database: duckdb_database; max_tasks: idx_t) {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_create_task_state*(database: duckdb_database): duckdb_task_state {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_execute_tasks_state*(state: duckdb_task_state) {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_execute_n_tasks_state*(state: duckdb_task_state;\r\n    max_tasks: idx_t): idx_t {.\r\n    importc, cdecl, impduckdbDyn.}\r\nproc duckdb_finish_execution*(state: duckdb_task_state) {.importc, cdecl,\r\n    impduckdbDyn.}\r\nproc duckdb_task_state_is_finished*(state: duckdb_task_state): bool {.importc,\r\n    cdecl, impduckdbDyn.}\r\nproc duckdb_destroy_task_state*(state: duckdb_task_state) {.importc, cdecl,\r\n    impduckdbDyn.}\r\n{.pop.}\r\n\r\nimport std/db_common\r\nimport std/json\r\nimport os\r\n\r\ntype\r\n  DbConn* = duckdb_database\r\n\r\n\r\nproc open*(connection, user, password, database: string): DbConn {.\r\n  tags: [DbEffect].} =\r\n  var db: DbConn\r\n  if (duckdb_open(connection, db.addr) == DuckDBError):\r\n    var msg = osErrorMsg(osLastError())\r\n    raise newException(DbError, \"couldn't open database. \" & msg)\r\n  result = db\r\n\r\nproc getValue*(db: var DbConn, query: SqlQuery, args: varargs[string,\r\n    `$`]): string {.tags: [ReadDbEffect].} =\r\n  var\r\n    con: duckdb_connection\r\n    res: duckdb_result\r\n    pStmt: duckdb_prepared_statement\r\n  if (duckdb_connect(db, con.addr) == DuckDBError):\r\n    raise newException(DbError, \"error occured when connecting to database\")\r\n\r\n  if (duckdb_prepare(con, cstring(query), addr(\r\n      pStmt)) == DuckDBError):\r\n    var msg = duckdb_prepare_error(pStmt)\r\n    duckdb_disconnect(addr(con))\r\n    raise newException(DbError, \"error occured when preparing statement: \" & $msg)\r\n\r\n  echo duckdb_param_type(pStmt, 1.idx_t)\r\n\r\n  if args.len != 0:\r\n    if duckdb_nparams(pStmt) != args.len.idx_t:\r\n      duckdb_destroy_prepare(addr(pStmt))\r\n      duckdb_disconnect(addr(con))\r\n      raise newException(DbError, \"wrong number of binding parameters\")\r\n\r\n    for i, arg in args.pairs:\r\n      if (duckdb_bind_varchar(pStmt, (i + 1).idx_t, cstring(arg))) == DuckDBError:\r\n        duckdb_destroy_prepare(addr(pStmt))\r\n        duckdb_disconnect(addr(con))\r\n        raise newException(DbError, \"error occured when attempting to bind value \" &\r\n            arg & \" at position \" & $i)\r\n      # echo duckdb_param_type(pStmt, (i+1).idx_t)\r\n      # if duckdb_param_type(pStmt, (i+1).idx_t) == DUCKDB_TYPE_INVALID:\r\n      #   duckdb_destroy_prepare(addr(pStmt))\r\n      #   duckdb_disconnect(addr(con))\r\n      #   raise newException(DbError, \"parameter type error value:\" &\r\n      #       arg & \", at position: \" & $i)\r\n\r\n  if duckdb_execute_prepared(pStmt, addr(res)) == DuckDBError:\r\n    var msg = duckdb_result_error(addr(res))\r\n    duckdb_destroy_prepare(addr(pStmt))\r\n    duckdb_disconnect(addr(con))\r\n    raise newException(DbError, \"error occured when executing prepared statement: \" & $msg)\r\n\r\n  let val = duckdb_value_varchar(addr(res), 0.csize_t, 0.csize_t)\r\n  if val.isNil:\r\n    result = \"\"\r\n  else:\r\n    result = $val\r\n  duckdb_free(val)\r\n  duckdb_destroy_result(addr(res))\r\n  duckdb_destroy_prepare(addr(pStmt))\r\n  duckdb_disconnect(addr(con))\r\n\r\nproc main() =\r\n  var db = open(\"test.db\", \"\", \"\", \"\")\r\n  try:\r\n    var x = db.getValue(sql\"SELECT sum(i) FROM integers WHERE i > ?\", \"3\")\r\n    echo x\r\n  except:\r\n    echo getCurrentExceptionMsg()\r\n  finally:\r\n    duckdb_close(addr(db))\r\n\r\nmain()\r\n\r\n\r\n```\n\n### OS:\n\nwindows 10\n\n### DuckDB Version:\n\n0.5.1\n\n### DuckDB Client:\n\nNim / C api\n\n### Full Name:\n\nSteve McAllister\n\n### Affiliation:\n\nNone\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\nReading a CSV file with an empty header is problematic\n### Discussed in https://github.com/duckdb/duckdb/discussions/4932\r\n\r\n<div type='discussions-op-text'>\r\n\r\n<sup>Originally posted by **szarnyasg** October  9, 2022</sup>\r\n### What happens?\r\n\r\nWhen loading a CSV file with an empty header, the first row with actual content is either skipped (with `HEADER true`) or it is read but its first attribute is not loaded correctly (with `HEADER false`).\r\n\r\nObviously, such a CSV file is malformed so it's unclear how it should be loaded, so one can argue this is not a bug. That said, IMHO loading half the first row violates the principle of least surprise -- either throwing an error message or loading the full row would be better alternatives.\r\n\r\n### To Reproduce\r\n\r\nCreate `my.csv` with an empty first line:\r\n```csv\r\n\r\na 1\r\nb 2\r\nc 3\r\n```\r\nRun the following commands in DuckDB:\r\n```sql\r\nCREATE OR REPLACE TABLE stats (file varchar, numEntities bigint);\r\nCOPY stats FROM 'my.csv' (DELIMITER ' ');\r\nSELECT * FROM stats;\r\n```\r\n```console\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 file \u2502 numEntities \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502      \u2502 1           \u2502\r\n\u2502 b    \u2502 2           \u2502\r\n\u2502 c    \u2502 3           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\nNote that the `file` attribute is empty for the first row.\r\n\r\nWith the `HEADER` setting, the line (`a 1`) is skipped in the CSV file:\r\n```sql\r\nCREATE OR REPLACE TABLE stats (file varchar, numEntities bigint);\r\nCOPY stats FROM 'my.csv' (DELIMITER ' ', HEADER);\r\nSELECT * FROM stats;\r\n```\r\n```console\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 file \u2502 numEntities \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 b    \u2502 2           \u2502\r\n\u2502 c    \u2502 3           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n\r\nOriginally reported by @szarnyasg , I had not noticed the missing data before pressing \"convert\". The missing stuff is problematic indeed.\n",
  "hints_text": "\n",
  "created_at": "2022-10-10T08:07:04Z"
}