{
  "repo": "duckdb/duckdb",
  "pull_number": 5010,
  "instance_id": "duckdb__duckdb-5010",
  "issue_numbers": [
    "4976"
  ],
  "base_commit": "c2ca23eef98ca91fdf73ff29129bc7816bd73ff3",
  "patch": "diff --git a/src/execution/index/art/art.cpp b/src/execution/index/art/art.cpp\nindex ccc0edd5a99d..98ff6824ecc6 100644\n--- a/src/execution/index/art/art.cpp\n+++ b/src/execution/index/art/art.cpp\n@@ -287,19 +287,6 @@ void Construct(vector<Key> &keys, row_t *row_ids, Node *&node, KeySection &key_s\n \t}\n }\n \n-void FindFirstNotNullKey(vector<Key> &keys, bool &skipped_all_nulls, idx_t &start_idx) {\n-\n-\tif (!skipped_all_nulls) {\n-\t\tfor (idx_t i = 0; i < keys.size(); i++) {\n-\t\t\tif (!keys[i].Empty()) {\n-\t\t\t\tstart_idx = i;\n-\t\t\t\tskipped_all_nulls = true;\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n void ART::ConstructAndMerge(IndexLock &lock, PayloadScanner &scanner, Allocator &allocator) {\n \n \tauto payload_types = logical_types;\n@@ -308,7 +295,6 @@ void ART::ConstructAndMerge(IndexLock &lock, PayloadScanner &scanner, Allocator\n \tArenaAllocator arena_allocator(allocator);\n \tvector<Key> keys(STANDARD_VECTOR_SIZE);\n \n-\tauto skipped_all_nulls = false;\n \tauto temp_art = make_unique<ART>(this->column_ids, this->table_io_manager, this->unbound_expressions,\n \t                                 this->constraint_type, this->db);\n \n@@ -333,22 +319,6 @@ void ART::ConstructAndMerge(IndexLock &lock, PayloadScanner &scanner, Allocator\n \t\tarena_allocator.Reset();\n \t\tGenerateKeys(arena_allocator, ordered_chunk, keys);\n \n-\t\t// we order NULLS FIRST, so we might have to skip nulls at the start of our sorted data\n-\t\tidx_t start_idx = 0;\n-\t\tFindFirstNotNullKey(keys, skipped_all_nulls, start_idx);\n-\n-\t\tif (start_idx != 0 && IsPrimary()) {\n-\t\t\tthrow ConstraintException(\"NULLs in new data violate the primary key constraint of the index\");\n-\t\t}\n-\n-\t\tif (!skipped_all_nulls) {\n-\t\t\tif (IsPrimary()) {\n-\t\t\t\t// chunk consists only of NULLs\n-\t\t\t\tthrow ConstraintException(\"NULLs in new data violate the primary key constraint of the index\");\n-\t\t\t}\n-\t\t\tcontinue;\n-\t\t}\n-\n \t\t// prepare the row_identifiers\n \t\trow_identifiers.Flatten(ordered_chunk.size());\n \t\tauto row_ids = FlatVector::GetData<row_t>(row_identifiers);\n@@ -356,7 +326,7 @@ void ART::ConstructAndMerge(IndexLock &lock, PayloadScanner &scanner, Allocator\n \t\t// construct the ART of this chunk\n \t\tauto art = make_unique<ART>(this->column_ids, this->table_io_manager, this->unbound_expressions,\n \t\t                            this->constraint_type, this->db);\n-\t\tauto key_section = KeySection(start_idx, ordered_chunk.size() - 1, 0, 0);\n+\t\tauto key_section = KeySection(0, ordered_chunk.size() - 1, 0, 0);\n \t\tauto has_constraint = IsUnique();\n \t\tConstruct(keys, row_ids, art->tree, key_section, has_constraint);\n \ndiff --git a/src/execution/physical_plan/plan_create_index.cpp b/src/execution/physical_plan/plan_create_index.cpp\nindex 52b6d89d0635..37d0349ae0e9 100644\n--- a/src/execution/physical_plan/plan_create_index.cpp\n+++ b/src/execution/physical_plan/plan_create_index.cpp\n@@ -1,9 +1,12 @@\n #include \"duckdb/catalog/catalog_entry/table_catalog_entry.hpp\"\n+#include \"duckdb/execution/operator/filter/physical_filter.hpp\"\n+#include \"duckdb/execution/operator/scan/physical_table_scan.hpp\"\n #include \"duckdb/execution/operator/schema/physical_create_index.hpp\"\n #include \"duckdb/execution/physical_plan_generator.hpp\"\n-#include \"duckdb/planner/operator/logical_create_index.hpp\"\n-#include \"duckdb/execution/operator/scan/physical_table_scan.hpp\"\n #include \"duckdb/function/table/table_scan.hpp\"\n+#include \"duckdb/planner/filter/null_filter.hpp\"\n+#include \"duckdb/planner/operator/logical_create_index.hpp\"\n+#include \"duckdb/planner/table_filter.hpp\"\n \n namespace duckdb {\n \n@@ -11,11 +14,13 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalCreateInde\n \n \tD_ASSERT(op.children.empty());\n \n+\t// table scan operator for index key columns and row IDs\n \tunique_ptr<TableFilterSet> table_filters;\n \top.info->column_ids.emplace_back(COLUMN_IDENTIFIER_ROW_ID);\n \n \tauto &bind_data = (TableScanBindData &)*op.bind_data;\n \tbind_data.is_create_index = true;\n+\n \tauto table_scan =\n \t    make_unique<PhysicalTableScan>(op.info->scan_types, op.function, move(op.bind_data), op.info->column_ids,\n \t                                   op.info->names, move(table_filters), op.estimated_cardinality);\n@@ -23,10 +28,32 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalCreateInde\n \tdependencies.insert(&op.table);\n \top.info->column_ids.pop_back();\n \n+\tD_ASSERT(op.info->scan_types.size() - 1 <= op.info->names.size());\n+\tD_ASSERT(op.info->scan_types.size() - 1 <= op.info->column_ids.size());\n+\n+\t// filter operator for IS_NOT_NULL on each key column\n+\tvector<LogicalType> filter_types;\n+\tvector<unique_ptr<Expression>> filter_select_list;\n+\n+\tfor (idx_t i = 0; i < op.info->scan_types.size() - 1; i++) {\n+\t\tfilter_types.push_back(op.info->scan_types[i]);\n+\t\tauto is_not_null_expr =\n+\t\t    make_unique<BoundOperatorExpression>(ExpressionType::OPERATOR_IS_NOT_NULL, LogicalType::BOOLEAN);\n+\t\tauto bound_ref =\n+\t\t    make_unique<BoundReferenceExpression>(op.info->names[op.info->column_ids[i]], op.info->scan_types[i], i);\n+\t\tis_not_null_expr->children.push_back(move(bound_ref));\n+\t\tfilter_select_list.push_back(move(is_not_null_expr));\n+\t}\n+\n+\tauto null_filter = make_unique<PhysicalFilter>(move(filter_types), move(filter_select_list), STANDARD_VECTOR_SIZE);\n+\tnull_filter->types.emplace_back(LogicalType::ROW_TYPE);\n+\tnull_filter->children.push_back(move(table_scan));\n+\n+\t// actual physical create index operator\n \tauto physical_create_index =\n \t    make_unique<PhysicalCreateIndex>(op, op.table, op.info->column_ids, move(op.expressions), move(op.info),\n \t                                     move(op.unbound_expressions), op.estimated_cardinality);\n-\tphysical_create_index->children.push_back(move(table_scan));\n+\tphysical_create_index->children.push_back(move(null_filter));\n \treturn move(physical_create_index);\n }\n \n",
  "test_patch": "diff --git a/test/sql/index/art/test_art_create_index.test b/test/sql/index/art/test_art_create_index.test\nnew file mode 100644\nindex 000000000000..7c01a1fd4ddb\n--- /dev/null\n+++ b/test/sql/index/art/test_art_create_index.test\n@@ -0,0 +1,17 @@\n+# name: test/sql/index/art/test_art_create_index.test\n+# description: CREATE INDEX\n+# group: [art]\n+\n+# test to reproduce issue #4976\n+\n+statement ok\n+CREATE TABLE t0(c0 DOUBLE, c1 TIMESTAMP DEFAULT(TIMESTAMP '1970-01-04 12:58:32'));\n+\n+statement ok\n+INSERT INTO t0(c1, c0) VALUES (TIMESTAMP '1969-12-28 23:02:08', 1);\n+\n+statement ok\n+INSERT INTO t0(c0) VALUES (DEFAULT);\n+\n+statement ok\n+CREATE INDEX i2 ON t0(c1, c0);\n\\ No newline at end of file\n",
  "problem_statement": "Crash When Creating Index\n### What happens?\n\nCrash.\n\n### To Reproduce\n\n```sql\r\nCREATE TABLE t0(c0 DOUBLE, c1 TIMESTAMP DEFAULT(TIMESTAMP '1970-01-04 12:58:32'));\r\nINSERT INTO t0(c1, c0) VALUES (TIMESTAMP '1969-12-28 23:02:08', 1);\r\nINSERT INTO t0(c0) VALUES (DEFAULT);\r\nCREATE INDEX i2 ON t0(c1, c0); -- segment fault\r\n```\n\n### OS:\n\nUbuntu 20:04\n\n### DuckDB Version:\n\nv0.5.2-dev737 9913e0e80\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nJinsheng Ba\n\n### Affiliation:\n\nNational University of Singapore\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "This crash should no longer occur once the current `CREATE INDEX` PR gets merged (#4960). ",
  "created_at": "2022-10-17T13:30:59Z"
}