diff --git a/src/execution/index/art/art.cpp b/src/execution/index/art/art.cpp
index ccc0edd5a99d..98ff6824ecc6 100644
--- a/src/execution/index/art/art.cpp
+++ b/src/execution/index/art/art.cpp
@@ -287,19 +287,6 @@ void Construct(vector<Key> &keys, row_t *row_ids, Node *&node, KeySection &key_s
 	}
 }
 
-void FindFirstNotNullKey(vector<Key> &keys, bool &skipped_all_nulls, idx_t &start_idx) {
-
-	if (!skipped_all_nulls) {
-		for (idx_t i = 0; i < keys.size(); i++) {
-			if (!keys[i].Empty()) {
-				start_idx = i;
-				skipped_all_nulls = true;
-				return;
-			}
-		}
-	}
-}
-
 void ART::ConstructAndMerge(IndexLock &lock, PayloadScanner &scanner, Allocator &allocator) {
 
 	auto payload_types = logical_types;
@@ -308,7 +295,6 @@ void ART::ConstructAndMerge(IndexLock &lock, PayloadScanner &scanner, Allocator
 	ArenaAllocator arena_allocator(allocator);
 	vector<Key> keys(STANDARD_VECTOR_SIZE);
 
-	auto skipped_all_nulls = false;
 	auto temp_art = make_unique<ART>(this->column_ids, this->table_io_manager, this->unbound_expressions,
 	                                 this->constraint_type, this->db);
 
@@ -333,22 +319,6 @@ void ART::ConstructAndMerge(IndexLock &lock, PayloadScanner &scanner, Allocator
 		arena_allocator.Reset();
 		GenerateKeys(arena_allocator, ordered_chunk, keys);
 
-		// we order NULLS FIRST, so we might have to skip nulls at the start of our sorted data
-		idx_t start_idx = 0;
-		FindFirstNotNullKey(keys, skipped_all_nulls, start_idx);
-
-		if (start_idx != 0 && IsPrimary()) {
-			throw ConstraintException("NULLs in new data violate the primary key constraint of the index");
-		}
-
-		if (!skipped_all_nulls) {
-			if (IsPrimary()) {
-				// chunk consists only of NULLs
-				throw ConstraintException("NULLs in new data violate the primary key constraint of the index");
-			}
-			continue;
-		}
-
 		// prepare the row_identifiers
 		row_identifiers.Flatten(ordered_chunk.size());
 		auto row_ids = FlatVector::GetData<row_t>(row_identifiers);
@@ -356,7 +326,7 @@ void ART::ConstructAndMerge(IndexLock &lock, PayloadScanner &scanner, Allocator
 		// construct the ART of this chunk
 		auto art = make_unique<ART>(this->column_ids, this->table_io_manager, this->unbound_expressions,
 		                            this->constraint_type, this->db);
-		auto key_section = KeySection(start_idx, ordered_chunk.size() - 1, 0, 0);
+		auto key_section = KeySection(0, ordered_chunk.size() - 1, 0, 0);
 		auto has_constraint = IsUnique();
 		Construct(keys, row_ids, art->tree, key_section, has_constraint);
 
diff --git a/src/execution/physical_plan/plan_create_index.cpp b/src/execution/physical_plan/plan_create_index.cpp
index 52b6d89d0635..37d0349ae0e9 100644
--- a/src/execution/physical_plan/plan_create_index.cpp
+++ b/src/execution/physical_plan/plan_create_index.cpp
@@ -1,9 +1,12 @@
 #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
+#include "duckdb/execution/operator/filter/physical_filter.hpp"
+#include "duckdb/execution/operator/scan/physical_table_scan.hpp"
 #include "duckdb/execution/operator/schema/physical_create_index.hpp"
 #include "duckdb/execution/physical_plan_generator.hpp"
-#include "duckdb/planner/operator/logical_create_index.hpp"
-#include "duckdb/execution/operator/scan/physical_table_scan.hpp"
 #include "duckdb/function/table/table_scan.hpp"
+#include "duckdb/planner/filter/null_filter.hpp"
+#include "duckdb/planner/operator/logical_create_index.hpp"
+#include "duckdb/planner/table_filter.hpp"
 
 namespace duckdb {
 
@@ -11,11 +14,13 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalCreateInde
 
 	D_ASSERT(op.children.empty());
 
+	// table scan operator for index key columns and row IDs
 	unique_ptr<TableFilterSet> table_filters;
 	op.info->column_ids.emplace_back(COLUMN_IDENTIFIER_ROW_ID);
 
 	auto &bind_data = (TableScanBindData &)*op.bind_data;
 	bind_data.is_create_index = true;
+
 	auto table_scan =
 	    make_unique<PhysicalTableScan>(op.info->scan_types, op.function, move(op.bind_data), op.info->column_ids,
 	                                   op.info->names, move(table_filters), op.estimated_cardinality);
@@ -23,10 +28,32 @@ unique_ptr<PhysicalOperator> PhysicalPlanGenerator::CreatePlan(LogicalCreateInde
 	dependencies.insert(&op.table);
 	op.info->column_ids.pop_back();
 
+	D_ASSERT(op.info->scan_types.size() - 1 <= op.info->names.size());
+	D_ASSERT(op.info->scan_types.size() - 1 <= op.info->column_ids.size());
+
+	// filter operator for IS_NOT_NULL on each key column
+	vector<LogicalType> filter_types;
+	vector<unique_ptr<Expression>> filter_select_list;
+
+	for (idx_t i = 0; i < op.info->scan_types.size() - 1; i++) {
+		filter_types.push_back(op.info->scan_types[i]);
+		auto is_not_null_expr =
+		    make_unique<BoundOperatorExpression>(ExpressionType::OPERATOR_IS_NOT_NULL, LogicalType::BOOLEAN);
+		auto bound_ref =
+		    make_unique<BoundReferenceExpression>(op.info->names[op.info->column_ids[i]], op.info->scan_types[i], i);
+		is_not_null_expr->children.push_back(move(bound_ref));
+		filter_select_list.push_back(move(is_not_null_expr));
+	}
+
+	auto null_filter = make_unique<PhysicalFilter>(move(filter_types), move(filter_select_list), STANDARD_VECTOR_SIZE);
+	null_filter->types.emplace_back(LogicalType::ROW_TYPE);
+	null_filter->children.push_back(move(table_scan));
+
+	// actual physical create index operator
 	auto physical_create_index =
 	    make_unique<PhysicalCreateIndex>(op, op.table, op.info->column_ids, move(op.expressions), move(op.info),
 	                                     move(op.unbound_expressions), op.estimated_cardinality);
-	physical_create_index->children.push_back(move(table_scan));
+	physical_create_index->children.push_back(move(null_filter));
 	return move(physical_create_index);
 }
 
