You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Querying a `TIME` type from NodeJS crashes the Javascript Interpreter
### What happens?

Javascript does not have support for a built-in `TIME` data type, so if you try to query for a `TIME` column from Node you are supposed to get a Javascript exception about the data type being unsupported, but instead, the interpreter crashes like so:

```
> Uncaught Error: Data type is not supported TIME
> node[76445]: ../src/node_util.cc:242:static void node::util::WeakReference::DecRef(const FunctionCallbackInfo<v8::Value> &): Assertion `(weak_ref->reference_count_) >= (1)' failed.
 1: 0x10728a4e8 node::Abort() [/usr/local/Cellar/node/18.10.0/bin/node]
 2: 0x10728a4d3 node::Abort() [/usr/local/Cellar/node/18.10.0/bin/node]
 3: 0x10731a7b4 node::util::GuessHandleType(v8::FunctionCallbackInfo<v8::Value> const&) [/usr/local/Cellar/node/18.10.0/bin/node]
 4: 0x107436c37 v8::internal::FunctionCallbackArguments::Call(v8::internal::CallHandlerInfo) [/usr/local/Cellar/node/18.10.0/bin/node]
 5: 0x107436a1d v8::internal::MaybeHandle<v8::internal::Object> v8::internal::(anonymous namespace)::HandleApiCallHelper<false>(v8::internal::Isolate*, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::HeapObject>, v8::internal::Handle<v8::internal::FunctionTemplateInfo>, v8::internal::Handle<v8::internal::Object>, v8::internal::BuiltinArguments) [/usr/local/Cellar/node/18.10.0/bin/node]
 6: 0x1074364a5 v8::internal::Builtin_HandleApiCall(int, unsigned long*, v8::internal::Isolate*) [/usr/local/Cellar/node/18.10.0/bin/node]
 7: 0x1070dfef9 Builtins_CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit [/usr/local/Cellar/node/18.10.0/bin/node]
```

### To Reproduce

Here's some NodeJS code to run that can easily reproduce the issue:

```
const { Database } = require('duckdb');
const db = new Database('/tmp/test.db');
db.all("SELECT CAST('11:10:10' as TIME) as time", function(err, res) {
  if (err) {
    console.log("An error!");
  }
  console.log(res[0].time);
});
```

### OS:

OS X

### DuckDB Version:

0.5.1

### DuckDB Client:

NodeJS

### Full Name:

Josh Wills

### Affiliation:

WeaveGrid

### Have you tried this on the latest `master` branch?

- [X] I agree

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] I agree

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=master" alt="Github Actions Badge">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The detail of benchmarks is in our [Benchmark Guide](benchmark/README.md).
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
[end of README.md]
[start of tools/nodejs/src/statement.cpp]
1: #include "duckdb.hpp"
2: #include "duckdb_node.hpp"
3: #include "napi.h"
4: 
5: #include <algorithm>
6: #include <cassert>
7: 
8: namespace node_duckdb {
9: 
10: Napi::FunctionReference Statement::constructor;
11: 
12: Napi::Object Statement::Init(Napi::Env env, Napi::Object exports) {
13: 	Napi::HandleScope scope(env);
14: 
15: 	Napi::Function t =
16: 	    DefineClass(env, "Statement",
17: 	                {InstanceMethod("run", &Statement::Run), InstanceMethod("all", &Statement::All),
18: 	                 InstanceMethod("each", &Statement::Each), InstanceMethod("finalize", &Statement::Finish),
19: 	                 InstanceMethod("stream", &Statement::Stream)});
20: 
21: 	constructor = Napi::Persistent(t);
22: 	constructor.SuppressDestruct();
23: 
24: 	exports.Set("Statement", t);
25: 	return exports;
26: }
27: 
28: struct PrepareTask : public Task {
29: 	PrepareTask(Statement &statement, Napi::Function callback) : Task(statement, callback) {
30: 	}
31: 
32: 	void DoWork() override {
33: 		auto &statement = Get<Statement>();
34: 		statement.statement = statement.connection_ref->connection->Prepare(statement.sql);
35: 	}
36: 
37: 	void Callback() override {
38: 		auto &statement = Get<Statement>();
39: 		auto env = statement.Env();
40: 		Napi::HandleScope scope(env);
41: 
42: 		auto cb = callback.Value();
43: 		if (statement.statement->HasError()) {
44: 			cb.MakeCallback(statement.Value(), {Utils::CreateError(env, statement.statement->error.Message())});
45: 			return;
46: 		}
47: 		cb.MakeCallback(statement.Value(), {env.Null(), statement.Value()});
48: 	}
49: };
50: 
51: Statement::Statement(const Napi::CallbackInfo &info) : Napi::ObjectWrap<Statement>(info) {
52: 
53: 	Napi::Env env = info.Env();
54: 	int length = info.Length();
55: 
56: 	if (length <= 0 || !Connection::HasInstance(info[0])) {
57: 		Napi::TypeError::New(env, "Connection object expected").ThrowAsJavaScriptException();
58: 		return;
59: 	} else if (length <= 1 || !info[1].IsString()) {
60: 		Napi::TypeError::New(env, "SQL query expected").ThrowAsJavaScriptException();
61: 		return;
62: 	}
63: 
64: 	connection_ref = Napi::ObjectWrap<Connection>::Unwrap(info[0].As<Napi::Object>());
65: 	connection_ref->Ref();
66: 
67: 	sql = info[1].As<Napi::String>();
68: 
69: 	Napi::Function callback;
70: 	if (info.Length() > 1 && info[2].IsFunction()) {
71: 		callback = info[2].As<Napi::Function>();
72: 	}
73: 
74: 	// TODO we can have parameters here as well. Forward if that is the case.
75: 	Value().As<Napi::Object>().DefineProperty(
76: 	    Napi::PropertyDescriptor::Value("sql", info[1].As<Napi::String>(), napi_default));
77: 	connection_ref->database_ref->Schedule(env, duckdb::make_unique<PrepareTask>(*this, callback));
78: }
79: 
80: Statement::~Statement() {
81: 	connection_ref->Unref();
82: 	connection_ref = nullptr;
83: }
84: 
85: // A Napi InstanceOf for Javascript Objects "Date" and "RegExp"
86: static bool OtherInstanceOf(Napi::Object source, const char *object_type) {
87: 	if (strcmp(object_type, "Date") == 0) {
88: 		return source.InstanceOf(source.Env().Global().Get(object_type).As<Napi::Function>());
89: 	} else if (strcmp(object_type, "RegExp") == 0) {
90: 		return source.InstanceOf(source.Env().Global().Get(object_type).As<Napi::Function>());
91: 	}
92: 
93: 	return false;
94: }
95: 
96: static duckdb::Value BindParameter(const Napi::Value source) {
97: 	if (source.IsString()) {
98: 		return duckdb::Value(source.As<Napi::String>().Utf8Value());
99: 	} else if (OtherInstanceOf(source.As<Napi::Object>(), "RegExp")) {
100: 		return duckdb::Value(source.ToString().Utf8Value());
101: 	} else if (source.IsNumber()) {
102: 		if (Utils::OtherIsInt(source.As<Napi::Number>())) {
103: 			return duckdb::Value::INTEGER(source.As<Napi::Number>().Int32Value());
104: 		} else {
105: 			return duckdb::Value::DOUBLE(source.As<Napi::Number>().DoubleValue());
106: 		}
107: 	} else if (source.IsBoolean()) {
108: 		return duckdb::Value::BOOLEAN(source.As<Napi::Boolean>().Value());
109: 	} else if (source.IsNull()) {
110: 		return duckdb::Value();
111: 	} else if (source.IsBuffer()) {
112: 		Napi::Buffer<char> buffer = source.As<Napi::Buffer<char>>();
113: 		return duckdb::Value::BLOB(std::string(buffer.Data(), buffer.Length()));
114: #if (NAPI_VERSION > 4)
115: 	} else if (source.IsDate()) {
116: 		const auto micros = int64_t(source.As<Napi::Date>().ValueOf()) * duckdb::Interval::MICROS_PER_MSEC;
117: 		if (micros % duckdb::Interval::MICROS_PER_DAY) {
118: 			return duckdb::Value::TIMESTAMP(duckdb::timestamp_t(micros));
119: 		} else {
120: 			const auto days = int32_t(micros / duckdb::Interval::MICROS_PER_DAY);
121: 			return duckdb::Value::DATE(duckdb::date_t(days));
122: 		}
123: #endif
124: 	} else if (source.IsObject()) {
125: 		return duckdb::Value(source.ToString().Utf8Value());
126: 	}
127: 	return duckdb::Value();
128: }
129: 
130: static Napi::Value convert_col_val(Napi::Env &env, duckdb::Value dval, duckdb::LogicalTypeId id) {
131: 	Napi::Value value;
132: 
133: 	if (dval.IsNull()) {
134: 		return env.Null();
135: 	}
136: 
137: 	// TODO templateroo here
138: 	switch (id) {
139: 	case duckdb::LogicalTypeId::BOOLEAN: {
140: 		value = Napi::Boolean::New(env, duckdb::BooleanValue::Get(dval));
141: 	} break;
142: 	case duckdb::LogicalTypeId::TINYINT: {
143: 		value = Napi::Number::New(env, duckdb::TinyIntValue::Get(dval));
144: 	} break;
145: 	case duckdb::LogicalTypeId::SMALLINT: {
146: 		value = Napi::Number::New(env, duckdb::SmallIntValue::Get(dval));
147: 	} break;
148: 	case duckdb::LogicalTypeId::INTEGER: {
149: 		value = Napi::Number::New(env, duckdb::IntegerValue::Get(dval));
150: 	} break;
151: 	case duckdb::LogicalTypeId::BIGINT: {
152: 		value = Napi::Number::New(env, duckdb::BigIntValue::Get(dval));
153: 	} break;
154: 	case duckdb::LogicalTypeId::UTINYINT: {
155: 		value = Napi::Number::New(env, duckdb::UTinyIntValue::Get(dval));
156: 	} break;
157: 	case duckdb::LogicalTypeId::USMALLINT: {
158: 		value = Napi::Number::New(env, duckdb::USmallIntValue::Get(dval));
159: 	} break;
160: 	case duckdb::LogicalTypeId::UINTEGER: {
161: 		value = Napi::Number::New(env, duckdb::UIntegerValue::Get(dval));
162: 	} break;
163: 	case duckdb::LogicalTypeId::UBIGINT: {
164: 		value = Napi::Number::New(env, duckdb::UBigIntValue::Get(dval));
165: 	} break;
166: 	case duckdb::LogicalTypeId::FLOAT: {
167: 		value = Napi::Number::New(env, duckdb::FloatValue::Get(dval));
168: 	} break;
169: 	case duckdb::LogicalTypeId::DOUBLE: {
170: 		value = Napi::Number::New(env, duckdb::DoubleValue::Get(dval));
171: 	} break;
172: 	case duckdb::LogicalTypeId::HUGEINT: {
173: 		value = Napi::Number::New(env, dval.GetValue<double>());
174: 	} break;
175: 	case duckdb::LogicalTypeId::DECIMAL: {
176: 		value = Napi::Number::New(env, dval.GetValue<double>());
177: 	} break;
178: 	case duckdb::LogicalTypeId::INTERVAL: {
179: 		auto interval = duckdb::IntervalValue::Get(dval);
180: 		auto object_value = Napi::Object::New(env);
181: 		object_value.Set("months", interval.months);
182: 		object_value.Set("days", interval.days);
183: 		object_value.Set("micros", interval.micros);
184: 		value = object_value;
185: 	} break;
186: #if (NAPI_VERSION > 4)
187: 	case duckdb::LogicalTypeId::DATE: {
188: 		const auto scale = duckdb::Interval::SECS_PER_DAY * duckdb::Interval::MSECS_PER_SEC;
189: 		value = Napi::Date::New(env, double(dval.GetValue<int32_t>() * scale));
190: 	} break;
191: 	case duckdb::LogicalTypeId::TIMESTAMP:
192: 	case duckdb::LogicalTypeId::TIMESTAMP_TZ: {
193: 		value = Napi::Date::New(env, double(dval.GetValue<int64_t>() / duckdb::Interval::MICROS_PER_MSEC));
194: 	} break;
195: #endif
196: 	case duckdb::LogicalTypeId::VARCHAR: {
197: 		value = Napi::String::New(env, duckdb::StringValue::Get(dval));
198: 	} break;
199: 	case duckdb::LogicalTypeId::BLOB: {
200: 		auto &blob = duckdb::StringValue::Get(dval);
201: 		value = Napi::Buffer<char>::Copy(env, blob.c_str(), blob.length());
202: 	} break;
203: 	case duckdb::LogicalTypeId::SQLNULL: {
204: 		value = env.Null();
205: 	} break;
206: 	case duckdb::LogicalTypeId::LIST: {
207: 		auto child_type = duckdb::ListType::GetChildType(dval.type());
208: 		auto &child_values = duckdb::ListValue::GetChildren(dval);
209: 		auto object_value = Napi::Array::New(env);
210: 		for (duckdb::idx_t child_idx = 0; child_idx < child_values.size(); child_idx++) {
211: 			auto child_value = child_values.at(child_idx);
212: 			object_value.Set(child_idx, convert_col_val(env, child_value, child_type.id()));
213: 		}
214: 		value = object_value;
215: 	} break;
216: 	case duckdb::LogicalTypeId::STRUCT: {
217: 		auto &child_types = duckdb::StructType::GetChildTypes(dval.type());
218: 		auto &child_values = duckdb::StructValue::GetChildren(dval);
219: 		auto object_value = Napi::Object::New(env);
220: 		for (duckdb::idx_t child_idx = 0; child_idx < child_values.size(); child_idx++) {
221: 			auto child_value = child_values.at(child_idx);
222: 			auto child_type = child_types.at(child_idx);
223: 			object_value.Set(child_type.first, convert_col_val(env, child_value, child_type.second.id()));
224: 		}
225: 		value = object_value;
226: 	} break;
227: 	default:
228: 		Napi::Error::New(env, "Data type is not supported " + dval.type().ToString()).ThrowAsJavaScriptException();
229: 		return env.Null();
230: 	}
231: 
232: 	return value;
233: }
234: 
235: static Napi::Value convert_chunk(Napi::Env &env, std::vector<std::string> names, duckdb::DataChunk &chunk) {
236: 	Napi::EscapableHandleScope scope(env);
237: 	std::vector<Napi::String> node_names;
238: 	assert(names.size() == chunk.ColumnCount());
239: 	node_names.reserve(names.size());
240: 	for (auto &name : names) {
241: 		node_names.push_back(Napi::String::New(env, name));
242: 	}
243: 	Napi::Array result(Napi::Array::New(env, chunk.size()));
244: 
245: 	for (duckdb::idx_t row_idx = 0; row_idx < chunk.size(); row_idx++) {
246: 		Napi::Object row_result = Napi::Object::New(env);
247: 
248: 		for (duckdb::idx_t col_idx = 0; col_idx < chunk.ColumnCount(); col_idx++) {
249: 			duckdb::Value dval = chunk.GetValue(col_idx, row_idx);
250: 			row_result.Set(node_names[col_idx], convert_col_val(env, dval, chunk.data[col_idx].GetType().id()));
251: 		}
252: 		result.Set(row_idx, row_result);
253: 	}
254: 
255: 	return scope.Escape(result);
256: }
257: 
258: enum RunType { RUN, EACH, ALL };
259: 
260: struct StatementParam {
261: 	std::vector<duckdb::Value> params;
262: 	Napi::Function callback;
263: 	Napi::Function complete;
264: };
265: 
266: struct RunPreparedTask : public Task {
267: 	RunPreparedTask(Statement &statement, duckdb::unique_ptr<StatementParam> params, RunType run_type)
268: 	    : Task(statement, params->callback), params(move(params)), run_type(run_type) {
269: 	}
270: 
271: 	void DoWork() override {
272: 		auto &statement = Get<Statement>();
273: 		// ignorant folk arrive here without caring about the prepare callback error
274: 		if (!statement.statement || statement.statement->HasError()) {
275: 			return;
276: 		}
277: 
278: 		result = statement.statement->Execute(params->params, run_type != RunType::ALL);
279: 	}
280: 
281: 	void Callback() override {
282: 		auto &statement = Get<Statement>();
283: 		Napi::Env env = statement.Env();
284: 		Napi::HandleScope scope(env);
285: 
286: 		auto cb = callback.Value();
287: 		// if there was an error we need to say so
288: 		if (!statement.statement) {
289: 			cb.MakeCallback(statement.Value(), {Utils::CreateError(env, "statement was finalized")});
290: 			return;
291: 		}
292: 		if (statement.statement->HasError()) {
293: 			cb.MakeCallback(statement.Value(), {Utils::CreateError(env, statement.statement->GetError())});
294: 			return;
295: 		}
296: 		if (result->HasError()) {
297: 			cb.MakeCallback(statement.Value(), {Utils::CreateError(env, result->GetError())});
298: 			return;
299: 		}
300: 
301: 		switch (run_type) {
302: 		case RunType::RUN:
303: 			cb.MakeCallback(statement.Value(), {env.Null()});
304: 			break;
305: 		case RunType::EACH: {
306: 			duckdb::idx_t count = 0;
307: 			while (true) {
308: 				Napi::HandleScope scope(env);
309: 
310: 				auto chunk = result->Fetch();
311: 				if (!chunk || chunk->size() == 0) {
312: 					break;
313: 				}
314: 
315: 				auto chunk_converted = convert_chunk(env, result->names, *chunk).ToObject();
316: 				if (!chunk_converted.IsArray()) {
317: 					// error was set before
318: 					return;
319: 				}
320: 				for (duckdb::idx_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
321: 					cb.MakeCallback(statement.Value(), {env.Null(), chunk_converted.Get(row_idx)});
322: 					count++;
323: 				}
324: 			}
325: 			if (!params->complete.IsUndefined() && params->complete.IsFunction()) {
326: 				params->complete.MakeCallback(statement.Value(), {env.Null(), Napi::Number::New(env, count)});
327: 			}
328: 			break;
329: 		}
330: 		case RunType::ALL: {
331: 			auto materialized_result = (duckdb::MaterializedQueryResult *)result.get();
332: 			Napi::Array result_arr(Napi::Array::New(env, materialized_result->RowCount()));
333: 
334: 			duckdb::idx_t out_idx = 0;
335: 			while (true) {
336: 				auto chunk = result->Fetch();
337: 				if (!chunk || chunk->size() == 0) {
338: 					break;
339: 				}
340: 				// ToObject has to happen here otherwise the converted chunk gets garbage collected for some reason
341: 				auto chunk_converted = convert_chunk(env, result->names, *chunk).ToObject();
342: 				if (!chunk_converted.IsArray()) {
343: 					// error was set before
344: 					return;
345: 				}
346: 				for (duckdb::idx_t row_idx = 0; row_idx < chunk->size(); row_idx++) {
347: 					result_arr.Set(out_idx++, chunk_converted.Get(row_idx));
348: 				}
349: 			}
350: 
351: 			cb.MakeCallback(statement.Value(), {env.Null(), result_arr});
352: 		} break;
353: 		}
354: 	}
355: 	std::unique_ptr<duckdb::QueryResult> result;
356: 	duckdb::unique_ptr<StatementParam> params;
357: 	RunType run_type;
358: };
359: 
360: struct RunQueryTask : public Task {
361: 	RunQueryTask(Statement &statement, duckdb::unique_ptr<StatementParam> params, Napi::Promise::Deferred deferred)
362: 	    : Task(statement), deferred(deferred), params(move(params)) {
363: 	}
364: 
365: 	void DoWork() override {
366: 		auto &statement = Get<Statement>();
367: 		if (!statement.statement || statement.statement->HasError()) {
368: 			return;
369: 		}
370: 
371: 		result = statement.statement->Execute(params->params, true);
372: 	}
373: 
374: 	void DoCallback() override {
375: 		auto &statement = Get<Statement>();
376: 		Napi::Env env = statement.Env();
377: 		Napi::HandleScope scope(env);
378: 
379: 		if (!statement.statement) {
380: 			deferred.Reject(Utils::CreateError(env, "statement was finalized"));
381: 		} else if (statement.statement->HasError()) {
382: 			deferred.Reject(Utils::CreateError(env, statement.statement->GetError()));
383: 		} else if (result->HasError()) {
384: 			deferred.Reject(Utils::CreateError(env, result->GetError()));
385: 		} else {
386: 			auto db = statement.connection_ref->database_ref->Value();
387: 			auto query_result = QueryResult::constructor.New({db});
388: 			auto unwrapped = Napi::ObjectWrap<QueryResult>::Unwrap(query_result);
389: 			unwrapped->result = move(result);
390: 			deferred.Resolve(query_result);
391: 		}
392: 	}
393: 
394: 	Napi::Promise::Deferred deferred;
395: 	std::unique_ptr<duckdb::QueryResult> result;
396: 	duckdb::unique_ptr<StatementParam> params;
397: };
398: 
399: duckdb::unique_ptr<StatementParam> Statement::HandleArgs(const Napi::CallbackInfo &info) {
400: 	size_t start_idx = ignore_first_param ? 1 : 0;
401: 	auto params = duckdb::make_unique<StatementParam>();
402: 
403: 	for (auto i = start_idx; i < info.Length(); i++) {
404: 		auto &p = info[i];
405: 		if (p.IsFunction()) {
406: 			if (!params->callback.IsUndefined()) { // we already saw a callback, so this is the finalizer
407: 				params->complete = p.As<Napi::Function>();
408: 			} else {
409: 				params->callback = p.As<Napi::Function>();
410: 			}
411: 			continue;
412: 		}
413: 		if (p.IsUndefined()) {
414: 			continue;
415: 		}
416: 		params->params.push_back(BindParameter(p));
417: 	}
418: 	return params;
419: }
420: 
421: Napi::Value Statement::All(const Napi::CallbackInfo &info) {
422: 	connection_ref->database_ref->Schedule(info.Env(),
423: 	                                       duckdb::make_unique<RunPreparedTask>(*this, HandleArgs(info), RunType::ALL));
424: 	return info.This();
425: }
426: 
427: Napi::Value Statement::Run(const Napi::CallbackInfo &info) {
428: 	connection_ref->database_ref->Schedule(info.Env(),
429: 	                                       duckdb::make_unique<RunPreparedTask>(*this, HandleArgs(info), RunType::RUN));
430: 	return info.This();
431: }
432: 
433: Napi::Value Statement::Each(const Napi::CallbackInfo &info) {
434: 	connection_ref->database_ref->Schedule(
435: 	    info.Env(), duckdb::make_unique<RunPreparedTask>(*this, HandleArgs(info), RunType::EACH));
436: 	return info.This();
437: }
438: 
439: Napi::Value Statement::Stream(const Napi::CallbackInfo &info) {
440: 	auto deferred = Napi::Promise::Deferred::New(info.Env());
441: 	connection_ref->database_ref->Schedule(info.Env(),
442: 	                                       duckdb::make_unique<RunQueryTask>(*this, HandleArgs(info), deferred));
443: 	return deferred.Promise();
444: }
445: 
446: struct FinishTask : public Task {
447: 	FinishTask(Statement &statement, Napi::Function callback) : Task(statement, callback) {
448: 	}
449: 
450: 	void DoWork() override {
451: 		// TODO why does this break stuff?
452: 		// Get<Statement>().statement.reset();
453: 	}
454: };
455: 
456: Napi::Value Statement::Finish(const Napi::CallbackInfo &info) {
457: 	Napi::Env env = info.Env();
458: 	Napi::HandleScope scope(env);
459: 
460: 	Napi::Function callback;
461: 
462: 	if (info.Length() > 0 && info[0].IsFunction()) {
463: 		callback = info[0].As<Napi::Function>();
464: 	}
465: 
466: 	connection_ref->database_ref->Schedule(env, duckdb::make_unique<FinishTask>(*this, callback));
467: 	return env.Null();
468: }
469: 
470: Napi::FunctionReference QueryResult::constructor;
471: 
472: Napi::Object QueryResult::Init(Napi::Env env, Napi::Object exports) {
473: 	Napi::HandleScope scope(env);
474: 
475: 	Napi::Function t = DefineClass(env, "QueryResult", {InstanceMethod("nextChunk", &QueryResult::NextChunk)});
476: 
477: 	constructor = Napi::Persistent(t);
478: 	constructor.SuppressDestruct();
479: 
480: 	exports.Set("QueryResult", t);
481: 	return exports;
482: }
483: 
484: QueryResult::QueryResult(const Napi::CallbackInfo &info) : Napi::ObjectWrap<QueryResult>(info) {
485: 	database_ref = Napi::ObjectWrap<Database>::Unwrap(info[0].As<Napi::Object>());
486: 	database_ref->Ref();
487: }
488: 
489: QueryResult::~QueryResult() {
490: 	database_ref->Unref();
491: 	database_ref = nullptr;
492: }
493: 
494: struct GetChunkTask : public Task {
495: 	GetChunkTask(QueryResult &query_result, Napi::Promise::Deferred deferred) : Task(query_result), deferred(deferred) {
496: 	}
497: 
498: 	void DoWork() override {
499: 		auto &query_result = Get<QueryResult>();
500: 		chunk = query_result.result->Fetch();
501: 	}
502: 
503: 	void DoCallback() override {
504: 		auto &query_result = Get<QueryResult>();
505: 		Napi::Env env = query_result.Env();
506: 		Napi::HandleScope scope(env);
507: 
508: 		if (chunk == nullptr || chunk->size() == 0) {
509: 			deferred.Resolve(env.Null());
510: 			return;
511: 		}
512: 
513: 		auto chunk_converted = convert_chunk(env, query_result.result->names, *chunk).ToObject();
514: 		if (!chunk_converted.IsArray()) {
515: 			deferred.Reject(Utils::CreateError(env, "internal error: chunk is not array"));
516: 		} else {
517: 			deferred.Resolve(chunk_converted);
518: 		}
519: 	}
520: 
521: 	Napi::Promise::Deferred deferred;
522: 	std::unique_ptr<duckdb::DataChunk> chunk;
523: };
524: 
525: Napi::Value QueryResult::NextChunk(const Napi::CallbackInfo &info) {
526: 	auto env = info.Env();
527: 	auto deferred = Napi::Promise::Deferred::New(env);
528: 	database_ref->Schedule(env, duckdb::make_unique<GetChunkTask>(*this, deferred));
529: 
530: 	return deferred.Promise();
531: }
532: 
533: } // namespace node_duckdb
[end of tools/nodejs/src/statement.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: