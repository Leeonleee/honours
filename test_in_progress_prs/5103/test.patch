diff --git a/test/sql/aggregate/aggregates/test_quantile_cont.test b/test/sql/aggregate/aggregates/test_quantile_cont.test
index c2ff06787b61..a289059f3944 100644
--- a/test/sql/aggregate/aggregates/test_quantile_cont.test
+++ b/test/sql/aggregate/aggregates/test_quantile_cont.test
@@ -104,8 +104,6 @@ SELECT quantile_cont('00:00:00'::TIME + interval (r/100) second, 0.5) FROM quant
 
 statement error
 SELECT quantile_cont(interval (r/100) second, 0.5) FROM quantile
-----
-01:23:19
 
 # WITH TIME ZONE
 query I
diff --git a/test/sql/aggregate/aggregates/test_quantile_cont_list.test b/test/sql/aggregate/aggregates/test_quantile_cont_list.test
index 440aeb857eee..d7656027cbeb 100644
--- a/test/sql/aggregate/aggregates/test_quantile_cont_list.test
+++ b/test/sql/aggregate/aggregates/test_quantile_cont_list.test
@@ -34,8 +34,6 @@ FROM quantiles
 
 statement error
 SELECT quantile_cont(interval (r/100) second, [0.25, 0.5, 0.75]) FROM quantiles
-----
-[00:16:39, 01:23:19, 02:29:59]
 
 # single GROUP
 query R
diff --git a/test/sql/aggregate/qualify/test_qualify.test b/test/sql/aggregate/qualify/test_qualify.test
index fcd745194011..aa313317227a 100644
--- a/test/sql/aggregate/qualify/test_qualify.test
+++ b/test/sql/aggregate/qualify/test_qualify.test
@@ -130,7 +130,6 @@ SELECT b, SUM(a) AS sum FROM test GROUP BY b QUALIFY row_number() OVER (PARTITIO
 # expression in qualify
 statement ok
 SELECT b, SUM(a) AS sum FROM test GROUP BY b QUALIFY row_number() OVER (PARTITION BY b) > sum * 10;
-----
 
 query ITI
 SELECT * FROM qt QUALIFY row_number() OVER (PARTITION BY b ORDER BY c) = (SELECT max(c) FROM qt) ORDER BY b;
diff --git a/test/sql/binder/test_having_alias.test b/test/sql/binder/test_having_alias.test
index 1218ddfdddde..cba977aa331a 100644
--- a/test/sql/binder/test_having_alias.test
+++ b/test/sql/binder/test_having_alias.test
@@ -52,8 +52,6 @@ SELECT COUNT(i) AS i FROM integers HAVING i=5;
 
 statement error
 SELECT COUNT(i) AS i FROM integers HAVING i=5 ORDER BY i;
-----
-5
 
 # use the same alias multiple times
 query I
diff --git a/test/sql/copy/csv/csv_error_message.test b/test/sql/copy/csv/csv_error_message.test
new file mode 100644
index 000000000000..43ab0915171d
--- /dev/null
+++ b/test/sql/copy/csv/csv_error_message.test
@@ -0,0 +1,22 @@
+# name: test/sql/copy/csv/csv_error_message.test
+# description: Various CSV reader error messages
+# group: [csv]
+
+statement ok
+PRAGMA enable_verification
+
+statement ok
+COPY (SELECT i::VARCHAR i FROM range(103) tbl(i) UNION ALL SELECT 'hello') TO '__TEST_DIR__/int_parse_error.csv' (HEADER, DELIMITER '|')
+
+statement error
+SELECT * FROM read_csv('__TEST_DIR__/int_parse_error.csv', columns={'i': 'INT'}, header=True)
+----
+line 105
+
+statement ok
+COPY (SELECT i::VARCHAR i FROM range(103) tbl(i) UNION ALL SELECT 'hello') TO '__TEST_DIR__/int_parse_error.csv' (HEADER 0, DELIMITER '|')
+
+statement error
+SELECT * FROM read_csv('__TEST_DIR__/int_parse_error.csv', columns={'i': 'INT'}, header=False)
+----
+line 104
diff --git a/test/sql/copy/csv/csv_null_byte.test b/test/sql/copy/csv/csv_null_byte.test
new file mode 100644
index 000000000000..6e0e30be1497
--- /dev/null
+++ b/test/sql/copy/csv/csv_null_byte.test
@@ -0,0 +1,26 @@
+# name: test/sql/copy/csv/csv_null_byte.test
+# description: Read a CSV with a null byte
+# group: [csv]
+
+statement ok
+PRAGMA enable_verification
+
+statement error
+select * from 'data/csv/nullbyte.csv';
+----
+line 2
+
+statement error
+select * from read_csv('data/csv/nullbyte.csv', columns={'col1': 'VARCHAR', 'col2': 'VARCHAR'}, delim='|');
+----
+line 2
+
+statement error
+select * from 'data/csv/nullbyte_header.csv';
+----
+line 1
+
+statement error
+select * from read_csv('data/csv/nullbyte_header.csv', columns={'col1': 'VARCHAR', 'col2': 'VARCHAR'}, delim='|', header=False);
+----
+line 1
diff --git a/test/sql/copy/csv/test_abac.test b/test/sql/copy/csv/test_abac.test
index 924c53d2dac7..05a1c63d2633 100644
--- a/test/sql/copy/csv/test_abac.test
+++ b/test/sql/copy/csv/test_abac.test
@@ -103,6 +103,8 @@ CREATE TABLE abac_tbl (a VARCHAR);
 
 statement error
 COPY abac_tbl FROM 'test/sql/copy/csv/data/abac/simple_unterminated_quote.csv' (QUOTE '"', AUTO_DETECT FALSE);
+----
+line 1
 
 statement ok
 DROP TABLE abac_tbl
@@ -160,6 +162,8 @@ CREATE TABLE abac_tbl (a VARCHAR);
 
 statement error
 COPY abac_tbl FROM 'test/sql/copy/csv/data/abac/unterminated_quote_escape.csv' (QUOTE '"', ESCAPE '"', AUTO_DETECT FALSE);
+----
+line 1
 
 statement ok
 DROP TABLE abac_tbl
@@ -170,6 +174,8 @@ CREATE TABLE abac_tbl (a VARCHAR);
 
 statement error
 COPY abac_tbl FROM 'test/sql/copy/csv/data/abac/unterminated_escape.csv' (QUOTE '"', ESCAPE '''', AUTO_DETECT FALSE);
+----
+1
 
 statement ok
 DROP TABLE abac_tbl
@@ -180,6 +186,8 @@ CREATE TABLE abac_tbl (a VARCHAR);
 
 statement error
 COPY abac_tbl FROM 'test/sql/copy/csv/data/abac/complex_unterminated_quote.csv' (QUOTE 'ABABAC', AUTO_DETECT FALSE);
+----
+1
 
 statement ok
 DROP TABLE abac_tbl
@@ -205,6 +213,8 @@ CREATE TABLE abac_tbl (a VARCHAR);
 
 statement error
 COPY abac_tbl FROM 'test/sql/copy/csv/data/abac/unterminated_quote_with_escape_complex.csv' (QUOTE 'ABAC', ESCAPE 'ABAB', AUTO_DETECT FALSE);
+----
+line 1
 
 statement ok
 DROP TABLE abac_tbl
@@ -215,6 +225,8 @@ CREATE TABLE abac_tbl (a VARCHAR);
 
 statement error
 COPY abac_tbl FROM 'test/sql/copy/csv/data/abac/unterminated_quote_escape_complex.csv' (QUOTE 'ABAC', ESCAPE 'ABAC', AUTO_DETECT FALSE);
+----
+line 1
 
 statement ok
 DROP TABLE abac_tbl
@@ -225,6 +237,8 @@ CREATE TABLE abac_tbl (a VARCHAR);
 
 statement error
 COPY abac_tbl FROM 'test/sql/copy/csv/data/abac/unterminated_escape_complex.csv' (QUOTE 'ABAC', ESCAPE 'ABAB', AUTO_DETECT FALSE);
+----
+line 1
 
 statement ok
 DROP TABLE abac_tbl
diff --git a/test/sql/copy/csv/test_dateformat.test b/test/sql/copy/csv/test_dateformat.test
index 2a87c4ceba40..5ff656eb8bf7 100644
--- a/test/sql/copy/csv/test_dateformat.test
+++ b/test/sql/copy/csv/test_dateformat.test
@@ -8,6 +8,8 @@ CREATE TABLE dates (d DATE);
 # base date format does not work here
 statement error
 COPY dates FROM 'test/sql/copy/csv/data/test/dateformat.csv' (AUTO_DETECT 0, HEADER 0)
+----
+line 1
 
 statement ok
 COPY dates FROM 'test/sql/copy/csv/data/test/dateformat.csv' (HEADER 0, DATEFORMAT '%d/%m/%Y')
diff --git a/test/sql/copy/csv/test_max_line_size.test_slow b/test/sql/copy/csv/test_max_line_size.test_slow
index 5e1818ede0f6..2fc9d17d8a63 100644
--- a/test/sql/copy/csv/test_max_line_size.test_slow
+++ b/test/sql/copy/csv/test_max_line_size.test_slow
@@ -22,6 +22,8 @@ CREATE TABLE test (a INTEGER, b VARCHAR, c INTEGER);
 # size by a small margin as the calculation is an estimate based on reads before parsing.
 statement error
 COPY test FROM '__TEST_DIR__/test.csv';
+----
+line 2
 
 # we can override the max line size
 statement ok
diff --git a/test/sql/function/timestamp/test_icu_dateadd.test b/test/sql/function/timestamp/test_icu_dateadd.test
index 8133e52471bf..28fb4e3b3523 100644
--- a/test/sql/function/timestamp/test_icu_dateadd.test
+++ b/test/sql/function/timestamp/test_icu_dateadd.test
@@ -276,8 +276,6 @@ SELECT ts + INTERVAL (-150) millisecond FROM limits WHERE label = 'tsmin';
 
 statement error
 SELECT ts + INTERVAL (-485) microsecond FROM limits WHERE label = 'tsmin';
-----
-290309-12-22 (BC) 00:00:00.000515+00
 
 # Backward from the maximum
 # UDate loses ms accuracy when close to the upper limit,
diff --git a/test/sql/order/test_limit_percent.test b/test/sql/order/test_limit_percent.test
index 4ea6215ef1a3..56ab42850ad2 100644
--- a/test/sql/order/test_limit_percent.test
+++ b/test/sql/order/test_limit_percent.test
@@ -142,7 +142,6 @@ SELECT * FROM test LIMIT 30% OFFSET RANDOM() / 10.0;
 
 statement ok
 SELECT b FROM test LIMIT 0%
-----
 
 #Subqueries that return negative values
 statement error
diff --git a/test/sql/prepared/prepare_default_varchar.test b/test/sql/prepared/prepare_default_varchar.test
index 215cae6712d9..5b609b53269c 100644
--- a/test/sql/prepared/prepare_default_varchar.test
+++ b/test/sql/prepared/prepare_default_varchar.test
@@ -139,8 +139,6 @@ time: 27
 
 statement error
 EXECUTE v7('hello world', [1, 2, 3])
-----
-hello world: [1, 2, 3]
 
 # unbound parameter with lists
 statement ok
diff --git a/test/sql/returning/returning_insert.test b/test/sql/returning/returning_insert.test
index 705212e9f98f..644dff6b1cf6 100644
--- a/test/sql/returning/returning_insert.test
+++ b/test/sql/returning/returning_insert.test
@@ -137,8 +137,6 @@ INSERT INTO table1 SELECT * from table1 RETURNING row_number() OVER (ORDER BY a)
 
 statement error
 INSERT INTO table1 VALUES (1, 2, 3) RETURNING [1, 2] IN (SELECT [a, b] from table1);
-----
-1
 
 # scalar subquery (should fail since scalar is a subquery)
 statement error
diff --git a/test/sql/storage/test_multiple_free_list_blocks.test_coverage b/test/sql/storage/test_multiple_free_list_blocks.test_coverage
deleted file mode 100644
index 0174b5f2ff8a..000000000000
--- a/test/sql/storage/test_multiple_free_list_blocks.test_coverage
+++ /dev/null
@@ -1,44 +0,0 @@
-# name: test/sql/storage/test_multiple_free_list_blocks.test_coverage
-# description: Test free_list with multiple blocks
-# group: [storage]
-
-require skip_reload
-
-
-load __TEST_DIR__/free_list_blocks.db
-
-statement ok
-PRAGMA debug_many_free_list_blocks=true
-
-statement ok
-CREATE TABLE integers(i INT, j INT)
-
-loop i 0 100
-
-statement ok
-DROP TABLE integers
-
-statement ok
-CREATE TABLE integers(i INT, j INT)
-
-statement ok
-INSERT INTO integers VALUES (1, 2), (2, 3), (1, 4);
-
-statement ok
-CHECKPOINT
-
-restart
-
-query II
-SELECT * FROM integers
-----
-1	2
-2	3
-1	4
-
-query I
-SELECT total_blocks * block_size < 10 * 262144 FROM pragma_database_size()
-----
-true
-
-endloop
diff --git a/test/sql/types/enum/test_enum_table.test b/test/sql/types/enum/test_enum_table.test
index 0b7e104536cc..d48f0067d382 100644
--- a/test/sql/types/enum/test_enum_table.test
+++ b/test/sql/types/enum/test_enum_table.test
@@ -217,8 +217,6 @@ ok
 
 statement error
 SELECT CAST ('bla' as mood)
-----
-ok
 
 query I
 SELECT TRY_CAST ('bla' as mood)
diff --git a/test/sqlite/result_helper.cpp b/test/sqlite/result_helper.cpp
index 78992aa3b688..9f50dcf13c77 100644
--- a/test/sqlite/result_helper.cpp
+++ b/test/sqlite/result_helper.cpp
@@ -263,6 +263,12 @@ bool TestResultHelper::CheckStatementResult(const Statement &statement, ExecuteC
 		} else {
 			expect_ok = true;
 		}
+		if (result.HasError() && !statement.expected_error.empty()) {
+			if (!StringUtil::Contains(result.GetError(), statement.expected_error)) {
+				logger.ExpectedErrorMismatch(statement.expected_error, result);
+				return false;
+			}
+		}
 	}
 
 	/* Report an error if the results do not match expectation */
diff --git a/test/sqlite/sqllogic_command.hpp b/test/sqlite/sqllogic_command.hpp
index 94c23d05f08a..6b4d180d26e1 100644
--- a/test/sqlite/sqllogic_command.hpp
+++ b/test/sqlite/sqllogic_command.hpp
@@ -68,6 +68,7 @@ class Statement : public Command {
 	Statement(SQLLogicTestRunner &runner);
 
 	bool expect_ok;
+	string expected_error;
 
 public:
 	void ExecuteInternal(ExecuteContext &context) const override;
diff --git a/test/sqlite/sqllogic_parser.cpp b/test/sqlite/sqllogic_parser.cpp
index b6c0a91076da..bdd1e89f3089 100644
--- a/test/sqlite/sqllogic_parser.cpp
+++ b/test/sqlite/sqllogic_parser.cpp
@@ -53,12 +53,12 @@ void SQLLogicParser::NextLine() {
 	current_line++;
 }
 
-string SQLLogicParser::ExtractStatement(bool is_query) {
+string SQLLogicParser::ExtractStatement() {
 	string statement;
 
 	bool first_line = true;
 	while (current_line < lines.size() && !EmptyOrComment(lines[current_line])) {
-		if (is_query && lines[current_line] == "----") {
+		if (lines[current_line] == "----") {
 			break;
 		}
 		if (!first_line) {
@@ -87,6 +87,27 @@ vector<string> SQLLogicParser::ExtractExpectedResult() {
 	return result;
 }
 
+string SQLLogicParser::ExtractExpectedError(bool expect_ok) {
+	// check if there is an expected error at all
+	if (current_line >= lines.size() || lines[current_line] != "----") {
+		return string();
+	}
+	if (expect_ok) {
+		Fail("Failed to parse statement: only statement error can have an expected error message, not statement ok");
+	}
+	current_line++;
+	string error;
+	while (current_line < lines.size() && !lines[current_line].empty()) {
+		if (error.empty()) {
+			error = lines[current_line];
+		} else {
+			Fail("Failed to parse statement error: expected single line error message");
+		}
+		current_line++;
+	}
+	return error;
+}
+
 void SQLLogicParser::FailRecursive(const string &msg, vector<ExceptionFormatValue> &values) {
 	auto error_message =
 	    file_name + ":" + to_string(current_line + 1) + ": " + ExceptionFormatValue::Format(msg, values);
diff --git a/test/sqlite/sqllogic_parser.hpp b/test/sqlite/sqllogic_parser.hpp
index b2cfee0d01ec..bad81495590f 100644
--- a/test/sqlite/sqllogic_parser.hpp
+++ b/test/sqlite/sqllogic_parser.hpp
@@ -73,11 +73,14 @@ class SQLLogicParser {
 	//! Extract a statement and move the current_line pointer forward
 	//! if "is_query" is false, the statement stops at the next empty line
 	//! if "is_query" is true, the statement stops at the next empty line or the next ----
-	string ExtractStatement(bool is_query);
+	string ExtractStatement();
 
 	//! Extract the expected result
 	vector<string> ExtractExpectedResult();
 
+	//! Extract the expected error (in case of statement error)
+	string ExtractExpectedError(bool expect_ok);
+
 	//! Tokenize the current line
 	SQLLogicToken Tokenize();
 
diff --git a/test/sqlite/sqllogic_test_logger.cpp b/test/sqlite/sqllogic_test_logger.cpp
index 06837812ab51..a3d21a368dc8 100644
--- a/test/sqlite/sqllogic_test_logger.cpp
+++ b/test/sqlite/sqllogic_test_logger.cpp
@@ -260,4 +260,13 @@ void SQLLogicTestLogger::UnexpectedStatement(bool expect_ok, MaterializedQueryRe
 	result.Print();
 }
 
+void SQLLogicTestLogger::ExpectedErrorMismatch(const string &expected_error, MaterializedQueryResult &result) {
+	PrintErrorHeader("Query failed, but error message did not match expected error message: " + expected_error);
+	PrintLineSep();
+	PrintSQL();
+	PrintHeader("Actual result:");
+	PrintLineSep();
+	result.Print();
+}
+
 } // namespace duckdb
diff --git a/test/sqlite/sqllogic_test_logger.hpp b/test/sqlite/sqllogic_test_logger.hpp
index 9b3438e96217..60a8c990d63d 100644
--- a/test/sqlite/sqllogic_test_logger.hpp
+++ b/test/sqlite/sqllogic_test_logger.hpp
@@ -47,6 +47,7 @@ class SQLLogicTestLogger {
 	void SplitMismatch(idx_t row_number, idx_t expected_column_count, idx_t split_count);
 	void WrongResultHash(QueryResult *expected_result, MaterializedQueryResult &result);
 	void UnexpectedStatement(bool expect_ok, MaterializedQueryResult &result);
+	void ExpectedErrorMismatch(const string &expected_error, MaterializedQueryResult &result);
 
 private:
 	lock_guard<mutex> log_lock;
diff --git a/test/sqlite/sqllogic_test_runner.cpp b/test/sqlite/sqllogic_test_runner.cpp
index e1753345d0bd..af6dc5812483 100644
--- a/test/sqlite/sqllogic_test_runner.cpp
+++ b/test/sqlite/sqllogic_test_runner.cpp
@@ -267,10 +267,11 @@ void SQLLogicTestRunner::ExecuteFile(string script) {
 
 			// extract the SQL statement
 			parser.NextLine();
-			auto statement_text = parser.ExtractStatement(false);
+			auto statement_text = parser.ExtractStatement();
 			if (statement_text.empty()) {
 				parser.Fail("Unexpected empty statement text");
 			}
+			command->expected_error = parser.ExtractExpectedError(command->expect_ok);
 
 			// perform any renames in the text
 			command->base_sql_query = ReplaceKeywords(move(statement_text));
@@ -304,7 +305,7 @@ void SQLLogicTestRunner::ExecuteFile(string script) {
 
 			// extract the SQL statement
 			parser.NextLine();
-			auto statement_text = parser.ExtractStatement(true);
+			auto statement_text = parser.ExtractStatement();
 
 			// perform any renames in the text
 			command->base_sql_query = ReplaceKeywords(move(statement_text));
diff --git a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java
index 9fe79473faaa..bb7ba4edc12f 100644
--- a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java
+++ b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java
@@ -2410,7 +2410,7 @@ public static void test_null_bytes_in_string() throws Exception {
 						stmt::executeQuery,
 						SQLException.class
 				);
-				assertEquals(message, "String value is not valid UTF8");
+				assertEquals(message, "Null-byte (\\0) detected in value construction");
 			}
 		}
 	}
