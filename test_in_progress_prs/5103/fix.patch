diff --git a/data/csv/nullbyte.csv b/data/csv/nullbyte.csv
new file mode 100644
index 000000000000..d3b081e0badd
Binary files /dev/null and b/data/csv/nullbyte.csv differ
diff --git a/data/csv/nullbyte_header.csv b/data/csv/nullbyte_header.csv
new file mode 100644
index 000000000000..e96bedde772f
Binary files /dev/null and b/data/csv/nullbyte_header.csv differ
diff --git a/scripts/generate_extensions_function.py b/scripts/generate_extensions_function.py
index 01249b97c697..16c27118e5cf 100644
--- a/scripts/generate_extensions_function.py
+++ b/scripts/generate_extensions_function.py
@@ -60,7 +60,7 @@
     })
 
 if args.validate:
-    file = open(os.path.join("..","src","include","extension_functions.hpp"),'r')
+    file = open(os.path.join("..","src","include","duckdb", "main", "extension_functions.hpp"),'r')
     pattern = re.compile("{\"(.*?)\", \"(.*?)\"},")
     cur_function_map = dict(pattern.findall(file.read()))
     print("Cur Function Map: ")
@@ -83,11 +83,11 @@
         exit(1)
 else:
     # Generate Header
-    file = open(os.path.join("..","src","include","extension_functions.hpp"),'w')
+    file = open(os.path.join("..","src","include","duckdb", "main", "extension_functions.hpp"),'w')
     header = """//===----------------------------------------------------------------------===//
 //                         DuckDB
 //
-// extension_functions.hpp
+// duckdb/main/extension_functions.hpp
 //
 //
 //===----------------------------------------------------------------------===//
diff --git a/src/catalog/catalog.cpp b/src/catalog/catalog.cpp
index 40367ff24306..fcc380fb9275 100644
--- a/src/catalog/catalog.cpp
+++ b/src/catalog/catalog.cpp
@@ -27,7 +27,7 @@
 #include "duckdb/planner/parsed_data/bound_create_table_info.hpp"
 #include "duckdb/planner/binder.hpp"
 #include "duckdb/catalog/default/default_types.hpp"
-#include "extension_functions.hpp"
+#include "duckdb/main/extension_functions.hpp"
 #include <algorithm>
 namespace duckdb {
 
diff --git a/src/common/types/value.cpp b/src/common/types/value.cpp
index 82b900f59a3e..0e12ab984280 100644
--- a/src/common/types/value.cpp
+++ b/src/common/types/value.cpp
@@ -27,6 +27,7 @@
 #include "duckdb/common/types/cast_helpers.hpp"
 #include "duckdb/common/types/hash.hpp"
 #include "duckdb/function/cast/cast_function_set.hpp"
+#include "duckdb/main/error_manager.hpp"
 
 #include <utility>
 #include <cmath>
@@ -63,7 +64,7 @@ Value::Value(string_t val) : Value(string(val.GetDataUnsafe(), val.GetSize())) {
 
 Value::Value(string val) : type_(LogicalType::VARCHAR), is_null(false), str_value(move(val)) {
 	if (!Value::StringIsValid(str_value.c_str(), str_value.size())) {
-		throw Exception("String value is not valid UTF8");
+		throw Exception(ErrorManager::InvalidUnicodeError(str_value, "value construction"));
 	}
 }
 
diff --git a/src/execution/operator/persistent/buffered_csv_reader.cpp b/src/execution/operator/persistent/buffered_csv_reader.cpp
index 8555042b4b6f..5608aa05196e 100644
--- a/src/execution/operator/persistent/buffered_csv_reader.cpp
+++ b/src/execution/operator/persistent/buffered_csv_reader.cpp
@@ -14,6 +14,7 @@
 #include "utf8proc_wrapper.hpp"
 #include "utf8proc.hpp"
 #include "duckdb/parser/keyword_helper.hpp"
+#include "duckdb/main/error_manager.hpp"
 
 #include <algorithm>
 #include <cctype>
@@ -1048,8 +1049,10 @@ void BufferedCSVReader::DetectCandidateTypes(const vector<LogicalType> &type_can
 					// try cast from string to sql_type
 					Value dummy_val;
 					if (is_header_row) {
+						VerifyUTF8(col, 0, header_row, -int64_t(parse_chunk.size()));
 						dummy_val = header_row.GetValue(col, 0);
 					} else {
+						VerifyUTF8(col, row, parse_chunk);
 						dummy_val = parse_chunk.GetValue(col, row);
 					}
 					// try formatting for date types if the user did not specify one and it starts with numeric values.
@@ -1903,9 +1906,9 @@ void BufferedCSVReader::AddValue(char *str_val, idx_t length, idx_t &column, vec
 			error_column_overflow = true;
 			return;
 		} else {
-			throw InvalidInputException("Error on line %s: expected %lld values per row, but got more. (%s)",
-			                            GetLineNumberStr(linenr, linenr_estimated).c_str(), sql_types.size(),
-			                            options.ToString());
+			throw InvalidInputException(
+			    "Error in file \"%s\", on line %s: expected %lld values per row, but got more. (%s)", options.file_path,
+			    GetLineNumberStr(linenr, linenr_estimated).c_str(), sql_types.size(), options.ToString());
 		}
 	}
 
@@ -1975,9 +1978,9 @@ bool BufferedCSVReader::AddRow(DataChunk &insert_chunk, idx_t &column) {
 			column = 0;
 			return false;
 		} else {
-			throw InvalidInputException("Error on line %s: expected %lld values per row, but got %d. (%s)",
-			                            GetLineNumberStr(linenr, linenr_estimated).c_str(), sql_types.size(), column,
-			                            options.ToString());
+			throw InvalidInputException(
+			    "Error in file \"%s\" on line %s: expected %lld values per row, but got %d. (%s)", options.file_path,
+			    GetLineNumberStr(linenr, linenr_estimated).c_str(), sql_types.size(), column, options.ToString());
 		}
 	}
 
@@ -2015,6 +2018,38 @@ void BufferedCSVReader::SetNullUnionCols(DataChunk &insert_chunk) {
 	}
 }
 
+void BufferedCSVReader::VerifyUTF8(idx_t col_idx, idx_t row_idx, DataChunk &chunk, int64_t offset) {
+	D_ASSERT(col_idx < chunk.data.size());
+	D_ASSERT(row_idx < chunk.size());
+	auto &v = chunk.data[col_idx];
+	if (FlatVector::IsNull(v, row_idx)) {
+		return;
+	}
+
+	auto parse_data = FlatVector::GetData<string_t>(chunk.data[col_idx]);
+	auto s = parse_data[row_idx];
+	auto utf_type = Utf8Proc::Analyze(s.GetDataUnsafe(), s.GetSize());
+	if (utf_type == UnicodeType::INVALID) {
+		string col_name = to_string(col_idx);
+		if (col_idx < col_names.size()) {
+			col_name = "\"" + col_names[col_idx] + "\"";
+		}
+		int64_t error_line = linenr - (chunk.size() - row_idx) + 1 + offset;
+		D_ASSERT(error_line >= 0);
+		throw InvalidInputException("Error in file \"%s\" at line %llu in column \"%s\": "
+		                            "%s. Parser options: %s",
+		                            options.file_path, error_line, col_name,
+		                            ErrorManager::InvalidUnicodeError(s.GetString(), "CSV file"), options.ToString());
+	}
+}
+
+void BufferedCSVReader::VerifyUTF8(idx_t col_idx) {
+	D_ASSERT(col_idx < parse_chunk.data.size());
+	for (idx_t i = 0; i < parse_chunk.size(); i++) {
+		VerifyUTF8(col_idx, i, parse_chunk);
+	}
+}
+
 void BufferedCSVReader::Flush(DataChunk &insert_chunk) {
 	if (parse_chunk.size() == 0) {
 		return;
@@ -2028,23 +2063,7 @@ void BufferedCSVReader::Flush(DataChunk &insert_chunk) {
 		if (sql_types[col_idx].id() == LogicalTypeId::VARCHAR) {
 			// target type is varchar: no need to convert
 			// just test that all strings are valid utf-8 strings
-			auto parse_data = FlatVector::GetData<string_t>(parse_chunk.data[col_idx]);
-			for (idx_t i = 0; i < parse_chunk.size(); i++) {
-				if (!FlatVector::IsNull(parse_chunk.data[col_idx], i)) {
-					auto s = parse_data[i];
-					auto utf_type = Utf8Proc::Analyze(s.GetDataUnsafe(), s.GetSize());
-					if (utf_type == UnicodeType::INVALID) {
-						string col_name = to_string(col_idx);
-						if (col_idx < col_names.size()) {
-							col_name = "\"" + col_names[col_idx] + "\"";
-						}
-						throw InvalidInputException("Error in file \"%s\" between line %llu and %llu in column \"%s\": "
-						                            "file is not valid UTF8. Parser options: %s",
-						                            options.file_path, linenr - parse_chunk.size(), linenr, col_name,
-						                            options.ToString());
-					}
-				}
-			}
+			VerifyUTF8(col_idx);
 			insert_chunk.data[insert_cols_idx[col_idx]].Reference(parse_chunk.data[col_idx]);
 		} else {
 			string error_message;
@@ -2078,17 +2097,27 @@ void BufferedCSVReader::Flush(DataChunk &insert_chunk) {
 				col_name = "\"" + col_names[col_idx] + "\"";
 			}
 
+			// figure out the exact line number
+			idx_t row_idx;
+			for (row_idx = 0; row_idx < parse_chunk.size(); row_idx++) {
+				auto &inserted_column = insert_chunk.data[col_idx];
+				auto &parsed_column = parse_chunk.data[col_idx];
+
+				if (FlatVector::IsNull(inserted_column, row_idx) && !FlatVector::IsNull(parsed_column, row_idx)) {
+					break;
+				}
+			}
+			auto error_line = linenr - (parse_chunk.size() - row_idx) + 1;
+
 			if (options.auto_detect) {
-				throw InvalidInputException("%s in column %s, between line %llu and %llu. Parser "
+				throw InvalidInputException("%s in column %s, at line %llu. Parser "
 				                            "options: %s. Consider either increasing the sample size "
 				                            "(SAMPLE_SIZE=X [X rows] or SAMPLE_SIZE=-1 [all rows]), "
 				                            "or skipping column conversion (ALL_VARCHAR=1)",
-				                            error_message, col_name, linenr - parse_chunk.size() + 1, linenr,
-				                            options.ToString());
+				                            error_message, col_name, error_line, options.ToString());
 			} else {
-				throw InvalidInputException("%s between line %llu and %llu in column %s. Parser options: %s ",
-				                            error_message, linenr - parse_chunk.size(), linenr, col_name,
-				                            options.ToString());
+				throw InvalidInputException("%s at line %llu in column %s. Parser options: %s ", error_message,
+				                            error_line, col_name, options.ToString());
 			}
 		}
 	}
diff --git a/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp b/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp
index deac4bc29c92..56e0669a12f6 100644
--- a/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp
+++ b/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp
@@ -288,6 +288,9 @@ class BufferedCSVReader {
 	                                        vector<vector<LogicalType>> &best_sql_types_candidates,
 	                                        map<LogicalTypeId, vector<string>> &best_format_candidates);
 
+	void VerifyUTF8(idx_t col_idx);
+	void VerifyUTF8(idx_t col_idx, idx_t row_idx, DataChunk &chunk, int64_t offset = 0);
+
 private:
 	//! Whether or not the current row's columns have overflown sql_types.size()
 	bool error_column_overflow = false;
diff --git a/src/include/duckdb/main/config.hpp b/src/include/duckdb/main/config.hpp
index dd42fb514f12..fbd10d947956 100644
--- a/src/include/duckdb/main/config.hpp
+++ b/src/include/duckdb/main/config.hpp
@@ -30,6 +30,7 @@
 namespace duckdb {
 class CastFunctionSet;
 class ClientContext;
+class ErrorManager;
 class CompressionFunction;
 class TableFunctionRef;
 
@@ -114,8 +115,6 @@ struct DBConfigOptions {
 	set<OptimizerType> disabled_optimizers;
 	//! Force a specific compression method to be used when checkpointing (if available)
 	CompressionType force_compression = CompressionType::COMPRESSION_AUTO;
-	//! Debug flag that adds additional (unnecessary) free_list blocks to the storage
-	bool debug_many_free_list_blocks = false;
 	//! Debug setting for window aggregation mode: (window, combine, separate)
 	WindowAggregationMode window_mode = WindowAggregationMode::WINDOW;
 	//! Whether or not preserving insertion order should be preserved
@@ -158,6 +157,8 @@ struct DBConfig {
 	vector<ParserExtension> parser_extensions;
 	//! Extensions made to the optimizer
 	vector<OptimizerExtension> optimizer_extensions;
+	//! Error manager
+	unique_ptr<ErrorManager> error_manager;
 
 	DUCKDB_API void AddExtensionOption(string name, string description, LogicalType parameter,
 	                                   set_option_callback_t function = nullptr);
diff --git a/src/include/duckdb/main/error_manager.hpp b/src/include/duckdb/main/error_manager.hpp
new file mode 100644
index 000000000000..e700a26050ba
--- /dev/null
+++ b/src/include/duckdb/main/error_manager.hpp
@@ -0,0 +1,59 @@
+//===----------------------------------------------------------------------===//
+//                         DuckDB
+//
+// duckdb/main/error_manager.hpp
+//
+//
+//===----------------------------------------------------------------------===//
+
+#pragma once
+
+#include "duckdb/common/common.hpp"
+#include "duckdb/common/exception.hpp"
+#include "duckdb/common/map.hpp"
+
+namespace duckdb {
+class ClientContext;
+class DatabaseInstance;
+
+enum class ErrorType : uint16_t {
+	// error message types
+	UNSIGNED_EXTENSION = 0,
+
+	// this should always be the last value
+	ERROR_COUNT,
+	INVALID = 65535,
+};
+
+//! The error manager class is responsible for formatting error messages
+//! It allows for error messages to be overridden by extensions and clients
+class ErrorManager {
+public:
+	template <typename... Args>
+	string FormatException(ErrorType error_type, Args... params) {
+		vector<ExceptionFormatValue> values;
+		return FormatExceptionRecursive(error_type, values, params...);
+	}
+
+	DUCKDB_API string FormatExceptionRecursive(ErrorType error_type, vector<ExceptionFormatValue> &values);
+
+	template <class T, typename... Args>
+	string FormatExceptionRecursive(ErrorType error_type, vector<ExceptionFormatValue> &values, T param,
+	                                Args... params) {
+		values.push_back(ExceptionFormatValue::CreateFormatValue<T>(param));
+		return FormatExceptionRecursive(error_type, values, params...);
+	}
+
+	DUCKDB_API static string InvalidUnicodeError(const string &input, const string &context);
+
+	//! Adds a custom error for a specific error type
+	void AddCustomError(ErrorType type, string new_error);
+
+	DUCKDB_API ErrorManager &Get(ClientContext &context);
+	DUCKDB_API ErrorManager &Get(DatabaseInstance &context);
+
+private:
+	map<ErrorType, string> custom_errors;
+};
+
+} // namespace duckdb
diff --git a/src/include/extension_functions.hpp b/src/include/duckdb/main/extension_functions.hpp
similarity index 98%
rename from src/include/extension_functions.hpp
rename to src/include/duckdb/main/extension_functions.hpp
index 168df86f6a8c..243f96a9cde9 100644
--- a/src/include/extension_functions.hpp
+++ b/src/include/duckdb/main/extension_functions.hpp
@@ -1,7 +1,7 @@
 //===----------------------------------------------------------------------===//
 //                         DuckDB
 //
-// extension_functions.hpp
+// duckdb/main/extension_functions.hpp
 //
 //
 //===----------------------------------------------------------------------===//
diff --git a/src/include/duckdb/main/settings.hpp b/src/include/duckdb/main/settings.hpp
index 8ca3459dd6c6..4d9055d69f5a 100644
--- a/src/include/duckdb/main/settings.hpp
+++ b/src/include/duckdb/main/settings.hpp
@@ -60,14 +60,6 @@ struct DebugForceNoCrossProduct {
 	static Value GetSetting(ClientContext &context);
 };
 
-struct DebugManyFreeListBlocks {
-	static constexpr const char *Name = "debug_many_free_list_blocks";
-	static constexpr const char *Description = "DEBUG SETTING: add additional blocks to the free list";
-	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
-	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
-	static Value GetSetting(ClientContext &context);
-};
-
 struct DebugWindowMode {
 	static constexpr const char *Name = "debug_window_mode";
 	static constexpr const char *Description = "DEBUG SETTING: switch window mode to use";
diff --git a/src/main/CMakeLists.txt b/src/main/CMakeLists.txt
index 523c620b8caa..65ccb4ba8a03 100644
--- a/src/main/CMakeLists.txt
+++ b/src/main/CMakeLists.txt
@@ -21,6 +21,7 @@ add_library_unity(
   connection.cpp
   database.cpp
   db_instance_cache.cpp
+  error_manager.cpp
   extension.cpp
   materialized_query_result.cpp
   pending_query_result.cpp
diff --git a/src/main/config.cpp b/src/main/config.cpp
index 003cca899a18..3710c767666f 100644
--- a/src/main/config.cpp
+++ b/src/main/config.cpp
@@ -28,7 +28,6 @@ static ConfigurationOption internal_options[] = {DUCKDB_GLOBAL(AccessModeSetting
                                                  DUCKDB_GLOBAL(DebugCheckpointAbort),
                                                  DUCKDB_LOCAL(DebugForceExternal),
                                                  DUCKDB_LOCAL(DebugForceNoCrossProduct),
-                                                 DUCKDB_GLOBAL(DebugManyFreeListBlocks),
                                                  DUCKDB_GLOBAL(DebugWindowMode),
                                                  DUCKDB_GLOBAL_LOCAL(DefaultCollationSetting),
                                                  DUCKDB_GLOBAL(DefaultOrderSetting),
diff --git a/src/main/database.cpp b/src/main/database.cpp
index 3ddda8a2ed61..5adf85e043d2 100644
--- a/src/main/database.cpp
+++ b/src/main/database.cpp
@@ -12,6 +12,7 @@
 #include "duckdb/main/extension_helper.hpp"
 #include "duckdb/main/replacement_opens.hpp"
 #include "duckdb/function/cast/cast_function_set.hpp"
+#include "duckdb/main/error_manager.hpp"
 
 #ifndef DUCKDB_NO_THREADS
 #include "duckdb/common/thread.hpp"
@@ -23,6 +24,7 @@ DBConfig::DBConfig() {
 	compression_functions = make_unique<CompressionFunctionSet>();
 	replacement_opens.push_back(ExtensionPrefixReplacementOpen());
 	cast_functions = make_unique<CastFunctionSet>();
+	error_manager = make_unique<ErrorManager>();
 }
 
 DBConfig::DBConfig(std::unordered_map<string, string> &config_dict, bool read_only) {
@@ -240,17 +242,15 @@ Allocator &Allocator::Get(DatabaseInstance &db) {
 }
 
 void DatabaseInstance::Configure(DBConfig &new_config) {
-	config.options.database_path = new_config.options.database_path;
-	config.options.access_mode = AccessMode::READ_WRITE;
-	if (new_config.options.access_mode != AccessMode::UNDEFINED) {
-		config.options.access_mode = new_config.options.access_mode;
+	config.options = new_config.options;
+	if (config.options.access_mode == AccessMode::UNDEFINED) {
+		config.options.access_mode = AccessMode::READ_WRITE;
 	}
 	if (new_config.file_system) {
 		config.file_system = move(new_config.file_system);
 	} else {
 		config.file_system = make_unique<VirtualFileSystem>();
 	}
-	config.options.maximum_memory = new_config.options.maximum_memory;
 	if (config.options.maximum_memory == (idx_t)-1) {
 		auto memory = FileSystem::GetAvailableMemory();
 		if (memory != DConstants::INVALID_INDEX) {
@@ -263,29 +263,15 @@ void DatabaseInstance::Configure(DBConfig &new_config) {
 #else
 		config.options.maximum_threads = 1;
 #endif
-	} else {
-		config.options.maximum_threads = new_config.options.maximum_threads;
 	}
-	config.options.external_threads = new_config.options.external_threads;
-	config.options.load_extensions = new_config.options.load_extensions;
-	config.options.force_compression = new_config.options.force_compression;
 	config.allocator = move(new_config.allocator);
 	if (!config.allocator) {
 		config.allocator = make_unique<Allocator>();
 	}
-	config.options.checkpoint_wal_size = new_config.options.checkpoint_wal_size;
-	config.options.use_direct_io = new_config.options.use_direct_io;
-	config.options.temporary_directory = new_config.options.temporary_directory;
-	config.options.collation = new_config.options.collation;
-	config.options.default_order_type = new_config.options.default_order_type;
-	config.options.default_null_order = new_config.options.default_null_order;
-	config.options.enable_external_access = new_config.options.enable_external_access;
-	config.options.allow_unsigned_extensions = new_config.options.allow_unsigned_extensions;
 	config.replacement_scans = move(new_config.replacement_scans);
-	config.replacement_opens = move(new_config.replacement_opens); // TODO is this okay?
-	config.options.initialize_default_database = new_config.options.initialize_default_database;
-	config.options.disabled_optimizers = move(new_config.options.disabled_optimizers);
+	config.replacement_opens = move(new_config.replacement_opens);
 	config.parser_extensions = move(new_config.parser_extensions);
+	config.error_manager = move(new_config.error_manager);
 }
 
 DBConfig &DBConfig::GetConfig(ClientContext &context) {
diff --git a/src/main/error_manager.cpp b/src/main/error_manager.cpp
new file mode 100644
index 000000000000..aba0074efaa3
--- /dev/null
+++ b/src/main/error_manager.cpp
@@ -0,0 +1,70 @@
+#include "duckdb/main/error_manager.hpp"
+#include "duckdb/main/config.hpp"
+#include "utf8proc_wrapper.hpp"
+
+namespace duckdb {
+
+struct DefaultError {
+	ErrorType type;
+	const char *error;
+};
+
+static DefaultError internal_errors[] = {
+    {ErrorType::UNSIGNED_EXTENSION,
+     "Extension \"%s\" could not be loaded because its signature is either missing or invalid and unsigned extensions "
+     "are disabled by configuration (allow_unsigned_extensions)"},
+    {ErrorType::INVALID, nullptr}};
+
+string ErrorManager::FormatExceptionRecursive(ErrorType error_type, vector<ExceptionFormatValue> &values) {
+	if (error_type >= ErrorType::ERROR_COUNT) {
+		throw InternalException("Invalid error type passed to ErrorManager::FormatError");
+	}
+	auto entry = custom_errors.find(error_type);
+	string error;
+	if (entry == custom_errors.end()) {
+		// error was not overwritten
+		error = internal_errors[int(error_type)].error;
+	} else {
+		// error was overwritten
+		error = entry->second;
+	}
+	return ExceptionFormatValue::Format(error, values);
+}
+
+string ErrorManager::InvalidUnicodeError(const string &input, const string &context) {
+	UnicodeInvalidReason reason;
+	size_t pos;
+	auto unicode = Utf8Proc::Analyze((const char *)input.c_str(), input.size(), &reason, &pos);
+	if (unicode != UnicodeType::INVALID) {
+		return "Invalid unicode error thrown but no invalid unicode detected in " + context;
+	}
+	string base_message;
+	switch (reason) {
+	case UnicodeInvalidReason::NULL_BYTE:
+		base_message = "Null-byte (\\0)";
+		break;
+	case UnicodeInvalidReason::BYTE_MISMATCH:
+		base_message = "Invalid unicode (byte sequence mismatch)";
+		break;
+	case UnicodeInvalidReason::INVALID_UNICODE:
+		base_message = "Invalid unicode";
+		break;
+	default:
+		break;
+	}
+	return base_message + " detected in " + context;
+}
+
+void ErrorManager::AddCustomError(ErrorType type, string new_error) {
+	custom_errors.insert(make_pair(type, move(new_error)));
+}
+
+ErrorManager &ErrorManager::Get(ClientContext &context) {
+	return *DBConfig::GetConfig(context).error_manager;
+}
+
+ErrorManager &ErrorManager::Get(DatabaseInstance &context) {
+	return *DBConfig::GetConfig(context).error_manager;
+}
+
+} // namespace duckdb
diff --git a/src/main/extension/extension_load.cpp b/src/main/extension/extension_load.cpp
index db9c43af1221..3b0528875c6b 100644
--- a/src/main/extension/extension_load.cpp
+++ b/src/main/extension/extension_load.cpp
@@ -2,6 +2,7 @@
 #include "duckdb/common/virtual_file_system.hpp"
 #include "duckdb/function/replacement_open.hpp"
 #include "duckdb/main/extension_helper.hpp"
+#include "duckdb/main/error_manager.hpp"
 #include "mbedtls_wrapper.hpp"
 
 namespace duckdb {
@@ -69,10 +70,7 @@ ExtensionInitResult ExtensionHelper::InitialLoad(DBConfig &config, FileOpener *o
 			}
 		}
 		if (!any_valid && !config.options.allow_unsigned_extensions) {
-			throw IOException(
-			    "Extension \"%s\" could not be loaded because its signature is either missing or "
-			    "invalid and unsigned extensions are disabled by configuration (allow_unsigned_extensions)",
-			    filename);
+			throw IOException(config.error_manager->FormatException(ErrorType::UNSIGNED_EXTENSION, filename));
 		}
 	}
 	auto lib_hdl = dlopen(filename.c_str(), RTLD_NOW | RTLD_LOCAL);
diff --git a/src/main/settings/settings.cpp b/src/main/settings/settings.cpp
index 81fdf044504a..53f70ac743e8 100644
--- a/src/main/settings/settings.cpp
+++ b/src/main/settings/settings.cpp
@@ -103,18 +103,6 @@ Value DebugForceNoCrossProduct::GetSetting(ClientContext &context) {
 	return Value::BOOLEAN(ClientConfig::GetConfig(context).force_no_cross_product);
 }
 
-//===--------------------------------------------------------------------===//
-// Debug Many Free List blocks
-//===--------------------------------------------------------------------===//
-void DebugManyFreeListBlocks::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
-	config.options.debug_many_free_list_blocks = input.GetValue<bool>();
-}
-
-Value DebugManyFreeListBlocks::GetSetting(ClientContext &context) {
-	auto &config = DBConfig::GetConfig(context);
-	return Value::BOOLEAN(config.options.debug_many_free_list_blocks);
-}
-
 //===--------------------------------------------------------------------===//
 // Debug Window Mode
 //===--------------------------------------------------------------------===//
diff --git a/src/storage/single_file_block_manager.cpp b/src/storage/single_file_block_manager.cpp
index 87609cf19ce9..39281a917913 100644
--- a/src/storage/single_file_block_manager.cpp
+++ b/src/storage/single_file_block_manager.cpp
@@ -317,10 +317,6 @@ vector<block_id_t> SingleFileBlockManager::GetFreeListBlocks() {
 		// a bit from the max block size
 		auto space_in_block = Storage::BLOCK_SIZE - 4 * sizeof(block_id_t);
 		auto total_blocks = (total_size + space_in_block - 1) / space_in_block;
-		auto &config = DBConfig::GetConfig(db);
-		if (config.options.debug_many_free_list_blocks) {
-			total_blocks++;
-		}
 		D_ASSERT(total_size > 0);
 		D_ASSERT(total_blocks > 0);
 
diff --git a/src/storage/statistics/string_statistics.cpp b/src/storage/statistics/string_statistics.cpp
index 4f81d6ff2ab2..681f29a9acf2 100644
--- a/src/storage/statistics/string_statistics.cpp
+++ b/src/storage/statistics/string_statistics.cpp
@@ -3,6 +3,7 @@
 #include "utf8proc_wrapper.hpp"
 #include "duckdb/common/string_util.hpp"
 #include "duckdb/common/types/vector.hpp"
+#include "duckdb/main/error_manager.hpp"
 
 namespace duckdb {
 
@@ -92,7 +93,8 @@ void StringStatistics::Update(const string_t &value) {
 		if (unicode == UnicodeType::UNICODE) {
 			has_unicode = true;
 		} else if (unicode == UnicodeType::INVALID) {
-			throw InternalException("Invalid unicode detected in segment statistics update!");
+			throw InternalException(
+			    ErrorManager::InvalidUnicodeError(string((char *)data, size), "segment statistics update"));
 		}
 	}
 }
diff --git a/tools/shell/shell.c b/tools/shell/shell.c
index f3143b289946..b293415c4068 100644
--- a/tools/shell/shell.c
+++ b/tools/shell/shell.c
@@ -20627,6 +20627,8 @@ int SQLITE_CDECL wmain(int argc, wchar_t **wargv){
       data.openMode = SHELL_OPEN_READONLY;
     }else if( strcmp(z,"-nofollow")==0 ){
       data.openFlags = SQLITE_OPEN_NOFOLLOW;
+    }else if( strcmp(z,"-unsigned")==0 ){
+      data.openFlags |= DUCKDB_UNSIGNED_EXTENSIONS;
 #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)
     }else if( strncmp(z, "-A",2)==0 ){
       /* All remaining command-line arguments are passed to the ".archive"
diff --git a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp
index 2363f34f103d..7e182d7f7233 100644
--- a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp
+++ b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp
@@ -10,6 +10,7 @@
 #include "duckdb/common/types.hpp"
 #include "duckdb/common/operator/cast_operators.hpp"
 #include "duckdb/common/preserved_error.hpp"
+#include "duckdb/main/error_manager.hpp"
 #include "utf8proc_wrapper.hpp"
 
 #include <ctype.h>
@@ -99,6 +100,11 @@ int sqlite3_open_v2(const char *filename, /* Database filename (UTF-8) */
 		if (flags & DUCKDB_UNSIGNED_EXTENSIONS) {
 			config.options.allow_unsigned_extensions = true;
 		}
+		config.error_manager->AddCustomError(
+		    ErrorType::UNSIGNED_EXTENSION,
+		    "Extension \"%s\" could not be loaded because its signature is either missing or invalid and unsigned "
+		    "extensions are disabled by configuration.
Start the shell with the -unsigned parameter to allow this "
+		    "(e.g. duckdb -unsigned).");
 		pDb->db = make_unique<DuckDB>(filename, &config);
 		pDb->db->LoadExtension<SQLAutoCompleteExtension>();
 		pDb->con = make_unique<Connection>(*pDb->db);
