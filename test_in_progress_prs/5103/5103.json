{
  "repo": "duckdb/duckdb",
  "pull_number": 5103,
  "instance_id": "duckdb__duckdb-5103",
  "issue_numbers": [
    "5011",
    "5022",
    "5022"
  ],
  "base_commit": "4697529877f42188bf4e6f0ece66fd6ebc5f88c5",
  "patch": "diff --git a/data/csv/nullbyte.csv b/data/csv/nullbyte.csv\nnew file mode 100644\nindex 000000000000..d3b081e0badd\nBinary files /dev/null and b/data/csv/nullbyte.csv differ\ndiff --git a/data/csv/nullbyte_header.csv b/data/csv/nullbyte_header.csv\nnew file mode 100644\nindex 000000000000..e96bedde772f\nBinary files /dev/null and b/data/csv/nullbyte_header.csv differ\ndiff --git a/scripts/generate_extensions_function.py b/scripts/generate_extensions_function.py\nindex 01249b97c697..16c27118e5cf 100644\n--- a/scripts/generate_extensions_function.py\n+++ b/scripts/generate_extensions_function.py\n@@ -60,7 +60,7 @@\n     })\n \n if args.validate:\n-    file = open(os.path.join(\"..\",\"src\",\"include\",\"extension_functions.hpp\"),'r')\n+    file = open(os.path.join(\"..\",\"src\",\"include\",\"duckdb\", \"main\", \"extension_functions.hpp\"),'r')\n     pattern = re.compile(\"{\\\"(.*?)\\\", \\\"(.*?)\\\"},\")\n     cur_function_map = dict(pattern.findall(file.read()))\n     print(\"Cur Function Map: \")\n@@ -83,11 +83,11 @@\n         exit(1)\n else:\n     # Generate Header\n-    file = open(os.path.join(\"..\",\"src\",\"include\",\"extension_functions.hpp\"),'w')\n+    file = open(os.path.join(\"..\",\"src\",\"include\",\"duckdb\", \"main\", \"extension_functions.hpp\"),'w')\n     header = \"\"\"//===----------------------------------------------------------------------===//\n //                         DuckDB\n //\n-// extension_functions.hpp\n+// duckdb/main/extension_functions.hpp\n //\n //\n //===----------------------------------------------------------------------===//\ndiff --git a/src/catalog/catalog.cpp b/src/catalog/catalog.cpp\nindex 40367ff24306..fcc380fb9275 100644\n--- a/src/catalog/catalog.cpp\n+++ b/src/catalog/catalog.cpp\n@@ -27,7 +27,7 @@\n #include \"duckdb/planner/parsed_data/bound_create_table_info.hpp\"\n #include \"duckdb/planner/binder.hpp\"\n #include \"duckdb/catalog/default/default_types.hpp\"\n-#include \"extension_functions.hpp\"\n+#include \"duckdb/main/extension_functions.hpp\"\n #include <algorithm>\n namespace duckdb {\n \ndiff --git a/src/common/types/value.cpp b/src/common/types/value.cpp\nindex 82b900f59a3e..0e12ab984280 100644\n--- a/src/common/types/value.cpp\n+++ b/src/common/types/value.cpp\n@@ -27,6 +27,7 @@\n #include \"duckdb/common/types/cast_helpers.hpp\"\n #include \"duckdb/common/types/hash.hpp\"\n #include \"duckdb/function/cast/cast_function_set.hpp\"\n+#include \"duckdb/main/error_manager.hpp\"\n \n #include <utility>\n #include <cmath>\n@@ -63,7 +64,7 @@ Value::Value(string_t val) : Value(string(val.GetDataUnsafe(), val.GetSize())) {\n \n Value::Value(string val) : type_(LogicalType::VARCHAR), is_null(false), str_value(move(val)) {\n \tif (!Value::StringIsValid(str_value.c_str(), str_value.size())) {\n-\t\tthrow Exception(\"String value is not valid UTF8\");\n+\t\tthrow Exception(ErrorManager::InvalidUnicodeError(str_value, \"value construction\"));\n \t}\n }\n \ndiff --git a/src/execution/operator/persistent/buffered_csv_reader.cpp b/src/execution/operator/persistent/buffered_csv_reader.cpp\nindex 8555042b4b6f..5608aa05196e 100644\n--- a/src/execution/operator/persistent/buffered_csv_reader.cpp\n+++ b/src/execution/operator/persistent/buffered_csv_reader.cpp\n@@ -14,6 +14,7 @@\n #include \"utf8proc_wrapper.hpp\"\n #include \"utf8proc.hpp\"\n #include \"duckdb/parser/keyword_helper.hpp\"\n+#include \"duckdb/main/error_manager.hpp\"\n \n #include <algorithm>\n #include <cctype>\n@@ -1048,8 +1049,10 @@ void BufferedCSVReader::DetectCandidateTypes(const vector<LogicalType> &type_can\n \t\t\t\t\t// try cast from string to sql_type\n \t\t\t\t\tValue dummy_val;\n \t\t\t\t\tif (is_header_row) {\n+\t\t\t\t\t\tVerifyUTF8(col, 0, header_row, -int64_t(parse_chunk.size()));\n \t\t\t\t\t\tdummy_val = header_row.GetValue(col, 0);\n \t\t\t\t\t} else {\n+\t\t\t\t\t\tVerifyUTF8(col, row, parse_chunk);\n \t\t\t\t\t\tdummy_val = parse_chunk.GetValue(col, row);\n \t\t\t\t\t}\n \t\t\t\t\t// try formatting for date types if the user did not specify one and it starts with numeric values.\n@@ -1903,9 +1906,9 @@ void BufferedCSVReader::AddValue(char *str_val, idx_t length, idx_t &column, vec\n \t\t\terror_column_overflow = true;\n \t\t\treturn;\n \t\t} else {\n-\t\t\tthrow InvalidInputException(\"Error on line %s: expected %lld values per row, but got more. (%s)\",\n-\t\t\t                            GetLineNumberStr(linenr, linenr_estimated).c_str(), sql_types.size(),\n-\t\t\t                            options.ToString());\n+\t\t\tthrow InvalidInputException(\n+\t\t\t    \"Error in file \\\"%s\\\", on line %s: expected %lld values per row, but got more. (%s)\", options.file_path,\n+\t\t\t    GetLineNumberStr(linenr, linenr_estimated).c_str(), sql_types.size(), options.ToString());\n \t\t}\n \t}\n \n@@ -1975,9 +1978,9 @@ bool BufferedCSVReader::AddRow(DataChunk &insert_chunk, idx_t &column) {\n \t\t\tcolumn = 0;\n \t\t\treturn false;\n \t\t} else {\n-\t\t\tthrow InvalidInputException(\"Error on line %s: expected %lld values per row, but got %d. (%s)\",\n-\t\t\t                            GetLineNumberStr(linenr, linenr_estimated).c_str(), sql_types.size(), column,\n-\t\t\t                            options.ToString());\n+\t\t\tthrow InvalidInputException(\n+\t\t\t    \"Error in file \\\"%s\\\" on line %s: expected %lld values per row, but got %d. (%s)\", options.file_path,\n+\t\t\t    GetLineNumberStr(linenr, linenr_estimated).c_str(), sql_types.size(), column, options.ToString());\n \t\t}\n \t}\n \n@@ -2015,6 +2018,38 @@ void BufferedCSVReader::SetNullUnionCols(DataChunk &insert_chunk) {\n \t}\n }\n \n+void BufferedCSVReader::VerifyUTF8(idx_t col_idx, idx_t row_idx, DataChunk &chunk, int64_t offset) {\n+\tD_ASSERT(col_idx < chunk.data.size());\n+\tD_ASSERT(row_idx < chunk.size());\n+\tauto &v = chunk.data[col_idx];\n+\tif (FlatVector::IsNull(v, row_idx)) {\n+\t\treturn;\n+\t}\n+\n+\tauto parse_data = FlatVector::GetData<string_t>(chunk.data[col_idx]);\n+\tauto s = parse_data[row_idx];\n+\tauto utf_type = Utf8Proc::Analyze(s.GetDataUnsafe(), s.GetSize());\n+\tif (utf_type == UnicodeType::INVALID) {\n+\t\tstring col_name = to_string(col_idx);\n+\t\tif (col_idx < col_names.size()) {\n+\t\t\tcol_name = \"\\\"\" + col_names[col_idx] + \"\\\"\";\n+\t\t}\n+\t\tint64_t error_line = linenr - (chunk.size() - row_idx) + 1 + offset;\n+\t\tD_ASSERT(error_line >= 0);\n+\t\tthrow InvalidInputException(\"Error in file \\\"%s\\\" at line %llu in column \\\"%s\\\": \"\n+\t\t                            \"%s. Parser options: %s\",\n+\t\t                            options.file_path, error_line, col_name,\n+\t\t                            ErrorManager::InvalidUnicodeError(s.GetString(), \"CSV file\"), options.ToString());\n+\t}\n+}\n+\n+void BufferedCSVReader::VerifyUTF8(idx_t col_idx) {\n+\tD_ASSERT(col_idx < parse_chunk.data.size());\n+\tfor (idx_t i = 0; i < parse_chunk.size(); i++) {\n+\t\tVerifyUTF8(col_idx, i, parse_chunk);\n+\t}\n+}\n+\n void BufferedCSVReader::Flush(DataChunk &insert_chunk) {\n \tif (parse_chunk.size() == 0) {\n \t\treturn;\n@@ -2028,23 +2063,7 @@ void BufferedCSVReader::Flush(DataChunk &insert_chunk) {\n \t\tif (sql_types[col_idx].id() == LogicalTypeId::VARCHAR) {\n \t\t\t// target type is varchar: no need to convert\n \t\t\t// just test that all strings are valid utf-8 strings\n-\t\t\tauto parse_data = FlatVector::GetData<string_t>(parse_chunk.data[col_idx]);\n-\t\t\tfor (idx_t i = 0; i < parse_chunk.size(); i++) {\n-\t\t\t\tif (!FlatVector::IsNull(parse_chunk.data[col_idx], i)) {\n-\t\t\t\t\tauto s = parse_data[i];\n-\t\t\t\t\tauto utf_type = Utf8Proc::Analyze(s.GetDataUnsafe(), s.GetSize());\n-\t\t\t\t\tif (utf_type == UnicodeType::INVALID) {\n-\t\t\t\t\t\tstring col_name = to_string(col_idx);\n-\t\t\t\t\t\tif (col_idx < col_names.size()) {\n-\t\t\t\t\t\t\tcol_name = \"\\\"\" + col_names[col_idx] + \"\\\"\";\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tthrow InvalidInputException(\"Error in file \\\"%s\\\" between line %llu and %llu in column \\\"%s\\\": \"\n-\t\t\t\t\t\t                            \"file is not valid UTF8. Parser options: %s\",\n-\t\t\t\t\t\t                            options.file_path, linenr - parse_chunk.size(), linenr, col_name,\n-\t\t\t\t\t\t                            options.ToString());\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\tVerifyUTF8(col_idx);\n \t\t\tinsert_chunk.data[insert_cols_idx[col_idx]].Reference(parse_chunk.data[col_idx]);\n \t\t} else {\n \t\t\tstring error_message;\n@@ -2078,17 +2097,27 @@ void BufferedCSVReader::Flush(DataChunk &insert_chunk) {\n \t\t\t\tcol_name = \"\\\"\" + col_names[col_idx] + \"\\\"\";\n \t\t\t}\n \n+\t\t\t// figure out the exact line number\n+\t\t\tidx_t row_idx;\n+\t\t\tfor (row_idx = 0; row_idx < parse_chunk.size(); row_idx++) {\n+\t\t\t\tauto &inserted_column = insert_chunk.data[col_idx];\n+\t\t\t\tauto &parsed_column = parse_chunk.data[col_idx];\n+\n+\t\t\t\tif (FlatVector::IsNull(inserted_column, row_idx) && !FlatVector::IsNull(parsed_column, row_idx)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tauto error_line = linenr - (parse_chunk.size() - row_idx) + 1;\n+\n \t\t\tif (options.auto_detect) {\n-\t\t\t\tthrow InvalidInputException(\"%s in column %s, between line %llu and %llu. Parser \"\n+\t\t\t\tthrow InvalidInputException(\"%s in column %s, at line %llu. Parser \"\n \t\t\t\t                            \"options: %s. Consider either increasing the sample size \"\n \t\t\t\t                            \"(SAMPLE_SIZE=X [X rows] or SAMPLE_SIZE=-1 [all rows]), \"\n \t\t\t\t                            \"or skipping column conversion (ALL_VARCHAR=1)\",\n-\t\t\t\t                            error_message, col_name, linenr - parse_chunk.size() + 1, linenr,\n-\t\t\t\t                            options.ToString());\n+\t\t\t\t                            error_message, col_name, error_line, options.ToString());\n \t\t\t} else {\n-\t\t\t\tthrow InvalidInputException(\"%s between line %llu and %llu in column %s. Parser options: %s \",\n-\t\t\t\t                            error_message, linenr - parse_chunk.size(), linenr, col_name,\n-\t\t\t\t                            options.ToString());\n+\t\t\t\tthrow InvalidInputException(\"%s at line %llu in column %s. Parser options: %s \", error_message,\n+\t\t\t\t                            error_line, col_name, options.ToString());\n \t\t\t}\n \t\t}\n \t}\ndiff --git a/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp b/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp\nindex deac4bc29c92..56e0669a12f6 100644\n--- a/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp\n+++ b/src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp\n@@ -288,6 +288,9 @@ class BufferedCSVReader {\n \t                                        vector<vector<LogicalType>> &best_sql_types_candidates,\n \t                                        map<LogicalTypeId, vector<string>> &best_format_candidates);\n \n+\tvoid VerifyUTF8(idx_t col_idx);\n+\tvoid VerifyUTF8(idx_t col_idx, idx_t row_idx, DataChunk &chunk, int64_t offset = 0);\n+\n private:\n \t//! Whether or not the current row's columns have overflown sql_types.size()\n \tbool error_column_overflow = false;\ndiff --git a/src/include/duckdb/main/config.hpp b/src/include/duckdb/main/config.hpp\nindex dd42fb514f12..fbd10d947956 100644\n--- a/src/include/duckdb/main/config.hpp\n+++ b/src/include/duckdb/main/config.hpp\n@@ -30,6 +30,7 @@\n namespace duckdb {\n class CastFunctionSet;\n class ClientContext;\n+class ErrorManager;\n class CompressionFunction;\n class TableFunctionRef;\n \n@@ -114,8 +115,6 @@ struct DBConfigOptions {\n \tset<OptimizerType> disabled_optimizers;\n \t//! Force a specific compression method to be used when checkpointing (if available)\n \tCompressionType force_compression = CompressionType::COMPRESSION_AUTO;\n-\t//! Debug flag that adds additional (unnecessary) free_list blocks to the storage\n-\tbool debug_many_free_list_blocks = false;\n \t//! Debug setting for window aggregation mode: (window, combine, separate)\n \tWindowAggregationMode window_mode = WindowAggregationMode::WINDOW;\n \t//! Whether or not preserving insertion order should be preserved\n@@ -158,6 +157,8 @@ struct DBConfig {\n \tvector<ParserExtension> parser_extensions;\n \t//! Extensions made to the optimizer\n \tvector<OptimizerExtension> optimizer_extensions;\n+\t//! Error manager\n+\tunique_ptr<ErrorManager> error_manager;\n \n \tDUCKDB_API void AddExtensionOption(string name, string description, LogicalType parameter,\n \t                                   set_option_callback_t function = nullptr);\ndiff --git a/src/include/duckdb/main/error_manager.hpp b/src/include/duckdb/main/error_manager.hpp\nnew file mode 100644\nindex 000000000000..e700a26050ba\n--- /dev/null\n+++ b/src/include/duckdb/main/error_manager.hpp\n@@ -0,0 +1,59 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/main/error_manager.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/common/common.hpp\"\n+#include \"duckdb/common/exception.hpp\"\n+#include \"duckdb/common/map.hpp\"\n+\n+namespace duckdb {\n+class ClientContext;\n+class DatabaseInstance;\n+\n+enum class ErrorType : uint16_t {\n+\t// error message types\n+\tUNSIGNED_EXTENSION = 0,\n+\n+\t// this should always be the last value\n+\tERROR_COUNT,\n+\tINVALID = 65535,\n+};\n+\n+//! The error manager class is responsible for formatting error messages\n+//! It allows for error messages to be overridden by extensions and clients\n+class ErrorManager {\n+public:\n+\ttemplate <typename... Args>\n+\tstring FormatException(ErrorType error_type, Args... params) {\n+\t\tvector<ExceptionFormatValue> values;\n+\t\treturn FormatExceptionRecursive(error_type, values, params...);\n+\t}\n+\n+\tDUCKDB_API string FormatExceptionRecursive(ErrorType error_type, vector<ExceptionFormatValue> &values);\n+\n+\ttemplate <class T, typename... Args>\n+\tstring FormatExceptionRecursive(ErrorType error_type, vector<ExceptionFormatValue> &values, T param,\n+\t                                Args... params) {\n+\t\tvalues.push_back(ExceptionFormatValue::CreateFormatValue<T>(param));\n+\t\treturn FormatExceptionRecursive(error_type, values, params...);\n+\t}\n+\n+\tDUCKDB_API static string InvalidUnicodeError(const string &input, const string &context);\n+\n+\t//! Adds a custom error for a specific error type\n+\tvoid AddCustomError(ErrorType type, string new_error);\n+\n+\tDUCKDB_API ErrorManager &Get(ClientContext &context);\n+\tDUCKDB_API ErrorManager &Get(DatabaseInstance &context);\n+\n+private:\n+\tmap<ErrorType, string> custom_errors;\n+};\n+\n+} // namespace duckdb\ndiff --git a/src/include/extension_functions.hpp b/src/include/duckdb/main/extension_functions.hpp\nsimilarity index 98%\nrename from src/include/extension_functions.hpp\nrename to src/include/duckdb/main/extension_functions.hpp\nindex 168df86f6a8c..243f96a9cde9 100644\n--- a/src/include/extension_functions.hpp\n+++ b/src/include/duckdb/main/extension_functions.hpp\n@@ -1,7 +1,7 @@\n //===----------------------------------------------------------------------===//\n //                         DuckDB\n //\n-// extension_functions.hpp\n+// duckdb/main/extension_functions.hpp\n //\n //\n //===----------------------------------------------------------------------===//\ndiff --git a/src/include/duckdb/main/settings.hpp b/src/include/duckdb/main/settings.hpp\nindex 8ca3459dd6c6..4d9055d69f5a 100644\n--- a/src/include/duckdb/main/settings.hpp\n+++ b/src/include/duckdb/main/settings.hpp\n@@ -60,14 +60,6 @@ struct DebugForceNoCrossProduct {\n \tstatic Value GetSetting(ClientContext &context);\n };\n \n-struct DebugManyFreeListBlocks {\n-\tstatic constexpr const char *Name = \"debug_many_free_list_blocks\";\n-\tstatic constexpr const char *Description = \"DEBUG SETTING: add additional blocks to the free list\";\n-\tstatic constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;\n-\tstatic void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);\n-\tstatic Value GetSetting(ClientContext &context);\n-};\n-\n struct DebugWindowMode {\n \tstatic constexpr const char *Name = \"debug_window_mode\";\n \tstatic constexpr const char *Description = \"DEBUG SETTING: switch window mode to use\";\ndiff --git a/src/main/CMakeLists.txt b/src/main/CMakeLists.txt\nindex 523c620b8caa..65ccb4ba8a03 100644\n--- a/src/main/CMakeLists.txt\n+++ b/src/main/CMakeLists.txt\n@@ -21,6 +21,7 @@ add_library_unity(\n   connection.cpp\n   database.cpp\n   db_instance_cache.cpp\n+  error_manager.cpp\n   extension.cpp\n   materialized_query_result.cpp\n   pending_query_result.cpp\ndiff --git a/src/main/config.cpp b/src/main/config.cpp\nindex 003cca899a18..3710c767666f 100644\n--- a/src/main/config.cpp\n+++ b/src/main/config.cpp\n@@ -28,7 +28,6 @@ static ConfigurationOption internal_options[] = {DUCKDB_GLOBAL(AccessModeSetting\n                                                  DUCKDB_GLOBAL(DebugCheckpointAbort),\n                                                  DUCKDB_LOCAL(DebugForceExternal),\n                                                  DUCKDB_LOCAL(DebugForceNoCrossProduct),\n-                                                 DUCKDB_GLOBAL(DebugManyFreeListBlocks),\n                                                  DUCKDB_GLOBAL(DebugWindowMode),\n                                                  DUCKDB_GLOBAL_LOCAL(DefaultCollationSetting),\n                                                  DUCKDB_GLOBAL(DefaultOrderSetting),\ndiff --git a/src/main/database.cpp b/src/main/database.cpp\nindex 3ddda8a2ed61..5adf85e043d2 100644\n--- a/src/main/database.cpp\n+++ b/src/main/database.cpp\n@@ -12,6 +12,7 @@\n #include \"duckdb/main/extension_helper.hpp\"\n #include \"duckdb/main/replacement_opens.hpp\"\n #include \"duckdb/function/cast/cast_function_set.hpp\"\n+#include \"duckdb/main/error_manager.hpp\"\n \n #ifndef DUCKDB_NO_THREADS\n #include \"duckdb/common/thread.hpp\"\n@@ -23,6 +24,7 @@ DBConfig::DBConfig() {\n \tcompression_functions = make_unique<CompressionFunctionSet>();\n \treplacement_opens.push_back(ExtensionPrefixReplacementOpen());\n \tcast_functions = make_unique<CastFunctionSet>();\n+\terror_manager = make_unique<ErrorManager>();\n }\n \n DBConfig::DBConfig(std::unordered_map<string, string> &config_dict, bool read_only) {\n@@ -240,17 +242,15 @@ Allocator &Allocator::Get(DatabaseInstance &db) {\n }\n \n void DatabaseInstance::Configure(DBConfig &new_config) {\n-\tconfig.options.database_path = new_config.options.database_path;\n-\tconfig.options.access_mode = AccessMode::READ_WRITE;\n-\tif (new_config.options.access_mode != AccessMode::UNDEFINED) {\n-\t\tconfig.options.access_mode = new_config.options.access_mode;\n+\tconfig.options = new_config.options;\n+\tif (config.options.access_mode == AccessMode::UNDEFINED) {\n+\t\tconfig.options.access_mode = AccessMode::READ_WRITE;\n \t}\n \tif (new_config.file_system) {\n \t\tconfig.file_system = move(new_config.file_system);\n \t} else {\n \t\tconfig.file_system = make_unique<VirtualFileSystem>();\n \t}\n-\tconfig.options.maximum_memory = new_config.options.maximum_memory;\n \tif (config.options.maximum_memory == (idx_t)-1) {\n \t\tauto memory = FileSystem::GetAvailableMemory();\n \t\tif (memory != DConstants::INVALID_INDEX) {\n@@ -263,29 +263,15 @@ void DatabaseInstance::Configure(DBConfig &new_config) {\n #else\n \t\tconfig.options.maximum_threads = 1;\n #endif\n-\t} else {\n-\t\tconfig.options.maximum_threads = new_config.options.maximum_threads;\n \t}\n-\tconfig.options.external_threads = new_config.options.external_threads;\n-\tconfig.options.load_extensions = new_config.options.load_extensions;\n-\tconfig.options.force_compression = new_config.options.force_compression;\n \tconfig.allocator = move(new_config.allocator);\n \tif (!config.allocator) {\n \t\tconfig.allocator = make_unique<Allocator>();\n \t}\n-\tconfig.options.checkpoint_wal_size = new_config.options.checkpoint_wal_size;\n-\tconfig.options.use_direct_io = new_config.options.use_direct_io;\n-\tconfig.options.temporary_directory = new_config.options.temporary_directory;\n-\tconfig.options.collation = new_config.options.collation;\n-\tconfig.options.default_order_type = new_config.options.default_order_type;\n-\tconfig.options.default_null_order = new_config.options.default_null_order;\n-\tconfig.options.enable_external_access = new_config.options.enable_external_access;\n-\tconfig.options.allow_unsigned_extensions = new_config.options.allow_unsigned_extensions;\n \tconfig.replacement_scans = move(new_config.replacement_scans);\n-\tconfig.replacement_opens = move(new_config.replacement_opens); // TODO is this okay?\n-\tconfig.options.initialize_default_database = new_config.options.initialize_default_database;\n-\tconfig.options.disabled_optimizers = move(new_config.options.disabled_optimizers);\n+\tconfig.replacement_opens = move(new_config.replacement_opens);\n \tconfig.parser_extensions = move(new_config.parser_extensions);\n+\tconfig.error_manager = move(new_config.error_manager);\n }\n \n DBConfig &DBConfig::GetConfig(ClientContext &context) {\ndiff --git a/src/main/error_manager.cpp b/src/main/error_manager.cpp\nnew file mode 100644\nindex 000000000000..aba0074efaa3\n--- /dev/null\n+++ b/src/main/error_manager.cpp\n@@ -0,0 +1,70 @@\n+#include \"duckdb/main/error_manager.hpp\"\n+#include \"duckdb/main/config.hpp\"\n+#include \"utf8proc_wrapper.hpp\"\n+\n+namespace duckdb {\n+\n+struct DefaultError {\n+\tErrorType type;\n+\tconst char *error;\n+};\n+\n+static DefaultError internal_errors[] = {\n+    {ErrorType::UNSIGNED_EXTENSION,\n+     \"Extension \\\"%s\\\" could not be loaded because its signature is either missing or invalid and unsigned extensions \"\n+     \"are disabled by configuration (allow_unsigned_extensions)\"},\n+    {ErrorType::INVALID, nullptr}};\n+\n+string ErrorManager::FormatExceptionRecursive(ErrorType error_type, vector<ExceptionFormatValue> &values) {\n+\tif (error_type >= ErrorType::ERROR_COUNT) {\n+\t\tthrow InternalException(\"Invalid error type passed to ErrorManager::FormatError\");\n+\t}\n+\tauto entry = custom_errors.find(error_type);\n+\tstring error;\n+\tif (entry == custom_errors.end()) {\n+\t\t// error was not overwritten\n+\t\terror = internal_errors[int(error_type)].error;\n+\t} else {\n+\t\t// error was overwritten\n+\t\terror = entry->second;\n+\t}\n+\treturn ExceptionFormatValue::Format(error, values);\n+}\n+\n+string ErrorManager::InvalidUnicodeError(const string &input, const string &context) {\n+\tUnicodeInvalidReason reason;\n+\tsize_t pos;\n+\tauto unicode = Utf8Proc::Analyze((const char *)input.c_str(), input.size(), &reason, &pos);\n+\tif (unicode != UnicodeType::INVALID) {\n+\t\treturn \"Invalid unicode error thrown but no invalid unicode detected in \" + context;\n+\t}\n+\tstring base_message;\n+\tswitch (reason) {\n+\tcase UnicodeInvalidReason::NULL_BYTE:\n+\t\tbase_message = \"Null-byte (\\\\0)\";\n+\t\tbreak;\n+\tcase UnicodeInvalidReason::BYTE_MISMATCH:\n+\t\tbase_message = \"Invalid unicode (byte sequence mismatch)\";\n+\t\tbreak;\n+\tcase UnicodeInvalidReason::INVALID_UNICODE:\n+\t\tbase_message = \"Invalid unicode\";\n+\t\tbreak;\n+\tdefault:\n+\t\tbreak;\n+\t}\n+\treturn base_message + \" detected in \" + context;\n+}\n+\n+void ErrorManager::AddCustomError(ErrorType type, string new_error) {\n+\tcustom_errors.insert(make_pair(type, move(new_error)));\n+}\n+\n+ErrorManager &ErrorManager::Get(ClientContext &context) {\n+\treturn *DBConfig::GetConfig(context).error_manager;\n+}\n+\n+ErrorManager &ErrorManager::Get(DatabaseInstance &context) {\n+\treturn *DBConfig::GetConfig(context).error_manager;\n+}\n+\n+} // namespace duckdb\ndiff --git a/src/main/extension/extension_load.cpp b/src/main/extension/extension_load.cpp\nindex db9c43af1221..3b0528875c6b 100644\n--- a/src/main/extension/extension_load.cpp\n+++ b/src/main/extension/extension_load.cpp\n@@ -2,6 +2,7 @@\n #include \"duckdb/common/virtual_file_system.hpp\"\n #include \"duckdb/function/replacement_open.hpp\"\n #include \"duckdb/main/extension_helper.hpp\"\n+#include \"duckdb/main/error_manager.hpp\"\n #include \"mbedtls_wrapper.hpp\"\n \n namespace duckdb {\n@@ -69,10 +70,7 @@ ExtensionInitResult ExtensionHelper::InitialLoad(DBConfig &config, FileOpener *o\n \t\t\t}\n \t\t}\n \t\tif (!any_valid && !config.options.allow_unsigned_extensions) {\n-\t\t\tthrow IOException(\n-\t\t\t    \"Extension \\\"%s\\\" could not be loaded because its signature is either missing or \"\n-\t\t\t    \"invalid and unsigned extensions are disabled by configuration (allow_unsigned_extensions)\",\n-\t\t\t    filename);\n+\t\t\tthrow IOException(config.error_manager->FormatException(ErrorType::UNSIGNED_EXTENSION, filename));\n \t\t}\n \t}\n \tauto lib_hdl = dlopen(filename.c_str(), RTLD_NOW | RTLD_LOCAL);\ndiff --git a/src/main/settings/settings.cpp b/src/main/settings/settings.cpp\nindex 81fdf044504a..53f70ac743e8 100644\n--- a/src/main/settings/settings.cpp\n+++ b/src/main/settings/settings.cpp\n@@ -103,18 +103,6 @@ Value DebugForceNoCrossProduct::GetSetting(ClientContext &context) {\n \treturn Value::BOOLEAN(ClientConfig::GetConfig(context).force_no_cross_product);\n }\n \n-//===--------------------------------------------------------------------===//\n-// Debug Many Free List blocks\n-//===--------------------------------------------------------------------===//\n-void DebugManyFreeListBlocks::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {\n-\tconfig.options.debug_many_free_list_blocks = input.GetValue<bool>();\n-}\n-\n-Value DebugManyFreeListBlocks::GetSetting(ClientContext &context) {\n-\tauto &config = DBConfig::GetConfig(context);\n-\treturn Value::BOOLEAN(config.options.debug_many_free_list_blocks);\n-}\n-\n //===--------------------------------------------------------------------===//\n // Debug Window Mode\n //===--------------------------------------------------------------------===//\ndiff --git a/src/storage/single_file_block_manager.cpp b/src/storage/single_file_block_manager.cpp\nindex 87609cf19ce9..39281a917913 100644\n--- a/src/storage/single_file_block_manager.cpp\n+++ b/src/storage/single_file_block_manager.cpp\n@@ -317,10 +317,6 @@ vector<block_id_t> SingleFileBlockManager::GetFreeListBlocks() {\n \t\t// a bit from the max block size\n \t\tauto space_in_block = Storage::BLOCK_SIZE - 4 * sizeof(block_id_t);\n \t\tauto total_blocks = (total_size + space_in_block - 1) / space_in_block;\n-\t\tauto &config = DBConfig::GetConfig(db);\n-\t\tif (config.options.debug_many_free_list_blocks) {\n-\t\t\ttotal_blocks++;\n-\t\t}\n \t\tD_ASSERT(total_size > 0);\n \t\tD_ASSERT(total_blocks > 0);\n \ndiff --git a/src/storage/statistics/string_statistics.cpp b/src/storage/statistics/string_statistics.cpp\nindex 4f81d6ff2ab2..681f29a9acf2 100644\n--- a/src/storage/statistics/string_statistics.cpp\n+++ b/src/storage/statistics/string_statistics.cpp\n@@ -3,6 +3,7 @@\n #include \"utf8proc_wrapper.hpp\"\n #include \"duckdb/common/string_util.hpp\"\n #include \"duckdb/common/types/vector.hpp\"\n+#include \"duckdb/main/error_manager.hpp\"\n \n namespace duckdb {\n \n@@ -92,7 +93,8 @@ void StringStatistics::Update(const string_t &value) {\n \t\tif (unicode == UnicodeType::UNICODE) {\n \t\t\thas_unicode = true;\n \t\t} else if (unicode == UnicodeType::INVALID) {\n-\t\t\tthrow InternalException(\"Invalid unicode detected in segment statistics update!\");\n+\t\t\tthrow InternalException(\n+\t\t\t    ErrorManager::InvalidUnicodeError(string((char *)data, size), \"segment statistics update\"));\n \t\t}\n \t}\n }\ndiff --git a/tools/shell/shell.c b/tools/shell/shell.c\nindex f3143b289946..b293415c4068 100644\n--- a/tools/shell/shell.c\n+++ b/tools/shell/shell.c\n@@ -20627,6 +20627,8 @@ int SQLITE_CDECL wmain(int argc, wchar_t **wargv){\n       data.openMode = SHELL_OPEN_READONLY;\n     }else if( strcmp(z,\"-nofollow\")==0 ){\n       data.openFlags = SQLITE_OPEN_NOFOLLOW;\n+    }else if( strcmp(z,\"-unsigned\")==0 ){\n+      data.openFlags |= DUCKDB_UNSIGNED_EXTENSIONS;\n #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)\n     }else if( strncmp(z, \"-A\",2)==0 ){\n       /* All remaining command-line arguments are passed to the \".archive\"\ndiff --git a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\nindex 2363f34f103d..7e182d7f7233 100644\n--- a/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\n+++ b/tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp\n@@ -10,6 +10,7 @@\n #include \"duckdb/common/types.hpp\"\n #include \"duckdb/common/operator/cast_operators.hpp\"\n #include \"duckdb/common/preserved_error.hpp\"\n+#include \"duckdb/main/error_manager.hpp\"\n #include \"utf8proc_wrapper.hpp\"\n \n #include <ctype.h>\n@@ -99,6 +100,11 @@ int sqlite3_open_v2(const char *filename, /* Database filename (UTF-8) */\n \t\tif (flags & DUCKDB_UNSIGNED_EXTENSIONS) {\n \t\t\tconfig.options.allow_unsigned_extensions = true;\n \t\t}\n+\t\tconfig.error_manager->AddCustomError(\n+\t\t    ErrorType::UNSIGNED_EXTENSION,\n+\t\t    \"Extension \\\"%s\\\" could not be loaded because its signature is either missing or invalid and unsigned \"\n+\t\t    \"extensions are disabled by configuration.\\nStart the shell with the -unsigned parameter to allow this \"\n+\t\t    \"(e.g. duckdb -unsigned).\");\n \t\tpDb->db = make_unique<DuckDB>(filename, &config);\n \t\tpDb->db->LoadExtension<SQLAutoCompleteExtension>();\n \t\tpDb->con = make_unique<Connection>(*pDb->db);\n",
  "test_patch": "diff --git a/test/sql/aggregate/aggregates/test_quantile_cont.test b/test/sql/aggregate/aggregates/test_quantile_cont.test\nindex c2ff06787b61..a289059f3944 100644\n--- a/test/sql/aggregate/aggregates/test_quantile_cont.test\n+++ b/test/sql/aggregate/aggregates/test_quantile_cont.test\n@@ -104,8 +104,6 @@ SELECT quantile_cont('00:00:00'::TIME + interval (r/100) second, 0.5) FROM quant\n \n statement error\n SELECT quantile_cont(interval (r/100) second, 0.5) FROM quantile\n-----\n-01:23:19\n \n # WITH TIME ZONE\n query I\ndiff --git a/test/sql/aggregate/aggregates/test_quantile_cont_list.test b/test/sql/aggregate/aggregates/test_quantile_cont_list.test\nindex 440aeb857eee..d7656027cbeb 100644\n--- a/test/sql/aggregate/aggregates/test_quantile_cont_list.test\n+++ b/test/sql/aggregate/aggregates/test_quantile_cont_list.test\n@@ -34,8 +34,6 @@ FROM quantiles\n \n statement error\n SELECT quantile_cont(interval (r/100) second, [0.25, 0.5, 0.75]) FROM quantiles\n-----\n-[00:16:39, 01:23:19, 02:29:59]\n \n # single GROUP\n query R\ndiff --git a/test/sql/aggregate/qualify/test_qualify.test b/test/sql/aggregate/qualify/test_qualify.test\nindex fcd745194011..aa313317227a 100644\n--- a/test/sql/aggregate/qualify/test_qualify.test\n+++ b/test/sql/aggregate/qualify/test_qualify.test\n@@ -130,7 +130,6 @@ SELECT b, SUM(a) AS sum FROM test GROUP BY b QUALIFY row_number() OVER (PARTITIO\n # expression in qualify\n statement ok\n SELECT b, SUM(a) AS sum FROM test GROUP BY b QUALIFY row_number() OVER (PARTITION BY b) > sum * 10;\n-----\n \n query ITI\n SELECT * FROM qt QUALIFY row_number() OVER (PARTITION BY b ORDER BY c) = (SELECT max(c) FROM qt) ORDER BY b;\ndiff --git a/test/sql/binder/test_having_alias.test b/test/sql/binder/test_having_alias.test\nindex 1218ddfdddde..cba977aa331a 100644\n--- a/test/sql/binder/test_having_alias.test\n+++ b/test/sql/binder/test_having_alias.test\n@@ -52,8 +52,6 @@ SELECT COUNT(i) AS i FROM integers HAVING i=5;\n \n statement error\n SELECT COUNT(i) AS i FROM integers HAVING i=5 ORDER BY i;\n-----\n-5\n \n # use the same alias multiple times\n query I\ndiff --git a/test/sql/copy/csv/csv_error_message.test b/test/sql/copy/csv/csv_error_message.test\nnew file mode 100644\nindex 000000000000..43ab0915171d\n--- /dev/null\n+++ b/test/sql/copy/csv/csv_error_message.test\n@@ -0,0 +1,22 @@\n+# name: test/sql/copy/csv/csv_error_message.test\n+# description: Various CSV reader error messages\n+# group: [csv]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+COPY (SELECT i::VARCHAR i FROM range(103) tbl(i) UNION ALL SELECT 'hello') TO '__TEST_DIR__/int_parse_error.csv' (HEADER, DELIMITER '|')\n+\n+statement error\n+SELECT * FROM read_csv('__TEST_DIR__/int_parse_error.csv', columns={'i': 'INT'}, header=True)\n+----\n+line 105\n+\n+statement ok\n+COPY (SELECT i::VARCHAR i FROM range(103) tbl(i) UNION ALL SELECT 'hello') TO '__TEST_DIR__/int_parse_error.csv' (HEADER 0, DELIMITER '|')\n+\n+statement error\n+SELECT * FROM read_csv('__TEST_DIR__/int_parse_error.csv', columns={'i': 'INT'}, header=False)\n+----\n+line 104\ndiff --git a/test/sql/copy/csv/csv_null_byte.test b/test/sql/copy/csv/csv_null_byte.test\nnew file mode 100644\nindex 000000000000..6e0e30be1497\n--- /dev/null\n+++ b/test/sql/copy/csv/csv_null_byte.test\n@@ -0,0 +1,26 @@\n+# name: test/sql/copy/csv/csv_null_byte.test\n+# description: Read a CSV with a null byte\n+# group: [csv]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement error\n+select * from 'data/csv/nullbyte.csv';\n+----\n+line 2\n+\n+statement error\n+select * from read_csv('data/csv/nullbyte.csv', columns={'col1': 'VARCHAR', 'col2': 'VARCHAR'}, delim='|');\n+----\n+line 2\n+\n+statement error\n+select * from 'data/csv/nullbyte_header.csv';\n+----\n+line 1\n+\n+statement error\n+select * from read_csv('data/csv/nullbyte_header.csv', columns={'col1': 'VARCHAR', 'col2': 'VARCHAR'}, delim='|', header=False);\n+----\n+line 1\ndiff --git a/test/sql/copy/csv/test_abac.test b/test/sql/copy/csv/test_abac.test\nindex 924c53d2dac7..05a1c63d2633 100644\n--- a/test/sql/copy/csv/test_abac.test\n+++ b/test/sql/copy/csv/test_abac.test\n@@ -103,6 +103,8 @@ CREATE TABLE abac_tbl (a VARCHAR);\n \n statement error\n COPY abac_tbl FROM 'test/sql/copy/csv/data/abac/simple_unterminated_quote.csv' (QUOTE '\"', AUTO_DETECT FALSE);\n+----\n+line 1\n \n statement ok\n DROP TABLE abac_tbl\n@@ -160,6 +162,8 @@ CREATE TABLE abac_tbl (a VARCHAR);\n \n statement error\n COPY abac_tbl FROM 'test/sql/copy/csv/data/abac/unterminated_quote_escape.csv' (QUOTE '\"', ESCAPE '\"', AUTO_DETECT FALSE);\n+----\n+line 1\n \n statement ok\n DROP TABLE abac_tbl\n@@ -170,6 +174,8 @@ CREATE TABLE abac_tbl (a VARCHAR);\n \n statement error\n COPY abac_tbl FROM 'test/sql/copy/csv/data/abac/unterminated_escape.csv' (QUOTE '\"', ESCAPE '''', AUTO_DETECT FALSE);\n+----\n+1\n \n statement ok\n DROP TABLE abac_tbl\n@@ -180,6 +186,8 @@ CREATE TABLE abac_tbl (a VARCHAR);\n \n statement error\n COPY abac_tbl FROM 'test/sql/copy/csv/data/abac/complex_unterminated_quote.csv' (QUOTE 'ABABAC', AUTO_DETECT FALSE);\n+----\n+1\n \n statement ok\n DROP TABLE abac_tbl\n@@ -205,6 +213,8 @@ CREATE TABLE abac_tbl (a VARCHAR);\n \n statement error\n COPY abac_tbl FROM 'test/sql/copy/csv/data/abac/unterminated_quote_with_escape_complex.csv' (QUOTE 'ABAC', ESCAPE 'ABAB', AUTO_DETECT FALSE);\n+----\n+line 1\n \n statement ok\n DROP TABLE abac_tbl\n@@ -215,6 +225,8 @@ CREATE TABLE abac_tbl (a VARCHAR);\n \n statement error\n COPY abac_tbl FROM 'test/sql/copy/csv/data/abac/unterminated_quote_escape_complex.csv' (QUOTE 'ABAC', ESCAPE 'ABAC', AUTO_DETECT FALSE);\n+----\n+line 1\n \n statement ok\n DROP TABLE abac_tbl\n@@ -225,6 +237,8 @@ CREATE TABLE abac_tbl (a VARCHAR);\n \n statement error\n COPY abac_tbl FROM 'test/sql/copy/csv/data/abac/unterminated_escape_complex.csv' (QUOTE 'ABAC', ESCAPE 'ABAB', AUTO_DETECT FALSE);\n+----\n+line 1\n \n statement ok\n DROP TABLE abac_tbl\ndiff --git a/test/sql/copy/csv/test_dateformat.test b/test/sql/copy/csv/test_dateformat.test\nindex 2a87c4ceba40..5ff656eb8bf7 100644\n--- a/test/sql/copy/csv/test_dateformat.test\n+++ b/test/sql/copy/csv/test_dateformat.test\n@@ -8,6 +8,8 @@ CREATE TABLE dates (d DATE);\n # base date format does not work here\n statement error\n COPY dates FROM 'test/sql/copy/csv/data/test/dateformat.csv' (AUTO_DETECT 0, HEADER 0)\n+----\n+line 1\n \n statement ok\n COPY dates FROM 'test/sql/copy/csv/data/test/dateformat.csv' (HEADER 0, DATEFORMAT '%d/%m/%Y')\ndiff --git a/test/sql/copy/csv/test_max_line_size.test_slow b/test/sql/copy/csv/test_max_line_size.test_slow\nindex 5e1818ede0f6..2fc9d17d8a63 100644\n--- a/test/sql/copy/csv/test_max_line_size.test_slow\n+++ b/test/sql/copy/csv/test_max_line_size.test_slow\n@@ -22,6 +22,8 @@ CREATE TABLE test (a INTEGER, b VARCHAR, c INTEGER);\n # size by a small margin as the calculation is an estimate based on reads before parsing.\n statement error\n COPY test FROM '__TEST_DIR__/test.csv';\n+----\n+line 2\n \n # we can override the max line size\n statement ok\ndiff --git a/test/sql/function/timestamp/test_icu_dateadd.test b/test/sql/function/timestamp/test_icu_dateadd.test\nindex 8133e52471bf..28fb4e3b3523 100644\n--- a/test/sql/function/timestamp/test_icu_dateadd.test\n+++ b/test/sql/function/timestamp/test_icu_dateadd.test\n@@ -276,8 +276,6 @@ SELECT ts + INTERVAL (-150) millisecond FROM limits WHERE label = 'tsmin';\n \n statement error\n SELECT ts + INTERVAL (-485) microsecond FROM limits WHERE label = 'tsmin';\n-----\n-290309-12-22 (BC) 00:00:00.000515+00\n \n # Backward from the maximum\n # UDate loses ms accuracy when close to the upper limit,\ndiff --git a/test/sql/order/test_limit_percent.test b/test/sql/order/test_limit_percent.test\nindex 4ea6215ef1a3..56ab42850ad2 100644\n--- a/test/sql/order/test_limit_percent.test\n+++ b/test/sql/order/test_limit_percent.test\n@@ -142,7 +142,6 @@ SELECT * FROM test LIMIT 30% OFFSET RANDOM() / 10.0;\n \n statement ok\n SELECT b FROM test LIMIT 0%\n-----\n \n #Subqueries that return negative values\n statement error\ndiff --git a/test/sql/prepared/prepare_default_varchar.test b/test/sql/prepared/prepare_default_varchar.test\nindex 215cae6712d9..5b609b53269c 100644\n--- a/test/sql/prepared/prepare_default_varchar.test\n+++ b/test/sql/prepared/prepare_default_varchar.test\n@@ -139,8 +139,6 @@ time: 27\n \n statement error\n EXECUTE v7('hello world', [1, 2, 3])\n-----\n-hello world: [1, 2, 3]\n \n # unbound parameter with lists\n statement ok\ndiff --git a/test/sql/returning/returning_insert.test b/test/sql/returning/returning_insert.test\nindex 705212e9f98f..644dff6b1cf6 100644\n--- a/test/sql/returning/returning_insert.test\n+++ b/test/sql/returning/returning_insert.test\n@@ -137,8 +137,6 @@ INSERT INTO table1 SELECT * from table1 RETURNING row_number() OVER (ORDER BY a)\n \n statement error\n INSERT INTO table1 VALUES (1, 2, 3) RETURNING [1, 2] IN (SELECT [a, b] from table1);\n-----\n-1\n \n # scalar subquery (should fail since scalar is a subquery)\n statement error\ndiff --git a/test/sql/storage/test_multiple_free_list_blocks.test_coverage b/test/sql/storage/test_multiple_free_list_blocks.test_coverage\ndeleted file mode 100644\nindex 0174b5f2ff8a..000000000000\n--- a/test/sql/storage/test_multiple_free_list_blocks.test_coverage\n+++ /dev/null\n@@ -1,44 +0,0 @@\n-# name: test/sql/storage/test_multiple_free_list_blocks.test_coverage\n-# description: Test free_list with multiple blocks\n-# group: [storage]\n-\n-require skip_reload\n-\n-\n-load __TEST_DIR__/free_list_blocks.db\n-\n-statement ok\n-PRAGMA debug_many_free_list_blocks=true\n-\n-statement ok\n-CREATE TABLE integers(i INT, j INT)\n-\n-loop i 0 100\n-\n-statement ok\n-DROP TABLE integers\n-\n-statement ok\n-CREATE TABLE integers(i INT, j INT)\n-\n-statement ok\n-INSERT INTO integers VALUES (1, 2), (2, 3), (1, 4);\n-\n-statement ok\n-CHECKPOINT\n-\n-restart\n-\n-query II\n-SELECT * FROM integers\n-----\n-1\t2\n-2\t3\n-1\t4\n-\n-query I\n-SELECT total_blocks * block_size < 10 * 262144 FROM pragma_database_size()\n-----\n-true\n-\n-endloop\ndiff --git a/test/sql/types/enum/test_enum_table.test b/test/sql/types/enum/test_enum_table.test\nindex 0b7e104536cc..d48f0067d382 100644\n--- a/test/sql/types/enum/test_enum_table.test\n+++ b/test/sql/types/enum/test_enum_table.test\n@@ -217,8 +217,6 @@ ok\n \n statement error\n SELECT CAST ('bla' as mood)\n-----\n-ok\n \n query I\n SELECT TRY_CAST ('bla' as mood)\ndiff --git a/test/sqlite/result_helper.cpp b/test/sqlite/result_helper.cpp\nindex 78992aa3b688..9f50dcf13c77 100644\n--- a/test/sqlite/result_helper.cpp\n+++ b/test/sqlite/result_helper.cpp\n@@ -263,6 +263,12 @@ bool TestResultHelper::CheckStatementResult(const Statement &statement, ExecuteC\n \t\t} else {\n \t\t\texpect_ok = true;\n \t\t}\n+\t\tif (result.HasError() && !statement.expected_error.empty()) {\n+\t\t\tif (!StringUtil::Contains(result.GetError(), statement.expected_error)) {\n+\t\t\t\tlogger.ExpectedErrorMismatch(statement.expected_error, result);\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n \t}\n \n \t/* Report an error if the results do not match expectation */\ndiff --git a/test/sqlite/sqllogic_command.hpp b/test/sqlite/sqllogic_command.hpp\nindex 94c23d05f08a..6b4d180d26e1 100644\n--- a/test/sqlite/sqllogic_command.hpp\n+++ b/test/sqlite/sqllogic_command.hpp\n@@ -68,6 +68,7 @@ class Statement : public Command {\n \tStatement(SQLLogicTestRunner &runner);\n \n \tbool expect_ok;\n+\tstring expected_error;\n \n public:\n \tvoid ExecuteInternal(ExecuteContext &context) const override;\ndiff --git a/test/sqlite/sqllogic_parser.cpp b/test/sqlite/sqllogic_parser.cpp\nindex b6c0a91076da..bdd1e89f3089 100644\n--- a/test/sqlite/sqllogic_parser.cpp\n+++ b/test/sqlite/sqllogic_parser.cpp\n@@ -53,12 +53,12 @@ void SQLLogicParser::NextLine() {\n \tcurrent_line++;\n }\n \n-string SQLLogicParser::ExtractStatement(bool is_query) {\n+string SQLLogicParser::ExtractStatement() {\n \tstring statement;\n \n \tbool first_line = true;\n \twhile (current_line < lines.size() && !EmptyOrComment(lines[current_line])) {\n-\t\tif (is_query && lines[current_line] == \"----\") {\n+\t\tif (lines[current_line] == \"----\") {\n \t\t\tbreak;\n \t\t}\n \t\tif (!first_line) {\n@@ -87,6 +87,27 @@ vector<string> SQLLogicParser::ExtractExpectedResult() {\n \treturn result;\n }\n \n+string SQLLogicParser::ExtractExpectedError(bool expect_ok) {\n+\t// check if there is an expected error at all\n+\tif (current_line >= lines.size() || lines[current_line] != \"----\") {\n+\t\treturn string();\n+\t}\n+\tif (expect_ok) {\n+\t\tFail(\"Failed to parse statement: only statement error can have an expected error message, not statement ok\");\n+\t}\n+\tcurrent_line++;\n+\tstring error;\n+\twhile (current_line < lines.size() && !lines[current_line].empty()) {\n+\t\tif (error.empty()) {\n+\t\t\terror = lines[current_line];\n+\t\t} else {\n+\t\t\tFail(\"Failed to parse statement error: expected single line error message\");\n+\t\t}\n+\t\tcurrent_line++;\n+\t}\n+\treturn error;\n+}\n+\n void SQLLogicParser::FailRecursive(const string &msg, vector<ExceptionFormatValue> &values) {\n \tauto error_message =\n \t    file_name + \":\" + to_string(current_line + 1) + \": \" + ExceptionFormatValue::Format(msg, values);\ndiff --git a/test/sqlite/sqllogic_parser.hpp b/test/sqlite/sqllogic_parser.hpp\nindex b2cfee0d01ec..bad81495590f 100644\n--- a/test/sqlite/sqllogic_parser.hpp\n+++ b/test/sqlite/sqllogic_parser.hpp\n@@ -73,11 +73,14 @@ class SQLLogicParser {\n \t//! Extract a statement and move the current_line pointer forward\n \t//! if \"is_query\" is false, the statement stops at the next empty line\n \t//! if \"is_query\" is true, the statement stops at the next empty line or the next ----\n-\tstring ExtractStatement(bool is_query);\n+\tstring ExtractStatement();\n \n \t//! Extract the expected result\n \tvector<string> ExtractExpectedResult();\n \n+\t//! Extract the expected error (in case of statement error)\n+\tstring ExtractExpectedError(bool expect_ok);\n+\n \t//! Tokenize the current line\n \tSQLLogicToken Tokenize();\n \ndiff --git a/test/sqlite/sqllogic_test_logger.cpp b/test/sqlite/sqllogic_test_logger.cpp\nindex 06837812ab51..a3d21a368dc8 100644\n--- a/test/sqlite/sqllogic_test_logger.cpp\n+++ b/test/sqlite/sqllogic_test_logger.cpp\n@@ -260,4 +260,13 @@ void SQLLogicTestLogger::UnexpectedStatement(bool expect_ok, MaterializedQueryRe\n \tresult.Print();\n }\n \n+void SQLLogicTestLogger::ExpectedErrorMismatch(const string &expected_error, MaterializedQueryResult &result) {\n+\tPrintErrorHeader(\"Query failed, but error message did not match expected error message: \" + expected_error);\n+\tPrintLineSep();\n+\tPrintSQL();\n+\tPrintHeader(\"Actual result:\");\n+\tPrintLineSep();\n+\tresult.Print();\n+}\n+\n } // namespace duckdb\ndiff --git a/test/sqlite/sqllogic_test_logger.hpp b/test/sqlite/sqllogic_test_logger.hpp\nindex 9b3438e96217..60a8c990d63d 100644\n--- a/test/sqlite/sqllogic_test_logger.hpp\n+++ b/test/sqlite/sqllogic_test_logger.hpp\n@@ -47,6 +47,7 @@ class SQLLogicTestLogger {\n \tvoid SplitMismatch(idx_t row_number, idx_t expected_column_count, idx_t split_count);\n \tvoid WrongResultHash(QueryResult *expected_result, MaterializedQueryResult &result);\n \tvoid UnexpectedStatement(bool expect_ok, MaterializedQueryResult &result);\n+\tvoid ExpectedErrorMismatch(const string &expected_error, MaterializedQueryResult &result);\n \n private:\n \tlock_guard<mutex> log_lock;\ndiff --git a/test/sqlite/sqllogic_test_runner.cpp b/test/sqlite/sqllogic_test_runner.cpp\nindex e1753345d0bd..af6dc5812483 100644\n--- a/test/sqlite/sqllogic_test_runner.cpp\n+++ b/test/sqlite/sqllogic_test_runner.cpp\n@@ -267,10 +267,11 @@ void SQLLogicTestRunner::ExecuteFile(string script) {\n \n \t\t\t// extract the SQL statement\n \t\t\tparser.NextLine();\n-\t\t\tauto statement_text = parser.ExtractStatement(false);\n+\t\t\tauto statement_text = parser.ExtractStatement();\n \t\t\tif (statement_text.empty()) {\n \t\t\t\tparser.Fail(\"Unexpected empty statement text\");\n \t\t\t}\n+\t\t\tcommand->expected_error = parser.ExtractExpectedError(command->expect_ok);\n \n \t\t\t// perform any renames in the text\n \t\t\tcommand->base_sql_query = ReplaceKeywords(move(statement_text));\n@@ -304,7 +305,7 @@ void SQLLogicTestRunner::ExecuteFile(string script) {\n \n \t\t\t// extract the SQL statement\n \t\t\tparser.NextLine();\n-\t\t\tauto statement_text = parser.ExtractStatement(true);\n+\t\t\tauto statement_text = parser.ExtractStatement();\n \n \t\t\t// perform any renames in the text\n \t\t\tcommand->base_sql_query = ReplaceKeywords(move(statement_text));\ndiff --git a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\nindex 9fe79473faaa..bb7ba4edc12f 100644\n--- a/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n+++ b/tools/jdbc/src/test/java/org/duckdb/test/TestDuckDBJDBC.java\n@@ -2410,7 +2410,7 @@ public static void test_null_bytes_in_string() throws Exception {\n \t\t\t\t\t\tstmt::executeQuery,\n \t\t\t\t\t\tSQLException.class\n \t\t\t\t);\n-\t\t\t\tassertEquals(message, \"String value is not valid UTF8\");\n+\t\t\t\tassertEquals(message, \"Null-byte (\\\\0) detected in value construction\");\n \t\t\t}\n \t\t}\n \t}\n",
  "problem_statement": "Precise row number on CSV import errors\n### What happens?\r\n\r\nFor some CSV import errors the line number where the error occurred is a range of lines. For example, [this](https://github.com/duckdb/duckdb/blob/master/src/execution/operator/persistent/buffered_csv_reader.cpp#L2072). It would be helpful for troubleshooting if an exact line number could be provided.\r\n\r\nAlso, the [error](https://github.com/duckdb/duckdb/blob/master/src/execution/operator/persistent/buffered_csv_reader.cpp#L1797) for maximum line size has no line number information.\r\n\r\n### To Reproduce\r\n\r\nN/A\r\n\r\n### OS:\r\n\r\nLinux\r\n\r\n### DuckDB Version:\r\n\r\n0.5.1\r\n\r\n### DuckDB Client:\r\n\r\nJDBC\r\n\r\n### Full Name:\r\n\r\nMichael Albers\r\n\r\n### Affiliation:\r\n\r\nMode\r\n\r\n### Have you tried this on the latest `master` branch?\r\n\r\n- [X] I agree\r\n\r\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\r\n\r\n- [X] I agree\nCLI cannot load unsigned extension after open an existing db file (with -unsigned flag)\n### What happens?\n\nThe following error raises when start the client with on an existing db file.\r\n\r\n```\r\nError: IO Error: Extension \"build/release/extension/postgres_scanner/postgres_scanner.duckdb_extension\" could not be loaded because its signature is either missing or invalid and unsigned extensions are disabled by configuration (allow_unsigned_extensions)\r\n```\r\n\r\nIn-memory mode and opening a new db file will not raise this issue.\n\n### To Reproduce\n\nCan use [postgres extension](https://github.com/duckdblabs/postgres_scanner) to reproduce the issue. After building duckdb and postgres extension:\r\n\r\n```bash\r\n# Error if `test.db` exists, success if not\r\n./duckdb/build/release/duckdb -unsigned test.db\r\nD LOAD 'build/release/extension/postgres_scanner/postgres_scanner.duckdb_extension';\r\n\r\n# No error\r\n./duckdb/build/release/duckdb -unsigned\r\nD LOAD 'build/release/extension/postgres_scanner/postgres_scanner.duckdb_extension';\r\n```\n\n### OS:\n\nOSX (m1)\n\n### DuckDB Version:\n\nmaster branch (c2ca23eef98ca91fdf73ff29129bc7816bd73ff3)\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nXiaoying Wang\n\n### Affiliation:\n\nSimon Fraser University\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\nCLI cannot load unsigned extension after open an existing db file (with -unsigned flag)\n### What happens?\n\nThe following error raises when start the client with on an existing db file.\r\n\r\n```\r\nError: IO Error: Extension \"build/release/extension/postgres_scanner/postgres_scanner.duckdb_extension\" could not be loaded because its signature is either missing or invalid and unsigned extensions are disabled by configuration (allow_unsigned_extensions)\r\n```\r\n\r\nIn-memory mode and opening a new db file will not raise this issue.\n\n### To Reproduce\n\nCan use [postgres extension](https://github.com/duckdblabs/postgres_scanner) to reproduce the issue. After building duckdb and postgres extension:\r\n\r\n```bash\r\n# Error if `test.db` exists, success if not\r\n./duckdb/build/release/duckdb -unsigned test.db\r\nD LOAD 'build/release/extension/postgres_scanner/postgres_scanner.duckdb_extension';\r\n\r\n# No error\r\n./duckdb/build/release/duckdb -unsigned\r\nD LOAD 'build/release/extension/postgres_scanner/postgres_scanner.duckdb_extension';\r\n```\n\n### OS:\n\nOSX (m1)\n\n### DuckDB Version:\n\nmaster branch (c2ca23eef98ca91fdf73ff29129bc7816bd73ff3)\n\n### DuckDB Client:\n\nCLI\n\n### Full Name:\n\nXiaoying Wang\n\n### Affiliation:\n\nSimon Fraser University\n\n### Have you tried this on the latest `master` branch?\n\n- [X] I agree\n\n### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?\n\n- [X] I agree\n",
  "hints_text": "\nHave you tried this on the latest master? This seems very similar to #4895.\nThanks for the quick reply! Yeah, I found that issue and tried on latest master. It works on `.open` mode after start the client with command `duckdb -unsigned`. But it still raise the error if I start the client with `duckdb -unsigned existing.db`.\nSimilar also to https://github.com/duckdb/duckdb/discussions/4959#discussioncomment-3859646\nHave you tried this on the latest master? This seems very similar to #4895.\nThanks for the quick reply! Yeah, I found that issue and tried on latest master. It works on `.open` mode after start the client with command `duckdb -unsigned`. But it still raise the error if I start the client with `duckdb -unsigned existing.db`.\nSimilar also to https://github.com/duckdb/duckdb/discussions/4959#discussioncomment-3859646",
  "created_at": "2022-10-27T13:03:59Z"
}