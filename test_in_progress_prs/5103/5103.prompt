You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Precise row number on CSV import errors
### What happens?

For some CSV import errors the line number where the error occurred is a range of lines. For example, [this](https://github.com/duckdb/duckdb/blob/master/src/execution/operator/persistent/buffered_csv_reader.cpp#L2072). It would be helpful for troubleshooting if an exact line number could be provided.

Also, the [error](https://github.com/duckdb/duckdb/blob/master/src/execution/operator/persistent/buffered_csv_reader.cpp#L1797) for maximum line size has no line number information.

### To Reproduce

N/A

### OS:

Linux

### DuckDB Version:

0.5.1

### DuckDB Client:

JDBC

### Full Name:

Michael Albers

### Affiliation:

Mode

### Have you tried this on the latest `master` branch?

- [X] I agree

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] I agree
CLI cannot load unsigned extension after open an existing db file (with -unsigned flag)
### What happens?

The following error raises when start the client with on an existing db file.

```
Error: IO Error: Extension "build/release/extension/postgres_scanner/postgres_scanner.duckdb_extension" could not be loaded because its signature is either missing or invalid and unsigned extensions are disabled by configuration (allow_unsigned_extensions)
```

In-memory mode and opening a new db file will not raise this issue.

### To Reproduce

Can use [postgres extension](https://github.com/duckdblabs/postgres_scanner) to reproduce the issue. After building duckdb and postgres extension:

```bash
# Error if `test.db` exists, success if not
./duckdb/build/release/duckdb -unsigned test.db
D LOAD 'build/release/extension/postgres_scanner/postgres_scanner.duckdb_extension';

# No error
./duckdb/build/release/duckdb -unsigned
D LOAD 'build/release/extension/postgres_scanner/postgres_scanner.duckdb_extension';
```

### OS:

OSX (m1)

### DuckDB Version:

master branch (c2ca23eef98ca91fdf73ff29129bc7816bd73ff3)

### DuckDB Client:

CLI

### Full Name:

Xiaoying Wang

### Affiliation:

Simon Fraser University

### Have you tried this on the latest `master` branch?

- [X] I agree

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] I agree
CLI cannot load unsigned extension after open an existing db file (with -unsigned flag)
### What happens?

The following error raises when start the client with on an existing db file.

```
Error: IO Error: Extension "build/release/extension/postgres_scanner/postgres_scanner.duckdb_extension" could not be loaded because its signature is either missing or invalid and unsigned extensions are disabled by configuration (allow_unsigned_extensions)
```

In-memory mode and opening a new db file will not raise this issue.

### To Reproduce

Can use [postgres extension](https://github.com/duckdblabs/postgres_scanner) to reproduce the issue. After building duckdb and postgres extension:

```bash
# Error if `test.db` exists, success if not
./duckdb/build/release/duckdb -unsigned test.db
D LOAD 'build/release/extension/postgres_scanner/postgres_scanner.duckdb_extension';

# No error
./duckdb/build/release/duckdb -unsigned
D LOAD 'build/release/extension/postgres_scanner/postgres_scanner.duckdb_extension';
```

### OS:

OSX (m1)

### DuckDB Version:

master branch (c2ca23eef98ca91fdf73ff29129bc7816bd73ff3)

### DuckDB Client:

CLI

### Full Name:

Xiaoying Wang

### Affiliation:

Simon Fraser University

### Have you tried this on the latest `master` branch?

- [X] I agree

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] I agree

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=master" alt="Github Actions Badge">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The detail of benchmarks is in our [Benchmark Guide](benchmark/README.md).
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
[end of README.md]
[start of scripts/generate_extensions_function.py]
1: import os
2: import csv
3: import re
4: import argparse
5: import glob
6: 
7: os.chdir(os.path.dirname(__file__))
8: 
9: parser = argparse.ArgumentParser(description='Generates/Validates extension_functions.hpp file')
10: 
11: parser.add_argument('--validate', action=argparse.BooleanOptionalAction,
12:                     help='If set  will validate that extension_functions.hpp is up to date, otherwise it generates the extension_functions.hpp file.')
13: 
14: 
15: args = parser.parse_args()
16: 
17: stored_functions = {
18:     'substrait': ["from_substrait", "get_substrait", "get_substrait_json"]
19: }
20: 
21: functions = {}
22: ext_dir = os.path.join('..', '.github', 'config', 'extensions.csv')
23: reader = csv.reader(open(ext_dir))
24: # This skips the first row (i.e., the header) of the CSV file.
25: next(reader)
26: 
27: get_func = "select distinct on(function_name) function_name from duckdb_functions();"
28: duckdb_path = os.path.join("..",'build', 'release', 'duckdb')
29: base_functions = os.popen(f'{duckdb_path} -csv -c "{get_func}" ').read().split("\n")[1:-1]
30: 
31: base_functions = {x for x in base_functions}
32: 
33: function_map = {}
34: 
35: # root_dir needs a trailing slash (i.e. /root/dir/)
36: extension_path = {}
37: for filename in glob.iglob('/tmp/' + '**/*.duckdb_extension', recursive=True):
38:     extension_path[os.path.splitext(os.path.basename(filename))[0]] = filename
39: 
40: for extension in reader:
41:     extension_name = extension[0]
42:     if extension_name not in extension_path:
43:         if extension_name not in stored_functions:
44:             print(f"Missing extension {extension_name}")
45:             exit(1)
46:         extension_functions = stored_functions[extension_name]
47:         print(f"Loading {extension_name} from stored functions: {extension_functions}")
48:         function_map.update({
49:             extension_function: extension_name
50:             for extension_function in (set(extension_functions) - base_functions)
51:         })
52:         continue
53: 
54:     print(f"Load {extension_name} at {extension_path[extension_name]}")
55:     load = f"LOAD '{extension_path[extension_name]}';"
56:     extension_functions = os.popen(f'{duckdb_path} -unsigned -csv -c "{load}{get_func}" ').read().split("\n")[1:-1]
57:     function_map.update({
58:         extension_function: extension_name
59:         for extension_function in (set(extension_functions) - base_functions)
60:     })
61: 
62: if args.validate:
63:     file = open(os.path.join("..","src","include","extension_functions.hpp"),'r')
64:     pattern = re.compile("{\"(.*?)\", \"(.*?)\"},")
65:     cur_function_map = dict(pattern.findall(file.read()))
66:     print("Cur Function Map: ")
67:     print(sorted(list(cur_function_map)))
68:     print("Function Map: ")
69:     print(sorted(list(function_map)))
70:     if len(cur_function_map) == 0:
71:         print("Current function map is empty?")
72:         exit(1)
73:     if cur_function_map != function_map:
74:         print("Difference between current functions and function map")
75:         print(f"Current function map length: {len(cur_function_map)}")
76:         print(f"Function map length: {len(function_map)}")
77:         for f in function_map:
78:             if f not in cur_function_map:
79:                 print(f"Function {f} of function_map does not exist in cur_function_map")
80:         for f in cur_function_map:
81:             if f not in function_map:
82:                 print(f"Function {f} of cur_function_map does not exist in function_map")
83:         exit(1)
84: else:
85:     # Generate Header
86:     file = open(os.path.join("..","src","include","extension_functions.hpp"),'w')
87:     header = """//===----------------------------------------------------------------------===//
88: //                         DuckDB
89: //
90: // extension_functions.hpp
91: //
92: //
93: //===----------------------------------------------------------------------===//
94: 
95: #pragma once
96: 
97: #include \"duckdb/common/unordered_map.hpp\"
98: 
99: 
100: namespace duckdb {
101: 
102: struct ExtensionFunction {
103:     char function[48];
104:     char extension[48];
105: };
106: 
107: static constexpr ExtensionFunction EXTENSION_FUNCTIONS[] = {
108: """
109:     file.write(header)
110:     # Sort Function Map
111:     sorted_function = sorted(function_map)
112: 
113:     for function_name in sorted_function:
114:         file.write("    {")
115:         file.write(f'"{function_name}", "{function_map[function_name]}"')
116:         file.write("}, \n")
117:     footer = """};
118: } // namespace duckdb"""
119:     file.write(footer)
120: 
121:     file.close()
[end of scripts/generate_extensions_function.py]
[start of src/catalog/catalog.cpp]
1: #include "duckdb/catalog/catalog.hpp"
2: 
3: #include "duckdb/catalog/catalog_search_path.hpp"
4: #include "duckdb/catalog/catalog_entry/list.hpp"
5: #include "duckdb/catalog/catalog_set.hpp"
6: #include "duckdb/catalog/default/default_schemas.hpp"
7: #include "duckdb/catalog/dependency_manager.hpp"
8: #include "duckdb/catalog/catalog_entry/type_catalog_entry.hpp"
9: #include "duckdb/common/exception.hpp"
10: #include "duckdb/main/client_context.hpp"
11: #include "duckdb/main/client_data.hpp"
12: #include "duckdb/main/database.hpp"
13: #include "duckdb/parser/expression/function_expression.hpp"
14: #include "duckdb/parser/parsed_data/alter_table_info.hpp"
15: #include "duckdb/parser/parsed_data/create_aggregate_function_info.hpp"
16: #include "duckdb/parser/parsed_data/create_collation_info.hpp"
17: #include "duckdb/parser/parsed_data/create_copy_function_info.hpp"
18: #include "duckdb/parser/parsed_data/create_index_info.hpp"
19: #include "duckdb/parser/parsed_data/create_pragma_function_info.hpp"
20: #include "duckdb/parser/parsed_data/create_scalar_function_info.hpp"
21: #include "duckdb/parser/parsed_data/create_schema_info.hpp"
22: #include "duckdb/parser/parsed_data/create_sequence_info.hpp"
23: #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
24: #include "duckdb/parser/parsed_data/create_type_info.hpp"
25: #include "duckdb/parser/parsed_data/create_view_info.hpp"
26: #include "duckdb/parser/parsed_data/drop_info.hpp"
27: #include "duckdb/planner/parsed_data/bound_create_table_info.hpp"
28: #include "duckdb/planner/binder.hpp"
29: #include "duckdb/catalog/default/default_types.hpp"
30: #include "extension_functions.hpp"
31: #include <algorithm>
32: namespace duckdb {
33: 
34: string SimilarCatalogEntry::GetQualifiedName() const {
35: 	D_ASSERT(Found());
36: 
37: 	return schema->name + "." + name;
38: }
39: 
40: Catalog::Catalog(DatabaseInstance &db)
41:     : db(db), schemas(make_unique<CatalogSet>(*this, make_unique<DefaultSchemaGenerator>(*this))),
42:       dependency_manager(make_unique<DependencyManager>(*this)) {
43: 	catalog_version = 0;
44: }
45: Catalog::~Catalog() {
46: }
47: 
48: Catalog &Catalog::GetCatalog(ClientContext &context) {
49: 	return context.db->GetCatalog();
50: }
51: 
52: CatalogEntry *Catalog::CreateTable(ClientContext &context, BoundCreateTableInfo *info) {
53: 	auto schema = GetSchema(context, info->base->schema);
54: 	return CreateTable(context, schema, info);
55: }
56: 
57: CatalogEntry *Catalog::CreateTable(ClientContext &context, unique_ptr<CreateTableInfo> info) {
58: 	auto binder = Binder::CreateBinder(context);
59: 	auto bound_info = binder->BindCreateTableInfo(move(info));
60: 	return CreateTable(context, bound_info.get());
61: }
62: 
63: CatalogEntry *Catalog::CreateTable(ClientContext &context, SchemaCatalogEntry *schema, BoundCreateTableInfo *info) {
64: 	return schema->CreateTable(context, info);
65: }
66: 
67: CatalogEntry *Catalog::CreateView(ClientContext &context, CreateViewInfo *info) {
68: 	auto schema = GetSchema(context, info->schema);
69: 	return CreateView(context, schema, info);
70: }
71: 
72: CatalogEntry *Catalog::CreateView(ClientContext &context, SchemaCatalogEntry *schema, CreateViewInfo *info) {
73: 	return schema->CreateView(context, info);
74: }
75: 
76: CatalogEntry *Catalog::CreateSequence(ClientContext &context, CreateSequenceInfo *info) {
77: 	auto schema = GetSchema(context, info->schema);
78: 	return CreateSequence(context, schema, info);
79: }
80: 
81: CatalogEntry *Catalog::CreateType(ClientContext &context, CreateTypeInfo *info) {
82: 	auto schema = GetSchema(context, info->schema);
83: 	return CreateType(context, schema, info);
84: }
85: 
86: CatalogEntry *Catalog::CreateSequence(ClientContext &context, SchemaCatalogEntry *schema, CreateSequenceInfo *info) {
87: 	return schema->CreateSequence(context, info);
88: }
89: 
90: CatalogEntry *Catalog::CreateType(ClientContext &context, SchemaCatalogEntry *schema, CreateTypeInfo *info) {
91: 	return schema->CreateType(context, info);
92: }
93: 
94: CatalogEntry *Catalog::CreateTableFunction(ClientContext &context, CreateTableFunctionInfo *info) {
95: 	auto schema = GetSchema(context, info->schema);
96: 	return CreateTableFunction(context, schema, info);
97: }
98: 
99: CatalogEntry *Catalog::CreateTableFunction(ClientContext &context, SchemaCatalogEntry *schema,
100:                                            CreateTableFunctionInfo *info) {
101: 	return schema->CreateTableFunction(context, info);
102: }
103: 
104: CatalogEntry *Catalog::CreateCopyFunction(ClientContext &context, CreateCopyFunctionInfo *info) {
105: 	auto schema = GetSchema(context, info->schema);
106: 	return CreateCopyFunction(context, schema, info);
107: }
108: 
109: CatalogEntry *Catalog::CreateCopyFunction(ClientContext &context, SchemaCatalogEntry *schema,
110:                                           CreateCopyFunctionInfo *info) {
111: 	return schema->CreateCopyFunction(context, info);
112: }
113: 
114: CatalogEntry *Catalog::CreatePragmaFunction(ClientContext &context, CreatePragmaFunctionInfo *info) {
115: 	auto schema = GetSchema(context, info->schema);
116: 	return CreatePragmaFunction(context, schema, info);
117: }
118: 
119: CatalogEntry *Catalog::CreatePragmaFunction(ClientContext &context, SchemaCatalogEntry *schema,
120:                                             CreatePragmaFunctionInfo *info) {
121: 	return schema->CreatePragmaFunction(context, info);
122: }
123: 
124: CatalogEntry *Catalog::CreateFunction(ClientContext &context, CreateFunctionInfo *info) {
125: 	auto schema = GetSchema(context, info->schema);
126: 	return CreateFunction(context, schema, info);
127: }
128: 
129: CatalogEntry *Catalog::CreateFunction(ClientContext &context, SchemaCatalogEntry *schema, CreateFunctionInfo *info) {
130: 	return schema->CreateFunction(context, info);
131: }
132: 
133: CatalogEntry *Catalog::CreateCollation(ClientContext &context, CreateCollationInfo *info) {
134: 	auto schema = GetSchema(context, info->schema);
135: 	return CreateCollation(context, schema, info);
136: }
137: 
138: CatalogEntry *Catalog::CreateCollation(ClientContext &context, SchemaCatalogEntry *schema, CreateCollationInfo *info) {
139: 	return schema->CreateCollation(context, info);
140: }
141: 
142: CatalogEntry *Catalog::CreateSchema(ClientContext &context, CreateSchemaInfo *info) {
143: 	D_ASSERT(!info->schema.empty());
144: 	if (info->schema == TEMP_SCHEMA) {
145: 		throw CatalogException("Cannot create built-in schema \"%s\"", info->schema);
146: 	}
147: 
148: 	unordered_set<CatalogEntry *> dependencies;
149: 	auto entry = make_unique<SchemaCatalogEntry>(this, info->schema, info->internal);
150: 	auto result = entry.get();
151: 	if (!schemas->CreateEntry(context, info->schema, move(entry), dependencies)) {
152: 		if (info->on_conflict == OnCreateConflict::ERROR_ON_CONFLICT) {
153: 			throw CatalogException("Schema with name %s already exists!", info->schema);
154: 		} else {
155: 			D_ASSERT(info->on_conflict == OnCreateConflict::IGNORE_ON_CONFLICT);
156: 		}
157: 		return nullptr;
158: 	}
159: 	return result;
160: }
161: 
162: void Catalog::DropSchema(ClientContext &context, DropInfo *info) {
163: 	D_ASSERT(!info->name.empty());
164: 	ModifyCatalog();
165: 	if (!schemas->DropEntry(context, info->name, info->cascade)) {
166: 		if (!info->if_exists) {
167: 			throw CatalogException("Schema with name \"%s\" does not exist!", info->name);
168: 		}
169: 	}
170: }
171: 
172: void Catalog::DropEntry(ClientContext &context, DropInfo *info) {
173: 	ModifyCatalog();
174: 	if (info->type == CatalogType::SCHEMA_ENTRY) {
175: 		// DROP SCHEMA
176: 		DropSchema(context, info);
177: 		return;
178: 	}
179: 
180: 	auto lookup = LookupEntry(context, info->type, info->schema, info->name, info->if_exists);
181: 	if (!lookup.Found()) {
182: 		return;
183: 	}
184: 
185: 	lookup.schema->DropEntry(context, info);
186: }
187: 
188: CatalogEntry *Catalog::AddFunction(ClientContext &context, CreateFunctionInfo *info) {
189: 	auto schema = GetSchema(context, info->schema);
190: 	return AddFunction(context, schema, info);
191: }
192: 
193: CatalogEntry *Catalog::AddFunction(ClientContext &context, SchemaCatalogEntry *schema, CreateFunctionInfo *info) {
194: 	return schema->AddFunction(context, info);
195: }
196: 
197: SchemaCatalogEntry *Catalog::GetSchema(ClientContext &context, const string &schema_name, bool if_exists,
198:                                        QueryErrorContext error_context) {
199: 	D_ASSERT(!schema_name.empty());
200: 	if (schema_name == TEMP_SCHEMA) {
201: 		return ClientData::Get(context).temporary_objects.get();
202: 	}
203: 	auto entry = schemas->GetEntry(context, schema_name);
204: 	if (!entry && !if_exists) {
205: 		throw CatalogException(error_context.FormatError("Schema with name %s does not exist!", schema_name));
206: 	}
207: 	return (SchemaCatalogEntry *)entry;
208: }
209: 
210: void Catalog::ScanSchemas(ClientContext &context, std::function<void(CatalogEntry *)> callback) {
211: 	// create all default schemas first
212: 	schemas->Scan(context, [&](CatalogEntry *entry) { callback(entry); });
213: }
214: 
215: SimilarCatalogEntry Catalog::SimilarEntryInSchemas(ClientContext &context, const string &entry_name, CatalogType type,
216:                                                    const vector<SchemaCatalogEntry *> &schemas) {
217: 
218: 	vector<CatalogSet *> sets;
219: 	std::transform(schemas.begin(), schemas.end(), std::back_inserter(sets),
220: 	               [type](SchemaCatalogEntry *s) -> CatalogSet * { return &s->GetCatalogSet(type); });
221: 	pair<string, idx_t> most_similar {"", (idx_t)-1};
222: 	SchemaCatalogEntry *schema_of_most_similar = nullptr;
223: 	for (auto schema : schemas) {
224: 		auto entry = schema->GetCatalogSet(type).SimilarEntry(context, entry_name);
225: 		if (!entry.first.empty() && (most_similar.first.empty() || most_similar.second > entry.second)) {
226: 			most_similar = entry;
227: 			schema_of_most_similar = schema;
228: 		}
229: 	}
230: 
231: 	return {most_similar.first, most_similar.second, schema_of_most_similar};
232: }
233: 
234: string FindExtension(const string &function_name) {
235: 	auto size = sizeof(EXTENSION_FUNCTIONS) / sizeof(ExtensionFunction);
236: 	auto it = std::lower_bound(
237: 	    EXTENSION_FUNCTIONS, EXTENSION_FUNCTIONS + size, function_name,
238: 	    [](const ExtensionFunction &element, const string &value) { return element.function < value; });
239: 	if (it != EXTENSION_FUNCTIONS + size && it->function == function_name) {
240: 		return it->extension;
241: 	}
242: 	return "";
243: }
244: CatalogException Catalog::CreateMissingEntryException(ClientContext &context, const string &entry_name,
245:                                                       CatalogType type, const vector<SchemaCatalogEntry *> &schemas,
246:                                                       QueryErrorContext error_context) {
247: 	auto entry = SimilarEntryInSchemas(context, entry_name, type, schemas);
248: 
249: 	vector<SchemaCatalogEntry *> unseen_schemas;
250: 	this->schemas->Scan([&schemas, &unseen_schemas](CatalogEntry *entry) {
251: 		auto schema_entry = (SchemaCatalogEntry *)entry;
252: 		if (std::find(schemas.begin(), schemas.end(), schema_entry) == schemas.end()) {
253: 			unseen_schemas.emplace_back(schema_entry);
254: 		}
255: 	});
256: 	auto unseen_entry = SimilarEntryInSchemas(context, entry_name, type, unseen_schemas);
257: 	auto extension_name = FindExtension(entry_name);
258: 	if (!extension_name.empty()) {
259: 		return CatalogException("Function with name %s is not on the catalog, but it exists in the %s extension. To "
260: 		                        "Install and Load the extension, run: INSTALL %s; LOAD %s;",
261: 		                        entry_name, extension_name, extension_name, extension_name);
262: 	}
263: 	string did_you_mean;
264: 	if (unseen_entry.Found() && unseen_entry.distance < entry.distance) {
265: 		did_you_mean = "\nDid you mean \"" + unseen_entry.GetQualifiedName() + "\"?";
266: 	} else if (entry.Found()) {
267: 		did_you_mean = "\nDid you mean \"" + entry.name + "\"?";
268: 	}
269: 
270: 	return CatalogException(error_context.FormatError("%s with name %s does not exist!%s", CatalogTypeToString(type),
271: 	                                                  entry_name, did_you_mean));
272: }
273: 
274: CatalogEntryLookup Catalog::LookupEntry(ClientContext &context, CatalogType type, const string &schema_name,
275:                                         const string &name, bool if_exists, QueryErrorContext error_context) {
276: 	if (!schema_name.empty()) {
277: 		auto schema = GetSchema(context, schema_name, if_exists, error_context);
278: 		if (!schema) {
279: 			D_ASSERT(if_exists);
280: 			return {nullptr, nullptr};
281: 		}
282: 
283: 		auto entry = schema->GetCatalogSet(type).GetEntry(context, name);
284: 		if (!entry && !if_exists) {
285: 			throw CreateMissingEntryException(context, name, type, {schema}, error_context);
286: 		}
287: 
288: 		return {schema, entry};
289: 	}
290: 
291: 	const auto &paths = ClientData::Get(context).catalog_search_path->Get();
292: 	for (const auto &path : paths) {
293: 		auto lookup = LookupEntry(context, type, path, name, true, error_context);
294: 		if (lookup.Found()) {
295: 			return lookup;
296: 		}
297: 	}
298: 
299: 	if (!if_exists) {
300: 		vector<SchemaCatalogEntry *> schemas;
301: 		for (const auto &path : paths) {
302: 			auto schema = GetSchema(context, path, true);
303: 			if (schema) {
304: 				schemas.emplace_back(schema);
305: 			}
306: 		}
307: 
308: 		throw CreateMissingEntryException(context, name, type, schemas, error_context);
309: 	}
310: 
311: 	return {nullptr, nullptr};
312: }
313: 
314: CatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema, const string &name) {
315: 	vector<CatalogType> entry_types {CatalogType::TABLE_ENTRY, CatalogType::SEQUENCE_ENTRY};
316: 
317: 	for (auto entry_type : entry_types) {
318: 		CatalogEntry *result = GetEntry(context, entry_type, schema, name, true);
319: 		if (result != nullptr) {
320: 			return result;
321: 		}
322: 	}
323: 
324: 	throw CatalogException("CatalogElement \"%s.%s\" does not exist!", schema, name);
325: }
326: 
327: CatalogEntry *Catalog::GetEntry(ClientContext &context, CatalogType type, const string &schema_name, const string &name,
328:                                 bool if_exists, QueryErrorContext error_context) {
329: 	return LookupEntry(context, type, schema_name, name, if_exists, error_context).entry;
330: }
331: 
332: template <>
333: TableCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
334:                                      bool if_exists, QueryErrorContext error_context) {
335: 	auto entry = GetEntry(context, CatalogType::TABLE_ENTRY, schema_name, name, if_exists);
336: 	if (!entry) {
337: 		return nullptr;
338: 	}
339: 	if (entry->type != CatalogType::TABLE_ENTRY) {
340: 		throw CatalogException(error_context.FormatError("%s is not a table", name));
341: 	}
342: 	return (TableCatalogEntry *)entry;
343: }
344: 
345: template <>
346: SequenceCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
347:                                         bool if_exists, QueryErrorContext error_context) {
348: 	return (SequenceCatalogEntry *)GetEntry(context, CatalogType::SEQUENCE_ENTRY, schema_name, name, if_exists,
349: 	                                        error_context);
350: }
351: 
352: template <>
353: TableFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
354:                                              bool if_exists, QueryErrorContext error_context) {
355: 	return (TableFunctionCatalogEntry *)GetEntry(context, CatalogType::TABLE_FUNCTION_ENTRY, schema_name, name,
356: 	                                             if_exists, error_context);
357: }
358: 
359: template <>
360: CopyFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
361:                                             bool if_exists, QueryErrorContext error_context) {
362: 	return (CopyFunctionCatalogEntry *)GetEntry(context, CatalogType::COPY_FUNCTION_ENTRY, schema_name, name, if_exists,
363: 	                                            error_context);
364: }
365: 
366: template <>
367: PragmaFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
368:                                               bool if_exists, QueryErrorContext error_context) {
369: 	return (PragmaFunctionCatalogEntry *)GetEntry(context, CatalogType::PRAGMA_FUNCTION_ENTRY, schema_name, name,
370: 	                                              if_exists, error_context);
371: }
372: 
373: template <>
374: AggregateFunctionCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
375:                                                  bool if_exists, QueryErrorContext error_context) {
376: 	auto entry = GetEntry(context, CatalogType::AGGREGATE_FUNCTION_ENTRY, schema_name, name, if_exists, error_context);
377: 	if (entry->type != CatalogType::AGGREGATE_FUNCTION_ENTRY) {
378: 		throw CatalogException(error_context.FormatError("%s is not an aggregate function", name));
379: 	}
380: 	return (AggregateFunctionCatalogEntry *)entry;
381: }
382: 
383: template <>
384: CollateCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
385:                                        bool if_exists, QueryErrorContext error_context) {
386: 	return (CollateCatalogEntry *)GetEntry(context, CatalogType::COLLATION_ENTRY, schema_name, name, if_exists,
387: 	                                       error_context);
388: }
389: 
390: template <>
391: TypeCatalogEntry *Catalog::GetEntry(ClientContext &context, const string &schema_name, const string &name,
392:                                     bool if_exists, QueryErrorContext error_context) {
393: 	return (TypeCatalogEntry *)GetEntry(context, CatalogType::TYPE_ENTRY, schema_name, name, if_exists, error_context);
394: }
395: 
396: LogicalType Catalog::GetType(ClientContext &context, const string &schema, const string &name) {
397: 	auto user_type_catalog = GetEntry<TypeCatalogEntry>(context, schema, name);
398: 	auto result_type = user_type_catalog->user_type;
399: 	LogicalType::SetCatalog(result_type, user_type_catalog);
400: 	return result_type;
401: }
402: 
403: void Catalog::Alter(ClientContext &context, AlterInfo *info) {
404: 	ModifyCatalog();
405: 	auto lookup = LookupEntry(context, info->GetCatalogType(), info->schema, info->name, info->if_exists);
406: 	if (!lookup.Found()) {
407: 		return;
408: 	}
409: 	return lookup.schema->Alter(context, info);
410: }
411: 
412: idx_t Catalog::GetCatalogVersion() {
413: 	return catalog_version;
414: }
415: 
416: idx_t Catalog::ModifyCatalog() {
417: 	return catalog_version++;
418: }
419: 
420: } // namespace duckdb
[end of src/catalog/catalog.cpp]
[start of src/common/types/value.cpp]
1: #include "duckdb/common/types/value.hpp"
2: 
3: #include "duckdb/common/exception.hpp"
4: #include "duckdb/common/to_string.hpp"
5: #include "duckdb/common/limits.hpp"
6: #include "duckdb/common/operator/aggregate_operators.hpp"
7: #include "duckdb/common/operator/cast_operators.hpp"
8: #include "duckdb/common/operator/comparison_operators.hpp"
9: 
10: #include "utf8proc_wrapper.hpp"
11: #include "duckdb/common/operator/numeric_binary_operators.hpp"
12: #include "duckdb/common/printer.hpp"
13: #include "duckdb/common/field_writer.hpp"
14: #include "duckdb/common/types/blob.hpp"
15: #include "duckdb/common/types/date.hpp"
16: #include "duckdb/common/types/decimal.hpp"
17: #include "duckdb/common/types/hugeint.hpp"
18: #include "duckdb/common/types/uuid.hpp"
19: #include "duckdb/common/types/interval.hpp"
20: #include "duckdb/common/types/null_value.hpp"
21: #include "duckdb/common/types/time.hpp"
22: #include "duckdb/common/types/timestamp.hpp"
23: #include "duckdb/common/types/vector.hpp"
24: #include "duckdb/common/value_operations/value_operations.hpp"
25: #include "duckdb/common/vector_operations/vector_operations.hpp"
26: #include "duckdb/common/string_util.hpp"
27: #include "duckdb/common/types/cast_helpers.hpp"
28: #include "duckdb/common/types/hash.hpp"
29: #include "duckdb/function/cast/cast_function_set.hpp"
30: 
31: #include <utility>
32: #include <cmath>
33: 
34: namespace duckdb {
35: 
36: Value::Value(LogicalType type) : type_(move(type)), is_null(true) {
37: }
38: 
39: Value::Value(int32_t val) : type_(LogicalType::INTEGER), is_null(false) {
40: 	value_.integer = val;
41: }
42: 
43: Value::Value(int64_t val) : type_(LogicalType::BIGINT), is_null(false) {
44: 	value_.bigint = val;
45: }
46: 
47: Value::Value(float val) : type_(LogicalType::FLOAT), is_null(false) {
48: 	value_.float_ = val;
49: }
50: 
51: Value::Value(double val) : type_(LogicalType::DOUBLE), is_null(false) {
52: 	value_.double_ = val;
53: }
54: 
55: Value::Value(const char *val) : Value(val ? string(val) : string()) {
56: }
57: 
58: Value::Value(std::nullptr_t val) : Value(LogicalType::VARCHAR) {
59: }
60: 
61: Value::Value(string_t val) : Value(string(val.GetDataUnsafe(), val.GetSize())) {
62: }
63: 
64: Value::Value(string val) : type_(LogicalType::VARCHAR), is_null(false), str_value(move(val)) {
65: 	if (!Value::StringIsValid(str_value.c_str(), str_value.size())) {
66: 		throw Exception("String value is not valid UTF8");
67: 	}
68: }
69: 
70: Value::~Value() {
71: }
72: 
73: Value::Value(const Value &other)
74:     : type_(other.type_), is_null(other.is_null), value_(other.value_), str_value(other.str_value),
75:       struct_value(other.struct_value), list_value(other.list_value) {
76: }
77: 
78: Value::Value(Value &&other) noexcept
79:     : type_(move(other.type_)), is_null(other.is_null), value_(other.value_), str_value(move(other.str_value)),
80:       struct_value(move(other.struct_value)), list_value(move(other.list_value)) {
81: }
82: 
83: Value &Value::operator=(const Value &other) {
84: 	type_ = other.type_;
85: 	is_null = other.is_null;
86: 	value_ = other.value_;
87: 	str_value = other.str_value;
88: 	struct_value = other.struct_value;
89: 	list_value = other.list_value;
90: 	return *this;
91: }
92: 
93: Value &Value::operator=(Value &&other) noexcept {
94: 	type_ = move(other.type_);
95: 	is_null = other.is_null;
96: 	value_ = other.value_;
97: 	str_value = move(other.str_value);
98: 	struct_value = move(other.struct_value);
99: 	list_value = move(other.list_value);
100: 	return *this;
101: }
102: 
103: Value Value::MinimumValue(const LogicalType &type) {
104: 	switch (type.id()) {
105: 	case LogicalTypeId::BOOLEAN:
106: 		return Value::BOOLEAN(false);
107: 	case LogicalTypeId::TINYINT:
108: 		return Value::TINYINT(NumericLimits<int8_t>::Minimum());
109: 	case LogicalTypeId::SMALLINT:
110: 		return Value::SMALLINT(NumericLimits<int16_t>::Minimum());
111: 	case LogicalTypeId::INTEGER:
112: 	case LogicalTypeId::SQLNULL:
113: 		return Value::INTEGER(NumericLimits<int32_t>::Minimum());
114: 	case LogicalTypeId::BIGINT:
115: 		return Value::BIGINT(NumericLimits<int64_t>::Minimum());
116: 	case LogicalTypeId::HUGEINT:
117: 		return Value::HUGEINT(NumericLimits<hugeint_t>::Minimum());
118: 	case LogicalTypeId::UUID:
119: 		return Value::UUID(NumericLimits<hugeint_t>::Minimum());
120: 	case LogicalTypeId::UTINYINT:
121: 		return Value::UTINYINT(NumericLimits<uint8_t>::Minimum());
122: 	case LogicalTypeId::USMALLINT:
123: 		return Value::USMALLINT(NumericLimits<uint16_t>::Minimum());
124: 	case LogicalTypeId::UINTEGER:
125: 		return Value::UINTEGER(NumericLimits<uint32_t>::Minimum());
126: 	case LogicalTypeId::UBIGINT:
127: 		return Value::UBIGINT(NumericLimits<uint64_t>::Minimum());
128: 	case LogicalTypeId::DATE:
129: 		return Value::DATE(Date::FromDate(Date::DATE_MIN_YEAR, Date::DATE_MIN_MONTH, Date::DATE_MIN_DAY));
130: 	case LogicalTypeId::TIME:
131: 		return Value::TIME(dtime_t(0));
132: 	case LogicalTypeId::TIMESTAMP:
133: 		return Value::TIMESTAMP(Date::FromDate(Timestamp::MIN_YEAR, Timestamp::MIN_MONTH, Timestamp::MIN_DAY),
134: 		                        dtime_t(0));
135: 	case LogicalTypeId::TIMESTAMP_SEC:
136: 		return MinimumValue(LogicalType::TIMESTAMP).DefaultCastAs(LogicalType::TIMESTAMP_S);
137: 	case LogicalTypeId::TIMESTAMP_MS:
138: 		return MinimumValue(LogicalType::TIMESTAMP).DefaultCastAs(LogicalType::TIMESTAMP_MS);
139: 	case LogicalTypeId::TIMESTAMP_NS:
140: 		return Value::TIMESTAMPNS(timestamp_t(NumericLimits<int64_t>::Minimum()));
141: 	case LogicalTypeId::TIME_TZ:
142: 		return Value::TIMETZ(dtime_t(0));
143: 	case LogicalTypeId::TIMESTAMP_TZ:
144: 		return Value::TIMESTAMPTZ(Timestamp::FromDatetime(
145: 		    Date::FromDate(Timestamp::MIN_YEAR, Timestamp::MIN_MONTH, Timestamp::MIN_DAY), dtime_t(0)));
146: 	case LogicalTypeId::FLOAT:
147: 		return Value::FLOAT(NumericLimits<float>::Minimum());
148: 	case LogicalTypeId::DOUBLE:
149: 		return Value::DOUBLE(NumericLimits<double>::Minimum());
150: 	case LogicalTypeId::DECIMAL: {
151: 		auto width = DecimalType::GetWidth(type);
152: 		auto scale = DecimalType::GetScale(type);
153: 		switch (type.InternalType()) {
154: 		case PhysicalType::INT16:
155: 			return Value::DECIMAL(int16_t(-NumericHelper::POWERS_OF_TEN[width] + 1), width, scale);
156: 		case PhysicalType::INT32:
157: 			return Value::DECIMAL(int32_t(-NumericHelper::POWERS_OF_TEN[width] + 1), width, scale);
158: 		case PhysicalType::INT64:
159: 			return Value::DECIMAL(int64_t(-NumericHelper::POWERS_OF_TEN[width] + 1), width, scale);
160: 		case PhysicalType::INT128:
161: 			return Value::DECIMAL(-Hugeint::POWERS_OF_TEN[width] + 1, width, scale);
162: 		default:
163: 			throw InternalException("Unknown decimal type");
164: 		}
165: 	}
166: 	case LogicalTypeId::ENUM:
167: 		return Value::ENUM(0, type);
168: 	default:
169: 		throw InvalidTypeException(type, "MinimumValue requires numeric type");
170: 	}
171: }
172: 
173: Value Value::MaximumValue(const LogicalType &type) {
174: 	switch (type.id()) {
175: 	case LogicalTypeId::BOOLEAN:
176: 		return Value::BOOLEAN(true);
177: 	case LogicalTypeId::TINYINT:
178: 		return Value::TINYINT(NumericLimits<int8_t>::Maximum());
179: 	case LogicalTypeId::SMALLINT:
180: 		return Value::SMALLINT(NumericLimits<int16_t>::Maximum());
181: 	case LogicalTypeId::INTEGER:
182: 	case LogicalTypeId::SQLNULL:
183: 		return Value::INTEGER(NumericLimits<int32_t>::Maximum());
184: 	case LogicalTypeId::BIGINT:
185: 		return Value::BIGINT(NumericLimits<int64_t>::Maximum());
186: 	case LogicalTypeId::HUGEINT:
187: 		return Value::HUGEINT(NumericLimits<hugeint_t>::Maximum());
188: 	case LogicalTypeId::UUID:
189: 		return Value::UUID(NumericLimits<hugeint_t>::Maximum());
190: 	case LogicalTypeId::UTINYINT:
191: 		return Value::UTINYINT(NumericLimits<uint8_t>::Maximum());
192: 	case LogicalTypeId::USMALLINT:
193: 		return Value::USMALLINT(NumericLimits<uint16_t>::Maximum());
194: 	case LogicalTypeId::UINTEGER:
195: 		return Value::UINTEGER(NumericLimits<uint32_t>::Maximum());
196: 	case LogicalTypeId::UBIGINT:
197: 		return Value::UBIGINT(NumericLimits<uint64_t>::Maximum());
198: 	case LogicalTypeId::DATE:
199: 		return Value::DATE(Date::FromDate(Date::DATE_MAX_YEAR, Date::DATE_MAX_MONTH, Date::DATE_MAX_DAY));
200: 	case LogicalTypeId::TIME:
201: 		return Value::TIME(dtime_t(Interval::SECS_PER_DAY * Interval::MICROS_PER_SEC - 1));
202: 	case LogicalTypeId::TIMESTAMP:
203: 		return Value::TIMESTAMP(timestamp_t(NumericLimits<int64_t>::Maximum() - 1));
204: 	case LogicalTypeId::TIMESTAMP_MS:
205: 		return MaximumValue(LogicalType::TIMESTAMP).DefaultCastAs(LogicalType::TIMESTAMP_MS);
206: 	case LogicalTypeId::TIMESTAMP_NS:
207: 		return Value::TIMESTAMPNS(timestamp_t(NumericLimits<int64_t>::Maximum() - 1));
208: 	case LogicalTypeId::TIMESTAMP_SEC:
209: 		return MaximumValue(LogicalType::TIMESTAMP).DefaultCastAs(LogicalType::TIMESTAMP_S);
210: 	case LogicalTypeId::TIME_TZ:
211: 		return Value::TIMETZ(dtime_t(Interval::SECS_PER_DAY * Interval::MICROS_PER_SEC - 1));
212: 	case LogicalTypeId::TIMESTAMP_TZ:
213: 		return MaximumValue(LogicalType::TIMESTAMP);
214: 	case LogicalTypeId::FLOAT:
215: 		return Value::FLOAT(NumericLimits<float>::Maximum());
216: 	case LogicalTypeId::DOUBLE:
217: 		return Value::DOUBLE(NumericLimits<double>::Maximum());
218: 	case LogicalTypeId::DECIMAL: {
219: 		auto width = DecimalType::GetWidth(type);
220: 		auto scale = DecimalType::GetScale(type);
221: 		switch (type.InternalType()) {
222: 		case PhysicalType::INT16:
223: 			return Value::DECIMAL(int16_t(NumericHelper::POWERS_OF_TEN[width] - 1), width, scale);
224: 		case PhysicalType::INT32:
225: 			return Value::DECIMAL(int32_t(NumericHelper::POWERS_OF_TEN[width] - 1), width, scale);
226: 		case PhysicalType::INT64:
227: 			return Value::DECIMAL(int64_t(NumericHelper::POWERS_OF_TEN[width] - 1), width, scale);
228: 		case PhysicalType::INT128:
229: 			return Value::DECIMAL(Hugeint::POWERS_OF_TEN[width] - 1, width, scale);
230: 		default:
231: 			throw InternalException("Unknown decimal type");
232: 		}
233: 	}
234: 	case LogicalTypeId::ENUM:
235: 		return Value::ENUM(EnumType::GetSize(type) - 1, type);
236: 	default:
237: 		throw InvalidTypeException(type, "MaximumValue requires numeric type");
238: 	}
239: }
240: 
241: Value Value::BOOLEAN(int8_t value) {
242: 	Value result(LogicalType::BOOLEAN);
243: 	result.value_.boolean = value ? true : false;
244: 	result.is_null = false;
245: 	return result;
246: }
247: 
248: Value Value::TINYINT(int8_t value) {
249: 	Value result(LogicalType::TINYINT);
250: 	result.value_.tinyint = value;
251: 	result.is_null = false;
252: 	return result;
253: }
254: 
255: Value Value::SMALLINT(int16_t value) {
256: 	Value result(LogicalType::SMALLINT);
257: 	result.value_.smallint = value;
258: 	result.is_null = false;
259: 	return result;
260: }
261: 
262: Value Value::INTEGER(int32_t value) {
263: 	Value result(LogicalType::INTEGER);
264: 	result.value_.integer = value;
265: 	result.is_null = false;
266: 	return result;
267: }
268: 
269: Value Value::BIGINT(int64_t value) {
270: 	Value result(LogicalType::BIGINT);
271: 	result.value_.bigint = value;
272: 	result.is_null = false;
273: 	return result;
274: }
275: 
276: Value Value::HUGEINT(hugeint_t value) {
277: 	Value result(LogicalType::HUGEINT);
278: 	result.value_.hugeint = value;
279: 	result.is_null = false;
280: 	return result;
281: }
282: 
283: Value Value::UUID(hugeint_t value) {
284: 	Value result(LogicalType::UUID);
285: 	result.value_.hugeint = value;
286: 	result.is_null = false;
287: 	return result;
288: }
289: 
290: Value Value::UUID(const string &value) {
291: 	Value result(LogicalType::UUID);
292: 	result.value_.hugeint = UUID::FromString(value);
293: 	result.is_null = false;
294: 	return result;
295: }
296: 
297: Value Value::UTINYINT(uint8_t value) {
298: 	Value result(LogicalType::UTINYINT);
299: 	result.value_.utinyint = value;
300: 	result.is_null = false;
301: 	return result;
302: }
303: 
304: Value Value::USMALLINT(uint16_t value) {
305: 	Value result(LogicalType::USMALLINT);
306: 	result.value_.usmallint = value;
307: 	result.is_null = false;
308: 	return result;
309: }
310: 
311: Value Value::UINTEGER(uint32_t value) {
312: 	Value result(LogicalType::UINTEGER);
313: 	result.value_.uinteger = value;
314: 	result.is_null = false;
315: 	return result;
316: }
317: 
318: Value Value::UBIGINT(uint64_t value) {
319: 	Value result(LogicalType::UBIGINT);
320: 	result.value_.ubigint = value;
321: 	result.is_null = false;
322: 	return result;
323: }
324: 
325: bool Value::FloatIsFinite(float value) {
326: 	return !(std::isnan(value) || std::isinf(value));
327: }
328: 
329: bool Value::DoubleIsFinite(double value) {
330: 	return !(std::isnan(value) || std::isinf(value));
331: }
332: 
333: template <>
334: bool Value::IsNan(float input) {
335: 	return std::isnan(input);
336: }
337: 
338: template <>
339: bool Value::IsNan(double input) {
340: 	return std::isnan(input);
341: }
342: 
343: template <>
344: bool Value::IsFinite(float input) {
345: 	return Value::FloatIsFinite(input);
346: }
347: 
348: template <>
349: bool Value::IsFinite(double input) {
350: 	return Value::DoubleIsFinite(input);
351: }
352: 
353: template <>
354: bool Value::IsFinite(date_t input) {
355: 	return Date::IsFinite(input);
356: }
357: 
358: template <>
359: bool Value::IsFinite(timestamp_t input) {
360: 	return Timestamp::IsFinite(input);
361: }
362: 
363: bool Value::StringIsValid(const char *str, idx_t length) {
364: 	auto utf_type = Utf8Proc::Analyze(str, length);
365: 	return utf_type != UnicodeType::INVALID;
366: }
367: 
368: Value Value::DECIMAL(int16_t value, uint8_t width, uint8_t scale) {
369: 	D_ASSERT(width <= Decimal::MAX_WIDTH_INT16);
370: 	Value result(LogicalType::DECIMAL(width, scale));
371: 	result.value_.smallint = value;
372: 	result.is_null = false;
373: 	return result;
374: }
375: 
376: Value Value::DECIMAL(int32_t value, uint8_t width, uint8_t scale) {
377: 	D_ASSERT(width >= Decimal::MAX_WIDTH_INT16 && width <= Decimal::MAX_WIDTH_INT32);
378: 	Value result(LogicalType::DECIMAL(width, scale));
379: 	result.value_.integer = value;
380: 	result.is_null = false;
381: 	return result;
382: }
383: 
384: Value Value::DECIMAL(int64_t value, uint8_t width, uint8_t scale) {
385: 	auto decimal_type = LogicalType::DECIMAL(width, scale);
386: 	Value result(decimal_type);
387: 	switch (decimal_type.InternalType()) {
388: 	case PhysicalType::INT16:
389: 		result.value_.smallint = value;
390: 		break;
391: 	case PhysicalType::INT32:
392: 		result.value_.integer = value;
393: 		break;
394: 	case PhysicalType::INT64:
395: 		result.value_.bigint = value;
396: 		break;
397: 	default:
398: 		result.value_.hugeint = value;
399: 		break;
400: 	}
401: 	result.type_.Verify();
402: 	result.is_null = false;
403: 	return result;
404: }
405: 
406: Value Value::DECIMAL(hugeint_t value, uint8_t width, uint8_t scale) {
407: 	D_ASSERT(width >= Decimal::MAX_WIDTH_INT64 && width <= Decimal::MAX_WIDTH_INT128);
408: 	Value result(LogicalType::DECIMAL(width, scale));
409: 	result.value_.hugeint = value;
410: 	result.is_null = false;
411: 	return result;
412: }
413: 
414: Value Value::FLOAT(float value) {
415: 	Value result(LogicalType::FLOAT);
416: 	result.value_.float_ = value;
417: 	result.is_null = false;
418: 	return result;
419: }
420: 
421: Value Value::DOUBLE(double value) {
422: 	Value result(LogicalType::DOUBLE);
423: 	result.value_.double_ = value;
424: 	result.is_null = false;
425: 	return result;
426: }
427: 
428: Value Value::HASH(hash_t value) {
429: 	Value result(LogicalType::HASH);
430: 	result.value_.hash = value;
431: 	result.is_null = false;
432: 	return result;
433: }
434: 
435: Value Value::POINTER(uintptr_t value) {
436: 	Value result(LogicalType::POINTER);
437: 	result.value_.pointer = value;
438: 	result.is_null = false;
439: 	return result;
440: }
441: 
442: Value Value::DATE(date_t value) {
443: 	Value result(LogicalType::DATE);
444: 	result.value_.date = value;
445: 	result.is_null = false;
446: 	return result;
447: }
448: 
449: Value Value::DATE(int32_t year, int32_t month, int32_t day) {
450: 	return Value::DATE(Date::FromDate(year, month, day));
451: }
452: 
453: Value Value::TIME(dtime_t value) {
454: 	Value result(LogicalType::TIME);
455: 	result.value_.time = value;
456: 	result.is_null = false;
457: 	return result;
458: }
459: 
460: Value Value::TIMETZ(dtime_t value) {
461: 	Value result(LogicalType::TIME_TZ);
462: 	result.value_.time = value;
463: 	result.is_null = false;
464: 	return result;
465: }
466: 
467: Value Value::TIME(int32_t hour, int32_t min, int32_t sec, int32_t micros) {
468: 	return Value::TIME(Time::FromTime(hour, min, sec, micros));
469: }
470: 
471: Value Value::TIMESTAMP(timestamp_t value) {
472: 	Value result(LogicalType::TIMESTAMP);
473: 	result.value_.timestamp = value;
474: 	result.is_null = false;
475: 	return result;
476: }
477: 
478: Value Value::TIMESTAMPTZ(timestamp_t value) {
479: 	Value result(LogicalType::TIMESTAMP_TZ);
480: 	result.value_.timestamp = value;
481: 	result.is_null = false;
482: 	return result;
483: }
484: 
485: Value Value::TIMESTAMPNS(timestamp_t timestamp) {
486: 	Value result(LogicalType::TIMESTAMP_NS);
487: 	result.value_.timestamp = timestamp;
488: 	result.is_null = false;
489: 	return result;
490: }
491: 
492: Value Value::TIMESTAMPMS(timestamp_t timestamp) {
493: 	Value result(LogicalType::TIMESTAMP_MS);
494: 	result.value_.timestamp = timestamp;
495: 	result.is_null = false;
496: 	return result;
497: }
498: 
499: Value Value::TIMESTAMPSEC(timestamp_t timestamp) {
500: 	Value result(LogicalType::TIMESTAMP_S);
501: 	result.value_.timestamp = timestamp;
502: 	result.is_null = false;
503: 	return result;
504: }
505: 
506: Value Value::TIMESTAMP(date_t date, dtime_t time) {
507: 	return Value::TIMESTAMP(Timestamp::FromDatetime(date, time));
508: }
509: 
510: Value Value::TIMESTAMP(int32_t year, int32_t month, int32_t day, int32_t hour, int32_t min, int32_t sec,
511:                        int32_t micros) {
512: 	auto val = Value::TIMESTAMP(Date::FromDate(year, month, day), Time::FromTime(hour, min, sec, micros));
513: 	val.type_ = LogicalType::TIMESTAMP;
514: 	return val;
515: }
516: 
517: Value Value::STRUCT(child_list_t<Value> values) {
518: 	Value result;
519: 	child_list_t<LogicalType> child_types;
520: 	for (auto &child : values) {
521: 		child_types.push_back(make_pair(move(child.first), child.second.type()));
522: 		result.struct_value.push_back(move(child.second));
523: 	}
524: 	result.type_ = LogicalType::STRUCT(move(child_types));
525: 
526: 	result.is_null = false;
527: 	return result;
528: }
529: 
530: Value Value::MAP(Value key, Value value) {
531: 	Value result;
532: 	child_list_t<LogicalType> child_types;
533: 	child_types.push_back({"key", key.type()});
534: 	child_types.push_back({"value", value.type()});
535: 
536: 	result.type_ = LogicalType::MAP(move(child_types));
537: 
538: 	result.struct_value.push_back(move(key));
539: 	result.struct_value.push_back(move(value));
540: 	result.is_null = false;
541: 	return result;
542: }
543: 
544: Value Value::UNION(child_list_t<LogicalType> members, uint8_t tag, Value value) {
545: 	D_ASSERT(members.size() > 0);
546: 	D_ASSERT(members.size() <= UnionType::MAX_UNION_MEMBERS);
547: 	D_ASSERT(members.size() > tag);
548: 
549: 	D_ASSERT(value.type() == members[tag].second);
550: 
551: 	Value result;
552: 	result.is_null = false;
553: 	// add the tag to the front of the struct
554: 	result.struct_value.emplace_back(Value::TINYINT(tag));
555: 	for (idx_t i = 0; i < members.size(); i++) {
556: 		if (i != tag) {
557: 			result.struct_value.emplace_back(members[i].second);
558: 		} else {
559: 			result.struct_value.emplace_back(nullptr);
560: 		}
561: 	}
562: 	result.struct_value[tag + 1] = move(value);
563: 
564: 	result.type_ = LogicalType::UNION(move(members));
565: 	return result;
566: }
567: 
568: Value Value::LIST(vector<Value> values) {
569: 	if (values.empty()) {
570: 		throw InternalException("Value::LIST requires a non-empty list of values. Use Value::EMPTYLIST instead.");
571: 	}
572: #ifdef DEBUG
573: 	for (idx_t i = 1; i < values.size(); i++) {
574: 		D_ASSERT(values[i].type() == values[0].type());
575: 	}
576: #endif
577: 	Value result;
578: 	result.type_ = LogicalType::LIST(values[0].type());
579: 	result.list_value = move(values);
580: 	result.is_null = false;
581: 	return result;
582: }
583: 
584: Value Value::LIST(LogicalType child_type, vector<Value> values) {
585: 	if (values.empty()) {
586: 		return Value::EMPTYLIST(move(child_type));
587: 	}
588: 	for (auto &val : values) {
589: 		val = val.DefaultCastAs(child_type);
590: 	}
591: 	return Value::LIST(move(values));
592: }
593: 
594: Value Value::EMPTYLIST(LogicalType child_type) {
595: 	Value result;
596: 	result.type_ = LogicalType::LIST(move(child_type));
597: 	result.is_null = false;
598: 	return result;
599: }
600: 
601: Value Value::BLOB(const_data_ptr_t data, idx_t len) {
602: 	Value result(LogicalType::BLOB);
603: 	result.is_null = false;
604: 	result.str_value = string((const char *)data, len);
605: 	return result;
606: }
607: 
608: Value Value::BLOB(const string &data) {
609: 	Value result(LogicalType::BLOB);
610: 	result.is_null = false;
611: 	result.str_value = Blob::ToBlob(string_t(data));
612: 	return result;
613: }
614: 
615: Value Value::JSON(const char *val) {
616: 	auto result = Value(val);
617: 	result.type_ = LogicalTypeId::JSON;
618: 	return result;
619: }
620: 
621: Value Value::JSON(string_t val) {
622: 	auto result = Value(val);
623: 	result.type_ = LogicalTypeId::JSON;
624: 	return result;
625: }
626: 
627: Value Value::JSON(string val) {
628: 	auto result = Value(move(val));
629: 	result.type_ = LogicalTypeId::JSON;
630: 	return result;
631: }
632: 
633: Value Value::ENUM(uint64_t value, const LogicalType &original_type) {
634: 	D_ASSERT(original_type.id() == LogicalTypeId::ENUM);
635: 	Value result(original_type);
636: 	switch (original_type.InternalType()) {
637: 	case PhysicalType::UINT8:
638: 		result.value_.utinyint = value;
639: 		break;
640: 	case PhysicalType::UINT16:
641: 		result.value_.usmallint = value;
642: 		break;
643: 	case PhysicalType::UINT32:
644: 		result.value_.uinteger = value;
645: 		break;
646: 	case PhysicalType::UINT64: //  DEDUP_POINTER_ENUM
647: 		result.value_.ubigint = value;
648: 		break;
649: 	default:
650: 		throw InternalException("Incorrect Physical Type for ENUM");
651: 	}
652: 	result.is_null = false;
653: 	return result;
654: }
655: 
656: Value Value::INTERVAL(int32_t months, int32_t days, int64_t micros) {
657: 	Value result(LogicalType::INTERVAL);
658: 	result.is_null = false;
659: 	result.value_.interval.months = months;
660: 	result.value_.interval.days = days;
661: 	result.value_.interval.micros = micros;
662: 	return result;
663: }
664: 
665: Value Value::INTERVAL(interval_t interval) {
666: 	return Value::INTERVAL(interval.months, interval.days, interval.micros);
667: }
668: 
669: //===--------------------------------------------------------------------===//
670: // CreateValue
671: //===--------------------------------------------------------------------===//
672: template <>
673: Value Value::CreateValue(bool value) {
674: 	return Value::BOOLEAN(value);
675: }
676: 
677: template <>
678: Value Value::CreateValue(int8_t value) {
679: 	return Value::TINYINT(value);
680: }
681: 
682: template <>
683: Value Value::CreateValue(int16_t value) {
684: 	return Value::SMALLINT(value);
685: }
686: 
687: template <>
688: Value Value::CreateValue(int32_t value) {
689: 	return Value::INTEGER(value);
690: }
691: 
692: template <>
693: Value Value::CreateValue(int64_t value) {
694: 	return Value::BIGINT(value);
695: }
696: 
697: template <>
698: Value Value::CreateValue(uint8_t value) {
699: 	return Value::UTINYINT(value);
700: }
701: 
702: template <>
703: Value Value::CreateValue(uint16_t value) {
704: 	return Value::USMALLINT(value);
705: }
706: 
707: template <>
708: Value Value::CreateValue(uint32_t value) {
709: 	return Value::UINTEGER(value);
710: }
711: 
712: template <>
713: Value Value::CreateValue(uint64_t value) {
714: 	return Value::UBIGINT(value);
715: }
716: 
717: template <>
718: Value Value::CreateValue(hugeint_t value) {
719: 	return Value::HUGEINT(value);
720: }
721: 
722: template <>
723: Value Value::CreateValue(date_t value) {
724: 	return Value::DATE(value);
725: }
726: 
727: template <>
728: Value Value::CreateValue(dtime_t value) {
729: 	return Value::TIME(value);
730: }
731: 
732: template <>
733: Value Value::CreateValue(dtime_tz_t value) {
734: 	return Value::TIMETZ(value);
735: }
736: 
737: template <>
738: Value Value::CreateValue(timestamp_t value) {
739: 	return Value::TIMESTAMP(value);
740: }
741: 
742: template <>
743: Value Value::CreateValue(timestamp_sec_t value) {
744: 	return Value::TIMESTAMPSEC(value);
745: }
746: 
747: template <>
748: Value Value::CreateValue(timestamp_ms_t value) {
749: 	return Value::TIMESTAMPMS(value);
750: }
751: 
752: template <>
753: Value Value::CreateValue(timestamp_ns_t value) {
754: 	return Value::TIMESTAMPNS(value);
755: }
756: 
757: template <>
758: Value Value::CreateValue(timestamp_tz_t value) {
759: 	return Value::TIMESTAMPTZ(value);
760: }
761: 
762: template <>
763: Value Value::CreateValue(const char *value) {
764: 	return Value(string(value));
765: }
766: 
767: template <>
768: Value Value::CreateValue(string value) { // NOLINT: required for templating
769: 	return Value::BLOB(value);
770: }
771: 
772: template <>
773: Value Value::CreateValue(string_t value) {
774: 	return Value(value);
775: }
776: 
777: template <>
778: Value Value::CreateValue(float value) {
779: 	return Value::FLOAT(value);
780: }
781: 
782: template <>
783: Value Value::CreateValue(double value) {
784: 	return Value::DOUBLE(value);
785: }
786: 
787: template <>
788: Value Value::CreateValue(interval_t value) {
789: 	return Value::INTERVAL(value);
790: }
791: 
792: template <>
793: Value Value::CreateValue(Value value) {
794: 	return value;
795: }
796: 
797: //===--------------------------------------------------------------------===//
798: // GetValue
799: //===--------------------------------------------------------------------===//
800: template <class T>
801: T Value::GetValueInternal() const {
802: 	if (IsNull()) {
803: 		throw InternalException("Calling GetValueInternal on a value that is NULL");
804: 	}
805: 	switch (type_.id()) {
806: 	case LogicalTypeId::BOOLEAN:
807: 		return Cast::Operation<bool, T>(value_.boolean);
808: 	case LogicalTypeId::TINYINT:
809: 		return Cast::Operation<int8_t, T>(value_.tinyint);
810: 	case LogicalTypeId::SMALLINT:
811: 		return Cast::Operation<int16_t, T>(value_.smallint);
812: 	case LogicalTypeId::INTEGER:
813: 		return Cast::Operation<int32_t, T>(value_.integer);
814: 	case LogicalTypeId::BIGINT:
815: 		return Cast::Operation<int64_t, T>(value_.bigint);
816: 	case LogicalTypeId::HUGEINT:
817: 	case LogicalTypeId::UUID:
818: 		return Cast::Operation<hugeint_t, T>(value_.hugeint);
819: 	case LogicalTypeId::DATE:
820: 		return Cast::Operation<date_t, T>(value_.date);
821: 	case LogicalTypeId::TIME:
822: 	case LogicalTypeId::TIME_TZ:
823: 		return Cast::Operation<dtime_t, T>(value_.time);
824: 	case LogicalTypeId::TIMESTAMP:
825: 	case LogicalTypeId::TIMESTAMP_TZ:
826: 		return Cast::Operation<timestamp_t, T>(value_.timestamp);
827: 	case LogicalTypeId::UTINYINT:
828: 		return Cast::Operation<uint8_t, T>(value_.utinyint);
829: 	case LogicalTypeId::USMALLINT:
830: 		return Cast::Operation<uint16_t, T>(value_.usmallint);
831: 	case LogicalTypeId::UINTEGER:
832: 		return Cast::Operation<uint32_t, T>(value_.uinteger);
833: 	case LogicalTypeId::TIMESTAMP_MS:
834: 	case LogicalTypeId::TIMESTAMP_NS:
835: 	case LogicalTypeId::TIMESTAMP_SEC:
836: 	case LogicalTypeId::UBIGINT:
837: 		return Cast::Operation<uint64_t, T>(value_.ubigint);
838: 	case LogicalTypeId::FLOAT:
839: 		return Cast::Operation<float, T>(value_.float_);
840: 	case LogicalTypeId::DOUBLE:
841: 		return Cast::Operation<double, T>(value_.double_);
842: 	case LogicalTypeId::VARCHAR:
843: 		return Cast::Operation<string_t, T>(str_value.c_str());
844: 	case LogicalTypeId::INTERVAL:
845: 		return Cast::Operation<interval_t, T>(value_.interval);
846: 	case LogicalTypeId::DECIMAL:
847: 		return DefaultCastAs(LogicalType::DOUBLE).GetValueInternal<T>();
848: 	case LogicalTypeId::ENUM: {
849: 		switch (type_.InternalType()) {
850: 		case PhysicalType::UINT8:
851: 			return Cast::Operation<uint8_t, T>(value_.utinyint);
852: 		case PhysicalType::UINT16:
853: 			return Cast::Operation<uint16_t, T>(value_.usmallint);
854: 		case PhysicalType::UINT32:
855: 			return Cast::Operation<uint32_t, T>(value_.uinteger);
856: 		default:
857: 			throw InternalException("Invalid Internal Type for ENUMs");
858: 		}
859: 	}
860: 	default:
861: 		throw NotImplementedException("Unimplemented type \"%s\" for GetValue()", type_.ToString());
862: 	}
863: }
864: 
865: template <>
866: bool Value::GetValue() const {
867: 	return GetValueInternal<int8_t>();
868: }
869: template <>
870: int8_t Value::GetValue() const {
871: 	return GetValueInternal<int8_t>();
872: }
873: template <>
874: int16_t Value::GetValue() const {
875: 	return GetValueInternal<int16_t>();
876: }
877: template <>
878: int32_t Value::GetValue() const {
879: 	if (type_.id() == LogicalTypeId::DATE) {
880: 		return value_.integer;
881: 	}
882: 	return GetValueInternal<int32_t>();
883: }
884: template <>
885: int64_t Value::GetValue() const {
886: 	if (IsNull()) {
887: 		throw InternalException("Calling GetValue on a value that is NULL");
888: 	}
889: 	switch (type_.id()) {
890: 	case LogicalTypeId::TIMESTAMP:
891: 	case LogicalTypeId::TIMESTAMP_SEC:
892: 	case LogicalTypeId::TIMESTAMP_NS:
893: 	case LogicalTypeId::TIMESTAMP_MS:
894: 	case LogicalTypeId::TIME:
895: 	case LogicalTypeId::TIME_TZ:
896: 	case LogicalTypeId::TIMESTAMP_TZ:
897: 		return value_.bigint;
898: 	default:
899: 		return GetValueInternal<int64_t>();
900: 	}
901: }
902: template <>
903: hugeint_t Value::GetValue() const {
904: 	return GetValueInternal<hugeint_t>();
905: }
906: template <>
907: uint8_t Value::GetValue() const {
908: 	return GetValueInternal<uint8_t>();
909: }
910: template <>
911: uint16_t Value::GetValue() const {
912: 	return GetValueInternal<uint16_t>();
913: }
914: template <>
915: uint32_t Value::GetValue() const {
916: 	return GetValueInternal<uint32_t>();
917: }
918: template <>
919: uint64_t Value::GetValue() const {
920: 	return GetValueInternal<uint64_t>();
921: }
922: template <>
923: string Value::GetValue() const {
924: 	return ToString();
925: }
926: template <>
927: float Value::GetValue() const {
928: 	return GetValueInternal<float>();
929: }
930: template <>
931: double Value::GetValue() const {
932: 	return GetValueInternal<double>();
933: }
934: template <>
935: date_t Value::GetValue() const {
936: 	return GetValueInternal<date_t>();
937: }
938: template <>
939: dtime_t Value::GetValue() const {
940: 	return GetValueInternal<dtime_t>();
941: }
942: template <>
943: timestamp_t Value::GetValue() const {
944: 	return GetValueInternal<timestamp_t>();
945: }
946: 
947: template <>
948: DUCKDB_API interval_t Value::GetValue() const {
949: 	return GetValueInternal<interval_t>();
950: }
951: 
952: template <>
953: DUCKDB_API Value Value::GetValue() const {
954: 	return Value(*this);
955: }
956: 
957: uintptr_t Value::GetPointer() const {
958: 	D_ASSERT(type() == LogicalType::POINTER);
959: 	return value_.pointer;
960: }
961: 
962: Value Value::Numeric(const LogicalType &type, int64_t value) {
963: 	switch (type.id()) {
964: 	case LogicalTypeId::BOOLEAN:
965: 		D_ASSERT(value == 0 || value == 1);
966: 		return Value::BOOLEAN(value ? 1 : 0);
967: 	case LogicalTypeId::TINYINT:
968: 		D_ASSERT(value >= NumericLimits<int8_t>::Minimum() && value <= NumericLimits<int8_t>::Maximum());
969: 		return Value::TINYINT((int8_t)value);
970: 	case LogicalTypeId::SMALLINT:
971: 		D_ASSERT(value >= NumericLimits<int16_t>::Minimum() && value <= NumericLimits<int16_t>::Maximum());
972: 		return Value::SMALLINT((int16_t)value);
973: 	case LogicalTypeId::INTEGER:
974: 		D_ASSERT(value >= NumericLimits<int32_t>::Minimum() && value <= NumericLimits<int32_t>::Maximum());
975: 		return Value::INTEGER((int32_t)value);
976: 	case LogicalTypeId::BIGINT:
977: 		return Value::BIGINT(value);
978: 	case LogicalTypeId::UTINYINT:
979: 		D_ASSERT(value >= NumericLimits<uint8_t>::Minimum() && value <= NumericLimits<uint8_t>::Maximum());
980: 		return Value::UTINYINT((uint8_t)value);
981: 	case LogicalTypeId::USMALLINT:
982: 		D_ASSERT(value >= NumericLimits<uint16_t>::Minimum() && value <= NumericLimits<uint16_t>::Maximum());
983: 		return Value::USMALLINT((uint16_t)value);
984: 	case LogicalTypeId::UINTEGER:
985: 		D_ASSERT(value >= NumericLimits<uint32_t>::Minimum() && value <= NumericLimits<uint32_t>::Maximum());
986: 		return Value::UINTEGER((uint32_t)value);
987: 	case LogicalTypeId::UBIGINT:
988: 		D_ASSERT(value >= 0);
989: 		return Value::UBIGINT(value);
990: 	case LogicalTypeId::HUGEINT:
991: 		return Value::HUGEINT(value);
992: 	case LogicalTypeId::DECIMAL:
993: 		return Value::DECIMAL(value, DecimalType::GetWidth(type), DecimalType::GetScale(type));
994: 	case LogicalTypeId::FLOAT:
995: 		return Value((float)value);
996: 	case LogicalTypeId::DOUBLE:
997: 		return Value((double)value);
998: 	case LogicalTypeId::POINTER:
999: 		return Value::POINTER(value);
1000: 	case LogicalTypeId::DATE:
1001: 		D_ASSERT(value >= NumericLimits<int32_t>::Minimum() && value <= NumericLimits<int32_t>::Maximum());
1002: 		return Value::DATE(date_t(value));
1003: 	case LogicalTypeId::TIME:
1004: 		return Value::TIME(dtime_t(value));
1005: 	case LogicalTypeId::TIMESTAMP:
1006: 		return Value::TIMESTAMP(timestamp_t(value));
1007: 	case LogicalTypeId::TIMESTAMP_NS:
1008: 		return Value::TIMESTAMPNS(timestamp_t(value));
1009: 	case LogicalTypeId::TIMESTAMP_MS:
1010: 		return Value::TIMESTAMPMS(timestamp_t(value));
1011: 	case LogicalTypeId::TIMESTAMP_SEC:
1012: 		return Value::TIMESTAMPSEC(timestamp_t(value));
1013: 	case LogicalTypeId::TIME_TZ:
1014: 		return Value::TIMETZ(dtime_t(value));
1015: 	case LogicalTypeId::TIMESTAMP_TZ:
1016: 		return Value::TIMESTAMPTZ(timestamp_t(value));
1017: 	case LogicalTypeId::ENUM:
1018: 		switch (type.InternalType()) {
1019: 		case PhysicalType::UINT8:
1020: 			D_ASSERT(value >= NumericLimits<uint8_t>::Minimum() && value <= NumericLimits<uint8_t>::Maximum());
1021: 			return Value::UTINYINT((uint8_t)value);
1022: 		case PhysicalType::UINT16:
1023: 			D_ASSERT(value >= NumericLimits<uint16_t>::Minimum() && value <= NumericLimits<uint16_t>::Maximum());
1024: 			return Value::USMALLINT((uint16_t)value);
1025: 		case PhysicalType::UINT32:
1026: 			D_ASSERT(value >= NumericLimits<uint32_t>::Minimum() && value <= NumericLimits<uint32_t>::Maximum());
1027: 			return Value::UINTEGER((uint32_t)value);
1028: 		default:
1029: 			throw InternalException("Enum doesn't accept this physical type");
1030: 		}
1031: 	default:
1032: 		throw InvalidTypeException(type, "Numeric requires numeric type");
1033: 	}
1034: }
1035: 
1036: Value Value::Numeric(const LogicalType &type, hugeint_t value) {
1037: #ifdef DEBUG
1038: 	// perform a throwing cast to verify that the type fits
1039: 	Value::HUGEINT(value).DefaultCastAs(type);
1040: #endif
1041: 	switch (type.id()) {
1042: 	case LogicalTypeId::HUGEINT:
1043: 		return Value::HUGEINT(value);
1044: 	case LogicalTypeId::UBIGINT:
1045: 		return Value::UBIGINT(Hugeint::Cast<uint64_t>(value));
1046: 	default:
1047: 		return Value::Numeric(type, Hugeint::Cast<int64_t>(value));
1048: 	}
1049: }
1050: 
1051: //===--------------------------------------------------------------------===//
1052: // GetValueUnsafe
1053: //===--------------------------------------------------------------------===//
1054: template <>
1055: DUCKDB_API bool Value::GetValueUnsafe() const {
1056: 	D_ASSERT(type_.InternalType() == PhysicalType::BOOL);
1057: 	return value_.boolean;
1058: }
1059: 
1060: template <>
1061: int8_t Value::GetValueUnsafe() const {
1062: 	D_ASSERT(type_.InternalType() == PhysicalType::INT8 || type_.InternalType() == PhysicalType::BOOL);
1063: 	return value_.tinyint;
1064: }
1065: 
1066: template <>
1067: int16_t Value::GetValueUnsafe() const {
1068: 	D_ASSERT(type_.InternalType() == PhysicalType::INT16);
1069: 	return value_.smallint;
1070: }
1071: 
1072: template <>
1073: int32_t Value::GetValueUnsafe() const {
1074: 	D_ASSERT(type_.InternalType() == PhysicalType::INT32);
1075: 	return value_.integer;
1076: }
1077: 
1078: template <>
1079: int64_t Value::GetValueUnsafe() const {
1080: 	D_ASSERT(type_.InternalType() == PhysicalType::INT64);
1081: 	return value_.bigint;
1082: }
1083: 
1084: template <>
1085: hugeint_t Value::GetValueUnsafe() const {
1086: 	D_ASSERT(type_.InternalType() == PhysicalType::INT128);
1087: 	return value_.hugeint;
1088: }
1089: 
1090: template <>
1091: uint8_t Value::GetValueUnsafe() const {
1092: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT8);
1093: 	return value_.utinyint;
1094: }
1095: 
1096: template <>
1097: uint16_t Value::GetValueUnsafe() const {
1098: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT16);
1099: 	return value_.usmallint;
1100: }
1101: 
1102: template <>
1103: uint32_t Value::GetValueUnsafe() const {
1104: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT32);
1105: 	return value_.uinteger;
1106: }
1107: 
1108: template <>
1109: uint64_t Value::GetValueUnsafe() const {
1110: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT64);
1111: 	return value_.ubigint;
1112: }
1113: 
1114: template <>
1115: string Value::GetValueUnsafe() const {
1116: 	D_ASSERT(type_.InternalType() == PhysicalType::VARCHAR);
1117: 	return str_value;
1118: }
1119: 
1120: template <>
1121: DUCKDB_API string_t Value::GetValueUnsafe() const {
1122: 	D_ASSERT(type_.InternalType() == PhysicalType::VARCHAR);
1123: 	return string_t(str_value);
1124: }
1125: 
1126: template <>
1127: float Value::GetValueUnsafe() const {
1128: 	D_ASSERT(type_.InternalType() == PhysicalType::FLOAT);
1129: 	return value_.float_;
1130: }
1131: 
1132: template <>
1133: double Value::GetValueUnsafe() const {
1134: 	D_ASSERT(type_.InternalType() == PhysicalType::DOUBLE);
1135: 	return value_.double_;
1136: }
1137: 
1138: template <>
1139: date_t Value::GetValueUnsafe() const {
1140: 	D_ASSERT(type_.InternalType() == PhysicalType::INT32);
1141: 	return value_.date;
1142: }
1143: 
1144: template <>
1145: dtime_t Value::GetValueUnsafe() const {
1146: 	D_ASSERT(type_.InternalType() == PhysicalType::INT64);
1147: 	return value_.time;
1148: }
1149: 
1150: template <>
1151: timestamp_t Value::GetValueUnsafe() const {
1152: 	D_ASSERT(type_.InternalType() == PhysicalType::INT64);
1153: 	return value_.timestamp;
1154: }
1155: 
1156: template <>
1157: interval_t Value::GetValueUnsafe() const {
1158: 	D_ASSERT(type_.InternalType() == PhysicalType::INTERVAL);
1159: 	return value_.interval;
1160: }
1161: 
1162: //===--------------------------------------------------------------------===//
1163: // GetReferenceUnsafe
1164: //===--------------------------------------------------------------------===//
1165: template <>
1166: int8_t &Value::GetReferenceUnsafe() {
1167: 	D_ASSERT(type_.InternalType() == PhysicalType::INT8 || type_.InternalType() == PhysicalType::BOOL);
1168: 	return value_.tinyint;
1169: }
1170: 
1171: template <>
1172: int16_t &Value::GetReferenceUnsafe() {
1173: 	D_ASSERT(type_.InternalType() == PhysicalType::INT16);
1174: 	return value_.smallint;
1175: }
1176: 
1177: template <>
1178: int32_t &Value::GetReferenceUnsafe() {
1179: 	D_ASSERT(type_.InternalType() == PhysicalType::INT32);
1180: 	return value_.integer;
1181: }
1182: 
1183: template <>
1184: int64_t &Value::GetReferenceUnsafe() {
1185: 	D_ASSERT(type_.InternalType() == PhysicalType::INT64);
1186: 	return value_.bigint;
1187: }
1188: 
1189: template <>
1190: hugeint_t &Value::GetReferenceUnsafe() {
1191: 	D_ASSERT(type_.InternalType() == PhysicalType::INT128);
1192: 	return value_.hugeint;
1193: }
1194: 
1195: template <>
1196: uint8_t &Value::GetReferenceUnsafe() {
1197: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT8);
1198: 	return value_.utinyint;
1199: }
1200: 
1201: template <>
1202: uint16_t &Value::GetReferenceUnsafe() {
1203: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT16);
1204: 	return value_.usmallint;
1205: }
1206: 
1207: template <>
1208: uint32_t &Value::GetReferenceUnsafe() {
1209: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT32);
1210: 	return value_.uinteger;
1211: }
1212: 
1213: template <>
1214: uint64_t &Value::GetReferenceUnsafe() {
1215: 	D_ASSERT(type_.InternalType() == PhysicalType::UINT64);
1216: 	return value_.ubigint;
1217: }
1218: 
1219: template <>
1220: float &Value::GetReferenceUnsafe() {
1221: 	D_ASSERT(type_.InternalType() == PhysicalType::FLOAT);
1222: 	return value_.float_;
1223: }
1224: 
1225: template <>
1226: double &Value::GetReferenceUnsafe() {
1227: 	D_ASSERT(type_.InternalType() == PhysicalType::DOUBLE);
1228: 	return value_.double_;
1229: }
1230: 
1231: template <>
1232: date_t &Value::GetReferenceUnsafe() {
1233: 	D_ASSERT(type_.InternalType() == PhysicalType::INT32);
1234: 	return value_.date;
1235: }
1236: 
1237: template <>
1238: dtime_t &Value::GetReferenceUnsafe() {
1239: 	D_ASSERT(type_.InternalType() == PhysicalType::INT64);
1240: 	return value_.time;
1241: }
1242: 
1243: template <>
1244: timestamp_t &Value::GetReferenceUnsafe() {
1245: 	D_ASSERT(type_.InternalType() == PhysicalType::INT64);
1246: 	return value_.timestamp;
1247: }
1248: 
1249: template <>
1250: interval_t &Value::GetReferenceUnsafe() {
1251: 	D_ASSERT(type_.InternalType() == PhysicalType::INTERVAL);
1252: 	return value_.interval;
1253: }
1254: 
1255: //===--------------------------------------------------------------------===//
1256: // Hash
1257: //===--------------------------------------------------------------------===//
1258: hash_t Value::Hash() const {
1259: 	if (IsNull()) {
1260: 		return 0;
1261: 	}
1262: 	Vector input(*this);
1263: 	Vector result(LogicalType::HASH);
1264: 	VectorOperations::Hash(input, result, 1);
1265: 
1266: 	auto data = FlatVector::GetData<hash_t>(result);
1267: 	return data[0];
1268: }
1269: 
1270: string Value::ToString() const {
1271: 	if (IsNull()) {
1272: 		return "NULL";
1273: 	}
1274: 	return DefaultCastAs(LogicalType::VARCHAR).str_value;
1275: }
1276: 
1277: string Value::ToSQLString() const {
1278: 	if (IsNull()) {
1279: 		return ToString();
1280: 	}
1281: 	switch (type_.id()) {
1282: 	case LogicalTypeId::UUID:
1283: 	case LogicalTypeId::DATE:
1284: 	case LogicalTypeId::TIME:
1285: 	case LogicalTypeId::TIMESTAMP:
1286: 	case LogicalTypeId::TIME_TZ:
1287: 	case LogicalTypeId::TIMESTAMP_TZ:
1288: 	case LogicalTypeId::TIMESTAMP_SEC:
1289: 	case LogicalTypeId::TIMESTAMP_MS:
1290: 	case LogicalTypeId::TIMESTAMP_NS:
1291: 	case LogicalTypeId::INTERVAL:
1292: 	case LogicalTypeId::BLOB:
1293: 		return "'" + ToString() + "'::" + type_.ToString();
1294: 	case LogicalTypeId::VARCHAR:
1295: 		return "'" + StringUtil::Replace(ToString(), "'", "''") + "'";
1296: 	case LogicalTypeId::STRUCT: {
1297: 		string ret = "{";
1298: 		auto &child_types = StructType::GetChildTypes(type_);
1299: 		for (size_t i = 0; i < struct_value.size(); i++) {
1300: 			auto &name = child_types[i].first;
1301: 			auto &child = struct_value[i];
1302: 			ret += "'" + name + "': " + child.ToSQLString();
1303: 			if (i < struct_value.size() - 1) {
1304: 				ret += ", ";
1305: 			}
1306: 		}
1307: 		ret += "}";
1308: 		return ret;
1309: 	}
1310: 	case LogicalTypeId::FLOAT:
1311: 		if (!FloatIsFinite(FloatValue::Get(*this))) {
1312: 			return "'" + ToString() + "'::" + type_.ToString();
1313: 		}
1314: 		return ToString();
1315: 	case LogicalTypeId::DOUBLE: {
1316: 		double val = DoubleValue::Get(*this);
1317: 		if (!DoubleIsFinite(val)) {
1318: 			if (!Value::IsNan(val)) {
1319: 				// to infinity and beyond
1320: 				return val < 0 ? "-1e1000" : "1e1000";
1321: 			}
1322: 			return "'" + ToString() + "'::" + type_.ToString();
1323: 		}
1324: 		return ToString();
1325: 	}
1326: 	case LogicalTypeId::LIST: {
1327: 		string ret = "[";
1328: 		for (size_t i = 0; i < list_value.size(); i++) {
1329: 			auto &child = list_value[i];
1330: 			ret += child.ToSQLString();
1331: 			if (i < list_value.size() - 1) {
1332: 				ret += ", ";
1333: 			}
1334: 		}
1335: 		ret += "]";
1336: 		return ret;
1337: 	}
1338: 	default:
1339: 		return ToString();
1340: 	}
1341: }
1342: 
1343: //===--------------------------------------------------------------------===//
1344: // Type-specific getters
1345: //===--------------------------------------------------------------------===//
1346: bool BooleanValue::Get(const Value &value) {
1347: 	return value.GetValueUnsafe<bool>();
1348: }
1349: 
1350: int8_t TinyIntValue::Get(const Value &value) {
1351: 	return value.GetValueUnsafe<int8_t>();
1352: }
1353: 
1354: int16_t SmallIntValue::Get(const Value &value) {
1355: 	return value.GetValueUnsafe<int16_t>();
1356: }
1357: 
1358: int32_t IntegerValue::Get(const Value &value) {
1359: 	return value.GetValueUnsafe<int32_t>();
1360: }
1361: 
1362: int64_t BigIntValue::Get(const Value &value) {
1363: 	return value.GetValueUnsafe<int64_t>();
1364: }
1365: 
1366: hugeint_t HugeIntValue::Get(const Value &value) {
1367: 	return value.GetValueUnsafe<hugeint_t>();
1368: }
1369: 
1370: uint8_t UTinyIntValue::Get(const Value &value) {
1371: 	return value.GetValueUnsafe<uint8_t>();
1372: }
1373: 
1374: uint16_t USmallIntValue::Get(const Value &value) {
1375: 	return value.GetValueUnsafe<uint16_t>();
1376: }
1377: 
1378: uint32_t UIntegerValue::Get(const Value &value) {
1379: 	return value.GetValueUnsafe<uint32_t>();
1380: }
1381: 
1382: uint64_t UBigIntValue::Get(const Value &value) {
1383: 	return value.GetValueUnsafe<uint64_t>();
1384: }
1385: 
1386: float FloatValue::Get(const Value &value) {
1387: 	return value.GetValueUnsafe<float>();
1388: }
1389: 
1390: double DoubleValue::Get(const Value &value) {
1391: 	return value.GetValueUnsafe<double>();
1392: }
1393: 
1394: const string &StringValue::Get(const Value &value) {
1395: 	D_ASSERT(value.type().InternalType() == PhysicalType::VARCHAR);
1396: 	return value.str_value;
1397: }
1398: 
1399: date_t DateValue::Get(const Value &value) {
1400: 	return value.GetValueUnsafe<date_t>();
1401: }
1402: 
1403: dtime_t TimeValue::Get(const Value &value) {
1404: 	return value.GetValueUnsafe<dtime_t>();
1405: }
1406: 
1407: timestamp_t TimestampValue::Get(const Value &value) {
1408: 	return value.GetValueUnsafe<timestamp_t>();
1409: }
1410: 
1411: interval_t IntervalValue::Get(const Value &value) {
1412: 	return value.GetValueUnsafe<interval_t>();
1413: }
1414: 
1415: const vector<Value> &StructValue::GetChildren(const Value &value) {
1416: 	D_ASSERT(value.type().InternalType() == PhysicalType::STRUCT);
1417: 	return value.struct_value;
1418: }
1419: 
1420: const vector<Value> &ListValue::GetChildren(const Value &value) {
1421: 	D_ASSERT(value.type().InternalType() == PhysicalType::LIST);
1422: 	return value.list_value;
1423: }
1424: 
1425: const Value &UnionValue::GetValue(const Value &value) {
1426: 	D_ASSERT(value.type() == LogicalTypeId::UNION);
1427: 	auto &children = StructValue::GetChildren(value);
1428: 	auto tag = children[0].GetValueUnsafe<uint8_t>();
1429: 	D_ASSERT(tag < children.size() - 1);
1430: 	return children[tag + 1];
1431: }
1432: 
1433: uint8_t UnionValue::GetTag(const Value &value) {
1434: 	D_ASSERT(value.type() == LogicalTypeId::UNION);
1435: 	auto children = StructValue::GetChildren(value);
1436: 	auto tag = children[0].GetValueUnsafe<uint8_t>();
1437: 	return tag;
1438: }
1439: 
1440: hugeint_t IntegralValue::Get(const Value &value) {
1441: 	switch (value.type().InternalType()) {
1442: 	case PhysicalType::INT8:
1443: 		return TinyIntValue::Get(value);
1444: 	case PhysicalType::INT16:
1445: 		return SmallIntValue::Get(value);
1446: 	case PhysicalType::INT32:
1447: 		return IntegerValue::Get(value);
1448: 	case PhysicalType::INT64:
1449: 		return BigIntValue::Get(value);
1450: 	case PhysicalType::INT128:
1451: 		return HugeIntValue::Get(value);
1452: 	case PhysicalType::UINT8:
1453: 		return UTinyIntValue::Get(value);
1454: 	case PhysicalType::UINT16:
1455: 		return USmallIntValue::Get(value);
1456: 	case PhysicalType::UINT32:
1457: 		return UIntegerValue::Get(value);
1458: 	case PhysicalType::UINT64:
1459: 		return UBigIntValue::Get(value);
1460: 	default:
1461: 		throw InternalException("Invalid internal type \"%s\" for IntegralValue::Get", value.type().ToString());
1462: 	}
1463: }
1464: 
1465: //===--------------------------------------------------------------------===//
1466: // Comparison Operators
1467: //===--------------------------------------------------------------------===//
1468: bool Value::operator==(const Value &rhs) const {
1469: 	return ValueOperations::Equals(*this, rhs);
1470: }
1471: 
1472: bool Value::operator!=(const Value &rhs) const {
1473: 	return ValueOperations::NotEquals(*this, rhs);
1474: }
1475: 
1476: bool Value::operator<(const Value &rhs) const {
1477: 	return ValueOperations::LessThan(*this, rhs);
1478: }
1479: 
1480: bool Value::operator>(const Value &rhs) const {
1481: 	return ValueOperations::GreaterThan(*this, rhs);
1482: }
1483: 
1484: bool Value::operator<=(const Value &rhs) const {
1485: 	return ValueOperations::LessThanEquals(*this, rhs);
1486: }
1487: 
1488: bool Value::operator>=(const Value &rhs) const {
1489: 	return ValueOperations::GreaterThanEquals(*this, rhs);
1490: }
1491: 
1492: bool Value::operator==(const int64_t &rhs) const {
1493: 	return *this == Value::Numeric(type_, rhs);
1494: }
1495: 
1496: bool Value::operator!=(const int64_t &rhs) const {
1497: 	return *this != Value::Numeric(type_, rhs);
1498: }
1499: 
1500: bool Value::operator<(const int64_t &rhs) const {
1501: 	return *this < Value::Numeric(type_, rhs);
1502: }
1503: 
1504: bool Value::operator>(const int64_t &rhs) const {
1505: 	return *this > Value::Numeric(type_, rhs);
1506: }
1507: 
1508: bool Value::operator<=(const int64_t &rhs) const {
1509: 	return *this <= Value::Numeric(type_, rhs);
1510: }
1511: 
1512: bool Value::operator>=(const int64_t &rhs) const {
1513: 	return *this >= Value::Numeric(type_, rhs);
1514: }
1515: 
1516: bool Value::TryCastAs(CastFunctionSet &set, GetCastFunctionInput &get_input, const LogicalType &target_type,
1517:                       Value &new_value, string *error_message, bool strict) const {
1518: 	if (type_ == target_type) {
1519: 		new_value = Copy();
1520: 		return true;
1521: 	}
1522: 	Vector input(*this);
1523: 	Vector result(target_type);
1524: 	if (!VectorOperations::TryCast(set, get_input, input, result, 1, error_message, strict)) {
1525: 		return false;
1526: 	}
1527: 	new_value = result.GetValue(0);
1528: 	return true;
1529: }
1530: 
1531: bool Value::TryCastAs(ClientContext &context, const LogicalType &target_type, Value &new_value, string *error_message,
1532:                       bool strict) const {
1533: 	GetCastFunctionInput get_input(context);
1534: 	return TryCastAs(CastFunctionSet::Get(context), get_input, target_type, new_value, error_message, strict);
1535: }
1536: 
1537: bool Value::DefaultTryCastAs(const LogicalType &target_type, Value &new_value, string *error_message,
1538:                              bool strict) const {
1539: 	CastFunctionSet set;
1540: 	GetCastFunctionInput get_input;
1541: 	return TryCastAs(set, get_input, target_type, new_value, error_message, strict);
1542: }
1543: 
1544: Value Value::CastAs(CastFunctionSet &set, GetCastFunctionInput &get_input, const LogicalType &target_type,
1545:                     bool strict) const {
1546: 	Value new_value;
1547: 	string error_message;
1548: 	if (!TryCastAs(set, get_input, target_type, new_value, &error_message, strict)) {
1549: 		throw InvalidInputException("Failed to cast value: %s", error_message);
1550: 	}
1551: 	return new_value;
1552: }
1553: 
1554: Value Value::CastAs(ClientContext &context, const LogicalType &target_type, bool strict) const {
1555: 	GetCastFunctionInput get_input(context);
1556: 	return CastAs(CastFunctionSet::Get(context), get_input, target_type, strict);
1557: }
1558: 
1559: Value Value::DefaultCastAs(const LogicalType &target_type, bool strict) const {
1560: 	CastFunctionSet set;
1561: 	GetCastFunctionInput get_input;
1562: 	return CastAs(set, get_input, target_type, strict);
1563: }
1564: 
1565: bool Value::TryCastAs(CastFunctionSet &set, GetCastFunctionInput &get_input, const LogicalType &target_type,
1566:                       bool strict) {
1567: 	Value new_value;
1568: 	string error_message;
1569: 	if (!TryCastAs(set, get_input, target_type, new_value, &error_message, strict)) {
1570: 		return false;
1571: 	}
1572: 	type_ = target_type;
1573: 	is_null = new_value.is_null;
1574: 	value_ = new_value.value_;
1575: 	str_value = new_value.str_value;
1576: 	struct_value = new_value.struct_value;
1577: 	list_value = new_value.list_value;
1578: 	return true;
1579: }
1580: 
1581: bool Value::TryCastAs(ClientContext &context, const LogicalType &target_type, bool strict) {
1582: 	GetCastFunctionInput get_input(context);
1583: 	return TryCastAs(CastFunctionSet::Get(context), get_input, target_type, strict);
1584: }
1585: 
1586: bool Value::DefaultTryCastAs(const LogicalType &target_type, bool strict) {
1587: 	CastFunctionSet set;
1588: 	GetCastFunctionInput get_input;
1589: 	return TryCastAs(set, get_input, target_type, strict);
1590: }
1591: 
1592: void Value::Serialize(Serializer &main_serializer) const {
1593: 	FieldWriter writer(main_serializer);
1594: 	writer.WriteSerializable(type_);
1595: 	writer.WriteField<bool>(IsNull());
1596: 	if (!IsNull()) {
1597: 		auto &serializer = writer.GetSerializer();
1598: 		switch (type_.InternalType()) {
1599: 		case PhysicalType::BOOL:
1600: 			serializer.Write<int8_t>(value_.boolean);
1601: 			break;
1602: 		case PhysicalType::INT8:
1603: 			serializer.Write<int8_t>(value_.tinyint);
1604: 			break;
1605: 		case PhysicalType::INT16:
1606: 			serializer.Write<int16_t>(value_.smallint);
1607: 			break;
1608: 		case PhysicalType::INT32:
1609: 			serializer.Write<int32_t>(value_.integer);
1610: 			break;
1611: 		case PhysicalType::INT64:
1612: 			serializer.Write<int64_t>(value_.bigint);
1613: 			break;
1614: 		case PhysicalType::UINT8:
1615: 			serializer.Write<uint8_t>(value_.utinyint);
1616: 			break;
1617: 		case PhysicalType::UINT16:
1618: 			serializer.Write<uint16_t>(value_.usmallint);
1619: 			break;
1620: 		case PhysicalType::UINT32:
1621: 			serializer.Write<uint32_t>(value_.uinteger);
1622: 			break;
1623: 		case PhysicalType::UINT64:
1624: 			serializer.Write<uint64_t>(value_.ubigint);
1625: 			break;
1626: 		case PhysicalType::INT128:
1627: 			serializer.Write<hugeint_t>(value_.hugeint);
1628: 			break;
1629: 		case PhysicalType::FLOAT:
1630: 			serializer.Write<float>(value_.float_);
1631: 			break;
1632: 		case PhysicalType::DOUBLE:
1633: 			serializer.Write<double>(value_.double_);
1634: 			break;
1635: 		case PhysicalType::INTERVAL:
1636: 			serializer.Write<interval_t>(value_.interval);
1637: 			break;
1638: 		case PhysicalType::VARCHAR:
1639: 			serializer.WriteString(str_value);
1640: 			break;
1641: 		default: {
1642: 			Vector v(*this);
1643: 			v.Serialize(1, serializer);
1644: 			break;
1645: 		}
1646: 		}
1647: 	}
1648: 	writer.Finalize();
1649: }
1650: 
1651: Value Value::Deserialize(Deserializer &main_source) {
1652: 	FieldReader reader(main_source);
1653: 	auto type = reader.ReadRequiredSerializable<LogicalType, LogicalType>();
1654: 	auto is_null = reader.ReadRequired<bool>();
1655: 	Value new_value = Value(type);
1656: 	if (is_null) {
1657: 		reader.Finalize();
1658: 		return new_value;
1659: 	}
1660: 	new_value.is_null = false;
1661: 	auto &source = reader.GetSource();
1662: 	switch (type.InternalType()) {
1663: 	case PhysicalType::BOOL:
1664: 		new_value.value_.boolean = source.Read<int8_t>();
1665: 		break;
1666: 	case PhysicalType::INT8:
1667: 		new_value.value_.tinyint = source.Read<int8_t>();
1668: 		break;
1669: 	case PhysicalType::INT16:
1670: 		new_value.value_.smallint = source.Read<int16_t>();
1671: 		break;
1672: 	case PhysicalType::INT32:
1673: 		new_value.value_.integer = source.Read<int32_t>();
1674: 		break;
1675: 	case PhysicalType::INT64:
1676: 		new_value.value_.bigint = source.Read<int64_t>();
1677: 		break;
1678: 	case PhysicalType::UINT8:
1679: 		new_value.value_.utinyint = source.Read<uint8_t>();
1680: 		break;
1681: 	case PhysicalType::UINT16:
1682: 		new_value.value_.usmallint = source.Read<uint16_t>();
1683: 		break;
1684: 	case PhysicalType::UINT32:
1685: 		new_value.value_.uinteger = source.Read<uint32_t>();
1686: 		break;
1687: 	case PhysicalType::UINT64:
1688: 		new_value.value_.ubigint = source.Read<uint64_t>();
1689: 		break;
1690: 	case PhysicalType::INT128:
1691: 		new_value.value_.hugeint = source.Read<hugeint_t>();
1692: 		break;
1693: 	case PhysicalType::FLOAT:
1694: 		new_value.value_.float_ = source.Read<float>();
1695: 		break;
1696: 	case PhysicalType::DOUBLE:
1697: 		new_value.value_.double_ = source.Read<double>();
1698: 		break;
1699: 	case PhysicalType::INTERVAL:
1700: 		new_value.value_.interval = source.Read<interval_t>();
1701: 		break;
1702: 	case PhysicalType::VARCHAR:
1703: 		new_value.str_value = source.Read<string>();
1704: 		break;
1705: 	default: {
1706: 		Vector v(type);
1707: 		v.Deserialize(1, source);
1708: 		new_value = v.GetValue(0);
1709: 		break;
1710: 	}
1711: 	}
1712: 	reader.Finalize();
1713: 	return new_value;
1714: }
1715: 
1716: void Value::Print() const {
1717: 	Printer::Print(ToString());
1718: }
1719: 
1720: bool Value::NotDistinctFrom(const Value &lvalue, const Value &rvalue) {
1721: 	return ValueOperations::NotDistinctFrom(lvalue, rvalue);
1722: }
1723: 
1724: bool Value::ValuesAreEqual(CastFunctionSet &set, GetCastFunctionInput &get_input, const Value &result_value,
1725:                            const Value &value) {
1726: 	if (result_value.IsNull() != value.IsNull()) {
1727: 		return false;
1728: 	}
1729: 	if (result_value.IsNull() && value.IsNull()) {
1730: 		// NULL = NULL in checking code
1731: 		return true;
1732: 	}
1733: 	switch (value.type_.id()) {
1734: 	case LogicalTypeId::FLOAT: {
1735: 		auto other = result_value.CastAs(set, get_input, LogicalType::FLOAT);
1736: 		float ldecimal = value.value_.float_;
1737: 		float rdecimal = other.value_.float_;
1738: 		return ApproxEqual(ldecimal, rdecimal);
1739: 	}
1740: 	case LogicalTypeId::DOUBLE: {
1741: 		auto other = result_value.CastAs(set, get_input, LogicalType::DOUBLE);
1742: 		double ldecimal = value.value_.double_;
1743: 		double rdecimal = other.value_.double_;
1744: 		return ApproxEqual(ldecimal, rdecimal);
1745: 	}
1746: 	case LogicalTypeId::VARCHAR: {
1747: 		auto other = result_value.CastAs(set, get_input, LogicalType::VARCHAR);
1748: 		// some results might contain padding spaces, e.g. when rendering
1749: 		// VARCHAR(10) and the string only has 6 characters, they will be padded
1750: 		// with spaces to 10 in the rendering. We don't do that here yet as we
1751: 		// are looking at internal structures. So just ignore any extra spaces
1752: 		// on the right
1753: 		string left = other.str_value;
1754: 		string right = value.str_value;
1755: 		StringUtil::RTrim(left);
1756: 		StringUtil::RTrim(right);
1757: 		return left == right;
1758: 	}
1759: 	default:
1760: 		if (result_value.type_.id() == LogicalTypeId::FLOAT || result_value.type_.id() == LogicalTypeId::DOUBLE) {
1761: 			return Value::ValuesAreEqual(set, get_input, value, result_value);
1762: 		}
1763: 		return value == result_value;
1764: 	}
1765: }
1766: 
1767: bool Value::ValuesAreEqual(ClientContext &context, const Value &result_value, const Value &value) {
1768: 	GetCastFunctionInput get_input(context);
1769: 	return Value::ValuesAreEqual(CastFunctionSet::Get(context), get_input, result_value, value);
1770: }
1771: bool Value::DefaultValuesAreEqual(const Value &result_value, const Value &value) {
1772: 	CastFunctionSet set;
1773: 	GetCastFunctionInput get_input;
1774: 	return Value::ValuesAreEqual(set, get_input, result_value, value);
1775: }
1776: 
1777: } // namespace duckdb
[end of src/common/types/value.cpp]
[start of src/execution/operator/persistent/buffered_csv_reader.cpp]
1: #include "duckdb/execution/operator/persistent/buffered_csv_reader.hpp"
2: 
3: #include "duckdb/catalog/catalog_entry/table_catalog_entry.hpp"
4: #include "duckdb/common/file_system.hpp"
5: #include "duckdb/common/string_util.hpp"
6: #include "duckdb/common/to_string.hpp"
7: #include "duckdb/common/types/cast_helpers.hpp"
8: #include "duckdb/common/vector_operations/unary_executor.hpp"
9: #include "duckdb/common/vector_operations/vector_operations.hpp"
10: #include "duckdb/function/scalar/strftime.hpp"
11: #include "duckdb/main/database.hpp"
12: #include "duckdb/parser/column_definition.hpp"
13: #include "duckdb/storage/data_table.hpp"
14: #include "utf8proc_wrapper.hpp"
15: #include "utf8proc.hpp"
16: #include "duckdb/parser/keyword_helper.hpp"
17: 
18: #include <algorithm>
19: #include <cctype>
20: #include <cstring>
21: #include <fstream>
22: 
23: namespace duckdb {
24: 
25: static bool ParseBoolean(const Value &value, const string &loption);
26: 
27: static bool ParseBoolean(const vector<Value> &set, const string &loption) {
28: 	if (set.empty()) {
29: 		// no option specified: default to true
30: 		return true;
31: 	}
32: 	if (set.size() > 1) {
33: 		throw BinderException("\"%s\" expects a single argument as a boolean value (e.g. TRUE or 1)", loption);
34: 	}
35: 	return ParseBoolean(set[0], loption);
36: }
37: 
38: static bool ParseBoolean(const Value &value, const string &loption) {
39: 
40: 	if (value.type().id() == LogicalTypeId::LIST) {
41: 		auto &children = ListValue::GetChildren(value);
42: 		return ParseBoolean(children, loption);
43: 	}
44: 	if (value.type() == LogicalType::FLOAT || value.type() == LogicalType::DOUBLE ||
45: 	    value.type().id() == LogicalTypeId::DECIMAL) {
46: 		throw BinderException("\"%s\" expects a boolean value (e.g. TRUE or 1)", loption);
47: 	}
48: 	return BooleanValue::Get(value.DefaultCastAs(LogicalType::BOOLEAN));
49: }
50: 
51: static string ParseString(const Value &value, const string &loption) {
52: 	if (value.type().id() == LogicalTypeId::LIST) {
53: 		auto &children = ListValue::GetChildren(value);
54: 		if (children.size() != 1) {
55: 			throw BinderException("\"%s\" expects a single argument as a string value", loption);
56: 		}
57: 		return ParseString(children[0], loption);
58: 	}
59: 	if (value.type().id() != LogicalTypeId::VARCHAR) {
60: 		throw BinderException("\"%s\" expects a string argument!", loption);
61: 	}
62: 	return value.GetValue<string>();
63: }
64: 
65: static int64_t ParseInteger(const Value &value, const string &loption) {
66: 	if (value.type().id() == LogicalTypeId::LIST) {
67: 		auto &children = ListValue::GetChildren(value);
68: 		if (children.size() != 1) {
69: 			// no option specified or multiple options specified
70: 			throw BinderException("\"%s\" expects a single argument as an integer value", loption);
71: 		}
72: 		return ParseInteger(children[0], loption);
73: 	}
74: 	return value.GetValue<int64_t>();
75: }
76: 
77: static vector<bool> ParseColumnList(const vector<Value> &set, vector<string> &names, const string &loption) {
78: 	vector<bool> result;
79: 
80: 	if (set.empty()) {
81: 		throw BinderException("\"%s\" expects a column list or * as parameter", loption);
82: 	}
83: 	// list of options: parse the list
84: 	unordered_map<string, bool> option_map;
85: 	for (idx_t i = 0; i < set.size(); i++) {
86: 		option_map[set[i].ToString()] = false;
87: 	}
88: 	result.resize(names.size(), false);
89: 	for (idx_t i = 0; i < names.size(); i++) {
90: 		auto entry = option_map.find(names[i]);
91: 		if (entry != option_map.end()) {
92: 			result[i] = true;
93: 			entry->second = true;
94: 		}
95: 	}
96: 	for (auto &entry : option_map) {
97: 		if (!entry.second) {
98: 			throw BinderException("\"%s\" expected to find %s, but it was not found in the table", loption,
99: 			                      entry.first.c_str());
100: 		}
101: 	}
102: 	return result;
103: }
104: 
105: static vector<bool> ParseColumnList(const Value &value, vector<string> &names, const string &loption) {
106: 	vector<bool> result;
107: 
108: 	// Only accept a list of arguments
109: 	if (value.type().id() != LogicalTypeId::LIST) {
110: 		// Support a single argument if it's '*'
111: 		if (value.type().id() == LogicalTypeId::VARCHAR && value.GetValue<string>() == "*") {
112: 			result.resize(names.size(), true);
113: 			return result;
114: 		}
115: 		throw BinderException("\"%s\" expects a column list or * as parameter", loption);
116: 	}
117: 	auto &children = ListValue::GetChildren(value);
118: 	// accept '*' as single argument
119: 	if (children.size() == 1 && children[0].type().id() == LogicalTypeId::VARCHAR &&
120: 	    children[0].GetValue<string>() == "*") {
121: 		result.resize(names.size(), true);
122: 		return result;
123: 	}
124: 	return ParseColumnList(children, names, loption);
125: }
126: 
127: struct CSVFileHandle {
128: public:
129: 	explicit CSVFileHandle(unique_ptr<FileHandle> file_handle_p) : file_handle(move(file_handle_p)) {
130: 		can_seek = file_handle->CanSeek();
131: 		plain_file_source = file_handle->OnDiskFile() && can_seek;
132: 		file_size = file_handle->GetFileSize();
133: 	}
134: 
135: 	bool CanSeek() {
136: 		return can_seek;
137: 	}
138: 	void Seek(idx_t position) {
139: 		if (!can_seek) {
140: 			throw InternalException("Cannot seek in this file");
141: 		}
142: 		file_handle->Seek(position);
143: 	}
144: 	idx_t SeekPosition() {
145: 		if (!can_seek) {
146: 			throw InternalException("Cannot seek in this file");
147: 		}
148: 		return file_handle->SeekPosition();
149: 	}
150: 	void Reset() {
151: 		if (plain_file_source) {
152: 			file_handle->Reset();
153: 		} else {
154: 			if (!reset_enabled) {
155: 				throw InternalException("Reset called but reset is not enabled for this CSV Handle");
156: 			}
157: 			read_position = 0;
158: 		}
159: 	}
160: 	bool PlainFileSource() {
161: 		return plain_file_source;
162: 	}
163: 
164: 	bool OnDiskFile() {
165: 		return file_handle->OnDiskFile();
166: 	}
167: 
168: 	idx_t FileSize() {
169: 		return file_size;
170: 	}
171: 
172: 	idx_t Read(void *buffer, idx_t nr_bytes) {
173: 		if (!plain_file_source) {
174: 			// not a plain file source: we need to do some bookkeeping around the reset functionality
175: 			idx_t result_offset = 0;
176: 			if (read_position < buffer_size) {
177: 				// we need to read from our cached buffer
178: 				auto buffer_read_count = MinValue<idx_t>(nr_bytes, buffer_size - read_position);
179: 				memcpy(buffer, cached_buffer.get() + read_position, buffer_read_count);
180: 				result_offset += buffer_read_count;
181: 				read_position += buffer_read_count;
182: 				if (result_offset == nr_bytes) {
183: 					return nr_bytes;
184: 				}
185: 			} else if (!reset_enabled && cached_buffer) {
186: 				// reset is disabled but we still have cached data
187: 				// we can remove any cached data
188: 				cached_buffer.reset();
189: 				buffer_size = 0;
190: 				buffer_capacity = 0;
191: 				read_position = 0;
192: 			}
193: 			// we have data left to read from the file
194: 			// read directly into the buffer
195: 			auto bytes_read = file_handle->Read((char *)buffer + result_offset, nr_bytes - result_offset);
196: 			read_position += bytes_read;
197: 			if (reset_enabled) {
198: 				// if reset caching is enabled, we need to cache the bytes that we have read
199: 				if (buffer_size + bytes_read >= buffer_capacity) {
200: 					// no space; first enlarge the buffer
201: 					buffer_capacity = MaxValue<idx_t>(NextPowerOfTwo(buffer_size + bytes_read), buffer_capacity * 2);
202: 
203: 					auto new_buffer = unique_ptr<data_t[]>(new data_t[buffer_capacity]);
204: 					if (buffer_size > 0) {
205: 						memcpy(new_buffer.get(), cached_buffer.get(), buffer_size);
206: 					}
207: 					cached_buffer = move(new_buffer);
208: 				}
209: 				memcpy(cached_buffer.get() + buffer_size, (char *)buffer + result_offset, bytes_read);
210: 				buffer_size += bytes_read;
211: 			}
212: 
213: 			return result_offset + bytes_read;
214: 		} else {
215: 			return file_handle->Read(buffer, nr_bytes);
216: 		}
217: 	}
218: 
219: 	string ReadLine() {
220: 		bool carriage_return = false;
221: 		string result;
222: 		char buffer[1];
223: 		while (true) {
224: 			idx_t bytes_read = Read(buffer, 1);
225: 			if (bytes_read == 0) {
226: 				return result;
227: 			}
228: 			if (carriage_return) {
229: 				if (buffer[0] != '\n') {
230: 					if (!file_handle->CanSeek()) {
231: 						throw BinderException(
232: 						    "Carriage return newlines not supported when reading CSV files in which we cannot seek");
233: 					}
234: 					file_handle->Seek(file_handle->SeekPosition() - 1);
235: 					return result;
236: 				}
237: 			}
238: 			if (buffer[0] == '\n') {
239: 				return result;
240: 			}
241: 			if (buffer[0] != '\r') {
242: 				result += buffer[0];
243: 			} else {
244: 				carriage_return = true;
245: 			}
246: 		}
247: 	}
248: 
249: 	void DisableReset() {
250: 		this->reset_enabled = false;
251: 	}
252: 
253: private:
254: 	unique_ptr<FileHandle> file_handle;
255: 	bool reset_enabled = true;
256: 	bool can_seek = false;
257: 	bool plain_file_source = false;
258: 	idx_t file_size = 0;
259: 	// reset support
260: 	unique_ptr<data_t[]> cached_buffer;
261: 	idx_t read_position = 0;
262: 	idx_t buffer_size = 0;
263: 	idx_t buffer_capacity = 0;
264: };
265: 
266: void BufferedCSVReaderOptions::SetDelimiter(const string &input) {
267: 	this->delimiter = StringUtil::Replace(input, "\\t", "\t");
268: 	this->has_delimiter = true;
269: 	if (input.empty()) {
270: 		this->delimiter = string("\0", 1);
271: 	}
272: }
273: 
274: void BufferedCSVReaderOptions::SetDateFormat(LogicalTypeId type, const string &format, bool read_format) {
275: 	string error;
276: 	if (read_format) {
277: 		auto &date_format = this->date_format[type];
278: 		error = StrTimeFormat::ParseFormatSpecifier(format, date_format);
279: 		date_format.format_specifier = format;
280: 	} else {
281: 		auto &date_format = this->write_date_format[type];
282: 		error = StrTimeFormat::ParseFormatSpecifier(format, date_format);
283: 	}
284: 	if (!error.empty()) {
285: 		throw InvalidInputException("Could not parse DATEFORMAT: %s", error.c_str());
286: 	}
287: 	has_format[type] = true;
288: }
289: 
290: void BufferedCSVReaderOptions::SetReadOption(const string &loption, const Value &value,
291:                                              vector<string> &expected_names) {
292: 	if (SetBaseOption(loption, value)) {
293: 		return;
294: 	}
295: 	if (loption == "auto_detect") {
296: 		auto_detect = ParseBoolean(value, loption);
297: 	} else if (loption == "sample_size") {
298: 		int64_t sample_size = ParseInteger(value, loption);
299: 		if (sample_size < 1 && sample_size != -1) {
300: 			throw BinderException("Unsupported parameter for SAMPLE_SIZE: cannot be smaller than 1");
301: 		}
302: 		if (sample_size == -1) {
303: 			sample_chunks = std::numeric_limits<uint64_t>::max();
304: 			sample_chunk_size = STANDARD_VECTOR_SIZE;
305: 		} else if (sample_size <= STANDARD_VECTOR_SIZE) {
306: 			sample_chunk_size = sample_size;
307: 			sample_chunks = 1;
308: 		} else {
309: 			sample_chunk_size = STANDARD_VECTOR_SIZE;
310: 			sample_chunks = sample_size / STANDARD_VECTOR_SIZE;
311: 		}
312: 	} else if (loption == "skip") {
313: 		skip_rows = ParseInteger(value, loption);
314: 	} else if (loption == "max_line_size" || loption == "maximum_line_size") {
315: 		maximum_line_size = ParseInteger(value, loption);
316: 	} else if (loption == "sample_chunk_size") {
317: 		sample_chunk_size = ParseInteger(value, loption);
318: 		if (sample_chunk_size > STANDARD_VECTOR_SIZE) {
319: 			throw BinderException(
320: 			    "Unsupported parameter for SAMPLE_CHUNK_SIZE: cannot be bigger than STANDARD_VECTOR_SIZE %d",
321: 			    STANDARD_VECTOR_SIZE);
322: 		} else if (sample_chunk_size < 1) {
323: 			throw BinderException("Unsupported parameter for SAMPLE_CHUNK_SIZE: cannot be smaller than 1");
324: 		}
325: 	} else if (loption == "sample_chunks") {
326: 		sample_chunks = ParseInteger(value, loption);
327: 		if (sample_chunks < 1) {
328: 			throw BinderException("Unsupported parameter for SAMPLE_CHUNKS: cannot be smaller than 1");
329: 		}
330: 	} else if (loption == "force_not_null") {
331: 		force_not_null = ParseColumnList(value, expected_names, loption);
332: 	} else if (loption == "date_format" || loption == "dateformat") {
333: 		string format = ParseString(value, loption);
334: 		SetDateFormat(LogicalTypeId::DATE, format, true);
335: 	} else if (loption == "timestamp_format" || loption == "timestampformat") {
336: 		string format = ParseString(value, loption);
337: 		SetDateFormat(LogicalTypeId::TIMESTAMP, format, true);
338: 	} else if (loption == "escape") {
339: 		escape = ParseString(value, loption);
340: 		has_escape = true;
341: 	} else if (loption == "ignore_errors") {
342: 		ignore_errors = ParseBoolean(value, loption);
343: 	} else if (loption == "union_by_name") {
344: 		union_by_name = ParseBoolean(value, loption);
345: 	} else {
346: 		throw BinderException("Unrecognized option for CSV reader \"%s\"", loption);
347: 	}
348: }
349: 
350: void BufferedCSVReaderOptions::SetWriteOption(const string &loption, const Value &value) {
351: 	if (SetBaseOption(loption, value)) {
352: 		return;
353: 	}
354: 
355: 	if (loption == "force_quote") {
356: 		force_quote = ParseColumnList(value, names, loption);
357: 	} else if (loption == "date_format" || loption == "dateformat") {
358: 		string format = ParseString(value, loption);
359: 		SetDateFormat(LogicalTypeId::DATE, format, false);
360: 	} else if (loption == "timestamp_format" || loption == "timestampformat") {
361: 		string format = ParseString(value, loption);
362: 		if (StringUtil::Lower(format) == "iso") {
363: 			format = "%Y-%m-%dT%H:%M:%S.%fZ";
364: 		}
365: 		SetDateFormat(LogicalTypeId::TIMESTAMP, format, false);
366: 	} else {
367: 		throw BinderException("Unrecognized option CSV writer \"%s\"", loption);
368: 	}
369: }
370: 
371: bool BufferedCSVReaderOptions::SetBaseOption(const string &loption, const Value &value) {
372: 	// Make sure this function was only called after the option was turned into lowercase
373: 	D_ASSERT(!std::any_of(loption.begin(), loption.end(), ::isupper));
374: 
375: 	if (StringUtil::StartsWith(loption, "delim") || StringUtil::StartsWith(loption, "sep")) {
376: 		SetDelimiter(ParseString(value, loption));
377: 	} else if (loption == "quote") {
378: 		quote = ParseString(value, loption);
379: 		has_quote = true;
380: 	} else if (loption == "escape") {
381: 		escape = ParseString(value, loption);
382: 		has_escape = true;
383: 	} else if (loption == "header") {
384: 		header = ParseBoolean(value, loption);
385: 		has_header = true;
386: 	} else if (loption == "null" || loption == "nullstr") {
387: 		null_str = ParseString(value, loption);
388: 	} else if (loption == "encoding") {
389: 		auto encoding = StringUtil::Lower(ParseString(value, loption));
390: 		if (encoding != "utf8" && encoding != "utf-8") {
391: 			throw BinderException("Copy is only supported for UTF-8 encoded files, ENCODING 'UTF-8'");
392: 		}
393: 	} else if (loption == "compression") {
394: 		compression = FileCompressionTypeFromString(ParseString(value, loption));
395: 	} else {
396: 		// unrecognized option in base CSV
397: 		return false;
398: 	}
399: 	return true;
400: }
401: 
402: std::string BufferedCSVReaderOptions::ToString() const {
403: 	return "DELIMITER='" + delimiter + (has_delimiter ? "'" : (auto_detect ? "' (auto detected)" : "' (default)")) +
404: 	       ", QUOTE='" + quote + (has_quote ? "'" : (auto_detect ? "' (auto detected)" : "' (default)")) +
405: 	       ", ESCAPE='" + escape + (has_escape ? "'" : (auto_detect ? "' (auto detected)" : "' (default)")) +
406: 	       ", HEADER=" + std::to_string(header) +
407: 	       (has_header ? "" : (auto_detect ? " (auto detected)" : "' (default)")) +
408: 	       ", SAMPLE_SIZE=" + std::to_string(sample_chunk_size * sample_chunks) +
409: 	       ", IGNORE_ERRORS=" + std::to_string(ignore_errors) + ", ALL_VARCHAR=" + std::to_string(all_varchar);
410: }
411: 
412: static string GetLineNumberStr(idx_t linenr, bool linenr_estimated) {
413: 	string estimated = (linenr_estimated ? string(" (estimated)") : string(""));
414: 	return to_string(linenr + 1) + estimated;
415: }
416: 
417: static bool StartsWithNumericDate(string &separator, const string &value) {
418: 	auto begin = value.c_str();
419: 	auto end = begin + value.size();
420: 
421: 	//	StrpTimeFormat::Parse will skip whitespace, so we can too
422: 	auto field1 = std::find_if_not(begin, end, StringUtil::CharacterIsSpace);
423: 	if (field1 == end) {
424: 		return false;
425: 	}
426: 
427: 	//	first numeric field must start immediately
428: 	if (!StringUtil::CharacterIsDigit(*field1)) {
429: 		return false;
430: 	}
431: 	auto literal1 = std::find_if_not(field1, end, StringUtil::CharacterIsDigit);
432: 	if (literal1 == end) {
433: 		return false;
434: 	}
435: 
436: 	//	second numeric field must exist
437: 	auto field2 = std::find_if(literal1, end, StringUtil::CharacterIsDigit);
438: 	if (field2 == end) {
439: 		return false;
440: 	}
441: 	auto literal2 = std::find_if_not(field2, end, StringUtil::CharacterIsDigit);
442: 	if (literal2 == end) {
443: 		return false;
444: 	}
445: 
446: 	//	third numeric field must exist
447: 	auto field3 = std::find_if(literal2, end, StringUtil::CharacterIsDigit);
448: 	if (field3 == end) {
449: 		return false;
450: 	}
451: 
452: 	//	second literal must match first
453: 	if (((field3 - literal2) != (field2 - literal1)) || strncmp(literal1, literal2, (field2 - literal1)) != 0) {
454: 		return false;
455: 	}
456: 
457: 	//	copy the literal as the separator, escaping percent signs
458: 	separator.clear();
459: 	while (literal1 < field2) {
460: 		const auto literal_char = *literal1++;
461: 		if (literal_char == '%') {
462: 			separator.push_back(literal_char);
463: 		}
464: 		separator.push_back(literal_char);
465: 	}
466: 
467: 	return true;
468: }
469: 
470: string GenerateDateFormat(const string &separator, const char *format_template) {
471: 	string format_specifier = format_template;
472: 	auto amount_of_dashes = std::count(format_specifier.begin(), format_specifier.end(), '-');
473: 	if (!amount_of_dashes) {
474: 		return format_specifier;
475: 	}
476: 	string result;
477: 	result.reserve(format_specifier.size() - amount_of_dashes + (amount_of_dashes * separator.size()));
478: 	for (auto &character : format_specifier) {
479: 		if (character == '-') {
480: 			result += separator;
481: 		} else {
482: 			result += character;
483: 		}
484: 	}
485: 	return result;
486: }
487: 
488: TextSearchShiftArray::TextSearchShiftArray() {
489: }
490: 
491: TextSearchShiftArray::TextSearchShiftArray(string search_term) : length(search_term.size()) {
492: 	if (length > 255) {
493: 		throw Exception("Size of delimiter/quote/escape in CSV reader is limited to 255 bytes");
494: 	}
495: 	// initialize the shifts array
496: 	shifts = unique_ptr<uint8_t[]>(new uint8_t[length * 255]);
497: 	memset(shifts.get(), 0, length * 255 * sizeof(uint8_t));
498: 	// iterate over each of the characters in the array
499: 	for (idx_t main_idx = 0; main_idx < length; main_idx++) {
500: 		uint8_t current_char = (uint8_t)search_term[main_idx];
501: 		// now move over all the remaining positions
502: 		for (idx_t i = main_idx; i < length; i++) {
503: 			bool is_match = true;
504: 			// check if the prefix matches at this position
505: 			// if it does, we move to this position after encountering the current character
506: 			for (idx_t j = 0; j < main_idx; j++) {
507: 				if (search_term[i - main_idx + j] != search_term[j]) {
508: 					is_match = false;
509: 				}
510: 			}
511: 			if (!is_match) {
512: 				continue;
513: 			}
514: 			shifts[i * 255 + current_char] = main_idx + 1;
515: 		}
516: 	}
517: }
518: 
519: BufferedCSVReader::BufferedCSVReader(FileSystem &fs_p, Allocator &allocator, FileOpener *opener_p,
520:                                      BufferedCSVReaderOptions options_p, const vector<LogicalType> &requested_types)
521:     : fs(fs_p), allocator(allocator), opener(opener_p), options(move(options_p)), buffer_size(0), position(0),
522:       start(0) {
523: 	file_handle = OpenCSV(options);
524: 	Initialize(requested_types);
525: }
526: 
527: BufferedCSVReader::BufferedCSVReader(ClientContext &context, BufferedCSVReaderOptions options_p,
528:                                      const vector<LogicalType> &requested_types)
529:     : BufferedCSVReader(FileSystem::GetFileSystem(context), Allocator::Get(context), FileSystem::GetFileOpener(context),
530:                         move(options_p), requested_types) {
531: }
532: 
533: BufferedCSVReader::~BufferedCSVReader() {
534: }
535: 
536: idx_t BufferedCSVReader::GetFileSize() {
537: 	return file_handle ? file_handle->FileSize() : 0;
538: }
539: 
540: void BufferedCSVReader::Initialize(const vector<LogicalType> &requested_types) {
541: 	PrepareComplexParser();
542: 	if (options.auto_detect) {
543: 		sql_types = SniffCSV(requested_types);
544: 		if (sql_types.empty()) {
545: 			throw Exception("Failed to detect column types from CSV: is the file a valid CSV file?");
546: 		}
547: 		if (cached_chunks.empty()) {
548: 			JumpToBeginning(options.skip_rows, options.header);
549: 		}
550: 	} else {
551: 		sql_types = requested_types;
552: 		ResetBuffer();
553: 		SkipRowsAndReadHeader(options.skip_rows, options.header);
554: 	}
555: 	InitParseChunk(sql_types.size());
556: 	InitInsertChunkIdx(sql_types.size());
557: 	// we only need reset support during the automatic CSV type detection
558: 	// since reset support might require caching (in the case of streams), we disable it for the remainder
559: 	file_handle->DisableReset();
560: }
561: 
562: void BufferedCSVReader::PrepareComplexParser() {
563: 	delimiter_search = TextSearchShiftArray(options.delimiter);
564: 	escape_search = TextSearchShiftArray(options.escape);
565: 	quote_search = TextSearchShiftArray(options.quote);
566: }
567: 
568: unique_ptr<CSVFileHandle> BufferedCSVReader::OpenCSV(const BufferedCSVReaderOptions &options) {
569: 	auto file_handle = fs.OpenFile(options.file_path.c_str(), FileFlags::FILE_FLAGS_READ, FileLockType::NO_LOCK,
570: 	                               options.compression, this->opener);
571: 	return make_unique<CSVFileHandle>(move(file_handle));
572: }
573: 
574: // Helper function to generate column names
575: static string GenerateColumnName(const idx_t total_cols, const idx_t col_number, const string &prefix = "column") {
576: 	int max_digits = NumericHelper::UnsignedLength(total_cols - 1);
577: 	int digits = NumericHelper::UnsignedLength(col_number);
578: 	string leading_zeros = string(max_digits - digits, '0');
579: 	string value = to_string(col_number);
580: 	return string(prefix + leading_zeros + value);
581: }
582: 
583: // Helper function for UTF-8 aware space trimming
584: static string TrimWhitespace(const string &col_name) {
585: 	utf8proc_int32_t codepoint;
586: 	auto str = reinterpret_cast<const utf8proc_uint8_t *>(col_name.c_str());
587: 	idx_t size = col_name.size();
588: 	// Find the first character that is not left trimmed
589: 	idx_t begin = 0;
590: 	while (begin < size) {
591: 		auto bytes = utf8proc_iterate(str + begin, size - begin, &codepoint);
592: 		D_ASSERT(bytes > 0);
593: 		if (utf8proc_category(codepoint) != UTF8PROC_CATEGORY_ZS) {
594: 			break;
595: 		}
596: 		begin += bytes;
597: 	}
598: 
599: 	// Find the last character that is not right trimmed
600: 	idx_t end;
601: 	end = begin;
602: 	for (auto next = begin; next < col_name.size();) {
603: 		auto bytes = utf8proc_iterate(str + next, size - next, &codepoint);
604: 		D_ASSERT(bytes > 0);
605: 		next += bytes;
606: 		if (utf8proc_category(codepoint) != UTF8PROC_CATEGORY_ZS) {
607: 			end = next;
608: 		}
609: 	}
610: 
611: 	// return the trimmed string
612: 	return col_name.substr(begin, end - begin);
613: }
614: 
615: static string NormalizeColumnName(const string &col_name) {
616: 	// normalize UTF8 characters to NFKD
617: 	auto nfkd = utf8proc_NFKD((const utf8proc_uint8_t *)col_name.c_str(), col_name.size());
618: 	const string col_name_nfkd = string((const char *)nfkd, strlen((const char *)nfkd));
619: 	free(nfkd);
620: 
621: 	// only keep ASCII characters 0-9 a-z A-Z and replace spaces with regular whitespace
622: 	string col_name_ascii = "";
623: 	for (idx_t i = 0; i < col_name_nfkd.size(); i++) {
624: 		if (col_name_nfkd[i] == '_' || (col_name_nfkd[i] >= '0' && col_name_nfkd[i] <= '9') ||
625: 		    (col_name_nfkd[i] >= 'A' && col_name_nfkd[i] <= 'Z') ||
626: 		    (col_name_nfkd[i] >= 'a' && col_name_nfkd[i] <= 'z')) {
627: 			col_name_ascii += col_name_nfkd[i];
628: 		} else if (StringUtil::CharacterIsSpace(col_name_nfkd[i])) {
629: 			col_name_ascii += " ";
630: 		}
631: 	}
632: 
633: 	// trim whitespace and replace remaining whitespace by _
634: 	string col_name_trimmed = TrimWhitespace(col_name_ascii);
635: 	string col_name_cleaned = "";
636: 	bool in_whitespace = false;
637: 	for (idx_t i = 0; i < col_name_trimmed.size(); i++) {
638: 		if (col_name_trimmed[i] == ' ') {
639: 			if (!in_whitespace) {
640: 				col_name_cleaned += "_";
641: 				in_whitespace = true;
642: 			}
643: 		} else {
644: 			col_name_cleaned += col_name_trimmed[i];
645: 			in_whitespace = false;
646: 		}
647: 	}
648: 
649: 	// don't leave string empty; if not empty, make lowercase
650: 	if (col_name_cleaned.empty()) {
651: 		col_name_cleaned = "_";
652: 	} else {
653: 		col_name_cleaned = StringUtil::Lower(col_name_cleaned);
654: 	}
655: 
656: 	// prepend _ if name starts with a digit or is a reserved keyword
657: 	if (KeywordHelper::IsKeyword(col_name_cleaned) || (col_name_cleaned[0] >= '0' && col_name_cleaned[0] <= '9')) {
658: 		col_name_cleaned = "_" + col_name_cleaned;
659: 	}
660: 	return col_name_cleaned;
661: }
662: 
663: void BufferedCSVReader::ResetBuffer() {
664: 	buffer.reset();
665: 	buffer_size = 0;
666: 	position = 0;
667: 	start = 0;
668: 	cached_buffers.clear();
669: }
670: 
671: void BufferedCSVReader::ResetStream() {
672: 	if (!file_handle->CanSeek()) {
673: 		// seeking to the beginning appears to not be supported in all compiler/os-scenarios,
674: 		// so we have to create a new stream source here for now
675: 		file_handle->Reset();
676: 	} else {
677: 		file_handle->Seek(0);
678: 	}
679: 	linenr = 0;
680: 	linenr_estimated = false;
681: 	bytes_per_line_avg = 0;
682: 	sample_chunk_idx = 0;
683: 	jumping_samples = false;
684: }
685: 
686: void BufferedCSVReader::InitParseChunk(idx_t num_cols) {
687: 	// adapt not null info
688: 	if (options.force_not_null.size() != num_cols) {
689: 		options.force_not_null.resize(num_cols, false);
690: 	}
691: 	if (num_cols == parse_chunk.ColumnCount()) {
692: 		parse_chunk.Reset();
693: 	} else {
694: 		parse_chunk.Destroy();
695: 
696: 		// initialize the parse_chunk with a set of VARCHAR types
697: 		vector<LogicalType> varchar_types(num_cols, LogicalType::VARCHAR);
698: 		parse_chunk.Initialize(allocator, varchar_types);
699: 	}
700: }
701: 
702: void BufferedCSVReader::InitInsertChunkIdx(idx_t num_cols) {
703: 	for (idx_t col = 0; col < num_cols; ++col) {
704: 		insert_cols_idx.push_back(col);
705: 	}
706: }
707: 
708: void BufferedCSVReader::JumpToBeginning(idx_t skip_rows = 0, bool skip_header = false) {
709: 	ResetBuffer();
710: 	ResetStream();
711: 	sample_chunk_idx = 0;
712: 	bytes_in_chunk = 0;
713: 	end_of_file_reached = false;
714: 	bom_checked = false;
715: 	SkipRowsAndReadHeader(skip_rows, skip_header);
716: }
717: 
718: void BufferedCSVReader::SkipRowsAndReadHeader(idx_t skip_rows, bool skip_header) {
719: 	for (idx_t i = 0; i < skip_rows; i++) {
720: 		// ignore skip rows
721: 		string read_line = file_handle->ReadLine();
722: 		linenr++;
723: 	}
724: 
725: 	if (skip_header) {
726: 		// ignore the first line as a header line
727: 		InitParseChunk(sql_types.size());
728: 		ParseCSV(ParserMode::PARSING_HEADER);
729: 	}
730: }
731: 
732: bool BufferedCSVReader::JumpToNextSample() {
733: 	// get bytes contained in the previously read chunk
734: 	idx_t remaining_bytes_in_buffer = buffer_size - start;
735: 	bytes_in_chunk -= remaining_bytes_in_buffer;
736: 	if (remaining_bytes_in_buffer == 0) {
737: 		return false;
738: 	}
739: 
740: 	// assess if it makes sense to jump, based on size of the first chunk relative to size of the entire file
741: 	if (sample_chunk_idx == 0) {
742: 		idx_t bytes_first_chunk = bytes_in_chunk;
743: 		double chunks_fit = (file_handle->FileSize() / (double)bytes_first_chunk);
744: 		jumping_samples = chunks_fit >= options.sample_chunks;
745: 
746: 		// jump back to the beginning
747: 		JumpToBeginning(options.skip_rows, options.header);
748: 		sample_chunk_idx++;
749: 		return true;
750: 	}
751: 
752: 	if (end_of_file_reached || sample_chunk_idx >= options.sample_chunks) {
753: 		return false;
754: 	}
755: 
756: 	// if we deal with any other sources than plaintext files, jumping_samples can be tricky. In that case
757: 	// we just read x continuous chunks from the stream TODO: make jumps possible for zipfiles.
758: 	if (!file_handle->PlainFileSource() || !jumping_samples) {
759: 		sample_chunk_idx++;
760: 		return true;
761: 	}
762: 
763: 	// update average bytes per line
764: 	double bytes_per_line = bytes_in_chunk / (double)options.sample_chunk_size;
765: 	bytes_per_line_avg = ((bytes_per_line_avg * (sample_chunk_idx)) + bytes_per_line) / (sample_chunk_idx + 1);
766: 
767: 	// if none of the previous conditions were met, we can jump
768: 	idx_t partition_size = (idx_t)round(file_handle->FileSize() / (double)options.sample_chunks);
769: 
770: 	// calculate offset to end of the current partition
771: 	int64_t offset = partition_size - bytes_in_chunk - remaining_bytes_in_buffer;
772: 	auto current_pos = file_handle->SeekPosition();
773: 
774: 	if (current_pos + offset < file_handle->FileSize()) {
775: 		// set position in stream and clear failure bits
776: 		file_handle->Seek(current_pos + offset);
777: 
778: 		// estimate linenr
779: 		linenr += (idx_t)round((offset + remaining_bytes_in_buffer) / bytes_per_line_avg);
780: 		linenr_estimated = true;
781: 	} else {
782: 		// seek backwards from the end in last chunk and hope to catch the end of the file
783: 		// TODO: actually it would be good to make sure that the end of file is being reached, because
784: 		// messy end-lines are quite common. For this case, however, we first need a skip_end detection anyways.
785: 		file_handle->Seek(file_handle->FileSize() - bytes_in_chunk);
786: 
787: 		// estimate linenr
788: 		linenr = (idx_t)round((file_handle->FileSize() - bytes_in_chunk) / bytes_per_line_avg);
789: 		linenr_estimated = true;
790: 	}
791: 
792: 	// reset buffers and parse chunk
793: 	ResetBuffer();
794: 
795: 	// seek beginning of next line
796: 	// FIXME: if this jump ends up in a quoted linebreak, we will have a problem
797: 	string read_line = file_handle->ReadLine();
798: 	linenr++;
799: 
800: 	sample_chunk_idx++;
801: 
802: 	return true;
803: }
804: 
805: void BufferedCSVReader::SetDateFormat(const string &format_specifier, const LogicalTypeId &sql_type) {
806: 	options.has_format[sql_type] = true;
807: 	auto &date_format = options.date_format[sql_type];
808: 	date_format.format_specifier = format_specifier;
809: 	StrTimeFormat::ParseFormatSpecifier(date_format.format_specifier, date_format);
810: }
811: 
812: bool BufferedCSVReader::TryCastValue(const Value &value, const LogicalType &sql_type) {
813: 	if (options.has_format[LogicalTypeId::DATE] && sql_type.id() == LogicalTypeId::DATE) {
814: 		date_t result;
815: 		string error_message;
816: 		return options.date_format[LogicalTypeId::DATE].TryParseDate(string_t(StringValue::Get(value)), result,
817: 		                                                             error_message);
818: 	} else if (options.has_format[LogicalTypeId::TIMESTAMP] && sql_type.id() == LogicalTypeId::TIMESTAMP) {
819: 		timestamp_t result;
820: 		string error_message;
821: 		return options.date_format[LogicalTypeId::TIMESTAMP].TryParseTimestamp(string_t(StringValue::Get(value)),
822: 		                                                                       result, error_message);
823: 	} else {
824: 		Value new_value;
825: 		string error_message;
826: 		return value.DefaultTryCastAs(sql_type, new_value, &error_message, true);
827: 	}
828: }
829: 
830: struct TryCastDateOperator {
831: 	static bool Operation(BufferedCSVReaderOptions &options, string_t input, date_t &result, string &error_message) {
832: 		return options.date_format[LogicalTypeId::DATE].TryParseDate(input, result, error_message);
833: 	}
834: };
835: 
836: struct TryCastTimestampOperator {
837: 	static bool Operation(BufferedCSVReaderOptions &options, string_t input, timestamp_t &result,
838: 	                      string &error_message) {
839: 		return options.date_format[LogicalTypeId::TIMESTAMP].TryParseTimestamp(input, result, error_message);
840: 	}
841: };
842: 
843: template <class OP, class T>
844: static bool TemplatedTryCastDateVector(BufferedCSVReaderOptions &options, Vector &input_vector, Vector &result_vector,
845:                                        idx_t count, string &error_message) {
846: 	D_ASSERT(input_vector.GetType().id() == LogicalTypeId::VARCHAR);
847: 	bool all_converted = true;
848: 	UnaryExecutor::Execute<string_t, T>(input_vector, result_vector, count, [&](string_t input) {
849: 		T result;
850: 		if (!OP::Operation(options, input, result, error_message)) {
851: 			all_converted = false;
852: 		}
853: 		return result;
854: 	});
855: 	return all_converted;
856: }
857: 
858: bool TryCastDateVector(BufferedCSVReaderOptions &options, Vector &input_vector, Vector &result_vector, idx_t count,
859:                        string &error_message) {
860: 	return TemplatedTryCastDateVector<TryCastDateOperator, date_t>(options, input_vector, result_vector, count,
861: 	                                                               error_message);
862: }
863: 
864: bool TryCastTimestampVector(BufferedCSVReaderOptions &options, Vector &input_vector, Vector &result_vector, idx_t count,
865:                             string &error_message) {
866: 	return TemplatedTryCastDateVector<TryCastTimestampOperator, timestamp_t>(options, input_vector, result_vector,
867: 	                                                                         count, error_message);
868: }
869: 
870: bool BufferedCSVReader::TryCastVector(Vector &parse_chunk_col, idx_t size, const LogicalType &sql_type) {
871: 	// try vector-cast from string to sql_type
872: 	Vector dummy_result(sql_type);
873: 	if (options.has_format[LogicalTypeId::DATE] && sql_type == LogicalTypeId::DATE) {
874: 		// use the date format to cast the chunk
875: 		string error_message;
876: 		return TryCastDateVector(options, parse_chunk_col, dummy_result, size, error_message);
877: 	} else if (options.has_format[LogicalTypeId::TIMESTAMP] && sql_type == LogicalTypeId::TIMESTAMP) {
878: 		// use the timestamp format to cast the chunk
879: 		string error_message;
880: 		return TryCastTimestampVector(options, parse_chunk_col, dummy_result, size, error_message);
881: 	} else {
882: 		// target type is not varchar: perform a cast
883: 		string error_message;
884: 		return VectorOperations::DefaultTryCast(parse_chunk_col, dummy_result, size, &error_message, true);
885: 	}
886: }
887: 
888: enum class QuoteRule : uint8_t { QUOTES_RFC = 0, QUOTES_OTHER = 1, NO_QUOTES = 2 };
889: 
890: void BufferedCSVReader::DetectDialect(const vector<LogicalType> &requested_types,
891:                                       BufferedCSVReaderOptions &original_options,
892:                                       vector<BufferedCSVReaderOptions> &info_candidates, idx_t &best_num_cols) {
893: 	// set up the candidates we consider for delimiter and quote rules based on user input
894: 	vector<string> delim_candidates;
895: 	vector<QuoteRule> quoterule_candidates;
896: 	vector<vector<string>> quote_candidates_map;
897: 	vector<vector<string>> escape_candidates_map = {{""}, {"\\"}, {""}};
898: 
899: 	if (options.has_delimiter) {
900: 		// user provided a delimiter: use that delimiter
901: 		delim_candidates = {options.delimiter};
902: 	} else {
903: 		// no delimiter provided: try standard/common delimiters
904: 		delim_candidates = {",", "|", ";", "\t"};
905: 	}
906: 	if (options.has_quote) {
907: 		// user provided quote: use that quote rule
908: 		quote_candidates_map = {{options.quote}, {options.quote}, {options.quote}};
909: 	} else {
910: 		// no quote rule provided: use standard/common quotes
911: 		quote_candidates_map = {{"\""}, {"\"", "'"}, {""}};
912: 	}
913: 	if (options.has_escape) {
914: 		// user provided escape: use that escape rule
915: 		if (options.escape.empty()) {
916: 			quoterule_candidates = {QuoteRule::QUOTES_RFC};
917: 		} else {
918: 			quoterule_candidates = {QuoteRule::QUOTES_OTHER};
919: 		}
920: 		escape_candidates_map[static_cast<uint8_t>(quoterule_candidates[0])] = {options.escape};
921: 	} else {
922: 		// no escape provided: try standard/common escapes
923: 		quoterule_candidates = {QuoteRule::QUOTES_RFC, QuoteRule::QUOTES_OTHER, QuoteRule::NO_QUOTES};
924: 	}
925: 
926: 	idx_t best_consistent_rows = 0;
927: 	for (auto quoterule : quoterule_candidates) {
928: 		const auto &quote_candidates = quote_candidates_map[static_cast<uint8_t>(quoterule)];
929: 		for (const auto &quote : quote_candidates) {
930: 			for (const auto &delim : delim_candidates) {
931: 				const auto &escape_candidates = escape_candidates_map[static_cast<uint8_t>(quoterule)];
932: 				for (const auto &escape : escape_candidates) {
933: 					BufferedCSVReaderOptions sniff_info = original_options;
934: 					sniff_info.delimiter = delim;
935: 					sniff_info.quote = quote;
936: 					sniff_info.escape = escape;
937: 
938: 					options = sniff_info;
939: 					PrepareComplexParser();
940: 
941: 					JumpToBeginning(original_options.skip_rows);
942: 					sniffed_column_counts.clear();
943: 
944: 					if (!TryParseCSV(ParserMode::SNIFFING_DIALECT)) {
945: 						continue;
946: 					}
947: 
948: 					idx_t start_row = original_options.skip_rows;
949: 					idx_t consistent_rows = 0;
950: 					idx_t num_cols = 0;
951: 
952: 					for (idx_t row = 0; row < sniffed_column_counts.size(); row++) {
953: 						if (sniffed_column_counts[row] == num_cols) {
954: 							consistent_rows++;
955: 						} else {
956: 							num_cols = sniffed_column_counts[row];
957: 							start_row = row + original_options.skip_rows;
958: 							consistent_rows = 1;
959: 						}
960: 					}
961: 
962: 					// some logic
963: 					bool more_values = (consistent_rows > best_consistent_rows && num_cols >= best_num_cols);
964: 					bool single_column_before = best_num_cols < 2 && num_cols > best_num_cols;
965: 					bool rows_consistent =
966: 					    start_row + consistent_rows - original_options.skip_rows == sniffed_column_counts.size();
967: 					bool more_than_one_row = (consistent_rows > 1);
968: 					bool more_than_one_column = (num_cols > 1);
969: 					bool start_good = !info_candidates.empty() && (start_row <= info_candidates.front().skip_rows);
970: 
971: 					if (!requested_types.empty() && requested_types.size() != num_cols) {
972: 						continue;
973: 					} else if ((more_values || single_column_before) && rows_consistent) {
974: 						sniff_info.skip_rows = start_row;
975: 						sniff_info.num_cols = num_cols;
976: 						best_consistent_rows = consistent_rows;
977: 						best_num_cols = num_cols;
978: 
979: 						info_candidates.clear();
980: 						info_candidates.push_back(sniff_info);
981: 					} else if (more_than_one_row && more_than_one_column && start_good && rows_consistent) {
982: 						bool same_quote_is_candidate = false;
983: 						for (auto &info_candidate : info_candidates) {
984: 							if (quote.compare(info_candidate.quote) == 0) {
985: 								same_quote_is_candidate = true;
986: 							}
987: 						}
988: 						if (!same_quote_is_candidate) {
989: 							sniff_info.skip_rows = start_row;
990: 							sniff_info.num_cols = num_cols;
991: 							info_candidates.push_back(sniff_info);
992: 						}
993: 					}
994: 				}
995: 			}
996: 		}
997: 	}
998: }
999: 
1000: void BufferedCSVReader::DetectCandidateTypes(const vector<LogicalType> &type_candidates,
1001:                                              const map<LogicalTypeId, vector<const char *>> &format_template_candidates,
1002:                                              const vector<BufferedCSVReaderOptions> &info_candidates,
1003:                                              BufferedCSVReaderOptions &original_options, idx_t best_num_cols,
1004:                                              vector<vector<LogicalType>> &best_sql_types_candidates,
1005:                                              std::map<LogicalTypeId, vector<string>> &best_format_candidates,
1006:                                              DataChunk &best_header_row) {
1007: 	BufferedCSVReaderOptions best_options;
1008: 	idx_t min_varchar_cols = best_num_cols + 1;
1009: 
1010: 	// check which info candidate leads to minimum amount of non-varchar columns...
1011: 	for (const auto &t : format_template_candidates) {
1012: 		best_format_candidates[t.first].clear();
1013: 	}
1014: 	for (auto &info_candidate : info_candidates) {
1015: 		options = info_candidate;
1016: 		vector<vector<LogicalType>> info_sql_types_candidates(options.num_cols, type_candidates);
1017: 		std::map<LogicalTypeId, bool> has_format_candidates;
1018: 		std::map<LogicalTypeId, vector<string>> format_candidates;
1019: 		for (const auto &t : format_template_candidates) {
1020: 			has_format_candidates[t.first] = false;
1021: 			format_candidates[t.first].clear();
1022: 		}
1023: 
1024: 		// set all sql_types to VARCHAR so we can do datatype detection based on VARCHAR values
1025: 		sql_types.clear();
1026: 		sql_types.assign(options.num_cols, LogicalType::VARCHAR);
1027: 
1028: 		// jump to beginning and skip potential header
1029: 		JumpToBeginning(options.skip_rows, true);
1030: 		DataChunk header_row;
1031: 		header_row.Initialize(allocator, sql_types);
1032: 		parse_chunk.Copy(header_row);
1033: 
1034: 		if (header_row.size() == 0) {
1035: 			continue;
1036: 		}
1037: 
1038: 		// init parse chunk and read csv with info candidate
1039: 		InitParseChunk(sql_types.size());
1040: 		ParseCSV(ParserMode::SNIFFING_DATATYPES);
1041: 		for (idx_t row_idx = 0; row_idx <= parse_chunk.size(); row_idx++) {
1042: 			bool is_header_row = row_idx == 0;
1043: 			idx_t row = row_idx - 1;
1044: 			for (idx_t col = 0; col < parse_chunk.ColumnCount(); col++) {
1045: 				auto &col_type_candidates = info_sql_types_candidates[col];
1046: 				while (col_type_candidates.size() > 1) {
1047: 					const auto &sql_type = col_type_candidates.back();
1048: 					// try cast from string to sql_type
1049: 					Value dummy_val;
1050: 					if (is_header_row) {
1051: 						dummy_val = header_row.GetValue(col, 0);
1052: 					} else {
1053: 						dummy_val = parse_chunk.GetValue(col, row);
1054: 					}
1055: 					// try formatting for date types if the user did not specify one and it starts with numeric values.
1056: 					string separator;
1057: 					if (has_format_candidates.count(sql_type.id()) && !original_options.has_format[sql_type.id()] &&
1058: 					    StartsWithNumericDate(separator, StringValue::Get(dummy_val))) {
1059: 						// generate date format candidates the first time through
1060: 						auto &type_format_candidates = format_candidates[sql_type.id()];
1061: 						const auto had_format_candidates = has_format_candidates[sql_type.id()];
1062: 						if (!has_format_candidates[sql_type.id()]) {
1063: 							has_format_candidates[sql_type.id()] = true;
1064: 							// order by preference
1065: 							auto entry = format_template_candidates.find(sql_type.id());
1066: 							if (entry != format_template_candidates.end()) {
1067: 								const auto &format_template_list = entry->second;
1068: 								for (const auto &t : format_template_list) {
1069: 									const auto format_string = GenerateDateFormat(separator, t);
1070: 									// don't parse ISO 8601
1071: 									if (format_string.find("%Y-%m-%d") == string::npos) {
1072: 										type_format_candidates.emplace_back(format_string);
1073: 									}
1074: 								}
1075: 							}
1076: 							//	initialise the first candidate
1077: 							options.has_format[sql_type.id()] = true;
1078: 							//	all formats are constructed to be valid
1079: 							SetDateFormat(type_format_candidates.back(), sql_type.id());
1080: 						}
1081: 						// check all formats and keep the first one that works
1082: 						StrpTimeFormat::ParseResult result;
1083: 						auto save_format_candidates = type_format_candidates;
1084: 						while (!type_format_candidates.empty()) {
1085: 							//	avoid using exceptions for flow control...
1086: 							auto &current_format = options.date_format[sql_type.id()];
1087: 							if (current_format.Parse(StringValue::Get(dummy_val), result)) {
1088: 								break;
1089: 							}
1090: 							//	doesn't work - move to the next one
1091: 							type_format_candidates.pop_back();
1092: 							options.has_format[sql_type.id()] = (!type_format_candidates.empty());
1093: 							if (!type_format_candidates.empty()) {
1094: 								SetDateFormat(type_format_candidates.back(), sql_type.id());
1095: 							}
1096: 						}
1097: 						//	if none match, then this is not a value of type sql_type,
1098: 						if (type_format_candidates.empty()) {
1099: 							//	so restore the candidates that did work.
1100: 							//	or throw them out if they were generated by this value.
1101: 							if (had_format_candidates) {
1102: 								type_format_candidates.swap(save_format_candidates);
1103: 								if (!type_format_candidates.empty()) {
1104: 									SetDateFormat(type_format_candidates.back(), sql_type.id());
1105: 								}
1106: 							} else {
1107: 								has_format_candidates[sql_type.id()] = false;
1108: 							}
1109: 						}
1110: 					}
1111: 					// try cast from string to sql_type
1112: 					if (TryCastValue(dummy_val, sql_type)) {
1113: 						break;
1114: 					} else {
1115: 						col_type_candidates.pop_back();
1116: 					}
1117: 				}
1118: 			}
1119: 			// reset type detection, because first row could be header,
1120: 			// but only do it if csv has more than one line (including header)
1121: 			if (parse_chunk.size() > 0 && is_header_row) {
1122: 				info_sql_types_candidates = vector<vector<LogicalType>>(options.num_cols, type_candidates);
1123: 				for (auto &f : format_candidates) {
1124: 					f.second.clear();
1125: 				}
1126: 				for (auto &h : has_format_candidates) {
1127: 					h.second = false;
1128: 				}
1129: 			}
1130: 		}
1131: 
1132: 		idx_t varchar_cols = 0;
1133: 		for (idx_t col = 0; col < parse_chunk.ColumnCount(); col++) {
1134: 			auto &col_type_candidates = info_sql_types_candidates[col];
1135: 			// check number of varchar columns
1136: 			const auto &col_type = col_type_candidates.back();
1137: 			if (col_type == LogicalType::VARCHAR) {
1138: 				varchar_cols++;
1139: 			}
1140: 		}
1141: 
1142: 		// it's good if the dialect creates more non-varchar columns, but only if we sacrifice < 30% of best_num_cols.
1143: 		if (varchar_cols < min_varchar_cols && parse_chunk.ColumnCount() > (best_num_cols * 0.7)) {
1144: 			// we have a new best_options candidate
1145: 			best_options = info_candidate;
1146: 			min_varchar_cols = varchar_cols;
1147: 			best_sql_types_candidates = info_sql_types_candidates;
1148: 			best_format_candidates = format_candidates;
1149: 			best_header_row.Destroy();
1150: 			auto header_row_types = header_row.GetTypes();
1151: 			best_header_row.Initialize(allocator, header_row_types);
1152: 			header_row.Copy(best_header_row);
1153: 		}
1154: 	}
1155: 
1156: 	options = best_options;
1157: 	for (const auto &best : best_format_candidates) {
1158: 		if (!best.second.empty()) {
1159: 			SetDateFormat(best.second.back(), best.first);
1160: 		}
1161: 	}
1162: }
1163: 
1164: void BufferedCSVReader::DetectHeader(const vector<vector<LogicalType>> &best_sql_types_candidates,
1165:                                      const DataChunk &best_header_row) {
1166: 	// information for header detection
1167: 	bool first_row_consistent = true;
1168: 	bool first_row_nulls = false;
1169: 
1170: 	// check if header row is all null and/or consistent with detected column data types
1171: 	first_row_nulls = true;
1172: 	for (idx_t col = 0; col < best_sql_types_candidates.size(); col++) {
1173: 		auto dummy_val = best_header_row.GetValue(col, 0);
1174: 		if (!dummy_val.IsNull()) {
1175: 			first_row_nulls = false;
1176: 		}
1177: 
1178: 		// try cast to sql_type of column
1179: 		const auto &sql_type = best_sql_types_candidates[col].back();
1180: 		if (!TryCastValue(dummy_val, sql_type)) {
1181: 			first_row_consistent = false;
1182: 		}
1183: 	}
1184: 
1185: 	// update parser info, and read, generate & set col_names based on previous findings
1186: 	if (((!first_row_consistent || first_row_nulls) && !options.has_header) || (options.has_header && options.header)) {
1187: 		options.header = true;
1188: 		case_insensitive_map_t<idx_t> name_collision_count;
1189: 		// get header names from CSV
1190: 		for (idx_t col = 0; col < options.num_cols; col++) {
1191: 			const auto &val = best_header_row.GetValue(col, 0);
1192: 			string col_name = val.ToString();
1193: 
1194: 			// generate name if field is empty
1195: 			if (col_name.empty() || val.IsNull()) {
1196: 				col_name = GenerateColumnName(options.num_cols, col);
1197: 			}
1198: 
1199: 			// normalize names or at least trim whitespace
1200: 			if (options.normalize_names) {
1201: 				col_name = NormalizeColumnName(col_name);
1202: 			} else {
1203: 				col_name = TrimWhitespace(col_name);
1204: 			}
1205: 
1206: 			// avoid duplicate header names
1207: 			const string col_name_raw = col_name;
1208: 			while (name_collision_count.find(col_name) != name_collision_count.end()) {
1209: 				name_collision_count[col_name] += 1;
1210: 				col_name = col_name + "_" + to_string(name_collision_count[col_name]);
1211: 			}
1212: 
1213: 			col_names.push_back(col_name);
1214: 			name_collision_count[col_name] = 0;
1215: 		}
1216: 
1217: 	} else {
1218: 		options.header = false;
1219: 		for (idx_t col = 0; col < options.num_cols; col++) {
1220: 			string column_name = GenerateColumnName(options.num_cols, col);
1221: 			col_names.push_back(column_name);
1222: 		}
1223: 	}
1224: }
1225: 
1226: vector<LogicalType> BufferedCSVReader::RefineTypeDetection(const vector<LogicalType> &type_candidates,
1227:                                                            const vector<LogicalType> &requested_types,
1228:                                                            vector<vector<LogicalType>> &best_sql_types_candidates,
1229:                                                            map<LogicalTypeId, vector<string>> &best_format_candidates) {
1230: 	// for the type refine we set the SQL types to VARCHAR for all columns
1231: 	sql_types.clear();
1232: 	sql_types.assign(options.num_cols, LogicalType::VARCHAR);
1233: 
1234: 	vector<LogicalType> detected_types;
1235: 
1236: 	// if data types were provided, exit here if number of columns does not match
1237: 	if (!requested_types.empty()) {
1238: 		if (requested_types.size() != options.num_cols) {
1239: 			throw InvalidInputException(
1240: 			    "Error while determining column types: found %lld columns but expected %d. (%s)", options.num_cols,
1241: 			    requested_types.size(), options.ToString());
1242: 		} else {
1243: 			detected_types = requested_types;
1244: 		}
1245: 	} else if (options.all_varchar) {
1246: 		// return all types varchar
1247: 		detected_types = sql_types;
1248: 	} else {
1249: 		// jump through the rest of the file and continue to refine the sql type guess
1250: 		while (JumpToNextSample()) {
1251: 			InitParseChunk(sql_types.size());
1252: 			// if jump ends up a bad line, we just skip this chunk
1253: 			if (!TryParseCSV(ParserMode::SNIFFING_DATATYPES)) {
1254: 				continue;
1255: 			}
1256: 			for (idx_t col = 0; col < parse_chunk.ColumnCount(); col++) {
1257: 				vector<LogicalType> &col_type_candidates = best_sql_types_candidates[col];
1258: 				while (col_type_candidates.size() > 1) {
1259: 					const auto &sql_type = col_type_candidates.back();
1260: 					//	narrow down the date formats
1261: 					if (best_format_candidates.count(sql_type.id())) {
1262: 						auto &best_type_format_candidates = best_format_candidates[sql_type.id()];
1263: 						auto save_format_candidates = best_type_format_candidates;
1264: 						while (!best_type_format_candidates.empty()) {
1265: 							if (TryCastVector(parse_chunk.data[col], parse_chunk.size(), sql_type)) {
1266: 								break;
1267: 							}
1268: 							//	doesn't work - move to the next one
1269: 							best_type_format_candidates.pop_back();
1270: 							options.has_format[sql_type.id()] = (!best_type_format_candidates.empty());
1271: 							if (!best_type_format_candidates.empty()) {
1272: 								SetDateFormat(best_type_format_candidates.back(), sql_type.id());
1273: 							}
1274: 						}
1275: 						//	if none match, then this is not a column of type sql_type,
1276: 						if (best_type_format_candidates.empty()) {
1277: 							//	so restore the candidates that did work.
1278: 							best_type_format_candidates.swap(save_format_candidates);
1279: 							if (!best_type_format_candidates.empty()) {
1280: 								SetDateFormat(best_type_format_candidates.back(), sql_type.id());
1281: 							}
1282: 						}
1283: 					}
1284: 
1285: 					if (TryCastVector(parse_chunk.data[col], parse_chunk.size(), sql_type)) {
1286: 						break;
1287: 					} else {
1288: 						col_type_candidates.pop_back();
1289: 					}
1290: 				}
1291: 			}
1292: 
1293: 			if (!jumping_samples) {
1294: 				if ((sample_chunk_idx)*options.sample_chunk_size <= options.buffer_size) {
1295: 					// cache parse chunk
1296: 					// create a new chunk and fill it with the remainder
1297: 					auto chunk = make_unique<DataChunk>();
1298: 					auto parse_chunk_types = parse_chunk.GetTypes();
1299: 					chunk->Move(parse_chunk);
1300: 					cached_chunks.push(move(chunk));
1301: 				} else {
1302: 					while (!cached_chunks.empty()) {
1303: 						cached_chunks.pop();
1304: 					}
1305: 				}
1306: 			}
1307: 		}
1308: 
1309: 		// set sql types
1310: 		for (auto &best_sql_types_candidate : best_sql_types_candidates) {
1311: 			LogicalType d_type = best_sql_types_candidate.back();
1312: 			if (best_sql_types_candidate.size() == type_candidates.size()) {
1313: 				d_type = LogicalType::VARCHAR;
1314: 			}
1315: 			detected_types.push_back(d_type);
1316: 		}
1317: 	}
1318: 
1319: 	return detected_types;
1320: }
1321: 
1322: vector<LogicalType> BufferedCSVReader::SniffCSV(const vector<LogicalType> &requested_types) {
1323: 	for (auto &type : requested_types) {
1324: 		// auto detect for blobs not supported: there may be invalid UTF-8 in the file
1325: 		if (type.id() == LogicalTypeId::BLOB) {
1326: 			return requested_types;
1327: 		}
1328: 	}
1329: 
1330: 	// #######
1331: 	// ### dialect detection
1332: 	// #######
1333: 	BufferedCSVReaderOptions original_options = options;
1334: 	vector<BufferedCSVReaderOptions> info_candidates;
1335: 	idx_t best_num_cols = 0;
1336: 
1337: 	DetectDialect(requested_types, original_options, info_candidates, best_num_cols);
1338: 
1339: 	// if no dialect candidate was found, then file was most likely empty and we throw an exception
1340: 	if (info_candidates.empty()) {
1341: 		throw InvalidInputException(
1342: 		    "Error in file \"%s\": CSV options could not be auto-detected. Consider setting parser options manually.",
1343: 		    options.file_path);
1344: 	}
1345: 
1346: 	// #######
1347: 	// ### type detection (initial)
1348: 	// #######
1349: 	// type candidates, ordered by descending specificity (~ from high to low)
1350: 	vector<LogicalType> type_candidates = {
1351: 	    LogicalType::VARCHAR, LogicalType::TIMESTAMP,
1352: 	    LogicalType::DATE,    LogicalType::TIME,
1353: 	    LogicalType::DOUBLE,  /* LogicalType::FLOAT,*/ LogicalType::BIGINT,
1354: 	    LogicalType::INTEGER, /*LogicalType::SMALLINT, LogicalType::TINYINT,*/ LogicalType::BOOLEAN,
1355: 	    LogicalType::SQLNULL};
1356: 	// format template candidates, ordered by descending specificity (~ from high to low)
1357: 	std::map<LogicalTypeId, vector<const char *>> format_template_candidates = {
1358: 	    {LogicalTypeId::DATE, {"%m-%d-%Y", "%m-%d-%y", "%d-%m-%Y", "%d-%m-%y", "%Y-%m-%d", "%y-%m-%d"}},
1359: 	    {LogicalTypeId::TIMESTAMP,
1360: 	     {"%Y-%m-%d %H:%M:%S.%f", "%m-%d-%Y %I:%M:%S %p", "%m-%d-%y %I:%M:%S %p", "%d-%m-%Y %H:%M:%S",
1361: 	      "%d-%m-%y %H:%M:%S", "%Y-%m-%d %H:%M:%S", "%y-%m-%d %H:%M:%S"}},
1362: 	};
1363: 	vector<vector<LogicalType>> best_sql_types_candidates;
1364: 	map<LogicalTypeId, vector<string>> best_format_candidates;
1365: 	DataChunk best_header_row;
1366: 	DetectCandidateTypes(type_candidates, format_template_candidates, info_candidates, original_options, best_num_cols,
1367: 	                     best_sql_types_candidates, best_format_candidates, best_header_row);
1368: 
1369: 	// #######
1370: 	// ### header detection
1371: 	// #######
1372: 	options.num_cols = best_num_cols;
1373: 	DetectHeader(best_sql_types_candidates, best_header_row);
1374: 
1375: 	// #######
1376: 	// ### type detection (refining)
1377: 	// #######
1378: 	return RefineTypeDetection(type_candidates, requested_types, best_sql_types_candidates, best_format_candidates);
1379: }
1380: 
1381: bool BufferedCSVReader::TryParseComplexCSV(DataChunk &insert_chunk, string &error_message) {
1382: 	// used for parsing algorithm
1383: 	bool finished_chunk = false;
1384: 	idx_t column = 0;
1385: 	vector<idx_t> escape_positions;
1386: 	bool has_quotes = false;
1387: 	uint8_t delimiter_pos = 0, escape_pos = 0, quote_pos = 0;
1388: 	idx_t offset = 0;
1389: 
1390: 	// read values into the buffer (if any)
1391: 	if (position >= buffer_size) {
1392: 		if (!ReadBuffer(start)) {
1393: 			return true;
1394: 		}
1395: 	}
1396: 	// start parsing the first value
1397: 	start = position;
1398: 	goto value_start;
1399: value_start:
1400: 	/* state: value_start */
1401: 	// this state parses the first characters of a value
1402: 	offset = 0;
1403: 	delimiter_pos = 0;
1404: 	quote_pos = 0;
1405: 	do {
1406: 		idx_t count = 0;
1407: 		for (; position < buffer_size; position++) {
1408: 			quote_search.Match(quote_pos, buffer[position]);
1409: 			delimiter_search.Match(delimiter_pos, buffer[position]);
1410: 			count++;
1411: 			if (delimiter_pos == options.delimiter.size()) {
1412: 				// found a delimiter, add the value
1413: 				offset = options.delimiter.size() - 1;
1414: 				goto add_value;
1415: 			} else if (StringUtil::CharacterIsNewline(buffer[position])) {
1416: 				// found a newline, add the row
1417: 				goto add_row;
1418: 			}
1419: 			if (count > quote_pos) {
1420: 				// did not find a quote directly at the start of the value, stop looking for the quote now
1421: 				goto normal;
1422: 			}
1423: 			if (quote_pos == options.quote.size()) {
1424: 				// found a quote, go to quoted loop and skip the initial quote
1425: 				start += options.quote.size();
1426: 				goto in_quotes;
1427: 			}
1428: 		}
1429: 	} while (ReadBuffer(start));
1430: 	// file ends while scanning for quote/delimiter, go to final state
1431: 	goto final_state;
1432: normal:
1433: 	/* state: normal parsing state */
1434: 	// this state parses the remainder of a non-quoted value until we reach a delimiter or newline
1435: 	position++;
1436: 	do {
1437: 		for (; position < buffer_size; position++) {
1438: 			delimiter_search.Match(delimiter_pos, buffer[position]);
1439: 			if (delimiter_pos == options.delimiter.size()) {
1440: 				offset = options.delimiter.size() - 1;
1441: 				goto add_value;
1442: 			} else if (StringUtil::CharacterIsNewline(buffer[position])) {
1443: 				goto add_row;
1444: 			}
1445: 		}
1446: 	} while (ReadBuffer(start));
1447: 	goto final_state;
1448: add_value:
1449: 	AddValue(buffer.get() + start, position - start - offset, column, escape_positions, has_quotes);
1450: 	// increase position by 1 and move start to the new position
1451: 	offset = 0;
1452: 	has_quotes = false;
1453: 	start = ++position;
1454: 	if (position >= buffer_size && !ReadBuffer(start)) {
1455: 		// file ends right after delimiter, go to final state
1456: 		goto final_state;
1457: 	}
1458: 	goto value_start;
1459: add_row : {
1460: 	// check type of newline (\r or \n)
1461: 	bool carriage_return = buffer[position] == '\r';
1462: 	AddValue(buffer.get() + start, position - start - offset, column, escape_positions, has_quotes);
1463: 	finished_chunk = AddRow(insert_chunk, column);
1464: 	// increase position by 1 and move start to the new position
1465: 	offset = 0;
1466: 	has_quotes = false;
1467: 	start = ++position;
1468: 	if (position >= buffer_size && !ReadBuffer(start)) {
1469: 		// file ends right after newline, go to final state
1470: 		goto final_state;
1471: 	}
1472: 	if (carriage_return) {
1473: 		// \r newline, go to special state that parses an optional \n afterwards
1474: 		goto carriage_return;
1475: 	} else {
1476: 		// \n newline, move to value start
1477: 		if (finished_chunk) {
1478: 			return true;
1479: 		}
1480: 		goto value_start;
1481: 	}
1482: }
1483: in_quotes:
1484: 	/* state: in_quotes */
1485: 	// this state parses the remainder of a quoted value
1486: 	quote_pos = 0;
1487: 	escape_pos = 0;
1488: 	has_quotes = true;
1489: 	position++;
1490: 	do {
1491: 		for (; position < buffer_size; position++) {
1492: 			quote_search.Match(quote_pos, buffer[position]);
1493: 			escape_search.Match(escape_pos, buffer[position]);
1494: 			if (quote_pos == options.quote.size()) {
1495: 				goto unquote;
1496: 			} else if (escape_pos == options.escape.size()) {
1497: 				escape_positions.push_back(position - start - (options.escape.size() - 1));
1498: 				goto handle_escape;
1499: 			}
1500: 		}
1501: 	} while (ReadBuffer(start));
1502: 	// still in quoted state at the end of the file, error:
1503: 	error_message = StringUtil::Format("Error in file \"%s\" on line %s: unterminated quotes. (%s)", options.file_path,
1504: 	                                   GetLineNumberStr(linenr, linenr_estimated).c_str(), options.ToString());
1505: 	return false;
1506: unquote:
1507: 	/* state: unquote */
1508: 	// this state handles the state directly after we unquote
1509: 	// in this state we expect either another quote (entering the quoted state again, and escaping the quote)
1510: 	// or a delimiter/newline, ending the current value and moving on to the next value
1511: 	delimiter_pos = 0;
1512: 	quote_pos = 0;
1513: 	position++;
1514: 	if (position >= buffer_size && !ReadBuffer(start)) {
1515: 		// file ends right after unquote, go to final state
1516: 		offset = options.quote.size();
1517: 		goto final_state;
1518: 	}
1519: 	if (StringUtil::CharacterIsNewline(buffer[position])) {
1520: 		// quote followed by newline, add row
1521: 		offset = options.quote.size();
1522: 		goto add_row;
1523: 	}
1524: 	do {
1525: 		idx_t count = 0;
1526: 		for (; position < buffer_size; position++) {
1527: 			quote_search.Match(quote_pos, buffer[position]);
1528: 			delimiter_search.Match(delimiter_pos, buffer[position]);
1529: 			count++;
1530: 			if (count > delimiter_pos && count > quote_pos) {
1531: 				error_message = StringUtil::Format(
1532: 				    "Error in file \"%s\" on line %s: quote should be followed by end of value, end "
1533: 				    "of row or another quote. (%s)",
1534: 				    options.file_path, GetLineNumberStr(linenr, linenr_estimated).c_str(), options.ToString());
1535: 				return false;
1536: 			}
1537: 			if (delimiter_pos == options.delimiter.size()) {
1538: 				// quote followed by delimiter, add value
1539: 				offset = options.quote.size() + options.delimiter.size() - 1;
1540: 				goto add_value;
1541: 			} else if (quote_pos == options.quote.size() &&
1542: 			           (options.escape.empty() || options.escape == options.quote)) {
1543: 				// quote followed by quote, go back to quoted state and add to escape
1544: 				escape_positions.push_back(position - start - (options.quote.size() - 1));
1545: 				goto in_quotes;
1546: 			}
1547: 		}
1548: 	} while (ReadBuffer(start));
1549: 	error_message = StringUtil::Format(
1550: 	    "Error in file \"%s\" on line %s: quote should be followed by end of value, end of row or another quote. (%s)",
1551: 	    options.file_path, GetLineNumberStr(linenr, linenr_estimated).c_str(), options.ToString());
1552: 	return false;
1553: handle_escape:
1554: 	escape_pos = 0;
1555: 	quote_pos = 0;
1556: 	position++;
1557: 	do {
1558: 		idx_t count = 0;
1559: 		for (; position < buffer_size; position++) {
1560: 			quote_search.Match(quote_pos, buffer[position]);
1561: 			escape_search.Match(escape_pos, buffer[position]);
1562: 			count++;
1563: 			if (count > escape_pos && count > quote_pos) {
1564: 				error_message = StringUtil::Format(
1565: 				    "Error in file \"%s\" on line %s: neither QUOTE nor ESCAPE is proceeded by ESCAPE. (%s)",
1566: 				    options.file_path, GetLineNumberStr(linenr, linenr_estimated).c_str(), options.ToString());
1567: 				return false;
1568: 			}
1569: 			if (quote_pos == options.quote.size() || escape_pos == options.escape.size()) {
1570: 				// found quote or escape: move back to quoted state
1571: 				goto in_quotes;
1572: 			}
1573: 		}
1574: 	} while (ReadBuffer(start));
1575: 	error_message =
1576: 	    StringUtil::Format("Error in file \"%s\" on line %s: neither QUOTE nor ESCAPE is proceeded by ESCAPE. (%s)",
1577: 	                       options.file_path, GetLineNumberStr(linenr, linenr_estimated).c_str(), options.ToString());
1578: 	return false;
1579: carriage_return:
1580: 	/* state: carriage_return */
1581: 	// this stage optionally skips a newline (\n) character, which allows \r\n to be interpreted as a single line
1582: 	if (buffer[position] == '\n') {
1583: 		// newline after carriage return: skip
1584: 		start = ++position;
1585: 		if (position >= buffer_size && !ReadBuffer(start)) {
1586: 			// file ends right after newline, go to final state
1587: 			goto final_state;
1588: 		}
1589: 	}
1590: 	if (finished_chunk) {
1591: 		return true;
1592: 	}
1593: 	goto value_start;
1594: final_state:
1595: 	if (finished_chunk) {
1596: 		return true;
1597: 	}
1598: 	if (column > 0 || position > start) {
1599: 		// remaining values to be added to the chunk
1600: 		AddValue(buffer.get() + start, position - start - offset, column, escape_positions, has_quotes);
1601: 		finished_chunk = AddRow(insert_chunk, column);
1602: 	}
1603: 	// final stage, only reached after parsing the file is finished
1604: 	// flush the parsed chunk and finalize parsing
1605: 	if (mode == ParserMode::PARSING) {
1606: 		Flush(insert_chunk);
1607: 	}
1608: 
1609: 	end_of_file_reached = true;
1610: 	return true;
1611: }
1612: 
1613: bool BufferedCSVReader::TryParseSimpleCSV(DataChunk &insert_chunk, string &error_message) {
1614: 	// used for parsing algorithm
1615: 	bool finished_chunk = false;
1616: 	idx_t column = 0;
1617: 	idx_t offset = 0;
1618: 	bool has_quotes = false;
1619: 	vector<idx_t> escape_positions;
1620: 
1621: 	// read values into the buffer (if any)
1622: 	if (position >= buffer_size) {
1623: 		if (!ReadBuffer(start)) {
1624: 			return true;
1625: 		}
1626: 	}
1627: 	// start parsing the first value
1628: 	goto value_start;
1629: value_start:
1630: 	offset = 0;
1631: 	/* state: value_start */
1632: 	// this state parses the first character of a value
1633: 	if (buffer[position] == options.quote[0]) {
1634: 		// quote: actual value starts in the next position
1635: 		// move to in_quotes state
1636: 		start = position + 1;
1637: 		goto in_quotes;
1638: 	} else {
1639: 		// no quote, move to normal parsing state
1640: 		start = position;
1641: 		goto normal;
1642: 	}
1643: normal:
1644: 	/* state: normal parsing state */
1645: 	// this state parses the remainder of a non-quoted value until we reach a delimiter or newline
1646: 	do {
1647: 		for (; position < buffer_size; position++) {
1648: 			if (buffer[position] == options.delimiter[0]) {
1649: 				// delimiter: end the value and add it to the chunk
1650: 				goto add_value;
1651: 			} else if (StringUtil::CharacterIsNewline(buffer[position])) {
1652: 				// newline: add row
1653: 				goto add_row;
1654: 			}
1655: 		}
1656: 	} while (ReadBuffer(start));
1657: 	// file ends during normal scan: go to end state
1658: 	goto final_state;
1659: add_value:
1660: 	AddValue(buffer.get() + start, position - start - offset, column, escape_positions, has_quotes);
1661: 	// increase position by 1 and move start to the new position
1662: 	offset = 0;
1663: 	has_quotes = false;
1664: 	start = ++position;
1665: 	if (position >= buffer_size && !ReadBuffer(start)) {
1666: 		// file ends right after delimiter, go to final state
1667: 		goto final_state;
1668: 	}
1669: 	goto value_start;
1670: add_row : {
1671: 	// check type of newline (\r or \n)
1672: 	bool carriage_return = buffer[position] == '\r';
1673: 	AddValue(buffer.get() + start, position - start - offset, column, escape_positions, has_quotes);
1674: 	finished_chunk = AddRow(insert_chunk, column);
1675: 	// increase position by 1 and move start to the new position
1676: 	offset = 0;
1677: 	has_quotes = false;
1678: 	start = ++position;
1679: 	if (position >= buffer_size && !ReadBuffer(start)) {
1680: 		// file ends right after delimiter, go to final state
1681: 		goto final_state;
1682: 	}
1683: 	if (carriage_return) {
1684: 		// \r newline, go to special state that parses an optional \n afterwards
1685: 		goto carriage_return;
1686: 	} else {
1687: 		// \n newline, move to value start
1688: 		if (finished_chunk) {
1689: 			return true;
1690: 		}
1691: 		goto value_start;
1692: 	}
1693: }
1694: in_quotes:
1695: 	/* state: in_quotes */
1696: 	// this state parses the remainder of a quoted value
1697: 	has_quotes = true;
1698: 	position++;
1699: 	do {
1700: 		for (; position < buffer_size; position++) {
1701: 			if (buffer[position] == options.quote[0]) {
1702: 				// quote: move to unquoted state
1703: 				goto unquote;
1704: 			} else if (buffer[position] == options.escape[0]) {
1705: 				// escape: store the escaped position and move to handle_escape state
1706: 				escape_positions.push_back(position - start);
1707: 				goto handle_escape;
1708: 			}
1709: 		}
1710: 	} while (ReadBuffer(start));
1711: 	// still in quoted state at the end of the file, error:
1712: 	throw InvalidInputException("Error in file \"%s\" on line %s: unterminated quotes. (%s)", options.file_path,
1713: 	                            GetLineNumberStr(linenr, linenr_estimated).c_str(), options.ToString());
1714: unquote:
1715: 	/* state: unquote */
1716: 	// this state handles the state directly after we unquote
1717: 	// in this state we expect either another quote (entering the quoted state again, and escaping the quote)
1718: 	// or a delimiter/newline, ending the current value and moving on to the next value
1719: 	position++;
1720: 	if (position >= buffer_size && !ReadBuffer(start)) {
1721: 		// file ends right after unquote, go to final state
1722: 		offset = 1;
1723: 		goto final_state;
1724: 	}
1725: 	if (buffer[position] == options.quote[0] && (options.escape.empty() || options.escape[0] == options.quote[0])) {
1726: 		// escaped quote, return to quoted state and store escape position
1727: 		escape_positions.push_back(position - start);
1728: 		goto in_quotes;
1729: 	} else if (buffer[position] == options.delimiter[0]) {
1730: 		// delimiter, add value
1731: 		offset = 1;
1732: 		goto add_value;
1733: 	} else if (StringUtil::CharacterIsNewline(buffer[position])) {
1734: 		offset = 1;
1735: 		goto add_row;
1736: 	} else {
1737: 		error_message = StringUtil::Format(
1738: 		    "Error in file \"%s\" on line %s: quote should be followed by end of value, end of "
1739: 		    "row or another quote. (%s)",
1740: 		    options.file_path, GetLineNumberStr(linenr, linenr_estimated).c_str(), options.ToString());
1741: 		return false;
1742: 	}
1743: handle_escape:
1744: 	/* state: handle_escape */
1745: 	// escape should be followed by a quote or another escape character
1746: 	position++;
1747: 	if (position >= buffer_size && !ReadBuffer(start)) {
1748: 		error_message = StringUtil::Format(
1749: 		    "Error in file \"%s\" on line %s: neither QUOTE nor ESCAPE is proceeded by ESCAPE. (%s)", options.file_path,
1750: 		    GetLineNumberStr(linenr, linenr_estimated).c_str(), options.ToString());
1751: 		return false;
1752: 	}
1753: 	if (buffer[position] != options.quote[0] && buffer[position] != options.escape[0]) {
1754: 		error_message = StringUtil::Format(
1755: 		    "Error in file \"%s\" on line %s: neither QUOTE nor ESCAPE is proceeded by ESCAPE. (%s)", options.file_path,
1756: 		    GetLineNumberStr(linenr, linenr_estimated).c_str(), options.ToString());
1757: 		return false;
1758: 	}
1759: 	// escape was followed by quote or escape, go back to quoted state
1760: 	goto in_quotes;
1761: carriage_return:
1762: 	/* state: carriage_return */
1763: 	// this stage optionally skips a newline (\n) character, which allows \r\n to be interpreted as a single line
1764: 	if (buffer[position] == '\n') {
1765: 		// newline after carriage return: skip
1766: 		// increase position by 1 and move start to the new position
1767: 		start = ++position;
1768: 		if (position >= buffer_size && !ReadBuffer(start)) {
1769: 			// file ends right after delimiter, go to final state
1770: 			goto final_state;
1771: 		}
1772: 	}
1773: 	if (finished_chunk) {
1774: 		return true;
1775: 	}
1776: 	goto value_start;
1777: final_state:
1778: 	if (finished_chunk) {
1779: 		return true;
1780: 	}
1781: 
1782: 	if (column > 0 || position > start) {
1783: 		// remaining values to be added to the chunk
1784: 		AddValue(buffer.get() + start, position - start - offset, column, escape_positions, has_quotes);
1785: 		finished_chunk = AddRow(insert_chunk, column);
1786: 	}
1787: 
1788: 	// final stage, only reached after parsing the file is finished
1789: 	// flush the parsed chunk and finalize parsing
1790: 	if (mode == ParserMode::PARSING) {
1791: 		Flush(insert_chunk);
1792: 	}
1793: 
1794: 	end_of_file_reached = true;
1795: 	return true;
1796: }
1797: 
1798: bool BufferedCSVReader::ReadBuffer(idx_t &start) {
1799: 	auto old_buffer = move(buffer);
1800: 
1801: 	// the remaining part of the last buffer
1802: 	idx_t remaining = buffer_size - start;
1803: 
1804: 	bool large_buffers = mode == ParserMode::PARSING && !file_handle->OnDiskFile() && file_handle->CanSeek();
1805: 	idx_t buffer_read_size = large_buffers ? INITIAL_BUFFER_SIZE_LARGE : INITIAL_BUFFER_SIZE;
1806: 
1807: 	while (remaining > buffer_read_size) {
1808: 		buffer_read_size *= 2;
1809: 	}
1810: 
1811: 	// Check line length
1812: 	if (remaining > options.maximum_line_size) {
1813: 		throw InvalidInputException("Maximum line size of %llu bytes exceeded on line %s!", options.maximum_line_size,
1814: 		                            GetLineNumberStr(linenr, linenr_estimated));
1815: 	}
1816: 
1817: 	buffer = unique_ptr<char[]>(new char[buffer_read_size + remaining + 1]);
1818: 	buffer_size = remaining + buffer_read_size;
1819: 	if (remaining > 0) {
1820: 		// remaining from last buffer: copy it here
1821: 		memcpy(buffer.get(), old_buffer.get() + start, remaining);
1822: 	}
1823: 	idx_t read_count = file_handle->Read(buffer.get() + remaining, buffer_read_size);
1824: 
1825: 	bytes_in_chunk += read_count;
1826: 	buffer_size = remaining + read_count;
1827: 	buffer[buffer_size] = '\0';
1828: 	if (old_buffer) {
1829: 		cached_buffers.push_back(move(old_buffer));
1830: 	}
1831: 	start = 0;
1832: 	position = remaining;
1833: 	if (!bom_checked) {
1834: 		bom_checked = true;
1835: 		if (read_count >= 3 && buffer[0] == '\xEF' && buffer[1] == '\xBB' && buffer[2] == '\xBF') {
1836: 			position += 3;
1837: 		}
1838: 	}
1839: 
1840: 	return read_count > 0;
1841: }
1842: 
1843: void BufferedCSVReader::ParseCSV(DataChunk &insert_chunk) {
1844: 	// if no auto-detect or auto-detect with jumping samples, we have nothing cached and start from the beginning
1845: 	if (cached_chunks.empty()) {
1846: 		cached_buffers.clear();
1847: 	} else {
1848: 		auto &chunk = cached_chunks.front();
1849: 		parse_chunk.Move(*chunk);
1850: 		cached_chunks.pop();
1851: 		Flush(insert_chunk);
1852: 		return;
1853: 	}
1854: 
1855: 	string error_message;
1856: 	if (!TryParseCSV(ParserMode::PARSING, insert_chunk, error_message)) {
1857: 		throw InvalidInputException(error_message);
1858: 	}
1859: }
1860: 
1861: bool BufferedCSVReader::TryParseCSV(ParserMode mode) {
1862: 	DataChunk dummy_chunk;
1863: 	string error_message;
1864: 	return TryParseCSV(mode, dummy_chunk, error_message);
1865: }
1866: 
1867: void BufferedCSVReader::ParseCSV(ParserMode mode) {
1868: 	DataChunk dummy_chunk;
1869: 	string error_message;
1870: 	if (!TryParseCSV(mode, dummy_chunk, error_message)) {
1871: 		throw InvalidInputException(error_message);
1872: 	}
1873: }
1874: 
1875: bool BufferedCSVReader::TryParseCSV(ParserMode parser_mode, DataChunk &insert_chunk, string &error_message) {
1876: 	mode = parser_mode;
1877: 
1878: 	if (options.quote.size() <= 1 && options.escape.size() <= 1 && options.delimiter.size() == 1) {
1879: 		return TryParseSimpleCSV(insert_chunk, error_message);
1880: 	} else {
1881: 		return TryParseComplexCSV(insert_chunk, error_message);
1882: 	}
1883: }
1884: 
1885: void BufferedCSVReader::AddValue(char *str_val, idx_t length, idx_t &column, vector<idx_t> &escape_positions,
1886:                                  bool has_quotes) {
1887: 	if (length == 0 && column == 0) {
1888: 		row_empty = true;
1889: 	} else {
1890: 		row_empty = false;
1891: 	}
1892: 
1893: 	if (!sql_types.empty() && column == sql_types.size() && length == 0) {
1894: 		// skip a single trailing delimiter in last column
1895: 		return;
1896: 	}
1897: 	if (mode == ParserMode::SNIFFING_DIALECT) {
1898: 		column++;
1899: 		return;
1900: 	}
1901: 	if (column >= sql_types.size()) {
1902: 		if (options.ignore_errors) {
1903: 			error_column_overflow = true;
1904: 			return;
1905: 		} else {
1906: 			throw InvalidInputException("Error on line %s: expected %lld values per row, but got more. (%s)",
1907: 			                            GetLineNumberStr(linenr, linenr_estimated).c_str(), sql_types.size(),
1908: 			                            options.ToString());
1909: 		}
1910: 	}
1911: 
1912: 	// insert the line number into the chunk
1913: 	idx_t row_entry = parse_chunk.size();
1914: 
1915: 	str_val[length] = '\0';
1916: 
1917: 	// test against null string, but only if the value was not quoted
1918: 	if ((!has_quotes || sql_types[column].id() != LogicalTypeId::VARCHAR) && !options.force_not_null[column] &&
1919: 	    strcmp(options.null_str.c_str(), str_val) == 0) {
1920: 		FlatVector::SetNull(parse_chunk.data[column], row_entry, true);
1921: 	} else {
1922: 		auto &v = parse_chunk.data[column];
1923: 		auto parse_data = FlatVector::GetData<string_t>(v);
1924: 		if (!escape_positions.empty()) {
1925: 			// remove escape characters (if any)
1926: 			string old_val = str_val;
1927: 			string new_val = "";
1928: 			idx_t prev_pos = 0;
1929: 			for (idx_t i = 0; i < escape_positions.size(); i++) {
1930: 				idx_t next_pos = escape_positions[i];
1931: 				new_val += old_val.substr(prev_pos, next_pos - prev_pos);
1932: 
1933: 				if (options.escape.empty() || options.escape == options.quote) {
1934: 					prev_pos = next_pos + options.quote.size();
1935: 				} else {
1936: 					prev_pos = next_pos + options.escape.size();
1937: 				}
1938: 			}
1939: 			new_val += old_val.substr(prev_pos, old_val.size() - prev_pos);
1940: 			escape_positions.clear();
1941: 			parse_data[row_entry] = StringVector::AddStringOrBlob(v, string_t(new_val));
1942: 		} else {
1943: 			parse_data[row_entry] = string_t(str_val, length);
1944: 		}
1945: 	}
1946: 
1947: 	// move to the next column
1948: 	column++;
1949: }
1950: 
1951: bool BufferedCSVReader::AddRow(DataChunk &insert_chunk, idx_t &column) {
1952: 	linenr++;
1953: 
1954: 	if (row_empty) {
1955: 		row_empty = false;
1956: 		if (sql_types.size() != 1) {
1957: 			if (mode == ParserMode::PARSING) {
1958: 				FlatVector::SetNull(parse_chunk.data[0], parse_chunk.size(), false);
1959: 			}
1960: 			column = 0;
1961: 			return false;
1962: 		}
1963: 	}
1964: 
1965: 	// Error forwarded by 'ignore_errors' - originally encountered in 'AddValue'
1966: 	if (error_column_overflow) {
1967: 		D_ASSERT(options.ignore_errors);
1968: 		error_column_overflow = false;
1969: 		column = 0;
1970: 		return false;
1971: 	}
1972: 
1973: 	if (column < sql_types.size() && mode != ParserMode::SNIFFING_DIALECT) {
1974: 		if (options.ignore_errors) {
1975: 			column = 0;
1976: 			return false;
1977: 		} else {
1978: 			throw InvalidInputException("Error on line %s: expected %lld values per row, but got %d. (%s)",
1979: 			                            GetLineNumberStr(linenr, linenr_estimated).c_str(), sql_types.size(), column,
1980: 			                            options.ToString());
1981: 		}
1982: 	}
1983: 
1984: 	if (mode == ParserMode::SNIFFING_DIALECT) {
1985: 		sniffed_column_counts.push_back(column);
1986: 
1987: 		if (sniffed_column_counts.size() == options.sample_chunk_size) {
1988: 			return true;
1989: 		}
1990: 	} else {
1991: 		parse_chunk.SetCardinality(parse_chunk.size() + 1);
1992: 	}
1993: 
1994: 	if (mode == ParserMode::PARSING_HEADER) {
1995: 		return true;
1996: 	}
1997: 
1998: 	if (mode == ParserMode::SNIFFING_DATATYPES && parse_chunk.size() == options.sample_chunk_size) {
1999: 		return true;
2000: 	}
2001: 
2002: 	if (mode == ParserMode::PARSING && parse_chunk.size() == STANDARD_VECTOR_SIZE) {
2003: 		Flush(insert_chunk);
2004: 		return true;
2005: 	}
2006: 
2007: 	column = 0;
2008: 	return false;
2009: }
2010: 
2011: void BufferedCSVReader::SetNullUnionCols(DataChunk &insert_chunk) {
2012: 	for (idx_t col = 0; col < insert_nulls_idx.size(); ++col) {
2013: 		insert_chunk.data[insert_nulls_idx[col]].SetVectorType(VectorType::CONSTANT_VECTOR);
2014: 		ConstantVector::SetNull(insert_chunk.data[insert_nulls_idx[col]], true);
2015: 	}
2016: }
2017: 
2018: void BufferedCSVReader::Flush(DataChunk &insert_chunk) {
2019: 	if (parse_chunk.size() == 0) {
2020: 		return;
2021: 	}
2022: 
2023: 	bool conversion_error_ignored = false;
2024: 
2025: 	// convert the columns in the parsed chunk to the types of the table
2026: 	insert_chunk.SetCardinality(parse_chunk);
2027: 	for (idx_t col_idx = 0; col_idx < sql_types.size(); col_idx++) {
2028: 		if (sql_types[col_idx].id() == LogicalTypeId::VARCHAR) {
2029: 			// target type is varchar: no need to convert
2030: 			// just test that all strings are valid utf-8 strings
2031: 			auto parse_data = FlatVector::GetData<string_t>(parse_chunk.data[col_idx]);
2032: 			for (idx_t i = 0; i < parse_chunk.size(); i++) {
2033: 				if (!FlatVector::IsNull(parse_chunk.data[col_idx], i)) {
2034: 					auto s = parse_data[i];
2035: 					auto utf_type = Utf8Proc::Analyze(s.GetDataUnsafe(), s.GetSize());
2036: 					if (utf_type == UnicodeType::INVALID) {
2037: 						string col_name = to_string(col_idx);
2038: 						if (col_idx < col_names.size()) {
2039: 							col_name = "\"" + col_names[col_idx] + "\"";
2040: 						}
2041: 						throw InvalidInputException("Error in file \"%s\" between line %llu and %llu in column \"%s\": "
2042: 						                            "file is not valid UTF8. Parser options: %s",
2043: 						                            options.file_path, linenr - parse_chunk.size(), linenr, col_name,
2044: 						                            options.ToString());
2045: 					}
2046: 				}
2047: 			}
2048: 			insert_chunk.data[insert_cols_idx[col_idx]].Reference(parse_chunk.data[col_idx]);
2049: 		} else {
2050: 			string error_message;
2051: 			bool success;
2052: 			if (options.has_format[LogicalTypeId::DATE] && sql_types[col_idx].id() == LogicalTypeId::DATE) {
2053: 				// use the date format to cast the chunk
2054: 				success =
2055: 				    TryCastDateVector(options, parse_chunk.data[col_idx], insert_chunk.data[insert_cols_idx[col_idx]],
2056: 				                      parse_chunk.size(), error_message);
2057: 			} else if (options.has_format[LogicalTypeId::TIMESTAMP] &&
2058: 			           sql_types[col_idx].id() == LogicalTypeId::TIMESTAMP) {
2059: 				// use the date format to cast the chunk
2060: 				success = TryCastTimestampVector(options, parse_chunk.data[col_idx],
2061: 				                                 insert_chunk.data[insert_cols_idx[col_idx]], parse_chunk.size(),
2062: 				                                 error_message);
2063: 			} else {
2064: 				// target type is not varchar: perform a cast
2065: 				success = VectorOperations::DefaultTryCast(parse_chunk.data[col_idx],
2066: 				                                           insert_chunk.data[insert_cols_idx[col_idx]],
2067: 				                                           parse_chunk.size(), &error_message);
2068: 			}
2069: 			if (success) {
2070: 				continue;
2071: 			}
2072: 			if (options.ignore_errors) {
2073: 				conversion_error_ignored = true;
2074: 				continue;
2075: 			}
2076: 			string col_name = to_string(col_idx);
2077: 			if (col_idx < col_names.size()) {
2078: 				col_name = "\"" + col_names[col_idx] + "\"";
2079: 			}
2080: 
2081: 			if (options.auto_detect) {
2082: 				throw InvalidInputException("%s in column %s, between line %llu and %llu. Parser "
2083: 				                            "options: %s. Consider either increasing the sample size "
2084: 				                            "(SAMPLE_SIZE=X [X rows] or SAMPLE_SIZE=-1 [all rows]), "
2085: 				                            "or skipping column conversion (ALL_VARCHAR=1)",
2086: 				                            error_message, col_name, linenr - parse_chunk.size() + 1, linenr,
2087: 				                            options.ToString());
2088: 			} else {
2089: 				throw InvalidInputException("%s between line %llu and %llu in column %s. Parser options: %s ",
2090: 				                            error_message, linenr - parse_chunk.size(), linenr, col_name,
2091: 				                            options.ToString());
2092: 			}
2093: 		}
2094: 	}
2095: 	if (conversion_error_ignored) {
2096: 		D_ASSERT(options.ignore_errors);
2097: 		SelectionVector succesful_rows;
2098: 		succesful_rows.Initialize(parse_chunk.size());
2099: 		idx_t sel_size = 0;
2100: 
2101: 		for (idx_t row_idx = 0; row_idx < parse_chunk.size(); row_idx++) {
2102: 			bool failed = false;
2103: 			for (idx_t column_idx = 0; column_idx < sql_types.size(); column_idx++) {
2104: 
2105: 				auto &inserted_column = insert_chunk.data[column_idx];
2106: 				auto &parsed_column = parse_chunk.data[column_idx];
2107: 
2108: 				bool was_already_null = FlatVector::IsNull(parsed_column, row_idx);
2109: 				if (!was_already_null && FlatVector::IsNull(inserted_column, row_idx)) {
2110: 					failed = true;
2111: 					break;
2112: 				}
2113: 			}
2114: 			if (!failed) {
2115: 				succesful_rows.set_index(sel_size++, row_idx);
2116: 			}
2117: 		}
2118: 		insert_chunk.Slice(succesful_rows, sel_size);
2119: 	}
2120: 	parse_chunk.Reset();
2121: }
2122: } // namespace duckdb
[end of src/execution/operator/persistent/buffered_csv_reader.cpp]
[start of src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/execution/operator/persistent/buffered_csv_reader.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/execution/physical_operator.hpp"
12: #include "duckdb/parser/parsed_data/copy_info.hpp"
13: #include "duckdb/function/scalar/strftime.hpp"
14: #include "duckdb/common/types/chunk_collection.hpp"
15: #include "duckdb/common/enums/file_compression_type.hpp"
16: #include "duckdb/common/map.hpp"
17: #include "duckdb/common/queue.hpp"
18: 
19: #include <sstream>
20: 
21: namespace duckdb {
22: struct CopyInfo;
23: struct CSVFileHandle;
24: struct FileHandle;
25: struct StrpTimeFormat;
26: 
27: class FileOpener;
28: class FileSystem;
29: 
30: //! The shifts array allows for linear searching of multi-byte values. For each position, it determines the next
31: //! position given that we encounter a byte with the given value.
32: /*! For example, if we have a string "ABAC", the shifts array will have the following values:
33:  *  [0] --> ['A'] = 1, all others = 0
34:  *  [1] --> ['B'] = 2, ['A'] = 1, all others = 0
35:  *  [2] --> ['A'] = 3, all others = 0
36:  *  [3] --> ['C'] = 4 (match), 'B' = 2, 'A' = 1, all others = 0
37:  * Suppose we then search in the following string "ABABAC", our progression will be as follows:
38:  * 'A' -> [1], 'B' -> [2], 'A' -> [3], 'B' -> [2], 'A' -> [3], 'C' -> [4] (match!)
39:  */
40: struct TextSearchShiftArray {
41: 	TextSearchShiftArray();
42: 	explicit TextSearchShiftArray(string search_term);
43: 
44: 	inline bool Match(uint8_t &position, uint8_t byte_value) {
45: 		if (position >= length) {
46: 			return false;
47: 		}
48: 		position = shifts[position * 255 + byte_value];
49: 		return position == length;
50: 	}
51: 
52: 	idx_t length;
53: 	unique_ptr<uint8_t[]> shifts;
54: };
55: 
56: struct BufferedCSVReaderOptions {
57: 	//===--------------------------------------------------------------------===//
58: 	// CommonCSVOptions
59: 	//===--------------------------------------------------------------------===//
60: 
61: 	//! Whether or not a delimiter was defined by the user
62: 	bool has_delimiter = false;
63: 	//! Delimiter to separate columns within each line
64: 	string delimiter = ",";
65: 	//! Whether or not a quote sign was defined by the user
66: 	bool has_quote = false;
67: 	//! Quote used for columns that contain reserved characters, e.g., delimiter
68: 	string quote = "\"";
69: 	//! Whether or not an escape character was defined by the user
70: 	bool has_escape = false;
71: 	//! Escape character to escape quote character
72: 	string escape;
73: 	//! Whether or not a header information was given by the user
74: 	bool has_header = false;
75: 	//! Whether or not the file has a header line
76: 	bool header = false;
77: 	//! Whether or not we should ignore InvalidInput errors
78: 	bool ignore_errors = false;
79: 	//! Expected number of columns
80: 	idx_t num_cols = 0;
81: 	//! Number of samples to buffer
82: 	idx_t buffer_size = STANDARD_VECTOR_SIZE * 100;
83: 	//! Specifies the string that represents a null value
84: 	string null_str;
85: 	//! Whether file is compressed or not, and if so which compression type
86: 	//! AUTO_DETECT (default; infer from file extension)
87: 	FileCompressionType compression = FileCompressionType::AUTO_DETECT;
88: 	//! The column names of the columns to read/write
89: 	vector<string> names;
90: 
91: 	//===--------------------------------------------------------------------===//
92: 	// ReadCSVOptions
93: 	//===--------------------------------------------------------------------===//
94: 
95: 	//! How many leading rows to skip
96: 	idx_t skip_rows = 0;
97: 	//! Maximum CSV line size: specified because if we reach this amount, we likely have wrong delimiters (default: 2MB)
98: 	//! note that this is the guaranteed line length that will succeed, longer lines may be accepted if slightly above
99: 	idx_t maximum_line_size = 2097152;
100: 	//! Whether or not header names shall be normalized
101: 	bool normalize_names = false;
102: 	//! True, if column with that index must skip null check
103: 	vector<bool> force_not_null;
104: 	//! Consider all columns to be of type varchar
105: 	bool all_varchar = false;
106: 	//! Size of sample chunk used for dialect and type detection
107: 	idx_t sample_chunk_size = STANDARD_VECTOR_SIZE;
108: 	//! Number of sample chunks used for type detection
109: 	idx_t sample_chunks = 10;
110: 	//! Whether or not to automatically detect dialect and datatypes
111: 	bool auto_detect = false;
112: 	//! The file path of the CSV file to read
113: 	string file_path;
114: 	//! Whether or not to include a file name column
115: 	bool include_file_name = false;
116: 	//! Whether or not to include a parsed hive partition columns
117: 	bool include_parsed_hive_partitions = false;
118: 	//! Whether or not to union files with different (but compatible) columns
119: 	bool union_by_name = false;
120: 
121: 	//===--------------------------------------------------------------------===//
122: 	// WriteCSVOptions
123: 	//===--------------------------------------------------------------------===//
124: 
125: 	//! True, if column with that index must be quoted
126: 	vector<bool> force_quote;
127: 
128: 	//! The date format to use (if any is specified)
129: 	std::map<LogicalTypeId, StrpTimeFormat> date_format = {{LogicalTypeId::DATE, {}}, {LogicalTypeId::TIMESTAMP, {}}};
130: 	//! The date format to use for writing (if any is specified)
131: 	std::map<LogicalTypeId, StrfTimeFormat> write_date_format = {{LogicalTypeId::DATE, {}},
132: 	                                                             {LogicalTypeId::TIMESTAMP, {}}};
133: 	//! Whether or not a type format is specified
134: 	std::map<LogicalTypeId, bool> has_format = {{LogicalTypeId::DATE, false}, {LogicalTypeId::TIMESTAMP, false}};
135: 
136: 	void Serialize(FieldWriter &writer) const;
137: 	void Deserialize(FieldReader &reader);
138: 
139: 	void SetDelimiter(const string &delimiter);
140: 	//! Set an option that is supported by both reading and writing functions, called by
141: 	//! the SetReadOption and SetWriteOption methods
142: 	bool SetBaseOption(const string &loption, const Value &value);
143: 
144: 	//! loption - lowercase string
145: 	//! set - argument(s) to the option
146: 	//! expected_names - names expected if the option is "columns"
147: 	void SetReadOption(const string &loption, const Value &value, vector<string> &expected_names);
148: 
149: 	void SetWriteOption(const string &loption, const Value &value);
150: 	void SetDateFormat(LogicalTypeId type, const string &format, bool read_format);
151: 
152: 	std::string ToString() const;
153: };
154: 
155: enum class ParserMode : uint8_t { PARSING = 0, SNIFFING_DIALECT = 1, SNIFFING_DATATYPES = 2, PARSING_HEADER = 3 };
156: 
157: //! Buffered CSV reader is a class that reads values from a stream and parses them as a CSV file
158: class BufferedCSVReader {
159: 	//! Initial buffer read size; can be extended for long lines
160: 	static constexpr idx_t INITIAL_BUFFER_SIZE = 16384;
161: 	//! Larger buffer size for non disk files
162: 	static constexpr idx_t INITIAL_BUFFER_SIZE_LARGE = 10000000; // 10MB
163: 	ParserMode mode;
164: 
165: public:
166: 	BufferedCSVReader(ClientContext &context, BufferedCSVReaderOptions options,
167: 	                  const vector<LogicalType> &requested_types = vector<LogicalType>());
168: 
169: 	BufferedCSVReader(FileSystem &fs, Allocator &allocator, FileOpener *opener, BufferedCSVReaderOptions options,
170: 	                  const vector<LogicalType> &requested_types = vector<LogicalType>());
171: 	~BufferedCSVReader();
172: 
173: 	FileSystem &fs;
174: 	Allocator &allocator;
175: 	FileOpener *opener;
176: 	BufferedCSVReaderOptions options;
177: 	vector<LogicalType> sql_types;
178: 	vector<string> col_names;
179: 
180: 	//! remap parse_chunk col to insert_chunk col, because when
181: 	//! union_by_name option on insert_chunk may have more cols
182: 	vector<idx_t> insert_cols_idx;
183: 	vector<idx_t> insert_nulls_idx;
184: 
185: 	unique_ptr<CSVFileHandle> file_handle;
186: 
187: 	unique_ptr<char[]> buffer;
188: 	idx_t buffer_size;
189: 	idx_t position;
190: 	idx_t start = 0;
191: 
192: 	idx_t linenr = 0;
193: 	bool linenr_estimated = false;
194: 
195: 	vector<idx_t> sniffed_column_counts;
196: 	bool row_empty = false;
197: 	idx_t sample_chunk_idx = 0;
198: 	bool jumping_samples = false;
199: 	bool end_of_file_reached = false;
200: 	bool bom_checked = false;
201: 
202: 	idx_t bytes_in_chunk = 0;
203: 	double bytes_per_line_avg = 0;
204: 
205: 	vector<unique_ptr<char[]>> cached_buffers;
206: 
207: 	TextSearchShiftArray delimiter_search, escape_search, quote_search;
208: 
209: 	DataChunk parse_chunk;
210: 
211: 	std::queue<unique_ptr<DataChunk>> cached_chunks;
212: 
213: public:
214: 	//! Extract a single DataChunk from the CSV file and stores it in insert_chunk
215: 	void ParseCSV(DataChunk &insert_chunk);
216: 
217: 	idx_t GetFileSize();
218: 
219: 	//! Fill nulls into the cols that mismtach union names
220: 	void SetNullUnionCols(DataChunk &insert_chunk);
221: 
222: private:
223: 	//! Initialize Parser
224: 	void Initialize(const vector<LogicalType> &requested_types);
225: 	//! Initializes the parse_chunk with varchar columns and aligns info with new number of cols
226: 	void InitParseChunk(idx_t num_cols);
227: 	//! Initializes the insert_chunk idx for mapping parse_chunk cols to insert_chunk cols
228: 	void InitInsertChunkIdx(idx_t num_cols);
229: 	//! Initializes the TextSearchShiftArrays for complex parser
230: 	void PrepareComplexParser();
231: 	//! Try to parse a single datachunk from the file. Throws an exception if anything goes wrong.
232: 	void ParseCSV(ParserMode mode);
233: 	//! Try to parse a single datachunk from the file. Returns whether or not the parsing is successful
234: 	bool TryParseCSV(ParserMode mode);
235: 	//! Extract a single DataChunk from the CSV file and stores it in insert_chunk
236: 	bool TryParseCSV(ParserMode mode, DataChunk &insert_chunk, string &error_message);
237: 	//! Sniffs CSV dialect and determines skip rows, header row, column types and column names
238: 	vector<LogicalType> SniffCSV(const vector<LogicalType> &requested_types);
239: 	//! Change the date format for the type to the string
240: 	void SetDateFormat(const string &format_specifier, const LogicalTypeId &sql_type);
241: 	//! Try to cast a string value to the specified sql type
242: 	bool TryCastValue(const Value &value, const LogicalType &sql_type);
243: 	//! Try to cast a vector of values to the specified sql type
244: 	bool TryCastVector(Vector &parse_chunk_col, idx_t size, const LogicalType &sql_type);
245: 	//! Skips skip_rows, reads header row from input stream
246: 	void SkipRowsAndReadHeader(idx_t skip_rows, bool skip_header);
247: 	//! Jumps back to the beginning of input stream and resets necessary internal states
248: 	void JumpToBeginning(idx_t skip_rows, bool skip_header);
249: 	//! Jumps back to the beginning of input stream and resets necessary internal states
250: 	bool JumpToNextSample();
251: 	//! Resets the buffer
252: 	void ResetBuffer();
253: 	//! Resets the steam
254: 	void ResetStream();
255: 
256: 	//! Parses a CSV file with a one-byte delimiter, escape and quote character
257: 	bool TryParseSimpleCSV(DataChunk &insert_chunk, string &error_message);
258: 	//! Parses more complex CSV files with multi-byte delimiters, escapes or quotes
259: 	bool TryParseComplexCSV(DataChunk &insert_chunk, string &error_message);
260: 
261: 	//! Adds a value to the current row
262: 	void AddValue(char *str_val, idx_t length, idx_t &column, vector<idx_t> &escape_positions, bool has_quotes);
263: 	//! Adds a row to the insert_chunk, returns true if the chunk is filled as a result of this row being added
264: 	bool AddRow(DataChunk &insert_chunk, idx_t &column);
265: 	//! Finalizes a chunk, parsing all values that have been added so far and adding them to the insert_chunk
266: 	void Flush(DataChunk &insert_chunk);
267: 	//! Reads a new buffer from the CSV file if the current one has been exhausted
268: 	bool ReadBuffer(idx_t &start);
269: 
270: 	unique_ptr<CSVFileHandle> OpenCSV(const BufferedCSVReaderOptions &options);
271: 
272: 	//! First phase of auto detection: detect CSV dialect (i.e. delimiter, quote rules, etc)
273: 	void DetectDialect(const vector<LogicalType> &requested_types, BufferedCSVReaderOptions &original_options,
274: 	                   vector<BufferedCSVReaderOptions> &info_candidates, idx_t &best_num_cols);
275: 	//! Second phase of auto detection: detect candidate types for each column
276: 	void DetectCandidateTypes(const vector<LogicalType> &type_candidates,
277: 	                          const map<LogicalTypeId, vector<const char *>> &format_template_candidates,
278: 	                          const vector<BufferedCSVReaderOptions> &info_candidates,
279: 	                          BufferedCSVReaderOptions &original_options, idx_t best_num_cols,
280: 	                          vector<vector<LogicalType>> &best_sql_types_candidates,
281: 	                          std::map<LogicalTypeId, vector<string>> &best_format_candidates,
282: 	                          DataChunk &best_header_row);
283: 	//! Third phase of auto detection: detect header of CSV file
284: 	void DetectHeader(const vector<vector<LogicalType>> &best_sql_types_candidates, const DataChunk &best_header_row);
285: 	//! Fourth phase of auto detection: refine the types of each column and select which types to use for each column
286: 	vector<LogicalType> RefineTypeDetection(const vector<LogicalType> &type_candidates,
287: 	                                        const vector<LogicalType> &requested_types,
288: 	                                        vector<vector<LogicalType>> &best_sql_types_candidates,
289: 	                                        map<LogicalTypeId, vector<string>> &best_format_candidates);
290: 
291: private:
292: 	//! Whether or not the current row's columns have overflown sql_types.size()
293: 	bool error_column_overflow = false;
294: };
295: 
296: } // namespace duckdb
[end of src/include/duckdb/execution/operator/persistent/buffered_csv_reader.hpp]
[start of src/include/duckdb/main/config.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/config.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/allocator.hpp"
12: #include "duckdb/common/case_insensitive_map.hpp"
13: #include "duckdb/common/common.hpp"
14: #include "duckdb/common/enums/order_type.hpp"
15: #include "duckdb/common/file_system.hpp"
16: #include "duckdb/common/winapi.hpp"
17: #include "duckdb/common/types/value.hpp"
18: #include "duckdb/common/vector.hpp"
19: #include "duckdb/function/replacement_scan.hpp"
20: #include "duckdb/function/replacement_open.hpp"
21: #include "duckdb/common/set.hpp"
22: #include "duckdb/common/enums/compression_type.hpp"
23: #include "duckdb/common/enums/optimizer_type.hpp"
24: #include "duckdb/common/enums/window_aggregation_mode.hpp"
25: #include "duckdb/common/enums/set_scope.hpp"
26: #include "duckdb/parser/parser_extension.hpp"
27: #include "duckdb/function/cast/default_casts.hpp"
28: #include "duckdb/optimizer/optimizer_extension.hpp"
29: 
30: namespace duckdb {
31: class CastFunctionSet;
32: class ClientContext;
33: class CompressionFunction;
34: class TableFunctionRef;
35: 
36: struct CompressionFunctionSet;
37: struct DBConfig;
38: 
39: enum class AccessMode : uint8_t { UNDEFINED = 0, AUTOMATIC = 1, READ_ONLY = 2, READ_WRITE = 3 };
40: 
41: enum class CheckpointAbort : uint8_t {
42: 	NO_ABORT = 0,
43: 	DEBUG_ABORT_BEFORE_TRUNCATE = 1,
44: 	DEBUG_ABORT_BEFORE_HEADER = 2,
45: 	DEBUG_ABORT_AFTER_FREE_LIST_WRITE = 3
46: };
47: 
48: typedef void (*set_global_function_t)(DatabaseInstance *db, DBConfig &config, const Value &parameter);
49: typedef void (*set_local_function_t)(ClientContext &context, const Value &parameter);
50: typedef Value (*get_setting_function_t)(ClientContext &context);
51: 
52: struct ConfigurationOption {
53: 	const char *name;
54: 	const char *description;
55: 	LogicalTypeId parameter_type;
56: 	set_global_function_t set_global;
57: 	set_local_function_t set_local;
58: 	get_setting_function_t get_setting;
59: };
60: 
61: typedef void (*set_option_callback_t)(ClientContext &context, SetScope scope, Value &parameter);
62: 
63: struct ExtensionOption {
64: 	ExtensionOption(string description_p, LogicalType type_p, set_option_callback_t set_function_p)
65: 	    : description(move(description_p)), type(move(type_p)), set_function(set_function_p) {
66: 	}
67: 
68: 	string description;
69: 	LogicalType type;
70: 	set_option_callback_t set_function;
71: };
72: 
73: struct DBConfigOptions {
74: 	//! Database file path. May be empty for in-memory mode
75: 	string database_path;
76: 	//! Access mode of the database (AUTOMATIC, READ_ONLY or READ_WRITE)
77: 	AccessMode access_mode = AccessMode::AUTOMATIC;
78: 	//! Checkpoint when WAL reaches this size (default: 16MB)
79: 	idx_t checkpoint_wal_size = 1 << 24;
80: 	//! Whether or not to use Direct IO, bypassing operating system buffers
81: 	bool use_direct_io = false;
82: 	//! Whether extensions should be loaded on start-up
83: 	bool load_extensions = true;
84: 	//! The maximum memory used by the database system (in bytes). Default: 80% of System available memory
85: 	idx_t maximum_memory = (idx_t)-1;
86: 	//! The maximum amount of CPU threads used by the database system. Default: all available.
87: 	idx_t maximum_threads = (idx_t)-1;
88: 	//! The number of external threads that work on DuckDB tasks. Default: none.
89: 	idx_t external_threads = 0;
90: 	//! Whether or not to create and use a temporary directory to store intermediates that do not fit in memory
91: 	bool use_temporary_directory = true;
92: 	//! Directory to store temporary structures that do not fit in memory
93: 	string temporary_directory;
94: 	//! The collation type of the database
95: 	string collation = string();
96: 	//! The order type used when none is specified (default: ASC)
97: 	OrderType default_order_type = OrderType::ASCENDING;
98: 	//! Null ordering used when none is specified (default: NULLS FIRST)
99: 	OrderByNullType default_null_order = OrderByNullType::NULLS_FIRST;
100: 	//! enable COPY and related commands
101: 	bool enable_external_access = true;
102: 	//! Whether or not object cache is used
103: 	bool object_cache_enable = false;
104: 	//! Force checkpoint when CHECKPOINT is called or on shutdown, even if no changes have been made
105: 	bool force_checkpoint = false;
106: 	//! Run a checkpoint on successful shutdown and delete the WAL, to leave only a single database file behind
107: 	bool checkpoint_on_shutdown = true;
108: 	//! Debug flag that decides when a checkpoing should be aborted. Only used for testing purposes.
109: 	CheckpointAbort checkpoint_abort = CheckpointAbort::NO_ABORT;
110: 	//! Initialize the database with the standard set of DuckDB functions
111: 	//! You should probably not touch this unless you know what you are doing
112: 	bool initialize_default_database = true;
113: 	//! The set of disabled optimizers (default empty)
114: 	set<OptimizerType> disabled_optimizers;
115: 	//! Force a specific compression method to be used when checkpointing (if available)
116: 	CompressionType force_compression = CompressionType::COMPRESSION_AUTO;
117: 	//! Debug flag that adds additional (unnecessary) free_list blocks to the storage
118: 	bool debug_many_free_list_blocks = false;
119: 	//! Debug setting for window aggregation mode: (window, combine, separate)
120: 	WindowAggregationMode window_mode = WindowAggregationMode::WINDOW;
121: 	//! Whether or not preserving insertion order should be preserved
122: 	bool preserve_insertion_order = true;
123: 	//! Database configuration variables as controlled by SET
124: 	case_insensitive_map_t<Value> set_variables;
125: 	//! Whether unsigned extensions should be loaded
126: 	bool allow_unsigned_extensions = false;
127: 	//! Enable emitting FSST Vectors
128: 	bool enable_fsst_vectors = false;
129: 
130: 	bool operator==(const DBConfigOptions &other) const;
131: };
132: 
133: struct DBConfig {
134: 	friend class DatabaseInstance;
135: 	friend class StorageManager;
136: 
137: public:
138: 	DUCKDB_API DBConfig();
139: 	DUCKDB_API DBConfig(std::unordered_map<string, string> &config_dict, bool read_only);
140: 	DUCKDB_API ~DBConfig();
141: 
142: 	//! Replacement table scans are automatically attempted when a table name cannot be found in the schema
143: 	vector<ReplacementScan> replacement_scans;
144: 
145: 	//! Replacement open handlers are callbacks that run pre and post database initialization
146: 	vector<ReplacementOpen> replacement_opens;
147: 
148: 	//! Extra parameters that can be SET for loaded extensions
149: 	case_insensitive_map_t<ExtensionOption> extension_parameters;
150: 	//! The FileSystem to use, can be overwritten to allow for injecting custom file systems for testing purposes (e.g.
151: 	//! RamFS or something similar)
152: 	unique_ptr<FileSystem> file_system;
153: 	//! The allocator used by the system
154: 	unique_ptr<Allocator> allocator;
155: 	//! Database configuration options
156: 	DBConfigOptions options;
157: 	//! Extensions made to the parser
158: 	vector<ParserExtension> parser_extensions;
159: 	//! Extensions made to the optimizer
160: 	vector<OptimizerExtension> optimizer_extensions;
161: 
162: 	DUCKDB_API void AddExtensionOption(string name, string description, LogicalType parameter,
163: 	                                   set_option_callback_t function = nullptr);
164: 
165: public:
166: 	DUCKDB_API static DBConfig &GetConfig(ClientContext &context);
167: 	DUCKDB_API static DBConfig &GetConfig(DatabaseInstance &db);
168: 	DUCKDB_API static const DBConfig &GetConfig(const ClientContext &context);
169: 	DUCKDB_API static const DBConfig &GetConfig(const DatabaseInstance &db);
170: 	DUCKDB_API static vector<ConfigurationOption> GetOptions();
171: 	DUCKDB_API static idx_t GetOptionCount();
172: 	DUCKDB_API static vector<string> GetOptionNames();
173: 
174: 	//! Fetch an option by index. Returns a pointer to the option, or nullptr if out of range
175: 	DUCKDB_API static ConfigurationOption *GetOptionByIndex(idx_t index);
176: 	//! Fetch an option by name. Returns a pointer to the option, or nullptr if none exists.
177: 	DUCKDB_API static ConfigurationOption *GetOptionByName(const string &name);
178: 
179: 	DUCKDB_API void SetOption(const ConfigurationOption &option, const Value &value);
180: 
181: 	DUCKDB_API static idx_t ParseMemoryLimit(const string &arg);
182: 
183: 	//! Return the list of possible compression functions for the specific physical type
184: 	DUCKDB_API vector<CompressionFunction *> GetCompressionFunctions(PhysicalType data_type);
185: 	//! Return the compression function for the specified compression type/physical type combo
186: 	DUCKDB_API CompressionFunction *GetCompressionFunction(CompressionType type, PhysicalType data_type);
187: 
188: 	bool operator==(const DBConfig &other);
189: 	bool operator!=(const DBConfig &other);
190: 
191: 	DUCKDB_API CastFunctionSet &GetCastFunctions();
192: 
193: private:
194: 	unique_ptr<CompressionFunctionSet> compression_functions;
195: 	unique_ptr<CastFunctionSet> cast_functions;
196: };
197: 
198: } // namespace duckdb
[end of src/include/duckdb/main/config.hpp]
[start of src/include/extension_functions.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // extension_functions.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/unordered_map.hpp"
12: 
13: namespace duckdb {
14: 
15: struct ExtensionFunction {
16: 	char function[48];
17: 	char extension[48];
18: };
19: 
20: static constexpr ExtensionFunction EXTENSION_FUNCTIONS[] = {
21:     {"->>", "json"},
22:     {"array_to_json", "json"},
23:     {"create_fts_index", "fts"},
24:     {"dbgen", "tpch"},
25:     {"drop_fts_index", "fts"},
26:     {"dsdgen", "tpcds"},
27:     {"excel_text", "excel"},
28:     {"from_json", "json"},
29:     {"from_json_strict", "json"},
30:     {"from_substrait", "substrait"},
31:     {"get_substrait", "substrait"},
32:     {"get_substrait_json", "substrait"},
33:     {"icu_calendar_names", "icu"},
34:     {"icu_sort_key", "icu"},
35:     {"json", "json"},
36:     {"json_array", "json"},
37:     {"json_array_length", "json"},
38:     {"json_contains", "json"},
39:     {"json_extract", "json"},
40:     {"json_extract_path", "json"},
41:     {"json_extract_path_text", "json"},
42:     {"json_extract_string", "json"},
43:     {"json_group_array", "json"},
44:     {"json_group_object", "json"},
45:     {"json_group_structure", "json"},
46:     {"json_merge_patch", "json"},
47:     {"json_object", "json"},
48:     {"json_quote", "json"},
49:     {"json_structure", "json"},
50:     {"json_transform", "json"},
51:     {"json_transform_strict", "json"},
52:     {"json_type", "json"},
53:     {"json_valid", "json"},
54:     {"make_timestamptz", "icu"},
55:     {"parquet_metadata", "parquet"},
56:     {"parquet_scan", "parquet"},
57:     {"parquet_schema", "parquet"},
58:     {"pg_timezone_names", "icu"},
59:     {"postgres_attach", "postgres_scanner"},
60:     {"postgres_scan", "postgres_scanner"},
61:     {"postgres_scan_pushdown", "postgres_scanner"},
62:     {"read_json_objects", "json"},
63:     {"read_ndjson_objects", "json"},
64:     {"read_parquet", "parquet"},
65:     {"row_to_json", "json"},
66:     {"sqlite_attach", "sqlite_scanner"},
67:     {"sqlite_scan", "sqlite_scanner"},
68:     {"stem", "fts"},
69:     {"text", "excel"},
70:     {"to_json", "json"},
71:     {"tpcds", "tpcds"},
72:     {"tpcds_answers", "tpcds"},
73:     {"tpcds_queries", "tpcds"},
74:     {"tpch", "tpch"},
75:     {"tpch_answers", "tpch"},
76:     {"tpch_queries", "tpch"},
77:     {"visualize_diff_profiling_output", "visualizer"},
78:     {"visualize_json_profiling_output", "visualizer"},
79:     {"visualize_last_profiling_output", "visualizer"},
80: };
81: } // namespace duckdb
[end of src/include/extension_functions.hpp]
[start of src/include/duckdb/main/settings.hpp]
1: //===----------------------------------------------------------------------===//
2: //                         DuckDB
3: //
4: // duckdb/main/settings.hpp
5: //
6: //
7: //===----------------------------------------------------------------------===//
8: 
9: #pragma once
10: 
11: #include "duckdb/common/common.hpp"
12: #include "duckdb/common/types/value.hpp"
13: 
14: namespace duckdb {
15: class ClientContext;
16: class DatabaseInstance;
17: struct DBConfig;
18: 
19: struct AccessModeSetting {
20: 	static constexpr const char *Name = "access_mode";
21: 	static constexpr const char *Description = "Access mode of the database (AUTOMATIC, READ_ONLY or READ_WRITE)";
22: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
23: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
24: 	static Value GetSetting(ClientContext &context);
25: };
26: 
27: struct CheckpointThresholdSetting {
28: 	static constexpr const char *Name = "checkpoint_threshold";
29: 	static constexpr const char *Description =
30: 	    "The WAL size threshold at which to automatically trigger a checkpoint (e.g. 1GB)";
31: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
32: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
33: 	static Value GetSetting(ClientContext &context);
34: };
35: 
36: struct DebugCheckpointAbort {
37: 	static constexpr const char *Name = "debug_checkpoint_abort";
38: 	static constexpr const char *Description =
39: 	    "DEBUG SETTING: trigger an abort while checkpointing for testing purposes";
40: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
41: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
42: 	static Value GetSetting(ClientContext &context);
43: };
44: 
45: struct DebugForceExternal {
46: 	static constexpr const char *Name = "debug_force_external";
47: 	static constexpr const char *Description =
48: 	    "DEBUG SETTING: force out-of-core computation for operators that support it, used for testing";
49: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
50: 	static void SetLocal(ClientContext &context, const Value &parameter);
51: 	static Value GetSetting(ClientContext &context);
52: };
53: 
54: struct DebugForceNoCrossProduct {
55: 	static constexpr const char *Name = "debug_force_no_cross_product";
56: 	static constexpr const char *Description =
57: 	    "DEBUG SETTING: Force disable cross product generation when hyper graph isn't connected, used for testing";
58: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
59: 	static void SetLocal(ClientContext &context, const Value &parameter);
60: 	static Value GetSetting(ClientContext &context);
61: };
62: 
63: struct DebugManyFreeListBlocks {
64: 	static constexpr const char *Name = "debug_many_free_list_blocks";
65: 	static constexpr const char *Description = "DEBUG SETTING: add additional blocks to the free list";
66: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
67: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
68: 	static Value GetSetting(ClientContext &context);
69: };
70: 
71: struct DebugWindowMode {
72: 	static constexpr const char *Name = "debug_window_mode";
73: 	static constexpr const char *Description = "DEBUG SETTING: switch window mode to use";
74: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
75: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
76: 	static Value GetSetting(ClientContext &context);
77: };
78: 
79: struct DefaultCollationSetting {
80: 	static constexpr const char *Name = "default_collation";
81: 	static constexpr const char *Description = "The collation setting used when none is specified";
82: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
83: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
84: 	static void SetLocal(ClientContext &context, const Value &parameter);
85: 	static Value GetSetting(ClientContext &context);
86: };
87: 
88: struct DefaultOrderSetting {
89: 	static constexpr const char *Name = "default_order";
90: 	static constexpr const char *Description = "The order type used when none is specified (ASC or DESC)";
91: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
92: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
93: 	static Value GetSetting(ClientContext &context);
94: };
95: 
96: struct DefaultNullOrderSetting {
97: 	static constexpr const char *Name = "default_null_order";
98: 	static constexpr const char *Description = "Null ordering used when none is specified (NULLS_FIRST or NULLS_LAST)";
99: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
100: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
101: 	static Value GetSetting(ClientContext &context);
102: };
103: 
104: struct DisabledOptimizersSetting {
105: 	static constexpr const char *Name = "disabled_optimizers";
106: 	static constexpr const char *Description = "DEBUG SETTING: disable a specific set of optimizers (comma separated)";
107: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
108: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
109: 	static Value GetSetting(ClientContext &context);
110: };
111: 
112: struct EnableExternalAccessSetting {
113: 	static constexpr const char *Name = "enable_external_access";
114: 	static constexpr const char *Description =
115: 	    "Allow the database to access external state (through e.g. loading/installing modules, COPY TO/FROM, CSV "
116: 	    "readers, pandas replacement scans, etc)";
117: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
118: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
119: 	static Value GetSetting(ClientContext &context);
120: };
121: 
122: struct EnableFSSTVectors {
123: 	static constexpr const char *Name = "enable_fsst_vectors";
124: 	static constexpr const char *Description =
125: 	    "Allow scans on FSST compressed segments to emit compressed vectors to utilize late decompression";
126: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
127: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
128: 	static Value GetSetting(ClientContext &context);
129: };
130: 
131: struct AllowUnsignedExtensionsSetting {
132: 	static constexpr const char *Name = "allow_unsigned_extensions";
133: 	static constexpr const char *Description = "Allow to load extensions with invalid or missing signatures";
134: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
135: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
136: 	static Value GetSetting(ClientContext &context);
137: };
138: 
139: struct EnableObjectCacheSetting {
140: 	static constexpr const char *Name = "enable_object_cache";
141: 	static constexpr const char *Description = "Whether or not object cache is used to cache e.g. Parquet metadata";
142: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
143: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
144: 	static Value GetSetting(ClientContext &context);
145: };
146: 
147: struct EnableProfilingSetting {
148: 	static constexpr const char *Name = "enable_profiling";
149: 	static constexpr const char *Description =
150: 	    "Enables profiling, and sets the output format (JSON, QUERY_TREE, QUERY_TREE_OPTIMIZER)";
151: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
152: 	static void SetLocal(ClientContext &context, const Value &parameter);
153: 	static Value GetSetting(ClientContext &context);
154: };
155: 
156: struct EnableProgressBarSetting {
157: 	static constexpr const char *Name = "enable_progress_bar";
158: 	static constexpr const char *Description =
159: 	    "Enables the progress bar, printing progress to the terminal for long queries";
160: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
161: 	static void SetLocal(ClientContext &context, const Value &parameter);
162: 	static Value GetSetting(ClientContext &context);
163: };
164: 
165: struct ExplainOutputSetting {
166: 	static constexpr const char *Name = "explain_output";
167: 	static constexpr const char *Description = "Output of EXPLAIN statements (ALL, OPTIMIZED_ONLY, PHYSICAL_ONLY)";
168: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
169: 	static void SetLocal(ClientContext &context, const Value &parameter);
170: 	static Value GetSetting(ClientContext &context);
171: };
172: 
173: struct ExternalThreadsSetting {
174: 	static constexpr const char *Name = "external_threads";
175: 	static constexpr const char *Description = "The number of external threads that work on DuckDB tasks.";
176: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
177: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
178: 	static Value GetSetting(ClientContext &context);
179: };
180: 
181: struct FileSearchPathSetting {
182: 	static constexpr const char *Name = "file_search_path";
183: 	static constexpr const char *Description = "A comma separated list of directories to search for input files";
184: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
185: 	static void SetLocal(ClientContext &context, const Value &parameter);
186: 	static Value GetSetting(ClientContext &context);
187: };
188: 
189: struct ForceCompressionSetting {
190: 	static constexpr const char *Name = "force_compression";
191: 	static constexpr const char *Description = "DEBUG SETTING: forces a specific compression method to be used";
192: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
193: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
194: 	static Value GetSetting(ClientContext &context);
195: };
196: 
197: struct HomeDirectorySetting {
198: 	static constexpr const char *Name = "home_directory";
199: 	static constexpr const char *Description = "Sets the home directory used by the system";
200: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
201: 	static void SetLocal(ClientContext &context, const Value &parameter);
202: 	static Value GetSetting(ClientContext &context);
203: };
204: 
205: struct LogQueryPathSetting {
206: 	static constexpr const char *Name = "log_query_path";
207: 	static constexpr const char *Description =
208: 	    "Specifies the path to which queries should be logged (default: empty string, queries are not logged)";
209: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
210: 	static void SetLocal(ClientContext &context, const Value &parameter);
211: 	static Value GetSetting(ClientContext &context);
212: };
213: 
214: struct MaximumExpressionDepthSetting {
215: 	static constexpr const char *Name = "max_expression_depth";
216: 	static constexpr const char *Description =
217: 	    "The maximum expression depth limit in the parser. WARNING: increasing this setting and using very deep "
218: 	    "expressions might lead to stack overflow errors.";
219: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::UBIGINT;
220: 	static void SetLocal(ClientContext &context, const Value &parameter);
221: 	static Value GetSetting(ClientContext &context);
222: };
223: 
224: struct MaximumMemorySetting {
225: 	static constexpr const char *Name = "max_memory";
226: 	static constexpr const char *Description = "The maximum memory of the system (e.g. 1GB)";
227: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
228: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
229: 	static Value GetSetting(ClientContext &context);
230: };
231: 
232: struct PerfectHashThresholdSetting {
233: 	static constexpr const char *Name = "perfect_ht_threshold";
234: 	static constexpr const char *Description = "Threshold in bytes for when to use a perfect hash table (default: 12)";
235: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
236: 	static void SetLocal(ClientContext &context, const Value &parameter);
237: 	static Value GetSetting(ClientContext &context);
238: };
239: 
240: struct PreserveIdentifierCase {
241: 	static constexpr const char *Name = "preserve_identifier_case";
242: 	static constexpr const char *Description =
243: 	    "Whether or not to preserve the identifier case, instead of always lowercasing all non-quoted identifiers";
244: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
245: 	static void SetLocal(ClientContext &context, const Value &parameter);
246: 	static Value GetSetting(ClientContext &context);
247: };
248: 
249: struct PreserveInsertionOrder {
250: 	static constexpr const char *Name = "preserve_insertion_order";
251: 	static constexpr const char *Description =
252: 	    "Whether or not to preserve insertion order. If set to false the system is allowed to re-order any results "
253: 	    "that do not contain ORDER BY clauses.";
254: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BOOLEAN;
255: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
256: 	static Value GetSetting(ClientContext &context);
257: };
258: 
259: struct ProfilerHistorySize {
260: 	static constexpr const char *Name = "profiler_history_size";
261: 	static constexpr const char *Description = "Sets the profiler history size";
262: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
263: 	static void SetLocal(ClientContext &context, const Value &parameter);
264: 	static Value GetSetting(ClientContext &context);
265: };
266: 
267: struct ProfileOutputSetting {
268: 	static constexpr const char *Name = "profile_output";
269: 	static constexpr const char *Description =
270: 	    "The file to which profile output should be saved, or empty to print to the terminal";
271: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
272: 	static void SetLocal(ClientContext &context, const Value &parameter);
273: 	static Value GetSetting(ClientContext &context);
274: };
275: 
276: struct ProfilingModeSetting {
277: 	static constexpr const char *Name = "profiling_mode";
278: 	static constexpr const char *Description = "The profiling mode (STANDARD or DETAILED)";
279: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
280: 	static void SetLocal(ClientContext &context, const Value &parameter);
281: 	static Value GetSetting(ClientContext &context);
282: };
283: 
284: struct ProgressBarTimeSetting {
285: 	static constexpr const char *Name = "progress_bar_time";
286: 	static constexpr const char *Description =
287: 	    "Sets the time (in milliseconds) how long a query needs to take before we start printing a progress bar";
288: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
289: 	static void SetLocal(ClientContext &context, const Value &parameter);
290: 	static Value GetSetting(ClientContext &context);
291: };
292: 
293: struct SchemaSetting {
294: 	static constexpr const char *Name = "schema";
295: 	static constexpr const char *Description =
296: 	    "Sets the default search schema. Equivalent to setting search_path to a single value.";
297: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
298: 	static void SetLocal(ClientContext &context, const Value &parameter);
299: 	static Value GetSetting(ClientContext &context);
300: };
301: 
302: struct SearchPathSetting {
303: 	static constexpr const char *Name = "search_path";
304: 	static constexpr const char *Description =
305: 	    "Sets the default search search path as a comma-separated list of values";
306: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
307: 	static void SetLocal(ClientContext &context, const Value &parameter);
308: 	static Value GetSetting(ClientContext &context);
309: };
310: 
311: struct TempDirectorySetting {
312: 	static constexpr const char *Name = "temp_directory";
313: 	static constexpr const char *Description = "Set the directory to which to write temp files";
314: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::VARCHAR;
315: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
316: 	static Value GetSetting(ClientContext &context);
317: };
318: 
319: struct ThreadsSetting {
320: 	static constexpr const char *Name = "threads";
321: 	static constexpr const char *Description = "The number of total threads used by the system.";
322: 	static constexpr const LogicalTypeId InputType = LogicalTypeId::BIGINT;
323: 	static void SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &parameter);
324: 	static Value GetSetting(ClientContext &context);
325: };
326: 
327: } // namespace duckdb
[end of src/include/duckdb/main/settings.hpp]
[start of src/main/CMakeLists.txt]
1: if(NOT CLANG_TIDY)
2:   add_subdirectory(capi)
3: endif()
4: add_subdirectory(extension)
5: add_subdirectory(relation)
6: add_subdirectory(settings)
7: 
8: if(FORCE_QUERY_LOG)
9:   add_definitions(-DDUCKDB_FORCE_QUERY_LOG="\""${FORCE_QUERY_LOG}"\"")
10: endif()
11: 
12: add_library_unity(
13:   duckdb_main
14:   OBJECT
15:   appender.cpp
16:   client_context_file_opener.cpp
17:   client_context.cpp
18:   client_data.cpp
19:   client_verify.cpp
20:   config.cpp
21:   connection.cpp
22:   database.cpp
23:   db_instance_cache.cpp
24:   extension.cpp
25:   materialized_query_result.cpp
26:   pending_query_result.cpp
27:   prepared_statement.cpp
28:   prepared_statement_data.cpp
29:   relation.cpp
30:   extension_prefix_opener.cpp
31:   query_profiler.cpp
32:   query_result.cpp
33:   stream_query_result.cpp)
34: set(ALL_OBJECT_FILES
35:     ${ALL_OBJECT_FILES} $<TARGET_OBJECTS:duckdb_main>
36:     PARENT_SCOPE)
[end of src/main/CMakeLists.txt]
[start of src/main/config.cpp]
1: #include "duckdb/main/config.hpp"
2: 
3: #include "duckdb/common/operator/cast_operators.hpp"
4: #include "duckdb/common/string_util.hpp"
5: #include "duckdb/main/settings.hpp"
6: 
7: namespace duckdb {
8: 
9: #define DUCKDB_GLOBAL(_PARAM)                                                                                          \
10: 	{ _PARAM::Name, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, nullptr, _PARAM::GetSetting }
11: #define DUCKDB_GLOBAL_ALIAS(_ALIAS, _PARAM)                                                                            \
12: 	{ _ALIAS, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, nullptr, _PARAM::GetSetting }
13: 
14: #define DUCKDB_LOCAL(_PARAM)                                                                                           \
15: 	{ _PARAM::Name, _PARAM::Description, _PARAM::InputType, nullptr, _PARAM::SetLocal, _PARAM::GetSetting }
16: #define DUCKDB_LOCAL_ALIAS(_ALIAS, _PARAM)                                                                             \
17: 	{ _ALIAS, _PARAM::Description, _PARAM::InputType, nullptr, _PARAM::SetLocal, _PARAM::GetSetting }
18: 
19: #define DUCKDB_GLOBAL_LOCAL(_PARAM)                                                                                    \
20: 	{ _PARAM::Name, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, _PARAM::SetLocal, _PARAM::GetSetting }
21: #define DUCKDB_GLOBAL_LOCAL_ALIAS(_ALIAS, _PARAM)                                                                      \
22: 	{ _ALIAS, _PARAM::Description, _PARAM::InputType, _PARAM::SetGlobal, _PARAM::SetLocal, _PARAM::GetSetting }
23: #define FINAL_SETTING                                                                                                  \
24: 	{ nullptr, nullptr, LogicalTypeId::INVALID, nullptr, nullptr, nullptr }
25: 
26: static ConfigurationOption internal_options[] = {DUCKDB_GLOBAL(AccessModeSetting),
27:                                                  DUCKDB_GLOBAL(CheckpointThresholdSetting),
28:                                                  DUCKDB_GLOBAL(DebugCheckpointAbort),
29:                                                  DUCKDB_LOCAL(DebugForceExternal),
30:                                                  DUCKDB_LOCAL(DebugForceNoCrossProduct),
31:                                                  DUCKDB_GLOBAL(DebugManyFreeListBlocks),
32:                                                  DUCKDB_GLOBAL(DebugWindowMode),
33:                                                  DUCKDB_GLOBAL_LOCAL(DefaultCollationSetting),
34:                                                  DUCKDB_GLOBAL(DefaultOrderSetting),
35:                                                  DUCKDB_GLOBAL(DefaultNullOrderSetting),
36:                                                  DUCKDB_GLOBAL(DisabledOptimizersSetting),
37:                                                  DUCKDB_GLOBAL(EnableExternalAccessSetting),
38:                                                  DUCKDB_GLOBAL(EnableFSSTVectors),
39:                                                  DUCKDB_GLOBAL(AllowUnsignedExtensionsSetting),
40:                                                  DUCKDB_GLOBAL(EnableObjectCacheSetting),
41:                                                  DUCKDB_LOCAL(EnableProfilingSetting),
42:                                                  DUCKDB_LOCAL(EnableProgressBarSetting),
43:                                                  DUCKDB_LOCAL(ExplainOutputSetting),
44:                                                  DUCKDB_GLOBAL(ExternalThreadsSetting),
45:                                                  DUCKDB_LOCAL(FileSearchPathSetting),
46:                                                  DUCKDB_GLOBAL(ForceCompressionSetting),
47:                                                  DUCKDB_LOCAL(HomeDirectorySetting),
48:                                                  DUCKDB_LOCAL(LogQueryPathSetting),
49:                                                  DUCKDB_LOCAL(MaximumExpressionDepthSetting),
50:                                                  DUCKDB_GLOBAL(MaximumMemorySetting),
51:                                                  DUCKDB_GLOBAL_ALIAS("memory_limit", MaximumMemorySetting),
52:                                                  DUCKDB_GLOBAL_ALIAS("null_order", DefaultNullOrderSetting),
53:                                                  DUCKDB_LOCAL(PerfectHashThresholdSetting),
54:                                                  DUCKDB_LOCAL(PreserveIdentifierCase),
55:                                                  DUCKDB_GLOBAL(PreserveInsertionOrder),
56:                                                  DUCKDB_LOCAL(ProfilerHistorySize),
57:                                                  DUCKDB_LOCAL(ProfileOutputSetting),
58:                                                  DUCKDB_LOCAL(ProfilingModeSetting),
59:                                                  DUCKDB_LOCAL_ALIAS("profiling_output", ProfileOutputSetting),
60:                                                  DUCKDB_LOCAL(ProgressBarTimeSetting),
61:                                                  DUCKDB_LOCAL(SchemaSetting),
62:                                                  DUCKDB_LOCAL(SearchPathSetting),
63:                                                  DUCKDB_GLOBAL(TempDirectorySetting),
64:                                                  DUCKDB_GLOBAL(ThreadsSetting),
65:                                                  DUCKDB_GLOBAL_ALIAS("wal_autocheckpoint", CheckpointThresholdSetting),
66:                                                  DUCKDB_GLOBAL_ALIAS("worker_threads", ThreadsSetting),
67:                                                  FINAL_SETTING};
68: 
69: vector<ConfigurationOption> DBConfig::GetOptions() {
70: 	vector<ConfigurationOption> options;
71: 	for (idx_t index = 0; internal_options[index].name; index++) {
72: 		options.push_back(internal_options[index]);
73: 	}
74: 	return options;
75: }
76: 
77: idx_t DBConfig::GetOptionCount() {
78: 	idx_t count = 0;
79: 	for (idx_t index = 0; internal_options[index].name; index++) {
80: 		count++;
81: 	}
82: 	return count;
83: }
84: 
85: vector<std::string> DBConfig::GetOptionNames() {
86: 	vector<string> names;
87: 	for (idx_t i = 0, option_count = DBConfig::GetOptionCount(); i < option_count; i++) {
88: 		names.emplace_back(DBConfig::GetOptionByIndex(i)->name);
89: 	}
90: 	return names;
91: }
92: 
93: ConfigurationOption *DBConfig::GetOptionByIndex(idx_t target_index) {
94: 	for (idx_t index = 0; internal_options[index].name; index++) {
95: 		if (index == target_index) {
96: 			return internal_options + index;
97: 		}
98: 	}
99: 	return nullptr;
100: }
101: 
102: ConfigurationOption *DBConfig::GetOptionByName(const string &name) {
103: 	auto lname = StringUtil::Lower(name);
104: 	for (idx_t index = 0; internal_options[index].name; index++) {
105: 		D_ASSERT(StringUtil::Lower(internal_options[index].name) == string(internal_options[index].name));
106: 		if (internal_options[index].name == lname) {
107: 			return internal_options + index;
108: 		}
109: 	}
110: 	return nullptr;
111: }
112: 
113: void DBConfig::SetOption(const ConfigurationOption &option, const Value &value) {
114: 	if (!option.set_global) {
115: 		throw InternalException("Could not set option \"%s\" as a global option", option.name);
116: 	}
117: 	Value input = value.DefaultCastAs(option.parameter_type);
118: 	option.set_global(nullptr, *this, input);
119: }
120: 
121: void DBConfig::AddExtensionOption(string name, string description, LogicalType parameter,
122:                                   set_option_callback_t function) {
123: 	extension_parameters.insert(make_pair(move(name), ExtensionOption(move(description), move(parameter), function)));
124: }
125: 
126: CastFunctionSet &DBConfig::GetCastFunctions() {
127: 	return *cast_functions;
128: }
129: 
130: idx_t DBConfig::ParseMemoryLimit(const string &arg) {
131: 	if (arg[0] == '-' || arg == "null" || arg == "none") {
132: 		return DConstants::INVALID_INDEX;
133: 	}
134: 	// split based on the number/non-number
135: 	idx_t idx = 0;
136: 	while (StringUtil::CharacterIsSpace(arg[idx])) {
137: 		idx++;
138: 	}
139: 	idx_t num_start = idx;
140: 	while ((arg[idx] >= '0' && arg[idx] <= '9') || arg[idx] == '.' || arg[idx] == 'e' || arg[idx] == 'E' ||
141: 	       arg[idx] == '-') {
142: 		idx++;
143: 	}
144: 	if (idx == num_start) {
145: 		throw ParserException("Memory limit must have a number (e.g. SET memory_limit=1GB");
146: 	}
147: 	string number = arg.substr(num_start, idx - num_start);
148: 
149: 	// try to parse the number
150: 	double limit = Cast::Operation<string_t, double>(string_t(number));
151: 
152: 	// now parse the memory limit unit (e.g. bytes, gb, etc)
153: 	while (StringUtil::CharacterIsSpace(arg[idx])) {
154: 		idx++;
155: 	}
156: 	idx_t start = idx;
157: 	while (idx < arg.size() && !StringUtil::CharacterIsSpace(arg[idx])) {
158: 		idx++;
159: 	}
160: 	if (limit < 0) {
161: 		// limit < 0, set limit to infinite
162: 		return (idx_t)-1;
163: 	}
164: 	string unit = StringUtil::Lower(arg.substr(start, idx - start));
165: 	idx_t multiplier;
166: 	if (unit == "byte" || unit == "bytes" || unit == "b") {
167: 		multiplier = 1;
168: 	} else if (unit == "kilobyte" || unit == "kilobytes" || unit == "kb" || unit == "k") {
169: 		multiplier = 1000LL;
170: 	} else if (unit == "megabyte" || unit == "megabytes" || unit == "mb" || unit == "m") {
171: 		multiplier = 1000LL * 1000LL;
172: 	} else if (unit == "gigabyte" || unit == "gigabytes" || unit == "gb" || unit == "g") {
173: 		multiplier = 1000LL * 1000LL * 1000LL;
174: 	} else if (unit == "terabyte" || unit == "terabytes" || unit == "tb" || unit == "t") {
175: 		multiplier = 1000LL * 1000LL * 1000LL * 1000LL;
176: 	} else {
177: 		throw ParserException("Unknown unit for memory_limit: %s (expected: b, mb, gb or tb)", unit);
178: 	}
179: 	return (idx_t)multiplier * limit;
180: }
181: 
182: // Right now we only really care about access mode when comparing DBConfigs
183: bool DBConfigOptions::operator==(const DBConfigOptions &other) const {
184: 	return other.access_mode == access_mode;
185: }
186: 
187: bool DBConfig::operator==(const DBConfig &other) {
188: 	return other.options == options;
189: }
190: 
191: bool DBConfig::operator!=(const DBConfig &other) {
192: 	return !(other.options == options);
193: }
194: 
195: } // namespace duckdb
[end of src/main/config.cpp]
[start of src/main/database.cpp]
1: #include "duckdb/main/database.hpp"
2: 
3: #include "duckdb/catalog/catalog.hpp"
4: #include "duckdb/common/virtual_file_system.hpp"
5: #include "duckdb/main/client_context.hpp"
6: #include "duckdb/parallel/task_scheduler.hpp"
7: #include "duckdb/storage/storage_manager.hpp"
8: #include "duckdb/storage/object_cache.hpp"
9: #include "duckdb/transaction/transaction_manager.hpp"
10: #include "duckdb/main/connection_manager.hpp"
11: #include "duckdb/function/compression_function.hpp"
12: #include "duckdb/main/extension_helper.hpp"
13: #include "duckdb/main/replacement_opens.hpp"
14: #include "duckdb/function/cast/cast_function_set.hpp"
15: 
16: #ifndef DUCKDB_NO_THREADS
17: #include "duckdb/common/thread.hpp"
18: #endif
19: 
20: namespace duckdb {
21: 
22: DBConfig::DBConfig() {
23: 	compression_functions = make_unique<CompressionFunctionSet>();
24: 	replacement_opens.push_back(ExtensionPrefixReplacementOpen());
25: 	cast_functions = make_unique<CastFunctionSet>();
26: }
27: 
28: DBConfig::DBConfig(std::unordered_map<string, string> &config_dict, bool read_only) {
29: 	compression_functions = make_unique<CompressionFunctionSet>();
30: 	if (read_only) {
31: 		options.access_mode = AccessMode::READ_ONLY;
32: 	}
33: 	for (auto &kv : config_dict) {
34: 		string key = kv.first;
35: 		string val = kv.second;
36: 		auto config_property = DBConfig::GetOptionByName(key);
37: 		if (!config_property) {
38: 			throw InvalidInputException("Unrecognized configuration property \"%s\"", key);
39: 		}
40: 		auto opt_val = Value(val);
41: 		DBConfig::SetOption(*config_property, opt_val);
42: 	}
43: }
44: 
45: DBConfig::~DBConfig() {
46: }
47: 
48: DatabaseInstance::DatabaseInstance() : is_invalidated(false) {
49: }
50: 
51: DatabaseInstance::~DatabaseInstance() {
52: 	if (Exception::UncaughtException()) {
53: 		return;
54: 	}
55: 
56: 	// shutting down: attempt to checkpoint the database
57: 	// but only if we are not cleaning up as part of an exception unwind
58: 	try {
59: 		auto &storage = StorageManager::GetStorageManager(*this);
60: 		if (!storage.InMemory()) {
61: 			auto &config = storage.db.config;
62: 			if (!config.options.checkpoint_on_shutdown) {
63: 				return;
64: 			}
65: 			storage.CreateCheckpoint(true);
66: 		}
67: 	} catch (...) {
68: 	}
69: }
70: 
71: BufferManager &BufferManager::GetBufferManager(DatabaseInstance &db) {
72: 	return *db.GetStorageManager().buffer_manager;
73: }
74: 
75: DatabaseInstance &DatabaseInstance::GetDatabase(ClientContext &context) {
76: 	return *context.db;
77: }
78: 
79: StorageManager &StorageManager::GetStorageManager(DatabaseInstance &db) {
80: 	return db.GetStorageManager();
81: }
82: 
83: Catalog &Catalog::GetCatalog(DatabaseInstance &db) {
84: 	return db.GetCatalog();
85: }
86: 
87: FileSystem &FileSystem::GetFileSystem(DatabaseInstance &db) {
88: 	return db.GetFileSystem();
89: }
90: 
91: DBConfig &DBConfig::GetConfig(DatabaseInstance &db) {
92: 	return db.config;
93: }
94: 
95: ClientConfig &ClientConfig::GetConfig(ClientContext &context) {
96: 	return context.config;
97: }
98: 
99: const DBConfig &DBConfig::GetConfig(const DatabaseInstance &db) {
100: 	return db.config;
101: }
102: 
103: const ClientConfig &ClientConfig::GetConfig(const ClientContext &context) {
104: 	return context.config;
105: }
106: 
107: TransactionManager &TransactionManager::Get(ClientContext &context) {
108: 	return TransactionManager::Get(DatabaseInstance::GetDatabase(context));
109: }
110: 
111: TransactionManager &TransactionManager::Get(DatabaseInstance &db) {
112: 	return db.GetTransactionManager();
113: }
114: 
115: ConnectionManager &ConnectionManager::Get(DatabaseInstance &db) {
116: 	return db.GetConnectionManager();
117: }
118: 
119: ConnectionManager &ConnectionManager::Get(ClientContext &context) {
120: 	return ConnectionManager::Get(DatabaseInstance::GetDatabase(context));
121: }
122: 
123: void DatabaseInstance::Initialize(const char *database_path, DBConfig *user_config) {
124: 	DBConfig default_config;
125: 	DBConfig *config_ptr = &default_config;
126: 	if (user_config) {
127: 		config_ptr = user_config;
128: 	}
129: 
130: 	if (config_ptr->options.temporary_directory.empty() && database_path) {
131: 		// no directory specified: use default temp path
132: 		config_ptr->options.temporary_directory = string(database_path) + ".tmp";
133: 
134: 		// special treatment for in-memory mode
135: 		if (strcmp(database_path, ":memory:") == 0) {
136: 			config_ptr->options.temporary_directory = ".tmp";
137: 		}
138: 	}
139: 
140: 	if (database_path) {
141: 		config_ptr->options.database_path = database_path;
142: 	} else {
143: 		config_ptr->options.database_path.clear();
144: 	}
145: 
146: 	for (auto &open : config_ptr->replacement_opens) {
147: 		if (open.pre_func) {
148: 			open.data = open.pre_func(*config_ptr, open.static_data.get());
149: 			if (open.data) {
150: 				break;
151: 			}
152: 		}
153: 	}
154: 	Configure(*config_ptr);
155: 
156: 	if (user_config && !user_config->options.use_temporary_directory) {
157: 		// temporary directories explicitly disabled
158: 		config.options.temporary_directory = string();
159: 	}
160: 
161: 	// TODO: Support an extension here, to generate different storage managers
162: 	// depending on the DB path structure/prefix.
163: 	const string dbPath = config.options.database_path;
164: 	storage = make_unique<SingleFileStorageManager>(*this, dbPath, config.options.access_mode == AccessMode::READ_ONLY);
165: 
166: 	catalog = make_unique<Catalog>(*this);
167: 	transaction_manager = make_unique<TransactionManager>(*this);
168: 	scheduler = make_unique<TaskScheduler>(*this);
169: 	object_cache = make_unique<ObjectCache>();
170: 	connection_manager = make_unique<ConnectionManager>();
171: 
172: 	// initialize the database
173: 	storage->Initialize();
174: 
175: 	// only increase thread count after storage init because we get races on catalog otherwise
176: 	scheduler->SetThreads(config.options.maximum_threads);
177: 
178: 	for (auto &open : config.replacement_opens) {
179: 		if (open.post_func && open.data) {
180: 			open.post_func(*this, open.data.get());
181: 			break;
182: 		}
183: 	}
184: }
185: 
186: DuckDB::DuckDB(const char *path, DBConfig *new_config) : instance(make_shared<DatabaseInstance>()) {
187: 	instance->Initialize(path, new_config);
188: 	if (instance->config.options.load_extensions) {
189: 		ExtensionHelper::LoadAllExtensions(*this);
190: 	}
191: }
192: 
193: DuckDB::DuckDB(const string &path, DBConfig *config) : DuckDB(path.c_str(), config) {
194: }
195: 
196: DuckDB::DuckDB(DatabaseInstance &instance_p) : instance(instance_p.shared_from_this()) {
197: }
198: 
199: DuckDB::~DuckDB() {
200: }
201: 
202: StorageManager &DatabaseInstance::GetStorageManager() {
203: 	return *storage;
204: }
205: 
206: Catalog &DatabaseInstance::GetCatalog() {
207: 	return *catalog;
208: }
209: 
210: TransactionManager &DatabaseInstance::GetTransactionManager() {
211: 	return *transaction_manager;
212: }
213: 
214: TaskScheduler &DatabaseInstance::GetScheduler() {
215: 	return *scheduler;
216: }
217: 
218: ObjectCache &DatabaseInstance::GetObjectCache() {
219: 	return *object_cache;
220: }
221: 
222: FileSystem &DatabaseInstance::GetFileSystem() {
223: 	return *config.file_system;
224: }
225: 
226: ConnectionManager &DatabaseInstance::GetConnectionManager() {
227: 	return *connection_manager;
228: }
229: 
230: FileSystem &DuckDB::GetFileSystem() {
231: 	return instance->GetFileSystem();
232: }
233: 
234: Allocator &Allocator::Get(ClientContext &context) {
235: 	return Allocator::Get(*context.db);
236: }
237: 
238: Allocator &Allocator::Get(DatabaseInstance &db) {
239: 	return *db.config.allocator;
240: }
241: 
242: void DatabaseInstance::Configure(DBConfig &new_config) {
243: 	config.options.database_path = new_config.options.database_path;
244: 	config.options.access_mode = AccessMode::READ_WRITE;
245: 	if (new_config.options.access_mode != AccessMode::UNDEFINED) {
246: 		config.options.access_mode = new_config.options.access_mode;
247: 	}
248: 	if (new_config.file_system) {
249: 		config.file_system = move(new_config.file_system);
250: 	} else {
251: 		config.file_system = make_unique<VirtualFileSystem>();
252: 	}
253: 	config.options.maximum_memory = new_config.options.maximum_memory;
254: 	if (config.options.maximum_memory == (idx_t)-1) {
255: 		auto memory = FileSystem::GetAvailableMemory();
256: 		if (memory != DConstants::INVALID_INDEX) {
257: 			config.options.maximum_memory = memory * 8 / 10;
258: 		}
259: 	}
260: 	if (new_config.options.maximum_threads == (idx_t)-1) {
261: #ifndef DUCKDB_NO_THREADS
262: 		config.options.maximum_threads = std::thread::hardware_concurrency();
263: #else
264: 		config.options.maximum_threads = 1;
265: #endif
266: 	} else {
267: 		config.options.maximum_threads = new_config.options.maximum_threads;
268: 	}
269: 	config.options.external_threads = new_config.options.external_threads;
270: 	config.options.load_extensions = new_config.options.load_extensions;
271: 	config.options.force_compression = new_config.options.force_compression;
272: 	config.allocator = move(new_config.allocator);
273: 	if (!config.allocator) {
274: 		config.allocator = make_unique<Allocator>();
275: 	}
276: 	config.options.checkpoint_wal_size = new_config.options.checkpoint_wal_size;
277: 	config.options.use_direct_io = new_config.options.use_direct_io;
278: 	config.options.temporary_directory = new_config.options.temporary_directory;
279: 	config.options.collation = new_config.options.collation;
280: 	config.options.default_order_type = new_config.options.default_order_type;
281: 	config.options.default_null_order = new_config.options.default_null_order;
282: 	config.options.enable_external_access = new_config.options.enable_external_access;
283: 	config.options.allow_unsigned_extensions = new_config.options.allow_unsigned_extensions;
284: 	config.replacement_scans = move(new_config.replacement_scans);
285: 	config.replacement_opens = move(new_config.replacement_opens); // TODO is this okay?
286: 	config.options.initialize_default_database = new_config.options.initialize_default_database;
287: 	config.options.disabled_optimizers = move(new_config.options.disabled_optimizers);
288: 	config.parser_extensions = move(new_config.parser_extensions);
289: }
290: 
291: DBConfig &DBConfig::GetConfig(ClientContext &context) {
292: 	return context.db->config;
293: }
294: 
295: const DBConfig &DBConfig::GetConfig(const ClientContext &context) {
296: 	return context.db->config;
297: }
298: 
299: idx_t DatabaseInstance::NumberOfThreads() {
300: 	return scheduler->NumberOfThreads();
301: }
302: 
303: const unordered_set<std::string> &DatabaseInstance::LoadedExtensions() {
304: 	return loaded_extensions;
305: }
306: 
307: idx_t DuckDB::NumberOfThreads() {
308: 	return instance->NumberOfThreads();
309: }
310: 
311: bool DuckDB::ExtensionIsLoaded(const std::string &name) {
312: 	return instance->loaded_extensions.find(name) != instance->loaded_extensions.end();
313: }
314: void DatabaseInstance::SetExtensionLoaded(const std::string &name) {
315: 	loaded_extensions.insert(name);
316: }
317: 
318: bool DatabaseInstance::TryGetCurrentSetting(const std::string &key, Value &result) {
319: 	// check the session values
320: 	auto &db_config = DBConfig::GetConfig(*this);
321: 	const auto &global_config_map = db_config.options.set_variables;
322: 
323: 	auto global_value = global_config_map.find(key);
324: 	bool found_global_value = global_value != global_config_map.end();
325: 	if (!found_global_value) {
326: 		return false;
327: 	}
328: 	result = global_value->second;
329: 	return true;
330: }
331: 
332: string ClientConfig::ExtractTimezone() const {
333: 	auto entry = set_variables.find("TimeZone");
334: 	if (entry == set_variables.end()) {
335: 		return "UTC";
336: 	} else {
337: 		return entry->second.GetValue<std::string>();
338: 	}
339: }
340: 
341: void DatabaseInstance::Invalidate() {
342: 	this->is_invalidated = true;
343: }
344: bool DatabaseInstance::IsInvalidated() {
345: 	return this->is_invalidated;
346: }
347: 
348: } // namespace duckdb
[end of src/main/database.cpp]
[start of src/main/extension/extension_load.cpp]
1: #include "duckdb/common/dl.hpp"
2: #include "duckdb/common/virtual_file_system.hpp"
3: #include "duckdb/function/replacement_open.hpp"
4: #include "duckdb/main/extension_helper.hpp"
5: #include "mbedtls_wrapper.hpp"
6: 
7: namespace duckdb {
8: 
9: //===--------------------------------------------------------------------===//
10: // Load External Extension
11: //===--------------------------------------------------------------------===//
12: typedef void (*ext_init_fun_t)(DatabaseInstance &);
13: typedef const char *(*ext_version_fun_t)(void);
14: 
15: template <class T>
16: static T LoadFunctionFromDLL(void *dll, const string &function_name, const string &filename) {
17: 	auto function = dlsym(dll, function_name.c_str());
18: 	if (!function) {
19: 		throw IOException("File \"%s\" did not contain function \"%s\": %s", filename, function_name, GetDLError());
20: 	}
21: 	return (T)function;
22: }
23: 
24: ExtensionInitResult ExtensionHelper::InitialLoad(DBConfig &config, FileOpener *opener, const string &extension) {
25: 	if (!config.options.enable_external_access) {
26: 		throw PermissionException("Loading external extensions is disabled through configuration");
27: 	}
28: 	VirtualFileSystem fallback_file_system; // config may not contain one yet
29: 	auto &fs = config.file_system ? *config.file_system : fallback_file_system;
30: 	auto filename = fs.ConvertSeparators(extension);
31: 
32: 	// shorthand case
33: 	if (!StringUtil::Contains(extension, ".") && !StringUtil::Contains(extension, fs.PathSeparator())) {
34: 		string local_path = fs.GetHomeDirectory(opener);
35: 		auto path_components = PathComponents();
36: 		for (auto &path_ele : path_components) {
37: 			local_path = fs.JoinPath(local_path, path_ele);
38: 		}
39: 		filename = fs.JoinPath(local_path, extension + ".duckdb_extension");
40: 	}
41: 
42: 	if (!fs.FileExists(filename)) {
43: 		throw IOException("Extension \"%s\" not found", filename);
44: 	}
45: 	{
46: 		auto handle = fs.OpenFile(filename, FileFlags::FILE_FLAGS_READ);
47: 
48: 		// signature is the last 265 bytes of the file
49: 
50: 		string signature;
51: 		signature.resize(256);
52: 
53: 		auto signature_offset = handle->GetFileSize() - signature.size();
54: 
55: 		string file_content;
56: 		file_content.resize(signature_offset);
57: 		handle->Read((void *)file_content.data(), signature_offset, 0);
58: 
59: 		// TODO maybe we should do a stream read / hash update here
60: 		handle->Read((void *)signature.data(), signature.size(), signature_offset);
61: 
62: 		auto hash = duckdb_mbedtls::MbedTlsWrapper::ComputeSha256Hash(file_content);
63: 
64: 		bool any_valid = false;
65: 		for (auto &key : ExtensionHelper::GetPublicKeys()) {
66: 			if (duckdb_mbedtls::MbedTlsWrapper::IsValidSha256Signature(key, signature, hash)) {
67: 				any_valid = true;
68: 				break;
69: 			}
70: 		}
71: 		if (!any_valid && !config.options.allow_unsigned_extensions) {
72: 			throw IOException(
73: 			    "Extension \"%s\" could not be loaded because its signature is either missing or "
74: 			    "invalid and unsigned extensions are disabled by configuration (allow_unsigned_extensions)",
75: 			    filename);
76: 		}
77: 	}
78: 	auto lib_hdl = dlopen(filename.c_str(), RTLD_NOW | RTLD_LOCAL);
79: 	if (!lib_hdl) {
80: 		throw IOException("Extension \"%s\" could not be loaded: %s", filename, GetDLError());
81: 	}
82: 
83: 	auto basename = fs.ExtractBaseName(filename);
84: 
85: 	ext_version_fun_t version_fun;
86: 	auto version_fun_name = basename + "_version";
87: 
88: 	version_fun = LoadFunctionFromDLL<ext_version_fun_t>(lib_hdl, version_fun_name, filename);
89: 
90: 	std::string engine_version = std::string(DuckDB::LibraryVersion());
91: 
92: 	auto version_fun_result = (*version_fun)();
93: 	if (version_fun_result == nullptr) {
94: 		throw InvalidInputException("Extension \"%s\" returned a nullptr", filename);
95: 	}
96: 	std::string extension_version = std::string(version_fun_result);
97: 
98: 	// Trim v's if necessary
99: 	std::string extension_version_trimmed = extension_version;
100: 	std::string engine_version_trimmed = engine_version;
101: 	if (extension_version.length() > 0 && extension_version[0] == 'v') {
102: 		extension_version_trimmed = extension_version.substr(1);
103: 	}
104: 	if (engine_version.length() > 0 && engine_version[0] == 'v') {
105: 		engine_version_trimmed = engine_version.substr(1);
106: 	}
107: 
108: 	if (extension_version_trimmed != engine_version_trimmed) {
109: 		throw InvalidInputException("Extension \"%s\" version (%s) does not match DuckDB version (%s)", filename,
110: 		                            extension_version, engine_version);
111: 	}
112: 
113: 	ExtensionInitResult res;
114: 	res.basename = basename;
115: 	res.filename = filename;
116: 	res.lib_hdl = lib_hdl;
117: 	return res;
118: }
119: 
120: void ExtensionHelper::LoadExternalExtension(ClientContext &context, const string &extension) {
121: 	auto &db = DatabaseInstance::GetDatabase(context);
122: 
123: 	auto res = InitialLoad(DBConfig::GetConfig(context), FileSystem::GetFileOpener(context), extension);
124: 	auto init_fun_name = res.basename + "_init";
125: 
126: 	ext_init_fun_t init_fun;
127: 	init_fun = LoadFunctionFromDLL<ext_init_fun_t>(res.lib_hdl, init_fun_name, res.filename);
128: 
129: 	try {
130: 		(*init_fun)(db);
131: 	} catch (std::exception &e) {
132: 		throw InvalidInputException("Initialization function \"%s\" from file \"%s\" threw an exception: \"%s\"",
133: 		                            init_fun_name, res.filename, e.what());
134: 	}
135: 
136: 	DatabaseInstance::GetDatabase(context).SetExtensionLoaded(extension);
137: }
138: 
139: unique_ptr<ReplacementOpenData> ExtensionHelper::ReplacementOpenPre(const string &extension, DBConfig &config) {
140: 
141: 	auto res = InitialLoad(config, nullptr, extension); // TODO opener
142: 	auto init_fun_name = res.basename + "_replacement_open_pre";
143: 
144: 	replacement_open_pre_t open_pre_fun;
145: 	open_pre_fun = LoadFunctionFromDLL<replacement_open_pre_t>(res.lib_hdl, init_fun_name, res.filename);
146: 
147: 	try {
148: 		return (*open_pre_fun)(config, nullptr);
149: 	} catch (std::exception &e) {
150: 		throw InvalidInputException("Initialization function \"%s\" from file \"%s\" threw an exception: \"%s\"",
151: 		                            init_fun_name, res.filename, e.what());
152: 	}
153: }
154: 
155: void ExtensionHelper::ReplacementOpenPost(ClientContext &context, const string &extension, DatabaseInstance &instance,
156:                                           ReplacementOpenData *open_data) {
157: 	auto res = InitialLoad(DBConfig::GetConfig(context), FileSystem::GetFileOpener(context), extension);
158: 	auto init_fun_name = res.basename + "_replacement_open_post";
159: 
160: 	replacement_open_post_t open_post_fun;
161: 	open_post_fun = LoadFunctionFromDLL<replacement_open_post_t>(res.lib_hdl, init_fun_name, res.filename);
162: 
163: 	try {
164: 		(*open_post_fun)(instance, open_data);
165: 	} catch (std::exception &e) {
166: 		throw InvalidInputException("Initialization function \"%s\" from file \"%s\" threw an exception: \"%s\"",
167: 		                            init_fun_name, res.filename, e.what());
168: 	}
169: }
170: 
171: } // namespace duckdb
[end of src/main/extension/extension_load.cpp]
[start of src/main/settings/settings.cpp]
1: #include "duckdb/main/settings.hpp"
2: 
3: #include "duckdb/catalog/catalog_search_path.hpp"
4: #include "duckdb/common/string_util.hpp"
5: #include "duckdb/main/client_context.hpp"
6: #include "duckdb/main/client_data.hpp"
7: #include "duckdb/main/config.hpp"
8: #include "duckdb/main/query_profiler.hpp"
9: #include "duckdb/parallel/task_scheduler.hpp"
10: #include "duckdb/parser/parser.hpp"
11: #include "duckdb/planner/expression_binder.hpp"
12: #include "duckdb/storage/buffer_manager.hpp"
13: #include "duckdb/storage/storage_manager.hpp"
14: 
15: namespace duckdb {
16: 
17: //===--------------------------------------------------------------------===//
18: // Access Mode
19: //===--------------------------------------------------------------------===//
20: void AccessModeSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
21: 	auto parameter = StringUtil::Lower(input.ToString());
22: 	if (parameter == "automatic") {
23: 		config.options.access_mode = AccessMode::AUTOMATIC;
24: 	} else if (parameter == "read_only") {
25: 		config.options.access_mode = AccessMode::READ_ONLY;
26: 	} else if (parameter == "read_write") {
27: 		config.options.access_mode = AccessMode::READ_WRITE;
28: 	} else {
29: 		throw InvalidInputException(
30: 		    "Unrecognized parameter for option ACCESS_MODE \"%s\". Expected READ_ONLY or READ_WRITE.", parameter);
31: 	}
32: }
33: 
34: Value AccessModeSetting::GetSetting(ClientContext &context) {
35: 	auto &config = DBConfig::GetConfig(context);
36: 	switch (config.options.access_mode) {
37: 	case AccessMode::AUTOMATIC:
38: 		return "automatic";
39: 	case AccessMode::READ_ONLY:
40: 		return "read_only";
41: 	case AccessMode::READ_WRITE:
42: 		return "read_write";
43: 	default:
44: 		throw InternalException("Unknown access mode setting");
45: 	}
46: }
47: 
48: //===--------------------------------------------------------------------===//
49: // Checkpoint Threshold
50: //===--------------------------------------------------------------------===//
51: void CheckpointThresholdSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
52: 	idx_t new_limit = DBConfig::ParseMemoryLimit(input.ToString());
53: 	config.options.checkpoint_wal_size = new_limit;
54: }
55: 
56: Value CheckpointThresholdSetting::GetSetting(ClientContext &context) {
57: 	auto &config = DBConfig::GetConfig(context);
58: 	return Value(StringUtil::BytesToHumanReadableString(config.options.checkpoint_wal_size));
59: }
60: 
61: //===--------------------------------------------------------------------===//
62: // Debug Checkpoint Abort
63: //===--------------------------------------------------------------------===//
64: void DebugCheckpointAbort::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
65: 	auto checkpoint_abort = StringUtil::Lower(input.ToString());
66: 	if (checkpoint_abort == "none") {
67: 		config.options.checkpoint_abort = CheckpointAbort::NO_ABORT;
68: 	} else if (checkpoint_abort == "before_truncate") {
69: 		config.options.checkpoint_abort = CheckpointAbort::DEBUG_ABORT_BEFORE_TRUNCATE;
70: 	} else if (checkpoint_abort == "before_header") {
71: 		config.options.checkpoint_abort = CheckpointAbort::DEBUG_ABORT_BEFORE_HEADER;
72: 	} else if (checkpoint_abort == "after_free_list_write") {
73: 		config.options.checkpoint_abort = CheckpointAbort::DEBUG_ABORT_AFTER_FREE_LIST_WRITE;
74: 	} else {
75: 		throw ParserException(
76: 		    "Unrecognized option for PRAGMA debug_checkpoint_abort, expected none, before_truncate or before_header");
77: 	}
78: }
79: 
80: Value DebugCheckpointAbort::GetSetting(ClientContext &context) {
81: 	return Value();
82: }
83: 
84: //===--------------------------------------------------------------------===//
85: // Debug Force External
86: //===--------------------------------------------------------------------===//
87: void DebugForceExternal::SetLocal(ClientContext &context, const Value &input) {
88: 	ClientConfig::GetConfig(context).force_external = input.GetValue<bool>();
89: }
90: 
91: Value DebugForceExternal::GetSetting(ClientContext &context) {
92: 	return Value::BOOLEAN(ClientConfig::GetConfig(context).force_external);
93: }
94: 
95: //===--------------------------------------------------------------------===//
96: // Debug Force NoCrossProduct
97: //===--------------------------------------------------------------------===//
98: void DebugForceNoCrossProduct::SetLocal(ClientContext &context, const Value &input) {
99: 	ClientConfig::GetConfig(context).force_no_cross_product = input.GetValue<bool>();
100: }
101: 
102: Value DebugForceNoCrossProduct::GetSetting(ClientContext &context) {
103: 	return Value::BOOLEAN(ClientConfig::GetConfig(context).force_no_cross_product);
104: }
105: 
106: //===--------------------------------------------------------------------===//
107: // Debug Many Free List blocks
108: //===--------------------------------------------------------------------===//
109: void DebugManyFreeListBlocks::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
110: 	config.options.debug_many_free_list_blocks = input.GetValue<bool>();
111: }
112: 
113: Value DebugManyFreeListBlocks::GetSetting(ClientContext &context) {
114: 	auto &config = DBConfig::GetConfig(context);
115: 	return Value::BOOLEAN(config.options.debug_many_free_list_blocks);
116: }
117: 
118: //===--------------------------------------------------------------------===//
119: // Debug Window Mode
120: //===--------------------------------------------------------------------===//
121: void DebugWindowMode::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
122: 	auto param = StringUtil::Lower(input.ToString());
123: 	if (param == "window") {
124: 		config.options.window_mode = WindowAggregationMode::WINDOW;
125: 	} else if (param == "combine") {
126: 		config.options.window_mode = WindowAggregationMode::COMBINE;
127: 	} else if (param == "separate") {
128: 		config.options.window_mode = WindowAggregationMode::SEPARATE;
129: 	} else {
130: 		throw ParserException("Unrecognized option for PRAGMA debug_window_mode, expected window, combine or separate");
131: 	}
132: }
133: 
134: Value DebugWindowMode::GetSetting(ClientContext &context) {
135: 	return Value();
136: }
137: 
138: //===--------------------------------------------------------------------===//
139: // Default Collation
140: //===--------------------------------------------------------------------===//
141: void DefaultCollationSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
142: 	auto parameter = StringUtil::Lower(input.ToString());
143: 	config.options.collation = parameter;
144: }
145: 
146: void DefaultCollationSetting::SetLocal(ClientContext &context, const Value &input) {
147: 	auto parameter = input.ToString();
148: 	// bind the collation to verify that it exists
149: 	ExpressionBinder::TestCollation(context, parameter);
150: 	auto &config = DBConfig::GetConfig(context);
151: 	config.options.collation = parameter;
152: }
153: 
154: Value DefaultCollationSetting::GetSetting(ClientContext &context) {
155: 	auto &config = DBConfig::GetConfig(context);
156: 	return Value(config.options.collation);
157: }
158: 
159: //===--------------------------------------------------------------------===//
160: // Default Order
161: //===--------------------------------------------------------------------===//
162: void DefaultOrderSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
163: 	auto parameter = StringUtil::Lower(input.ToString());
164: 	if (parameter == "ascending" || parameter == "asc") {
165: 		config.options.default_order_type = OrderType::ASCENDING;
166: 	} else if (parameter == "descending" || parameter == "desc") {
167: 		config.options.default_order_type = OrderType::DESCENDING;
168: 	} else {
169: 		throw InvalidInputException("Unrecognized parameter for option DEFAULT_ORDER \"%s\". Expected ASC or DESC.",
170: 		                            parameter);
171: 	}
172: }
173: 
174: Value DefaultOrderSetting::GetSetting(ClientContext &context) {
175: 	auto &config = DBConfig::GetConfig(context);
176: 	switch (config.options.default_order_type) {
177: 	case OrderType::ASCENDING:
178: 		return "asc";
179: 	case OrderType::DESCENDING:
180: 		return "desc";
181: 	default:
182: 		throw InternalException("Unknown order type setting");
183: 	}
184: }
185: 
186: //===--------------------------------------------------------------------===//
187: // Default Null Order
188: //===--------------------------------------------------------------------===//
189: void DefaultNullOrderSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
190: 	auto parameter = StringUtil::Lower(input.ToString());
191: 
192: 	if (parameter == "nulls_first" || parameter == "nulls first" || parameter == "null first" || parameter == "first") {
193: 		config.options.default_null_order = OrderByNullType::NULLS_FIRST;
194: 	} else if (parameter == "nulls_last" || parameter == "nulls last" || parameter == "null last" ||
195: 	           parameter == "last") {
196: 		config.options.default_null_order = OrderByNullType::NULLS_LAST;
197: 	} else {
198: 		throw ParserException(
199: 		    "Unrecognized parameter for option NULL_ORDER \"%s\", expected either NULLS FIRST or NULLS LAST",
200: 		    parameter);
201: 	}
202: }
203: 
204: Value DefaultNullOrderSetting::GetSetting(ClientContext &context) {
205: 	auto &config = DBConfig::GetConfig(context);
206: 	switch (config.options.default_null_order) {
207: 	case OrderByNullType::NULLS_FIRST:
208: 		return "nulls_first";
209: 	case OrderByNullType::NULLS_LAST:
210: 		return "nulls_last";
211: 	default:
212: 		throw InternalException("Unknown null order setting");
213: 	}
214: }
215: 
216: //===--------------------------------------------------------------------===//
217: // Disabled Optimizer
218: //===--------------------------------------------------------------------===//
219: void DisabledOptimizersSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
220: 	auto list = StringUtil::Split(input.ToString(), ",");
221: 	set<OptimizerType> disabled_optimizers;
222: 	for (auto &entry : list) {
223: 		auto param = StringUtil::Lower(entry);
224: 		StringUtil::Trim(param);
225: 		if (param.empty()) {
226: 			continue;
227: 		}
228: 		disabled_optimizers.insert(OptimizerTypeFromString(param));
229: 	}
230: 	config.options.disabled_optimizers = move(disabled_optimizers);
231: }
232: 
233: Value DisabledOptimizersSetting::GetSetting(ClientContext &context) {
234: 	auto &config = DBConfig::GetConfig(context);
235: 	string result;
236: 	for (auto &optimizer : config.options.disabled_optimizers) {
237: 		if (!result.empty()) {
238: 			result += ",";
239: 		}
240: 		result += OptimizerTypeToString(optimizer);
241: 	}
242: 	return Value(result);
243: }
244: 
245: //===--------------------------------------------------------------------===//
246: // Enable External Access
247: //===--------------------------------------------------------------------===//
248: void EnableExternalAccessSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
249: 	auto new_value = input.GetValue<bool>();
250: 	if (db && new_value) {
251: 		throw InvalidInputException("Cannot change enable_external_access setting while database is running");
252: 	}
253: 	config.options.enable_external_access = new_value;
254: }
255: 
256: Value EnableExternalAccessSetting::GetSetting(ClientContext &context) {
257: 	auto &config = DBConfig::GetConfig(context);
258: 	return Value::BOOLEAN(config.options.enable_external_access);
259: }
260: 
261: //===--------------------------------------------------------------------===//
262: // Enable FSST Vectors
263: //===--------------------------------------------------------------------===//
264: void EnableFSSTVectors::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
265: 	config.options.enable_fsst_vectors = input.GetValue<bool>();
266: }
267: 
268: Value EnableFSSTVectors::GetSetting(ClientContext &context) {
269: 	auto &config = DBConfig::GetConfig(context);
270: 	return Value::BOOLEAN(config.options.enable_fsst_vectors);
271: }
272: 
273: //===--------------------------------------------------------------------===//
274: // Allow Unsigned Extensions
275: //===--------------------------------------------------------------------===//
276: void AllowUnsignedExtensionsSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
277: 	auto new_value = input.GetValue<bool>();
278: 	if (db && new_value) {
279: 		throw InvalidInputException("Cannot change allow_unsigned_extensions setting while database is running");
280: 	}
281: 	config.options.allow_unsigned_extensions = new_value;
282: }
283: 
284: Value AllowUnsignedExtensionsSetting::GetSetting(ClientContext &context) {
285: 	auto &config = DBConfig::GetConfig(context);
286: 	return Value::BOOLEAN(config.options.allow_unsigned_extensions);
287: }
288: 
289: //===--------------------------------------------------------------------===//
290: // Enable Object Cache
291: //===--------------------------------------------------------------------===//
292: void EnableObjectCacheSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
293: 	config.options.object_cache_enable = input.GetValue<bool>();
294: }
295: 
296: Value EnableObjectCacheSetting::GetSetting(ClientContext &context) {
297: 	auto &config = DBConfig::GetConfig(context);
298: 	return Value::BOOLEAN(config.options.object_cache_enable);
299: }
300: 
301: //===--------------------------------------------------------------------===//
302: // Enable Profiling
303: //===--------------------------------------------------------------------===//
304: void EnableProfilingSetting::SetLocal(ClientContext &context, const Value &input) {
305: 	auto parameter = StringUtil::Lower(input.ToString());
306: 
307: 	auto &config = ClientConfig::GetConfig(context);
308: 	if (parameter == "json") {
309: 		config.profiler_print_format = ProfilerPrintFormat::JSON;
310: 	} else if (parameter == "query_tree") {
311: 		config.profiler_print_format = ProfilerPrintFormat::QUERY_TREE;
312: 	} else if (parameter == "query_tree_optimizer") {
313: 		config.profiler_print_format = ProfilerPrintFormat::QUERY_TREE_OPTIMIZER;
314: 	} else {
315: 		throw ParserException(
316: 		    "Unrecognized print format %s, supported formats: [json, query_tree, query_tree_optimizer]", parameter);
317: 	}
318: 	config.enable_profiler = true;
319: 	config.emit_profiler_output = true;
320: }
321: 
322: Value EnableProfilingSetting::GetSetting(ClientContext &context) {
323: 	auto &config = ClientConfig::GetConfig(context);
324: 	if (!config.enable_profiler) {
325: 		return Value();
326: 	}
327: 	switch (config.profiler_print_format) {
328: 	case ProfilerPrintFormat::JSON:
329: 		return Value("json");
330: 	case ProfilerPrintFormat::QUERY_TREE:
331: 		return Value("query_tree");
332: 	case ProfilerPrintFormat::QUERY_TREE_OPTIMIZER:
333: 		return Value("query_tree_optimizer");
334: 	default:
335: 		throw InternalException("Unsupported profiler print format");
336: 	}
337: }
338: 
339: //===--------------------------------------------------------------------===//
340: // Enable Progress Bar
341: //===--------------------------------------------------------------------===//
342: void EnableProgressBarSetting::SetLocal(ClientContext &context, const Value &input) {
343: 	ClientConfig::GetConfig(context).enable_progress_bar = input.GetValue<bool>();
344: }
345: 
346: Value EnableProgressBarSetting::GetSetting(ClientContext &context) {
347: 	return Value::BOOLEAN(ClientConfig::GetConfig(context).enable_progress_bar);
348: }
349: 
350: //===--------------------------------------------------------------------===//
351: // Explain Output
352: //===--------------------------------------------------------------------===//
353: void ExplainOutputSetting::SetLocal(ClientContext &context, const Value &input) {
354: 	auto parameter = StringUtil::Lower(input.ToString());
355: 	if (parameter == "all") {
356: 		ClientConfig::GetConfig(context).explain_output_type = ExplainOutputType::ALL;
357: 	} else if (parameter == "optimized_only") {
358: 		ClientConfig::GetConfig(context).explain_output_type = ExplainOutputType::OPTIMIZED_ONLY;
359: 	} else if (parameter == "physical_only") {
360: 		ClientConfig::GetConfig(context).explain_output_type = ExplainOutputType::PHYSICAL_ONLY;
361: 	} else {
362: 		throw ParserException("Unrecognized output type \"%s\", expected either ALL, OPTIMIZED_ONLY or PHYSICAL_ONLY",
363: 		                      parameter);
364: 	}
365: }
366: 
367: Value ExplainOutputSetting::GetSetting(ClientContext &context) {
368: 	switch (ClientConfig::GetConfig(context).explain_output_type) {
369: 	case ExplainOutputType::ALL:
370: 		return "all";
371: 	case ExplainOutputType::OPTIMIZED_ONLY:
372: 		return "optimized_only";
373: 	case ExplainOutputType::PHYSICAL_ONLY:
374: 		return "physical_only";
375: 	default:
376: 		throw InternalException("Unrecognized explain output type");
377: 	}
378: }
379: 
380: //===--------------------------------------------------------------------===//
381: // External Threads Setting
382: //===--------------------------------------------------------------------===//
383: void ExternalThreadsSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
384: 	config.options.external_threads = input.GetValue<int64_t>();
385: }
386: 
387: Value ExternalThreadsSetting::GetSetting(ClientContext &context) {
388: 	auto &config = DBConfig::GetConfig(context);
389: 	return Value::BIGINT(config.options.external_threads);
390: }
391: 
392: //===--------------------------------------------------------------------===//
393: // File Search Path
394: //===--------------------------------------------------------------------===//
395: void FileSearchPathSetting::SetLocal(ClientContext &context, const Value &input) {
396: 	auto parameter = input.ToString();
397: 	auto &client_data = ClientData::Get(context);
398: 	client_data.file_search_path = parameter;
399: }
400: 
401: Value FileSearchPathSetting::GetSetting(ClientContext &context) {
402: 	auto &client_data = ClientData::Get(context);
403: 	return Value(client_data.file_search_path);
404: }
405: 
406: //===--------------------------------------------------------------------===//
407: // Force Compression
408: //===--------------------------------------------------------------------===//
409: void ForceCompressionSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
410: 	auto compression = StringUtil::Lower(input.ToString());
411: 	if (compression == "none") {
412: 		config.options.force_compression = CompressionType::COMPRESSION_AUTO;
413: 	} else {
414: 		auto compression_type = CompressionTypeFromString(compression);
415: 		if (compression_type == CompressionType::COMPRESSION_AUTO) {
416: 			throw ParserException("Unrecognized option for PRAGMA force_compression, expected none, uncompressed, rle, "
417: 			                      "dictionary, pfor, bitpacking or fsst");
418: 		}
419: 		config.options.force_compression = compression_type;
420: 	}
421: }
422: 
423: Value ForceCompressionSetting::GetSetting(ClientContext &context) {
424: 	return Value();
425: }
426: 
427: //===--------------------------------------------------------------------===//
428: // Home Directory
429: //===--------------------------------------------------------------------===//
430: void HomeDirectorySetting::SetLocal(ClientContext &context, const Value &input) {
431: 	auto &config = ClientConfig::GetConfig(context);
432: 	config.home_directory = input.IsNull() ? string() : input.ToString();
433: }
434: 
435: Value HomeDirectorySetting::GetSetting(ClientContext &context) {
436: 	auto &config = ClientConfig::GetConfig(context);
437: 	return Value(config.home_directory);
438: }
439: 
440: //===--------------------------------------------------------------------===//
441: // Log Query Path
442: //===--------------------------------------------------------------------===//
443: void LogQueryPathSetting::SetLocal(ClientContext &context, const Value &input) {
444: 	auto &client_data = ClientData::Get(context);
445: 	auto path = input.ToString();
446: 	if (path.empty()) {
447: 		// empty path: clean up query writer
448: 		client_data.log_query_writer = nullptr;
449: 	} else {
450: 		client_data.log_query_writer =
451: 		    make_unique<BufferedFileWriter>(FileSystem::GetFileSystem(context), path,
452: 		                                    BufferedFileWriter::DEFAULT_OPEN_FLAGS, client_data.file_opener.get());
453: 	}
454: }
455: 
456: Value LogQueryPathSetting::GetSetting(ClientContext &context) {
457: 	auto &client_data = ClientData::Get(context);
458: 	return client_data.log_query_writer ? Value(client_data.log_query_writer->path) : Value();
459: }
460: 
461: //===--------------------------------------------------------------------===//
462: // Maximum Expression Depth
463: //===--------------------------------------------------------------------===//
464: void MaximumExpressionDepthSetting::SetLocal(ClientContext &context, const Value &input) {
465: 	ClientConfig::GetConfig(context).max_expression_depth = input.GetValue<uint64_t>();
466: }
467: 
468: Value MaximumExpressionDepthSetting::GetSetting(ClientContext &context) {
469: 	return Value::UBIGINT(ClientConfig::GetConfig(context).max_expression_depth);
470: }
471: 
472: //===--------------------------------------------------------------------===//
473: // Maximum Memory
474: //===--------------------------------------------------------------------===//
475: void MaximumMemorySetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
476: 	config.options.maximum_memory = DBConfig::ParseMemoryLimit(input.ToString());
477: 	if (db) {
478: 		BufferManager::GetBufferManager(*db).SetLimit(config.options.maximum_memory);
479: 	}
480: }
481: 
482: Value MaximumMemorySetting::GetSetting(ClientContext &context) {
483: 	auto &config = DBConfig::GetConfig(context);
484: 	return Value(StringUtil::BytesToHumanReadableString(config.options.maximum_memory));
485: }
486: 
487: //===--------------------------------------------------------------------===//
488: // Perfect Hash Threshold
489: //===--------------------------------------------------------------------===//
490: void PerfectHashThresholdSetting::SetLocal(ClientContext &context, const Value &input) {
491: 	auto bits = input.GetValue<int32_t>();
492: 	if (bits < 0 || bits > 32) {
493: 		throw ParserException("Perfect HT threshold out of range: should be within range 0 - 32");
494: 	}
495: 	ClientConfig::GetConfig(context).perfect_ht_threshold = bits;
496: }
497: 
498: Value PerfectHashThresholdSetting::GetSetting(ClientContext &context) {
499: 	return Value::BIGINT(ClientConfig::GetConfig(context).perfect_ht_threshold);
500: }
501: 
502: //===--------------------------------------------------------------------===//
503: // PreserveIdentifierCase
504: //===--------------------------------------------------------------------===//
505: void PreserveIdentifierCase::SetLocal(ClientContext &context, const Value &input) {
506: 	ClientConfig::GetConfig(context).preserve_identifier_case = input.GetValue<bool>();
507: }
508: 
509: Value PreserveIdentifierCase::GetSetting(ClientContext &context) {
510: 	return Value::BOOLEAN(ClientConfig::GetConfig(context).preserve_identifier_case);
511: }
512: 
513: //===--------------------------------------------------------------------===//
514: // PreserveInsertionOrder
515: //===--------------------------------------------------------------------===//
516: void PreserveInsertionOrder::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
517: 	config.options.preserve_insertion_order = input.GetValue<bool>();
518: }
519: 
520: Value PreserveInsertionOrder::GetSetting(ClientContext &context) {
521: 	auto &config = DBConfig::GetConfig(context);
522: 	return Value::BOOLEAN(config.options.preserve_insertion_order);
523: }
524: 
525: //===--------------------------------------------------------------------===//
526: // Profiler History Size
527: //===--------------------------------------------------------------------===//
528: void ProfilerHistorySize::SetLocal(ClientContext &context, const Value &input) {
529: 	auto size = input.GetValue<int64_t>();
530: 	if (size <= 0) {
531: 		throw ParserException("Size should be >= 0");
532: 	}
533: 	auto &client_data = ClientData::Get(context);
534: 	client_data.query_profiler_history->SetProfilerHistorySize(size);
535: }
536: 
537: Value ProfilerHistorySize::GetSetting(ClientContext &context) {
538: 	return Value();
539: }
540: 
541: //===--------------------------------------------------------------------===//
542: // Profile Output
543: //===--------------------------------------------------------------------===//
544: void ProfileOutputSetting::SetLocal(ClientContext &context, const Value &input) {
545: 	auto &config = ClientConfig::GetConfig(context);
546: 	auto parameter = input.ToString();
547: 	config.profiler_save_location = parameter;
548: }
549: 
550: Value ProfileOutputSetting::GetSetting(ClientContext &context) {
551: 	auto &config = ClientConfig::GetConfig(context);
552: 	return Value(config.profiler_save_location);
553: }
554: 
555: //===--------------------------------------------------------------------===//
556: // Profiling Mode
557: //===--------------------------------------------------------------------===//
558: void ProfilingModeSetting::SetLocal(ClientContext &context, const Value &input) {
559: 	auto parameter = StringUtil::Lower(input.ToString());
560: 	auto &config = ClientConfig::GetConfig(context);
561: 	if (parameter == "standard") {
562: 		config.enable_profiler = true;
563: 		config.enable_detailed_profiling = false;
564: 		config.emit_profiler_output = true;
565: 	} else if (parameter == "detailed") {
566: 		config.enable_profiler = true;
567: 		config.enable_detailed_profiling = true;
568: 		config.emit_profiler_output = true;
569: 	} else {
570: 		throw ParserException("Unrecognized profiling mode \"%s\", supported formats: [standard, detailed]", parameter);
571: 	}
572: }
573: 
574: Value ProfilingModeSetting::GetSetting(ClientContext &context) {
575: 	auto &config = ClientConfig::GetConfig(context);
576: 	if (!config.enable_profiler) {
577: 		return Value();
578: 	}
579: 	return Value(config.enable_detailed_profiling ? "detailed" : "standard");
580: }
581: 
582: //===--------------------------------------------------------------------===//
583: // Progress Bar Time
584: //===--------------------------------------------------------------------===//
585: void ProgressBarTimeSetting::SetLocal(ClientContext &context, const Value &input) {
586: 	ClientConfig::GetConfig(context).wait_time = input.GetValue<int32_t>();
587: 	ClientConfig::GetConfig(context).enable_progress_bar = true;
588: }
589: 
590: Value ProgressBarTimeSetting::GetSetting(ClientContext &context) {
591: 	return Value::BIGINT(ClientConfig::GetConfig(context).wait_time);
592: }
593: 
594: //===--------------------------------------------------------------------===//
595: // Schema
596: //===--------------------------------------------------------------------===//
597: void SchemaSetting::SetLocal(ClientContext &context, const Value &input) {
598: 	auto parameter = input.ToString();
599: 	auto &client_data = ClientData::Get(context);
600: 	client_data.catalog_search_path->Set(parameter, true);
601: }
602: 
603: Value SchemaSetting::GetSetting(ClientContext &context) {
604: 	return SearchPathSetting::GetSetting(context);
605: }
606: 
607: //===--------------------------------------------------------------------===//
608: // Search Path
609: //===--------------------------------------------------------------------===//
610: void SearchPathSetting::SetLocal(ClientContext &context, const Value &input) {
611: 	auto parameter = input.ToString();
612: 	auto &client_data = ClientData::Get(context);
613: 	client_data.catalog_search_path->Set(parameter, false);
614: }
615: 
616: Value SearchPathSetting::GetSetting(ClientContext &context) {
617: 	auto &client_data = ClientData::Get(context);
618: 	return Value(StringUtil::Join(client_data.catalog_search_path->GetSetPaths(), ","));
619: }
620: 
621: //===--------------------------------------------------------------------===//
622: // Temp Directory
623: //===--------------------------------------------------------------------===//
624: void TempDirectorySetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
625: 	config.options.temporary_directory = input.ToString();
626: 	config.options.use_temporary_directory = !config.options.temporary_directory.empty();
627: 	if (db) {
628: 		auto &buffer_manager = BufferManager::GetBufferManager(*db);
629: 		buffer_manager.SetTemporaryDirectory(config.options.temporary_directory);
630: 	}
631: }
632: 
633: Value TempDirectorySetting::GetSetting(ClientContext &context) {
634: 	auto &buffer_manager = BufferManager::GetBufferManager(context);
635: 	return Value(buffer_manager.GetTemporaryDirectory());
636: }
637: 
638: //===--------------------------------------------------------------------===//
639: // Threads Setting
640: //===--------------------------------------------------------------------===//
641: void ThreadsSetting::SetGlobal(DatabaseInstance *db, DBConfig &config, const Value &input) {
642: 	config.options.maximum_threads = input.GetValue<int64_t>();
643: 	if (db) {
644: 		TaskScheduler::GetScheduler(*db).SetThreads(config.options.maximum_threads);
645: 	}
646: }
647: 
648: Value ThreadsSetting::GetSetting(ClientContext &context) {
649: 	auto &config = DBConfig::GetConfig(context);
650: 	return Value::BIGINT(config.options.maximum_threads);
651: }
652: 
653: } // namespace duckdb
[end of src/main/settings/settings.cpp]
[start of src/storage/single_file_block_manager.cpp]
1: #include "duckdb/storage/single_file_block_manager.hpp"
2: 
3: #include "duckdb/common/allocator.hpp"
4: #include "duckdb/common/exception.hpp"
5: #include "duckdb/common/serializer/buffered_deserializer.hpp"
6: #include "duckdb/common/serializer/buffered_serializer.hpp"
7: #include "duckdb/common/field_writer.hpp"
8: #include "duckdb/storage/meta_block_reader.hpp"
9: #include "duckdb/storage/meta_block_writer.hpp"
10: #include "duckdb/storage/buffer_manager.hpp"
11: #include "duckdb/main/config.hpp"
12: 
13: #include <algorithm>
14: #include <cstring>
15: 
16: namespace duckdb {
17: 
18: const char MainHeader::MAGIC_BYTES[] = "DUCK";
19: 
20: void MainHeader::Serialize(Serializer &ser) {
21: 	ser.WriteData((data_ptr_t)MAGIC_BYTES, MAGIC_BYTE_SIZE);
22: 	ser.Write<uint64_t>(version_number);
23: 	FieldWriter writer(ser);
24: 	for (idx_t i = 0; i < FLAG_COUNT; i++) {
25: 		writer.WriteField<uint64_t>(flags[i]);
26: 	}
27: 	writer.Finalize();
28: }
29: 
30: void MainHeader::CheckMagicBytes(FileHandle &handle) {
31: 	data_t magic_bytes[MAGIC_BYTE_SIZE];
32: 	if (handle.GetFileSize() < MainHeader::MAGIC_BYTE_SIZE + MainHeader::MAGIC_BYTE_OFFSET) {
33: 		throw IOException("The file is not a valid DuckDB database file!");
34: 	}
35: 	handle.Read(magic_bytes, MainHeader::MAGIC_BYTE_SIZE, MainHeader::MAGIC_BYTE_OFFSET);
36: 	if (memcmp(magic_bytes, MainHeader::MAGIC_BYTES, MainHeader::MAGIC_BYTE_SIZE) != 0) {
37: 		throw IOException("The file is not a valid DuckDB database file!");
38: 	}
39: }
40: 
41: MainHeader MainHeader::Deserialize(Deserializer &source) {
42: 	data_t magic_bytes[MAGIC_BYTE_SIZE];
43: 	MainHeader header;
44: 	source.ReadData(magic_bytes, MainHeader::MAGIC_BYTE_SIZE);
45: 	if (memcmp(magic_bytes, MainHeader::MAGIC_BYTES, MainHeader::MAGIC_BYTE_SIZE) != 0) {
46: 		throw IOException("The file is not a valid DuckDB database file!");
47: 	}
48: 	header.version_number = source.Read<uint64_t>();
49: 	// read the flags
50: 	FieldReader reader(source);
51: 	for (idx_t i = 0; i < FLAG_COUNT; i++) {
52: 		header.flags[i] = reader.ReadRequired<uint64_t>();
53: 	}
54: 	reader.Finalize();
55: 	return header;
56: }
57: 
58: void DatabaseHeader::Serialize(Serializer &ser) {
59: 	ser.Write<uint64_t>(iteration);
60: 	ser.Write<block_id_t>(meta_block);
61: 	ser.Write<block_id_t>(free_list);
62: 	ser.Write<uint64_t>(block_count);
63: }
64: 
65: DatabaseHeader DatabaseHeader::Deserialize(Deserializer &source) {
66: 	DatabaseHeader header;
67: 	header.iteration = source.Read<uint64_t>();
68: 	header.meta_block = source.Read<block_id_t>();
69: 	header.free_list = source.Read<block_id_t>();
70: 	header.block_count = source.Read<uint64_t>();
71: 	return header;
72: }
73: 
74: template <class T>
75: void SerializeHeaderStructure(T header, data_ptr_t ptr) {
76: 	BufferedSerializer ser(ptr, Storage::FILE_HEADER_SIZE);
77: 	header.Serialize(ser);
78: }
79: 
80: template <class T>
81: T DeserializeHeaderStructure(data_ptr_t ptr) {
82: 	BufferedDeserializer source(ptr, Storage::FILE_HEADER_SIZE);
83: 	return T::Deserialize(source);
84: }
85: 
86: SingleFileBlockManager::SingleFileBlockManager(DatabaseInstance &db, string path_p, bool read_only, bool create_new,
87:                                                bool use_direct_io)
88:     : BlockManager(BufferManager::GetBufferManager(db)), db(db), path(move(path_p)),
89:       header_buffer(Allocator::Get(db), FileBufferType::MANAGED_BUFFER,
90:                     Storage::FILE_HEADER_SIZE - Storage::BLOCK_HEADER_SIZE),
91:       iteration_count(0), read_only(read_only), use_direct_io(use_direct_io) {
92: 	uint8_t flags;
93: 	FileLockType lock;
94: 	if (read_only) {
95: 		D_ASSERT(!create_new);
96: 		flags = FileFlags::FILE_FLAGS_READ;
97: 		lock = FileLockType::READ_LOCK;
98: 	} else {
99: 		flags = FileFlags::FILE_FLAGS_WRITE | FileFlags::FILE_FLAGS_READ;
100: 		lock = FileLockType::WRITE_LOCK;
101: 		if (create_new) {
102: 			flags |= FileFlags::FILE_FLAGS_FILE_CREATE;
103: 		}
104: 	}
105: 	if (use_direct_io) {
106: 		flags |= FileFlags::FILE_FLAGS_DIRECT_IO;
107: 	}
108: 	// open the RDBMS handle
109: 	auto &fs = FileSystem::GetFileSystem(db);
110: 	handle = fs.OpenFile(path, flags, lock);
111: 	if (create_new) {
112: 		// if we create a new file, we fill the metadata of the file
113: 		// first fill in the new header
114: 		header_buffer.Clear();
115: 
116: 		MainHeader main_header;
117: 		main_header.version_number = VERSION_NUMBER;
118: 		memset(main_header.flags, 0, sizeof(uint64_t) * 4);
119: 
120: 		SerializeHeaderStructure<MainHeader>(main_header, header_buffer.buffer);
121: 		// now write the header to the file
122: 		header_buffer.ChecksumAndWrite(*handle, 0);
123: 		header_buffer.Clear();
124: 
125: 		// write the database headers
126: 		// initialize meta_block and free_list to INVALID_BLOCK because the database file does not contain any actual
127: 		// content yet
128: 		DatabaseHeader h1, h2;
129: 		// header 1
130: 		h1.iteration = 0;
131: 		h1.meta_block = INVALID_BLOCK;
132: 		h1.free_list = INVALID_BLOCK;
133: 		h1.block_count = 0;
134: 		SerializeHeaderStructure<DatabaseHeader>(h1, header_buffer.buffer);
135: 		header_buffer.ChecksumAndWrite(*handle, Storage::FILE_HEADER_SIZE);
136: 		// header 2
137: 		h2.iteration = 0;
138: 		h2.meta_block = INVALID_BLOCK;
139: 		h2.free_list = INVALID_BLOCK;
140: 		h2.block_count = 0;
141: 		SerializeHeaderStructure<DatabaseHeader>(h2, header_buffer.buffer);
142: 		header_buffer.ChecksumAndWrite(*handle, Storage::FILE_HEADER_SIZE * 2);
143: 		// ensure that writing to disk is completed before returning
144: 		handle->Sync();
145: 		// we start with h2 as active_header, this way our initial write will be in h1
146: 		iteration_count = 0;
147: 		active_header = 1;
148: 		max_block = 0;
149: 	} else {
150: 		MainHeader::CheckMagicBytes(*handle);
151: 		// otherwise, we check the metadata of the file
152: 		header_buffer.ReadAndChecksum(*handle, 0);
153: 		MainHeader header = DeserializeHeaderStructure<MainHeader>(header_buffer.buffer);
154: 		// check the version number
155: 		if (header.version_number != VERSION_NUMBER) {
156: 			throw IOException(
157: 			    "Trying to read a database file with version number %lld, but we can only read version %lld.\n"
158: 			    "The database file was created with an %s version of DuckDB.\n\n"
159: 			    "The storage of DuckDB is not yet stable; newer versions of DuckDB cannot read old database files and "
160: 			    "vice versa.\n"
161: 			    "The storage will be stabilized when version 1.0 releases.\n\n"
162: 			    "For now, we recommend that you load the database file in a supported version of DuckDB, and use the "
163: 			    "EXPORT DATABASE command "
164: 			    "followed by IMPORT DATABASE on the current version of DuckDB.",
165: 			    header.version_number, VERSION_NUMBER, VERSION_NUMBER > header.version_number ? "older" : "newer");
166: 		}
167: 
168: 		// read the database headers from disk
169: 		DatabaseHeader h1, h2;
170: 		header_buffer.ReadAndChecksum(*handle, Storage::FILE_HEADER_SIZE);
171: 		h1 = DeserializeHeaderStructure<DatabaseHeader>(header_buffer.buffer);
172: 		header_buffer.ReadAndChecksum(*handle, Storage::FILE_HEADER_SIZE * 2);
173: 		h2 = DeserializeHeaderStructure<DatabaseHeader>(header_buffer.buffer);
174: 		// check the header with the highest iteration count
175: 		if (h1.iteration > h2.iteration) {
176: 			// h1 is active header
177: 			active_header = 0;
178: 			Initialize(h1);
179: 		} else {
180: 			// h2 is active header
181: 			active_header = 1;
182: 			Initialize(h2);
183: 		}
184: 		LoadFreeList();
185: 	}
186: }
187: 
188: void SingleFileBlockManager::Initialize(DatabaseHeader &header) {
189: 	free_list_id = header.free_list;
190: 	meta_block = header.meta_block;
191: 	iteration_count = header.iteration;
192: 	max_block = header.block_count;
193: }
194: 
195: void SingleFileBlockManager::LoadFreeList() {
196: 	if (read_only) {
197: 		// no need to load free list for read only db
198: 		return;
199: 	}
200: 	if (free_list_id == INVALID_BLOCK) {
201: 		// no free list
202: 		return;
203: 	}
204: 	MetaBlockReader reader(*this, free_list_id);
205: 	auto free_list_count = reader.Read<uint64_t>();
206: 	free_list.clear();
207: 	for (idx_t i = 0; i < free_list_count; i++) {
208: 		free_list.insert(reader.Read<block_id_t>());
209: 	}
210: 	auto multi_use_blocks_count = reader.Read<uint64_t>();
211: 	multi_use_blocks.clear();
212: 	for (idx_t i = 0; i < multi_use_blocks_count; i++) {
213: 		auto block_id = reader.Read<block_id_t>();
214: 		auto usage_count = reader.Read<uint32_t>();
215: 		multi_use_blocks[block_id] = usage_count;
216: 	}
217: }
218: 
219: bool SingleFileBlockManager::IsRootBlock(block_id_t root) {
220: 	return root == meta_block;
221: }
222: 
223: block_id_t SingleFileBlockManager::GetFreeBlockId() {
224: 	lock_guard<mutex> lock(block_lock);
225: 	block_id_t block;
226: 	if (!free_list.empty()) {
227: 		// free list is non empty
228: 		// take an entry from the free list
229: 		block = *free_list.begin();
230: 		// erase the entry from the free list again
231: 		free_list.erase(free_list.begin());
232: 	} else {
233: 		block = max_block++;
234: 	}
235: 	return block;
236: }
237: 
238: void SingleFileBlockManager::MarkBlockAsModified(block_id_t block_id) {
239: 	lock_guard<mutex> lock(block_lock);
240: 	D_ASSERT(block_id >= 0);
241: 
242: 	// check if the block is a multi-use block
243: 	auto entry = multi_use_blocks.find(block_id);
244: 	if (entry != multi_use_blocks.end()) {
245: 		// it is! reduce the reference count of the block
246: 		entry->second--;
247: 		// check the reference count: is the block still a multi-use block?
248: 		if (entry->second <= 1) {
249: 			// no longer a multi-use block!
250: 			multi_use_blocks.erase(entry);
251: 		}
252: 		return;
253: 	}
254: 	// Check for multi-free
255: 	// TODO: Fix the bug that causes this assert to fire, then uncomment it.
256: 	// D_ASSERT(modified_blocks.find(block_id) == modified_blocks.end());
257: 	D_ASSERT(free_list.find(block_id) == free_list.end());
258: 	modified_blocks.insert(block_id);
259: }
260: 
261: void SingleFileBlockManager::IncreaseBlockReferenceCount(block_id_t block_id) {
262: 	lock_guard<mutex> lock(block_lock);
263: 	D_ASSERT(free_list.find(block_id) == free_list.end());
264: 	auto entry = multi_use_blocks.find(block_id);
265: 	if (entry != multi_use_blocks.end()) {
266: 		entry->second++;
267: 	} else {
268: 		multi_use_blocks[block_id] = 2;
269: 	}
270: }
271: 
272: block_id_t SingleFileBlockManager::GetMetaBlock() {
273: 	return meta_block;
274: }
275: 
276: idx_t SingleFileBlockManager::TotalBlocks() {
277: 	lock_guard<mutex> lock(block_lock);
278: 	return max_block;
279: }
280: 
281: idx_t SingleFileBlockManager::FreeBlocks() {
282: 	lock_guard<mutex> lock(block_lock);
283: 	return free_list.size();
284: }
285: 
286: unique_ptr<Block> SingleFileBlockManager::CreateBlock(block_id_t block_id, FileBuffer *source_buffer) {
287: 	if (source_buffer) {
288: 		D_ASSERT(source_buffer->AllocSize() == Storage::BLOCK_ALLOC_SIZE);
289: 		return make_unique<Block>(*source_buffer, block_id);
290: 	} else {
291: 		return make_unique<Block>(Allocator::Get(db), block_id);
292: 	}
293: }
294: 
295: void SingleFileBlockManager::Read(Block &block) {
296: 	D_ASSERT(block.id >= 0);
297: 	D_ASSERT(std::find(free_list.begin(), free_list.end(), block.id) == free_list.end());
298: 	block.ReadAndChecksum(*handle, BLOCK_START + block.id * Storage::BLOCK_ALLOC_SIZE);
299: }
300: 
301: void SingleFileBlockManager::Write(FileBuffer &buffer, block_id_t block_id) {
302: 	D_ASSERT(block_id >= 0);
303: 	buffer.ChecksumAndWrite(*handle, BLOCK_START + block_id * Storage::BLOCK_ALLOC_SIZE);
304: }
305: 
306: vector<block_id_t> SingleFileBlockManager::GetFreeListBlocks() {
307: 	vector<block_id_t> free_list_blocks;
308: 
309: 	if (!free_list.empty() || !multi_use_blocks.empty() || !modified_blocks.empty()) {
310: 		// there are blocks in the free list or multi_use_blocks
311: 		// figure out how many blocks we need to write these to the file
312: 		auto free_list_size = sizeof(uint64_t) + sizeof(block_id_t) * (free_list.size() + modified_blocks.size());
313: 		auto multi_use_blocks_size =
314: 		    sizeof(uint64_t) + (sizeof(block_id_t) + sizeof(uint32_t)) * multi_use_blocks.size();
315: 		auto total_size = free_list_size + multi_use_blocks_size;
316: 		// because of potential alignment issues and needing to store a next pointer in a block we subtract
317: 		// a bit from the max block size
318: 		auto space_in_block = Storage::BLOCK_SIZE - 4 * sizeof(block_id_t);
319: 		auto total_blocks = (total_size + space_in_block - 1) / space_in_block;
320: 		auto &config = DBConfig::GetConfig(db);
321: 		if (config.options.debug_many_free_list_blocks) {
322: 			total_blocks++;
323: 		}
324: 		D_ASSERT(total_size > 0);
325: 		D_ASSERT(total_blocks > 0);
326: 
327: 		// reserve the blocks that we are going to write
328: 		// since these blocks are no longer free we cannot just include them in the free list!
329: 		for (idx_t i = 0; i < total_blocks; i++) {
330: 			auto block_id = GetFreeBlockId();
331: 			free_list_blocks.push_back(block_id);
332: 		}
333: 	}
334: 
335: 	return free_list_blocks;
336: }
337: 
338: class FreeListBlockWriter : public MetaBlockWriter {
339: public:
340: 	FreeListBlockWriter(BlockManager &block_manager, vector<block_id_t> &free_list_blocks_p)
341: 	    : MetaBlockWriter(block_manager, free_list_blocks_p[0]), free_list_blocks(free_list_blocks_p), index(1) {
342: 	}
343: 
344: 	vector<block_id_t> &free_list_blocks;
345: 	idx_t index;
346: 
347: protected:
348: 	block_id_t GetNextBlockId() override {
349: 		if (index >= free_list_blocks.size()) {
350: 			throw InternalException(
351: 			    "Free List Block Writer ran out of blocks, this means not enough blocks were allocated up front");
352: 		}
353: 		return free_list_blocks[index++];
354: 	}
355: };
356: 
357: void SingleFileBlockManager::WriteHeader(DatabaseHeader header) {
358: 	// set the iteration count
359: 	header.iteration = ++iteration_count;
360: 
361: 	vector<block_id_t> free_list_blocks = GetFreeListBlocks();
362: 
363: 	// now handle the free list
364: 	// add all modified blocks to the free list: they can now be written to again
365: 	for (auto &block : modified_blocks) {
366: 		free_list.insert(block);
367: 	}
368: 	modified_blocks.clear();
369: 
370: 	if (!free_list_blocks.empty()) {
371: 		// there are blocks to write, either in the free_list or in the modified_blocks
372: 		// we write these blocks specifically to the free_list_blocks
373: 		// a normal MetaBlockWriter will fetch blocks to use from the free_list
374: 		// but since we are WRITING the free_list, this behavior is sub-optimal
375: 
376: 		FreeListBlockWriter writer(*this, free_list_blocks);
377: 
378: 		auto ptr = writer.GetBlockPointer();
379: 		D_ASSERT(ptr.block_id == free_list_blocks[0]);
380: 		header.free_list = ptr.block_id;
381: 		for (auto &block_id : free_list_blocks) {
382: 			modified_blocks.insert(block_id);
383: 		}
384: 
385: 		writer.Write<uint64_t>(free_list.size());
386: 		for (auto &block_id : free_list) {
387: 			writer.Write<block_id_t>(block_id);
388: 		}
389: 		writer.Write<uint64_t>(multi_use_blocks.size());
390: 		for (auto &entry : multi_use_blocks) {
391: 			writer.Write<block_id_t>(entry.first);
392: 			writer.Write<uint32_t>(entry.second);
393: 		}
394: 		writer.Flush();
395: 	} else {
396: 		// no blocks in the free list
397: 		header.free_list = INVALID_BLOCK;
398: 	}
399: 	header.block_count = max_block;
400: 
401: 	auto &config = DBConfig::GetConfig(db);
402: 	if (config.options.checkpoint_abort == CheckpointAbort::DEBUG_ABORT_AFTER_FREE_LIST_WRITE) {
403: 		throw FatalException("Checkpoint aborted after free list write because of PRAGMA checkpoint_abort flag");
404: 	}
405: 
406: 	if (!use_direct_io) {
407: 		// if we are not using Direct IO we need to fsync BEFORE we write the header to ensure that all the previous
408: 		// blocks are written as well
409: 		handle->Sync();
410: 	}
411: 	// set the header inside the buffer
412: 	header_buffer.Clear();
413: 	Store<DatabaseHeader>(header, header_buffer.buffer);
414: 	// now write the header to the file, active_header determines whether we write to h1 or h2
415: 	// note that if active_header is h1 we write to h2, and vice versa
416: 	header_buffer.ChecksumAndWrite(*handle,
417: 	                               active_header == 1 ? Storage::FILE_HEADER_SIZE : Storage::FILE_HEADER_SIZE * 2);
418: 	// switch active header to the other header
419: 	active_header = 1 - active_header;
420: 	//! Ensure the header write ends up on disk
421: 	handle->Sync();
422: }
423: 
424: } // namespace duckdb
[end of src/storage/single_file_block_manager.cpp]
[start of src/storage/statistics/string_statistics.cpp]
1: #include "duckdb/storage/statistics/string_statistics.hpp"
2: #include "duckdb/common/field_writer.hpp"
3: #include "utf8proc_wrapper.hpp"
4: #include "duckdb/common/string_util.hpp"
5: #include "duckdb/common/types/vector.hpp"
6: 
7: namespace duckdb {
8: 
9: StringStatistics::StringStatistics(LogicalType type_p, StatisticsType stats_type)
10:     : BaseStatistics(move(type_p), stats_type) {
11: 	InitializeBase();
12: 	for (idx_t i = 0; i < MAX_STRING_MINMAX_SIZE; i++) {
13: 		min[i] = 0xFF;
14: 		max[i] = 0;
15: 	}
16: 	max_string_length = 0;
17: 	has_unicode = false;
18: 	has_overflow_strings = false;
19: }
20: 
21: unique_ptr<BaseStatistics> StringStatistics::Copy() const {
22: 	auto result = make_unique<StringStatistics>(type, stats_type);
23: 	result->CopyBase(*this);
24: 
25: 	memcpy(result->min, min, MAX_STRING_MINMAX_SIZE);
26: 	memcpy(result->max, max, MAX_STRING_MINMAX_SIZE);
27: 	result->has_unicode = has_unicode;
28: 	result->max_string_length = max_string_length;
29: 	return move(result);
30: }
31: 
32: void StringStatistics::Serialize(FieldWriter &writer) const {
33: 	writer.WriteBlob(min, MAX_STRING_MINMAX_SIZE);
34: 	writer.WriteBlob(max, MAX_STRING_MINMAX_SIZE);
35: 	writer.WriteField<bool>(has_unicode);
36: 	writer.WriteField<uint32_t>(max_string_length);
37: 	writer.WriteField<bool>(has_overflow_strings);
38: }
39: 
40: unique_ptr<BaseStatistics> StringStatistics::Deserialize(FieldReader &reader, LogicalType type) {
41: 	auto stats = make_unique<StringStatistics>(move(type), StatisticsType::LOCAL_STATS);
42: 	reader.ReadBlob(stats->min, MAX_STRING_MINMAX_SIZE);
43: 	reader.ReadBlob(stats->max, MAX_STRING_MINMAX_SIZE);
44: 	stats->has_unicode = reader.ReadRequired<bool>();
45: 	stats->max_string_length = reader.ReadRequired<uint32_t>();
46: 	stats->has_overflow_strings = reader.ReadRequired<bool>();
47: 	return move(stats);
48: }
49: 
50: static int StringValueComparison(const_data_ptr_t data, idx_t len, const_data_ptr_t comparison) {
51: 	D_ASSERT(len <= StringStatistics::MAX_STRING_MINMAX_SIZE);
52: 	for (idx_t i = 0; i < len; i++) {
53: 		if (data[i] < comparison[i]) {
54: 			return -1;
55: 		} else if (data[i] > comparison[i]) {
56: 			return 1;
57: 		}
58: 	}
59: 	return 0;
60: }
61: 
62: static void ConstructValue(const_data_ptr_t data, idx_t size, data_t target[]) {
63: 	idx_t value_size =
64: 	    size > StringStatistics::MAX_STRING_MINMAX_SIZE ? StringStatistics::MAX_STRING_MINMAX_SIZE : size;
65: 	memcpy(target, data, value_size);
66: 	for (idx_t i = value_size; i < StringStatistics::MAX_STRING_MINMAX_SIZE; i++) {
67: 		target[i] = '\0';
68: 	}
69: }
70: 
71: void StringStatistics::Update(const string_t &value) {
72: 	auto data = (const_data_ptr_t)value.GetDataUnsafe();
73: 	auto size = value.GetSize();
74: 
75: 	//! we can only fit 8 bytes, so we might need to trim our string
76: 	// construct the value
77: 	data_t target[MAX_STRING_MINMAX_SIZE];
78: 	ConstructValue(data, size, target);
79: 
80: 	// update the min and max
81: 	if (StringValueComparison(target, MAX_STRING_MINMAX_SIZE, min) < 0) {
82: 		memcpy(min, target, MAX_STRING_MINMAX_SIZE);
83: 	}
84: 	if (StringValueComparison(target, MAX_STRING_MINMAX_SIZE, max) > 0) {
85: 		memcpy(max, target, MAX_STRING_MINMAX_SIZE);
86: 	}
87: 	if (size > max_string_length) {
88: 		max_string_length = size;
89: 	}
90: 	if (type.id() == LogicalTypeId::VARCHAR && !has_unicode) {
91: 		auto unicode = Utf8Proc::Analyze((const char *)data, size);
92: 		if (unicode == UnicodeType::UNICODE) {
93: 			has_unicode = true;
94: 		} else if (unicode == UnicodeType::INVALID) {
95: 			throw InternalException("Invalid unicode detected in segment statistics update!");
96: 		}
97: 	}
98: }
99: 
100: void StringStatistics::Merge(const BaseStatistics &other_p) {
101: 	BaseStatistics::Merge(other_p);
102: 	auto &other = (const StringStatistics &)other_p;
103: 	if (StringValueComparison(other.min, MAX_STRING_MINMAX_SIZE, min) < 0) {
104: 		memcpy(min, other.min, MAX_STRING_MINMAX_SIZE);
105: 	}
106: 	if (StringValueComparison(other.max, MAX_STRING_MINMAX_SIZE, max) > 0) {
107: 		memcpy(max, other.max, MAX_STRING_MINMAX_SIZE);
108: 	}
109: 	has_unicode = has_unicode || other.has_unicode;
110: 	max_string_length = MaxValue<uint32_t>(max_string_length, other.max_string_length);
111: 	has_overflow_strings = has_overflow_strings || other.has_overflow_strings;
112: }
113: 
114: FilterPropagateResult StringStatistics::CheckZonemap(ExpressionType comparison_type, const string &constant) const {
115: 	auto data = (const_data_ptr_t)constant.c_str();
116: 	auto size = constant.size();
117: 
118: 	idx_t value_size = size > MAX_STRING_MINMAX_SIZE ? MAX_STRING_MINMAX_SIZE : size;
119: 	int min_comp = StringValueComparison(data, value_size, min);
120: 	int max_comp = StringValueComparison(data, value_size, max);
121: 	switch (comparison_type) {
122: 	case ExpressionType::COMPARE_EQUAL:
123: 		if (min_comp >= 0 && max_comp <= 0) {
124: 			return FilterPropagateResult::NO_PRUNING_POSSIBLE;
125: 		} else {
126: 			return FilterPropagateResult::FILTER_ALWAYS_FALSE;
127: 		}
128: 	case ExpressionType::COMPARE_NOTEQUAL:
129: 		if (min_comp < 0 || max_comp > 0) {
130: 			return FilterPropagateResult::FILTER_ALWAYS_TRUE;
131: 		}
132: 		return FilterPropagateResult::NO_PRUNING_POSSIBLE;
133: 	case ExpressionType::COMPARE_GREATERTHANOREQUALTO:
134: 	case ExpressionType::COMPARE_GREATERTHAN:
135: 		if (max_comp <= 0) {
136: 			return FilterPropagateResult::NO_PRUNING_POSSIBLE;
137: 		} else {
138: 			return FilterPropagateResult::FILTER_ALWAYS_FALSE;
139: 		}
140: 	case ExpressionType::COMPARE_LESSTHAN:
141: 	case ExpressionType::COMPARE_LESSTHANOREQUALTO:
142: 		if (min_comp >= 0) {
143: 			return FilterPropagateResult::NO_PRUNING_POSSIBLE;
144: 		} else {
145: 			return FilterPropagateResult::FILTER_ALWAYS_FALSE;
146: 		}
147: 	default:
148: 		throw InternalException("Expression type not implemented for string statistics zone map");
149: 	}
150: }
151: 
152: static idx_t GetValidMinMaxSubstring(const_data_ptr_t data) {
153: 	for (idx_t i = 0; i < StringStatistics::MAX_STRING_MINMAX_SIZE; i++) {
154: 		if (data[i] == '\0') {
155: 			return i;
156: 		}
157: 		if ((data[i] & 0x80) != 0) {
158: 			return i;
159: 		}
160: 	}
161: 	return StringStatistics::MAX_STRING_MINMAX_SIZE;
162: }
163: 
164: string StringStatistics::ToString() const {
165: 	idx_t min_len = GetValidMinMaxSubstring(min);
166: 	idx_t max_len = GetValidMinMaxSubstring(max);
167: 	return StringUtil::Format("[Min: %s, Max: %s, Has Unicode: %s, Max String Length: %lld]%s",
168: 	                          string((const char *)min, min_len), string((const char *)max, max_len),
169: 	                          has_unicode ? "true" : "false", max_string_length, BaseStatistics::ToString());
170: }
171: 
172: void StringStatistics::Verify(Vector &vector, const SelectionVector &sel, idx_t count) const {
173: 	BaseStatistics::Verify(vector, sel, count);
174: 
175: 	string_t min_string((const char *)min, MAX_STRING_MINMAX_SIZE);
176: 	string_t max_string((const char *)max, MAX_STRING_MINMAX_SIZE);
177: 
178: 	UnifiedVectorFormat vdata;
179: 	vector.ToUnifiedFormat(count, vdata);
180: 	auto data = (string_t *)vdata.data;
181: 	for (idx_t i = 0; i < count; i++) {
182: 		auto idx = sel.get_index(i);
183: 		auto index = vdata.sel->get_index(idx);
184: 		if (!vdata.validity.RowIsValid(index)) {
185: 			continue;
186: 		}
187: 		auto value = data[index];
188: 		auto data = value.GetDataUnsafe();
189: 		auto len = value.GetSize();
190: 		// LCOV_EXCL_START
191: 		if (len > max_string_length) {
192: 			throw InternalException(
193: 			    "Statistics mismatch: string value exceeds maximum string length.\nStatistics: %s\nVector: %s",
194: 			    ToString(), vector.ToString(count));
195: 		}
196: 		if (type.id() == LogicalTypeId::VARCHAR && !has_unicode) {
197: 			auto unicode = Utf8Proc::Analyze(data, len);
198: 			if (unicode == UnicodeType::UNICODE) {
199: 				throw InternalException("Statistics mismatch: string value contains unicode, but statistics says it "
200: 				                        "shouldn't.\nStatistics: %s\nVector: %s",
201: 				                        ToString(), vector.ToString(count));
202: 			} else if (unicode == UnicodeType::INVALID) {
203: 				throw InternalException("Invalid unicode detected in vector: %s", vector.ToString(count));
204: 			}
205: 		}
206: 		if (StringValueComparison((const_data_ptr_t)data, MinValue<idx_t>(len, MAX_STRING_MINMAX_SIZE), min) < 0) {
207: 			throw InternalException("Statistics mismatch: value is smaller than min.\nStatistics: %s\nVector: %s",
208: 			                        ToString(), vector.ToString(count));
209: 		}
210: 		if (StringValueComparison((const_data_ptr_t)data, MinValue<idx_t>(len, MAX_STRING_MINMAX_SIZE), max) > 0) {
211: 			throw InternalException("Statistics mismatch: value is bigger than max.\nStatistics: %s\nVector: %s",
212: 			                        ToString(), vector.ToString(count));
213: 		}
214: 		// LCOV_EXCL_STOP
215: 	}
216: }
217: 
218: } // namespace duckdb
[end of src/storage/statistics/string_statistics.cpp]
[start of tools/shell/shell.c]
1: /* DO NOT EDIT!
2: ** This file is automatically generated by the script in the canonical
3: ** SQLite source tree at tool/mkshellc.tcl.  That script combines source
4: ** code from various constituent source files of SQLite into this single
5: ** "shell.c" file used to implement the SQLite command-line shell.
6: **
7: ** Most of the code found below comes from the "src/shell.c.in" file in
8: ** the canonical SQLite source tree.  That main file contains "INCLUDE"
9: ** lines that specify other files in the canonical source tree that are
10: ** inserted to getnerate this complete program source file.
11: **
12: ** The code from multiple files is combined into this single "shell.c"
13: ** source file to help make the command-line program easier to compile.
14: **
15: ** To modify this program, get a copy of the canonical SQLite source tree,
16: ** edit the src/shell.c.in" and/or some of the other files that are included
17: ** by "src/shell.c.in", then rerun the tool/mkshellc.tcl script.
18: */
19: /*
20: ** 2001 September 15
21: **
22: ** The author disclaims copyright to this source code.  In place of
23: ** a legal notice, here is a blessing:
24: **
25: **    May you do good and not evil.
26: **    May you find forgiveness for yourself and forgive others.
27: **    May you share freely, never taking more than you give.
28: **
29: *************************************************************************
30: ** This file contains code to implement the "sqlite" command line
31: ** utility for accessing SQLite databases.
32: */
33: #if (defined(_WIN32) || defined(WIN32)) && !defined(_CRT_SECURE_NO_WARNINGS)
34: /* This needs to come before any includes for MSVC compiler */
35: #define _CRT_SECURE_NO_WARNINGS
36: #endif
37: 
38: /*
39: ** Determine if we are dealing with WinRT, which provides only a subset of
40: ** the full Win32 API.
41: */
42: #if !defined(SQLITE_OS_WINRT)
43: # define SQLITE_OS_WINRT 0
44: #endif
45: 
46: /*
47: ** Warning pragmas copied from msvc.h in the core.
48: */
49: #if defined(_MSC_VER)
50: #pragma warning(disable : 4054)
51: #pragma warning(disable : 4055)
52: #pragma warning(disable : 4100)
53: #pragma warning(disable : 4127)
54: #pragma warning(disable : 4130)
55: #pragma warning(disable : 4152)
56: #pragma warning(disable : 4189)
57: #pragma warning(disable : 4206)
58: #pragma warning(disable : 4210)
59: #pragma warning(disable : 4232)
60: #pragma warning(disable : 4244)
61: #pragma warning(disable : 4305)
62: #pragma warning(disable : 4306)
63: #pragma warning(disable : 4702)
64: #pragma warning(disable : 4706)
65: #endif /* defined(_MSC_VER) */
66: 
67: /*
68: ** No support for loadable extensions in VxWorks.
69: */
70: #if (defined(__RTP__) || defined(_WRS_KERNEL)) && !SQLITE_OMIT_LOAD_EXTENSION
71: # define SQLITE_OMIT_LOAD_EXTENSION 1
72: #endif
73: 
74: /*
75: ** Enable large-file support for fopen() and friends on unix.
76: */
77: #ifndef SQLITE_DISABLE_LFS
78: # define _LARGE_FILE       1
79: # ifndef _FILE_OFFSET_BITS
80: #   define _FILE_OFFSET_BITS 64
81: # endif
82: # define _LARGEFILE_SOURCE 1
83: #endif
84: 
85: #include <stdlib.h>
86: #include <string.h>
87: #include <stdio.h>
88: #include <assert.h>
89: #include "sqlite3.h"
90: typedef sqlite3_int64 i64;
91: typedef sqlite3_uint64 u64;
92: typedef unsigned char u8;
93: #if SQLITE_USER_AUTHENTICATION
94: # include "sqlite3userauth.h"
95: #endif
96: #include <ctype.h>
97: #include <stdarg.h>
98: 
99: #if !defined(_WIN32) && !defined(WIN32)
100: # include <signal.h>
101: # if !defined(__RTP__) && !defined(_WRS_KERNEL)
102: #  include <pwd.h>
103: # endif
104: #endif
105: #if (!defined(_WIN32) && !defined(WIN32)) || defined(__MINGW32__)
106: # include <unistd.h>
107: # include <dirent.h>
108: # define GETPID getpid
109: # if defined(__MINGW32__)
110: #  define DIRENT dirent
111: #  ifndef S_ISLNK
112: #   define S_ISLNK(mode) (0)
113: #  endif
114: # endif
115: #else
116: # define GETPID (int)GetCurrentProcessId
117: #endif
118: #include <sys/types.h>
119: #include <sys/stat.h>
120: 
121: #if HAVE_READLINE
122: # include <readline/readline.h>
123: # include <readline/history.h>
124: #endif
125: 
126: #if HAVE_EDITLINE
127: # include <editline/readline.h>
128: #endif
129: 
130: #if HAVE_EDITLINE || HAVE_READLINE
131: 
132: # define shell_add_history(X) add_history(X)
133: # define shell_read_history(X) read_history(X)
134: # define shell_write_history(X) write_history(X)
135: # define shell_stifle_history(X) stifle_history(X)
136: # define shell_readline(X) readline(X)
137: 
138: #elif HAVE_LINENOISE
139: 
140: # include "linenoise.h"
141: # define shell_add_history(X) linenoiseHistoryAdd(X)
142: # define shell_read_history(X) linenoiseHistoryLoad(X)
143: # define shell_write_history(X) linenoiseHistorySave(X)
144: # define shell_stifle_history(X) linenoiseHistorySetMaxLen(X)
145: # define shell_readline(X) linenoise(X)
146: 
147: #else
148: 
149: # define shell_read_history(X)
150: # define shell_write_history(X)
151: # define shell_stifle_history(X)
152: 
153: # define SHELL_USE_LOCAL_GETLINE 1
154: #endif
155: 
156: 
157: #if defined(_WIN32) || defined(WIN32)
158: # if SQLITE_OS_WINRT
159: #  define SQLITE_OMIT_POPEN 1
160: # else
161: #  include <io.h>
162: #  include <fcntl.h>
163: #  define isatty(h) _isatty(h)
164: #  ifndef access
165: #   define access(f,m) _access((f),(m))
166: #  endif
167: #  ifndef unlink
168: #   define unlink _unlink
169: #  endif
170: #  ifndef strdup
171: #   define strdup _strdup
172: #  endif
173: #  undef popen
174: #  define popen _popen
175: #  undef pclose
176: #  define pclose _pclose
177: # endif
178: #else
179:  /* Make sure isatty() has a prototype. */
180:  extern int isatty(int);
181: 
182: # if !defined(__RTP__) && !defined(_WRS_KERNEL)
183:   /* popen and pclose are not C89 functions and so are
184:   ** sometimes omitted from the <stdio.h> header */
185:    extern FILE *popen(const char*,const char*);
186:    extern int pclose(FILE*);
187: # else
188: #  define SQLITE_OMIT_POPEN 1
189: # endif
190: #endif
191: 
192: #if defined(_WIN32_WCE)
193: /* Windows CE (arm-wince-mingw32ce-gcc) does not provide isatty()
194:  * thus we always assume that we have a console. That can be
195:  * overridden with the -batch command line option.
196:  */
197: #define isatty(x) 1
198: #endif
199: 
200: /* ctype macros that work with signed characters */
201: #define IsSpace(X)  isspace((unsigned char)X)
202: #define IsDigit(X)  isdigit((unsigned char)X)
203: #define ToLower(X)  (char)tolower((unsigned char)X)
204: 
205: #if defined(_WIN32) || defined(WIN32)
206: #if SQLITE_OS_WINRT
207: #include <intrin.h>
208: #endif
209: #include <windows.h>
210: 
211: /* string conversion routines only needed on Win32 */
212: extern char *sqlite3_win32_unicode_to_utf8(LPCWSTR);
213: extern char *sqlite3_win32_mbcs_to_utf8_v2(const char *, int);
214: extern char *sqlite3_win32_utf8_to_mbcs_v2(const char *, int);
215: extern LPWSTR sqlite3_win32_utf8_to_unicode(const char *zText);
216: #endif
217: 
218: /* On Windows, we normally run with output mode of TEXT so that \n characters
219: ** are automatically translated into \r\n.  However, this behavior needs
220: ** to be disabled in some cases (ex: when generating CSV output and when
221: ** rendering quoted strings that contain \n characters).  The following
222: ** routines take care of that.
223: */
224: #if (defined(_WIN32) || defined(WIN32)) && !SQLITE_OS_WINRT
225: static void setBinaryMode(FILE *file, int isOutput){
226:   if( isOutput ) fflush(file);
227:   _setmode(_fileno(file), _O_BINARY);
228: }
229: static void setTextMode(FILE *file, int isOutput){
230:   if( isOutput ) fflush(file);
231:   _setmode(_fileno(file), _O_TEXT);
232: }
233: #else
234: # define setBinaryMode(X,Y)
235: # define setTextMode(X,Y)
236: #endif
237: 
238: 
239: /* True if the timer is enabled */
240: static int enableTimer = 0;
241: 
242: /* Return the current wall-clock time */
243: static sqlite3_int64 timeOfDay(void){
244:   static sqlite3_vfs *clockVfs = 0;
245:   sqlite3_int64 t;
246:   if( clockVfs==0 ) clockVfs = sqlite3_vfs_find(0);
247:   if( clockVfs->iVersion>=2 && clockVfs->xCurrentTimeInt64!=0 ){
248:     clockVfs->xCurrentTimeInt64(clockVfs, &t);
249:   }else{
250:     double r;
251:     clockVfs->xCurrentTime(clockVfs, &r);
252:     t = (sqlite3_int64)(r*86400000.0);
253:   }
254:   return t;
255: }
256: 
257: #if !defined(_WIN32) && !defined(WIN32) && !defined(__minux)
258: #include <sys/time.h>
259: #include <sys/resource.h>
260: 
261: /* VxWorks does not support getrusage() as far as we can determine */
262: #if defined(_WRS_KERNEL) || defined(__RTP__)
263: struct rusage {
264:   struct timeval ru_utime; /* user CPU time used */
265:   struct timeval ru_stime; /* system CPU time used */
266: };
267: #define getrusage(A,B) memset(B,0,sizeof(*B))
268: #endif
269: 
270: /* Saved resource information for the beginning of an operation */
271: static struct rusage sBegin;  /* CPU time at start */
272: static sqlite3_int64 iBegin;  /* Wall-clock time at start */
273: 
274: /*
275: ** Begin timing an operation
276: */
277: static void beginTimer(void){
278:   if( enableTimer ){
279:     getrusage(RUSAGE_SELF, &sBegin);
280:     iBegin = timeOfDay();
281:   }
282: }
283: 
284: /* Return the difference of two time_structs in seconds */
285: static double timeDiff(struct timeval *pStart, struct timeval *pEnd){
286:   return (pEnd->tv_usec - pStart->tv_usec)*0.000001 +
287:          (double)(pEnd->tv_sec - pStart->tv_sec);
288: }
289: 
290: /*
291: ** Print the timing results.
292: */
293: static void endTimer(void){
294:   if( enableTimer ){
295:     sqlite3_int64 iEnd = timeOfDay();
296:     struct rusage sEnd;
297:     getrusage(RUSAGE_SELF, &sEnd);
298:     printf("Run Time (s): real %.3f user %f sys %f\n",
299:        (iEnd - iBegin)*0.001,
300:        timeDiff(&sBegin.ru_utime, &sEnd.ru_utime),
301:        timeDiff(&sBegin.ru_stime, &sEnd.ru_stime));
302:   }
303: }
304: 
305: #define BEGIN_TIMER beginTimer()
306: #define END_TIMER endTimer()
307: #define HAS_TIMER 1
308: 
309: #elif (defined(_WIN32) || defined(WIN32))
310: 
311: /* Saved resource information for the beginning of an operation */
312: static HANDLE hProcess;
313: static FILETIME ftKernelBegin;
314: static FILETIME ftUserBegin;
315: static sqlite3_int64 ftWallBegin;
316: typedef BOOL (WINAPI *GETPROCTIMES)(HANDLE, LPFILETIME, LPFILETIME,
317:                                     LPFILETIME, LPFILETIME);
318: static GETPROCTIMES getProcessTimesAddr = NULL;
319: 
320: /*
321: ** Check to see if we have timer support.  Return 1 if necessary
322: ** support found (or found previously).
323: */
324: static int hasTimer(void){
325:   if( getProcessTimesAddr ){
326:     return 1;
327:   } else {
328: #if !SQLITE_OS_WINRT
329:     /* GetProcessTimes() isn't supported in WIN95 and some other Windows
330:     ** versions. See if the version we are running on has it, and if it
331:     ** does, save off a pointer to it and the current process handle.
332:     */
333:     hProcess = GetCurrentProcess();
334:     if( hProcess ){
335:       HINSTANCE hinstLib = LoadLibrary(TEXT("Kernel32.dll"));
336:       if( NULL != hinstLib ){
337:         getProcessTimesAddr =
338:             (GETPROCTIMES) GetProcAddress(hinstLib, "GetProcessTimes");
339:         if( NULL != getProcessTimesAddr ){
340:           return 1;
341:         }
342:         FreeLibrary(hinstLib);
343:       }
344:     }
345: #endif
346:   }
347:   return 0;
348: }
349: 
350: /*
351: ** Begin timing an operation
352: */
353: static void beginTimer(void){
354:   if( enableTimer && getProcessTimesAddr ){
355:     FILETIME ftCreation, ftExit;
356:     getProcessTimesAddr(hProcess,&ftCreation,&ftExit,
357:                         &ftKernelBegin,&ftUserBegin);
358:     ftWallBegin = timeOfDay();
359:   }
360: }
361: 
362: /* Return the difference of two FILETIME structs in seconds */
363: static double timeDiff(FILETIME *pStart, FILETIME *pEnd){
364:   sqlite_int64 i64Start = *((sqlite_int64 *) pStart);
365:   sqlite_int64 i64End = *((sqlite_int64 *) pEnd);
366:   return (double) ((i64End - i64Start) / 10000000.0);
367: }
368: 
369: /*
370: ** Print the timing results.
371: */
372: static void endTimer(void){
373:   if( enableTimer && getProcessTimesAddr){
374:     FILETIME ftCreation, ftExit, ftKernelEnd, ftUserEnd;
375:     sqlite3_int64 ftWallEnd = timeOfDay();
376:     getProcessTimesAddr(hProcess,&ftCreation,&ftExit,&ftKernelEnd,&ftUserEnd);
377:     printf("Run Time (s): real %.3f user %f sys %f\n",
378:        (ftWallEnd - ftWallBegin)*0.001,
379:        timeDiff(&ftUserBegin, &ftUserEnd),
380:        timeDiff(&ftKernelBegin, &ftKernelEnd));
381:   }
382: }
383: 
384: #define BEGIN_TIMER beginTimer()
385: #define END_TIMER endTimer()
386: #define HAS_TIMER hasTimer()
387: 
388: #else
389: #define BEGIN_TIMER
390: #define END_TIMER
391: #define HAS_TIMER 0
392: #endif
393: 
394: /*
395: ** Used to prevent warnings about unused parameters
396: */
397: #define UNUSED_PARAMETER(x) (void)(x)
398: 
399: /*
400: ** Number of elements in an array
401: */
402: #define ArraySize(X)  (int)(sizeof(X)/sizeof(X[0]))
403: 
404: /*
405: ** If the following flag is set, then command execution stops
406: ** at an error if we are not interactive.
407: */
408: static int bail_on_error = 0;
409: 
410: /*
411: ** Threat stdin as an interactive input if the following variable
412: ** is true.  Otherwise, assume stdin is connected to a file or pipe.
413: */
414: static int stdin_is_interactive = 1;
415: 
416: /*
417: ** On Windows systems we have to know if standard output is a console
418: ** in order to translate UTF-8 into MBCS.  The following variable is
419: ** true if translation is required.
420: */
421: static int stdout_is_console = 1;
422: 
423: /*
424: ** The following is the open SQLite database.  We make a pointer
425: ** to this database a static variable so that it can be accessed
426: ** by the SIGINT handler to interrupt database processing.
427: */
428: static sqlite3 *globalDb = 0;
429: 
430: /*
431: ** True if an interrupt (Control-C) has been received.
432: */
433: static volatile int seenInterrupt = 0;
434: 
435: #ifdef SQLITE_DEBUG
436: /*
437: ** Out-of-memory simulator variables
438: */
439: static unsigned int oomCounter = 0;    /* Simulate OOM when equals 1 */
440: static unsigned int oomRepeat = 0;     /* Number of OOMs in a row */
441: static void*(*defaultMalloc)(int) = 0; /* The low-level malloc routine */
442: #endif /* SQLITE_DEBUG */
443: 
444: /*
445: ** This is the name of our program. It is set in main(), used
446: ** in a number of other places, mostly for error messages.
447: */
448: static char *Argv0;
449: 
450: /*
451: ** Prompt strings. Initialized in main. Settable with
452: **   .prompt main continue
453: */
454: static char mainPrompt[20];     /* First line prompt. default: "sqlite> "*/
455: static char continuePrompt[20]; /* Continuation prompt. default: "   ...> " */
456: 
457: /*
458: ** Render output like fprintf().  Except, if the output is going to the
459: ** console and if this is running on a Windows machine, translate the
460: ** output from UTF-8 into MBCS.
461: */
462: #if defined(_WIN32) || defined(WIN32)
463: void utf8_printf(FILE *out, const char *zFormat, ...){
464:   va_list ap;
465:   va_start(ap, zFormat);
466:   if( stdout_is_console && (out==stdout || out==stderr) ){
467:     char *z1 = sqlite3_vmprintf(zFormat, ap);
468:     char *z2 = sqlite3_win32_utf8_to_mbcs_v2(z1, 0);
469:     sqlite3_free(z1);
470:     fputs(z2, out);
471:     sqlite3_free(z2);
472:   }else{
473:     vfprintf(out, zFormat, ap);
474:   }
475:   va_end(ap);
476: }
477: #elif !defined(utf8_printf)
478: # define utf8_printf fprintf
479: #endif
480: 
481: /*
482: ** Render output like fprintf().  This should not be used on anything that
483: ** includes string formatting (e.g. "%s").
484: */
485: #if !defined(raw_printf)
486: # define raw_printf fprintf
487: #endif
488: 
489: /* Indicate out-of-memory and exit. */
490: static void shell_out_of_memory(void){
491:   raw_printf(stderr,"Error: out of memory\n");
492:   exit(1);
493: }
494: 
495: #ifdef SQLITE_DEBUG
496: /* This routine is called when a simulated OOM occurs.  It is broken
497: ** out as a separate routine to make it easy to set a breakpoint on
498: ** the OOM
499: */
500: void shellOomFault(void){
501:   if( oomRepeat>0 ){
502:     oomRepeat--;
503:   }else{
504:     oomCounter--;
505:   }
506: }
507: #endif /* SQLITE_DEBUG */
508: 
509: #ifdef SQLITE_DEBUG
510: /* This routine is a replacement malloc() that is used to simulate
511: ** Out-Of-Memory (OOM) errors for testing purposes.
512: */
513: static void *oomMalloc(int nByte){
514:   if( oomCounter ){
515:     if( oomCounter==1 ){
516:       shellOomFault();
517:       return 0;
518:     }else{
519:       oomCounter--;
520:     }
521:   }
522:   return defaultMalloc(nByte);
523: }
524: #endif /* SQLITE_DEBUG */
525: 
526: #ifdef SQLITE_DEBUG
527: /* Register the OOM simulator.  This must occur before any memory
528: ** allocations */
529: static void registerOomSimulator(void){
530:   sqlite3_mem_methods mem;
531:   sqlite3_config(SQLITE_CONFIG_GETMALLOC, &mem);
532:   defaultMalloc = mem.xMalloc;
533:   mem.xMalloc = oomMalloc;
534:   sqlite3_config(SQLITE_CONFIG_MALLOC, &mem);
535: }
536: #endif
537: 
538: /*
539: ** Write I/O traces to the following stream.
540: */
541: #ifdef SQLITE_ENABLE_IOTRACE
542: static FILE *iotrace = 0;
543: #endif
544: 
545: /*
546: ** This routine works like printf in that its first argument is a
547: ** format string and subsequent arguments are values to be substituted
548: ** in place of % fields.  The result of formatting this string
549: ** is written to iotrace.
550: */
551: #ifdef SQLITE_ENABLE_IOTRACE
552: static void SQLITE_CDECL iotracePrintf(const char *zFormat, ...){
553:   va_list ap;
554:   char *z;
555:   if( iotrace==0 ) return;
556:   va_start(ap, zFormat);
557:   z = sqlite3_vmprintf(zFormat, ap);
558:   va_end(ap);
559:   utf8_printf(iotrace, "%s", z);
560:   sqlite3_free(z);
561: }
562: #endif
563: 
564: /*
565: ** Output string zUtf to stream pOut as w characters.  If w is negative,
566: ** then right-justify the text.  W is the width in UTF-8 characters, not
567: ** in bytes.  This is different from the %*.*s specification in printf
568: ** since with %*.*s the width is measured in bytes, not characters.
569: */
570: static void utf8_width_print(FILE *pOut, int w, const char *zUtf){
571:   int i;
572:   int n;
573:   int aw = w<0 ? -w : w;
574:   char zBuf[1000];
575:   if( aw>(int)sizeof(zBuf)/3 ) aw = (int)sizeof(zBuf)/3;
576: #ifdef HAVE_LINENOISE
577:   i = linenoiseGetRenderPosition(zUtf, strlen(zUtf), aw, &n);
578:   if (i < 0)
579: #endif
580:   for(i=n=0; zUtf[i]; i++){
581:     if( (zUtf[i]&0xc0)!=0x80 ){
582:       n++;
583:       if( n==aw ){
584:         do{ i++; }while( (zUtf[i]&0xc0)==0x80 );
585:         break;
586:       }
587:     }
588:   }
589:   if( n>=aw ){
590:     utf8_printf(pOut, "%.*s", i, zUtf);
591:   }else if( w<0 ){
592:     utf8_printf(pOut, "%*s%s", aw-n, "", zUtf);
593:   }else{
594:     utf8_printf(pOut, "%s%*s", zUtf, aw-n, "");
595:   }
596: }
597: 
598: 
599: /*
600: ** Determines if a string is a number of not.
601: */
602: static int isNumber(const char *z, int *realnum){
603:   if( *z=='-' || *z=='+' ) z++;
604:   if( !IsDigit(*z) ){
605:     return 0;
606:   }
607:   z++;
608:   if( realnum ) *realnum = 0;
609:   while( IsDigit(*z) ){ z++; }
610:   if( *z=='.' ){
611:     z++;
612:     if( !IsDigit(*z) ) return 0;
613:     while( IsDigit(*z) ){ z++; }
614:     if( realnum ) *realnum = 1;
615:   }
616:   if( *z=='e' || *z=='E' ){
617:     z++;
618:     if( *z=='+' || *z=='-' ) z++;
619:     if( !IsDigit(*z) ) return 0;
620:     while( IsDigit(*z) ){ z++; }
621:     if( realnum ) *realnum = 1;
622:   }
623:   return *z==0;
624: }
625: 
626: /*
627: ** Compute a string length that is limited to what can be stored in
628: ** lower 30 bits of a 32-bit signed integer.
629: */
630: static int strlen30(const char *z){
631:   const char *z2 = z;
632:   while( *z2 ){ z2++; }
633:   return 0x3fffffff & (int)(z2 - z);
634: }
635: 
636: /*
637: ** Return the length of a string in characters.
638: */
639: static int strlenChar(const char *z){
640: #ifdef HAVE_LINENOISE
641:   return linenoiseComputeRenderWidth(z, strlen(z));
642: #else
643:   int n = 0;
644:   while( *z ){
645:     if( (0xc0&*(z++))!=0x80 ) n++;
646:   }
647:   return n;
648: #endif
649: }
650: 
651: /*
652: ** Return true if zFile does not exist or if it is not an ordinary file.
653: */
654: #ifdef _WIN32
655: # define notNormalFile(X) 0
656: #else
657: static int notNormalFile(const char *zFile){
658:   struct stat x;
659:   int rc;
660:   memset(&x, 0, sizeof(x));
661:   rc = stat(zFile, &x);
662:   return rc || !S_ISREG(x.st_mode);
663: }
664: #endif
665: 
666: /*
667: ** This routine reads a line of text from FILE in, stores
668: ** the text in memory obtained from malloc() and returns a pointer
669: ** to the text.  NULL is returned at end of file, or if malloc()
670: ** fails.
671: **
672: ** If zLine is not NULL then it is a malloced buffer returned from
673: ** a previous call to this routine that may be reused.
674: */
675: static char *local_getline(char *zLine, FILE *in){
676:   int nLine = zLine==0 ? 0 : 100;
677:   int n = 0;
678: 
679:   while( 1 ){
680:     if( n+100>nLine ){
681:       nLine = nLine*2 + 100;
682:       zLine = realloc(zLine, nLine);
683:       if( zLine==0 ) shell_out_of_memory();
684:     }
685:     if( fgets(&zLine[n], nLine - n, in)==0 ){
686:       if( n==0 ){
687:         free(zLine);
688:         return 0;
689:       }
690:       zLine[n] = 0;
691:       break;
692:     }
693:     while( zLine[n] ) n++;
694:     if( n>0 && zLine[n-1]=='\n' ){
695:       n--;
696:       if( n>0 && zLine[n-1]=='\r' ) n--;
697:       zLine[n] = 0;
698:       break;
699:     }
700:   }
701: #if defined(_WIN32) || defined(WIN32)
702:   /* For interactive input on Windows systems, translate the
703:   ** multi-byte characterset characters into UTF-8. */
704:   if( stdin_is_interactive && in==stdin ){
705:     char *zTrans = sqlite3_win32_mbcs_to_utf8_v2(zLine, 0);
706:     if( zTrans ){
707:       int nTrans = strlen30(zTrans)+1;
708:       if( nTrans>nLine ){
709:         zLine = realloc(zLine, nTrans);
710:         if( zLine==0 ) shell_out_of_memory();
711:       }
712:       memcpy(zLine, zTrans, nTrans);
713:       sqlite3_free(zTrans);
714:     }
715:   }
716: #endif /* defined(_WIN32) || defined(WIN32) */
717:   return zLine;
718: }
719: 
720: /*
721: ** Retrieve a single line of input text.
722: **
723: ** If in==0 then read from standard input and prompt before each line.
724: ** If isContinuation is true, then a continuation prompt is appropriate.
725: ** If isContinuation is zero, then the main prompt should be used.
726: **
727: ** If zPrior is not NULL then it is a buffer from a prior call to this
728: ** routine that can be reused.
729: **
730: ** The result is stored in space obtained from malloc() and must either
731: ** be freed by the caller or else passed back into this routine via the
732: ** zPrior argument for reuse.
733: */
734: static char *one_input_line(FILE *in, char *zPrior, int isContinuation){
735:   char *zPrompt;
736:   char *zResult;
737:   if( in!=0 ){
738:     zResult = local_getline(zPrior, in);
739:   }else{
740:     zPrompt = isContinuation ? continuePrompt : mainPrompt;
741: #if SHELL_USE_LOCAL_GETLINE
742:     printf("%s", zPrompt);
743:     fflush(stdout);
744:     zResult = local_getline(zPrior, stdin);
745: #else
746:     free(zPrior);
747:     zResult = shell_readline(zPrompt);
748:     if( zResult && *zResult && *zResult != '\3' ) shell_add_history(zResult);
749: #endif
750:   }
751:   return zResult;
752: }
753: 
754: 
755: /*
756: ** Return the value of a hexadecimal digit.  Return -1 if the input
757: ** is not a hex digit.
758: */
759: static int hexDigitValue(char c){
760:   if( c>='0' && c<='9' ) return c - '0';
761:   if( c>='a' && c<='f' ) return c - 'a' + 10;
762:   if( c>='A' && c<='F' ) return c - 'A' + 10;
763:   return -1;
764: }
765: 
766: /*
767: ** Interpret zArg as an integer value, possibly with suffixes.
768: */
769: static sqlite3_int64 integerValue(const char *zArg){
770:   sqlite3_int64 v = 0;
771:   static const struct { char *zSuffix; int iMult; } aMult[] = {
772:     { "KiB", 1024 },
773:     { "MiB", 1024*1024 },
774:     { "GiB", 1024*1024*1024 },
775:     { "KB",  1000 },
776:     { "MB",  1000000 },
777:     { "GB",  1000000000 },
778:     { "K",   1000 },
779:     { "M",   1000000 },
780:     { "G",   1000000000 },
781:   };
782:   int i;
783:   int isNeg = 0;
784:   if( zArg[0]=='-' ){
785:     isNeg = 1;
786:     zArg++;
787:   }else if( zArg[0]=='+' ){
788:     zArg++;
789:   }
790:   if( zArg[0]=='0' && zArg[1]=='x' ){
791:     int x;
792:     zArg += 2;
793:     while( (x = hexDigitValue(zArg[0]))>=0 ){
794:       v = (v<<4) + x;
795:       zArg++;
796:     }
797:   }else{
798:     while( IsDigit(zArg[0]) ){
799:       v = v*10 + zArg[0] - '0';
800:       zArg++;
801:     }
802:   }
803:   for(i=0; i<ArraySize(aMult); i++){
804:     if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 ){
805:       v *= aMult[i].iMult;
806:       break;
807:     }
808:   }
809:   return isNeg? -v : v;
810: }
811: 
812: /*
813: ** A variable length string to which one can append text.
814: */
815: typedef struct ShellText ShellText;
816: struct ShellText {
817:   char *z;
818:   int n;
819:   int nAlloc;
820: };
821: 
822: /*
823: ** Initialize and destroy a ShellText object
824: */
825: static void initText(ShellText *p){
826:   memset(p, 0, sizeof(*p));
827: }
828: static void freeText(ShellText *p){
829:   free(p->z);
830:   initText(p);
831: }
832: 
833: /* zIn is either a pointer to a NULL-terminated string in memory obtained
834: ** from malloc(), or a NULL pointer. The string pointed to by zAppend is
835: ** added to zIn, and the result returned in memory obtained from malloc().
836: ** zIn, if it was not NULL, is freed.
837: **
838: ** If the third argument, quote, is not '\0', then it is used as a
839: ** quote character for zAppend.
840: */
841: static void appendText(ShellText *p, char const *zAppend, char quote){
842:   int len;
843:   int i;
844:   int nAppend = strlen30(zAppend);
845: 
846:   len = nAppend+p->n+1;
847:   if( quote ){
848:     len += 2;
849:     for(i=0; i<nAppend; i++){
850:       if( zAppend[i]==quote ) len++;
851:     }
852:   }
853: 
854:   if( p->n+len>=p->nAlloc ){
855:     p->nAlloc = p->nAlloc*2 + len + 20;
856:     p->z = realloc(p->z, p->nAlloc);
857:     if( p->z==0 ) shell_out_of_memory();
858:   }
859: 
860:   if( quote ){
861:     char *zCsr = p->z+p->n;
862:     *zCsr++ = quote;
863:     for(i=0; i<nAppend; i++){
864:       *zCsr++ = zAppend[i];
865:       if( zAppend[i]==quote ) *zCsr++ = quote;
866:     }
867:     *zCsr++ = quote;
868:     p->n = (int)(zCsr - p->z);
869:     *zCsr = '\0';
870:   }else{
871:     memcpy(p->z+p->n, zAppend, nAppend);
872:     p->n += nAppend;
873:     p->z[p->n] = '\0';
874:   }
875: }
876: 
877: /*
878: ** Attempt to determine if identifier zName needs to be quoted, either
879: ** because it contains non-alphanumeric characters, or because it is an
880: ** SQLite keyword.  Be conservative in this estimate:  When in doubt assume
881: ** that quoting is required.
882: **
883: ** Return '"' if quoting is required.  Return 0 if no quoting is required.
884: */
885: static char quoteChar(const char *zName){
886:   int i;
887:   if( !isalpha((unsigned char)zName[0]) && zName[0]!='_' ) return '"';
888:   for(i=0; zName[i]; i++){
889:     if( !isalnum((unsigned char)zName[i]) && zName[i]!='_' ) return '"';
890:   }
891:   return sqlite3_keyword_check(zName, i) ? '"' : 0;
892: }
893: 
894: /*
895: ** Construct a fake object name and column list to describe the structure
896: ** of the view, virtual table, or table valued function zSchema.zName.
897: */
898: static char *shellFakeSchema(
899:   sqlite3 *db,            /* The database connection containing the vtab */
900:   const char *zSchema,    /* Schema of the database holding the vtab */
901:   const char *zName       /* The name of the virtual table */
902: ){
903:   sqlite3_stmt *pStmt = 0;
904:   char *zSql;
905:   ShellText s;
906:   char cQuote;
907:   char *zDiv = "(";
908:   int nRow = 0;
909: 
910:   zSql = sqlite3_mprintf("PRAGMA \"%w\".table_info=%Q;",
911:                          zSchema ? zSchema : "main", zName);
912:   sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
913:   sqlite3_free(zSql);
914:   initText(&s);
915:   if( zSchema ){
916:     cQuote = quoteChar(zSchema);
917:     if( cQuote && sqlite3_stricmp(zSchema,"temp")==0 ) cQuote = 0;
918:     appendText(&s, zSchema, cQuote);
919:     appendText(&s, ".", 0);
920:   }
921:   cQuote = quoteChar(zName);
922:   appendText(&s, zName, cQuote);
923:   while( sqlite3_step(pStmt)==SQLITE_ROW ){
924:     const char *zCol = (const char*)sqlite3_column_text(pStmt, 1);
925:     nRow++;
926:     appendText(&s, zDiv, 0);
927:     zDiv = ",";
928:     cQuote = quoteChar(zCol);
929:     appendText(&s, zCol, cQuote);
930:   }
931:   appendText(&s, ")", 0);
932:   sqlite3_finalize(pStmt);
933:   if( nRow==0 ){
934:     freeText(&s);
935:     s.z = 0;
936:   }
937:   return s.z;
938: }
939: 
940: /*
941: ** SQL function:  shell_module_schema(X)
942: **
943: ** Return a fake schema for the table-valued function or eponymous virtual
944: ** table X.
945: */
946: static void shellModuleSchema(
947:   sqlite3_context *pCtx,
948:   int nVal,
949:   sqlite3_value **apVal
950: ){
951:   const char *zName = (const char*)sqlite3_value_text(apVal[0]);
952:   char *zFake = shellFakeSchema(sqlite3_context_db_handle(pCtx), 0, zName);
953:   UNUSED_PARAMETER(nVal);
954:   if( zFake ){
955:     sqlite3_result_text(pCtx, sqlite3_mprintf("/* %s */", zFake),
956:                         -1, sqlite3_free);
957:     free(zFake);
958:   }
959: }
960: 
961: /*
962: ** SQL function:  shell_add_schema(S,X)
963: **
964: ** Add the schema name X to the CREATE statement in S and return the result.
965: ** Examples:
966: **
967: **    CREATE TABLE t1(x)   ->   CREATE TABLE xyz.t1(x);
968: **
969: ** Also works on
970: **
971: **    CREATE INDEX
972: **    CREATE UNIQUE INDEX
973: **    CREATE VIEW
974: **    CREATE TRIGGER
975: **    CREATE VIRTUAL TABLE
976: **
977: ** This UDF is used by the .schema command to insert the schema name of
978: ** attached databases into the middle of the sqlite_schema.sql field.
979: */
980: static void shellAddSchemaName(
981:   sqlite3_context *pCtx,
982:   int nVal,
983:   sqlite3_value **apVal
984: ){
985:   static const char *aPrefix[] = {
986:      "TABLE",
987:      "INDEX",
988:      "UNIQUE INDEX",
989:      "VIEW",
990:      "TRIGGER",
991:      "VIRTUAL TABLE"
992:   };
993:   int i = 0;
994:   const char *zIn = (const char*)sqlite3_value_text(apVal[0]);
995:   const char *zSchema = (const char*)sqlite3_value_text(apVal[1]);
996:   const char *zName = (const char*)sqlite3_value_text(apVal[2]);
997:   sqlite3 *db = sqlite3_context_db_handle(pCtx);
998:   UNUSED_PARAMETER(nVal);
999:   if( zIn!=0 && strncmp(zIn, "CREATE ", 7)==0 ){
1000:     for(i=0; i<(int)(sizeof(aPrefix)/sizeof(aPrefix[0])); i++){
1001:       int n = strlen30(aPrefix[i]);
1002:       if( strncmp(zIn+7, aPrefix[i], n)==0 && zIn[n+7]==' ' ){
1003:         char *z = 0;
1004:         char *zFake = 0;
1005:         if( zSchema ){
1006:           char cQuote = quoteChar(zSchema);
1007:           if( cQuote && sqlite3_stricmp(zSchema,"temp")!=0 ){
1008:             z = sqlite3_mprintf("%.*s \"%w\".%s", n+7, zIn, zSchema, zIn+n+8);
1009:           }else{
1010:             z = sqlite3_mprintf("%.*s %s.%s", n+7, zIn, zSchema, zIn+n+8);
1011:           }
1012:         }
1013:         if( zName
1014:          && aPrefix[i][0]=='V'
1015:          && (zFake = shellFakeSchema(db, zSchema, zName))!=0
1016:         ){
1017:           if( z==0 ){
1018:             z = sqlite3_mprintf("%s\n/* %s */", zIn, zFake);
1019:           }else{
1020:             z = sqlite3_mprintf("%z\n/* %s */", z, zFake);
1021:           }
1022:           free(zFake);
1023:         }
1024:         if( z ){
1025:           sqlite3_result_text(pCtx, z, -1, sqlite3_free);
1026:           return;
1027:         }
1028:       }
1029:     }
1030:   }
1031:   sqlite3_result_value(pCtx, apVal[0]);
1032: }
1033: 
1034: /*
1035: ** The source code for several run-time loadable extensions is inserted
1036: ** below by the ../tool/mkshellc.tcl script.  Before processing that included
1037: ** code, we need to override some macros to make the included program code
1038: ** work here in the middle of this regular program.
1039: */
1040: #define SQLITE_EXTENSION_INIT1
1041: #define SQLITE_EXTENSION_INIT2(X) (void)(X)
1042: 
1043: #if defined(_WIN32) && defined(_MSC_VER)
1044: /************************* Begin test_windirent.h ******************/
1045: /*
1046: ** 2015 November 30
1047: **
1048: ** The author disclaims copyright to this source code.  In place of
1049: ** a legal notice, here is a blessing:
1050: **
1051: **    May you do good and not evil.
1052: **    May you find forgiveness for yourself and forgive others.
1053: **    May you share freely, never taking more than you give.
1054: **
1055: *************************************************************************
1056: ** This file contains declarations for most of the opendir() family of
1057: ** POSIX functions on Win32 using the MSVCRT.
1058: */
1059: 
1060: #if defined(_WIN32) && defined(_MSC_VER) && !defined(SQLITE_WINDIRENT_H)
1061: #define SQLITE_WINDIRENT_H
1062: 
1063: /*
1064: ** We need several data types from the Windows SDK header.
1065: */
1066: 
1067: #ifndef WIN32_LEAN_AND_MEAN
1068: #define WIN32_LEAN_AND_MEAN
1069: #endif
1070: 
1071: #include "windows.h"
1072: 
1073: /*
1074: ** We need several support functions from the SQLite core.
1075: */
1076: 
1077: /* #include "sqlite3.h" */
1078: 
1079: /*
1080: ** We need several things from the ANSI and MSVCRT headers.
1081: */
1082: 
1083: #include <stdio.h>
1084: #include <stdlib.h>
1085: #include <errno.h>
1086: #include <io.h>
1087: #include <limits.h>
1088: #include <sys/types.h>
1089: #include <sys/stat.h>
1090: 
1091: /*
1092: ** We may need several defines that should have been in "sys/stat.h".
1093: */
1094: 
1095: #ifndef S_ISREG
1096: #define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)
1097: #endif
1098: 
1099: #ifndef S_ISDIR
1100: #define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)
1101: #endif
1102: 
1103: #ifndef S_ISLNK
1104: #define S_ISLNK(mode) (0)
1105: #endif
1106: 
1107: /*
1108: ** We may need to provide the "mode_t" type.
1109: */
1110: 
1111: #ifndef MODE_T_DEFINED
1112:   #define MODE_T_DEFINED
1113:   typedef unsigned short mode_t;
1114: #endif
1115: 
1116: /*
1117: ** We may need to provide the "ino_t" type.
1118: */
1119: 
1120: #ifndef INO_T_DEFINED
1121:   #define INO_T_DEFINED
1122:   typedef unsigned short ino_t;
1123: #endif
1124: 
1125: /*
1126: ** We need to define "NAME_MAX" if it was not present in "limits.h".
1127: */
1128: 
1129: #ifndef NAME_MAX
1130: #  ifdef FILENAME_MAX
1131: #    define NAME_MAX (FILENAME_MAX)
1132: #  else
1133: #    define NAME_MAX (260)
1134: #  endif
1135: #endif
1136: 
1137: /*
1138: ** We need to define "NULL_INTPTR_T" and "BAD_INTPTR_T".
1139: */
1140: 
1141: #ifndef NULL_INTPTR_T
1142: #  define NULL_INTPTR_T ((intptr_t)(0))
1143: #endif
1144: 
1145: #ifndef BAD_INTPTR_T
1146: #  define BAD_INTPTR_T ((intptr_t)(-1))
1147: #endif
1148: 
1149: /*
1150: ** We need to provide the necessary structures and related types.
1151: */
1152: 
1153: #ifndef DIRENT_DEFINED
1154: #define DIRENT_DEFINED
1155: typedef struct DIRENT DIRENT;
1156: typedef DIRENT *LPDIRENT;
1157: struct DIRENT {
1158:   ino_t d_ino;               /* Sequence number, do not use. */
1159:   unsigned d_attributes;     /* Win32 file attributes. */
1160:   char d_name[NAME_MAX + 1]; /* Name within the directory. */
1161: };
1162: #endif
1163: 
1164: #ifndef DIR_DEFINED
1165: #define DIR_DEFINED
1166: typedef struct DIR DIR;
1167: typedef DIR *LPDIR;
1168: struct DIR {
1169:   intptr_t d_handle; /* Value returned by "_findfirst". */
1170:   DIRENT d_first;    /* DIRENT constructed based on "_findfirst". */
1171:   DIRENT d_next;     /* DIRENT constructed based on "_findnext". */
1172: };
1173: #endif
1174: 
1175: /*
1176: ** Provide a macro, for use by the implementation, to determine if a
1177: ** particular directory entry should be skipped over when searching for
1178: ** the next directory entry that should be returned by the readdir() or
1179: ** readdir_r() functions.
1180: */
1181: 
1182: #ifndef is_filtered
1183: #  define is_filtered(a) ((((a).attrib)&_A_HIDDEN) || (((a).attrib)&_A_SYSTEM))
1184: #endif
1185: 
1186: /*
1187: ** Provide the function prototype for the POSIX compatiable getenv()
1188: ** function.  This function is not thread-safe.
1189: */
1190: 
1191: extern const char *windirent_getenv(const char *name);
1192: 
1193: /*
1194: ** Finally, we can provide the function prototypes for the opendir(),
1195: ** readdir(), readdir_r(), and closedir() POSIX functions.
1196: */
1197: 
1198: extern LPDIR opendir(const char *dirname);
1199: extern LPDIRENT readdir(LPDIR dirp);
1200: extern INT readdir_r(LPDIR dirp, LPDIRENT entry, LPDIRENT *result);
1201: extern INT closedir(LPDIR dirp);
1202: 
1203: #endif /* defined(WIN32) && defined(_MSC_VER) */
1204: 
1205: /************************* End test_windirent.h ********************/
1206: /************************* Begin test_windirent.c ******************/
1207: /*
1208: ** 2015 November 30
1209: **
1210: ** The author disclaims copyright to this source code.  In place of
1211: ** a legal notice, here is a blessing:
1212: **
1213: **    May you do good and not evil.
1214: **    May you find forgiveness for yourself and forgive others.
1215: **    May you share freely, never taking more than you give.
1216: **
1217: *************************************************************************
1218: ** This file contains code to implement most of the opendir() family of
1219: ** POSIX functions on Win32 using the MSVCRT.
1220: */
1221: 
1222: #if defined(_WIN32) && defined(_MSC_VER)
1223: /* #include "test_windirent.h" */
1224: 
1225: /*
1226: ** Implementation of the POSIX getenv() function using the Win32 API.
1227: ** This function is not thread-safe.
1228: */
1229: const char *windirent_getenv(
1230:   const char *name
1231: ){
1232:   static char value[32768]; /* Maximum length, per MSDN */
1233:   DWORD dwSize = sizeof(value) / sizeof(char); /* Size in chars */
1234:   DWORD dwRet; /* Value returned by GetEnvironmentVariableA() */
1235: 
1236:   memset(value, 0, sizeof(value));
1237:   dwRet = GetEnvironmentVariableA(name, value, dwSize);
1238:   if( dwRet==0 || dwRet>dwSize ){
1239:     /*
1240:     ** The function call to GetEnvironmentVariableA() failed -OR-
1241:     ** the buffer is not large enough.  Either way, return NULL.
1242:     */
1243:     return 0;
1244:   }else{
1245:     /*
1246:     ** The function call to GetEnvironmentVariableA() succeeded
1247:     ** -AND- the buffer contains the entire value.
1248:     */
1249:     return value;
1250:   }
1251: }
1252: 
1253: /*
1254: ** Implementation of the POSIX opendir() function using the MSVCRT.
1255: */
1256: LPDIR opendir(
1257:   const char *dirname
1258: ){
1259:   struct _finddata_t data;
1260:   LPDIR dirp = (LPDIR)sqlite3_malloc(sizeof(DIR));
1261:   SIZE_T namesize = sizeof(data.name) / sizeof(data.name[0]);
1262: 
1263:   if( dirp==NULL ) return NULL;
1264:   memset(dirp, 0, sizeof(DIR));
1265: 
1266:   /* TODO: Remove this if Unix-style root paths are not used. */
1267:   if( sqlite3_stricmp(dirname, "/")==0 ){
1268:     dirname = windirent_getenv("SystemDrive");
1269:   }
1270: 
1271:   memset(&data, 0, sizeof(struct _finddata_t));
1272:   _snprintf(data.name, namesize, "%s\\*", dirname);
1273:   dirp->d_handle = _findfirst(data.name, &data);
1274: 
1275:   if( dirp->d_handle==BAD_INTPTR_T ){
1276:     closedir(dirp);
1277:     return NULL;
1278:   }
1279: 
1280:   /* TODO: Remove this block to allow hidden and/or system files. */
1281:   if( is_filtered(data) ){
1282: next:
1283: 
1284:     memset(&data, 0, sizeof(struct _finddata_t));
1285:     if( _findnext(dirp->d_handle, &data)==-1 ){
1286:       closedir(dirp);
1287:       return NULL;
1288:     }
1289: 
1290:     /* TODO: Remove this block to allow hidden and/or system files. */
1291:     if( is_filtered(data) ) goto next;
1292:   }
1293: 
1294:   dirp->d_first.d_attributes = data.attrib;
1295:   strncpy(dirp->d_first.d_name, data.name, NAME_MAX);
1296:   dirp->d_first.d_name[NAME_MAX] = '\0';
1297: 
1298:   return dirp;
1299: }
1300: 
1301: /*
1302: ** Implementation of the POSIX readdir() function using the MSVCRT.
1303: */
1304: LPDIRENT readdir(
1305:   LPDIR dirp
1306: ){
1307:   struct _finddata_t data;
1308: 
1309:   if( dirp==NULL ) return NULL;
1310: 
1311:   if( dirp->d_first.d_ino==0 ){
1312:     dirp->d_first.d_ino++;
1313:     dirp->d_next.d_ino++;
1314: 
1315:     return &dirp->d_first;
1316:   }
1317: 
1318: next:
1319: 
1320:   memset(&data, 0, sizeof(struct _finddata_t));
1321:   if( _findnext(dirp->d_handle, &data)==-1 ) return NULL;
1322: 
1323:   /* TODO: Remove this block to allow hidden and/or system files. */
1324:   if( is_filtered(data) ) goto next;
1325: 
1326:   dirp->d_next.d_ino++;
1327:   dirp->d_next.d_attributes = data.attrib;
1328:   strncpy(dirp->d_next.d_name, data.name, NAME_MAX);
1329:   dirp->d_next.d_name[NAME_MAX] = '\0';
1330: 
1331:   return &dirp->d_next;
1332: }
1333: 
1334: /*
1335: ** Implementation of the POSIX readdir_r() function using the MSVCRT.
1336: */
1337: INT readdir_r(
1338:   LPDIR dirp,
1339:   LPDIRENT entry,
1340:   LPDIRENT *result
1341: ){
1342:   struct _finddata_t data;
1343: 
1344:   if( dirp==NULL ) return EBADF;
1345: 
1346:   if( dirp->d_first.d_ino==0 ){
1347:     dirp->d_first.d_ino++;
1348:     dirp->d_next.d_ino++;
1349: 
1350:     entry->d_ino = dirp->d_first.d_ino;
1351:     entry->d_attributes = dirp->d_first.d_attributes;
1352:     strncpy(entry->d_name, dirp->d_first.d_name, NAME_MAX);
1353:     entry->d_name[NAME_MAX] = '\0';
1354: 
1355:     *result = entry;
1356:     return 0;
1357:   }
1358: 
1359: next:
1360: 
1361:   memset(&data, 0, sizeof(struct _finddata_t));
1362:   if( _findnext(dirp->d_handle, &data)==-1 ){
1363:     *result = NULL;
1364:     return ENOENT;
1365:   }
1366: 
1367:   /* TODO: Remove this block to allow hidden and/or system files. */
1368:   if( is_filtered(data) ) goto next;
1369: 
1370:   entry->d_ino = (ino_t)-1; /* not available */
1371:   entry->d_attributes = data.attrib;
1372:   strncpy(entry->d_name, data.name, NAME_MAX);
1373:   entry->d_name[NAME_MAX] = '\0';
1374: 
1375:   *result = entry;
1376:   return 0;
1377: }
1378: 
1379: /*
1380: ** Implementation of the POSIX closedir() function using the MSVCRT.
1381: */
1382: INT closedir(
1383:   LPDIR dirp
1384: ){
1385:   INT result = 0;
1386: 
1387:   if( dirp==NULL ) return EINVAL;
1388: 
1389:   if( dirp->d_handle!=NULL_INTPTR_T && dirp->d_handle!=BAD_INTPTR_T ){
1390:     result = _findclose(dirp->d_handle);
1391:   }
1392: 
1393:   sqlite3_free(dirp);
1394:   return result;
1395: }
1396: 
1397: #endif /* defined(WIN32) && defined(_MSC_VER) */
1398: 
1399: /************************* End test_windirent.c ********************/
1400: #define dirent DIRENT
1401: #endif
1402: /************************* Begin ../ext/misc/shathree.c ******************/
1403: /*
1404: ** 2017-03-08
1405: **
1406: ** The author disclaims copyright to this source code.  In place of
1407: ** a legal notice, here is a blessing:
1408: **
1409: **    May you do good and not evil.
1410: **    May you find forgiveness for yourself and forgive others.
1411: **    May you share freely, never taking more than you give.
1412: **
1413: ******************************************************************************
1414: **
1415: ** This SQLite extension implements functions that compute SHA3 hashes.
1416: ** Two SQL functions are implemented:
1417: **
1418: **     sha3(X,SIZE)
1419: **     sha3_query(Y,SIZE)
1420: **
1421: ** The sha3(X) function computes the SHA3 hash of the input X, or NULL if
1422: ** X is NULL.
1423: **
1424: ** The sha3_query(Y) function evalutes all queries in the SQL statements of Y
1425: ** and returns a hash of their results.
1426: **
1427: ** The SIZE argument is optional.  If omitted, the SHA3-256 hash algorithm
1428: ** is used.  If SIZE is included it must be one of the integers 224, 256,
1429: ** 384, or 512, to determine SHA3 hash variant that is computed.
1430: */
1431: /* #include "sqlite3ext.h" */
1432: SQLITE_EXTENSION_INIT1
1433: #include <assert.h>
1434: #include <string.h>
1435: #include <stdarg.h>
1436: /* typedef sqlite3_uint64 u64; */
1437: 
1438: /******************************************************************************
1439: ** The Hash Engine
1440: */
1441: /*
1442: ** Macros to determine whether the machine is big or little endian,
1443: ** and whether or not that determination is run-time or compile-time.
1444: **
1445: ** For best performance, an attempt is made to guess at the byte-order
1446: ** using C-preprocessor macros.  If that is unsuccessful, or if
1447: ** -DSHA3_BYTEORDER=0 is set, then byte-order is determined
1448: ** at run-time.
1449: */
1450: #ifndef SHA3_BYTEORDER
1451: # if defined(i386)     || defined(__i386__)   || defined(_M_IX86) ||    \
1452:      defined(__x86_64) || defined(__x86_64__) || defined(_M_X64)  ||    \
1453:      defined(_M_AMD64) || defined(_M_ARM)     || defined(__x86)   ||    \
1454:      defined(__arm__)
1455: #   define SHA3_BYTEORDER    1234
1456: # elif defined(sparc)    || defined(__ppc__)
1457: #   define SHA3_BYTEORDER    4321
1458: # else
1459: #   define SHA3_BYTEORDER 0
1460: # endif
1461: #endif
1462: 
1463: 
1464: /*
1465: ** State structure for a SHA3 hash in progress
1466: */
1467: typedef struct SHA3Context SHA3Context;
1468: struct SHA3Context {
1469:   union {
1470:     u64 s[25];                /* Keccak state. 5x5 lines of 64 bits each */
1471:     unsigned char x[1600];    /* ... or 1600 bytes */
1472:   } u;
1473:   unsigned nRate;        /* Bytes of input accepted per Keccak iteration */
1474:   unsigned nLoaded;      /* Input bytes loaded into u.x[] so far this cycle */
1475:   unsigned ixMask;       /* Insert next input into u.x[nLoaded^ixMask]. */
1476: };
1477: 
1478: /*
1479: ** A single step of the Keccak mixing function for a 1600-bit state
1480: */
1481: static void KeccakF1600Step(SHA3Context *p){
1482:   int i;
1483:   u64 b0, b1, b2, b3, b4;
1484:   u64 c0, c1, c2, c3, c4;
1485:   u64 d0, d1, d2, d3, d4;
1486:   static const u64 RC[] = {
1487:     0x0000000000000001ULL,  0x0000000000008082ULL,
1488:     0x800000000000808aULL,  0x8000000080008000ULL,
1489:     0x000000000000808bULL,  0x0000000080000001ULL,
1490:     0x8000000080008081ULL,  0x8000000000008009ULL,
1491:     0x000000000000008aULL,  0x0000000000000088ULL,
1492:     0x0000000080008009ULL,  0x000000008000000aULL,
1493:     0x000000008000808bULL,  0x800000000000008bULL,
1494:     0x8000000000008089ULL,  0x8000000000008003ULL,
1495:     0x8000000000008002ULL,  0x8000000000000080ULL,
1496:     0x000000000000800aULL,  0x800000008000000aULL,
1497:     0x8000000080008081ULL,  0x8000000000008080ULL,
1498:     0x0000000080000001ULL,  0x8000000080008008ULL
1499:   };
1500: # define a00 (p->u.s[0])
1501: # define a01 (p->u.s[1])
1502: # define a02 (p->u.s[2])
1503: # define a03 (p->u.s[3])
1504: # define a04 (p->u.s[4])
1505: # define a10 (p->u.s[5])
1506: # define a11 (p->u.s[6])
1507: # define a12 (p->u.s[7])
1508: # define a13 (p->u.s[8])
1509: # define a14 (p->u.s[9])
1510: # define a20 (p->u.s[10])
1511: # define a21 (p->u.s[11])
1512: # define a22 (p->u.s[12])
1513: # define a23 (p->u.s[13])
1514: # define a24 (p->u.s[14])
1515: # define a30 (p->u.s[15])
1516: # define a31 (p->u.s[16])
1517: # define a32 (p->u.s[17])
1518: # define a33 (p->u.s[18])
1519: # define a34 (p->u.s[19])
1520: # define a40 (p->u.s[20])
1521: # define a41 (p->u.s[21])
1522: # define a42 (p->u.s[22])
1523: # define a43 (p->u.s[23])
1524: # define a44 (p->u.s[24])
1525: # define ROL64(a,x) ((a<<x)|(a>>(64-x)))
1526: 
1527:   for(i=0; i<24; i+=4){
1528:     c0 = a00^a10^a20^a30^a40;
1529:     c1 = a01^a11^a21^a31^a41;
1530:     c2 = a02^a12^a22^a32^a42;
1531:     c3 = a03^a13^a23^a33^a43;
1532:     c4 = a04^a14^a24^a34^a44;
1533:     d0 = c4^ROL64(c1, 1);
1534:     d1 = c0^ROL64(c2, 1);
1535:     d2 = c1^ROL64(c3, 1);
1536:     d3 = c2^ROL64(c4, 1);
1537:     d4 = c3^ROL64(c0, 1);
1538: 
1539:     b0 = (a00^d0);
1540:     b1 = ROL64((a11^d1), 44);
1541:     b2 = ROL64((a22^d2), 43);
1542:     b3 = ROL64((a33^d3), 21);
1543:     b4 = ROL64((a44^d4), 14);
1544:     a00 =   b0 ^((~b1)&  b2 );
1545:     a00 ^= RC[i];
1546:     a11 =   b1 ^((~b2)&  b3 );
1547:     a22 =   b2 ^((~b3)&  b4 );
1548:     a33 =   b3 ^((~b4)&  b0 );
1549:     a44 =   b4 ^((~b0)&  b1 );
1550: 
1551:     b2 = ROL64((a20^d0), 3);
1552:     b3 = ROL64((a31^d1), 45);
1553:     b4 = ROL64((a42^d2), 61);
1554:     b0 = ROL64((a03^d3), 28);
1555:     b1 = ROL64((a14^d4), 20);
1556:     a20 =   b0 ^((~b1)&  b2 );
1557:     a31 =   b1 ^((~b2)&  b3 );
1558:     a42 =   b2 ^((~b3)&  b4 );
1559:     a03 =   b3 ^((~b4)&  b0 );
1560:     a14 =   b4 ^((~b0)&  b1 );
1561: 
1562:     b4 = ROL64((a40^d0), 18);
1563:     b0 = ROL64((a01^d1), 1);
1564:     b1 = ROL64((a12^d2), 6);
1565:     b2 = ROL64((a23^d3), 25);
1566:     b3 = ROL64((a34^d4), 8);
1567:     a40 =   b0 ^((~b1)&  b2 );
1568:     a01 =   b1 ^((~b2)&  b3 );
1569:     a12 =   b2 ^((~b3)&  b4 );
1570:     a23 =   b3 ^((~b4)&  b0 );
1571:     a34 =   b4 ^((~b0)&  b1 );
1572: 
1573:     b1 = ROL64((a10^d0), 36);
1574:     b2 = ROL64((a21^d1), 10);
1575:     b3 = ROL64((a32^d2), 15);
1576:     b4 = ROL64((a43^d3), 56);
1577:     b0 = ROL64((a04^d4), 27);
1578:     a10 =   b0 ^((~b1)&  b2 );
1579:     a21 =   b1 ^((~b2)&  b3 );
1580:     a32 =   b2 ^((~b3)&  b4 );
1581:     a43 =   b3 ^((~b4)&  b0 );
1582:     a04 =   b4 ^((~b0)&  b1 );
1583: 
1584:     b3 = ROL64((a30^d0), 41);
1585:     b4 = ROL64((a41^d1), 2);
1586:     b0 = ROL64((a02^d2), 62);
1587:     b1 = ROL64((a13^d3), 55);
1588:     b2 = ROL64((a24^d4), 39);
1589:     a30 =   b0 ^((~b1)&  b2 );
1590:     a41 =   b1 ^((~b2)&  b3 );
1591:     a02 =   b2 ^((~b3)&  b4 );
1592:     a13 =   b3 ^((~b4)&  b0 );
1593:     a24 =   b4 ^((~b0)&  b1 );
1594: 
1595:     c0 = a00^a20^a40^a10^a30;
1596:     c1 = a11^a31^a01^a21^a41;
1597:     c2 = a22^a42^a12^a32^a02;
1598:     c3 = a33^a03^a23^a43^a13;
1599:     c4 = a44^a14^a34^a04^a24;
1600:     d0 = c4^ROL64(c1, 1);
1601:     d1 = c0^ROL64(c2, 1);
1602:     d2 = c1^ROL64(c3, 1);
1603:     d3 = c2^ROL64(c4, 1);
1604:     d4 = c3^ROL64(c0, 1);
1605: 
1606:     b0 = (a00^d0);
1607:     b1 = ROL64((a31^d1), 44);
1608:     b2 = ROL64((a12^d2), 43);
1609:     b3 = ROL64((a43^d3), 21);
1610:     b4 = ROL64((a24^d4), 14);
1611:     a00 =   b0 ^((~b1)&  b2 );
1612:     a00 ^= RC[i+1];
1613:     a31 =   b1 ^((~b2)&  b3 );
1614:     a12 =   b2 ^((~b3)&  b4 );
1615:     a43 =   b3 ^((~b4)&  b0 );
1616:     a24 =   b4 ^((~b0)&  b1 );
1617: 
1618:     b2 = ROL64((a40^d0), 3);
1619:     b3 = ROL64((a21^d1), 45);
1620:     b4 = ROL64((a02^d2), 61);
1621:     b0 = ROL64((a33^d3), 28);
1622:     b1 = ROL64((a14^d4), 20);
1623:     a40 =   b0 ^((~b1)&  b2 );
1624:     a21 =   b1 ^((~b2)&  b3 );
1625:     a02 =   b2 ^((~b3)&  b4 );
1626:     a33 =   b3 ^((~b4)&  b0 );
1627:     a14 =   b4 ^((~b0)&  b1 );
1628: 
1629:     b4 = ROL64((a30^d0), 18);
1630:     b0 = ROL64((a11^d1), 1);
1631:     b1 = ROL64((a42^d2), 6);
1632:     b2 = ROL64((a23^d3), 25);
1633:     b3 = ROL64((a04^d4), 8);
1634:     a30 =   b0 ^((~b1)&  b2 );
1635:     a11 =   b1 ^((~b2)&  b3 );
1636:     a42 =   b2 ^((~b3)&  b4 );
1637:     a23 =   b3 ^((~b4)&  b0 );
1638:     a04 =   b4 ^((~b0)&  b1 );
1639: 
1640:     b1 = ROL64((a20^d0), 36);
1641:     b2 = ROL64((a01^d1), 10);
1642:     b3 = ROL64((a32^d2), 15);
1643:     b4 = ROL64((a13^d3), 56);
1644:     b0 = ROL64((a44^d4), 27);
1645:     a20 =   b0 ^((~b1)&  b2 );
1646:     a01 =   b1 ^((~b2)&  b3 );
1647:     a32 =   b2 ^((~b3)&  b4 );
1648:     a13 =   b3 ^((~b4)&  b0 );
1649:     a44 =   b4 ^((~b0)&  b1 );
1650: 
1651:     b3 = ROL64((a10^d0), 41);
1652:     b4 = ROL64((a41^d1), 2);
1653:     b0 = ROL64((a22^d2), 62);
1654:     b1 = ROL64((a03^d3), 55);
1655:     b2 = ROL64((a34^d4), 39);
1656:     a10 =   b0 ^((~b1)&  b2 );
1657:     a41 =   b1 ^((~b2)&  b3 );
1658:     a22 =   b2 ^((~b3)&  b4 );
1659:     a03 =   b3 ^((~b4)&  b0 );
1660:     a34 =   b4 ^((~b0)&  b1 );
1661: 
1662:     c0 = a00^a40^a30^a20^a10;
1663:     c1 = a31^a21^a11^a01^a41;
1664:     c2 = a12^a02^a42^a32^a22;
1665:     c3 = a43^a33^a23^a13^a03;
1666:     c4 = a24^a14^a04^a44^a34;
1667:     d0 = c4^ROL64(c1, 1);
1668:     d1 = c0^ROL64(c2, 1);
1669:     d2 = c1^ROL64(c3, 1);
1670:     d3 = c2^ROL64(c4, 1);
1671:     d4 = c3^ROL64(c0, 1);
1672: 
1673:     b0 = (a00^d0);
1674:     b1 = ROL64((a21^d1), 44);
1675:     b2 = ROL64((a42^d2), 43);
1676:     b3 = ROL64((a13^d3), 21);
1677:     b4 = ROL64((a34^d4), 14);
1678:     a00 =   b0 ^((~b1)&  b2 );
1679:     a00 ^= RC[i+2];
1680:     a21 =   b1 ^((~b2)&  b3 );
1681:     a42 =   b2 ^((~b3)&  b4 );
1682:     a13 =   b3 ^((~b4)&  b0 );
1683:     a34 =   b4 ^((~b0)&  b1 );
1684: 
1685:     b2 = ROL64((a30^d0), 3);
1686:     b3 = ROL64((a01^d1), 45);
1687:     b4 = ROL64((a22^d2), 61);
1688:     b0 = ROL64((a43^d3), 28);
1689:     b1 = ROL64((a14^d4), 20);
1690:     a30 =   b0 ^((~b1)&  b2 );
1691:     a01 =   b1 ^((~b2)&  b3 );
1692:     a22 =   b2 ^((~b3)&  b4 );
1693:     a43 =   b3 ^((~b4)&  b0 );
1694:     a14 =   b4 ^((~b0)&  b1 );
1695: 
1696:     b4 = ROL64((a10^d0), 18);
1697:     b0 = ROL64((a31^d1), 1);
1698:     b1 = ROL64((a02^d2), 6);
1699:     b2 = ROL64((a23^d3), 25);
1700:     b3 = ROL64((a44^d4), 8);
1701:     a10 =   b0 ^((~b1)&  b2 );
1702:     a31 =   b1 ^((~b2)&  b3 );
1703:     a02 =   b2 ^((~b3)&  b4 );
1704:     a23 =   b3 ^((~b4)&  b0 );
1705:     a44 =   b4 ^((~b0)&  b1 );
1706: 
1707:     b1 = ROL64((a40^d0), 36);
1708:     b2 = ROL64((a11^d1), 10);
1709:     b3 = ROL64((a32^d2), 15);
1710:     b4 = ROL64((a03^d3), 56);
1711:     b0 = ROL64((a24^d4), 27);
1712:     a40 =   b0 ^((~b1)&  b2 );
1713:     a11 =   b1 ^((~b2)&  b3 );
1714:     a32 =   b2 ^((~b3)&  b4 );
1715:     a03 =   b3 ^((~b4)&  b0 );
1716:     a24 =   b4 ^((~b0)&  b1 );
1717: 
1718:     b3 = ROL64((a20^d0), 41);
1719:     b4 = ROL64((a41^d1), 2);
1720:     b0 = ROL64((a12^d2), 62);
1721:     b1 = ROL64((a33^d3), 55);
1722:     b2 = ROL64((a04^d4), 39);
1723:     a20 =   b0 ^((~b1)&  b2 );
1724:     a41 =   b1 ^((~b2)&  b3 );
1725:     a12 =   b2 ^((~b3)&  b4 );
1726:     a33 =   b3 ^((~b4)&  b0 );
1727:     a04 =   b4 ^((~b0)&  b1 );
1728: 
1729:     c0 = a00^a30^a10^a40^a20;
1730:     c1 = a21^a01^a31^a11^a41;
1731:     c2 = a42^a22^a02^a32^a12;
1732:     c3 = a13^a43^a23^a03^a33;
1733:     c4 = a34^a14^a44^a24^a04;
1734:     d0 = c4^ROL64(c1, 1);
1735:     d1 = c0^ROL64(c2, 1);
1736:     d2 = c1^ROL64(c3, 1);
1737:     d3 = c2^ROL64(c4, 1);
1738:     d4 = c3^ROL64(c0, 1);
1739: 
1740:     b0 = (a00^d0);
1741:     b1 = ROL64((a01^d1), 44);
1742:     b2 = ROL64((a02^d2), 43);
1743:     b3 = ROL64((a03^d3), 21);
1744:     b4 = ROL64((a04^d4), 14);
1745:     a00 =   b0 ^((~b1)&  b2 );
1746:     a00 ^= RC[i+3];
1747:     a01 =   b1 ^((~b2)&  b3 );
1748:     a02 =   b2 ^((~b3)&  b4 );
1749:     a03 =   b3 ^((~b4)&  b0 );
1750:     a04 =   b4 ^((~b0)&  b1 );
1751: 
1752:     b2 = ROL64((a10^d0), 3);
1753:     b3 = ROL64((a11^d1), 45);
1754:     b4 = ROL64((a12^d2), 61);
1755:     b0 = ROL64((a13^d3), 28);
1756:     b1 = ROL64((a14^d4), 20);
1757:     a10 =   b0 ^((~b1)&  b2 );
1758:     a11 =   b1 ^((~b2)&  b3 );
1759:     a12 =   b2 ^((~b3)&  b4 );
1760:     a13 =   b3 ^((~b4)&  b0 );
1761:     a14 =   b4 ^((~b0)&  b1 );
1762: 
1763:     b4 = ROL64((a20^d0), 18);
1764:     b0 = ROL64((a21^d1), 1);
1765:     b1 = ROL64((a22^d2), 6);
1766:     b2 = ROL64((a23^d3), 25);
1767:     b3 = ROL64((a24^d4), 8);
1768:     a20 =   b0 ^((~b1)&  b2 );
1769:     a21 =   b1 ^((~b2)&  b3 );
1770:     a22 =   b2 ^((~b3)&  b4 );
1771:     a23 =   b3 ^((~b4)&  b0 );
1772:     a24 =   b4 ^((~b0)&  b1 );
1773: 
1774:     b1 = ROL64((a30^d0), 36);
1775:     b2 = ROL64((a31^d1), 10);
1776:     b3 = ROL64((a32^d2), 15);
1777:     b4 = ROL64((a33^d3), 56);
1778:     b0 = ROL64((a34^d4), 27);
1779:     a30 =   b0 ^((~b1)&  b2 );
1780:     a31 =   b1 ^((~b2)&  b3 );
1781:     a32 =   b2 ^((~b3)&  b4 );
1782:     a33 =   b3 ^((~b4)&  b0 );
1783:     a34 =   b4 ^((~b0)&  b1 );
1784: 
1785:     b3 = ROL64((a40^d0), 41);
1786:     b4 = ROL64((a41^d1), 2);
1787:     b0 = ROL64((a42^d2), 62);
1788:     b1 = ROL64((a43^d3), 55);
1789:     b2 = ROL64((a44^d4), 39);
1790:     a40 =   b0 ^((~b1)&  b2 );
1791:     a41 =   b1 ^((~b2)&  b3 );
1792:     a42 =   b2 ^((~b3)&  b4 );
1793:     a43 =   b3 ^((~b4)&  b0 );
1794:     a44 =   b4 ^((~b0)&  b1 );
1795:   }
1796: }
1797: 
1798: /*
1799: ** Initialize a new hash.  iSize determines the size of the hash
1800: ** in bits and should be one of 224, 256, 384, or 512.  Or iSize
1801: ** can be zero to use the default hash size of 256 bits.
1802: */
1803: static void SHA3Init(SHA3Context *p, int iSize){
1804:   memset(p, 0, sizeof(*p));
1805:   if( iSize>=128 && iSize<=512 ){
1806:     p->nRate = (1600 - ((iSize + 31)&~31)*2)/8;
1807:   }else{
1808:     p->nRate = (1600 - 2*256)/8;
1809:   }
1810: #if SHA3_BYTEORDER==1234
1811:   /* Known to be little-endian at compile-time. No-op */
1812: #elif SHA3_BYTEORDER==4321
1813:   p->ixMask = 7;  /* Big-endian */
1814: #else
1815:   {
1816:     static unsigned int one = 1;
1817:     if( 1==*(unsigned char*)&one ){
1818:       /* Little endian.  No byte swapping. */
1819:       p->ixMask = 0;
1820:     }else{
1821:       /* Big endian.  Byte swap. */
1822:       p->ixMask = 7;
1823:     }
1824:   }
1825: #endif
1826: }
1827: 
1828: /*
1829: ** Make consecutive calls to the SHA3Update function to add new content
1830: ** to the hash
1831: */
1832: static void SHA3Update(
1833:   SHA3Context *p,
1834:   const unsigned char *aData,
1835:   unsigned int nData
1836: ){
1837:   unsigned int i = 0;
1838: #if SHA3_BYTEORDER==1234
1839:   if( (p->nLoaded % 8)==0 && ((aData - (const unsigned char*)0)&7)==0 ){
1840:     for(; i+7<nData; i+=8){
1841:       p->u.s[p->nLoaded/8] ^= *(u64*)&aData[i];
1842:       p->nLoaded += 8;
1843:       if( p->nLoaded>=p->nRate ){
1844:         KeccakF1600Step(p);
1845:         p->nLoaded = 0;
1846:       }
1847:     }
1848:   }
1849: #endif
1850:   for(; i<nData; i++){
1851: #if SHA3_BYTEORDER==1234
1852:     p->u.x[p->nLoaded] ^= aData[i];
1853: #elif SHA3_BYTEORDER==4321
1854:     p->u.x[p->nLoaded^0x07] ^= aData[i];
1855: #else
1856:     p->u.x[p->nLoaded^p->ixMask] ^= aData[i];
1857: #endif
1858:     p->nLoaded++;
1859:     if( p->nLoaded==p->nRate ){
1860:       KeccakF1600Step(p);
1861:       p->nLoaded = 0;
1862:     }
1863:   }
1864: }
1865: 
1866: /*
1867: ** After all content has been added, invoke SHA3Final() to compute
1868: ** the final hash.  The function returns a pointer to the binary
1869: ** hash value.
1870: */
1871: static unsigned char *SHA3Final(SHA3Context *p){
1872:   unsigned int i;
1873:   if( p->nLoaded==p->nRate-1 ){
1874:     const unsigned char c1 = 0x86;
1875:     SHA3Update(p, &c1, 1);
1876:   }else{
1877:     const unsigned char c2 = 0x06;
1878:     const unsigned char c3 = 0x80;
1879:     SHA3Update(p, &c2, 1);
1880:     p->nLoaded = p->nRate - 1;
1881:     SHA3Update(p, &c3, 1);
1882:   }
1883:   for(i=0; i<p->nRate; i++){
1884:     p->u.x[i+p->nRate] = p->u.x[i^p->ixMask];
1885:   }
1886:   return &p->u.x[p->nRate];
1887: }
1888: /* End of the hashing logic
1889: *****************************************************************************/
1890: 
1891: /*
1892: ** Implementation of the sha3(X,SIZE) function.
1893: **
1894: ** Return a BLOB which is the SIZE-bit SHA3 hash of X.  The default
1895: ** size is 256.  If X is a BLOB, it is hashed as is.
1896: ** For all other non-NULL types of input, X is converted into a UTF-8 string
1897: ** and the string is hashed without the trailing 0x00 terminator.  The hash
1898: ** of a NULL value is NULL.
1899: */
1900: static void sha3Func(
1901:   sqlite3_context *context,
1902:   int argc,
1903:   sqlite3_value **argv
1904: ){
1905:   SHA3Context cx;
1906:   int eType = sqlite3_value_type(argv[0]);
1907:   int nByte = sqlite3_value_bytes(argv[0]);
1908:   int iSize;
1909:   if( argc==1 ){
1910:     iSize = 256;
1911:   }else{
1912:     iSize = sqlite3_value_int(argv[1]);
1913:     if( iSize!=224 && iSize!=256 && iSize!=384 && iSize!=512 ){
1914:       sqlite3_result_error(context, "SHA3 size should be one of: 224 256 "
1915:                                     "384 512", -1);
1916:       return;
1917:     }
1918:   }
1919:   if( eType==SQLITE_NULL ) return;
1920:   SHA3Init(&cx, iSize);
1921:   if( eType==SQLITE_BLOB ){
1922:     SHA3Update(&cx, sqlite3_value_blob(argv[0]), nByte);
1923:   }else{
1924:     SHA3Update(&cx, sqlite3_value_text(argv[0]), nByte);
1925:   }
1926:   sqlite3_result_blob(context, SHA3Final(&cx), iSize/8, SQLITE_TRANSIENT);
1927: }
1928: 
1929: /* Compute a string using sqlite3_vsnprintf() with a maximum length
1930: ** of 50 bytes and add it to the hash.
1931: */
1932: static void hash_step_vformat(
1933:   SHA3Context *p,                 /* Add content to this context */
1934:   const char *zFormat,
1935:   ...
1936: ){
1937:   va_list ap;
1938:   int n;
1939:   char zBuf[50];
1940:   va_start(ap, zFormat);
1941:   sqlite3_vsnprintf(sizeof(zBuf),zBuf,zFormat,ap);
1942:   va_end(ap);
1943:   n = (int)strlen(zBuf);
1944:   SHA3Update(p, (unsigned char*)zBuf, n);
1945: }
1946: 
1947: /*
1948: ** Implementation of the sha3_query(SQL,SIZE) function.
1949: **
1950: ** This function compiles and runs the SQL statement(s) given in the
1951: ** argument. The results are hashed using a SIZE-bit SHA3.  The default
1952: ** size is 256.
1953: **
1954: ** The format of the byte stream that is hashed is summarized as follows:
1955: **
1956: **       S<n>:<sql>
1957: **       R
1958: **       N
1959: **       I<int>
1960: **       F<ieee-float>
1961: **       B<size>:<bytes>
1962: **       T<size>:<text>
1963: **
1964: ** <sql> is the original SQL text for each statement run and <n> is
1965: ** the size of that text.  The SQL text is UTF-8.  A single R character
1966: ** occurs before the start of each row.  N means a NULL value.
1967: ** I mean an 8-byte little-endian integer <int>.  F is a floating point
1968: ** number with an 8-byte little-endian IEEE floating point value <ieee-float>.
1969: ** B means blobs of <size> bytes.  T means text rendered as <size>
1970: ** bytes of UTF-8.  The <n> and <size> values are expressed as an ASCII
1971: ** text integers.
1972: **
1973: ** For each SQL statement in the X input, there is one S segment.  Each
1974: ** S segment is followed by zero or more R segments, one for each row in the
1975: ** result set.  After each R, there are one or more N, I, F, B, or T segments,
1976: ** one for each column in the result set.  Segments are concatentated directly
1977: ** with no delimiters of any kind.
1978: */
1979: static void sha3QueryFunc(
1980:   sqlite3_context *context,
1981:   int argc,
1982:   sqlite3_value **argv
1983: ){
1984:   sqlite3 *db = sqlite3_context_db_handle(context);
1985:   const char *zSql = (const char*)sqlite3_value_text(argv[0]);
1986:   sqlite3_stmt *pStmt = 0;
1987:   int nCol;                   /* Number of columns in the result set */
1988:   int i;                      /* Loop counter */
1989:   int rc;
1990:   int n;
1991:   const char *z;
1992:   SHA3Context cx;
1993:   int iSize;
1994: 
1995:   if( argc==1 ){
1996:     iSize = 256;
1997:   }else{
1998:     iSize = sqlite3_value_int(argv[1]);
1999:     if( iSize!=224 && iSize!=256 && iSize!=384 && iSize!=512 ){
2000:       sqlite3_result_error(context, "SHA3 size should be one of: 224 256 "
2001:                                     "384 512", -1);
2002:       return;
2003:     }
2004:   }
2005:   if( zSql==0 ) return;
2006:   SHA3Init(&cx, iSize);
2007:   while( zSql[0] ){
2008:     rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zSql);
2009:     if( rc ){
2010:       char *zMsg = sqlite3_mprintf("error SQL statement [%s]: %s",
2011:                                    zSql, sqlite3_errmsg(db));
2012:       sqlite3_finalize(pStmt);
2013:       sqlite3_result_error(context, zMsg, -1);
2014:       sqlite3_free(zMsg);
2015:       return;
2016:     }
2017:     if( !sqlite3_stmt_readonly(pStmt) ){
2018:       char *zMsg = sqlite3_mprintf("non-query: [%s]", sqlite3_sql(pStmt));
2019:       sqlite3_finalize(pStmt);
2020:       sqlite3_result_error(context, zMsg, -1);
2021:       sqlite3_free(zMsg);
2022:       return;
2023:     }
2024:     nCol = sqlite3_column_count(pStmt);
2025:     z = sqlite3_sql(pStmt);
2026:     n = (int)strlen(z);
2027:     hash_step_vformat(&cx,"S%d:",n);
2028:     SHA3Update(&cx,(unsigned char*)z,n);
2029: 
2030:     /* Compute a hash over the result of the query */
2031:     while( SQLITE_ROW==sqlite3_step(pStmt) ){
2032:       SHA3Update(&cx,(const unsigned char*)"R",1);
2033:       for(i=0; i<nCol; i++){
2034:         switch( sqlite3_column_type(pStmt,i) ){
2035:           case SQLITE_NULL: {
2036:             SHA3Update(&cx, (const unsigned char*)"N",1);
2037:             break;
2038:           }
2039:           case SQLITE_INTEGER: {
2040:             sqlite3_uint64 u;
2041:             int j;
2042:             unsigned char x[9];
2043:             sqlite3_int64 v = sqlite3_column_int64(pStmt,i);
2044:             memcpy(&u, &v, 8);
2045:             for(j=8; j>=1; j--){
2046:               x[j] = u & 0xff;
2047:               u >>= 8;
2048:             }
2049:             x[0] = 'I';
2050:             SHA3Update(&cx, x, 9);
2051:             break;
2052:           }
2053:           case SQLITE_FLOAT: {
2054:             sqlite3_uint64 u;
2055:             int j;
2056:             unsigned char x[9];
2057:             double r = sqlite3_column_double(pStmt,i);
2058:             memcpy(&u, &r, 8);
2059:             for(j=8; j>=1; j--){
2060:               x[j] = u & 0xff;
2061:               u >>= 8;
2062:             }
2063:             x[0] = 'F';
2064:             SHA3Update(&cx,x,9);
2065:             break;
2066:           }
2067:           case SQLITE_TEXT: {
2068:             int n2 = sqlite3_column_bytes(pStmt, i);
2069:             const unsigned char *z2 = sqlite3_column_text(pStmt, i);
2070:             hash_step_vformat(&cx,"T%d:",n2);
2071:             SHA3Update(&cx, z2, n2);
2072:             break;
2073:           }
2074:           case SQLITE_BLOB: {
2075:             int n2 = sqlite3_column_bytes(pStmt, i);
2076:             const unsigned char *z2 = sqlite3_column_blob(pStmt, i);
2077:             hash_step_vformat(&cx,"B%d:",n2);
2078:             SHA3Update(&cx, z2, n2);
2079:             break;
2080:           }
2081:         }
2082:       }
2083:     }
2084:     sqlite3_finalize(pStmt);
2085:   }
2086:   sqlite3_result_blob(context, SHA3Final(&cx), iSize/8, SQLITE_TRANSIENT);
2087: }
2088: 
2089: 
2090: #ifdef _WIN32
2091: 
2092: #endif
2093: int sqlite3_shathree_init(
2094:   sqlite3 *db,
2095:   char **pzErrMsg,
2096:   const sqlite3_api_routines *pApi
2097: ){
2098:   int rc = SQLITE_OK;
2099:   SQLITE_EXTENSION_INIT2(pApi);
2100:   (void)pzErrMsg;  /* Unused parameter */
2101:   rc = sqlite3_create_function(db, "sha3", 1,
2102:                       SQLITE_UTF8 | SQLITE_INNOCUOUS | SQLITE_DETERMINISTIC,
2103:                       0, sha3Func, 0, 0);
2104:   if( rc==SQLITE_OK ){
2105:     rc = sqlite3_create_function(db, "sha3", 2,
2106:                       SQLITE_UTF8 | SQLITE_INNOCUOUS | SQLITE_DETERMINISTIC,
2107:                       0, sha3Func, 0, 0);
2108:   }
2109:   if( rc==SQLITE_OK ){
2110:     rc = sqlite3_create_function(db, "sha3_query", 1,
2111:                       SQLITE_UTF8 | SQLITE_DIRECTONLY,
2112:                       0, sha3QueryFunc, 0, 0);
2113:   }
2114:   if( rc==SQLITE_OK ){
2115:     rc = sqlite3_create_function(db, "sha3_query", 2,
2116:                       SQLITE_UTF8 | SQLITE_DIRECTONLY,
2117:                       0, sha3QueryFunc, 0, 0);
2118:   }
2119:   return rc;
2120: }
2121: 
2122: /************************* End ../ext/misc/shathree.c ********************/
2123: /************************* Begin ../ext/misc/fileio.c ******************/
2124: /*
2125: ** 2014-06-13
2126: **
2127: ** The author disclaims copyright to this source code.  In place of
2128: ** a legal notice, here is a blessing:
2129: **
2130: **    May you do good and not evil.
2131: **    May you find forgiveness for yourself and forgive others.
2132: **    May you share freely, never taking more than you give.
2133: **
2134: ******************************************************************************
2135: **
2136: ** This SQLite extension implements SQL functions readfile() and
2137: ** writefile(), and eponymous virtual type "fsdir".
2138: **
2139: ** WRITEFILE(FILE, DATA [, MODE [, MTIME]]):
2140: **
2141: **   If neither of the optional arguments is present, then this UDF
2142: **   function writes blob DATA to file FILE. If successful, the number
2143: **   of bytes written is returned. If an error occurs, NULL is returned.
2144: **
2145: **   If the first option argument - MODE - is present, then it must
2146: **   be passed an integer value that corresponds to a POSIX mode
2147: **   value (file type + permissions, as returned in the stat.st_mode
2148: **   field by the stat() system call). Three types of files may
2149: **   be written/created:
2150: **
2151: **     regular files:  (mode & 0170000)==0100000
2152: **     symbolic links: (mode & 0170000)==0120000
2153: **     directories:    (mode & 0170000)==0040000
2154: **
2155: **   For a directory, the DATA is ignored. For a symbolic link, it is
2156: **   interpreted as text and used as the target of the link. For a
2157: **   regular file, it is interpreted as a blob and written into the
2158: **   named file. Regardless of the type of file, its permissions are
2159: **   set to (mode & 0777) before returning.
2160: **
2161: **   If the optional MTIME argument is present, then it is interpreted
2162: **   as an integer - the number of seconds since the unix epoch. The
2163: **   modification-time of the target file is set to this value before
2164: **   returning.
2165: **
2166: **   If three or more arguments are passed to this function and an
2167: **   error is encountered, an exception is raised.
2168: **
2169: ** READFILE(FILE):
2170: **
2171: **   Read and return the contents of file FILE (type blob) from disk.
2172: **
2173: ** FSDIR:
2174: **
2175: **   Used as follows:
2176: **
2177: **     SELECT * FROM fsdir($path [, $dir]);
2178: **
2179: **   Parameter $path is an absolute or relative pathname. If the file that it
2180: **   refers to does not exist, it is an error. If the path refers to a regular
2181: **   file or symbolic link, it returns a single row. Or, if the path refers
2182: **   to a directory, it returns one row for the directory, and one row for each
2183: **   file within the hierarchy rooted at $path.
2184: **
2185: **   Each row has the following columns:
2186: **
2187: **     name:  Path to file or directory (text value).
2188: **     mode:  Value of stat.st_mode for directory entry (an integer).
2189: **     mtime: Value of stat.st_mtime for directory entry (an integer).
2190: **     data:  For a regular file, a blob containing the file data. For a
2191: **            symlink, a text value containing the text of the link. For a
2192: **            directory, NULL.
2193: **
2194: **   If a non-NULL value is specified for the optional $dir parameter and
2195: **   $path is a relative path, then $path is interpreted relative to $dir.
2196: **   And the paths returned in the "name" column of the table are also
2197: **   relative to directory $dir.
2198: */
2199: /* #include "sqlite3ext.h" */
2200: SQLITE_EXTENSION_INIT1
2201: #include <stdio.h>
2202: #include <string.h>
2203: #include <assert.h>
2204: 
2205: #include <sys/types.h>
2206: #include <sys/stat.h>
2207: #include <fcntl.h>
2208: #if !defined(_WIN32) && !defined(WIN32)
2209: #  include <unistd.h>
2210: #  include <dirent.h>
2211: #  include <utime.h>
2212: #  include <sys/time.h>
2213: #else
2214: #  include "windows.h"
2215: #  include <io.h>
2216: #  include <direct.h>
2217: /* #  include "test_windirent.h" */
2218: #  define dirent DIRENT
2219: #  ifndef chmod
2220: #    define chmod _chmod
2221: #  endif
2222: #  ifndef stat
2223: #    define stat _stat
2224: #  endif
2225: #  define mkdir(path,mode) _mkdir(path)
2226: #  define lstat(path,buf) stat(path,buf)
2227: #endif
2228: #include <time.h>
2229: #include <errno.h>
2230: 
2231: 
2232: /*
2233: ** Structure of the fsdir() table-valued function
2234: */
2235:                  /*    0    1    2     3    4           5             */
2236: #define FSDIR_SCHEMA "(name,mode,mtime,data,path HIDDEN,dir HIDDEN)"
2237: #define FSDIR_COLUMN_NAME     0     /* Name of the file */
2238: #define FSDIR_COLUMN_MODE     1     /* Access mode */
2239: #define FSDIR_COLUMN_MTIME    2     /* Last modification time */
2240: #define FSDIR_COLUMN_DATA     3     /* File content */
2241: #define FSDIR_COLUMN_PATH     4     /* Path to top of search */
2242: #define FSDIR_COLUMN_DIR      5     /* Path is relative to this directory */
2243: 
2244: 
2245: /*
2246: ** Set the result stored by context ctx to a blob containing the
2247: ** contents of file zName.  Or, leave the result unchanged (NULL)
2248: ** if the file does not exist or is unreadable.
2249: **
2250: ** If the file exceeds the SQLite blob size limit, through an
2251: ** SQLITE_TOOBIG error.
2252: **
2253: ** Throw an SQLITE_IOERR if there are difficulties pulling the file
2254: ** off of disk.
2255: */
2256: static void readFileContents(sqlite3_context *ctx, const char *zName){
2257:   FILE *in;
2258:   sqlite3_int64 nIn;
2259:   void *pBuf;
2260:   sqlite3 *db;
2261:   int mxBlob;
2262: 
2263:   in = fopen(zName, "rb");
2264:   if( in==0 ){
2265:     /* File does not exist or is unreadable. Leave the result set to NULL. */
2266:     return;
2267:   }
2268:   fseek(in, 0, SEEK_END);
2269:   nIn = ftell(in);
2270:   rewind(in);
2271:   db = sqlite3_context_db_handle(ctx);
2272:   mxBlob = sqlite3_limit(db, SQLITE_LIMIT_LENGTH, -1);
2273:   if( nIn>mxBlob ){
2274:     sqlite3_result_error_code(ctx, SQLITE_TOOBIG);
2275:     fclose(in);
2276:     return;
2277:   }
2278:   pBuf = sqlite3_malloc64( nIn ? nIn : 1 );
2279:   if( pBuf==0 ){
2280:     sqlite3_result_error_nomem(ctx);
2281:     fclose(in);
2282:     return;
2283:   }
2284:   if( nIn==(sqlite3_int64)fread(pBuf, 1, (size_t)nIn, in) ){
2285:     sqlite3_result_blob64(ctx, pBuf, nIn, sqlite3_free);
2286:   }else{
2287:     sqlite3_result_error_code(ctx, SQLITE_IOERR);
2288:     sqlite3_free(pBuf);
2289:   }
2290:   fclose(in);
2291: }
2292: 
2293: /*
2294: ** Implementation of the "readfile(X)" SQL function.  The entire content
2295: ** of the file named X is read and returned as a BLOB.  NULL is returned
2296: ** if the file does not exist or is unreadable.
2297: */
2298: static void readfileFunc(
2299:   sqlite3_context *context,
2300:   int argc,
2301:   sqlite3_value **argv
2302: ){
2303:   const char *zName;
2304:   (void)(argc);  /* Unused parameter */
2305:   zName = (const char*)sqlite3_value_text(argv[0]);
2306:   if( zName==0 ) return;
2307:   readFileContents(context, zName);
2308: }
2309: 
2310: /*
2311: ** Set the error message contained in context ctx to the results of
2312: ** vprintf(zFmt, ...).
2313: */
2314: static void ctxErrorMsg(sqlite3_context *ctx, const char *zFmt, ...){
2315:   char *zMsg = 0;
2316:   va_list ap;
2317:   va_start(ap, zFmt);
2318:   zMsg = sqlite3_vmprintf(zFmt, ap);
2319:   sqlite3_result_error(ctx, zMsg, -1);
2320:   sqlite3_free(zMsg);
2321:   va_end(ap);
2322: }
2323: 
2324: #if defined(_WIN32)
2325: /*
2326: ** This function is designed to convert a Win32 FILETIME structure into the
2327: ** number of seconds since the Unix Epoch (1970-01-01 00:00:00 UTC).
2328: */
2329: static sqlite3_uint64 fileTimeToUnixTime(
2330:   LPFILETIME pFileTime
2331: ){
2332:   SYSTEMTIME epochSystemTime;
2333:   ULARGE_INTEGER epochIntervals;
2334:   FILETIME epochFileTime;
2335:   ULARGE_INTEGER fileIntervals;
2336: 
2337:   memset(&epochSystemTime, 0, sizeof(SYSTEMTIME));
2338:   epochSystemTime.wYear = 1970;
2339:   epochSystemTime.wMonth = 1;
2340:   epochSystemTime.wDay = 1;
2341:   SystemTimeToFileTime(&epochSystemTime, &epochFileTime);
2342:   epochIntervals.LowPart = epochFileTime.dwLowDateTime;
2343:   epochIntervals.HighPart = epochFileTime.dwHighDateTime;
2344: 
2345:   fileIntervals.LowPart = pFileTime->dwLowDateTime;
2346:   fileIntervals.HighPart = pFileTime->dwHighDateTime;
2347: 
2348:   return (fileIntervals.QuadPart - epochIntervals.QuadPart) / 10000000;
2349: }
2350: 
2351: /*
2352: ** This function attempts to normalize the time values found in the stat()
2353: ** buffer to UTC.  This is necessary on Win32, where the runtime library
2354: ** appears to return these values as local times.
2355: */
2356: static void statTimesToUtc(
2357:   const char *zPath,
2358:   struct stat *pStatBuf
2359: ){
2360:   HANDLE hFindFile;
2361:   WIN32_FIND_DATAW fd;
2362:   LPWSTR zUnicodeName;
2363:   extern LPWSTR sqlite3_win32_utf8_to_unicode(const char*);
2364:   zUnicodeName = sqlite3_win32_utf8_to_unicode(zPath);
2365:   if( zUnicodeName ){
2366:     memset(&fd, 0, sizeof(WIN32_FIND_DATAW));
2367:     hFindFile = FindFirstFileW(zUnicodeName, &fd);
2368:     if( hFindFile!=NULL ){
2369:       pStatBuf->st_ctime = (time_t)fileTimeToUnixTime(&fd.ftCreationTime);
2370:       pStatBuf->st_atime = (time_t)fileTimeToUnixTime(&fd.ftLastAccessTime);
2371:       pStatBuf->st_mtime = (time_t)fileTimeToUnixTime(&fd.ftLastWriteTime);
2372:       FindClose(hFindFile);
2373:     }
2374:     sqlite3_free(zUnicodeName);
2375:   }
2376: }
2377: #endif
2378: 
2379: /*
2380: ** This function is used in place of stat().  On Windows, special handling
2381: ** is required in order for the included time to be returned as UTC.  On all
2382: ** other systems, this function simply calls stat().
2383: */
2384: static int fileStat(
2385:   const char *zPath,
2386:   struct stat *pStatBuf
2387: ){
2388: #if defined(_WIN32)
2389:   int rc = stat(zPath, pStatBuf);
2390:   if( rc==0 ) statTimesToUtc(zPath, pStatBuf);
2391:   return rc;
2392: #else
2393:   return stat(zPath, pStatBuf);
2394: #endif
2395: }
2396: 
2397: /*
2398: ** This function is used in place of lstat().  On Windows, special handling
2399: ** is required in order for the included time to be returned as UTC.  On all
2400: ** other systems, this function simply calls lstat().
2401: */
2402: static int fileLinkStat(
2403:   const char *zPath,
2404:   struct stat *pStatBuf
2405: ){
2406: #if defined(_WIN32)
2407:   int rc = lstat(zPath, pStatBuf);
2408:   if( rc==0 ) statTimesToUtc(zPath, pStatBuf);
2409:   return rc;
2410: #else
2411:   return lstat(zPath, pStatBuf);
2412: #endif
2413: }
2414: 
2415: /*
2416: ** Argument zFile is the name of a file that will be created and/or written
2417: ** by SQL function writefile(). This function ensures that the directory
2418: ** zFile will be written to exists, creating it if required. The permissions
2419: ** for any path components created by this function are set in accordance
2420: ** with the current umask.
2421: **
2422: ** If an OOM condition is encountered, SQLITE_NOMEM is returned. Otherwise,
2423: ** SQLITE_OK is returned if the directory is successfully created, or
2424: ** SQLITE_ERROR otherwise.
2425: */
2426: static int makeDirectory(
2427:   const char *zFile
2428: ){
2429:   char *zCopy = sqlite3_mprintf("%s", zFile);
2430:   int rc = SQLITE_OK;
2431: 
2432:   if( zCopy==0 ){
2433:     rc = SQLITE_NOMEM;
2434:   }else{
2435:     int nCopy = (int)strlen(zCopy);
2436:     int i = 1;
2437: 
2438:     while( rc==SQLITE_OK ){
2439:       struct stat sStat;
2440:       int rc2;
2441: 
2442:       for(; zCopy[i]!='/' && i<nCopy; i++);
2443:       if( i==nCopy ) break;
2444:       zCopy[i] = '\0';
2445: 
2446:       rc2 = fileStat(zCopy, &sStat);
2447:       if( rc2!=0 ){
2448:         if( mkdir(zCopy, 0777) ) rc = SQLITE_ERROR;
2449:       }else{
2450:         if( !S_ISDIR(sStat.st_mode) ) rc = SQLITE_ERROR;
2451:       }
2452:       zCopy[i] = '/';
2453:       i++;
2454:     }
2455: 
2456:     sqlite3_free(zCopy);
2457:   }
2458: 
2459:   return rc;
2460: }
2461: 
2462: /*
2463: ** This function does the work for the writefile() UDF. Refer to
2464: ** header comments at the top of this file for details.
2465: */
2466: static int writeFile(
2467:   sqlite3_context *pCtx,          /* Context to return bytes written in */
2468:   const char *zFile,              /* File to write */
2469:   sqlite3_value *pData,           /* Data to write */
2470:   mode_t mode,                    /* MODE parameter passed to writefile() */
2471:   sqlite3_int64 mtime             /* MTIME parameter (or -1 to not set time) */
2472: ){
2473: #if !defined(_WIN32) && !defined(WIN32)
2474:   if( S_ISLNK(mode) ){
2475:     const char *zTo = (const char*)sqlite3_value_text(pData);
2476:     if( symlink(zTo, zFile)<0 ) return 1;
2477:   }else
2478: #endif
2479:   {
2480:     if( S_ISDIR(mode) ){
2481:       if( mkdir(zFile, mode) ){
2482:         /* The mkdir() call to create the directory failed. This might not
2483:         ** be an error though - if there is already a directory at the same
2484:         ** path and either the permissions already match or can be changed
2485:         ** to do so using chmod(), it is not an error.  */
2486:         struct stat sStat;
2487:         if( errno!=EEXIST
2488:          || 0!=fileStat(zFile, &sStat)
2489:          || !S_ISDIR(sStat.st_mode)
2490:          || ((sStat.st_mode&0777)!=(mode&0777) && 0!=chmod(zFile, mode&0777))
2491:         ){
2492:           return 1;
2493:         }
2494:       }
2495:     }else{
2496:       sqlite3_int64 nWrite = 0;
2497:       const char *z;
2498:       int rc = 0;
2499:       FILE *out = fopen(zFile, "wb");
2500:       if( out==0 ) return 1;
2501:       z = (const char*)sqlite3_value_blob(pData);
2502:       if( z ){
2503:         sqlite3_int64 n = fwrite(z, 1, sqlite3_value_bytes(pData), out);
2504:         nWrite = sqlite3_value_bytes(pData);
2505:         if( nWrite!=n ){
2506:           rc = 1;
2507:         }
2508:       }
2509:       fclose(out);
2510:       if( rc==0 && mode && chmod(zFile, mode & 0777) ){
2511:         rc = 1;
2512:       }
2513:       if( rc ) return 2;
2514:       sqlite3_result_int64(pCtx, nWrite);
2515:     }
2516:   }
2517: 
2518:   if( mtime>=0 ){
2519: #if defined(_WIN32)
2520: #if !SQLITE_OS_WINRT
2521:     /* Windows */
2522:     FILETIME lastAccess;
2523:     FILETIME lastWrite;
2524:     SYSTEMTIME currentTime;
2525:     LONGLONG intervals;
2526:     HANDLE hFile;
2527:     LPWSTR zUnicodeName;
2528:     extern LPWSTR sqlite3_win32_utf8_to_unicode(const char*);
2529: 
2530:     GetSystemTime(&currentTime);
2531:     SystemTimeToFileTime(&currentTime, &lastAccess);
2532:     intervals = Int32x32To64(mtime, 10000000) + 116444736000000000;
2533:     lastWrite.dwLowDateTime = (DWORD)intervals;
2534:     lastWrite.dwHighDateTime = intervals >> 32;
2535:     zUnicodeName = sqlite3_win32_utf8_to_unicode(zFile);
2536:     if( zUnicodeName==0 ){
2537:       return 1;
2538:     }
2539:     hFile = CreateFileW(
2540:       zUnicodeName, FILE_WRITE_ATTRIBUTES, 0, NULL, OPEN_EXISTING,
2541:       FILE_FLAG_BACKUP_SEMANTICS, NULL
2542:     );
2543:     sqlite3_free(zUnicodeName);
2544:     if( hFile!=INVALID_HANDLE_VALUE ){
2545:       BOOL bResult = SetFileTime(hFile, NULL, &lastAccess, &lastWrite);
2546:       CloseHandle(hFile);
2547:       return !bResult;
2548:     }else{
2549:       return 1;
2550:     }
2551: #endif
2552: #elif defined(AT_FDCWD) && 0 /* utimensat() is not universally available */
2553:     /* Recent unix */
2554:     struct timespec times[2];
2555:     times[0].tv_nsec = times[1].tv_nsec = 0;
2556:     times[0].tv_sec = time(0);
2557:     times[1].tv_sec = mtime;
2558:     if( utimensat(AT_FDCWD, zFile, times, AT_SYMLINK_NOFOLLOW) ){
2559:       return 1;
2560:     }
2561: #else
2562:     /* Legacy unix */
2563:     struct timeval times[2];
2564:     times[0].tv_usec = times[1].tv_usec = 0;
2565:     times[0].tv_sec = time(0);
2566:     times[1].tv_sec = mtime;
2567:     if( utimes(zFile, times) ){
2568:       return 1;
2569:     }
2570: #endif
2571:   }
2572: 
2573:   return 0;
2574: }
2575: 
2576: /*
2577: ** Implementation of the "writefile(W,X[,Y[,Z]]])" SQL function.
2578: ** Refer to header comments at the top of this file for details.
2579: */
2580: static void writefileFunc(
2581:   sqlite3_context *context,
2582:   int argc,
2583:   sqlite3_value **argv
2584: ){
2585:   const char *zFile;
2586:   mode_t mode = 0;
2587:   int res;
2588:   sqlite3_int64 mtime = -1;
2589: 
2590:   if( argc<2 || argc>4 ){
2591:     sqlite3_result_error(context,
2592:         "wrong number of arguments to function writefile()", -1
2593:     );
2594:     return;
2595:   }
2596: 
2597:   zFile = (const char*)sqlite3_value_text(argv[0]);
2598:   if( zFile==0 ) return;
2599:   if( argc>=3 ){
2600:     mode = (mode_t)sqlite3_value_int(argv[2]);
2601:   }
2602:   if( argc==4 ){
2603:     mtime = sqlite3_value_int64(argv[3]);
2604:   }
2605: 
2606:   res = writeFile(context, zFile, argv[1], mode, mtime);
2607:   if( res==1 && errno==ENOENT ){
2608:     if( makeDirectory(zFile)==SQLITE_OK ){
2609:       res = writeFile(context, zFile, argv[1], mode, mtime);
2610:     }
2611:   }
2612: 
2613:   if( argc>2 && res!=0 ){
2614:     if( S_ISLNK(mode) ){
2615:       ctxErrorMsg(context, "failed to create symlink: %s", zFile);
2616:     }else if( S_ISDIR(mode) ){
2617:       ctxErrorMsg(context, "failed to create directory: %s", zFile);
2618:     }else{
2619:       ctxErrorMsg(context, "failed to write file: %s", zFile);
2620:     }
2621:   }
2622: }
2623: 
2624: /*
2625: ** SQL function:   lsmode(MODE)
2626: **
2627: ** Given a numberic st_mode from stat(), convert it into a human-readable
2628: ** text string in the style of "ls -l".
2629: */
2630: static void lsModeFunc(
2631:   sqlite3_context *context,
2632:   int argc,
2633:   sqlite3_value **argv
2634: ){
2635:   int i;
2636:   int iMode = sqlite3_value_int(argv[0]);
2637:   char z[16];
2638:   (void)argc;
2639:   if( S_ISLNK(iMode) ){
2640:     z[0] = 'l';
2641:   }else if( S_ISREG(iMode) ){
2642:     z[0] = '-';
2643:   }else if( S_ISDIR(iMode) ){
2644:     z[0] = 'd';
2645:   }else{
2646:     z[0] = '?';
2647:   }
2648:   for(i=0; i<3; i++){
2649:     int m = (iMode >> ((2-i)*3));
2650:     char *a = &z[1 + i*3];
2651:     a[0] = (m & 0x4) ? 'r' : '-';
2652:     a[1] = (m & 0x2) ? 'w' : '-';
2653:     a[2] = (m & 0x1) ? 'x' : '-';
2654:   }
2655:   z[10] = '\0';
2656:   sqlite3_result_text(context, z, -1, SQLITE_TRANSIENT);
2657: }
2658: 
2659: #ifndef SQLITE_OMIT_VIRTUALTABLE
2660: 
2661: /*
2662: ** Cursor type for recursively iterating through a directory structure.
2663: */
2664: typedef struct fsdir_cursor fsdir_cursor;
2665: typedef struct FsdirLevel FsdirLevel;
2666: 
2667: struct FsdirLevel {
2668:   DIR *pDir;                 /* From opendir() */
2669:   char *zDir;                /* Name of directory (nul-terminated) */
2670: };
2671: 
2672: struct fsdir_cursor {
2673:   sqlite3_vtab_cursor base;  /* Base class - must be first */
2674: 
2675:   int nLvl;                  /* Number of entries in aLvl[] array */
2676:   int iLvl;                  /* Index of current entry */
2677:   FsdirLevel *aLvl;          /* Hierarchy of directories being traversed */
2678: 
2679:   const char *zBase;
2680:   int nBase;
2681: 
2682:   struct stat sStat;         /* Current lstat() results */
2683:   char *zPath;               /* Path to current entry */
2684:   sqlite3_int64 iRowid;      /* Current rowid */
2685: };
2686: 
2687: typedef struct fsdir_tab fsdir_tab;
2688: struct fsdir_tab {
2689:   sqlite3_vtab base;         /* Base class - must be first */
2690: };
2691: 
2692: /*
2693: ** Construct a new fsdir virtual table object.
2694: */
2695: static int fsdirConnect(
2696:   sqlite3 *db,
2697:   void *pAux,
2698:   int argc, const char *const*argv,
2699:   sqlite3_vtab **ppVtab,
2700:   char **pzErr
2701: ){
2702:   fsdir_tab *pNew = 0;
2703:   int rc;
2704:   (void)pAux;
2705:   (void)argc;
2706:   (void)argv;
2707:   (void)pzErr;
2708:   rc = sqlite3_declare_vtab(db, "CREATE TABLE x" FSDIR_SCHEMA);
2709:   if( rc==SQLITE_OK ){
2710:     pNew = (fsdir_tab*)sqlite3_malloc( sizeof(*pNew) );
2711:     if( pNew==0 ) return SQLITE_NOMEM;
2712:     memset(pNew, 0, sizeof(*pNew));
2713:     sqlite3_vtab_config(db, SQLITE_VTAB_DIRECTONLY);
2714:   }
2715:   *ppVtab = (sqlite3_vtab*)pNew;
2716:   return rc;
2717: }
2718: 
2719: /*
2720: ** This method is the destructor for fsdir vtab objects.
2721: */
2722: static int fsdirDisconnect(sqlite3_vtab *pVtab){
2723:   sqlite3_free(pVtab);
2724:   return SQLITE_OK;
2725: }
2726: 
2727: /*
2728: ** Constructor for a new fsdir_cursor object.
2729: */
2730: static int fsdirOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){
2731:   fsdir_cursor *pCur;
2732:   (void)p;
2733:   pCur = sqlite3_malloc( sizeof(*pCur) );
2734:   if( pCur==0 ) return SQLITE_NOMEM;
2735:   memset(pCur, 0, sizeof(*pCur));
2736:   pCur->iLvl = -1;
2737:   *ppCursor = &pCur->base;
2738:   return SQLITE_OK;
2739: }
2740: 
2741: /*
2742: ** Reset a cursor back to the state it was in when first returned
2743: ** by fsdirOpen().
2744: */
2745: static void fsdirResetCursor(fsdir_cursor *pCur){
2746:   int i;
2747:   for(i=0; i<=pCur->iLvl; i++){
2748:     FsdirLevel *pLvl = &pCur->aLvl[i];
2749:     if( pLvl->pDir ) closedir(pLvl->pDir);
2750:     sqlite3_free(pLvl->zDir);
2751:   }
2752:   sqlite3_free(pCur->zPath);
2753:   sqlite3_free(pCur->aLvl);
2754:   pCur->aLvl = 0;
2755:   pCur->zPath = 0;
2756:   pCur->zBase = 0;
2757:   pCur->nBase = 0;
2758:   pCur->nLvl = 0;
2759:   pCur->iLvl = -1;
2760:   pCur->iRowid = 1;
2761: }
2762: 
2763: /*
2764: ** Destructor for an fsdir_cursor.
2765: */
2766: static int fsdirClose(sqlite3_vtab_cursor *cur){
2767:   fsdir_cursor *pCur = (fsdir_cursor*)cur;
2768: 
2769:   fsdirResetCursor(pCur);
2770:   sqlite3_free(pCur);
2771:   return SQLITE_OK;
2772: }
2773: 
2774: /*
2775: ** Set the error message for the virtual table associated with cursor
2776: ** pCur to the results of vprintf(zFmt, ...).
2777: */
2778: static void fsdirSetErrmsg(fsdir_cursor *pCur, const char *zFmt, ...){
2779:   va_list ap;
2780:   va_start(ap, zFmt);
2781:   pCur->base.pVtab->zErrMsg = sqlite3_vmprintf(zFmt, ap);
2782:   va_end(ap);
2783: }
2784: 
2785: 
2786: /*
2787: ** Advance an fsdir_cursor to its next row of output.
2788: */
2789: static int fsdirNext(sqlite3_vtab_cursor *cur){
2790:   fsdir_cursor *pCur = (fsdir_cursor*)cur;
2791:   mode_t m = pCur->sStat.st_mode;
2792: 
2793:   pCur->iRowid++;
2794:   if( S_ISDIR(m) ){
2795:     /* Descend into this directory */
2796:     int iNew = pCur->iLvl + 1;
2797:     FsdirLevel *pLvl;
2798:     if( iNew>=pCur->nLvl ){
2799:       int nNew = iNew+1;
2800:       sqlite3_int64 nByte = nNew*sizeof(FsdirLevel);
2801:       FsdirLevel *aNew = (FsdirLevel*)sqlite3_realloc64(pCur->aLvl, nByte);
2802:       if( aNew==0 ) return SQLITE_NOMEM;
2803:       memset(&aNew[pCur->nLvl], 0, sizeof(FsdirLevel)*(nNew-pCur->nLvl));
2804:       pCur->aLvl = aNew;
2805:       pCur->nLvl = nNew;
2806:     }
2807:     pCur->iLvl = iNew;
2808:     pLvl = &pCur->aLvl[iNew];
2809: 
2810:     pLvl->zDir = pCur->zPath;
2811:     pCur->zPath = 0;
2812:     pLvl->pDir = opendir(pLvl->zDir);
2813:     if( pLvl->pDir==0 ){
2814:       fsdirSetErrmsg(pCur, "cannot read directory: %s", pCur->zPath);
2815:       return SQLITE_ERROR;
2816:     }
2817:   }
2818: 
2819:   while( pCur->iLvl>=0 ){
2820:     FsdirLevel *pLvl = &pCur->aLvl[pCur->iLvl];
2821:     struct dirent *pEntry = readdir(pLvl->pDir);
2822:     if( pEntry ){
2823:       if( pEntry->d_name[0]=='.' ){
2824:        if( pEntry->d_name[1]=='.' && pEntry->d_name[2]=='\0' ) continue;
2825:        if( pEntry->d_name[1]=='\0' ) continue;
2826:       }
2827:       sqlite3_free(pCur->zPath);
2828:       pCur->zPath = sqlite3_mprintf("%s/%s", pLvl->zDir, pEntry->d_name);
2829:       if( pCur->zPath==0 ) return SQLITE_NOMEM;
2830:       if( fileLinkStat(pCur->zPath, &pCur->sStat) ){
2831:         fsdirSetErrmsg(pCur, "cannot stat file: %s", pCur->zPath);
2832:         return SQLITE_ERROR;
2833:       }
2834:       return SQLITE_OK;
2835:     }
2836:     closedir(pLvl->pDir);
2837:     sqlite3_free(pLvl->zDir);
2838:     pLvl->pDir = 0;
2839:     pLvl->zDir = 0;
2840:     pCur->iLvl--;
2841:   }
2842: 
2843:   /* EOF */
2844:   sqlite3_free(pCur->zPath);
2845:   pCur->zPath = 0;
2846:   return SQLITE_OK;
2847: }
2848: 
2849: /*
2850: ** Return values of columns for the row at which the series_cursor
2851: ** is currently pointing.
2852: */
2853: static int fsdirColumn(
2854:   sqlite3_vtab_cursor *cur,   /* The cursor */
2855:   sqlite3_context *ctx,       /* First argument to sqlite3_result_...() */
2856:   int i                       /* Which column to return */
2857: ){
2858:   fsdir_cursor *pCur = (fsdir_cursor*)cur;
2859:   switch( i ){
2860:     case FSDIR_COLUMN_NAME: {
2861:       sqlite3_result_text(ctx, &pCur->zPath[pCur->nBase], -1, SQLITE_TRANSIENT);
2862:       break;
2863:     }
2864: 
2865:     case FSDIR_COLUMN_MODE:
2866:       sqlite3_result_int64(ctx, pCur->sStat.st_mode);
2867:       break;
2868: 
2869:     case FSDIR_COLUMN_MTIME:
2870:       sqlite3_result_int64(ctx, pCur->sStat.st_mtime);
2871:       break;
2872: 
2873:     case FSDIR_COLUMN_DATA: {
2874:       mode_t m = pCur->sStat.st_mode;
2875:       if( S_ISDIR(m) ){
2876:         sqlite3_result_null(ctx);
2877: #if !defined(_WIN32) && !defined(WIN32)
2878:       }else if( S_ISLNK(m) ){
2879:         char aStatic[64];
2880:         char *aBuf = aStatic;
2881:         sqlite3_int64 nBuf = 64;
2882:         int n;
2883: 
2884:         while( 1 ){
2885:           n = readlink(pCur->zPath, aBuf, nBuf);
2886:           if( n<nBuf ) break;
2887:           if( aBuf!=aStatic ) sqlite3_free(aBuf);
2888:           nBuf = nBuf*2;
2889:           aBuf = sqlite3_malloc64(nBuf);
2890:           if( aBuf==0 ){
2891:             sqlite3_result_error_nomem(ctx);
2892:             return SQLITE_NOMEM;
2893:           }
2894:         }
2895: 
2896:         sqlite3_result_text(ctx, aBuf, n, SQLITE_TRANSIENT);
2897:         if( aBuf!=aStatic ) sqlite3_free(aBuf);
2898: #endif
2899:       }else{
2900:         readFileContents(ctx, pCur->zPath);
2901:       }
2902:     }
2903:     case FSDIR_COLUMN_PATH:
2904:     default: {
2905:       /* The FSDIR_COLUMN_PATH and FSDIR_COLUMN_DIR are input parameters.
2906:       ** always return their values as NULL */
2907:       break;
2908:     }
2909:   }
2910:   return SQLITE_OK;
2911: }
2912: 
2913: /*
2914: ** Return the rowid for the current row. In this implementation, the
2915: ** first row returned is assigned rowid value 1, and each subsequent
2916: ** row a value 1 more than that of the previous.
2917: */
2918: static int fsdirRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
2919:   fsdir_cursor *pCur = (fsdir_cursor*)cur;
2920:   *pRowid = pCur->iRowid;
2921:   return SQLITE_OK;
2922: }
2923: 
2924: /*
2925: ** Return TRUE if the cursor has been moved off of the last
2926: ** row of output.
2927: */
2928: static int fsdirEof(sqlite3_vtab_cursor *cur){
2929:   fsdir_cursor *pCur = (fsdir_cursor*)cur;
2930:   return (pCur->zPath==0);
2931: }
2932: 
2933: /*
2934: ** xFilter callback.
2935: **
2936: ** idxNum==1   PATH parameter only
2937: ** idxNum==2   Both PATH and DIR supplied
2938: */
2939: static int fsdirFilter(
2940:   sqlite3_vtab_cursor *cur,
2941:   int idxNum, const char *idxStr,
2942:   int argc, sqlite3_value **argv
2943: ){
2944:   const char *zDir = 0;
2945:   fsdir_cursor *pCur = (fsdir_cursor*)cur;
2946:   (void)idxStr;
2947:   fsdirResetCursor(pCur);
2948: 
2949:   if( idxNum==0 ){
2950:     fsdirSetErrmsg(pCur, "table function fsdir requires an argument");
2951:     return SQLITE_ERROR;
2952:   }
2953: 
2954:   assert( argc==idxNum && (argc==1 || argc==2) );
2955:   zDir = (const char*)sqlite3_value_text(argv[0]);
2956:   if( zDir==0 ){
2957:     fsdirSetErrmsg(pCur, "table function fsdir requires a non-NULL argument");
2958:     return SQLITE_ERROR;
2959:   }
2960:   if( argc==2 ){
2961:     pCur->zBase = (const char*)sqlite3_value_text(argv[1]);
2962:   }
2963:   if( pCur->zBase ){
2964:     pCur->nBase = (int)strlen(pCur->zBase)+1;
2965:     pCur->zPath = sqlite3_mprintf("%s/%s", pCur->zBase, zDir);
2966:   }else{
2967:     pCur->zPath = sqlite3_mprintf("%s", zDir);
2968:   }
2969: 
2970:   if( pCur->zPath==0 ){
2971:     return SQLITE_NOMEM;
2972:   }
2973:   if( fileLinkStat(pCur->zPath, &pCur->sStat) ){
2974:     fsdirSetErrmsg(pCur, "cannot stat file: %s", pCur->zPath);
2975:     return SQLITE_ERROR;
2976:   }
2977: 
2978:   return SQLITE_OK;
2979: }
2980: 
2981: /*
2982: ** SQLite will invoke this method one or more times while planning a query
2983: ** that uses the generate_series virtual table.  This routine needs to create
2984: ** a query plan for each invocation and compute an estimated cost for that
2985: ** plan.
2986: **
2987: ** In this implementation idxNum is used to represent the
2988: ** query plan.  idxStr is unused.
2989: **
2990: ** The query plan is represented by values of idxNum:
2991: **
2992: **  (1)  The path value is supplied by argv[0]
2993: **  (2)  Path is in argv[0] and dir is in argv[1]
2994: */
2995: static int fsdirBestIndex(
2996:   sqlite3_vtab *tab,
2997:   sqlite3_index_info *pIdxInfo
2998: ){
2999:   int i;                 /* Loop over constraints */
3000:   int idxPath = -1;      /* Index in pIdxInfo->aConstraint of PATH= */
3001:   int idxDir = -1;       /* Index in pIdxInfo->aConstraint of DIR= */
3002:   int seenPath = 0;      /* True if an unusable PATH= constraint is seen */
3003:   int seenDir = 0;       /* True if an unusable DIR= constraint is seen */
3004:   const struct sqlite3_index_constraint *pConstraint;
3005: 
3006:   (void)tab;
3007:   pConstraint = pIdxInfo->aConstraint;
3008:   for(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++){
3009:     if( pConstraint->op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;
3010:     switch( pConstraint->iColumn ){
3011:       case FSDIR_COLUMN_PATH: {
3012:         if( pConstraint->usable ){
3013:           idxPath = i;
3014:           seenPath = 0;
3015:         }else if( idxPath<0 ){
3016:           seenPath = 1;
3017:         }
3018:         break;
3019:       }
3020:       case FSDIR_COLUMN_DIR: {
3021:         if( pConstraint->usable ){
3022:           idxDir = i;
3023:           seenDir = 0;
3024:         }else if( idxDir<0 ){
3025:           seenDir = 1;
3026:         }
3027:         break;
3028:       }
3029:     }
3030:   }
3031:   if( seenPath || seenDir ){
3032:     /* If input parameters are unusable, disallow this plan */
3033:     return SQLITE_CONSTRAINT;
3034:   }
3035: 
3036:   if( idxPath<0 ){
3037:     pIdxInfo->idxNum = 0;
3038:     /* The pIdxInfo->estimatedCost should have been initialized to a huge
3039:     ** number.  Leave it unchanged. */
3040:     pIdxInfo->estimatedRows = 0x7fffffff;
3041:   }else{
3042:     pIdxInfo->aConstraintUsage[idxPath].omit = 1;
3043:     pIdxInfo->aConstraintUsage[idxPath].argvIndex = 1;
3044:     if( idxDir>=0 ){
3045:       pIdxInfo->aConstraintUsage[idxDir].omit = 1;
3046:       pIdxInfo->aConstraintUsage[idxDir].argvIndex = 2;
3047:       pIdxInfo->idxNum = 2;
3048:       pIdxInfo->estimatedCost = 10.0;
3049:     }else{
3050:       pIdxInfo->idxNum = 1;
3051:       pIdxInfo->estimatedCost = 100.0;
3052:     }
3053:   }
3054: 
3055:   return SQLITE_OK;
3056: }
3057: 
3058: /*
3059: ** Register the "fsdir" virtual table.
3060: */
3061: static int fsdirRegister(sqlite3 *db){
3062:   static sqlite3_module fsdirModule = {
3063:     0,                         /* iVersion */
3064:     0,                         /* xCreate */
3065:     fsdirConnect,              /* xConnect */
3066:     fsdirBestIndex,            /* xBestIndex */
3067:     fsdirDisconnect,           /* xDisconnect */
3068:     0,                         /* xDestroy */
3069:     fsdirOpen,                 /* xOpen - open a cursor */
3070:     fsdirClose,                /* xClose - close a cursor */
3071:     fsdirFilter,               /* xFilter - configure scan constraints */
3072:     fsdirNext,                 /* xNext - advance a cursor */
3073:     fsdirEof,                  /* xEof - check for end of scan */
3074:     fsdirColumn,               /* xColumn - read data */
3075:     fsdirRowid,                /* xRowid - read data */
3076:     0,                         /* xUpdate */
3077:     0,                         /* xBegin */
3078:     0,                         /* xSync */
3079:     0,                         /* xCommit */
3080:     0,                         /* xRollback */
3081:     0,                         /* xFindMethod */
3082:     0,                         /* xRename */
3083:     0,                         /* xSavepoint */
3084:     0,                         /* xRelease */
3085:     0,                         /* xRollbackTo */
3086:     0,                         /* xShadowName */
3087:   };
3088: 
3089:   int rc = sqlite3_create_module(db, "fsdir", &fsdirModule, 0);
3090:   return rc;
3091: }
3092: #else         /* SQLITE_OMIT_VIRTUALTABLE */
3093: # define fsdirRegister(x) SQLITE_OK
3094: #endif
3095: 
3096: #ifdef _WIN32
3097: 
3098: #endif
3099: int sqlite3_fileio_init(
3100:   sqlite3 *db,
3101:   char **pzErrMsg,
3102:   const sqlite3_api_routines *pApi
3103: ){
3104:   int rc = SQLITE_OK;
3105:   SQLITE_EXTENSION_INIT2(pApi);
3106:   (void)pzErrMsg;  /* Unused parameter */
3107:   rc = sqlite3_create_function(db, "readfile", 1,
3108:                                SQLITE_UTF8|SQLITE_DIRECTONLY, 0,
3109:                                readfileFunc, 0, 0);
3110:   if( rc==SQLITE_OK ){
3111:     rc = sqlite3_create_function(db, "writefile", -1,
3112:                                  SQLITE_UTF8|SQLITE_DIRECTONLY, 0,
3113:                                  writefileFunc, 0, 0);
3114:   }
3115:   if( rc==SQLITE_OK ){
3116:     rc = sqlite3_create_function(db, "lsmode", 1, SQLITE_UTF8, 0,
3117:                                  lsModeFunc, 0, 0);
3118:   }
3119:   if( rc==SQLITE_OK ){
3120:     rc = fsdirRegister(db);
3121:   }
3122:   return rc;
3123: }
3124: 
3125: /************************* End ../ext/misc/fileio.c ********************/
3126: /************************* Begin ../ext/misc/completion.c ******************/
3127: /*
3128: ** 2017-07-10
3129: **
3130: ** The author disclaims copyright to this source code.  In place of
3131: ** a legal notice, here is a blessing:
3132: **
3133: **    May you do good and not evil.
3134: **    May you find forgiveness for yourself and forgive others.
3135: **    May you share freely, never taking more than you give.
3136: **
3137: *************************************************************************
3138: **
3139: ** This file implements an eponymous virtual table that returns suggested
3140: ** completions for a partial SQL input.
3141: **
3142: ** Suggested usage:
3143: **
3144: **     SELECT DISTINCT candidate COLLATE nocase
3145: **       FROM completion($prefix,$wholeline)
3146: **      ORDER BY 1;
3147: **
3148: ** The two query parameters are optional.  $prefix is the text of the
3149: ** current word being typed and that is to be completed.  $wholeline is
3150: ** the complete input line, used for context.
3151: **
3152: ** The raw completion() table might return the same candidate multiple
3153: ** times, for example if the same column name is used to two or more
3154: ** tables.  And the candidates are returned in an arbitrary order.  Hence,
3155: ** the DISTINCT and ORDER BY are recommended.
3156: **
3157: ** This virtual table operates at the speed of human typing, and so there
3158: ** is no attempt to make it fast.  Even a slow implementation will be much
3159: ** faster than any human can type.
3160: **
3161: */
3162: /* #include "sqlite3ext.h" */
3163: SQLITE_EXTENSION_INIT1
3164: #include <assert.h>
3165: #include <string.h>
3166: #include <ctype.h>
3167: 
3168: #ifndef SQLITE_OMIT_VIRTUALTABLE
3169: 
3170: /* completion_vtab is a subclass of sqlite3_vtab which will
3171: ** serve as the underlying representation of a completion virtual table
3172: */
3173: typedef struct completion_vtab completion_vtab;
3174: struct completion_vtab {
3175:   sqlite3_vtab base;  /* Base class - must be first */
3176:   sqlite3 *db;        /* Database connection for this completion vtab */
3177: };
3178: 
3179: /* completion_cursor is a subclass of sqlite3_vtab_cursor which will
3180: ** serve as the underlying representation of a cursor that scans
3181: ** over rows of the result
3182: */
3183: typedef struct completion_cursor completion_cursor;
3184: struct completion_cursor {
3185:   sqlite3_vtab_cursor base;  /* Base class - must be first */
3186:   sqlite3 *db;               /* Database connection for this cursor */
3187:   int nPrefix, nLine;        /* Number of bytes in zPrefix and zLine */
3188:   char *zPrefix;             /* The prefix for the word we want to complete */
3189:   char *zLine;               /* The whole that we want to complete */
3190:   const char *zCurrentRow;   /* Current output row */
3191:   int szRow;                 /* Length of the zCurrentRow string */
3192:   sqlite3_stmt *pStmt;       /* Current statement */
3193:   sqlite3_int64 iRowid;      /* The rowid */
3194:   int ePhase;                /* Current phase */
3195:   int j;                     /* inter-phase counter */
3196: };
3197: 
3198: /* Values for ePhase:
3199: */
3200: #define COMPLETION_FIRST_PHASE   1
3201: #define COMPLETION_KEYWORDS      1
3202: #define COMPLETION_PRAGMAS       2
3203: #define COMPLETION_FUNCTIONS     3
3204: #define COMPLETION_COLLATIONS    4
3205: #define COMPLETION_INDEXES       5
3206: #define COMPLETION_TRIGGERS      6
3207: #define COMPLETION_DATABASES     7
3208: #define COMPLETION_TABLES        8    /* Also VIEWs and TRIGGERs */
3209: #define COMPLETION_COLUMNS       9
3210: #define COMPLETION_MODULES       10
3211: #define COMPLETION_EOF           11
3212: 
3213: /*
3214: ** The completionConnect() method is invoked to create a new
3215: ** completion_vtab that describes the completion virtual table.
3216: **
3217: ** Think of this routine as the constructor for completion_vtab objects.
3218: **
3219: ** All this routine needs to do is:
3220: **
3221: **    (1) Allocate the completion_vtab object and initialize all fields.
3222: **
3223: **    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
3224: **        result set of queries against completion will look like.
3225: */
3226: static int completionConnect(
3227:   sqlite3 *db,
3228:   void *pAux,
3229:   int argc, const char *const*argv,
3230:   sqlite3_vtab **ppVtab,
3231:   char **pzErr
3232: ){
3233:   completion_vtab *pNew;
3234:   int rc;
3235: 
3236:   (void)(pAux);    /* Unused parameter */
3237:   (void)(argc);    /* Unused parameter */
3238:   (void)(argv);    /* Unused parameter */
3239:   (void)(pzErr);   /* Unused parameter */
3240: 
3241: /* Column numbers */
3242: #define COMPLETION_COLUMN_CANDIDATE 0  /* Suggested completion of the input */
3243: #define COMPLETION_COLUMN_PREFIX    1  /* Prefix of the word to be completed */
3244: #define COMPLETION_COLUMN_WHOLELINE 2  /* Entire line seen so far */
3245: #define COMPLETION_COLUMN_PHASE     3  /* ePhase - used for debugging only */
3246: 
3247:   sqlite3_vtab_config(db, SQLITE_VTAB_INNOCUOUS);
3248:   rc = sqlite3_declare_vtab(db,
3249:       "CREATE TABLE x("
3250:       "  candidate TEXT,"
3251:       "  prefix TEXT HIDDEN,"
3252:       "  wholeline TEXT HIDDEN,"
3253:       "  phase INT HIDDEN"        /* Used for debugging only */
3254:       ")");
3255:   if( rc==SQLITE_OK ){
3256:     pNew = sqlite3_malloc( sizeof(*pNew) );
3257:     *ppVtab = (sqlite3_vtab*)pNew;
3258:     if( pNew==0 ) return SQLITE_NOMEM;
3259:     memset(pNew, 0, sizeof(*pNew));
3260:     pNew->db = db;
3261:   }
3262:   return rc;
3263: }
3264: 
3265: /*
3266: ** This method is the destructor for completion_cursor objects.
3267: */
3268: static int completionDisconnect(sqlite3_vtab *pVtab){
3269:   sqlite3_free(pVtab);
3270:   return SQLITE_OK;
3271: }
3272: 
3273: /*
3274: ** Constructor for a new completion_cursor object.
3275: */
3276: static int completionOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){
3277:   completion_cursor *pCur;
3278:   pCur = sqlite3_malloc( sizeof(*pCur) );
3279:   if( pCur==0 ) return SQLITE_NOMEM;
3280:   memset(pCur, 0, sizeof(*pCur));
3281:   pCur->db = ((completion_vtab*)p)->db;
3282:   *ppCursor = &pCur->base;
3283:   return SQLITE_OK;
3284: }
3285: 
3286: /*
3287: ** Reset the completion_cursor.
3288: */
3289: static void completionCursorReset(completion_cursor *pCur){
3290:   sqlite3_free(pCur->zPrefix);   pCur->zPrefix = 0;  pCur->nPrefix = 0;
3291:   sqlite3_free(pCur->zLine);     pCur->zLine = 0;    pCur->nLine = 0;
3292:   sqlite3_finalize(pCur->pStmt); pCur->pStmt = 0;
3293:   pCur->j = 0;
3294: }
3295: 
3296: /*
3297: ** Destructor for a completion_cursor.
3298: */
3299: static int completionClose(sqlite3_vtab_cursor *cur){
3300:   completionCursorReset((completion_cursor*)cur);
3301:   sqlite3_free(cur);
3302:   return SQLITE_OK;
3303: }
3304: 
3305: /*
3306: ** Advance a completion_cursor to its next row of output.
3307: **
3308: ** The ->ePhase, ->j, and ->pStmt fields of the completion_cursor object
3309: ** record the current state of the scan.  This routine sets ->zCurrentRow
3310: ** to the current row of output and then returns.  If no more rows remain,
3311: ** then ->ePhase is set to COMPLETION_EOF which will signal the virtual
3312: ** table that has reached the end of its scan.
3313: **
3314: ** The current implementation just lists potential identifiers and
3315: ** keywords and filters them by zPrefix.  Future enhancements should
3316: ** take zLine into account to try to restrict the set of identifiers and
3317: ** keywords based on what would be legal at the current point of input.
3318: */
3319: static int completionNext(sqlite3_vtab_cursor *cur){
3320:   completion_cursor *pCur = (completion_cursor*)cur;
3321:   int eNextPhase = 0;  /* Next phase to try if current phase reaches end */
3322:   int iCol = -1;       /* If >=0, step pCur->pStmt and use the i-th column */
3323:   pCur->iRowid++;
3324:   while( pCur->ePhase!=COMPLETION_EOF ){
3325:     switch( pCur->ePhase ){
3326:       case COMPLETION_KEYWORDS: {
3327:         if( pCur->j >= sqlite3_keyword_count() ){
3328:           pCur->zCurrentRow = 0;
3329:           pCur->ePhase = COMPLETION_DATABASES;
3330:         }else{
3331:           sqlite3_keyword_name(pCur->j++, &pCur->zCurrentRow, &pCur->szRow);
3332:         }
3333:         iCol = -1;
3334:         break;
3335:       }
3336:       case COMPLETION_DATABASES: {
3337:         if( pCur->pStmt==0 ){
3338:           sqlite3_prepare_v2(pCur->db, "PRAGMA database_list", -1,
3339:                              &pCur->pStmt, 0);
3340:         }
3341:         iCol = 1;
3342:         eNextPhase = COMPLETION_TABLES;
3343:         break;
3344:       }
3345:       case COMPLETION_TABLES: {
3346:         if( pCur->pStmt==0 ){
3347:           sqlite3_stmt *pS2;
3348:           char *zSql = 0;
3349:           const char *zSep = "";
3350:           sqlite3_prepare_v2(pCur->db, "PRAGMA database_list", -1, &pS2, 0);
3351:           while( sqlite3_step(pS2)==SQLITE_ROW ){
3352:             const char *zDb = (const char*)sqlite3_column_text(pS2, 1);
3353:             zSql = sqlite3_mprintf(
3354:                "%z%s"
3355:                "SELECT name FROM \"%w\".sqlite_schema",
3356:                zSql, zSep, zDb
3357:             );
3358:             if( zSql==0 ) return SQLITE_NOMEM;
3359:             zSep = " UNION ";
3360:           }
3361:           sqlite3_finalize(pS2);
3362:           sqlite3_prepare_v2(pCur->db, zSql, -1, &pCur->pStmt, 0);
3363:           sqlite3_free(zSql);
3364:         }
3365:         iCol = 0;
3366:         eNextPhase = COMPLETION_COLUMNS;
3367:         break;
3368:       }
3369:       case COMPLETION_COLUMNS: {
3370:         if( pCur->pStmt==0 ){
3371:           sqlite3_stmt *pS2;
3372:           char *zSql = 0;
3373:           const char *zSep = "";
3374:           sqlite3_prepare_v2(pCur->db, "PRAGMA database_list", -1, &pS2, 0);
3375:           while( sqlite3_step(pS2)==SQLITE_ROW ){
3376:             const char *zDb = (const char*)sqlite3_column_text(pS2, 1);
3377:             zSql = sqlite3_mprintf(
3378:                "%z%s"
3379:                "SELECT pti.name FROM \"%w\".sqlite_schema AS sm"
3380:                        " JOIN pragma_table_info(sm.name,%Q) AS pti"
3381:                " WHERE sm.type='table'",
3382:                zSql, zSep, zDb, zDb
3383:             );
3384:             if( zSql==0 ) return SQLITE_NOMEM;
3385:             zSep = " UNION ";
3386:           }
3387:           sqlite3_finalize(pS2);
3388:           sqlite3_prepare_v2(pCur->db, zSql, -1, &pCur->pStmt, 0);
3389:           sqlite3_free(zSql);
3390:         }
3391:         iCol = 0;
3392:         eNextPhase = COMPLETION_EOF;
3393:         break;
3394:       }
3395:     }
3396:     if( iCol<0 ){
3397:       /* This case is when the phase presets zCurrentRow */
3398:       if( pCur->zCurrentRow==0 ) continue;
3399:     }else{
3400:       if( sqlite3_step(pCur->pStmt)==SQLITE_ROW ){
3401:         /* Extract the next row of content */
3402:         pCur->zCurrentRow = (const char*)sqlite3_column_text(pCur->pStmt, iCol);
3403:         pCur->szRow = sqlite3_column_bytes(pCur->pStmt, iCol);
3404:       }else{
3405:         /* When all rows are finished, advance to the next phase */
3406:         sqlite3_finalize(pCur->pStmt);
3407:         pCur->pStmt = 0;
3408:         pCur->ePhase = eNextPhase;
3409:         continue;
3410:       }
3411:     }
3412:     if( pCur->nPrefix==0 ) break;
3413:     if( pCur->nPrefix<=pCur->szRow
3414:      && sqlite3_strnicmp(pCur->zPrefix, pCur->zCurrentRow, pCur->nPrefix)==0
3415:     ){
3416:       break;
3417:     }
3418:   }
3419: 
3420:   return SQLITE_OK;
3421: }
3422: 
3423: /*
3424: ** Return values of columns for the row at which the completion_cursor
3425: ** is currently pointing.
3426: */
3427: static int completionColumn(
3428:   sqlite3_vtab_cursor *cur,   /* The cursor */
3429:   sqlite3_context *ctx,       /* First argument to sqlite3_result_...() */
3430:   int i                       /* Which column to return */
3431: ){
3432:   completion_cursor *pCur = (completion_cursor*)cur;
3433:   switch( i ){
3434:     case COMPLETION_COLUMN_CANDIDATE: {
3435:       sqlite3_result_text(ctx, pCur->zCurrentRow, pCur->szRow,SQLITE_TRANSIENT);
3436:       break;
3437:     }
3438:     case COMPLETION_COLUMN_PREFIX: {
3439:       sqlite3_result_text(ctx, pCur->zPrefix, -1, SQLITE_TRANSIENT);
3440:       break;
3441:     }
3442:     case COMPLETION_COLUMN_WHOLELINE: {
3443:       sqlite3_result_text(ctx, pCur->zLine, -1, SQLITE_TRANSIENT);
3444:       break;
3445:     }
3446:     case COMPLETION_COLUMN_PHASE: {
3447:       sqlite3_result_int(ctx, pCur->ePhase);
3448:       break;
3449:     }
3450:   }
3451:   return SQLITE_OK;
3452: }
3453: 
3454: /*
3455: ** Return the rowid for the current row.  In this implementation, the
3456: ** rowid is the same as the output value.
3457: */
3458: static int completionRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
3459:   completion_cursor *pCur = (completion_cursor*)cur;
3460:   *pRowid = pCur->iRowid;
3461:   return SQLITE_OK;
3462: }
3463: 
3464: /*
3465: ** Return TRUE if the cursor has been moved off of the last
3466: ** row of output.
3467: */
3468: static int completionEof(sqlite3_vtab_cursor *cur){
3469:   completion_cursor *pCur = (completion_cursor*)cur;
3470:   return pCur->ePhase >= COMPLETION_EOF;
3471: }
3472: 
3473: /*
3474: ** This method is called to "rewind" the completion_cursor object back
3475: ** to the first row of output.  This method is always called at least
3476: ** once prior to any call to completionColumn() or completionRowid() or
3477: ** completionEof().
3478: */
3479: static int completionFilter(
3480:   sqlite3_vtab_cursor *pVtabCursor,
3481:   int idxNum, const char *idxStr,
3482:   int argc, sqlite3_value **argv
3483: ){
3484:   completion_cursor *pCur = (completion_cursor *)pVtabCursor;
3485:   int iArg = 0;
3486:   (void)(idxStr);   /* Unused parameter */
3487:   (void)(argc);     /* Unused parameter */
3488:   completionCursorReset(pCur);
3489:   if( idxNum & 1 ){
3490:     pCur->nPrefix = sqlite3_value_bytes(argv[iArg]);
3491:     if( pCur->nPrefix>0 ){
3492:       pCur->zPrefix = sqlite3_mprintf("%s", sqlite3_value_text(argv[iArg]));
3493:       if( pCur->zPrefix==0 ) return SQLITE_NOMEM;
3494:     }
3495:     iArg = 1;
3496:   }
3497:   if( idxNum & 2 ){
3498:     pCur->nLine = sqlite3_value_bytes(argv[iArg]);
3499:     if( pCur->nLine>0 ){
3500:       pCur->zLine = sqlite3_mprintf("%s", sqlite3_value_text(argv[iArg]));
3501:       if( pCur->zLine==0 ) return SQLITE_NOMEM;
3502:     }
3503:   }
3504:   if( pCur->zLine!=0 && pCur->zPrefix==0 ){
3505:     int i = pCur->nLine;
3506:     while( i>0 && (isalnum(pCur->zLine[i-1]) || pCur->zLine[i-1]=='_') ){
3507:       i--;
3508:     }
3509:     pCur->nPrefix = pCur->nLine - i;
3510:     if( pCur->nPrefix>0 ){
3511:       pCur->zPrefix = sqlite3_mprintf("%.*s", pCur->nPrefix, pCur->zLine + i);
3512:       if( pCur->zPrefix==0 ) return SQLITE_NOMEM;
3513:     }
3514:   }
3515:   pCur->iRowid = 0;
3516:   pCur->ePhase = COMPLETION_FIRST_PHASE;
3517:   return completionNext(pVtabCursor);
3518: }
3519: 
3520: /*
3521: ** SQLite will invoke this method one or more times while planning a query
3522: ** that uses the completion virtual table.  This routine needs to create
3523: ** a query plan for each invocation and compute an estimated cost for that
3524: ** plan.
3525: **
3526: ** There are two hidden parameters that act as arguments to the table-valued
3527: ** function:  "prefix" and "wholeline".  Bit 0 of idxNum is set if "prefix"
3528: ** is available and bit 1 is set if "wholeline" is available.
3529: */
3530: static int completionBestIndex(
3531:   sqlite3_vtab *tab,
3532:   sqlite3_index_info *pIdxInfo
3533: ){
3534:   int i;                 /* Loop over constraints */
3535:   int idxNum = 0;        /* The query plan bitmask */
3536:   int prefixIdx = -1;    /* Index of the start= constraint, or -1 if none */
3537:   int wholelineIdx = -1; /* Index of the stop= constraint, or -1 if none */
3538:   int nArg = 0;          /* Number of arguments that completeFilter() expects */
3539:   const struct sqlite3_index_constraint *pConstraint;
3540: 
3541:   (void)(tab);    /* Unused parameter */
3542:   pConstraint = pIdxInfo->aConstraint;
3543:   for(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++){
3544:     if( pConstraint->usable==0 ) continue;
3545:     if( pConstraint->op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;
3546:     switch( pConstraint->iColumn ){
3547:       case COMPLETION_COLUMN_PREFIX:
3548:         prefixIdx = i;
3549:         idxNum |= 1;
3550:         break;
3551:       case COMPLETION_COLUMN_WHOLELINE:
3552:         wholelineIdx = i;
3553:         idxNum |= 2;
3554:         break;
3555:     }
3556:   }
3557:   if( prefixIdx>=0 ){
3558:     pIdxInfo->aConstraintUsage[prefixIdx].argvIndex = ++nArg;
3559:     pIdxInfo->aConstraintUsage[prefixIdx].omit = 1;
3560:   }
3561:   if( wholelineIdx>=0 ){
3562:     pIdxInfo->aConstraintUsage[wholelineIdx].argvIndex = ++nArg;
3563:     pIdxInfo->aConstraintUsage[wholelineIdx].omit = 1;
3564:   }
3565:   pIdxInfo->idxNum = idxNum;
3566:   pIdxInfo->estimatedCost = (double)5000 - 1000*nArg;
3567:   pIdxInfo->estimatedRows = 500 - 100*nArg;
3568:   return SQLITE_OK;
3569: }
3570: 
3571: /*
3572: ** This following structure defines all the methods for the
3573: ** completion virtual table.
3574: */
3575: static sqlite3_module completionModule = {
3576:   0,                         /* iVersion */
3577:   0,                         /* xCreate */
3578:   completionConnect,         /* xConnect */
3579:   completionBestIndex,       /* xBestIndex */
3580:   completionDisconnect,      /* xDisconnect */
3581:   0,                         /* xDestroy */
3582:   completionOpen,            /* xOpen - open a cursor */
3583:   completionClose,           /* xClose - close a cursor */
3584:   completionFilter,          /* xFilter - configure scan constraints */
3585:   completionNext,            /* xNext - advance a cursor */
3586:   completionEof,             /* xEof - check for end of scan */
3587:   completionColumn,          /* xColumn - read data */
3588:   completionRowid,           /* xRowid - read data */
3589:   0,                         /* xUpdate */
3590:   0,                         /* xBegin */
3591:   0,                         /* xSync */
3592:   0,                         /* xCommit */
3593:   0,                         /* xRollback */
3594:   0,                         /* xFindMethod */
3595:   0,                         /* xRename */
3596:   0,                         /* xSavepoint */
3597:   0,                         /* xRelease */
3598:   0,                         /* xRollbackTo */
3599:   0                          /* xShadowName */
3600: };
3601: 
3602: #endif /* SQLITE_OMIT_VIRTUALTABLE */
3603: 
3604: int sqlite3CompletionVtabInit(sqlite3 *db){
3605:   int rc = SQLITE_OK;
3606: #ifndef SQLITE_OMIT_VIRTUALTABLE
3607:   rc = sqlite3_create_module(db, "completion", &completionModule, 0);
3608: #endif
3609:   return rc;
3610: }
3611: 
3612: #ifdef _WIN32
3613: 
3614: #endif
3615: int sqlite3_completion_init(
3616:   sqlite3 *db,
3617:   char **pzErrMsg,
3618:   const sqlite3_api_routines *pApi
3619: ){
3620:   int rc = SQLITE_OK;
3621:   SQLITE_EXTENSION_INIT2(pApi);
3622:   (void)(pzErrMsg);  /* Unused parameter */
3623: #ifndef SQLITE_OMIT_VIRTUALTABLE
3624:   rc = sqlite3CompletionVtabInit(db);
3625: #endif
3626:   return rc;
3627: }
3628: 
3629: /************************* End ../ext/misc/completion.c ********************/
3630: /************************* Begin ../ext/misc/appendvfs.c ******************/
3631: /*
3632: ** 2017-10-20
3633: **
3634: ** The author disclaims copyright to this source code.  In place of
3635: ** a legal notice, here is a blessing:
3636: **
3637: **    May you do good and not evil.
3638: **    May you find forgiveness for yourself and forgive others.
3639: **    May you share freely, never taking more than you give.
3640: **
3641: ******************************************************************************
3642: **
3643: ** This file implements a VFS shim that allows an SQLite database to be
3644: ** appended onto the end of some other file, such as an executable.
3645: **
3646: ** A special record must appear at the end of the file that identifies the
3647: ** file as an appended database and provides an offset to page 1.  For
3648: ** best performance page 1 should be located at a disk page boundary, though
3649: ** that is not required.
3650: **
3651: ** When opening a database using this VFS, the connection might treat
3652: ** the file as an ordinary SQLite database, or it might treat is as a
3653: ** database appended onto some other file.  Here are the rules:
3654: **
3655: **  (1)  When opening a new empty file, that file is treated as an ordinary
3656: **       database.
3657: **
3658: **  (2)  When opening a file that begins with the standard SQLite prefix
3659: **       string "SQLite format 3", that file is treated as an ordinary
3660: **       database.
3661: **
3662: **  (3)  When opening a file that ends with the appendvfs trailer string
3663: **       "Start-Of-SQLite3-NNNNNNNN" that file is treated as an appended
3664: **       database.
3665: **
3666: **  (4)  If none of the above apply and the SQLITE_OPEN_CREATE flag is
3667: **       set, then a new database is appended to the already existing file.
3668: **
3669: **  (5)  Otherwise, SQLITE_CANTOPEN is returned.
3670: **
3671: ** To avoid unnecessary complications with the PENDING_BYTE, the size of
3672: ** the file containing the database is limited to 1GB.  This VFS will refuse
3673: ** to read or write past the 1GB mark.  This restriction might be lifted in
3674: ** future versions.  For now, if you need a large database, then keep the
3675: ** database in a separate file.
3676: **
3677: ** If the file being opened is not an appended database, then this shim is
3678: ** a pass-through into the default underlying VFS.
3679: **/
3680: /* #include "sqlite3ext.h" */
3681: SQLITE_EXTENSION_INIT1
3682: #include <string.h>
3683: #include <assert.h>
3684: 
3685: /* The append mark at the end of the database is:
3686: **
3687: **     Start-Of-SQLite3-NNNNNNNN
3688: **     123456789 123456789 12345
3689: **
3690: ** The NNNNNNNN represents a 64-bit big-endian unsigned integer which is
3691: ** the offset to page 1.
3692: */
3693: #define APND_MARK_PREFIX     "Start-Of-SQLite3-"
3694: #define APND_MARK_PREFIX_SZ  17
3695: #define APND_MARK_SIZE       25
3696: 
3697: /*
3698: ** Maximum size of the combined prefix + database + append-mark.  This
3699: ** must be less than 0x40000000 to avoid locking issues on Windows.
3700: */
3701: #define APND_MAX_SIZE  (65536*15259)
3702: 
3703: /*
3704: ** Forward declaration of objects used by this utility
3705: */
3706: typedef struct sqlite3_vfs ApndVfs;
3707: typedef struct ApndFile ApndFile;
3708: 
3709: /* Access to a lower-level VFS that (might) implement dynamic loading,
3710: ** access to randomness, etc.
3711: */
3712: #define ORIGVFS(p)  ((sqlite3_vfs*)((p)->pAppData))
3713: #define ORIGFILE(p) ((sqlite3_file*)(((ApndFile*)(p))+1))
3714: 
3715: /* An open file */
3716: struct ApndFile {
3717:   sqlite3_file base;              /* IO methods */
3718:   sqlite3_int64 iPgOne;           /* File offset to page 1 */
3719:   sqlite3_int64 iMark;            /* Start of the append-mark */
3720: };
3721: 
3722: /*
3723: ** Methods for ApndFile
3724: */
3725: static int apndClose(sqlite3_file*);
3726: static int apndRead(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
3727: static int apndWrite(sqlite3_file*,const void*,int iAmt, sqlite3_int64 iOfst);
3728: static int apndTruncate(sqlite3_file*, sqlite3_int64 size);
3729: static int apndSync(sqlite3_file*, int flags);
3730: static int apndFileSize(sqlite3_file*, sqlite3_int64 *pSize);
3731: static int apndLock(sqlite3_file*, int);
3732: static int apndUnlock(sqlite3_file*, int);
3733: static int apndCheckReservedLock(sqlite3_file*, int *pResOut);
3734: static int apndFileControl(sqlite3_file*, int op, void *pArg);
3735: static int apndSectorSize(sqlite3_file*);
3736: static int apndDeviceCharacteristics(sqlite3_file*);
3737: static int apndShmMap(sqlite3_file*, int iPg, int pgsz, int, void volatile**);
3738: static int apndShmLock(sqlite3_file*, int offset, int n, int flags);
3739: static void apndShmBarrier(sqlite3_file*);
3740: static int apndShmUnmap(sqlite3_file*, int deleteFlag);
3741: static int apndFetch(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);
3742: static int apndUnfetch(sqlite3_file*, sqlite3_int64 iOfst, void *p);
3743: 
3744: /*
3745: ** Methods for ApndVfs
3746: */
3747: static int apndOpen(sqlite3_vfs*, const char *, sqlite3_file*, int , int *);
3748: static int apndDelete(sqlite3_vfs*, const char *zName, int syncDir);
3749: static int apndAccess(sqlite3_vfs*, const char *zName, int flags, int *);
3750: static int apndFullPathname(sqlite3_vfs*, const char *zName, int, char *zOut);
3751: static void *apndDlOpen(sqlite3_vfs*, const char *zFilename);
3752: static void apndDlError(sqlite3_vfs*, int nByte, char *zErrMsg);
3753: static void (*apndDlSym(sqlite3_vfs *pVfs, void *p, const char*zSym))(void);
3754: static void apndDlClose(sqlite3_vfs*, void*);
3755: static int apndRandomness(sqlite3_vfs*, int nByte, char *zOut);
3756: static int apndSleep(sqlite3_vfs*, int microseconds);
3757: static int apndCurrentTime(sqlite3_vfs*, double*);
3758: static int apndGetLastError(sqlite3_vfs*, int, char *);
3759: static int apndCurrentTimeInt64(sqlite3_vfs*, sqlite3_int64*);
3760: static int apndSetSystemCall(sqlite3_vfs*, const char*,sqlite3_syscall_ptr);
3761: static sqlite3_syscall_ptr apndGetSystemCall(sqlite3_vfs*, const char *z);
3762: static const char *apndNextSystemCall(sqlite3_vfs*, const char *zName);
3763: 
3764: static sqlite3_vfs apnd_vfs = {
3765:   3,                            /* iVersion (set when registered) */
3766:   0,                            /* szOsFile (set when registered) */
3767:   1024,                         /* mxPathname */
3768:   0,                            /* pNext */
3769:   "apndvfs",                    /* zName */
3770:   0,                            /* pAppData (set when registered) */
3771:   apndOpen,                     /* xOpen */
3772:   apndDelete,                   /* xDelete */
3773:   apndAccess,                   /* xAccess */
3774:   apndFullPathname,             /* xFullPathname */
3775:   apndDlOpen,                   /* xDlOpen */
3776:   apndDlError,                  /* xDlError */
3777:   apndDlSym,                    /* xDlSym */
3778:   apndDlClose,                  /* xDlClose */
3779:   apndRandomness,               /* xRandomness */
3780:   apndSleep,                    /* xSleep */
3781:   apndCurrentTime,              /* xCurrentTime */
3782:   apndGetLastError,             /* xGetLastError */
3783:   apndCurrentTimeInt64,         /* xCurrentTimeInt64 */
3784:   apndSetSystemCall,            /* xSetSystemCall */
3785:   apndGetSystemCall,            /* xGetSystemCall */
3786:   apndNextSystemCall            /* xNextSystemCall */
3787: };
3788: 
3789: static const sqlite3_io_methods apnd_io_methods = {
3790:   3,                              /* iVersion */
3791:   apndClose,                      /* xClose */
3792:   apndRead,                       /* xRead */
3793:   apndWrite,                      /* xWrite */
3794:   apndTruncate,                   /* xTruncate */
3795:   apndSync,                       /* xSync */
3796:   apndFileSize,                   /* xFileSize */
3797:   apndLock,                       /* xLock */
3798:   apndUnlock,                     /* xUnlock */
3799:   apndCheckReservedLock,          /* xCheckReservedLock */
3800:   apndFileControl,                /* xFileControl */
3801:   apndSectorSize,                 /* xSectorSize */
3802:   apndDeviceCharacteristics,      /* xDeviceCharacteristics */
3803:   apndShmMap,                     /* xShmMap */
3804:   apndShmLock,                    /* xShmLock */
3805:   apndShmBarrier,                 /* xShmBarrier */
3806:   apndShmUnmap,                   /* xShmUnmap */
3807:   apndFetch,                      /* xFetch */
3808:   apndUnfetch                     /* xUnfetch */
3809: };
3810: 
3811: 
3812: 
3813: /*
3814: ** Close an apnd-file.
3815: */
3816: static int apndClose(sqlite3_file *pFile){
3817:   pFile = ORIGFILE(pFile);
3818:   return pFile->pMethods->xClose(pFile);
3819: }
3820: 
3821: /*
3822: ** Read data from an apnd-file.
3823: */
3824: static int apndRead(
3825:   sqlite3_file *pFile,
3826:   void *zBuf,
3827:   int iAmt,
3828:   sqlite_int64 iOfst
3829: ){
3830:   ApndFile *p = (ApndFile *)pFile;
3831:   pFile = ORIGFILE(pFile);
3832:   return pFile->pMethods->xRead(pFile, zBuf, iAmt, iOfst+p->iPgOne);
3833: }
3834: 
3835: /*
3836: ** Add the append-mark onto the end of the file.
3837: */
3838: static int apndWriteMark(ApndFile *p, sqlite3_file *pFile){
3839:   int i;
3840:   unsigned char a[APND_MARK_SIZE];
3841:   memcpy(a, APND_MARK_PREFIX, APND_MARK_PREFIX_SZ);
3842:   for(i=0; i<8; i++){
3843:     a[APND_MARK_PREFIX_SZ+i] = (p->iPgOne >> (56 - i*8)) & 0xff;
3844:   }
3845:   return pFile->pMethods->xWrite(pFile, a, APND_MARK_SIZE, p->iMark);
3846: }
3847: 
3848: /*
3849: ** Write data to an apnd-file.
3850: */
3851: static int apndWrite(
3852:   sqlite3_file *pFile,
3853:   const void *zBuf,
3854:   int iAmt,
3855:   sqlite_int64 iOfst
3856: ){
3857:   int rc;
3858:   ApndFile *p = (ApndFile *)pFile;
3859:   pFile = ORIGFILE(pFile);
3860:   if( iOfst+iAmt>=APND_MAX_SIZE ) return SQLITE_FULL;
3861:   rc = pFile->pMethods->xWrite(pFile, zBuf, iAmt, iOfst+p->iPgOne);
3862:   if( rc==SQLITE_OK &&  iOfst + iAmt + p->iPgOne > p->iMark ){
3863:     sqlite3_int64 sz = 0;
3864:     rc = pFile->pMethods->xFileSize(pFile, &sz);
3865:     if( rc==SQLITE_OK ){
3866:       p->iMark = sz - APND_MARK_SIZE;
3867:       if( iOfst + iAmt + p->iPgOne > p->iMark ){
3868:         p->iMark = p->iPgOne + iOfst + iAmt;
3869:         rc = apndWriteMark(p, pFile);
3870:       }
3871:     }
3872:   }
3873:   return rc;
3874: }
3875: 
3876: /*
3877: ** Truncate an apnd-file.
3878: */
3879: static int apndTruncate(sqlite3_file *pFile, sqlite_int64 size){
3880:   int rc;
3881:   ApndFile *p = (ApndFile *)pFile;
3882:   pFile = ORIGFILE(pFile);
3883:   rc = pFile->pMethods->xTruncate(pFile, size+p->iPgOne+APND_MARK_SIZE);
3884:   if( rc==SQLITE_OK ){
3885:     p->iMark = p->iPgOne+size;
3886:     rc = apndWriteMark(p, pFile);
3887:   }
3888:   return rc;
3889: }
3890: 
3891: /*
3892: ** Sync an apnd-file.
3893: */
3894: static int apndSync(sqlite3_file *pFile, int flags){
3895:   pFile = ORIGFILE(pFile);
3896:   return pFile->pMethods->xSync(pFile, flags);
3897: }
3898: 
3899: /*
3900: ** Return the current file-size of an apnd-file.
3901: */
3902: static int apndFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){
3903:   ApndFile *p = (ApndFile *)pFile;
3904:   int rc;
3905:   pFile = ORIGFILE(p);
3906:   rc = pFile->pMethods->xFileSize(pFile, pSize);
3907:   if( rc==SQLITE_OK && p->iPgOne ){
3908:     *pSize -= p->iPgOne + APND_MARK_SIZE;
3909:   }
3910:   return rc;
3911: }
3912: 
3913: /*
3914: ** Lock an apnd-file.
3915: */
3916: static int apndLock(sqlite3_file *pFile, int eLock){
3917:   pFile = ORIGFILE(pFile);
3918:   return pFile->pMethods->xLock(pFile, eLock);
3919: }
3920: 
3921: /*
3922: ** Unlock an apnd-file.
3923: */
3924: static int apndUnlock(sqlite3_file *pFile, int eLock){
3925:   pFile = ORIGFILE(pFile);
3926:   return pFile->pMethods->xUnlock(pFile, eLock);
3927: }
3928: 
3929: /*
3930: ** Check if another file-handle holds a RESERVED lock on an apnd-file.
3931: */
3932: static int apndCheckReservedLock(sqlite3_file *pFile, int *pResOut){
3933:   pFile = ORIGFILE(pFile);
3934:   return pFile->pMethods->xCheckReservedLock(pFile, pResOut);
3935: }
3936: 
3937: /*
3938: ** File control method. For custom operations on an apnd-file.
3939: */
3940: static int apndFileControl(sqlite3_file *pFile, int op, void *pArg){
3941:   ApndFile *p = (ApndFile *)pFile;
3942:   int rc;
3943:   pFile = ORIGFILE(pFile);
3944:   rc = pFile->pMethods->xFileControl(pFile, op, pArg);
3945:   if( rc==SQLITE_OK && op==SQLITE_FCNTL_VFSNAME ){
3946:     *(char**)pArg = sqlite3_mprintf("apnd(%lld)/%z", p->iPgOne, *(char**)pArg);
3947:   }
3948:   return rc;
3949: }
3950: 
3951: /*
3952: ** Return the sector-size in bytes for an apnd-file.
3953: */
3954: static int apndSectorSize(sqlite3_file *pFile){
3955:   pFile = ORIGFILE(pFile);
3956:   return pFile->pMethods->xSectorSize(pFile);
3957: }
3958: 
3959: /*
3960: ** Return the device characteristic flags supported by an apnd-file.
3961: */
3962: static int apndDeviceCharacteristics(sqlite3_file *pFile){
3963:   pFile = ORIGFILE(pFile);
3964:   return pFile->pMethods->xDeviceCharacteristics(pFile);
3965: }
3966: 
3967: /* Create a shared memory file mapping */
3968: static int apndShmMap(
3969:   sqlite3_file *pFile,
3970:   int iPg,
3971:   int pgsz,
3972:   int bExtend,
3973:   void volatile **pp
3974: ){
3975:   pFile = ORIGFILE(pFile);
3976:   return pFile->pMethods->xShmMap(pFile,iPg,pgsz,bExtend,pp);
3977: }
3978: 
3979: /* Perform locking on a shared-memory segment */
3980: static int apndShmLock(sqlite3_file *pFile, int offset, int n, int flags){
3981:   pFile = ORIGFILE(pFile);
3982:   return pFile->pMethods->xShmLock(pFile,offset,n,flags);
3983: }
3984: 
3985: /* Memory barrier operation on shared memory */
3986: static void apndShmBarrier(sqlite3_file *pFile){
3987:   pFile = ORIGFILE(pFile);
3988:   pFile->pMethods->xShmBarrier(pFile);
3989: }
3990: 
3991: /* Unmap a shared memory segment */
3992: static int apndShmUnmap(sqlite3_file *pFile, int deleteFlag){
3993:   pFile = ORIGFILE(pFile);
3994:   return pFile->pMethods->xShmUnmap(pFile,deleteFlag);
3995: }
3996: 
3997: /* Fetch a page of a memory-mapped file */
3998: static int apndFetch(
3999:   sqlite3_file *pFile,
4000:   sqlite3_int64 iOfst,
4001:   int iAmt,
4002:   void **pp
4003: ){
4004:   ApndFile *p = (ApndFile *)pFile;
4005:   pFile = ORIGFILE(pFile);
4006:   return pFile->pMethods->xFetch(pFile, iOfst+p->iPgOne, iAmt, pp);
4007: }
4008: 
4009: /* Release a memory-mapped page */
4010: static int apndUnfetch(sqlite3_file *pFile, sqlite3_int64 iOfst, void *pPage){
4011:   ApndFile *p = (ApndFile *)pFile;
4012:   pFile = ORIGFILE(pFile);
4013:   return pFile->pMethods->xUnfetch(pFile, iOfst+p->iPgOne, pPage);
4014: }
4015: 
4016: /*
4017: ** Check to see if the file is an ordinary SQLite database file.
4018: */
4019: static int apndIsOrdinaryDatabaseFile(sqlite3_int64 sz, sqlite3_file *pFile){
4020:   int rc;
4021:   char zHdr[16];
4022:   static const char aSqliteHdr[] = "SQLite format 3";
4023:   if( sz<512 ) return 0;
4024:   rc = pFile->pMethods->xRead(pFile, zHdr, sizeof(zHdr), 0);
4025:   if( rc ) return 0;
4026:   return memcmp(zHdr, aSqliteHdr, sizeof(zHdr))==0;
4027: }
4028: 
4029: /*
4030: ** Try to read the append-mark off the end of a file.  Return the
4031: ** start of the appended database if the append-mark is present.  If
4032: ** there is no append-mark, return -1;
4033: */
4034: static sqlite3_int64 apndReadMark(sqlite3_int64 sz, sqlite3_file *pFile){
4035:   int rc, i;
4036:   sqlite3_int64 iMark;
4037:   unsigned char a[APND_MARK_SIZE];
4038: 
4039:   if( sz<=APND_MARK_SIZE ) return -1;
4040:   rc = pFile->pMethods->xRead(pFile, a, APND_MARK_SIZE, sz-APND_MARK_SIZE);
4041:   if( rc ) return -1;
4042:   if( memcmp(a, APND_MARK_PREFIX, APND_MARK_PREFIX_SZ)!=0 ) return -1;
4043:   iMark = ((sqlite3_int64)(a[APND_MARK_PREFIX_SZ]&0x7f))<<56;
4044:   for(i=1; i<8; i++){
4045:     iMark += (sqlite3_int64)a[APND_MARK_PREFIX_SZ+i]<<(56-8*i);
4046:   }
4047:   return iMark;
4048: }
4049: 
4050: /*
4051: ** Open an apnd file handle.
4052: */
4053: static int apndOpen(
4054:   sqlite3_vfs *pVfs,
4055:   const char *zName,
4056:   sqlite3_file *pFile,
4057:   int flags,
4058:   int *pOutFlags
4059: ){
4060:   ApndFile *p;
4061:   sqlite3_file *pSubFile;
4062:   sqlite3_vfs *pSubVfs;
4063:   int rc;
4064:   sqlite3_int64 sz;
4065:   pSubVfs = ORIGVFS(pVfs);
4066:   if( (flags & SQLITE_OPEN_MAIN_DB)==0 ){
4067:     return pSubVfs->xOpen(pSubVfs, zName, pFile, flags, pOutFlags);
4068:   }
4069:   p = (ApndFile*)pFile;
4070:   memset(p, 0, sizeof(*p));
4071:   pSubFile = ORIGFILE(pFile);
4072:   pFile->pMethods = &apnd_io_methods;
4073:   rc = pSubVfs->xOpen(pSubVfs, zName, pSubFile, flags, pOutFlags);
4074:   if( rc ) goto apnd_open_done;
4075:   rc = pSubFile->pMethods->xFileSize(pSubFile, &sz);
4076:   if( rc ){
4077:     pSubFile->pMethods->xClose(pSubFile);
4078:     goto apnd_open_done;
4079:   }
4080:   if( apndIsOrdinaryDatabaseFile(sz, pSubFile) ){
4081:     memmove(pFile, pSubFile, pSubVfs->szOsFile);
4082:     return SQLITE_OK;
4083:   }
4084:   p->iMark = 0;
4085:   p->iPgOne = apndReadMark(sz, pFile);
4086:   if( p->iPgOne>0 ){
4087:     return SQLITE_OK;
4088:   }
4089:   if( (flags & SQLITE_OPEN_CREATE)==0 ){
4090:     pSubFile->pMethods->xClose(pSubFile);
4091:     rc = SQLITE_CANTOPEN;
4092:   }
4093:   p->iPgOne = (sz+0xfff) & ~(sqlite3_int64)0xfff;
4094: apnd_open_done:
4095:   if( rc ) pFile->pMethods = 0;
4096:   return rc;
4097: }
4098: 
4099: /*
4100: ** All other VFS methods are pass-thrus.
4101: */
4102: static int apndDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){
4103:   return ORIGVFS(pVfs)->xDelete(ORIGVFS(pVfs), zPath, dirSync);
4104: }
4105: static int apndAccess(
4106:   sqlite3_vfs *pVfs,
4107:   const char *zPath,
4108:   int flags,
4109:   int *pResOut
4110: ){
4111:   return ORIGVFS(pVfs)->xAccess(ORIGVFS(pVfs), zPath, flags, pResOut);
4112: }
4113: static int apndFullPathname(
4114:   sqlite3_vfs *pVfs,
4115:   const char *zPath,
4116:   int nOut,
4117:   char *zOut
4118: ){
4119:   return ORIGVFS(pVfs)->xFullPathname(ORIGVFS(pVfs),zPath,nOut,zOut);
4120: }
4121: static void *apndDlOpen(sqlite3_vfs *pVfs, const char *zPath){
4122:   return ORIGVFS(pVfs)->xDlOpen(ORIGVFS(pVfs), zPath);
4123: }
4124: static void apndDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){
4125:   ORIGVFS(pVfs)->xDlError(ORIGVFS(pVfs), nByte, zErrMsg);
4126: }
4127: static void (*apndDlSym(sqlite3_vfs *pVfs, void *p, const char *zSym))(void){
4128:   return ORIGVFS(pVfs)->xDlSym(ORIGVFS(pVfs), p, zSym);
4129: }
4130: static void apndDlClose(sqlite3_vfs *pVfs, void *pHandle){
4131:   ORIGVFS(pVfs)->xDlClose(ORIGVFS(pVfs), pHandle);
4132: }
4133: static int apndRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){
4134:   return ORIGVFS(pVfs)->xRandomness(ORIGVFS(pVfs), nByte, zBufOut);
4135: }
4136: static int apndSleep(sqlite3_vfs *pVfs, int nMicro){
4137:   return ORIGVFS(pVfs)->xSleep(ORIGVFS(pVfs), nMicro);
4138: }
4139: static int apndCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){
4140:   return ORIGVFS(pVfs)->xCurrentTime(ORIGVFS(pVfs), pTimeOut);
4141: }
4142: static int apndGetLastError(sqlite3_vfs *pVfs, int a, char *b){
4143:   return ORIGVFS(pVfs)->xGetLastError(ORIGVFS(pVfs), a, b);
4144: }
4145: static int apndCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *p){
4146:   return ORIGVFS(pVfs)->xCurrentTimeInt64(ORIGVFS(pVfs), p);
4147: }
4148: static int apndSetSystemCall(
4149:   sqlite3_vfs *pVfs,
4150:   const char *zName,
4151:   sqlite3_syscall_ptr pCall
4152: ){
4153:   return ORIGVFS(pVfs)->xSetSystemCall(ORIGVFS(pVfs),zName,pCall);
4154: }
4155: static sqlite3_syscall_ptr apndGetSystemCall(
4156:   sqlite3_vfs *pVfs,
4157:   const char *zName
4158: ){
4159:   return ORIGVFS(pVfs)->xGetSystemCall(ORIGVFS(pVfs),zName);
4160: }
4161: static const char *apndNextSystemCall(sqlite3_vfs *pVfs, const char *zName){
4162:   return ORIGVFS(pVfs)->xNextSystemCall(ORIGVFS(pVfs), zName);
4163: }
4164: 
4165: 
4166: #ifdef _WIN32
4167: 
4168: #endif
4169: /*
4170: ** This routine is called when the extension is loaded.
4171: ** Register the new VFS.
4172: */
4173: int sqlite3_appendvfs_init(
4174:   sqlite3 *db,
4175:   char **pzErrMsg,
4176:   const sqlite3_api_routines *pApi
4177: ){
4178:   int rc = SQLITE_OK;
4179:   sqlite3_vfs *pOrig;
4180:   SQLITE_EXTENSION_INIT2(pApi);
4181:   (void)pzErrMsg;
4182:   (void)db;
4183:   pOrig = sqlite3_vfs_find(0);
4184:   apnd_vfs.iVersion = pOrig->iVersion;
4185:   apnd_vfs.pAppData = pOrig;
4186:   apnd_vfs.szOsFile = pOrig->szOsFile + sizeof(ApndFile);
4187:   rc = sqlite3_vfs_register(&apnd_vfs, 0);
4188: #ifdef APPENDVFS_TEST
4189:   if( rc==SQLITE_OK ){
4190:     rc = sqlite3_auto_extension((void(*)(void))apndvfsRegister);
4191:   }
4192: #endif
4193:   if( rc==SQLITE_OK ) rc = SQLITE_OK_LOAD_PERMANENTLY;
4194:   return rc;
4195: }
4196: 
4197: /************************* End ../ext/misc/appendvfs.c ********************/
4198: /************************* Begin ../ext/misc/memtrace.c ******************/
4199: /*
4200: ** 2019-01-21
4201: **
4202: ** The author disclaims copyright to this source code.  In place of
4203: ** a legal notice, here is a blessing:
4204: **
4205: **    May you do good and not evil.
4206: **    May you find forgiveness for yourself and forgive others.
4207: **    May you share freely, never taking more than you give.
4208: **
4209: *************************************************************************
4210: **
4211: ** This file implements an extension that uses the SQLITE_CONFIG_MALLOC
4212: ** mechanism to add a tracing layer on top of SQLite.  If this extension
4213: ** is registered prior to sqlite3_initialize(), it will cause all memory
4214: ** allocation activities to be logged on standard output, or to some other
4215: ** FILE specified by the initializer.
4216: **
4217: ** This file needs to be compiled into the application that uses it.
4218: **
4219: ** This extension is used to implement the --memtrace option of the
4220: ** command-line shell.
4221: */
4222: #include <assert.h>
4223: #include <string.h>
4224: #include <stdio.h>
4225: 
4226: /* The original memory allocation routines */
4227: static sqlite3_mem_methods memtraceBase;
4228: static FILE *memtraceOut;
4229: 
4230: /* Methods that trace memory allocations */
4231: static void *memtraceMalloc(int n){
4232:   if( memtraceOut ){
4233:     fprintf(memtraceOut, "MEMTRACE: allocate %d bytes\n",
4234:             memtraceBase.xRoundup(n));
4235:   }
4236:   return memtraceBase.xMalloc(n);
4237: }
4238: static void memtraceFree(void *p){
4239:   if( p==0 ) return;
4240:   if( memtraceOut ){
4241:     fprintf(memtraceOut, "MEMTRACE: free %d bytes\n", memtraceBase.xSize(p));
4242:   }
4243:   memtraceBase.xFree(p);
4244: }
4245: static void *memtraceRealloc(void *p, int n){
4246:   if( p==0 ) return memtraceMalloc(n);
4247:   if( n==0 ){
4248:     memtraceFree(p);
4249:     return 0;
4250:   }
4251:   if( memtraceOut ){
4252:     fprintf(memtraceOut, "MEMTRACE: resize %d -> %d bytes\n",
4253:             memtraceBase.xSize(p), memtraceBase.xRoundup(n));
4254:   }
4255:   return memtraceBase.xRealloc(p, n);
4256: }
4257: static int memtraceSize(void *p){
4258:   return memtraceBase.xSize(p);
4259: }
4260: static int memtraceRoundup(int n){
4261:   return memtraceBase.xRoundup(n);
4262: }
4263: static int memtraceInit(void *p){
4264:   return memtraceBase.xInit(p);
4265: }
4266: static void memtraceShutdown(void *p){
4267:   memtraceBase.xShutdown(p);
4268: }
4269: 
4270: /* The substitute memory allocator */
4271: static sqlite3_mem_methods ersaztMethods = {
4272:   memtraceMalloc,
4273:   memtraceFree,
4274:   memtraceRealloc,
4275:   memtraceSize,
4276:   memtraceRoundup,
4277:   memtraceInit,
4278:   memtraceShutdown,
4279:   0
4280: };
4281: 
4282: /* Begin tracing memory allocations to out. */
4283: int sqlite3MemTraceActivate(FILE *out){
4284:   int rc = SQLITE_OK;
4285:   if( memtraceBase.xMalloc==0 ){
4286:     rc = sqlite3_config(SQLITE_CONFIG_GETMALLOC, &memtraceBase);
4287:     if( rc==SQLITE_OK ){
4288:       rc = sqlite3_config(SQLITE_CONFIG_MALLOC, &ersaztMethods);
4289:     }
4290:   }
4291:   memtraceOut = out;
4292:   return rc;
4293: }
4294: 
4295: /* Deactivate memory tracing */
4296: int sqlite3MemTraceDeactivate(void){
4297:   int rc = SQLITE_OK;
4298:   if( memtraceBase.xMalloc!=0 ){
4299:     rc = sqlite3_config(SQLITE_CONFIG_MALLOC, &memtraceBase);
4300:     if( rc==SQLITE_OK ){
4301:       memset(&memtraceBase, 0, sizeof(memtraceBase));
4302:     }
4303:   }
4304:   memtraceOut = 0;
4305:   return rc;
4306: }
4307: 
4308: /************************* End ../ext/misc/memtrace.c ********************/
4309: /************************* Begin ../ext/misc/uint.c ******************/
4310: /*
4311: ** 2020-04-14
4312: **
4313: ** The author disclaims copyright to this source code.  In place of
4314: ** a legal notice, here is a blessing:
4315: **
4316: **    May you do good and not evil.
4317: **    May you find forgiveness for yourself and forgive others.
4318: **    May you share freely, never taking more than you give.
4319: **
4320: ******************************************************************************
4321: **
4322: ** This SQLite extension implements the UINT collating sequence.
4323: **
4324: ** UINT works like BINARY for text, except that embedded strings
4325: ** of digits compare in numeric order.
4326: **
4327: **     *   Leading zeros are handled properly, in the sense that
4328: **         they do not mess of the maginitude comparison of embedded
4329: **         strings of digits.  "x00123y" is equal to "x123y".
4330: **
4331: **     *   Only unsigned integers are recognized.  Plus and minus
4332: **         signs are ignored.  Decimal points and exponential notation
4333: **         are ignored.
4334: **
4335: **     *   Embedded integers can be of arbitrary length.  Comparison
4336: **         is *not* limited integers that can be expressed as a
4337: **         64-bit machine integer.
4338: */
4339: /* #include "sqlite3ext.h" */
4340: SQLITE_EXTENSION_INIT1
4341: #include <assert.h>
4342: #include <string.h>
4343: #include <ctype.h>
4344: 
4345: /*
4346: ** Compare text in lexicographic order, except strings of digits
4347: ** compare in numeric order.
4348: */
4349: static int uintCollFunc(
4350:   void *notUsed,
4351:   int nKey1, const void *pKey1,
4352:   int nKey2, const void *pKey2
4353: ){
4354:   const unsigned char *zA = (const unsigned char*)pKey1;
4355:   const unsigned char *zB = (const unsigned char*)pKey2;
4356:   int i=0, j=0, x;
4357:   (void)notUsed;
4358:   while( i<nKey1 && j<nKey2 ){
4359:     x = zA[i] - zB[j];
4360:     if( isdigit(zA[i]) ){
4361:       int k;
4362:       if( !isdigit(zB[j]) ) return x;
4363:       while( i<nKey1 && zA[i]=='0' ){ i++; }
4364:       while( j<nKey2 && zB[j]=='0' ){ j++; }
4365:       k = 0;
4366:       while( i+k<nKey1 && isdigit(zA[i+k])
4367:              && j+k<nKey2 && isdigit(zB[j+k]) ){
4368:         k++;
4369:       }
4370:       if( i+k<nKey1 && isdigit(zA[i+k]) ){
4371:         return +1;
4372:       }else if( j+k<nKey2 && isdigit(zB[j+k]) ){
4373:         return -1;
4374:       }else{
4375:         x = memcmp(zA+i, zB+j, k);
4376:         if( x ) return x;
4377:         i += k;
4378:         j += k;
4379:       }
4380:     }else if( x ){
4381:       return x;
4382:     }else{
4383:       i++;
4384:       j++;
4385:     }
4386:   }
4387:   return (nKey1 - i) - (nKey2 - j);
4388: }
4389: 
4390: #ifdef _WIN32
4391: 
4392: #endif
4393: int sqlite3_uint_init(
4394:   sqlite3 *db,
4395:   char **pzErrMsg,
4396:   const sqlite3_api_routines *pApi
4397: ){
4398:   SQLITE_EXTENSION_INIT2(pApi);
4399:   (void)pzErrMsg;  /* Unused parameter */
4400:   return sqlite3_create_collation(db, "uint", SQLITE_UTF8, 0, uintCollFunc);
4401: }
4402: 
4403: /************************* End ../ext/misc/uint.c ********************/
4404: /************************* Begin ../ext/misc/decimal.c ******************/
4405: /*
4406: ** 2020-06-22
4407: **
4408: ** The author disclaims copyright to this source code.  In place of
4409: ** a legal notice, here is a blessing:
4410: **
4411: **    May you do good and not evil.
4412: **    May you find forgiveness for yourself and forgive others.
4413: **    May you share freely, never taking more than you give.
4414: **
4415: ******************************************************************************
4416: **
4417: ** Routines to implement arbitrary-precision decimal math.
4418: **
4419: ** The focus here is on simplicity and correctness, not performance.
4420: */
4421: /* #include "sqlite3ext.h" */
4422: SQLITE_EXTENSION_INIT1
4423: #include <assert.h>
4424: #include <string.h>
4425: #include <ctype.h>
4426: #include <stdlib.h>
4427: 
4428: /* Mark a function parameter as unused, to suppress nuisance compiler
4429: ** warnings. */
4430: #ifndef UNUSED_PARAMETER
4431: # define UNUSED_PARAMETER(X)  (void)(X)
4432: #endif
4433: 
4434: 
4435: /* A decimal object */
4436: typedef struct Decimal Decimal;
4437: struct Decimal {
4438:   char sign;        /* 0 for positive, 1 for negative */
4439:   char oom;         /* True if an OOM is encountered */
4440:   char isNull;      /* True if holds a NULL rather than a number */
4441:   char isInit;      /* True upon initialization */
4442:   int nDigit;       /* Total number of digits */
4443:   int nFrac;        /* Number of digits to the right of the decimal point */
4444:   signed char *a;   /* Array of digits.  Most significant first. */
4445: };
4446: 
4447: /*
4448: ** Release memory held by a Decimal, but do not free the object itself.
4449: */
4450: static void decimal_clear(Decimal *p){
4451:   sqlite3_free(p->a);
4452: }
4453: 
4454: /*
4455: ** Destroy a Decimal object
4456: */
4457: static void decimal_free(Decimal *p){
4458:   if( p ){
4459:     decimal_clear(p);
4460:     sqlite3_free(p);
4461:   }
4462: }
4463: 
4464: /*
4465: ** Allocate a new Decimal object.  Initialize it to the number given
4466: ** by the input string.
4467: */
4468: static Decimal *decimal_new(
4469:   sqlite3_context *pCtx,
4470:   sqlite3_value *pIn,
4471:   int nAlt,
4472:   const unsigned char *zAlt
4473: ){
4474:   Decimal *p;
4475:   int n, i;
4476:   const unsigned char *zIn;
4477:   int iExp = 0;
4478:   p = sqlite3_malloc( sizeof(*p) );
4479:   if( p==0 ) goto new_no_mem;
4480:   p->sign = 0;
4481:   p->oom = 0;
4482:   p->isInit = 1;
4483:   p->isNull = 0;
4484:   p->nDigit = 0;
4485:   p->nFrac = 0;
4486:   if( zAlt ){
4487:     n = nAlt,
4488:     zIn = zAlt;
4489:   }else{
4490:     if( sqlite3_value_type(pIn)==SQLITE_NULL ){
4491:       p->a = 0;
4492:       p->isNull = 1;
4493:       return p;
4494:     }
4495:     n = sqlite3_value_bytes(pIn);
4496:     zIn = sqlite3_value_text(pIn);
4497:   }
4498:   p->a = sqlite3_malloc64( n+1 );
4499:   if( p->a==0 ) goto new_no_mem;
4500:   for(i=0; isspace(zIn[i]); i++){}
4501:   if( zIn[i]=='-' ){
4502:     p->sign = 1;
4503:     i++;
4504:   }else if( zIn[i]=='+' ){
4505:     i++;
4506:   }
4507:   while( i<n && zIn[i]=='0' ) i++;
4508:   while( i<n ){
4509:     char c = zIn[i];
4510:     if( c>='0' && c<='9' ){
4511:       p->a[p->nDigit++] = c - '0';
4512:     }else if( c=='.' ){
4513:       p->nFrac = p->nDigit + 1;
4514:     }else if( c=='e' || c=='E' ){
4515:       int j = i+1;
4516:       int neg = 0;
4517:       if( j>=n ) break;
4518:       if( zIn[j]=='-' ){
4519:         neg = 1;
4520:         j++;
4521:       }else if( zIn[j]=='+' ){
4522:         j++;
4523:       }
4524:       while( j<n && iExp<1000000 ){
4525:         if( zIn[j]>='0' && zIn[j]<='9' ){
4526:           iExp = iExp*10 + zIn[j] - '0';
4527:         }
4528:         j++;
4529:       }
4530:       if( neg ) iExp = -iExp;
4531:       break;
4532:     }
4533:     i++;
4534:   }
4535:   if( p->nFrac ){
4536:     p->nFrac = p->nDigit - (p->nFrac - 1);
4537:   }
4538:   if( iExp>0 ){
4539:     if( p->nFrac>0 ){
4540:       if( iExp<=p->nFrac ){
4541:         p->nFrac -= iExp;
4542:         iExp = 0;
4543:       }else{
4544:         iExp -= p->nFrac;
4545:         p->nFrac = 0;
4546:       }
4547:     }
4548:     if( iExp>0 ){
4549:       p->a = sqlite3_realloc64(p->a, p->nDigit + iExp + 1 );
4550:       if( p->a==0 ) goto new_no_mem;
4551:       memset(p->a+p->nDigit, 0, iExp);
4552:       p->nDigit += iExp;
4553:     }
4554:   }else if( iExp<0 ){
4555:     int nExtra;
4556:     iExp = -iExp;
4557:     nExtra = p->nDigit - p->nFrac - 1;
4558:     if( nExtra ){
4559:       if( nExtra>=iExp ){
4560:         p->nFrac += iExp;
4561:         iExp  = 0;
4562:       }else{
4563:         iExp -= nExtra;
4564:         p->nFrac = p->nDigit - 1;
4565:       }
4566:     }
4567:     if( iExp>0 ){
4568:       p->a = sqlite3_realloc64(p->a, p->nDigit + iExp + 1 );
4569:       if( p->a==0 ) goto new_no_mem;
4570:       memmove(p->a+iExp, p->a, p->nDigit);
4571:       memset(p->a, 0, iExp);
4572:       p->nDigit += iExp;
4573:       p->nFrac += iExp;
4574:     }
4575:   }
4576:   return p;
4577: 
4578: new_no_mem:
4579:   if( pCtx ) sqlite3_result_error_nomem(pCtx);
4580:   sqlite3_free(p);
4581:   return 0;
4582: }
4583: 
4584: /*
4585: ** Make the given Decimal the result.
4586: */
4587: static void decimal_result(sqlite3_context *pCtx, Decimal *p){
4588:   char *z;
4589:   int i, j;
4590:   int n;
4591:   if( p==0 || p->oom ){
4592:     sqlite3_result_error_nomem(pCtx);
4593:     return;
4594:   }
4595:   if( p->isNull ){
4596:     sqlite3_result_null(pCtx);
4597:     return;
4598:   }
4599:   z = sqlite3_malloc( p->nDigit+4 );
4600:   if( z==0 ){
4601:     sqlite3_result_error_nomem(pCtx);
4602:     return;
4603:   }
4604:   i = 0;
4605:   if( p->nDigit==0 || (p->nDigit==1 && p->a[0]==0) ){
4606:     p->sign = 0;
4607:   }
4608:   if( p->sign ){
4609:     z[0] = '-';
4610:     i = 1;
4611:   }
4612:   n = p->nDigit - p->nFrac;
4613:   if( n<=0 ){
4614:     z[i++] = '0';
4615:   }
4616:   j = 0;
4617:   while( n>1 && p->a[j]==0 ){
4618:     j++;
4619:     n--;
4620:   }
4621:   while( n>0  ){
4622:     z[i++] = p->a[j] + '0';
4623:     j++;
4624:     n--;
4625:   }
4626:   if( p->nFrac ){
4627:     z[i++] = '.';
4628:     do{
4629:       z[i++] = p->a[j] + '0';
4630:       j++;
4631:     }while( j<p->nDigit );
4632:   }
4633:   z[i] = 0;
4634:   sqlite3_result_text(pCtx, z, i, sqlite3_free);
4635: }
4636: 
4637: /*
4638: ** SQL Function:   decimal(X)
4639: **
4640: ** Convert input X into decimal and then back into text
4641: */
4642: static void decimalFunc(
4643:   sqlite3_context *context,
4644:   int argc,
4645:   sqlite3_value **argv
4646: ){
4647:   Decimal *p = decimal_new(context, argv[0], 0, 0);
4648:   UNUSED_PARAMETER(argc);
4649:   decimal_result(context, p);
4650:   decimal_free(p);
4651: }
4652: 
4653: /*
4654: ** Compare to Decimal objects.  Return negative, 0, or positive if the
4655: ** first object is less than, equal to, or greater than the second.
4656: **
4657: ** Preconditions for this routine:
4658: **
4659: **    pA!=0
4660: **    pA->isNull==0
4661: **    pB!=0
4662: **    pB->isNull==0
4663: */
4664: static int decimal_cmp(const Decimal *pA, const Decimal *pB){
4665:   int nASig, nBSig, rc, n;
4666:   if( pA->sign!=pB->sign ){
4667:     return pA->sign ? -1 : +1;
4668:   }
4669:   if( pA->sign ){
4670:     const Decimal *pTemp = pA;
4671:     pA = pB;
4672:     pB = pTemp;
4673:   }
4674:   nASig = pA->nDigit - pA->nFrac;
4675:   nBSig = pB->nDigit - pB->nFrac;
4676:   if( nASig!=nBSig ){
4677:     return nASig - nBSig;
4678:   }
4679:   n = pA->nDigit;
4680:   if( n>pB->nDigit ) n = pB->nDigit;
4681:   rc = memcmp(pA->a, pB->a, n);
4682:   if( rc==0 ){
4683:     rc = pA->nDigit - pB->nDigit;
4684:   }
4685:   return rc;
4686: }
4687: 
4688: /*
4689: ** SQL Function:   decimal_cmp(X, Y)
4690: **
4691: ** Return negative, zero, or positive if X is less then, equal to, or
4692: ** greater than Y.
4693: */
4694: static void decimalCmpFunc(
4695:   sqlite3_context *context,
4696:   int argc,
4697:   sqlite3_value **argv
4698: ){
4699:   Decimal *pA = 0, *pB = 0;
4700:   int rc;
4701: 
4702:   UNUSED_PARAMETER(argc);
4703:   pA = decimal_new(context, argv[0], 0, 0);
4704:   if( pA==0 || pA->isNull ) goto cmp_done;
4705:   pB = decimal_new(context, argv[1], 0, 0);
4706:   if( pB==0 || pB->isNull ) goto cmp_done;
4707:   rc = decimal_cmp(pA, pB);
4708:   if( rc<0 ) rc = -1;
4709:   else if( rc>0 ) rc = +1;
4710:   sqlite3_result_int(context, rc);
4711: cmp_done:
4712:   decimal_free(pA);
4713:   decimal_free(pB);
4714: }
4715: 
4716: /*
4717: ** Expand the Decimal so that it has a least nDigit digits and nFrac
4718: ** digits to the right of the decimal point.
4719: */
4720: static void decimal_expand(Decimal *p, int nDigit, int nFrac){
4721:   int nAddSig;
4722:   int nAddFrac;
4723:   if( p==0 ) return;
4724:   nAddFrac = nFrac - p->nFrac;
4725:   nAddSig = (nDigit - p->nDigit) - nAddFrac;
4726:   if( nAddFrac==0 && nAddSig==0 ) return;
4727:   p->a = sqlite3_realloc64(p->a, nDigit+1);
4728:   if( p->a==0 ){
4729:     p->oom = 1;
4730:     return;
4731:   }
4732:   if( nAddSig ){
4733:     memmove(p->a+nAddSig, p->a, p->nDigit);
4734:     memset(p->a, 0, nAddSig);
4735:     p->nDigit += nAddSig;
4736:   }
4737:   if( nAddFrac ){
4738:     memset(p->a+p->nDigit, 0, nAddFrac);
4739:     p->nDigit += nAddFrac;
4740:     p->nFrac += nAddFrac;
4741:   }
4742: }
4743: 
4744: /*
4745: ** Add the value pB into pA.
4746: **
4747: ** Both pA and pB might become denormalized by this routine.
4748: */
4749: static void decimal_add(Decimal *pA, Decimal *pB){
4750:   int nSig, nFrac, nDigit;
4751:   int i, rc;
4752:   if( pA==0 ){
4753:     return;
4754:   }
4755:   if( pA->oom || pB==0 || pB->oom ){
4756:     pA->oom = 1;
4757:     return;
4758:   }
4759:   if( pA->isNull || pB->isNull ){
4760:     pA->isNull = 1;
4761:     return;
4762:   }
4763:   nSig = pA->nDigit - pA->nFrac;
4764:   if( nSig && pA->a[0]==0 ) nSig--;
4765:   if( nSig<pB->nDigit-pB->nFrac ){
4766:     nSig = pB->nDigit - pB->nFrac;
4767:   }
4768:   nFrac = pA->nFrac;
4769:   if( nFrac<pB->nFrac ) nFrac = pB->nFrac;
4770:   nDigit = nSig + nFrac + 1;
4771:   decimal_expand(pA, nDigit, nFrac);
4772:   decimal_expand(pB, nDigit, nFrac);
4773:   if( pA->oom || pB->oom ){
4774:     pA->oom = 1;
4775:   }else{
4776:     if( pA->sign==pB->sign ){
4777:       int carry = 0;
4778:       for(i=nDigit-1; i>=0; i--){
4779:         int x = pA->a[i] + pB->a[i] + carry;
4780:         if( x>=10 ){
4781:           carry = 1;
4782:           pA->a[i] = x - 10;
4783:         }else{
4784:           carry = 0;
4785:           pA->a[i] = x;
4786:         }
4787:       }
4788:     }else{
4789:       signed char *aA, *aB;
4790:       int borrow = 0;
4791:       rc = memcmp(pA->a, pB->a, nDigit);
4792:       if( rc<0 ){
4793:         aA = pB->a;
4794:         aB = pA->a;
4795:         pA->sign = !pA->sign;
4796:       }else{
4797:         aA = pA->a;
4798:         aB = pB->a;
4799:       }
4800:       for(i=nDigit-1; i>=0; i--){
4801:         int x = aA[i] - aB[i] - borrow;
4802:         if( x<0 ){
4803:           pA->a[i] = x+10;
4804:           borrow = 1;
4805:         }else{
4806:           pA->a[i] = x;
4807:           borrow = 0;
4808:         }
4809:       }
4810:     }
4811:   }
4812: }
4813: 
4814: /*
4815: ** Compare text in decimal order.
4816: */
4817: static int decimalCollFunc(
4818:   void *notUsed,
4819:   int nKey1, const void *pKey1,
4820:   int nKey2, const void *pKey2
4821: ){
4822:   const unsigned char *zA = (const unsigned char*)pKey1;
4823:   const unsigned char *zB = (const unsigned char*)pKey2;
4824:   Decimal *pA = decimal_new(0, 0, nKey1, zA);
4825:   Decimal *pB = decimal_new(0, 0, nKey2, zB);
4826:   int rc;
4827:   UNUSED_PARAMETER(notUsed);
4828:   if( pA==0 || pB==0 ){
4829:     rc = 0;
4830:   }else{
4831:     rc = decimal_cmp(pA, pB);
4832:   }
4833:   decimal_free(pA);
4834:   decimal_free(pB);
4835:   return rc;
4836: }
4837: 
4838: 
4839: /*
4840: ** SQL Function:   decimal_add(X, Y)
4841: **                 decimal_sub(X, Y)
4842: **
4843: ** Return the sum or difference of X and Y.
4844: */
4845: static void decimalAddFunc(
4846:   sqlite3_context *context,
4847:   int argc,
4848:   sqlite3_value **argv
4849: ){
4850:   Decimal *pA = decimal_new(context, argv[0], 0, 0);
4851:   Decimal *pB = decimal_new(context, argv[1], 0, 0);
4852:   UNUSED_PARAMETER(argc);
4853:   decimal_add(pA, pB);
4854:   decimal_result(context, pA);
4855:   decimal_free(pA);
4856:   decimal_free(pB);
4857: }
4858: static void decimalSubFunc(
4859:   sqlite3_context *context,
4860:   int argc,
4861:   sqlite3_value **argv
4862: ){
4863:   Decimal *pA = decimal_new(context, argv[0], 0, 0);
4864:   Decimal *pB = decimal_new(context, argv[1], 0, 0);
4865:   UNUSED_PARAMETER(argc);
4866:   if( pB==0 ) return;
4867:   pB->sign = !pB->sign;
4868:   decimal_add(pA, pB);
4869:   decimal_result(context, pA);
4870:   decimal_free(pA);
4871:   decimal_free(pB);
4872: }
4873: 
4874: /* Aggregate funcion:   decimal_sum(X)
4875: **
4876: ** Works like sum() except that it uses decimal arithmetic for unlimited
4877: ** precision.
4878: */
4879: static void decimalSumStep(
4880:   sqlite3_context *context,
4881:   int argc,
4882:   sqlite3_value **argv
4883: ){
4884:   Decimal *p;
4885:   Decimal *pArg;
4886:   UNUSED_PARAMETER(argc);
4887:   p = sqlite3_aggregate_context(context, sizeof(*p));
4888:   if( p==0 ) return;
4889:   if( !p->isInit ){
4890:     p->isInit = 1;
4891:     p->a = sqlite3_malloc(2);
4892:     if( p->a==0 ){
4893:       p->oom = 1;
4894:     }else{
4895:       p->a[0] = 0;
4896:     }
4897:     p->nDigit = 1;
4898:     p->nFrac = 0;
4899:   }
4900:   if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;
4901:   pArg = decimal_new(context, argv[0], 0, 0);
4902:   decimal_add(p, pArg);
4903:   decimal_free(pArg);
4904: }
4905: static void decimalSumInverse(
4906:   sqlite3_context *context,
4907:   int argc,
4908:   sqlite3_value **argv
4909: ){
4910:   Decimal *p;
4911:   Decimal *pArg;
4912:   UNUSED_PARAMETER(argc);
4913:   p = sqlite3_aggregate_context(context, sizeof(*p));
4914:   if( p==0 ) return;
4915:   if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;
4916:   pArg = decimal_new(context, argv[0], 0, 0);
4917:   if( pArg ) pArg->sign = !pArg->sign;
4918:   decimal_add(p, pArg);
4919:   decimal_free(pArg);
4920: }
4921: static void decimalSumValue(sqlite3_context *context){
4922:   Decimal *p = sqlite3_aggregate_context(context, 0);
4923:   if( p==0 ) return;
4924:   decimal_result(context, p);
4925: }
4926: static void decimalSumFinalize(sqlite3_context *context){
4927:   Decimal *p = sqlite3_aggregate_context(context, 0);
4928:   if( p==0 ) return;
4929:   decimal_result(context, p);
4930:   decimal_clear(p);
4931: }
4932: 
4933: /*
4934: ** SQL Function:   decimal_mul(X, Y)
4935: **
4936: ** Return the product of X and Y.
4937: **
4938: ** All significant digits after the decimal point are retained.
4939: ** Trailing zeros after the decimal point are omitted as long as
4940: ** the number of digits after the decimal point is no less than
4941: ** either the number of digits in either input.
4942: */
4943: static void decimalMulFunc(
4944:   sqlite3_context *context,
4945:   int argc,
4946:   sqlite3_value **argv
4947: ){
4948:   Decimal *pA = decimal_new(context, argv[0], 0, 0);
4949:   Decimal *pB = decimal_new(context, argv[1], 0, 0);
4950:   signed char *acc = 0;
4951:   int i, j, k;
4952:   int minFrac;
4953:   UNUSED_PARAMETER(argc);
4954:   if( pA==0 || pA->oom || pA->isNull
4955:    || pB==0 || pB->oom || pB->isNull
4956:   ){
4957:     goto mul_end;
4958:   }
4959:   acc = sqlite3_malloc64( pA->nDigit + pB->nDigit + 2 );
4960:   if( acc==0 ){
4961:     sqlite3_result_error_nomem(context);
4962:     goto mul_end;
4963:   }
4964:   memset(acc, 0, pA->nDigit + pB->nDigit + 2);
4965:   minFrac = pA->nFrac;
4966:   if( pB->nFrac<minFrac ) minFrac = pB->nFrac;
4967:   for(i=pA->nDigit-1; i>=0; i--){
4968:     signed char f = pA->a[i];
4969:     int carry = 0, x;
4970:     for(j=pB->nDigit-1, k=i+j+3; j>=0; j--, k--){
4971:       x = acc[k] + f*pB->a[j] + carry;
4972:       acc[k] = x%10;
4973:       carry = x/10;
4974:     }
4975:     x = acc[k] + carry;
4976:     acc[k] = x%10;
4977:     acc[k-1] += x/10;
4978:   }
4979:   sqlite3_free(pA->a);
4980:   pA->a = acc;
4981:   acc = 0;
4982:   pA->nDigit += pB->nDigit + 2;
4983:   pA->nFrac += pB->nFrac;
4984:   pA->sign ^= pB->sign;
4985:   while( pA->nFrac>minFrac && pA->a[pA->nDigit-1]==0 ){
4986:     pA->nFrac--;
4987:     pA->nDigit--;
4988:   }
4989:   decimal_result(context, pA);
4990: 
4991: mul_end:
4992:   sqlite3_free(acc);
4993:   decimal_free(pA);
4994:   decimal_free(pB);
4995: }
4996: 
4997: #ifdef _WIN32
4998: 
4999: #endif
5000: int sqlite3_decimal_init(
5001:   sqlite3 *db,
5002:   char **pzErrMsg,
5003:   const sqlite3_api_routines *pApi
5004: ){
5005:   int rc = SQLITE_OK;
5006:   static const struct {
5007:     const char *zFuncName;
5008:     int nArg;
5009:     void (*xFunc)(sqlite3_context*,int,sqlite3_value**);
5010:   } aFunc[] = {
5011:     { "decimal",       1,   decimalFunc        },
5012:     { "decimal_cmp",   2,   decimalCmpFunc     },
5013:     { "decimal_add",   2,   decimalAddFunc     },
5014:     { "decimal_sub",   2,   decimalSubFunc     },
5015:     { "decimal_mul",   2,   decimalMulFunc     },
5016:   };
5017:   unsigned int i;
5018:   (void)pzErrMsg;  /* Unused parameter */
5019: 
5020:   SQLITE_EXTENSION_INIT2(pApi);
5021: 
5022:   for(i=0; i<sizeof(aFunc)/sizeof(aFunc[0]) && rc==SQLITE_OK; i++){
5023:     rc = sqlite3_create_function(db, aFunc[i].zFuncName, aFunc[i].nArg,
5024:                    SQLITE_UTF8|SQLITE_INNOCUOUS|SQLITE_DETERMINISTIC,
5025:                    0, aFunc[i].xFunc, 0, 0);
5026:   }
5027:   if( rc==SQLITE_OK ){
5028:     rc = sqlite3_create_window_function(db, "decimal_sum", 1,
5029:                    SQLITE_UTF8|SQLITE_INNOCUOUS|SQLITE_DETERMINISTIC, 0,
5030:                    decimalSumStep, decimalSumFinalize,
5031:                    decimalSumValue, decimalSumInverse, 0);
5032:   }
5033:   if( rc==SQLITE_OK ){
5034:     rc = sqlite3_create_collation(db, "decimal", SQLITE_UTF8,
5035:                                   0, decimalCollFunc);
5036:   }
5037:   return rc;
5038: }
5039: 
5040: /************************* End ../ext/misc/decimal.c ********************/
5041: /************************* Begin ../ext/misc/ieee754.c ******************/
5042: /*
5043: ** 2013-04-17
5044: **
5045: ** The author disclaims copyright to this source code.  In place of
5046: ** a legal notice, here is a blessing:
5047: **
5048: **    May you do good and not evil.
5049: **    May you find forgiveness for yourself and forgive others.
5050: **    May you share freely, never taking more than you give.
5051: **
5052: ******************************************************************************
5053: **
5054: ** This SQLite extension implements functions for the exact display
5055: ** and input of IEEE754 Binary64 floating-point numbers.
5056: **
5057: **   ieee754(X)
5058: **   ieee754(Y,Z)
5059: **
5060: ** In the first form, the value X should be a floating-point number.
5061: ** The function will return a string of the form 'ieee754(Y,Z)' where
5062: ** Y and Z are integers such that X==Y*pow(2,Z).
5063: **
5064: ** In the second form, Y and Z are integers which are the mantissa and
5065: ** base-2 exponent of a new floating point number.  The function returns
5066: ** a floating-point value equal to Y*pow(2,Z).
5067: **
5068: ** Examples:
5069: **
5070: **     ieee754(2.0)             ->     'ieee754(2,0)'
5071: **     ieee754(45.25)           ->     'ieee754(181,-2)'
5072: **     ieee754(2, 0)            ->     2.0
5073: **     ieee754(181, -2)         ->     45.25
5074: **
5075: ** Two additional functions break apart the one-argument ieee754()
5076: ** result into separate integer values:
5077: **
5078: **     ieee754_mantissa(45.25)  ->     181
5079: **     ieee754_exponent(45.25)  ->     -2
5080: **
5081: ** These functions convert binary64 numbers into blobs and back again.
5082: **
5083: **     ieee754_from_blob(x'3ff0000000000000')  ->  1.0
5084: **     ieee754_to_blob(1.0)                    ->  x'3ff0000000000000'
5085: **
5086: ** In all single-argument functions, if the argument is an 8-byte blob
5087: ** then that blob is interpreted as a big-endian binary64 value.
5088: **
5089: **
5090: ** EXACT DECIMAL REPRESENTATION OF BINARY64 VALUES
5091: ** -----------------------------------------------
5092: **
5093: ** This extension in combination with the separate 'decimal' extension
5094: ** can be used to compute the exact decimal representation of binary64
5095: ** values.  To begin, first compute a table of exponent values:
5096: **
5097: **    CREATE TABLE pow2(x INTEGER PRIMARY KEY, v TEXT);
5098: **    WITH RECURSIVE c(x,v) AS (
5099: **      VALUES(0,'1')
5100: **      UNION ALL
5101: **      SELECT x+1, decimal_mul(v,'2') FROM c WHERE x+1<=971
5102: **    ) INSERT INTO pow2(x,v) SELECT x, v FROM c;
5103: **    WITH RECURSIVE c(x,v) AS (
5104: **      VALUES(-1,'0.5')
5105: **      UNION ALL
5106: **      SELECT x-1, decimal_mul(v,'0.5') FROM c WHERE x-1>=-1075
5107: **    ) INSERT INTO pow2(x,v) SELECT x, v FROM c;
5108: **
5109: ** Then, to compute the exact decimal representation of a floating
5110: ** point value (the value 47.49 is used in the example) do:
5111: **
5112: **    WITH c(n) AS (VALUES(47.49))
5113: **          ---------------^^^^^---- Replace with whatever you want
5114: **    SELECT decimal_mul(ieee754_mantissa(c.n),pow2.v)
5115: **      FROM pow2, c WHERE pow2.x=ieee754_exponent(c.n);
5116: **
5117: ** Here is a query to show various boundry values for the binary64
5118: ** number format:
5119: **
5120: **    WITH c(name,bin) AS (VALUES
5121: **       ('minimum positive value',        x'0000000000000001'),
5122: **       ('maximum subnormal value',       x'000fffffffffffff'),
5123: **       ('mininum positive nornal value', x'0010000000000000'),
5124: **       ('maximum value',                 x'7fefffffffffffff'))
5125: **    SELECT c.name, decimal_mul(ieee754_mantissa(c.bin),pow2.v)
5126: **      FROM pow2, c WHERE pow2.x=ieee754_exponent(c.bin);
5127: **
5128: */
5129: /* #include "sqlite3ext.h" */
5130: SQLITE_EXTENSION_INIT1
5131: #include <assert.h>
5132: #include <string.h>
5133: 
5134: /* Mark a function parameter as unused, to suppress nuisance compiler
5135: ** warnings. */
5136: #ifndef UNUSED_PARAMETER
5137: # define UNUSED_PARAMETER(X)  (void)(X)
5138: #endif
5139: 
5140: /*
5141: ** Implementation of the ieee754() function
5142: */
5143: static void ieee754func(
5144:   sqlite3_context *context,
5145:   int argc,
5146:   sqlite3_value **argv
5147: ){
5148:   if( argc==1 ){
5149:     sqlite3_int64 m, a;
5150:     double r;
5151:     int e;
5152:     int isNeg;
5153:     char zResult[100];
5154:     assert( sizeof(m)==sizeof(r) );
5155:     if( sqlite3_value_type(argv[0])==SQLITE_BLOB
5156:      && sqlite3_value_bytes(argv[0])==sizeof(r)
5157:     ){
5158:       const unsigned char *x = sqlite3_value_blob(argv[0]);
5159:       unsigned int i;
5160:       sqlite3_uint64 v = 0;
5161:       for(i=0; i<sizeof(r); i++){
5162:         v = (v<<8) | x[i];
5163:       }
5164:       memcpy(&r, &v, sizeof(r));
5165:     }else{
5166:       r = sqlite3_value_double(argv[0]);
5167:     }
5168:     if( r<0.0 ){
5169:       isNeg = 1;
5170:       r = -r;
5171:     }else{
5172:       isNeg = 0;
5173:     }
5174:     memcpy(&a,&r,sizeof(a));
5175:     if( a==0 ){
5176:       e = 0;
5177:       m = 0;
5178:     }else{
5179:       e = a>>52;
5180:       m = a & ((((sqlite3_int64)1)<<52)-1);
5181:       if( e==0 ){
5182:         m <<= 1;
5183:       }else{
5184:         m |= ((sqlite3_int64)1)<<52;
5185:       }
5186:       while( e<1075 && m>0 && (m&1)==0 ){
5187:         m >>= 1;
5188:         e++;
5189:       }
5190:       if( isNeg ) m = -m;
5191:     }
5192:     switch( *(int*)sqlite3_user_data(context) ){
5193:       case 0:
5194:         sqlite3_snprintf(sizeof(zResult), zResult, "ieee754(%lld,%d)",
5195:                          m, e-1075);
5196:         sqlite3_result_text(context, zResult, -1, SQLITE_TRANSIENT);
5197:         break;
5198:       case 1:
5199:         sqlite3_result_int64(context, m);
5200:         break;
5201:       case 2:
5202:         sqlite3_result_int(context, e-1075);
5203:         break;
5204:     }
5205:   }else{
5206:     sqlite3_int64 m, e, a;
5207:     double r;
5208:     int isNeg = 0;
5209:     m = sqlite3_value_int64(argv[0]);
5210:     e = sqlite3_value_int64(argv[1]);
5211:     if( m<0 ){
5212:       isNeg = 1;
5213:       m = -m;
5214:       if( m<0 ) return;
5215:     }else if( m==0 && e>-1000 && e<1000 ){
5216:       sqlite3_result_double(context, 0.0);
5217:       return;
5218:     }
5219:     while( (m>>32)&0xffe00000 ){
5220:       m >>= 1;
5221:       e++;
5222:     }
5223:     while( m!=0 && ((m>>32)&0xfff00000)==0 ){
5224:       m <<= 1;
5225:       e--;
5226:     }
5227:     e += 1075;
5228:     if( e<=0 ){
5229:       /* Subnormal */
5230:       m >>= 1-e;
5231:       e = 0;
5232:     }else if( e>0x7ff ){
5233:       e = 0x7ff;
5234:     }
5235:     a = m & ((((sqlite3_int64)1)<<52)-1);
5236:     a |= e<<52;
5237:     if( isNeg ) a |= ((sqlite3_uint64)1)<<63;
5238:     memcpy(&r, &a, sizeof(r));
5239:     sqlite3_result_double(context, r);
5240:   }
5241: }
5242: 
5243: /*
5244: ** Functions to convert between blobs and floats.
5245: */
5246: static void ieee754func_from_blob(
5247:   sqlite3_context *context,
5248:   int argc,
5249:   sqlite3_value **argv
5250: ){
5251:   UNUSED_PARAMETER(argc);
5252:   if( sqlite3_value_type(argv[0])==SQLITE_BLOB
5253:    && sqlite3_value_bytes(argv[0])==sizeof(double)
5254:   ){
5255:     double r;
5256:     const unsigned char *x = sqlite3_value_blob(argv[0]);
5257:     unsigned int i;
5258:     sqlite3_uint64 v = 0;
5259:     for(i=0; i<sizeof(r); i++){
5260:       v = (v<<8) | x[i];
5261:     }
5262:     memcpy(&r, &v, sizeof(r));
5263:     sqlite3_result_double(context, r);
5264:   }
5265: }
5266: static void ieee754func_to_blob(
5267:   sqlite3_context *context,
5268:   int argc,
5269:   sqlite3_value **argv
5270: ){
5271:   UNUSED_PARAMETER(argc);
5272:   if( sqlite3_value_type(argv[0])==SQLITE_FLOAT
5273:    || sqlite3_value_type(argv[0])==SQLITE_INTEGER
5274:   ){
5275:     double r = sqlite3_value_double(argv[0]);
5276:     sqlite3_uint64 v;
5277:     unsigned char a[sizeof(r)];
5278:     unsigned int i;
5279:     memcpy(&v, &r, sizeof(r));
5280:     for(i=1; i<=sizeof(r); i++){
5281:       a[sizeof(r)-i] = v&0xff;
5282:       v >>= 8;
5283:     }
5284:     sqlite3_result_blob(context, a, sizeof(r), SQLITE_TRANSIENT);
5285:   }
5286: }
5287: 
5288: 
5289: #ifdef _WIN32
5290: 
5291: #endif
5292: int sqlite3_ieee_init(
5293:   sqlite3 *db,
5294:   char **pzErrMsg,
5295:   const sqlite3_api_routines *pApi
5296: ){
5297:   static const struct {
5298:     char *zFName;
5299:     int nArg;
5300:     int iAux;
5301:     void (*xFunc)(sqlite3_context*,int,sqlite3_value**);
5302:   } aFunc[] = {
5303:     { "ieee754",           1,   0, ieee754func },
5304:     { "ieee754",           2,   0, ieee754func },
5305:     { "ieee754_mantissa",  1,   1, ieee754func },
5306:     { "ieee754_exponent",  1,   2, ieee754func },
5307:     { "ieee754_to_blob",   1,   0, ieee754func_to_blob },
5308:     { "ieee754_from_blob", 1,   0, ieee754func_from_blob },
5309: 
5310:   };
5311:   unsigned int i;
5312:   int rc = SQLITE_OK;
5313:   SQLITE_EXTENSION_INIT2(pApi);
5314:   (void)pzErrMsg;  /* Unused parameter */
5315:   for(i=0; i<sizeof(aFunc)/sizeof(aFunc[0]) && rc==SQLITE_OK; i++){
5316:     rc = sqlite3_create_function(db, aFunc[i].zFName, aFunc[i].nArg,
5317:                                SQLITE_UTF8|SQLITE_INNOCUOUS,
5318:                                (void*)&aFunc[i].iAux,
5319:                                aFunc[i].xFunc, 0, 0);
5320:   }
5321:   return rc;
5322: }
5323: 
5324: /************************* End ../ext/misc/ieee754.c ********************/
5325: #ifdef SQLITE_HAVE_ZLIB
5326: /************************* Begin ../ext/misc/zipfile.c ******************/
5327: /*
5328: ** 2017-12-26
5329: **
5330: ** The author disclaims copyright to this source code.  In place of
5331: ** a legal notice, here is a blessing:
5332: **
5333: **    May you do good and not evil.
5334: **    May you find forgiveness for yourself and forgive others.
5335: **    May you share freely, never taking more than you give.
5336: **
5337: ******************************************************************************
5338: **
5339: ** This file implements a virtual table for reading and writing ZIP archive
5340: ** files.
5341: **
5342: ** Usage example:
5343: **
5344: **     SELECT name, sz, datetime(mtime,'unixepoch') FROM zipfile($filename);
5345: **
5346: ** Current limitations:
5347: **
5348: **    *  No support for encryption
5349: **    *  No support for ZIP archives spanning multiple files
5350: **    *  No support for zip64 extensions
5351: **    *  Only the "inflate/deflate" (zlib) compression method is supported
5352: */
5353: /* #include "sqlite3ext.h" */
5354: SQLITE_EXTENSION_INIT1
5355: #include <stdio.h>
5356: #include <string.h>
5357: #include <assert.h>
5358: 
5359: #include <zlib.h>
5360: 
5361: #ifndef SQLITE_OMIT_VIRTUALTABLE
5362: 
5363: #ifndef SQLITE_AMALGAMATION
5364: 
5365: /* typedef sqlite3_int64 i64; */
5366: /* typedef unsigned char u8; */
5367: typedef unsigned short u16;
5368: typedef unsigned long u32;
5369: #define MIN(a,b) ((a)<(b) ? (a) : (b))
5370: 
5371: #if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)
5372: # define ALWAYS(X)      (1)
5373: # define NEVER(X)       (0)
5374: #elif !defined(NDEBUG)
5375: # define ALWAYS(X)      ((X)?1:(assert(0),0))
5376: # define NEVER(X)       ((X)?(assert(0),1):0)
5377: #else
5378: # define ALWAYS(X)      (X)
5379: # define NEVER(X)       (X)
5380: #endif
5381: 
5382: #endif   /* SQLITE_AMALGAMATION */
5383: 
5384: /*
5385: ** Definitions for mode bitmasks S_IFDIR, S_IFREG and S_IFLNK.
5386: **
5387: ** In some ways it would be better to obtain these values from system
5388: ** header files. But, the dependency is undesirable and (a) these
5389: ** have been stable for decades, (b) the values are part of POSIX and
5390: ** are also made explicit in [man stat], and (c) are part of the
5391: ** file format for zip archives.
5392: */
5393: #ifndef S_IFDIR
5394: # define S_IFDIR 0040000
5395: #endif
5396: #ifndef S_IFREG
5397: # define S_IFREG 0100000
5398: #endif
5399: #ifndef S_IFLNK
5400: # define S_IFLNK 0120000
5401: #endif
5402: 
5403: static const char ZIPFILE_SCHEMA[] =
5404:   "CREATE TABLE y("
5405:     "name PRIMARY KEY,"  /* 0: Name of file in zip archive */
5406:     "mode,"              /* 1: POSIX mode for file */
5407:     "mtime,"             /* 2: Last modification time (secs since 1970)*/
5408:     "sz,"                /* 3: Size of object */
5409:     "rawdata,"           /* 4: Raw data */
5410:     "data,"              /* 5: Uncompressed data */
5411:     "method,"            /* 6: Compression method (integer) */
5412:     "z HIDDEN"           /* 7: Name of zip file */
5413:   ") WITHOUT ROWID;";
5414: 
5415: #define ZIPFILE_F_COLUMN_IDX 7    /* Index of column "file" in the above */
5416: #define ZIPFILE_BUFFER_SIZE (64*1024)
5417: 
5418: 
5419: /*
5420: ** Magic numbers used to read and write zip files.
5421: **
5422: ** ZIPFILE_NEWENTRY_MADEBY:
5423: **   Use this value for the "version-made-by" field in new zip file
5424: **   entries. The upper byte indicates "unix", and the lower byte
5425: **   indicates that the zip file matches pkzip specification 3.0.
5426: **   This is what info-zip seems to do.
5427: **
5428: ** ZIPFILE_NEWENTRY_REQUIRED:
5429: **   Value for "version-required-to-extract" field of new entries.
5430: **   Version 2.0 is required to support folders and deflate compression.
5431: **
5432: ** ZIPFILE_NEWENTRY_FLAGS:
5433: **   Value for "general-purpose-bit-flags" field of new entries. Bit
5434: **   11 means "utf-8 filename and comment".
5435: **
5436: ** ZIPFILE_SIGNATURE_CDS:
5437: **   First 4 bytes of a valid CDS record.
5438: **
5439: ** ZIPFILE_SIGNATURE_LFH:
5440: **   First 4 bytes of a valid LFH record.
5441: **
5442: ** ZIPFILE_SIGNATURE_EOCD
5443: **   First 4 bytes of a valid EOCD record.
5444: */
5445: #define ZIPFILE_EXTRA_TIMESTAMP   0x5455
5446: #define ZIPFILE_NEWENTRY_MADEBY   ((3<<8) + 30)
5447: #define ZIPFILE_NEWENTRY_REQUIRED 20
5448: #define ZIPFILE_NEWENTRY_FLAGS    0x800
5449: #define ZIPFILE_SIGNATURE_CDS     0x02014b50
5450: #define ZIPFILE_SIGNATURE_LFH     0x04034b50
5451: #define ZIPFILE_SIGNATURE_EOCD    0x06054b50
5452: 
5453: /*
5454: ** The sizes of the fixed-size part of each of the three main data
5455: ** structures in a zip archive.
5456: */
5457: #define ZIPFILE_LFH_FIXED_SZ      30
5458: #define ZIPFILE_EOCD_FIXED_SZ     22
5459: #define ZIPFILE_CDS_FIXED_SZ      46
5460: 
5461: /*
5462: *** 4.3.16  End of central directory record:
5463: ***
5464: ***   end of central dir signature    4 bytes  (0x06054b50)
5465: ***   number of this disk             2 bytes
5466: ***   number of the disk with the
5467: ***   start of the central directory  2 bytes
5468: ***   total number of entries in the
5469: ***   central directory on this disk  2 bytes
5470: ***   total number of entries in
5471: ***   the central directory           2 bytes
5472: ***   size of the central directory   4 bytes
5473: ***   offset of start of central
5474: ***   directory with respect to
5475: ***   the starting disk number        4 bytes
5476: ***   .ZIP file comment length        2 bytes
5477: ***   .ZIP file comment       (variable size)
5478: */
5479: typedef struct ZipfileEOCD ZipfileEOCD;
5480: struct ZipfileEOCD {
5481:   u16 iDisk;
5482:   u16 iFirstDisk;
5483:   u16 nEntry;
5484:   u16 nEntryTotal;
5485:   u32 nSize;
5486:   u32 iOffset;
5487: };
5488: 
5489: /*
5490: *** 4.3.12  Central directory structure:
5491: ***
5492: *** ...
5493: ***
5494: ***   central file header signature   4 bytes  (0x02014b50)
5495: ***   version made by                 2 bytes
5496: ***   version needed to extract       2 bytes
5497: ***   general purpose bit flag        2 bytes
5498: ***   compression method              2 bytes
5499: ***   last mod file time              2 bytes
5500: ***   last mod file date              2 bytes
5501: ***   crc-32                          4 bytes
5502: ***   compressed size                 4 bytes
5503: ***   uncompressed size               4 bytes
5504: ***   file name length                2 bytes
5505: ***   extra field length              2 bytes
5506: ***   file comment length             2 bytes
5507: ***   disk number start               2 bytes
5508: ***   internal file attributes        2 bytes
5509: ***   external file attributes        4 bytes
5510: ***   relative offset of local header 4 bytes
5511: */
5512: typedef struct ZipfileCDS ZipfileCDS;
5513: struct ZipfileCDS {
5514:   u16 iVersionMadeBy;
5515:   u16 iVersionExtract;
5516:   u16 flags;
5517:   u16 iCompression;
5518:   u16 mTime;
5519:   u16 mDate;
5520:   u32 crc32;
5521:   u32 szCompressed;
5522:   u32 szUncompressed;
5523:   u16 nFile;
5524:   u16 nExtra;
5525:   u16 nComment;
5526:   u16 iDiskStart;
5527:   u16 iInternalAttr;
5528:   u32 iExternalAttr;
5529:   u32 iOffset;
5530:   char *zFile;                    /* Filename (sqlite3_malloc()) */
5531: };
5532: 
5533: /*
5534: *** 4.3.7  Local file header:
5535: ***
5536: ***   local file header signature     4 bytes  (0x04034b50)
5537: ***   version needed to extract       2 bytes
5538: ***   general purpose bit flag        2 bytes
5539: ***   compression method              2 bytes
5540: ***   last mod file time              2 bytes
5541: ***   last mod file date              2 bytes
5542: ***   crc-32                          4 bytes
5543: ***   compressed size                 4 bytes
5544: ***   uncompressed size               4 bytes
5545: ***   file name length                2 bytes
5546: ***   extra field length              2 bytes
5547: ***
5548: */
5549: typedef struct ZipfileLFH ZipfileLFH;
5550: struct ZipfileLFH {
5551:   u16 iVersionExtract;
5552:   u16 flags;
5553:   u16 iCompression;
5554:   u16 mTime;
5555:   u16 mDate;
5556:   u32 crc32;
5557:   u32 szCompressed;
5558:   u32 szUncompressed;
5559:   u16 nFile;
5560:   u16 nExtra;
5561: };
5562: 
5563: typedef struct ZipfileEntry ZipfileEntry;
5564: struct ZipfileEntry {
5565:   ZipfileCDS cds;            /* Parsed CDS record */
5566:   u32 mUnixTime;             /* Modification time, in UNIX format */
5567:   u8 *aExtra;                /* cds.nExtra+cds.nComment bytes of extra data */
5568:   i64 iDataOff;              /* Offset to data in file (if aData==0) */
5569:   u8 *aData;                 /* cds.szCompressed bytes of compressed data */
5570:   ZipfileEntry *pNext;       /* Next element in in-memory CDS */
5571: };
5572: 
5573: /*
5574: ** Cursor type for zipfile tables.
5575: */
5576: typedef struct ZipfileCsr ZipfileCsr;
5577: struct ZipfileCsr {
5578:   sqlite3_vtab_cursor base;  /* Base class - must be first */
5579:   i64 iId;                   /* Cursor ID */
5580:   u8 bEof;                   /* True when at EOF */
5581:   u8 bNoop;                  /* If next xNext() call is no-op */
5582: 
5583:   /* Used outside of write transactions */
5584:   FILE *pFile;               /* Zip file */
5585:   i64 iNextOff;              /* Offset of next record in central directory */
5586:   ZipfileEOCD eocd;          /* Parse of central directory record */
5587: 
5588:   ZipfileEntry *pFreeEntry;  /* Free this list when cursor is closed or reset */
5589:   ZipfileEntry *pCurrent;    /* Current entry */
5590:   ZipfileCsr *pCsrNext;      /* Next cursor on same virtual table */
5591: };
5592: 
5593: typedef struct ZipfileTab ZipfileTab;
5594: struct ZipfileTab {
5595:   sqlite3_vtab base;         /* Base class - must be first */
5596:   char *zFile;               /* Zip file this table accesses (may be NULL) */
5597:   sqlite3 *db;               /* Host database connection */
5598:   u8 *aBuffer;               /* Temporary buffer used for various tasks */
5599: 
5600:   ZipfileCsr *pCsrList;      /* List of cursors */
5601:   i64 iNextCsrid;
5602: 
5603:   /* The following are used by write transactions only */
5604:   ZipfileEntry *pFirstEntry; /* Linked list of all files (if pWriteFd!=0) */
5605:   ZipfileEntry *pLastEntry;  /* Last element in pFirstEntry list */
5606:   FILE *pWriteFd;            /* File handle open on zip archive */
5607:   i64 szCurrent;             /* Current size of zip archive */
5608:   i64 szOrig;                /* Size of archive at start of transaction */
5609: };
5610: 
5611: /*
5612: ** Set the error message contained in context ctx to the results of
5613: ** vprintf(zFmt, ...).
5614: */
5615: static void zipfileCtxErrorMsg(sqlite3_context *ctx, const char *zFmt, ...){
5616:   char *zMsg = 0;
5617:   va_list ap;
5618:   va_start(ap, zFmt);
5619:   zMsg = sqlite3_vmprintf(zFmt, ap);
5620:   sqlite3_result_error(ctx, zMsg, -1);
5621:   sqlite3_free(zMsg);
5622:   va_end(ap);
5623: }
5624: 
5625: /*
5626: ** If string zIn is quoted, dequote it in place. Otherwise, if the string
5627: ** is not quoted, do nothing.
5628: */
5629: static void zipfileDequote(char *zIn){
5630:   char q = zIn[0];
5631:   if( q=='"' || q=='\'' || q=='`' || q=='[' ){
5632:     int iIn = 1;
5633:     int iOut = 0;
5634:     if( q=='[' ) q = ']';
5635:     while( ALWAYS(zIn[iIn]) ){
5636:       char c = zIn[iIn++];
5637:       if( c==q && zIn[iIn++]!=q ) break;
5638:       zIn[iOut++] = c;
5639:     }
5640:     zIn[iOut] = '\0';
5641:   }
5642: }
5643: 
5644: /*
5645: ** Construct a new ZipfileTab virtual table object.
5646: **
5647: **   argv[0]   -> module name  ("zipfile")
5648: **   argv[1]   -> database name
5649: **   argv[2]   -> table name
5650: **   argv[...] -> "column name" and other module argument fields.
5651: */
5652: static int zipfileConnect(
5653:   sqlite3 *db,
5654:   void *pAux,
5655:   int argc, const char *const*argv,
5656:   sqlite3_vtab **ppVtab,
5657:   char **pzErr
5658: ){
5659:   int nByte = sizeof(ZipfileTab) + ZIPFILE_BUFFER_SIZE;
5660:   int nFile = 0;
5661:   const char *zFile = 0;
5662:   ZipfileTab *pNew = 0;
5663:   int rc;
5664: 
5665:   /* If the table name is not "zipfile", require that the argument be
5666:   ** specified. This stops zipfile tables from being created as:
5667:   **
5668:   **   CREATE VIRTUAL TABLE zzz USING zipfile();
5669:   **
5670:   ** It does not prevent:
5671:   **
5672:   **   CREATE VIRTUAL TABLE zipfile USING zipfile();
5673:   */
5674:   assert( 0==sqlite3_stricmp(argv[0], "zipfile") );
5675:   if( (0!=sqlite3_stricmp(argv[2], "zipfile") && argc<4) || argc>4 ){
5676:     *pzErr = sqlite3_mprintf("zipfile constructor requires one argument");
5677:     return SQLITE_ERROR;
5678:   }
5679: 
5680:   if( argc>3 ){
5681:     zFile = argv[3];
5682:     nFile = (int)strlen(zFile)+1;
5683:   }
5684: 
5685:   rc = sqlite3_declare_vtab(db, ZIPFILE_SCHEMA);
5686:   if( rc==SQLITE_OK ){
5687:     pNew = (ZipfileTab*)sqlite3_malloc64((sqlite3_int64)nByte+nFile);
5688:     if( pNew==0 ) return SQLITE_NOMEM;
5689:     memset(pNew, 0, nByte+nFile);
5690:     pNew->db = db;
5691:     pNew->aBuffer = (u8*)&pNew[1];
5692:     if( zFile ){
5693:       pNew->zFile = (char*)&pNew->aBuffer[ZIPFILE_BUFFER_SIZE];
5694:       memcpy(pNew->zFile, zFile, nFile);
5695:       zipfileDequote(pNew->zFile);
5696:     }
5697:   }
5698:   sqlite3_vtab_config(db, SQLITE_VTAB_DIRECTONLY);
5699:   *ppVtab = (sqlite3_vtab*)pNew;
5700:   return rc;
5701: }
5702: 
5703: /*
5704: ** Free the ZipfileEntry structure indicated by the only argument.
5705: */
5706: static void zipfileEntryFree(ZipfileEntry *p){
5707:   if( p ){
5708:     sqlite3_free(p->cds.zFile);
5709:     sqlite3_free(p);
5710:   }
5711: }
5712: 
5713: /*
5714: ** Release resources that should be freed at the end of a write
5715: ** transaction.
5716: */
5717: static void zipfileCleanupTransaction(ZipfileTab *pTab){
5718:   ZipfileEntry *pEntry;
5719:   ZipfileEntry *pNext;
5720: 
5721:   if( pTab->pWriteFd ){
5722:     fclose(pTab->pWriteFd);
5723:     pTab->pWriteFd = 0;
5724:   }
5725:   for(pEntry=pTab->pFirstEntry; pEntry; pEntry=pNext){
5726:     pNext = pEntry->pNext;
5727:     zipfileEntryFree(pEntry);
5728:   }
5729:   pTab->pFirstEntry = 0;
5730:   pTab->pLastEntry = 0;
5731:   pTab->szCurrent = 0;
5732:   pTab->szOrig = 0;
5733: }
5734: 
5735: /*
5736: ** This method is the destructor for zipfile vtab objects.
5737: */
5738: static int zipfileDisconnect(sqlite3_vtab *pVtab){
5739:   zipfileCleanupTransaction((ZipfileTab*)pVtab);
5740:   sqlite3_free(pVtab);
5741:   return SQLITE_OK;
5742: }
5743: 
5744: /*
5745: ** Constructor for a new ZipfileCsr object.
5746: */
5747: static int zipfileOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCsr){
5748:   ZipfileTab *pTab = (ZipfileTab*)p;
5749:   ZipfileCsr *pCsr;
5750:   pCsr = sqlite3_malloc(sizeof(*pCsr));
5751:   *ppCsr = (sqlite3_vtab_cursor*)pCsr;
5752:   if( pCsr==0 ){
5753:     return SQLITE_NOMEM;
5754:   }
5755:   memset(pCsr, 0, sizeof(*pCsr));
5756:   pCsr->iId = ++pTab->iNextCsrid;
5757:   pCsr->pCsrNext = pTab->pCsrList;
5758:   pTab->pCsrList = pCsr;
5759:   return SQLITE_OK;
5760: }
5761: 
5762: /*
5763: ** Reset a cursor back to the state it was in when first returned
5764: ** by zipfileOpen().
5765: */
5766: static void zipfileResetCursor(ZipfileCsr *pCsr){
5767:   ZipfileEntry *p;
5768:   ZipfileEntry *pNext;
5769: 
5770:   pCsr->bEof = 0;
5771:   if( pCsr->pFile ){
5772:     fclose(pCsr->pFile);
5773:     pCsr->pFile = 0;
5774:     zipfileEntryFree(pCsr->pCurrent);
5775:     pCsr->pCurrent = 0;
5776:   }
5777: 
5778:   for(p=pCsr->pFreeEntry; p; p=pNext){
5779:     pNext = p->pNext;
5780:     zipfileEntryFree(p);
5781:   }
5782: }
5783: 
5784: /*
5785: ** Destructor for an ZipfileCsr.
5786: */
5787: static int zipfileClose(sqlite3_vtab_cursor *cur){
5788:   ZipfileCsr *pCsr = (ZipfileCsr*)cur;
5789:   ZipfileTab *pTab = (ZipfileTab*)(pCsr->base.pVtab);
5790:   ZipfileCsr **pp;
5791:   zipfileResetCursor(pCsr);
5792: 
5793:   /* Remove this cursor from the ZipfileTab.pCsrList list. */
5794:   for(pp=&pTab->pCsrList; *pp!=pCsr; pp=&((*pp)->pCsrNext));
5795:   *pp = pCsr->pCsrNext;
5796: 
5797:   sqlite3_free(pCsr);
5798:   return SQLITE_OK;
5799: }
5800: 
5801: /*
5802: ** Set the error message for the virtual table associated with cursor
5803: ** pCsr to the results of vprintf(zFmt, ...).
5804: */
5805: static void zipfileTableErr(ZipfileTab *pTab, const char *zFmt, ...){
5806:   va_list ap;
5807:   va_start(ap, zFmt);
5808:   sqlite3_free(pTab->base.zErrMsg);
5809:   pTab->base.zErrMsg = sqlite3_vmprintf(zFmt, ap);
5810:   va_end(ap);
5811: }
5812: static void zipfileCursorErr(ZipfileCsr *pCsr, const char *zFmt, ...){
5813:   va_list ap;
5814:   va_start(ap, zFmt);
5815:   sqlite3_free(pCsr->base.pVtab->zErrMsg);
5816:   pCsr->base.pVtab->zErrMsg = sqlite3_vmprintf(zFmt, ap);
5817:   va_end(ap);
5818: }
5819: 
5820: /*
5821: ** Read nRead bytes of data from offset iOff of file pFile into buffer
5822: ** aRead[]. Return SQLITE_OK if successful, or an SQLite error code
5823: ** otherwise.
5824: **
5825: ** If an error does occur, output variable (*pzErrmsg) may be set to point
5826: ** to an English language error message. It is the responsibility of the
5827: ** caller to eventually free this buffer using
5828: ** sqlite3_free().
5829: */
5830: static int zipfileReadData(
5831:   FILE *pFile,                    /* Read from this file */
5832:   u8 *aRead,                      /* Read into this buffer */
5833:   int nRead,                      /* Number of bytes to read */
5834:   i64 iOff,                       /* Offset to read from */
5835:   char **pzErrmsg                 /* OUT: Error message (from sqlite3_malloc) */
5836: ){
5837:   size_t n;
5838:   fseek(pFile, (long)iOff, SEEK_SET);
5839:   n = fread(aRead, 1, nRead, pFile);
5840:   if( (int)n!=nRead ){
5841:     *pzErrmsg = sqlite3_mprintf("error in fread()");
5842:     return SQLITE_ERROR;
5843:   }
5844:   return SQLITE_OK;
5845: }
5846: 
5847: static int zipfileAppendData(
5848:   ZipfileTab *pTab,
5849:   const u8 *aWrite,
5850:   int nWrite
5851: ){
5852:   size_t n;
5853:   fseek(pTab->pWriteFd, (long)pTab->szCurrent, SEEK_SET);
5854:   n = fwrite(aWrite, 1, nWrite, pTab->pWriteFd);
5855:   if( (int)n!=nWrite ){
5856:     pTab->base.zErrMsg = sqlite3_mprintf("error in fwrite()");
5857:     return SQLITE_ERROR;
5858:   }
5859:   pTab->szCurrent += nWrite;
5860:   return SQLITE_OK;
5861: }
5862: 
5863: /*
5864: ** Read and return a 16-bit little-endian unsigned integer from buffer aBuf.
5865: */
5866: static u16 zipfileGetU16(const u8 *aBuf){
5867:   return (aBuf[1] << 8) + aBuf[0];
5868: }
5869: 
5870: /*
5871: ** Read and return a 32-bit little-endian unsigned integer from buffer aBuf.
5872: */
5873: static u32 zipfileGetU32(const u8 *aBuf){
5874:   return ((u32)(aBuf[3]) << 24)
5875:        + ((u32)(aBuf[2]) << 16)
5876:        + ((u32)(aBuf[1]) <<  8)
5877:        + ((u32)(aBuf[0]) <<  0);
5878: }
5879: 
5880: /*
5881: ** Write a 16-bit little endiate integer into buffer aBuf.
5882: */
5883: static void zipfilePutU16(u8 *aBuf, u16 val){
5884:   aBuf[0] = val & 0xFF;
5885:   aBuf[1] = (val>>8) & 0xFF;
5886: }
5887: 
5888: /*
5889: ** Write a 32-bit little endiate integer into buffer aBuf.
5890: */
5891: static void zipfilePutU32(u8 *aBuf, u32 val){
5892:   aBuf[0] = val & 0xFF;
5893:   aBuf[1] = (val>>8) & 0xFF;
5894:   aBuf[2] = (val>>16) & 0xFF;
5895:   aBuf[3] = (val>>24) & 0xFF;
5896: }
5897: 
5898: #define zipfileRead32(aBuf) ( aBuf+=4, zipfileGetU32(aBuf-4) )
5899: #define zipfileRead16(aBuf) ( aBuf+=2, zipfileGetU16(aBuf-2) )
5900: 
5901: #define zipfileWrite32(aBuf,val) { zipfilePutU32(aBuf,val); aBuf+=4; }
5902: #define zipfileWrite16(aBuf,val) { zipfilePutU16(aBuf,val); aBuf+=2; }
5903: 
5904: /*
5905: ** Magic numbers used to read CDS records.
5906: */
5907: #define ZIPFILE_CDS_NFILE_OFF        28
5908: #define ZIPFILE_CDS_SZCOMPRESSED_OFF 20
5909: 
5910: /*
5911: ** Decode the CDS record in buffer aBuf into (*pCDS). Return SQLITE_ERROR
5912: ** if the record is not well-formed, or SQLITE_OK otherwise.
5913: */
5914: static int zipfileReadCDS(u8 *aBuf, ZipfileCDS *pCDS){
5915:   u8 *aRead = aBuf;
5916:   u32 sig = zipfileRead32(aRead);
5917:   int rc = SQLITE_OK;
5918:   if( sig!=ZIPFILE_SIGNATURE_CDS ){
5919:     rc = SQLITE_ERROR;
5920:   }else{
5921:     pCDS->iVersionMadeBy = zipfileRead16(aRead);
5922:     pCDS->iVersionExtract = zipfileRead16(aRead);
5923:     pCDS->flags = zipfileRead16(aRead);
5924:     pCDS->iCompression = zipfileRead16(aRead);
5925:     pCDS->mTime = zipfileRead16(aRead);
5926:     pCDS->mDate = zipfileRead16(aRead);
5927:     pCDS->crc32 = zipfileRead32(aRead);
5928:     pCDS->szCompressed = zipfileRead32(aRead);
5929:     pCDS->szUncompressed = zipfileRead32(aRead);
5930:     assert( aRead==&aBuf[ZIPFILE_CDS_NFILE_OFF] );
5931:     pCDS->nFile = zipfileRead16(aRead);
5932:     pCDS->nExtra = zipfileRead16(aRead);
5933:     pCDS->nComment = zipfileRead16(aRead);
5934:     pCDS->iDiskStart = zipfileRead16(aRead);
5935:     pCDS->iInternalAttr = zipfileRead16(aRead);
5936:     pCDS->iExternalAttr = zipfileRead32(aRead);
5937:     pCDS->iOffset = zipfileRead32(aRead);
5938:     assert( aRead==&aBuf[ZIPFILE_CDS_FIXED_SZ] );
5939:   }
5940: 
5941:   return rc;
5942: }
5943: 
5944: /*
5945: ** Decode the LFH record in buffer aBuf into (*pLFH). Return SQLITE_ERROR
5946: ** if the record is not well-formed, or SQLITE_OK otherwise.
5947: */
5948: static int zipfileReadLFH(
5949:   u8 *aBuffer,
5950:   ZipfileLFH *pLFH
5951: ){
5952:   u8 *aRead = aBuffer;
5953:   int rc = SQLITE_OK;
5954: 
5955:   u32 sig = zipfileRead32(aRead);
5956:   if( sig!=ZIPFILE_SIGNATURE_LFH ){
5957:     rc = SQLITE_ERROR;
5958:   }else{
5959:     pLFH->iVersionExtract = zipfileRead16(aRead);
5960:     pLFH->flags = zipfileRead16(aRead);
5961:     pLFH->iCompression = zipfileRead16(aRead);
5962:     pLFH->mTime = zipfileRead16(aRead);
5963:     pLFH->mDate = zipfileRead16(aRead);
5964:     pLFH->crc32 = zipfileRead32(aRead);
5965:     pLFH->szCompressed = zipfileRead32(aRead);
5966:     pLFH->szUncompressed = zipfileRead32(aRead);
5967:     pLFH->nFile = zipfileRead16(aRead);
5968:     pLFH->nExtra = zipfileRead16(aRead);
5969:   }
5970:   return rc;
5971: }
5972: 
5973: 
5974: /*
5975: ** Buffer aExtra (size nExtra bytes) contains zip archive "extra" fields.
5976: ** Scan through this buffer to find an "extra-timestamp" field. If one
5977: ** exists, extract the 32-bit modification-timestamp from it and store
5978: ** the value in output parameter *pmTime.
5979: **
5980: ** Zero is returned if no extra-timestamp record could be found (and so
5981: ** *pmTime is left unchanged), or non-zero otherwise.
5982: **
5983: ** The general format of an extra field is:
5984: **
5985: **   Header ID    2 bytes
5986: **   Data Size    2 bytes
5987: **   Data         N bytes
5988: */
5989: static int zipfileScanExtra(u8 *aExtra, int nExtra, u32 *pmTime){
5990:   int ret = 0;
5991:   u8 *p = aExtra;
5992:   u8 *pEnd = &aExtra[nExtra];
5993: 
5994:   while( p<pEnd ){
5995:     u16 id = zipfileRead16(p);
5996:     u16 nByte = zipfileRead16(p);
5997: 
5998:     switch( id ){
5999:       case ZIPFILE_EXTRA_TIMESTAMP: {
6000:         u8 b = p[0];
6001:         if( b & 0x01 ){     /* 0x01 -> modtime is present */
6002:           *pmTime = zipfileGetU32(&p[1]);
6003:           ret = 1;
6004:         }
6005:         break;
6006:       }
6007:     }
6008: 
6009:     p += nByte;
6010:   }
6011:   return ret;
6012: }
6013: 
6014: /*
6015: ** Convert the standard MS-DOS timestamp stored in the mTime and mDate
6016: ** fields of the CDS structure passed as the only argument to a 32-bit
6017: ** UNIX seconds-since-the-epoch timestamp. Return the result.
6018: **
6019: ** "Standard" MS-DOS time format:
6020: **
6021: **   File modification time:
6022: **     Bits 00-04: seconds divided by 2
6023: **     Bits 05-10: minute
6024: **     Bits 11-15: hour
6025: **   File modification date:
6026: **     Bits 00-04: day
6027: **     Bits 05-08: month (1-12)
6028: **     Bits 09-15: years from 1980
6029: **
6030: ** https://msdn.microsoft.com/en-us/library/9kkf9tah.aspx
6031: */
6032: static u32 zipfileMtime(ZipfileCDS *pCDS){
6033:   int Y = (1980 + ((pCDS->mDate >> 9) & 0x7F));
6034:   int M = ((pCDS->mDate >> 5) & 0x0F);
6035:   int D = (pCDS->mDate & 0x1F);
6036:   int B = -13;
6037: 
6038:   int sec = (pCDS->mTime & 0x1F)*2;
6039:   int min = (pCDS->mTime >> 5) & 0x3F;
6040:   int hr = (pCDS->mTime >> 11) & 0x1F;
6041:   i64 JD;
6042: 
6043:   /* JD = INT(365.25 * (Y+4716)) + INT(30.6001 * (M+1)) + D + B - 1524.5 */
6044: 
6045:   /* Calculate the JD in seconds for noon on the day in question */
6046:   if( M<3 ){
6047:     Y = Y-1;
6048:     M = M+12;
6049:   }
6050:   JD = (i64)(24*60*60) * (
6051:       (int)(365.25 * (Y + 4716))
6052:     + (int)(30.6001 * (M + 1))
6053:     + D + B - 1524
6054:   );
6055: 
6056:   /* Correct the JD for the time within the day */
6057:   JD += (hr-12) * 3600 + min * 60 + sec;
6058: 
6059:   /* Convert JD to unix timestamp (the JD epoch is 2440587.5) */
6060:   return (u32)(JD - (i64)(24405875) * 24*60*6);
6061: }
6062: 
6063: /*
6064: ** The opposite of zipfileMtime(). This function populates the mTime and
6065: ** mDate fields of the CDS structure passed as the first argument according
6066: ** to the UNIX timestamp value passed as the second.
6067: */
6068: static void zipfileMtimeToDos(ZipfileCDS *pCds, u32 mUnixTime){
6069:   /* Convert unix timestamp to JD (2440588 is noon on 1/1/1970) */
6070:   i64 JD = (i64)2440588 + mUnixTime / (24*60*60);
6071: 
6072:   int A, B, C, D, E;
6073:   int yr, mon, day;
6074:   int hr, min, sec;
6075: 
6076:   A = (int)((JD - 1867216.25)/36524.25);
6077:   A = (int)(JD + 1 + A - (A/4));
6078:   B = A + 1524;
6079:   C = (int)((B - 122.1)/365.25);
6080:   D = (36525*(C&32767))/100;
6081:   E = (int)((B-D)/30.6001);
6082: 
6083:   day = B - D - (int)(30.6001*E);
6084:   mon = (E<14 ? E-1 : E-13);
6085:   yr = mon>2 ? C-4716 : C-4715;
6086: 
6087:   hr = (mUnixTime % (24*60*60)) / (60*60);
6088:   min = (mUnixTime % (60*60)) / 60;
6089:   sec = (mUnixTime % 60);
6090: 
6091:   if( yr>=1980 ){
6092:     pCds->mDate = (u16)(day + (mon << 5) + ((yr-1980) << 9));
6093:     pCds->mTime = (u16)(sec/2 + (min<<5) + (hr<<11));
6094:   }else{
6095:     pCds->mDate = pCds->mTime = 0;
6096:   }
6097: 
6098:   assert( mUnixTime<315507600
6099:        || mUnixTime==zipfileMtime(pCds)
6100:        || ((mUnixTime % 2) && mUnixTime-1==zipfileMtime(pCds))
6101:        /* || (mUnixTime % 2) */
6102:   );
6103: }
6104: 
6105: /*
6106: ** If aBlob is not NULL, then it is a pointer to a buffer (nBlob bytes in
6107: ** size) containing an entire zip archive image. Or, if aBlob is NULL,
6108: ** then pFile is a file-handle open on a zip file. In either case, this
6109: ** function creates a ZipfileEntry object based on the zip archive entry
6110: ** for which the CDS record is at offset iOff.
6111: **
6112: ** If successful, SQLITE_OK is returned and (*ppEntry) set to point to
6113: ** the new object. Otherwise, an SQLite error code is returned and the
6114: ** final value of (*ppEntry) undefined.
6115: */
6116: static int zipfileGetEntry(
6117:   ZipfileTab *pTab,               /* Store any error message here */
6118:   const u8 *aBlob,                /* Pointer to in-memory file image */
6119:   int nBlob,                      /* Size of aBlob[] in bytes */
6120:   FILE *pFile,                    /* If aBlob==0, read from this file */
6121:   i64 iOff,                       /* Offset of CDS record */
6122:   ZipfileEntry **ppEntry          /* OUT: Pointer to new object */
6123: ){
6124:   u8 *aRead;
6125:   char **pzErr = &pTab->base.zErrMsg;
6126:   int rc = SQLITE_OK;
6127: 
6128:   if( aBlob==0 ){
6129:     aRead = pTab->aBuffer;
6130:     rc = zipfileReadData(pFile, aRead, ZIPFILE_CDS_FIXED_SZ, iOff, pzErr);
6131:   }else{
6132:     aRead = (u8*)&aBlob[iOff];
6133:   }
6134: 
6135:   if( rc==SQLITE_OK ){
6136:     sqlite3_int64 nAlloc;
6137:     ZipfileEntry *pNew;
6138: 
6139:     int nFile = zipfileGetU16(&aRead[ZIPFILE_CDS_NFILE_OFF]);
6140:     int nExtra = zipfileGetU16(&aRead[ZIPFILE_CDS_NFILE_OFF+2]);
6141:     nExtra += zipfileGetU16(&aRead[ZIPFILE_CDS_NFILE_OFF+4]);
6142: 
6143:     nAlloc = sizeof(ZipfileEntry) + nExtra;
6144:     if( aBlob ){
6145:       nAlloc += zipfileGetU32(&aRead[ZIPFILE_CDS_SZCOMPRESSED_OFF]);
6146:     }
6147: 
6148:     pNew = (ZipfileEntry*)sqlite3_malloc64(nAlloc);
6149:     if( pNew==0 ){
6150:       rc = SQLITE_NOMEM;
6151:     }else{
6152:       memset(pNew, 0, sizeof(ZipfileEntry));
6153:       rc = zipfileReadCDS(aRead, &pNew->cds);
6154:       if( rc!=SQLITE_OK ){
6155:         *pzErr = sqlite3_mprintf("failed to read CDS at offset %lld", iOff);
6156:       }else if( aBlob==0 ){
6157:         rc = zipfileReadData(
6158:             pFile, aRead, nExtra+nFile, iOff+ZIPFILE_CDS_FIXED_SZ, pzErr
6159:         );
6160:       }else{
6161:         aRead = (u8*)&aBlob[iOff + ZIPFILE_CDS_FIXED_SZ];
6162:       }
6163:     }
6164: 
6165:     if( rc==SQLITE_OK ){
6166:       u32 *pt = &pNew->mUnixTime;
6167:       pNew->cds.zFile = sqlite3_mprintf("%.*s", nFile, aRead);
6168:       pNew->aExtra = (u8*)&pNew[1];
6169:       memcpy(pNew->aExtra, &aRead[nFile], nExtra);
6170:       if( pNew->cds.zFile==0 ){
6171:         rc = SQLITE_NOMEM;
6172:       }else if( 0==zipfileScanExtra(&aRead[nFile], pNew->cds.nExtra, pt) ){
6173:         pNew->mUnixTime = zipfileMtime(&pNew->cds);
6174:       }
6175:     }
6176: 
6177:     if( rc==SQLITE_OK ){
6178:       static const int szFix = ZIPFILE_LFH_FIXED_SZ;
6179:       ZipfileLFH lfh;
6180:       if( pFile ){
6181:         rc = zipfileReadData(pFile, aRead, szFix, pNew->cds.iOffset, pzErr);
6182:       }else{
6183:         aRead = (u8*)&aBlob[pNew->cds.iOffset];
6184:       }
6185: 
6186:       rc = zipfileReadLFH(aRead, &lfh);
6187:       if( rc==SQLITE_OK ){
6188:         pNew->iDataOff =  pNew->cds.iOffset + ZIPFILE_LFH_FIXED_SZ;
6189:         pNew->iDataOff += lfh.nFile + lfh.nExtra;
6190:         if( aBlob && pNew->cds.szCompressed ){
6191:           pNew->aData = &pNew->aExtra[nExtra];
6192:           memcpy(pNew->aData, &aBlob[pNew->iDataOff], pNew->cds.szCompressed);
6193:         }
6194:       }else{
6195:         *pzErr = sqlite3_mprintf("failed to read LFH at offset %d",
6196:             (int)pNew->cds.iOffset
6197:         );
6198:       }
6199:     }
6200: 
6201:     if( rc!=SQLITE_OK ){
6202:       zipfileEntryFree(pNew);
6203:     }else{
6204:       *ppEntry = pNew;
6205:     }
6206:   }
6207: 
6208:   return rc;
6209: }
6210: 
6211: /*
6212: ** Advance an ZipfileCsr to its next row of output.
6213: */
6214: static int zipfileNext(sqlite3_vtab_cursor *cur){
6215:   ZipfileCsr *pCsr = (ZipfileCsr*)cur;
6216:   int rc = SQLITE_OK;
6217: 
6218:   if( pCsr->pFile ){
6219:     i64 iEof = pCsr->eocd.iOffset + pCsr->eocd.nSize;
6220:     zipfileEntryFree(pCsr->pCurrent);
6221:     pCsr->pCurrent = 0;
6222:     if( pCsr->iNextOff>=iEof ){
6223:       pCsr->bEof = 1;
6224:     }else{
6225:       ZipfileEntry *p = 0;
6226:       ZipfileTab *pTab = (ZipfileTab*)(cur->pVtab);
6227:       rc = zipfileGetEntry(pTab, 0, 0, pCsr->pFile, pCsr->iNextOff, &p);
6228:       if( rc==SQLITE_OK ){
6229:         pCsr->iNextOff += ZIPFILE_CDS_FIXED_SZ;
6230:         pCsr->iNextOff += (int)p->cds.nExtra + p->cds.nFile + p->cds.nComment;
6231:       }
6232:       pCsr->pCurrent = p;
6233:     }
6234:   }else{
6235:     if( !pCsr->bNoop ){
6236:       pCsr->pCurrent = pCsr->pCurrent->pNext;
6237:     }
6238:     if( pCsr->pCurrent==0 ){
6239:       pCsr->bEof = 1;
6240:     }
6241:   }
6242: 
6243:   pCsr->bNoop = 0;
6244:   return rc;
6245: }
6246: 
6247: static void zipfileFree(void *p) {
6248:   sqlite3_free(p);
6249: }
6250: 
6251: /*
6252: ** Buffer aIn (size nIn bytes) contains compressed data. Uncompressed, the
6253: ** size is nOut bytes. This function uncompresses the data and sets the
6254: ** return value in context pCtx to the result (a blob).
6255: **
6256: ** If an error occurs, an error code is left in pCtx instead.
6257: */
6258: static void zipfileInflate(
6259:   sqlite3_context *pCtx,          /* Store result here */
6260:   const u8 *aIn,                  /* Compressed data */
6261:   int nIn,                        /* Size of buffer aIn[] in bytes */
6262:   int nOut                        /* Expected output size */
6263: ){
6264:   u8 *aRes = sqlite3_malloc(nOut);
6265:   if( aRes==0 ){
6266:     sqlite3_result_error_nomem(pCtx);
6267:   }else{
6268:     int err;
6269:     z_stream str;
6270:     memset(&str, 0, sizeof(str));
6271: 
6272:     str.next_in = (Byte*)aIn;
6273:     str.avail_in = nIn;
6274:     str.next_out = (Byte*)aRes;
6275:     str.avail_out = nOut;
6276: 
6277:     err = inflateInit2(&str, -15);
6278:     if( err!=Z_OK ){
6279:       zipfileCtxErrorMsg(pCtx, "inflateInit2() failed (%d)", err);
6280:     }else{
6281:       err = inflate(&str, Z_NO_FLUSH);
6282:       if( err!=Z_STREAM_END ){
6283:         zipfileCtxErrorMsg(pCtx, "inflate() failed (%d)", err);
6284:       }else{
6285:         sqlite3_result_blob(pCtx, aRes, nOut, zipfileFree);
6286:         aRes = 0;
6287:       }
6288:     }
6289:     sqlite3_free(aRes);
6290:     inflateEnd(&str);
6291:   }
6292: }
6293: 
6294: /*
6295: ** Buffer aIn (size nIn bytes) contains uncompressed data. This function
6296: ** compresses it and sets (*ppOut) to point to a buffer containing the
6297: ** compressed data. The caller is responsible for eventually calling
6298: ** sqlite3_free() to release buffer (*ppOut). Before returning, (*pnOut)
6299: ** is set to the size of buffer (*ppOut) in bytes.
6300: **
6301: ** If no error occurs, SQLITE_OK is returned. Otherwise, an SQLite error
6302: ** code is returned and an error message left in virtual-table handle
6303: ** pTab. The values of (*ppOut) and (*pnOut) are left unchanged in this
6304: ** case.
6305: */
6306: static int zipfileDeflate(
6307:   const u8 *aIn, int nIn,         /* Input */
6308:   u8 **ppOut, int *pnOut,         /* Output */
6309:   char **pzErr                    /* OUT: Error message */
6310: ){
6311:   int rc = SQLITE_OK;
6312:   sqlite3_int64 nAlloc;
6313:   z_stream str;
6314:   u8 *aOut;
6315: 
6316:   memset(&str, 0, sizeof(str));
6317:   str.next_in = (Bytef*)aIn;
6318:   str.avail_in = nIn;
6319:   deflateInit2(&str, 9, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY);
6320: 
6321:   nAlloc = deflateBound(&str, nIn);
6322:   aOut = (u8*)sqlite3_malloc64(nAlloc);
6323:   if( aOut==0 ){
6324:     rc = SQLITE_NOMEM;
6325:   }else{
6326:     int res;
6327:     str.next_out = aOut;
6328:     str.avail_out = nAlloc;
6329:     res = deflate(&str, Z_FINISH);
6330:     if( res==Z_STREAM_END ){
6331:       *ppOut = aOut;
6332:       *pnOut = (int)str.total_out;
6333:     }else{
6334:       sqlite3_free(aOut);
6335:       *pzErr = sqlite3_mprintf("zipfile: deflate() error");
6336:       rc = SQLITE_ERROR;
6337:     }
6338:     deflateEnd(&str);
6339:   }
6340: 
6341:   return rc;
6342: }
6343: 
6344: 
6345: /*
6346: ** Return values of columns for the row at which the series_cursor
6347: ** is currently pointing.
6348: */
6349: static int zipfileColumn(
6350:   sqlite3_vtab_cursor *cur,   /* The cursor */
6351:   sqlite3_context *ctx,       /* First argument to sqlite3_result_...() */
6352:   int i                       /* Which column to return */
6353: ){
6354:   ZipfileCsr *pCsr = (ZipfileCsr*)cur;
6355:   ZipfileCDS *pCDS = &pCsr->pCurrent->cds;
6356:   int rc = SQLITE_OK;
6357:   switch( i ){
6358:     case 0:   /* name */
6359:       sqlite3_result_text(ctx, pCDS->zFile, -1, SQLITE_TRANSIENT);
6360:       break;
6361:     case 1:   /* mode */
6362:       /* TODO: Whether or not the following is correct surely depends on
6363:       ** the platform on which the archive was created.  */
6364:       sqlite3_result_int(ctx, pCDS->iExternalAttr >> 16);
6365:       break;
6366:     case 2: { /* mtime */
6367:       sqlite3_result_int64(ctx, pCsr->pCurrent->mUnixTime);
6368:       break;
6369:     }
6370:     case 3: { /* sz */
6371:       if( sqlite3_vtab_nochange(ctx)==0 ){
6372:         sqlite3_result_int64(ctx, pCDS->szUncompressed);
6373:       }
6374:       break;
6375:     }
6376:     case 4:   /* rawdata */
6377:       if( sqlite3_vtab_nochange(ctx) ) break;
6378:     case 5: { /* data */
6379:       if( i==4 || pCDS->iCompression==0 || pCDS->iCompression==8 ){
6380:         int sz = pCDS->szCompressed;
6381:         int szFinal = pCDS->szUncompressed;
6382:         if( szFinal>0 ){
6383:           u8 *aBuf;
6384:           u8 *aFree = 0;
6385:           if( pCsr->pCurrent->aData ){
6386:             aBuf = pCsr->pCurrent->aData;
6387:           }else{
6388:             aBuf = aFree = sqlite3_malloc64(sz);
6389:             if( aBuf==0 ){
6390:               rc = SQLITE_NOMEM;
6391:             }else{
6392:               FILE *pFile = pCsr->pFile;
6393:               if( pFile==0 ){
6394:                 pFile = ((ZipfileTab*)(pCsr->base.pVtab))->pWriteFd;
6395:               }
6396:               rc = zipfileReadData(pFile, aBuf, sz, pCsr->pCurrent->iDataOff,
6397:                   &pCsr->base.pVtab->zErrMsg
6398:               );
6399:             }
6400:           }
6401:           if( rc==SQLITE_OK ){
6402:             if( i==5 && pCDS->iCompression ){
6403:               zipfileInflate(ctx, aBuf, sz, szFinal);
6404:             }else{
6405:               sqlite3_result_blob(ctx, aBuf, sz, SQLITE_TRANSIENT);
6406:             }
6407:           }
6408:           sqlite3_free(aFree);
6409:         }else{
6410:           /* Figure out if this is a directory or a zero-sized file. Consider
6411:           ** it to be a directory either if the mode suggests so, or if
6412:           ** the final character in the name is '/'.  */
6413:           u32 mode = pCDS->iExternalAttr >> 16;
6414:           if( !(mode & S_IFDIR) && pCDS->zFile[pCDS->nFile-1]!='/' ){
6415:             sqlite3_result_blob(ctx, "", 0, SQLITE_STATIC);
6416:           }
6417:         }
6418:       }
6419:       break;
6420:     }
6421:     case 6:   /* method */
6422:       sqlite3_result_int(ctx, pCDS->iCompression);
6423:       break;
6424:     default:  /* z */
6425:       assert( i==7 );
6426:       sqlite3_result_int64(ctx, pCsr->iId);
6427:       break;
6428:   }
6429: 
6430:   return rc;
6431: }
6432: 
6433: /*
6434: ** Return TRUE if the cursor is at EOF.
6435: */
6436: static int zipfileEof(sqlite3_vtab_cursor *cur){
6437:   ZipfileCsr *pCsr = (ZipfileCsr*)cur;
6438:   return pCsr->bEof;
6439: }
6440: 
6441: /*
6442: ** If aBlob is not NULL, then it points to a buffer nBlob bytes in size
6443: ** containing an entire zip archive image. Or, if aBlob is NULL, then pFile
6444: ** is guaranteed to be a file-handle open on a zip file.
6445: **
6446: ** This function attempts to locate the EOCD record within the zip archive
6447: ** and populate *pEOCD with the results of decoding it. SQLITE_OK is
6448: ** returned if successful. Otherwise, an SQLite error code is returned and
6449: ** an English language error message may be left in virtual-table pTab.
6450: */
6451: static int zipfileReadEOCD(
6452:   ZipfileTab *pTab,               /* Return errors here */
6453:   const u8 *aBlob,                /* Pointer to in-memory file image */
6454:   int nBlob,                      /* Size of aBlob[] in bytes */
6455:   FILE *pFile,                    /* Read from this file if aBlob==0 */
6456:   ZipfileEOCD *pEOCD              /* Object to populate */
6457: ){
6458:   u8 *aRead = pTab->aBuffer;      /* Temporary buffer */
6459:   int nRead;                      /* Bytes to read from file */
6460:   int rc = SQLITE_OK;
6461: 
6462:   if( aBlob==0 ){
6463:     i64 iOff;                     /* Offset to read from */
6464:     i64 szFile;                   /* Total size of file in bytes */
6465:     fseek(pFile, 0, SEEK_END);
6466:     szFile = (i64)ftell(pFile);
6467:     if( szFile==0 ){
6468:       memset(pEOCD, 0, sizeof(ZipfileEOCD));
6469:       return SQLITE_OK;
6470:     }
6471:     nRead = (int)(MIN(szFile, ZIPFILE_BUFFER_SIZE));
6472:     iOff = szFile - nRead;
6473:     rc = zipfileReadData(pFile, aRead, nRead, iOff, &pTab->base.zErrMsg);
6474:   }else{
6475:     nRead = (int)(MIN(nBlob, ZIPFILE_BUFFER_SIZE));
6476:     aRead = (u8*)&aBlob[nBlob-nRead];
6477:   }
6478: 
6479:   if( rc==SQLITE_OK ){
6480:     int i;
6481: 
6482:     /* Scan backwards looking for the signature bytes */
6483:     for(i=nRead-20; i>=0; i--){
6484:       if( aRead[i]==0x50 && aRead[i+1]==0x4b
6485:        && aRead[i+2]==0x05 && aRead[i+3]==0x06
6486:       ){
6487:         break;
6488:       }
6489:     }
6490:     if( i<0 ){
6491:       pTab->base.zErrMsg = sqlite3_mprintf(
6492:           "cannot find end of central directory record"
6493:       );
6494:       return SQLITE_ERROR;
6495:     }
6496: 
6497:     aRead += i+4;
6498:     pEOCD->iDisk = zipfileRead16(aRead);
6499:     pEOCD->iFirstDisk = zipfileRead16(aRead);
6500:     pEOCD->nEntry = zipfileRead16(aRead);
6501:     pEOCD->nEntryTotal = zipfileRead16(aRead);
6502:     pEOCD->nSize = zipfileRead32(aRead);
6503:     pEOCD->iOffset = zipfileRead32(aRead);
6504:   }
6505: 
6506:   return rc;
6507: }
6508: 
6509: /*
6510: ** Add object pNew to the linked list that begins at ZipfileTab.pFirstEntry
6511: ** and ends with pLastEntry. If argument pBefore is NULL, then pNew is added
6512: ** to the end of the list. Otherwise, it is added to the list immediately
6513: ** before pBefore (which is guaranteed to be a part of said list).
6514: */
6515: static void zipfileAddEntry(
6516:   ZipfileTab *pTab,
6517:   ZipfileEntry *pBefore,
6518:   ZipfileEntry *pNew
6519: ){
6520:   assert( (pTab->pFirstEntry==0)==(pTab->pLastEntry==0) );
6521:   assert( pNew->pNext==0 );
6522:   if( pBefore==0 ){
6523:     if( pTab->pFirstEntry==0 ){
6524:       pTab->pFirstEntry = pTab->pLastEntry = pNew;
6525:     }else{
6526:       assert( pTab->pLastEntry->pNext==0 );
6527:       pTab->pLastEntry->pNext = pNew;
6528:       pTab->pLastEntry = pNew;
6529:     }
6530:   }else{
6531:     ZipfileEntry **pp;
6532:     for(pp=&pTab->pFirstEntry; *pp!=pBefore; pp=&((*pp)->pNext));
6533:     pNew->pNext = pBefore;
6534:     *pp = pNew;
6535:   }
6536: }
6537: 
6538: static int zipfileLoadDirectory(ZipfileTab *pTab, const u8 *aBlob, int nBlob){
6539:   ZipfileEOCD eocd;
6540:   int rc;
6541:   int i;
6542:   i64 iOff;
6543: 
6544:   rc = zipfileReadEOCD(pTab, aBlob, nBlob, pTab->pWriteFd, &eocd);
6545:   iOff = eocd.iOffset;
6546:   for(i=0; rc==SQLITE_OK && i<eocd.nEntry; i++){
6547:     ZipfileEntry *pNew = 0;
6548:     rc = zipfileGetEntry(pTab, aBlob, nBlob, pTab->pWriteFd, iOff, &pNew);
6549: 
6550:     if( rc==SQLITE_OK ){
6551:       zipfileAddEntry(pTab, 0, pNew);
6552:       iOff += ZIPFILE_CDS_FIXED_SZ;
6553:       iOff += (int)pNew->cds.nExtra + pNew->cds.nFile + pNew->cds.nComment;
6554:     }
6555:   }
6556:   return rc;
6557: }
6558: 
6559: /*
6560: ** xFilter callback.
6561: */
6562: static int zipfileFilter(
6563:   sqlite3_vtab_cursor *cur,
6564:   int idxNum, const char *idxStr,
6565:   int argc, sqlite3_value **argv
6566: ){
6567:   ZipfileTab *pTab = (ZipfileTab*)cur->pVtab;
6568:   ZipfileCsr *pCsr = (ZipfileCsr*)cur;
6569:   const char *zFile = 0;          /* Zip file to scan */
6570:   int rc = SQLITE_OK;             /* Return Code */
6571:   int bInMemory = 0;              /* True for an in-memory zipfile */
6572: 
6573:   zipfileResetCursor(pCsr);
6574: 
6575:   if( pTab->zFile ){
6576:     zFile = pTab->zFile;
6577:   }else if( idxNum==0 ){
6578:     zipfileCursorErr(pCsr, "zipfile() function requires an argument");
6579:     return SQLITE_ERROR;
6580:   }else if( sqlite3_value_type(argv[0])==SQLITE_BLOB ){
6581:     const u8 *aBlob = (const u8*)sqlite3_value_blob(argv[0]);
6582:     int nBlob = sqlite3_value_bytes(argv[0]);
6583:     assert( pTab->pFirstEntry==0 );
6584:     rc = zipfileLoadDirectory(pTab, aBlob, nBlob);
6585:     pCsr->pFreeEntry = pTab->pFirstEntry;
6586:     pTab->pFirstEntry = pTab->pLastEntry = 0;
6587:     if( rc!=SQLITE_OK ) return rc;
6588:     bInMemory = 1;
6589:   }else{
6590:     zFile = (const char*)sqlite3_value_text(argv[0]);
6591:   }
6592: 
6593:   if( 0==pTab->pWriteFd && 0==bInMemory ){
6594:     pCsr->pFile = fopen(zFile, "rb");
6595:     if( pCsr->pFile==0 ){
6596:       zipfileCursorErr(pCsr, "cannot open file: %s", zFile);
6597:       rc = SQLITE_ERROR;
6598:     }else{
6599:       rc = zipfileReadEOCD(pTab, 0, 0, pCsr->pFile, &pCsr->eocd);
6600:       if( rc==SQLITE_OK ){
6601:         if( pCsr->eocd.nEntry==0 ){
6602:           pCsr->bEof = 1;
6603:         }else{
6604:           pCsr->iNextOff = pCsr->eocd.iOffset;
6605:           rc = zipfileNext(cur);
6606:         }
6607:       }
6608:     }
6609:   }else{
6610:     pCsr->bNoop = 1;
6611:     pCsr->pCurrent = pCsr->pFreeEntry ? pCsr->pFreeEntry : pTab->pFirstEntry;
6612:     rc = zipfileNext(cur);
6613:   }
6614: 
6615:   return rc;
6616: }
6617: 
6618: /*
6619: ** xBestIndex callback.
6620: */
6621: static int zipfileBestIndex(
6622:   sqlite3_vtab *tab,
6623:   sqlite3_index_info *pIdxInfo
6624: ){
6625:   int i;
6626:   int idx = -1;
6627:   int unusable = 0;
6628: 
6629:   for(i=0; i<pIdxInfo->nConstraint; i++){
6630:     const struct sqlite3_index_constraint *pCons = &pIdxInfo->aConstraint[i];
6631:     if( pCons->iColumn!=ZIPFILE_F_COLUMN_IDX ) continue;
6632:     if( pCons->usable==0 ){
6633:       unusable = 1;
6634:     }else if( pCons->op==SQLITE_INDEX_CONSTRAINT_EQ ){
6635:       idx = i;
6636:     }
6637:   }
6638:   pIdxInfo->estimatedCost = 1000.0;
6639:   if( idx>=0 ){
6640:     pIdxInfo->aConstraintUsage[idx].argvIndex = 1;
6641:     pIdxInfo->aConstraintUsage[idx].omit = 1;
6642:     pIdxInfo->idxNum = 1;
6643:   }else if( unusable ){
6644:     return SQLITE_CONSTRAINT;
6645:   }
6646:   return SQLITE_OK;
6647: }
6648: 
6649: static ZipfileEntry *zipfileNewEntry(const char *zPath){
6650:   ZipfileEntry *pNew;
6651:   pNew = sqlite3_malloc(sizeof(ZipfileEntry));
6652:   if( pNew ){
6653:     memset(pNew, 0, sizeof(ZipfileEntry));
6654:     pNew->cds.zFile = sqlite3_mprintf("%s", zPath);
6655:     if( pNew->cds.zFile==0 ){
6656:       sqlite3_free(pNew);
6657:       pNew = 0;
6658:     }
6659:   }
6660:   return pNew;
6661: }
6662: 
6663: static int zipfileSerializeLFH(ZipfileEntry *pEntry, u8 *aBuf){
6664:   ZipfileCDS *pCds = &pEntry->cds;
6665:   u8 *a = aBuf;
6666: 
6667:   pCds->nExtra = 9;
6668: 
6669:   /* Write the LFH itself */
6670:   zipfileWrite32(a, ZIPFILE_SIGNATURE_LFH);
6671:   zipfileWrite16(a, pCds->iVersionExtract);
6672:   zipfileWrite16(a, pCds->flags);
6673:   zipfileWrite16(a, pCds->iCompression);
6674:   zipfileWrite16(a, pCds->mTime);
6675:   zipfileWrite16(a, pCds->mDate);
6676:   zipfileWrite32(a, pCds->crc32);
6677:   zipfileWrite32(a, pCds->szCompressed);
6678:   zipfileWrite32(a, pCds->szUncompressed);
6679:   zipfileWrite16(a, (u16)pCds->nFile);
6680:   zipfileWrite16(a, pCds->nExtra);
6681:   assert( a==&aBuf[ZIPFILE_LFH_FIXED_SZ] );
6682: 
6683:   /* Add the file name */
6684:   memcpy(a, pCds->zFile, (int)pCds->nFile);
6685:   a += (int)pCds->nFile;
6686: 
6687:   /* The "extra" data */
6688:   zipfileWrite16(a, ZIPFILE_EXTRA_TIMESTAMP);
6689:   zipfileWrite16(a, 5);
6690:   *a++ = 0x01;
6691:   zipfileWrite32(a, pEntry->mUnixTime);
6692: 
6693:   return a-aBuf;
6694: }
6695: 
6696: static int zipfileAppendEntry(
6697:   ZipfileTab *pTab,
6698:   ZipfileEntry *pEntry,
6699:   const u8 *pData,
6700:   int nData
6701: ){
6702:   u8 *aBuf = pTab->aBuffer;
6703:   int nBuf;
6704:   int rc;
6705: 
6706:   nBuf = zipfileSerializeLFH(pEntry, aBuf);
6707:   rc = zipfileAppendData(pTab, aBuf, nBuf);
6708:   if( rc==SQLITE_OK ){
6709:     pEntry->iDataOff = pTab->szCurrent;
6710:     rc = zipfileAppendData(pTab, pData, nData);
6711:   }
6712: 
6713:   return rc;
6714: }
6715: 
6716: static int zipfileGetMode(
6717:   sqlite3_value *pVal,
6718:   int bIsDir,                     /* If true, default to directory */
6719:   u32 *pMode,                     /* OUT: Mode value */
6720:   char **pzErr                    /* OUT: Error message */
6721: ){
6722:   const char *z = (const char*)sqlite3_value_text(pVal);
6723:   u32 mode = 0;
6724:   if( z==0 ){
6725:     mode = (bIsDir ? (S_IFDIR + 0755) : (S_IFREG + 0644));
6726:   }else if( z[0]>='0' && z[0]<='9' ){
6727:     mode = (unsigned int)sqlite3_value_int(pVal);
6728:   }else{
6729:     const char zTemplate[11] = "-rwxrwxrwx";
6730:     int i;
6731:     if( strlen(z)!=10 ) goto parse_error;
6732:     switch( z[0] ){
6733:       case '-': mode |= S_IFREG; break;
6734:       case 'd': mode |= S_IFDIR; break;
6735:       case 'l': mode |= S_IFLNK; break;
6736:       default: goto parse_error;
6737:     }
6738:     for(i=1; i<10; i++){
6739:       if( z[i]==zTemplate[i] ) mode |= 1 << (9-i);
6740:       else if( z[i]!='-' ) goto parse_error;
6741:     }
6742:   }
6743:   if( ((mode & S_IFDIR)==0)==bIsDir ){
6744:     /* The "mode" attribute is a directory, but data has been specified.
6745:     ** Or vice-versa - no data but "mode" is a file or symlink.  */
6746:     *pzErr = sqlite3_mprintf("zipfile: mode does not match data");
6747:     return SQLITE_CONSTRAINT;
6748:   }
6749:   *pMode = mode;
6750:   return SQLITE_OK;
6751: 
6752:  parse_error:
6753:   *pzErr = sqlite3_mprintf("zipfile: parse error in mode: %s", z);
6754:   return SQLITE_ERROR;
6755: }
6756: 
6757: /*
6758: ** Both (const char*) arguments point to nul-terminated strings. Argument
6759: ** nB is the value of strlen(zB). This function returns 0 if the strings are
6760: ** identical, ignoring any trailing '/' character in either path.  */
6761: static int zipfileComparePath(const char *zA, const char *zB, int nB){
6762:   int nA = (int)strlen(zA);
6763:   if( nA>0 && zA[nA-1]=='/' ) nA--;
6764:   if( nB>0 && zB[nB-1]=='/' ) nB--;
6765:   if( nA==nB && memcmp(zA, zB, nA)==0 ) return 0;
6766:   return 1;
6767: }
6768: 
6769: static int zipfileBegin(sqlite3_vtab *pVtab){
6770:   ZipfileTab *pTab = (ZipfileTab*)pVtab;
6771:   int rc = SQLITE_OK;
6772: 
6773:   assert( pTab->pWriteFd==0 );
6774:   if( pTab->zFile==0 || pTab->zFile[0]==0 ){
6775:     pTab->base.zErrMsg = sqlite3_mprintf("zipfile: missing filename");
6776:     return SQLITE_ERROR;
6777:   }
6778: 
6779:   /* Open a write fd on the file. Also load the entire central directory
6780:   ** structure into memory. During the transaction any new file data is
6781:   ** appended to the archive file, but the central directory is accumulated
6782:   ** in main-memory until the transaction is committed.  */
6783:   pTab->pWriteFd = fopen(pTab->zFile, "ab+");
6784:   if( pTab->pWriteFd==0 ){
6785:     pTab->base.zErrMsg = sqlite3_mprintf(
6786:         "zipfile: failed to open file %s for writing", pTab->zFile
6787:         );
6788:     rc = SQLITE_ERROR;
6789:   }else{
6790:     fseek(pTab->pWriteFd, 0, SEEK_END);
6791:     pTab->szCurrent = pTab->szOrig = (i64)ftell(pTab->pWriteFd);
6792:     rc = zipfileLoadDirectory(pTab, 0, 0);
6793:   }
6794: 
6795:   if( rc!=SQLITE_OK ){
6796:     zipfileCleanupTransaction(pTab);
6797:   }
6798: 
6799:   return rc;
6800: }
6801: 
6802: /*
6803: ** Return the current time as a 32-bit timestamp in UNIX epoch format (like
6804: ** time(2)).
6805: */
6806: static u32 zipfileTime(void){
6807:   sqlite3_vfs *pVfs = sqlite3_vfs_find(0);
6808:   u32 ret;
6809:   if( pVfs->iVersion>=2 && pVfs->xCurrentTimeInt64 ){
6810:     i64 ms;
6811:     pVfs->xCurrentTimeInt64(pVfs, &ms);
6812:     ret = (u32)((ms/1000) - ((i64)24405875 * 8640));
6813:   }else{
6814:     double day;
6815:     pVfs->xCurrentTime(pVfs, &day);
6816:     ret = (u32)((day - 2440587.5) * 86400);
6817:   }
6818:   return ret;
6819: }
6820: 
6821: /*
6822: ** Return a 32-bit timestamp in UNIX epoch format.
6823: **
6824: ** If the value passed as the only argument is either NULL or an SQL NULL,
6825: ** return the current time. Otherwise, return the value stored in (*pVal)
6826: ** cast to a 32-bit unsigned integer.
6827: */
6828: static u32 zipfileGetTime(sqlite3_value *pVal){
6829:   if( pVal==0 || sqlite3_value_type(pVal)==SQLITE_NULL ){
6830:     return zipfileTime();
6831:   }
6832:   return (u32)sqlite3_value_int64(pVal);
6833: }
6834: 
6835: /*
6836: ** Unless it is NULL, entry pOld is currently part of the pTab->pFirstEntry
6837: ** linked list.  Remove it from the list and free the object.
6838: */
6839: static void zipfileRemoveEntryFromList(ZipfileTab *pTab, ZipfileEntry *pOld){
6840:   if( pOld ){
6841:     ZipfileEntry **pp;
6842:     for(pp=&pTab->pFirstEntry; (*pp)!=pOld; pp=&((*pp)->pNext));
6843:     *pp = (*pp)->pNext;
6844:     zipfileEntryFree(pOld);
6845:   }
6846: }
6847: 
6848: /*
6849: ** xUpdate method.
6850: */
6851: static int zipfileUpdate(
6852:   sqlite3_vtab *pVtab,
6853:   int nVal,
6854:   sqlite3_value **apVal,
6855:   sqlite_int64 *pRowid
6856: ){
6857:   ZipfileTab *pTab = (ZipfileTab*)pVtab;
6858:   int rc = SQLITE_OK;             /* Return Code */
6859:   ZipfileEntry *pNew = 0;         /* New in-memory CDS entry */
6860: 
6861:   u32 mode = 0;                   /* Mode for new entry */
6862:   u32 mTime = 0;                  /* Modification time for new entry */
6863:   i64 sz = 0;                     /* Uncompressed size */
6864:   const char *zPath = 0;          /* Path for new entry */
6865:   int nPath = 0;                  /* strlen(zPath) */
6866:   const u8 *pData = 0;            /* Pointer to buffer containing content */
6867:   int nData = 0;                  /* Size of pData buffer in bytes */
6868:   int iMethod = 0;                /* Compression method for new entry */
6869:   u8 *pFree = 0;                  /* Free this */
6870:   char *zFree = 0;                /* Also free this */
6871:   ZipfileEntry *pOld = 0;
6872:   ZipfileEntry *pOld2 = 0;
6873:   int bUpdate = 0;                /* True for an update that modifies "name" */
6874:   int bIsDir = 0;
6875:   u32 iCrc32 = 0;
6876: 
6877:   if( pTab->pWriteFd==0 ){
6878:     rc = zipfileBegin(pVtab);
6879:     if( rc!=SQLITE_OK ) return rc;
6880:   }
6881: 
6882:   /* If this is a DELETE or UPDATE, find the archive entry to delete. */
6883:   if( sqlite3_value_type(apVal[0])!=SQLITE_NULL ){
6884:     const char *zDelete = (const char*)sqlite3_value_text(apVal[0]);
6885:     int nDelete = (int)strlen(zDelete);
6886:     if( nVal>1 ){
6887:       const char *zUpdate = (const char*)sqlite3_value_text(apVal[1]);
6888:       if( zUpdate && zipfileComparePath(zUpdate, zDelete, nDelete)!=0 ){
6889:         bUpdate = 1;
6890:       }
6891:     }
6892:     for(pOld=pTab->pFirstEntry; 1; pOld=pOld->pNext){
6893:       if( zipfileComparePath(pOld->cds.zFile, zDelete, nDelete)==0 ){
6894:         break;
6895:       }
6896:       assert( pOld->pNext );
6897:     }
6898:   }
6899: 
6900:   if( nVal>1 ){
6901:     /* Check that "sz" and "rawdata" are both NULL: */
6902:     if( sqlite3_value_type(apVal[5])!=SQLITE_NULL ){
6903:       zipfileTableErr(pTab, "sz must be NULL");
6904:       rc = SQLITE_CONSTRAINT;
6905:     }
6906:     if( sqlite3_value_type(apVal[6])!=SQLITE_NULL ){
6907:       zipfileTableErr(pTab, "rawdata must be NULL");
6908:       rc = SQLITE_CONSTRAINT;
6909:     }
6910: 
6911:     if( rc==SQLITE_OK ){
6912:       if( sqlite3_value_type(apVal[7])==SQLITE_NULL ){
6913:         /* data=NULL. A directory */
6914:         bIsDir = 1;
6915:       }else{
6916:         /* Value specified for "data", and possibly "method". This must be
6917:         ** a regular file or a symlink. */
6918:         const u8 *aIn = sqlite3_value_blob(apVal[7]);
6919:         int nIn = sqlite3_value_bytes(apVal[7]);
6920:         int bAuto = sqlite3_value_type(apVal[8])==SQLITE_NULL;
6921: 
6922:         iMethod = sqlite3_value_int(apVal[8]);
6923:         sz = nIn;
6924:         pData = aIn;
6925:         nData = nIn;
6926:         if( iMethod!=0 && iMethod!=8 ){
6927:           zipfileTableErr(pTab, "unknown compression method: %d", iMethod);
6928:           rc = SQLITE_CONSTRAINT;
6929:         }else{
6930:           if( bAuto || iMethod ){
6931:             int nCmp;
6932:             rc = zipfileDeflate(aIn, nIn, &pFree, &nCmp, &pTab->base.zErrMsg);
6933:             if( rc==SQLITE_OK ){
6934:               if( iMethod || nCmp<nIn ){
6935:                 iMethod = 8;
6936:                 pData = pFree;
6937:                 nData = nCmp;
6938:               }
6939:             }
6940:           }
6941:           iCrc32 = crc32(0, aIn, nIn);
6942:         }
6943:       }
6944:     }
6945: 
6946:     if( rc==SQLITE_OK ){
6947:       rc = zipfileGetMode(apVal[3], bIsDir, &mode, &pTab->base.zErrMsg);
6948:     }
6949: 
6950:     if( rc==SQLITE_OK ){
6951:       zPath = (const char*)sqlite3_value_text(apVal[2]);
6952:       if( zPath==0 ) zPath = "";
6953:       nPath = (int)strlen(zPath);
6954:       mTime = zipfileGetTime(apVal[4]);
6955:     }
6956: 
6957:     if( rc==SQLITE_OK && bIsDir ){
6958:       /* For a directory, check that the last character in the path is a
6959:       ** '/'. This appears to be required for compatibility with info-zip
6960:       ** (the unzip command on unix). It does not create directories
6961:       ** otherwise.  */
6962:       if( nPath<=0 || zPath[nPath-1]!='/' ){
6963:         zFree = sqlite3_mprintf("%s/", zPath);
6964:         zPath = (const char*)zFree;
6965:         if( zFree==0 ){
6966:           rc = SQLITE_NOMEM;
6967:           nPath = 0;
6968:         }else{
6969:           nPath = (int)strlen(zPath);
6970:         }
6971:       }
6972:     }
6973: 
6974:     /* Check that we're not inserting a duplicate entry -OR- updating an
6975:     ** entry with a path, thereby making it into a duplicate. */
6976:     if( (pOld==0 || bUpdate) && rc==SQLITE_OK ){
6977:       ZipfileEntry *p;
6978:       for(p=pTab->pFirstEntry; p; p=p->pNext){
6979:         if( zipfileComparePath(p->cds.zFile, zPath, nPath)==0 ){
6980:           switch( sqlite3_vtab_on_conflict(pTab->db) ){
6981:             case SQLITE_IGNORE: {
6982:               goto zipfile_update_done;
6983:             }
6984:             case SQLITE_REPLACE: {
6985:               pOld2 = p;
6986:               break;
6987:             }
6988:             default: {
6989:               zipfileTableErr(pTab, "duplicate name: \"%s\"", zPath);
6990:               rc = SQLITE_CONSTRAINT;
6991:               break;
6992:             }
6993:           }
6994:           break;
6995:         }
6996:       }
6997:     }
6998: 
6999:     if( rc==SQLITE_OK ){
7000:       /* Create the new CDS record. */
7001:       pNew = zipfileNewEntry(zPath);
7002:       if( pNew==0 ){
7003:         rc = SQLITE_NOMEM;
7004:       }else{
7005:         pNew->cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;
7006:         pNew->cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;
7007:         pNew->cds.flags = ZIPFILE_NEWENTRY_FLAGS;
7008:         pNew->cds.iCompression = (u16)iMethod;
7009:         zipfileMtimeToDos(&pNew->cds, mTime);
7010:         pNew->cds.crc32 = iCrc32;
7011:         pNew->cds.szCompressed = nData;
7012:         pNew->cds.szUncompressed = (u32)sz;
7013:         pNew->cds.iExternalAttr = (mode<<16);
7014:         pNew->cds.iOffset = (u32)pTab->szCurrent;
7015:         pNew->cds.nFile = (u16)nPath;
7016:         pNew->mUnixTime = (u32)mTime;
7017:         rc = zipfileAppendEntry(pTab, pNew, pData, nData);
7018:         zipfileAddEntry(pTab, pOld, pNew);
7019:       }
7020:     }
7021:   }
7022: 
7023:   if( rc==SQLITE_OK && (pOld || pOld2) ){
7024:     ZipfileCsr *pCsr;
7025:     for(pCsr=pTab->pCsrList; pCsr; pCsr=pCsr->pCsrNext){
7026:       if( pCsr->pCurrent && (pCsr->pCurrent==pOld || pCsr->pCurrent==pOld2) ){
7027:         pCsr->pCurrent = pCsr->pCurrent->pNext;
7028:         pCsr->bNoop = 1;
7029:       }
7030:     }
7031: 
7032:     zipfileRemoveEntryFromList(pTab, pOld);
7033:     zipfileRemoveEntryFromList(pTab, pOld2);
7034:   }
7035: 
7036: zipfile_update_done:
7037:   sqlite3_free(pFree);
7038:   sqlite3_free(zFree);
7039:   return rc;
7040: }
7041: 
7042: static int zipfileSerializeEOCD(ZipfileEOCD *p, u8 *aBuf){
7043:   u8 *a = aBuf;
7044:   zipfileWrite32(a, ZIPFILE_SIGNATURE_EOCD);
7045:   zipfileWrite16(a, p->iDisk);
7046:   zipfileWrite16(a, p->iFirstDisk);
7047:   zipfileWrite16(a, p->nEntry);
7048:   zipfileWrite16(a, p->nEntryTotal);
7049:   zipfileWrite32(a, p->nSize);
7050:   zipfileWrite32(a, p->iOffset);
7051:   zipfileWrite16(a, 0);        /* Size of trailing comment in bytes*/
7052: 
7053:   return a-aBuf;
7054: }
7055: 
7056: static int zipfileAppendEOCD(ZipfileTab *pTab, ZipfileEOCD *p){
7057:   int nBuf = zipfileSerializeEOCD(p, pTab->aBuffer);
7058:   assert( nBuf==ZIPFILE_EOCD_FIXED_SZ );
7059:   return zipfileAppendData(pTab, pTab->aBuffer, nBuf);
7060: }
7061: 
7062: /*
7063: ** Serialize the CDS structure into buffer aBuf[]. Return the number
7064: ** of bytes written.
7065: */
7066: static int zipfileSerializeCDS(ZipfileEntry *pEntry, u8 *aBuf){
7067:   u8 *a = aBuf;
7068:   ZipfileCDS *pCDS = &pEntry->cds;
7069: 
7070:   if( pEntry->aExtra==0 ){
7071:     pCDS->nExtra = 9;
7072:   }
7073: 
7074:   zipfileWrite32(a, ZIPFILE_SIGNATURE_CDS);
7075:   zipfileWrite16(a, pCDS->iVersionMadeBy);
7076:   zipfileWrite16(a, pCDS->iVersionExtract);
7077:   zipfileWrite16(a, pCDS->flags);
7078:   zipfileWrite16(a, pCDS->iCompression);
7079:   zipfileWrite16(a, pCDS->mTime);
7080:   zipfileWrite16(a, pCDS->mDate);
7081:   zipfileWrite32(a, pCDS->crc32);
7082:   zipfileWrite32(a, pCDS->szCompressed);
7083:   zipfileWrite32(a, pCDS->szUncompressed);
7084:   assert( a==&aBuf[ZIPFILE_CDS_NFILE_OFF] );
7085:   zipfileWrite16(a, pCDS->nFile);
7086:   zipfileWrite16(a, pCDS->nExtra);
7087:   zipfileWrite16(a, pCDS->nComment);
7088:   zipfileWrite16(a, pCDS->iDiskStart);
7089:   zipfileWrite16(a, pCDS->iInternalAttr);
7090:   zipfileWrite32(a, pCDS->iExternalAttr);
7091:   zipfileWrite32(a, pCDS->iOffset);
7092: 
7093:   memcpy(a, pCDS->zFile, pCDS->nFile);
7094:   a += pCDS->nFile;
7095: 
7096:   if( pEntry->aExtra ){
7097:     int n = (int)pCDS->nExtra + (int)pCDS->nComment;
7098:     memcpy(a, pEntry->aExtra, n);
7099:     a += n;
7100:   }else{
7101:     assert( pCDS->nExtra==9 );
7102:     zipfileWrite16(a, ZIPFILE_EXTRA_TIMESTAMP);
7103:     zipfileWrite16(a, 5);
7104:     *a++ = 0x01;
7105:     zipfileWrite32(a, pEntry->mUnixTime);
7106:   }
7107: 
7108:   return a-aBuf;
7109: }
7110: 
7111: static int zipfileCommit(sqlite3_vtab *pVtab){
7112:   ZipfileTab *pTab = (ZipfileTab*)pVtab;
7113:   int rc = SQLITE_OK;
7114:   if( pTab->pWriteFd ){
7115:     i64 iOffset = pTab->szCurrent;
7116:     ZipfileEntry *p;
7117:     ZipfileEOCD eocd;
7118:     int nEntry = 0;
7119: 
7120:     /* Write out all entries */
7121:     for(p=pTab->pFirstEntry; rc==SQLITE_OK && p; p=p->pNext){
7122:       int n = zipfileSerializeCDS(p, pTab->aBuffer);
7123:       rc = zipfileAppendData(pTab, pTab->aBuffer, n);
7124:       nEntry++;
7125:     }
7126: 
7127:     /* Write out the EOCD record */
7128:     eocd.iDisk = 0;
7129:     eocd.iFirstDisk = 0;
7130:     eocd.nEntry = (u16)nEntry;
7131:     eocd.nEntryTotal = (u16)nEntry;
7132:     eocd.nSize = (u32)(pTab->szCurrent - iOffset);
7133:     eocd.iOffset = (u32)iOffset;
7134:     rc = zipfileAppendEOCD(pTab, &eocd);
7135: 
7136:     zipfileCleanupTransaction(pTab);
7137:   }
7138:   return rc;
7139: }
7140: 
7141: static int zipfileRollback(sqlite3_vtab *pVtab){
7142:   return zipfileCommit(pVtab);
7143: }
7144: 
7145: static ZipfileCsr *zipfileFindCursor(ZipfileTab *pTab, i64 iId){
7146:   ZipfileCsr *pCsr;
7147:   for(pCsr=pTab->pCsrList; pCsr; pCsr=pCsr->pCsrNext){
7148:     if( iId==pCsr->iId ) break;
7149:   }
7150:   return pCsr;
7151: }
7152: 
7153: static void zipfileFunctionCds(
7154:   sqlite3_context *context,
7155:   int argc,
7156:   sqlite3_value **argv
7157: ){
7158:   ZipfileCsr *pCsr;
7159:   ZipfileTab *pTab = (ZipfileTab*)sqlite3_user_data(context);
7160:   assert( argc>0 );
7161: 
7162:   pCsr = zipfileFindCursor(pTab, sqlite3_value_int64(argv[0]));
7163:   if( pCsr ){
7164:     ZipfileCDS *p = &pCsr->pCurrent->cds;
7165:     char *zRes = sqlite3_mprintf("{"
7166:         "\"version-made-by\" : %u, "
7167:         "\"version-to-extract\" : %u, "
7168:         "\"flags\" : %u, "
7169:         "\"compression\" : %u, "
7170:         "\"time\" : %u, "
7171:         "\"date\" : %u, "
7172:         "\"crc32\" : %u, "
7173:         "\"compressed-size\" : %u, "
7174:         "\"uncompressed-size\" : %u, "
7175:         "\"file-name-length\" : %u, "
7176:         "\"extra-field-length\" : %u, "
7177:         "\"file-comment-length\" : %u, "
7178:         "\"disk-number-start\" : %u, "
7179:         "\"internal-attr\" : %u, "
7180:         "\"external-attr\" : %u, "
7181:         "\"offset\" : %u }",
7182:         (u32)p->iVersionMadeBy, (u32)p->iVersionExtract,
7183:         (u32)p->flags, (u32)p->iCompression,
7184:         (u32)p->mTime, (u32)p->mDate,
7185:         (u32)p->crc32, (u32)p->szCompressed,
7186:         (u32)p->szUncompressed, (u32)p->nFile,
7187:         (u32)p->nExtra, (u32)p->nComment,
7188:         (u32)p->iDiskStart, (u32)p->iInternalAttr,
7189:         (u32)p->iExternalAttr, (u32)p->iOffset
7190:     );
7191: 
7192:     if( zRes==0 ){
7193:       sqlite3_result_error_nomem(context);
7194:     }else{
7195:       sqlite3_result_text(context, zRes, -1, SQLITE_TRANSIENT);
7196:       sqlite3_free(zRes);
7197:     }
7198:   }
7199: }
7200: 
7201: /*
7202: ** xFindFunction method.
7203: */
7204: static int zipfileFindFunction(
7205:   sqlite3_vtab *pVtab,            /* Virtual table handle */
7206:   int nArg,                       /* Number of SQL function arguments */
7207:   const char *zName,              /* Name of SQL function */
7208:   void (**pxFunc)(sqlite3_context*,int,sqlite3_value**), /* OUT: Result */
7209:   void **ppArg                    /* OUT: User data for *pxFunc */
7210: ){
7211:   if( sqlite3_stricmp("zipfile_cds", zName)==0 ){
7212:     *pxFunc = zipfileFunctionCds;
7213:     *ppArg = (void*)pVtab;
7214:     return 1;
7215:   }
7216:   return 0;
7217: }
7218: 
7219: typedef struct ZipfileBuffer ZipfileBuffer;
7220: struct ZipfileBuffer {
7221:   u8 *a;                          /* Pointer to buffer */
7222:   int n;                          /* Size of buffer in bytes */
7223:   int nAlloc;                     /* Byte allocated at a[] */
7224: };
7225: 
7226: typedef struct ZipfileCtx ZipfileCtx;
7227: struct ZipfileCtx {
7228:   int nEntry;
7229:   ZipfileBuffer body;
7230:   ZipfileBuffer cds;
7231: };
7232: 
7233: static int zipfileBufferGrow(ZipfileBuffer *pBuf, int nByte){
7234:   if( pBuf->n+nByte>pBuf->nAlloc ){
7235:     u8 *aNew;
7236:     sqlite3_int64 nNew = pBuf->n ? pBuf->n*2 : 512;
7237:     int nReq = pBuf->n + nByte;
7238: 
7239:     while( nNew<nReq ) nNew = nNew*2;
7240:     aNew = sqlite3_realloc64(pBuf->a, nNew);
7241:     if( aNew==0 ) return SQLITE_NOMEM;
7242:     pBuf->a = aNew;
7243:     pBuf->nAlloc = (int)nNew;
7244:   }
7245:   return SQLITE_OK;
7246: }
7247: 
7248: /*
7249: ** xStep() callback for the zipfile() aggregate. This can be called in
7250: ** any of the following ways:
7251: **
7252: **   SELECT zipfile(name,data) ...
7253: **   SELECT zipfile(name,mode,mtime,data) ...
7254: **   SELECT zipfile(name,mode,mtime,data,method) ...
7255: */
7256: void zipfileStep(sqlite3_context *pCtx, int nVal, sqlite3_value **apVal){
7257:   ZipfileCtx *p;                  /* Aggregate function context */
7258:   ZipfileEntry e;                 /* New entry to add to zip archive */
7259: 
7260:   sqlite3_value *pName = 0;
7261:   sqlite3_value *pMode = 0;
7262:   sqlite3_value *pMtime = 0;
7263:   sqlite3_value *pData = 0;
7264:   sqlite3_value *pMethod = 0;
7265: 
7266:   int bIsDir = 0;
7267:   u32 mode;
7268:   int rc = SQLITE_OK;
7269:   char *zErr = 0;
7270: 
7271:   int iMethod = -1;               /* Compression method to use (0 or 8) */
7272: 
7273:   const u8 *aData = 0;            /* Possibly compressed data for new entry */
7274:   int nData = 0;                  /* Size of aData[] in bytes */
7275:   int szUncompressed = 0;         /* Size of data before compression */
7276:   u8 *aFree = 0;                  /* Free this before returning */
7277:   u32 iCrc32 = 0;                 /* crc32 of uncompressed data */
7278: 
7279:   char *zName = 0;                /* Path (name) of new entry */
7280:   int nName = 0;                  /* Size of zName in bytes */
7281:   char *zFree = 0;                /* Free this before returning */
7282:   int nByte;
7283: 
7284:   memset(&e, 0, sizeof(e));
7285:   p = (ZipfileCtx*)sqlite3_aggregate_context(pCtx, sizeof(ZipfileCtx));
7286:   if( p==0 ) return;
7287: 
7288:   /* Martial the arguments into stack variables */
7289:   if( nVal!=2 && nVal!=4 && nVal!=5 ){
7290:     zErr = sqlite3_mprintf("wrong number of arguments to function zipfile()");
7291:     rc = SQLITE_ERROR;
7292:     goto zipfile_step_out;
7293:   }
7294:   pName = apVal[0];
7295:   if( nVal==2 ){
7296:     pData = apVal[1];
7297:   }else{
7298:     pMode = apVal[1];
7299:     pMtime = apVal[2];
7300:     pData = apVal[3];
7301:     if( nVal==5 ){
7302:       pMethod = apVal[4];
7303:     }
7304:   }
7305: 
7306:   /* Check that the 'name' parameter looks ok. */
7307:   zName = (char*)sqlite3_value_text(pName);
7308:   nName = sqlite3_value_bytes(pName);
7309:   if( zName==0 ){
7310:     zErr = sqlite3_mprintf("first argument to zipfile() must be non-NULL");
7311:     rc = SQLITE_ERROR;
7312:     goto zipfile_step_out;
7313:   }
7314: 
7315:   /* Inspect the 'method' parameter. This must be either 0 (store), 8 (use
7316:   ** deflate compression) or NULL (choose automatically).  */
7317:   if( pMethod && SQLITE_NULL!=sqlite3_value_type(pMethod) ){
7318:     iMethod = (int)sqlite3_value_int64(pMethod);
7319:     if( iMethod!=0 && iMethod!=8 ){
7320:       zErr = sqlite3_mprintf("illegal method value: %d", iMethod);
7321:       rc = SQLITE_ERROR;
7322:       goto zipfile_step_out;
7323:     }
7324:   }
7325: 
7326:   /* Now inspect the data. If this is NULL, then the new entry must be a
7327:   ** directory.  Otherwise, figure out whether or not the data should
7328:   ** be deflated or simply stored in the zip archive. */
7329:   if( sqlite3_value_type(pData)==SQLITE_NULL ){
7330:     bIsDir = 1;
7331:     iMethod = 0;
7332:   }else{
7333:     aData = sqlite3_value_blob(pData);
7334:     szUncompressed = nData = sqlite3_value_bytes(pData);
7335:     iCrc32 = crc32(0, aData, nData);
7336:     if( iMethod<0 || iMethod==8 ){
7337:       int nOut = 0;
7338:       rc = zipfileDeflate(aData, nData, &aFree, &nOut, &zErr);
7339:       if( rc!=SQLITE_OK ){
7340:         goto zipfile_step_out;
7341:       }
7342:       if( iMethod==8 || nOut<nData ){
7343:         aData = aFree;
7344:         nData = nOut;
7345:         iMethod = 8;
7346:       }else{
7347:         iMethod = 0;
7348:       }
7349:     }
7350:   }
7351: 
7352:   /* Decode the "mode" argument. */
7353:   rc = zipfileGetMode(pMode, bIsDir, &mode, &zErr);
7354:   if( rc ) goto zipfile_step_out;
7355: 
7356:   /* Decode the "mtime" argument. */
7357:   e.mUnixTime = zipfileGetTime(pMtime);
7358: 
7359:   /* If this is a directory entry, ensure that there is exactly one '/'
7360:   ** at the end of the path. Or, if this is not a directory and the path
7361:   ** ends in '/' it is an error. */
7362:   if( bIsDir==0 ){
7363:     if( nName>0 && zName[nName-1]=='/' ){
7364:       zErr = sqlite3_mprintf("non-directory name must not end with /");
7365:       rc = SQLITE_ERROR;
7366:       goto zipfile_step_out;
7367:     }
7368:   }else{
7369:     if( nName==0 || zName[nName-1]!='/' ){
7370:       zName = zFree = sqlite3_mprintf("%s/", zName);
7371:       if( zName==0 ){
7372:         rc = SQLITE_NOMEM;
7373:         goto zipfile_step_out;
7374:       }
7375:       nName = (int)strlen(zName);
7376:     }else{
7377:       while( nName>1 && zName[nName-2]=='/' ) nName--;
7378:     }
7379:   }
7380: 
7381:   /* Assemble the ZipfileEntry object for the new zip archive entry */
7382:   e.cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;
7383:   e.cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;
7384:   e.cds.flags = ZIPFILE_NEWENTRY_FLAGS;
7385:   e.cds.iCompression = (u16)iMethod;
7386:   zipfileMtimeToDos(&e.cds, (u32)e.mUnixTime);
7387:   e.cds.crc32 = iCrc32;
7388:   e.cds.szCompressed = nData;
7389:   e.cds.szUncompressed = szUncompressed;
7390:   e.cds.iExternalAttr = (mode<<16);
7391:   e.cds.iOffset = p->body.n;
7392:   e.cds.nFile = (u16)nName;
7393:   e.cds.zFile = zName;
7394: 
7395:   /* Append the LFH to the body of the new archive */
7396:   nByte = ZIPFILE_LFH_FIXED_SZ + e.cds.nFile + 9;
7397:   if( (rc = zipfileBufferGrow(&p->body, nByte)) ) goto zipfile_step_out;
7398:   p->body.n += zipfileSerializeLFH(&e, &p->body.a[p->body.n]);
7399: 
7400:   /* Append the data to the body of the new archive */
7401:   if( nData>0 ){
7402:     if( (rc = zipfileBufferGrow(&p->body, nData)) ) goto zipfile_step_out;
7403:     memcpy(&p->body.a[p->body.n], aData, nData);
7404:     p->body.n += nData;
7405:   }
7406: 
7407:   /* Append the CDS record to the directory of the new archive */
7408:   nByte = ZIPFILE_CDS_FIXED_SZ + e.cds.nFile + 9;
7409:   if( (rc = zipfileBufferGrow(&p->cds, nByte)) ) goto zipfile_step_out;
7410:   p->cds.n += zipfileSerializeCDS(&e, &p->cds.a[p->cds.n]);
7411: 
7412:   /* Increment the count of entries in the archive */
7413:   p->nEntry++;
7414: 
7415:  zipfile_step_out:
7416:   sqlite3_free(aFree);
7417:   sqlite3_free(zFree);
7418:   if( rc ){
7419:     if( zErr ){
7420:       sqlite3_result_error(pCtx, zErr, -1);
7421:     }else{
7422:       sqlite3_result_error_code(pCtx, rc);
7423:     }
7424:   }
7425:   sqlite3_free(zErr);
7426: }
7427: 
7428: /*
7429: ** xFinalize() callback for zipfile aggregate function.
7430: */
7431: void zipfileFinal(sqlite3_context *pCtx){
7432:   ZipfileCtx *p;
7433:   ZipfileEOCD eocd;
7434:   sqlite3_int64 nZip;
7435:   u8 *aZip;
7436: 
7437:   p = (ZipfileCtx*)sqlite3_aggregate_context(pCtx, sizeof(ZipfileCtx));
7438:   if( p==0 ) return;
7439:   if( p->nEntry>0 ){
7440:     memset(&eocd, 0, sizeof(eocd));
7441:     eocd.nEntry = (u16)p->nEntry;
7442:     eocd.nEntryTotal = (u16)p->nEntry;
7443:     eocd.nSize = p->cds.n;
7444:     eocd.iOffset = p->body.n;
7445: 
7446:     nZip = p->body.n + p->cds.n + ZIPFILE_EOCD_FIXED_SZ;
7447:     aZip = (u8*)sqlite3_malloc64(nZip);
7448:     if( aZip==0 ){
7449:       sqlite3_result_error_nomem(pCtx);
7450:     }else{
7451:       memcpy(aZip, p->body.a, p->body.n);
7452:       memcpy(&aZip[p->body.n], p->cds.a, p->cds.n);
7453:       zipfileSerializeEOCD(&eocd, &aZip[p->body.n + p->cds.n]);
7454:       sqlite3_result_blob(pCtx, aZip, (int)nZip, zipfileFree);
7455:     }
7456:   }
7457: 
7458:   sqlite3_free(p->body.a);
7459:   sqlite3_free(p->cds.a);
7460: }
7461: 
7462: 
7463: /*
7464: ** Register the "zipfile" virtual table.
7465: */
7466: static int zipfileRegister(sqlite3 *db){
7467:   static sqlite3_module zipfileModule = {
7468:     1,                         /* iVersion */
7469:     zipfileConnect,            /* xCreate */
7470:     zipfileConnect,            /* xConnect */
7471:     zipfileBestIndex,          /* xBestIndex */
7472:     zipfileDisconnect,         /* xDisconnect */
7473:     zipfileDisconnect,         /* xDestroy */
7474:     zipfileOpen,               /* xOpen - open a cursor */
7475:     zipfileClose,              /* xClose - close a cursor */
7476:     zipfileFilter,             /* xFilter - configure scan constraints */
7477:     zipfileNext,               /* xNext - advance a cursor */
7478:     zipfileEof,                /* xEof - check for end of scan */
7479:     zipfileColumn,             /* xColumn - read data */
7480:     0,                         /* xRowid - read data */
7481:     zipfileUpdate,             /* xUpdate */
7482:     zipfileBegin,              /* xBegin */
7483:     0,                         /* xSync */
7484:     zipfileCommit,             /* xCommit */
7485:     zipfileRollback,           /* xRollback */
7486:     zipfileFindFunction,       /* xFindMethod */
7487:     0,                         /* xRename */
7488:   };
7489: 
7490:   int rc = sqlite3_create_module(db, "zipfile"  , &zipfileModule, 0);
7491:   if( rc==SQLITE_OK ) rc = sqlite3_overload_function(db, "zipfile_cds", -1);
7492:   if( rc==SQLITE_OK ){
7493:     rc = sqlite3_create_function(db, "zipfile", -1, SQLITE_UTF8, 0, 0,
7494:         zipfileStep, zipfileFinal
7495:     );
7496:   }
7497:   return rc;
7498: }
7499: #else         /* SQLITE_OMIT_VIRTUALTABLE */
7500: # define zipfileRegister(x) SQLITE_OK
7501: #endif
7502: 
7503: #ifdef _WIN32
7504: 
7505: #endif
7506: int sqlite3_zipfile_init(
7507:   sqlite3 *db,
7508:   char **pzErrMsg,
7509:   const sqlite3_api_routines *pApi
7510: ){
7511:   SQLITE_EXTENSION_INIT2(pApi);
7512:   (void)pzErrMsg;  /* Unused parameter */
7513:   return zipfileRegister(db);
7514: }
7515: 
7516: /************************* End ../ext/misc/zipfile.c ********************/
7517: /************************* Begin ../ext/misc/sqlar.c ******************/
7518: /*
7519: ** 2017-12-17
7520: **
7521: ** The author disclaims copyright to this source code.  In place of
7522: ** a legal notice, here is a blessing:
7523: **
7524: **    May you do good and not evil.
7525: **    May you find forgiveness for yourself and forgive others.
7526: **    May you share freely, never taking more than you give.
7527: **
7528: ******************************************************************************
7529: **
7530: ** Utility functions sqlar_compress() and sqlar_uncompress(). Useful
7531: ** for working with sqlar archives and used by the shell tool's built-in
7532: ** sqlar support.
7533: */
7534: /* #include "sqlite3ext.h" */
7535: SQLITE_EXTENSION_INIT1
7536: #include <zlib.h>
7537: #include <assert.h>
7538: 
7539: /*
7540: ** Implementation of the "sqlar_compress(X)" SQL function.
7541: **
7542: ** If the type of X is SQLITE_BLOB, and compressing that blob using
7543: ** zlib utility function compress() yields a smaller blob, return the
7544: ** compressed blob. Otherwise, return a copy of X.
7545: **
7546: ** SQLar uses the "zlib format" for compressed content.  The zlib format
7547: ** contains a two-byte identification header and a four-byte checksum at
7548: ** the end.  This is different from ZIP which uses the raw deflate format.
7549: **
7550: ** Future enhancements to SQLar might add support for new compression formats.
7551: ** If so, those new formats will be identified by alternative headers in the
7552: ** compressed data.
7553: */
7554: static void sqlarCompressFunc(
7555:   sqlite3_context *context,
7556:   int argc,
7557:   sqlite3_value **argv
7558: ){
7559:   assert( argc==1 );
7560:   if( sqlite3_value_type(argv[0])==SQLITE_BLOB ){
7561:     const Bytef *pData = sqlite3_value_blob(argv[0]);
7562:     uLong nData = sqlite3_value_bytes(argv[0]);
7563:     uLongf nOut = compressBound(nData);
7564:     Bytef *pOut;
7565: 
7566:     pOut = (Bytef*)sqlite3_malloc(nOut);
7567:     if( pOut==0 ){
7568:       sqlite3_result_error_nomem(context);
7569:       return;
7570:     }else{
7571:       if( Z_OK!=compress(pOut, &nOut, pData, nData) ){
7572:         sqlite3_result_error(context, "error in compress()", -1);
7573:       }else if( nOut<nData ){
7574:         sqlite3_result_blob(context, pOut, nOut, SQLITE_TRANSIENT);
7575:       }else{
7576:         sqlite3_result_value(context, argv[0]);
7577:       }
7578:       sqlite3_free(pOut);
7579:     }
7580:   }else{
7581:     sqlite3_result_value(context, argv[0]);
7582:   }
7583: }
7584: 
7585: /*
7586: ** Implementation of the "sqlar_uncompress(X,SZ)" SQL function
7587: **
7588: ** Parameter SZ is interpreted as an integer. If it is less than or
7589: ** equal to zero, then this function returns a copy of X. Or, if
7590: ** SZ is equal to the size of X when interpreted as a blob, also
7591: ** return a copy of X. Otherwise, decompress blob X using zlib
7592: ** utility function uncompress() and return the results (another
7593: ** blob).
7594: */
7595: static void sqlarUncompressFunc(
7596:   sqlite3_context *context,
7597:   int argc,
7598:   sqlite3_value **argv
7599: ){
7600:   uLong nData;
7601:   uLongf sz;
7602: 
7603:   assert( argc==2 );
7604:   sz = sqlite3_value_int(argv[1]);
7605: 
7606:   if( sz<=0 || sz==(nData = sqlite3_value_bytes(argv[0])) ){
7607:     sqlite3_result_value(context, argv[0]);
7608:   }else{
7609:     const Bytef *pData= sqlite3_value_blob(argv[0]);
7610:     Bytef *pOut = sqlite3_malloc(sz);
7611:     if( Z_OK!=uncompress(pOut, &sz, pData, nData) ){
7612:       sqlite3_result_error(context, "error in uncompress()", -1);
7613:     }else{
7614:       sqlite3_result_blob(context, pOut, sz, SQLITE_TRANSIENT);
7615:     }
7616:     sqlite3_free(pOut);
7617:   }
7618: }
7619: 
7620: 
7621: #ifdef _WIN32
7622: 
7623: #endif
7624: int sqlite3_sqlar_init(
7625:   sqlite3 *db,
7626:   char **pzErrMsg,
7627:   const sqlite3_api_routines *pApi
7628: ){
7629:   int rc = SQLITE_OK;
7630:   SQLITE_EXTENSION_INIT2(pApi);
7631:   (void)pzErrMsg;  /* Unused parameter */
7632:   rc = sqlite3_create_function(db, "sqlar_compress", 1,
7633:                                SQLITE_UTF8|SQLITE_INNOCUOUS, 0,
7634:                                sqlarCompressFunc, 0, 0);
7635:   if( rc==SQLITE_OK ){
7636:     rc = sqlite3_create_function(db, "sqlar_uncompress", 2,
7637:                                  SQLITE_UTF8|SQLITE_INNOCUOUS, 0,
7638:                                  sqlarUncompressFunc, 0, 0);
7639:   }
7640:   return rc;
7641: }
7642: 
7643: /************************* End ../ext/misc/sqlar.c ********************/
7644: #endif
7645: /************************* Begin ../ext/expert/sqlite3expert.h ******************/
7646: /*
7647: ** 2017 April 07
7648: **
7649: ** The author disclaims copyright to this source code.  In place of
7650: ** a legal notice, here is a blessing:
7651: **
7652: **    May you do good and not evil.
7653: **    May you find forgiveness for yourself and forgive others.
7654: **    May you share freely, never taking more than you give.
7655: **
7656: *************************************************************************
7657: */
7658: #if !defined(SQLITEEXPERT_H)
7659: #define SQLITEEXPERT_H 1
7660: /* #include "sqlite3.h" */
7661: 
7662: typedef struct sqlite3expert sqlite3expert;
7663: 
7664: /*
7665: ** Create a new sqlite3expert object.
7666: **
7667: ** If successful, a pointer to the new object is returned and (*pzErr) set
7668: ** to NULL. Or, if an error occurs, NULL is returned and (*pzErr) set to
7669: ** an English-language error message. In this case it is the responsibility
7670: ** of the caller to eventually free the error message buffer using
7671: ** sqlite3_free().
7672: */
7673: sqlite3expert *sqlite3_expert_new(sqlite3 *db, char **pzErr);
7674: 
7675: /*
7676: ** Configure an sqlite3expert object.
7677: **
7678: ** EXPERT_CONFIG_SAMPLE:
7679: **   By default, sqlite3_expert_analyze() generates sqlite_stat1 data for
7680: **   each candidate index. This involves scanning and sorting the entire
7681: **   contents of each user database table once for each candidate index
7682: **   associated with the table. For large databases, this can be
7683: **   prohibitively slow. This option allows the sqlite3expert object to
7684: **   be configured so that sqlite_stat1 data is instead generated based on a
7685: **   subset of each table, or so that no sqlite_stat1 data is used at all.
7686: **
7687: **   A single integer argument is passed to this option. If the value is less
7688: **   than or equal to zero, then no sqlite_stat1 data is generated or used by
7689: **   the analysis - indexes are recommended based on the database schema only.
7690: **   Or, if the value is 100 or greater, complete sqlite_stat1 data is
7691: **   generated for each candidate index (this is the default). Finally, if the
7692: **   value falls between 0 and 100, then it represents the percentage of user
7693: **   table rows that should be considered when generating sqlite_stat1 data.
7694: **
7695: **   Examples:
7696: **
7697: **     // Do not generate any sqlite_stat1 data
7698: **     sqlite3_expert_config(pExpert, EXPERT_CONFIG_SAMPLE, 0);
7699: **
7700: **     // Generate sqlite_stat1 data based on 10% of the rows in each table.
7701: **     sqlite3_expert_config(pExpert, EXPERT_CONFIG_SAMPLE, 10);
7702: */
7703: int sqlite3_expert_config(sqlite3expert *p, int op, ...);
7704: 
7705: #define EXPERT_CONFIG_SAMPLE 1    /* int */
7706: 
7707: /*
7708: ** Specify zero or more SQL statements to be included in the analysis.
7709: **
7710: ** Buffer zSql must contain zero or more complete SQL statements. This
7711: ** function parses all statements contained in the buffer and adds them
7712: ** to the internal list of statements to analyze. If successful, SQLITE_OK
7713: ** is returned and (*pzErr) set to NULL. Or, if an error occurs - for example
7714: ** due to a error in the SQL - an SQLite error code is returned and (*pzErr)
7715: ** may be set to point to an English language error message. In this case
7716: ** the caller is responsible for eventually freeing the error message buffer
7717: ** using sqlite3_free().
7718: **
7719: ** If an error does occur while processing one of the statements in the
7720: ** buffer passed as the second argument, none of the statements in the
7721: ** buffer are added to the analysis.
7722: **
7723: ** This function must be called before sqlite3_expert_analyze(). If a call
7724: ** to this function is made on an sqlite3expert object that has already
7725: ** been passed to sqlite3_expert_analyze() SQLITE_MISUSE is returned
7726: ** immediately and no statements are added to the analysis.
7727: */
7728: int sqlite3_expert_sql(
7729:   sqlite3expert *p,               /* From a successful sqlite3_expert_new() */
7730:   const char *zSql,               /* SQL statement(s) to add */
7731:   char **pzErr                    /* OUT: Error message (if any) */
7732: );
7733: 
7734: 
7735: /*
7736: ** This function is called after the sqlite3expert object has been configured
7737: ** with all SQL statements using sqlite3_expert_sql() to actually perform
7738: ** the analysis. Once this function has been called, it is not possible to
7739: ** add further SQL statements to the analysis.
7740: **
7741: ** If successful, SQLITE_OK is returned and (*pzErr) is set to NULL. Or, if
7742: ** an error occurs, an SQLite error code is returned and (*pzErr) set to
7743: ** point to a buffer containing an English language error message. In this
7744: ** case it is the responsibility of the caller to eventually free the buffer
7745: ** using sqlite3_free().
7746: **
7747: ** If an error does occur within this function, the sqlite3expert object
7748: ** is no longer useful for any purpose. At that point it is no longer
7749: ** possible to add further SQL statements to the object or to re-attempt
7750: ** the analysis. The sqlite3expert object must still be freed using a call
7751: ** sqlite3_expert_destroy().
7752: */
7753: int sqlite3_expert_analyze(sqlite3expert *p, char **pzErr);
7754: 
7755: /*
7756: ** Return the total number of statements loaded using sqlite3_expert_sql().
7757: ** The total number of SQL statements may be different from the total number
7758: ** to calls to sqlite3_expert_sql().
7759: */
7760: int sqlite3_expert_count(sqlite3expert*);
7761: 
7762: /*
7763: ** Return a component of the report.
7764: **
7765: ** This function is called after sqlite3_expert_analyze() to extract the
7766: ** results of the analysis. Each call to this function returns either a
7767: ** NULL pointer or a pointer to a buffer containing a nul-terminated string.
7768: ** The value passed as the third argument must be one of the EXPERT_REPORT_*
7769: ** #define constants defined below.
7770: **
7771: ** For some EXPERT_REPORT_* parameters, the buffer returned contains
7772: ** information relating to a specific SQL statement. In these cases that
7773: ** SQL statement is identified by the value passed as the second argument.
7774: ** SQL statements are numbered from 0 in the order in which they are parsed.
7775: ** If an out-of-range value (less than zero or equal to or greater than the
7776: ** value returned by sqlite3_expert_count()) is passed as the second argument
7777: ** along with such an EXPERT_REPORT_* parameter, NULL is always returned.
7778: **
7779: ** EXPERT_REPORT_SQL:
7780: **   Return the text of SQL statement iStmt.
7781: **
7782: ** EXPERT_REPORT_INDEXES:
7783: **   Return a buffer containing the CREATE INDEX statements for all recommended
7784: **   indexes for statement iStmt. If there are no new recommeded indexes, NULL
7785: **   is returned.
7786: **
7787: ** EXPERT_REPORT_PLAN:
7788: **   Return a buffer containing the EXPLAIN QUERY PLAN output for SQL query
7789: **   iStmt after the proposed indexes have been added to the database schema.
7790: **
7791: ** EXPERT_REPORT_CANDIDATES:
7792: **   Return a pointer to a buffer containing the CREATE INDEX statements
7793: **   for all indexes that were tested (for all SQL statements). The iStmt
7794: **   parameter is ignored for EXPERT_REPORT_CANDIDATES calls.
7795: */
7796: const char *sqlite3_expert_report(sqlite3expert*, int iStmt, int eReport);
7797: 
7798: /*
7799: ** Values for the third argument passed to sqlite3_expert_report().
7800: */
7801: #define EXPERT_REPORT_SQL        1
7802: #define EXPERT_REPORT_INDEXES    2
7803: #define EXPERT_REPORT_PLAN       3
7804: #define EXPERT_REPORT_CANDIDATES 4
7805: 
7806: /*
7807: ** Free an (sqlite3expert*) handle and all associated resources. There
7808: ** should be one call to this function for each successful call to
7809: ** sqlite3-expert_new().
7810: */
7811: void sqlite3_expert_destroy(sqlite3expert*);
7812: 
7813: #endif  /* !defined(SQLITEEXPERT_H) */
7814: 
7815: /************************* End ../ext/expert/sqlite3expert.h ********************/
7816: /************************* Begin ../ext/expert/sqlite3expert.c ******************/
7817: /*
7818: ** 2017 April 09
7819: **
7820: ** The author disclaims copyright to this source code.  In place of
7821: ** a legal notice, here is a blessing:
7822: **
7823: **    May you do good and not evil.
7824: **    May you find forgiveness for yourself and forgive others.
7825: **    May you share freely, never taking more than you give.
7826: **
7827: *************************************************************************
7828: */
7829: /* #include "sqlite3expert.h" */
7830: #include <assert.h>
7831: #include <string.h>
7832: #include <stdio.h>
7833: 
7834: #ifndef SQLITE_OMIT_VIRTUALTABLE
7835: 
7836: /* typedef sqlite3_int64 i64; */
7837: /* typedef sqlite3_uint64 u64; */
7838: 
7839: typedef struct IdxColumn IdxColumn;
7840: typedef struct IdxConstraint IdxConstraint;
7841: typedef struct IdxScan IdxScan;
7842: typedef struct IdxStatement IdxStatement;
7843: typedef struct IdxTable IdxTable;
7844: typedef struct IdxWrite IdxWrite;
7845: 
7846: #define STRLEN  (int)strlen
7847: 
7848: /*
7849: ** A temp table name that we assume no user database will actually use.
7850: ** If this assumption proves incorrect triggers on the table with the
7851: ** conflicting name will be ignored.
7852: */
7853: #define UNIQUE_TABLE_NAME "t592690916721053953805701627921227776"
7854: 
7855: /*
7856: ** A single constraint. Equivalent to either "col = ?" or "col < ?" (or
7857: ** any other type of single-ended range constraint on a column).
7858: **
7859: ** pLink:
7860: **   Used to temporarily link IdxConstraint objects into lists while
7861: **   creating candidate indexes.
7862: */
7863: struct IdxConstraint {
7864:   char *zColl;                    /* Collation sequence */
7865:   int bRange;                     /* True for range, false for eq */
7866:   int iCol;                       /* Constrained table column */
7867:   int bFlag;                      /* Used by idxFindCompatible() */
7868:   int bDesc;                      /* True if ORDER BY <expr> DESC */
7869:   IdxConstraint *pNext;           /* Next constraint in pEq or pRange list */
7870:   IdxConstraint *pLink;           /* See above */
7871: };
7872: 
7873: /*
7874: ** A single scan of a single table.
7875: */
7876: struct IdxScan {
7877:   IdxTable *pTab;                 /* Associated table object */
7878:   int iDb;                        /* Database containing table zTable */
7879:   i64 covering;                   /* Mask of columns required for cov. index */
7880:   IdxConstraint *pOrder;          /* ORDER BY columns */
7881:   IdxConstraint *pEq;             /* List of == constraints */
7882:   IdxConstraint *pRange;          /* List of < constraints */
7883:   IdxScan *pNextScan;             /* Next IdxScan object for same analysis */
7884: };
7885: 
7886: /*
7887: ** Information regarding a single database table. Extracted from
7888: ** "PRAGMA table_info" by function idxGetTableInfo().
7889: */
7890: struct IdxColumn {
7891:   char *zName;
7892:   char *zColl;
7893:   int iPk;
7894: };
7895: struct IdxTable {
7896:   int nCol;
7897:   char *zName;                    /* Table name */
7898:   IdxColumn *aCol;
7899:   IdxTable *pNext;                /* Next table in linked list of all tables */
7900: };
7901: 
7902: /*
7903: ** An object of the following type is created for each unique table/write-op
7904: ** seen. The objects are stored in a singly-linked list beginning at
7905: ** sqlite3expert.pWrite.
7906: */
7907: struct IdxWrite {
7908:   IdxTable *pTab;
7909:   int eOp;                        /* SQLITE_UPDATE, DELETE or INSERT */
7910:   IdxWrite *pNext;
7911: };
7912: 
7913: /*
7914: ** Each statement being analyzed is represented by an instance of this
7915: ** structure.
7916: */
7917: struct IdxStatement {
7918:   int iId;                        /* Statement number */
7919:   char *zSql;                     /* SQL statement */
7920:   char *zIdx;                     /* Indexes */
7921:   char *zEQP;                     /* Plan */
7922:   IdxStatement *pNext;
7923: };
7924: 
7925: 
7926: /*
7927: ** A hash table for storing strings. With space for a payload string
7928: ** with each entry. Methods are:
7929: **
7930: **   idxHashInit()
7931: **   idxHashClear()
7932: **   idxHashAdd()
7933: **   idxHashSearch()
7934: */
7935: #define IDX_HASH_SIZE 1023
7936: typedef struct IdxHashEntry IdxHashEntry;
7937: typedef struct IdxHash IdxHash;
7938: struct IdxHashEntry {
7939:   char *zKey;                     /* nul-terminated key */
7940:   char *zVal;                     /* nul-terminated value string */
7941:   char *zVal2;                    /* nul-terminated value string 2 */
7942:   IdxHashEntry *pHashNext;        /* Next entry in same hash bucket */
7943:   IdxHashEntry *pNext;            /* Next entry in hash */
7944: };
7945: struct IdxHash {
7946:   IdxHashEntry *pFirst;
7947:   IdxHashEntry *aHash[IDX_HASH_SIZE];
7948: };
7949: 
7950: /*
7951: ** sqlite3expert object.
7952: */
7953: struct sqlite3expert {
7954:   int iSample;                    /* Percentage of tables to sample for stat1 */
7955:   sqlite3 *db;                    /* User database */
7956:   sqlite3 *dbm;                   /* In-memory db for this analysis */
7957:   sqlite3 *dbv;                   /* Vtab schema for this analysis */
7958:   IdxTable *pTable;               /* List of all IdxTable objects */
7959:   IdxScan *pScan;                 /* List of scan objects */
7960:   IdxWrite *pWrite;               /* List of write objects */
7961:   IdxStatement *pStatement;       /* List of IdxStatement objects */
7962:   int bRun;                       /* True once analysis has run */
7963:   char **pzErrmsg;
7964:   int rc;                         /* Error code from whereinfo hook */
7965:   IdxHash hIdx;                   /* Hash containing all candidate indexes */
7966:   char *zCandidates;              /* For EXPERT_REPORT_CANDIDATES */
7967: };
7968: 
7969: 
7970: /*
7971: ** Allocate and return nByte bytes of zeroed memory using sqlite3_malloc().
7972: ** If the allocation fails, set *pRc to SQLITE_NOMEM and return NULL.
7973: */
7974: static void *idxMalloc(int *pRc, int nByte){
7975:   void *pRet;
7976:   assert( *pRc==SQLITE_OK );
7977:   assert( nByte>0 );
7978:   pRet = sqlite3_malloc(nByte);
7979:   if( pRet ){
7980:     memset(pRet, 0, nByte);
7981:   }else{
7982:     *pRc = SQLITE_NOMEM;
7983:   }
7984:   return pRet;
7985: }
7986: 
7987: /*
7988: ** Initialize an IdxHash hash table.
7989: */
7990: static void idxHashInit(IdxHash *pHash){
7991:   memset(pHash, 0, sizeof(IdxHash));
7992: }
7993: 
7994: /*
7995: ** Reset an IdxHash hash table.
7996: */
7997: static void idxHashClear(IdxHash *pHash){
7998:   int i;
7999:   for(i=0; i<IDX_HASH_SIZE; i++){
8000:     IdxHashEntry *pEntry;
8001:     IdxHashEntry *pNext;
8002:     for(pEntry=pHash->aHash[i]; pEntry; pEntry=pNext){
8003:       pNext = pEntry->pHashNext;
8004:       sqlite3_free(pEntry->zVal2);
8005:       sqlite3_free(pEntry);
8006:     }
8007:   }
8008:   memset(pHash, 0, sizeof(IdxHash));
8009: }
8010: 
8011: /*
8012: ** Return the index of the hash bucket that the string specified by the
8013: ** arguments to this function belongs.
8014: */
8015: static int idxHashString(const char *z, int n){
8016:   unsigned int ret = 0;
8017:   int i;
8018:   for(i=0; i<n; i++){
8019:     ret += (ret<<3) + (unsigned char)(z[i]);
8020:   }
8021:   return (int)(ret % IDX_HASH_SIZE);
8022: }
8023: 
8024: /*
8025: ** If zKey is already present in the hash table, return non-zero and do
8026: ** nothing. Otherwise, add an entry with key zKey and payload string zVal to
8027: ** the hash table passed as the second argument.
8028: */
8029: static int idxHashAdd(
8030:   int *pRc,
8031:   IdxHash *pHash,
8032:   const char *zKey,
8033:   const char *zVal
8034: ){
8035:   int nKey = STRLEN(zKey);
8036:   int iHash = idxHashString(zKey, nKey);
8037:   int nVal = (zVal ? STRLEN(zVal) : 0);
8038:   IdxHashEntry *pEntry;
8039:   assert( iHash>=0 );
8040:   for(pEntry=pHash->aHash[iHash]; pEntry; pEntry=pEntry->pHashNext){
8041:     if( STRLEN(pEntry->zKey)==nKey && 0==memcmp(pEntry->zKey, zKey, nKey) ){
8042:       return 1;
8043:     }
8044:   }
8045:   pEntry = idxMalloc(pRc, sizeof(IdxHashEntry) + nKey+1 + nVal+1);
8046:   if( pEntry ){
8047:     pEntry->zKey = (char*)&pEntry[1];
8048:     memcpy(pEntry->zKey, zKey, nKey);
8049:     if( zVal ){
8050:       pEntry->zVal = &pEntry->zKey[nKey+1];
8051:       memcpy(pEntry->zVal, zVal, nVal);
8052:     }
8053:     pEntry->pHashNext = pHash->aHash[iHash];
8054:     pHash->aHash[iHash] = pEntry;
8055: 
8056:     pEntry->pNext = pHash->pFirst;
8057:     pHash->pFirst = pEntry;
8058:   }
8059:   return 0;
8060: }
8061: 
8062: /*
8063: ** If zKey/nKey is present in the hash table, return a pointer to the
8064: ** hash-entry object.
8065: */
8066: static IdxHashEntry *idxHashFind(IdxHash *pHash, const char *zKey, int nKey){
8067:   int iHash;
8068:   IdxHashEntry *pEntry;
8069:   if( nKey<0 ) nKey = STRLEN(zKey);
8070:   iHash = idxHashString(zKey, nKey);
8071:   assert( iHash>=0 );
8072:   for(pEntry=pHash->aHash[iHash]; pEntry; pEntry=pEntry->pHashNext){
8073:     if( STRLEN(pEntry->zKey)==nKey && 0==memcmp(pEntry->zKey, zKey, nKey) ){
8074:       return pEntry;
8075:     }
8076:   }
8077:   return 0;
8078: }
8079: 
8080: /*
8081: ** If the hash table contains an entry with a key equal to the string
8082: ** passed as the final two arguments to this function, return a pointer
8083: ** to the payload string. Otherwise, if zKey/nKey is not present in the
8084: ** hash table, return NULL.
8085: */
8086: static const char *idxHashSearch(IdxHash *pHash, const char *zKey, int nKey){
8087:   IdxHashEntry *pEntry = idxHashFind(pHash, zKey, nKey);
8088:   if( pEntry ) return pEntry->zVal;
8089:   return 0;
8090: }
8091: 
8092: /*
8093: ** Allocate and return a new IdxConstraint object. Set the IdxConstraint.zColl
8094: ** variable to point to a copy of nul-terminated string zColl.
8095: */
8096: static IdxConstraint *idxNewConstraint(int *pRc, const char *zColl){
8097:   IdxConstraint *pNew;
8098:   int nColl = STRLEN(zColl);
8099: 
8100:   assert( *pRc==SQLITE_OK );
8101:   pNew = (IdxConstraint*)idxMalloc(pRc, sizeof(IdxConstraint) * nColl + 1);
8102:   if( pNew ){
8103:     pNew->zColl = (char*)&pNew[1];
8104:     memcpy(pNew->zColl, zColl, nColl+1);
8105:   }
8106:   return pNew;
8107: }
8108: 
8109: /*
8110: ** An error associated with database handle db has just occurred. Pass
8111: ** the error message to callback function xOut.
8112: */
8113: static void idxDatabaseError(
8114:   sqlite3 *db,                    /* Database handle */
8115:   char **pzErrmsg                 /* Write error here */
8116: ){
8117:   *pzErrmsg = sqlite3_mprintf("%s", sqlite3_errmsg(db));
8118: }
8119: 
8120: /*
8121: ** Prepare an SQL statement.
8122: */
8123: static int idxPrepareStmt(
8124:   sqlite3 *db,                    /* Database handle to compile against */
8125:   sqlite3_stmt **ppStmt,          /* OUT: Compiled SQL statement */
8126:   char **pzErrmsg,                /* OUT: sqlite3_malloc()ed error message */
8127:   const char *zSql                /* SQL statement to compile */
8128: ){
8129:   int rc = sqlite3_prepare_v2(db, zSql, -1, ppStmt, 0);
8130:   if( rc!=SQLITE_OK ){
8131:     *ppStmt = 0;
8132:     idxDatabaseError(db, pzErrmsg);
8133:   }
8134:   return rc;
8135: }
8136: 
8137: /*
8138: ** Prepare an SQL statement using the results of a printf() formatting.
8139: */
8140: static int idxPrintfPrepareStmt(
8141:   sqlite3 *db,                    /* Database handle to compile against */
8142:   sqlite3_stmt **ppStmt,          /* OUT: Compiled SQL statement */
8143:   char **pzErrmsg,                /* OUT: sqlite3_malloc()ed error message */
8144:   const char *zFmt,               /* printf() format of SQL statement */
8145:   ...                             /* Trailing printf() arguments */
8146: ){
8147:   va_list ap;
8148:   int rc;
8149:   char *zSql;
8150:   va_start(ap, zFmt);
8151:   zSql = sqlite3_vmprintf(zFmt, ap);
8152:   if( zSql==0 ){
8153:     rc = SQLITE_NOMEM;
8154:   }else{
8155:     rc = idxPrepareStmt(db, ppStmt, pzErrmsg, zSql);
8156:     sqlite3_free(zSql);
8157:   }
8158:   va_end(ap);
8159:   return rc;
8160: }
8161: 
8162: 
8163: /*************************************************************************
8164: ** Beginning of virtual table implementation.
8165: */
8166: typedef struct ExpertVtab ExpertVtab;
8167: struct ExpertVtab {
8168:   sqlite3_vtab base;
8169:   IdxTable *pTab;
8170:   sqlite3expert *pExpert;
8171: };
8172: 
8173: typedef struct ExpertCsr ExpertCsr;
8174: struct ExpertCsr {
8175:   sqlite3_vtab_cursor base;
8176:   sqlite3_stmt *pData;
8177: };
8178: 
8179: static char *expertDequote(const char *zIn){
8180:   int n = STRLEN(zIn);
8181:   char *zRet = sqlite3_malloc(n);
8182: 
8183:   assert( zIn[0]=='\'' );
8184:   assert( zIn[n-1]=='\'' );
8185: 
8186:   if( zRet ){
8187:     int iOut = 0;
8188:     int iIn = 0;
8189:     for(iIn=1; iIn<(n-1); iIn++){
8190:       if( zIn[iIn]=='\'' ){
8191:         assert( zIn[iIn+1]=='\'' );
8192:         iIn++;
8193:       }
8194:       zRet[iOut++] = zIn[iIn];
8195:     }
8196:     zRet[iOut] = '\0';
8197:   }
8198: 
8199:   return zRet;
8200: }
8201: 
8202: /*
8203: ** This function is the implementation of both the xConnect and xCreate
8204: ** methods of the r-tree virtual table.
8205: **
8206: **   argv[0]   -> module name
8207: **   argv[1]   -> database name
8208: **   argv[2]   -> table name
8209: **   argv[...] -> column names...
8210: */
8211: static int expertConnect(
8212:   sqlite3 *db,
8213:   void *pAux,
8214:   int argc, const char *const*argv,
8215:   sqlite3_vtab **ppVtab,
8216:   char **pzErr
8217: ){
8218:   sqlite3expert *pExpert = (sqlite3expert*)pAux;
8219:   ExpertVtab *p = 0;
8220:   int rc;
8221: 
8222:   if( argc!=4 ){
8223:     *pzErr = sqlite3_mprintf("internal error!");
8224:     rc = SQLITE_ERROR;
8225:   }else{
8226:     char *zCreateTable = expertDequote(argv[3]);
8227:     if( zCreateTable ){
8228:       rc = sqlite3_declare_vtab(db, zCreateTable);
8229:       if( rc==SQLITE_OK ){
8230:         p = idxMalloc(&rc, sizeof(ExpertVtab));
8231:       }
8232:       if( rc==SQLITE_OK ){
8233:         p->pExpert = pExpert;
8234:         p->pTab = pExpert->pTable;
8235:         assert( sqlite3_stricmp(p->pTab->zName, argv[2])==0 );
8236:       }
8237:       sqlite3_free(zCreateTable);
8238:     }else{
8239:       rc = SQLITE_NOMEM;
8240:     }
8241:   }
8242: 
8243:   *ppVtab = (sqlite3_vtab*)p;
8244:   return rc;
8245: }
8246: 
8247: static int expertDisconnect(sqlite3_vtab *pVtab){
8248:   ExpertVtab *p = (ExpertVtab*)pVtab;
8249:   sqlite3_free(p);
8250:   return SQLITE_OK;
8251: }
8252: 
8253: static int expertBestIndex(sqlite3_vtab *pVtab, sqlite3_index_info *pIdxInfo){
8254:   ExpertVtab *p = (ExpertVtab*)pVtab;
8255:   int rc = SQLITE_OK;
8256:   int n = 0;
8257:   IdxScan *pScan;
8258:   const int opmask =
8259:     SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_GT |
8260:     SQLITE_INDEX_CONSTRAINT_LT | SQLITE_INDEX_CONSTRAINT_GE |
8261:     SQLITE_INDEX_CONSTRAINT_LE;
8262: 
8263:   pScan = idxMalloc(&rc, sizeof(IdxScan));
8264:   if( pScan ){
8265:     int i;
8266: 
8267:     /* Link the new scan object into the list */
8268:     pScan->pTab = p->pTab;
8269:     pScan->pNextScan = p->pExpert->pScan;
8270:     p->pExpert->pScan = pScan;
8271: 
8272:     /* Add the constraints to the IdxScan object */
8273:     for(i=0; i<pIdxInfo->nConstraint; i++){
8274:       struct sqlite3_index_constraint *pCons = &pIdxInfo->aConstraint[i];
8275:       if( pCons->usable
8276:        && pCons->iColumn>=0
8277:        && p->pTab->aCol[pCons->iColumn].iPk==0
8278:        && (pCons->op & opmask)
8279:       ){
8280:         IdxConstraint *pNew;
8281:         const char *zColl = sqlite3_vtab_collation(pIdxInfo, i);
8282:         pNew = idxNewConstraint(&rc, zColl);
8283:         if( pNew ){
8284:           pNew->iCol = pCons->iColumn;
8285:           if( pCons->op==SQLITE_INDEX_CONSTRAINT_EQ ){
8286:             pNew->pNext = pScan->pEq;
8287:             pScan->pEq = pNew;
8288:           }else{
8289:             pNew->bRange = 1;
8290:             pNew->pNext = pScan->pRange;
8291:             pScan->pRange = pNew;
8292:           }
8293:         }
8294:         n++;
8295:         pIdxInfo->aConstraintUsage[i].argvIndex = n;
8296:       }
8297:     }
8298: 
8299:     /* Add the ORDER BY to the IdxScan object */
8300:     for(i=pIdxInfo->nOrderBy-1; i>=0; i--){
8301:       int iCol = pIdxInfo->aOrderBy[i].iColumn;
8302:       if( iCol>=0 ){
8303:         IdxConstraint *pNew = idxNewConstraint(&rc, p->pTab->aCol[iCol].zColl);
8304:         if( pNew ){
8305:           pNew->iCol = iCol;
8306:           pNew->bDesc = pIdxInfo->aOrderBy[i].desc;
8307:           pNew->pNext = pScan->pOrder;
8308:           pNew->pLink = pScan->pOrder;
8309:           pScan->pOrder = pNew;
8310:           n++;
8311:         }
8312:       }
8313:     }
8314:   }
8315: 
8316:   pIdxInfo->estimatedCost = 1000000.0 / (n+1);
8317:   return rc;
8318: }
8319: 
8320: static int expertUpdate(
8321:   sqlite3_vtab *pVtab,
8322:   int nData,
8323:   sqlite3_value **azData,
8324:   sqlite_int64 *pRowid
8325: ){
8326:   (void)pVtab;
8327:   (void)nData;
8328:   (void)azData;
8329:   (void)pRowid;
8330:   return SQLITE_OK;
8331: }
8332: 
8333: /*
8334: ** Virtual table module xOpen method.
8335: */
8336: static int expertOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){
8337:   int rc = SQLITE_OK;
8338:   ExpertCsr *pCsr;
8339:   (void)pVTab;
8340:   pCsr = idxMalloc(&rc, sizeof(ExpertCsr));
8341:   *ppCursor = (sqlite3_vtab_cursor*)pCsr;
8342:   return rc;
8343: }
8344: 
8345: /*
8346: ** Virtual table module xClose method.
8347: */
8348: static int expertClose(sqlite3_vtab_cursor *cur){
8349:   ExpertCsr *pCsr = (ExpertCsr*)cur;
8350:   sqlite3_finalize(pCsr->pData);
8351:   sqlite3_free(pCsr);
8352:   return SQLITE_OK;
8353: }
8354: 
8355: /*
8356: ** Virtual table module xEof method.
8357: **
8358: ** Return non-zero if the cursor does not currently point to a valid
8359: ** record (i.e if the scan has finished), or zero otherwise.
8360: */
8361: static int expertEof(sqlite3_vtab_cursor *cur){
8362:   ExpertCsr *pCsr = (ExpertCsr*)cur;
8363:   return pCsr->pData==0;
8364: }
8365: 
8366: /*
8367: ** Virtual table module xNext method.
8368: */
8369: static int expertNext(sqlite3_vtab_cursor *cur){
8370:   ExpertCsr *pCsr = (ExpertCsr*)cur;
8371:   int rc = SQLITE_OK;
8372: 
8373:   assert( pCsr->pData );
8374:   rc = sqlite3_step(pCsr->pData);
8375:   if( rc!=SQLITE_ROW ){
8376:     rc = sqlite3_finalize(pCsr->pData);
8377:     pCsr->pData = 0;
8378:   }else{
8379:     rc = SQLITE_OK;
8380:   }
8381: 
8382:   return rc;
8383: }
8384: 
8385: /*
8386: ** Virtual table module xRowid method.
8387: */
8388: static int expertRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
8389:   (void)cur;
8390:   *pRowid = 0;
8391:   return SQLITE_OK;
8392: }
8393: 
8394: /*
8395: ** Virtual table module xColumn method.
8396: */
8397: static int expertColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){
8398:   ExpertCsr *pCsr = (ExpertCsr*)cur;
8399:   sqlite3_value *pVal;
8400:   pVal = sqlite3_column_value(pCsr->pData, i);
8401:   if( pVal ){
8402:     sqlite3_result_value(ctx, pVal);
8403:   }
8404:   return SQLITE_OK;
8405: }
8406: 
8407: /*
8408: ** Virtual table module xFilter method.
8409: */
8410: static int expertFilter(
8411:   sqlite3_vtab_cursor *cur,
8412:   int idxNum, const char *idxStr,
8413:   int argc, sqlite3_value **argv
8414: ){
8415:   ExpertCsr *pCsr = (ExpertCsr*)cur;
8416:   ExpertVtab *pVtab = (ExpertVtab*)(cur->pVtab);
8417:   sqlite3expert *pExpert = pVtab->pExpert;
8418:   int rc;
8419: 
8420:   (void)idxNum;
8421:   (void)idxStr;
8422:   (void)argc;
8423:   (void)argv;
8424:   rc = sqlite3_finalize(pCsr->pData);
8425:   pCsr->pData = 0;
8426:   if( rc==SQLITE_OK ){
8427:     rc = idxPrintfPrepareStmt(pExpert->db, &pCsr->pData, &pVtab->base.zErrMsg,
8428:         "SELECT * FROM main.%Q WHERE sample()", pVtab->pTab->zName
8429:     );
8430:   }
8431: 
8432:   if( rc==SQLITE_OK ){
8433:     rc = expertNext(cur);
8434:   }
8435:   return rc;
8436: }
8437: 
8438: static int idxRegisterVtab(sqlite3expert *p){
8439:   static sqlite3_module expertModule = {
8440:     2,                            /* iVersion */
8441:     expertConnect,                /* xCreate - create a table */
8442:     expertConnect,                /* xConnect - connect to an existing table */
8443:     expertBestIndex,              /* xBestIndex - Determine search strategy */
8444:     expertDisconnect,             /* xDisconnect - Disconnect from a table */
8445:     expertDisconnect,             /* xDestroy - Drop a table */
8446:     expertOpen,                   /* xOpen - open a cursor */
8447:     expertClose,                  /* xClose - close a cursor */
8448:     expertFilter,                 /* xFilter - configure scan constraints */
8449:     expertNext,                   /* xNext - advance a cursor */
8450:     expertEof,                    /* xEof */
8451:     expertColumn,                 /* xColumn - read data */
8452:     expertRowid,                  /* xRowid - read data */
8453:     expertUpdate,                 /* xUpdate - write data */
8454:     0,                            /* xBegin - begin transaction */
8455:     0,                            /* xSync - sync transaction */
8456:     0,                            /* xCommit - commit transaction */
8457:     0,                            /* xRollback - rollback transaction */
8458:     0,                            /* xFindFunction - function overloading */
8459:     0,                            /* xRename - rename the table */
8460:     0,                            /* xSavepoint */
8461:     0,                            /* xRelease */
8462:     0,                            /* xRollbackTo */
8463:     0,                            /* xShadowName */
8464:   };
8465: 
8466:   return sqlite3_create_module(p->dbv, "expert", &expertModule, (void*)p);
8467: }
8468: /*
8469: ** End of virtual table implementation.
8470: *************************************************************************/
8471: /*
8472: ** Finalize SQL statement pStmt. If (*pRc) is SQLITE_OK when this function
8473: ** is called, set it to the return value of sqlite3_finalize() before
8474: ** returning. Otherwise, discard the sqlite3_finalize() return value.
8475: */
8476: static void idxFinalize(int *pRc, sqlite3_stmt *pStmt){
8477:   int rc = sqlite3_finalize(pStmt);
8478:   if( *pRc==SQLITE_OK ) *pRc = rc;
8479: }
8480: 
8481: /*
8482: ** Attempt to allocate an IdxTable structure corresponding to table zTab
8483: ** in the main database of connection db. If successful, set (*ppOut) to
8484: ** point to the new object and return SQLITE_OK. Otherwise, return an
8485: ** SQLite error code and set (*ppOut) to NULL. In this case *pzErrmsg may be
8486: ** set to point to an error string.
8487: **
8488: ** It is the responsibility of the caller to eventually free either the
8489: ** IdxTable object or error message using sqlite3_free().
8490: */
8491: static int idxGetTableInfo(
8492:   sqlite3 *db,                    /* Database connection to read details from */
8493:   const char *zTab,               /* Table name */
8494:   IdxTable **ppOut,               /* OUT: New object (if successful) */
8495:   char **pzErrmsg                 /* OUT: Error message (if not) */
8496: ){
8497:   sqlite3_stmt *p1 = 0;
8498:   int nCol = 0;
8499:   int nTab = STRLEN(zTab);
8500:   int nByte = sizeof(IdxTable) + nTab + 1;
8501:   IdxTable *pNew = 0;
8502:   int rc, rc2;
8503:   char *pCsr = 0;
8504: 
8505:   rc = idxPrintfPrepareStmt(db, &p1, pzErrmsg, "PRAGMA table_info=%Q", zTab);
8506:   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(p1) ){
8507:     const char *zCol = (const char*)sqlite3_column_text(p1, 1);
8508:     nByte += 1 + STRLEN(zCol);
8509:     rc = sqlite3_table_column_metadata(
8510:         db, "main", zTab, zCol, 0, &zCol, 0, 0, 0
8511:     );
8512:     nByte += 1 + STRLEN(zCol);
8513:     nCol++;
8514:   }
8515:   rc2 = sqlite3_reset(p1);
8516:   if( rc==SQLITE_OK ) rc = rc2;
8517: 
8518:   nByte += sizeof(IdxColumn) * nCol;
8519:   if( rc==SQLITE_OK ){
8520:     pNew = idxMalloc(&rc, nByte);
8521:   }
8522:   if( rc==SQLITE_OK ){
8523:     pNew->aCol = (IdxColumn*)&pNew[1];
8524:     pNew->nCol = nCol;
8525:     pCsr = (char*)&pNew->aCol[nCol];
8526:   }
8527: 
8528:   nCol = 0;
8529:   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(p1) ){
8530:     const char *zCol = (const char*)sqlite3_column_text(p1, 1);
8531:     int nCopy = STRLEN(zCol) + 1;
8532:     pNew->aCol[nCol].zName = pCsr;
8533:     pNew->aCol[nCol].iPk = sqlite3_column_int(p1, 5);
8534:     memcpy(pCsr, zCol, nCopy);
8535:     pCsr += nCopy;
8536: 
8537:     rc = sqlite3_table_column_metadata(
8538:         db, "main", zTab, zCol, 0, &zCol, 0, 0, 0
8539:     );
8540:     if( rc==SQLITE_OK ){
8541:       nCopy = STRLEN(zCol) + 1;
8542:       pNew->aCol[nCol].zColl = pCsr;
8543:       memcpy(pCsr, zCol, nCopy);
8544:       pCsr += nCopy;
8545:     }
8546: 
8547:     nCol++;
8548:   }
8549:   idxFinalize(&rc, p1);
8550: 
8551:   if( rc!=SQLITE_OK ){
8552:     sqlite3_free(pNew);
8553:     pNew = 0;
8554:   }else{
8555:     pNew->zName = pCsr;
8556:     memcpy(pNew->zName, zTab, nTab+1);
8557:   }
8558: 
8559:   *ppOut = pNew;
8560:   return rc;
8561: }
8562: 
8563: /*
8564: ** This function is a no-op if *pRc is set to anything other than
8565: ** SQLITE_OK when it is called.
8566: **
8567: ** If *pRc is initially set to SQLITE_OK, then the text specified by
8568: ** the printf() style arguments is appended to zIn and the result returned
8569: ** in a buffer allocated by sqlite3_malloc(). sqlite3_free() is called on
8570: ** zIn before returning.
8571: */
8572: static char *idxAppendText(int *pRc, char *zIn, const char *zFmt, ...){
8573:   va_list ap;
8574:   char *zAppend = 0;
8575:   char *zRet = 0;
8576:   int nIn = zIn ? STRLEN(zIn) : 0;
8577:   int nAppend = 0;
8578:   va_start(ap, zFmt);
8579:   if( *pRc==SQLITE_OK ){
8580:     zAppend = sqlite3_vmprintf(zFmt, ap);
8581:     if( zAppend ){
8582:       nAppend = STRLEN(zAppend);
8583:       zRet = (char*)sqlite3_malloc(nIn + nAppend + 1);
8584:     }
8585:     if( zAppend && zRet ){
8586:       if( nIn ) memcpy(zRet, zIn, nIn);
8587:       memcpy(&zRet[nIn], zAppend, nAppend+1);
8588:     }else{
8589:       sqlite3_free(zRet);
8590:       zRet = 0;
8591:       *pRc = SQLITE_NOMEM;
8592:     }
8593:     sqlite3_free(zAppend);
8594:     sqlite3_free(zIn);
8595:   }
8596:   va_end(ap);
8597:   return zRet;
8598: }
8599: 
8600: /*
8601: ** Return true if zId must be quoted in order to use it as an SQL
8602: ** identifier, or false otherwise.
8603: */
8604: static int idxIdentifierRequiresQuotes(const char *zId){
8605:   int i;
8606:   for(i=0; zId[i]; i++){
8607:     if( !(zId[i]=='_')
8608:      && !(zId[i]>='0' && zId[i]<='9')
8609:      && !(zId[i]>='a' && zId[i]<='z')
8610:      && !(zId[i]>='A' && zId[i]<='Z')
8611:     ){
8612:       return 1;
8613:     }
8614:   }
8615:   return 0;
8616: }
8617: 
8618: /*
8619: ** This function appends an index column definition suitable for constraint
8620: ** pCons to the string passed as zIn and returns the result.
8621: */
8622: static char *idxAppendColDefn(
8623:   int *pRc,                       /* IN/OUT: Error code */
8624:   char *zIn,                      /* Column defn accumulated so far */
8625:   IdxTable *pTab,                 /* Table index will be created on */
8626:   IdxConstraint *pCons
8627: ){
8628:   char *zRet = zIn;
8629:   IdxColumn *p = &pTab->aCol[pCons->iCol];
8630:   if( zRet ) zRet = idxAppendText(pRc, zRet, ", ");
8631: 
8632:   if( idxIdentifierRequiresQuotes(p->zName) ){
8633:     zRet = idxAppendText(pRc, zRet, "%Q", p->zName);
8634:   }else{
8635:     zRet = idxAppendText(pRc, zRet, "%s", p->zName);
8636:   }
8637: 
8638:   if( sqlite3_stricmp(p->zColl, pCons->zColl) ){
8639:     if( idxIdentifierRequiresQuotes(pCons->zColl) ){
8640:       zRet = idxAppendText(pRc, zRet, " COLLATE %Q", pCons->zColl);
8641:     }else{
8642:       zRet = idxAppendText(pRc, zRet, " COLLATE %s", pCons->zColl);
8643:     }
8644:   }
8645: 
8646:   if( pCons->bDesc ){
8647:     zRet = idxAppendText(pRc, zRet, " DESC");
8648:   }
8649:   return zRet;
8650: }
8651: 
8652: /*
8653: ** Search database dbm for an index compatible with the one idxCreateFromCons()
8654: ** would create from arguments pScan, pEq and pTail. If no error occurs and
8655: ** such an index is found, return non-zero. Or, if no such index is found,
8656: ** return zero.
8657: **
8658: ** If an error occurs, set *pRc to an SQLite error code and return zero.
8659: */
8660: static int idxFindCompatible(
8661:   int *pRc,                       /* OUT: Error code */
8662:   sqlite3* dbm,                   /* Database to search */
8663:   IdxScan *pScan,                 /* Scan for table to search for index on */
8664:   IdxConstraint *pEq,             /* List of == constraints */
8665:   IdxConstraint *pTail            /* List of range constraints */
8666: ){
8667:   const char *zTbl = pScan->pTab->zName;
8668:   sqlite3_stmt *pIdxList = 0;
8669:   IdxConstraint *pIter;
8670:   int nEq = 0;                    /* Number of elements in pEq */
8671:   int rc;
8672: 
8673:   /* Count the elements in list pEq */
8674:   for(pIter=pEq; pIter; pIter=pIter->pLink) nEq++;
8675: 
8676:   rc = idxPrintfPrepareStmt(dbm, &pIdxList, 0, "PRAGMA index_list=%Q", zTbl);
8677:   while( rc==SQLITE_OK && sqlite3_step(pIdxList)==SQLITE_ROW ){
8678:     int bMatch = 1;
8679:     IdxConstraint *pT = pTail;
8680:     sqlite3_stmt *pInfo = 0;
8681:     const char *zIdx = (const char*)sqlite3_column_text(pIdxList, 1);
8682: 
8683:     /* Zero the IdxConstraint.bFlag values in the pEq list */
8684:     for(pIter=pEq; pIter; pIter=pIter->pLink) pIter->bFlag = 0;
8685: 
8686:     rc = idxPrintfPrepareStmt(dbm, &pInfo, 0, "PRAGMA index_xInfo=%Q", zIdx);
8687:     while( rc==SQLITE_OK && sqlite3_step(pInfo)==SQLITE_ROW ){
8688:       int iIdx = sqlite3_column_int(pInfo, 0);
8689:       int iCol = sqlite3_column_int(pInfo, 1);
8690:       const char *zColl = (const char*)sqlite3_column_text(pInfo, 4);
8691: 
8692:       if( iIdx<nEq ){
8693:         for(pIter=pEq; pIter; pIter=pIter->pLink){
8694:           if( pIter->bFlag ) continue;
8695:           if( pIter->iCol!=iCol ) continue;
8696:           if( sqlite3_stricmp(pIter->zColl, zColl) ) continue;
8697:           pIter->bFlag = 1;
8698:           break;
8699:         }
8700:         if( pIter==0 ){
8701:           bMatch = 0;
8702:           break;
8703:         }
8704:       }else{
8705:         if( pT ){
8706:           if( pT->iCol!=iCol || sqlite3_stricmp(pT->zColl, zColl) ){
8707:             bMatch = 0;
8708:             break;
8709:           }
8710:           pT = pT->pLink;
8711:         }
8712:       }
8713:     }
8714:     idxFinalize(&rc, pInfo);
8715: 
8716:     if( rc==SQLITE_OK && bMatch ){
8717:       sqlite3_finalize(pIdxList);
8718:       return 1;
8719:     }
8720:   }
8721:   idxFinalize(&rc, pIdxList);
8722: 
8723:   *pRc = rc;
8724:   return 0;
8725: }
8726: 
8727: static int idxCreateFromCons(
8728:   sqlite3expert *p,
8729:   IdxScan *pScan,
8730:   IdxConstraint *pEq,
8731:   IdxConstraint *pTail
8732: ){
8733:   sqlite3 *dbm = p->dbm;
8734:   int rc = SQLITE_OK;
8735:   if( (pEq || pTail) && 0==idxFindCompatible(&rc, dbm, pScan, pEq, pTail) ){
8736:     IdxTable *pTab = pScan->pTab;
8737:     char *zCols = 0;
8738:     char *zIdx = 0;
8739:     IdxConstraint *pCons;
8740:     unsigned int h = 0;
8741:     const char *zFmt;
8742: 
8743:     for(pCons=pEq; pCons; pCons=pCons->pLink){
8744:       zCols = idxAppendColDefn(&rc, zCols, pTab, pCons);
8745:     }
8746:     for(pCons=pTail; pCons; pCons=pCons->pLink){
8747:       zCols = idxAppendColDefn(&rc, zCols, pTab, pCons);
8748:     }
8749: 
8750:     if( rc==SQLITE_OK ){
8751:       /* Hash the list of columns to come up with a name for the index */
8752:       const char *zTable = pScan->pTab->zName;
8753:       char *zName;                /* Index name */
8754:       int i;
8755:       for(i=0; zCols[i]; i++){
8756:         h += ((h<<3) + zCols[i]);
8757:       }
8758:       zName = sqlite3_mprintf("%s_idx_%08x", zTable, h);
8759:       if( zName==0 ){
8760:         rc = SQLITE_NOMEM;
8761:       }else{
8762:         if( idxIdentifierRequiresQuotes(zTable) ){
8763:           zFmt = "CREATE INDEX '%q' ON %Q(%s)";
8764:         }else{
8765:           zFmt = "CREATE INDEX %s ON %s(%s)";
8766:         }
8767:         zIdx = sqlite3_mprintf(zFmt, zName, zTable, zCols);
8768:         if( !zIdx ){
8769:           rc = SQLITE_NOMEM;
8770:         }else{
8771:           rc = sqlite3_exec(dbm, zIdx, 0, 0, p->pzErrmsg);
8772:           idxHashAdd(&rc, &p->hIdx, zName, zIdx);
8773:         }
8774:         sqlite3_free(zName);
8775:         sqlite3_free(zIdx);
8776:       }
8777:     }
8778: 
8779:     sqlite3_free(zCols);
8780:   }
8781:   return rc;
8782: }
8783: 
8784: /*
8785: ** Return true if list pList (linked by IdxConstraint.pLink) contains
8786: ** a constraint compatible with *p. Otherwise return false.
8787: */
8788: static int idxFindConstraint(IdxConstraint *pList, IdxConstraint *p){
8789:   IdxConstraint *pCmp;
8790:   for(pCmp=pList; pCmp; pCmp=pCmp->pLink){
8791:     if( p->iCol==pCmp->iCol ) return 1;
8792:   }
8793:   return 0;
8794: }
8795: 
8796: static int idxCreateFromWhere(
8797:   sqlite3expert *p,
8798:   IdxScan *pScan,                 /* Create indexes for this scan */
8799:   IdxConstraint *pTail            /* range/ORDER BY constraints for inclusion */
8800: ){
8801:   IdxConstraint *p1 = 0;
8802:   IdxConstraint *pCon;
8803:   int rc;
8804: 
8805:   /* Gather up all the == constraints. */
8806:   for(pCon=pScan->pEq; pCon; pCon=pCon->pNext){
8807:     if( !idxFindConstraint(p1, pCon) && !idxFindConstraint(pTail, pCon) ){
8808:       pCon->pLink = p1;
8809:       p1 = pCon;
8810:     }
8811:   }
8812: 
8813:   /* Create an index using the == constraints collected above. And the
8814:   ** range constraint/ORDER BY terms passed in by the caller, if any. */
8815:   rc = idxCreateFromCons(p, pScan, p1, pTail);
8816: 
8817:   /* If no range/ORDER BY passed by the caller, create a version of the
8818:   ** index for each range constraint.  */
8819:   if( pTail==0 ){
8820:     for(pCon=pScan->pRange; rc==SQLITE_OK && pCon; pCon=pCon->pNext){
8821:       assert( pCon->pLink==0 );
8822:       if( !idxFindConstraint(p1, pCon) && !idxFindConstraint(pTail, pCon) ){
8823:         rc = idxCreateFromCons(p, pScan, p1, pCon);
8824:       }
8825:     }
8826:   }
8827: 
8828:   return rc;
8829: }
8830: 
8831: /*
8832: ** Create candidate indexes in database [dbm] based on the data in
8833: ** linked-list pScan.
8834: */
8835: static int idxCreateCandidates(sqlite3expert *p){
8836:   int rc = SQLITE_OK;
8837:   IdxScan *pIter;
8838: 
8839:   for(pIter=p->pScan; pIter && rc==SQLITE_OK; pIter=pIter->pNextScan){
8840:     rc = idxCreateFromWhere(p, pIter, 0);
8841:     if( rc==SQLITE_OK && pIter->pOrder ){
8842:       rc = idxCreateFromWhere(p, pIter, pIter->pOrder);
8843:     }
8844:   }
8845: 
8846:   return rc;
8847: }
8848: 
8849: /*
8850: ** Free all elements of the linked list starting at pConstraint.
8851: */
8852: static void idxConstraintFree(IdxConstraint *pConstraint){
8853:   IdxConstraint *pNext;
8854:   IdxConstraint *p;
8855: 
8856:   for(p=pConstraint; p; p=pNext){
8857:     pNext = p->pNext;
8858:     sqlite3_free(p);
8859:   }
8860: }
8861: 
8862: /*
8863: ** Free all elements of the linked list starting from pScan up until pLast
8864: ** (pLast is not freed).
8865: */
8866: static void idxScanFree(IdxScan *pScan, IdxScan *pLast){
8867:   IdxScan *p;
8868:   IdxScan *pNext;
8869:   for(p=pScan; p!=pLast; p=pNext){
8870:     pNext = p->pNextScan;
8871:     idxConstraintFree(p->pOrder);
8872:     idxConstraintFree(p->pEq);
8873:     idxConstraintFree(p->pRange);
8874:     sqlite3_free(p);
8875:   }
8876: }
8877: 
8878: /*
8879: ** Free all elements of the linked list starting from pStatement up
8880: ** until pLast (pLast is not freed).
8881: */
8882: static void idxStatementFree(IdxStatement *pStatement, IdxStatement *pLast){
8883:   IdxStatement *p;
8884:   IdxStatement *pNext;
8885:   for(p=pStatement; p!=pLast; p=pNext){
8886:     pNext = p->pNext;
8887:     sqlite3_free(p->zEQP);
8888:     sqlite3_free(p->zIdx);
8889:     sqlite3_free(p);
8890:   }
8891: }
8892: 
8893: /*
8894: ** Free the linked list of IdxTable objects starting at pTab.
8895: */
8896: static void idxTableFree(IdxTable *pTab){
8897:   IdxTable *pIter;
8898:   IdxTable *pNext;
8899:   for(pIter=pTab; pIter; pIter=pNext){
8900:     pNext = pIter->pNext;
8901:     sqlite3_free(pIter);
8902:   }
8903: }
8904: 
8905: /*
8906: ** Free the linked list of IdxWrite objects starting at pTab.
8907: */
8908: static void idxWriteFree(IdxWrite *pTab){
8909:   IdxWrite *pIter;
8910:   IdxWrite *pNext;
8911:   for(pIter=pTab; pIter; pIter=pNext){
8912:     pNext = pIter->pNext;
8913:     sqlite3_free(pIter);
8914:   }
8915: }
8916: 
8917: 
8918: 
8919: /*
8920: ** This function is called after candidate indexes have been created. It
8921: ** runs all the queries to see which indexes they prefer, and populates
8922: ** IdxStatement.zIdx and IdxStatement.zEQP with the results.
8923: */
8924: int idxFindIndexes(
8925:   sqlite3expert *p,
8926:   char **pzErr                         /* OUT: Error message (sqlite3_malloc) */
8927: ){
8928:   IdxStatement *pStmt;
8929:   sqlite3 *dbm = p->dbm;
8930:   int rc = SQLITE_OK;
8931: 
8932:   IdxHash hIdx;
8933:   idxHashInit(&hIdx);
8934: 
8935:   for(pStmt=p->pStatement; rc==SQLITE_OK && pStmt; pStmt=pStmt->pNext){
8936:     IdxHashEntry *pEntry;
8937:     sqlite3_stmt *pExplain = 0;
8938:     idxHashClear(&hIdx);
8939:     rc = idxPrintfPrepareStmt(dbm, &pExplain, pzErr,
8940:         "EXPLAIN QUERY PLAN %s", pStmt->zSql
8941:     );
8942:     while( rc==SQLITE_OK && sqlite3_step(pExplain)==SQLITE_ROW ){
8943:       /* int iId = sqlite3_column_int(pExplain, 0); */
8944:       /* int iParent = sqlite3_column_int(pExplain, 1); */
8945:       /* int iNotUsed = sqlite3_column_int(pExplain, 2); */
8946:       const char *zDetail = (const char*)sqlite3_column_text(pExplain, 3);
8947:       int nDetail;
8948:       int i;
8949: 
8950:       if( !zDetail ) continue;
8951:       nDetail = STRLEN(zDetail);
8952: 
8953:       for(i=0; i<nDetail; i++){
8954:         const char *zIdx = 0;
8955:         if( i+13<nDetail && memcmp(&zDetail[i], " USING INDEX ", 13)==0 ){
8956:           zIdx = &zDetail[i+13];
8957:         }else if( i+22<nDetail
8958:             && memcmp(&zDetail[i], " USING COVERING INDEX ", 22)==0
8959:         ){
8960:           zIdx = &zDetail[i+22];
8961:         }
8962:         if( zIdx ){
8963:           const char *zSql;
8964:           int nIdx = 0;
8965:           while( zIdx[nIdx]!='\0' && (zIdx[nIdx]!=' ' || zIdx[nIdx+1]!='(') ){
8966:             nIdx++;
8967:           }
8968:           zSql = idxHashSearch(&p->hIdx, zIdx, nIdx);
8969:           if( zSql ){
8970:             idxHashAdd(&rc, &hIdx, zSql, 0);
8971:             if( rc ) goto find_indexes_out;
8972:           }
8973:           break;
8974:         }
8975:       }
8976: 
8977:       if( zDetail[0]!='-' ){
8978:         pStmt->zEQP = idxAppendText(&rc, pStmt->zEQP, "%s\n", zDetail);
8979:       }
8980:     }
8981: 
8982:     for(pEntry=hIdx.pFirst; pEntry; pEntry=pEntry->pNext){
8983:       pStmt->zIdx = idxAppendText(&rc, pStmt->zIdx, "%s;\n", pEntry->zKey);
8984:     }
8985: 
8986:     idxFinalize(&rc, pExplain);
8987:   }
8988: 
8989:  find_indexes_out:
8990:   idxHashClear(&hIdx);
8991:   return rc;
8992: }
8993: 
8994: static int idxAuthCallback(
8995:   void *pCtx,
8996:   int eOp,
8997:   const char *z3,
8998:   const char *z4,
8999:   const char *zDb,
9000:   const char *zTrigger
9001: ){
9002:   int rc = SQLITE_OK;
9003:   (void)z4;
9004:   (void)zTrigger;
9005:   if( eOp==SQLITE_INSERT || eOp==SQLITE_UPDATE || eOp==SQLITE_DELETE ){
9006:     if( sqlite3_stricmp(zDb, "main")==0 ){
9007:       sqlite3expert *p = (sqlite3expert*)pCtx;
9008:       IdxTable *pTab;
9009:       for(pTab=p->pTable; pTab; pTab=pTab->pNext){
9010:         if( 0==sqlite3_stricmp(z3, pTab->zName) ) break;
9011:       }
9012:       if( pTab ){
9013:         IdxWrite *pWrite;
9014:         for(pWrite=p->pWrite; pWrite; pWrite=pWrite->pNext){
9015:           if( pWrite->pTab==pTab && pWrite->eOp==eOp ) break;
9016:         }
9017:         if( pWrite==0 ){
9018:           pWrite = idxMalloc(&rc, sizeof(IdxWrite));
9019:           if( rc==SQLITE_OK ){
9020:             pWrite->pTab = pTab;
9021:             pWrite->eOp = eOp;
9022:             pWrite->pNext = p->pWrite;
9023:             p->pWrite = pWrite;
9024:           }
9025:         }
9026:       }
9027:     }
9028:   }
9029:   return rc;
9030: }
9031: 
9032: static int idxProcessOneTrigger(
9033:   sqlite3expert *p,
9034:   IdxWrite *pWrite,
9035:   char **pzErr
9036: ){
9037:   static const char *zInt = UNIQUE_TABLE_NAME;
9038:   static const char *zDrop = "DROP TABLE " UNIQUE_TABLE_NAME;
9039:   IdxTable *pTab = pWrite->pTab;
9040:   const char *zTab = pTab->zName;
9041:   const char *zSql =
9042:     "SELECT 'CREATE TEMP' || substr(sql, 7) FROM sqlite_schema "
9043:     "WHERE tbl_name = %Q AND type IN ('table', 'trigger') "
9044:     "ORDER BY type;";
9045:   sqlite3_stmt *pSelect = 0;
9046:   int rc = SQLITE_OK;
9047:   char *zWrite = 0;
9048: 
9049:   /* Create the table and its triggers in the temp schema */
9050:   rc = idxPrintfPrepareStmt(p->db, &pSelect, pzErr, zSql, zTab, zTab);
9051:   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSelect) ){
9052:     const char *zCreate = (const char*)sqlite3_column_text(pSelect, 0);
9053:     rc = sqlite3_exec(p->dbv, zCreate, 0, 0, pzErr);
9054:   }
9055:   idxFinalize(&rc, pSelect);
9056: 
9057:   /* Rename the table in the temp schema to zInt */
9058:   if( rc==SQLITE_OK ){
9059:     char *z = sqlite3_mprintf("ALTER TABLE temp.%Q RENAME TO %Q", zTab, zInt);
9060:     if( z==0 ){
9061:       rc = SQLITE_NOMEM;
9062:     }else{
9063:       rc = sqlite3_exec(p->dbv, z, 0, 0, pzErr);
9064:       sqlite3_free(z);
9065:     }
9066:   }
9067: 
9068:   switch( pWrite->eOp ){
9069:     case SQLITE_INSERT: {
9070:       int i;
9071:       zWrite = idxAppendText(&rc, zWrite, "INSERT INTO %Q VALUES(", zInt);
9072:       for(i=0; i<pTab->nCol; i++){
9073:         zWrite = idxAppendText(&rc, zWrite, "%s?", i==0 ? "" : ", ");
9074:       }
9075:       zWrite = idxAppendText(&rc, zWrite, ")");
9076:       break;
9077:     }
9078:     case SQLITE_UPDATE: {
9079:       int i;
9080:       zWrite = idxAppendText(&rc, zWrite, "UPDATE %Q SET ", zInt);
9081:       for(i=0; i<pTab->nCol; i++){
9082:         zWrite = idxAppendText(&rc, zWrite, "%s%Q=?", i==0 ? "" : ", ",
9083:             pTab->aCol[i].zName
9084:         );
9085:       }
9086:       break;
9087:     }
9088:     default: {
9089:       assert( pWrite->eOp==SQLITE_DELETE );
9090:       if( rc==SQLITE_OK ){
9091:         zWrite = sqlite3_mprintf("DELETE FROM %Q", zInt);
9092:         if( zWrite==0 ) rc = SQLITE_NOMEM;
9093:       }
9094:     }
9095:   }
9096: 
9097:   if( rc==SQLITE_OK ){
9098:     sqlite3_stmt *pX = 0;
9099:     rc = sqlite3_prepare_v2(p->dbv, zWrite, -1, &pX, 0);
9100:     idxFinalize(&rc, pX);
9101:     if( rc!=SQLITE_OK ){
9102:       idxDatabaseError(p->dbv, pzErr);
9103:     }
9104:   }
9105:   sqlite3_free(zWrite);
9106: 
9107:   if( rc==SQLITE_OK ){
9108:     rc = sqlite3_exec(p->dbv, zDrop, 0, 0, pzErr);
9109:   }
9110: 
9111:   return rc;
9112: }
9113: 
9114: static int idxProcessTriggers(sqlite3expert *p, char **pzErr){
9115:   int rc = SQLITE_OK;
9116:   IdxWrite *pEnd = 0;
9117:   IdxWrite *pFirst = p->pWrite;
9118: 
9119:   while( rc==SQLITE_OK && pFirst!=pEnd ){
9120:     IdxWrite *pIter;
9121:     for(pIter=pFirst; rc==SQLITE_OK && pIter!=pEnd; pIter=pIter->pNext){
9122:       rc = idxProcessOneTrigger(p, pIter, pzErr);
9123:     }
9124:     pEnd = pFirst;
9125:     pFirst = p->pWrite;
9126:   }
9127: 
9128:   return rc;
9129: }
9130: 
9131: 
9132: static int idxCreateVtabSchema(sqlite3expert *p, char **pzErrmsg){
9133:   int rc = idxRegisterVtab(p);
9134:   sqlite3_stmt *pSchema = 0;
9135: 
9136:   /* For each table in the main db schema:
9137:   **
9138:   **   1) Add an entry to the p->pTable list, and
9139:   **   2) Create the equivalent virtual table in dbv.
9140:   */
9141:   rc = idxPrepareStmt(p->db, &pSchema, pzErrmsg,
9142:       "SELECT type, name, sql, 1 FROM sqlite_schema "
9143:       "WHERE type IN ('table','view') AND name NOT LIKE 'sqlite_%%' "
9144:       " UNION ALL "
9145:       "SELECT type, name, sql, 2 FROM sqlite_schema "
9146:       "WHERE type = 'trigger'"
9147:       "  AND tbl_name IN(SELECT name FROM sqlite_schema WHERE type = 'view') "
9148:       "ORDER BY 4, 1"
9149:   );
9150:   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSchema) ){
9151:     const char *zType = (const char*)sqlite3_column_text(pSchema, 0);
9152:     const char *zName = (const char*)sqlite3_column_text(pSchema, 1);
9153:     const char *zSql = (const char*)sqlite3_column_text(pSchema, 2);
9154: 
9155:     if( zType[0]=='v' || zType[1]=='r' ){
9156:       rc = sqlite3_exec(p->dbv, zSql, 0, 0, pzErrmsg);
9157:     }else{
9158:       IdxTable *pTab;
9159:       rc = idxGetTableInfo(p->db, zName, &pTab, pzErrmsg);
9160:       if( rc==SQLITE_OK ){
9161:         int i;
9162:         char *zInner = 0;
9163:         char *zOuter = 0;
9164:         pTab->pNext = p->pTable;
9165:         p->pTable = pTab;
9166: 
9167:         /* The statement the vtab will pass to sqlite3_declare_vtab() */
9168:         zInner = idxAppendText(&rc, 0, "CREATE TABLE x(");
9169:         for(i=0; i<pTab->nCol; i++){
9170:           zInner = idxAppendText(&rc, zInner, "%s%Q COLLATE %s",
9171:               (i==0 ? "" : ", "), pTab->aCol[i].zName, pTab->aCol[i].zColl
9172:           );
9173:         }
9174:         zInner = idxAppendText(&rc, zInner, ")");
9175: 
9176:         /* The CVT statement to create the vtab */
9177:         zOuter = idxAppendText(&rc, 0,
9178:             "CREATE VIRTUAL TABLE %Q USING expert(%Q)", zName, zInner
9179:         );
9180:         if( rc==SQLITE_OK ){
9181:           rc = sqlite3_exec(p->dbv, zOuter, 0, 0, pzErrmsg);
9182:         }
9183:         sqlite3_free(zInner);
9184:         sqlite3_free(zOuter);
9185:       }
9186:     }
9187:   }
9188:   idxFinalize(&rc, pSchema);
9189:   return rc;
9190: }
9191: 
9192: struct IdxSampleCtx {
9193:   int iTarget;
9194:   double target;                  /* Target nRet/nRow value */
9195:   double nRow;                    /* Number of rows seen */
9196:   double nRet;                    /* Number of rows returned */
9197: };
9198: 
9199: static void idxSampleFunc(
9200:   sqlite3_context *pCtx,
9201:   int argc,
9202:   sqlite3_value **argv
9203: ){
9204:   struct IdxSampleCtx *p = (struct IdxSampleCtx*)sqlite3_user_data(pCtx);
9205:   int bRet;
9206: 
9207:   (void)argv;
9208:   assert( argc==0 );
9209:   if( p->nRow==0.0 ){
9210:     bRet = 1;
9211:   }else{
9212:     bRet = (p->nRet / p->nRow) <= p->target;
9213:     if( bRet==0 ){
9214:       unsigned short rnd;
9215:       sqlite3_randomness(2, (void*)&rnd);
9216:       bRet = ((int)rnd % 100) <= p->iTarget;
9217:     }
9218:   }
9219: 
9220:   sqlite3_result_int(pCtx, bRet);
9221:   p->nRow += 1.0;
9222:   p->nRet += (double)bRet;
9223: }
9224: 
9225: struct IdxRemCtx {
9226:   int nSlot;
9227:   struct IdxRemSlot {
9228:     int eType;                    /* SQLITE_NULL, INTEGER, REAL, TEXT, BLOB */
9229:     i64 iVal;                     /* SQLITE_INTEGER value */
9230:     double rVal;                  /* SQLITE_FLOAT value */
9231:     int nByte;                    /* Bytes of space allocated at z */
9232:     int n;                        /* Size of buffer z */
9233:     char *z;                      /* SQLITE_TEXT/BLOB value */
9234:   } aSlot[1];
9235: };
9236: 
9237: /*
9238: ** Implementation of scalar function rem().
9239: */
9240: static void idxRemFunc(
9241:   sqlite3_context *pCtx,
9242:   int argc,
9243:   sqlite3_value **argv
9244: ){
9245:   struct IdxRemCtx *p = (struct IdxRemCtx*)sqlite3_user_data(pCtx);
9246:   struct IdxRemSlot *pSlot;
9247:   int iSlot;
9248:   assert( argc==2 );
9249: 
9250:   iSlot = sqlite3_value_int(argv[0]);
9251:   assert( iSlot<=p->nSlot );
9252:   pSlot = &p->aSlot[iSlot];
9253: 
9254:   switch( pSlot->eType ){
9255:     case SQLITE_NULL:
9256:       /* no-op */
9257:       break;
9258: 
9259:     case SQLITE_INTEGER:
9260:       sqlite3_result_int64(pCtx, pSlot->iVal);
9261:       break;
9262: 
9263:     case SQLITE_FLOAT:
9264:       sqlite3_result_double(pCtx, pSlot->rVal);
9265:       break;
9266: 
9267:     case SQLITE_BLOB:
9268:       sqlite3_result_blob(pCtx, pSlot->z, pSlot->n, SQLITE_TRANSIENT);
9269:       break;
9270: 
9271:     case SQLITE_TEXT:
9272:       sqlite3_result_text(pCtx, pSlot->z, pSlot->n, SQLITE_TRANSIENT);
9273:       break;
9274:   }
9275: 
9276:   pSlot->eType = sqlite3_value_type(argv[1]);
9277:   switch( pSlot->eType ){
9278:     case SQLITE_NULL:
9279:       /* no-op */
9280:       break;
9281: 
9282:     case SQLITE_INTEGER:
9283:       pSlot->iVal = sqlite3_value_int64(argv[1]);
9284:       break;
9285: 
9286:     case SQLITE_FLOAT:
9287:       pSlot->rVal = sqlite3_value_double(argv[1]);
9288:       break;
9289: 
9290:     case SQLITE_BLOB:
9291:     case SQLITE_TEXT: {
9292:       int nByte = sqlite3_value_bytes(argv[1]);
9293:       if( nByte>pSlot->nByte ){
9294:         char *zNew = (char*)sqlite3_realloc(pSlot->z, nByte*2);
9295:         if( zNew==0 ){
9296:           sqlite3_result_error_nomem(pCtx);
9297:           return;
9298:         }
9299:         pSlot->nByte = nByte*2;
9300:         pSlot->z = zNew;
9301:       }
9302:       pSlot->n = nByte;
9303:       if( pSlot->eType==SQLITE_BLOB ){
9304:         memcpy(pSlot->z, sqlite3_value_blob(argv[1]), nByte);
9305:       }else{
9306:         memcpy(pSlot->z, sqlite3_value_text(argv[1]), nByte);
9307:       }
9308:       break;
9309:     }
9310:   }
9311: }
9312: 
9313: static int idxLargestIndex(sqlite3 *db, int *pnMax, char **pzErr){
9314:   int rc = SQLITE_OK;
9315:   const char *zMax =
9316:     "SELECT max(i.seqno) FROM "
9317:     "  sqlite_schema AS s, "
9318:     "  pragma_index_list(s.name) AS l, "
9319:     "  pragma_index_info(l.name) AS i "
9320:     "WHERE s.type = 'table'";
9321:   sqlite3_stmt *pMax = 0;
9322: 
9323:   *pnMax = 0;
9324:   rc = idxPrepareStmt(db, &pMax, pzErr, zMax);
9325:   if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pMax) ){
9326:     *pnMax = sqlite3_column_int(pMax, 0) + 1;
9327:   }
9328:   idxFinalize(&rc, pMax);
9329: 
9330:   return rc;
9331: }
9332: 
9333: static int idxPopulateOneStat1(
9334:   sqlite3expert *p,
9335:   sqlite3_stmt *pIndexXInfo,
9336:   sqlite3_stmt *pWriteStat,
9337:   const char *zTab,
9338:   const char *zIdx,
9339:   char **pzErr
9340: ){
9341:   char *zCols = 0;
9342:   char *zOrder = 0;
9343:   char *zQuery = 0;
9344:   int nCol = 0;
9345:   int i;
9346:   sqlite3_stmt *pQuery = 0;
9347:   int *aStat = 0;
9348:   int rc = SQLITE_OK;
9349: 
9350:   assert( p->iSample>0 );
9351: 
9352:   /* Formulate the query text */
9353:   sqlite3_bind_text(pIndexXInfo, 1, zIdx, -1, SQLITE_STATIC);
9354:   while( SQLITE_OK==rc && SQLITE_ROW==sqlite3_step(pIndexXInfo) ){
9355:     const char *zComma = zCols==0 ? "" : ", ";
9356:     const char *zName = (const char*)sqlite3_column_text(pIndexXInfo, 0);
9357:     const char *zColl = (const char*)sqlite3_column_text(pIndexXInfo, 1);
9358:     zCols = idxAppendText(&rc, zCols,
9359:         "%sx.%Q IS rem(%d, x.%Q) COLLATE %s", zComma, zName, nCol, zName, zColl
9360:     );
9361:     zOrder = idxAppendText(&rc, zOrder, "%s%d", zComma, ++nCol);
9362:   }
9363:   sqlite3_reset(pIndexXInfo);
9364:   if( rc==SQLITE_OK ){
9365:     if( p->iSample==100 ){
9366:       zQuery = sqlite3_mprintf(
9367:           "SELECT %s FROM %Q x ORDER BY %s", zCols, zTab, zOrder
9368:       );
9369:     }else{
9370:       zQuery = sqlite3_mprintf(
9371:           "SELECT %s FROM temp."UNIQUE_TABLE_NAME" x ORDER BY %s", zCols, zOrder
9372:       );
9373:     }
9374:   }
9375:   sqlite3_free(zCols);
9376:   sqlite3_free(zOrder);
9377: 
9378:   /* Formulate the query text */
9379:   if( rc==SQLITE_OK ){
9380:     sqlite3 *dbrem = (p->iSample==100 ? p->db : p->dbv);
9381:     rc = idxPrepareStmt(dbrem, &pQuery, pzErr, zQuery);
9382:   }
9383:   sqlite3_free(zQuery);
9384: 
9385:   if( rc==SQLITE_OK ){
9386:     aStat = (int*)idxMalloc(&rc, sizeof(int)*(nCol+1));
9387:   }
9388:   if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pQuery) ){
9389:     IdxHashEntry *pEntry;
9390:     char *zStat = 0;
9391:     for(i=0; i<=nCol; i++) aStat[i] = 1;
9392:     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pQuery) ){
9393:       aStat[0]++;
9394:       for(i=0; i<nCol; i++){
9395:         if( sqlite3_column_int(pQuery, i)==0 ) break;
9396:       }
9397:       for(/*no-op*/; i<nCol; i++){
9398:         aStat[i+1]++;
9399:       }
9400:     }
9401: 
9402:     if( rc==SQLITE_OK ){
9403:       int s0 = aStat[0];
9404:       zStat = sqlite3_mprintf("%d", s0);
9405:       if( zStat==0 ) rc = SQLITE_NOMEM;
9406:       for(i=1; rc==SQLITE_OK && i<=nCol; i++){
9407:         zStat = idxAppendText(&rc, zStat, " %d", (s0+aStat[i]/2) / aStat[i]);
9408:       }
9409:     }
9410: 
9411:     if( rc==SQLITE_OK ){
9412:       sqlite3_bind_text(pWriteStat, 1, zTab, -1, SQLITE_STATIC);
9413:       sqlite3_bind_text(pWriteStat, 2, zIdx, -1, SQLITE_STATIC);
9414:       sqlite3_bind_text(pWriteStat, 3, zStat, -1, SQLITE_STATIC);
9415:       sqlite3_step(pWriteStat);
9416:       rc = sqlite3_reset(pWriteStat);
9417:     }
9418: 
9419:     pEntry = idxHashFind(&p->hIdx, zIdx, STRLEN(zIdx));
9420:     if( pEntry ){
9421:       assert( pEntry->zVal2==0 );
9422:       pEntry->zVal2 = zStat;
9423:     }else{
9424:       sqlite3_free(zStat);
9425:     }
9426:   }
9427:   sqlite3_free(aStat);
9428:   idxFinalize(&rc, pQuery);
9429: 
9430:   return rc;
9431: }
9432: 
9433: static int idxBuildSampleTable(sqlite3expert *p, const char *zTab){
9434:   int rc;
9435:   char *zSql;
9436: 
9437:   rc = sqlite3_exec(p->dbv,"DROP TABLE IF EXISTS temp."UNIQUE_TABLE_NAME,0,0,0);
9438:   if( rc!=SQLITE_OK ) return rc;
9439: 
9440:   zSql = sqlite3_mprintf(
9441:       "CREATE TABLE temp." UNIQUE_TABLE_NAME " AS SELECT * FROM %Q", zTab
9442:   );
9443:   if( zSql==0 ) return SQLITE_NOMEM;
9444:   rc = sqlite3_exec(p->dbv, zSql, 0, 0, 0);
9445:   sqlite3_free(zSql);
9446: 
9447:   return rc;
9448: }
9449: 
9450: /*
9451: ** This function is called as part of sqlite3_expert_analyze(). Candidate
9452: ** indexes have already been created in database sqlite3expert.dbm, this
9453: ** function populates sqlite_stat1 table in the same database.
9454: **
9455: ** The stat1 data is generated by querying the
9456: */
9457: static int idxPopulateStat1(sqlite3expert *p, char **pzErr){
9458:   int rc = SQLITE_OK;
9459:   int nMax =0;
9460:   struct IdxRemCtx *pCtx = 0;
9461:   struct IdxSampleCtx samplectx;
9462:   int i;
9463:   i64 iPrev = -100000;
9464:   sqlite3_stmt *pAllIndex = 0;
9465:   sqlite3_stmt *pIndexXInfo = 0;
9466:   sqlite3_stmt *pWrite = 0;
9467: 
9468:   const char *zAllIndex =
9469:     "SELECT s.rowid, s.name, l.name FROM "
9470:     "  sqlite_schema AS s, "
9471:     "  pragma_index_list(s.name) AS l "
9472:     "WHERE s.type = 'table'";
9473:   const char *zIndexXInfo =
9474:     "SELECT name, coll FROM pragma_index_xinfo(?) WHERE key";
9475:   const char *zWrite = "INSERT INTO sqlite_stat1 VALUES(?, ?, ?)";
9476: 
9477:   /* If iSample==0, no sqlite_stat1 data is required. */
9478:   if( p->iSample==0 ) return SQLITE_OK;
9479: 
9480:   rc = idxLargestIndex(p->dbm, &nMax, pzErr);
9481:   if( nMax<=0 || rc!=SQLITE_OK ) return rc;
9482: 
9483:   rc = sqlite3_exec(p->dbm, "ANALYZE; PRAGMA writable_schema=1", 0, 0, 0);
9484: 
9485:   if( rc==SQLITE_OK ){
9486:     int nByte = sizeof(struct IdxRemCtx) + (sizeof(struct IdxRemSlot) * nMax);
9487:     pCtx = (struct IdxRemCtx*)idxMalloc(&rc, nByte);
9488:   }
9489: 
9490:   if( rc==SQLITE_OK ){
9491:     sqlite3 *dbrem = (p->iSample==100 ? p->db : p->dbv);
9492:     rc = sqlite3_create_function(
9493:         dbrem, "rem", 2, SQLITE_UTF8, (void*)pCtx, idxRemFunc, 0, 0
9494:     );
9495:   }
9496:   if( rc==SQLITE_OK ){
9497:     rc = sqlite3_create_function(
9498:         p->db, "sample", 0, SQLITE_UTF8, (void*)&samplectx, idxSampleFunc, 0, 0
9499:     );
9500:   }
9501: 
9502:   if( rc==SQLITE_OK ){
9503:     pCtx->nSlot = nMax+1;
9504:     rc = idxPrepareStmt(p->dbm, &pAllIndex, pzErr, zAllIndex);
9505:   }
9506:   if( rc==SQLITE_OK ){
9507:     rc = idxPrepareStmt(p->dbm, &pIndexXInfo, pzErr, zIndexXInfo);
9508:   }
9509:   if( rc==SQLITE_OK ){
9510:     rc = idxPrepareStmt(p->dbm, &pWrite, pzErr, zWrite);
9511:   }
9512: 
9513:   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pAllIndex) ){
9514:     i64 iRowid = sqlite3_column_int64(pAllIndex, 0);
9515:     const char *zTab = (const char*)sqlite3_column_text(pAllIndex, 1);
9516:     const char *zIdx = (const char*)sqlite3_column_text(pAllIndex, 2);
9517:     if( p->iSample<100 && iPrev!=iRowid ){
9518:       samplectx.target = (double)p->iSample / 100.0;
9519:       samplectx.iTarget = p->iSample;
9520:       samplectx.nRow = 0.0;
9521:       samplectx.nRet = 0.0;
9522:       rc = idxBuildSampleTable(p, zTab);
9523:       if( rc!=SQLITE_OK ) break;
9524:     }
9525:     rc = idxPopulateOneStat1(p, pIndexXInfo, pWrite, zTab, zIdx, pzErr);
9526:     iPrev = iRowid;
9527:   }
9528:   if( rc==SQLITE_OK && p->iSample<100 ){
9529:     rc = sqlite3_exec(p->dbv,
9530:         "DROP TABLE IF EXISTS temp." UNIQUE_TABLE_NAME, 0,0,0
9531:     );
9532:   }
9533: 
9534:   idxFinalize(&rc, pAllIndex);
9535:   idxFinalize(&rc, pIndexXInfo);
9536:   idxFinalize(&rc, pWrite);
9537: 
9538:   for(i=0; i<pCtx->nSlot; i++){
9539:     sqlite3_free(pCtx->aSlot[i].z);
9540:   }
9541:   sqlite3_free(pCtx);
9542: 
9543:   if( rc==SQLITE_OK ){
9544:     rc = sqlite3_exec(p->dbm, "ANALYZE sqlite_schema", 0, 0, 0);
9545:   }
9546: 
9547:   sqlite3_exec(p->db, "DROP TABLE IF EXISTS temp."UNIQUE_TABLE_NAME,0,0,0);
9548:   return rc;
9549: }
9550: 
9551: /*
9552: ** Allocate a new sqlite3expert object.
9553: */
9554: sqlite3expert *sqlite3_expert_new(sqlite3 *db, char **pzErrmsg){
9555:   int rc = SQLITE_OK;
9556:   sqlite3expert *pNew;
9557: 
9558:   pNew = (sqlite3expert*)idxMalloc(&rc, sizeof(sqlite3expert));
9559: 
9560:   /* Open two in-memory databases to work with. The "vtab database" (dbv)
9561:   ** will contain a virtual table corresponding to each real table in
9562:   ** the user database schema, and a copy of each view. It is used to
9563:   ** collect information regarding the WHERE, ORDER BY and other clauses
9564:   ** of the user's query.
9565:   */
9566:   if( rc==SQLITE_OK ){
9567:     pNew->db = db;
9568:     pNew->iSample = 100;
9569:     rc = sqlite3_open(":memory:", &pNew->dbv);
9570:   }
9571:   if( rc==SQLITE_OK ){
9572:     rc = sqlite3_open(":memory:", &pNew->dbm);
9573:     if( rc==SQLITE_OK ){
9574:       sqlite3_db_config(pNew->dbm, SQLITE_DBCONFIG_TRIGGER_EQP, 1, (int*)0);
9575:     }
9576:   }
9577: 
9578: 
9579:   /* Copy the entire schema of database [db] into [dbm]. */
9580:   if( rc==SQLITE_OK ){
9581:     sqlite3_stmt *pSql;
9582:     rc = idxPrintfPrepareStmt(pNew->db, &pSql, pzErrmsg,
9583:         "SELECT sql FROM sqlite_schema WHERE name NOT LIKE 'sqlite_%%'"
9584:         " AND sql NOT LIKE 'CREATE VIRTUAL %%'"
9585:     );
9586:     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSql) ){
9587:       const char *zSql = (const char*)sqlite3_column_text(pSql, 0);
9588:       rc = sqlite3_exec(pNew->dbm, zSql, 0, 0, pzErrmsg);
9589:     }
9590:     idxFinalize(&rc, pSql);
9591:   }
9592: 
9593:   /* Create the vtab schema */
9594:   if( rc==SQLITE_OK ){
9595:     rc = idxCreateVtabSchema(pNew, pzErrmsg);
9596:   }
9597: 
9598:   /* Register the auth callback with dbv */
9599:   if( rc==SQLITE_OK ){
9600:     sqlite3_set_authorizer(pNew->dbv, idxAuthCallback, (void*)pNew);
9601:   }
9602: 
9603:   /* If an error has occurred, free the new object and reutrn NULL. Otherwise,
9604:   ** return the new sqlite3expert handle.  */
9605:   if( rc!=SQLITE_OK ){
9606:     sqlite3_expert_destroy(pNew);
9607:     pNew = 0;
9608:   }
9609:   return pNew;
9610: }
9611: 
9612: /*
9613: ** Configure an sqlite3expert object.
9614: */
9615: int sqlite3_expert_config(sqlite3expert *p, int op, ...){
9616:   int rc = SQLITE_OK;
9617:   va_list ap;
9618:   va_start(ap, op);
9619:   switch( op ){
9620:     case EXPERT_CONFIG_SAMPLE: {
9621:       int iVal = va_arg(ap, int);
9622:       if( iVal<0 ) iVal = 0;
9623:       if( iVal>100 ) iVal = 100;
9624:       p->iSample = iVal;
9625:       break;
9626:     }
9627:     default:
9628:       rc = SQLITE_NOTFOUND;
9629:       break;
9630:   }
9631: 
9632:   va_end(ap);
9633:   return rc;
9634: }
9635: 
9636: /*
9637: ** Add an SQL statement to the analysis.
9638: */
9639: int sqlite3_expert_sql(
9640:   sqlite3expert *p,               /* From sqlite3_expert_new() */
9641:   const char *zSql,               /* SQL statement to add */
9642:   char **pzErr                    /* OUT: Error message (if any) */
9643: ){
9644:   IdxScan *pScanOrig = p->pScan;
9645:   IdxStatement *pStmtOrig = p->pStatement;
9646:   int rc = SQLITE_OK;
9647:   const char *zStmt = zSql;
9648: 
9649:   if( p->bRun ) return SQLITE_MISUSE;
9650: 
9651:   while( rc==SQLITE_OK && zStmt && zStmt[0] ){
9652:     sqlite3_stmt *pStmt = 0;
9653:     rc = sqlite3_prepare_v2(p->dbv, zStmt, -1, &pStmt, &zStmt);
9654:     if( rc==SQLITE_OK ){
9655:       if( pStmt ){
9656:         IdxStatement *pNew;
9657:         const char *z = sqlite3_sql(pStmt);
9658:         int n = STRLEN(z);
9659:         pNew = (IdxStatement*)idxMalloc(&rc, sizeof(IdxStatement) + n+1);
9660:         if( rc==SQLITE_OK ){
9661:           pNew->zSql = (char*)&pNew[1];
9662:           memcpy(pNew->zSql, z, n+1);
9663:           pNew->pNext = p->pStatement;
9664:           if( p->pStatement ) pNew->iId = p->pStatement->iId+1;
9665:           p->pStatement = pNew;
9666:         }
9667:         sqlite3_finalize(pStmt);
9668:       }
9669:     }else{
9670:       idxDatabaseError(p->dbv, pzErr);
9671:     }
9672:   }
9673: 
9674:   if( rc!=SQLITE_OK ){
9675:     idxScanFree(p->pScan, pScanOrig);
9676:     idxStatementFree(p->pStatement, pStmtOrig);
9677:     p->pScan = pScanOrig;
9678:     p->pStatement = pStmtOrig;
9679:   }
9680: 
9681:   return rc;
9682: }
9683: 
9684: int sqlite3_expert_analyze(sqlite3expert *p, char **pzErr){
9685:   int rc;
9686:   IdxHashEntry *pEntry;
9687: 
9688:   /* Do trigger processing to collect any extra IdxScan structures */
9689:   rc = idxProcessTriggers(p, pzErr);
9690: 
9691:   /* Create candidate indexes within the in-memory database file */
9692:   if( rc==SQLITE_OK ){
9693:     rc = idxCreateCandidates(p);
9694:   }
9695: 
9696:   /* Generate the stat1 data */
9697:   if( rc==SQLITE_OK ){
9698:     rc = idxPopulateStat1(p, pzErr);
9699:   }
9700: 
9701:   /* Formulate the EXPERT_REPORT_CANDIDATES text */
9702:   for(pEntry=p->hIdx.pFirst; pEntry; pEntry=pEntry->pNext){
9703:     p->zCandidates = idxAppendText(&rc, p->zCandidates,
9704:         "%s;%s%s\n", pEntry->zVal,
9705:         pEntry->zVal2 ? " -- stat1: " : "", pEntry->zVal2
9706:     );
9707:   }
9708: 
9709:   /* Figure out which of the candidate indexes are preferred by the query
9710:   ** planner and report the results to the user.  */
9711:   if( rc==SQLITE_OK ){
9712:     rc = idxFindIndexes(p, pzErr);
9713:   }
9714: 
9715:   if( rc==SQLITE_OK ){
9716:     p->bRun = 1;
9717:   }
9718:   return rc;
9719: }
9720: 
9721: /*
9722: ** Return the total number of statements that have been added to this
9723: ** sqlite3expert using sqlite3_expert_sql().
9724: */
9725: int sqlite3_expert_count(sqlite3expert *p){
9726:   int nRet = 0;
9727:   if( p->pStatement ) nRet = p->pStatement->iId+1;
9728:   return nRet;
9729: }
9730: 
9731: /*
9732: ** Return a component of the report.
9733: */
9734: const char *sqlite3_expert_report(sqlite3expert *p, int iStmt, int eReport){
9735:   const char *zRet = 0;
9736:   IdxStatement *pStmt;
9737: 
9738:   if( p->bRun==0 ) return 0;
9739:   for(pStmt=p->pStatement; pStmt && pStmt->iId!=iStmt; pStmt=pStmt->pNext);
9740:   switch( eReport ){
9741:     case EXPERT_REPORT_SQL:
9742:       if( pStmt ) zRet = pStmt->zSql;
9743:       break;
9744:     case EXPERT_REPORT_INDEXES:
9745:       if( pStmt ) zRet = pStmt->zIdx;
9746:       break;
9747:     case EXPERT_REPORT_PLAN:
9748:       if( pStmt ) zRet = pStmt->zEQP;
9749:       break;
9750:     case EXPERT_REPORT_CANDIDATES:
9751:       zRet = p->zCandidates;
9752:       break;
9753:   }
9754:   return zRet;
9755: }
9756: 
9757: /*
9758: ** Free an sqlite3expert object.
9759: */
9760: void sqlite3_expert_destroy(sqlite3expert *p){
9761:   if( p ){
9762:     sqlite3_close(p->dbm);
9763:     sqlite3_close(p->dbv);
9764:     idxScanFree(p->pScan, 0);
9765:     idxStatementFree(p->pStatement, 0);
9766:     idxTableFree(p->pTable);
9767:     idxWriteFree(p->pWrite);
9768:     idxHashClear(&p->hIdx);
9769:     sqlite3_free(p->zCandidates);
9770:     sqlite3_free(p);
9771:   }
9772: }
9773: 
9774: #endif /* ifndef SQLITE_OMIT_VIRTUALTABLE */
9775: 
9776: /************************* End ../ext/expert/sqlite3expert.c ********************/
9777: 
9778: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)
9779: /************************* Begin ../ext/misc/dbdata.c ******************/
9780: /*
9781: ** 2019-04-17
9782: **
9783: ** The author disclaims copyright to this source code.  In place of
9784: ** a legal notice, here is a blessing:
9785: **
9786: **    May you do good and not evil.
9787: **    May you find forgiveness for yourself and forgive others.
9788: **    May you share freely, never taking more than you give.
9789: **
9790: ******************************************************************************
9791: **
9792: ** This file contains an implementation of two eponymous virtual tables,
9793: ** "sqlite_dbdata" and "sqlite_dbptr". Both modules require that the
9794: ** "sqlite_dbpage" eponymous virtual table be available.
9795: **
9796: ** SQLITE_DBDATA:
9797: **   sqlite_dbdata is used to extract data directly from a database b-tree
9798: **   page and its associated overflow pages, bypassing the b-tree layer.
9799: **   The table schema is equivalent to:
9800: **
9801: **     CREATE TABLE sqlite_dbdata(
9802: **       pgno INTEGER,
9803: **       cell INTEGER,
9804: **       field INTEGER,
9805: **       value ANY,
9806: **       schema TEXT HIDDEN
9807: **     );
9808: **
9809: **   IMPORTANT: THE VIRTUAL TABLE SCHEMA ABOVE IS SUBJECT TO CHANGE. IN THE
9810: **   FUTURE NEW NON-HIDDEN COLUMNS MAY BE ADDED BETWEEN "value" AND
9811: **   "schema".
9812: **
9813: **   Each page of the database is inspected. If it cannot be interpreted as
9814: **   a b-tree page, or if it is a b-tree page containing 0 entries, the
9815: **   sqlite_dbdata table contains no rows for that page.  Otherwise, the
9816: **   table contains one row for each field in the record associated with
9817: **   each cell on the page. For intkey b-trees, the key value is stored in
9818: **   field -1.
9819: **
9820: **   For example, for the database:
9821: **
9822: **     CREATE TABLE t1(a, b);     -- root page is page 2
9823: **     INSERT INTO t1(rowid, a, b) VALUES(5, 'v', 'five');
9824: **     INSERT INTO t1(rowid, a, b) VALUES(10, 'x', 'ten');
9825: **
9826: **   the sqlite_dbdata table contains, as well as from entries related to
9827: **   page 1, content equivalent to:
9828: **
9829: **     INSERT INTO sqlite_dbdata(pgno, cell, field, value) VALUES
9830: **         (2, 0, -1, 5     ),
9831: **         (2, 0,  0, 'v'   ),
9832: **         (2, 0,  1, 'five'),
9833: **         (2, 1, -1, 10    ),
9834: **         (2, 1,  0, 'x'   ),
9835: **         (2, 1,  1, 'ten' );
9836: **
9837: **   If database corruption is encountered, this module does not report an
9838: **   error. Instead, it attempts to extract as much data as possible and
9839: **   ignores the corruption.
9840: **
9841: ** SQLITE_DBPTR:
9842: **   The sqlite_dbptr table has the following schema:
9843: **
9844: **     CREATE TABLE sqlite_dbptr(
9845: **       pgno INTEGER,
9846: **       child INTEGER,
9847: **       schema TEXT HIDDEN
9848: **     );
9849: **
9850: **   It contains one entry for each b-tree pointer between a parent and
9851: **   child page in the database.
9852: */
9853: #if !defined(SQLITEINT_H)
9854: /* #include "sqlite3ext.h" */
9855: 
9856: /* typedef unsigned char u8; */
9857: 
9858: #endif
9859: SQLITE_EXTENSION_INIT1
9860: #include <string.h>
9861: #include <assert.h>
9862: 
9863: #define DBDATA_PADDING_BYTES 100
9864: 
9865: typedef struct DbdataTable DbdataTable;
9866: typedef struct DbdataCursor DbdataCursor;
9867: 
9868: /* Cursor object */
9869: struct DbdataCursor {
9870:   sqlite3_vtab_cursor base;       /* Base class.  Must be first */
9871:   sqlite3_stmt *pStmt;            /* For fetching database pages */
9872: 
9873:   int iPgno;                      /* Current page number */
9874:   u8 *aPage;                      /* Buffer containing page */
9875:   int nPage;                      /* Size of aPage[] in bytes */
9876:   int nCell;                      /* Number of cells on aPage[] */
9877:   int iCell;                      /* Current cell number */
9878:   int bOnePage;                   /* True to stop after one page */
9879:   int szDb;
9880:   sqlite3_int64 iRowid;
9881: 
9882:   /* Only for the sqlite_dbdata table */
9883:   u8 *pRec;                       /* Buffer containing current record */
9884:   int nRec;                       /* Size of pRec[] in bytes */
9885:   int nHdr;                       /* Size of header in bytes */
9886:   int iField;                     /* Current field number */
9887:   u8 *pHdrPtr;
9888:   u8 *pPtr;
9889: 
9890:   sqlite3_int64 iIntkey;          /* Integer key value */
9891: };
9892: 
9893: /* Table object */
9894: struct DbdataTable {
9895:   sqlite3_vtab base;              /* Base class.  Must be first */
9896:   sqlite3 *db;                    /* The database connection */
9897:   sqlite3_stmt *pStmt;            /* For fetching database pages */
9898:   int bPtr;                       /* True for sqlite3_dbptr table */
9899: };
9900: 
9901: /* Column and schema definitions for sqlite_dbdata */
9902: #define DBDATA_COLUMN_PGNO        0
9903: #define DBDATA_COLUMN_CELL        1
9904: #define DBDATA_COLUMN_FIELD       2
9905: #define DBDATA_COLUMN_VALUE       3
9906: #define DBDATA_COLUMN_SCHEMA      4
9907: #define DBDATA_SCHEMA             \
9908:       "CREATE TABLE x("           \
9909:       "  pgno INTEGER,"           \
9910:       "  cell INTEGER,"           \
9911:       "  field INTEGER,"          \
9912:       "  value ANY,"              \
9913:       "  schema TEXT HIDDEN"      \
9914:       ")"
9915: 
9916: /* Column and schema definitions for sqlite_dbptr */
9917: #define DBPTR_COLUMN_PGNO         0
9918: #define DBPTR_COLUMN_CHILD        1
9919: #define DBPTR_COLUMN_SCHEMA       2
9920: #define DBPTR_SCHEMA              \
9921:       "CREATE TABLE x("           \
9922:       "  pgno INTEGER,"           \
9923:       "  child INTEGER,"          \
9924:       "  schema TEXT HIDDEN"      \
9925:       ")"
9926: 
9927: /*
9928: ** Connect to an sqlite_dbdata (pAux==0) or sqlite_dbptr (pAux!=0) virtual
9929: ** table.
9930: */
9931: static int dbdataConnect(
9932:   sqlite3 *db,
9933:   void *pAux,
9934:   int argc, const char *const*argv,
9935:   sqlite3_vtab **ppVtab,
9936:   char **pzErr
9937: ){
9938:   DbdataTable *pTab = 0;
9939:   int rc = sqlite3_declare_vtab(db, pAux ? DBPTR_SCHEMA : DBDATA_SCHEMA);
9940: 
9941:   if( rc==SQLITE_OK ){
9942:     pTab = (DbdataTable*)sqlite3_malloc64(sizeof(DbdataTable));
9943:     if( pTab==0 ){
9944:       rc = SQLITE_NOMEM;
9945:     }else{
9946:       memset(pTab, 0, sizeof(DbdataTable));
9947:       pTab->db = db;
9948:       pTab->bPtr = (pAux!=0);
9949:     }
9950:   }
9951: 
9952:   *ppVtab = (sqlite3_vtab*)pTab;
9953:   return rc;
9954: }
9955: 
9956: /*
9957: ** Disconnect from or destroy a sqlite_dbdata or sqlite_dbptr virtual table.
9958: */
9959: static int dbdataDisconnect(sqlite3_vtab *pVtab){
9960:   DbdataTable *pTab = (DbdataTable*)pVtab;
9961:   if( pTab ){
9962:     sqlite3_finalize(pTab->pStmt);
9963:     sqlite3_free(pVtab);
9964:   }
9965:   return SQLITE_OK;
9966: }
9967: 
9968: /*
9969: ** This function interprets two types of constraints:
9970: **
9971: **       schema=?
9972: **       pgno=?
9973: **
9974: ** If neither are present, idxNum is set to 0. If schema=? is present,
9975: ** the 0x01 bit in idxNum is set. If pgno=? is present, the 0x02 bit
9976: ** in idxNum is set.
9977: **
9978: ** If both parameters are present, schema is in position 0 and pgno in
9979: ** position 1.
9980: */
9981: static int dbdataBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdx){
9982:   DbdataTable *pTab = (DbdataTable*)tab;
9983:   int i;
9984:   int iSchema = -1;
9985:   int iPgno = -1;
9986:   int colSchema = (pTab->bPtr ? DBPTR_COLUMN_SCHEMA : DBDATA_COLUMN_SCHEMA);
9987: 
9988:   for(i=0; i<pIdx->nConstraint; i++){
9989:     struct sqlite3_index_constraint *p = &pIdx->aConstraint[i];
9990:     if( p->op==SQLITE_INDEX_CONSTRAINT_EQ ){
9991:       if( p->iColumn==colSchema ){
9992:         if( p->usable==0 ) return SQLITE_CONSTRAINT;
9993:         iSchema = i;
9994:       }
9995:       if( p->iColumn==DBDATA_COLUMN_PGNO && p->usable ){
9996:         iPgno = i;
9997:       }
9998:     }
9999:   }
10000: 
10001:   if( iSchema>=0 ){
10002:     pIdx->aConstraintUsage[iSchema].argvIndex = 1;
10003:     pIdx->aConstraintUsage[iSchema].omit = 1;
10004:   }
10005:   if( iPgno>=0 ){
10006:     pIdx->aConstraintUsage[iPgno].argvIndex = 1 + (iSchema>=0);
10007:     pIdx->aConstraintUsage[iPgno].omit = 1;
10008:     pIdx->estimatedCost = 100;
10009:     pIdx->estimatedRows =  50;
10010: 
10011:     if( pTab->bPtr==0 && pIdx->nOrderBy && pIdx->aOrderBy[0].desc==0 ){
10012:       int iCol = pIdx->aOrderBy[0].iColumn;
10013:       if( pIdx->nOrderBy==1 ){
10014:         pIdx->orderByConsumed = (iCol==0 || iCol==1);
10015:       }else if( pIdx->nOrderBy==2 && pIdx->aOrderBy[1].desc==0 && iCol==0 ){
10016:         pIdx->orderByConsumed = (pIdx->aOrderBy[1].iColumn==1);
10017:       }
10018:     }
10019: 
10020:   }else{
10021:     pIdx->estimatedCost = 100000000;
10022:     pIdx->estimatedRows = 1000000000;
10023:   }
10024:   pIdx->idxNum = (iSchema>=0 ? 0x01 : 0x00) | (iPgno>=0 ? 0x02 : 0x00);
10025:   return SQLITE_OK;
10026: }
10027: 
10028: /*
10029: ** Open a new sqlite_dbdata or sqlite_dbptr cursor.
10030: */
10031: static int dbdataOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){
10032:   DbdataCursor *pCsr;
10033: 
10034:   pCsr = (DbdataCursor*)sqlite3_malloc64(sizeof(DbdataCursor));
10035:   if( pCsr==0 ){
10036:     return SQLITE_NOMEM;
10037:   }else{
10038:     memset(pCsr, 0, sizeof(DbdataCursor));
10039:     pCsr->base.pVtab = pVTab;
10040:   }
10041: 
10042:   *ppCursor = (sqlite3_vtab_cursor *)pCsr;
10043:   return SQLITE_OK;
10044: }
10045: 
10046: /*
10047: ** Restore a cursor object to the state it was in when first allocated
10048: ** by dbdataOpen().
10049: */
10050: static void dbdataResetCursor(DbdataCursor *pCsr){
10051:   DbdataTable *pTab = (DbdataTable*)(pCsr->base.pVtab);
10052:   if( pTab->pStmt==0 ){
10053:     pTab->pStmt = pCsr->pStmt;
10054:   }else{
10055:     sqlite3_finalize(pCsr->pStmt);
10056:   }
10057:   pCsr->pStmt = 0;
10058:   pCsr->iPgno = 1;
10059:   pCsr->iCell = 0;
10060:   pCsr->iField = 0;
10061:   pCsr->bOnePage = 0;
10062:   sqlite3_free(pCsr->aPage);
10063:   sqlite3_free(pCsr->pRec);
10064:   pCsr->pRec = 0;
10065:   pCsr->aPage = 0;
10066: }
10067: 
10068: /*
10069: ** Close an sqlite_dbdata or sqlite_dbptr cursor.
10070: */
10071: static int dbdataClose(sqlite3_vtab_cursor *pCursor){
10072:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;
10073:   dbdataResetCursor(pCsr);
10074:   sqlite3_free(pCsr);
10075:   return SQLITE_OK;
10076: }
10077: 
10078: /*
10079: ** Utility methods to decode 16 and 32-bit big-endian unsigned integers.
10080: */
10081: static unsigned int get_uint16(unsigned char *a){
10082:   return (a[0]<<8)|a[1];
10083: }
10084: static unsigned int get_uint32(unsigned char *a){
10085:   return ((unsigned int)a[0]<<24)
10086:        | ((unsigned int)a[1]<<16)
10087:        | ((unsigned int)a[2]<<8)
10088:        | ((unsigned int)a[3]);
10089: }
10090: 
10091: /*
10092: ** Load page pgno from the database via the sqlite_dbpage virtual table.
10093: ** If successful, set (*ppPage) to point to a buffer containing the page
10094: ** data, (*pnPage) to the size of that buffer in bytes and return
10095: ** SQLITE_OK. In this case it is the responsibility of the caller to
10096: ** eventually free the buffer using sqlite3_free().
10097: **
10098: ** Or, if an error occurs, set both (*ppPage) and (*pnPage) to 0 and
10099: ** return an SQLite error code.
10100: */
10101: static int dbdataLoadPage(
10102:   DbdataCursor *pCsr,             /* Cursor object */
10103:   unsigned int pgno,              /* Page number of page to load */
10104:   u8 **ppPage,                    /* OUT: pointer to page buffer */
10105:   int *pnPage                     /* OUT: Size of (*ppPage) in bytes */
10106: ){
10107:   int rc2;
10108:   int rc = SQLITE_OK;
10109:   sqlite3_stmt *pStmt = pCsr->pStmt;
10110: 
10111:   *ppPage = 0;
10112:   *pnPage = 0;
10113:   sqlite3_bind_int64(pStmt, 2, pgno);
10114:   if( SQLITE_ROW==sqlite3_step(pStmt) ){
10115:     int nCopy = sqlite3_column_bytes(pStmt, 0);
10116:     if( nCopy>0 ){
10117:       u8 *pPage;
10118:       pPage = (u8*)sqlite3_malloc64(nCopy + DBDATA_PADDING_BYTES);
10119:       if( pPage==0 ){
10120:         rc = SQLITE_NOMEM;
10121:       }else{
10122:         const u8 *pCopy = sqlite3_column_blob(pStmt, 0);
10123:         memcpy(pPage, pCopy, nCopy);
10124:         memset(&pPage[nCopy], 0, DBDATA_PADDING_BYTES);
10125:       }
10126:       *ppPage = pPage;
10127:       *pnPage = nCopy;
10128:     }
10129:   }
10130:   rc2 = sqlite3_reset(pStmt);
10131:   if( rc==SQLITE_OK ) rc = rc2;
10132: 
10133:   return rc;
10134: }
10135: 
10136: /*
10137: ** Read a varint.  Put the value in *pVal and return the number of bytes.
10138: */
10139: static int dbdataGetVarint(const u8 *z, sqlite3_int64 *pVal){
10140:   sqlite3_int64 v = 0;
10141:   int i;
10142:   for(i=0; i<8; i++){
10143:     v = (v<<7) + (z[i]&0x7f);
10144:     if( (z[i]&0x80)==0 ){ *pVal = v; return i+1; }
10145:   }
10146:   v = (v<<8) + (z[i]&0xff);
10147:   *pVal = v;
10148:   return 9;
10149: }
10150: 
10151: /*
10152: ** Return the number of bytes of space used by an SQLite value of type
10153: ** eType.
10154: */
10155: static int dbdataValueBytes(int eType){
10156:   switch( eType ){
10157:     case 0: case 8: case 9:
10158:     case 10: case 11:
10159:       return 0;
10160:     case 1:
10161:       return 1;
10162:     case 2:
10163:       return 2;
10164:     case 3:
10165:       return 3;
10166:     case 4:
10167:       return 4;
10168:     case 5:
10169:       return 6;
10170:     case 6:
10171:     case 7:
10172:       return 8;
10173:     default:
10174:       if( eType>0 ){
10175:         return ((eType-12) / 2);
10176:       }
10177:       return 0;
10178:   }
10179: }
10180: 
10181: /*
10182: ** Load a value of type eType from buffer pData and use it to set the
10183: ** result of context object pCtx.
10184: */
10185: static void dbdataValue(
10186:   sqlite3_context *pCtx,
10187:   int eType,
10188:   u8 *pData,
10189:   int nData
10190: ){
10191:   if( eType>=0 && dbdataValueBytes(eType)<=nData ){
10192:     switch( eType ){
10193:       case 0:
10194:       case 10:
10195:       case 11:
10196:         sqlite3_result_null(pCtx);
10197:         break;
10198: 
10199:       case 8:
10200:         sqlite3_result_int(pCtx, 0);
10201:         break;
10202:       case 9:
10203:         sqlite3_result_int(pCtx, 1);
10204:         break;
10205: 
10206:       case 1: case 2: case 3: case 4: case 5: case 6: case 7: {
10207:         sqlite3_uint64 v = (signed char)pData[0];
10208:         pData++;
10209:         switch( eType ){
10210:           case 7:
10211:           case 6:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;
10212:           case 5:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;
10213:           case 4:  v = (v<<8) + pData[0];  pData++;
10214:           case 3:  v = (v<<8) + pData[0];  pData++;
10215:           case 2:  v = (v<<8) + pData[0];  pData++;
10216:         }
10217: 
10218:         if( eType==7 ){
10219:           double r;
10220:           memcpy(&r, &v, sizeof(r));
10221:           sqlite3_result_double(pCtx, r);
10222:         }else{
10223:           sqlite3_result_int64(pCtx, (sqlite3_int64)v);
10224:         }
10225:         break;
10226:       }
10227: 
10228:       default: {
10229:         int n = ((eType-12) / 2);
10230:         if( eType % 2 ){
10231:           sqlite3_result_text(pCtx, (const char*)pData, n, SQLITE_TRANSIENT);
10232:         }else{
10233:           sqlite3_result_blob(pCtx, pData, n, SQLITE_TRANSIENT);
10234:         }
10235:       }
10236:     }
10237:   }
10238: }
10239: 
10240: /*
10241: ** Move an sqlite_dbdata or sqlite_dbptr cursor to the next entry.
10242: */
10243: static int dbdataNext(sqlite3_vtab_cursor *pCursor){
10244:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;
10245:   DbdataTable *pTab = (DbdataTable*)pCursor->pVtab;
10246: 
10247:   pCsr->iRowid++;
10248:   while( 1 ){
10249:     int rc;
10250:     int iOff = (pCsr->iPgno==1 ? 100 : 0);
10251:     int bNextPage = 0;
10252: 
10253:     if( pCsr->aPage==0 ){
10254:       while( 1 ){
10255:         if( pCsr->bOnePage==0 && pCsr->iPgno>pCsr->szDb ) return SQLITE_OK;
10256:         rc = dbdataLoadPage(pCsr, pCsr->iPgno, &pCsr->aPage, &pCsr->nPage);
10257:         if( rc!=SQLITE_OK ) return rc;
10258:         if( pCsr->aPage ) break;
10259:         pCsr->iPgno++;
10260:       }
10261:       pCsr->iCell = pTab->bPtr ? -2 : 0;
10262:       pCsr->nCell = get_uint16(&pCsr->aPage[iOff+3]);
10263:     }
10264: 
10265:     if( pTab->bPtr ){
10266:       if( pCsr->aPage[iOff]!=0x02 && pCsr->aPage[iOff]!=0x05 ){
10267:         pCsr->iCell = pCsr->nCell;
10268:       }
10269:       pCsr->iCell++;
10270:       if( pCsr->iCell>=pCsr->nCell ){
10271:         sqlite3_free(pCsr->aPage);
10272:         pCsr->aPage = 0;
10273:         if( pCsr->bOnePage ) return SQLITE_OK;
10274:         pCsr->iPgno++;
10275:       }else{
10276:         return SQLITE_OK;
10277:       }
10278:     }else{
10279:       /* If there is no record loaded, load it now. */
10280:       if( pCsr->pRec==0 ){
10281:         int bHasRowid = 0;
10282:         int nPointer = 0;
10283:         sqlite3_int64 nPayload = 0;
10284:         sqlite3_int64 nHdr = 0;
10285:         int iHdr;
10286:         int U, X;
10287:         int nLocal;
10288: 
10289:         switch( pCsr->aPage[iOff] ){
10290:           case 0x02:
10291:             nPointer = 4;
10292:             break;
10293:           case 0x0a:
10294:             break;
10295:           case 0x0d:
10296:             bHasRowid = 1;
10297:             break;
10298:           default:
10299:             /* This is not a b-tree page with records on it. Continue. */
10300:             pCsr->iCell = pCsr->nCell;
10301:             break;
10302:         }
10303: 
10304:         if( pCsr->iCell>=pCsr->nCell ){
10305:           bNextPage = 1;
10306:         }else{
10307: 
10308:           iOff += 8 + nPointer + pCsr->iCell*2;
10309:           if( iOff>pCsr->nPage ){
10310:             bNextPage = 1;
10311:           }else{
10312:             iOff = get_uint16(&pCsr->aPage[iOff]);
10313:           }
10314: 
10315:           /* For an interior node cell, skip past the child-page number */
10316:           iOff += nPointer;
10317: 
10318:           /* Load the "byte of payload including overflow" field */
10319:           if( bNextPage || iOff>pCsr->nPage ){
10320:             bNextPage = 1;
10321:           }else{
10322:             iOff += dbdataGetVarint(&pCsr->aPage[iOff], &nPayload);
10323:           }
10324: 
10325:           /* If this is a leaf intkey cell, load the rowid */
10326:           if( bHasRowid && !bNextPage && iOff<pCsr->nPage ){
10327:             iOff += dbdataGetVarint(&pCsr->aPage[iOff], &pCsr->iIntkey);
10328:           }
10329: 
10330:           /* Figure out how much data to read from the local page */
10331:           U = pCsr->nPage;
10332:           if( bHasRowid ){
10333:             X = U-35;
10334:           }else{
10335:             X = ((U-12)*64/255)-23;
10336:           }
10337:           if( nPayload<=X ){
10338:             nLocal = nPayload;
10339:           }else{
10340:             int M, K;
10341:             M = ((U-12)*32/255)-23;
10342:             K = M+((nPayload-M)%(U-4));
10343:             if( K<=X ){
10344:               nLocal = K;
10345:             }else{
10346:               nLocal = M;
10347:             }
10348:           }
10349: 
10350:           if( bNextPage || nLocal+iOff>pCsr->nPage ){
10351:             bNextPage = 1;
10352:           }else{
10353: 
10354:             /* Allocate space for payload. And a bit more to catch small buffer
10355:             ** overruns caused by attempting to read a varint or similar from
10356:             ** near the end of a corrupt record.  */
10357:             pCsr->pRec = (u8*)sqlite3_malloc64(nPayload+DBDATA_PADDING_BYTES);
10358:             if( pCsr->pRec==0 ) return SQLITE_NOMEM;
10359:             memset(pCsr->pRec, 0, nPayload+DBDATA_PADDING_BYTES);
10360:             pCsr->nRec = nPayload;
10361: 
10362:             /* Load the nLocal bytes of payload */
10363:             memcpy(pCsr->pRec, &pCsr->aPage[iOff], nLocal);
10364:             iOff += nLocal;
10365: 
10366:             /* Load content from overflow pages */
10367:             if( nPayload>nLocal ){
10368:               sqlite3_int64 nRem = nPayload - nLocal;
10369:               unsigned int pgnoOvfl = get_uint32(&pCsr->aPage[iOff]);
10370:               while( nRem>0 ){
10371:                 u8 *aOvfl = 0;
10372:                 int nOvfl = 0;
10373:                 int nCopy;
10374:                 rc = dbdataLoadPage(pCsr, pgnoOvfl, &aOvfl, &nOvfl);
10375:                 assert( rc!=SQLITE_OK || aOvfl==0 || nOvfl==pCsr->nPage );
10376:                 if( rc!=SQLITE_OK ) return rc;
10377:                 if( aOvfl==0 ) break;
10378: 
10379:                 nCopy = U-4;
10380:                 if( nCopy>nRem ) nCopy = nRem;
10381:                 memcpy(&pCsr->pRec[nPayload-nRem], &aOvfl[4], nCopy);
10382:                 nRem -= nCopy;
10383: 
10384:                 pgnoOvfl = get_uint32(aOvfl);
10385:                 sqlite3_free(aOvfl);
10386:               }
10387:             }
10388: 
10389:             iHdr = dbdataGetVarint(pCsr->pRec, &nHdr);
10390:             pCsr->nHdr = nHdr;
10391:             pCsr->pHdrPtr = &pCsr->pRec[iHdr];
10392:             pCsr->pPtr = &pCsr->pRec[pCsr->nHdr];
10393:             pCsr->iField = (bHasRowid ? -1 : 0);
10394:           }
10395:         }
10396:       }else{
10397:         pCsr->iField++;
10398:         if( pCsr->iField>0 ){
10399:           sqlite3_int64 iType;
10400:           if( pCsr->pHdrPtr>&pCsr->pRec[pCsr->nRec] ){
10401:             bNextPage = 1;
10402:           }else{
10403:             pCsr->pHdrPtr += dbdataGetVarint(pCsr->pHdrPtr, &iType);
10404:             pCsr->pPtr += dbdataValueBytes(iType);
10405:           }
10406:         }
10407:       }
10408: 
10409:       if( bNextPage ){
10410:         sqlite3_free(pCsr->aPage);
10411:         sqlite3_free(pCsr->pRec);
10412:         pCsr->aPage = 0;
10413:         pCsr->pRec = 0;
10414:         if( pCsr->bOnePage ) return SQLITE_OK;
10415:         pCsr->iPgno++;
10416:       }else{
10417:         if( pCsr->iField<0 || pCsr->pHdrPtr<&pCsr->pRec[pCsr->nHdr] ){
10418:           return SQLITE_OK;
10419:         }
10420: 
10421:         /* Advance to the next cell. The next iteration of the loop will load
10422:         ** the record and so on. */
10423:         sqlite3_free(pCsr->pRec);
10424:         pCsr->pRec = 0;
10425:         pCsr->iCell++;
10426:       }
10427:     }
10428:   }
10429: 
10430:   assert( !"can't get here" );
10431:   return SQLITE_OK;
10432: }
10433: 
10434: /*
10435: ** Return true if the cursor is at EOF.
10436: */
10437: static int dbdataEof(sqlite3_vtab_cursor *pCursor){
10438:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;
10439:   return pCsr->aPage==0;
10440: }
10441: 
10442: /*
10443: ** Determine the size in pages of database zSchema (where zSchema is
10444: ** "main", "temp" or the name of an attached database) and set
10445: ** pCsr->szDb accordingly. If successful, return SQLITE_OK. Otherwise,
10446: ** an SQLite error code.
10447: */
10448: static int dbdataDbsize(DbdataCursor *pCsr, const char *zSchema){
10449:   DbdataTable *pTab = (DbdataTable*)pCsr->base.pVtab;
10450:   char *zSql = 0;
10451:   int rc, rc2;
10452:   sqlite3_stmt *pStmt = 0;
10453: 
10454:   zSql = sqlite3_mprintf("PRAGMA %Q.page_count", zSchema);
10455:   if( zSql==0 ) return SQLITE_NOMEM;
10456:   rc = sqlite3_prepare_v2(pTab->db, zSql, -1, &pStmt, 0);
10457:   sqlite3_free(zSql);
10458:   if( rc==SQLITE_OK && sqlite3_step(pStmt)==SQLITE_ROW ){
10459:     pCsr->szDb = sqlite3_column_int(pStmt, 0);
10460:   }
10461:   rc2 = sqlite3_finalize(pStmt);
10462:   if( rc==SQLITE_OK ) rc = rc2;
10463:   return rc;
10464: }
10465: 
10466: /*
10467: ** xFilter method for sqlite_dbdata and sqlite_dbptr.
10468: */
10469: static int dbdataFilter(
10470:   sqlite3_vtab_cursor *pCursor,
10471:   int idxNum, const char *idxStr,
10472:   int argc, sqlite3_value **argv
10473: ){
10474:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;
10475:   DbdataTable *pTab = (DbdataTable*)pCursor->pVtab;
10476:   int rc = SQLITE_OK;
10477:   const char *zSchema = "main";
10478: 
10479:   dbdataResetCursor(pCsr);
10480:   assert( pCsr->iPgno==1 );
10481:   if( idxNum & 0x01 ){
10482:     zSchema = (const char*)sqlite3_value_text(argv[0]);
10483:   }
10484:   if( idxNum & 0x02 ){
10485:     pCsr->iPgno = sqlite3_value_int(argv[(idxNum & 0x01)]);
10486:     pCsr->bOnePage = 1;
10487:   }else{
10488:     pCsr->nPage = dbdataDbsize(pCsr, zSchema);
10489:     rc = dbdataDbsize(pCsr, zSchema);
10490:   }
10491: 
10492:   if( rc==SQLITE_OK ){
10493:     if( pTab->pStmt ){
10494:       pCsr->pStmt = pTab->pStmt;
10495:       pTab->pStmt = 0;
10496:     }else{
10497:       rc = sqlite3_prepare_v2(pTab->db,
10498:           "SELECT data FROM sqlite_dbpage(?) WHERE pgno=?", -1,
10499:           &pCsr->pStmt, 0
10500:       );
10501:     }
10502:   }
10503:   if( rc==SQLITE_OK ){
10504:     rc = sqlite3_bind_text(pCsr->pStmt, 1, zSchema, -1, SQLITE_TRANSIENT);
10505:   }else{
10506:     pTab->base.zErrMsg = sqlite3_mprintf("%s", sqlite3_errmsg(pTab->db));
10507:   }
10508:   if( rc==SQLITE_OK ){
10509:     rc = dbdataNext(pCursor);
10510:   }
10511:   return rc;
10512: }
10513: 
10514: /*
10515: ** Return a column for the sqlite_dbdata or sqlite_dbptr table.
10516: */
10517: static int dbdataColumn(
10518:   sqlite3_vtab_cursor *pCursor,
10519:   sqlite3_context *ctx,
10520:   int i
10521: ){
10522:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;
10523:   DbdataTable *pTab = (DbdataTable*)pCursor->pVtab;
10524:   if( pTab->bPtr ){
10525:     switch( i ){
10526:       case DBPTR_COLUMN_PGNO:
10527:         sqlite3_result_int64(ctx, pCsr->iPgno);
10528:         break;
10529:       case DBPTR_COLUMN_CHILD: {
10530:         int iOff = pCsr->iPgno==1 ? 100 : 0;
10531:         if( pCsr->iCell<0 ){
10532:           iOff += 8;
10533:         }else{
10534:           iOff += 12 + pCsr->iCell*2;
10535:           if( iOff>pCsr->nPage ) return SQLITE_OK;
10536:           iOff = get_uint16(&pCsr->aPage[iOff]);
10537:         }
10538:         if( iOff<=pCsr->nPage ){
10539:           sqlite3_result_int64(ctx, get_uint32(&pCsr->aPage[iOff]));
10540:         }
10541:         break;
10542:       }
10543:     }
10544:   }else{
10545:     switch( i ){
10546:       case DBDATA_COLUMN_PGNO:
10547:         sqlite3_result_int64(ctx, pCsr->iPgno);
10548:         break;
10549:       case DBDATA_COLUMN_CELL:
10550:         sqlite3_result_int(ctx, pCsr->iCell);
10551:         break;
10552:       case DBDATA_COLUMN_FIELD:
10553:         sqlite3_result_int(ctx, pCsr->iField);
10554:         break;
10555:       case DBDATA_COLUMN_VALUE: {
10556:         if( pCsr->iField<0 ){
10557:           sqlite3_result_int64(ctx, pCsr->iIntkey);
10558:         }else{
10559:           sqlite3_int64 iType;
10560:           dbdataGetVarint(pCsr->pHdrPtr, &iType);
10561:           dbdataValue(
10562:               ctx, iType, pCsr->pPtr, &pCsr->pRec[pCsr->nRec] - pCsr->pPtr
10563:           );
10564:         }
10565:         break;
10566:       }
10567:     }
10568:   }
10569:   return SQLITE_OK;
10570: }
10571: 
10572: /*
10573: ** Return the rowid for an sqlite_dbdata or sqlite_dptr table.
10574: */
10575: static int dbdataRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){
10576:   DbdataCursor *pCsr = (DbdataCursor*)pCursor;
10577:   *pRowid = pCsr->iRowid;
10578:   return SQLITE_OK;
10579: }
10580: 
10581: 
10582: /*
10583: ** Invoke this routine to register the "sqlite_dbdata" virtual table module
10584: */
10585: static int sqlite3DbdataRegister(sqlite3 *db){
10586:   static sqlite3_module dbdata_module = {
10587:     0,                            /* iVersion */
10588:     0,                            /* xCreate */
10589:     dbdataConnect,                /* xConnect */
10590:     dbdataBestIndex,              /* xBestIndex */
10591:     dbdataDisconnect,             /* xDisconnect */
10592:     0,                            /* xDestroy */
10593:     dbdataOpen,                   /* xOpen - open a cursor */
10594:     dbdataClose,                  /* xClose - close a cursor */
10595:     dbdataFilter,                 /* xFilter - configure scan constraints */
10596:     dbdataNext,                   /* xNext - advance a cursor */
10597:     dbdataEof,                    /* xEof - check for end of scan */
10598:     dbdataColumn,                 /* xColumn - read data */
10599:     dbdataRowid,                  /* xRowid - read data */
10600:     0,                            /* xUpdate */
10601:     0,                            /* xBegin */
10602:     0,                            /* xSync */
10603:     0,                            /* xCommit */
10604:     0,                            /* xRollback */
10605:     0,                            /* xFindMethod */
10606:     0,                            /* xRename */
10607:     0,                            /* xSavepoint */
10608:     0,                            /* xRelease */
10609:     0,                            /* xRollbackTo */
10610:     0                             /* xShadowName */
10611:   };
10612: 
10613:   int rc = sqlite3_create_module(db, "sqlite_dbdata", &dbdata_module, 0);
10614:   if( rc==SQLITE_OK ){
10615:     rc = sqlite3_create_module(db, "sqlite_dbptr", &dbdata_module, (void*)1);
10616:   }
10617:   return rc;
10618: }
10619: 
10620: #ifdef _WIN32
10621: 
10622: #endif
10623: int sqlite3_dbdata_init(
10624:   sqlite3 *db,
10625:   char **pzErrMsg,
10626:   const sqlite3_api_routines *pApi
10627: ){
10628:   SQLITE_EXTENSION_INIT2(pApi);
10629:   return sqlite3DbdataRegister(db);
10630: }
10631: 
10632: /************************* End ../ext/misc/dbdata.c ********************/
10633: #endif
10634: 
10635: #if defined(SQLITE_ENABLE_SESSION)
10636: /*
10637: ** State information for a single open session
10638: */
10639: typedef struct OpenSession OpenSession;
10640: struct OpenSession {
10641:   char *zName;             /* Symbolic name for this session */
10642:   int nFilter;             /* Number of xFilter rejection GLOB patterns */
10643:   char **azFilter;         /* Array of xFilter rejection GLOB patterns */
10644:   sqlite3_session *p;      /* The open session */
10645: };
10646: #endif
10647: 
10648: typedef struct ExpertInfo ExpertInfo;
10649: struct ExpertInfo {
10650:   sqlite3expert *pExpert;
10651:   int bVerbose;
10652: };
10653: 
10654: /* A single line in the EQP output */
10655: typedef struct EQPGraphRow EQPGraphRow;
10656: struct EQPGraphRow {
10657:   int iEqpId;           /* ID for this row */
10658:   int iParentId;        /* ID of the parent row */
10659:   EQPGraphRow *pNext;   /* Next row in sequence */
10660:   char zText[1];        /* Text to display for this row */
10661: };
10662: 
10663: /* All EQP output is collected into an instance of the following */
10664: typedef struct EQPGraph EQPGraph;
10665: struct EQPGraph {
10666:   EQPGraphRow *pRow;    /* Linked list of all rows of the EQP output */
10667:   EQPGraphRow *pLast;   /* Last element of the pRow list */
10668:   char zPrefix[100];    /* Graph prefix */
10669: };
10670: 
10671: /*
10672: ** State information about the database connection is contained in an
10673: ** instance of the following structure.
10674: */
10675: typedef struct ShellState ShellState;
10676: struct ShellState {
10677:   sqlite3 *db;           /* The database */
10678:   u8 autoExplain;        /* Automatically turn on .explain mode */
10679:   u8 autoEQP;            /* Run EXPLAIN QUERY PLAN prior to seach SQL stmt */
10680:   u8 autoEQPtest;        /* autoEQP is in test mode */
10681:   u8 autoEQPtrace;       /* autoEQP is in trace mode */
10682:   u8 statsOn;            /* True to display memory stats before each finalize */
10683:   u8 scanstatsOn;        /* True to display scan stats before each finalize */
10684:   u8 openMode;           /* SHELL_OPEN_NORMAL, _APPENDVFS, or _ZIPFILE */
10685:   u8 doXdgOpen;          /* Invoke start/open/xdg-open in output_reset() */
10686:   u8 nEqpLevel;          /* Depth of the EQP output graph */
10687:   u8 eTraceType;         /* SHELL_TRACE_* value for type of trace */
10688:   unsigned mEqpLines;    /* Mask of veritical lines in the EQP output graph */
10689:   int outCount;          /* Revert to stdout when reaching zero */
10690:   int cnt;               /* Number of records displayed so far */
10691:   int lineno;            /* Line number of last line read from in */
10692:   int openFlags;         /* Additional flags to open.  (SQLITE_OPEN_NOFOLLOW) */
10693:   FILE *in;              /* Read commands from this stream */
10694:   FILE *out;             /* Write results here */
10695:   FILE *traceOut;        /* Output for sqlite3_trace() */
10696:   int nErr;              /* Number of errors seen */
10697:   int mode;              /* An output mode setting */
10698:   int modePrior;         /* Saved mode */
10699:   int cMode;             /* temporary output mode for the current query */
10700:   int normalMode;        /* Output mode before ".explain on" */
10701:   int writableSchema;    /* True if PRAGMA writable_schema=ON */
10702:   int showHeader;        /* True to show column names in List or Column mode */
10703:   int nCheck;            /* Number of ".check" commands run */
10704:   unsigned nProgress;    /* Number of progress callbacks encountered */
10705:   unsigned mxProgress;   /* Maximum progress callbacks before failing */
10706:   unsigned flgProgress;  /* Flags for the progress callback */
10707:   unsigned shellFlgs;    /* Various flags */
10708:   unsigned priorShFlgs;  /* Saved copy of flags */
10709:   sqlite3_int64 szMax;   /* --maxsize argument to .open */
10710:   char *zDestTable;      /* Name of destination table when MODE_Insert */
10711:   char *zTempFile;       /* Temporary file that might need deleting */
10712:   char zTestcase[30];    /* Name of current test case */
10713:   char colSeparator[20]; /* Column separator character for several modes */
10714:   char rowSeparator[20]; /* Row separator character for MODE_Ascii */
10715:   char colSepPrior[20];  /* Saved column separator */
10716:   char rowSepPrior[20];  /* Saved row separator */
10717:   int *colWidth;         /* Requested width of each column in columnar modes */
10718:   int *actualWidth;      /* Actual width of each column */
10719:   int nWidth;            /* Number of slots in colWidth[] and actualWidth[] */
10720:   char nullValue[20];    /* The text to print when a NULL comes back from
10721:                          ** the database */
10722:   char outfile[FILENAME_MAX]; /* Filename for *out */
10723:   const char *zDbFilename;    /* name of the database file */
10724:   char *zFreeOnClose;         /* Filename to free when closing */
10725:   const char *zVfs;           /* Name of VFS to use */
10726:   sqlite3_stmt *pStmt;   /* Current statement if any. */
10727:   FILE *pLog;            /* Write log output here */
10728:   int *aiIndent;         /* Array of indents used in MODE_Explain */
10729:   int nIndent;           /* Size of array aiIndent[] */
10730:   int iIndent;           /* Index of current op in aiIndent[] */
10731:   EQPGraph sGraph;       /* Information for the graphical EXPLAIN QUERY PLAN */
10732: #if defined(SQLITE_ENABLE_SESSION)
10733:   int nSession;             /* Number of active sessions */
10734:   OpenSession aSession[4];  /* Array of sessions.  [0] is in focus. */
10735: #endif
10736:   ExpertInfo expert;        /* Valid if previous command was ".expert OPT..." */
10737: };
10738: 
10739: 
10740: /* Allowed values for ShellState.autoEQP
10741: */
10742: #define AUTOEQP_off      0           /* Automatic EXPLAIN QUERY PLAN is off */
10743: #define AUTOEQP_on       1           /* Automatic EQP is on */
10744: #define AUTOEQP_trigger  2           /* On and also show plans for triggers */
10745: #define AUTOEQP_full     3           /* Show full EXPLAIN */
10746: 
10747: /* Allowed values for ShellState.openMode
10748: */
10749: #define SHELL_OPEN_UNSPEC      0      /* No open-mode specified */
10750: #define SHELL_OPEN_NORMAL      1      /* Normal database file */
10751: #define SHELL_OPEN_APPENDVFS   2      /* Use appendvfs */
10752: #define SHELL_OPEN_ZIPFILE     3      /* Use the zipfile virtual table */
10753: #define SHELL_OPEN_READONLY    4      /* Open a normal database read-only */
10754: #define SHELL_OPEN_DESERIALIZE 5      /* Open using sqlite3_deserialize() */
10755: #define SHELL_OPEN_HEXDB       6      /* Use "dbtotxt" output as data source */
10756: 
10757: /* Allowed values for ShellState.eTraceType
10758: */
10759: #define SHELL_TRACE_PLAIN      0      /* Show input SQL text */
10760: #define SHELL_TRACE_EXPANDED   1      /* Show expanded SQL text */
10761: #define SHELL_TRACE_NORMALIZED 2      /* Show normalized SQL text */
10762: 
10763: /* Bits in the ShellState.flgProgress variable */
10764: #define SHELL_PROGRESS_QUIET 0x01  /* Omit announcing every progress callback */
10765: #define SHELL_PROGRESS_RESET 0x02  /* Reset the count when the progres
10766:                                    ** callback limit is reached, and for each
10767:                                    ** top-level SQL statement */
10768: #define SHELL_PROGRESS_ONCE  0x04  /* Cancel the --limit after firing once */
10769: 
10770: /*
10771: ** These are the allowed shellFlgs values
10772: */
10773: #define SHFLG_Pagecache      0x00000001 /* The --pagecache option is used */
10774: #define SHFLG_Lookaside      0x00000002 /* Lookaside memory is used */
10775: #define SHFLG_Backslash      0x00000004 /* The --backslash option is used */
10776: #define SHFLG_PreserveRowid  0x00000008 /* .dump preserves rowid values */
10777: #define SHFLG_Newlines       0x00000010 /* .dump --newline flag */
10778: #define SHFLG_CountChanges   0x00000020 /* .changes setting */
10779: #define SHFLG_Echo           0x00000040 /* .echo or --echo setting */
10780: #define SHFLG_HeaderSet      0x00000080 /* .header has been used */
10781: 
10782: /*
10783: ** Macros for testing and setting shellFlgs
10784: */
10785: #define ShellHasFlag(P,X)    (((P)->shellFlgs & (X))!=0)
10786: #define ShellSetFlag(P,X)    ((P)->shellFlgs|=(X))
10787: #define ShellClearFlag(P,X)  ((P)->shellFlgs&=(~(X)))
10788: 
10789: /*
10790: ** These are the allowed modes.
10791: */
10792: #define MODE_Line     0  /* One column per line.  Blank line between records */
10793: #define MODE_Column   1  /* One record per line in neat columns */
10794: #define MODE_List     2  /* One record per line with a separator */
10795: #define MODE_Semi     3  /* Same as MODE_List but append ";" to each line */
10796: #define MODE_Html     4  /* Generate an XHTML table */
10797: #define MODE_Insert   5  /* Generate SQL "insert" statements */
10798: #define MODE_Quote    6  /* Quote values as for SQL */
10799: #define MODE_Tcl      7  /* Generate ANSI-C or TCL quoted elements */
10800: #define MODE_Csv      8  /* Quote strings, numbers are plain */
10801: #define MODE_Explain  9  /* Like MODE_Column, but do not truncate data */
10802: #define MODE_Ascii   10  /* Use ASCII unit and record separators (0x1F/0x1E) */
10803: #define MODE_Pretty  11  /* Pretty-print schemas */
10804: #define MODE_EQP     12  /* Converts EXPLAIN QUERY PLAN output into a graph */
10805: #define MODE_Json    13  /* Output JSON */
10806: #define MODE_Markdown 14 /* Markdown formatting */
10807: #define MODE_Table   15  /* MySQL-style table formatting */
10808: #define MODE_Box     16  /* Unicode box-drawing characters */
10809: #define MODE_Latex   17  /* Latex tabular formatting */
10810: #define MODE_Trash   18  /* Discard output */
10811: #define MODE_Jsonlines 19  /* Output JSON Lines */
10812: 
10813: static const char *modeDescr[] = {
10814:   "line",
10815:   "column",
10816:   "list",
10817:   "semi",
10818:   "html",
10819:   "insert",
10820:   "quote",
10821:   "tcl",
10822:   "csv",
10823:   "explain",
10824:   "ascii",
10825:   "prettyprint",
10826:   "eqp",
10827:   "json",
10828:   "markdown",
10829:   "table",
10830:   "box",
10831:   "latex",
10832:   "trash",
10833:     "jsonlines"
10834: };
10835: 
10836: /*
10837: ** These are the column/row/line separators used by the various
10838: ** import/export modes.
10839: */
10840: #define SEP_Column    "|"
10841: #define SEP_Row       "\n"
10842: #define SEP_Tab       "\t"
10843: #define SEP_Space     " "
10844: #define SEP_Comma     ","
10845: #define SEP_CrLf      "\r\n"
10846: #define SEP_Unit      "\x1F"
10847: #define SEP_Record    "\x1E"
10848: 
10849: /*
10850: ** A callback for the sqlite3_log() interface.
10851: */
10852: static void shellLog(void *pArg, int iErrCode, const char *zMsg){
10853:   ShellState *p = (ShellState*)pArg;
10854:   if( p->pLog==0 ) return;
10855:   utf8_printf(p->pLog, "(%d) %s\n", iErrCode, zMsg);
10856:   fflush(p->pLog);
10857: }
10858: 
10859: /*
10860: ** SQL function:  shell_putsnl(X)
10861: **
10862: ** Write the text X to the screen (or whatever output is being directed)
10863: ** adding a newline at the end, and then return X.
10864: */
10865: static void shellPutsFunc(
10866:   sqlite3_context *pCtx,
10867:   int nVal,
10868:   sqlite3_value **apVal
10869: ){
10870:   ShellState *p = (ShellState*)sqlite3_user_data(pCtx);
10871:   (void)nVal;
10872:   utf8_printf(p->out, "%s\n", sqlite3_value_text(apVal[0]));
10873:   sqlite3_result_value(pCtx, apVal[0]);
10874: }
10875: 
10876: /*
10877: ** SQL function:   edit(VALUE)
10878: **                 edit(VALUE,EDITOR)
10879: **
10880: ** These steps:
10881: **
10882: **     (1) Write VALUE into a temporary file.
10883: **     (2) Run program EDITOR on that temporary file.
10884: **     (3) Read the temporary file back and return its content as the result.
10885: **     (4) Delete the temporary file
10886: **
10887: ** If the EDITOR argument is omitted, use the value in the VISUAL
10888: ** environment variable.  If still there is no EDITOR, through an error.
10889: **
10890: ** Also throw an error if the EDITOR program returns a non-zero exit code.
10891: */
10892: #ifndef SQLITE_NOHAVE_SYSTEM
10893: static void editFunc(
10894:   sqlite3_context *context,
10895:   int argc,
10896:   sqlite3_value **argv
10897: ){
10898:   const char *zEditor;
10899:   char *zTempFile = 0;
10900:   sqlite3 *db;
10901:   char *zCmd = 0;
10902:   int bBin;
10903:   int rc;
10904:   int hasCRNL = 0;
10905:   FILE *f = 0;
10906:   sqlite3_int64 sz;
10907:   sqlite3_int64 x;
10908:   unsigned char *p = 0;
10909: 
10910:   if( argc==2 ){
10911:     zEditor = (const char*)sqlite3_value_text(argv[1]);
10912:   }else{
10913:     zEditor = getenv("VISUAL");
10914:   }
10915:   if( zEditor==0 ){
10916:     sqlite3_result_error(context, "no editor for edit()", -1);
10917:     return;
10918:   }
10919:   if( sqlite3_value_type(argv[0])==SQLITE_NULL ){
10920:     sqlite3_result_error(context, "NULL input to edit()", -1);
10921:     return;
10922:   }
10923:   db = sqlite3_context_db_handle(context);
10924:   zTempFile = 0;
10925:   sqlite3_file_control(db, 0, SQLITE_FCNTL_TEMPFILENAME, &zTempFile);
10926:   if( zTempFile==0 ){
10927:     sqlite3_uint64 r = 0;
10928:     sqlite3_randomness(sizeof(r), &r);
10929:     zTempFile = sqlite3_mprintf("temp%llx", r);
10930:     if( zTempFile==0 ){
10931:       sqlite3_result_error_nomem(context);
10932:       return;
10933:     }
10934:   }
10935:   bBin = sqlite3_value_type(argv[0])==SQLITE_BLOB;
10936:   /* When writing the file to be edited, do \n to \r\n conversions on systems
10937:   ** that want \r\n line endings */
10938:   f = fopen(zTempFile, bBin ? "wb" : "w");
10939:   if( f==0 ){
10940:     sqlite3_result_error(context, "edit() cannot open temp file", -1);
10941:     goto edit_func_end;
10942:   }
10943:   sz = sqlite3_value_bytes(argv[0]);
10944:   if( bBin ){
10945:     x = fwrite(sqlite3_value_blob(argv[0]), 1, (size_t)sz, f);
10946:   }else{
10947:     const char *z = (const char*)sqlite3_value_text(argv[0]);
10948:     /* Remember whether or not the value originally contained \r\n */
10949:     if( z && strstr(z,"\r\n")!=0 ) hasCRNL = 1;
10950:     x = fwrite(sqlite3_value_text(argv[0]), 1, (size_t)sz, f);
10951:   }
10952:   fclose(f);
10953:   f = 0;
10954:   if( x!=sz ){
10955:     sqlite3_result_error(context, "edit() could not write the whole file", -1);
10956:     goto edit_func_end;
10957:   }
10958:   zCmd = sqlite3_mprintf("%s \"%s\"", zEditor, zTempFile);
10959:   if( zCmd==0 ){
10960:     sqlite3_result_error_nomem(context);
10961:     goto edit_func_end;
10962:   }
10963:   rc = system(zCmd);
10964:   sqlite3_free(zCmd);
10965:   if( rc ){
10966:     sqlite3_result_error(context, "EDITOR returned non-zero", -1);
10967:     goto edit_func_end;
10968:   }
10969:   f = fopen(zTempFile, "rb");
10970:   if( f==0 ){
10971:     sqlite3_result_error(context,
10972:       "edit() cannot reopen temp file after edit", -1);
10973:     goto edit_func_end;
10974:   }
10975:   fseek(f, 0, SEEK_END);
10976:   sz = ftell(f);
10977:   rewind(f);
10978:   p = sqlite3_malloc64( sz+1 );
10979:   if( p==0 ){
10980:     sqlite3_result_error_nomem(context);
10981:     goto edit_func_end;
10982:   }
10983:   x = fread(p, 1, (size_t)sz, f);
10984:   fclose(f);
10985:   f = 0;
10986:   if( x!=sz ){
10987:     sqlite3_result_error(context, "could not read back the whole file", -1);
10988:     goto edit_func_end;
10989:   }
10990:   if( bBin ){
10991:     sqlite3_result_blob64(context, p, sz, sqlite3_free);
10992:   }else{
10993:     sqlite3_int64 i, j;
10994:     if( hasCRNL ){
10995:       /* If the original contains \r\n then do no conversions back to \n */
10996:       j = sz;
10997:     }else{
10998:       /* If the file did not originally contain \r\n then convert any new
10999:       ** \r\n back into \n */
11000:       for(i=j=0; i<sz; i++){
11001:         if( p[i]=='\r' && p[i+1]=='\n' ) i++;
11002:         p[j++] = p[i];
11003:       }
11004:       sz = j;
11005:       p[sz] = 0;
11006:     }
11007:     sqlite3_result_text64(context, (const char*)p, sz,
11008:                           sqlite3_free, SQLITE_UTF8);
11009:   }
11010:   p = 0;
11011: 
11012: edit_func_end:
11013:   if( f ) fclose(f);
11014:   unlink(zTempFile);
11015:   sqlite3_free(zTempFile);
11016:   sqlite3_free(p);
11017: }
11018: #endif /* SQLITE_NOHAVE_SYSTEM */
11019: 
11020: /*
11021: ** Save or restore the current output mode
11022: */
11023: static void outputModePush(ShellState *p){
11024:   p->modePrior = p->mode;
11025:   p->priorShFlgs = p->shellFlgs;
11026:   memcpy(p->colSepPrior, p->colSeparator, sizeof(p->colSeparator));
11027:   memcpy(p->rowSepPrior, p->rowSeparator, sizeof(p->rowSeparator));
11028: }
11029: static void outputModePop(ShellState *p){
11030:   p->mode = p->modePrior;
11031:   p->shellFlgs = p->priorShFlgs;
11032:   memcpy(p->colSeparator, p->colSepPrior, sizeof(p->colSeparator));
11033:   memcpy(p->rowSeparator, p->rowSepPrior, sizeof(p->rowSeparator));
11034: }
11035: 
11036: /*
11037: ** Output the given string as a hex-encoded blob (eg. X'1234' )
11038: */
11039: static void output_hex_blob(FILE *out, const void *pBlob, int nBlob){
11040:   int i;
11041:   char *zBlob = (char *)pBlob;
11042:   raw_printf(out,"X'");
11043:   for(i=0; i<nBlob; i++){ raw_printf(out,"%02x",zBlob[i]&0xff); }
11044:   raw_printf(out,"'");
11045: }
11046: 
11047: /*
11048: ** Find a string that is not found anywhere in z[].  Return a pointer
11049: ** to that string.
11050: **
11051: ** Try to use zA and zB first.  If both of those are already found in z[]
11052: ** then make up some string and store it in the buffer zBuf.
11053: */
11054: static const char *unused_string(
11055:   const char *z,                    /* Result must not appear anywhere in z */
11056:   const char *zA, const char *zB,   /* Try these first */
11057:   char *zBuf                        /* Space to store a generated string */
11058: ){
11059:   unsigned i = 0;
11060:   if( strstr(z, zA)==0 ) return zA;
11061:   if( strstr(z, zB)==0 ) return zB;
11062:   do{
11063:     sqlite3_snprintf(20,zBuf,"(%s%u)", zA, i++);
11064:   }while( strstr(z,zBuf)!=0 );
11065:   return zBuf;
11066: }
11067: 
11068: /*
11069: ** Output the given string as a quoted string using SQL quoting conventions.
11070: **
11071: ** See also: output_quoted_escaped_string()
11072: */
11073: static void output_quoted_string(FILE *out, const char *z){
11074:   int i;
11075:   char c;
11076:   setBinaryMode(out, 1);
11077:   for(i=0; (c = z[i])!=0 && c!='\''; i++){}
11078:   if( c==0 ){
11079:     utf8_printf(out,"'%s'",z);
11080:   }else{
11081:     raw_printf(out, "'");
11082:     while( *z ){
11083:       for(i=0; (c = z[i])!=0 && c!='\''; i++){}
11084:       if( c=='\'' ) i++;
11085:       if( i ){
11086:         utf8_printf(out, "%.*s", i, z);
11087:         z += i;
11088:       }
11089:       if( c=='\'' ){
11090:         raw_printf(out, "'");
11091:         continue;
11092:       }
11093:       if( c==0 ){
11094:         break;
11095:       }
11096:       z++;
11097:     }
11098:     raw_printf(out, "'");
11099:   }
11100:   setTextMode(out, 1);
11101: }
11102: 
11103: /*
11104: ** Output the given string as a quoted string using SQL quoting conventions.
11105: ** Additionallly , escape the "\n" and "\r" characters so that they do not
11106: ** get corrupted by end-of-line translation facilities in some operating
11107: ** systems.
11108: **
11109: ** This is like output_quoted_string() but with the addition of the \r\n
11110: ** escape mechanism.
11111: */
11112: static void output_quoted_escaped_string(FILE *out, const char *z){
11113:   int i;
11114:   char c;
11115:   setBinaryMode(out, 1);
11116:   for(i=0; (c = z[i])!=0 && c!='\'' && c!='\n' && c!='\r'; i++){}
11117:   if( c==0 ){
11118:     utf8_printf(out,"'%s'",z);
11119:   }else{
11120:     const char *zNL = 0;
11121:     const char *zCR = 0;
11122:     int nNL = 0;
11123:     int nCR = 0;
11124:     char zBuf1[20], zBuf2[20];
11125:     for(i=0; z[i]; i++){
11126:       if( z[i]=='\n' ) nNL++;
11127:       if( z[i]=='\r' ) nCR++;
11128:     }
11129:     if( nNL ){
11130:       raw_printf(out, "replace(");
11131:       zNL = unused_string(z, "\\n", "\\012", zBuf1);
11132:     }
11133:     if( nCR ){
11134:       raw_printf(out, "replace(");
11135:       zCR = unused_string(z, "\\r", "\\015", zBuf2);
11136:     }
11137:     raw_printf(out, "'");
11138:     while( *z ){
11139:       for(i=0; (c = z[i])!=0 && c!='\n' && c!='\r' && c!='\''; i++){}
11140:       if( c=='\'' ) i++;
11141:       if( i ){
11142:         utf8_printf(out, "%.*s", i, z);
11143:         z += i;
11144:       }
11145:       if( c=='\'' ){
11146:         raw_printf(out, "'");
11147:         continue;
11148:       }
11149:       if( c==0 ){
11150:         break;
11151:       }
11152:       z++;
11153:       if( c=='\n' ){
11154:         raw_printf(out, "%s", zNL);
11155:         continue;
11156:       }
11157:       raw_printf(out, "%s", zCR);
11158:     }
11159:     raw_printf(out, "'");
11160:     if( nCR ){
11161:       raw_printf(out, ",'%s',char(13))", zCR);
11162:     }
11163:     if( nNL ){
11164:       raw_printf(out, ",'%s',char(10))", zNL);
11165:     }
11166:   }
11167:   setTextMode(out, 1);
11168: }
11169: 
11170: /*
11171: ** Output the given string as a quoted according to C or TCL quoting rules.
11172: */
11173: static void output_c_string(FILE *out, const char *z){
11174:   unsigned int c;
11175:   fputc('"', out);
11176:   while( (c = *(z++))!=0 ){
11177:     if( c=='\\' ){
11178:       fputc(c, out);
11179:       fputc(c, out);
11180:     }else if( c=='"' ){
11181:       fputc('\\', out);
11182:       fputc('"', out);
11183:     }else if( c=='\t' ){
11184:       fputc('\\', out);
11185:       fputc('t', out);
11186:     }else if( c=='\n' ){
11187:       fputc('\\', out);
11188:       fputc('n', out);
11189:     }else if( c=='\r' ){
11190:       fputc('\\', out);
11191:       fputc('r', out);
11192:     }else if( !isprint(c&0xff) ){
11193:       raw_printf(out, "\\%03o", c&0xff);
11194:     }else{
11195:       fputc(c, out);
11196:     }
11197:   }
11198:   fputc('"', out);
11199: }
11200: 
11201: /*
11202: ** Output the given string as a quoted according to JSON quoting rules.
11203: */
11204: static void output_json_string(FILE *out, const char *z, int n){
11205:   unsigned int c;
11206:   if( n<0 ) n = (int)strlen(z);
11207:   fputc('"', out);
11208:   while( n-- ){
11209:     c = *(z++);
11210:     if( c=='\\' || c=='"' ){
11211:       fputc('\\', out);
11212:       fputc(c, out);
11213:     }else if( c<=0x1f ){
11214:       fputc('\\', out);
11215:       if( c=='\b' ){
11216:         fputc('b', out);
11217:       }else if( c=='\f' ){
11218:         fputc('f', out);
11219:       }else if( c=='\n' ){
11220:         fputc('n', out);
11221:       }else if( c=='\r' ){
11222:         fputc('r', out);
11223:       }else if( c=='\t' ){
11224:         fputc('t', out);
11225:       }else{
11226:          raw_printf(out, "u%04x",c);
11227:       }
11228:     }else{
11229:       fputc(c, out);
11230:     }
11231:   }
11232:   fputc('"', out);
11233: }
11234: 
11235: /*
11236: ** Output the given string with characters that are special to
11237: ** HTML escaped.
11238: */
11239: static void output_html_string(FILE *out, const char *z){
11240:   int i;
11241:   if( z==0 ) z = "";
11242:   while( *z ){
11243:     for(i=0;   z[i]
11244:             && z[i]!='<'
11245:             && z[i]!='&'
11246:             && z[i]!='>'
11247:             && z[i]!='\"'
11248:             && z[i]!='\'';
11249:         i++){}
11250:     if( i>0 ){
11251:       utf8_printf(out,"%.*s",i,z);
11252:     }
11253:     if( z[i]=='<' ){
11254:       raw_printf(out,"&lt;");
11255:     }else if( z[i]=='&' ){
11256:       raw_printf(out,"&amp;");
11257:     }else if( z[i]=='>' ){
11258:       raw_printf(out,"&gt;");
11259:     }else if( z[i]=='\"' ){
11260:       raw_printf(out,"&quot;");
11261:     }else if( z[i]=='\'' ){
11262:       raw_printf(out,"&#39;");
11263:     }else{
11264:       break;
11265:     }
11266:     z += i + 1;
11267:   }
11268: }
11269: 
11270: /*
11271: ** If a field contains any character identified by a 1 in the following
11272: ** array, then the string must be quoted for CSV.
11273: */
11274: static const char needCsvQuote[] = {
11275:   1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
11276:   1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
11277:   1, 0, 1, 0, 0, 0, 0, 1,   0, 0, 0, 0, 0, 0, 0, 0,
11278:   0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,
11279:   0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,
11280:   0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,
11281:   0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,
11282:   0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 1,
11283:   1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
11284:   1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
11285:   1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
11286:   1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
11287:   1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
11288:   1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
11289:   1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
11290:   1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
11291: };
11292: 
11293: /*
11294: ** Output a single term of CSV.  Actually, p->colSeparator is used for
11295: ** the separator, which may or may not be a comma.  p->nullValue is
11296: ** the null value.  Strings are quoted if necessary.  The separator
11297: ** is only issued if bSep is true.
11298: */
11299: static void output_csv(ShellState *p, const char *z, int bSep){
11300:   FILE *out = p->out;
11301:   if( z==0 ){
11302:     utf8_printf(out,"%s",p->nullValue);
11303:   }else{
11304:     int i;
11305:     int nSep = strlen30(p->colSeparator);
11306:     for(i=0; z[i]; i++){
11307:       if( needCsvQuote[((unsigned char*)z)[i]]
11308:          || (z[i]==p->colSeparator[0] &&
11309:              (nSep==1 || memcmp(z, p->colSeparator, nSep)==0)) ){
11310:         i = 0;
11311:         break;
11312:       }
11313:     }
11314:     if( i==0 ){
11315:       char *zQuoted = sqlite3_mprintf("\"%w\"", z);
11316:       utf8_printf(out, "%s", zQuoted);
11317:       sqlite3_free(zQuoted);
11318:     }else{
11319:       utf8_printf(out, "%s", z);
11320:     }
11321:   }
11322:   if( bSep ){
11323:     utf8_printf(p->out, "%s", p->colSeparator);
11324:   }
11325: }
11326: 
11327: /*
11328: ** This routine runs when the user presses Ctrl-C
11329: */
11330: static void interrupt_handler(int NotUsed){
11331:   UNUSED_PARAMETER(NotUsed);
11332:   seenInterrupt++;
11333:   if( seenInterrupt>2 ) exit(1);
11334:   if( globalDb ) sqlite3_interrupt(globalDb);
11335: }
11336: 
11337: #if (defined(_WIN32) || defined(WIN32)) && !defined(_WIN32_WCE)
11338: /*
11339: ** This routine runs for console events (e.g. Ctrl-C) on Win32
11340: */
11341: static BOOL WINAPI ConsoleCtrlHandler(
11342:   DWORD dwCtrlType /* One of the CTRL_*_EVENT constants */
11343: ){
11344:   if( dwCtrlType==CTRL_C_EVENT ){
11345:     interrupt_handler(0);
11346:     return TRUE;
11347:   }
11348:   return FALSE;
11349: }
11350: #endif
11351: 
11352: #ifndef SQLITE_OMIT_AUTHORIZATION
11353: /*
11354: ** When the ".auth ON" is set, the following authorizer callback is
11355: ** invoked.  It always returns SQLITE_OK.
11356: */
11357: static int shellAuth(
11358:   void *pClientData,
11359:   int op,
11360:   const char *zA1,
11361:   const char *zA2,
11362:   const char *zA3,
11363:   const char *zA4
11364: ){
11365:   ShellState *p = (ShellState*)pClientData;
11366:   static const char *azAction[] = { 0,
11367:      "CREATE_INDEX",         "CREATE_TABLE",         "CREATE_TEMP_INDEX",
11368:      "CREATE_TEMP_TABLE",    "CREATE_TEMP_TRIGGER",  "CREATE_TEMP_VIEW",
11369:      "CREATE_TRIGGER",       "CREATE_VIEW",          "DELETE",
11370:      "DROP_INDEX",           "DROP_TABLE",           "DROP_TEMP_INDEX",
11371:      "DROP_TEMP_TABLE",      "DROP_TEMP_TRIGGER",    "DROP_TEMP_VIEW",
11372:      "DROP_TRIGGER",         "DROP_VIEW",            "INSERT",
11373:      "PRAGMA",               "READ",                 "SELECT",
11374:      "TRANSACTION",          "UPDATE",               "ATTACH",
11375:      "DETACH",               "ALTER_TABLE",          "REINDEX",
11376:      "ANALYZE",              "CREATE_VTABLE",        "DROP_VTABLE",
11377:      "FUNCTION",             "SAVEPOINT",            "RECURSIVE"
11378:   };
11379:   int i;
11380:   const char *az[4];
11381:   az[0] = zA1;
11382:   az[1] = zA2;
11383:   az[2] = zA3;
11384:   az[3] = zA4;
11385:   utf8_printf(p->out, "authorizer: %s", azAction[op]);
11386:   for(i=0; i<4; i++){
11387:     raw_printf(p->out, " ");
11388:     if( az[i] ){
11389:       output_c_string(p->out, az[i]);
11390:     }else{
11391:       raw_printf(p->out, "NULL");
11392:     }
11393:   }
11394:   raw_printf(p->out, "\n");
11395:   return SQLITE_OK;
11396: }
11397: #endif
11398: 
11399: /*
11400: ** Print a schema statement.  Part of MODE_Semi and MODE_Pretty output.
11401: **
11402: ** This routine converts some CREATE TABLE statements for shadow tables
11403: ** in FTS3/4/5 into CREATE TABLE IF NOT EXISTS statements.
11404: */
11405: static void printSchemaLine(FILE *out, const char *z, const char *zTail){
11406:   if( z==0 ) return;
11407:   if( zTail==0 ) return;
11408:   if( sqlite3_strglob("CREATE TABLE ['\"]*", z)==0 ){
11409:     utf8_printf(out, "CREATE TABLE IF NOT EXISTS %s%s", z+13, zTail);
11410:   }else{
11411:     utf8_printf(out, "%s%s", z, zTail);
11412:   }
11413: }
11414: static void printSchemaLineN(FILE *out, char *z, int n, const char *zTail){
11415:   char c = z[n];
11416:   z[n] = 0;
11417:   printSchemaLine(out, z, zTail);
11418:   z[n] = c;
11419: }
11420: 
11421: /*
11422: ** Return true if string z[] has nothing but whitespace and comments to the
11423: ** end of the first line.
11424: */
11425: static int wsToEol(const char *z){
11426:   int i;
11427:   for(i=0; z[i]; i++){
11428:     if( z[i]=='\n' ) return 1;
11429:     if( IsSpace(z[i]) ) continue;
11430:     if( z[i]=='-' && z[i+1]=='-' ) return 1;
11431:     return 0;
11432:   }
11433:   return 1;
11434: }
11435: 
11436: /*
11437: ** Add a new entry to the EXPLAIN QUERY PLAN data
11438: */
11439: static void eqp_append(ShellState *p, int iEqpId, int p2, const char *zText){
11440:   EQPGraphRow *pNew;
11441:   int nText = strlen30(zText);
11442:   if( p->autoEQPtest ){
11443:     utf8_printf(p->out, "%d,%d,%s\n", iEqpId, p2, zText);
11444:   }
11445:   pNew = sqlite3_malloc64( sizeof(*pNew) + nText );
11446:   if( pNew==0 ) shell_out_of_memory();
11447:   pNew->iEqpId = iEqpId;
11448:   pNew->iParentId = p2;
11449:   memcpy(pNew->zText, zText, nText+1);
11450:   pNew->pNext = 0;
11451:   if( p->sGraph.pLast ){
11452:     p->sGraph.pLast->pNext = pNew;
11453:   }else{
11454:     p->sGraph.pRow = pNew;
11455:   }
11456:   p->sGraph.pLast = pNew;
11457: }
11458: 
11459: /*
11460: ** Free and reset the EXPLAIN QUERY PLAN data that has been collected
11461: ** in p->sGraph.
11462: */
11463: static void eqp_reset(ShellState *p){
11464:   EQPGraphRow *pRow, *pNext;
11465:   for(pRow = p->sGraph.pRow; pRow; pRow = pNext){
11466:     pNext = pRow->pNext;
11467:     sqlite3_free(pRow);
11468:   }
11469:   memset(&p->sGraph, 0, sizeof(p->sGraph));
11470: }
11471: 
11472: /* Return the next EXPLAIN QUERY PLAN line with iEqpId that occurs after
11473: ** pOld, or return the first such line if pOld is NULL
11474: */
11475: static EQPGraphRow *eqp_next_row(ShellState *p, int iEqpId, EQPGraphRow *pOld){
11476:   EQPGraphRow *pRow = pOld ? pOld->pNext : p->sGraph.pRow;
11477:   while( pRow && pRow->iParentId!=iEqpId ) pRow = pRow->pNext;
11478:   return pRow;
11479: }
11480: 
11481: /* Render a single level of the graph that has iEqpId as its parent.  Called
11482: ** recursively to render sublevels.
11483: */
11484: static void eqp_render_level(ShellState *p, int iEqpId){
11485:   EQPGraphRow *pRow, *pNext;
11486:   int n = strlen30(p->sGraph.zPrefix);
11487:   char *z;
11488:   for(pRow = eqp_next_row(p, iEqpId, 0); pRow; pRow = pNext){
11489:     pNext = eqp_next_row(p, iEqpId, pRow);
11490:     z = pRow->zText;
11491:     utf8_printf(p->out, "%s%s%s\n", p->sGraph.zPrefix,
11492:                 pNext ? "|--" : "`--", z);
11493:     if( n<(int)sizeof(p->sGraph.zPrefix)-7 ){
11494:       memcpy(&p->sGraph.zPrefix[n], pNext ? "|  " : "   ", 4);
11495:       eqp_render_level(p, pRow->iEqpId);
11496:       p->sGraph.zPrefix[n] = 0;
11497:     }
11498:   }
11499: }
11500: 
11501: /*
11502: ** Display and reset the EXPLAIN QUERY PLAN data
11503: */
11504: static void eqp_render(ShellState *p){
11505:   EQPGraphRow *pRow = p->sGraph.pRow;
11506:   if( pRow ){
11507:     if( pRow->zText[0]=='-' ){
11508:       if( pRow->pNext==0 ){
11509:         eqp_reset(p);
11510:         return;
11511:       }
11512:       utf8_printf(p->out, "%s\n", pRow->zText+3);
11513:       p->sGraph.pRow = pRow->pNext;
11514:       sqlite3_free(pRow);
11515:     }else{
11516:       utf8_printf(p->out, "QUERY PLAN\n");
11517:     }
11518:     p->sGraph.zPrefix[0] = 0;
11519:     eqp_render_level(p, 0);
11520:     eqp_reset(p);
11521:   }
11522: }
11523: 
11524: #ifndef SQLITE_OMIT_PROGRESS_CALLBACK
11525: /*
11526: ** Progress handler callback.
11527: */
11528: static int progress_handler(void *pClientData) {
11529:   ShellState *p = (ShellState*)pClientData;
11530:   p->nProgress++;
11531:   if( p->nProgress>=p->mxProgress && p->mxProgress>0 ){
11532:     raw_printf(p->out, "Progress limit reached (%u)\n", p->nProgress);
11533:     if( p->flgProgress & SHELL_PROGRESS_RESET ) p->nProgress = 0;
11534:     if( p->flgProgress & SHELL_PROGRESS_ONCE ) p->mxProgress = 0;
11535:     return 1;
11536:   }
11537:   if( (p->flgProgress & SHELL_PROGRESS_QUIET)==0 ){
11538:     raw_printf(p->out, "Progress %u\n", p->nProgress);
11539:   }
11540:   return 0;
11541: }
11542: #endif /* SQLITE_OMIT_PROGRESS_CALLBACK */
11543: 
11544: /*
11545: ** Print N dashes
11546: */
11547: static void print_dashes(FILE *out, int N){
11548:   const char zDash[] = "--------------------------------------------------";
11549:   const int nDash = sizeof(zDash) - 1;
11550:   while( N>nDash ){
11551:     fputs(zDash, out);
11552:     N -= nDash;
11553:   }
11554:   raw_printf(out, "%.*s", N, zDash);
11555: }
11556: 
11557: /*
11558: ** Print a markdown or table-style row separator using ascii-art
11559: */
11560: static void print_row_separator(
11561:   ShellState *p,
11562:   int nArg,
11563:   const char *zSep
11564: ){
11565:   int i;
11566:   if( nArg>0 ){
11567:     fputs(zSep, p->out);
11568:     print_dashes(p->out, p->actualWidth[0]+2);
11569:     for(i=1; i<nArg; i++){
11570:       fputs(zSep, p->out);
11571:       print_dashes(p->out, p->actualWidth[i]+2);
11572:     }
11573:     fputs(zSep, p->out);
11574:   }
11575:   fputs("\n", p->out);
11576: }
11577: 
11578: /*
11579: ** This is the callback routine that the shell
11580: ** invokes for each row of a query result.
11581: */
11582: static int shell_callback(
11583:   void *pArg,
11584:   int nArg,        /* Number of result columns */
11585:   char **azArg,    /* Text of each result column */
11586:   char **azCol,    /* Column names */
11587:   int *aiType      /* Column types.  Might be NULL */
11588: ){
11589:   int i;
11590:   ShellState *p = (ShellState*)pArg;
11591: 
11592:   if( azArg==0 ) return 0;
11593:   switch( p->cMode ){
11594:     case MODE_Line: {
11595:       int w = 5;
11596:       if( azArg==0 ) break;
11597:       for(i=0; i<nArg; i++){
11598:         int len = strlen30(azCol[i] ? azCol[i] : "");
11599:         if( len>w ) w = len;
11600:       }
11601:       if( p->cnt++>0 ) utf8_printf(p->out, "%s", p->rowSeparator);
11602:       for(i=0; i<nArg; i++){
11603:         utf8_printf(p->out,"%*s = %s%s", w, azCol[i],
11604:                 azArg[i] ? azArg[i] : p->nullValue, p->rowSeparator);
11605:       }
11606:       break;
11607:     }
11608:     case MODE_Explain: {
11609:       if (nArg != 2) {
11610:         break;
11611:       }
11612:       utf8_printf(p->out, "\n\n");
11613:       utf8_printf(p->out, "\n");
11614:       if (strcmp(azArg[0], "logical_plan") == 0) {
11615:       utf8_printf(p->out, " Unoptimized Logical Plan  \n");
11616:       } else if (strcmp(azArg[0], "logical_opt") == 0) {
11617:       utf8_printf(p->out, "  Optimized Logical Plan   \n");
11618:       } else if (strcmp(azArg[0], "physical_plan") == 0) {
11619:       utf8_printf(p->out, "       Physical Plan       \n");
11620: 
11621:       }
11622:       utf8_printf(p->out, "\n");
11623:       utf8_printf(p->out, "\n");
11624:       utf8_printf(p->out, "%s", azArg[1]);
11625:       break;
11626:     }
11627:     case MODE_Semi: {   /* .schema and .fullschema output */
11628:       printSchemaLine(p->out, azArg[0], ";\n");
11629:       break;
11630:     }
11631:     case MODE_Pretty: {  /* .schema and .fullschema with --indent */
11632:       char *z;
11633:       int j;
11634:       int nParen = 0;
11635:       char cEnd = 0;
11636:       char c;
11637:       int nLine = 0;
11638:       assert( nArg==1 );
11639:       if( azArg[0]==0 ) break;
11640:       if( sqlite3_strlike("CREATE VIEW%", azArg[0], 0)==0
11641:        || sqlite3_strlike("CREATE TRIG%", azArg[0], 0)==0
11642:       ){
11643:         utf8_printf(p->out, "%s;\n", azArg[0]);
11644:         break;
11645:       }
11646:       z = sqlite3_mprintf("%s", azArg[0]);
11647:       j = 0;
11648:       for(i=0; IsSpace(z[i]); i++){}
11649:       for(; (c = z[i])!=0; i++){
11650:         if( IsSpace(c) ){
11651:           if( z[j-1]=='\r' ) z[j-1] = '\n';
11652:           if( IsSpace(z[j-1]) || z[j-1]=='(' ) continue;
11653:         }else if( (c=='(' || c==')') && j>0 && IsSpace(z[j-1]) ){
11654:           j--;
11655:         }
11656:         z[j++] = c;
11657:       }
11658:       while( j>0 && IsSpace(z[j-1]) ){ j--; }
11659:       z[j] = 0;
11660:       if( strlen30(z)>=79 ){
11661:         for(i=j=0; (c = z[i])!=0; i++){ /* Copy from z[i] back to z[j] */
11662:           if( c==cEnd ){
11663:             cEnd = 0;
11664:           }else if( c=='"' || c=='\'' || c=='`' ){
11665:             cEnd = c;
11666:           }else if( c=='[' ){
11667:             cEnd = ']';
11668:           }else if( c=='-' && z[i+1]=='-' ){
11669:             cEnd = '\n';
11670:           }else if( c=='(' ){
11671:             nParen++;
11672:           }else if( c==')' ){
11673:             nParen--;
11674:             if( nLine>0 && nParen==0 && j>0 ){
11675:               printSchemaLineN(p->out, z, j, "\n");
11676:               j = 0;
11677:             }
11678:           }
11679:           z[j++] = c;
11680:           if( nParen==1 && cEnd==0
11681:            && (c=='(' || c=='\n' || (c==',' && !wsToEol(z+i+1)))
11682:           ){
11683:             if( c=='\n' ) j--;
11684:             printSchemaLineN(p->out, z, j, "\n  ");
11685:             j = 0;
11686:             nLine++;
11687:             while( IsSpace(z[i+1]) ){ i++; }
11688:           }
11689:         }
11690:         z[j] = 0;
11691:       }
11692:       printSchemaLine(p->out, z, ";\n");
11693:       sqlite3_free(z);
11694:       break;
11695:     }
11696:     case MODE_List: {
11697:       if( p->cnt++==0 && p->showHeader ){
11698:         for(i=0; i<nArg; i++){
11699:           utf8_printf(p->out,"%s%s",azCol[i],
11700:                   i==nArg-1 ? p->rowSeparator : p->colSeparator);
11701:         }
11702:       }
11703:       if( azArg==0 ) break;
11704:       for(i=0; i<nArg; i++){
11705:         char *z = azArg[i];
11706:         if( z==0 ) z = p->nullValue;
11707:         utf8_printf(p->out, "%s", z);
11708:         if( i<nArg-1 ){
11709:           utf8_printf(p->out, "%s", p->colSeparator);
11710:         }else{
11711:           utf8_printf(p->out, "%s", p->rowSeparator);
11712:         }
11713:       }
11714:       break;
11715:     }
11716:     case MODE_Html: {
11717:       if( p->cnt++==0 && p->showHeader ){
11718:         raw_printf(p->out,"<TR>");
11719:         for(i=0; i<nArg; i++){
11720:           raw_printf(p->out,"<TH>");
11721:           output_html_string(p->out, azCol[i]);
11722:           raw_printf(p->out,"</TH>\n");
11723:         }
11724:         raw_printf(p->out,"</TR>\n");
11725:       }
11726:       if( azArg==0 ) break;
11727:       raw_printf(p->out,"<TR>");
11728:       for(i=0; i<nArg; i++){
11729:         raw_printf(p->out,"<TD>");
11730:         output_html_string(p->out, azArg[i] ? azArg[i] : p->nullValue);
11731:         raw_printf(p->out,"</TD>\n");
11732:       }
11733:       raw_printf(p->out,"</TR>\n");
11734:       break;
11735:     }
11736:     case MODE_Tcl: {
11737:       if( p->cnt++==0 && p->showHeader ){
11738:         for(i=0; i<nArg; i++){
11739:           output_c_string(p->out,azCol[i] ? azCol[i] : "");
11740:           if(i<nArg-1) utf8_printf(p->out, "%s", p->colSeparator);
11741:         }
11742:         utf8_printf(p->out, "%s", p->rowSeparator);
11743:       }
11744:       if( azArg==0 ) break;
11745:       for(i=0; i<nArg; i++){
11746:         output_c_string(p->out, azArg[i] ? azArg[i] : p->nullValue);
11747:         if(i<nArg-1) utf8_printf(p->out, "%s", p->colSeparator);
11748:       }
11749:       utf8_printf(p->out, "%s", p->rowSeparator);
11750:       break;
11751:     }
11752:     case MODE_Csv: {
11753:       setBinaryMode(p->out, 1);
11754:       if( p->cnt++==0 && p->showHeader ){
11755:         for(i=0; i<nArg; i++){
11756:           output_csv(p, azCol[i] ? azCol[i] : "", i<nArg-1);
11757:         }
11758:         utf8_printf(p->out, "%s", p->rowSeparator);
11759:       }
11760:       if( nArg>0 ){
11761:         for(i=0; i<nArg; i++){
11762:           output_csv(p, azArg[i], i<nArg-1);
11763:         }
11764:         utf8_printf(p->out, "%s", p->rowSeparator);
11765:       }
11766:       setTextMode(p->out, 1);
11767:       break;
11768:     }
11769:     case MODE_Insert: {
11770:       if( azArg==0 ) break;
11771:       utf8_printf(p->out,"INSERT INTO %s",p->zDestTable);
11772:       if( p->showHeader ){
11773:         raw_printf(p->out,"(");
11774:         for(i=0; i<nArg; i++){
11775:           if( i>0 ) raw_printf(p->out, ",");
11776:           if( quoteChar(azCol[i]) ){
11777:             char *z = sqlite3_mprintf("\"%w\"", azCol[i]);
11778:             utf8_printf(p->out, "%s", z);
11779:             sqlite3_free(z);
11780:           }else{
11781:             raw_printf(p->out, "%s", azCol[i]);
11782:           }
11783:         }
11784:         raw_printf(p->out,")");
11785:       }
11786:       p->cnt++;
11787:       for(i=0; i<nArg; i++){
11788:         raw_printf(p->out, i>0 ? "," : " VALUES(");
11789:         if( (azArg[i]==0) || (aiType && aiType[i]==SQLITE_NULL) ){
11790:           utf8_printf(p->out,"NULL");
11791:         }else if( aiType && aiType[i]==SQLITE_TEXT ){
11792:           if( ShellHasFlag(p, SHFLG_Newlines) ){
11793:             output_quoted_string(p->out, azArg[i]);
11794:           }else{
11795:             output_quoted_escaped_string(p->out, azArg[i]);
11796:           }
11797:         }else if( aiType && aiType[i]==SQLITE_INTEGER ){
11798:           utf8_printf(p->out,"%s", azArg[i]);
11799:         }else if( aiType && aiType[i]==SQLITE_FLOAT ){
11800:           char z[50];
11801:           double r = sqlite3_column_double(p->pStmt, i);
11802:           sqlite3_uint64 ur;
11803:           memcpy(&ur,&r,sizeof(r));
11804:           if( ur==0x7ff0000000000000LL ){
11805:             raw_printf(p->out, "1e999");
11806:           }else if( ur==0xfff0000000000000LL ){
11807:             raw_printf(p->out, "-1e999");
11808:           }else{
11809:             sqlite3_snprintf(50,z,"%!.20g", r);
11810:             raw_printf(p->out, "%s", z);
11811:           }
11812:         }else if( aiType && aiType[i]==SQLITE_BLOB && p->pStmt ){
11813:           const void *pBlob = sqlite3_column_blob(p->pStmt, i);
11814:           int nBlob = sqlite3_column_bytes(p->pStmt, i);
11815:           output_hex_blob(p->out, pBlob, nBlob);
11816:         }else if( isNumber(azArg[i], 0) ){
11817:           utf8_printf(p->out,"%s", azArg[i]);
11818:         }else if( ShellHasFlag(p, SHFLG_Newlines) ){
11819:           output_quoted_string(p->out, azArg[i]);
11820:         }else{
11821:           output_quoted_escaped_string(p->out, azArg[i]);
11822:         }
11823:       }
11824:       raw_printf(p->out,");\n");
11825:       break;
11826:     }
11827:     case MODE_Json:
11828: 	case MODE_Jsonlines: {
11829:       if( azArg==0 ) break;
11830:       if( p->cnt==0 ){
11831:         if (p->cMode == MODE_Json) {
11832:           fputc('[', p->out);
11833:         }
11834:         fputc('{', p->out);
11835:       }else{
11836:         if (p->cMode == MODE_Json) {
11837:           fputc(',', p->out);
11838:         }
11839:         fputs("\n{", p->out);
11840:       }
11841:       p->cnt++;
11842:       for(i=0; i<nArg; i++){
11843:         output_json_string(p->out, azCol[i], -1);
11844:         putc(':', p->out);
11845:         if( (azArg[i]==0) || (aiType && aiType[i]==SQLITE_NULL) ){
11846:           fputs("null",p->out);
11847:         }else if( aiType && aiType[i]==SQLITE_FLOAT ){
11848:           char z[50];
11849:           double r = sqlite3_column_double(p->pStmt, i);
11850:           sqlite3_uint64 ur;
11851:           memcpy(&ur,&r,sizeof(r));
11852:           if( ur==0x7ff0000000000000LL ){
11853:             raw_printf(p->out, "1e999");
11854:           }else if( ur==0xfff0000000000000LL ){
11855:             raw_printf(p->out, "-1e999");
11856:           }else{
11857:             sqlite3_snprintf(50,z,"%!.20g", r);
11858:             raw_printf(p->out, "%s", z);
11859:           }
11860:         }else if( aiType && aiType[i]==SQLITE_BLOB && p->pStmt ){
11861:           const void *pBlob = sqlite3_column_blob(p->pStmt, i);
11862:           int nBlob = sqlite3_column_bytes(p->pStmt, i);
11863:           output_json_string(p->out, pBlob, nBlob);
11864:         }else if( aiType && aiType[i]==SQLITE_TEXT ){
11865:           output_json_string(p->out, azArg[i], -1);
11866:         }else{
11867:           utf8_printf(p->out,"%s", azArg[i]);
11868:         }
11869:         if( i<nArg-1 ){
11870:           putc(',', p->out);
11871:         }
11872:       }
11873:       putc('}', p->out);
11874:       break;
11875:     }
11876:     case MODE_Quote: {
11877:       if( azArg==0 ) break;
11878:       if( p->cnt==0 && p->showHeader ){
11879:         for(i=0; i<nArg; i++){
11880:           if( i>0 ) fputs(p->colSeparator, p->out);
11881:           output_quoted_string(p->out, azCol[i]);
11882:         }
11883:         fputs(p->rowSeparator, p->out);
11884:       }
11885:       p->cnt++;
11886:       for(i=0; i<nArg; i++){
11887:         if( i>0 ) fputs(p->colSeparator, p->out);
11888:         if( (azArg[i]==0) || (aiType && aiType[i]==SQLITE_NULL) ){
11889:           utf8_printf(p->out,"NULL");
11890:         }else if( aiType && aiType[i]==SQLITE_TEXT ){
11891:           output_quoted_string(p->out, azArg[i]);
11892:         }else if( aiType && aiType[i]==SQLITE_INTEGER ){
11893:           utf8_printf(p->out,"%s", azArg[i]);
11894:         }else if( aiType && aiType[i]==SQLITE_FLOAT ){
11895:           char z[50];
11896:           double r = sqlite3_column_double(p->pStmt, i);
11897:           sqlite3_snprintf(50,z,"%!.20g", r);
11898:           raw_printf(p->out, "%s", z);
11899:         }else if( aiType && aiType[i]==SQLITE_BLOB && p->pStmt ){
11900:           const void *pBlob = sqlite3_column_blob(p->pStmt, i);
11901:           int nBlob = sqlite3_column_bytes(p->pStmt, i);
11902:           output_hex_blob(p->out, pBlob, nBlob);
11903:         }else if( isNumber(azArg[i], 0) ){
11904:           utf8_printf(p->out,"%s", azArg[i]);
11905:         }else{
11906:           output_quoted_string(p->out, azArg[i]);
11907:         }
11908:       }
11909:       fputs(p->rowSeparator, p->out);
11910:       break;
11911:     }
11912:     case MODE_Ascii: {
11913:       if( p->cnt++==0 && p->showHeader ){
11914:         for(i=0; i<nArg; i++){
11915:           if( i>0 ) utf8_printf(p->out, "%s", p->colSeparator);
11916:           utf8_printf(p->out,"%s",azCol[i] ? azCol[i] : "");
11917:         }
11918:         utf8_printf(p->out, "%s", p->rowSeparator);
11919:       }
11920:       if( azArg==0 ) break;
11921:       for(i=0; i<nArg; i++){
11922:         if( i>0 ) utf8_printf(p->out, "%s", p->colSeparator);
11923:         utf8_printf(p->out,"%s",azArg[i] ? azArg[i] : p->nullValue);
11924:       }
11925:       utf8_printf(p->out, "%s", p->rowSeparator);
11926:       break;
11927:     }
11928:     case MODE_EQP: {
11929:       eqp_append(p, atoi(azArg[0]), atoi(azArg[1]), azArg[3]);
11930:       break;
11931:     }
11932:   }
11933:   return 0;
11934: }
11935: 
11936: /*
11937: ** This is the callback routine that the SQLite library
11938: ** invokes for each row of a query result.
11939: */
11940: static int callback(void *pArg, int nArg, char **azArg, char **azCol){
11941:   /* since we don't have type info, call the shell_callback with a NULL value */
11942:   return shell_callback(pArg, nArg, azArg, azCol, NULL);
11943: }
11944: 
11945: /*
11946: ** This is the callback routine from sqlite3_exec() that appends all
11947: ** output onto the end of a ShellText object.
11948: */
11949: static int captureOutputCallback(void *pArg, int nArg, char **azArg, char **az){
11950:   ShellText *p = (ShellText*)pArg;
11951:   int i;
11952:   UNUSED_PARAMETER(az);
11953:   if( azArg==0 ) return 0;
11954:   if( p->n ) appendText(p, "|", 0);
11955:   for(i=0; i<nArg; i++){
11956:     if( i ) appendText(p, ",", 0);
11957:     if( azArg[i] ) appendText(p, azArg[i], 0);
11958:   }
11959:   return 0;
11960: }
11961: 
11962: /*
11963: ** Generate an appropriate SELFTEST table in the main database.
11964: */
11965: static void createSelftestTable(ShellState *p){
11966:   char *zErrMsg = 0;
11967:   sqlite3_exec(p->db,
11968:     "SAVEPOINT selftest_init;\n"
11969:     "CREATE TABLE IF NOT EXISTS selftest(\n"
11970:     "  tno INTEGER PRIMARY KEY,\n"   /* Test number */
11971:     "  op TEXT,\n"                   /* Operator:  memo run */
11972:     "  cmd TEXT,\n"                  /* Command text */
11973:     "  ans TEXT\n"                   /* Desired answer */
11974:     ");"
11975:     "CREATE TEMP TABLE [_shell$self](op,cmd,ans);\n"
11976:     "INSERT INTO [_shell$self](rowid,op,cmd)\n"
11977:     "  VALUES(coalesce((SELECT (max(tno)+100)/10 FROM selftest),10),\n"
11978:     "         'memo','Tests generated by --init');\n"
11979:     "INSERT INTO [_shell$self]\n"
11980:     "  SELECT 'run',\n"
11981:     "    'SELECT hex(sha3_query(''SELECT type,name,tbl_name,sql "
11982:                                  "FROM sqlite_schema ORDER BY 2'',224))',\n"
11983:     "    hex(sha3_query('SELECT type,name,tbl_name,sql "
11984:                           "FROM sqlite_schema ORDER BY 2',224));\n"
11985:     "INSERT INTO [_shell$self]\n"
11986:     "  SELECT 'run',"
11987:     "    'SELECT hex(sha3_query(''SELECT * FROM \"' ||"
11988:     "        printf('%w',name) || '\" NOT INDEXED'',224))',\n"
11989:     "    hex(sha3_query(printf('SELECT * FROM \"%w\" NOT INDEXED',name),224))\n"
11990:     "  FROM (\n"
11991:     "    SELECT name FROM sqlite_schema\n"
11992:     "     WHERE type='table'\n"
11993:     "       AND name<>'selftest'\n"
11994:     "       AND coalesce(rootpage,0)>0\n"
11995:     "  )\n"
11996:     " ORDER BY name;\n"
11997:     "INSERT INTO [_shell$self]\n"
11998:     "  VALUES('run','PRAGMA integrity_check','ok');\n"
11999:     "INSERT INTO selftest(tno,op,cmd,ans)"
12000:     "  SELECT rowid*10,op,cmd,ans FROM [_shell$self];\n"
12001:     "DROP TABLE [_shell$self];"
12002:     ,0,0,&zErrMsg);
12003:   if( zErrMsg ){
12004:     utf8_printf(stderr, "SELFTEST initialization failure: %s\n", zErrMsg);
12005:     sqlite3_free(zErrMsg);
12006:   }
12007:   sqlite3_exec(p->db, "RELEASE selftest_init",0,0,0);
12008: }
12009: 
12010: 
12011: /*
12012: ** Set the destination table field of the ShellState structure to
12013: ** the name of the table given.  Escape any quote characters in the
12014: ** table name.
12015: */
12016: static void set_table_name(ShellState *p, const char *zName){
12017:   int i, n;
12018:   char cQuote;
12019:   char *z;
12020: 
12021:   if( p->zDestTable ){
12022:     free(p->zDestTable);
12023:     p->zDestTable = 0;
12024:   }
12025:   if( zName==0 ) return;
12026:   cQuote = quoteChar(zName);
12027:   n = strlen30(zName);
12028:   if( cQuote ) n += n+2;
12029:   z = p->zDestTable = malloc( n+1 );
12030:   if( z==0 ) shell_out_of_memory();
12031:   n = 0;
12032:   if( cQuote ) z[n++] = cQuote;
12033:   for(i=0; zName[i]; i++){
12034:     z[n++] = zName[i];
12035:     if( zName[i]==cQuote ) z[n++] = cQuote;
12036:   }
12037:   if( cQuote ) z[n++] = cQuote;
12038:   z[n] = 0;
12039: }
12040: 
12041: 
12042: /*
12043: ** Execute a query statement that will generate SQL output.  Print
12044: ** the result columns, comma-separated, on a line and then add a
12045: ** semicolon terminator to the end of that line.
12046: **
12047: ** If the number of columns is 1 and that column contains text "--"
12048: ** then write the semicolon on a separate line.  That way, if a
12049: ** "--" comment occurs at the end of the statement, the comment
12050: ** won't consume the semicolon terminator.
12051: */
12052: static int run_table_dump_query(
12053:   ShellState *p,           /* Query context */
12054:   const char *zSelect      /* SELECT statement to extract content */
12055: ){
12056:   sqlite3_stmt *pSelect;
12057:   int rc;
12058:   int nResult;
12059:   int i;
12060:   const char *z;
12061:   rc = sqlite3_prepare_v2(p->db, zSelect, -1, &pSelect, 0);
12062:   if( rc!=SQLITE_OK || !pSelect ){
12063:     utf8_printf(p->out, "/**** ERROR: (%d) %s *****/\n", rc,
12064:                 sqlite3_errmsg(p->db));
12065:     if( (rc&0xff)!=SQLITE_CORRUPT ) p->nErr++;
12066:     return rc;
12067:   }
12068:   rc = sqlite3_step(pSelect);
12069:   nResult = sqlite3_column_count(pSelect);
12070:   while( rc==SQLITE_ROW ){
12071:     z = (const char*)sqlite3_column_text(pSelect, 0);
12072:     utf8_printf(p->out, "%s", z);
12073:     for(i=1; i<nResult; i++){
12074:       utf8_printf(p->out, ",%s", sqlite3_column_text(pSelect, i));
12075:     }
12076:     if( z==0 ) z = "";
12077:     while( z[0] && (z[0]!='-' || z[1]!='-') ) z++;
12078:     if( z[0] ){
12079:       raw_printf(p->out, "\n;\n");
12080:     }else{
12081:       raw_printf(p->out, ";\n");
12082:     }
12083:     rc = sqlite3_step(pSelect);
12084:   }
12085:   rc = sqlite3_finalize(pSelect);
12086:   if( rc!=SQLITE_OK ){
12087:     utf8_printf(p->out, "/**** ERROR: (%d) %s *****/\n", rc,
12088:                 sqlite3_errmsg(p->db));
12089:     if( (rc&0xff)!=SQLITE_CORRUPT ) p->nErr++;
12090:   }
12091:   return rc;
12092: }
12093: 
12094: /*
12095: ** Allocate space and save off current error string.
12096: */
12097: static char *save_err_msg(
12098:   sqlite3 *db            /* Database to query */
12099: ){
12100:   int nErrMsg = 1+strlen30(sqlite3_errmsg(db));
12101:   char *zErrMsg = sqlite3_malloc64(nErrMsg);
12102:   if( zErrMsg ){
12103:     memcpy(zErrMsg, sqlite3_errmsg(db), nErrMsg);
12104:   }
12105:   return zErrMsg;
12106: }
12107: 
12108: #ifdef __linux__
12109: /*
12110: ** Attempt to display I/O stats on Linux using /proc/PID/io
12111: */
12112: static void displayLinuxIoStats(FILE *out){
12113:   FILE *in;
12114:   char z[200];
12115:   sqlite3_snprintf(sizeof(z), z, "/proc/%d/io", getpid());
12116:   in = fopen(z, "rb");
12117:   if( in==0 ) return;
12118:   while( fgets(z, sizeof(z), in)!=0 ){
12119:     static const struct {
12120:       const char *zPattern;
12121:       const char *zDesc;
12122:     } aTrans[] = {
12123:       { "rchar: ",                  "Bytes received by read():" },
12124:       { "wchar: ",                  "Bytes sent to write():"    },
12125:       { "syscr: ",                  "Read() system calls:"      },
12126:       { "syscw: ",                  "Write() system calls:"     },
12127:       { "read_bytes: ",             "Bytes read from storage:"  },
12128:       { "write_bytes: ",            "Bytes written to storage:" },
12129:       { "cancelled_write_bytes: ",  "Cancelled write bytes:"    },
12130:     };
12131:     int i;
12132:     for(i=0; i<ArraySize(aTrans); i++){
12133:       int n = strlen30(aTrans[i].zPattern);
12134:       if( strncmp(aTrans[i].zPattern, z, n)==0 ){
12135:         utf8_printf(out, "%-36s %s", aTrans[i].zDesc, &z[n]);
12136:         break;
12137:       }
12138:     }
12139:   }
12140:   fclose(in);
12141: }
12142: #endif
12143: 
12144: /*
12145: ** Display a single line of status using 64-bit values.
12146: */
12147: static void displayStatLine(
12148:   ShellState *p,            /* The shell context */
12149:   char *zLabel,             /* Label for this one line */
12150:   char *zFormat,            /* Format for the result */
12151:   int iStatusCtrl,          /* Which status to display */
12152:   int bReset                /* True to reset the stats */
12153: ){
12154:   sqlite3_int64 iCur = -1;
12155:   sqlite3_int64 iHiwtr = -1;
12156:   int i, nPercent;
12157:   char zLine[200];
12158:   sqlite3_status64(iStatusCtrl, &iCur, &iHiwtr, bReset);
12159:   for(i=0, nPercent=0; zFormat[i]; i++){
12160:     if( zFormat[i]=='%' ) nPercent++;
12161:   }
12162:   if( nPercent>1 ){
12163:     sqlite3_snprintf(sizeof(zLine), zLine, zFormat, iCur, iHiwtr);
12164:   }else{
12165:     sqlite3_snprintf(sizeof(zLine), zLine, zFormat, iHiwtr);
12166:   }
12167:   raw_printf(p->out, "%-36s %s\n", zLabel, zLine);
12168: }
12169: 
12170: /*
12171: ** Display memory stats.
12172: */
12173: static int display_stats(
12174:   sqlite3 *db,                /* Database to query */
12175:   ShellState *pArg,           /* Pointer to ShellState */
12176:   int bReset                  /* True to reset the stats */
12177: ){
12178:   int iCur;
12179:   int iHiwtr;
12180:   FILE *out;
12181:   if( pArg==0 || pArg->out==0 ) return 0;
12182:   out = pArg->out;
12183: 
12184:   if( pArg->pStmt && (pArg->statsOn & 2) ){
12185:     int nCol, i, x;
12186:     sqlite3_stmt *pStmt = pArg->pStmt;
12187:     char z[100];
12188:     nCol = sqlite3_column_count(pStmt);
12189:     raw_printf(out, "%-36s %d\n", "Number of output columns:", nCol);
12190:     for(i=0; i<nCol; i++){
12191:       sqlite3_snprintf(sizeof(z),z,"Column %d %nname:", i, &x);
12192:       utf8_printf(out, "%-36s %s\n", z, sqlite3_column_name(pStmt,i));
12193: #ifndef SQLITE_OMIT_DECLTYPE
12194:       sqlite3_snprintf(30, z+x, "declared type:");
12195:       utf8_printf(out, "%-36s %s\n", z, sqlite3_column_decltype(pStmt, i));
12196: #endif
12197: #ifdef SQLITE_ENABLE_COLUMN_METADATA
12198:       sqlite3_snprintf(30, z+x, "database name:");
12199:       utf8_printf(out, "%-36s %s\n", z, sqlite3_column_database_name(pStmt,i));
12200:       sqlite3_snprintf(30, z+x, "table name:");
12201:       utf8_printf(out, "%-36s %s\n", z, sqlite3_column_table_name(pStmt,i));
12202:       sqlite3_snprintf(30, z+x, "origin name:");
12203:       utf8_printf(out, "%-36s %s\n", z, sqlite3_column_origin_name(pStmt,i));
12204: #endif
12205:     }
12206:   }
12207: 
12208:   displayStatLine(pArg, "Memory Used:",
12209:      "%lld (max %lld) bytes", SQLITE_STATUS_MEMORY_USED, bReset);
12210:   displayStatLine(pArg, "Number of Outstanding Allocations:",
12211:      "%lld (max %lld)", SQLITE_STATUS_MALLOC_COUNT, bReset);
12212:   if( pArg->shellFlgs & SHFLG_Pagecache ){
12213:     displayStatLine(pArg, "Number of Pcache Pages Used:",
12214:        "%lld (max %lld) pages", SQLITE_STATUS_PAGECACHE_USED, bReset);
12215:   }
12216:   displayStatLine(pArg, "Number of Pcache Overflow Bytes:",
12217:      "%lld (max %lld) bytes", SQLITE_STATUS_PAGECACHE_OVERFLOW, bReset);
12218:   displayStatLine(pArg, "Largest Allocation:",
12219:      "%lld bytes", SQLITE_STATUS_MALLOC_SIZE, bReset);
12220:   displayStatLine(pArg, "Largest Pcache Allocation:",
12221:      "%lld bytes", SQLITE_STATUS_PAGECACHE_SIZE, bReset);
12222: #ifdef YYTRACKMAXSTACKDEPTH
12223:   displayStatLine(pArg, "Deepest Parser Stack:",
12224:      "%lld (max %lld)", SQLITE_STATUS_PARSER_STACK, bReset);
12225: #endif
12226: 
12227:   if( db ){
12228:     if( pArg->shellFlgs & SHFLG_Lookaside ){
12229:       iHiwtr = iCur = -1;
12230:       sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_USED,
12231:                         &iCur, &iHiwtr, bReset);
12232:       raw_printf(pArg->out,
12233:               "Lookaside Slots Used:                %d (max %d)\n",
12234:               iCur, iHiwtr);
12235:       sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_HIT,
12236:                         &iCur, &iHiwtr, bReset);
12237:       raw_printf(pArg->out, "Successful lookaside attempts:       %d\n",
12238:               iHiwtr);
12239:       sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE,
12240:                         &iCur, &iHiwtr, bReset);
12241:       raw_printf(pArg->out, "Lookaside failures due to size:      %d\n",
12242:               iHiwtr);
12243:       sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL,
12244:                         &iCur, &iHiwtr, bReset);
12245:       raw_printf(pArg->out, "Lookaside failures due to OOM:       %d\n",
12246:               iHiwtr);
12247:     }
12248:     iHiwtr = iCur = -1;
12249:     sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_USED, &iCur, &iHiwtr, bReset);
12250:     raw_printf(pArg->out, "Pager Heap Usage:                    %d bytes\n",
12251:             iCur);
12252:     iHiwtr = iCur = -1;
12253:     sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_HIT, &iCur, &iHiwtr, 1);
12254:     raw_printf(pArg->out, "Page cache hits:                     %d\n", iCur);
12255:     iHiwtr = iCur = -1;
12256:     sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_MISS, &iCur, &iHiwtr, 1);
12257:     raw_printf(pArg->out, "Page cache misses:                   %d\n", iCur);
12258:     iHiwtr = iCur = -1;
12259:     sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_WRITE, &iCur, &iHiwtr, 1);
12260:     raw_printf(pArg->out, "Page cache writes:                   %d\n", iCur);
12261:     iHiwtr = iCur = -1;
12262:     sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_SPILL, &iCur, &iHiwtr, 1);
12263:     raw_printf(pArg->out, "Page cache spills:                   %d\n", iCur);
12264:     iHiwtr = iCur = -1;
12265:     sqlite3_db_status(db, SQLITE_DBSTATUS_SCHEMA_USED, &iCur, &iHiwtr, bReset);
12266:     raw_printf(pArg->out, "Schema Heap Usage:                   %d bytes\n",
12267:             iCur);
12268:     iHiwtr = iCur = -1;
12269:     sqlite3_db_status(db, SQLITE_DBSTATUS_STMT_USED, &iCur, &iHiwtr, bReset);
12270:     raw_printf(pArg->out, "Statement Heap/Lookaside Usage:      %d bytes\n",
12271:             iCur);
12272:   }
12273: 
12274:   if( pArg->pStmt ){
12275:     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_FULLSCAN_STEP,
12276:                                bReset);
12277:     raw_printf(pArg->out, "Fullscan Steps:                      %d\n", iCur);
12278:     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_SORT, bReset);
12279:     raw_printf(pArg->out, "Sort Operations:                     %d\n", iCur);
12280:     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_AUTOINDEX,bReset);
12281:     raw_printf(pArg->out, "Autoindex Inserts:                   %d\n", iCur);
12282:     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_VM_STEP, bReset);
12283:     raw_printf(pArg->out, "Virtual Machine Steps:               %d\n", iCur);
12284:     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_REPREPARE,bReset);
12285:     raw_printf(pArg->out, "Reprepare operations:                %d\n", iCur);
12286:     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_RUN, bReset);
12287:     raw_printf(pArg->out, "Number of times run:                 %d\n", iCur);
12288:     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_MEMUSED, bReset);
12289:     raw_printf(pArg->out, "Memory used by prepared stmt:        %d\n", iCur);
12290:   }
12291: 
12292: #ifdef __linux__
12293:   displayLinuxIoStats(pArg->out);
12294: #endif
12295: 
12296:   /* Do not remove this machine readable comment: extra-stats-output-here */
12297: 
12298:   return 0;
12299: }
12300: 
12301: /*
12302: ** Display scan stats.
12303: */
12304: static void display_scanstats(
12305:   sqlite3 *db,                    /* Database to query */
12306:   ShellState *pArg                /* Pointer to ShellState */
12307: ){
12308: #ifndef SQLITE_ENABLE_STMT_SCANSTATUS
12309:   UNUSED_PARAMETER(db);
12310:   UNUSED_PARAMETER(pArg);
12311: #else
12312:   int i, k, n, mx;
12313:   raw_printf(pArg->out, "-------- scanstats --------\n");
12314:   mx = 0;
12315:   for(k=0; k<=mx; k++){
12316:     double rEstLoop = 1.0;
12317:     for(i=n=0; 1; i++){
12318:       sqlite3_stmt *p = pArg->pStmt;
12319:       sqlite3_int64 nLoop, nVisit;
12320:       double rEst;
12321:       int iSid;
12322:       const char *zExplain;
12323:       if( sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_NLOOP, (void*)&nLoop) ){
12324:         break;
12325:       }
12326:       sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_SELECTID, (void*)&iSid);
12327:       if( iSid>mx ) mx = iSid;
12328:       if( iSid!=k ) continue;
12329:       if( n==0 ){
12330:         rEstLoop = (double)nLoop;
12331:         if( k>0 ) raw_printf(pArg->out, "-------- subquery %d -------\n", k);
12332:       }
12333:       n++;
12334:       sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_NVISIT, (void*)&nVisit);
12335:       sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_EST, (void*)&rEst);
12336:       sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_EXPLAIN, (void*)&zExplain);
12337:       utf8_printf(pArg->out, "Loop %2d: %s\n", n, zExplain);
12338:       rEstLoop *= rEst;
12339:       raw_printf(pArg->out,
12340:           "         nLoop=%-8lld nRow=%-8lld estRow=%-8lld estRow/Loop=%-8g\n",
12341:           nLoop, nVisit, (sqlite3_int64)(rEstLoop+0.5), rEst
12342:       );
12343:     }
12344:   }
12345:   raw_printf(pArg->out, "---------------------------\n");
12346: #endif
12347: }
12348: 
12349: /*
12350: ** Parameter azArray points to a zero-terminated array of strings. zStr
12351: ** points to a single nul-terminated string. Return non-zero if zStr
12352: ** is equal, according to strcmp(), to any of the strings in the array.
12353: ** Otherwise, return zero.
12354: */
12355: static int str_in_array(const char *zStr, const char **azArray){
12356:   int i;
12357:   for(i=0; azArray[i]; i++){
12358:     if( 0==strcmp(zStr, azArray[i]) ) return 1;
12359:   }
12360:   return 0;
12361: }
12362: 
12363: /*
12364: ** If compiled statement pSql appears to be an EXPLAIN statement, allocate
12365: ** and populate the ShellState.aiIndent[] array with the number of
12366: ** spaces each opcode should be indented before it is output.
12367: **
12368: ** The indenting rules are:
12369: **
12370: **     * For each "Next", "Prev", "VNext" or "VPrev" instruction, indent
12371: **       all opcodes that occur between the p2 jump destination and the opcode
12372: **       itself by 2 spaces.
12373: **
12374: **     * For each "Goto", if the jump destination is earlier in the program
12375: **       and ends on one of:
12376: **          Yield  SeekGt  SeekLt  RowSetRead  Rewind
12377: **       or if the P1 parameter is one instead of zero,
12378: **       then indent all opcodes between the earlier instruction
12379: **       and "Goto" by 2 spaces.
12380: */
12381: static void explain_data_prepare(ShellState *p, sqlite3_stmt *pSql){
12382:   const char *zSql;               /* The text of the SQL statement */
12383:   const char *z;                  /* Used to check if this is an EXPLAIN */
12384:   int *abYield = 0;               /* True if op is an OP_Yield */
12385:   int nAlloc = 0;                 /* Allocated size of p->aiIndent[], abYield */
12386:   int iOp;                        /* Index of operation in p->aiIndent[] */
12387: 
12388:   const char *azNext[] = { "Next", "Prev", "VPrev", "VNext", "SorterNext", 0 };
12389:   const char *azYield[] = { "Yield", "SeekLT", "SeekGT", "RowSetRead",
12390:                             "Rewind", 0 };
12391:   const char *azGoto[] = { "Goto", 0 };
12392: 
12393:   /* Try to figure out if this is really an EXPLAIN statement. If this
12394:   ** cannot be verified, return early.  */
12395:   if( sqlite3_column_count(pSql)!=8 ){
12396:     p->cMode = p->mode;
12397:     return;
12398:   }
12399:   zSql = sqlite3_sql(pSql);
12400:   if( zSql==0 ) return;
12401:   for(z=zSql; *z==' ' || *z=='\t' || *z=='\n' || *z=='\f' || *z=='\r'; z++);
12402:   if( sqlite3_strnicmp(z, "explain", 7) ){
12403:     p->cMode = p->mode;
12404:     return;
12405:   }
12406: 
12407:   for(iOp=0; SQLITE_ROW==sqlite3_step(pSql); iOp++){
12408:     int i;
12409:     int iAddr = sqlite3_column_int(pSql, 0);
12410:     const char *zOp = (const char*)sqlite3_column_text(pSql, 1);
12411: 
12412:     /* Set p2 to the P2 field of the current opcode. Then, assuming that
12413:     ** p2 is an instruction address, set variable p2op to the index of that
12414:     ** instruction in the aiIndent[] array. p2 and p2op may be different if
12415:     ** the current instruction is part of a sub-program generated by an
12416:     ** SQL trigger or foreign key.  */
12417:     int p2 = sqlite3_column_int(pSql, 3);
12418:     int p2op = (p2 + (iOp-iAddr));
12419: 
12420:     /* Grow the p->aiIndent array as required */
12421:     if( iOp>=nAlloc ){
12422:       if( iOp==0 ){
12423:         /* Do further verfication that this is explain output.  Abort if
12424:         ** it is not */
12425:         static const char *explainCols[] = {
12426:            "addr", "opcode", "p1", "p2", "p3", "p4", "p5", "comment" };
12427:         int jj;
12428:         for(jj=0; jj<ArraySize(explainCols); jj++){
12429:           if( strcmp(sqlite3_column_name(pSql,jj),explainCols[jj])!=0 ){
12430:             p->cMode = p->mode;
12431:             sqlite3_reset(pSql);
12432:             return;
12433:           }
12434:         }
12435:       }
12436:       nAlloc += 100;
12437:       p->aiIndent = (int*)sqlite3_realloc64(p->aiIndent, nAlloc*sizeof(int));
12438:       if( p->aiIndent==0 ) shell_out_of_memory();
12439:       abYield = (int*)sqlite3_realloc64(abYield, nAlloc*sizeof(int));
12440:       if( abYield==0 ) shell_out_of_memory();
12441:     }
12442:     abYield[iOp] = str_in_array(zOp, azYield);
12443:     p->aiIndent[iOp] = 0;
12444:     p->nIndent = iOp+1;
12445: 
12446:     if( str_in_array(zOp, azNext) ){
12447:       for(i=p2op; i<iOp; i++) p->aiIndent[i] += 2;
12448:     }
12449:     if( str_in_array(zOp, azGoto) && p2op<p->nIndent
12450:      && (abYield[p2op] || sqlite3_column_int(pSql, 2))
12451:     ){
12452:       for(i=p2op; i<iOp; i++) p->aiIndent[i] += 2;
12453:     }
12454:   }
12455: 
12456:   p->iIndent = 0;
12457:   sqlite3_free(abYield);
12458:   sqlite3_reset(pSql);
12459: }
12460: 
12461: /*
12462: ** Free the array allocated by explain_data_prepare().
12463: */
12464: static void explain_data_delete(ShellState *p){
12465:   sqlite3_free(p->aiIndent);
12466:   p->aiIndent = 0;
12467:   p->nIndent = 0;
12468:   p->iIndent = 0;
12469: }
12470: 
12471: /*
12472: ** Disable and restore .wheretrace and .selecttrace settings.
12473: */
12474: #if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_SELECTTRACE)
12475: extern unsigned int sqlite3_unsupported_selecttrace;
12476: static int savedSelectTrace;
12477: #endif
12478: #if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)
12479: extern int sqlite3WhereTrace;
12480: static int savedWhereTrace;
12481: #endif
12482: static void disable_debug_trace_modes(void){
12483: #if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_SELECTTRACE)
12484:   savedSelectTrace = sqlite3_unsupported_selecttrace;
12485:   sqlite3_unsupported_selecttrace = 0;
12486: #endif
12487: #if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)
12488:   savedWhereTrace = sqlite3WhereTrace;
12489:   sqlite3WhereTrace = 0;
12490: #endif
12491: }
12492: static void restore_debug_trace_modes(void){
12493: #if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_SELECTTRACE)
12494:   sqlite3_unsupported_selecttrace = savedSelectTrace;
12495: #endif
12496: #if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)
12497:   sqlite3WhereTrace = savedWhereTrace;
12498: #endif
12499: }
12500: 
12501: /* Create the TEMP table used to store parameter bindings */
12502: static void bind_table_init(ShellState *p){
12503:   int wrSchema = 0;
12504:   int defensiveMode = 0;
12505:   sqlite3_db_config(p->db, SQLITE_DBCONFIG_DEFENSIVE, -1, &defensiveMode);
12506:   sqlite3_db_config(p->db, SQLITE_DBCONFIG_DEFENSIVE, 0, 0);
12507:   sqlite3_db_config(p->db, SQLITE_DBCONFIG_WRITABLE_SCHEMA, -1, &wrSchema);
12508:   sqlite3_db_config(p->db, SQLITE_DBCONFIG_WRITABLE_SCHEMA, 1, 0);
12509:   sqlite3_exec(p->db,
12510:     "CREATE TABLE IF NOT EXISTS temp.sqlite_parameters(\n"
12511:     "  key TEXT PRIMARY KEY,\n"
12512:     "  value ANY\n"
12513:     ") WITHOUT ROWID;",
12514:     0, 0, 0);
12515:   sqlite3_db_config(p->db, SQLITE_DBCONFIG_WRITABLE_SCHEMA, wrSchema, 0);
12516:   sqlite3_db_config(p->db, SQLITE_DBCONFIG_DEFENSIVE, defensiveMode, 0);
12517: }
12518: 
12519: /*
12520: ** Bind parameters on a prepared statement.
12521: **
12522: ** Parameter bindings are taken from a TEMP table of the form:
12523: **
12524: **    CREATE TEMP TABLE sqlite_parameters(key TEXT PRIMARY KEY, value)
12525: **    WITHOUT ROWID;
12526: **
12527: ** No bindings occur if this table does not exist.  The name of the table
12528: ** begins with "sqlite_" so that it will not collide with ordinary application
12529: ** tables.  The table must be in the TEMP schema.
12530: */
12531: static void bind_prepared_stmt(ShellState *pArg, sqlite3_stmt *pStmt){
12532:   int nVar;
12533:   int i;
12534:   int rc;
12535:   sqlite3_stmt *pQ = 0;
12536: 
12537:   nVar = sqlite3_bind_parameter_count(pStmt);
12538:   if( nVar==0 ) return;  /* Nothing to do */
12539:   if( sqlite3_table_column_metadata(pArg->db, "TEMP", "sqlite_parameters",
12540:                                     "key", 0, 0, 0, 0, 0)!=SQLITE_OK ){
12541:     return; /* Parameter table does not exist */
12542:   }
12543:   rc = sqlite3_prepare_v2(pArg->db,
12544:           "SELECT value FROM temp.sqlite_parameters"
12545:           " WHERE key=?1", -1, &pQ, 0);
12546:   if( rc || pQ==0 ) return;
12547:   for(i=1; i<=nVar; i++){
12548:     char zNum[30];
12549:     const char *zVar = sqlite3_bind_parameter_name(pStmt, i);
12550:     if( zVar==0 ){
12551:       sqlite3_snprintf(sizeof(zNum),zNum,"?%d",i);
12552:       zVar = zNum;
12553:     }
12554:     sqlite3_bind_text(pQ, 1, zVar, -1, SQLITE_STATIC);
12555:     if( sqlite3_step(pQ)==SQLITE_ROW ){
12556:       sqlite3_bind_value(pStmt, i, sqlite3_column_value(pQ, 0));
12557:     }else{
12558:       sqlite3_bind_null(pStmt, i);
12559:     }
12560:     sqlite3_reset(pQ);
12561:   }
12562:   sqlite3_finalize(pQ);
12563: }
12564: 
12565: /*
12566: ** UTF8 box-drawing characters.  Imagine box lines like this:
12567: **
12568: **           1
12569: **           |
12570: **       4 --+-- 2
12571: **           |
12572: **           3
12573: **
12574: ** Each box characters has between 2 and 4 of the lines leading from
12575: ** the center.  The characters are here identified by the numbers of
12576: ** their corresponding lines.
12577: */
12578: #define BOX_24   "\342\224\200"  /* U+2500 --- */
12579: #define BOX_13   "\342\224\202"  /* U+2502  |  */
12580: #define BOX_23   "\342\224\214"  /* U+250c  ,- */
12581: #define BOX_34   "\342\224\220"  /* U+2510 -,  */
12582: #define BOX_12   "\342\224\224"  /* U+2514  '- */
12583: #define BOX_14   "\342\224\230"  /* U+2518 -'  */
12584: #define BOX_123  "\342\224\234"  /* U+251c  |- */
12585: #define BOX_134  "\342\224\244"  /* U+2524 -|  */
12586: #define BOX_234  "\342\224\254"  /* U+252c -,- */
12587: #define BOX_124  "\342\224\264"  /* U+2534 -'- */
12588: #define BOX_1234 "\342\224\274"  /* U+253c -|- */
12589: 
12590: /* Draw horizontal line N characters long using unicode box
12591: ** characters
12592: */
12593: static void print_box_line(FILE *out, int N){
12594:   const char zDash[] =
12595:       BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24
12596:       BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24 BOX_24;
12597:   const int nDash = sizeof(zDash) - 1;
12598:   N *= 3;
12599:   while( N>nDash ){
12600:     utf8_printf(out, zDash);
12601:     N -= nDash;
12602:   }
12603:   utf8_printf(out, "%.*s", N, zDash);
12604: }
12605: 
12606: /*
12607: ** Draw a horizontal separator for a MODE_Box table.
12608: */
12609: static void print_box_row_separator(
12610:   ShellState *p,
12611:   int nArg,
12612:   const char *zSep1,
12613:   const char *zSep2,
12614:   const char *zSep3
12615: ){
12616:   int i;
12617:   if( nArg>0 ){
12618:     utf8_printf(p->out, "%s", zSep1);
12619:     print_box_line(p->out, p->actualWidth[0]+2);
12620:     for(i=1; i<nArg; i++){
12621:       utf8_printf(p->out, "%s", zSep2);
12622:       print_box_line(p->out, p->actualWidth[i]+2);
12623:     }
12624:     utf8_printf(p->out, "%s", zSep3);
12625:   }
12626:   fputs("\n", p->out);
12627: }
12628: 
12629: 
12630: char *strdup_handle_newline(ShellState *p, const char *z) {
12631:   if (!z) {
12632:     return 0;
12633:   }
12634:   if (p->cMode != MODE_Box) {
12635:     return strdup(z);
12636:   }
12637:   int max_size = 80;
12638:   char *result = malloc(max_size * 2 + 10);
12639:   char *t = result;
12640:   int count = 0;
12641:   int interrupted = 0;
12642:   const char *s;
12643:   for(s = z; *s; s++, t++) {
12644:     if (*s == '\n') {
12645:       *t = '\\';
12646:       t++;
12647:       *t = 'n';
12648:     } else {
12649:       *t = *s;
12650:     }
12651:     count++;
12652:     if (count >= max_size && ((*s & 0xc0) != 0x80)) {
12653:       interrupted = 1;
12654:       break;
12655:     }
12656:   }
12657:   if (interrupted) {
12658:     *t++ = '.';
12659:     *t++ = '.';
12660:     *t++ = '.';
12661:   }
12662:   *t = '\0';
12663:   return result;
12664: }
12665: 
12666: int column_type_is_integer(const char *type) {
12667:   if (!type) {
12668:     return 0;
12669:   }
12670:   if (strcmp(type, "TINYINT") == 0) {
12671:     return 1;
12672:   }
12673:   if (strcmp(type, "SMALLINT") == 0) {
12674:     return 1;
12675:   }
12676:   if (strcmp(type, "INTEGER") == 0) {
12677:     return 1;
12678:   }
12679:   if (strcmp(type, "BIGINT") == 0) {
12680:     return 1;
12681:   }
12682:   if (strcmp(type, "FLOAT") == 0) {
12683:     return 1;
12684:   }
12685:   if (strcmp(type, "DOUBLE") == 0) {
12686:     return 1;
12687:   }
12688:   if (strcmp(type, "DECIMAL") == 0) {
12689:     return 1;
12690:   }
12691:   return 0;
12692: }
12693: 
12694: /*
12695: ** Run a prepared statement and output the result in one of the
12696: ** table-oriented formats: MODE_Column, MODE_Markdown, MODE_Table,
12697: ** or MODE_Box.
12698: **
12699: ** This is different from ordinary exec_prepared_stmt() in that
12700: ** it has to run the entire query and gather the results into memory
12701: ** first, in order to determine column widths, before providing
12702: ** any output.
12703: */
12704: static void exec_prepared_stmt_columnar(
12705:   ShellState *p,                        /* Pointer to ShellState */
12706:   sqlite3_stmt *pStmt                   /* Statment to run */
12707: ){
12708:   sqlite3_int64 nRow = 0;
12709:   int nColumn = 0;
12710:   char **azData = 0;
12711:   sqlite3_int64 nAlloc = 0;
12712:   const char *z;
12713:   int rc;
12714:   sqlite3_int64 i, nData;
12715:   int j, nTotal, w, n;
12716:   const char *colSep = 0;
12717:   const char *rowSep = 0;
12718: 
12719:   rc = sqlite3_step(pStmt);
12720:   if( rc!=SQLITE_ROW ) return;
12721:   nColumn = sqlite3_column_count(pStmt);
12722:   nAlloc = nColumn*4;
12723:   azData = sqlite3_malloc64( nAlloc*sizeof(char*) );
12724:   if( azData==0 ) shell_out_of_memory();
12725:   for(i=0; i<nColumn; i++){
12726:     azData[i] = strdup_handle_newline(p, sqlite3_column_name(pStmt,i));
12727:   }
12728:   do{
12729:     if( (nRow+2)*nColumn >= nAlloc ){
12730:       nAlloc *= 2;
12731:       azData = sqlite3_realloc64(azData, nAlloc*sizeof(char*));
12732:       if( azData==0 ) shell_out_of_memory();
12733:     }
12734:     nRow++;
12735:     for(i=0; i<nColumn; i++){
12736:       z = (const char*)sqlite3_column_text(pStmt,i);
12737:       azData[nRow*nColumn + i] = strdup_handle_newline(p, z);
12738:     }
12739:   }while( (rc = sqlite3_step(pStmt))==SQLITE_ROW );
12740:   if( nColumn>p->nWidth ){
12741:     p->colWidth = realloc(p->colWidth, nColumn*2*sizeof(int));
12742:     if( p->colWidth==0 ) shell_out_of_memory();
12743:     for(i=p->nWidth; i<nColumn; i++) p->colWidth[i] = 0;
12744:     p->nWidth = nColumn;
12745:     p->actualWidth = &p->colWidth[nColumn];
12746:   }
12747:   memset(p->actualWidth, 0, nColumn*sizeof(int));
12748:   for(i=0; i<nColumn; i++){
12749:     w = p->colWidth[i];
12750:     if( w<0 ) w = -w;
12751:     p->actualWidth[i] = w;
12752:   }
12753:   nTotal = nColumn*(nRow+1);
12754:   for(i=0; i<nTotal; i++){
12755:     z = azData[i];
12756:     if( z==0 ) z = p->nullValue;
12757:     n = strlenChar(z);
12758:     j = i%nColumn;
12759:     if( n>p->actualWidth[j] ) p->actualWidth[j] = n;
12760:   }
12761:   if( seenInterrupt ) goto columnar_end;
12762:   switch( p->cMode ){
12763:     case MODE_Column: {
12764:       colSep = "  ";
12765:       rowSep = "\n";
12766:       if( p->showHeader ){
12767:         for(i=0; i<nColumn; i++){
12768:           w = p->actualWidth[i];
12769:           if( p->colWidth[i]<0 ) w = -w;
12770:           utf8_width_print(p->out, w, azData[i]);
12771:           fputs(i==nColumn-1?"\n":"  ", p->out);
12772:         }
12773:         for(i=0; i<nColumn; i++){
12774:           print_dashes(p->out, p->actualWidth[i]);
12775:           fputs(i==nColumn-1?"\n":"  ", p->out);
12776:         }
12777:       }
12778:       break;
12779:     }
12780:     case MODE_Table: {
12781:       colSep = " | ";
12782:       rowSep = " |\n";
12783:       print_row_separator(p, nColumn, "+");
12784:       fputs("| ", p->out);
12785:       for(i=0; i<nColumn; i++){
12786:         w = p->actualWidth[i];
12787:         n = strlenChar(azData[i]);
12788:         utf8_printf(p->out, "%*s%s%*s", (w-n)/2, "", azData[i], (w-n+1)/2, "");
12789:         fputs(i==nColumn-1?" |\n":" | ", p->out);
12790:       }
12791:       print_row_separator(p, nColumn, "+");
12792:       break;
12793:     }
12794:     case MODE_Markdown: {
12795:       colSep = " | ";
12796:       rowSep = " |\n";
12797:       fputs("| ", p->out);
12798:       for(i=0; i<nColumn; i++){
12799:         w = p->actualWidth[i];
12800:         n = strlenChar(azData[i]);
12801:         utf8_printf(p->out, "%*s%s%*s", (w-n)/2, "", azData[i], (w-n+1)/2, "");
12802:         fputs(i==nColumn-1?" |\n":" | ", p->out);
12803:       }
12804:       print_row_separator(p, nColumn, "|");
12805:       break;
12806:     }
12807:     case MODE_Box: {
12808:       colSep = " " BOX_13 " ";
12809:       rowSep = " " BOX_13 "\n";
12810:       print_box_row_separator(p, nColumn, BOX_23, BOX_234, BOX_34);
12811:       utf8_printf(p->out, BOX_13 " ");
12812:       for(i=0; i<nColumn; i++){
12813:         w = p->actualWidth[i];
12814:         n = strlenChar(azData[i]);
12815:         utf8_printf(p->out, "%*s%s%*s%s",
12816:             (w-n)/2, "", azData[i], (w-n+1)/2, "",
12817:             i==nColumn-1?" "BOX_13"\n":" "BOX_13" ");
12818:       }
12819:       print_box_row_separator(p, nColumn, BOX_123, BOX_1234, BOX_134);
12820:       break;
12821:     }
12822:     case MODE_Latex: {
12823:       colSep = " & ";
12824:       rowSep = " \\\\\n";
12825:       fputs("\\begin{tabular}{|", p->out);
12826:       for(i=0; i<nColumn; i++){
12827:         const char *column_type = sqlite3_column_decltype(pStmt, i);
12828:         if (column_type_is_integer(column_type)) {
12829:           fputs("r", p->out);
12830:         } else {
12831:           fputs("l", p->out);
12832:         }
12833:       }
12834:       fputs("|}\n", p->out);
12835:       fputs("\\hline\n", p->out);
12836:       for(i=0; i<nColumn; i++){
12837:         w = p->actualWidth[i];
12838:         n = strlenChar(azData[i]);
12839:         utf8_printf(p->out, "%*s%s%*s", (w-n)/2, "", azData[i], (w-n+1)/2, "");
12840:         fputs(i==nColumn-1? rowSep:colSep, p->out);
12841:       }
12842:       fputs("\\hline\n", p->out);
12843:       break;
12844:     }
12845:   }
12846:   for(i=nColumn, j=0; i<nTotal; i++, j++){
12847:     if( j==0 && p->cMode!=MODE_Column && p->cMode != MODE_Latex ){
12848:       utf8_printf(p->out, "%s", p->cMode==MODE_Box?BOX_13" ":"| ");
12849:     }
12850:     z = azData[i];
12851:     if( z==0 ) z = p->nullValue;
12852:     w = p->actualWidth[j];
12853:     if( p->colWidth[j]<0 ) w = -w;
12854:     utf8_width_print(p->out, w, z);
12855:     if( j==nColumn-1 ){
12856:       utf8_printf(p->out, "%s", rowSep);
12857:       j = -1;
12858:       if( seenInterrupt ) goto columnar_end;
12859:     }else{
12860:       utf8_printf(p->out, "%s", colSep);
12861:     }
12862:   }
12863:   if( p->cMode==MODE_Table ){
12864:     print_row_separator(p, nColumn, "+");
12865:   }else if( p->cMode==MODE_Box ){
12866:     print_box_row_separator(p, nColumn, BOX_12, BOX_124, BOX_14);
12867:   } else if (p->cMode == MODE_Latex) {
12868:     fputs("\\hline\n", p->out);
12869:     fputs("\\end{tabular}\n", p->out);
12870:   }
12871: columnar_end:
12872:   if( seenInterrupt ){
12873:     utf8_printf(p->out, "Interrupt\n");
12874:   }
12875:   nData = (nRow+1)*nColumn;
12876:   for(i=0; i<nData; i++) free(azData[i]);
12877:   sqlite3_free(azData);
12878: }
12879: 
12880: /*
12881: ** Run a prepared statement
12882: */
12883: static void exec_prepared_stmt(
12884:   ShellState *pArg,                                /* Pointer to ShellState */
12885:   sqlite3_stmt *pStmt                              /* Statment to run */
12886: ){
12887:   int rc;
12888: 
12889:   if( pArg->cMode==MODE_Column
12890:    || pArg->cMode==MODE_Table
12891:    || pArg->cMode==MODE_Box
12892:    || pArg->cMode==MODE_Markdown
12893:    || pArg->cMode==MODE_Latex
12894:   ){
12895:     exec_prepared_stmt_columnar(pArg, pStmt);
12896:     return;
12897:   }
12898: 
12899:   /* perform the first step.  this will tell us if we
12900:   ** have a result set or not and how wide it is.
12901:   */
12902:   rc = sqlite3_step(pStmt);
12903:   /* if we have a result set... */
12904:   if( SQLITE_ROW == rc ){
12905:     /* allocate space for col name ptr, value ptr, and type */
12906:     int nCol = sqlite3_column_count(pStmt);
12907:     void *pData = sqlite3_malloc64(3*nCol*sizeof(const char*) + 1);
12908:     if( !pData ){
12909:       rc = SQLITE_NOMEM;
12910:     }else{
12911:       char **azCols = (char **)pData;      /* Names of result columns */
12912:       char **azVals = &azCols[nCol];       /* Results */
12913:       int *aiTypes = (int *)&azVals[nCol]; /* Result types */
12914:       int i, x;
12915:       assert(sizeof(int) <= sizeof(char *));
12916:       /* save off ptrs to column names */
12917:       for(i=0; i<nCol; i++){
12918:         azCols[i] = (char *)sqlite3_column_name(pStmt, i);
12919:       }
12920:       do{
12921:         if (pArg->cMode!=MODE_Trash) {
12922:           /* extract the data and data types */
12923:           for(i=0; i<nCol; i++){
12924:             aiTypes[i] = x = sqlite3_column_type(pStmt, i);
12925:             if( x==SQLITE_BLOB && pArg && pArg->cMode==MODE_Insert ){
12926:               azVals[i] = "";
12927:             }else{
12928:               azVals[i] = (char*)sqlite3_column_text(pStmt, i);
12929:             }
12930:             if( !azVals[i] && (aiTypes[i]!=SQLITE_NULL) ){
12931:               rc = SQLITE_NOMEM;
12932:               break; /* from for */
12933:             }
12934:           } /* end for */
12935:         }
12936: 
12937:         /* if data and types extracted successfully... */
12938:         if( SQLITE_ROW == rc ){
12939:           /* call the supplied callback with the result row data */
12940:           if( pArg->cMode!=MODE_Trash && shell_callback(pArg, nCol, azVals, azCols, aiTypes) ){
12941:             rc = SQLITE_ABORT;
12942:           }else{
12943:             rc = sqlite3_step(pStmt);
12944:           }
12945:         }
12946:       } while( SQLITE_ROW == rc );
12947:       sqlite3_free(pData);
12948:       if( pArg->cMode==MODE_Json ){
12949:         fputs("]\n", pArg->out);
12950:       }
12951:       if( pArg->cMode==MODE_Jsonlines ){
12952:         fputs("\n", pArg->out);
12953:       }
12954:     }
12955:   }
12956: }
12957: 
12958: #ifndef SQLITE_OMIT_VIRTUALTABLE
12959: /*
12960: ** This function is called to process SQL if the previous shell command
12961: ** was ".expert". It passes the SQL in the second argument directly to
12962: ** the sqlite3expert object.
12963: **
12964: ** If successful, SQLITE_OK is returned. Otherwise, an SQLite error
12965: ** code. In this case, (*pzErr) may be set to point to a buffer containing
12966: ** an English language error message. It is the responsibility of the
12967: ** caller to eventually free this buffer using sqlite3_free().
12968: */
12969: static int expertHandleSQL(
12970:   ShellState *pState,
12971:   const char *zSql,
12972:   char **pzErr
12973: ){
12974:   assert( pState->expert.pExpert );
12975:   assert( pzErr==0 || *pzErr==0 );
12976:   return sqlite3_expert_sql(pState->expert.pExpert, zSql, pzErr);
12977: }
12978: 
12979: /*
12980: ** This function is called either to silently clean up the object
12981: ** created by the ".expert" command (if bCancel==1), or to generate a
12982: ** report from it and then clean it up (if bCancel==0).
12983: **
12984: ** If successful, SQLITE_OK is returned. Otherwise, an SQLite error
12985: ** code. In this case, (*pzErr) may be set to point to a buffer containing
12986: ** an English language error message. It is the responsibility of the
12987: ** caller to eventually free this buffer using sqlite3_free().
12988: */
12989: static int expertFinish(
12990:   ShellState *pState,
12991:   int bCancel,
12992:   char **pzErr
12993: ){
12994:   int rc = SQLITE_OK;
12995:   sqlite3expert *p = pState->expert.pExpert;
12996:   assert( p );
12997:   assert( bCancel || pzErr==0 || *pzErr==0 );
12998:   if( bCancel==0 ){
12999:     FILE *out = pState->out;
13000:     int bVerbose = pState->expert.bVerbose;
13001: 
13002:     rc = sqlite3_expert_analyze(p, pzErr);
13003:     if( rc==SQLITE_OK ){
13004:       int nQuery = sqlite3_expert_count(p);
13005:       int i;
13006: 
13007:       if( bVerbose ){
13008:         const char *zCand = sqlite3_expert_report(p,0,EXPERT_REPORT_CANDIDATES);
13009:         raw_printf(out, "-- Candidates -----------------------------\n");
13010:         raw_printf(out, "%s\n", zCand);
13011:       }
13012:       for(i=0; i<nQuery; i++){
13013:         const char *zSql = sqlite3_expert_report(p, i, EXPERT_REPORT_SQL);
13014:         const char *zIdx = sqlite3_expert_report(p, i, EXPERT_REPORT_INDEXES);
13015:         const char *zEQP = sqlite3_expert_report(p, i, EXPERT_REPORT_PLAN);
13016:         if( zIdx==0 ) zIdx = "(no new indexes)\n";
13017:         if( bVerbose ){
13018:           raw_printf(out, "-- Query %d --------------------------------\n",i+1);
13019:           raw_printf(out, "%s\n\n", zSql);
13020:         }
13021:         raw_printf(out, "%s\n", zIdx);
13022:         raw_printf(out, "%s\n", zEQP);
13023:       }
13024:     }
13025:   }
13026:   sqlite3_expert_destroy(p);
13027:   pState->expert.pExpert = 0;
13028:   return rc;
13029: }
13030: 
13031: /*
13032: ** Implementation of ".expert" dot command.
13033: */
13034: static int expertDotCommand(
13035:   ShellState *pState,             /* Current shell tool state */
13036:   char **azArg,                   /* Array of arguments passed to dot command */
13037:   int nArg                        /* Number of entries in azArg[] */
13038: ){
13039:   int rc = SQLITE_OK;
13040:   char *zErr = 0;
13041:   int i;
13042:   int iSample = 0;
13043: 
13044:   assert( pState->expert.pExpert==0 );
13045:   memset(&pState->expert, 0, sizeof(ExpertInfo));
13046: 
13047:   for(i=1; rc==SQLITE_OK && i<nArg; i++){
13048:     char *z = azArg[i];
13049:     int n;
13050:     if( z[0]=='-' && z[1]=='-' ) z++;
13051:     n = strlen30(z);
13052:     if( n>=2 && 0==strncmp(z, "-verbose", n) ){
13053:       pState->expert.bVerbose = 1;
13054:     }
13055:     else if( n>=2 && 0==strncmp(z, "-sample", n) ){
13056:       if( i==(nArg-1) ){
13057:         raw_printf(stderr, "option requires an argument: %s\n", z);
13058:         rc = SQLITE_ERROR;
13059:       }else{
13060:         iSample = (int)integerValue(azArg[++i]);
13061:         if( iSample<0 || iSample>100 ){
13062:           raw_printf(stderr, "value out of range: %s\n", azArg[i]);
13063:           rc = SQLITE_ERROR;
13064:         }
13065:       }
13066:     }
13067:     else{
13068:       raw_printf(stderr, "unknown option: %s\n", z);
13069:       rc = SQLITE_ERROR;
13070:     }
13071:   }
13072: 
13073:   if( rc==SQLITE_OK ){
13074:     pState->expert.pExpert = sqlite3_expert_new(pState->db, &zErr);
13075:     if( pState->expert.pExpert==0 ){
13076:       raw_printf(stderr, "sqlite3_expert_new: %s\n", zErr);
13077:       rc = SQLITE_ERROR;
13078:     }else{
13079:       sqlite3_expert_config(
13080:           pState->expert.pExpert, EXPERT_CONFIG_SAMPLE, iSample
13081:       );
13082:     }
13083:   }
13084: 
13085:   return rc;
13086: }
13087: #endif /* ifndef SQLITE_OMIT_VIRTUALTABLE */
13088: 
13089: /*
13090: ** Execute a statement or set of statements.  Print
13091: ** any result rows/columns depending on the current mode
13092: ** set via the supplied callback.
13093: **
13094: ** This is very similar to SQLite's built-in sqlite3_exec()
13095: ** function except it takes a slightly different callback
13096: ** and callback data argument.
13097: */
13098: static int shell_exec(
13099:   ShellState *pArg,                         /* Pointer to ShellState */
13100:   const char *zSql,                         /* SQL to be evaluated */
13101:   char **pzErrMsg                           /* Error msg written here */
13102: ){
13103:   sqlite3_stmt *pStmt = NULL;     /* Statement to execute. */
13104:   int rc = SQLITE_OK;             /* Return Code */
13105:   int rc2;
13106:   const char *zLeftover;          /* Tail of unprocessed SQL */
13107:   sqlite3 *db = pArg->db;
13108: 
13109:   if( pzErrMsg ){
13110:     *pzErrMsg = NULL;
13111:   }
13112: 
13113: #ifndef SQLITE_OMIT_VIRTUALTABLE
13114:   if( pArg->expert.pExpert ){
13115:     rc = expertHandleSQL(pArg, zSql, pzErrMsg);
13116:     return expertFinish(pArg, (rc!=SQLITE_OK), pzErrMsg);
13117:   }
13118: #endif
13119: 
13120:   while( zSql[0] && (SQLITE_OK == rc) ){
13121:     static const char *zStmtSql;
13122:     rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);
13123:     if( SQLITE_OK != rc ){
13124:       if( pzErrMsg ){
13125:         *pzErrMsg = save_err_msg(db);
13126:       }
13127:     }else{
13128:       if( !pStmt ){
13129:         /* this happens for a comment or white-space */
13130:         zSql = zLeftover;
13131:         while( IsSpace(zSql[0]) ) zSql++;
13132:         continue;
13133:       }
13134:       zStmtSql = sqlite3_sql(pStmt);
13135:       if( zStmtSql==0 ) zStmtSql = "";
13136:       while( IsSpace(zStmtSql[0]) ) zStmtSql++;
13137: 
13138:       /* save off the prepared statment handle and reset row count */
13139:       if( pArg ){
13140:         pArg->pStmt = pStmt;
13141:         pArg->cnt = 0;
13142:       }
13143: 
13144:       /* echo the sql statement if echo on */
13145:       if( pArg && ShellHasFlag(pArg, SHFLG_Echo) ){
13146:         utf8_printf(pArg->out, "%s\n", zStmtSql ? zStmtSql : zSql);
13147:       }
13148: 
13149:       /* Show the EXPLAIN QUERY PLAN if .eqp is on */
13150:       if( pArg && pArg->autoEQP && sqlite3_stmt_isexplain(pStmt)==0 ){
13151:         sqlite3_stmt *pExplain;
13152:         char *zEQP;
13153:         int triggerEQP = 0;
13154:         disable_debug_trace_modes();
13155:         sqlite3_db_config(db, SQLITE_DBCONFIG_TRIGGER_EQP, -1, &triggerEQP);
13156:         if( pArg->autoEQP>=AUTOEQP_trigger ){
13157:           sqlite3_db_config(db, SQLITE_DBCONFIG_TRIGGER_EQP, 1, 0);
13158:         }
13159:         zEQP = sqlite3_mprintf("EXPLAIN QUERY PLAN %s", zStmtSql);
13160:         rc = sqlite3_prepare_v2(db, zEQP, -1, &pExplain, 0);
13161:         if( rc==SQLITE_OK ){
13162:           while( sqlite3_step(pExplain)==SQLITE_ROW ){
13163:             const char *zEQPLine = (const char*)sqlite3_column_text(pExplain,3);
13164:             int iEqpId = sqlite3_column_int(pExplain, 0);
13165:             int iParentId = sqlite3_column_int(pExplain, 1);
13166:             if( zEQPLine==0 ) zEQPLine = "";
13167:             if( zEQPLine[0]=='-' ) eqp_render(pArg);
13168:             eqp_append(pArg, iEqpId, iParentId, zEQPLine);
13169:           }
13170:           eqp_render(pArg);
13171:         }
13172:         sqlite3_finalize(pExplain);
13173:         sqlite3_free(zEQP);
13174:         if( pArg->autoEQP>=AUTOEQP_full ){
13175:           /* Also do an EXPLAIN for ".eqp full" mode */
13176:           zEQP = sqlite3_mprintf("EXPLAIN %s", zStmtSql);
13177:           rc = sqlite3_prepare_v2(db, zEQP, -1, &pExplain, 0);
13178:           if( rc==SQLITE_OK ){
13179:             pArg->cMode = MODE_Explain;
13180:             explain_data_prepare(pArg, pExplain);
13181:             exec_prepared_stmt(pArg, pExplain);
13182:             explain_data_delete(pArg);
13183:           }
13184:           sqlite3_finalize(pExplain);
13185:           sqlite3_free(zEQP);
13186:         }
13187:         if( pArg->autoEQP>=AUTOEQP_trigger && triggerEQP==0 ){
13188:           sqlite3_db_config(db, SQLITE_DBCONFIG_TRIGGER_EQP, 0, 0);
13189:           /* Reprepare pStmt before reactiving trace modes */
13190:           sqlite3_finalize(pStmt);
13191:           sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
13192:           if( pArg ) pArg->pStmt = pStmt;
13193:         }
13194:         restore_debug_trace_modes();
13195:       }
13196: 
13197:       if( pArg ){
13198:         pArg->cMode = pArg->mode;
13199:         if( pArg->autoExplain ){
13200:           if( sqlite3_stmt_isexplain(pStmt)==1 ){
13201:             pArg->cMode = MODE_Explain;
13202:           }
13203:           if( sqlite3_stmt_isexplain(pStmt)==2 ){
13204:             pArg->cMode = MODE_EQP;
13205:           }
13206:         }
13207: 
13208:         /* If the shell is currently in ".explain" mode, gather the extra
13209:         ** data required to add indents to the output.*/
13210:         // if( pArg->cMode==MODE_Explain ){
13211:         //   explain_data_prepare(pArg, pStmt);
13212:         // }
13213:       }
13214: 
13215:       bind_prepared_stmt(pArg, pStmt);
13216:       exec_prepared_stmt(pArg, pStmt);
13217:       explain_data_delete(pArg);
13218:       eqp_render(pArg);
13219: 
13220:       /* print usage stats if stats on */
13221:       if( pArg && pArg->statsOn ){
13222:         display_stats(db, pArg, 0);
13223:       }
13224: 
13225:       /* print loop-counters if required */
13226:       if( pArg && pArg->scanstatsOn ){
13227:         display_scanstats(db, pArg);
13228:       }
13229: 
13230:       /* Finalize the statement just executed. If this fails, save a
13231:       ** copy of the error message. Otherwise, set zSql to point to the
13232:       ** next statement to execute. */
13233:       rc2 = sqlite3_finalize(pStmt);
13234:       if( rc!=SQLITE_NOMEM ) rc = rc2;
13235:       if( rc==SQLITE_OK ){
13236:         zSql = zLeftover;
13237:         while( IsSpace(zSql[0]) ) zSql++;
13238:       }else if( pzErrMsg ){
13239:         *pzErrMsg = save_err_msg(db);
13240:       }
13241: 
13242:       /* clear saved stmt handle */
13243:       if( pArg ){
13244:         pArg->pStmt = NULL;
13245:       }
13246:     }
13247:   } /* end while */
13248: 
13249:   return rc;
13250: }
13251: 
13252: /*
13253: ** Release memory previously allocated by tableColumnList().
13254: */
13255: static void freeColumnList(char **azCol){
13256:   int i;
13257:   for(i=1; azCol[i]; i++){
13258:     sqlite3_free(azCol[i]);
13259:   }
13260:   /* azCol[0] is a static string */
13261:   sqlite3_free(azCol);
13262: }
13263: 
13264: /*
13265: ** Return a list of pointers to strings which are the names of all
13266: ** columns in table zTab.   The memory to hold the names is dynamically
13267: ** allocated and must be released by the caller using a subsequent call
13268: ** to freeColumnList().
13269: **
13270: ** The azCol[0] entry is usually NULL.  However, if zTab contains a rowid
13271: ** value that needs to be preserved, then azCol[0] is filled in with the
13272: ** name of the rowid column.
13273: **
13274: ** The first regular column in the table is azCol[1].  The list is terminated
13275: ** by an entry with azCol[i]==0.
13276: */
13277: static char **tableColumnList(ShellState *p, const char *zTab){
13278:   char **azCol = 0;
13279:   sqlite3_stmt *pStmt;
13280:   char *zSql;
13281:   int nCol = 0;
13282:   int nAlloc = 0;
13283:   int nPK = 0;       /* Number of PRIMARY KEY columns seen */
13284:   int isIPK = 0;     /* True if one PRIMARY KEY column of type INTEGER */
13285:   int preserveRowid = ShellHasFlag(p, SHFLG_PreserveRowid);
13286:   int rc;
13287: 
13288:   zSql = sqlite3_mprintf("PRAGMA table_info=%Q", zTab);
13289:   rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
13290:   sqlite3_free(zSql);
13291:   if( rc ) return 0;
13292:   while( sqlite3_step(pStmt)==SQLITE_ROW ){
13293:     if( nCol>=nAlloc-2 ){
13294:       nAlloc = nAlloc*2 + nCol + 10;
13295:       azCol = sqlite3_realloc(azCol, nAlloc*sizeof(azCol[0]));
13296:       if( azCol==0 ) shell_out_of_memory();
13297:     }
13298:     azCol[++nCol] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 1));
13299:     if( sqlite3_column_int(pStmt, 5) ){
13300:       nPK++;
13301:       if( nPK==1
13302:        && sqlite3_stricmp((const char*)sqlite3_column_text(pStmt,2),
13303:                           "INTEGER")==0
13304:       ){
13305:         isIPK = 1;
13306:       }else{
13307:         isIPK = 0;
13308:       }
13309:     }
13310:   }
13311:   sqlite3_finalize(pStmt);
13312:   if( azCol==0 ) return 0;
13313:   azCol[0] = 0;
13314:   azCol[nCol+1] = 0;
13315: 
13316:   /* The decision of whether or not a rowid really needs to be preserved
13317:   ** is tricky.  We never need to preserve a rowid for a WITHOUT ROWID table
13318:   ** or a table with an INTEGER PRIMARY KEY.  We are unable to preserve
13319:   ** rowids on tables where the rowid is inaccessible because there are other
13320:   ** columns in the table named "rowid", "_rowid_", and "oid".
13321:   */
13322:   if( preserveRowid && isIPK ){
13323:     /* If a single PRIMARY KEY column with type INTEGER was seen, then it
13324:     ** might be an alise for the ROWID.  But it might also be a WITHOUT ROWID
13325:     ** table or a INTEGER PRIMARY KEY DESC column, neither of which are
13326:     ** ROWID aliases.  To distinguish these cases, check to see if
13327:     ** there is a "pk" entry in "PRAGMA index_list".  There will be
13328:     ** no "pk" index if the PRIMARY KEY really is an alias for the ROWID.
13329:     */
13330:     zSql = sqlite3_mprintf("SELECT 1 FROM pragma_index_list(%Q)"
13331:                            " WHERE origin='pk'", zTab);
13332:     rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
13333:     sqlite3_free(zSql);
13334:     if( rc ){
13335:       freeColumnList(azCol);
13336:       return 0;
13337:     }
13338:     rc = sqlite3_step(pStmt);
13339:     sqlite3_finalize(pStmt);
13340:     preserveRowid = rc==SQLITE_ROW;
13341:   }
13342:   if( preserveRowid ){
13343:     /* Only preserve the rowid if we can find a name to use for the
13344:     ** rowid */
13345:     static char *azRowid[] = { "rowid", "_rowid_", "oid" };
13346:     int i, j;
13347:     for(j=0; j<3; j++){
13348:       for(i=1; i<=nCol; i++){
13349:         if( sqlite3_stricmp(azRowid[j],azCol[i])==0 ) break;
13350:       }
13351:       if( i>nCol ){
13352:         /* At this point, we know that azRowid[j] is not the name of any
13353:         ** ordinary column in the table.  Verify that azRowid[j] is a valid
13354:         ** name for the rowid before adding it to azCol[0].  WITHOUT ROWID
13355:         ** tables will fail this last check */
13356:         rc = sqlite3_table_column_metadata(p->db,0,zTab,azRowid[j],0,0,0,0,0);
13357:         if( rc==SQLITE_OK ) azCol[0] = azRowid[j];
13358:         break;
13359:       }
13360:     }
13361:   }
13362:   return azCol;
13363: }
13364: 
13365: /*
13366: ** Toggle the reverse_unordered_selects setting.
13367: */
13368: static void toggleSelectOrder(sqlite3 *db){
13369:   sqlite3_stmt *pStmt = 0;
13370:   int iSetting = 0;
13371:   char zStmt[100];
13372:   sqlite3_prepare_v2(db, "PRAGMA reverse_unordered_selects", -1, &pStmt, 0);
13373:   if( sqlite3_step(pStmt)==SQLITE_ROW ){
13374:     iSetting = sqlite3_column_int(pStmt, 0);
13375:   }
13376:   sqlite3_finalize(pStmt);
13377:   sqlite3_snprintf(sizeof(zStmt), zStmt,
13378:        "PRAGMA reverse_unordered_selects(%d)", !iSetting);
13379:   sqlite3_exec(db, zStmt, 0, 0, 0);
13380: }
13381: 
13382: /*
13383: ** This is a different callback routine used for dumping the database.
13384: ** Each row received by this callback consists of a table name,
13385: ** the table type ("index" or "table") and SQL to create the table.
13386: ** This routine should print text sufficient to recreate the table.
13387: */
13388: static int dump_callback(void *pArg, int nArg, char **azArg, char **azNotUsed){
13389:   int rc;
13390:   const char *zTable;
13391:   const char *zType;
13392:   const char *zSql;
13393:   ShellState *p = (ShellState *)pArg;
13394: 
13395:   UNUSED_PARAMETER(azNotUsed);
13396:   if( nArg!=3 || azArg==0 ) return 0;
13397:   zTable = azArg[0];
13398:   zType = azArg[1];
13399:   zSql = azArg[2];
13400: 
13401:   if( strcmp(zTable, "sqlite_sequence")==0 ){
13402:     raw_printf(p->out, "DELETE FROM sqlite_sequence;\n");
13403:   }else if( sqlite3_strglob("sqlite_stat?", zTable)==0 ){
13404:     raw_printf(p->out, "ANALYZE sqlite_schema;\n");
13405:   }else if( strncmp(zTable, "sqlite_", 7)==0 ){
13406:     return 0;
13407:   }else if( strncmp(zSql, "CREATE VIRTUAL TABLE", 20)==0 ){
13408:     char *zIns;
13409:     if( !p->writableSchema ){
13410:       raw_printf(p->out, "PRAGMA writable_schema=ON;\n");
13411:       p->writableSchema = 1;
13412:     }
13413:     zIns = sqlite3_mprintf(
13414:        "INSERT INTO sqlite_schema(type,name,tbl_name,rootpage,sql)"
13415:        "VALUES('table','%q','%q',0,'%q');",
13416:        zTable, zTable, zSql);
13417:     utf8_printf(p->out, "%s\n", zIns);
13418:     sqlite3_free(zIns);
13419:     return 0;
13420:   }else{
13421:     printSchemaLine(p->out, zSql, ";\n");
13422:   }
13423: 
13424:   if( strcmp(zType, "table")==0 ){
13425:     ShellText sSelect;
13426:     ShellText sTable;
13427:     char **azCol;
13428:     int i;
13429:     char *savedDestTable;
13430:     int savedMode;
13431: 
13432:     azCol = tableColumnList(p, zTable);
13433:     if( azCol==0 ){
13434:       p->nErr++;
13435:       return 0;
13436:     }
13437: 
13438:     /* Always quote the table name, even if it appears to be pure ascii,
13439:     ** in case it is a keyword. Ex:  INSERT INTO "table" ... */
13440:     initText(&sTable);
13441:     appendText(&sTable, zTable, quoteChar(zTable));
13442:     /* If preserving the rowid, add a column list after the table name.
13443:     ** In other words:  "INSERT INTO tab(rowid,a,b,c,...) VALUES(...)"
13444:     ** instead of the usual "INSERT INTO tab VALUES(...)".
13445:     */
13446:     if( azCol[0] ){
13447:       appendText(&sTable, "(", 0);
13448:       appendText(&sTable, azCol[0], 0);
13449:       for(i=1; azCol[i]; i++){
13450:         appendText(&sTable, ",", 0);
13451:         appendText(&sTable, azCol[i], quoteChar(azCol[i]));
13452:       }
13453:       appendText(&sTable, ")", 0);
13454:     }
13455: 
13456:     /* Build an appropriate SELECT statement */
13457:     initText(&sSelect);
13458:     appendText(&sSelect, "SELECT ", 0);
13459:     if( azCol[0] ){
13460:       appendText(&sSelect, azCol[0], 0);
13461:       appendText(&sSelect, ",", 0);
13462:     }
13463:     for(i=1; azCol[i]; i++){
13464:       appendText(&sSelect, azCol[i], quoteChar(azCol[i]));
13465:       if( azCol[i+1] ){
13466:         appendText(&sSelect, ",", 0);
13467:       }
13468:     }
13469:     freeColumnList(azCol);
13470:     appendText(&sSelect, " FROM ", 0);
13471:     appendText(&sSelect, zTable, quoteChar(zTable));
13472: 
13473:     savedDestTable = p->zDestTable;
13474:     savedMode = p->mode;
13475:     p->zDestTable = sTable.z;
13476:     p->mode = p->cMode = MODE_Insert;
13477:     rc = shell_exec(p, sSelect.z, 0);
13478:     if( (rc&0xff)==SQLITE_CORRUPT ){
13479:       raw_printf(p->out, "/****** CORRUPTION ERROR *******/\n");
13480:       toggleSelectOrder(p->db);
13481:       shell_exec(p, sSelect.z, 0);
13482:       toggleSelectOrder(p->db);
13483:     }
13484:     p->zDestTable = savedDestTable;
13485:     p->mode = savedMode;
13486:     freeText(&sTable);
13487:     freeText(&sSelect);
13488:     if( rc ) p->nErr++;
13489:   }
13490:   return 0;
13491: }
13492: 
13493: /*
13494: ** Run zQuery.  Use dump_callback() as the callback routine so that
13495: ** the contents of the query are output as SQL statements.
13496: **
13497: ** If we get a SQLITE_CORRUPT error, rerun the query after appending
13498: ** "ORDER BY rowid DESC" to the end.
13499: */
13500: static int run_schema_dump_query(
13501:   ShellState *p,
13502:   const char *zQuery
13503: ){
13504:   int rc;
13505:   char *zErr = 0;
13506:   rc = sqlite3_exec(p->db, zQuery, dump_callback, p, &zErr);
13507:   if( rc==SQLITE_CORRUPT ){
13508:     char *zQ2;
13509:     int len = strlen30(zQuery);
13510:     raw_printf(p->out, "/****** CORRUPTION ERROR *******/\n");
13511:     if( zErr ){
13512:       utf8_printf(p->out, "/****** %s ******/\n", zErr);
13513:       sqlite3_free(zErr);
13514:       zErr = 0;
13515:     }
13516:     zQ2 = malloc( len+100 );
13517:     if( zQ2==0 ) return rc;
13518:     sqlite3_snprintf(len+100, zQ2, "%s ORDER BY rowid DESC", zQuery);
13519:     rc = sqlite3_exec(p->db, zQ2, dump_callback, p, &zErr);
13520:     if( rc ){
13521:       utf8_printf(p->out, "/****** ERROR: %s ******/\n", zErr);
13522:     }else{
13523:       rc = SQLITE_CORRUPT;
13524:     }
13525:     sqlite3_free(zErr);
13526:     free(zQ2);
13527:   } else if( zErr ){
13528:     sqlite3_free(zErr);
13529:     zErr = 0;
13530:   }
13531:   return rc;
13532: }
13533: 
13534: /*
13535: ** Text of help messages.
13536: **
13537: ** The help text for each individual command begins with a line that starts
13538: ** with ".".  Subsequent lines are supplimental information.
13539: **
13540: ** There must be two or more spaces between the end of the command and the
13541: ** start of the description of what that command does.
13542: */
13543: static const char *(azHelp[]) = {
13544: #if defined(SQLITE_HAVE_ZLIB) && !defined(SQLITE_OMIT_VIRTUALTABLE)
13545:   ".archive ...             Manage SQL archives",
13546:   "   Each command must have exactly one of the following options:",
13547:   "     -c, --create               Create a new archive",
13548:   "     -u, --update               Add or update files with changed mtime",
13549:   "     -i, --insert               Like -u but always add even if unchanged",
13550:   "     -t, --list                 List contents of archive",
13551:   "     -x, --extract              Extract files from archive",
13552:   "   Optional arguments:",
13553:   "     -v, --verbose              Print each filename as it is processed",
13554:   "     -f FILE, --file FILE       Use archive FILE (default is current db)",
13555:   "     -a FILE, --append FILE     Open FILE using the apndvfs VFS",
13556:   "     -C DIR, --directory DIR    Read/extract files from directory DIR",
13557:   "     -n, --dryrun               Show the SQL that would have occurred",
13558:   "   Examples:",
13559:   "     .ar -cf ARCHIVE foo bar  # Create ARCHIVE from files foo and bar",
13560:   "     .ar -tf ARCHIVE          # List members of ARCHIVE",
13561:   "     .ar -xvf ARCHIVE         # Verbosely extract files from ARCHIVE",
13562:   "   See also:",
13563:   "      http://sqlite.org/cli.html#sqlar_archive_support",
13564: #endif
13565: #ifndef SQLITE_OMIT_AUTHORIZATION
13566:   ".auth ON|OFF             Show authorizer callbacks",
13567: #endif
13568:   ".backup ?DB? FILE        Backup DB (default \"main\") to FILE",
13569:   "       --append            Use the appendvfs",
13570:   "       --async             Write to FILE without journal and fsync()",
13571:   ".bail on|off             Stop after hitting an error.  Default OFF",
13572:   ".binary on|off           Turn binary output on or off.  Default OFF",
13573:   ".cd DIRECTORY            Change the working directory to DIRECTORY",
13574:   ".changes on|off          Show number of rows changed by SQL",
13575:   ".check GLOB              Fail if output since .testcase does not match",
13576:   ".clone NEWDB             Clone data into NEWDB from the existing database",
13577:   ".databases               List names and files of attached databases",
13578:   ".dbconfig ?op? ?val?     List or change sqlite3_db_config() options",
13579:   ".dbinfo ?DB?             Show status information about the database",
13580:   ".dump ?TABLE?            Render database content as SQL",
13581:   "   Options:",
13582:   "     --preserve-rowids      Include ROWID values in the output",
13583:   "     --newlines             Allow unescaped newline characters in output",
13584:   "   TABLE is a LIKE pattern for the tables to dump",
13585:   "   Additional LIKE patterns can be given in subsequent arguments",
13586:   ".echo on|off             Turn command echo on or off",
13587:   ".eqp on|off|full|...     Enable or disable automatic EXPLAIN QUERY PLAN",
13588:   "   Other Modes:",
13589: #ifdef SQLITE_DEBUG
13590:   "      test                  Show raw EXPLAIN QUERY PLAN output",
13591:   "      trace                 Like \"full\" but enable \"PRAGMA vdbe_trace\"",
13592: #endif
13593:   "      trigger               Like \"full\" but also show trigger bytecode",
13594:   ".excel                   Display the output of next command in spreadsheet",
13595:   "   --bom                   Put a UTF8 byte-order mark on intermediate file",
13596:   ".exit ?CODE?             Exit this program with return-code CODE",
13597:   ".expert                  EXPERIMENTAL. Suggest indexes for queries",
13598:   ".explain ?on|off|auto?   Change the EXPLAIN formatting mode.  Default: auto",
13599:   ".filectrl CMD ...        Run various sqlite3_file_control() operations",
13600:   "   --schema SCHEMA         Use SCHEMA instead of \"main\"",
13601:   "   --help                  Show CMD details",
13602:   ".fullschema ?--indent?   Show schema and the content of sqlite_stat tables",
13603:   ".headers on|off          Turn display of headers on or off",
13604:   ".help ?-all? ?PATTERN?   Show help text for PATTERN",
13605:   ".import FILE TABLE       Import data from FILE into TABLE",
13606:   "   Options:",
13607:   "     --ascii               Use \\037 and \\036 as column and row separators",
13608:   "     --csv                 Use , and \\n as column and row separators",
13609:   "     --skip N              Skip the first N rows of input",
13610:   "     -v                    \"Verbose\" - increase auxiliary output",
13611:   "   Notes:",
13612:   "     *  If TABLE does not exist, it is created.  The first row of input",
13613:   "        determines the column names.",
13614:   "     *  If neither --csv or --ascii are used, the input mode is derived",
13615:   "        from the \".mode\" output mode",
13616:   "     *  If FILE begins with \"|\" then it is a command that generates the",
13617:   "        input text.",
13618: #ifndef SQLITE_OMIT_TEST_CONTROL
13619:   ".imposter INDEX TABLE    Create imposter table TABLE on index INDEX",
13620: #endif
13621:   ".indexes ?TABLE?         Show names of indexes",
13622:   "                           If TABLE is specified, only show indexes for",
13623:   "                           tables matching TABLE using the LIKE operator.",
13624: #ifdef SQLITE_ENABLE_IOTRACE
13625:   ".iotrace FILE            Enable I/O diagnostic logging to FILE",
13626: #endif
13627:   ".limit ?LIMIT? ?VAL?     Display or change the value of an SQLITE_LIMIT",
13628:   ".lint OPTIONS            Report potential schema issues.",
13629:   "     Options:",
13630:   "        fkey-indexes     Find missing foreign key indexes",
13631: #ifndef SQLITE_OMIT_LOAD_EXTENSION
13632:   ".load FILE ?ENTRY?       Load an extension library",
13633: #endif
13634:   ".log FILE|off            Turn logging on or off.  FILE can be stderr/stdout",
13635:   ".mode MODE ?TABLE?       Set output mode",
13636:   "   MODE is one of:",
13637:   "     ascii     Columns/rows delimited by 0x1F and 0x1E",
13638:   "     box       Tables using unicode box-drawing characters",
13639:   "     csv       Comma-separated values",
13640:   "     column    Output in columns.  (See .width)",
13641:   "     html      HTML <table> code",
13642:   "     insert    SQL insert statements for TABLE",
13643:   "     json      Results in a JSON array",
13644:   "     line      One value per line",
13645:   "     list      Values delimited by \"|\"",
13646:   "     markdown  Markdown table format",
13647:   "     quote     Escape answers as for SQL",
13648:   "     table     ASCII-art table",
13649:   "     tabs      Tab-separated values",
13650:   "     tcl       TCL list elements",
13651:   ".nullvalue STRING        Use STRING in place of NULL values",
13652:   ".once ?OPTIONS? ?FILE?   Output for the next SQL command only to FILE",
13653:   "     If FILE begins with '|' then open as a pipe",
13654:   "       --bom  Put a UTF8 byte-order mark at the beginning",
13655:   "       -e     Send output to the system text editor",
13656:   "       -x     Send output as CSV to a spreadsheet (same as \".excel\")",
13657: #ifdef SQLITE_DEBUG
13658:   ".oom ?--repeat M? ?N?    Simulate an OOM error on the N-th allocation",
13659: #endif
13660:   ".open ?OPTIONS? ?FILE?   Close existing database and reopen FILE",
13661:   "     Options:",
13662:   "        --append        Use appendvfs to append database to the end of FILE",
13663: #ifdef SQLITE_ENABLE_DESERIALIZE
13664:   "        --deserialize   Load into memory useing sqlite3_deserialize()",
13665:   "        --hexdb         Load the output of \"dbtotxt\" as an in-memory db",
13666:   "        --maxsize N     Maximum size for --hexdb or --deserialized database",
13667: #endif
13668:   "        --new           Initialize FILE to an empty database",
13669:   "        --nofollow      Do not follow symbolic links",
13670:   "        --readonly      Open FILE readonly",
13671:   "        --zip           FILE is a ZIP archive",
13672:   ".output ?FILE?           Send output to FILE or stdout if FILE is omitted",
13673:   "   If FILE begins with '|' then open it as a pipe.",
13674:   "   Options:",
13675:   "     --bom                 Prefix output with a UTF8 byte-order mark",
13676:   "     -e                    Send output to the system text editor",
13677:   "     -x                    Send output as CSV to a spreadsheet",
13678:   ".parameter CMD ...       Manage SQL parameter bindings",
13679:   "   clear                   Erase all bindings",
13680:   "   init                    Initialize the TEMP table that holds bindings",
13681:   "   list                    List the current parameter bindings",
13682:   "   set PARAMETER VALUE     Given SQL parameter PARAMETER a value of VALUE",
13683:   "                           PARAMETER should start with one of: $ : @ ?",
13684:   "   unset PARAMETER         Remove PARAMETER from the binding table",
13685:   ".print STRING...         Print literal STRING",
13686: #ifndef SQLITE_OMIT_PROGRESS_CALLBACK
13687:   ".progress N              Invoke progress handler after every N opcodes",
13688:   "   --limit N                 Interrupt after N progress callbacks",
13689:   "   --once                    Do no more than one progress interrupt",
13690:   "   --quiet|-q                No output except at interrupts",
13691:   "   --reset                   Reset the count for each input and interrupt",
13692: #endif
13693:   ".prompt MAIN CONTINUE    Replace the standard prompts",
13694:   ".quit                    Exit this program",
13695:   ".read FILE               Read input from FILE",
13696: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)
13697:   ".recover                 Recover as much data as possible from corrupt db.",
13698:   "   --freelist-corrupt       Assume the freelist is corrupt",
13699:   "   --recovery-db NAME       Store recovery metadata in database file NAME",
13700:   "   --lost-and-found TABLE   Alternative name for the lost-and-found table",
13701:   "   --no-rowids              Do not attempt to recover rowid values",
13702:   "                            that are not also INTEGER PRIMARY KEYs",
13703: #endif
13704:   ".restore ?DB? FILE       Restore content of DB (default \"main\") from FILE",
13705:   ".save FILE               Write in-memory database into FILE",
13706:   ".scanstats on|off        Turn sqlite3_stmt_scanstatus() metrics on or off",
13707:   ".schema ?PATTERN?        Show the CREATE statements matching PATTERN",
13708:   "     Options:",
13709:   "         --indent            Try to pretty-print the schema",
13710:   ".selftest ?OPTIONS?      Run tests defined in the SELFTEST table",
13711:   "    Options:",
13712:   "       --init               Create a new SELFTEST table",
13713:   "       -v                   Verbose output",
13714:   ".separator COL ?ROW?     Change the column and row separators",
13715: #if defined(SQLITE_ENABLE_SESSION)
13716:   ".session ?NAME? CMD ...  Create or control sessions",
13717:   "   Subcommands:",
13718:   "     attach TABLE             Attach TABLE",
13719:   "     changeset FILE           Write a changeset into FILE",
13720:   "     close                    Close one session",
13721:   "     enable ?BOOLEAN?         Set or query the enable bit",
13722:   "     filter GLOB...           Reject tables matching GLOBs",
13723:   "     indirect ?BOOLEAN?       Mark or query the indirect status",
13724:   "     isempty                  Query whether the session is empty",
13725:   "     list                     List currently open session names",
13726:   "     open DB NAME             Open a new session on DB",
13727:   "     patchset FILE            Write a patchset into FILE",
13728:   "   If ?NAME? is omitted, the first defined session is used.",
13729: #endif
13730:   ".sha3sum ...             Compute a SHA3 hash of database content",
13731:   "    Options:",
13732:   "      --schema              Also hash the sqlite_schema table",
13733:   "      --sha3-224            Use the sha3-224 algorithm",
13734:   "      --sha3-256            Use the sha3-256 algorithm (default)",
13735:   "      --sha3-384            Use the sha3-384 algorithm",
13736:   "      --sha3-512            Use the sha3-512 algorithm",
13737:   "    Any other argument is a LIKE pattern for tables to hash",
13738: #ifndef SQLITE_NOHAVE_SYSTEM
13739:   ".shell CMD ARGS...       Run CMD ARGS... in a system shell",
13740: #endif
13741:   ".show                    Show the current values for various settings",
13742:   ".stats ?on|off?          Show stats or turn stats on or off",
13743: #ifndef SQLITE_NOHAVE_SYSTEM
13744:   ".system CMD ARGS...      Run CMD ARGS... in a system shell",
13745: #endif
13746:   ".tables ?TABLE?          List names of tables matching LIKE pattern TABLE",
13747:   ".testcase NAME           Begin redirecting output to 'testcase-out.txt'",
13748:   ".testctrl CMD ...        Run various sqlite3_test_control() operations",
13749:   "                           Run \".testctrl\" with no arguments for details",
13750:   ".timeout MS              Try opening locked tables for MS milliseconds",
13751:   ".timer on|off            Turn SQL timer on or off",
13752: #ifndef SQLITE_OMIT_TRACE
13753:   ".trace ?OPTIONS?         Output each SQL statement as it is run",
13754:   "    FILE                    Send output to FILE",
13755:   "    stdout                  Send output to stdout",
13756:   "    stderr                  Send output to stderr",
13757:   "    off                     Disable tracing",
13758:   "    --expanded              Expand query parameters",
13759: #ifdef SQLITE_ENABLE_NORMALIZE
13760:   "    --normalized            Normal the SQL statements",
13761: #endif
13762:   "    --plain                 Show SQL as it is input",
13763:   "    --stmt                  Trace statement execution (SQLITE_TRACE_STMT)",
13764:   "    --profile               Profile statements (SQLITE_TRACE_PROFILE)",
13765:   "    --row                   Trace each row (SQLITE_TRACE_ROW)",
13766:   "    --close                 Trace connection close (SQLITE_TRACE_CLOSE)",
13767: #endif /* SQLITE_OMIT_TRACE */
13768: #ifdef SQLITE_DEBUG
13769:   ".unmodule NAME ...       Unregister virtual table modules",
13770:   "    --allexcept             Unregister everything except those named",
13771: #endif
13772:   ".vfsinfo ?AUX?           Information about the top-level VFS",
13773:   ".vfslist                 List all available VFSes",
13774:   ".vfsname ?AUX?           Print the name of the VFS stack",
13775:   ".width NUM1 NUM2 ...     Set minimum column widths for columnar output",
13776:   "     Negative values right-justify",
13777: };
13778: 
13779: /*
13780: ** Output help text.
13781: **
13782: ** zPattern describes the set of commands for which help text is provided.
13783: ** If zPattern is NULL, then show all commands, but only give a one-line
13784: ** description of each.
13785: **
13786: ** Return the number of matches.
13787: */
13788: static int showHelp(FILE *out, const char *zPattern){
13789:   int i = 0;
13790:   int j = 0;
13791:   int n = 0;
13792:   char *zPat;
13793:   if( zPattern==0
13794:    || zPattern[0]=='0'
13795:    || strcmp(zPattern,"-a")==0
13796:    || strcmp(zPattern,"-all")==0
13797:    || strcmp(zPattern,"--all")==0
13798:   ){
13799:     /* Show all commands, but only one line per command */
13800:     if( zPattern==0 ) zPattern = "";
13801:     for(i=0; i<ArraySize(azHelp); i++){
13802:       if( azHelp[i][0]=='.' || zPattern[0] ){
13803:         utf8_printf(out, "%s\n", azHelp[i]);
13804:         n++;
13805:       }
13806:     }
13807:   }else{
13808:     /* Look for commands that for which zPattern is an exact prefix */
13809:     zPat = sqlite3_mprintf(".%s*", zPattern);
13810:     for(i=0; i<ArraySize(azHelp); i++){
13811:       if( sqlite3_strglob(zPat, azHelp[i])==0 ){
13812:         utf8_printf(out, "%s\n", azHelp[i]);
13813:         j = i+1;
13814:         n++;
13815:       }
13816:     }
13817:     sqlite3_free(zPat);
13818:     if( n ){
13819:       if( n==1 ){
13820:         /* when zPattern is a prefix of exactly one command, then include the
13821:         ** details of that command, which should begin at offset j */
13822:         while( j<ArraySize(azHelp)-1 && azHelp[j][0]!='.' ){
13823:           utf8_printf(out, "%s\n", azHelp[j]);
13824:           j++;
13825:         }
13826:       }
13827:       return n;
13828:     }
13829:     /* Look for commands that contain zPattern anywhere.  Show the complete
13830:     ** text of all commands that match. */
13831:     zPat = sqlite3_mprintf("%%%s%%", zPattern);
13832:     for(i=0; i<ArraySize(azHelp); i++){
13833:       if( azHelp[i][0]=='.' ) j = i;
13834:       if( sqlite3_strlike(zPat, azHelp[i], 0)==0 ){
13835:         utf8_printf(out, "%s\n", azHelp[j]);
13836:         while( j<ArraySize(azHelp)-1 && azHelp[j+1][0]!='.' ){
13837:           j++;
13838:           utf8_printf(out, "%s\n", azHelp[j]);
13839:         }
13840:         i = j;
13841:         n++;
13842:       }
13843:     }
13844:     sqlite3_free(zPat);
13845:   }
13846:   return n;
13847: }
13848: 
13849: /* Forward reference */
13850: static int process_input(ShellState *p);
13851: 
13852: /*
13853: ** Read the content of file zName into memory obtained from sqlite3_malloc64()
13854: ** and return a pointer to the buffer. The caller is responsible for freeing
13855: ** the memory.
13856: **
13857: ** If parameter pnByte is not NULL, (*pnByte) is set to the number of bytes
13858: ** read.
13859: **
13860: ** For convenience, a nul-terminator byte is always appended to the data read
13861: ** from the file before the buffer is returned. This byte is not included in
13862: ** the final value of (*pnByte), if applicable.
13863: **
13864: ** NULL is returned if any error is encountered. The final value of *pnByte
13865: ** is undefined in this case.
13866: */
13867: static char *readFile(const char *zName, int *pnByte){
13868:   FILE *in = fopen(zName, "rb");
13869:   long nIn;
13870:   size_t nRead;
13871:   char *pBuf;
13872:   if( in==0 ) return 0;
13873:   fseek(in, 0, SEEK_END);
13874:   nIn = ftell(in);
13875:   rewind(in);
13876:   pBuf = sqlite3_malloc64( nIn+1 );
13877:   if( pBuf==0 ){ fclose(in); return 0; }
13878:   nRead = fread(pBuf, nIn, 1, in);
13879:   fclose(in);
13880:   if( nRead!=1 ){
13881:     sqlite3_free(pBuf);
13882:     return 0;
13883:   }
13884:   pBuf[nIn] = 0;
13885:   if( pnByte ) *pnByte = nIn;
13886:   return pBuf;
13887: }
13888: 
13889: #if defined(SQLITE_ENABLE_SESSION)
13890: /*
13891: ** Close a single OpenSession object and release all of its associated
13892: ** resources.
13893: */
13894: static void session_close(OpenSession *pSession){
13895:   int i;
13896:   sqlite3session_delete(pSession->p);
13897:   sqlite3_free(pSession->zName);
13898:   for(i=0; i<pSession->nFilter; i++){
13899:     sqlite3_free(pSession->azFilter[i]);
13900:   }
13901:   sqlite3_free(pSession->azFilter);
13902:   memset(pSession, 0, sizeof(OpenSession));
13903: }
13904: #endif
13905: 
13906: /*
13907: ** Close all OpenSession objects and release all associated resources.
13908: */
13909: #if defined(SQLITE_ENABLE_SESSION)
13910: static void session_close_all(ShellState *p){
13911:   int i;
13912:   for(i=0; i<p->nSession; i++){
13913:     session_close(&p->aSession[i]);
13914:   }
13915:   p->nSession = 0;
13916: }
13917: #else
13918: # define session_close_all(X)
13919: #endif
13920: 
13921: /*
13922: ** Implementation of the xFilter function for an open session.  Omit
13923: ** any tables named by ".session filter" but let all other table through.
13924: */
13925: #if defined(SQLITE_ENABLE_SESSION)
13926: static int session_filter(void *pCtx, const char *zTab){
13927:   OpenSession *pSession = (OpenSession*)pCtx;
13928:   int i;
13929:   for(i=0; i<pSession->nFilter; i++){
13930:     if( sqlite3_strglob(pSession->azFilter[i], zTab)==0 ) return 0;
13931:   }
13932:   return 1;
13933: }
13934: #endif
13935: 
13936: /*
13937: ** Try to deduce the type of file for zName based on its content.  Return
13938: ** one of the SHELL_OPEN_* constants.
13939: **
13940: ** If the file does not exist or is empty but its name looks like a ZIP
13941: ** archive and the dfltZip flag is true, then assume it is a ZIP archive.
13942: ** Otherwise, assume an ordinary database regardless of the filename if
13943: ** the type cannot be determined from content.
13944: */
13945: int deduceDatabaseType(const char *zName, int dfltZip){
13946:   FILE *f = fopen(zName, "rb");
13947:   size_t n;
13948:   int rc = SHELL_OPEN_UNSPEC;
13949:   char zBuf[100];
13950:   if( f==0 ){
13951:     if( dfltZip && sqlite3_strlike("%.zip",zName,0)==0 ){
13952:        return SHELL_OPEN_ZIPFILE;
13953:     }else{
13954:        return SHELL_OPEN_NORMAL;
13955:     }
13956:   }
13957:   n = fread(zBuf, 16, 1, f);
13958:   if( n==1 && memcmp(zBuf, "SQLite format 3", 16)==0 ){
13959:     fclose(f);
13960:     return SHELL_OPEN_NORMAL;
13961:   }
13962:   fseek(f, -25, SEEK_END);
13963:   n = fread(zBuf, 25, 1, f);
13964:   if( n==1 && memcmp(zBuf, "Start-Of-SQLite3-", 17)==0 ){
13965:     rc = SHELL_OPEN_APPENDVFS;
13966:   }else{
13967:     fseek(f, -22, SEEK_END);
13968:     n = fread(zBuf, 22, 1, f);
13969:     if( n==1 && zBuf[0]==0x50 && zBuf[1]==0x4b && zBuf[2]==0x05
13970:        && zBuf[3]==0x06 ){
13971:       rc = SHELL_OPEN_ZIPFILE;
13972:     }else if( n==0 && dfltZip && sqlite3_strlike("%.zip",zName,0)==0 ){
13973:       rc = SHELL_OPEN_ZIPFILE;
13974:     }
13975:   }
13976:   fclose(f);
13977:   return rc;
13978: }
13979: 
13980: #ifdef SQLITE_ENABLE_DESERIALIZE
13981: /*
13982: ** Reconstruct an in-memory database using the output from the "dbtotxt"
13983: ** program.  Read content from the file in p->zDbFilename.  If p->zDbFilename
13984: ** is 0, then read from standard input.
13985: */
13986: static unsigned char *readHexDb(ShellState *p, int *pnData){
13987:   unsigned char *a = 0;
13988:   int nLine;
13989:   int n = 0;
13990:   int pgsz = 0;
13991:   int iOffset = 0;
13992:   int j, k;
13993:   int rc;
13994:   FILE *in;
13995:   unsigned int x[16];
13996:   char zLine[1000];
13997:   if( p->zDbFilename ){
13998:     in = fopen(p->zDbFilename, "r");
13999:     if( in==0 ){
14000:       utf8_printf(stderr, "cannot open \"%s\" for reading\n", p->zDbFilename);
14001:       return 0;
14002:     }
14003:     nLine = 0;
14004:   }else{
14005:     in = p->in;
14006:     nLine = p->lineno;
14007:     if( in==0 ) in = stdin;
14008:   }
14009:   *pnData = 0;
14010:   nLine++;
14011:   if( fgets(zLine, sizeof(zLine), in)==0 ) goto readHexDb_error;
14012:   rc = sscanf(zLine, "| size %d pagesize %d", &n, &pgsz);
14013:   if( rc!=2 ) goto readHexDb_error;
14014:   if( n<0 ) goto readHexDb_error;
14015:   if( pgsz<512 || pgsz>65536 || (pgsz&(pgsz-1))!=0 ) goto readHexDb_error;
14016:   n = (n+pgsz-1)&~(pgsz-1);  /* Round n up to the next multiple of pgsz */
14017:   a = sqlite3_malloc( n ? n : 1 );
14018:   if( a==0 ){
14019:     utf8_printf(stderr, "Out of memory!\n");
14020:     goto readHexDb_error;
14021:   }
14022:   memset(a, 0, n);
14023:   if( pgsz<512 || pgsz>65536 || (pgsz & (pgsz-1))!=0 ){
14024:     utf8_printf(stderr, "invalid pagesize\n");
14025:     goto readHexDb_error;
14026:   }
14027:   for(nLine++; fgets(zLine, sizeof(zLine), in)!=0; nLine++){
14028:     rc = sscanf(zLine, "| page %d offset %d", &j, &k);
14029:     if( rc==2 ){
14030:       iOffset = k;
14031:       continue;
14032:     }
14033:     if( strncmp(zLine, "| end ", 6)==0 ){
14034:       break;
14035:     }
14036:     rc = sscanf(zLine,"| %d: %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x",
14037:                 &j, &x[0], &x[1], &x[2], &x[3], &x[4], &x[5], &x[6], &x[7],
14038:                 &x[8], &x[9], &x[10], &x[11], &x[12], &x[13], &x[14], &x[15]);
14039:     if( rc==17 ){
14040:       k = iOffset+j;
14041:       if( k+16<=n ){
14042:         int ii;
14043:         for(ii=0; ii<16; ii++) a[k+ii] = x[ii]&0xff;
14044:       }
14045:     }
14046:   }
14047:   *pnData = n;
14048:   if( in!=p->in ){
14049:     fclose(in);
14050:   }else{
14051:     p->lineno = nLine;
14052:   }
14053:   return a;
14054: 
14055: readHexDb_error:
14056:   if( in!=p->in ){
14057:     fclose(in);
14058:   }else{
14059:     while( fgets(zLine, sizeof(zLine), p->in)!=0 ){
14060:       nLine++;
14061:       if(strncmp(zLine, "| end ", 6)==0 ) break;
14062:     }
14063:     p->lineno = nLine;
14064:   }
14065:   sqlite3_free(a);
14066:   utf8_printf(stderr,"Error on line %d of --hexdb input\n", nLine);
14067:   return 0;
14068: }
14069: #endif /* SQLITE_ENABLE_DESERIALIZE */
14070: 
14071: /*
14072: ** Scalar function "shell_int32". The first argument to this function
14073: ** must be a blob. The second a non-negative integer. This function
14074: ** reads and returns a 32-bit big-endian integer from byte
14075: ** offset (4*<arg2>) of the blob.
14076: */
14077: static void shellInt32(
14078:   sqlite3_context *context,
14079:   int argc,
14080:   sqlite3_value **argv
14081: ){
14082:   const unsigned char *pBlob;
14083:   int nBlob;
14084:   int iInt;
14085: 
14086:   UNUSED_PARAMETER(argc);
14087:   nBlob = sqlite3_value_bytes(argv[0]);
14088:   pBlob = (const unsigned char*)sqlite3_value_blob(argv[0]);
14089:   iInt = sqlite3_value_int(argv[1]);
14090: 
14091:   if( iInt>=0 && (iInt+1)*4<=nBlob ){
14092:     const unsigned char *a = &pBlob[iInt*4];
14093:     sqlite3_int64 iVal = ((sqlite3_int64)a[0]<<24)
14094:                        + ((sqlite3_int64)a[1]<<16)
14095:                        + ((sqlite3_int64)a[2]<< 8)
14096:                        + ((sqlite3_int64)a[3]<< 0);
14097:     sqlite3_result_int64(context, iVal);
14098:   }
14099: }
14100: 
14101: /*
14102: ** Scalar function "shell_idquote(X)" returns string X quoted as an identifier,
14103: ** using "..." with internal double-quote characters doubled.
14104: */
14105: static void shellIdQuote(
14106:   sqlite3_context *context,
14107:   int argc,
14108:   sqlite3_value **argv
14109: ){
14110:   const char *zName = (const char*)sqlite3_value_text(argv[0]);
14111:   UNUSED_PARAMETER(argc);
14112:   if( zName ){
14113:     char *z = sqlite3_mprintf("\"%w\"", zName);
14114:     sqlite3_result_text(context, z, -1, sqlite3_free);
14115:   }
14116: }
14117: 
14118: /*
14119: ** Scalar function "shell_escape_crnl" used by the .recover command.
14120: ** The argument passed to this function is the output of built-in
14121: ** function quote(). If the first character of the input is "'",
14122: ** indicating that the value passed to quote() was a text value,
14123: ** then this function searches the input for "\n" and "\r" characters
14124: ** and adds a wrapper similar to the following:
14125: **
14126: **   replace(replace(<input>, '\n', char(10), '\r', char(13));
14127: **
14128: ** Or, if the first character of the input is not "'", then a copy
14129: ** of the input is returned.
14130: */
14131: static void shellEscapeCrnl(
14132:   sqlite3_context *context,
14133:   int argc,
14134:   sqlite3_value **argv
14135: ){
14136:   const char *zText = (const char*)sqlite3_value_text(argv[0]);
14137:   UNUSED_PARAMETER(argc);
14138:   if( zText[0]=='\'' ){
14139:     int nText = sqlite3_value_bytes(argv[0]);
14140:     int i;
14141:     char zBuf1[20];
14142:     char zBuf2[20];
14143:     const char *zNL = 0;
14144:     const char *zCR = 0;
14145:     int nCR = 0;
14146:     int nNL = 0;
14147: 
14148:     for(i=0; zText[i]; i++){
14149:       if( zNL==0 && zText[i]=='\n' ){
14150:         zNL = unused_string(zText, "\\n", "\\012", zBuf1);
14151:         nNL = (int)strlen(zNL);
14152:       }
14153:       if( zCR==0 && zText[i]=='\r' ){
14154:         zCR = unused_string(zText, "\\r", "\\015", zBuf2);
14155:         nCR = (int)strlen(zCR);
14156:       }
14157:     }
14158: 
14159:     if( zNL || zCR ){
14160:       int iOut = 0;
14161:       i64 nMax = (nNL > nCR) ? nNL : nCR;
14162:       i64 nAlloc = nMax * nText + (nMax+64)*2;
14163:       char *zOut = (char*)sqlite3_malloc64(nAlloc);
14164:       if( zOut==0 ){
14165:         sqlite3_result_error_nomem(context);
14166:         return;
14167:       }
14168: 
14169:       if( zNL && zCR ){
14170:         memcpy(&zOut[iOut], "replace(replace(", 16);
14171:         iOut += 16;
14172:       }else{
14173:         memcpy(&zOut[iOut], "replace(", 8);
14174:         iOut += 8;
14175:       }
14176:       for(i=0; zText[i]; i++){
14177:         if( zText[i]=='\n' ){
14178:           memcpy(&zOut[iOut], zNL, nNL);
14179:           iOut += nNL;
14180:         }else if( zText[i]=='\r' ){
14181:           memcpy(&zOut[iOut], zCR, nCR);
14182:           iOut += nCR;
14183:         }else{
14184:           zOut[iOut] = zText[i];
14185:           iOut++;
14186:         }
14187:       }
14188: 
14189:       if( zNL ){
14190:         memcpy(&zOut[iOut], ",'", 2); iOut += 2;
14191:         memcpy(&zOut[iOut], zNL, nNL); iOut += nNL;
14192:         memcpy(&zOut[iOut], "', char(10))", 12); iOut += 12;
14193:       }
14194:       if( zCR ){
14195:         memcpy(&zOut[iOut], ",'", 2); iOut += 2;
14196:         memcpy(&zOut[iOut], zCR, nCR); iOut += nCR;
14197:         memcpy(&zOut[iOut], "', char(13))", 12); iOut += 12;
14198:       }
14199: 
14200:       sqlite3_result_text(context, zOut, iOut, SQLITE_TRANSIENT);
14201:       sqlite3_free(zOut);
14202:       return;
14203:     }
14204:   }
14205: 
14206:   sqlite3_result_value(context, argv[0]);
14207: }
14208: 
14209: /* Flags for open_db().
14210: **
14211: ** The default behavior of open_db() is to exit(1) if the database fails to
14212: ** open.  The OPEN_DB_KEEPALIVE flag changes that so that it prints an error
14213: ** but still returns without calling exit.
14214: **
14215: ** The OPEN_DB_ZIPFILE flag causes open_db() to prefer to open files as a
14216: ** ZIP archive if the file does not exist or is empty and its name matches
14217: ** the *.zip pattern.
14218: */
14219: #define OPEN_DB_KEEPALIVE   0x001   /* Return after error if true */
14220: #define OPEN_DB_ZIPFILE     0x002   /* Open as ZIP if name matches *.zip */
14221: 
14222: /*
14223: ** Make sure the database is open.  If it is not, then open it.  If
14224: ** the database fails to open, print an error message and exit.
14225: */
14226: static void open_db(ShellState *p, int openFlags){
14227:   if( p->db==0 ){
14228:     if( p->openMode==SHELL_OPEN_UNSPEC ){
14229:       if( p->zDbFilename==0 || p->zDbFilename[0]==0 ){
14230:         p->openMode = SHELL_OPEN_NORMAL;
14231:       }else{
14232:         p->openMode = (u8)deduceDatabaseType(p->zDbFilename,
14233:                              (openFlags & OPEN_DB_ZIPFILE)!=0);
14234:       }
14235:     }
14236:     switch( p->openMode ){
14237:       case SHELL_OPEN_APPENDVFS: {
14238:         sqlite3_open_v2(p->zDbFilename, &p->db,
14239:            SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|p->openFlags, "apndvfs");
14240:         break;
14241:       }
14242:       case SHELL_OPEN_HEXDB:
14243:       case SHELL_OPEN_DESERIALIZE: {
14244:         sqlite3_open(0, &p->db);
14245:         break;
14246:       }
14247:       case SHELL_OPEN_ZIPFILE: {
14248:         sqlite3_open(":memory:", &p->db);
14249:         break;
14250:       }
14251:       case SHELL_OPEN_READONLY: {
14252:         sqlite3_open_v2(p->zDbFilename, &p->db,
14253:             SQLITE_OPEN_READONLY|p->openFlags, 0);
14254:         break;
14255:       }
14256:       case SHELL_OPEN_UNSPEC:
14257:       case SHELL_OPEN_NORMAL: {
14258:         sqlite3_open_v2(p->zDbFilename, &p->db,
14259:            SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|p->openFlags, 0);
14260:         break;
14261:       }
14262:     }
14263:     globalDb = p->db;
14264:     if( p->db==0 || SQLITE_OK!=sqlite3_errcode(p->db) ){
14265:       utf8_printf(stderr,"Error: unable to open database \"%s\": %s\n",
14266:           p->zDbFilename, sqlite3_errmsg(p->db));
14267:       if( openFlags & OPEN_DB_KEEPALIVE ){
14268:         sqlite3_open(":memory:", &p->db);
14269:         return;
14270:       }
14271:       exit(1);
14272:     }
14273: #ifndef SQLITE_OMIT_LOAD_EXTENSION
14274:     sqlite3_enable_load_extension(p->db, 1);
14275: #endif
14276:     sqlite3_fileio_init(p->db, 0, 0);
14277:     sqlite3_shathree_init(p->db, 0, 0);
14278:     sqlite3_completion_init(p->db, 0, 0);
14279:     sqlite3_uint_init(p->db, 0, 0);
14280:     sqlite3_decimal_init(p->db, 0, 0);
14281:     sqlite3_ieee_init(p->db, 0, 0);
14282: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)
14283:     sqlite3_dbdata_init(p->db, 0, 0);
14284: #endif
14285: #ifdef SQLITE_HAVE_ZLIB
14286:     sqlite3_zipfile_init(p->db, 0, 0);
14287:     sqlite3_sqlar_init(p->db, 0, 0);
14288: #endif
14289:     sqlite3_create_function(p->db, "shell_add_schema", 3, SQLITE_UTF8, 0,
14290:                             shellAddSchemaName, 0, 0);
14291:     sqlite3_create_function(p->db, "shell_module_schema", 1, SQLITE_UTF8, 0,
14292:                             shellModuleSchema, 0, 0);
14293:     sqlite3_create_function(p->db, "shell_putsnl", 1, SQLITE_UTF8, p,
14294:                             shellPutsFunc, 0, 0);
14295:     sqlite3_create_function(p->db, "shell_escape_crnl", 1, SQLITE_UTF8, 0,
14296:                             shellEscapeCrnl, 0, 0);
14297:     sqlite3_create_function(p->db, "shell_int32", 2, SQLITE_UTF8, 0,
14298:                             shellInt32, 0, 0);
14299:     sqlite3_create_function(p->db, "shell_idquote", 1, SQLITE_UTF8, 0,
14300:                             shellIdQuote, 0, 0);
14301: #ifndef SQLITE_NOHAVE_SYSTEM
14302:     sqlite3_create_function(p->db, "edit", 1, SQLITE_UTF8, 0,
14303:                             editFunc, 0, 0);
14304:     sqlite3_create_function(p->db, "edit", 2, SQLITE_UTF8, 0,
14305:                             editFunc, 0, 0);
14306: #endif
14307:     if( p->openMode==SHELL_OPEN_ZIPFILE ){
14308:       char *zSql = sqlite3_mprintf(
14309:          "CREATE VIRTUAL TABLE zip USING zipfile(%Q);", p->zDbFilename);
14310:       sqlite3_exec(p->db, zSql, 0, 0, 0);
14311:       sqlite3_free(zSql);
14312:     }
14313: #ifdef SQLITE_ENABLE_DESERIALIZE
14314:     else
14315:     if( p->openMode==SHELL_OPEN_DESERIALIZE || p->openMode==SHELL_OPEN_HEXDB ){
14316:       int rc;
14317:       int nData = 0;
14318:       unsigned char *aData;
14319:       if( p->openMode==SHELL_OPEN_DESERIALIZE ){
14320:         aData = (unsigned char*)readFile(p->zDbFilename, &nData);
14321:       }else{
14322:         aData = readHexDb(p, &nData);
14323:         if( aData==0 ){
14324:           return;
14325:         }
14326:       }
14327:       rc = sqlite3_deserialize(p->db, "main", aData, nData, nData,
14328:                    SQLITE_DESERIALIZE_RESIZEABLE |
14329:                    SQLITE_DESERIALIZE_FREEONCLOSE);
14330:       if( rc ){
14331:         utf8_printf(stderr, "Error: sqlite3_deserialize() returns %d\n", rc);
14332:       }
14333:       if( p->szMax>0 ){
14334:         sqlite3_file_control(p->db, "main", SQLITE_FCNTL_SIZE_LIMIT, &p->szMax);
14335:       }
14336:     }
14337: #endif
14338:   }
14339: }
14340: 
14341: /*
14342: ** Attempt to close the databaes connection.  Report errors.
14343: */
14344: void close_db(sqlite3 *db){
14345:   int rc = sqlite3_close(db);
14346:   if( rc ){
14347:     utf8_printf(stderr, "Error: sqlite3_close() returns %d: %s\n",
14348:         rc, sqlite3_errmsg(db));
14349:   }
14350: }
14351: 
14352: #if HAVE_READLINE || HAVE_EDITLINE
14353: /*
14354: ** Readline completion callbacks
14355: */
14356: static char *readline_completion_generator(const char *text, int state){
14357:   static sqlite3_stmt *pStmt = 0;
14358:   char *zRet;
14359:   if( state==0 ){
14360:     char *zSql;
14361:     sqlite3_finalize(pStmt);
14362:     zSql = sqlite3_mprintf("SELECT DISTINCT candidate COLLATE nocase"
14363:                            "  FROM completion(%Q) ORDER BY 1", text);
14364:     sqlite3_prepare_v2(globalDb, zSql, -1, &pStmt, 0);
14365:     sqlite3_free(zSql);
14366:   }
14367:   if( sqlite3_step(pStmt)==SQLITE_ROW ){
14368:     zRet = strdup((const char*)sqlite3_column_text(pStmt, 0));
14369:   }else{
14370:     sqlite3_finalize(pStmt);
14371:     pStmt = 0;
14372:     zRet = 0;
14373:   }
14374:   return zRet;
14375: }
14376: static char **readline_completion(const char *zText, int iStart, int iEnd){
14377:   rl_attempted_completion_over = 1;
14378:   return rl_completion_matches(zText, readline_completion_generator);
14379: }
14380: 
14381: #elif HAVE_LINENOISE
14382: /*
14383: ** Linenoise completion callback
14384: */
14385: static void linenoise_completion(const char *zLine, linenoiseCompletions *lc){
14386:   int nLine = strlen30(zLine);
14387:   int copiedSuggestion = 0;
14388:   sqlite3_stmt *pStmt = 0;
14389:   char *zSql;
14390:   char zBuf[1000];
14391: 
14392:   if( nLine>sizeof(zBuf)-30 ) return;
14393:   if( zLine[0]=='.' || zLine[0]=='#') return;
14394: //  if( i==nLine-1 ) return;
14395:   zSql = sqlite3_mprintf("CALL sql_auto_complete(%Q)", zLine);
14396:   sqlite3 *localDb = NULL;
14397:   if (!globalDb) {
14398:     sqlite3_open(":memory:", &localDb);
14399:     sqlite3_prepare_v2(localDb, zSql, -1, &pStmt, 0);
14400:   } else {
14401:     sqlite3_prepare_v2(globalDb, zSql, -1, &pStmt, 0);
14402:   }
14403:   sqlite3_free(zSql);
14404:   while( sqlite3_step(pStmt)==SQLITE_ROW ){
14405:     const char *zCompletion = (const char*)sqlite3_column_text(pStmt, 0);
14406: 	int nCompletion = sqlite3_column_bytes(pStmt, 0);
14407: 	int iStart = sqlite3_column_int(pStmt, 1);
14408:     if( iStart+nCompletion < sizeof(zBuf)-1 ){
14409: 		if (!copiedSuggestion) {
14410: 			memcpy(zBuf, zLine, iStart);
14411: 			copiedSuggestion = 1;
14412: 		}
14413:       memcpy(zBuf+iStart, zCompletion, nCompletion+1);
14414:       linenoiseAddCompletion(lc, zBuf);
14415:     }
14416:   }
14417:   sqlite3_finalize(pStmt);
14418:   if (localDb) {
14419: 	  sqlite3_close(localDb);
14420:   }
14421: }
14422: #endif
14423: 
14424: /*
14425: ** Do C-language style dequoting.
14426: **
14427: **    \a    -> alarm
14428: **    \b    -> backspace
14429: **    \t    -> tab
14430: **    \n    -> newline
14431: **    \v    -> vertical tab
14432: **    \f    -> form feed
14433: **    \r    -> carriage return
14434: **    \s    -> space
14435: **    \"    -> "
14436: **    \'    -> '
14437: **    \\    -> backslash
14438: **    \NNN  -> ascii character NNN in octal
14439: */
14440: static void resolve_backslashes(char *z){
14441:   int i, j;
14442:   char c;
14443:   while( *z && *z!='\\' ) z++;
14444:   for(i=j=0; (c = z[i])!=0; i++, j++){
14445:     if( c=='\\' && z[i+1]!=0 ){
14446:       c = z[++i];
14447:       if( c=='a' ){
14448:         c = '\a';
14449:       }else if( c=='b' ){
14450:         c = '\b';
14451:       }else if( c=='t' ){
14452:         c = '\t';
14453:       }else if( c=='n' ){
14454:         c = '\n';
14455:       }else if( c=='v' ){
14456:         c = '\v';
14457:       }else if( c=='f' ){
14458:         c = '\f';
14459:       }else if( c=='r' ){
14460:         c = '\r';
14461:       }else if( c=='"' ){
14462:         c = '"';
14463:       }else if( c=='\'' ){
14464:         c = '\'';
14465:       }else if( c=='\\' ){
14466:         c = '\\';
14467:       }else if( c>='0' && c<='7' ){
14468:         c -= '0';
14469:         if( z[i+1]>='0' && z[i+1]<='7' ){
14470:           i++;
14471:           c = (c<<3) + z[i] - '0';
14472:           if( z[i+1]>='0' && z[i+1]<='7' ){
14473:             i++;
14474:             c = (c<<3) + z[i] - '0';
14475:           }
14476:         }
14477:       }
14478:     }
14479:     z[j] = c;
14480:   }
14481:   if( j<i ) z[j] = 0;
14482: }
14483: 
14484: /*
14485: ** Interpret zArg as either an integer or a boolean value.  Return 1 or 0
14486: ** for TRUE and FALSE.  Return the integer value if appropriate.
14487: */
14488: static int booleanValue(const char *zArg){
14489:   int i;
14490:   if( zArg[0]=='0' && zArg[1]=='x' ){
14491:     for(i=2; hexDigitValue(zArg[i])>=0; i++){}
14492:   }else{
14493:     for(i=0; zArg[i]>='0' && zArg[i]<='9'; i++){}
14494:   }
14495:   if( i>0 && zArg[i]==0 ) return (int)(integerValue(zArg) & 0xffffffff);
14496:   if( sqlite3_stricmp(zArg, "on")==0 || sqlite3_stricmp(zArg,"yes")==0 ){
14497:     return 1;
14498:   }
14499:   if( sqlite3_stricmp(zArg, "off")==0 || sqlite3_stricmp(zArg,"no")==0 ){
14500:     return 0;
14501:   }
14502:   utf8_printf(stderr, "ERROR: Not a boolean value: \"%s\". Assuming \"no\".\n",
14503:           zArg);
14504:   return 0;
14505: }
14506: 
14507: /*
14508: ** Set or clear a shell flag according to a boolean value.
14509: */
14510: static void setOrClearFlag(ShellState *p, unsigned mFlag, const char *zArg){
14511:   if( booleanValue(zArg) ){
14512:     ShellSetFlag(p, mFlag);
14513:   }else{
14514:     ShellClearFlag(p, mFlag);
14515:   }
14516: }
14517: 
14518: /*
14519: ** Close an output file, assuming it is not stderr or stdout
14520: */
14521: static void output_file_close(FILE *f){
14522:   if( f && f!=stdout && f!=stderr ) fclose(f);
14523: }
14524: 
14525: /*
14526: ** Try to open an output file.   The names "stdout" and "stderr" are
14527: ** recognized and do the right thing.  NULL is returned if the output
14528: ** filename is "off".
14529: */
14530: static FILE *output_file_open(const char *zFile, int bTextMode){
14531:   FILE *f;
14532:   if( strcmp(zFile,"stdout")==0 ){
14533:     f = stdout;
14534:   }else if( strcmp(zFile, "stderr")==0 ){
14535:     f = stderr;
14536:   }else if( strcmp(zFile, "off")==0 ){
14537:     f = 0;
14538:   }else{
14539:     f = fopen(zFile, bTextMode ? "w" : "wb");
14540:     if( f==0 ){
14541:       utf8_printf(stderr, "Error: cannot open \"%s\"\n", zFile);
14542:     }
14543:   }
14544:   return f;
14545: }
14546: 
14547: #ifndef SQLITE_OMIT_TRACE
14548: /*
14549: ** A routine for handling output from sqlite3_trace().
14550: */
14551: static int sql_trace_callback(
14552:   unsigned mType,         /* The trace type */
14553:   void *pArg,             /* The ShellState pointer */
14554:   void *pP,               /* Usually a pointer to sqlite_stmt */
14555:   void *pX                /* Auxiliary output */
14556: ){
14557:   ShellState *p = (ShellState*)pArg;
14558:   sqlite3_stmt *pStmt;
14559:   const char *zSql;
14560:   int nSql;
14561:   if( p->traceOut==0 ) return 0;
14562:   if( mType==SQLITE_TRACE_CLOSE ){
14563:     utf8_printf(p->traceOut, "-- closing database connection\n");
14564:     return 0;
14565:   }
14566:   if( mType!=SQLITE_TRACE_ROW && ((const char*)pX)[0]=='-' ){
14567:     zSql = (const char*)pX;
14568:   }else{
14569:     pStmt = (sqlite3_stmt*)pP;
14570:     switch( p->eTraceType ){
14571:       case SHELL_TRACE_EXPANDED: {
14572:         zSql = sqlite3_expanded_sql(pStmt);
14573:         break;
14574:       }
14575: #ifdef SQLITE_ENABLE_NORMALIZE
14576:       case SHELL_TRACE_NORMALIZED: {
14577:         zSql = sqlite3_normalized_sql(pStmt);
14578:         break;
14579:       }
14580: #endif
14581:       default: {
14582:         zSql = sqlite3_sql(pStmt);
14583:         break;
14584:       }
14585:     }
14586:   }
14587:   if( zSql==0 ) return 0;
14588:   nSql = strlen30(zSql);
14589:   while( nSql>0 && zSql[nSql-1]==';' ){ nSql--; }
14590:   switch( mType ){
14591:     case SQLITE_TRACE_ROW:
14592:     case SQLITE_TRACE_STMT: {
14593:       utf8_printf(p->traceOut, "%.*s;\n", nSql, zSql);
14594:       break;
14595:     }
14596:     case SQLITE_TRACE_PROFILE: {
14597:       sqlite3_int64 nNanosec = *(sqlite3_int64*)pX;
14598:       utf8_printf(p->traceOut, "%.*s; -- %lld ns\n", nSql, zSql, nNanosec);
14599:       break;
14600:     }
14601:   }
14602:   return 0;
14603: }
14604: #endif
14605: 
14606: /*
14607: ** A no-op routine that runs with the ".breakpoint" doc-command.  This is
14608: ** a useful spot to set a debugger breakpoint.
14609: */
14610: static void test_breakpoint(void){
14611:   static int nCall = 0;
14612:   nCall++;
14613: }
14614: 
14615: /*
14616: ** An object used to read a CSV and other files for import.
14617: */
14618: typedef struct ImportCtx ImportCtx;
14619: struct ImportCtx {
14620:   const char *zFile;  /* Name of the input file */
14621:   FILE *in;           /* Read the CSV text from this input stream */
14622:   int (SQLITE_CDECL *xCloser)(FILE*);      /* Func to close in */
14623:   char *z;            /* Accumulated text for a field */
14624:   int n;              /* Number of bytes in z */
14625:   int nAlloc;         /* Space allocated for z[] */
14626:   int nLine;          /* Current line number */
14627:   int nRow;           /* Number of rows imported */
14628:   int nErr;           /* Number of errors encountered */
14629:   int bNotFirst;      /* True if one or more bytes already read */
14630:   int cTerm;          /* Character that terminated the most recent field */
14631:   int cColSep;        /* The column separator character.  (Usually ",") */
14632:   int cRowSep;        /* The row separator character.  (Usually "\n") */
14633: };
14634: 
14635: /* Clean up resourced used by an ImportCtx */
14636: static void import_cleanup(ImportCtx *p){
14637:   if( p->in!=0 && p->xCloser!=0 ){
14638:     p->xCloser(p->in);
14639:     p->in = 0;
14640:   }
14641:   sqlite3_free(p->z);
14642:   p->z = 0;
14643: }
14644: 
14645: /* Append a single byte to z[] */
14646: static void import_append_char(ImportCtx *p, int c){
14647:   if( p->n+1>=p->nAlloc ){
14648:     p->nAlloc += p->nAlloc + 100;
14649:     p->z = sqlite3_realloc64(p->z, p->nAlloc);
14650:     if( p->z==0 ) shell_out_of_memory();
14651:   }
14652:   p->z[p->n++] = (char)c;
14653: }
14654: 
14655: /* Read a single field of CSV text.  Compatible with rfc4180 and extended
14656: ** with the option of having a separator other than ",".
14657: **
14658: **   +  Input comes from p->in.
14659: **   +  Store results in p->z of length p->n.  Space to hold p->z comes
14660: **      from sqlite3_malloc64().
14661: **   +  Use p->cSep as the column separator.  The default is ",".
14662: **   +  Use p->rSep as the row separator.  The default is "\n".
14663: **   +  Keep track of the line number in p->nLine.
14664: **   +  Store the character that terminates the field in p->cTerm.  Store
14665: **      EOF on end-of-file.
14666: **   +  Report syntax errors on stderr
14667: */
14668: static char *SQLITE_CDECL csv_read_one_field(ImportCtx *p){
14669:   int c;
14670:   int cSep = p->cColSep;
14671:   int rSep = p->cRowSep;
14672:   p->n = 0;
14673:   c = fgetc(p->in);
14674:   if( c==EOF || seenInterrupt ){
14675:     p->cTerm = EOF;
14676:     return 0;
14677:   }
14678:   if( c=='"' ){
14679:     int pc, ppc;
14680:     int startLine = p->nLine;
14681:     int cQuote = c;
14682:     pc = ppc = 0;
14683:     while( 1 ){
14684:       c = fgetc(p->in);
14685:       if( c==rSep ) p->nLine++;
14686:       if( c==cQuote ){
14687:         if( pc==cQuote ){
14688:           pc = 0;
14689:           continue;
14690:         }
14691:       }
14692:       if( (c==cSep && pc==cQuote)
14693:        || (c==rSep && pc==cQuote)
14694:        || (c==rSep && pc=='\r' && ppc==cQuote)
14695:        || (c==EOF && pc==cQuote)
14696:       ){
14697:         do{ p->n--; }while( p->z[p->n]!=cQuote );
14698:         p->cTerm = c;
14699:         break;
14700:       }
14701:       if( pc==cQuote && c!='\r' ){
14702:         utf8_printf(stderr, "%s:%d: unescaped %c character\n",
14703:                 p->zFile, p->nLine, cQuote);
14704:       }
14705:       if( c==EOF ){
14706:         utf8_printf(stderr, "%s:%d: unterminated %c-quoted field\n",
14707:                 p->zFile, startLine, cQuote);
14708:         p->cTerm = c;
14709:         break;
14710:       }
14711:       import_append_char(p, c);
14712:       ppc = pc;
14713:       pc = c;
14714:     }
14715:   }else{
14716:     /* If this is the first field being parsed and it begins with the
14717:     ** UTF-8 BOM  (0xEF BB BF) then skip the BOM */
14718:     if( (c&0xff)==0xef && p->bNotFirst==0 ){
14719:       import_append_char(p, c);
14720:       c = fgetc(p->in);
14721:       if( (c&0xff)==0xbb ){
14722:         import_append_char(p, c);
14723:         c = fgetc(p->in);
14724:         if( (c&0xff)==0xbf ){
14725:           p->bNotFirst = 1;
14726:           p->n = 0;
14727:           return csv_read_one_field(p);
14728:         }
14729:       }
14730:     }
14731:     while( c!=EOF && c!=cSep && c!=rSep ){
14732:       import_append_char(p, c);
14733:       c = fgetc(p->in);
14734:     }
14735:     if( c==rSep ){
14736:       p->nLine++;
14737:       if( p->n>0 && p->z[p->n-1]=='\r' ) p->n--;
14738:     }
14739:     p->cTerm = c;
14740:   }
14741:   if( p->z ) p->z[p->n] = 0;
14742:   p->bNotFirst = 1;
14743:   return p->z;
14744: }
14745: 
14746: /* Read a single field of ASCII delimited text.
14747: **
14748: **   +  Input comes from p->in.
14749: **   +  Store results in p->z of length p->n.  Space to hold p->z comes
14750: **      from sqlite3_malloc64().
14751: **   +  Use p->cSep as the column separator.  The default is "\x1F".
14752: **   +  Use p->rSep as the row separator.  The default is "\x1E".
14753: **   +  Keep track of the row number in p->nLine.
14754: **   +  Store the character that terminates the field in p->cTerm.  Store
14755: **      EOF on end-of-file.
14756: **   +  Report syntax errors on stderr
14757: */
14758: static char *SQLITE_CDECL ascii_read_one_field(ImportCtx *p){
14759:   int c;
14760:   int cSep = p->cColSep;
14761:   int rSep = p->cRowSep;
14762:   p->n = 0;
14763:   c = fgetc(p->in);
14764:   if( c==EOF || seenInterrupt ){
14765:     p->cTerm = EOF;
14766:     return 0;
14767:   }
14768:   while( c!=EOF && c!=cSep && c!=rSep ){
14769:     import_append_char(p, c);
14770:     c = fgetc(p->in);
14771:   }
14772:   if( c==rSep ){
14773:     p->nLine++;
14774:   }
14775:   p->cTerm = c;
14776:   if( p->z ) p->z[p->n] = 0;
14777:   return p->z;
14778: }
14779: 
14780: /*
14781: ** Try to transfer data for table zTable.  If an error is seen while
14782: ** moving forward, try to go backwards.  The backwards movement won't
14783: ** work for WITHOUT ROWID tables.
14784: */
14785: static void tryToCloneData(
14786:   ShellState *p,
14787:   sqlite3 *newDb,
14788:   const char *zTable
14789: ){
14790:   sqlite3_stmt *pQuery = 0;
14791:   sqlite3_stmt *pInsert = 0;
14792:   char *zQuery = 0;
14793:   char *zInsert = 0;
14794:   int rc;
14795:   int i, j, n;
14796:   int nTable = strlen30(zTable);
14797:   int k = 0;
14798:   int cnt = 0;
14799:   const int spinRate = 10000;
14800: 
14801:   zQuery = sqlite3_mprintf("SELECT * FROM \"%w\"", zTable);
14802:   rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);
14803:   if( rc ){
14804:     utf8_printf(stderr, "Error %d: %s on [%s]\n",
14805:             sqlite3_extended_errcode(p->db), sqlite3_errmsg(p->db),
14806:             zQuery);
14807:     goto end_data_xfer;
14808:   }
14809:   n = sqlite3_column_count(pQuery);
14810:   zInsert = sqlite3_malloc64(200 + nTable + n*3);
14811:   if( zInsert==0 ) shell_out_of_memory();
14812:   sqlite3_snprintf(200+nTable,zInsert,
14813:                    "INSERT OR IGNORE INTO \"%s\" VALUES(?", zTable);
14814:   i = strlen30(zInsert);
14815:   for(j=1; j<n; j++){
14816:     memcpy(zInsert+i, ",?", 2);
14817:     i += 2;
14818:   }
14819:   memcpy(zInsert+i, ");", 3);
14820:   rc = sqlite3_prepare_v2(newDb, zInsert, -1, &pInsert, 0);
14821:   if( rc ){
14822:     utf8_printf(stderr, "Error %d: %s on [%s]\n",
14823:             sqlite3_extended_errcode(newDb), sqlite3_errmsg(newDb),
14824:             zQuery);
14825:     goto end_data_xfer;
14826:   }
14827:   for(k=0; k<2; k++){
14828:     while( (rc = sqlite3_step(pQuery))==SQLITE_ROW ){
14829:       for(i=0; i<n; i++){
14830:         switch( sqlite3_column_type(pQuery, i) ){
14831:           case SQLITE_NULL: {
14832:             sqlite3_bind_null(pInsert, i+1);
14833:             break;
14834:           }
14835:           case SQLITE_INTEGER: {
14836:             sqlite3_bind_int64(pInsert, i+1, sqlite3_column_int64(pQuery,i));
14837:             break;
14838:           }
14839:           case SQLITE_FLOAT: {
14840:             sqlite3_bind_double(pInsert, i+1, sqlite3_column_double(pQuery,i));
14841:             break;
14842:           }
14843:           case SQLITE_TEXT: {
14844:             sqlite3_bind_text(pInsert, i+1,
14845:                              (const char*)sqlite3_column_text(pQuery,i),
14846:                              -1, SQLITE_STATIC);
14847:             break;
14848:           }
14849:           case SQLITE_BLOB: {
14850:             sqlite3_bind_blob(pInsert, i+1, sqlite3_column_blob(pQuery,i),
14851:                                             sqlite3_column_bytes(pQuery,i),
14852:                                             SQLITE_STATIC);
14853:             break;
14854:           }
14855:         }
14856:       } /* End for */
14857:       rc = sqlite3_step(pInsert);
14858:       if( rc!=SQLITE_OK && rc!=SQLITE_ROW && rc!=SQLITE_DONE ){
14859:         utf8_printf(stderr, "Error %d: %s\n", sqlite3_extended_errcode(newDb),
14860:                         sqlite3_errmsg(newDb));
14861:       }
14862:       sqlite3_reset(pInsert);
14863:       cnt++;
14864:       if( (cnt%spinRate)==0 ){
14865:         printf("%c\b", "|/-\\"[(cnt/spinRate)%4]);
14866:         fflush(stdout);
14867:       }
14868:     } /* End while */
14869:     if( rc==SQLITE_DONE ) break;
14870:     sqlite3_finalize(pQuery);
14871:     sqlite3_free(zQuery);
14872:     zQuery = sqlite3_mprintf("SELECT * FROM \"%w\" ORDER BY rowid DESC;",
14873:                              zTable);
14874:     rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);
14875:     if( rc ){
14876:       utf8_printf(stderr, "Warning: cannot step \"%s\" backwards", zTable);
14877:       break;
14878:     }
14879:   } /* End for(k=0...) */
14880: 
14881: end_data_xfer:
14882:   sqlite3_finalize(pQuery);
14883:   sqlite3_finalize(pInsert);
14884:   sqlite3_free(zQuery);
14885:   sqlite3_free(zInsert);
14886: }
14887: 
14888: 
14889: /*
14890: ** Try to transfer all rows of the schema that match zWhere.  For
14891: ** each row, invoke xForEach() on the object defined by that row.
14892: ** If an error is encountered while moving forward through the
14893: ** sqlite_schema table, try again moving backwards.
14894: */
14895: static void tryToCloneSchema(
14896:   ShellState *p,
14897:   sqlite3 *newDb,
14898:   const char *zWhere,
14899:   void (*xForEach)(ShellState*,sqlite3*,const char*)
14900: ){
14901:   sqlite3_stmt *pQuery = 0;
14902:   char *zQuery = 0;
14903:   int rc;
14904:   const unsigned char *zName;
14905:   const unsigned char *zSql;
14906:   char *zErrMsg = 0;
14907: 
14908:   zQuery = sqlite3_mprintf("SELECT name, sql FROM sqlite_schema"
14909:                            " WHERE %s", zWhere);
14910:   rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);
14911:   if( rc ){
14912:     utf8_printf(stderr, "Error: (%d) %s on [%s]\n",
14913:                     sqlite3_extended_errcode(p->db), sqlite3_errmsg(p->db),
14914:                     zQuery);
14915:     goto end_schema_xfer;
14916:   }
14917:   while( (rc = sqlite3_step(pQuery))==SQLITE_ROW ){
14918:     zName = sqlite3_column_text(pQuery, 0);
14919:     zSql = sqlite3_column_text(pQuery, 1);
14920:     printf("%s... ", zName); fflush(stdout);
14921:     sqlite3_exec(newDb, (const char*)zSql, 0, 0, &zErrMsg);
14922:     if( zErrMsg ){
14923:       utf8_printf(stderr, "Error: %s\nSQL: [%s]\n", zErrMsg, zSql);
14924:       sqlite3_free(zErrMsg);
14925:       zErrMsg = 0;
14926:     }
14927:     if( xForEach ){
14928:       xForEach(p, newDb, (const char*)zName);
14929:     }
14930:     printf("done\n");
14931:   }
14932:   if( rc!=SQLITE_DONE ){
14933:     sqlite3_finalize(pQuery);
14934:     sqlite3_free(zQuery);
14935:     zQuery = sqlite3_mprintf("SELECT name, sql FROM sqlite_schema"
14936:                              " WHERE %s ORDER BY rowid DESC", zWhere);
14937:     rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);
14938:     if( rc ){
14939:       utf8_printf(stderr, "Error: (%d) %s on [%s]\n",
14940:                       sqlite3_extended_errcode(p->db), sqlite3_errmsg(p->db),
14941:                       zQuery);
14942:       goto end_schema_xfer;
14943:     }
14944:     while( (rc = sqlite3_step(pQuery))==SQLITE_ROW ){
14945:       zName = sqlite3_column_text(pQuery, 0);
14946:       zSql = sqlite3_column_text(pQuery, 1);
14947:       printf("%s... ", zName); fflush(stdout);
14948:       sqlite3_exec(newDb, (const char*)zSql, 0, 0, &zErrMsg);
14949:       if( zErrMsg ){
14950:         utf8_printf(stderr, "Error: %s\nSQL: [%s]\n", zErrMsg, zSql);
14951:         sqlite3_free(zErrMsg);
14952:         zErrMsg = 0;
14953:       }
14954:       if( xForEach ){
14955:         xForEach(p, newDb, (const char*)zName);
14956:       }
14957:       printf("done\n");
14958:     }
14959:   }
14960: end_schema_xfer:
14961:   sqlite3_finalize(pQuery);
14962:   sqlite3_free(zQuery);
14963: }
14964: 
14965: /*
14966: ** Open a new database file named "zNewDb".  Try to recover as much information
14967: ** as possible out of the main database (which might be corrupt) and write it
14968: ** into zNewDb.
14969: */
14970: static void tryToClone(ShellState *p, const char *zNewDb){
14971:   int rc;
14972:   sqlite3 *newDb = 0;
14973:   if( access(zNewDb,0)==0 ){
14974:     utf8_printf(stderr, "File \"%s\" already exists.\n", zNewDb);
14975:     return;
14976:   }
14977:   rc = sqlite3_open(zNewDb, &newDb);
14978:   if( rc ){
14979:     utf8_printf(stderr, "Cannot create output database: %s\n",
14980:             sqlite3_errmsg(newDb));
14981:   }else{
14982:     sqlite3_exec(p->db, "PRAGMA writable_schema=ON;", 0, 0, 0);
14983:     sqlite3_exec(newDb, "BEGIN EXCLUSIVE;", 0, 0, 0);
14984:     tryToCloneSchema(p, newDb, "type='table'", tryToCloneData);
14985:     tryToCloneSchema(p, newDb, "type!='table'", 0);
14986:     sqlite3_exec(newDb, "COMMIT;", 0, 0, 0);
14987:     sqlite3_exec(p->db, "PRAGMA writable_schema=OFF;", 0, 0, 0);
14988:   }
14989:   close_db(newDb);
14990: }
14991: 
14992: /*
14993: ** Change the output file back to stdout.
14994: **
14995: ** If the p->doXdgOpen flag is set, that means the output was being
14996: ** redirected to a temporary file named by p->zTempFile.  In that case,
14997: ** launch start/open/xdg-open on that temporary file.
14998: */
14999: static void output_reset(ShellState *p){
15000:   if( p->outfile[0]=='|' ){
15001: #ifndef SQLITE_OMIT_POPEN
15002:     pclose(p->out);
15003: #endif
15004:   }else{
15005:     output_file_close(p->out);
15006: #ifndef SQLITE_NOHAVE_SYSTEM
15007:     if( p->doXdgOpen ){
15008:       const char *zXdgOpenCmd =
15009: #if defined(_WIN32)
15010:       "start";
15011: #elif defined(__APPLE__)
15012:       "open";
15013: #else
15014:       "xdg-open";
15015: #endif
15016:       char *zCmd;
15017:       zCmd = sqlite3_mprintf("%s %s", zXdgOpenCmd, p->zTempFile);
15018:       if( system(zCmd) ){
15019:         utf8_printf(stderr, "Failed: [%s]\n", zCmd);
15020:       }else{
15021:         /* Give the start/open/xdg-open command some time to get
15022:         ** going before we continue, and potential delete the
15023:         ** p->zTempFile data file out from under it */
15024:         sqlite3_sleep(2000);
15025:       }
15026:       sqlite3_free(zCmd);
15027:       outputModePop(p);
15028:       p->doXdgOpen = 0;
15029:     }
15030: #endif /* !defined(SQLITE_NOHAVE_SYSTEM) */
15031:   }
15032:   p->outfile[0] = 0;
15033:   p->out = stdout;
15034: }
15035: 
15036: /*
15037: ** Run an SQL command and return the single integer result.
15038: */
15039: static int db_int(ShellState *p, const char *zSql){
15040:   sqlite3_stmt *pStmt;
15041:   int res = 0;
15042:   sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
15043:   if( pStmt && sqlite3_step(pStmt)==SQLITE_ROW ){
15044:     res = sqlite3_column_int(pStmt,0);
15045:   }
15046:   sqlite3_finalize(pStmt);
15047:   return res;
15048: }
15049: 
15050: /*
15051: ** Convert a 2-byte or 4-byte big-endian integer into a native integer
15052: */
15053: static unsigned int get2byteInt(unsigned char *a){
15054:   return (a[0]<<8) + a[1];
15055: }
15056: static unsigned int get4byteInt(unsigned char *a){
15057:   return (a[0]<<24) + (a[1]<<16) + (a[2]<<8) + a[3];
15058: }
15059: 
15060: /*
15061: ** Implementation of the ".dbinfo" command.
15062: **
15063: ** Return 1 on error, 2 to exit, and 0 otherwise.
15064: */
15065: static int shell_dbinfo_command(ShellState *p, int nArg, char **azArg){
15066:   static const struct { const char *zName; int ofst; } aField[] = {
15067:      { "file change counter:",  24  },
15068:      { "database page count:",  28  },
15069:      { "freelist page count:",  36  },
15070:      { "schema cookie:",        40  },
15071:      { "schema format:",        44  },
15072:      { "default cache size:",   48  },
15073:      { "autovacuum top root:",  52  },
15074:      { "incremental vacuum:",   64  },
15075:      { "text encoding:",        56  },
15076:      { "user version:",         60  },
15077:      { "application id:",       68  },
15078:      { "software version:",     96  },
15079:   };
15080:   static const struct { const char *zName; const char *zSql; } aQuery[] = {
15081:      { "number of tables:",
15082:        "SELECT count(*) FROM %s WHERE type='table'" },
15083:      { "number of indexes:",
15084:        "SELECT count(*) FROM %s WHERE type='index'" },
15085:      { "number of triggers:",
15086:        "SELECT count(*) FROM %s WHERE type='trigger'" },
15087:      { "number of views:",
15088:        "SELECT count(*) FROM %s WHERE type='view'" },
15089:      { "schema size:",
15090:        "SELECT total(length(sql)) FROM %s" },
15091:   };
15092:   int i, rc;
15093:   unsigned iDataVersion;
15094:   char *zSchemaTab;
15095:   char *zDb = nArg>=2 ? azArg[1] : "main";
15096:   sqlite3_stmt *pStmt = 0;
15097:   unsigned char aHdr[100];
15098:   open_db(p, 0);
15099:   if( p->db==0 ) return 1;
15100:   rc = sqlite3_prepare_v2(p->db,
15101:              "SELECT data FROM sqlite_dbpage(?1) WHERE pgno=1",
15102:              -1, &pStmt, 0);
15103:   if( rc ){
15104:     utf8_printf(stderr, "error: %s\n", sqlite3_errmsg(p->db));
15105:     sqlite3_finalize(pStmt);
15106:     return 1;
15107:   }
15108:   sqlite3_bind_text(pStmt, 1, zDb, -1, SQLITE_STATIC);
15109:   if( sqlite3_step(pStmt)==SQLITE_ROW
15110:    && sqlite3_column_bytes(pStmt,0)>100
15111:   ){
15112:     memcpy(aHdr, sqlite3_column_blob(pStmt,0), 100);
15113:     sqlite3_finalize(pStmt);
15114:   }else{
15115:     raw_printf(stderr, "unable to read database header\n");
15116:     sqlite3_finalize(pStmt);
15117:     return 1;
15118:   }
15119:   i = get2byteInt(aHdr+16);
15120:   if( i==1 ) i = 65536;
15121:   utf8_printf(p->out, "%-20s %d\n", "database page size:", i);
15122:   utf8_printf(p->out, "%-20s %d\n", "write format:", aHdr[18]);
15123:   utf8_printf(p->out, "%-20s %d\n", "read format:", aHdr[19]);
15124:   utf8_printf(p->out, "%-20s %d\n", "reserved bytes:", aHdr[20]);
15125:   for(i=0; i<ArraySize(aField); i++){
15126:     int ofst = aField[i].ofst;
15127:     unsigned int val = get4byteInt(aHdr + ofst);
15128:     utf8_printf(p->out, "%-20s %u", aField[i].zName, val);
15129:     switch( ofst ){
15130:       case 56: {
15131:         if( val==1 ) raw_printf(p->out, " (utf8)");
15132:         if( val==2 ) raw_printf(p->out, " (utf16le)");
15133:         if( val==3 ) raw_printf(p->out, " (utf16be)");
15134:       }
15135:     }
15136:     raw_printf(p->out, "\n");
15137:   }
15138:   if( zDb==0 ){
15139:     zSchemaTab = sqlite3_mprintf("main.sqlite_schema");
15140:   }else if( strcmp(zDb,"temp")==0 ){
15141:     zSchemaTab = sqlite3_mprintf("%s", "sqlite_temp_schema");
15142:   }else{
15143:     zSchemaTab = sqlite3_mprintf("\"%w\".sqlite_schema", zDb);
15144:   }
15145:   for(i=0; i<ArraySize(aQuery); i++){
15146:     char *zSql = sqlite3_mprintf(aQuery[i].zSql, zSchemaTab);
15147:     int val = db_int(p, zSql);
15148:     sqlite3_free(zSql);
15149:     utf8_printf(p->out, "%-20s %d\n", aQuery[i].zName, val);
15150:   }
15151:   sqlite3_free(zSchemaTab);
15152:   sqlite3_file_control(p->db, zDb, SQLITE_FCNTL_DATA_VERSION, &iDataVersion);
15153:   utf8_printf(p->out, "%-20s %u\n", "data version", iDataVersion);
15154:   return 0;
15155: }
15156: 
15157: /*
15158: ** Print the current sqlite3_errmsg() value to stderr and return 1.
15159: */
15160: static int shellDatabaseError(sqlite3 *db){
15161:   const char *zErr = sqlite3_errmsg(db);
15162:   utf8_printf(stderr, "Error: %s\n", zErr);
15163:   return 1;
15164: }
15165: 
15166: /*
15167: ** Compare the pattern in zGlob[] against the text in z[].  Return TRUE
15168: ** if they match and FALSE (0) if they do not match.
15169: **
15170: ** Globbing rules:
15171: **
15172: **      '*'       Matches any sequence of zero or more characters.
15173: **
15174: **      '?'       Matches exactly one character.
15175: **
15176: **     [...]      Matches one character from the enclosed list of
15177: **                characters.
15178: **
15179: **     [^...]     Matches one character not in the enclosed list.
15180: **
15181: **      '#'       Matches any sequence of one or more digits with an
15182: **                optional + or - sign in front
15183: **
15184: **      ' '       Any span of whitespace matches any other span of
15185: **                whitespace.
15186: **
15187: ** Extra whitespace at the end of z[] is ignored.
15188: */
15189: static int testcase_glob(const char *zGlob, const char *z){
15190:   int c, c2;
15191:   int invert;
15192:   int seen;
15193: 
15194:   while( (c = (*(zGlob++)))!=0 ){
15195:     if( IsSpace(c) ){
15196:       if( !IsSpace(*z) ) return 0;
15197:       while( IsSpace(*zGlob) ) zGlob++;
15198:       while( IsSpace(*z) ) z++;
15199:     }else if( c=='*' ){
15200:       while( (c=(*(zGlob++))) == '*' || c=='?' ){
15201:         if( c=='?' && (*(z++))==0 ) return 0;
15202:       }
15203:       if( c==0 ){
15204:         return 1;
15205:       }else if( c=='[' ){
15206:         while( *z && testcase_glob(zGlob-1,z)==0 ){
15207:           z++;
15208:         }
15209:         return (*z)!=0;
15210:       }
15211:       while( (c2 = (*(z++)))!=0 ){
15212:         while( c2!=c ){
15213:           c2 = *(z++);
15214:           if( c2==0 ) return 0;
15215:         }
15216:         if( testcase_glob(zGlob,z) ) return 1;
15217:       }
15218:       return 0;
15219:     }else if( c=='?' ){
15220:       if( (*(z++))==0 ) return 0;
15221:     }else if( c=='[' ){
15222:       int prior_c = 0;
15223:       seen = 0;
15224:       invert = 0;
15225:       c = *(z++);
15226:       if( c==0 ) return 0;
15227:       c2 = *(zGlob++);
15228:       if( c2=='^' ){
15229:         invert = 1;
15230:         c2 = *(zGlob++);
15231:       }
15232:       if( c2==']' ){
15233:         if( c==']' ) seen = 1;
15234:         c2 = *(zGlob++);
15235:       }
15236:       while( c2 && c2!=']' ){
15237:         if( c2=='-' && zGlob[0]!=']' && zGlob[0]!=0 && prior_c>0 ){
15238:           c2 = *(zGlob++);
15239:           if( c>=prior_c && c<=c2 ) seen = 1;
15240:           prior_c = 0;
15241:         }else{
15242:           if( c==c2 ){
15243:             seen = 1;
15244:           }
15245:           prior_c = c2;
15246:         }
15247:         c2 = *(zGlob++);
15248:       }
15249:       if( c2==0 || (seen ^ invert)==0 ) return 0;
15250:     }else if( c=='#' ){
15251:       if( (z[0]=='-' || z[0]=='+') && IsDigit(z[1]) ) z++;
15252:       if( !IsDigit(z[0]) ) return 0;
15253:       z++;
15254:       while( IsDigit(z[0]) ){ z++; }
15255:     }else{
15256:       if( c!=(*(z++)) ) return 0;
15257:     }
15258:   }
15259:   while( IsSpace(*z) ){ z++; }
15260:   return *z==0;
15261: }
15262: 
15263: 
15264: /*
15265: ** Compare the string as a command-line option with either one or two
15266: ** initial "-" characters.
15267: */
15268: static int optionMatch(const char *zStr, const char *zOpt){
15269:   if( zStr[0]!='-' ) return 0;
15270:   zStr++;
15271:   if( zStr[0]=='-' ) zStr++;
15272:   return strcmp(zStr, zOpt)==0;
15273: }
15274: 
15275: /*
15276: ** Delete a file.
15277: */
15278: int shellDeleteFile(const char *zFilename){
15279:   int rc;
15280: #ifdef _WIN32
15281:   wchar_t *z = sqlite3_win32_utf8_to_unicode(zFilename);
15282:   rc = _wunlink(z);
15283:   sqlite3_free(z);
15284: #else
15285:   rc = unlink(zFilename);
15286: #endif
15287:   return rc;
15288: }
15289: 
15290: /*
15291: ** Try to delete the temporary file (if there is one) and free the
15292: ** memory used to hold the name of the temp file.
15293: */
15294: static void clearTempFile(ShellState *p){
15295:   if( p->zTempFile==0 ) return;
15296:   if( p->doXdgOpen ) return;
15297:   if( shellDeleteFile(p->zTempFile) ) return;
15298:   sqlite3_free(p->zTempFile);
15299:   p->zTempFile = 0;
15300: }
15301: 
15302: /*
15303: ** Create a new temp file name with the given suffix.
15304: */
15305: static void newTempFile(ShellState *p, const char *zSuffix){
15306:   clearTempFile(p);
15307:   sqlite3_free(p->zTempFile);
15308:   p->zTempFile = 0;
15309:   if( p->db ){
15310:     sqlite3_file_control(p->db, 0, SQLITE_FCNTL_TEMPFILENAME, &p->zTempFile);
15311:   }
15312:   if( p->zTempFile==0 ){
15313:     /* If p->db is an in-memory database then the TEMPFILENAME file-control
15314:     ** will not work and we will need to fallback to guessing */
15315:     char *zTemp;
15316:     sqlite3_uint64 r;
15317:     sqlite3_randomness(sizeof(r), &r);
15318:     zTemp = getenv("TEMP");
15319:     if( zTemp==0 ) zTemp = getenv("TMP");
15320:     if( zTemp==0 ){
15321: #ifdef _WIN32
15322:       zTemp = "\\tmp";
15323: #else
15324:       zTemp = "/tmp";
15325: #endif
15326:     }
15327:     p->zTempFile = sqlite3_mprintf("%s/temp%llx.%s", zTemp, r, zSuffix);
15328:   }else{
15329:     p->zTempFile = sqlite3_mprintf("%z.%s", p->zTempFile, zSuffix);
15330:   }
15331:   if( p->zTempFile==0 ){
15332:     raw_printf(stderr, "out of memory\n");
15333:     exit(1);
15334:   }
15335: }
15336: 
15337: 
15338: /*
15339: ** The implementation of SQL scalar function fkey_collate_clause(), used
15340: ** by the ".lint fkey-indexes" command. This scalar function is always
15341: ** called with four arguments - the parent table name, the parent column name,
15342: ** the child table name and the child column name.
15343: **
15344: **   fkey_collate_clause('parent-tab', 'parent-col', 'child-tab', 'child-col')
15345: **
15346: ** If either of the named tables or columns do not exist, this function
15347: ** returns an empty string. An empty string is also returned if both tables
15348: ** and columns exist but have the same default collation sequence. Or,
15349: ** if both exist but the default collation sequences are different, this
15350: ** function returns the string " COLLATE <parent-collation>", where
15351: ** <parent-collation> is the default collation sequence of the parent column.
15352: */
15353: static void shellFkeyCollateClause(
15354:   sqlite3_context *pCtx,
15355:   int nVal,
15356:   sqlite3_value **apVal
15357: ){
15358:   sqlite3 *db = sqlite3_context_db_handle(pCtx);
15359:   const char *zParent;
15360:   const char *zParentCol;
15361:   const char *zParentSeq;
15362:   const char *zChild;
15363:   const char *zChildCol;
15364:   const char *zChildSeq = 0;  /* Initialize to avoid false-positive warning */
15365:   int rc;
15366: 
15367:   assert( nVal==4 );
15368:   zParent = (const char*)sqlite3_value_text(apVal[0]);
15369:   zParentCol = (const char*)sqlite3_value_text(apVal[1]);
15370:   zChild = (const char*)sqlite3_value_text(apVal[2]);
15371:   zChildCol = (const char*)sqlite3_value_text(apVal[3]);
15372: 
15373:   sqlite3_result_text(pCtx, "", -1, SQLITE_STATIC);
15374:   rc = sqlite3_table_column_metadata(
15375:       db, "main", zParent, zParentCol, 0, &zParentSeq, 0, 0, 0
15376:   );
15377:   if( rc==SQLITE_OK ){
15378:     rc = sqlite3_table_column_metadata(
15379:         db, "main", zChild, zChildCol, 0, &zChildSeq, 0, 0, 0
15380:     );
15381:   }
15382: 
15383:   if( rc==SQLITE_OK && sqlite3_stricmp(zParentSeq, zChildSeq) ){
15384:     char *z = sqlite3_mprintf(" COLLATE %s", zParentSeq);
15385:     sqlite3_result_text(pCtx, z, -1, SQLITE_TRANSIENT);
15386:     sqlite3_free(z);
15387:   }
15388: }
15389: 
15390: 
15391: /*
15392: ** The implementation of dot-command ".lint fkey-indexes".
15393: */
15394: static int lintFkeyIndexes(
15395:   ShellState *pState,             /* Current shell tool state */
15396:   char **azArg,                   /* Array of arguments passed to dot command */
15397:   int nArg                        /* Number of entries in azArg[] */
15398: ){
15399:   sqlite3 *db = pState->db;       /* Database handle to query "main" db of */
15400:   FILE *out = pState->out;        /* Stream to write non-error output to */
15401:   int bVerbose = 0;               /* If -verbose is present */
15402:   int bGroupByParent = 0;         /* If -groupbyparent is present */
15403:   int i;                          /* To iterate through azArg[] */
15404:   const char *zIndent = "";       /* How much to indent CREATE INDEX by */
15405:   int rc;                         /* Return code */
15406:   sqlite3_stmt *pSql = 0;         /* Compiled version of SQL statement below */
15407: 
15408:   /*
15409:   ** This SELECT statement returns one row for each foreign key constraint
15410:   ** in the schema of the main database. The column values are:
15411:   **
15412:   ** 0. The text of an SQL statement similar to:
15413:   **
15414:   **      "EXPLAIN QUERY PLAN SELECT 1 FROM child_table WHERE child_key=?"
15415:   **
15416:   **    This SELECT is similar to the one that the foreign keys implementation
15417:   **    needs to run internally on child tables. If there is an index that can
15418:   **    be used to optimize this query, then it can also be used by the FK
15419:   **    implementation to optimize DELETE or UPDATE statements on the parent
15420:   **    table.
15421:   **
15422:   ** 1. A GLOB pattern suitable for sqlite3_strglob(). If the plan output by
15423:   **    the EXPLAIN QUERY PLAN command matches this pattern, then the schema
15424:   **    contains an index that can be used to optimize the query.
15425:   **
15426:   ** 2. Human readable text that describes the child table and columns. e.g.
15427:   **
15428:   **       "child_table(child_key1, child_key2)"
15429:   **
15430:   ** 3. Human readable text that describes the parent table and columns. e.g.
15431:   **
15432:   **       "parent_table(parent_key1, parent_key2)"
15433:   **
15434:   ** 4. A full CREATE INDEX statement for an index that could be used to
15435:   **    optimize DELETE or UPDATE statements on the parent table. e.g.
15436:   **
15437:   **       "CREATE INDEX child_table_child_key ON child_table(child_key)"
15438:   **
15439:   ** 5. The name of the parent table.
15440:   **
15441:   ** These six values are used by the C logic below to generate the report.
15442:   */
15443:   const char *zSql =
15444:   "SELECT "
15445:     "     'EXPLAIN QUERY PLAN SELECT 1 FROM ' || quote(s.name) || ' WHERE '"
15446:     "  || group_concat(quote(s.name) || '.' || quote(f.[from]) || '=?' "
15447:     "  || fkey_collate_clause("
15448:     "       f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]),' AND ')"
15449:     ", "
15450:     "     'SEARCH TABLE ' || s.name || ' USING COVERING INDEX*('"
15451:     "  || group_concat('*=?', ' AND ') || ')'"
15452:     ", "
15453:     "     s.name  || '(' || group_concat(f.[from],  ', ') || ')'"
15454:     ", "
15455:     "     f.[table] || '(' || group_concat(COALESCE(f.[to], p.[name])) || ')'"
15456:     ", "
15457:     "     'CREATE INDEX ' || quote(s.name ||'_'|| group_concat(f.[from], '_'))"
15458:     "  || ' ON ' || quote(s.name) || '('"
15459:     "  || group_concat(quote(f.[from]) ||"
15460:     "        fkey_collate_clause("
15461:     "          f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]), ', ')"
15462:     "  || ');'"
15463:     ", "
15464:     "     f.[table] "
15465:     "FROM sqlite_schema AS s, pragma_foreign_key_list(s.name) AS f "
15466:     "LEFT JOIN pragma_table_info AS p ON (pk-1=seq AND p.arg=f.[table]) "
15467:     "GROUP BY s.name, f.id "
15468:     "ORDER BY (CASE WHEN ? THEN f.[table] ELSE s.name END)"
15469:   ;
15470:   const char *zGlobIPK = "SEARCH TABLE * USING INTEGER PRIMARY KEY (rowid=?)";
15471: 
15472:   for(i=2; i<nArg; i++){
15473:     int n = strlen30(azArg[i]);
15474:     if( n>1 && sqlite3_strnicmp("-verbose", azArg[i], n)==0 ){
15475:       bVerbose = 1;
15476:     }
15477:     else if( n>1 && sqlite3_strnicmp("-groupbyparent", azArg[i], n)==0 ){
15478:       bGroupByParent = 1;
15479:       zIndent = "    ";
15480:     }
15481:     else{
15482:       raw_printf(stderr, "Usage: %s %s ?-verbose? ?-groupbyparent?\n",
15483:           azArg[0], azArg[1]
15484:       );
15485:       return SQLITE_ERROR;
15486:     }
15487:   }
15488: 
15489:   /* Register the fkey_collate_clause() SQL function */
15490:   rc = sqlite3_create_function(db, "fkey_collate_clause", 4, SQLITE_UTF8,
15491:       0, shellFkeyCollateClause, 0, 0
15492:   );
15493: 
15494: 
15495:   if( rc==SQLITE_OK ){
15496:     rc = sqlite3_prepare_v2(db, zSql, -1, &pSql, 0);
15497:   }
15498:   if( rc==SQLITE_OK ){
15499:     sqlite3_bind_int(pSql, 1, bGroupByParent);
15500:   }
15501: 
15502:   if( rc==SQLITE_OK ){
15503:     int rc2;
15504:     char *zPrev = 0;
15505:     while( SQLITE_ROW==sqlite3_step(pSql) ){
15506:       int res = -1;
15507:       sqlite3_stmt *pExplain = 0;
15508:       const char *zEQP = (const char*)sqlite3_column_text(pSql, 0);
15509:       const char *zGlob = (const char*)sqlite3_column_text(pSql, 1);
15510:       const char *zFrom = (const char*)sqlite3_column_text(pSql, 2);
15511:       const char *zTarget = (const char*)sqlite3_column_text(pSql, 3);
15512:       const char *zCI = (const char*)sqlite3_column_text(pSql, 4);
15513:       const char *zParent = (const char*)sqlite3_column_text(pSql, 5);
15514: 
15515:       rc = sqlite3_prepare_v2(db, zEQP, -1, &pExplain, 0);
15516:       if( rc!=SQLITE_OK ) break;
15517:       if( SQLITE_ROW==sqlite3_step(pExplain) ){
15518:         const char *zPlan = (const char*)sqlite3_column_text(pExplain, 3);
15519:         res = (
15520:               0==sqlite3_strglob(zGlob, zPlan)
15521:            || 0==sqlite3_strglob(zGlobIPK, zPlan)
15522:         );
15523:       }
15524:       rc = sqlite3_finalize(pExplain);
15525:       if( rc!=SQLITE_OK ) break;
15526: 
15527:       if( res<0 ){
15528:         raw_printf(stderr, "Error: internal error");
15529:         break;
15530:       }else{
15531:         if( bGroupByParent
15532:         && (bVerbose || res==0)
15533:         && (zPrev==0 || sqlite3_stricmp(zParent, zPrev))
15534:         ){
15535:           raw_printf(out, "-- Parent table %s\n", zParent);
15536:           sqlite3_free(zPrev);
15537:           zPrev = sqlite3_mprintf("%s", zParent);
15538:         }
15539: 
15540:         if( res==0 ){
15541:           raw_printf(out, "%s%s --> %s\n", zIndent, zCI, zTarget);
15542:         }else if( bVerbose ){
15543:           raw_printf(out, "%s/* no extra indexes required for %s -> %s */\n",
15544:               zIndent, zFrom, zTarget
15545:           );
15546:         }
15547:       }
15548:     }
15549:     sqlite3_free(zPrev);
15550: 
15551:     if( rc!=SQLITE_OK ){
15552:       raw_printf(stderr, "%s\n", sqlite3_errmsg(db));
15553:     }
15554: 
15555:     rc2 = sqlite3_finalize(pSql);
15556:     if( rc==SQLITE_OK && rc2!=SQLITE_OK ){
15557:       rc = rc2;
15558:       raw_printf(stderr, "%s\n", sqlite3_errmsg(db));
15559:     }
15560:   }else{
15561:     raw_printf(stderr, "%s\n", sqlite3_errmsg(db));
15562:   }
15563: 
15564:   return rc;
15565: }
15566: 
15567: /*
15568: ** Implementation of ".lint" dot command.
15569: */
15570: static int lintDotCommand(
15571:   ShellState *pState,             /* Current shell tool state */
15572:   char **azArg,                   /* Array of arguments passed to dot command */
15573:   int nArg                        /* Number of entries in azArg[] */
15574: ){
15575:   int n;
15576:   n = (nArg>=2 ? strlen30(azArg[1]) : 0);
15577:   if( n<1 || sqlite3_strnicmp(azArg[1], "fkey-indexes", n) ) goto usage;
15578:   return lintFkeyIndexes(pState, azArg, nArg);
15579: 
15580:  usage:
15581:   raw_printf(stderr, "Usage %s sub-command ?switches...?\n", azArg[0]);
15582:   raw_printf(stderr, "Where sub-commands are:\n");
15583:   raw_printf(stderr, "    fkey-indexes\n");
15584:   return SQLITE_ERROR;
15585: }
15586: 
15587: #if !defined SQLITE_OMIT_VIRTUALTABLE
15588: static void shellPrepare(
15589:   sqlite3 *db,
15590:   int *pRc,
15591:   const char *zSql,
15592:   sqlite3_stmt **ppStmt
15593: ){
15594:   *ppStmt = 0;
15595:   if( *pRc==SQLITE_OK ){
15596:     int rc = sqlite3_prepare_v2(db, zSql, -1, ppStmt, 0);
15597:     if( rc!=SQLITE_OK ){
15598:       raw_printf(stderr, "sql error: %s (%d)\n",
15599:           sqlite3_errmsg(db), sqlite3_errcode(db)
15600:       );
15601:       *pRc = rc;
15602:     }
15603:   }
15604: }
15605: 
15606: /*
15607: ** Create a prepared statement using printf-style arguments for the SQL.
15608: **
15609: ** This routine is could be marked "static".  But it is not always used,
15610: ** depending on compile-time options.  By omitting the "static", we avoid
15611: ** nuisance compiler warnings about "defined but not used".
15612: */
15613: void shellPreparePrintf(
15614:   sqlite3 *db,
15615:   int *pRc,
15616:   sqlite3_stmt **ppStmt,
15617:   const char *zFmt,
15618:   ...
15619: ){
15620:   *ppStmt = 0;
15621:   if( *pRc==SQLITE_OK ){
15622:     va_list ap;
15623:     char *z;
15624:     va_start(ap, zFmt);
15625:     z = sqlite3_vmprintf(zFmt, ap);
15626:     va_end(ap);
15627:     if( z==0 ){
15628:       *pRc = SQLITE_NOMEM;
15629:     }else{
15630:       shellPrepare(db, pRc, z, ppStmt);
15631:       sqlite3_free(z);
15632:     }
15633:   }
15634: }
15635: 
15636: /* Finalize the prepared statement created using shellPreparePrintf().
15637: **
15638: ** This routine is could be marked "static".  But it is not always used,
15639: ** depending on compile-time options.  By omitting the "static", we avoid
15640: ** nuisance compiler warnings about "defined but not used".
15641: */
15642: void shellFinalize(
15643:   int *pRc,
15644:   sqlite3_stmt *pStmt
15645: ){
15646:   if( pStmt ){
15647:     sqlite3 *db = sqlite3_db_handle(pStmt);
15648:     int rc = sqlite3_finalize(pStmt);
15649:     if( *pRc==SQLITE_OK ){
15650:       if( rc!=SQLITE_OK ){
15651:         raw_printf(stderr, "SQL error: %s\n", sqlite3_errmsg(db));
15652:       }
15653:       *pRc = rc;
15654:     }
15655:   }
15656: }
15657: 
15658: /* Reset the prepared statement created using shellPreparePrintf().
15659: **
15660: ** This routine is could be marked "static".  But it is not always used,
15661: ** depending on compile-time options.  By omitting the "static", we avoid
15662: ** nuisance compiler warnings about "defined but not used".
15663: */
15664: void shellReset(
15665:   int *pRc,
15666:   sqlite3_stmt *pStmt
15667: ){
15668:   int rc = sqlite3_reset(pStmt);
15669:   if( *pRc==SQLITE_OK ){
15670:     if( rc!=SQLITE_OK ){
15671:       sqlite3 *db = sqlite3_db_handle(pStmt);
15672:       raw_printf(stderr, "SQL error: %s\n", sqlite3_errmsg(db));
15673:     }
15674:     *pRc = rc;
15675:   }
15676: }
15677: #endif /* !defined SQLITE_OMIT_VIRTUALTABLE */
15678: 
15679: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)
15680: /******************************************************************************
15681: ** The ".archive" or ".ar" command.
15682: */
15683: /*
15684: ** Structure representing a single ".ar" command.
15685: */
15686: typedef struct ArCommand ArCommand;
15687: struct ArCommand {
15688:   u8 eCmd;                        /* An AR_CMD_* value */
15689:   u8 bVerbose;                    /* True if --verbose */
15690:   u8 bZip;                        /* True if the archive is a ZIP */
15691:   u8 bDryRun;                     /* True if --dry-run */
15692:   u8 bAppend;                     /* True if --append */
15693:   u8 fromCmdLine;                 /* Run from -A instead of .archive */
15694:   int nArg;                       /* Number of command arguments */
15695:   char *zSrcTable;                /* "sqlar", "zipfile($file)" or "zip" */
15696:   const char *zFile;              /* --file argument, or NULL */
15697:   const char *zDir;               /* --directory argument, or NULL */
15698:   char **azArg;                   /* Array of command arguments */
15699:   ShellState *p;                  /* Shell state */
15700:   sqlite3 *db;                    /* Database containing the archive */
15701: };
15702: 
15703: /*
15704: ** Print a usage message for the .ar command to stderr and return SQLITE_ERROR.
15705: */
15706: static int arUsage(FILE *f){
15707:   showHelp(f,"archive");
15708:   return SQLITE_ERROR;
15709: }
15710: 
15711: /*
15712: ** Print an error message for the .ar command to stderr and return
15713: ** SQLITE_ERROR.
15714: */
15715: static int arErrorMsg(ArCommand *pAr, const char *zFmt, ...){
15716:   va_list ap;
15717:   char *z;
15718:   va_start(ap, zFmt);
15719:   z = sqlite3_vmprintf(zFmt, ap);
15720:   va_end(ap);
15721:   utf8_printf(stderr, "Error: %s\n", z);
15722:   if( pAr->fromCmdLine ){
15723:     utf8_printf(stderr, "Use \"-A\" for more help\n");
15724:   }else{
15725:     utf8_printf(stderr, "Use \".archive --help\" for more help\n");
15726:   }
15727:   sqlite3_free(z);
15728:   return SQLITE_ERROR;
15729: }
15730: 
15731: /*
15732: ** Values for ArCommand.eCmd.
15733: */
15734: #define AR_CMD_CREATE       1
15735: #define AR_CMD_UPDATE       2
15736: #define AR_CMD_INSERT       3
15737: #define AR_CMD_EXTRACT      4
15738: #define AR_CMD_LIST         5
15739: #define AR_CMD_HELP         6
15740: 
15741: /*
15742: ** Other (non-command) switches.
15743: */
15744: #define AR_SWITCH_VERBOSE     7
15745: #define AR_SWITCH_FILE        8
15746: #define AR_SWITCH_DIRECTORY   9
15747: #define AR_SWITCH_APPEND     10
15748: #define AR_SWITCH_DRYRUN     11
15749: 
15750: static int arProcessSwitch(ArCommand *pAr, int eSwitch, const char *zArg){
15751:   switch( eSwitch ){
15752:     case AR_CMD_CREATE:
15753:     case AR_CMD_EXTRACT:
15754:     case AR_CMD_LIST:
15755:     case AR_CMD_UPDATE:
15756:     case AR_CMD_INSERT:
15757:     case AR_CMD_HELP:
15758:       if( pAr->eCmd ){
15759:         return arErrorMsg(pAr, "multiple command options");
15760:       }
15761:       pAr->eCmd = eSwitch;
15762:       break;
15763: 
15764:     case AR_SWITCH_DRYRUN:
15765:       pAr->bDryRun = 1;
15766:       break;
15767:     case AR_SWITCH_VERBOSE:
15768:       pAr->bVerbose = 1;
15769:       break;
15770:     case AR_SWITCH_APPEND:
15771:       pAr->bAppend = 1;
15772:       /* Fall thru into --file */
15773:     case AR_SWITCH_FILE:
15774:       pAr->zFile = zArg;
15775:       break;
15776:     case AR_SWITCH_DIRECTORY:
15777:       pAr->zDir = zArg;
15778:       break;
15779:   }
15780: 
15781:   return SQLITE_OK;
15782: }
15783: 
15784: /*
15785: ** Parse the command line for an ".ar" command. The results are written into
15786: ** structure (*pAr). SQLITE_OK is returned if the command line is parsed
15787: ** successfully, otherwise an error message is written to stderr and
15788: ** SQLITE_ERROR returned.
15789: */
15790: static int arParseCommand(
15791:   char **azArg,                   /* Array of arguments passed to dot command */
15792:   int nArg,                       /* Number of entries in azArg[] */
15793:   ArCommand *pAr                  /* Populate this object */
15794: ){
15795:   struct ArSwitch {
15796:     const char *zLong;
15797:     char cShort;
15798:     u8 eSwitch;
15799:     u8 bArg;
15800:   } aSwitch[] = {
15801:     { "create",    'c', AR_CMD_CREATE,       0 },
15802:     { "extract",   'x', AR_CMD_EXTRACT,      0 },
15803:     { "insert",    'i', AR_CMD_INSERT,       0 },
15804:     { "list",      't', AR_CMD_LIST,         0 },
15805:     { "update",    'u', AR_CMD_UPDATE,       0 },
15806:     { "help",      'h', AR_CMD_HELP,         0 },
15807:     { "verbose",   'v', AR_SWITCH_VERBOSE,   0 },
15808:     { "file",      'f', AR_SWITCH_FILE,      1 },
15809:     { "append",    'a', AR_SWITCH_APPEND,    1 },
15810:     { "directory", 'C', AR_SWITCH_DIRECTORY, 1 },
15811:     { "dryrun",    'n', AR_SWITCH_DRYRUN,    0 },
15812:   };
15813:   int nSwitch = sizeof(aSwitch) / sizeof(struct ArSwitch);
15814:   struct ArSwitch *pEnd = &aSwitch[nSwitch];
15815: 
15816:   if( nArg<=1 ){
15817:     utf8_printf(stderr, "Wrong number of arguments.  Usage:\n");
15818:     return arUsage(stderr);
15819:   }else{
15820:     char *z = azArg[1];
15821:     if( z[0]!='-' ){
15822:       /* Traditional style [tar] invocation */
15823:       int i;
15824:       int iArg = 2;
15825:       for(i=0; z[i]; i++){
15826:         const char *zArg = 0;
15827:         struct ArSwitch *pOpt;
15828:         for(pOpt=&aSwitch[0]; pOpt<pEnd; pOpt++){
15829:           if( z[i]==pOpt->cShort ) break;
15830:         }
15831:         if( pOpt==pEnd ){
15832:           return arErrorMsg(pAr, "unrecognized option: %c", z[i]);
15833:         }
15834:         if( pOpt->bArg ){
15835:           if( iArg>=nArg ){
15836:             return arErrorMsg(pAr, "option requires an argument: %c",z[i]);
15837:           }
15838:           zArg = azArg[iArg++];
15839:         }
15840:         if( arProcessSwitch(pAr, pOpt->eSwitch, zArg) ) return SQLITE_ERROR;
15841:       }
15842:       pAr->nArg = nArg-iArg;
15843:       if( pAr->nArg>0 ){
15844:         pAr->azArg = &azArg[iArg];
15845:       }
15846:     }else{
15847:       /* Non-traditional invocation */
15848:       int iArg;
15849:       for(iArg=1; iArg<nArg; iArg++){
15850:         int n;
15851:         z = azArg[iArg];
15852:         if( z[0]!='-' ){
15853:           /* All remaining command line words are command arguments. */
15854:           pAr->azArg = &azArg[iArg];
15855:           pAr->nArg = nArg-iArg;
15856:           break;
15857:         }
15858:         n = strlen30(z);
15859: 
15860:         if( z[1]!='-' ){
15861:           int i;
15862:           /* One or more short options */
15863:           for(i=1; i<n; i++){
15864:             const char *zArg = 0;
15865:             struct ArSwitch *pOpt;
15866:             for(pOpt=&aSwitch[0]; pOpt<pEnd; pOpt++){
15867:               if( z[i]==pOpt->cShort ) break;
15868:             }
15869:             if( pOpt==pEnd ){
15870:               return arErrorMsg(pAr, "unrecognized option: %c", z[i]);
15871:             }
15872:             if( pOpt->bArg ){
15873:               if( i<(n-1) ){
15874:                 zArg = &z[i+1];
15875:                 i = n;
15876:               }else{
15877:                 if( iArg>=(nArg-1) ){
15878:                   return arErrorMsg(pAr, "option requires an argument: %c",
15879:                                     z[i]);
15880:                 }
15881:                 zArg = azArg[++iArg];
15882:               }
15883:             }
15884:             if( arProcessSwitch(pAr, pOpt->eSwitch, zArg) ) return SQLITE_ERROR;
15885:           }
15886:         }else if( z[2]=='\0' ){
15887:           /* A -- option, indicating that all remaining command line words
15888:           ** are command arguments.  */
15889:           pAr->azArg = &azArg[iArg+1];
15890:           pAr->nArg = nArg-iArg-1;
15891:           break;
15892:         }else{
15893:           /* A long option */
15894:           const char *zArg = 0;             /* Argument for option, if any */
15895:           struct ArSwitch *pMatch = 0;      /* Matching option */
15896:           struct ArSwitch *pOpt;            /* Iterator */
15897:           for(pOpt=&aSwitch[0]; pOpt<pEnd; pOpt++){
15898:             const char *zLong = pOpt->zLong;
15899:             if( (n-2)<=strlen30(zLong) && 0==memcmp(&z[2], zLong, n-2) ){
15900:               if( pMatch ){
15901:                 return arErrorMsg(pAr, "ambiguous option: %s",z);
15902:               }else{
15903:                 pMatch = pOpt;
15904:               }
15905:             }
15906:           }
15907: 
15908:           if( pMatch==0 ){
15909:             return arErrorMsg(pAr, "unrecognized option: %s", z);
15910:           }
15911:           if( pMatch->bArg ){
15912:             if( iArg>=(nArg-1) ){
15913:               return arErrorMsg(pAr, "option requires an argument: %s", z);
15914:             }
15915:             zArg = azArg[++iArg];
15916:           }
15917:           if( arProcessSwitch(pAr, pMatch->eSwitch, zArg) ) return SQLITE_ERROR;
15918:         }
15919:       }
15920:     }
15921:   }
15922: 
15923:   return SQLITE_OK;
15924: }
15925: 
15926: /*
15927: ** This function assumes that all arguments within the ArCommand.azArg[]
15928: ** array refer to archive members, as for the --extract or --list commands.
15929: ** It checks that each of them are present. If any specified file is not
15930: ** present in the archive, an error is printed to stderr and an error
15931: ** code returned. Otherwise, if all specified arguments are present in
15932: ** the archive, SQLITE_OK is returned.
15933: **
15934: ** This function strips any trailing '/' characters from each argument.
15935: ** This is consistent with the way the [tar] command seems to work on
15936: ** Linux.
15937: */
15938: static int arCheckEntries(ArCommand *pAr){
15939:   int rc = SQLITE_OK;
15940:   if( pAr->nArg ){
15941:     int i, j;
15942:     sqlite3_stmt *pTest = 0;
15943: 
15944:     shellPreparePrintf(pAr->db, &rc, &pTest,
15945:         "SELECT name FROM %s WHERE name=$name",
15946:         pAr->zSrcTable
15947:     );
15948:     j = sqlite3_bind_parameter_index(pTest, "$name");
15949:     for(i=0; i<pAr->nArg && rc==SQLITE_OK; i++){
15950:       char *z = pAr->azArg[i];
15951:       int n = strlen30(z);
15952:       int bOk = 0;
15953:       while( n>0 && z[n-1]=='/' ) n--;
15954:       z[n] = '\0';
15955:       sqlite3_bind_text(pTest, j, z, -1, SQLITE_STATIC);
15956:       if( SQLITE_ROW==sqlite3_step(pTest) ){
15957:         bOk = 1;
15958:       }
15959:       shellReset(&rc, pTest);
15960:       if( rc==SQLITE_OK && bOk==0 ){
15961:         utf8_printf(stderr, "not found in archive: %s\n", z);
15962:         rc = SQLITE_ERROR;
15963:       }
15964:     }
15965:     shellFinalize(&rc, pTest);
15966:   }
15967:   return rc;
15968: }
15969: 
15970: /*
15971: ** Format a WHERE clause that can be used against the "sqlar" table to
15972: ** identify all archive members that match the command arguments held
15973: ** in (*pAr). Leave this WHERE clause in (*pzWhere) before returning.
15974: ** The caller is responsible for eventually calling sqlite3_free() on
15975: ** any non-NULL (*pzWhere) value.
15976: */
15977: static void arWhereClause(
15978:   int *pRc,
15979:   ArCommand *pAr,
15980:   char **pzWhere                  /* OUT: New WHERE clause */
15981: ){
15982:   char *zWhere = 0;
15983:   if( *pRc==SQLITE_OK ){
15984:     if( pAr->nArg==0 ){
15985:       zWhere = sqlite3_mprintf("1");
15986:     }else{
15987:       int i;
15988:       const char *zSep = "";
15989:       for(i=0; i<pAr->nArg; i++){
15990:         const char *z = pAr->azArg[i];
15991:         zWhere = sqlite3_mprintf(
15992:           "%z%s name = '%q' OR substr(name,1,%d) = '%q/'",
15993:           zWhere, zSep, z, strlen30(z)+1, z
15994:         );
15995:         if( zWhere==0 ){
15996:           *pRc = SQLITE_NOMEM;
15997:           break;
15998:         }
15999:         zSep = " OR ";
16000:       }
16001:     }
16002:   }
16003:   *pzWhere = zWhere;
16004: }
16005: 
16006: /*
16007: ** Implementation of .ar "lisT" command.
16008: */
16009: static int arListCommand(ArCommand *pAr){
16010:   const char *zSql = "SELECT %s FROM %s WHERE %s";
16011:   const char *azCols[] = {
16012:     "name",
16013:     "lsmode(mode), sz, datetime(mtime, 'unixepoch'), name"
16014:   };
16015: 
16016:   char *zWhere = 0;
16017:   sqlite3_stmt *pSql = 0;
16018:   int rc;
16019: 
16020:   rc = arCheckEntries(pAr);
16021:   arWhereClause(&rc, pAr, &zWhere);
16022: 
16023:   shellPreparePrintf(pAr->db, &rc, &pSql, zSql, azCols[pAr->bVerbose],
16024:                      pAr->zSrcTable, zWhere);
16025:   if( pAr->bDryRun ){
16026:     utf8_printf(pAr->p->out, "%s\n", sqlite3_sql(pSql));
16027:   }else{
16028:     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSql) ){
16029:       if( pAr->bVerbose ){
16030:         utf8_printf(pAr->p->out, "%s % 10d  %s  %s\n",
16031:             sqlite3_column_text(pSql, 0),
16032:             sqlite3_column_int(pSql, 1),
16033:             sqlite3_column_text(pSql, 2),
16034:             sqlite3_column_text(pSql, 3)
16035:         );
16036:       }else{
16037:         utf8_printf(pAr->p->out, "%s\n", sqlite3_column_text(pSql, 0));
16038:       }
16039:     }
16040:   }
16041:   shellFinalize(&rc, pSql);
16042:   sqlite3_free(zWhere);
16043:   return rc;
16044: }
16045: 
16046: 
16047: /*
16048: ** Implementation of .ar "eXtract" command.
16049: */
16050: static int arExtractCommand(ArCommand *pAr){
16051:   const char *zSql1 =
16052:     "SELECT "
16053:     " ($dir || name),"
16054:     " writefile(($dir || name), %s, mode, mtime) "
16055:     "FROM %s WHERE (%s) AND (data IS NULL OR $dirOnly = 0)"
16056:     " AND name NOT GLOB '*..[/\\]*'";
16057: 
16058:   const char *azExtraArg[] = {
16059:     "sqlar_uncompress(data, sz)",
16060:     "data"
16061:   };
16062: 
16063:   sqlite3_stmt *pSql = 0;
16064:   int rc = SQLITE_OK;
16065:   char *zDir = 0;
16066:   char *zWhere = 0;
16067:   int i, j;
16068: 
16069:   /* If arguments are specified, check that they actually exist within
16070:   ** the archive before proceeding. And formulate a WHERE clause to
16071:   ** match them.  */
16072:   rc = arCheckEntries(pAr);
16073:   arWhereClause(&rc, pAr, &zWhere);
16074: 
16075:   if( rc==SQLITE_OK ){
16076:     if( pAr->zDir ){
16077:       zDir = sqlite3_mprintf("%s/", pAr->zDir);
16078:     }else{
16079:       zDir = sqlite3_mprintf("");
16080:     }
16081:     if( zDir==0 ) rc = SQLITE_NOMEM;
16082:   }
16083: 
16084:   shellPreparePrintf(pAr->db, &rc, &pSql, zSql1,
16085:       azExtraArg[pAr->bZip], pAr->zSrcTable, zWhere
16086:   );
16087: 
16088:   if( rc==SQLITE_OK ){
16089:     j = sqlite3_bind_parameter_index(pSql, "$dir");
16090:     sqlite3_bind_text(pSql, j, zDir, -1, SQLITE_STATIC);
16091: 
16092:     /* Run the SELECT statement twice. The first time, writefile() is called
16093:     ** for all archive members that should be extracted. The second time,
16094:     ** only for the directories. This is because the timestamps for
16095:     ** extracted directories must be reset after they are populated (as
16096:     ** populating them changes the timestamp).  */
16097:     for(i=0; i<2; i++){
16098:       j = sqlite3_bind_parameter_index(pSql, "$dirOnly");
16099:       sqlite3_bind_int(pSql, j, i);
16100:       if( pAr->bDryRun ){
16101:         utf8_printf(pAr->p->out, "%s\n", sqlite3_sql(pSql));
16102:       }else{
16103:         while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSql) ){
16104:           if( i==0 && pAr->bVerbose ){
16105:             utf8_printf(pAr->p->out, "%s\n", sqlite3_column_text(pSql, 0));
16106:           }
16107:         }
16108:       }
16109:       shellReset(&rc, pSql);
16110:     }
16111:     shellFinalize(&rc, pSql);
16112:   }
16113: 
16114:   sqlite3_free(zDir);
16115:   sqlite3_free(zWhere);
16116:   return rc;
16117: }
16118: 
16119: /*
16120: ** Run the SQL statement in zSql.  Or if doing a --dryrun, merely print it out.
16121: */
16122: static int arExecSql(ArCommand *pAr, const char *zSql){
16123:   int rc;
16124:   if( pAr->bDryRun ){
16125:     utf8_printf(pAr->p->out, "%s\n", zSql);
16126:     rc = SQLITE_OK;
16127:   }else{
16128:     char *zErr = 0;
16129:     rc = sqlite3_exec(pAr->db, zSql, 0, 0, &zErr);
16130:     if( zErr ){
16131:       utf8_printf(stdout, "ERROR: %s\n", zErr);
16132:       sqlite3_free(zErr);
16133:     }
16134:   }
16135:   return rc;
16136: }
16137: 
16138: 
16139: /*
16140: ** Implementation of .ar "create", "insert", and "update" commands.
16141: **
16142: **     create    ->     Create a new SQL archive
16143: **     insert    ->     Insert or reinsert all files listed
16144: **     update    ->     Insert files that have changed or that were not
16145: **                      previously in the archive
16146: **
16147: ** Create the "sqlar" table in the database if it does not already exist.
16148: ** Then add each file in the azFile[] array to the archive. Directories
16149: ** are added recursively. If argument bVerbose is non-zero, a message is
16150: ** printed on stdout for each file archived.
16151: **
16152: ** The create command is the same as update, except that it drops
16153: ** any existing "sqlar" table before beginning.  The "insert" command
16154: ** always overwrites every file named on the command-line, where as
16155: ** "update" only overwrites if the size or mtime or mode has changed.
16156: */
16157: static int arCreateOrUpdateCommand(
16158:   ArCommand *pAr,                 /* Command arguments and options */
16159:   int bUpdate,                    /* true for a --create. */
16160:   int bOnlyIfChanged              /* Only update if file has changed */
16161: ){
16162:   const char *zCreate =
16163:       "CREATE TABLE IF NOT EXISTS sqlar(\n"
16164:       "  name TEXT PRIMARY KEY,  -- name of the file\n"
16165:       "  mode INT,               -- access permissions\n"
16166:       "  mtime INT,              -- last modification time\n"
16167:       "  sz INT,                 -- original file size\n"
16168:       "  data BLOB               -- compressed content\n"
16169:       ")";
16170:   const char *zDrop = "DROP TABLE IF EXISTS sqlar";
16171:   const char *zInsertFmt[2] = {
16172:      "REPLACE INTO %s(name,mode,mtime,sz,data)\n"
16173:      "  SELECT\n"
16174:      "    %s,\n"
16175:      "    mode,\n"
16176:      "    mtime,\n"
16177:      "    CASE substr(lsmode(mode),1,1)\n"
16178:      "      WHEN '-' THEN length(data)\n"
16179:      "      WHEN 'd' THEN 0\n"
16180:      "      ELSE -1 END,\n"
16181:      "    sqlar_compress(data)\n"
16182:      "  FROM fsdir(%Q,%Q) AS disk\n"
16183:      "  WHERE lsmode(mode) NOT LIKE '?%%'%s;"
16184:      ,
16185:      "REPLACE INTO %s(name,mode,mtime,data)\n"
16186:      "  SELECT\n"
16187:      "    %s,\n"
16188:      "    mode,\n"
16189:      "    mtime,\n"
16190:      "    data\n"
16191:      "  FROM fsdir(%Q,%Q) AS disk\n"
16192:      "  WHERE lsmode(mode) NOT LIKE '?%%'%s;"
16193:   };
16194:   int i;                          /* For iterating through azFile[] */
16195:   int rc;                         /* Return code */
16196:   const char *zTab = 0;           /* SQL table into which to insert */
16197:   char *zSql;
16198:   char zTemp[50];
16199:   char *zExists = 0;
16200: 
16201:   arExecSql(pAr, "PRAGMA page_size=512");
16202:   rc = arExecSql(pAr, "SAVEPOINT ar;");
16203:   if( rc!=SQLITE_OK ) return rc;
16204:   zTemp[0] = 0;
16205:   if( pAr->bZip ){
16206:     /* Initialize the zipfile virtual table, if necessary */
16207:     if( pAr->zFile ){
16208:       sqlite3_uint64 r;
16209:       sqlite3_randomness(sizeof(r),&r);
16210:       sqlite3_snprintf(sizeof(zTemp),zTemp,"zip%016llx",r);
16211:       zTab = zTemp;
16212:       zSql = sqlite3_mprintf(
16213:          "CREATE VIRTUAL TABLE temp.%s USING zipfile(%Q)",
16214:          zTab, pAr->zFile
16215:       );
16216:       rc = arExecSql(pAr, zSql);
16217:       sqlite3_free(zSql);
16218:     }else{
16219:       zTab = "zip";
16220:     }
16221:   }else{
16222:     /* Initialize the table for an SQLAR */
16223:     zTab = "sqlar";
16224:     if( bUpdate==0 ){
16225:       rc = arExecSql(pAr, zDrop);
16226:       if( rc!=SQLITE_OK ) goto end_ar_transaction;
16227:     }
16228:     rc = arExecSql(pAr, zCreate);
16229:   }
16230:   if( bOnlyIfChanged ){
16231:     zExists = sqlite3_mprintf(
16232:       " AND NOT EXISTS("
16233:           "SELECT 1 FROM %s AS mem"
16234:           " WHERE mem.name=disk.name"
16235:           " AND mem.mtime=disk.mtime"
16236:           " AND mem.mode=disk.mode)", zTab);
16237:   }else{
16238:     zExists = sqlite3_mprintf("");
16239:   }
16240:   if( zExists==0 ) rc = SQLITE_NOMEM;
16241:   for(i=0; i<pAr->nArg && rc==SQLITE_OK; i++){
16242:     char *zSql2 = sqlite3_mprintf(zInsertFmt[pAr->bZip], zTab,
16243:         pAr->bVerbose ? "shell_putsnl(name)" : "name",
16244:         pAr->azArg[i], pAr->zDir, zExists);
16245:     rc = arExecSql(pAr, zSql2);
16246:     sqlite3_free(zSql2);
16247:   }
16248: end_ar_transaction:
16249:   if( rc!=SQLITE_OK ){
16250:     sqlite3_exec(pAr->db, "ROLLBACK TO ar; RELEASE ar;", 0, 0, 0);
16251:   }else{
16252:     rc = arExecSql(pAr, "RELEASE ar;");
16253:     if( pAr->bZip && pAr->zFile ){
16254:       zSql = sqlite3_mprintf("DROP TABLE %s", zTemp);
16255:       arExecSql(pAr, zSql);
16256:       sqlite3_free(zSql);
16257:     }
16258:   }
16259:   sqlite3_free(zExists);
16260:   return rc;
16261: }
16262: 
16263: /*
16264: ** Implementation of ".ar" dot command.
16265: */
16266: static int arDotCommand(
16267:   ShellState *pState,          /* Current shell tool state */
16268:   int fromCmdLine,             /* True if -A command-line option, not .ar cmd */
16269:   char **azArg,                /* Array of arguments passed to dot command */
16270:   int nArg                     /* Number of entries in azArg[] */
16271: ){
16272:   ArCommand cmd;
16273:   int rc;
16274:   memset(&cmd, 0, sizeof(cmd));
16275:   cmd.fromCmdLine = fromCmdLine;
16276:   rc = arParseCommand(azArg, nArg, &cmd);
16277:   if( rc==SQLITE_OK ){
16278:     int eDbType = SHELL_OPEN_UNSPEC;
16279:     cmd.p = pState;
16280:     cmd.db = pState->db;
16281:     if( cmd.zFile ){
16282:       eDbType = deduceDatabaseType(cmd.zFile, 1);
16283:     }else{
16284:       eDbType = pState->openMode;
16285:     }
16286:     if( eDbType==SHELL_OPEN_ZIPFILE ){
16287:       if( cmd.eCmd==AR_CMD_EXTRACT || cmd.eCmd==AR_CMD_LIST ){
16288:         if( cmd.zFile==0 ){
16289:           cmd.zSrcTable = sqlite3_mprintf("zip");
16290:         }else{
16291:           cmd.zSrcTable = sqlite3_mprintf("zipfile(%Q)", cmd.zFile);
16292:         }
16293:       }
16294:       cmd.bZip = 1;
16295:     }else if( cmd.zFile ){
16296:       int flags;
16297:       if( cmd.bAppend ) eDbType = SHELL_OPEN_APPENDVFS;
16298:       if( cmd.eCmd==AR_CMD_CREATE || cmd.eCmd==AR_CMD_INSERT
16299:            || cmd.eCmd==AR_CMD_UPDATE ){
16300:         flags = SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE;
16301:       }else{
16302:         flags = SQLITE_OPEN_READONLY;
16303:       }
16304:       cmd.db = 0;
16305:       if( cmd.bDryRun ){
16306:         utf8_printf(pState->out, "-- open database '%s'%s\n", cmd.zFile,
16307:              eDbType==SHELL_OPEN_APPENDVFS ? " using 'apndvfs'" : "");
16308:       }
16309:       rc = sqlite3_open_v2(cmd.zFile, &cmd.db, flags,
16310:              eDbType==SHELL_OPEN_APPENDVFS ? "apndvfs" : 0);
16311:       if( rc!=SQLITE_OK ){
16312:         utf8_printf(stderr, "cannot open file: %s (%s)\n",
16313:             cmd.zFile, sqlite3_errmsg(cmd.db)
16314:         );
16315:         goto end_ar_command;
16316:       }
16317:       sqlite3_fileio_init(cmd.db, 0, 0);
16318:       sqlite3_sqlar_init(cmd.db, 0, 0);
16319:       sqlite3_create_function(cmd.db, "shell_putsnl", 1, SQLITE_UTF8, cmd.p,
16320:                               shellPutsFunc, 0, 0);
16321: 
16322:     }
16323:     if( cmd.zSrcTable==0 && cmd.bZip==0 && cmd.eCmd!=AR_CMD_HELP ){
16324:       if( cmd.eCmd!=AR_CMD_CREATE
16325:        && sqlite3_table_column_metadata(cmd.db,0,"sqlar","name",0,0,0,0,0)
16326:       ){
16327:         utf8_printf(stderr, "database does not contain an 'sqlar' table\n");
16328:         rc = SQLITE_ERROR;
16329:         goto end_ar_command;
16330:       }
16331:       cmd.zSrcTable = sqlite3_mprintf("sqlar");
16332:     }
16333: 
16334:     switch( cmd.eCmd ){
16335:       case AR_CMD_CREATE:
16336:         rc = arCreateOrUpdateCommand(&cmd, 0, 0);
16337:         break;
16338: 
16339:       case AR_CMD_EXTRACT:
16340:         rc = arExtractCommand(&cmd);
16341:         break;
16342: 
16343:       case AR_CMD_LIST:
16344:         rc = arListCommand(&cmd);
16345:         break;
16346: 
16347:       case AR_CMD_HELP:
16348:         arUsage(pState->out);
16349:         break;
16350: 
16351:       case AR_CMD_INSERT:
16352:         rc = arCreateOrUpdateCommand(&cmd, 1, 0);
16353:         break;
16354: 
16355:       default:
16356:         assert( cmd.eCmd==AR_CMD_UPDATE );
16357:         rc = arCreateOrUpdateCommand(&cmd, 1, 1);
16358:         break;
16359:     }
16360:   }
16361: end_ar_command:
16362:   if( cmd.db!=pState->db ){
16363:     close_db(cmd.db);
16364:   }
16365:   sqlite3_free(cmd.zSrcTable);
16366: 
16367:   return rc;
16368: }
16369: /* End of the ".archive" or ".ar" command logic
16370: *******************************************************************************/
16371: #endif /* !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB) */
16372: 
16373: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)
16374: /*
16375: ** If (*pRc) is not SQLITE_OK when this function is called, it is a no-op.
16376: ** Otherwise, the SQL statement or statements in zSql are executed using
16377: ** database connection db and the error code written to *pRc before
16378: ** this function returns.
16379: */
16380: static void shellExec(sqlite3 *db, int *pRc, const char *zSql){
16381:   int rc = *pRc;
16382:   if( rc==SQLITE_OK ){
16383:     char *zErr = 0;
16384:     rc = sqlite3_exec(db, zSql, 0, 0, &zErr);
16385:     if( rc!=SQLITE_OK ){
16386:       raw_printf(stderr, "SQL error: %s\n", zErr);
16387:     }
16388:     *pRc = rc;
16389:   }
16390: }
16391: 
16392: /*
16393: ** Like shellExec(), except that zFmt is a printf() style format string.
16394: */
16395: static void shellExecPrintf(sqlite3 *db, int *pRc, const char *zFmt, ...){
16396:   char *z = 0;
16397:   if( *pRc==SQLITE_OK ){
16398:     va_list ap;
16399:     va_start(ap, zFmt);
16400:     z = sqlite3_vmprintf(zFmt, ap);
16401:     va_end(ap);
16402:     if( z==0 ){
16403:       *pRc = SQLITE_NOMEM;
16404:     }else{
16405:       shellExec(db, pRc, z);
16406:     }
16407:     sqlite3_free(z);
16408:   }
16409: }
16410: 
16411: /*
16412: ** If *pRc is not SQLITE_OK when this function is called, it is a no-op.
16413: ** Otherwise, an attempt is made to allocate, zero and return a pointer
16414: ** to a buffer nByte bytes in size. If an OOM error occurs, *pRc is set
16415: ** to SQLITE_NOMEM and NULL returned.
16416: */
16417: static void *shellMalloc(int *pRc, sqlite3_int64 nByte){
16418:   void *pRet = 0;
16419:   if( *pRc==SQLITE_OK ){
16420:     pRet = sqlite3_malloc64(nByte);
16421:     if( pRet==0 ){
16422:       *pRc = SQLITE_NOMEM;
16423:     }else{
16424:       memset(pRet, 0, nByte);
16425:     }
16426:   }
16427:   return pRet;
16428: }
16429: 
16430: /*
16431: ** If *pRc is not SQLITE_OK when this function is called, it is a no-op.
16432: ** Otherwise, zFmt is treated as a printf() style string. The result of
16433: ** formatting it along with any trailing arguments is written into a
16434: ** buffer obtained from sqlite3_malloc(), and pointer to which is returned.
16435: ** It is the responsibility of the caller to eventually free this buffer
16436: ** using a call to sqlite3_free().
16437: **
16438: ** If an OOM error occurs, (*pRc) is set to SQLITE_NOMEM and a NULL
16439: ** pointer returned.
16440: */
16441: static char *shellMPrintf(int *pRc, const char *zFmt, ...){
16442:   char *z = 0;
16443:   if( *pRc==SQLITE_OK ){
16444:     va_list ap;
16445:     va_start(ap, zFmt);
16446:     z = sqlite3_vmprintf(zFmt, ap);
16447:     va_end(ap);
16448:     if( z==0 ){
16449:       *pRc = SQLITE_NOMEM;
16450:     }
16451:   }
16452:   return z;
16453: }
16454: 
16455: /*
16456: ** When running the ".recover" command, each output table, and the special
16457: ** orphaned row table if it is required, is represented by an instance
16458: ** of the following struct.
16459: */
16460: typedef struct RecoverTable RecoverTable;
16461: struct RecoverTable {
16462:   char *zQuoted;                  /* Quoted version of table name */
16463:   int nCol;                       /* Number of columns in table */
16464:   char **azlCol;                  /* Array of column lists */
16465:   int iPk;                        /* Index of IPK column */
16466: };
16467: 
16468: /*
16469: ** Free a RecoverTable object allocated by recoverFindTable() or
16470: ** recoverOrphanTable().
16471: */
16472: static void recoverFreeTable(RecoverTable *pTab){
16473:   if( pTab ){
16474:     sqlite3_free(pTab->zQuoted);
16475:     if( pTab->azlCol ){
16476:       int i;
16477:       for(i=0; i<=pTab->nCol; i++){
16478:         sqlite3_free(pTab->azlCol[i]);
16479:       }
16480:       sqlite3_free(pTab->azlCol);
16481:     }
16482:     sqlite3_free(pTab);
16483:   }
16484: }
16485: 
16486: /*
16487: ** This function is a no-op if (*pRc) is not SQLITE_OK when it is called.
16488: ** Otherwise, it allocates and returns a RecoverTable object based on the
16489: ** final four arguments passed to this function. It is the responsibility
16490: ** of the caller to eventually free the returned object using
16491: ** recoverFreeTable().
16492: */
16493: static RecoverTable *recoverNewTable(
16494:   int *pRc,                       /* IN/OUT: Error code */
16495:   const char *zName,              /* Name of table */
16496:   const char *zSql,               /* CREATE TABLE statement */
16497:   int bIntkey,
16498:   int nCol
16499: ){
16500:   sqlite3 *dbtmp = 0;             /* sqlite3 handle for testing CREATE TABLE */
16501:   int rc = *pRc;
16502:   RecoverTable *pTab = 0;
16503: 
16504:   pTab = (RecoverTable*)shellMalloc(&rc, sizeof(RecoverTable));
16505:   if( rc==SQLITE_OK ){
16506:     int nSqlCol = 0;
16507:     int bSqlIntkey = 0;
16508:     sqlite3_stmt *pStmt = 0;
16509: 
16510:     rc = sqlite3_open("", &dbtmp);
16511:     if( rc==SQLITE_OK ){
16512:       sqlite3_create_function(dbtmp, "shell_idquote", 1, SQLITE_UTF8, 0,
16513:                               shellIdQuote, 0, 0);
16514:     }
16515:     if( rc==SQLITE_OK ){
16516:       rc = sqlite3_exec(dbtmp, "PRAGMA writable_schema = on", 0, 0, 0);
16517:     }
16518:     if( rc==SQLITE_OK ){
16519:       rc = sqlite3_exec(dbtmp, zSql, 0, 0, 0);
16520:       if( rc==SQLITE_ERROR ){
16521:         rc = SQLITE_OK;
16522:         goto finished;
16523:       }
16524:     }
16525:     shellPreparePrintf(dbtmp, &rc, &pStmt,
16526:         "SELECT count(*) FROM pragma_table_info(%Q)", zName
16527:     );
16528:     if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){
16529:       nSqlCol = sqlite3_column_int(pStmt, 0);
16530:     }
16531:     shellFinalize(&rc, pStmt);
16532: 
16533:     if( rc!=SQLITE_OK || nSqlCol<nCol ){
16534:       goto finished;
16535:     }
16536: 
16537:     shellPreparePrintf(dbtmp, &rc, &pStmt,
16538:       "SELECT ("
16539:       "  SELECT substr(data,1,1)==X'0D' FROM sqlite_dbpage WHERE pgno=rootpage"
16540:       ") FROM sqlite_schema WHERE name = %Q", zName
16541:     );
16542:     if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){
16543:       bSqlIntkey = sqlite3_column_int(pStmt, 0);
16544:     }
16545:     shellFinalize(&rc, pStmt);
16546: 
16547:     if( bIntkey==bSqlIntkey ){
16548:       int i;
16549:       const char *zPk = "_rowid_";
16550:       sqlite3_stmt *pPkFinder = 0;
16551: 
16552:       /* If this is an intkey table and there is an INTEGER PRIMARY KEY,
16553:       ** set zPk to the name of the PK column, and pTab->iPk to the index
16554:       ** of the column, where columns are 0-numbered from left to right.
16555:       ** Or, if this is a WITHOUT ROWID table or if there is no IPK column,
16556:       ** leave zPk as "_rowid_" and pTab->iPk at -2.  */
16557:       pTab->iPk = -2;
16558:       if( bIntkey ){
16559:         shellPreparePrintf(dbtmp, &rc, &pPkFinder,
16560:           "SELECT cid, name FROM pragma_table_info(%Q) "
16561:           "  WHERE pk=1 AND type='integer' COLLATE nocase"
16562:           "  AND NOT EXISTS (SELECT cid FROM pragma_table_info(%Q) WHERE pk=2)"
16563:           , zName, zName
16564:         );
16565:         if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pPkFinder) ){
16566:           pTab->iPk = sqlite3_column_int(pPkFinder, 0);
16567:           zPk = (const char*)sqlite3_column_text(pPkFinder, 1);
16568:         }
16569:       }
16570: 
16571:       pTab->zQuoted = shellMPrintf(&rc, "\"%w\"", zName);
16572:       pTab->azlCol = (char**)shellMalloc(&rc, sizeof(char*) * (nSqlCol+1));
16573:       pTab->nCol = nSqlCol;
16574: 
16575:       if( bIntkey ){
16576:         pTab->azlCol[0] = shellMPrintf(&rc, "\"%w\"", zPk);
16577:       }else{
16578:         pTab->azlCol[0] = shellMPrintf(&rc, "");
16579:       }
16580:       i = 1;
16581:       shellPreparePrintf(dbtmp, &rc, &pStmt,
16582:           "SELECT %Q || group_concat(shell_idquote(name), ', ') "
16583:           "  FILTER (WHERE cid!=%d) OVER (ORDER BY %s cid) "
16584:           "FROM pragma_table_info(%Q)",
16585:           bIntkey ? ", " : "", pTab->iPk,
16586:           bIntkey ? "" : "(CASE WHEN pk=0 THEN 1000000 ELSE pk END), ",
16587:           zName
16588:       );
16589:       while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){
16590:         const char *zText = (const char*)sqlite3_column_text(pStmt, 0);
16591:         pTab->azlCol[i] = shellMPrintf(&rc, "%s%s", pTab->azlCol[0], zText);
16592:         i++;
16593:       }
16594:       shellFinalize(&rc, pStmt);
16595: 
16596:       shellFinalize(&rc, pPkFinder);
16597:     }
16598:   }
16599: 
16600:  finished:
16601:   sqlite3_close(dbtmp);
16602:   *pRc = rc;
16603:   if( rc!=SQLITE_OK || (pTab && pTab->zQuoted==0) ){
16604:     recoverFreeTable(pTab);
16605:     pTab = 0;
16606:   }
16607:   return pTab;
16608: }
16609: 
16610: /*
16611: ** This function is called to search the schema recovered from the
16612: ** sqlite_schema table of the (possibly) corrupt database as part
16613: ** of a ".recover" command. Specifically, for a table with root page
16614: ** iRoot and at least nCol columns. Additionally, if bIntkey is 0, the
16615: ** table must be a WITHOUT ROWID table, or if non-zero, not one of
16616: ** those.
16617: **
16618: ** If a table is found, a (RecoverTable*) object is returned. Or, if
16619: ** no such table is found, but bIntkey is false and iRoot is the
16620: ** root page of an index in the recovered schema, then (*pbNoop) is
16621: ** set to true and NULL returned. Or, if there is no such table or
16622: ** index, NULL is returned and (*pbNoop) set to 0, indicating that
16623: ** the caller should write data to the orphans table.
16624: */
16625: static RecoverTable *recoverFindTable(
16626:   ShellState *pState,             /* Shell state object */
16627:   int *pRc,                       /* IN/OUT: Error code */
16628:   int iRoot,                      /* Root page of table */
16629:   int bIntkey,                    /* True for an intkey table */
16630:   int nCol,                       /* Number of columns in table */
16631:   int *pbNoop                     /* OUT: True if iRoot is root of index */
16632: ){
16633:   sqlite3_stmt *pStmt = 0;
16634:   RecoverTable *pRet = 0;
16635:   int bNoop = 0;
16636:   const char *zSql = 0;
16637:   const char *zName = 0;
16638: 
16639:   /* Search the recovered schema for an object with root page iRoot. */
16640:   shellPreparePrintf(pState->db, pRc, &pStmt,
16641:       "SELECT type, name, sql FROM recovery.schema WHERE rootpage=%d", iRoot
16642:   );
16643:   while( *pRc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){
16644:     const char *zType = (const char*)sqlite3_column_text(pStmt, 0);
16645:     if( bIntkey==0 && sqlite3_stricmp(zType, "index")==0 ){
16646:       bNoop = 1;
16647:       break;
16648:     }
16649:     if( sqlite3_stricmp(zType, "table")==0 ){
16650:       zName = (const char*)sqlite3_column_text(pStmt, 1);
16651:       zSql = (const char*)sqlite3_column_text(pStmt, 2);
16652:       pRet = recoverNewTable(pRc, zName, zSql, bIntkey, nCol);
16653:       break;
16654:     }
16655:   }
16656: 
16657:   shellFinalize(pRc, pStmt);
16658:   *pbNoop = bNoop;
16659:   return pRet;
16660: }
16661: 
16662: /*
16663: ** Return a RecoverTable object representing the orphans table.
16664: */
16665: static RecoverTable *recoverOrphanTable(
16666:   ShellState *pState,             /* Shell state object */
16667:   int *pRc,                       /* IN/OUT: Error code */
16668:   const char *zLostAndFound,      /* Base name for orphans table */
16669:   int nCol                        /* Number of user data columns */
16670: ){
16671:   RecoverTable *pTab = 0;
16672:   if( nCol>=0 && *pRc==SQLITE_OK ){
16673:     int i;
16674: 
16675:     /* This block determines the name of the orphan table. The prefered
16676:     ** name is zLostAndFound. But if that clashes with another name
16677:     ** in the recovered schema, try zLostAndFound_0, zLostAndFound_1
16678:     ** and so on until a non-clashing name is found.  */
16679:     int iTab = 0;
16680:     char *zTab = shellMPrintf(pRc, "%s", zLostAndFound);
16681:     sqlite3_stmt *pTest = 0;
16682:     shellPrepare(pState->db, pRc,
16683:         "SELECT 1 FROM recovery.schema WHERE name=?", &pTest
16684:     );
16685:     if( pTest ) sqlite3_bind_text(pTest, 1, zTab, -1, SQLITE_TRANSIENT);
16686:     while( *pRc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pTest) ){
16687:       shellReset(pRc, pTest);
16688:       sqlite3_free(zTab);
16689:       zTab = shellMPrintf(pRc, "%s_%d", zLostAndFound, iTab++);
16690:       sqlite3_bind_text(pTest, 1, zTab, -1, SQLITE_TRANSIENT);
16691:     }
16692:     shellFinalize(pRc, pTest);
16693: 
16694:     pTab = (RecoverTable*)shellMalloc(pRc, sizeof(RecoverTable));
16695:     if( pTab ){
16696:       pTab->zQuoted = shellMPrintf(pRc, "\"%w\"", zTab);
16697:       pTab->nCol = nCol;
16698:       pTab->iPk = -2;
16699:       if( nCol>0 ){
16700:         pTab->azlCol = (char**)shellMalloc(pRc, sizeof(char*) * (nCol+1));
16701:         if( pTab->azlCol ){
16702:           pTab->azlCol[nCol] = shellMPrintf(pRc, "");
16703:           for(i=nCol-1; i>=0; i--){
16704:             pTab->azlCol[i] = shellMPrintf(pRc, "%s, NULL", pTab->azlCol[i+1]);
16705:           }
16706:         }
16707:       }
16708: 
16709:       if( *pRc!=SQLITE_OK ){
16710:         recoverFreeTable(pTab);
16711:         pTab = 0;
16712:       }else{
16713:         raw_printf(pState->out,
16714:             "CREATE TABLE %s(rootpgno INTEGER, "
16715:             "pgno INTEGER, nfield INTEGER, id INTEGER", pTab->zQuoted
16716:         );
16717:         for(i=0; i<nCol; i++){
16718:           raw_printf(pState->out, ", c%d", i);
16719:         }
16720:         raw_printf(pState->out, ");\n");
16721:       }
16722:     }
16723:     sqlite3_free(zTab);
16724:   }
16725:   return pTab;
16726: }
16727: 
16728: /*
16729: ** This function is called to recover data from the database. A script
16730: ** to construct a new database containing all recovered data is output
16731: ** on stream pState->out.
16732: */
16733: static int recoverDatabaseCmd(ShellState *pState, int nArg, char **azArg){
16734:   int rc = SQLITE_OK;
16735:   sqlite3_stmt *pLoop = 0;        /* Loop through all root pages */
16736:   sqlite3_stmt *pPages = 0;       /* Loop through all pages in a group */
16737:   sqlite3_stmt *pCells = 0;       /* Loop through all cells in a page */
16738:   const char *zRecoveryDb = "";   /* Name of "recovery" database */
16739:   const char *zLostAndFound = "lost_and_found";
16740:   int i;
16741:   int nOrphan = -1;
16742:   RecoverTable *pOrphan = 0;
16743: 
16744:   int bFreelist = 1;              /* 0 if --freelist-corrupt is specified */
16745:   int bRowids = 1;                /* 0 if --no-rowids */
16746:   for(i=1; i<nArg; i++){
16747:     char *z = azArg[i];
16748:     int n;
16749:     if( z[0]=='-' && z[1]=='-' ) z++;
16750:     n = strlen30(z);
16751:     if( n<=17 && memcmp("-freelist-corrupt", z, n)==0 ){
16752:       bFreelist = 0;
16753:     }else
16754:     if( n<=12 && memcmp("-recovery-db", z, n)==0 && i<(nArg-1) ){
16755:       i++;
16756:       zRecoveryDb = azArg[i];
16757:     }else
16758:     if( n<=15 && memcmp("-lost-and-found", z, n)==0 && i<(nArg-1) ){
16759:       i++;
16760:       zLostAndFound = azArg[i];
16761:     }else
16762:     if( n<=10 && memcmp("-no-rowids", z, n)==0 ){
16763:       bRowids = 0;
16764:     }
16765:     else{
16766:       utf8_printf(stderr, "unexpected option: %s\n", azArg[i]);
16767:       showHelp(pState->out, azArg[0]);
16768:       return 1;
16769:     }
16770:   }
16771: 
16772:   shellExecPrintf(pState->db, &rc,
16773:     /* Attach an in-memory database named 'recovery'. Create an indexed
16774:     ** cache of the sqlite_dbptr virtual table. */
16775:     "PRAGMA writable_schema = on;"
16776:     "ATTACH %Q AS recovery;"
16777:     "DROP TABLE IF EXISTS recovery.dbptr;"
16778:     "DROP TABLE IF EXISTS recovery.freelist;"
16779:     "DROP TABLE IF EXISTS recovery.map;"
16780:     "DROP TABLE IF EXISTS recovery.schema;"
16781:     "CREATE TABLE recovery.freelist(pgno INTEGER PRIMARY KEY);", zRecoveryDb
16782:   );
16783: 
16784:   if( bFreelist ){
16785:     shellExec(pState->db, &rc,
16786:       "WITH trunk(pgno) AS ("
16787:       "  SELECT shell_int32("
16788:       "      (SELECT data FROM sqlite_dbpage WHERE pgno=1), 8) AS x "
16789:       "      WHERE x>0"
16790:       "    UNION"
16791:       "  SELECT shell_int32("
16792:       "      (SELECT data FROM sqlite_dbpage WHERE pgno=trunk.pgno), 0) AS x "
16793:       "      FROM trunk WHERE x>0"
16794:       "),"
16795:       "freelist(data, n, freepgno) AS ("
16796:       "  SELECT data, min(16384, shell_int32(data, 1)-1), t.pgno "
16797:       "      FROM trunk t, sqlite_dbpage s WHERE s.pgno=t.pgno"
16798:       "    UNION ALL"
16799:       "  SELECT data, n-1, shell_int32(data, 2+n) "
16800:       "      FROM freelist WHERE n>=0"
16801:       ")"
16802:       "REPLACE INTO recovery.freelist SELECT freepgno FROM freelist;"
16803:     );
16804:   }
16805: 
16806:   /* If this is an auto-vacuum database, add all pointer-map pages to
16807:   ** the freelist table. Do this regardless of whether or not
16808:   ** --freelist-corrupt was specified.  */
16809:   shellExec(pState->db, &rc,
16810:     "WITH ptrmap(pgno) AS ("
16811:     "  SELECT 2 WHERE shell_int32("
16812:     "    (SELECT data FROM sqlite_dbpage WHERE pgno=1), 13"
16813:     "  )"
16814:     "    UNION ALL "
16815:     "  SELECT pgno+1+(SELECT page_size FROM pragma_page_size)/5 AS pp "
16816:     "  FROM ptrmap WHERE pp<=(SELECT page_count FROM pragma_page_count)"
16817:     ")"
16818:     "REPLACE INTO recovery.freelist SELECT pgno FROM ptrmap"
16819:   );
16820: 
16821:   shellExec(pState->db, &rc,
16822:     "CREATE TABLE recovery.dbptr("
16823:     "      pgno, child, PRIMARY KEY(child, pgno)"
16824:     ") WITHOUT ROWID;"
16825:     "INSERT OR IGNORE INTO recovery.dbptr(pgno, child) "
16826:     "    SELECT * FROM sqlite_dbptr"
16827:     "      WHERE pgno NOT IN freelist AND child NOT IN freelist;"
16828: 
16829:     /* Delete any pointer to page 1. This ensures that page 1 is considered
16830:     ** a root page, regardless of how corrupt the db is. */
16831:     "DELETE FROM recovery.dbptr WHERE child = 1;"
16832: 
16833:     /* Delete all pointers to any pages that have more than one pointer
16834:     ** to them. Such pages will be treated as root pages when recovering
16835:     ** data.  */
16836:     "DELETE FROM recovery.dbptr WHERE child IN ("
16837:     "  SELECT child FROM recovery.dbptr GROUP BY child HAVING count(*)>1"
16838:     ");"
16839: 
16840:     /* Create the "map" table that will (eventually) contain instructions
16841:     ** for dealing with each page in the db that contains one or more
16842:     ** records. */
16843:     "CREATE TABLE recovery.map("
16844:       "pgno INTEGER PRIMARY KEY, maxlen INT, intkey, root INT"
16845:     ");"
16846: 
16847:     /* Populate table [map]. If there are circular loops of pages in the
16848:     ** database, the following adds all pages in such a loop to the map
16849:     ** as individual root pages. This could be handled better.  */
16850:     "WITH pages(i, maxlen) AS ("
16851:     "  SELECT page_count, ("
16852:     "    SELECT max(field+1) FROM sqlite_dbdata WHERE pgno=page_count"
16853:     "  ) FROM pragma_page_count WHERE page_count>0"
16854:     "    UNION ALL"
16855:     "  SELECT i-1, ("
16856:     "    SELECT max(field+1) FROM sqlite_dbdata WHERE pgno=i-1"
16857:     "  ) FROM pages WHERE i>=2"
16858:     ")"
16859:     "INSERT INTO recovery.map(pgno, maxlen, intkey, root) "
16860:     "  SELECT i, maxlen, NULL, ("
16861:     "    WITH p(orig, pgno, parent) AS ("
16862:     "      SELECT 0, i, (SELECT pgno FROM recovery.dbptr WHERE child=i)"
16863:     "        UNION "
16864:     "      SELECT i, p.parent, "
16865:     "        (SELECT pgno FROM recovery.dbptr WHERE child=p.parent) FROM p"
16866:     "    )"
16867:     "    SELECT pgno FROM p WHERE (parent IS NULL OR pgno = orig)"
16868:     ") "
16869:     "FROM pages WHERE maxlen IS NOT NULL AND i NOT IN freelist;"
16870:     "UPDATE recovery.map AS o SET intkey = ("
16871:     "  SELECT substr(data, 1, 1)==X'0D' FROM sqlite_dbpage WHERE pgno=o.pgno"
16872:     ");"
16873: 
16874:     /* Extract data from page 1 and any linked pages into table
16875:     ** recovery.schema. With the same schema as an sqlite_schema table.  */
16876:     "CREATE TABLE recovery.schema(type, name, tbl_name, rootpage, sql);"
16877:     "INSERT INTO recovery.schema SELECT "
16878:     "  max(CASE WHEN field=0 THEN value ELSE NULL END),"
16879:     "  max(CASE WHEN field=1 THEN value ELSE NULL END),"
16880:     "  max(CASE WHEN field=2 THEN value ELSE NULL END),"
16881:     "  max(CASE WHEN field=3 THEN value ELSE NULL END),"
16882:     "  max(CASE WHEN field=4 THEN value ELSE NULL END)"
16883:     "FROM sqlite_dbdata WHERE pgno IN ("
16884:     "  SELECT pgno FROM recovery.map WHERE root=1"
16885:     ")"
16886:     "GROUP BY pgno, cell;"
16887:     "CREATE INDEX recovery.schema_rootpage ON schema(rootpage);"
16888:   );
16889: 
16890:   /* Open a transaction, then print out all non-virtual, non-"sqlite_%"
16891:   ** CREATE TABLE statements that extracted from the existing schema.  */
16892:   if( rc==SQLITE_OK ){
16893:     sqlite3_stmt *pStmt = 0;
16894:     /* ".recover" might output content in an order which causes immediate
16895:     ** foreign key constraints to be violated. So disable foreign-key
16896:     ** constraint enforcement to prevent problems when running the output
16897:     ** script. */
16898:     raw_printf(pState->out, "PRAGMA foreign_keys=OFF;\n");
16899:     raw_printf(pState->out, "BEGIN;\n");
16900:     raw_printf(pState->out, "PRAGMA writable_schema = on;\n");
16901:     shellPrepare(pState->db, &rc,
16902:         "SELECT sql FROM recovery.schema "
16903:         "WHERE type='table' AND sql LIKE 'create table%'", &pStmt
16904:     );
16905:     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){
16906:       const char *zCreateTable = (const char*)sqlite3_column_text(pStmt, 0);
16907:       raw_printf(pState->out, "CREATE TABLE IF NOT EXISTS %s;\n",
16908:           &zCreateTable[12]
16909:       );
16910:     }
16911:     shellFinalize(&rc, pStmt);
16912:   }
16913: 
16914:   /* Figure out if an orphan table will be required. And if so, how many
16915:   ** user columns it should contain */
16916:   shellPrepare(pState->db, &rc,
16917:       "SELECT coalesce(max(maxlen), -2) FROM recovery.map WHERE root>1"
16918:       , &pLoop
16919:   );
16920:   if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pLoop) ){
16921:     nOrphan = sqlite3_column_int(pLoop, 0);
16922:   }
16923:   shellFinalize(&rc, pLoop);
16924:   pLoop = 0;
16925: 
16926:   shellPrepare(pState->db, &rc,
16927:       "SELECT pgno FROM recovery.map WHERE root=?", &pPages
16928:   );
16929: 
16930:   shellPrepare(pState->db, &rc,
16931:       "SELECT max(field), group_concat(shell_escape_crnl(quote"
16932:       "(case when (? AND field<0) then NULL else value end)"
16933:       "), ', ')"
16934:       ", min(field) "
16935:       "FROM sqlite_dbdata WHERE pgno = ? AND field != ?"
16936:       "GROUP BY cell", &pCells
16937:   );
16938: 
16939:   /* Loop through each root page. */
16940:   shellPrepare(pState->db, &rc,
16941:       "SELECT root, intkey, max(maxlen) FROM recovery.map"
16942:       " WHERE root>1 GROUP BY root, intkey ORDER BY root=("
16943:       "  SELECT rootpage FROM recovery.schema WHERE name='sqlite_sequence'"
16944:       ")", &pLoop
16945:   );
16946:   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pLoop) ){
16947:     int iRoot = sqlite3_column_int(pLoop, 0);
16948:     int bIntkey = sqlite3_column_int(pLoop, 1);
16949:     int nCol = sqlite3_column_int(pLoop, 2);
16950:     int bNoop = 0;
16951:     RecoverTable *pTab;
16952: 
16953:     assert( bIntkey==0 || bIntkey==1 );
16954:     pTab = recoverFindTable(pState, &rc, iRoot, bIntkey, nCol, &bNoop);
16955:     if( bNoop || rc ) continue;
16956:     if( pTab==0 ){
16957:       if( pOrphan==0 ){
16958:         pOrphan = recoverOrphanTable(pState, &rc, zLostAndFound, nOrphan);
16959:       }
16960:       pTab = pOrphan;
16961:       if( pTab==0 ) break;
16962:     }
16963: 
16964:     if( 0==sqlite3_stricmp(pTab->zQuoted, "\"sqlite_sequence\"") ){
16965:       raw_printf(pState->out, "DELETE FROM sqlite_sequence;\n");
16966:     }
16967:     sqlite3_bind_int(pPages, 1, iRoot);
16968:     if( bRowids==0 && pTab->iPk<0 ){
16969:       sqlite3_bind_int(pCells, 1, 1);
16970:     }else{
16971:       sqlite3_bind_int(pCells, 1, 0);
16972:     }
16973:     sqlite3_bind_int(pCells, 3, pTab->iPk);
16974: 
16975:     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pPages) ){
16976:       int iPgno = sqlite3_column_int(pPages, 0);
16977:       sqlite3_bind_int(pCells, 2, iPgno);
16978:       while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pCells) ){
16979:         int nField = sqlite3_column_int(pCells, 0);
16980:         int iMin = sqlite3_column_int(pCells, 2);
16981:         const char *zVal = (const char*)sqlite3_column_text(pCells, 1);
16982: 
16983:         RecoverTable *pTab2 = pTab;
16984:         if( pTab!=pOrphan && (iMin<0)!=bIntkey ){
16985:           if( pOrphan==0 ){
16986:             pOrphan = recoverOrphanTable(pState, &rc, zLostAndFound, nOrphan);
16987:           }
16988:           pTab2 = pOrphan;
16989:           if( pTab2==0 ) break;
16990:         }
16991: 
16992:         nField = nField+1;
16993:         if( pTab2==pOrphan ){
16994:           raw_printf(pState->out,
16995:               "INSERT INTO %s VALUES(%d, %d, %d, %s%s%s);\n",
16996:               pTab2->zQuoted, iRoot, iPgno, nField,
16997:               iMin<0 ? "" : "NULL, ", zVal, pTab2->azlCol[nField]
16998:           );
16999:         }else{
17000:           raw_printf(pState->out, "INSERT INTO %s(%s) VALUES( %s );\n",
17001:               pTab2->zQuoted, pTab2->azlCol[nField], zVal
17002:           );
17003:         }
17004:       }
17005:       shellReset(&rc, pCells);
17006:     }
17007:     shellReset(&rc, pPages);
17008:     if( pTab!=pOrphan ) recoverFreeTable(pTab);
17009:   }
17010:   shellFinalize(&rc, pLoop);
17011:   shellFinalize(&rc, pPages);
17012:   shellFinalize(&rc, pCells);
17013:   recoverFreeTable(pOrphan);
17014: 
17015:   /* The rest of the schema */
17016:   if( rc==SQLITE_OK ){
17017:     sqlite3_stmt *pStmt = 0;
17018:     shellPrepare(pState->db, &rc,
17019:         "SELECT sql, name FROM recovery.schema "
17020:         "WHERE sql NOT LIKE 'create table%'", &pStmt
17021:     );
17022:     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){
17023:       const char *zSql = (const char*)sqlite3_column_text(pStmt, 0);
17024:       if( sqlite3_strnicmp(zSql, "create virt", 11)==0 ){
17025:         const char *zName = (const char*)sqlite3_column_text(pStmt, 1);
17026:         char *zPrint = shellMPrintf(&rc,
17027:           "INSERT INTO sqlite_schema VALUES('table', %Q, %Q, 0, %Q)",
17028:           zName, zName, zSql
17029:         );
17030:         raw_printf(pState->out, "%s;\n", zPrint);
17031:         sqlite3_free(zPrint);
17032:       }else{
17033:         raw_printf(pState->out, "%s;\n", zSql);
17034:       }
17035:     }
17036:     shellFinalize(&rc, pStmt);
17037:   }
17038: 
17039:   if( rc==SQLITE_OK ){
17040:     raw_printf(pState->out, "PRAGMA writable_schema = off;\n");
17041:     raw_printf(pState->out, "COMMIT;\n");
17042:   }
17043:   sqlite3_exec(pState->db, "DETACH recovery", 0, 0, 0);
17044:   return rc;
17045: }
17046: #endif /* !(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB) */
17047: 
17048: 
17049: /*
17050: ** If an input line begins with "." then invoke this routine to
17051: ** process that line.
17052: **
17053: ** Return 1 on error, 2 to exit, and 0 otherwise.
17054: */
17055: static int do_meta_command(char *zLine, ShellState *p){
17056:   int h = 1;
17057:   int nArg = 0;
17058:   int n, c;
17059:   int rc = 0;
17060:   char *azArg[52];
17061: 
17062: #ifndef SQLITE_OMIT_VIRTUALTABLE
17063:   if( p->expert.pExpert ){
17064:     expertFinish(p, 1, 0);
17065:   }
17066: #endif
17067: 
17068:   /* Parse the input line into tokens.
17069:   */
17070:   while( zLine[h] && nArg<ArraySize(azArg)-1 ){
17071:     while( IsSpace(zLine[h]) ){ h++; }
17072:     if( zLine[h]==0 ) break;
17073:     if( zLine[h]=='\'' || zLine[h]=='"' ){
17074:       int delim = zLine[h++];
17075:       azArg[nArg++] = &zLine[h];
17076:       while( zLine[h] && zLine[h]!=delim ){
17077:         if( zLine[h]=='\\' && delim=='"' && zLine[h+1]!=0 ) h++;
17078:         h++;
17079:       }
17080:       if( zLine[h]==delim ){
17081:         zLine[h++] = 0;
17082:       }
17083:       if( delim=='"' ) resolve_backslashes(azArg[nArg-1]);
17084:     }else{
17085:       azArg[nArg++] = &zLine[h];
17086:       while( zLine[h] && !IsSpace(zLine[h]) ){ h++; }
17087:       if( zLine[h] ) zLine[h++] = 0;
17088:       resolve_backslashes(azArg[nArg-1]);
17089:     }
17090:   }
17091:   azArg[nArg] = 0;
17092: 
17093:   /* Process the input line.
17094:   */
17095:   if( nArg==0 ) return 0; /* no tokens, no error */
17096:   n = strlen30(azArg[0]);
17097:   c = azArg[0][0];
17098:   clearTempFile(p);
17099: 
17100: #ifndef SQLITE_OMIT_AUTHORIZATION
17101:   if( c=='a' && strncmp(azArg[0], "auth", n)==0 ){
17102:     if( nArg!=2 ){
17103:       raw_printf(stderr, "Usage: .auth ON|OFF\n");
17104:       rc = 1;
17105:       goto meta_command_exit;
17106:     }
17107:     open_db(p, 0);
17108:     if( booleanValue(azArg[1]) ){
17109:       sqlite3_set_authorizer(p->db, shellAuth, p);
17110:     }else{
17111:       sqlite3_set_authorizer(p->db, 0, 0);
17112:     }
17113:   }else
17114: #endif
17115: 
17116: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)
17117:   if( c=='a' && strncmp(azArg[0], "archive", n)==0 ){
17118:     open_db(p, 0);
17119:     rc = arDotCommand(p, 0, azArg, nArg);
17120:   }else
17121: #endif
17122: 
17123:   if( (c=='b' && n>=3 && strncmp(azArg[0], "backup", n)==0)
17124:    || (c=='s' && n>=3 && strncmp(azArg[0], "save", n)==0)
17125:   ){
17126:     const char *zDestFile = 0;
17127:     const char *zDb = 0;
17128:     sqlite3 *pDest;
17129:     sqlite3_backup *pBackup;
17130:     int j;
17131:     int bAsync = 0;
17132:     const char *zVfs = 0;
17133:     for(j=1; j<nArg; j++){
17134:       const char *z = azArg[j];
17135:       if( z[0]=='-' ){
17136:         if( z[1]=='-' ) z++;
17137:         if( strcmp(z, "-append")==0 ){
17138:           zVfs = "apndvfs";
17139:         }else
17140:         if( strcmp(z, "-async")==0 ){
17141:           bAsync = 1;
17142:         }else
17143:         {
17144:           utf8_printf(stderr, "unknown option: %s\n", azArg[j]);
17145:           return 1;
17146:         }
17147:       }else if( zDestFile==0 ){
17148:         zDestFile = azArg[j];
17149:       }else if( zDb==0 ){
17150:         zDb = zDestFile;
17151:         zDestFile = azArg[j];
17152:       }else{
17153:         raw_printf(stderr, "Usage: .backup ?DB? ?OPTIONS? FILENAME\n");
17154:         return 1;
17155:       }
17156:     }
17157:     if( zDestFile==0 ){
17158:       raw_printf(stderr, "missing FILENAME argument on .backup\n");
17159:       return 1;
17160:     }
17161:     if( zDb==0 ) zDb = "main";
17162:     rc = sqlite3_open_v2(zDestFile, &pDest,
17163:                   SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE, zVfs);
17164:     if( rc!=SQLITE_OK ){
17165:       utf8_printf(stderr, "Error: cannot open \"%s\"\n", zDestFile);
17166:       close_db(pDest);
17167:       return 1;
17168:     }
17169:     if( bAsync ){
17170:       sqlite3_exec(pDest, "PRAGMA synchronous=OFF; PRAGMA journal_mode=OFF;",
17171:                    0, 0, 0);
17172:     }
17173:     open_db(p, 0);
17174:     pBackup = sqlite3_backup_init(pDest, "main", p->db, zDb);
17175:     if( pBackup==0 ){
17176:       utf8_printf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));
17177:       close_db(pDest);
17178:       return 1;
17179:     }
17180:     while(  (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK ){}
17181:     sqlite3_backup_finish(pBackup);
17182:     if( rc==SQLITE_DONE ){
17183:       rc = 0;
17184:     }else{
17185:       utf8_printf(stderr, "Error: %s\n", sqlite3_errmsg(pDest));
17186:       rc = 1;
17187:     }
17188:     close_db(pDest);
17189:   }else
17190: 
17191:   if( c=='b' && n>=3 && strncmp(azArg[0], "bail", n)==0 ){
17192:     if( nArg==2 ){
17193:       bail_on_error = booleanValue(azArg[1]);
17194:     }else{
17195:       raw_printf(stderr, "Usage: .bail on|off\n");
17196:       rc = 1;
17197:     }
17198:   }else
17199: 
17200:   if( c=='b' && n>=3 && strncmp(azArg[0], "binary", n)==0 ){
17201:     if( nArg==2 ){
17202:       if( booleanValue(azArg[1]) ){
17203:         setBinaryMode(p->out, 1);
17204:       }else{
17205:         setTextMode(p->out, 1);
17206:       }
17207:     }else{
17208:       raw_printf(stderr, "Usage: .binary on|off\n");
17209:       rc = 1;
17210:     }
17211:   }else
17212: 
17213:   if( c=='c' && strcmp(azArg[0],"cd")==0 ){
17214:     if( nArg==2 ){
17215: #if defined(_WIN32) || defined(WIN32)
17216:       wchar_t *z = sqlite3_win32_utf8_to_unicode(azArg[1]);
17217:       rc = !SetCurrentDirectoryW(z);
17218:       sqlite3_free(z);
17219: #else
17220:       rc = chdir(azArg[1]);
17221: #endif
17222:       if( rc ){
17223:         utf8_printf(stderr, "Cannot change to directory \"%s\"\n", azArg[1]);
17224:         rc = 1;
17225:       }
17226:     }else{
17227:       raw_printf(stderr, "Usage: .cd DIRECTORY\n");
17228:       rc = 1;
17229:     }
17230:   }else
17231: 
17232:   /* The undocumented ".breakpoint" command causes a call to the no-op
17233:   ** routine named test_breakpoint().
17234:   */
17235:   if( c=='b' && n>=3 && strncmp(azArg[0], "breakpoint", n)==0 ){
17236:     test_breakpoint();
17237:   }else
17238: 
17239:   if( c=='c' && n>=3 && strncmp(azArg[0], "changes", n)==0 ){
17240:     if( nArg==2 ){
17241:       setOrClearFlag(p, SHFLG_CountChanges, azArg[1]);
17242:     }else{
17243:       raw_printf(stderr, "Usage: .changes on|off\n");
17244:       rc = 1;
17245:     }
17246:   }else
17247: 
17248:   /* Cancel output redirection, if it is currently set (by .testcase)
17249:   ** Then read the content of the testcase-out.txt file and compare against
17250:   ** azArg[1].  If there are differences, report an error and exit.
17251:   */
17252:   if( c=='c' && n>=3 && strncmp(azArg[0], "check", n)==0 ){
17253:     char *zRes = 0;
17254:     output_reset(p);
17255:     if( nArg!=2 ){
17256:       raw_printf(stderr, "Usage: .check GLOB-PATTERN\n");
17257:       rc = 2;
17258:     }else if( (zRes = readFile("testcase-out.txt", 0))==0 ){
17259:       raw_printf(stderr, "Error: cannot read 'testcase-out.txt'\n");
17260:       rc = 2;
17261:     }else if( testcase_glob(azArg[1],zRes)==0 ){
17262:       utf8_printf(stderr,
17263:                  "testcase-%s FAILED\n Expected: [%s]\n      Got: [%s]\n",
17264:                  p->zTestcase, azArg[1], zRes);
17265:       rc = 1;
17266:     }else{
17267:       utf8_printf(stdout, "testcase-%s ok\n", p->zTestcase);
17268:       p->nCheck++;
17269:     }
17270:     sqlite3_free(zRes);
17271:   }else
17272: 
17273:   if( c=='c' && strncmp(azArg[0], "clone", n)==0 ){
17274:     if( nArg==2 ){
17275:       tryToClone(p, azArg[1]);
17276:     }else{
17277:       raw_printf(stderr, "Usage: .clone FILENAME\n");
17278:       rc = 1;
17279:     }
17280:   }else
17281: 
17282:   if( c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0 ){
17283:     ShellState data;
17284:     char *zErrMsg = 0;
17285:     open_db(p, 0);
17286:     memcpy(&data, p, sizeof(data));
17287:     data.showHeader = 0;
17288:     data.cMode = data.mode = MODE_List;
17289:     sqlite3_snprintf(sizeof(data.colSeparator),data.colSeparator,": ");
17290:     data.cnt = 0;
17291:     sqlite3_exec(p->db, "SELECT name, file FROM pragma_database_list",
17292:                  callback, &data, &zErrMsg);
17293:     if( zErrMsg ){
17294:       utf8_printf(stderr,"Error: %s\n", zErrMsg);
17295:       sqlite3_free(zErrMsg);
17296:       rc = 1;
17297:     }
17298:   }else
17299: 
17300:   if( c=='d' && n>=3 && strncmp(azArg[0], "dbconfig", n)==0 ){
17301:     static const struct DbConfigChoices {
17302:       const char *zName;
17303:       int op;
17304:     } aDbConfig[] = {
17305:         { "defensive",          SQLITE_DBCONFIG_DEFENSIVE             },
17306:         { "dqs_ddl",            SQLITE_DBCONFIG_DQS_DDL               },
17307:         { "dqs_dml",            SQLITE_DBCONFIG_DQS_DML               },
17308:         { "enable_fkey",        SQLITE_DBCONFIG_ENABLE_FKEY           },
17309:         { "enable_qpsg",        SQLITE_DBCONFIG_ENABLE_QPSG           },
17310:         { "enable_trigger",     SQLITE_DBCONFIG_ENABLE_TRIGGER        },
17311:         { "enable_view",        SQLITE_DBCONFIG_ENABLE_VIEW           },
17312:         { "fts3_tokenizer",     SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER },
17313:         { "legacy_alter_table", SQLITE_DBCONFIG_LEGACY_ALTER_TABLE    },
17314:         { "legacy_file_format", SQLITE_DBCONFIG_LEGACY_FILE_FORMAT    },
17315:         { "load_extension",     SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION },
17316:         { "no_ckpt_on_close",   SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE      },
17317:         { "reset_database",     SQLITE_DBCONFIG_RESET_DATABASE        },
17318:         { "trigger_eqp",        SQLITE_DBCONFIG_TRIGGER_EQP           },
17319:         { "trusted_schema",     SQLITE_DBCONFIG_TRUSTED_SCHEMA        },
17320:         { "writable_schema",    SQLITE_DBCONFIG_WRITABLE_SCHEMA       },
17321:     };
17322:     int ii, v;
17323:     open_db(p, 0);
17324:     for(ii=0; ii<ArraySize(aDbConfig); ii++){
17325:       if( nArg>1 && strcmp(azArg[1], aDbConfig[ii].zName)!=0 ) continue;
17326:       if( nArg>=3 ){
17327:         sqlite3_db_config(p->db, aDbConfig[ii].op, booleanValue(azArg[2]), 0);
17328:       }
17329:       sqlite3_db_config(p->db, aDbConfig[ii].op, -1, &v);
17330:       utf8_printf(p->out, "%19s %s\n", aDbConfig[ii].zName, v ? "on" : "off");
17331:       if( nArg>1 ) break;
17332:     }
17333:     if( nArg>1 && ii==ArraySize(aDbConfig) ){
17334:       utf8_printf(stderr, "Error: unknown dbconfig \"%s\"\n", azArg[1]);
17335:       utf8_printf(stderr, "Enter \".dbconfig\" with no arguments for a list\n");
17336:     }
17337:   }else
17338: 
17339:   if( c=='d' && n>=3 && strncmp(azArg[0], "dbinfo", n)==0 ){
17340:     rc = shell_dbinfo_command(p, nArg, azArg);
17341:   }else
17342: 
17343: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)
17344:   if( c=='r' && strncmp(azArg[0], "recover", n)==0 ){
17345:     open_db(p, 0);
17346:     rc = recoverDatabaseCmd(p, nArg, azArg);
17347:   }else
17348: #endif /* !(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB) */
17349: 
17350:   if( c=='d' && strncmp(azArg[0], "dump", n)==0 ){
17351:     char *zLike = 0;
17352:     char *zSql;
17353:     int i;
17354:     int savedShowHeader = p->showHeader;
17355:     int savedShellFlags = p->shellFlgs;
17356:     ShellClearFlag(p, SHFLG_PreserveRowid|SHFLG_Newlines|SHFLG_Echo);
17357:     for(i=1; i<nArg; i++){
17358:       if( azArg[i][0]=='-' ){
17359:         const char *z = azArg[i]+1;
17360:         if( z[0]=='-' ) z++;
17361:         if( strcmp(z,"preserve-rowids")==0 ){
17362: #ifdef SQLITE_OMIT_VIRTUALTABLE
17363:           raw_printf(stderr, "The --preserve-rowids option is not compatible"
17364:                              " with SQLITE_OMIT_VIRTUALTABLE\n");
17365:           rc = 1;
17366:           sqlite3_free(zLike);
17367:           goto meta_command_exit;
17368: #else
17369:           ShellSetFlag(p, SHFLG_PreserveRowid);
17370: #endif
17371:         }else
17372:         if( strcmp(z,"newlines")==0 ){
17373:           ShellSetFlag(p, SHFLG_Newlines);
17374:         }else
17375:         {
17376:           raw_printf(stderr, "Unknown option \"%s\" on \".dump\"\n", azArg[i]);
17377:           rc = 1;
17378:           sqlite3_free(zLike);
17379:           goto meta_command_exit;
17380:         }
17381:       }else if( zLike ){
17382:         zLike = sqlite3_mprintf("%z OR name LIKE %Q ESCAPE '\\'",
17383:                 zLike, azArg[i]);
17384:       }else{
17385:         zLike = sqlite3_mprintf("name LIKE %Q ESCAPE '\\'", azArg[i]);
17386:       }
17387:     }
17388: 
17389:     open_db(p, 0);
17390: 
17391:     /* When playing back a "dump", the content might appear in an order
17392:     ** which causes immediate foreign key constraints to be violated.
17393:     ** So disable foreign-key constraint enforcement to prevent problems. */
17394:     raw_printf(p->out, "PRAGMA foreign_keys=OFF;\n");
17395:     raw_printf(p->out, "BEGIN TRANSACTION;\n");
17396:     p->writableSchema = 0;
17397:     p->showHeader = 0;
17398:     /* Set writable_schema=ON since doing so forces SQLite to initialize
17399:     ** as much of the schema as it can even if the sqlite_schema table is
17400:     ** corrupt. */
17401:     sqlite3_exec(p->db, "SAVEPOINT dump; PRAGMA writable_schema=ON", 0, 0, 0);
17402:     p->nErr = 0;
17403:     if( zLike==0 ) zLike = sqlite3_mprintf("true");
17404:     zSql = sqlite3_mprintf(
17405:       "SELECT name, type, sql FROM sqlite_schema "
17406:       "WHERE (%s) AND type=='table'"
17407:       "  AND sql NOT NULL"
17408:       " ORDER BY tbl_name='sqlite_sequence'",
17409:       zLike
17410:     );
17411:     run_schema_dump_query(p,zSql);
17412:     sqlite3_free(zSql);
17413:     zSql = sqlite3_mprintf(
17414:       "SELECT sql FROM sqlite_schema "
17415:       "WHERE (%s) AND sql NOT NULL"
17416:       "  AND type IN ('index','trigger','view')",
17417:       zLike
17418:     );
17419:     run_table_dump_query(p, zSql);
17420:     sqlite3_free(zSql);
17421:     sqlite3_free(zLike);
17422:     if( p->writableSchema ){
17423:       raw_printf(p->out, "PRAGMA writable_schema=OFF;\n");
17424:       p->writableSchema = 0;
17425:     }
17426:     sqlite3_exec(p->db, "PRAGMA writable_schema=OFF;", 0, 0, 0);
17427:     sqlite3_exec(p->db, "RELEASE dump;", 0, 0, 0);
17428:     raw_printf(p->out, p->nErr?"ROLLBACK; -- due to errors\n":"COMMIT;\n");
17429:     p->showHeader = savedShowHeader;
17430:     p->shellFlgs = savedShellFlags;
17431:   }else
17432: 
17433:   if( c=='e' && strncmp(azArg[0], "echo", n)==0 ){
17434:     if( nArg==2 ){
17435:       setOrClearFlag(p, SHFLG_Echo, azArg[1]);
17436:     }else{
17437:       raw_printf(stderr, "Usage: .echo on|off\n");
17438:       rc = 1;
17439:     }
17440:   }else
17441: 
17442:   if( c=='e' && strncmp(azArg[0], "eqp", n)==0 ){
17443:     if( nArg==2 ){
17444:       p->autoEQPtest = 0;
17445:       if( p->autoEQPtrace ){
17446:         if( p->db ) sqlite3_exec(p->db, "PRAGMA vdbe_trace=OFF;", 0, 0, 0);
17447:         p->autoEQPtrace = 0;
17448:       }
17449:       if( strcmp(azArg[1],"full")==0 ){
17450:         p->autoEQP = AUTOEQP_full;
17451:       }else if( strcmp(azArg[1],"trigger")==0 ){
17452:         p->autoEQP = AUTOEQP_trigger;
17453: #ifdef SQLITE_DEBUG
17454:       }else if( strcmp(azArg[1],"test")==0 ){
17455:         p->autoEQP = AUTOEQP_on;
17456:         p->autoEQPtest = 1;
17457:       }else if( strcmp(azArg[1],"trace")==0 ){
17458:         p->autoEQP = AUTOEQP_full;
17459:         p->autoEQPtrace = 1;
17460:         open_db(p, 0);
17461:         sqlite3_exec(p->db, "SELECT name FROM sqlite_schema LIMIT 1", 0, 0, 0);
17462:         sqlite3_exec(p->db, "PRAGMA vdbe_trace=ON;", 0, 0, 0);
17463: #endif
17464:       }else{
17465:         p->autoEQP = (u8)booleanValue(azArg[1]);
17466:       }
17467:     }else{
17468:       raw_printf(stderr, "Usage: .eqp off|on|trace|trigger|full\n");
17469:       rc = 1;
17470:     }
17471:   }else
17472: 
17473:   if( c=='e' && strncmp(azArg[0], "exit", n)==0 ){
17474:     if( nArg>1 && (rc = (int)integerValue(azArg[1]))!=0 ) exit(rc);
17475:     rc = 2;
17476:   }else
17477: 
17478:   /* The ".explain" command is automatic now.  It is largely pointless.  It
17479:   ** retained purely for backwards compatibility */
17480:   if( c=='e' && strncmp(azArg[0], "explain", n)==0 ){
17481:     int val = 1;
17482:     if( nArg>=2 ){
17483:       if( strcmp(azArg[1],"auto")==0 ){
17484:         val = 99;
17485:       }else{
17486:         val =  booleanValue(azArg[1]);
17487:       }
17488:     }
17489:     if( val==1 && p->mode!=MODE_Explain ){
17490:       p->normalMode = p->mode;
17491:       p->mode = MODE_Explain;
17492:       p->autoExplain = 0;
17493:     }else if( val==0 ){
17494:       if( p->mode==MODE_Explain ) p->mode = p->normalMode;
17495:       p->autoExplain = 0;
17496:     }else if( val==99 ){
17497:       if( p->mode==MODE_Explain ) p->mode = p->normalMode;
17498:       p->autoExplain = 1;
17499:     }
17500:   }else
17501: 
17502: #ifndef SQLITE_OMIT_VIRTUALTABLE
17503:   if( c=='e' && strncmp(azArg[0], "expert", n)==0 ){
17504:     open_db(p, 0);
17505:     expertDotCommand(p, azArg, nArg);
17506:   }else
17507: #endif
17508: 
17509:   if( c=='f' && strncmp(azArg[0], "filectrl", n)==0 ){
17510:     static const struct {
17511:        const char *zCtrlName;   /* Name of a test-control option */
17512:        int ctrlCode;            /* Integer code for that option */
17513:        const char *zUsage;      /* Usage notes */
17514:     } aCtrl[] = {
17515:       { "size_limit",     SQLITE_FCNTL_SIZE_LIMIT,      "[LIMIT]"        },
17516:       { "chunk_size",     SQLITE_FCNTL_CHUNK_SIZE,      "SIZE"           },
17517:    /* { "win32_av_retry", SQLITE_FCNTL_WIN32_AV_RETRY,  "COUNT DELAY"    },*/
17518:       { "persist_wal",    SQLITE_FCNTL_PERSIST_WAL,     "[BOOLEAN]"      },
17519:       { "psow",       SQLITE_FCNTL_POWERSAFE_OVERWRITE, "[BOOLEAN]"      },
17520:    /* { "pragma",         SQLITE_FCNTL_PRAGMA,          "NAME ARG"       },*/
17521:       { "tempfilename",   SQLITE_FCNTL_TEMPFILENAME,    ""               },
17522:       { "has_moved",      SQLITE_FCNTL_HAS_MOVED,       ""               },
17523:       { "lock_timeout",   SQLITE_FCNTL_LOCK_TIMEOUT,    "MILLISEC"       },
17524:       { "reserve_bytes",  SQLITE_FCNTL_RESERVE_BYTES,   "[N]"            },
17525:     };
17526:     int filectrl = -1;
17527:     int iCtrl = -1;
17528:     sqlite3_int64 iRes = 0;  /* Integer result to display if rc2==1 */
17529:     int isOk = 0;            /* 0: usage  1: %lld  2: no-result */
17530:     int n2, i;
17531:     const char *zCmd = 0;
17532:     const char *zSchema = 0;
17533: 
17534:     open_db(p, 0);
17535:     zCmd = nArg>=2 ? azArg[1] : "help";
17536: 
17537:     if( zCmd[0]=='-'
17538:      && (strcmp(zCmd,"--schema")==0 || strcmp(zCmd,"-schema")==0)
17539:      && nArg>=4
17540:     ){
17541:       zSchema = azArg[2];
17542:       for(i=3; i<nArg; i++) azArg[i-2] = azArg[i];
17543:       nArg -= 2;
17544:       zCmd = azArg[1];
17545:     }
17546: 
17547:     /* The argument can optionally begin with "-" or "--" */
17548:     if( zCmd[0]=='-' && zCmd[1] ){
17549:       zCmd++;
17550:       if( zCmd[0]=='-' && zCmd[1] ) zCmd++;
17551:     }
17552: 
17553:     /* --help lists all file-controls */
17554:     if( strcmp(zCmd,"help")==0 ){
17555:       utf8_printf(p->out, "Available file-controls:\n");
17556:       for(i=0; i<ArraySize(aCtrl); i++){
17557:         utf8_printf(p->out, "  .filectrl %s %s\n",
17558:                     aCtrl[i].zCtrlName, aCtrl[i].zUsage);
17559:       }
17560:       rc = 1;
17561:       goto meta_command_exit;
17562:     }
17563: 
17564:     /* convert filectrl text option to value. allow any unique prefix
17565:     ** of the option name, or a numerical value. */
17566:     n2 = strlen30(zCmd);
17567:     for(i=0; i<ArraySize(aCtrl); i++){
17568:       if( strncmp(zCmd, aCtrl[i].zCtrlName, n2)==0 ){
17569:         if( filectrl<0 ){
17570:           filectrl = aCtrl[i].ctrlCode;
17571:           iCtrl = i;
17572:         }else{
17573:           utf8_printf(stderr, "Error: ambiguous file-control: \"%s\"\n"
17574:                               "Use \".filectrl --help\" for help\n", zCmd);
17575:           rc = 1;
17576:           goto meta_command_exit;
17577:         }
17578:       }
17579:     }
17580:     if( filectrl<0 ){
17581:       utf8_printf(stderr,"Error: unknown file-control: %s\n"
17582:                          "Use \".filectrl --help\" for help\n", zCmd);
17583:     }else{
17584:       switch(filectrl){
17585:         case SQLITE_FCNTL_SIZE_LIMIT: {
17586:           if( nArg!=2 && nArg!=3 ) break;
17587:           iRes = nArg==3 ? integerValue(azArg[2]) : -1;
17588:           sqlite3_file_control(p->db, zSchema, SQLITE_FCNTL_SIZE_LIMIT, &iRes);
17589:           isOk = 1;
17590:           break;
17591:         }
17592:         case SQLITE_FCNTL_LOCK_TIMEOUT:
17593:         case SQLITE_FCNTL_CHUNK_SIZE: {
17594:           int x;
17595:           if( nArg!=3 ) break;
17596:           x = (int)integerValue(azArg[2]);
17597:           sqlite3_file_control(p->db, zSchema, filectrl, &x);
17598:           isOk = 2;
17599:           break;
17600:         }
17601:         case SQLITE_FCNTL_PERSIST_WAL:
17602:         case SQLITE_FCNTL_POWERSAFE_OVERWRITE: {
17603:           int x;
17604:           if( nArg!=2 && nArg!=3 ) break;
17605:           x = nArg==3 ? booleanValue(azArg[2]) : -1;
17606:           sqlite3_file_control(p->db, zSchema, filectrl, &x);
17607:           iRes = x;
17608:           isOk = 1;
17609:           break;
17610:         }
17611:         case SQLITE_FCNTL_HAS_MOVED: {
17612:           int x;
17613:           if( nArg!=2 ) break;
17614:           sqlite3_file_control(p->db, zSchema, filectrl, &x);
17615:           iRes = x;
17616:           isOk = 1;
17617:           break;
17618:         }
17619:         case SQLITE_FCNTL_TEMPFILENAME: {
17620:           char *z = 0;
17621:           if( nArg!=2 ) break;
17622:           sqlite3_file_control(p->db, zSchema, filectrl, &z);
17623:           if( z ){
17624:             utf8_printf(p->out, "%s\n", z);
17625:             sqlite3_free(z);
17626:           }
17627:           isOk = 2;
17628:           break;
17629:         }
17630:         case SQLITE_FCNTL_RESERVE_BYTES: {
17631:           int x;
17632:           if( nArg>=3 ){
17633:             x = atoi(azArg[2]);
17634:             sqlite3_file_control(p->db, zSchema, filectrl, &x);
17635:           }
17636:           x = -1;
17637:           sqlite3_file_control(p->db, zSchema, filectrl, &x);
17638:           utf8_printf(p->out,"%d\n", x);
17639:           isOk = 2;
17640:           break;
17641:         }
17642:       }
17643:     }
17644:     if( isOk==0 && iCtrl>=0 ){
17645:       utf8_printf(p->out, "Usage: .filectrl %s %s\n", zCmd,aCtrl[iCtrl].zUsage);
17646:       rc = 1;
17647:     }else if( isOk==1 ){
17648:       char zBuf[100];
17649:       sqlite3_snprintf(sizeof(zBuf), zBuf, "%lld", iRes);
17650:       raw_printf(p->out, "%s\n", zBuf);
17651:     }
17652:   }else
17653: 
17654:   if( c=='f' && strncmp(azArg[0], "fullschema", n)==0 ){
17655:     raw_printf(p->out, "No STAT tables available\n");
17656:     // ShellState data;
17657:     // char *zErrMsg = 0;
17658:     // int doStats = 0;
17659:     // memcpy(&data, p, sizeof(data));
17660:     // data.showHeader = 0;
17661:     // data.cMode = data.mode = MODE_Semi;
17662:     // if( nArg==2 && optionMatch(azArg[1], "indent") ){
17663:     //   data.cMode = data.mode = MODE_Pretty;
17664:     //   nArg = 1;
17665:     // }
17666:     // if( nArg!=1 ){
17667:     //   raw_printf(stderr, "Usage: .fullschema ?--indent?\n");
17668:     //   rc = 1;
17669:     //   goto meta_command_exit;
17670:     // }
17671:     // open_db(p, 0);
17672:     // rc = sqlite3_exec(p->db,
17673:     //    "SELECT sql FROM"
17674:     //    "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"
17675:     //    "     FROM sqlite_schema UNION ALL"
17676:     //    "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_schema) "
17677:     //    "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%' "
17678:     //    "ORDER BY rowid",
17679:     //    callback, &data, &zErrMsg
17680:     // );
17681:     // if( rc==SQLITE_OK ){
17682:     //   sqlite3_stmt *pStmt;
17683:     //   rc = sqlite3_prepare_v2(p->db,
17684:     //            "SELECT rowid FROM sqlite_schema"
17685:     //            " WHERE name GLOB 'sqlite_stat[134]'",
17686:     //            -1, &pStmt, 0);
17687:     //   doStats = sqlite3_step(pStmt)==SQLITE_ROW;
17688:     //   sqlite3_finalize(pStmt);
17689:     // }
17690:     // if( doStats==0 ){
17691:     //   raw_printf(p->out, "/* No STAT tables available */\n");
17692:     // }else{
17693:     //   raw_printf(p->out, "ANALYZE sqlite_schema;\n");
17694:     //   sqlite3_exec(p->db, "SELECT 'ANALYZE sqlite_schema'",
17695:     //                callback, &data, &zErrMsg);
17696:     //   data.cMode = data.mode = MODE_Insert;
17697:     //   data.zDestTable = "sqlite_stat1";
17698:     //   shell_exec(&data, "SELECT * FROM sqlite_stat1", &zErrMsg);
17699:     //   data.zDestTable = "sqlite_stat4";
17700:     //   shell_exec(&data, "SELECT * FROM sqlite_stat4", &zErrMsg);
17701:     //   raw_printf(p->out, "ANALYZE sqlite_schema;\n");
17702:     // }
17703:   }else
17704: 
17705:   if( c=='h' && strncmp(azArg[0], "headers", n)==0 ){
17706:     if( nArg==2 ){
17707:       p->showHeader = booleanValue(azArg[1]);
17708:       p->shellFlgs |= SHFLG_HeaderSet;
17709:     }else{
17710:       raw_printf(stderr, "Usage: .headers on|off\n");
17711:       rc = 1;
17712:     }
17713:   }else
17714: 
17715:   if( c=='h' && strncmp(azArg[0], "help", n)==0 ){
17716:     if( nArg>=2 ){
17717:       n = showHelp(p->out, azArg[1]);
17718:       if( n==0 ){
17719:         utf8_printf(p->out, "Nothing matches '%s'\n", azArg[1]);
17720:       }
17721:     }else{
17722:       showHelp(p->out, 0);
17723:     }
17724:   }else
17725: 
17726:   if( c=='i' && strncmp(azArg[0], "import", n)==0 ){
17727:     char *zTable = 0;           /* Insert data into this table */
17728:     char *zFile = 0;            /* Name of file to extra content from */
17729:     sqlite3_stmt *pStmt = NULL; /* A statement */
17730:     int nCol;                   /* Number of columns in the table */
17731:     int nByte;                  /* Number of bytes in an SQL string */
17732:     int i, j;                   /* Loop counters */
17733:     int needCommit;             /* True to COMMIT or ROLLBACK at end */
17734:     int nSep;                   /* Number of bytes in p->colSeparator[] */
17735:     char *zSql;                 /* An SQL statement */
17736:     ImportCtx sCtx;             /* Reader context */
17737:     char *(SQLITE_CDECL *xRead)(ImportCtx*); /* Func to read one value */
17738:     int eVerbose = 0;           /* Larger for more console output */
17739:     int nSkip = 0;              /* Initial lines to skip */
17740:     int useOutputMode = 1;      /* Use output mode to determine separators */
17741: 
17742:     memset(&sCtx, 0, sizeof(sCtx));
17743:     if( p->mode==MODE_Ascii ){
17744:       xRead = ascii_read_one_field;
17745:     }else{
17746:       xRead = csv_read_one_field;
17747:     }
17748:     for(i=1; i<nArg; i++){
17749:       char *z = azArg[i];
17750:       if( z[0]=='-' && z[1]=='-' ) z++;
17751:       if( z[0]!='-' ){
17752:         if( zFile==0 ){
17753:           zFile = z;
17754:         }else if( zTable==0 ){
17755:           zTable = z;
17756:         }else{
17757:           utf8_printf(p->out, "ERROR: extra argument: \"%s\".  Usage:\n", z);
17758:           showHelp(p->out, "import");
17759:           rc = 1;
17760:           goto meta_command_exit;
17761:         }
17762:       }else if( strcmp(z,"-v")==0 ){
17763:         eVerbose++;
17764:       }else if( strcmp(z,"-skip")==0 && i<nArg-1 ){
17765:         nSkip = integerValue(azArg[++i]);
17766:       }else if( strcmp(z,"-ascii")==0 ){
17767:         sCtx.cColSep = SEP_Unit[0];
17768:         sCtx.cRowSep = SEP_Record[0];
17769:         xRead = ascii_read_one_field;
17770:         useOutputMode = 0;
17771:       }else if( strcmp(z,"-csv")==0 ){
17772:         sCtx.cColSep = ',';
17773:         sCtx.cRowSep = '\n';
17774:         xRead = csv_read_one_field;
17775:         useOutputMode = 0;
17776:       }else{
17777:         utf8_printf(p->out, "ERROR: unknown option: \"%s\".  Usage:\n", z);
17778:         showHelp(p->out, "import");
17779:         rc = 1;
17780:         goto meta_command_exit;
17781:       }
17782:     }
17783:     if( zTable==0 ){
17784:       utf8_printf(p->out, "ERROR: missing %s argument. Usage:\n",
17785:                   zFile==0 ? "FILE" : "TABLE");
17786:       showHelp(p->out, "import");
17787:       rc = 1;
17788:       goto meta_command_exit;
17789:     }
17790:     seenInterrupt = 0;
17791:     open_db(p, 0);
17792:     if( useOutputMode ){
17793:       /* If neither the --csv or --ascii options are specified, then set
17794:       ** the column and row separator characters from the output mode. */
17795:       nSep = strlen30(p->colSeparator);
17796:       if( nSep==0 ){
17797:         raw_printf(stderr,
17798:                    "Error: non-null column separator required for import\n");
17799:         rc = 1;
17800:         goto meta_command_exit;
17801:       }
17802:       if( nSep>1 ){
17803:         raw_printf(stderr,
17804:               "Error: multi-character column separators not allowed"
17805:               " for import\n");
17806:         rc = 1;
17807:         goto meta_command_exit;
17808:       }
17809:       nSep = strlen30(p->rowSeparator);
17810:       if( nSep==0 ){
17811:         raw_printf(stderr,
17812:             "Error: non-null row separator required for import\n");
17813:         rc = 1;
17814:         goto meta_command_exit;
17815:       }
17816:       if( nSep==2 && p->mode==MODE_Csv && strcmp(p->rowSeparator,SEP_CrLf)==0 ){
17817:         /* When importing CSV (only), if the row separator is set to the
17818:         ** default output row separator, change it to the default input
17819:         ** row separator.  This avoids having to maintain different input
17820:         ** and output row separators. */
17821:         sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);
17822:         nSep = strlen30(p->rowSeparator);
17823:       }
17824:       if( nSep>1 ){
17825:         raw_printf(stderr, "Error: multi-character row separators not allowed"
17826:                            " for import\n");
17827:         rc = 1;
17828:         goto meta_command_exit;
17829:       }
17830:       sCtx.cColSep = p->colSeparator[0];
17831:       sCtx.cRowSep = p->rowSeparator[0];
17832:     }
17833:     sCtx.zFile = zFile;
17834:     sCtx.nLine = 1;
17835:     if( sCtx.zFile[0]=='|' ){
17836: #ifdef SQLITE_OMIT_POPEN
17837:       raw_printf(stderr, "Error: pipes are not supported in this OS\n");
17838:       rc = 1;
17839:       goto meta_command_exit;
17840: #else
17841:       sCtx.in = popen(sCtx.zFile+1, "r");
17842:       sCtx.zFile = "<pipe>";
17843:       sCtx.xCloser = pclose;
17844: #endif
17845:     }else{
17846:       sCtx.in = fopen(sCtx.zFile, "rb");
17847:       sCtx.xCloser = fclose;
17848:     }
17849:     if( sCtx.in==0 ){
17850:       utf8_printf(stderr, "Error: cannot open \"%s\"\n", zFile);
17851:       rc = 1;
17852:       goto meta_command_exit;
17853:     }
17854:     if( eVerbose>=2 || (eVerbose>=1 && useOutputMode) ){
17855:       char zSep[2];
17856:       zSep[1] = 0;
17857:       zSep[0] = sCtx.cColSep;
17858:       utf8_printf(p->out, "Column separator ");
17859:       output_c_string(p->out, zSep);
17860:       utf8_printf(p->out, ", row separator ");
17861:       zSep[0] = sCtx.cRowSep;
17862:       output_c_string(p->out, zSep);
17863:       utf8_printf(p->out, "\n");
17864:     }
17865:     while( (nSkip--)>0 ){
17866:       while( xRead(&sCtx) && sCtx.cTerm==sCtx.cColSep ){}
17867:     }
17868:     zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);
17869:     if( zSql==0 ){
17870:       import_cleanup(&sCtx);
17871:       shell_out_of_memory();
17872:     }
17873:     nByte = strlen30(zSql);
17874:     rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
17875:     import_append_char(&sCtx, 0);    /* To ensure sCtx.z is allocated */
17876:     if( rc && sqlite3_strglob("Catalog Error: Table with name *", sqlite3_errmsg(p->db))==0 ){
17877:       char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);
17878:       char cSep = '(';
17879:       while( xRead(&sCtx) ){
17880:         zCreate = sqlite3_mprintf("%z%c\n  \"%w\" TEXT", zCreate, cSep, sCtx.z);
17881:         cSep = ',';
17882:         if( sCtx.cTerm!=sCtx.cColSep ) break;
17883:       }
17884:       if( cSep=='(' ){
17885:         sqlite3_free(zCreate);
17886:         import_cleanup(&sCtx);
17887:         utf8_printf(stderr,"%s: empty file\n", sCtx.zFile);
17888:         rc = 1;
17889:         goto meta_command_exit;
17890:       }
17891:       zCreate = sqlite3_mprintf("%z\n)", zCreate);
17892:       if( eVerbose>=1 ){
17893:         utf8_printf(p->out, "%s\n", zCreate);
17894:       }
17895:       rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);
17896:       sqlite3_free(zCreate);
17897:       if( rc ){
17898:         utf8_printf(stderr, "CREATE TABLE %s(...) failed: %s\n", zTable,
17899:                 sqlite3_errmsg(p->db));
17900:         import_cleanup(&sCtx);
17901:         rc = 1;
17902:         goto meta_command_exit;
17903:       }
17904:       rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
17905:     }
17906:     sqlite3_free(zSql);
17907:     if( rc ){
17908:       if (pStmt) sqlite3_finalize(pStmt);
17909:       utf8_printf(stderr,"Error: %s\n", sqlite3_errmsg(p->db));
17910:       import_cleanup(&sCtx);
17911:       rc = 1;
17912:       goto meta_command_exit;
17913:     }
17914:     nCol = sqlite3_column_count(pStmt);
17915:     sqlite3_finalize(pStmt);
17916:     pStmt = 0;
17917:     if( nCol==0 ) return 0; /* no columns, no error */
17918:     zSql = sqlite3_malloc64( nByte*2 + 20 + nCol*2 );
17919:     if( zSql==0 ){
17920:       import_cleanup(&sCtx);
17921:       shell_out_of_memory();
17922:     }
17923:     sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \"%w\" VALUES(?", zTable);
17924:     j = strlen30(zSql);
17925:     for(i=1; i<nCol; i++){
17926:       zSql[j++] = ',';
17927:       zSql[j++] = '?';
17928:     }
17929:     zSql[j++] = ')';
17930:     zSql[j] = 0;
17931:     if( eVerbose>=2 ){
17932:       utf8_printf(p->out, "Insert using: %s\n", zSql);
17933:     }
17934:     rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
17935:     sqlite3_free(zSql);
17936:     if( rc ){
17937:       utf8_printf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));
17938:       if (pStmt) sqlite3_finalize(pStmt);
17939:       import_cleanup(&sCtx);
17940:       rc = 1;
17941:       goto meta_command_exit;
17942:     }
17943:     needCommit = sqlite3_get_autocommit(p->db);
17944:     if( needCommit ) sqlite3_exec(p->db, "BEGIN", 0, 0, 0);
17945:     do{
17946:       int startLine = sCtx.nLine;
17947:       for(i=0; i<nCol; i++){
17948:         char *z = xRead(&sCtx);
17949:         /*
17950:         ** Did we reach end-of-file before finding any columns?
17951:         ** If so, stop instead of NULL filling the remaining columns.
17952:         */
17953:         if( z==0 && i==0 ) break;
17954:         /*
17955:         ** Did we reach end-of-file OR end-of-line before finding any
17956:         ** columns in ASCII mode?  If so, stop instead of NULL filling
17957:         ** the remaining columns.
17958:         */
17959:         if( p->mode==MODE_Ascii && (z==0 || z[0]==0) && i==0 ) break;
17960:         sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);
17961:         if( i<nCol-1 && sCtx.cTerm!=sCtx.cColSep ){
17962:           utf8_printf(stderr, "%s:%d: expected %d columns but found %d - "
17963:                           "filling the rest with NULL\n",
17964:                           sCtx.zFile, startLine, nCol, i+1);
17965:           i += 2;
17966:           while( i<=nCol ){ sqlite3_bind_null(pStmt, i); i++; }
17967:         }
17968:       }
17969:       if( sCtx.cTerm==sCtx.cColSep ){
17970:         do{
17971:           xRead(&sCtx);
17972:           i++;
17973:         }while( sCtx.cTerm==sCtx.cColSep );
17974:         utf8_printf(stderr, "%s:%d: expected %d columns but found %d - "
17975:                         "extras ignored\n",
17976:                         sCtx.zFile, startLine, nCol, i);
17977:       }
17978:       if( i>=nCol ){
17979:         sqlite3_step(pStmt);
17980:         rc = sqlite3_reset(pStmt);
17981:         if( rc!=SQLITE_OK ){
17982:           utf8_printf(stderr, "%s:%d: INSERT failed: %s\n", sCtx.zFile,
17983:                       startLine, sqlite3_errmsg(p->db));
17984:           sCtx.nErr++;
17985:         }else{
17986:           sCtx.nRow++;
17987:         }
17988:       }
17989:     }while( sCtx.cTerm!=EOF );
17990: 
17991:     import_cleanup(&sCtx);
17992:     sqlite3_finalize(pStmt);
17993:     if( needCommit ) sqlite3_exec(p->db, "COMMIT", 0, 0, 0);
17994:     if( eVerbose>0 ){
17995:       utf8_printf(p->out,
17996:           "Added %d rows with %d errors using %d lines of input\n",
17997:           sCtx.nRow, sCtx.nErr, sCtx.nLine-1);
17998:     }
17999:   }else
18000: 
18001: #ifndef SQLITE_UNTESTABLE
18002:   if( c=='i' && strncmp(azArg[0], "imposter", n)==0 ){
18003:     char *zSql;
18004:     char *zCollist = 0;
18005:     sqlite3_stmt *pStmt;
18006:     int tnum = 0;
18007:     int isWO = 0;  /* True if making an imposter of a WITHOUT ROWID table */
18008:     int lenPK = 0; /* Length of the PRIMARY KEY string for isWO tables */
18009:     int i;
18010:     if( !(nArg==3 || (nArg==2 && sqlite3_stricmp(azArg[1],"off")==0)) ){
18011:       utf8_printf(stderr, "Usage: .imposter INDEX IMPOSTER\n"
18012:                           "       .imposter off\n");
18013:       /* Also allowed, but not documented:
18014:       **
18015:       **    .imposter TABLE IMPOSTER
18016:       **
18017:       ** where TABLE is a WITHOUT ROWID table.  In that case, the
18018:       ** imposter is another WITHOUT ROWID table with the columns in
18019:       ** storage order. */
18020:       rc = 1;
18021:       goto meta_command_exit;
18022:     }
18023:     open_db(p, 0);
18024:     if( nArg==2 ){
18025:       sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->db, "main", 0, 1);
18026:       goto meta_command_exit;
18027:     }
18028:     zSql = sqlite3_mprintf(
18029:       "SELECT rootpage, 0 FROM sqlite_schema"
18030:       " WHERE name='%q' AND type='index'"
18031:       "UNION ALL "
18032:       "SELECT rootpage, 1 FROM sqlite_schema"
18033:       " WHERE name='%q' AND type='table'"
18034:       "   AND sql LIKE '%%without%%rowid%%'",
18035:       azArg[1], azArg[1]
18036:     );
18037:     sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
18038:     sqlite3_free(zSql);
18039:     if( sqlite3_step(pStmt)==SQLITE_ROW ){
18040:       tnum = sqlite3_column_int(pStmt, 0);
18041:       isWO = sqlite3_column_int(pStmt, 1);
18042:     }
18043:     sqlite3_finalize(pStmt);
18044:     zSql = sqlite3_mprintf("PRAGMA index_xinfo='%q'", azArg[1]);
18045:     rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
18046:     sqlite3_free(zSql);
18047:     i = 0;
18048:     while( sqlite3_step(pStmt)==SQLITE_ROW ){
18049:       char zLabel[20];
18050:       const char *zCol = (const char*)sqlite3_column_text(pStmt,2);
18051:       i++;
18052:       if( zCol==0 ){
18053:         if( sqlite3_column_int(pStmt,1)==-1 ){
18054:           zCol = "_ROWID_";
18055:         }else{
18056:           sqlite3_snprintf(sizeof(zLabel),zLabel,"expr%d",i);
18057:           zCol = zLabel;
18058:         }
18059:       }
18060:       if( isWO && lenPK==0 && sqlite3_column_int(pStmt,5)==0 && zCollist ){
18061:         lenPK = (int)strlen(zCollist);
18062:       }
18063:       if( zCollist==0 ){
18064:         zCollist = sqlite3_mprintf("\"%w\"", zCol);
18065:       }else{
18066:         zCollist = sqlite3_mprintf("%z,\"%w\"", zCollist, zCol);
18067:       }
18068:     }
18069:     sqlite3_finalize(pStmt);
18070:     if( i==0 || tnum==0 ){
18071:       utf8_printf(stderr, "no such index: \"%s\"\n", azArg[1]);
18072:       rc = 1;
18073:       sqlite3_free(zCollist);
18074:       goto meta_command_exit;
18075:     }
18076:     if( lenPK==0 ) lenPK = 100000;
18077:     zSql = sqlite3_mprintf(
18078:           "CREATE TABLE \"%w\"(%s,PRIMARY KEY(%.*s))WITHOUT ROWID",
18079:           azArg[2], zCollist, lenPK, zCollist);
18080:     sqlite3_free(zCollist);
18081:     rc = sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->db, "main", 1, tnum);
18082:     if( rc==SQLITE_OK ){
18083:       rc = sqlite3_exec(p->db, zSql, 0, 0, 0);
18084:       sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->db, "main", 0, 0);
18085:       if( rc ){
18086:         utf8_printf(stderr, "Error in [%s]: %s\n", zSql, sqlite3_errmsg(p->db));
18087:       }else{
18088:         utf8_printf(stdout, "%s;\n", zSql);
18089:         raw_printf(stdout,
18090:           "WARNING: writing to an imposter table will corrupt the \"%s\" %s!\n",
18091:           azArg[1], isWO ? "table" : "index"
18092:         );
18093:       }
18094:     }else{
18095:       raw_printf(stderr, "SQLITE_TESTCTRL_IMPOSTER returns %d\n", rc);
18096:       rc = 1;
18097:     }
18098:     sqlite3_free(zSql);
18099:   }else
18100: #endif /* !defined(SQLITE_OMIT_TEST_CONTROL) */
18101: 
18102: #ifdef SQLITE_ENABLE_IOTRACE
18103:   if( c=='i' && strncmp(azArg[0], "iotrace", n)==0 ){
18104:     SQLITE_API extern void (SQLITE_CDECL *sqlite3IoTrace)(const char*, ...);
18105:     if( iotrace && iotrace!=stdout ) fclose(iotrace);
18106:     iotrace = 0;
18107:     if( nArg<2 ){
18108:       sqlite3IoTrace = 0;
18109:     }else if( strcmp(azArg[1], "-")==0 ){
18110:       sqlite3IoTrace = iotracePrintf;
18111:       iotrace = stdout;
18112:     }else{
18113:       iotrace = fopen(azArg[1], "w");
18114:       if( iotrace==0 ){
18115:         utf8_printf(stderr, "Error: cannot open \"%s\"\n", azArg[1]);
18116:         sqlite3IoTrace = 0;
18117:         rc = 1;
18118:       }else{
18119:         sqlite3IoTrace = iotracePrintf;
18120:       }
18121:     }
18122:   }else
18123: #endif
18124: 
18125:   if( c=='l' && n>=5 && strncmp(azArg[0], "limits", n)==0 ){
18126:     static const struct {
18127:        const char *zLimitName;   /* Name of a limit */
18128:        int limitCode;            /* Integer code for that limit */
18129:     } aLimit[] = {
18130:       { "length",                SQLITE_LIMIT_LENGTH                    },
18131:       { "sql_length",            SQLITE_LIMIT_SQL_LENGTH                },
18132:       { "column",                SQLITE_LIMIT_COLUMN                    },
18133:       { "expr_depth",            SQLITE_LIMIT_EXPR_DEPTH                },
18134:       { "compound_select",       SQLITE_LIMIT_COMPOUND_SELECT           },
18135:       { "vdbe_op",               SQLITE_LIMIT_VDBE_OP                   },
18136:       { "function_arg",          SQLITE_LIMIT_FUNCTION_ARG              },
18137:       { "attached",              SQLITE_LIMIT_ATTACHED                  },
18138:       { "like_pattern_length",   SQLITE_LIMIT_LIKE_PATTERN_LENGTH       },
18139:       { "variable_number",       SQLITE_LIMIT_VARIABLE_NUMBER           },
18140:       { "trigger_depth",         SQLITE_LIMIT_TRIGGER_DEPTH             },
18141:       { "worker_threads",        SQLITE_LIMIT_WORKER_THREADS            },
18142:     };
18143:     int i, n2;
18144:     open_db(p, 0);
18145:     if( nArg==1 ){
18146:       for(i=0; i<ArraySize(aLimit); i++){
18147:         printf("%20s %d\n", aLimit[i].zLimitName,
18148:                sqlite3_limit(p->db, aLimit[i].limitCode, -1));
18149:       }
18150:     }else if( nArg>3 ){
18151:       raw_printf(stderr, "Usage: .limit NAME ?NEW-VALUE?\n");
18152:       rc = 1;
18153:       goto meta_command_exit;
18154:     }else{
18155:       int iLimit = -1;
18156:       n2 = strlen30(azArg[1]);
18157:       for(i=0; i<ArraySize(aLimit); i++){
18158:         if( sqlite3_strnicmp(aLimit[i].zLimitName, azArg[1], n2)==0 ){
18159:           if( iLimit<0 ){
18160:             iLimit = i;
18161:           }else{
18162:             utf8_printf(stderr, "ambiguous limit: \"%s\"\n", azArg[1]);
18163:             rc = 1;
18164:             goto meta_command_exit;
18165:           }
18166:         }
18167:       }
18168:       if( iLimit<0 ){
18169:         utf8_printf(stderr, "unknown limit: \"%s\"\n"
18170:                         "enter \".limits\" with no arguments for a list.\n",
18171:                          azArg[1]);
18172:         rc = 1;
18173:         goto meta_command_exit;
18174:       }
18175:       if( nArg==3 ){
18176:         sqlite3_limit(p->db, aLimit[iLimit].limitCode,
18177:                       (int)integerValue(azArg[2]));
18178:       }
18179:       printf("%20s %d\n", aLimit[iLimit].zLimitName,
18180:              sqlite3_limit(p->db, aLimit[iLimit].limitCode, -1));
18181:     }
18182:   }else
18183: 
18184:   if( c=='l' && n>2 && strncmp(azArg[0], "lint", n)==0 ){
18185:     open_db(p, 0);
18186:     lintDotCommand(p, azArg, nArg);
18187:   }else
18188: 
18189: #ifndef SQLITE_OMIT_LOAD_EXTENSION
18190:   if( c=='l' && strncmp(azArg[0], "load", n)==0 ){
18191:     const char *zFile, *zProc;
18192:     char *zErrMsg = 0;
18193:     if( nArg<2 ){
18194:       raw_printf(stderr, "Usage: .load FILE ?ENTRYPOINT?\n");
18195:       rc = 1;
18196:       goto meta_command_exit;
18197:     }
18198:     zFile = azArg[1];
18199:     zProc = nArg>=3 ? azArg[2] : 0;
18200:     open_db(p, 0);
18201:     rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);
18202:     if( rc!=SQLITE_OK ){
18203:       utf8_printf(stderr, "Error: %s\n", zErrMsg);
18204:       sqlite3_free(zErrMsg);
18205:       rc = 1;
18206:     }
18207:   }else
18208: #endif
18209: 
18210:   if( c=='l' && strncmp(azArg[0], "log", n)==0 ){
18211:     if( nArg!=2 ){
18212:       raw_printf(stderr, "Usage: .log FILENAME\n");
18213:       rc = 1;
18214:     }else{
18215:       const char *zFile = azArg[1];
18216:       output_file_close(p->pLog);
18217:       p->pLog = output_file_open(zFile, 0);
18218:     }
18219:   }else
18220: 
18221:   if( c=='m' && strncmp(azArg[0], "mode", n)==0 ){
18222:     const char *zMode = nArg>=2 ? azArg[1] : "";
18223:     int n2 = strlen30(zMode);
18224:     int c2 = zMode[0];
18225:     if( c2=='l' && n2>2 && strncmp(azArg[1],"lines",n2)==0 ){
18226:       p->mode = MODE_Line;
18227:       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);
18228:     }else if( c2=='c' && strncmp(azArg[1],"columns",n2)==0 ){
18229:       p->mode = MODE_Column;
18230:       if( (p->shellFlgs & SHFLG_HeaderSet)==0 ){
18231:         p->showHeader = 1;
18232:       }
18233:       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);
18234:     }else if( c2=='l' && n2>2 && strncmp(azArg[1],"list",n2)==0 ){
18235:       p->mode = MODE_List;
18236:       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Column);
18237:       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);
18238:     }else if( c2=='h' && strncmp(azArg[1],"html",n2)==0 ){
18239:       p->mode = MODE_Html;
18240:     }else if( c2=='t' && strncmp(azArg[1],"tcl",n2)==0 ){
18241:       p->mode = MODE_Tcl;
18242:       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Space);
18243:       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);
18244:     }else if( c2=='c' && strncmp(azArg[1],"csv",n2)==0 ){
18245:       p->mode = MODE_Csv;
18246:       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Comma);
18247:       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_CrLf);
18248:     }else if( c2=='t' && strncmp(azArg[1],"tabs",n2)==0 ){
18249:       p->mode = MODE_List;
18250:       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Tab);
18251:     }else if( c2=='i' && strncmp(azArg[1],"insert",n2)==0 ){
18252:       p->mode = MODE_Insert;
18253:       set_table_name(p, nArg>=3 ? azArg[2] : "table");
18254:     }else if( c2=='q' && strncmp(azArg[1],"quote",n2)==0 ){
18255:       p->mode = MODE_Quote;
18256:       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Comma);
18257:       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);
18258:     }else if( c2=='a' && strncmp(azArg[1],"ascii",n2)==0 ){
18259:       p->mode = MODE_Ascii;
18260:       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Unit);
18261:       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Record);
18262:     }else if( c2=='m' && strncmp(azArg[1],"markdown",n2)==0 ){
18263:       p->mode = MODE_Markdown;
18264:     }else if( c2=='t' && strncmp(azArg[1],"table",n2)==0 ){
18265:       p->mode = MODE_Table;
18266:     }else if( c2=='b' && strncmp(azArg[1],"box",n2)==0 ){
18267:       p->mode = MODE_Box;
18268:     }else if( c2=='j' && strncmp(azArg[1],"json",n2)==0 ){
18269:       p->mode = MODE_Json;
18270:     }else if( c2=='l' && strncmp(azArg[1],"latex",n2)==0 ){
18271:       p->mode = MODE_Latex;
18272:     }else if( c2=='t' && strncmp(azArg[1],"trash",n2)==0 ){
18273:       p->mode = MODE_Trash;
18274: 	}else if( c2=='j' && strncmp(azArg[1],"jsonlines",n2)==0 ){
18275: 		p->mode = MODE_Jsonlines;
18276:     }else if( nArg==1 ){
18277:       raw_printf(p->out, "current output mode: %s\n", modeDescr[p->mode]);
18278:     }else{
18279:       raw_printf(stderr, "Error: mode should be one of: "
18280:          "ascii box column csv html insert json line list markdown "
18281:          "quote table tabs tcl latex trash \n");
18282:       rc = 1;
18283:     }
18284:     p->cMode = p->mode;
18285:   }else
18286: 
18287:   if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 ){
18288:     if( nArg==2 ){
18289:       sqlite3_snprintf(sizeof(p->nullValue), p->nullValue,
18290:                        "%.*s", (int)ArraySize(p->nullValue)-1, azArg[1]);
18291:     }else{
18292:       raw_printf(stderr, "Usage: .nullvalue STRING\n");
18293:       rc = 1;
18294:     }
18295:   }else
18296: 
18297: #ifdef SQLITE_DEBUG
18298:   if( c=='o' && strcmp(azArg[0],"oom")==0 ){
18299:     int i;
18300:     for(i=1; i<nArg; i++){
18301:       const char *z = azArg[i];
18302:       if( z[0]=='-' && z[1]=='-' ) z++;
18303:       if( strcmp(z,"-repeat")==0 ){
18304:         if( i==nArg-1 ){
18305:           raw_printf(p->out, "missing argument on \"%s\"\n", azArg[i]);
18306:           rc = 1;
18307:         }else{
18308:           oomRepeat = (int)integerValue(azArg[++i]);
18309:         }
18310:       }else if( IsDigit(z[0]) ){
18311:         oomCounter = (int)integerValue(azArg[i]);
18312:       }else{
18313:         raw_printf(p->out, "unknown argument: \"%s\"\n", azArg[i]);
18314:         raw_printf(p->out, "Usage: .oom [--repeat N] [M]\n");
18315:         rc = 1;
18316:       }
18317:     }
18318:     if( rc==0 ){
18319:       raw_printf(p->out, "oomCounter = %d\n", oomCounter);
18320:       raw_printf(p->out, "oomRepeat  = %d\n", oomRepeat);
18321:     }
18322:   }else
18323: #endif /* SQLITE_DEBUG */
18324: 
18325:   if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 ){
18326:     char *zNewFilename;  /* Name of the database file to open */
18327:     int iName = 1;       /* Index in azArg[] of the filename */
18328:     int newFlag = 0;     /* True to delete file before opening */
18329:     /* Close the existing database */
18330:     session_close_all(p);
18331:     close_db(p->db);
18332:     p->db = 0;
18333:     p->zDbFilename = 0;
18334:     sqlite3_free(p->zFreeOnClose);
18335:     p->zFreeOnClose = 0;
18336:     p->openMode = SHELL_OPEN_UNSPEC;
18337:     p->openFlags = p->openFlags & ~(SQLITE_OPEN_NOFOLLOW); // don't overwrite settings loaded in the command line
18338:     p->szMax = 0;
18339:     /* Check for command-line arguments */
18340:     for(iName=1; iName<nArg && azArg[iName][0]=='-'; iName++){
18341:       const char *z = azArg[iName];
18342:       if( optionMatch(z,"new") ){
18343:         newFlag = 1;
18344: #ifdef SQLITE_HAVE_ZLIB
18345:       }else if( optionMatch(z, "zip") ){
18346:         p->openMode = SHELL_OPEN_ZIPFILE;
18347: #endif
18348:       }else if( optionMatch(z, "append") ){
18349:         p->openMode = SHELL_OPEN_APPENDVFS;
18350:       }else if( optionMatch(z, "readonly") ){
18351:         p->openMode = SHELL_OPEN_READONLY;
18352:       }else if( optionMatch(z, "nofollow") ){
18353:         p->openFlags |= SQLITE_OPEN_NOFOLLOW;
18354: #ifdef SQLITE_ENABLE_DESERIALIZE
18355:       }else if( optionMatch(z, "deserialize") ){
18356:         p->openMode = SHELL_OPEN_DESERIALIZE;
18357:       }else if( optionMatch(z, "hexdb") ){
18358:         p->openMode = SHELL_OPEN_HEXDB;
18359:       }else if( optionMatch(z, "maxsize") && iName+1<nArg ){
18360:         p->szMax = integerValue(azArg[++iName]);
18361: #endif /* SQLITE_ENABLE_DESERIALIZE */
18362:       }else if( z[0]=='-' ){
18363:         utf8_printf(stderr, "unknown option: %s\n", z);
18364:         rc = 1;
18365:         goto meta_command_exit;
18366:       }
18367:     }
18368:     /* If a filename is specified, try to open it first */
18369:     zNewFilename = nArg>iName ? sqlite3_mprintf("%s", azArg[iName]) : 0;
18370:     if( zNewFilename || p->openMode==SHELL_OPEN_HEXDB ){
18371:       if( newFlag ) shellDeleteFile(zNewFilename);
18372:       p->zDbFilename = zNewFilename;
18373:       open_db(p, OPEN_DB_KEEPALIVE);
18374:       if( p->db==0 ){
18375:         utf8_printf(stderr, "Error: cannot open '%s'\n", zNewFilename);
18376:         sqlite3_free(zNewFilename);
18377:       }else{
18378:         p->zFreeOnClose = zNewFilename;
18379:       }
18380:     }
18381:     if( p->db==0 ){
18382:       /* As a fall-back open a TEMP database */
18383:       p->zDbFilename = 0;
18384:       open_db(p, 0);
18385:     }
18386:   }else
18387: 
18388:   if( (c=='o'
18389:         && (strncmp(azArg[0], "output", n)==0||strncmp(azArg[0], "once", n)==0))
18390:    || (c=='e' && n==5 && strcmp(azArg[0],"excel")==0)
18391:   ){
18392:     const char *zFile = 0;
18393:     int bTxtMode = 0;
18394:     int i;
18395:     int eMode = 0;
18396:     int bBOM = 0;
18397:     int bOnce = 0;  /* 0: .output, 1: .once, 2: .excel */
18398: 
18399:     if( c=='e' ){
18400:       eMode = 'x';
18401:       bOnce = 2;
18402:     }else if( strncmp(azArg[0],"once",n)==0 ){
18403:       bOnce = 1;
18404:     }
18405:     for(i=1; i<nArg; i++){
18406:       char *z = azArg[i];
18407:       if( z[0]=='-' ){
18408:         if( z[1]=='-' ) z++;
18409:         if( strcmp(z,"-bom")==0 ){
18410:           bBOM = 1;
18411:         }else if( c!='e' && strcmp(z,"-x")==0 ){
18412:           eMode = 'x';  /* spreadsheet */
18413:         }else if( c!='e' && strcmp(z,"-e")==0 ){
18414:           eMode = 'e';  /* text editor */
18415:         }else{
18416:           utf8_printf(p->out, "ERROR: unknown option: \"%s\".  Usage:\n",
18417:                       azArg[i]);
18418:           showHelp(p->out, azArg[0]);
18419:           rc = 1;
18420:           goto meta_command_exit;
18421:         }
18422:       }else if( zFile==0 ){
18423:         zFile = z;
18424:       }else{
18425:         utf8_printf(p->out,"ERROR: extra parameter: \"%s\".  Usage:\n",
18426:                     azArg[i]);
18427:         showHelp(p->out, azArg[0]);
18428:         rc = 1;
18429:         goto meta_command_exit;
18430:       }
18431:     }
18432:     if( zFile==0 ) zFile = "stdout";
18433:     if( bOnce ){
18434:       p->outCount = 2;
18435:     }else{
18436:       p->outCount = 0;
18437:     }
18438:     output_reset(p);
18439: #ifndef SQLITE_NOHAVE_SYSTEM
18440:     if( eMode=='e' || eMode=='x' ){
18441:       p->doXdgOpen = 1;
18442:       outputModePush(p);
18443:       if( eMode=='x' ){
18444:         /* spreadsheet mode.  Output as CSV. */
18445:         newTempFile(p, "csv");
18446:         ShellClearFlag(p, SHFLG_Echo);
18447:         p->mode = MODE_Csv;
18448:         sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Comma);
18449:         sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_CrLf);
18450:       }else{
18451:         /* text editor mode */
18452:         newTempFile(p, "txt");
18453:         bTxtMode = 1;
18454:       }
18455:       zFile = p->zTempFile;
18456:     }
18457: #endif /* SQLITE_NOHAVE_SYSTEM */
18458:     if( zFile[0]=='|' ){
18459: #ifdef SQLITE_OMIT_POPEN
18460:       raw_printf(stderr, "Error: pipes are not supported in this OS\n");
18461:       rc = 1;
18462:       p->out = stdout;
18463: #else
18464:       p->out = popen(zFile + 1, "w");
18465:       if( p->out==0 ){
18466:         utf8_printf(stderr,"Error: cannot open pipe \"%s\"\n", zFile + 1);
18467:         p->out = stdout;
18468:         rc = 1;
18469:       }else{
18470:         if( bBOM ) fprintf(p->out,"\357\273\277");
18471:         sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", zFile);
18472:       }
18473: #endif
18474:     }else{
18475:       p->out = output_file_open(zFile, bTxtMode);
18476:       if( p->out==0 ){
18477:         if( strcmp(zFile,"off")!=0 ){
18478:           utf8_printf(stderr,"Error: cannot write to \"%s\"\n", zFile);
18479:         }
18480:         p->out = stdout;
18481:         rc = 1;
18482:       } else {
18483:         if( bBOM ) fprintf(p->out,"\357\273\277");
18484:         sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", zFile);
18485:       }
18486:     }
18487:   }else
18488: 
18489:   if( c=='p' && n>=3 && strncmp(azArg[0], "parameter", n)==0 ){
18490:     open_db(p,0);
18491:     if( nArg<=1 ) goto parameter_syntax_error;
18492: 
18493:     /* .parameter clear
18494:     ** Clear all bind parameters by dropping the TEMP table that holds them.
18495:     */
18496:     if( nArg==2 && strcmp(azArg[1],"clear")==0 ){
18497:       sqlite3_exec(p->db, "DROP TABLE IF EXISTS temp.sqlite_parameters;",
18498:                    0, 0, 0);
18499:     }else
18500: 
18501:     /* .parameter list
18502:     ** List all bind parameters.
18503:     */
18504:     if( nArg==2 && strcmp(azArg[1],"list")==0 ){
18505:       sqlite3_stmt *pStmt = 0;
18506:       int rx;
18507:       int len = 0;
18508:       rx = sqlite3_prepare_v2(p->db,
18509:              "SELECT max(length(key)) "
18510:              "FROM temp.sqlite_parameters;", -1, &pStmt, 0);
18511:       if( rx==SQLITE_OK && sqlite3_step(pStmt)==SQLITE_ROW ){
18512:         len = sqlite3_column_int(pStmt, 0);
18513:         if( len>40 ) len = 40;
18514:       }
18515:       sqlite3_finalize(pStmt);
18516:       pStmt = 0;
18517:       if( len ){
18518:         rx = sqlite3_prepare_v2(p->db,
18519:              "SELECT key, quote(value) "
18520:              "FROM temp.sqlite_parameters;", -1, &pStmt, 0);
18521:         while( sqlite3_step(pStmt)==SQLITE_ROW ){
18522:           utf8_printf(p->out, "%-*s %s\n", len, sqlite3_column_text(pStmt,0),
18523:                       sqlite3_column_text(pStmt,1));
18524:         }
18525:         sqlite3_finalize(pStmt);
18526:       }
18527:     }else
18528: 
18529:     /* .parameter init
18530:     ** Make sure the TEMP table used to hold bind parameters exists.
18531:     ** Create it if necessary.
18532:     */
18533:     if( nArg==2 && strcmp(azArg[1],"init")==0 ){
18534:       bind_table_init(p);
18535:     }else
18536: 
18537:     /* .parameter set NAME VALUE
18538:     ** Set or reset a bind parameter.  NAME should be the full parameter
18539:     ** name exactly as it appears in the query.  (ex: $abc, @def).  The
18540:     ** VALUE can be in either SQL literal notation, or if not it will be
18541:     ** understood to be a text string.
18542:     */
18543:     if( nArg==4 && strcmp(azArg[1],"set")==0 ){
18544:       int rx;
18545:       char *zSql;
18546:       sqlite3_stmt *pStmt;
18547:       const char *zKey = azArg[2];
18548:       const char *zValue = azArg[3];
18549:       bind_table_init(p);
18550:       zSql = sqlite3_mprintf(
18551:                   "REPLACE INTO temp.sqlite_parameters(key,value)"
18552:                   "VALUES(%Q,%s);", zKey, zValue);
18553:       if( zSql==0 ) shell_out_of_memory();
18554:       pStmt = 0;
18555:       rx = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
18556:       sqlite3_free(zSql);
18557:       if( rx!=SQLITE_OK ){
18558:         sqlite3_finalize(pStmt);
18559:         pStmt = 0;
18560:         zSql = sqlite3_mprintf(
18561:                    "REPLACE INTO temp.sqlite_parameters(key,value)"
18562:                    "VALUES(%Q,%Q);", zKey, zValue);
18563:         if( zSql==0 ) shell_out_of_memory();
18564:         rx = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
18565:         sqlite3_free(zSql);
18566:         if( rx!=SQLITE_OK ){
18567:           utf8_printf(p->out, "Error: %s\n", sqlite3_errmsg(p->db));
18568:           sqlite3_finalize(pStmt);
18569:           pStmt = 0;
18570:           rc = 1;
18571:         }
18572:       }
18573:       sqlite3_step(pStmt);
18574:       sqlite3_finalize(pStmt);
18575:     }else
18576: 
18577:     /* .parameter unset NAME
18578:     ** Remove the NAME binding from the parameter binding table, if it
18579:     ** exists.
18580:     */
18581:     if( nArg==3 && strcmp(azArg[1],"unset")==0 ){
18582:       char *zSql = sqlite3_mprintf(
18583:           "DELETE FROM temp.sqlite_parameters WHERE key=%Q", azArg[2]);
18584:       if( zSql==0 ) shell_out_of_memory();
18585:       sqlite3_exec(p->db, zSql, 0, 0, 0);
18586:       sqlite3_free(zSql);
18587:     }else
18588:     /* If no command name matches, show a syntax error */
18589:     parameter_syntax_error:
18590:     showHelp(p->out, "parameter");
18591:   }else
18592: 
18593:   if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 ){
18594:     int i;
18595:     for(i=1; i<nArg; i++){
18596:       if( i>1 ) raw_printf(p->out, " ");
18597:       utf8_printf(p->out, "%s", azArg[i]);
18598:     }
18599:     raw_printf(p->out, "\n");
18600:   }else
18601: 
18602: #ifndef SQLITE_OMIT_PROGRESS_CALLBACK
18603:   if( c=='p' && n>=3 && strncmp(azArg[0], "progress", n)==0 ){
18604:     int i;
18605:     int nn = 0;
18606:     p->flgProgress = 0;
18607:     p->mxProgress = 0;
18608:     p->nProgress = 0;
18609:     for(i=1; i<nArg; i++){
18610:       const char *z = azArg[i];
18611:       if( z[0]=='-' ){
18612:         z++;
18613:         if( z[0]=='-' ) z++;
18614:         if( strcmp(z,"quiet")==0 || strcmp(z,"q")==0 ){
18615:           p->flgProgress |= SHELL_PROGRESS_QUIET;
18616:           continue;
18617:         }
18618:         if( strcmp(z,"reset")==0 ){
18619:           p->flgProgress |= SHELL_PROGRESS_RESET;
18620:           continue;
18621:         }
18622:         if( strcmp(z,"once")==0 ){
18623:           p->flgProgress |= SHELL_PROGRESS_ONCE;
18624:           continue;
18625:         }
18626:         if( strcmp(z,"limit")==0 ){
18627:           if( i+1>=nArg ){
18628:             utf8_printf(stderr, "Error: missing argument on --limit\n");
18629:             rc = 1;
18630:             goto meta_command_exit;
18631:           }else{
18632:             p->mxProgress = (int)integerValue(azArg[++i]);
18633:           }
18634:           continue;
18635:         }
18636:         utf8_printf(stderr, "Error: unknown option: \"%s\"\n", azArg[i]);
18637:         rc = 1;
18638:         goto meta_command_exit;
18639:       }else{
18640:         nn = (int)integerValue(z);
18641:       }
18642:     }
18643:     open_db(p, 0);
18644:     sqlite3_progress_handler(p->db, nn, progress_handler, p);
18645:   }else
18646: #endif /* SQLITE_OMIT_PROGRESS_CALLBACK */
18647: 
18648:   if( c=='p' && strncmp(azArg[0], "prompt", n)==0 ){
18649:     if( nArg >= 2) {
18650:       strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);
18651:     }
18652:     if( nArg >= 3) {
18653:       strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);
18654:     }
18655:   }else
18656: 
18657:   if( c=='q' && strncmp(azArg[0], "quit", n)==0 ){
18658:     rc = 2;
18659:   }else
18660: 
18661:   if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 ){
18662:     FILE *inSaved = p->in;
18663:     int savedLineno = p->lineno;
18664:     if( nArg!=2 ){
18665:       raw_printf(stderr, "Usage: .read FILE\n");
18666:       rc = 1;
18667:       goto meta_command_exit;
18668:     }
18669:     if( notNormalFile(azArg[1])
18670:      || (p->in = fopen(azArg[1], "rb"))==0
18671:     ){
18672:       utf8_printf(stderr,"Error: cannot open \"%s\"\n", azArg[1]);
18673:       rc = 1;
18674:     }else{
18675:       rc = process_input(p);
18676:       fclose(p->in);
18677:     }
18678:     p->in = inSaved;
18679:     p->lineno = savedLineno;
18680:   }else
18681: 
18682:   if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 ){
18683:     const char *zSrcFile;
18684:     const char *zDb;
18685:     sqlite3 *pSrc;
18686:     sqlite3_backup *pBackup;
18687:     int nTimeout = 0;
18688: 
18689:     if( nArg==2 ){
18690:       zSrcFile = azArg[1];
18691:       zDb = "main";
18692:     }else if( nArg==3 ){
18693:       zSrcFile = azArg[2];
18694:       zDb = azArg[1];
18695:     }else{
18696:       raw_printf(stderr, "Usage: .restore ?DB? FILE\n");
18697:       rc = 1;
18698:       goto meta_command_exit;
18699:     }
18700:     rc = sqlite3_open(zSrcFile, &pSrc);
18701:     if( rc!=SQLITE_OK ){
18702:       utf8_printf(stderr, "Error: cannot open \"%s\"\n", zSrcFile);
18703:       close_db(pSrc);
18704:       return 1;
18705:     }
18706:     open_db(p, 0);
18707:     pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");
18708:     if( pBackup==0 ){
18709:       utf8_printf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));
18710:       close_db(pSrc);
18711:       return 1;
18712:     }
18713:     while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK
18714:           || rc==SQLITE_BUSY  ){
18715:       if( rc==SQLITE_BUSY ){
18716:         if( nTimeout++ >= 3 ) break;
18717:         sqlite3_sleep(100);
18718:       }
18719:     }
18720:     sqlite3_backup_finish(pBackup);
18721:     if( rc==SQLITE_DONE ){
18722:       rc = 0;
18723:     }else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){
18724:       raw_printf(stderr, "Error: source database is busy\n");
18725:       rc = 1;
18726:     }else{
18727:       utf8_printf(stderr, "Error: %s\n", sqlite3_errmsg(p->db));
18728:       rc = 1;
18729:     }
18730:     close_db(pSrc);
18731:   }else
18732: 
18733:   if( c=='s' && strncmp(azArg[0], "scanstats", n)==0 ){
18734:     if( nArg==2 ){
18735:       p->scanstatsOn = (u8)booleanValue(azArg[1]);
18736: #ifndef SQLITE_ENABLE_STMT_SCANSTATUS
18737:       raw_printf(stderr, "Warning: .scanstats not available in this build.\n");
18738: #endif
18739:     }else{
18740:       raw_printf(stderr, "Usage: .scanstats on|off\n");
18741:       rc = 1;
18742:     }
18743:   }else
18744: 
18745:   if( c=='s' && strncmp(azArg[0], "schema", n)==0 ){
18746:     ShellText sSelect;
18747:     ShellState data;
18748:     char *zErrMsg = 0;
18749:     const char *zDiv = "(";
18750:     const char *zName = 0;
18751:     int bDebug = 0;
18752:     int ii;
18753: 
18754:     open_db(p, 0);
18755:     memcpy(&data, p, sizeof(data));
18756:     data.showHeader = 0;
18757:     data.cMode = data.mode = MODE_Semi;
18758:     initText(&sSelect);
18759:     for(ii=1; ii<nArg; ii++){
18760:       if( optionMatch(azArg[ii],"indent") ){
18761:         data.cMode = data.mode = MODE_Pretty;
18762:       }else if( optionMatch(azArg[ii],"debug") ){
18763:         bDebug = 1;
18764:       }else if( zName==0 ){
18765:         zName = azArg[ii];
18766:       }else{
18767:         raw_printf(stderr, "Usage: .schema ?--indent? ?LIKE-PATTERN?\n");
18768:         rc = 1;
18769:         goto meta_command_exit;
18770:       }
18771:     }
18772:     if( zName!=0 ){
18773:       int isSchema = sqlite3_strlike(zName, "sqlite_master", '\\')==0
18774:                   || sqlite3_strlike(zName, "sqlite_schema", '\\')==0
18775:                   || sqlite3_strlike(zName,"sqlite_temp_master", '\\')==0
18776:                   || sqlite3_strlike(zName,"sqlite_temp_schema", '\\')==0;
18777:       if( isSchema ){
18778:         char *new_argv[2], *new_colv[2];
18779:         new_argv[0] = sqlite3_mprintf(
18780:                       "CREATE TABLE %s (\n"
18781:                       "  type text,\n"
18782:                       "  name text,\n"
18783:                       "  tbl_name text,\n"
18784:                       "  rootpage integer,\n"
18785:                       "  sql text\n"
18786:                       ")", zName);
18787:         new_argv[1] = 0;
18788:         new_colv[0] = "sql";
18789:         new_colv[1] = 0;
18790:         callback(&data, 1, new_argv, new_colv);
18791:         sqlite3_free(new_argv[0]);
18792:       }
18793:     }
18794:     if( zDiv ){
18795:       appendText(&sSelect, "SELECT sql FROM sqlite_master WHERE ", 0);
18796:       if( zName ){
18797:         char *zQarg = sqlite3_mprintf("%Q", zName);
18798:         int bGlob = strchr(zName, '*') != 0 || strchr(zName, '?') != 0 ||
18799:                     strchr(zName, '[') != 0;
18800:         if( strchr(zName, '.') ){
18801:           appendText(&sSelect, "lower(printf('%s.%s',sname,tbl_name))", 0);
18802:         }else{
18803:           appendText(&sSelect, "lower(tbl_name)", 0);
18804:         }
18805:         appendText(&sSelect, bGlob ? " GLOB " : " LIKE ", 0);
18806:         appendText(&sSelect, zQarg, 0);
18807:         if( !bGlob ){
18808:           appendText(&sSelect, " ESCAPE '\\' ", 0);
18809:         }
18810:         appendText(&sSelect, " AND ", 0);
18811:         sqlite3_free(zQarg);
18812:       }
18813:       appendText(&sSelect, "type!='meta' AND sql IS NOT NULL"
18814:                            " ORDER BY name", 0);
18815:       if( bDebug ){
18816:         utf8_printf(p->out, "SQL: %s;\n", sSelect.z);
18817:       }else{
18818:         rc = sqlite3_exec(p->db, sSelect.z, callback, &data, &zErrMsg);
18819:       }
18820:       freeText(&sSelect);
18821:     }
18822:     if( zErrMsg ){
18823:       utf8_printf(stderr,"Error: %s\n", zErrMsg);
18824:       sqlite3_free(zErrMsg);
18825:       rc = 1;
18826:     }else if( rc != SQLITE_OK ){
18827:       raw_printf(stderr,"Error: querying schema information\n");
18828:       rc = 1;
18829:     }else{
18830:       rc = 0;
18831:     }
18832:   }else
18833: 
18834: #if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_SELECTTRACE)
18835:   if( c=='s' && n==11 && strncmp(azArg[0], "selecttrace", n)==0 ){
18836:     sqlite3_unsupported_selecttrace = nArg>=2 ? (int)integerValue(azArg[1]) : 0xffff;
18837:   }else
18838: #endif
18839: 
18840: #if defined(SQLITE_ENABLE_SESSION)
18841:   if( c=='s' && strncmp(azArg[0],"session",n)==0 && n>=3 ){
18842:     OpenSession *pSession = &p->aSession[0];
18843:     char **azCmd = &azArg[1];
18844:     int iSes = 0;
18845:     int nCmd = nArg - 1;
18846:     int i;
18847:     if( nArg<=1 ) goto session_syntax_error;
18848:     open_db(p, 0);
18849:     if( nArg>=3 ){
18850:       for(iSes=0; iSes<p->nSession; iSes++){
18851:         if( strcmp(p->aSession[iSes].zName, azArg[1])==0 ) break;
18852:       }
18853:       if( iSes<p->nSession ){
18854:         pSession = &p->aSession[iSes];
18855:         azCmd++;
18856:         nCmd--;
18857:       }else{
18858:         pSession = &p->aSession[0];
18859:         iSes = 0;
18860:       }
18861:     }
18862: 
18863:     /* .session attach TABLE
18864:     ** Invoke the sqlite3session_attach() interface to attach a particular
18865:     ** table so that it is never filtered.
18866:     */
18867:     if( strcmp(azCmd[0],"attach")==0 ){
18868:       if( nCmd!=2 ) goto session_syntax_error;
18869:       if( pSession->p==0 ){
18870:         session_not_open:
18871:         raw_printf(stderr, "ERROR: No sessions are open\n");
18872:       }else{
18873:         rc = sqlite3session_attach(pSession->p, azCmd[1]);
18874:         if( rc ){
18875:           raw_printf(stderr, "ERROR: sqlite3session_attach() returns %d\n", rc);
18876:           rc = 0;
18877:         }
18878:       }
18879:     }else
18880: 
18881:     /* .session changeset FILE
18882:     ** .session patchset FILE
18883:     ** Write a changeset or patchset into a file.  The file is overwritten.
18884:     */
18885:     if( strcmp(azCmd[0],"changeset")==0 || strcmp(azCmd[0],"patchset")==0 ){
18886:       FILE *out = 0;
18887:       if( nCmd!=2 ) goto session_syntax_error;
18888:       if( pSession->p==0 ) goto session_not_open;
18889:       out = fopen(azCmd[1], "wb");
18890:       if( out==0 ){
18891:         utf8_printf(stderr, "ERROR: cannot open \"%s\" for writing\n",
18892:                     azCmd[1]);
18893:       }else{
18894:         int szChng;
18895:         void *pChng;
18896:         if( azCmd[0][0]=='c' ){
18897:           rc = sqlite3session_changeset(pSession->p, &szChng, &pChng);
18898:         }else{
18899:           rc = sqlite3session_patchset(pSession->p, &szChng, &pChng);
18900:         }
18901:         if( rc ){
18902:           printf("Error: error code %d\n", rc);
18903:           rc = 0;
18904:         }
18905:         if( pChng
18906:           && fwrite(pChng, szChng, 1, out)!=1 ){
18907:           raw_printf(stderr, "ERROR: Failed to write entire %d-byte output\n",
18908:                   szChng);
18909:         }
18910:         sqlite3_free(pChng);
18911:         fclose(out);
18912:       }
18913:     }else
18914: 
18915:     /* .session close
18916:     ** Close the identified session
18917:     */
18918:     if( strcmp(azCmd[0], "close")==0 ){
18919:       if( nCmd!=1 ) goto session_syntax_error;
18920:       if( p->nSession ){
18921:         session_close(pSession);
18922:         p->aSession[iSes] = p->aSession[--p->nSession];
18923:       }
18924:     }else
18925: 
18926:     /* .session enable ?BOOLEAN?
18927:     ** Query or set the enable flag
18928:     */
18929:     if( strcmp(azCmd[0], "enable")==0 ){
18930:       int ii;
18931:       if( nCmd>2 ) goto session_syntax_error;
18932:       ii = nCmd==1 ? -1 : booleanValue(azCmd[1]);
18933:       if( p->nSession ){
18934:         ii = sqlite3session_enable(pSession->p, ii);
18935:         utf8_printf(p->out, "session %s enable flag = %d\n",
18936:                     pSession->zName, ii);
18937:       }
18938:     }else
18939: 
18940:     /* .session filter GLOB ....
18941:     ** Set a list of GLOB patterns of table names to be excluded.
18942:     */
18943:     if( strcmp(azCmd[0], "filter")==0 ){
18944:       int ii, nByte;
18945:       if( nCmd<2 ) goto session_syntax_error;
18946:       if( p->nSession ){
18947:         for(ii=0; ii<pSession->nFilter; ii++){
18948:           sqlite3_free(pSession->azFilter[ii]);
18949:         }
18950:         sqlite3_free(pSession->azFilter);
18951:         nByte = sizeof(pSession->azFilter[0])*(nCmd-1);
18952:         pSession->azFilter = sqlite3_malloc( nByte );
18953:         if( pSession->azFilter==0 ){
18954:           raw_printf(stderr, "Error: out or memory\n");
18955:           exit(1);
18956:         }
18957:         for(ii=1; ii<nCmd; ii++){
18958:           pSession->azFilter[ii-1] = sqlite3_mprintf("%s", azCmd[ii]);
18959:         }
18960:         pSession->nFilter = ii-1;
18961:       }
18962:     }else
18963: 
18964:     /* .session indirect ?BOOLEAN?
18965:     ** Query or set the indirect flag
18966:     */
18967:     if( strcmp(azCmd[0], "indirect")==0 ){
18968:       int ii;
18969:       if( nCmd>2 ) goto session_syntax_error;
18970:       ii = nCmd==1 ? -1 : booleanValue(azCmd[1]);
18971:       if( p->nSession ){
18972:         ii = sqlite3session_indirect(pSession->p, ii);
18973:         utf8_printf(p->out, "session %s indirect flag = %d\n",
18974:                     pSession->zName, ii);
18975:       }
18976:     }else
18977: 
18978:     /* .session isempty
18979:     ** Determine if the session is empty
18980:     */
18981:     if( strcmp(azCmd[0], "isempty")==0 ){
18982:       int ii;
18983:       if( nCmd!=1 ) goto session_syntax_error;
18984:       if( p->nSession ){
18985:         ii = sqlite3session_isempty(pSession->p);
18986:         utf8_printf(p->out, "session %s isempty flag = %d\n",
18987:                     pSession->zName, ii);
18988:       }
18989:     }else
18990: 
18991:     /* .session list
18992:     ** List all currently open sessions
18993:     */
18994:     if( strcmp(azCmd[0],"list")==0 ){
18995:       for(i=0; i<p->nSession; i++){
18996:         utf8_printf(p->out, "%d %s\n", i, p->aSession[i].zName);
18997:       }
18998:     }else
18999: 
19000:     /* .session open DB NAME
19001:     ** Open a new session called NAME on the attached database DB.
19002:     ** DB is normally "main".
19003:     */
19004:     if( strcmp(azCmd[0],"open")==0 ){
19005:       char *zName;
19006:       if( nCmd!=3 ) goto session_syntax_error;
19007:       zName = azCmd[2];
19008:       if( zName[0]==0 ) goto session_syntax_error;
19009:       for(i=0; i<p->nSession; i++){
19010:         if( strcmp(p->aSession[i].zName,zName)==0 ){
19011:           utf8_printf(stderr, "Session \"%s\" already exists\n", zName);
19012:           goto meta_command_exit;
19013:         }
19014:       }
19015:       if( p->nSession>=ArraySize(p->aSession) ){
19016:         raw_printf(stderr, "Maximum of %d sessions\n", ArraySize(p->aSession));
19017:         goto meta_command_exit;
19018:       }
19019:       pSession = &p->aSession[p->nSession];
19020:       rc = sqlite3session_create(p->db, azCmd[1], &pSession->p);
19021:       if( rc ){
19022:         raw_printf(stderr, "Cannot open session: error code=%d\n", rc);
19023:         rc = 0;
19024:         goto meta_command_exit;
19025:       }
19026:       pSession->nFilter = 0;
19027:       sqlite3session_table_filter(pSession->p, session_filter, pSession);
19028:       p->nSession++;
19029:       pSession->zName = sqlite3_mprintf("%s", zName);
19030:     }else
19031:     /* If no command name matches, show a syntax error */
19032:     session_syntax_error:
19033:     showHelp(p->out, "session");
19034:   }else
19035: #endif
19036: 
19037: #ifdef SQLITE_DEBUG
19038:   /* Undocumented commands for internal testing.  Subject to change
19039:   ** without notice. */
19040:   if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 ){
19041:     if( strncmp(azArg[0]+9, "boolean", n-9)==0 ){
19042:       int i, v;
19043:       for(i=1; i<nArg; i++){
19044:         v = booleanValue(azArg[i]);
19045:         utf8_printf(p->out, "%s: %d 0x%x\n", azArg[i], v, v);
19046:       }
19047:     }
19048:     if( strncmp(azArg[0]+9, "integer", n-9)==0 ){
19049:       int i; sqlite3_int64 v;
19050:       for(i=1; i<nArg; i++){
19051:         char zBuf[200];
19052:         v = integerValue(azArg[i]);
19053:         sqlite3_snprintf(sizeof(zBuf),zBuf,"%s: %lld 0x%llx\n", azArg[i],v,v);
19054:         utf8_printf(p->out, "%s", zBuf);
19055:       }
19056:     }
19057:   }else
19058: #endif
19059: 
19060:   if( c=='s' && n>=4 && strncmp(azArg[0],"selftest",n)==0 ){
19061:     int bIsInit = 0;         /* True to initialize the SELFTEST table */
19062:     int bVerbose = 0;        /* Verbose output */
19063:     int bSelftestExists;     /* True if SELFTEST already exists */
19064:     int i, k;                /* Loop counters */
19065:     int nTest = 0;           /* Number of tests runs */
19066:     int nErr = 0;            /* Number of errors seen */
19067:     ShellText str;           /* Answer for a query */
19068:     sqlite3_stmt *pStmt = 0; /* Query against the SELFTEST table */
19069: 
19070:     open_db(p,0);
19071:     for(i=1; i<nArg; i++){
19072:       const char *z = azArg[i];
19073:       if( z[0]=='-' && z[1]=='-' ) z++;
19074:       if( strcmp(z,"-init")==0 ){
19075:         bIsInit = 1;
19076:       }else
19077:       if( strcmp(z,"-v")==0 ){
19078:         bVerbose++;
19079:       }else
19080:       {
19081:         utf8_printf(stderr, "Unknown option \"%s\" on \"%s\"\n",
19082:                     azArg[i], azArg[0]);
19083:         raw_printf(stderr, "Should be one of: --init -v\n");
19084:         rc = 1;
19085:         goto meta_command_exit;
19086:       }
19087:     }
19088:     if( sqlite3_table_column_metadata(p->db,"main","selftest",0,0,0,0,0,0)
19089:            != SQLITE_OK ){
19090:       bSelftestExists = 0;
19091:     }else{
19092:       bSelftestExists = 1;
19093:     }
19094:     if( bIsInit ){
19095:       createSelftestTable(p);
19096:       bSelftestExists = 1;
19097:     }
19098:     initText(&str);
19099:     appendText(&str, "x", 0);
19100:     for(k=bSelftestExists; k>=0; k--){
19101:       if( k==1 ){
19102:         rc = sqlite3_prepare_v2(p->db,
19103:             "SELECT tno,op,cmd,ans FROM selftest ORDER BY tno",
19104:             -1, &pStmt, 0);
19105:       }else{
19106:         rc = sqlite3_prepare_v2(p->db,
19107:           "VALUES(0,'memo','Missing SELFTEST table - default checks only',''),"
19108:           "      (1,'run','PRAGMA integrity_check','ok')",
19109:           -1, &pStmt, 0);
19110:       }
19111:       if( rc ){
19112:         raw_printf(stderr, "Error querying the selftest table\n");
19113:         rc = 1;
19114:         sqlite3_finalize(pStmt);
19115:         goto meta_command_exit;
19116:       }
19117:       for(i=1; sqlite3_step(pStmt)==SQLITE_ROW; i++){
19118:         int tno = sqlite3_column_int(pStmt, 0);
19119:         const char *zOp = (const char*)sqlite3_column_text(pStmt, 1);
19120:         const char *zSql = (const char*)sqlite3_column_text(pStmt, 2);
19121:         const char *zAns = (const char*)sqlite3_column_text(pStmt, 3);
19122: 
19123:         k = 0;
19124:         if( bVerbose>0 ){
19125:           char *zQuote = sqlite3_mprintf("%q", zSql);
19126:           printf("%d: %s %s\n", tno, zOp, zSql);
19127:           sqlite3_free(zQuote);
19128:         }
19129:         if( strcmp(zOp,"memo")==0 ){
19130:           utf8_printf(p->out, "%s\n", zSql);
19131:         }else
19132:         if( strcmp(zOp,"run")==0 ){
19133:           char *zErrMsg = 0;
19134:           str.n = 0;
19135:           str.z[0] = 0;
19136:           rc = sqlite3_exec(p->db, zSql, captureOutputCallback, &str, &zErrMsg);
19137:           nTest++;
19138:           if( bVerbose ){
19139:             utf8_printf(p->out, "Result: %s\n", str.z);
19140:           }
19141:           if( rc || zErrMsg ){
19142:             nErr++;
19143:             rc = 1;
19144:             utf8_printf(p->out, "%d: error-code-%d: %s\n", tno, rc, zErrMsg);
19145:             sqlite3_free(zErrMsg);
19146:           }else if( strcmp(zAns,str.z)!=0 ){
19147:             nErr++;
19148:             rc = 1;
19149:             utf8_printf(p->out, "%d: Expected: [%s]\n", tno, zAns);
19150:             utf8_printf(p->out, "%d:      Got: [%s]\n", tno, str.z);
19151:           }
19152:         }else
19153:         {
19154:           utf8_printf(stderr,
19155:             "Unknown operation \"%s\" on selftest line %d\n", zOp, tno);
19156:           rc = 1;
19157:           break;
19158:         }
19159:       } /* End loop over rows of content from SELFTEST */
19160:       sqlite3_finalize(pStmt);
19161:     } /* End loop over k */
19162:     freeText(&str);
19163:     utf8_printf(p->out, "%d errors out of %d tests\n", nErr, nTest);
19164:   }else
19165: 
19166:   if( c=='s' && strncmp(azArg[0], "separator", n)==0 ){
19167:     if( nArg<2 || nArg>3 ){
19168:       raw_printf(stderr, "Usage: .separator COL ?ROW?\n");
19169:       rc = 1;
19170:     }
19171:     if( nArg>=2 ){
19172:       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator,
19173:                        "%.*s", (int)ArraySize(p->colSeparator)-1, azArg[1]);
19174:     }
19175:     if( nArg>=3 ){
19176:       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator,
19177:                        "%.*s", (int)ArraySize(p->rowSeparator)-1, azArg[2]);
19178:     }
19179:   }else
19180: 
19181:   if( c=='s' && n>=4 && strncmp(azArg[0],"sha3sum",n)==0 ){
19182:     const char *zLike = 0;   /* Which table to checksum. 0 means everything */
19183:     int i;                   /* Loop counter */
19184:     int bSchema = 0;         /* Also hash the schema */
19185:     int bSeparate = 0;       /* Hash each table separately */
19186:     int iSize = 224;         /* Hash algorithm to use */
19187:     int bDebug = 0;          /* Only show the query that would have run */
19188:     sqlite3_stmt *pStmt;     /* For querying tables names */
19189:     char *zSql;              /* SQL to be run */
19190:     char *zSep;              /* Separator */
19191:     ShellText sSql;          /* Complete SQL for the query to run the hash */
19192:     ShellText sQuery;        /* Set of queries used to read all content */
19193:     open_db(p, 0);
19194:     for(i=1; i<nArg; i++){
19195:       const char *z = azArg[i];
19196:       if( z[0]=='-' ){
19197:         z++;
19198:         if( z[0]=='-' ) z++;
19199:         if( strcmp(z,"schema")==0 ){
19200:           bSchema = 1;
19201:         }else
19202:         if( strcmp(z,"sha3-224")==0 || strcmp(z,"sha3-256")==0
19203:          || strcmp(z,"sha3-384")==0 || strcmp(z,"sha3-512")==0
19204:         ){
19205:           iSize = atoi(&z[5]);
19206:         }else
19207:         if( strcmp(z,"debug")==0 ){
19208:           bDebug = 1;
19209:         }else
19210:         {
19211:           utf8_printf(stderr, "Unknown option \"%s\" on \"%s\"\n",
19212:                       azArg[i], azArg[0]);
19213:           showHelp(p->out, azArg[0]);
19214:           rc = 1;
19215:           goto meta_command_exit;
19216:         }
19217:       }else if( zLike ){
19218:         raw_printf(stderr, "Usage: .sha3sum ?OPTIONS? ?LIKE-PATTERN?\n");
19219:         rc = 1;
19220:         goto meta_command_exit;
19221:       }else{
19222:         zLike = z;
19223:         bSeparate = 1;
19224:         if( sqlite3_strlike("sqlite\\_%", zLike, '\\')==0 ) bSchema = 1;
19225:       }
19226:     }
19227:     if( bSchema ){
19228:       zSql = "SELECT lower(name) FROM sqlite_schema"
19229:              " WHERE type='table' AND coalesce(rootpage,0)>1"
19230:              " UNION ALL SELECT 'sqlite_schema'"
19231:              " ORDER BY 1 collate nocase";
19232:     }else{
19233:       zSql = "SELECT lower(name) FROM sqlite_schema"
19234:              " WHERE type='table' AND coalesce(rootpage,0)>1"
19235:              " AND name NOT LIKE 'sqlite_%'"
19236:              " ORDER BY 1 collate nocase";
19237:     }
19238:     sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
19239:     initText(&sQuery);
19240:     initText(&sSql);
19241:     appendText(&sSql, "WITH [sha3sum$query](a,b) AS(",0);
19242:     zSep = "VALUES(";
19243:     while( SQLITE_ROW==sqlite3_step(pStmt) ){
19244:       const char *zTab = (const char*)sqlite3_column_text(pStmt,0);
19245:       if( zLike && sqlite3_strlike(zLike, zTab, 0)!=0 ) continue;
19246:       if( strncmp(zTab, "sqlite_",7)!=0 ){
19247:         appendText(&sQuery,"SELECT * FROM ", 0);
19248:         appendText(&sQuery,zTab,'"');
19249:         appendText(&sQuery," NOT INDEXED;", 0);
19250:       }else if( strcmp(zTab, "sqlite_schema")==0 ){
19251:         appendText(&sQuery,"SELECT type,name,tbl_name,sql FROM sqlite_schema"
19252:                            " ORDER BY name;", 0);
19253:       }else if( strcmp(zTab, "sqlite_sequence")==0 ){
19254:         appendText(&sQuery,"SELECT name,seq FROM sqlite_sequence"
19255:                            " ORDER BY name;", 0);
19256:       }else if( strcmp(zTab, "sqlite_stat1")==0 ){
19257:         appendText(&sQuery,"SELECT tbl,idx,stat FROM sqlite_stat1"
19258:                            " ORDER BY tbl,idx;", 0);
19259:       }else if( strcmp(zTab, "sqlite_stat4")==0 ){
19260:         appendText(&sQuery, "SELECT * FROM ", 0);
19261:         appendText(&sQuery, zTab, 0);
19262:         appendText(&sQuery, " ORDER BY tbl, idx, rowid;\n", 0);
19263:       }
19264:       appendText(&sSql, zSep, 0);
19265:       appendText(&sSql, sQuery.z, '\'');
19266:       sQuery.n = 0;
19267:       appendText(&sSql, ",", 0);
19268:       appendText(&sSql, zTab, '\'');
19269:       zSep = "),(";
19270:     }
19271:     sqlite3_finalize(pStmt);
19272:     if( bSeparate ){
19273:       zSql = sqlite3_mprintf(
19274:           "%s))"
19275:           " SELECT lower(hex(sha3_query(a,%d))) AS hash, b AS label"
19276:           "   FROM [sha3sum$query]",
19277:           sSql.z, iSize);
19278:     }else{
19279:       zSql = sqlite3_mprintf(
19280:           "%s))"
19281:           " SELECT lower(hex(sha3_query(group_concat(a,''),%d))) AS hash"
19282:           "   FROM [sha3sum$query]",
19283:           sSql.z, iSize);
19284:     }
19285:     freeText(&sQuery);
19286:     freeText(&sSql);
19287:     if( bDebug ){
19288:       utf8_printf(p->out, "%s\n", zSql);
19289:     }else{
19290:       shell_exec(p, zSql, 0);
19291:     }
19292:     sqlite3_free(zSql);
19293:   }else
19294: 
19295: #ifndef SQLITE_NOHAVE_SYSTEM
19296:   if( c=='s'
19297:    && (strncmp(azArg[0], "shell", n)==0 || strncmp(azArg[0],"system",n)==0)
19298:   ){
19299:     char *zCmd;
19300:     int i, x;
19301:     if( nArg<2 ){
19302:       raw_printf(stderr, "Usage: .system COMMAND\n");
19303:       rc = 1;
19304:       goto meta_command_exit;
19305:     }
19306:     zCmd = sqlite3_mprintf(strchr(azArg[1],' ')==0?"%s":"\"%s\"", azArg[1]);
19307:     for(i=2; i<nArg; i++){
19308:       zCmd = sqlite3_mprintf(strchr(azArg[i],' ')==0?"%z %s":"%z \"%s\"",
19309:                              zCmd, azArg[i]);
19310:     }
19311:     x = system(zCmd);
19312:     sqlite3_free(zCmd);
19313:     if( x ) raw_printf(stderr, "System command returns %d\n", x);
19314:   }else
19315: #endif /* !defined(SQLITE_NOHAVE_SYSTEM) */
19316: 
19317:   if( c=='s' && strncmp(azArg[0], "show", n)==0 ){
19318:     static const char *azBool[] = { "off", "on", "trigger", "full"};
19319:     int i;
19320:     if( nArg!=1 ){
19321:       raw_printf(stderr, "Usage: .show\n");
19322:       rc = 1;
19323:       goto meta_command_exit;
19324:     }
19325:     utf8_printf(p->out, "%12.12s: %s\n","echo",
19326:                                   azBool[ShellHasFlag(p, SHFLG_Echo)]);
19327:     utf8_printf(p->out, "%12.12s: %s\n","eqp", azBool[p->autoEQP&3]);
19328:     utf8_printf(p->out, "%12.12s: %s\n","explain",
19329:          p->mode==MODE_Explain ? "on" : p->autoExplain ? "auto" : "off");
19330:     utf8_printf(p->out,"%12.12s: %s\n","headers", azBool[p->showHeader!=0]);
19331:     utf8_printf(p->out, "%12.12s: %s\n","mode", modeDescr[p->mode]);
19332:     utf8_printf(p->out, "%12.12s: ", "nullvalue");
19333:       output_c_string(p->out, p->nullValue);
19334:       raw_printf(p->out, "\n");
19335:     utf8_printf(p->out,"%12.12s: %s\n","output",
19336:             strlen30(p->outfile) ? p->outfile : "stdout");
19337:     utf8_printf(p->out,"%12.12s: ", "colseparator");
19338:       output_c_string(p->out, p->colSeparator);
19339:       raw_printf(p->out, "\n");
19340:     utf8_printf(p->out,"%12.12s: ", "rowseparator");
19341:       output_c_string(p->out, p->rowSeparator);
19342:       raw_printf(p->out, "\n");
19343:     utf8_printf(p->out, "%12.12s: %s\n","stats", azBool[p->statsOn!=0]);
19344:     utf8_printf(p->out, "%12.12s: ", "width");
19345:     for (i=0;i<p->nWidth;i++) {
19346:       raw_printf(p->out, "%d ", p->colWidth[i]);
19347:     }
19348:     raw_printf(p->out, "\n");
19349:     utf8_printf(p->out, "%12.12s: %s\n", "filename",
19350:                 p->zDbFilename ? p->zDbFilename : "");
19351:   }else
19352: 
19353:   if( c=='s' && strncmp(azArg[0], "stats", n)==0 ){
19354:     if( nArg==2 ){
19355:       p->statsOn = (u8)booleanValue(azArg[1]);
19356:     }else if( nArg==1 ){
19357:       display_stats(p->db, p, 0);
19358:     }else{
19359:       raw_printf(stderr, "Usage: .stats ?on|off?\n");
19360:       rc = 1;
19361:     }
19362:   }else
19363: 
19364:   if( (c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0)
19365:    || (c=='i' && (strncmp(azArg[0], "indices", n)==0
19366:                  || strncmp(azArg[0], "indexes", n)==0) )
19367:   ){
19368:     sqlite3_stmt *pStmt;
19369:     char **azResult;
19370:     int nRow, nAlloc;
19371:     int ii;
19372:     ShellText s;
19373:     initText(&s);
19374:     open_db(p, 0);
19375:     rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);
19376:     if( rc ){
19377:       sqlite3_finalize(pStmt);
19378:       return shellDatabaseError(p->db);
19379:     }
19380: 
19381:     if( nArg>2 && c=='i' ){
19382:       /* It is an historical accident that the .indexes command shows an error
19383:       ** when called with the wrong number of arguments whereas the .tables
19384:       ** command does not. */
19385:       raw_printf(stderr, "Usage: .indexes ?LIKE-PATTERN?\n");
19386:       rc = 1;
19387:       sqlite3_finalize(pStmt);
19388:       goto meta_command_exit;
19389:     }
19390:     for(ii=0; sqlite3_step(pStmt)==SQLITE_ROW; ii++){
19391:       const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);
19392:       if( zDbName==0 ) continue;
19393:       if( s.z && s.z[0] ) appendText(&s, " UNION ALL ", 0);
19394:       if( sqlite3_stricmp(zDbName, "main")==0 ){
19395:         appendText(&s, "SELECT name FROM ", 0);
19396:       }else{
19397:         appendText(&s, "SELECT ", 0);
19398:         appendText(&s, zDbName, '\'');
19399:         appendText(&s, "||'.'||name FROM ", 0);
19400:       }
19401:       appendText(&s, zDbName, '"');
19402:       appendText(&s, ".sqlite_schema ", 0);
19403:       if( c=='t' ){
19404:         appendText(&s," WHERE type IN ('table','view')"
19405:                       "   AND name NOT LIKE 'sqlite_%'"
19406:                       "   AND name LIKE ?1", 0);
19407:       }else{
19408:         appendText(&s," WHERE type='index'"
19409:                       "   AND tbl_name LIKE ?1", 0);
19410:       }
19411:     }
19412:     rc = sqlite3_finalize(pStmt);
19413:     appendText(&s, " ORDER BY 1", 0);
19414:     rc = sqlite3_prepare_v2(p->db, s.z, -1, &pStmt, 0);
19415:     freeText(&s);
19416:     if( rc ) return shellDatabaseError(p->db);
19417: 
19418:     /* Run the SQL statement prepared by the above block. Store the results
19419:     ** as an array of nul-terminated strings in azResult[].  */
19420:     nRow = nAlloc = 0;
19421:     azResult = 0;
19422:     if( nArg>1 ){
19423:       sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);
19424:     }else{
19425:       sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);
19426:     }
19427:     while( sqlite3_step(pStmt)==SQLITE_ROW ){
19428:       if( nRow>=nAlloc ){
19429:         char **azNew;
19430:         int n2 = nAlloc*2 + 10;
19431:         azNew = sqlite3_realloc64(azResult, sizeof(azResult[0])*n2);
19432:         if( azNew==0 ) shell_out_of_memory();
19433:         nAlloc = n2;
19434:         azResult = azNew;
19435:       }
19436:       azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));
19437:       if( 0==azResult[nRow] ) shell_out_of_memory();
19438:       nRow++;
19439:     }
19440:     if( sqlite3_finalize(pStmt)!=SQLITE_OK ){
19441:       rc = shellDatabaseError(p->db);
19442:     }
19443: 
19444:     /* Pretty-print the contents of array azResult[] to the output */
19445:     if( rc==0 && nRow>0 ){
19446:       int len, maxlen = 0;
19447:       int i, j;
19448:       int nPrintCol, nPrintRow;
19449:       for(i=0; i<nRow; i++){
19450:         len = strlen30(azResult[i]);
19451:         if( len>maxlen ) maxlen = len;
19452:       }
19453:       nPrintCol = 80/(maxlen+2);
19454:       if( nPrintCol<1 ) nPrintCol = 1;
19455:       nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;
19456:       for(i=0; i<nPrintRow; i++){
19457:         for(j=i; j<nRow; j+=nPrintRow){
19458:           char *zSp = j<nPrintRow ? "" : "  ";
19459:           utf8_printf(p->out, "%s%-*s", zSp, maxlen,
19460:                       azResult[j] ? azResult[j]:"");
19461:         }
19462:         raw_printf(p->out, "\n");
19463:       }
19464:     }
19465: 
19466:     for(ii=0; ii<nRow; ii++) sqlite3_free(azResult[ii]);
19467:     sqlite3_free(azResult);
19468:   }else
19469: 
19470:   /* Begin redirecting output to the file "testcase-out.txt" */
19471:   if( c=='t' && strcmp(azArg[0],"testcase")==0 ){
19472:     output_reset(p);
19473:     p->out = output_file_open("testcase-out.txt", 0);
19474:     if( p->out==0 ){
19475:       raw_printf(stderr, "Error: cannot open 'testcase-out.txt'\n");
19476:     }
19477:     if( nArg>=2 ){
19478:       sqlite3_snprintf(sizeof(p->zTestcase), p->zTestcase, "%s", azArg[1]);
19479:     }else{
19480:       sqlite3_snprintf(sizeof(p->zTestcase), p->zTestcase, "?");
19481:     }
19482:   }else
19483: 
19484: #ifndef SQLITE_UNTESTABLE
19485:   if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 ){
19486:     static const struct {
19487:        const char *zCtrlName;   /* Name of a test-control option */
19488:        int ctrlCode;            /* Integer code for that option */
19489:        const char *zUsage;      /* Usage notes */
19490:     } aCtrl[] = {
19491:       { "always",             SQLITE_TESTCTRL_ALWAYS,        "BOOLEAN"        },
19492:       { "assert",             SQLITE_TESTCTRL_ASSERT,        "BOOLEAN"        },
19493:     /*{ "benign_malloc_hooks",SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS, ""       },*/
19494:     /*{ "bitvec_test",        SQLITE_TESTCTRL_BITVEC_TEST,   ""             },*/
19495:       { "byteorder",          SQLITE_TESTCTRL_BYTEORDER,     ""               },
19496:       { "extra_schema_checks",SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS,"BOOLEAN"   },
19497:     /*{ "fault_install",      SQLITE_TESTCTRL_FAULT_INSTALL, ""             },*/
19498:       { "imposter",         SQLITE_TESTCTRL_IMPOSTER, "SCHEMA ON/OFF ROOTPAGE"},
19499:       { "internal_functions", SQLITE_TESTCTRL_INTERNAL_FUNCTIONS, "" },
19500:       { "localtime_fault",    SQLITE_TESTCTRL_LOCALTIME_FAULT,"BOOLEAN"       },
19501:       { "never_corrupt",      SQLITE_TESTCTRL_NEVER_CORRUPT, "BOOLEAN"        },
19502:       { "optimizations",      SQLITE_TESTCTRL_OPTIMIZATIONS, "DISABLE-MASK"   },
19503: #ifdef YYCOVERAGE
19504:       { "parser_coverage",    SQLITE_TESTCTRL_PARSER_COVERAGE, ""             },
19505: #endif
19506:       { "pending_byte",       SQLITE_TESTCTRL_PENDING_BYTE,  "OFFSET  "       },
19507:       { "prng_restore",       SQLITE_TESTCTRL_PRNG_RESTORE,  ""               },
19508:       { "prng_save",          SQLITE_TESTCTRL_PRNG_SAVE,     ""               },
19509:       { "prng_seed",          SQLITE_TESTCTRL_PRNG_SEED,     "SEED ?db?"      },
19510:     };
19511:     int testctrl = -1;
19512:     int iCtrl = -1;
19513:     int rc2 = 0;    /* 0: usage.  1: %d  2: %x  3: no-output */
19514:     int isOk = 0;
19515:     int i, n2;
19516:     const char *zCmd = 0;
19517: 
19518:     open_db(p, 0);
19519:     zCmd = nArg>=2 ? azArg[1] : "help";
19520: 
19521:     /* The argument can optionally begin with "-" or "--" */
19522:     if( zCmd[0]=='-' && zCmd[1] ){
19523:       zCmd++;
19524:       if( zCmd[0]=='-' && zCmd[1] ) zCmd++;
19525:     }
19526: 
19527:     /* --help lists all test-controls */
19528:     if( strcmp(zCmd,"help")==0 ){
19529:       utf8_printf(p->out, "Available test-controls:\n");
19530:       for(i=0; i<ArraySize(aCtrl); i++){
19531:         utf8_printf(p->out, "  .testctrl %s %s\n",
19532:                     aCtrl[i].zCtrlName, aCtrl[i].zUsage);
19533:       }
19534:       rc = 1;
19535:       goto meta_command_exit;
19536:     }
19537: 
19538:     /* convert testctrl text option to value. allow any unique prefix
19539:     ** of the option name, or a numerical value. */
19540:     n2 = strlen30(zCmd);
19541:     for(i=0; i<ArraySize(aCtrl); i++){
19542:       if( strncmp(zCmd, aCtrl[i].zCtrlName, n2)==0 ){
19543:         if( testctrl<0 ){
19544:           testctrl = aCtrl[i].ctrlCode;
19545:           iCtrl = i;
19546:         }else{
19547:           utf8_printf(stderr, "Error: ambiguous test-control: \"%s\"\n"
19548:                               "Use \".testctrl --help\" for help\n", zCmd);
19549:           rc = 1;
19550:           goto meta_command_exit;
19551:         }
19552:       }
19553:     }
19554:     if( testctrl<0 ){
19555:       utf8_printf(stderr,"Error: unknown test-control: %s\n"
19556:                          "Use \".testctrl --help\" for help\n", zCmd);
19557:     }else{
19558:       switch(testctrl){
19559: 
19560:         /* sqlite3_test_control(int, db, int) */
19561:         case SQLITE_TESTCTRL_OPTIMIZATIONS:
19562:           if( nArg==3 ){
19563:             int opt = (int)strtol(azArg[2], 0, 0);
19564:             rc2 = sqlite3_test_control(testctrl, p->db, opt);
19565:             isOk = 3;
19566:           }
19567:           break;
19568: 
19569:         /* sqlite3_test_control(int) */
19570:         case SQLITE_TESTCTRL_PRNG_SAVE:
19571:         case SQLITE_TESTCTRL_PRNG_RESTORE:
19572:         case SQLITE_TESTCTRL_PRNG_RESET:
19573:         case SQLITE_TESTCTRL_BYTEORDER:
19574:           if( nArg==2 ){
19575:             rc2 = sqlite3_test_control(testctrl);
19576:             isOk = testctrl==SQLITE_TESTCTRL_BYTEORDER ? 1 : 3;
19577:           }
19578:           break;
19579: 
19580:         /* sqlite3_test_control(int, uint) */
19581:         case SQLITE_TESTCTRL_PENDING_BYTE:
19582:           if( nArg==3 ){
19583:             unsigned int opt = (unsigned int)integerValue(azArg[2]);
19584:             rc2 = sqlite3_test_control(testctrl, opt);
19585:             isOk = 3;
19586:           }
19587:           break;
19588: 
19589:         /* sqlite3_test_control(int, int, sqlite3*) */
19590:         case SQLITE_TESTCTRL_PRNG_SEED:
19591:           if( nArg==3 || nArg==4 ){
19592:             int ii = (int)integerValue(azArg[2]);
19593:             sqlite3 *db;
19594:             if( ii==0 && strcmp(azArg[2],"random")==0 ){
19595:               sqlite3_randomness(sizeof(ii),&ii);
19596:               printf("-- random seed: %d\n", ii);
19597:             }
19598:             if( nArg==3 ){
19599:               db = 0;
19600:             }else{
19601:               db = p->db;
19602:               /* Make sure the schema has been loaded */
19603:               sqlite3_table_column_metadata(db, 0, "x", 0, 0, 0, 0, 0, 0);
19604:             }
19605:             rc2 = sqlite3_test_control(testctrl, ii, db);
19606:             isOk = 3;
19607:           }
19608:           break;
19609: 
19610:         /* sqlite3_test_control(int, int) */
19611:         case SQLITE_TESTCTRL_ASSERT:
19612:         case SQLITE_TESTCTRL_ALWAYS:
19613:           if( nArg==3 ){
19614:             int opt = booleanValue(azArg[2]);
19615:             rc2 = sqlite3_test_control(testctrl, opt);
19616:             isOk = 1;
19617:           }
19618:           break;
19619: 
19620:         /* sqlite3_test_control(int, int) */
19621:         case SQLITE_TESTCTRL_LOCALTIME_FAULT:
19622:         case SQLITE_TESTCTRL_NEVER_CORRUPT:
19623:           if( nArg==3 ){
19624:             int opt = booleanValue(azArg[2]);
19625:             rc2 = sqlite3_test_control(testctrl, opt);
19626:             isOk = 3;
19627:           }
19628:           break;
19629: 
19630:         /* sqlite3_test_control(sqlite3*) */
19631:         case SQLITE_TESTCTRL_INTERNAL_FUNCTIONS:
19632:           rc2 = sqlite3_test_control(testctrl, p->db);
19633:           isOk = 3;
19634:           break;
19635: 
19636:         case SQLITE_TESTCTRL_IMPOSTER:
19637:           if( nArg==5 ){
19638:             rc2 = sqlite3_test_control(testctrl, p->db,
19639:                           azArg[2],
19640:                           integerValue(azArg[3]),
19641:                           integerValue(azArg[4]));
19642:             isOk = 3;
19643:           }
19644:           break;
19645: 
19646: #ifdef YYCOVERAGE
19647:         case SQLITE_TESTCTRL_PARSER_COVERAGE:
19648:           if( nArg==2 ){
19649:             sqlite3_test_control(testctrl, p->out);
19650:             isOk = 3;
19651:           }
19652: #endif
19653:       }
19654:     }
19655:     if( isOk==0 && iCtrl>=0 ){
19656:       utf8_printf(p->out, "Usage: .testctrl %s %s\n", zCmd,aCtrl[iCtrl].zUsage);
19657:       rc = 1;
19658:     }else if( isOk==1 ){
19659:       raw_printf(p->out, "%d\n", rc2);
19660:     }else if( isOk==2 ){
19661:       raw_printf(p->out, "0x%08x\n", rc2);
19662:     }
19663:   }else
19664: #endif /* !defined(SQLITE_UNTESTABLE) */
19665: 
19666:   if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 ){
19667:     open_db(p, 0);
19668:     sqlite3_busy_timeout(p->db, nArg>=2 ? (int)integerValue(azArg[1]) : 0);
19669:   }else
19670: 
19671:   if( c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0 ){
19672:     if( nArg==2 ){
19673:       enableTimer = booleanValue(azArg[1]);
19674:       if( enableTimer && !HAS_TIMER ){
19675:         raw_printf(stderr, "Error: timer not available on this system.\n");
19676:         enableTimer = 0;
19677:       }
19678:     }else{
19679:       raw_printf(stderr, "Usage: .timer on|off\n");
19680:       rc = 1;
19681:     }
19682:   }else
19683: 
19684: #ifndef SQLITE_OMIT_TRACE
19685:   if( c=='t' && strncmp(azArg[0], "trace", n)==0 ){
19686:     int mType = 0;
19687:     int jj;
19688:     open_db(p, 0);
19689:     for(jj=1; jj<nArg; jj++){
19690:       const char *z = azArg[jj];
19691:       if( z[0]=='-' ){
19692:         if( optionMatch(z, "expanded") ){
19693:           p->eTraceType = SHELL_TRACE_EXPANDED;
19694:         }
19695: #ifdef SQLITE_ENABLE_NORMALIZE
19696:         else if( optionMatch(z, "normalized") ){
19697:           p->eTraceType = SHELL_TRACE_NORMALIZED;
19698:         }
19699: #endif
19700:         else if( optionMatch(z, "plain") ){
19701:           p->eTraceType = SHELL_TRACE_PLAIN;
19702:         }
19703:         else if( optionMatch(z, "profile") ){
19704:           mType |= SQLITE_TRACE_PROFILE;
19705:         }
19706:         else if( optionMatch(z, "row") ){
19707:           mType |= SQLITE_TRACE_ROW;
19708:         }
19709:         else if( optionMatch(z, "stmt") ){
19710:           mType |= SQLITE_TRACE_STMT;
19711:         }
19712:         else if( optionMatch(z, "close") ){
19713:           mType |= SQLITE_TRACE_CLOSE;
19714:         }
19715:         else {
19716:           raw_printf(stderr, "Unknown option \"%s\" on \".trace\"\n", z);
19717:           rc = 1;
19718:           goto meta_command_exit;
19719:         }
19720:       }else{
19721:         output_file_close(p->traceOut);
19722:         p->traceOut = output_file_open(azArg[1], 0);
19723:       }
19724:     }
19725:     if( p->traceOut==0 ){
19726:       sqlite3_trace_v2(p->db, 0, 0, 0);
19727:     }else{
19728:       if( mType==0 ) mType = SQLITE_TRACE_STMT;
19729:       sqlite3_trace_v2(p->db, mType, sql_trace_callback, p);
19730:     }
19731:   }else
19732: #endif /* !defined(SQLITE_OMIT_TRACE) */
19733: 
19734: #if defined(SQLITE_DEBUG) && !defined(SQLITE_OMIT_VIRTUALTABLE)
19735:   if( c=='u' && strncmp(azArg[0], "unmodule", n)==0 ){
19736:     int ii;
19737:     int lenOpt;
19738:     char *zOpt;
19739:     if( nArg<2 ){
19740:       raw_printf(stderr, "Usage: .unmodule [--allexcept] NAME ...\n");
19741:       rc = 1;
19742:       goto meta_command_exit;
19743:     }
19744:     open_db(p, 0);
19745:     zOpt = azArg[1];
19746:     if( zOpt[0]=='-' && zOpt[1]=='-' && zOpt[2]!=0 ) zOpt++;
19747:     lenOpt = (int)strlen(zOpt);
19748:     if( lenOpt>=3 && strncmp(zOpt, "-allexcept",lenOpt)==0 ){
19749:       assert( azArg[nArg]==0 );
19750:       sqlite3_drop_modules(p->db, nArg>2 ? (const char**)(azArg+2) : 0);
19751:     }else{
19752:       for(ii=1; ii<nArg; ii++){
19753:         sqlite3_create_module(p->db, azArg[ii], 0, 0);
19754:       }
19755:     }
19756:   }else
19757: #endif
19758: 
19759: #if SQLITE_USER_AUTHENTICATION
19760:   if( c=='u' && strncmp(azArg[0], "user", n)==0 ){
19761:     if( nArg<2 ){
19762:       raw_printf(stderr, "Usage: .user SUBCOMMAND ...\n");
19763:       rc = 1;
19764:       goto meta_command_exit;
19765:     }
19766:     open_db(p, 0);
19767:     if( strcmp(azArg[1],"login")==0 ){
19768:       if( nArg!=4 ){
19769:         raw_printf(stderr, "Usage: .user login USER PASSWORD\n");
19770:         rc = 1;
19771:         goto meta_command_exit;
19772:       }
19773:       rc = sqlite3_user_authenticate(p->db, azArg[2], azArg[3],
19774:                                      strlen30(azArg[3]));
19775:       if( rc ){
19776:         utf8_printf(stderr, "Authentication failed for user %s\n", azArg[2]);
19777:         rc = 1;
19778:       }
19779:     }else if( strcmp(azArg[1],"add")==0 ){
19780:       if( nArg!=5 ){
19781:         raw_printf(stderr, "Usage: .user add USER PASSWORD ISADMIN\n");
19782:         rc = 1;
19783:         goto meta_command_exit;
19784:       }
19785:       rc = sqlite3_user_add(p->db, azArg[2], azArg[3], strlen30(azArg[3]),
19786:                             booleanValue(azArg[4]));
19787:       if( rc ){
19788:         raw_printf(stderr, "User-Add failed: %d\n", rc);
19789:         rc = 1;
19790:       }
19791:     }else if( strcmp(azArg[1],"edit")==0 ){
19792:       if( nArg!=5 ){
19793:         raw_printf(stderr, "Usage: .user edit USER PASSWORD ISADMIN\n");
19794:         rc = 1;
19795:         goto meta_command_exit;
19796:       }
19797:       rc = sqlite3_user_change(p->db, azArg[2], azArg[3], strlen30(azArg[3]),
19798:                               booleanValue(azArg[4]));
19799:       if( rc ){
19800:         raw_printf(stderr, "User-Edit failed: %d\n", rc);
19801:         rc = 1;
19802:       }
19803:     }else if( strcmp(azArg[1],"delete")==0 ){
19804:       if( nArg!=3 ){
19805:         raw_printf(stderr, "Usage: .user delete USER\n");
19806:         rc = 1;
19807:         goto meta_command_exit;
19808:       }
19809:       rc = sqlite3_user_delete(p->db, azArg[2]);
19810:       if( rc ){
19811:         raw_printf(stderr, "User-Delete failed: %d\n", rc);
19812:         rc = 1;
19813:       }
19814:     }else{
19815:       raw_printf(stderr, "Usage: .user login|add|edit|delete ...\n");
19816:       rc = 1;
19817:       goto meta_command_exit;
19818:     }
19819:   }else
19820: #endif /* SQLITE_USER_AUTHENTICATION */
19821: 
19822:   if( c=='v' && strncmp(azArg[0], "version", n)==0 ){
19823:     utf8_printf(p->out, "SQLite %s %s\n" /*extra-version-info*/,
19824:         sqlite3_libversion(), sqlite3_sourceid());
19825: #if SQLITE_HAVE_ZLIB
19826:     utf8_printf(p->out, "zlib version %s\n", zlibVersion());
19827: #endif
19828: #define CTIMEOPT_VAL_(opt) #opt
19829: #define CTIMEOPT_VAL(opt) CTIMEOPT_VAL_(opt)
19830: #if defined(__clang__) && defined(__clang_major__)
19831:     utf8_printf(p->out, "clang-" CTIMEOPT_VAL(__clang_major__) "."
19832:                     CTIMEOPT_VAL(__clang_minor__) "."
19833:                     CTIMEOPT_VAL(__clang_patchlevel__) "\n");
19834: #elif defined(_MSC_VER)
19835:     utf8_printf(p->out, "msvc-" CTIMEOPT_VAL(_MSC_VER) "\n");
19836: #elif defined(__GNUC__) && defined(__VERSION__)
19837:     utf8_printf(p->out, "gcc-" __VERSION__ "\n");
19838: #endif
19839:   }else
19840: 
19841:   if( c=='v' && strncmp(azArg[0], "vfsinfo", n)==0 ){
19842:     const char *zDbName = nArg==2 ? azArg[1] : "main";
19843:     sqlite3_vfs *pVfs = 0;
19844:     if( p->db ){
19845:       sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFS_POINTER, &pVfs);
19846:       if( pVfs ){
19847:         utf8_printf(p->out, "vfs.zName      = \"%s\"\n", pVfs->zName);
19848:         raw_printf(p->out, "vfs.iVersion   = %d\n", pVfs->iVersion);
19849:         raw_printf(p->out, "vfs.szOsFile   = %d\n", pVfs->szOsFile);
19850:         raw_printf(p->out, "vfs.mxPathname = %d\n", pVfs->mxPathname);
19851:       }
19852:     }
19853:   }else
19854: 
19855:   if( c=='v' && strncmp(azArg[0], "vfslist", n)==0 ){
19856:     sqlite3_vfs *pVfs;
19857:     sqlite3_vfs *pCurrent = 0;
19858:     if( p->db ){
19859:       sqlite3_file_control(p->db, "main", SQLITE_FCNTL_VFS_POINTER, &pCurrent);
19860:     }
19861:     for(pVfs=sqlite3_vfs_find(0); pVfs; pVfs=pVfs->pNext){
19862:       utf8_printf(p->out, "vfs.zName      = \"%s\"%s\n", pVfs->zName,
19863:            pVfs==pCurrent ? "  <--- CURRENT" : "");
19864:       raw_printf(p->out, "vfs.iVersion   = %d\n", pVfs->iVersion);
19865:       raw_printf(p->out, "vfs.szOsFile   = %d\n", pVfs->szOsFile);
19866:       raw_printf(p->out, "vfs.mxPathname = %d\n", pVfs->mxPathname);
19867:       if( pVfs->pNext ){
19868:         raw_printf(p->out, "-----------------------------------\n");
19869:       }
19870:     }
19871:   }else
19872: 
19873:   if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 ){
19874:     const char *zDbName = nArg==2 ? azArg[1] : "main";
19875:     char *zVfsName = 0;
19876:     if( p->db ){
19877:       sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);
19878:       if( zVfsName ){
19879:         utf8_printf(p->out, "%s\n", zVfsName);
19880:         sqlite3_free(zVfsName);
19881:       }
19882:     }
19883:   }else
19884: 
19885: #if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)
19886:   if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 ){
19887:     sqlite3WhereTrace = nArg>=2 ? booleanValue(azArg[1]) : 0xff;
19888:   }else
19889: #endif
19890: 
19891:   if( c=='w' && strncmp(azArg[0], "width", n)==0 ){
19892:     int j;
19893:     assert( nArg<=ArraySize(azArg) );
19894:     p->nWidth = nArg-1;
19895:     p->colWidth = realloc(p->colWidth, p->nWidth*sizeof(int)*2);
19896:     if( p->colWidth==0 && p->nWidth>0 ) shell_out_of_memory();
19897:     if( p->nWidth ) p->actualWidth = &p->colWidth[p->nWidth];
19898:     for(j=1; j<nArg; j++){
19899:       p->colWidth[j-1] = (int)integerValue(azArg[j]);
19900:     }
19901:   } else {
19902: #ifdef HAVE_LINENOISE
19903:     const char *error = NULL;
19904:     if (linenoiseParseOption((const char**) azArg, nArg, &error)) {
19905:       if (error) {
19906:         utf8_printf(stderr, "Error: %s\n", error);
19907:         rc = 1;
19908:       }
19909:     } else {
19910: #endif
19911:       utf8_printf(stderr, "Error: unknown command or invalid arguments: "
19912:         " \"%s\". Enter \".help\" for help\n", azArg[0]);
19913:       rc = 1;
19914: #ifdef HAVE_LINENOISE
19915:     }
19916: #endif
19917:   }
19918: 
19919: meta_command_exit:
19920:   if( p->outCount ){
19921:     p->outCount--;
19922:     if( p->outCount==0 ) output_reset(p);
19923:   }
19924:   return rc;
19925: }
19926: 
19927: /*
19928: ** Return TRUE if a semicolon occurs anywhere in the first N characters
19929: ** of string z[].
19930: */
19931: static int line_contains_semicolon(const char *z, int N){
19932:   int i;
19933:   for(i=0; i<N; i++){  if( z[i]==';' ) return 1; }
19934:   return 0;
19935: }
19936: 
19937: /*
19938: ** Test to see if a line consists entirely of whitespace.
19939: */
19940: static int _all_whitespace(const char *z){
19941:   for(; *z; z++){
19942:     if( IsSpace(z[0]) ) continue;
19943:     if( *z=='/' && z[1]=='*' ){
19944:       z += 2;
19945:       while( *z && (*z!='*' || z[1]!='/') ){ z++; }
19946:       if( *z==0 ) return 0;
19947:       z++;
19948:       continue;
19949:     }
19950:     if( *z=='-' && z[1]=='-' ){
19951:       z += 2;
19952:       while( *z && *z!='\n' ){ z++; }
19953:       if( *z==0 ) return 1;
19954:       continue;
19955:     }
19956:     return 0;
19957:   }
19958:   return 1;
19959: }
19960: 
19961: /*
19962: ** Return TRUE if the line typed in is an SQL command terminator other
19963: ** than a semi-colon.  The SQL Server style "go" command is understood
19964: ** as is the Oracle "/".
19965: */
19966: static int line_is_command_terminator(const char *zLine){
19967:   while( IsSpace(zLine[0]) ){ zLine++; };
19968:   // if( zLine[0]=='/' && _all_whitespace(&zLine[1]) ){
19969:   //   return 1;  /* Oracle */
19970:   // }
19971:   // if( ToLower(zLine[0])=='g' && ToLower(zLine[1])=='o'
19972:   //        && _all_whitespace(&zLine[2]) ){
19973:   //   return 1;  /* SQL Server */
19974:   // }
19975:   return 0;
19976: }
19977: 
19978: /*
19979: ** We need a default sqlite3_complete() implementation to use in case
19980: ** the shell is compiled with SQLITE_OMIT_COMPLETE.  The default assumes
19981: ** any arbitrary text is a complete SQL statement.  This is not very
19982: ** user-friendly, but it does seem to work.
19983: */
19984: #ifdef SQLITE_OMIT_COMPLETE
19985: #define sqlite3_complete(x) 1
19986: #endif
19987: 
19988: /*
19989: ** Return true if zSql is a complete SQL statement.  Return false if it
19990: ** ends in the middle of a string literal or C-style comment.
19991: */
19992: static int line_is_complete(char *zSql, int nSql){
19993:   int rc;
19994:   if( zSql==0 ) return 1;
19995:   zSql[nSql] = ';';
19996:   zSql[nSql+1] = 0;
19997:   rc = sqlite3_complete(zSql);
19998:   zSql[nSql] = 0;
19999:   return rc;
20000: }
20001: 
20002: /*
20003: ** Run a single line of SQL.  Return the number of errors.
20004: */
20005: static int runOneSqlLine(ShellState *p, char *zSql, FILE *in, int startline){
20006:   int rc;
20007:   char *zErrMsg = 0;
20008: 
20009:   open_db(p, 0);
20010:   if( ShellHasFlag(p,SHFLG_Backslash) ) resolve_backslashes(zSql);
20011:   if( p->flgProgress & SHELL_PROGRESS_RESET ) p->nProgress = 0;
20012:   BEGIN_TIMER;
20013:   rc = shell_exec(p, zSql, &zErrMsg);
20014:   END_TIMER;
20015:   if( rc || zErrMsg ){
20016:     char zPrefix[100];
20017:     if( in!=0 || !stdin_is_interactive ){
20018:       sqlite3_snprintf(sizeof(zPrefix), zPrefix,
20019:                        "Error: near line %d:", startline);
20020:     }else{
20021:       sqlite3_snprintf(sizeof(zPrefix), zPrefix, "Error:");
20022:     }
20023:     if( zErrMsg!=0 ){
20024:       utf8_printf(stderr, "%s %s\n", zPrefix, zErrMsg);
20025:       sqlite3_free(zErrMsg);
20026:       zErrMsg = 0;
20027:     }else{
20028:       utf8_printf(stderr, "%s %s\n", zPrefix, sqlite3_errmsg(p->db));
20029:     }
20030:     return 1;
20031:   }else if( ShellHasFlag(p, SHFLG_CountChanges) ){
20032:     raw_printf(p->out, "changes: %3d   total_changes: %d\n",
20033:             sqlite3_changes(p->db), sqlite3_total_changes(p->db));
20034:   }
20035:   return 0;
20036: }
20037: 
20038: 
20039: /*
20040: ** Read input from *in and process it.  If *in==0 then input
20041: ** is interactive - the user is typing it it.  Otherwise, input
20042: ** is coming from a file or device.  A prompt is issued and history
20043: ** is saved only if input is interactive.  An interrupt signal will
20044: ** cause this routine to exit immediately, unless input is interactive.
20045: **
20046: ** Return the number of errors.
20047: */
20048: static int process_input(ShellState *p){
20049:   char *zLine = 0;          /* A single input line */
20050:   char *zSql = 0;           /* Accumulated SQL text */
20051:   int nLine;                /* Length of current line */
20052:   int nSql = 0;             /* Bytes of zSql[] used */
20053:   int nAlloc = 0;           /* Allocated zSql[] space */
20054:   int nSqlPrior = 0;        /* Bytes of zSql[] used by prior line */
20055:   int rc;                   /* Error code */
20056:   int errCnt = 0;           /* Number of errors seen */
20057:   int startline = 0;        /* Line number for start of current input */
20058:   int numCtrlC = 0;
20059:   p->lineno = 0;
20060:   while( errCnt==0 || !bail_on_error || (p->in==0 && stdin_is_interactive) ){
20061:     fflush(p->out);
20062:     zLine = one_input_line(p->in, zLine, nSql>0);
20063:     if( zLine==0 ){
20064:       /* End of input */
20065:       if( p->in==0 && stdin_is_interactive ) printf("\n");
20066:       break;
20067:     }
20068:     if (*zLine == '\3') {
20069:       // ctrl c: reset sql statement
20070:       if (nSql == 0 && zLine[1] == '\0' && stdin_is_interactive) {
20071:         // if in interactive mode and we press ctrl c twice
20072:         // on an empty line, we exit
20073:         numCtrlC++;
20074:         if (numCtrlC >= 2) {
20075:           break;
20076:         }
20077:       }
20078:       nSql = 0;
20079:       continue;
20080:     } else {
20081:       numCtrlC = 0;
20082:     }
20083:     if( seenInterrupt ){
20084:       if( p->in!=0 ) break;
20085:       seenInterrupt = 0;
20086:     }
20087:     p->lineno++;
20088:     if( nSql==0 && _all_whitespace(zLine) ){
20089:       if( ShellHasFlag(p, SHFLG_Echo) ) printf("%s\n", zLine);
20090:       continue;
20091:     }
20092:     if( zLine && (zLine[0]=='.' || zLine[0]=='#') && nSql==0 ){
20093:       if( ShellHasFlag(p, SHFLG_Echo) ) printf("%s\n", zLine);
20094:       if( zLine[0]=='.' ){
20095:         rc = do_meta_command(zLine, p);
20096:         if( rc==2 ){ /* exit requested */
20097:           break;
20098:         }else if( rc ){
20099:           errCnt++;
20100:         }
20101:       }
20102:       continue;
20103:     }
20104:     if( line_is_command_terminator(zLine) && line_is_complete(zSql, nSql) ){
20105:       memcpy(zLine,";",2);
20106:     }
20107:     nLine = strlen30(zLine);
20108:     if( nSql+nLine+2>=nAlloc ){
20109:       nAlloc = nSql+nLine+100;
20110:       zSql = realloc(zSql, nAlloc);
20111:       if( zSql==0 ) shell_out_of_memory();
20112:     }
20113:     nSqlPrior = nSql;
20114:     if( nSql==0 ){
20115:       int i;
20116:       for(i=0; zLine[i] && IsSpace(zLine[i]); i++){}
20117:       assert( nAlloc>0 && zSql!=0 );
20118:       memcpy(zSql, zLine+i, nLine+1-i);
20119:       startline = p->lineno;
20120:       nSql = nLine-i;
20121:     }else{
20122:       zSql[nSql++] = '\n';
20123:       memcpy(zSql+nSql, zLine, nLine+1);
20124:       nSql += nLine;
20125:     }
20126:     if( nSql && line_contains_semicolon(&zSql[nSqlPrior], nSql-nSqlPrior)
20127:                 && sqlite3_complete(zSql) ){
20128:       errCnt += runOneSqlLine(p, zSql, p->in, startline);
20129:       nSql = 0;
20130:       if( p->outCount ){
20131:         output_reset(p);
20132:         p->outCount = 0;
20133:       }else{
20134:         clearTempFile(p);
20135:       }
20136:     }else if( nSql && _all_whitespace(zSql) ){
20137:       if( ShellHasFlag(p, SHFLG_Echo) ) printf("%s\n", zSql);
20138:       nSql = 0;
20139:     }
20140:   }
20141:   if( nSql && !_all_whitespace(zSql) ){
20142:     errCnt += runOneSqlLine(p, zSql, p->in, startline);
20143:   }
20144:   free(zSql);
20145:   free(zLine);
20146:   return errCnt>0;
20147: }
20148: 
20149: /*
20150: ** Return a pathname which is the user's home directory.  A
20151: ** 0 return indicates an error of some kind.
20152: */
20153: static char *find_home_dir(int clearFlag){
20154:   static char *home_dir = NULL;
20155:   if( clearFlag ){
20156:     free(home_dir);
20157:     home_dir = 0;
20158:     return 0;
20159:   }
20160:   if( home_dir ) return home_dir;
20161: 
20162: #if !defined(_WIN32) && !defined(WIN32) && !defined(_WIN32_WCE) \
20163:      && !defined(__RTP__) && !defined(_WRS_KERNEL)
20164:   {
20165:     struct passwd *pwent;
20166:     uid_t uid = getuid();
20167:     if( (pwent=getpwuid(uid)) != NULL) {
20168:       home_dir = pwent->pw_dir;
20169:     }
20170:   }
20171: #endif
20172: 
20173: #if defined(_WIN32_WCE)
20174:   /* Windows CE (arm-wince-mingw32ce-gcc) does not provide getenv()
20175:    */
20176:   home_dir = "/";
20177: #else
20178: 
20179: #if defined(_WIN32) || defined(WIN32)
20180:   if (!home_dir) {
20181:     home_dir = getenv("USERPROFILE");
20182:   }
20183: #endif
20184: 
20185:   if (!home_dir) {
20186:     home_dir = getenv("HOME");
20187:   }
20188: 
20189: #if defined(_WIN32) || defined(WIN32)
20190:   if (!home_dir) {
20191:     char *zDrive, *zPath;
20192:     int n;
20193:     zDrive = getenv("HOMEDRIVE");
20194:     zPath = getenv("HOMEPATH");
20195:     if( zDrive && zPath ){
20196:       n = strlen30(zDrive) + strlen30(zPath) + 1;
20197:       home_dir = malloc( n );
20198:       if( home_dir==0 ) return 0;
20199:       sqlite3_snprintf(n, home_dir, "%s%s", zDrive, zPath);
20200:       return home_dir;
20201:     }
20202:     home_dir = "c:\\";
20203:   }
20204: #endif
20205: 
20206: #endif /* !_WIN32_WCE */
20207: 
20208:   if( home_dir ){
20209:     int n = strlen30(home_dir) + 1;
20210:     char *z = malloc( n );
20211:     if( z ) memcpy(z, home_dir, n);
20212:     home_dir = z;
20213:   }
20214: 
20215:   return home_dir;
20216: }
20217: 
20218: /*
20219: ** Read input from the file given by sqliterc_override.  Or if that
20220: ** parameter is NULL, take input from ~/.duckdbrc
20221: **
20222: ** Returns the number of errors.
20223: */
20224: static void process_sqliterc(
20225:   ShellState *p,                  /* Configuration data */
20226:   const char *sqliterc_override   /* Name of config file. NULL to use default */
20227: ){
20228:   char *home_dir = NULL;
20229:   const char *sqliterc = sqliterc_override;
20230:   char *zBuf = 0;
20231:   FILE *inSaved = p->in;
20232:   int savedLineno = p->lineno;
20233: 
20234:   if (sqliterc == NULL) {
20235:     home_dir = find_home_dir(0);
20236:     if( home_dir==0 ){
20237:       raw_printf(stderr, "-- warning: cannot find home directory;"
20238:                       " cannot read ~/.duckdbrc\n");
20239:       return;
20240:     }
20241:     zBuf = sqlite3_mprintf("%s/.duckdbrc",home_dir);
20242:     sqliterc = zBuf;
20243:   }
20244:   p->in = fopen(sqliterc,"rb");
20245:   if( p->in ){
20246:     if( stdin_is_interactive ){
20247:       utf8_printf(stderr,"-- Loading resources from %s\n",sqliterc);
20248:     }
20249:     process_input(p);
20250:     fclose(p->in);
20251:   }
20252:   p->in = inSaved;
20253:   p->lineno = savedLineno;
20254:   sqlite3_free(zBuf);
20255: }
20256: 
20257: /*
20258: ** Show available command line options
20259: */
20260: static const char zOptions[] =
20261: #if defined(SQLITE_HAVE_ZLIB) && !defined(SQLITE_OMIT_VIRTUALTABLE)
20262:   "   -A ARGS...           run \".archive ARGS\" and exit\n"
20263: #endif
20264:   "   -append              append the database to the end of the file\n"
20265:   "   -ascii               set output mode to 'ascii'\n"
20266:   "   -bail                stop after hitting an error\n"
20267:   "   -batch               force batch I/O\n"
20268:   "   -box                 set output mode to 'box'\n"
20269:   "   -column              set output mode to 'column'\n"
20270:   "   -cmd COMMAND         run \"COMMAND\" before reading stdin\n"
20271:   "   -c COMMAND           run \"COMMAND\" and exit\n"
20272:   "   -csv                 set output mode to 'csv'\n"
20273: #if defined(SQLITE_ENABLE_DESERIALIZE)
20274:   "   -deserialize         open the database using sqlite3_deserialize()\n"
20275: #endif
20276:   "   -echo                print commands before execution\n"
20277:   "   -init FILENAME       read/process named file\n"
20278:   "   -[no]header          turn headers on or off\n"
20279: #if defined(SQLITE_ENABLE_MEMSYS3) || defined(SQLITE_ENABLE_MEMSYS5)
20280:   "   -heap SIZE           Size of heap for memsys3 or memsys5\n"
20281: #endif
20282:   "   -help                show this message\n"
20283:   "   -html                set output mode to HTML\n"
20284:   "   -interactive         force interactive I/O\n"
20285:   "   -json                set output mode to 'json'\n"
20286:   "   -line                set output mode to 'line'\n"
20287:   "   -list                set output mode to 'list'\n"
20288:   "   -lookaside SIZE N    use N entries of SZ bytes for lookaside memory\n"
20289:   "   -markdown            set output mode to 'markdown'\n"
20290: #if defined(SQLITE_ENABLE_DESERIALIZE)
20291:   "   -maxsize N           maximum size for a --deserialize database\n"
20292: #endif
20293:   "   -memtrace            trace all memory allocations and deallocations\n"
20294:   "   -mmap N              default mmap size set to N\n"
20295: #ifdef SQLITE_ENABLE_MULTIPLEX
20296:   "   -multiplex           enable the multiplexor VFS\n"
20297: #endif
20298:   "   -newline SEP         set output row separator. Default: '\\n'\n"
20299:   "   -nofollow            refuse to open symbolic links to database files\n"
20300:   "   -no-stdin            exit after processing options instead of reading stdin\n"
20301:   "   -nullvalue TEXT      set text string for NULL values. Default ''\n"
20302:   "   -pagecache SIZE N    use N slots of SZ bytes each for page cache memory\n"
20303:   "   -quote               set output mode to 'quote'\n"
20304:   "   -readonly            open the database read-only\n"
20305:   "   -s COMMAND           run \"COMMAND\" and exit\n"
20306:   "   -separator SEP       set output column separator. Default: '|'\n"
20307: #ifdef SQLITE_ENABLE_SORTER_REFERENCES
20308:   "   -sorterref SIZE      sorter references threshold size\n"
20309: #endif
20310:   "   -stats               print memory stats before each finalize\n"
20311:   "   -table               set output mode to 'table'\n"
20312:   "   -unsigned            allow loading of unsigned extensions\n"
20313:   "   -version             show DuckDB version\n"
20314:   "   -vfs NAME            use NAME as the default VFS\n"
20315: #ifdef SQLITE_ENABLE_VFSTRACE
20316:   "   -vfstrace            enable tracing of all VFS calls\n"
20317: #endif
20318: #ifdef SQLITE_HAVE_ZLIB
20319:   "   -zip                 open the file as a ZIP Archive\n"
20320: #endif
20321: ;
20322: static void usage(int showDetail){
20323:   utf8_printf(stderr,
20324:       "Usage: %s [OPTIONS] FILENAME [SQL]\n"
20325:       "FILENAME is the name of an DuckDB database. A new database is created\n"
20326:       "if the file does not previously exist.\n", Argv0);
20327:   if( showDetail ){
20328:     utf8_printf(stderr, "OPTIONS include:\n%s", zOptions);
20329:   }else{
20330:     raw_printf(stderr, "Use the -help option for additional information\n");
20331:   }
20332:   exit(1);
20333: }
20334: 
20335: /*
20336: ** Internal check:  Verify that the SQLite is uninitialized.  Print a
20337: ** error message if it is initialized.
20338: */
20339: static void verify_uninitialized(void){
20340:   if( sqlite3_config(-1)==SQLITE_MISUSE ){
20341:     utf8_printf(stdout, "WARNING: attempt to configure SQLite after"
20342:                         " initialization.\n");
20343:   }
20344: }
20345: 
20346: /*
20347: ** Initialize the state information in data
20348: */
20349: static void main_init(ShellState *data) {
20350:   memset(data, 0, sizeof(*data));
20351:   data->normalMode = data->cMode = data->mode = MODE_Box;
20352:   data->autoExplain = 1;
20353:   memcpy(data->colSeparator,SEP_Column, 2);
20354:   memcpy(data->rowSeparator,SEP_Row, 2);
20355:   data->showHeader = 1;
20356:   data->shellFlgs = SHFLG_Lookaside;
20357:   verify_uninitialized();
20358:   sqlite3_config(SQLITE_CONFIG_URI, 1);
20359:   sqlite3_config(SQLITE_CONFIG_LOG, shellLog, data);
20360:   sqlite3_config(SQLITE_CONFIG_MULTITHREAD);
20361:   sqlite3_snprintf(sizeof(mainPrompt), mainPrompt, "D ");
20362:   sqlite3_snprintf(sizeof(continuePrompt), continuePrompt, "> ");
20363: }
20364: 
20365: /*
20366: ** Output text to the console in a font that attracts extra attention.
20367: */
20368: #ifdef _WIN32
20369: static void printBold(const char *zText){
20370: #if !SQLITE_OS_WINRT
20371:   HANDLE out = GetStdHandle(STD_OUTPUT_HANDLE);
20372:   CONSOLE_SCREEN_BUFFER_INFO defaultScreenInfo;
20373:   GetConsoleScreenBufferInfo(out, &defaultScreenInfo);
20374:   SetConsoleTextAttribute(out,
20375:          FOREGROUND_RED|FOREGROUND_INTENSITY
20376:   );
20377: #endif
20378:   printf("%s", zText);
20379: #if !SQLITE_OS_WINRT
20380:   SetConsoleTextAttribute(out, defaultScreenInfo.wAttributes);
20381: #endif
20382: }
20383: #else
20384: static void printBold(const char *zText){
20385:   printf("\033[1m%s\033[0m", zText);
20386: }
20387: #endif
20388: 
20389: /*
20390: ** Get the argument to an --option.  Throw an error and die if no argument
20391: ** is available.
20392: */
20393: static char *cmdline_option_value(int argc, char **argv, int i){
20394:   if( i==argc ){
20395:     utf8_printf(stderr, "%s: Error: missing argument to %s\n",
20396:             argv[0], argv[argc-1]);
20397:     exit(1);
20398:   }
20399:   return argv[i];
20400: }
20401: 
20402: #ifndef SQLITE_SHELL_IS_UTF8
20403: #  if (defined(_WIN32) || defined(WIN32)) && defined(_MSC_VER)
20404: #    define SQLITE_SHELL_IS_UTF8          (0)
20405: #  else
20406: #    define SQLITE_SHELL_IS_UTF8          (1)
20407: #  endif
20408: #endif
20409: 
20410: #if SQLITE_SHELL_IS_UTF8
20411: int SQLITE_CDECL main(int argc, char **argv){
20412: #else
20413: int SQLITE_CDECL wmain(int argc, wchar_t **wargv){
20414:   char **argv;
20415: #endif
20416:   char *zErrMsg = 0;
20417:   ShellState data;
20418:   const char *zInitFile = 0;
20419:   int i;
20420:   int rc = 0;
20421:   int warnInmemoryDb = 0;
20422:   int readStdin = 1;
20423:   int nCmd = 0;
20424:   char **azCmd = 0;
20425:   const char *zVfs = 0;           /* Value of -vfs command-line option */
20426: #if !SQLITE_SHELL_IS_UTF8
20427:   char **argvToFree = 0;
20428:   int argcToFree = 0;
20429: #endif
20430: 
20431:   setBinaryMode(stdin, 0);
20432:   setvbuf(stderr, 0, _IONBF, 0); /* Make sure stderr is unbuffered */
20433:   stdin_is_interactive = isatty(0);
20434:   stdout_is_console = isatty(1);
20435: 
20436: #ifdef SQLITE_DEBUG
20437:   registerOomSimulator();
20438: #endif
20439: 
20440: #if !defined(_WIN32_WCE)
20441:   if( getenv("SQLITE_DEBUG_BREAK") ){
20442:     if( isatty(0) && isatty(2) ){
20443:       fprintf(stderr,
20444:           "attach debugger to process %d and press any key to continue.\n",
20445:           GETPID());
20446:       fgetc(stdin);
20447:     }else{
20448: #if defined(_WIN32) || defined(WIN32)
20449: #if SQLITE_OS_WINRT
20450:       __debugbreak();
20451: #else
20452:       DebugBreak();
20453: #endif
20454: #elif defined(SIGTRAP)
20455:       raise(SIGTRAP);
20456: #endif
20457:     }
20458:   }
20459: #endif
20460: 
20461: #if USE_SYSTEM_SQLITE+0!=1
20462:   if( strncmp(sqlite3_sourceid(),SQLITE_SOURCE_ID,60)!=0 ){
20463:     utf8_printf(stderr, "SQLite header and source version mismatch\n%s\n%s\n",
20464:             sqlite3_sourceid(), SQLITE_SOURCE_ID);
20465:     exit(1);
20466:   }
20467: #endif
20468:   main_init(&data);
20469: 
20470:   /* On Windows, we must translate command-line arguments into UTF-8.
20471:   ** The SQLite memory allocator subsystem has to be enabled in order to
20472:   ** do this.  But we want to run an sqlite3_shutdown() afterwards so that
20473:   ** subsequent sqlite3_config() calls will work.  So copy all results into
20474:   ** memory that does not come from the SQLite memory allocator.
20475:   */
20476: #if !SQLITE_SHELL_IS_UTF8
20477:   sqlite3_initialize();
20478:   argvToFree = malloc(sizeof(argv[0])*argc*2);
20479:   argcToFree = argc;
20480:   argv = argvToFree + argc;
20481:   if( argv==0 ) shell_out_of_memory();
20482:   for(i=0; i<argc; i++){
20483:     char *z = sqlite3_win32_unicode_to_utf8(wargv[i]);
20484:     int n;
20485:     if( z==0 ) shell_out_of_memory();
20486:     n = (int)strlen(z);
20487:     argv[i] = malloc( n+1 );
20488:     if( argv[i]==0 ) shell_out_of_memory();
20489:     memcpy(argv[i], z, n+1);
20490:     argvToFree[i] = argv[i];
20491:     sqlite3_free(z);
20492:   }
20493:   sqlite3_shutdown();
20494: #endif
20495: 
20496:   assert( argc>=1 && argv && argv[0] );
20497:   Argv0 = argv[0];
20498: 
20499:   /* Make sure we have a valid signal handler early, before anything
20500:   ** else is done.
20501:   */
20502: #ifdef SIGINT
20503:   signal(SIGINT, interrupt_handler);
20504: #elif (defined(_WIN32) || defined(WIN32)) && !defined(_WIN32_WCE)
20505:   SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE);
20506: #endif
20507: 
20508: #ifdef SQLITE_SHELL_DBNAME_PROC
20509:   {
20510:     /* If the SQLITE_SHELL_DBNAME_PROC macro is defined, then it is the name
20511:     ** of a C-function that will provide the name of the database file.  Use
20512:     ** this compile-time option to embed this shell program in larger
20513:     ** applications. */
20514:     extern void SQLITE_SHELL_DBNAME_PROC(const char**);
20515:     SQLITE_SHELL_DBNAME_PROC(&data.zDbFilename);
20516:     warnInmemoryDb = 0;
20517:   }
20518: #endif
20519: 
20520:   /* Do an initial pass through the command-line argument to locate
20521:   ** the name of the database file, the name of the initialization file,
20522:   ** the size of the alternative malloc heap,
20523:   ** and the first command to execute.
20524:   */
20525:   verify_uninitialized();
20526:   for(i=1; i<argc; i++){
20527:     char *z;
20528:     z = argv[i];
20529:     if( z[0]!='-' ){
20530:       if( data.zDbFilename==0 ){
20531:         data.zDbFilename = z;
20532:       }else{
20533:         /* Excesss arguments are interpreted as SQL (or dot-commands) and
20534:         ** mean that nothing is read from stdin */
20535:         readStdin = 0;
20536:         nCmd++;
20537:         azCmd = realloc(azCmd, sizeof(azCmd[0])*nCmd);
20538:         if( azCmd==0 ) shell_out_of_memory();
20539:         azCmd[nCmd-1] = z;
20540:       }
20541:     }
20542:     if( z[1]=='-' ) z++;
20543:     if( strcmp(z,"-separator")==0
20544:      || strcmp(z,"-nullvalue")==0
20545:      || strcmp(z,"-newline")==0
20546:      || strcmp(z,"-cmd")==0
20547:      || strcmp(z,"-c")==0
20548:      || strcmp(z,"-s")==0
20549:     ){
20550:       (void)cmdline_option_value(argc, argv, ++i);
20551:     }else if( strcmp(z,"-init")==0 ){
20552:       zInitFile = cmdline_option_value(argc, argv, ++i);
20553:     }else if( strcmp(z,"-batch")==0 ){
20554:       /* Need to check for batch mode here to so we can avoid printing
20555:       ** informational messages (like from process_sqliterc) before
20556:       ** we do the actual processing of arguments later in a second pass.
20557:       */
20558:       stdin_is_interactive = 0;
20559:     }else if( strcmp(z,"-heap")==0 ){
20560: #if defined(SQLITE_ENABLE_MEMSYS3) || defined(SQLITE_ENABLE_MEMSYS5)
20561:       const char *zSize;
20562:       sqlite3_int64 szHeap;
20563: 
20564:       zSize = cmdline_option_value(argc, argv, ++i);
20565:       szHeap = integerValue(zSize);
20566:       if( szHeap>0x7fff0000 ) szHeap = 0x7fff0000;
20567:       sqlite3_config(SQLITE_CONFIG_HEAP, malloc((int)szHeap), (int)szHeap, 64);
20568: #else
20569:       (void)cmdline_option_value(argc, argv, ++i);
20570: #endif
20571:     }else if( strcmp(z,"-pagecache")==0 ){
20572:       int n, sz;
20573:       sz = (int)integerValue(cmdline_option_value(argc,argv,++i));
20574:       if( sz>70000 ) sz = 70000;
20575:       if( sz<0 ) sz = 0;
20576:       n = (int)integerValue(cmdline_option_value(argc,argv,++i));
20577:       sqlite3_config(SQLITE_CONFIG_PAGECACHE,
20578:                     (n>0 && sz>0) ? malloc(n*sz) : 0, sz, n);
20579:       data.shellFlgs |= SHFLG_Pagecache;
20580:     }else if( strcmp(z,"-lookaside")==0 ){
20581:       int n, sz;
20582:       sz = (int)integerValue(cmdline_option_value(argc,argv,++i));
20583:       if( sz<0 ) sz = 0;
20584:       n = (int)integerValue(cmdline_option_value(argc,argv,++i));
20585:       if( n<0 ) n = 0;
20586:       sqlite3_config(SQLITE_CONFIG_LOOKASIDE, sz, n);
20587:       if( sz*n==0 ) data.shellFlgs &= ~SHFLG_Lookaside;
20588: #ifdef SQLITE_ENABLE_VFSTRACE
20589:     }else if( strcmp(z,"-vfstrace")==0 ){
20590:       extern int vfstrace_register(
20591:          const char *zTraceName,
20592:          const char *zOldVfsName,
20593:          int (*xOut)(const char*,void*),
20594:          void *pOutArg,
20595:          int makeDefault
20596:       );
20597:       vfstrace_register("trace",0,(int(*)(const char*,void*))fputs,stderr,1);
20598: #endif
20599: #ifdef SQLITE_ENABLE_MULTIPLEX
20600:     }else if( strcmp(z,"-multiplex")==0 ){
20601:       extern int sqlite3_multiple_initialize(const char*,int);
20602:       sqlite3_multiplex_initialize(0, 1);
20603: #endif
20604:     }else if( strcmp(z,"-mmap")==0 ){
20605:       sqlite3_int64 sz = integerValue(cmdline_option_value(argc,argv,++i));
20606:       sqlite3_config(SQLITE_CONFIG_MMAP_SIZE, sz, sz);
20607: #ifdef SQLITE_ENABLE_SORTER_REFERENCES
20608:     }else if( strcmp(z,"-sorterref")==0 ){
20609:       sqlite3_int64 sz = integerValue(cmdline_option_value(argc,argv,++i));
20610:       sqlite3_config(SQLITE_CONFIG_SORTERREF_SIZE, (int)sz);
20611: #endif
20612:     }else if( strcmp(z,"-vfs")==0 ){
20613:       zVfs = cmdline_option_value(argc, argv, ++i);
20614: #ifdef SQLITE_HAVE_ZLIB
20615:     }else if( strcmp(z,"-zip")==0 ){
20616:       data.openMode = SHELL_OPEN_ZIPFILE;
20617: #endif
20618:     }else if( strcmp(z,"-append")==0 ){
20619:       data.openMode = SHELL_OPEN_APPENDVFS;
20620: #ifdef SQLITE_ENABLE_DESERIALIZE
20621:     }else if( strcmp(z,"-deserialize")==0 ){
20622:       data.openMode = SHELL_OPEN_DESERIALIZE;
20623:     }else if( strcmp(z,"-maxsize")==0 && i+1<argc ){
20624:       data.szMax = integerValue(argv[++i]);
20625: #endif
20626:     }else if( strcmp(z,"-readonly")==0 ){
20627:       data.openMode = SHELL_OPEN_READONLY;
20628:     }else if( strcmp(z,"-nofollow")==0 ){
20629:       data.openFlags = SQLITE_OPEN_NOFOLLOW;
20630: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)
20631:     }else if( strncmp(z, "-A",2)==0 ){
20632:       /* All remaining command-line arguments are passed to the ".archive"
20633:       ** command, so ignore them */
20634:       break;
20635: #endif
20636:     }else if( strcmp(z, "-memtrace")==0 ){
20637:       sqlite3MemTraceActivate(stderr);
20638:     }
20639:   }
20640:   verify_uninitialized();
20641: 
20642: 
20643: #ifdef SQLITE_SHELL_INIT_PROC
20644:   {
20645:     /* If the SQLITE_SHELL_INIT_PROC macro is defined, then it is the name
20646:     ** of a C-function that will perform initialization actions on SQLite that
20647:     ** occur just before or after sqlite3_initialize(). Use this compile-time
20648:     ** option to embed this shell program in larger applications. */
20649:     extern void SQLITE_SHELL_INIT_PROC(void);
20650:     SQLITE_SHELL_INIT_PROC();
20651:   }
20652: #else
20653:   /* All the sqlite3_config() calls have now been made. So it is safe
20654:   ** to call sqlite3_initialize() and process any command line -vfs option. */
20655:   sqlite3_initialize();
20656: #endif
20657: 
20658:   if( zVfs ){
20659:     sqlite3_vfs *pVfs = sqlite3_vfs_find(zVfs);
20660:     if( pVfs ){
20661:       sqlite3_vfs_register(pVfs, 1);
20662:     }else{
20663:       utf8_printf(stderr, "no such VFS: \"%s\"\n", argv[i]);
20664:       exit(1);
20665:     }
20666:   }
20667: 
20668:   if( data.zDbFilename==0 ){
20669: #ifndef SQLITE_OMIT_MEMORYDB
20670:     data.zDbFilename = ":memory:";
20671:     warnInmemoryDb = argc==1;
20672: #else
20673:     utf8_printf(stderr,"%s: Error: no database filename specified\n", Argv0);
20674:     return 1;
20675: #endif
20676:   }
20677:   data.out = stdout;
20678:   sqlite3_appendvfs_init(0,0,0);
20679: 
20680:   /* Go ahead and open the database file if it already exists.  If the
20681:   ** file does not exist, delay opening it.  This prevents empty database
20682:   ** files from being created if a user mistypes the database name argument
20683:   ** to the sqlite command-line tool.
20684:   */
20685:   if( access(data.zDbFilename, 0)==0 ){
20686:     open_db(&data, 0);
20687:   }
20688: 
20689:   /* Process the initialization file if there is one.  If no -init option
20690:   ** is given on the command line, look for a file named ~/.sqliterc and
20691:   ** try to process it.
20692:   */
20693:   process_sqliterc(&data,zInitFile);
20694: 
20695:   /* Make a second pass through the command-line argument and set
20696:   ** options.  This second pass is delayed until after the initialization
20697:   ** file is processed so that the command-line arguments will override
20698:   ** settings in the initialization file.
20699:   */
20700:   for(i=1; i<argc; i++){
20701:     char *z = argv[i];
20702:     if( z[0]!='-' ) continue;
20703:     if( z[1]=='-' ){ z++; }
20704:     if( strcmp(z,"-init")==0 ){
20705:       i++;
20706:     }else if( strcmp(z,"-html")==0 ){
20707:       data.mode = MODE_Html;
20708:     }else if( strcmp(z,"-list")==0 ){
20709:       data.mode = MODE_List;
20710:     }else if( strcmp(z,"-quote")==0 ){
20711:       data.mode = MODE_Quote;
20712:     }else if( strcmp(z,"-line")==0 ){
20713:       data.mode = MODE_Line;
20714:     }else if( strcmp(z,"-column")==0 ){
20715:       data.mode = MODE_Column;
20716:     }else if( strcmp(z,"-json")==0 ){
20717:       data.mode = MODE_Json;
20718: 	}else if( strcmp(z,"-jsonlines")==0 ){
20719: 		data.mode = MODE_Jsonlines;
20720:     }else if( strcmp(z,"-markdown")==0 ){
20721:       data.mode = MODE_Markdown;
20722:     }else if( strcmp(z,"-table")==0 ){
20723:       data.mode = MODE_Table;
20724:     }else if( strcmp(z,"-box")==0 ){
20725:       data.mode = MODE_Box;
20726:     }else if( strcmp(z,"-latex")==0 ){
20727:       data.mode = MODE_Latex;
20728:     }else if( strcmp(z,"-csv")==0 ){
20729:       data.mode = MODE_Csv;
20730:       memcpy(data.colSeparator,",",2);
20731: #ifdef SQLITE_HAVE_ZLIB
20732:     }else if( strcmp(z,"-zip")==0 ){
20733:       data.openMode = SHELL_OPEN_ZIPFILE;
20734: #endif
20735:     }else if( strcmp(z,"-append")==0 ){
20736:       data.openMode = SHELL_OPEN_APPENDVFS;
20737: #ifdef SQLITE_ENABLE_DESERIALIZE
20738:     }else if( strcmp(z,"-deserialize")==0 ){
20739:       data.openMode = SHELL_OPEN_DESERIALIZE;
20740:     }else if( strcmp(z,"-maxsize")==0 && i+1<argc ){
20741:       data.szMax = integerValue(argv[++i]);
20742: #endif
20743:     }else if( strcmp(z,"-readonly")==0 ){
20744:       data.openMode = SHELL_OPEN_READONLY;
20745:     }else if( strcmp(z,"-nofollow")==0 ){
20746:       data.openFlags |= SQLITE_OPEN_NOFOLLOW;
20747:     }else if( strcmp(z,"-ascii")==0 ){
20748:       data.mode = MODE_Ascii;
20749:       sqlite3_snprintf(sizeof(data.colSeparator), data.colSeparator,
20750:                        SEP_Unit);
20751:       sqlite3_snprintf(sizeof(data.rowSeparator), data.rowSeparator,
20752:                        SEP_Record);
20753:     }else if( strcmp(z,"-separator")==0 ){
20754:       sqlite3_snprintf(sizeof(data.colSeparator), data.colSeparator,
20755:                        "%s",cmdline_option_value(argc,argv,++i));
20756:     }else if( strcmp(z,"-newline")==0 ){
20757:       sqlite3_snprintf(sizeof(data.rowSeparator), data.rowSeparator,
20758:                        "%s",cmdline_option_value(argc,argv,++i));
20759:     }else if( strcmp(z,"-nullvalue")==0 ){
20760:       sqlite3_snprintf(sizeof(data.nullValue), data.nullValue,
20761:                        "%s",cmdline_option_value(argc,argv,++i));
20762:     }else if( strcmp(z,"-header")==0 ){
20763:       data.showHeader = 1;
20764:     }else if( strcmp(z,"-noheader")==0 ){
20765:       data.showHeader = 0;
20766:     }else if( strcmp(z,"-echo")==0 ){
20767:       ShellSetFlag(&data, SHFLG_Echo);
20768:     }else if( strcmp(z,"-eqp")==0 ){
20769:       data.autoEQP = AUTOEQP_on;
20770:     }else if( strcmp(z,"-eqpfull")==0 ){
20771:       data.autoEQP = AUTOEQP_full;
20772:     }else if( strcmp(z,"-stats")==0 ){
20773:       data.statsOn = 1;
20774:     }else if( strcmp(z,"-scanstats")==0 ){
20775:       data.scanstatsOn = 1;
20776:     }else if( strcmp(z,"-unsigned")==0 ){
20777:       data.openFlags |= DUCKDB_UNSIGNED_EXTENSIONS;
20778:     }else if( strcmp(z,"-backslash")==0 ){
20779:       /* Undocumented command-line option: -backslash
20780:       ** Causes C-style backslash escapes to be evaluated in SQL statements
20781:       ** prior to sending the SQL into SQLite.  Useful for injecting
20782:       ** crazy bytes in the middle of SQL statements for testing and debugging.
20783:       */
20784:       ShellSetFlag(&data, SHFLG_Backslash);
20785:     }else if( strcmp(z,"-bail")==0 ){
20786:       bail_on_error = 1;
20787:     }else if( strcmp(z,"-version")==0 ){
20788:       printf("%s %s\n", sqlite3_libversion(), sqlite3_sourceid());
20789:       free(azCmd);
20790:       return 0;
20791:     }else if( strcmp(z,"-interactive")==0 ){
20792:       stdin_is_interactive = 1;
20793:     }else if( strcmp(z,"-batch")==0 ){
20794:       stdin_is_interactive = 0;
20795:     }else if( strcmp(z,"-heap")==0 ){
20796:       i++;
20797:     }else if( strcmp(z,"-pagecache")==0 ){
20798:       i+=2;
20799:     }else if( strcmp(z,"-lookaside")==0 ){
20800:       i+=2;
20801:     }else if( strcmp(z,"-mmap")==0 ){
20802:       i++;
20803:     }else if( strcmp(z,"-memtrace")==0 ){
20804:       i++;
20805: #ifdef SQLITE_ENABLE_SORTER_REFERENCES
20806:     }else if( strcmp(z,"-sorterref")==0 ){
20807:       i++;
20808: #endif
20809:     }else if( strcmp(z,"-vfs")==0 ){
20810:       i++;
20811: #ifdef SQLITE_ENABLE_VFSTRACE
20812:     }else if( strcmp(z,"-vfstrace")==0 ){
20813:       i++;
20814: #endif
20815: #ifdef SQLITE_ENABLE_MULTIPLEX
20816:     }else if( strcmp(z,"-multiplex")==0 ){
20817:       i++;
20818: #endif
20819:     }else if( strcmp(z,"-help")==0 ){
20820:       usage(1);
20821:     }else if( strcmp(z,"-no-stdin")==0 ){
20822:       readStdin = 0;
20823:     }else if( strcmp(z,"-cmd")==0 || strcmp(z,"-c")==0 || strcmp(z,"-s")==0){
20824:       if (strcmp(z,"-c")==0 || strcmp(z,"-s")==0) {
20825:         readStdin = 0;
20826:       }
20827:       /* Run commands that follow -cmd first and separately from commands
20828:       ** that simply appear on the command-line.  This seems goofy.  It would
20829:       ** be better if all commands ran in the order that they appear.  But
20830:       ** we retain the goofy behavior for historical compatibility. */
20831:       if( i==argc-1 ) break;
20832:       z = cmdline_option_value(argc,argv,++i);
20833:       if( z[0]=='.' ){
20834:         rc = do_meta_command(z, &data);
20835:         if( rc && bail_on_error ){
20836:           free(azCmd);
20837:           return rc==2 ? 0 : rc;
20838:         }
20839:       }else{
20840:         open_db(&data, 0);
20841:         rc = shell_exec(&data, z, &zErrMsg);
20842:         if( zErrMsg!=0 ){
20843:           utf8_printf(stderr,"Error: %s\n", zErrMsg);
20844:           sqlite3_free(zErrMsg);
20845:           if( bail_on_error ){
20846:             free(azCmd);
20847:             return rc!=0 ? rc : 1;
20848:           }
20849:         }else if( rc!=0 ){
20850:           utf8_printf(stderr,"Error: unable to process SQL \"%s\"\n", z);
20851:           if( bail_on_error ){
20852:             free(azCmd);
20853:             return rc;
20854:           }
20855:         }
20856:       }
20857: #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)
20858:     }else if( strncmp(z, "-A", 2)==0 ){
20859:       if( nCmd>0 ){
20860:         utf8_printf(stderr, "Error: cannot mix regular SQL or dot-commands"
20861:                             " with \"%s\"\n", z);
20862:         free(azCmd);
20863:         return 1;
20864:       }
20865:       open_db(&data, OPEN_DB_ZIPFILE);
20866:       if( z[2] ){
20867:         argv[i] = &z[2];
20868:         arDotCommand(&data, 1, argv+(i-1), argc-(i-1));
20869:       }else{
20870:         arDotCommand(&data, 1, argv+i, argc-i);
20871:       }
20872:       readStdin = 0;
20873:       break;
20874: #endif
20875:     }else{
20876:       utf8_printf(stderr,"%s: Error: unknown option: %s\n", Argv0, z);
20877:       raw_printf(stderr,"Use -help for a list of options.\n");
20878:       free(azCmd);
20879:       return 1;
20880:     }
20881:     data.cMode = data.mode;
20882:   }
20883: 
20884:   if( !readStdin ){
20885:     /* Run all arguments that do not begin with '-' as if they were separate
20886:     ** command-line inputs, except for the argToSkip argument which contains
20887:     ** the database filename.
20888:     */
20889:     for(i=0; i<nCmd; i++){
20890:       if( azCmd[i][0]=='.' ){
20891:         rc = do_meta_command(azCmd[i], &data);
20892:         if( rc ){
20893:           free(azCmd);
20894:           return rc==2 ? 0 : rc;
20895:         }
20896:       }else{
20897:         open_db(&data, 0);
20898:         rc = shell_exec(&data, azCmd[i], &zErrMsg);
20899:         if( zErrMsg!=0 ){
20900:           utf8_printf(stderr,"Error: %s\n", zErrMsg);
20901:           sqlite3_free(zErrMsg);
20902:           free(azCmd);
20903:           return rc!=0 ? rc : 1;
20904:         }else if( rc!=0 ){
20905:           utf8_printf(stderr,"Error: unable to process SQL: %s\n", azCmd[i]);
20906:           free(azCmd);
20907:           return rc;
20908:         }
20909:       }
20910:     }
20911:     free(azCmd);
20912:   }else{
20913:     /* Run commands received from standard input
20914:     */
20915:     if( stdin_is_interactive ){
20916:       char *zHome;
20917:       char *zHistory;
20918:       int nHistory;
20919:       printf(
20920:         "%s %.19s\n" /*extra-version-info*/
20921:         "Enter \".help\" for usage hints.\n",
20922:         sqlite3_libversion(), sqlite3_sourceid()
20923:       );
20924:       if( warnInmemoryDb ){
20925:         printf("Connected to a ");
20926:         printBold("transient in-memory database");
20927:         printf(".\nUse \".open FILENAME\" to reopen on a "
20928:                "persistent database.\n");
20929:       }
20930:       zHistory = getenv("DUCKDB_HISTORY");
20931:       if( zHistory ){
20932:         zHistory = strdup(zHistory);
20933:       }else if( (zHome = find_home_dir(0))!=0 ){
20934:         nHistory = strlen30(zHome) + 20;
20935:         if( (zHistory = malloc(nHistory))!=0 ){
20936:           sqlite3_snprintf(nHistory, zHistory,"%s/.duckdb_history", zHome);
20937:         }
20938:       }
20939:       if( zHistory ){ shell_read_history(zHistory); }
20940: #if HAVE_READLINE || HAVE_EDITLINE
20941:       rl_attempted_completion_function = readline_completion;
20942: #elif HAVE_LINENOISE
20943:       linenoiseSetCompletionCallback(linenoise_completion);
20944: #endif
20945:       data.in = 0;
20946:       rc = process_input(&data);
20947:       if( zHistory ){
20948:         shell_stifle_history(2000);
20949:         shell_write_history(zHistory);
20950:         free(zHistory);
20951:       }
20952:     }else{
20953:       data.in = stdin;
20954:       rc = process_input(&data);
20955:     }
20956:   }
20957:   set_table_name(&data, 0);
20958:   if( data.db ){
20959:     session_close_all(&data);
20960:     close_db(data.db);
20961:   }
20962:   sqlite3_free(data.zFreeOnClose);
20963:   find_home_dir(1);
20964:   output_reset(&data);
20965:   data.doXdgOpen = 0;
20966:   clearTempFile(&data);
20967: #if !SQLITE_SHELL_IS_UTF8
20968:   for(i=0; i<argcToFree; i++) free(argvToFree[i]);
20969:   free(argvToFree);
20970: #endif
20971:   free(data.colWidth);
20972:   /* Clear the global data structure so that valgrind will detect memory
20973:   ** leaks */
20974:   memset(&data, 0, sizeof(data));
20975:   return rc;
20976: }
[end of tools/shell/shell.c]
[start of tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp]
1: #include "sqlite3.h"
2: #include "sql_auto_complete_extension.hpp"
3: #include "udf_struct_sqlite3.h"
4: #include "sqlite3_udf_wrapper.hpp"
5: #include "cast_sqlite.hpp"
6: 
7: #include "duckdb.hpp"
8: #include "duckdb/parser/parser.hpp"
9: #include "duckdb/main/client_context.hpp"
10: #include "duckdb/common/types.hpp"
11: #include "duckdb/common/operator/cast_operators.hpp"
12: #include "duckdb/common/preserved_error.hpp"
13: #include "utf8proc_wrapper.hpp"
14: 
15: #include <ctype.h>
16: #include <stdio.h>
17: #include <stdlib.h>
18: #include <string.h>
19: #include <time.h>
20: #include <string>
21: #include <chrono>
22: #include <cassert>
23: #include <climits>
24: #include <thread>
25: 
26: using namespace duckdb;
27: using namespace std;
28: 
29: static char *sqlite3_strdup(const char *str);
30: 
31: struct sqlite3_string_buffer {
32: 	//! String data
33: 	unique_ptr<char[]> data;
34: 	//! String length
35: 	int data_len;
36: };
37: 
38: struct sqlite3_stmt {
39: 	//! The DB object that this statement belongs to
40: 	sqlite3 *db;
41: 	//! The query string
42: 	string query_string;
43: 	//! The prepared statement object, if successfully prepared
44: 	unique_ptr<PreparedStatement> prepared;
45: 	//! The result object, if successfully executed
46: 	unique_ptr<QueryResult> result;
47: 	//! The current chunk that we are iterating over
48: 	unique_ptr<DataChunk> current_chunk;
49: 	//! The current row into the current chunk that we are iterating over
50: 	int64_t current_row;
51: 	//! Bound values, used for binding to the prepared statement
52: 	vector<Value> bound_values;
53: 	//! Names of the prepared parameters
54: 	vector<string> bound_names;
55: 	//! The current column values converted to string, used and filled by sqlite3_column_text
56: 	unique_ptr<sqlite3_string_buffer[]> current_text;
57: };
58: 
59: void sqlite3_randomness(int N, void *pBuf) {
60: 	static bool init = false;
61: 	if (!init) {
62: 		srand(time(NULL));
63: 		init = true;
64: 	}
65: 	unsigned char *zBuf = (unsigned char *)pBuf;
66: 	while (N--) {
67: 		unsigned char nextByte = rand() % 255;
68: 		zBuf[N] = nextByte;
69: 	}
70: }
71: 
72: int sqlite3_open(const char *filename, /* Database filename (UTF-8) */
73:                  sqlite3 **ppDb        /* OUT: SQLite db handle */
74: ) {
75: 	return sqlite3_open_v2(filename, ppDb, 0, NULL);
76: }
77: 
78: int sqlite3_open_v2(const char *filename, /* Database filename (UTF-8) */
79:                     sqlite3 **ppDb,       /* OUT: SQLite db handle */
80:                     int flags,            /* Flags */
81:                     const char *zVfs      /* Name of VFS module to use */
82: ) {
83: 	if (filename && strcmp(filename, ":memory:") == 0) {
84: 		filename = NULL;
85: 	}
86: 	*ppDb = nullptr;
87: 	if (zVfs) { /* unsupported so if set we complain */
88: 		return SQLITE_ERROR;
89: 	}
90: 	int rc = SQLITE_OK;
91: 	sqlite3 *pDb = nullptr;
92: 	try {
93: 		pDb = new sqlite3();
94: 		DBConfig config;
95: 		config.options.access_mode = AccessMode::AUTOMATIC;
96: 		if (flags & SQLITE_OPEN_READONLY) {
97: 			config.options.access_mode = AccessMode::READ_ONLY;
98: 		}
99: 		if (flags & DUCKDB_UNSIGNED_EXTENSIONS) {
100: 			config.options.allow_unsigned_extensions = true;
101: 		}
102: 		pDb->db = make_unique<DuckDB>(filename, &config);
103: 		pDb->db->LoadExtension<SQLAutoCompleteExtension>();
104: 		pDb->con = make_unique<Connection>(*pDb->db);
105: 	} catch (const Exception &ex) {
106: 		if (pDb) {
107: 			pDb->last_error = PreservedError(ex);
108: 			pDb->errCode = SQLITE_ERROR;
109: 		}
110: 		rc = SQLITE_ERROR;
111: 	} catch (std::exception &ex) {
112: 		if (pDb) {
113: 			pDb->last_error = PreservedError(ex);
114: 			pDb->errCode = SQLITE_ERROR;
115: 		}
116: 		rc = SQLITE_ERROR;
117: 	}
118: 	*ppDb = pDb;
119: 	return rc;
120: }
121: 
122: int sqlite3_close(sqlite3 *db) {
123: 	if (db) {
124: 		delete db;
125: 	}
126: 	return SQLITE_OK;
127: }
128: 
129: int sqlite3_shutdown(void) {
130: 	return SQLITE_OK;
131: }
132: 
133: /* In SQLite this function compiles the query into VDBE bytecode,
134:  * in the implementation it currently executes the query */
135: // TODO: prepare the statement instead of executing right away
136: int sqlite3_prepare_v2(sqlite3 *db,           /* Database handle */
137:                        const char *zSql,      /* SQL statement, UTF-8 encoded */
138:                        int nByte,             /* Maximum length of zSql in bytes. */
139:                        sqlite3_stmt **ppStmt, /* OUT: Statement handle */
140:                        const char **pzTail    /* OUT: Pointer to unused portion of zSql */
141: ) {
142: 	if (!db || !ppStmt || !zSql) {
143: 		return SQLITE_MISUSE;
144: 	}
145: 	*ppStmt = nullptr;
146: 	string query = nByte < 0 ? zSql : string(zSql, nByte);
147: 	if (pzTail) {
148: 		*pzTail = zSql + query.size();
149: 	}
150: 	try {
151: 		Parser parser(db->con->context->GetParserOptions());
152: 		parser.ParseQuery(query);
153: 		if (parser.statements.size() == 0) {
154: 			return SQLITE_OK;
155: 		}
156: 		// extract the remainder
157: 		idx_t next_location = parser.statements[0]->stmt_location + parser.statements[0]->stmt_length;
158: 		bool set_remainder = next_location < query.size();
159: 
160: 		// extract the first statement
161: 		vector<unique_ptr<SQLStatement>> statements;
162: 		statements.push_back(move(parser.statements[0]));
163: 
164: 		db->con->context->HandlePragmaStatements(statements);
165: 
166: 		// if there are multiple statements here, we are dealing with an import database statement
167: 		// we directly execute all statements besides the final one
168: 		for (idx_t i = 0; i + 1 < statements.size(); i++) {
169: 			auto res = db->con->Query(move(statements[i]));
170: 			if (res->HasError()) {
171: 				db->last_error = res->GetErrorObject();
172: 				return SQLITE_ERROR;
173: 			}
174: 		}
175: 
176: 		// now prepare the query
177: 		auto prepared = db->con->Prepare(move(statements.back()));
178: 		if (prepared->HasError()) {
179: 			// failed to prepare: set the error message
180: 			db->last_error = prepared->error;
181: 			return SQLITE_ERROR;
182: 		}
183: 
184: 		// create the statement entry
185: 		unique_ptr<sqlite3_stmt> stmt = make_unique<sqlite3_stmt>();
186: 		stmt->db = db;
187: 		stmt->query_string = query;
188: 		stmt->prepared = move(prepared);
189: 		stmt->current_row = -1;
190: 		for (idx_t i = 0; i < stmt->prepared->n_param; i++) {
191: 			stmt->bound_names.push_back("$" + to_string(i + 1));
192: 			stmt->bound_values.push_back(Value());
193: 		}
194: 
195: 		// extract the remainder of the query and assign it to the pzTail
196: 		if (pzTail && set_remainder) {
197: 			*pzTail = zSql + next_location + 1;
198: 		}
199: 
200: 		*ppStmt = stmt.release();
201: 		return SQLITE_OK;
202: 	} catch (const Exception &ex) {
203: 		db->last_error = PreservedError(ex);
204: 		return SQLITE_ERROR;
205: 	} catch (std::exception &ex) {
206: 		db->last_error = PreservedError(ex);
207: 		return SQLITE_ERROR;
208: 	}
209: }
210: 
211: /* Prepare the next result to be retrieved */
212: int sqlite3_step(sqlite3_stmt *pStmt) {
213: 	if (!pStmt) {
214: 		return SQLITE_MISUSE;
215: 	}
216: 	if (!pStmt->prepared) {
217: 		pStmt->db->last_error = PreservedError("Attempting sqlite3_step() on a non-successfully prepared statement");
218: 		return SQLITE_ERROR;
219: 	}
220: 	pStmt->current_text = nullptr;
221: 	if (!pStmt->result) {
222: 		// no result yet! call Execute()
223: 		pStmt->result = pStmt->prepared->Execute(pStmt->bound_values, true);
224: 		if (pStmt->result->HasError()) {
225: 			// error in execute: clear prepared statement
226: 			pStmt->db->last_error = pStmt->result->GetErrorObject();
227: 			pStmt->prepared = nullptr;
228: 			return SQLITE_ERROR;
229: 		}
230: 		// fetch a chunk
231: 		if (!pStmt->result->TryFetch(pStmt->current_chunk, pStmt->db->last_error)) {
232: 			pStmt->prepared = nullptr;
233: 			return SQLITE_ERROR;
234: 		}
235: 
236: 		pStmt->current_row = -1;
237: 
238: 		auto properties = pStmt->prepared->GetStatementProperties();
239: 		if (properties.return_type == StatementReturnType::CHANGED_ROWS && pStmt->current_chunk &&
240: 		    pStmt->current_chunk->size() > 0) {
241: 			// update total changes
242: 			auto row_changes = pStmt->current_chunk->GetValue(0, 0);
243: 			if (!row_changes.IsNull() && row_changes.DefaultTryCastAs(LogicalType::BIGINT)) {
244: 				pStmt->db->last_changes = row_changes.GetValue<int64_t>();
245: 				pStmt->db->total_changes += row_changes.GetValue<int64_t>();
246: 			}
247: 		}
248: 		if (properties.return_type != StatementReturnType::QUERY_RESULT) {
249: 			// only SELECT statements return results
250: 			sqlite3_reset(pStmt);
251: 		}
252: 	}
253: 	if (!pStmt->current_chunk || pStmt->current_chunk->size() == 0) {
254: 		return SQLITE_DONE;
255: 	}
256: 	pStmt->current_row++;
257: 	if (pStmt->current_row >= (int32_t)pStmt->current_chunk->size()) {
258: 		// have to fetch again!
259: 		pStmt->current_row = 0;
260: 		if (!pStmt->result->TryFetch(pStmt->current_chunk, pStmt->db->last_error)) {
261: 			pStmt->prepared = nullptr;
262: 			return SQLITE_ERROR;
263: 		}
264: 		if (!pStmt->current_chunk || pStmt->current_chunk->size() == 0) {
265: 			sqlite3_reset(pStmt);
266: 			return SQLITE_DONE;
267: 		}
268: 	}
269: 	return SQLITE_ROW;
270: }
271: 
272: /* Execute multiple semicolon separated SQL statements
273:  * and execute the passed callback for each produced result,
274:  * largely copied from the original sqlite3 source */
275: int sqlite3_exec(sqlite3 *db,                /* The database on which the SQL executes */
276:                  const char *zSql,           /* The SQL to be executed */
277:                  sqlite3_callback xCallback, /* Invoke this callback routine */
278:                  void *pArg,                 /* First argument to xCallback() */
279:                  char **pzErrMsg             /* Write error messages here */
280: ) {
281: 	int rc = SQLITE_OK;            /* Return code */
282: 	const char *zLeftover;         /* Tail of unprocessed SQL */
283: 	sqlite3_stmt *pStmt = nullptr; /* The current SQL statement */
284: 	char **azCols = nullptr;       /* Names of result columns */
285: 	char **azVals = nullptr;       /* Result values */
286: 
287: 	if (zSql == nullptr) {
288: 		zSql = "";
289: 	}
290: 
291: 	while (rc == SQLITE_OK && zSql[0]) {
292: 		int nCol;
293: 
294: 		pStmt = nullptr;
295: 		rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);
296: 		if (rc != SQLITE_OK) {
297: 			if (pzErrMsg) {
298: 				auto errmsg = sqlite3_errmsg(db);
299: 				*pzErrMsg = errmsg ? sqlite3_strdup(errmsg) : nullptr;
300: 			}
301: 			continue;
302: 		}
303: 		if (!pStmt) {
304: 			/* this happens for a comment or white-space */
305: 			zSql = zLeftover;
306: 			continue;
307: 		}
308: 
309: 		nCol = sqlite3_column_count(pStmt);
310: 		azCols = (char **)malloc(nCol * sizeof(const char *));
311: 		azVals = (char **)malloc(nCol * sizeof(const char *));
312: 		if (!azCols || !azVals) {
313: 			goto exec_out;
314: 		}
315: 		for (int i = 0; i < nCol; i++) {
316: 			azCols[i] = (char *)sqlite3_column_name(pStmt, i);
317: 		}
318: 
319: 		while (true) {
320: 			rc = sqlite3_step(pStmt);
321: 
322: 			/* Invoke the callback function if required */
323: 			if (xCallback && rc == SQLITE_ROW) {
324: 				for (int i = 0; i < nCol; i++) {
325: 					azVals[i] = (char *)sqlite3_column_text(pStmt, i);
326: 					if (!azVals[i] && sqlite3_column_type(pStmt, i) != SQLITE_NULL) {
327: 						fprintf(stderr, "sqlite3_exec: out of memory.\n");
328: 						goto exec_out;
329: 					}
330: 				}
331: 				if (xCallback(pArg, nCol, azVals, azCols)) {
332: 					/* EVIDENCE-OF: R-38229-40159 If the callback function to
333: 					** sqlite3_exec() returns non-zero, then sqlite3_exec() will
334: 					** return SQLITE_ABORT. */
335: 					rc = SQLITE_ABORT;
336: 					sqlite3_finalize(pStmt);
337: 					pStmt = 0;
338: 					fprintf(stderr, "sqlite3_exec: callback returned non-zero. "
339: 					                "Aborting.\n");
340: 					goto exec_out;
341: 				}
342: 			}
343: 			if (rc == SQLITE_DONE) {
344: 				rc = sqlite3_finalize(pStmt);
345: 				pStmt = nullptr;
346: 				zSql = zLeftover;
347: 				while (isspace(zSql[0]))
348: 					zSql++;
349: 				break;
350: 			} else if (rc != SQLITE_ROW) {
351: 				// error
352: 				if (pzErrMsg) {
353: 					auto errmsg = sqlite3_errmsg(db);
354: 					*pzErrMsg = errmsg ? sqlite3_strdup(errmsg) : nullptr;
355: 				}
356: 				goto exec_out;
357: 			}
358: 		}
359: 
360: 		sqlite3_free(azCols);
361: 		sqlite3_free(azVals);
362: 		azCols = nullptr;
363: 		azVals = nullptr;
364: 	}
365: 
366: exec_out:
367: 	if (pStmt) {
368: 		sqlite3_finalize(pStmt);
369: 	}
370: 	sqlite3_free(azCols);
371: 	sqlite3_free(azVals);
372: 	if (rc != SQLITE_OK && pzErrMsg && !*pzErrMsg) {
373: 		// error but no error message set
374: 		*pzErrMsg = sqlite3_strdup("Unknown error in DuckDB!");
375: 	}
376: 	return rc;
377: }
378: 
379: /* Return the text of the SQL that was used to prepare the statement */
380: const char *sqlite3_sql(sqlite3_stmt *pStmt) {
381: 	return pStmt->query_string.c_str();
382: }
383: 
384: int sqlite3_column_count(sqlite3_stmt *pStmt) {
385: 	if (!pStmt || !pStmt->prepared) {
386: 		return 0;
387: 	}
388: 	return (int)pStmt->prepared->ColumnCount();
389: }
390: 
391: ////////////////////////////
392: //     sqlite3_column     //
393: ////////////////////////////
394: int sqlite3_column_type(sqlite3_stmt *pStmt, int iCol) {
395: 	if (!pStmt || !pStmt->result || !pStmt->current_chunk) {
396: 		return 0;
397: 	}
398: 	if (FlatVector::IsNull(pStmt->current_chunk->data[iCol], pStmt->current_row)) {
399: 		return SQLITE_NULL;
400: 	}
401: 	auto column_type = pStmt->result->types[iCol];
402: 	switch (column_type.id()) {
403: 	case LogicalTypeId::BOOLEAN:
404: 	case LogicalTypeId::TINYINT:
405: 	case LogicalTypeId::SMALLINT:
406: 	case LogicalTypeId::INTEGER:
407: 	case LogicalTypeId::BIGINT: /* TODO: Maybe blob? */
408: 		return SQLITE_INTEGER;
409: 	case LogicalTypeId::FLOAT:
410: 	case LogicalTypeId::DOUBLE:
411: 	case LogicalTypeId::DECIMAL:
412: 		return SQLITE_FLOAT;
413: 	case LogicalTypeId::DATE:
414: 	case LogicalTypeId::TIME:
415: 	case LogicalTypeId::TIMESTAMP:
416: 	case LogicalTypeId::TIMESTAMP_SEC:
417: 	case LogicalTypeId::TIMESTAMP_MS:
418: 	case LogicalTypeId::TIMESTAMP_NS:
419: 	case LogicalTypeId::VARCHAR:
420: 	case LogicalTypeId::LIST:
421: 	case LogicalTypeId::STRUCT:
422: 	case LogicalTypeId::MAP:
423: 		return SQLITE_TEXT;
424: 	case LogicalTypeId::BLOB:
425: 		return SQLITE_BLOB;
426: 	default:
427: 		// TODO(wangfenjin): agg function don't have type?
428: 		return SQLITE_TEXT;
429: 	}
430: 	return 0;
431: }
432: 
433: const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N) {
434: 	if (!pStmt || !pStmt->prepared) {
435: 		return nullptr;
436: 	}
437: 	return pStmt->prepared->GetNames()[N].c_str();
438: }
439: 
440: static bool sqlite3_column_has_value(sqlite3_stmt *pStmt, int iCol, LogicalType target_type, Value &val) {
441: 	if (!pStmt || !pStmt->result || !pStmt->current_chunk) {
442: 		return false;
443: 	}
444: 	if (iCol < 0 || iCol >= (int)pStmt->result->types.size()) {
445: 		return false;
446: 	}
447: 	if (FlatVector::IsNull(pStmt->current_chunk->data[iCol], pStmt->current_row)) {
448: 		return false;
449: 	}
450: 	try {
451: 		val =
452: 		    pStmt->current_chunk->data[iCol].GetValue(pStmt->current_row).CastAs(*pStmt->db->con->context, target_type);
453: 	} catch (...) {
454: 		return false;
455: 	}
456: 	return true;
457: }
458: 
459: double sqlite3_column_double(sqlite3_stmt *stmt, int iCol) {
460: 	Value val;
461: 	if (!sqlite3_column_has_value(stmt, iCol, LogicalType::DOUBLE, val)) {
462: 		return 0;
463: 	}
464: 	return DoubleValue::Get(val);
465: }
466: 
467: int sqlite3_column_int(sqlite3_stmt *stmt, int iCol) {
468: 	Value val;
469: 	if (!sqlite3_column_has_value(stmt, iCol, LogicalType::INTEGER, val)) {
470: 		return 0;
471: 	}
472: 	return IntegerValue::Get(val);
473: }
474: 
475: sqlite3_int64 sqlite3_column_int64(sqlite3_stmt *stmt, int iCol) {
476: 	Value val;
477: 	if (!sqlite3_column_has_value(stmt, iCol, LogicalType::BIGINT, val)) {
478: 		return 0;
479: 	}
480: 	return BigIntValue::Get(val);
481: }
482: 
483: const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int iCol) {
484: 	Value val;
485: 	if (!sqlite3_column_has_value(pStmt, iCol, LogicalType::VARCHAR, val)) {
486: 		return nullptr;
487: 	}
488: 	try {
489: 		if (!pStmt->current_text) {
490: 			pStmt->current_text =
491: 			    unique_ptr<sqlite3_string_buffer[]>(new sqlite3_string_buffer[pStmt->result->types.size()]);
492: 		}
493: 		auto &entry = pStmt->current_text[iCol];
494: 		if (!entry.data) {
495: 			// not initialized yet, convert the value and initialize it
496: 			auto &str_val = StringValue::Get(val);
497: 			entry.data = unique_ptr<char[]>(new char[str_val.size() + 1]);
498: 			memcpy(entry.data.get(), str_val.c_str(), str_val.size() + 1);
499: 			entry.data_len = str_val.length();
500: 		}
501: 		return (const unsigned char *)entry.data.get();
502: 	} catch (...) {
503: 		// memory error!
504: 		return nullptr;
505: 	}
506: }
507: 
508: const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int iCol) {
509: 	Value val;
510: 	if (!sqlite3_column_has_value(pStmt, iCol, LogicalType::BLOB, val)) {
511: 		return nullptr;
512: 	}
513: 	try {
514: 		if (!pStmt->current_text) {
515: 			pStmt->current_text =
516: 			    unique_ptr<sqlite3_string_buffer[]>(new sqlite3_string_buffer[pStmt->result->types.size()]);
517: 		}
518: 		auto &entry = pStmt->current_text[iCol];
519: 		if (!entry.data) {
520: 			// not initialized yet, convert the value and initialize it
521: 			auto &str_val = StringValue::Get(val);
522: 			entry.data = unique_ptr<char[]>(new char[str_val.size() + 1]);
523: 			memcpy(entry.data.get(), str_val.c_str(), str_val.size() + 1);
524: 			entry.data_len = str_val.length();
525: 		}
526: 		return (const unsigned char *)entry.data.get();
527: 	} catch (...) {
528: 		// memory error!
529: 		return nullptr;
530: 	}
531: }
532: 
533: ////////////////////////////
534: //      sqlite3_bind      //
535: ////////////////////////////
536: int sqlite3_bind_parameter_count(sqlite3_stmt *stmt) {
537: 	if (!stmt) {
538: 		return 0;
539: 	}
540: 	return stmt->prepared->n_param;
541: }
542: 
543: const char *sqlite3_bind_parameter_name(sqlite3_stmt *stmt, int idx) {
544: 	if (!stmt) {
545: 		return nullptr;
546: 	}
547: 	if (idx < 1 || idx > (int)stmt->prepared->n_param) {
548: 		return nullptr;
549: 	}
550: 	return stmt->bound_names[idx - 1].c_str();
551: }
552: 
553: int sqlite3_bind_parameter_index(sqlite3_stmt *stmt, const char *zName) {
554: 	if (!stmt || !zName) {
555: 		return 0;
556: 	}
557: 	for (idx_t i = 0; i < stmt->bound_names.size(); i++) {
558: 		if (stmt->bound_names[i] == string(zName)) {
559: 			return i + 1;
560: 		}
561: 	}
562: 	return 0;
563: }
564: 
565: int sqlite3_internal_bind_value(sqlite3_stmt *stmt, int idx, Value value) {
566: 	if (!stmt || !stmt->prepared || stmt->result) {
567: 		return SQLITE_MISUSE;
568: 	}
569: 	if (idx < 1 || idx > (int)stmt->prepared->n_param) {
570: 		return SQLITE_RANGE;
571: 	}
572: 	stmt->bound_values[idx - 1] = value;
573: 	return SQLITE_OK;
574: }
575: 
576: int sqlite3_bind_int(sqlite3_stmt *stmt, int idx, int val) {
577: 	return sqlite3_internal_bind_value(stmt, idx, Value::INTEGER(val));
578: }
579: 
580: int sqlite3_bind_int64(sqlite3_stmt *stmt, int idx, sqlite3_int64 val) {
581: 	return sqlite3_internal_bind_value(stmt, idx, Value::BIGINT(val));
582: }
583: 
584: int sqlite3_bind_double(sqlite3_stmt *stmt, int idx, double val) {
585: 	return sqlite3_internal_bind_value(stmt, idx, Value::DOUBLE(val));
586: }
587: 
588: int sqlite3_bind_null(sqlite3_stmt *stmt, int idx) {
589: 	return sqlite3_internal_bind_value(stmt, idx, Value());
590: }
591: 
592: SQLITE_API int sqlite3_bind_value(sqlite3_stmt *, int, const sqlite3_value *) {
593: 	fprintf(stderr, "sqlite3_bind_value: unsupported.\n");
594: 	return SQLITE_ERROR;
595: }
596: 
597: int sqlite3_bind_text(sqlite3_stmt *stmt, int idx, const char *val, int length, void (*free_func)(void *)) {
598: 	if (!val) {
599: 		return SQLITE_MISUSE;
600: 	}
601: 	string value;
602: 	if (length < 0) {
603: 		value = string(val);
604: 	} else {
605: 		value = string(val, length);
606: 	}
607: 	if (free_func && ((ptrdiff_t)free_func) != -1) {
608: 		free_func((void *)val);
609: 		val = nullptr;
610: 	}
611: 	try {
612: 		return sqlite3_internal_bind_value(stmt, idx, Value(value));
613: 	} catch (std::exception &ex) {
614: 		return SQLITE_ERROR;
615: 	}
616: }
617: 
618: int sqlite3_bind_blob(sqlite3_stmt *stmt, int idx, const void *val, int length, void (*free_func)(void *)) {
619: 	if (!val) {
620: 		return SQLITE_MISUSE;
621: 	}
622: 	Value blob;
623: 	if (length < 0) {
624: 		blob = Value::BLOB(string((const char *)val));
625: 	} else {
626: 		blob = Value::BLOB((const_data_ptr_t)val, length);
627: 	}
628: 	if (free_func && ((ptrdiff_t)free_func) != -1) {
629: 		free_func((void *)val);
630: 		val = nullptr;
631: 	}
632: 	try {
633: 		return sqlite3_internal_bind_value(stmt, idx, blob);
634: 	} catch (std::exception &ex) {
635: 		return SQLITE_ERROR;
636: 	}
637: }
638: 
639: SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt *stmt, int idx, int length) {
640: 	fprintf(stderr, "sqlite3_bind_zeroblob: unsupported.\n");
641: 	return SQLITE_ERROR;
642: }
643: 
644: int sqlite3_clear_bindings(sqlite3_stmt *stmt) {
645: 	if (!stmt) {
646: 		return SQLITE_MISUSE;
647: 	}
648: 	return SQLITE_OK;
649: }
650: 
651: int sqlite3_initialize(void) {
652: 	return SQLITE_OK;
653: }
654: 
655: int sqlite3_finalize(sqlite3_stmt *pStmt) {
656: 	if (pStmt) {
657: 		if (pStmt->result && pStmt->result->HasError()) {
658: 			pStmt->db->last_error = pStmt->result->GetErrorObject();
659: 			delete pStmt;
660: 			return SQLITE_ERROR;
661: 		}
662: 
663: 		delete pStmt;
664: 	}
665: 	return SQLITE_OK;
666: }
667: 
668: /*
669: ** Some systems have stricmp().  Others have strcasecmp().  Because
670: ** there is no consistency, we will define our own.
671: **
672: ** IMPLEMENTATION-OF: R-30243-02494 The sqlite3_stricmp() and
673: ** sqlite3_strnicmp() APIs allow applications and extensions to compare
674: ** the contents of two buffers containing UTF-8 strings in a
675: ** case-independent fashion, using the same definition of "case
676: ** independence" that SQLite uses internally when comparing identifiers.
677: */
678: 
679: const unsigned char sqlite3UpperToLower[] = {
680:     0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,
681:     22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,
682:     44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  97,
683:     98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
684:     120, 121, 122, 91,  92,  93,  94,  95,  96,  97,  98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
685:     110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131,
686:     132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153,
687:     154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
688:     176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197,
689:     198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219,
690:     220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241,
691:     242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255};
692: 
693: int sqlite3StrICmp(const char *zLeft, const char *zRight) {
694: 	unsigned char *a, *b;
695: 	int c;
696: 	a = (unsigned char *)zLeft;
697: 	b = (unsigned char *)zRight;
698: 	for (;;) {
699: 		c = (int)sqlite3UpperToLower[*a] - (int)sqlite3UpperToLower[*b];
700: 		if (c || *a == 0)
701: 			break;
702: 		a++;
703: 		b++;
704: 	}
705: 	return c;
706: }
707: 
708: SQLITE_API int sqlite3_stricmp(const char *zLeft, const char *zRight) {
709: 	if (zLeft == 0) {
710: 		return zRight ? -1 : 0;
711: 	} else if (zRight == 0) {
712: 		return 1;
713: 	}
714: 	return sqlite3StrICmp(zLeft, zRight);
715: }
716: 
717: SQLITE_API int sqlite3_strnicmp(const char *zLeft, const char *zRight, int N) {
718: 	unsigned char *a, *b;
719: 	if (zLeft == 0) {
720: 		return zRight ? -1 : 0;
721: 	} else if (zRight == 0) {
722: 		return 1;
723: 	}
724: 	a = (unsigned char *)zLeft;
725: 	b = (unsigned char *)zRight;
726: 	while (N-- > 0 && *a != 0 && sqlite3UpperToLower[*a] == sqlite3UpperToLower[*b]) {
727: 		a++;
728: 		b++;
729: 	}
730: 	return N < 0 ? 0 : sqlite3UpperToLower[*a] - sqlite3UpperToLower[*b];
731: }
732: 
733: char *sqlite3_strdup(const char *str) {
734: 	char *result = (char *)sqlite3_malloc64(strlen(str) + 1);
735: 	strcpy(result, str);
736: 	return result;
737: }
738: 
739: void *sqlite3_malloc64(sqlite3_uint64 n) {
740: 	return malloc(n);
741: }
742: 
743: void sqlite3_free(void *pVoid) {
744: 	free(pVoid);
745: }
746: 
747: void *sqlite3_malloc(int n) {
748: 	return sqlite3_malloc64(n);
749: }
750: 
751: void *sqlite3_realloc(void *ptr, int n) {
752: 	return sqlite3_realloc64(ptr, n);
753: }
754: 
755: void *sqlite3_realloc64(void *ptr, sqlite3_uint64 n) {
756: 	return realloc(ptr, n);
757: }
758: 
759: // TODO: stub
760: int sqlite3_config(int i, ...) {
761: 	return SQLITE_OK;
762: }
763: 
764: int sqlite3_errcode(sqlite3 *db) {
765: 	if (!db) {
766: 		return SQLITE_NOMEM;
767: 	}
768: 	// return db->last_error.empty() ? SQLITE_OK : SQLITE_ERROR;
769: 	return db->errCode; //! We should return the exact error code
770: }
771: 
772: int sqlite3_extended_errcode(sqlite3 *db) {
773: 	return sqlite3_errcode(db);
774: }
775: 
776: const char *sqlite3_errmsg(sqlite3 *db) {
777: 	if (!db) {
778: 		return "";
779: 	}
780: 	return db->last_error.Message().c_str();
781: }
782: 
783: void sqlite3_interrupt(sqlite3 *db) {
784: 	if (db && db->con) {
785: 		db->con->Interrupt();
786: 	}
787: }
788: 
789: const char *sqlite3_libversion(void) {
790: 	return DuckDB::LibraryVersion();
791: }
792: 
793: const char *sqlite3_sourceid(void) {
794: 	return DuckDB::SourceID();
795: }
796: 
797: int sqlite3_reset(sqlite3_stmt *stmt) {
798: 	if (stmt) {
799: 		stmt->result = nullptr;
800: 		stmt->current_chunk = nullptr;
801: 	}
802: 	return SQLITE_OK;
803: }
804: 
805: // support functions for shell.c
806: // most are dummies, we don't need them really
807: 
808: int sqlite3_db_status(sqlite3 *, int op, int *pCur, int *pHiwtr, int resetFlg) {
809: 	fprintf(stderr, "sqlite3_db_status: unsupported.\n");
810: 	return -1;
811: }
812: 
813: int sqlite3_changes(sqlite3 *db) {
814: 	return db->last_changes;
815: }
816: 
817: int sqlite3_total_changes(sqlite3 *db) {
818: 	return db->total_changes;
819: }
820: 
821: SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3 *db) {
822: 	return SQLITE_ERROR;
823: }
824: 
825: // some code borrowed from sqlite
826: // its probably best to match its behavior
827: 
828: typedef uint8_t u8;
829: 
830: /*
831: ** Token types used by the sqlite3_complete() routine.  See the header
832: ** comments on that procedure for additional information.
833: */
834: #define tkSEMI  0
835: #define tkWS    1
836: #define tkOTHER 2
837: 
838: const unsigned char sqlite3CtypeMap[256] = {
839:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 00..07    ........ */
840:     0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, /* 08..0f    ........ */
841:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 10..17    ........ */
842:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 18..1f    ........ */
843:     0x01, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x80, /* 20..27     !"#$%&' */
844:     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 28..2f    ()*+,-./ */
845:     0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, /* 30..37    01234567 */
846:     0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* 38..3f    89:;<=>? */
847: 
848:     0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x02, /* 40..47    @ABCDEFG */
849:     0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, /* 48..4f    HIJKLMNO */
850:     0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, /* 50..57    PQRSTUVW */
851:     0x02, 0x02, 0x02, 0x80, 0x00, 0x00, 0x00, 0x40, /* 58..5f    XYZ[\]^_ */
852:     0x80, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x22, /* 60..67    `abcdefg */
853:     0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, /* 68..6f    hijklmno */
854:     0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, /* 70..77    pqrstuvw */
855:     0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, /* 78..7f    xyz{|}~. */
856: 
857:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* 80..87    ........ */
858:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* 88..8f    ........ */
859:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* 90..97    ........ */
860:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* 98..9f    ........ */
861:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* a0..a7    ........ */
862:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* a8..af    ........ */
863:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* b0..b7    ........ */
864:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* b8..bf    ........ */
865: 
866:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* c0..c7    ........ */
867:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* c8..cf    ........ */
868:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* d0..d7    ........ */
869:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* d8..df    ........ */
870:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* e0..e7    ........ */
871:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* e8..ef    ........ */
872:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, /* f0..f7    ........ */
873:     0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40  /* f8..ff    ........ */
874: };
875: 
876: // TODO this can probably be simplified
877: #define IdChar(C) ((sqlite3CtypeMap[(unsigned char)C] & 0x46) != 0)
878: 
879: int sqlite3_complete(const char *zSql) {
880: 	u8 state = 0; /* Current state, using numbers defined in header comment */
881: 	u8 token;     /* Value of the next token */
882: 
883: 	/* If triggers are not supported by this compile then the statement machine
884: 	 ** used to detect the end of a statement is much simpler
885: 	 */
886: 	static const u8 trans[3][3] = {
887: 	    /* Token:           */
888: 	    /* State:       **  SEMI  WS  OTHER */
889: 	    /* 0 INVALID: */ {
890: 	        1,
891: 	        0,
892: 	        2,
893: 	    },
894: 	    /* 1   START: */
895: 	    {
896: 	        1,
897: 	        1,
898: 	        2,
899: 	    },
900: 	    /* 2  NORMAL: */
901: 	    {
902: 	        1,
903: 	        2,
904: 	        2,
905: 	    },
906: 	};
907: 
908: 	while (*zSql) {
909: 		switch (*zSql) {
910: 		case ';': { /* A semicolon */
911: 			token = tkSEMI;
912: 			break;
913: 		}
914: 		case ' ':
915: 		case '\r':
916: 		case '\t':
917: 		case '\n':
918: 		case '\f': { /* White space is ignored */
919: 			token = tkWS;
920: 			break;
921: 		}
922: 		case '/': { /* C-style comments */
923: 			if (zSql[1] != '*') {
924: 				token = tkOTHER;
925: 				break;
926: 			}
927: 			zSql += 2;
928: 			while (zSql[0] && (zSql[0] != '*' || zSql[1] != '/')) {
929: 				zSql++;
930: 			}
931: 			if (zSql[0] == 0)
932: 				return 0;
933: 			zSql++;
934: 			token = tkWS;
935: 			break;
936: 		}
937: 		case '-': { /* SQL-style comments from "--" to end of line */
938: 			if (zSql[1] != '-') {
939: 				token = tkOTHER;
940: 				break;
941: 			}
942: 			while (*zSql && *zSql != '\n') {
943: 				zSql++;
944: 			}
945: 			if (*zSql == 0)
946: 				return state == 1;
947: 			token = tkWS;
948: 			break;
949: 		}
950: 		case '`': /* Grave-accent quoted symbols used by MySQL */
951: 		case '"': /* single- and double-quoted strings */
952: 		case '\'': {
953: 			int c = *zSql;
954: 			zSql++;
955: 			while (*zSql && *zSql != c) {
956: 				zSql++;
957: 			}
958: 			if (*zSql == 0)
959: 				return 0;
960: 			token = tkOTHER;
961: 			break;
962: 		}
963: 		default: {
964: 
965: 			if (IdChar((u8)*zSql)) {
966: 				/* Keywords and unquoted identifiers */
967: 				int nId;
968: 				for (nId = 1; IdChar(zSql[nId]); nId++) {
969: 				}
970: 				token = tkOTHER;
971: 
972: 				zSql += nId - 1;
973: 			} else {
974: 				/* Operators and special symbols */
975: 				token = tkOTHER;
976: 			}
977: 			break;
978: 		}
979: 		}
980: 		state = trans[state][token];
981: 		zSql++;
982: 	}
983: 	return state == 1;
984: }
985: 
986: // checks if input ends with ;
987: int sqlite3_complete_old(const char *sql) {
988: 	fprintf(stderr, "sqlite3_complete: unsupported. '%s'\n", sql);
989: 	return -1;
990: }
991: 
992: // length of varchar or blob value
993: int sqlite3_column_bytes(sqlite3_stmt *pStmt, int iCol) {
994: 	// fprintf(stderr, "sqlite3_column_bytes: unsupported.\n");
995: 	return pStmt->current_text[iCol].data_len;
996: 	// return -1;
997: }
998: 
999: sqlite3_value *sqlite3_column_value(sqlite3_stmt *, int iCol) {
1000: 	fprintf(stderr, "sqlite3_column_value: unsupported.\n");
1001: 	return nullptr;
1002: }
1003: 
1004: int sqlite3_db_config(sqlite3 *, int op, ...) {
1005: 	fprintf(stderr, "sqlite3_db_config: unsupported.\n");
1006: 	return -1;
1007: }
1008: 
1009: int sqlite3_get_autocommit(sqlite3 *db) {
1010: 	return db->con->context->transaction.IsAutoCommit();
1011: }
1012: 
1013: int sqlite3_limit(sqlite3 *, int id, int newVal) {
1014: 	fprintf(stderr, "sqlite3_limit: unsupported.\n");
1015: 	return -1;
1016: }
1017: 
1018: int sqlite3_stmt_readonly(sqlite3_stmt *pStmt) {
1019: 	fprintf(stderr, "sqlite3_stmt_readonly: unsupported.\n");
1020: 	return -1;
1021: }
1022: 
1023: // TODO pretty easy schema lookup
1024: int sqlite3_table_column_metadata(sqlite3 *db,             /* Connection handle */
1025:                                   const char *zDbName,     /* Database name or NULL */
1026:                                   const char *zTableName,  /* Table name */
1027:                                   const char *zColumnName, /* Column name */
1028:                                   char const **pzDataType, /* OUTPUT: Declared data type */
1029:                                   char const **pzCollSeq,  /* OUTPUT: Collation sequence name */
1030:                                   int *pNotNull,           /* OUTPUT: True if NOT NULL constraint exists */
1031:                                   int *pPrimaryKey,        /* OUTPUT: True if column part of PK */
1032:                                   int *pAutoinc            /* OUTPUT: True if column is auto-increment */
1033: ) {
1034: 	fprintf(stderr, "sqlite3_table_column_metadata: unsupported.\n");
1035: 	return -1;
1036: }
1037: 
1038: const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int iCol) {
1039: 	if (!pStmt || !pStmt->prepared) {
1040: 		return NULL;
1041: 	}
1042: 	auto column_type = pStmt->prepared->GetTypes()[iCol];
1043: 	switch (column_type.id()) {
1044: 	case LogicalTypeId::BOOLEAN:
1045: 		return "BOOLEAN";
1046: 	case LogicalTypeId::TINYINT:
1047: 		return "TINYINT";
1048: 	case LogicalTypeId::SMALLINT:
1049: 		return "SMALLINT";
1050: 	case LogicalTypeId::INTEGER:
1051: 		return "INTEGER";
1052: 	case LogicalTypeId::BIGINT:
1053: 		return "BIGINT";
1054: 	case LogicalTypeId::FLOAT:
1055: 		return "FLOAT";
1056: 	case LogicalTypeId::DOUBLE:
1057: 		return "DOUBLE";
1058: 	case LogicalTypeId::DECIMAL:
1059: 		return "DECIMAL";
1060: 	case LogicalTypeId::DATE:
1061: 		return "DATE";
1062: 	case LogicalTypeId::TIME:
1063: 		return "TIME";
1064: 	case LogicalTypeId::TIMESTAMP:
1065: 	case LogicalTypeId::TIMESTAMP_NS:
1066: 	case LogicalTypeId::TIMESTAMP_MS:
1067: 	case LogicalTypeId::TIMESTAMP_SEC:
1068: 		return "TIMESTAMP";
1069: 	case LogicalTypeId::VARCHAR:
1070: 		return "VARCHAR";
1071: 	case LogicalTypeId::LIST:
1072: 		return "LIST";
1073: 	case LogicalTypeId::MAP:
1074: 		return "MAP";
1075: 	case LogicalTypeId::STRUCT:
1076: 		return "STRUCT";
1077: 	case LogicalTypeId::BLOB:
1078: 		return "BLOB";
1079: 	default:
1080: 		return NULL;
1081: 	}
1082: 	return NULL;
1083: }
1084: 
1085: int sqlite3_status64(int op, sqlite3_int64 *pCurrent, sqlite3_int64 *pHighwater, int resetFlag) {
1086: 	fprintf(stderr, "sqlite3_status64: unsupported.\n");
1087: 	return -1;
1088: }
1089: 
1090: int sqlite3_status64(sqlite3 *, int op, int *pCur, int *pHiwtr, int resetFlg) {
1091: 	fprintf(stderr, "sqlite3_status64: unsupported.\n");
1092: 	return -1;
1093: }
1094: 
1095: int sqlite3_stmt_status(sqlite3_stmt *, int op, int resetFlg) {
1096: 	fprintf(stderr, "sqlite3_stmt_status: unsupported.\n");
1097: 	return -1;
1098: }
1099: 
1100: int sqlite3_file_control(sqlite3 *, const char *zDbName, int op, void *ptr) {
1101: 	switch (op) {
1102: 	case SQLITE_FCNTL_TEMPFILENAME: {
1103: 		auto char_arg = (char **)ptr;
1104: 		*char_arg = nullptr;
1105: 		return -1;
1106: 	}
1107: 	default:
1108: 		break;
1109: 	}
1110: 	fprintf(stderr, "sqlite3_file_control op %d: unsupported.\n", op);
1111: 	return -1;
1112: }
1113: 
1114: int sqlite3_declare_vtab(sqlite3 *, const char *zSQL) {
1115: 	fprintf(stderr, "sqlite3_declare_vtab: unsupported.\n");
1116: 	return -1;
1117: }
1118: 
1119: const char *sqlite3_vtab_collation(sqlite3_index_info *, int) {
1120: 	fprintf(stderr, "sqlite3_vtab_collation: unsupported.\n");
1121: 	return nullptr;
1122: }
1123: 
1124: int sqlite3_sleep(int ms) {
1125: 	std::this_thread::sleep_for(std::chrono::milliseconds(ms));
1126: 	return ms;
1127: }
1128: 
1129: int sqlite3_busy_timeout(sqlite3 *, int ms) {
1130: 	fprintf(stderr, "sqlite3_busy_timeout: unsupported.\n");
1131: 	return -1;
1132: }
1133: 
1134: // unlikely to be supported
1135: 
1136: int sqlite3_trace_v2(sqlite3 *, unsigned uMask, int (*xCallback)(unsigned, void *, void *, void *), void *pCtx) {
1137: 	fprintf(stderr, "sqlite3_trace_v2: unsupported.\n");
1138: 	return -1;
1139: }
1140: 
1141: int sqlite3_test_control(int op, ...) {
1142: 	fprintf(stderr, "sqlite3_test_control: unsupported.\n");
1143: 	return -1;
1144: }
1145: 
1146: int sqlite3_enable_load_extension(sqlite3 *db, int onoff) {
1147: 	// fprintf(stderr, "sqlite3_enable_load_extension: unsupported.\n");
1148: 	return -1;
1149: }
1150: 
1151: int sqlite3_load_extension(sqlite3 *db,       /* Load the extension into this database connection */
1152:                            const char *zFile, /* Name of the shared library containing extension */
1153:                            const char *zProc, /* Entry point.  Derived from zFile if 0 */
1154:                            char **pzErrMsg    /* Put error message here if not 0 */
1155: ) {
1156: 	// fprintf(stderr, "sqlite3_load_extension: unsupported.\n");
1157: 	return -1;
1158: }
1159: 
1160: int sqlite3_create_module(sqlite3 *db,             /* SQLite connection to register module with */
1161:                           const char *zName,       /* Name of the module */
1162:                           const sqlite3_module *p, /* Methods for the module */
1163:                           void *pClientData        /* Client data for xCreate/xConnect */
1164: ) {
1165: 	// fprintf(stderr, "sqlite3_create_module: unsupported.\n");
1166: 	return -1;
1167: }
1168: 
1169: int sqlite3_create_function(sqlite3 *db, const char *zFunctionName, int nArg, int eTextRep, void *pApp,
1170:                             void (*xFunc)(sqlite3_context *, int, sqlite3_value **),
1171:                             void (*xStep)(sqlite3_context *, int, sqlite3_value **),
1172:                             void (*xFinal)(sqlite3_context *)) {
1173: 	if ((!xFunc && !xStep && !xFinal) || !zFunctionName || nArg < -1) {
1174: 		return SQLITE_MISUSE;
1175: 	}
1176: 	string fname = string(zFunctionName);
1177: 
1178: 	// Scalar function
1179: 	if (!xFunc) {
1180: 		return SQLITE_MISUSE;
1181: 	}
1182: 	auto udf_sqlite3 = SQLiteUDFWrapper::CreateSQLiteScalarFunction(xFunc, db, pApp);
1183: 	LogicalType varargs = LogicalType::INVALID;
1184: 	if (nArg == -1) {
1185: 		varargs = LogicalType::ANY;
1186: 		nArg = 0;
1187: 	}
1188: 
1189: 	vector<LogicalType> argv_types(nArg);
1190: 	for (idx_t i = 0; i < (idx_t)nArg; ++i) {
1191: 		argv_types[i] = LogicalType::ANY;
1192: 	}
1193: 
1194: 	UDFWrapper::RegisterFunction(fname, argv_types, LogicalType::VARCHAR, udf_sqlite3, *(db->con->context), varargs);
1195: 	return SQLITE_OK;
1196: }
1197: 
1198: int sqlite3_create_function_v2(sqlite3 *db, const char *zFunctionName, int nArg, int eTextRep, void *pApp,
1199:                                void (*xFunc)(sqlite3_context *, int, sqlite3_value **),
1200:                                void (*xStep)(sqlite3_context *, int, sqlite3_value **),
1201:                                void (*xFinal)(sqlite3_context *), void (*xDestroy)(void *)) {
1202: 	return -1;
1203: }
1204: 
1205: int sqlite3_set_authorizer(sqlite3 *, int (*xAuth)(void *, int, const char *, const char *, const char *, const char *),
1206:                            void *pUserData) {
1207: 	fprintf(stderr, "sqlite3_set_authorizer: unsupported.\n");
1208: 	return -1;
1209: }
1210: 
1211: // needed in shell timer
1212: static int unixCurrentTimeInt64(sqlite3_vfs *NotUsed, sqlite3_int64 *piNow) {
1213: 	using namespace std::chrono;
1214: 	*piNow = (sqlite3_int64)duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();
1215: 	return SQLITE_OK;
1216: }
1217: 
1218: static sqlite3_vfs static_sqlite3_virtual_file_systems[] = {{
1219:     3,                    // int iVersion;            /* Structure version number (currently 3) */
1220:     0,                    // int szOsFile;            /* Size of subclassed sqlite3_file */
1221:     0,                    // int mxPathname;          /* Maximum file pathname length */
1222:     nullptr,              // sqlite3_vfs *pNext;      /* Next registered VFS */
1223:     "dummy",              // const char *zName;       /* Name of this virtual file system */
1224:     nullptr,              // void *pAppData;          /* Pointer to application-specific data */
1225:     nullptr,              // int (*xOpen)(sqlite3_vfs*, const char *zName, sqlite3_file*, int flags, int *pOutFlags);
1226:     nullptr,              // int (*xDelete)(sqlite3_vfs*, const char *zName, int syncDir);
1227:     nullptr,              // int (*xAccess)(sqlite3_vfs*, const char *zName, int flags, int *pResOut);
1228:     nullptr,              // int (*xFullPathname)(sqlite3_vfs*, const char *zName, int nOut, char *zOut);
1229:     nullptr,              // void *(*xDlOpen)(sqlite3_vfs*, const char *zFilename);
1230:     nullptr,              // void (*xDlError)(sqlite3_vfs*, int nByte, char *zErrMsg);
1231:     nullptr,              // void (*(*xDlSym)(sqlite3_vfs*,void*, const char *zSymbol))(void);
1232:     nullptr,              // void (*xDlClose)(sqlite3_vfs*, void*);
1233:     nullptr,              // int (*xRandomness)(sqlite3_vfs*, int nByte, char *zOut);
1234:     nullptr,              // int (*xSleep)(sqlite3_vfs*, int microseconds);
1235:     nullptr,              // int (*xCurrentTime)(sqlite3_vfs*, double*);
1236:     nullptr,              // int (*xGetLastError)(sqlite3_vfs*, int, char *);
1237:     unixCurrentTimeInt64, // int (*xCurrentTimeInt64)(sqlite3_vfs*, sqlite3_int64*);
1238:     nullptr,              // int (*xSetSystemCall)(sqlite3_vfs*, const char *zName, sqlite3_syscall_ptr);
1239:     nullptr,              // sqlite3_syscall_ptr (*xGetSystemCall)(sqlite3_vfs*, const char *zName);
1240:     nullptr               // const char *(*xNextSystemCall)(sqlite3_vfs*, const char *zName);
1241: }};
1242: 
1243: // virtual file system, providing some dummies to avoid crashes
1244: sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName) {
1245: 	// return a dummy because the shell does not check the return code.
1246: 	return static_sqlite3_virtual_file_systems;
1247: }
1248: 
1249: int sqlite3_vfs_register(sqlite3_vfs *, int makeDflt) {
1250: 	// fprintf(stderr, "sqlite3_vfs_register: unsupported.\n");
1251: 	return -1;
1252: }
1253: 
1254: // backups, unused
1255: 
1256: int sqlite3_backup_step(sqlite3_backup *p, int nPage) {
1257: 	fprintf(stderr, "sqlite3_backup_step: unsupported.\n");
1258: 	return -1;
1259: }
1260: 
1261: int sqlite3_backup_finish(sqlite3_backup *p) {
1262: 	fprintf(stderr, "sqlite3_backup_finish: unsupported.\n");
1263: 	return -1;
1264: }
1265: 
1266: sqlite3_backup *sqlite3_backup_init(sqlite3 *pDest,         /* Destination database handle */
1267:                                     const char *zDestName,  /* Destination database name */
1268:                                     sqlite3 *pSource,       /* Source database handle */
1269:                                     const char *zSourceName /* Source database name */
1270: ) {
1271: 	fprintf(stderr, "sqlite3_backup_init: unsupported.\n");
1272: 	return nullptr;
1273: }
1274: 
1275: // UDF support stuff, unused for now. These cannot be called as create_function above is disabled
1276: 
1277: SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context *) {
1278: 	return nullptr;
1279: }
1280: 
1281: void *sqlite3_user_data(sqlite3_context *context) {
1282: 	assert(context);
1283: 	return context->pFunc.pUserData;
1284: }
1285: 
1286: #ifdef _WIN32
1287: #include <windows.h>
1288: 
1289: static void *sqlite3MallocZero(size_t n) {
1290: 	auto res = sqlite3_malloc(n);
1291: 	assert(res);
1292: 	memset(res, 0, n);
1293: 	return res;
1294: }
1295: 
1296: static LPWSTR winUtf8ToUnicode(const char *zText) {
1297: 	int nChar;
1298: 	LPWSTR zWideText;
1299: 
1300: 	nChar = MultiByteToWideChar(CP_UTF8, 0, zText, -1, NULL, 0);
1301: 	if (nChar == 0) {
1302: 		return 0;
1303: 	}
1304: 	zWideText = (LPWSTR)sqlite3MallocZero(nChar * sizeof(WCHAR));
1305: 	if (zWideText == 0) {
1306: 		return 0;
1307: 	}
1308: 	nChar = MultiByteToWideChar(CP_UTF8, 0, zText, -1, zWideText, nChar);
1309: 	if (nChar == 0) {
1310: 		sqlite3_free(zWideText);
1311: 		zWideText = 0;
1312: 	}
1313: 	return zWideText;
1314: }
1315: 
1316: static char *winUnicodeToMbcs(LPCWSTR zWideText, int useAnsi) {
1317: 	int nByte;
1318: 	char *zText;
1319: 	int codepage = useAnsi ? CP_ACP : CP_OEMCP;
1320: 
1321: 	nByte = WideCharToMultiByte(codepage, 0, zWideText, -1, 0, 0, 0, 0);
1322: 	if (nByte == 0) {
1323: 		return 0;
1324: 	}
1325: 	zText = (char *)sqlite3MallocZero(nByte);
1326: 	if (zText == 0) {
1327: 		return 0;
1328: 	}
1329: 	nByte = WideCharToMultiByte(codepage, 0, zWideText, -1, zText, nByte, 0, 0);
1330: 	if (nByte == 0) {
1331: 		sqlite3_free(zText);
1332: 		zText = 0;
1333: 	}
1334: 	return zText;
1335: }
1336: 
1337: static char *winUtf8ToMbcs(const char *zText, int useAnsi) {
1338: 	char *zTextMbcs;
1339: 	LPWSTR zTmpWide;
1340: 
1341: 	zTmpWide = winUtf8ToUnicode(zText);
1342: 	if (zTmpWide == 0) {
1343: 		return 0;
1344: 	}
1345: 	zTextMbcs = winUnicodeToMbcs(zTmpWide, useAnsi);
1346: 	sqlite3_free(zTmpWide);
1347: 	return zTextMbcs;
1348: }
1349: 
1350: SQLITE_API char *sqlite3_win32_utf8_to_mbcs_v2(const char *zText, int useAnsi) {
1351: 	return winUtf8ToMbcs(zText, useAnsi);
1352: }
1353: 
1354: LPWSTR sqlite3_win32_utf8_to_unicode(const char *zText) {
1355: 	return winUtf8ToUnicode(zText);
1356: }
1357: 
1358: static LPWSTR winMbcsToUnicode(const char *zText, int useAnsi) {
1359: 	int nByte;
1360: 	LPWSTR zMbcsText;
1361: 	int codepage = useAnsi ? CP_ACP : CP_OEMCP;
1362: 
1363: 	nByte = MultiByteToWideChar(codepage, 0, zText, -1, NULL, 0) * sizeof(WCHAR);
1364: 	if (nByte == 0) {
1365: 		return 0;
1366: 	}
1367: 	zMbcsText = (LPWSTR)sqlite3MallocZero(nByte * sizeof(WCHAR));
1368: 	if (zMbcsText == 0) {
1369: 		return 0;
1370: 	}
1371: 	nByte = MultiByteToWideChar(codepage, 0, zText, -1, zMbcsText, nByte);
1372: 	if (nByte == 0) {
1373: 		sqlite3_free(zMbcsText);
1374: 		zMbcsText = 0;
1375: 	}
1376: 	return zMbcsText;
1377: }
1378: 
1379: static char *winUnicodeToUtf8(LPCWSTR zWideText) {
1380: 	int nByte;
1381: 	char *zText;
1382: 
1383: 	nByte = WideCharToMultiByte(CP_UTF8, 0, zWideText, -1, 0, 0, 0, 0);
1384: 	if (nByte == 0) {
1385: 		return 0;
1386: 	}
1387: 	zText = (char *)sqlite3MallocZero(nByte);
1388: 	if (zText == 0) {
1389: 		return 0;
1390: 	}
1391: 	nByte = WideCharToMultiByte(CP_UTF8, 0, zWideText, -1, zText, nByte, 0, 0);
1392: 	if (nByte == 0) {
1393: 		sqlite3_free(zText);
1394: 		zText = 0;
1395: 	}
1396: 	return zText;
1397: }
1398: 
1399: static char *winMbcsToUtf8(const char *zText, int useAnsi) {
1400: 	char *zTextUtf8;
1401: 	LPWSTR zTmpWide;
1402: 
1403: 	zTmpWide = winMbcsToUnicode(zText, useAnsi);
1404: 	if (zTmpWide == 0) {
1405: 		return 0;
1406: 	}
1407: 	zTextUtf8 = winUnicodeToUtf8(zTmpWide);
1408: 	sqlite3_free(zTmpWide);
1409: 	return zTextUtf8;
1410: }
1411: 
1412: SQLITE_API char *sqlite3_win32_mbcs_to_utf8_v2(const char *zText, int useAnsi) {
1413: 	return winMbcsToUtf8(zText, useAnsi);
1414: }
1415: 
1416: SQLITE_API char *sqlite3_win32_unicode_to_utf8(LPCWSTR zWideText) {
1417: 	return winUnicodeToUtf8(zWideText);
1418: }
1419: 
1420: #endif
1421: 
1422: // TODO complain
1423: SQLITE_API void sqlite3_result_blob(sqlite3_context *context, const void *blob, int n_bytes, void (*xDel)(void *)) {
1424: 	sqlite3_result_blob64(context, blob, n_bytes, xDel);
1425: }
1426: 
1427: SQLITE_API void sqlite3_result_blob64(sqlite3_context *context, const void *blob, sqlite3_uint64 n_bytes,
1428:                                       void (*xDel)(void *)) {
1429: 	if (!blob) {
1430: 		context->isError = SQLITE_MISUSE;
1431: 		return;
1432: 	}
1433: 	context->result.type = SQLiteTypeValue::BLOB;
1434: 	context->result.str = string((char *)blob, n_bytes);
1435: 	if (xDel) {
1436: 		xDel((void *)blob);
1437: 	}
1438: }
1439: 
1440: SQLITE_API void sqlite3_result_double(sqlite3_context *context, double val) {
1441: 	context->result.u.r = val;
1442: 	context->result.type = SQLiteTypeValue::FLOAT;
1443: }
1444: 
1445: SQLITE_API void sqlite3_result_error(sqlite3_context *context, const char *msg, int n_bytes) {
1446: 	context->isError = SQLITE_ERROR;
1447: 	sqlite3_result_text(context, msg, n_bytes, nullptr);
1448: }
1449: 
1450: SQLITE_API void sqlite3_result_error16(sqlite3_context *context, const void *msg, int n_bytes) {
1451: 	fprintf(stderr, "sqlite3_result_error16: unsupported.\n");
1452: }
1453: 
1454: SQLITE_API void sqlite3_result_error_toobig(sqlite3_context *context) {
1455: 	sqlite3_result_error(context, "string or blob too big", -1);
1456: }
1457: 
1458: SQLITE_API void sqlite3_result_error_nomem(sqlite3_context *context) {
1459: 	sqlite3_result_error(context, "out of memory", -1);
1460: }
1461: 
1462: SQLITE_API void sqlite3_result_error_code(sqlite3_context *context, int code) {
1463: 	string error_msg;
1464: 	switch (code) {
1465: 	case SQLITE_NOMEM:
1466: 		sqlite3_result_error_nomem(context);
1467: 		return;
1468: 	case SQLITE_TOOBIG:
1469: 		sqlite3_result_error_toobig(context);
1470: 		return;
1471: 	case SQLITE_ERROR:
1472: 		error_msg = "Generic error";
1473: 		break;
1474: 	case SQLITE_INTERNAL:
1475: 		error_msg = "Internal logic error in SQLite";
1476: 		break;
1477: 	case SQLITE_PERM:
1478: 		error_msg = "Access permission denied";
1479: 		break;
1480: 	case SQLITE_ABORT:
1481: 		error_msg = "Callback routine requested an abort";
1482: 		break;
1483: 	case SQLITE_BUSY:
1484: 		error_msg = "The database file is locked";
1485: 		break;
1486: 	case SQLITE_LOCKED:
1487: 		error_msg = "A table in the database is locked";
1488: 		break;
1489: 	case SQLITE_READONLY:
1490: 		error_msg = "Attempt to write a readonly database";
1491: 		break;
1492: 	case SQLITE_INTERRUPT:
1493: 		error_msg = "Operation terminated by sqlite3_interrupt(";
1494: 		break;
1495: 	case SQLITE_IOERR:
1496: 		error_msg = "Some kind of disk I/O error occurred";
1497: 		break;
1498: 	case SQLITE_CORRUPT:
1499: 		error_msg = "The database disk image is malformed";
1500: 		break;
1501: 	case SQLITE_NOTFOUND:
1502: 		error_msg = "Unknown opcode in sqlite3_file_control()";
1503: 		break;
1504: 	case SQLITE_FULL:
1505: 		error_msg = "Insertion failed because database is full";
1506: 		break;
1507: 	case SQLITE_CANTOPEN:
1508: 		error_msg = "Unable to open the database file";
1509: 		break;
1510: 	case SQLITE_PROTOCOL:
1511: 		error_msg = "Database lock protocol error";
1512: 		break;
1513: 	case SQLITE_EMPTY:
1514: 		error_msg = "Internal use only";
1515: 		break;
1516: 	case SQLITE_SCHEMA:
1517: 		error_msg = "The database schema changed";
1518: 		break;
1519: 	case SQLITE_CONSTRAINT:
1520: 		error_msg = "Abort due to constraint violation";
1521: 		break;
1522: 	case SQLITE_MISMATCH:
1523: 		error_msg = "Data type mismatch";
1524: 		break;
1525: 	case SQLITE_MISUSE:
1526: 		error_msg = "Library used incorrectly";
1527: 		break;
1528: 	case SQLITE_NOLFS:
1529: 		error_msg = "Uses OS features not supported on host";
1530: 		break;
1531: 	case SQLITE_AUTH:
1532: 		error_msg = "Authorization denied";
1533: 		break;
1534: 	case SQLITE_FORMAT:
1535: 		error_msg = "Not used";
1536: 		break;
1537: 	case SQLITE_RANGE:
1538: 		error_msg = "2nd parameter to sqlite3_bind out of range";
1539: 		break;
1540: 	case SQLITE_NOTADB:
1541: 		error_msg = "File opened that is not a database file";
1542: 		break;
1543: 	default:
1544: 		error_msg = "unknown error code";
1545: 		break;
1546: 	}
1547: 	sqlite3_result_error(context, error_msg.c_str(), error_msg.size());
1548: }
1549: 
1550: SQLITE_API void sqlite3_result_int(sqlite3_context *context, int val) {
1551: 	sqlite3_result_int64(context, val);
1552: }
1553: 
1554: SQLITE_API void sqlite3_result_int64(sqlite3_context *context, sqlite3_int64 val) {
1555: 	context->result.u.i = val;
1556: 	context->result.type = SQLiteTypeValue::INTEGER;
1557: }
1558: 
1559: SQLITE_API void sqlite3_result_null(sqlite3_context *context) {
1560: 	context->result.type = SQLiteTypeValue::NULL_VALUE;
1561: }
1562: 
1563: SQLITE_API void sqlite3_result_text(sqlite3_context *context, const char *str_c, int n_chars, void (*xDel)(void *)) {
1564: 	if (!str_c) {
1565: 		context->isError = SQLITE_MISUSE;
1566: 		return;
1567: 	}
1568: 	if (n_chars < 0) {
1569: 		n_chars = strlen(str_c);
1570: 	}
1571: 
1572: 	auto utf_type = Utf8Proc::Analyze(str_c, n_chars);
1573: 	if (utf_type == UnicodeType::INVALID) {
1574: 		context->isError = SQLITE_MISUSE;
1575: 		return;
1576: 	}
1577: 	context->result = CastToSQLiteValue::Operation<string_t>(string_t(str_c, n_chars));
1578: 	if (xDel && xDel != SQLITE_TRANSIENT) {
1579: 		xDel((void *)str_c);
1580: 	}
1581: }
1582: 
1583: SQLITE_API void sqlite3_result_text64(sqlite3_context *, const char *, sqlite3_uint64, void (*)(void *),
1584:                                       unsigned char encoding) {
1585: }
1586: 
1587: SQLITE_API void sqlite3_result_text16(sqlite3_context *, const void *, int, void (*)(void *)) {
1588: }
1589: 
1590: SQLITE_API void sqlite3_result_text16le(sqlite3_context *, const void *, int, void (*)(void *)) {
1591: }
1592: 
1593: SQLITE_API void sqlite3_result_text16be(sqlite3_context *, const void *, int, void (*)(void *)) {
1594: }
1595: 
1596: SQLITE_API void sqlite3_result_value(sqlite3_context *, sqlite3_value *) {
1597: }
1598: 
1599: SQLITE_API void sqlite3_result_pointer(sqlite3_context *, void *, const char *, void (*)(void *)) {
1600: }
1601: 
1602: SQLITE_API void sqlite3_result_zeroblob(sqlite3_context *, int n) {
1603: }
1604: 
1605: SQLITE_API int sqlite3_result_zeroblob64(sqlite3_context *, sqlite3_uint64 n) {
1606: 	return -1;
1607: }
1608: 
1609: // TODO complain
1610: const void *sqlite3_value_blob(sqlite3_value *pVal) {
1611: 	return sqlite3_value_text(pVal);
1612: }
1613: 
1614: double sqlite3_value_double(sqlite3_value *pVal) {
1615: 	if (!pVal) {
1616: 		pVal->db->errCode = SQLITE_MISUSE;
1617: 		return 0.0;
1618: 	}
1619: 	switch (pVal->type) {
1620: 	case SQLiteTypeValue::FLOAT:
1621: 		return pVal->u.r;
1622: 	case SQLiteTypeValue::INTEGER:
1623: 		return (double)pVal->u.i;
1624: 	case SQLiteTypeValue::TEXT:
1625: 	case SQLiteTypeValue::BLOB:
1626: 		double res;
1627: 		if (TryCast::Operation<string_t, double>(string_t(pVal->str), res)) {
1628: 			return res;
1629: 		}
1630: 		break;
1631: 	default:
1632: 		break;
1633: 	}
1634: 	pVal->db->errCode = SQLITE_MISMATCH;
1635: 	return 0.0;
1636: }
1637: 
1638: int sqlite3_value_int(sqlite3_value *pVal) {
1639: 	int64_t res = sqlite3_value_int64(pVal);
1640: 	if (res >= NumericLimits<int>::Minimum() && res <= NumericLimits<int>::Maximum()) {
1641: 		return res;
1642: 	}
1643: 	pVal->db->errCode = SQLITE_MISMATCH;
1644: 	return 0;
1645: }
1646: 
1647: sqlite3_int64 sqlite3_value_int64(sqlite3_value *pVal) {
1648: 	if (!pVal) {
1649: 		pVal->db->errCode = SQLITE_MISUSE;
1650: 		return 0;
1651: 	}
1652: 	int64_t res;
1653: 	switch (pVal->type) {
1654: 	case SQLiteTypeValue::INTEGER:
1655: 		return pVal->u.i;
1656: 	case SQLiteTypeValue::FLOAT:
1657: 		if (TryCast::Operation<double, int64_t>(pVal->u.r, res)) {
1658: 			return res;
1659: 		}
1660: 		break;
1661: 	case SQLiteTypeValue::TEXT:
1662: 	case SQLiteTypeValue::BLOB:
1663: 		if (TryCast::Operation<string_t, int64_t>(string_t(pVal->str), res)) {
1664: 			return res;
1665: 		}
1666: 		break;
1667: 	default:
1668: 		break;
1669: 	}
1670: 	pVal->db->errCode = SQLITE_MISMATCH;
1671: 	return 0;
1672: }
1673: 
1674: void *sqlite3_value_pointer(sqlite3_value *, const char *) {
1675: 	return nullptr;
1676: }
1677: 
1678: const unsigned char *sqlite3_value_text(sqlite3_value *pVal) {
1679: 	if (!pVal) {
1680: 		pVal->db->errCode = SQLITE_MISUSE;
1681: 		return nullptr;
1682: 	}
1683: 	if (pVal->type == SQLiteTypeValue::TEXT || pVal->type == SQLiteTypeValue::BLOB) {
1684: 		return (const unsigned char *)pVal->str.c_str();
1685: 	}
1686: 
1687: 	if (pVal->type == SQLiteTypeValue::INTEGER || pVal->type == SQLiteTypeValue::FLOAT) {
1688: 		Value value = (pVal->type == SQLiteTypeValue::INTEGER) ? Value::BIGINT(pVal->u.i) : Value::DOUBLE(pVal->u.r);
1689: 		if (!value.DefaultTryCastAs(LogicalType::VARCHAR)) {
1690: 			pVal->db->errCode = SQLITE_NOMEM;
1691: 			return nullptr;
1692: 		}
1693: 		auto &str_val = StringValue::Get(value);
1694: 		*pVal = CastToSQLiteValue::Operation<string_t>(string_t(str_val));
1695: 		return (const unsigned char *)pVal->str.c_str();
1696: 	}
1697: 	if (pVal->type == SQLiteTypeValue::NULL_VALUE) {
1698: 		return nullptr;
1699: 	}
1700: 	pVal->db->errCode = SQLITE_MISMATCH;
1701: 	return nullptr;
1702: }
1703: 
1704: SQLITE_API const void *sqlite3_value_text16(sqlite3_value *) {
1705: 	return nullptr;
1706: }
1707: 
1708: SQLITE_API const void *sqlite3_value_text16le(sqlite3_value *) {
1709: 	return nullptr;
1710: }
1711: 
1712: SQLITE_API const void *sqlite3_value_text16be(sqlite3_value *) {
1713: 	return nullptr;
1714: }
1715: 
1716: SQLITE_API int sqlite3_value_bytes(sqlite3_value *pVal) {
1717: 	if (pVal->type == SQLiteTypeValue::TEXT || pVal->type == SQLiteTypeValue::BLOB) {
1718: 		return pVal->str.size();
1719: 	}
1720: 	return 0;
1721: }
1722: 
1723: SQLITE_API int sqlite3_value_bytes16(sqlite3_value *) {
1724: 	return 0;
1725: }
1726: 
1727: SQLITE_API int sqlite3_value_type(sqlite3_value *pVal) {
1728: 	return (int)pVal->type;
1729: }
1730: 
1731: SQLITE_API int sqlite3_value_numeric_type(sqlite3_value *) {
1732: 	return 0;
1733: }
1734: 
1735: SQLITE_API int sqlite3_value_nochange(sqlite3_value *) {
1736: 	return 0;
1737: }
1738: 
1739: SQLITE_API sqlite3_value *sqlite3_value_dup(const sqlite3_value *val) {
1740: 	return new sqlite3_value(*val);
1741: }
1742: 
1743: SQLITE_API void sqlite3_value_free(sqlite3_value *val) {
1744: 	if (!val) {
1745: 		return;
1746: 	}
1747: 	delete val;
1748: }
1749: 
1750: SQLITE_API void *sqlite3_aggregate_context(sqlite3_context *, int nBytes) {
1751: 	fprintf(stderr, "sqlite3_aggregate_context: unsupported.\n");
1752: 
1753: 	return nullptr;
1754: }
1755: 
1756: SQLITE_API int sqlite3_create_collation(sqlite3 *, const char *zName, int eTextRep, void *pArg,
1757:                                         int (*xCompare)(void *, int, const void *, int, const void *)) {
1758: 	return SQLITE_ERROR;
1759: }
1760: 
1761: SQLITE_API int sqlite3_create_window_function(sqlite3 *db, const char *zFunctionName, int nArg, int eTextRep,
1762:                                               void *pApp, void (*xStep)(sqlite3_context *, int, sqlite3_value **),
1763:                                               void (*xFinal)(sqlite3_context *), void (*xValue)(sqlite3_context *),
1764:                                               void (*xInverse)(sqlite3_context *, int, sqlite3_value **),
1765:                                               void (*xDestroy)(void *)) {
1766: 	// commented for now because such error message prevents the shell-test.py to pass
1767: 	//	fprintf(stderr, "sqlite3_create_window_function: unsupported.\n");
1768: 	return SQLITE_ERROR;
1769: }
1770: 
1771: SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt *s) {
1772: 	return s->db;
1773: }
1774: 
1775: SQLITE_API char *sqlite3_expanded_sql(sqlite3_stmt *pStmt) {
1776: 	fprintf(stderr, "sqlite3_expanded_sql: unsupported.\n");
1777: 	return nullptr;
1778: }
1779: 
1780: SQLITE_API int sqlite3_keyword_check(const char *str, int len) {
1781: 	return Parser::IsKeyword(std::string(str, len));
1782: }
1783: 
1784: SQLITE_API int sqlite3_keyword_count(void) {
1785: 	fprintf(stderr, "sqlite3_keyword_count: unsupported.\n");
1786: 	return 0;
1787: }
1788: 
1789: SQLITE_API int sqlite3_keyword_name(int, const char **, int *) {
1790: 	fprintf(stderr, "sqlite3_keyword_name: unsupported.\n");
1791: 	return 0;
1792: }
1793: 
1794: SQLITE_API void sqlite3_progress_handler(sqlite3 *, int, int (*)(void *), void *) {
1795: 	fprintf(stderr, "sqlite3_progress_handler: unsupported.\n");
1796: }
1797: 
1798: SQLITE_API int sqlite3_stmt_isexplain(sqlite3_stmt *pStmt) {
1799: 	if (!pStmt || !pStmt->prepared) {
1800: 		return 0;
1801: 	}
1802: 	return pStmt->prepared->GetStatementType() == StatementType::EXPLAIN_STATEMENT;
1803: }
1804: 
1805: SQLITE_API int sqlite3_vtab_config(sqlite3 *, int op, ...) {
1806: 	fprintf(stderr, "sqlite3_vtab_config: unsupported.\n");
1807: 	return SQLITE_ERROR;
1808: }
1809: 
1810: SQLITE_API int sqlite3_busy_handler(sqlite3 *, int (*)(void *, int), void *) {
1811: 	return SQLITE_ERROR;
1812: }
1813: 
1814: SQLITE_API int sqlite3_get_table(sqlite3 *db,       /* An open database */
1815:                                  const char *zSql,  /* SQL to be evaluated */
1816:                                  char ***pazResult, /* Results of the query */
1817:                                  int *pnRow,        /* Number of result rows written here */
1818:                                  int *pnColumn,     /* Number of result columns written here */
1819:                                  char **pzErrmsg    /* Error msg written here */
1820: ) {
1821: 	fprintf(stderr, "sqlite3_get_table: unsupported.\n");
1822: 	return SQLITE_ERROR;
1823: }
1824: 
1825: SQLITE_API void sqlite3_free_table(char **result) {
1826: 	fprintf(stderr, "sqlite3_free_table: unsupported.\n");
1827: }
1828: 
1829: SQLITE_API int sqlite3_prepare(sqlite3 *db,           /* Database handle */
1830:                                const char *zSql,      /* SQL statement, UTF-8 encoded */
1831:                                int nByte,             /* Maximum length of zSql in bytes. */
1832:                                sqlite3_stmt **ppStmt, /* OUT: Statement handle */
1833:                                const char **pzTail    /* OUT: Pointer to unused portion of zSql */
1834: ) {
1835: 	return sqlite3_prepare_v2(db, zSql, nByte, ppStmt, pzTail);
1836: }
1837: 
1838: SQLITE_API void *sqlite3_trace(sqlite3 *, void (*xTrace)(void *, const char *), void *) {
1839: 	fprintf(stderr, "sqlite3_trace: unsupported.\n");
1840: 	return nullptr;
1841: }
1842: 
1843: SQLITE_API void *sqlite3_profile(sqlite3 *, void (*xProfile)(void *, const char *, sqlite3_uint64), void *) {
1844: 	fprintf(stderr, "sqlite3_profile: unsupported.\n");
1845: 	return nullptr;
1846: }
1847: 
1848: SQLITE_API int sqlite3_libversion_number(void) {
1849: 	return SQLITE_VERSION_NUMBER;
1850: }
1851: 
1852: SQLITE_API int sqlite3_threadsafe(void) {
1853: 	return SQLITE_OK;
1854: }
1855: 
1856: SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int) {
1857: 	fprintf(stderr, "sqlite3_mutex_alloc: unsupported.\n");
1858: 	return nullptr;
1859: }
1860: 
1861: SQLITE_API void sqlite3_mutex_free(sqlite3_mutex *) {
1862: 	fprintf(stderr, "sqlite3_mutex_free: unsupported.\n");
1863: }
1864: 
1865: SQLITE_API int sqlite3_extended_result_codes(sqlite3 *db, int onoff) {
1866: 	fprintf(stderr, "sqlite3_extended_result_codes: unsupported.\n");
1867: 	return SQLITE_ERROR;
1868: }
1869: 
1870: SQLITE_API void *sqlite3_update_hook(sqlite3 *db, /* Attach the hook to this database */
1871:                                      void (*xCallback)(void *, int, char const *, char const *, sqlite_int64),
1872:                                      void *pArg /* Argument to the function */
1873: ) {
1874: 	fprintf(stderr, "sqlite3_update_hook: unsupported.\n");
1875: 	return nullptr;
1876: }
1877: 
1878: SQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...) {
1879: 	fprintf(stderr, "sqlite3_log: unsupported.\n");
1880: }
1881: 
1882: SQLITE_API int sqlite3_unlock_notify(sqlite3 *db, void (*xNotify)(void **, int), void *pArg) {
1883: 	fprintf(stderr, "sqlite3_unlock_notify: unsupported.\n");
1884: 	return SQLITE_ERROR;
1885: }
1886: 
1887: SQLITE_API void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg) {
1888: 	fprintf(stderr, "sqlite3_get_auxdata: unsupported.\n");
1889: 	return nullptr;
1890: }
1891: 
1892: SQLITE_API void *sqlite3_rollback_hook(sqlite3 *db,               /* Attach the hook to this database */
1893:                                        void (*xCallback)(void *), /* Callback function */
1894:                                        void *pArg                 /* Argument to the function */
1895: ) {
1896: 	fprintf(stderr, "sqlite3_rollback_hook: unsupported.\n");
1897: 	return nullptr;
1898: }
1899: 
1900: SQLITE_API void *sqlite3_commit_hook(sqlite3 *db,              /* Attach the hook to this database */
1901:                                      int (*xCallback)(void *), /* Function to invoke on each commit */
1902:                                      void *pArg                /* Argument to the function */
1903: ) {
1904: 	fprintf(stderr, "sqlite3_commit_hook: unsupported.\n");
1905: 	return nullptr;
1906: }
1907: 
1908: SQLITE_API int sqlite3_blob_open(sqlite3 *db,          /* The database connection */
1909:                                  const char *zDb,      /* The attached database containing the blob */
1910:                                  const char *zTable,   /* The table containing the blob */
1911:                                  const char *zColumn,  /* The column containing the blob */
1912:                                  sqlite_int64 iRow,    /* The row containing the glob */
1913:                                  int wrFlag,           /* True -> read/write access, false -> read-only */
1914:                                  sqlite3_blob **ppBlob /* Handle for accessing the blob returned here */
1915: ) {
1916: 	fprintf(stderr, "sqlite3_blob_open: unsupported.\n");
1917: 	return SQLITE_ERROR;
1918: }
1919: 
1920: SQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName) {
1921: 	fprintf(stderr, "sqlite3_db_filename: unsupported.\n");
1922: 	return nullptr;
1923: }
1924: 
1925: SQLITE_API int sqlite3_stmt_busy(sqlite3_stmt *) {
1926: 	fprintf(stderr, "sqlite3_stmt_busy: unsupported.\n");
1927: 	return false;
1928: }
1929: 
1930: SQLITE_API int sqlite3_bind_pointer(sqlite3_stmt *pStmt, int i, void *pPtr, const char *zPTtype,
1931:                                     void (*xDestructor)(void *)) {
1932: 	fprintf(stderr, "sqlite3_bind_pointer: unsupported.\n");
1933: 	return SQLITE_ERROR;
1934: }
1935: 
1936: SQLITE_API int sqlite3_create_module_v2(sqlite3 *db,                   /* Database in which module is registered */
1937:                                         const char *zName,             /* Name assigned to this module */
1938:                                         const sqlite3_module *pModule, /* The definition of the module */
1939:                                         void *pAux,                    /* Context pointer for xCreate/xConnect */
1940:                                         void (*xDestroy)(void *)       /* Module destructor function */
1941: ) {
1942: 	fprintf(stderr, "sqlite3_create_module_v2: unsupported.\n");
1943: 	return SQLITE_ERROR;
1944: }
1945: 
1946: SQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset) {
1947: 	fprintf(stderr, "sqlite3_blob_write: unsupported.\n");
1948: 	return SQLITE_ERROR;
1949: }
1950: 
1951: SQLITE_API void sqlite3_set_auxdata(sqlite3_context *, int N, void *, void (*)(void *)) {
1952: 	fprintf(stderr, "sqlite3_set_auxdata: unsupported.\n");
1953: }
1954: 
1955: SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt) {
1956: 	fprintf(stderr, "sqlite3_next_stmt: unsupported.\n");
1957: 	return nullptr;
1958: }
1959: 
1960: SQLITE_API int sqlite3_collation_needed(sqlite3 *, void *, void (*)(void *, sqlite3 *, int eTextRep, const char *)) {
1961: 	fprintf(stderr, "sqlite3_collation_needed: unsupported.\n");
1962: 	return SQLITE_ERROR;
1963: }
1964: 
1965: SQLITE_API int sqlite3_create_collation_v2(sqlite3 *, const char *zName, int eTextRep, void *pArg,
1966:                                            int (*xCompare)(void *, int, const void *, int, const void *),
1967:                                            void (*xDestroy)(void *)) {
1968: 	fprintf(stderr, "sqlite3_create_collation_v2: unsupported.\n");
1969: 	return SQLITE_ERROR;
1970: }
[end of tools/sqlite3_api_wrapper/sqlite3_api_wrapper.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: