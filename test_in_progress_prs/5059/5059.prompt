You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
Python Table function does not support fully qualified table name
### What happens?

Method [https://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyConnection.table](duckdb.DuckDBPyConnection.table) does not support fully qualified table name.


### To Reproduce

```
import duckdb

con = duckdb.connect(":memory:")
con.execute("create schema fff")

# Create table in main schema
con.execute("create table t1 as select 1 as t")
con.table("t1") # -> this works fine

# Create table in fff schema
con.execute("create table fff.t2 as select 1 as t")
con.table("fff.t2") # -> Table does not exist!
con.table("main.fff.t2") # -> Table does not exist!
con.table("t2") # -> Table does not exist!
```

Alternatively, it is possible to use `duckdb.query('SELECT * FROM fff.t2')`, that works.

### OS:

MacOS

### DuckDB Version:

0.5.1

### DuckDB Client:

Python

### Full Name:

Radek Tom≈°ej

### Affiliation:

Alma Career

### Have you tried this on the latest `master` branch?

- [X] I agree

### Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?

- [X] I agree

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=master" alt="Github Actions Badge">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The detail of benchmarks is in our [Benchmark Guide](benchmark/README.md).
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
[end of README.md]
[start of tools/pythonpkg/src/pyconnection.cpp]
1: #include "duckdb_python/pyconnection.hpp"
2: 
3: #include "datetime.h" // from Python
4: #include "duckdb/common/arrow/arrow.hpp"
5: #include "duckdb/common/printer.hpp"
6: #include "duckdb/common/types.hpp"
7: #include "duckdb/common/types/vector.hpp"
8: #include "duckdb/main/client_context.hpp"
9: #include "duckdb/main/config.hpp"
10: #include "duckdb/main/db_instance_cache.hpp"
11: #include "duckdb/main/extension_helper.hpp"
12: #include "duckdb/parser/expression/constant_expression.hpp"
13: #include "duckdb/parser/expression/function_expression.hpp"
14: #include "duckdb/parser/parsed_data/create_table_function_info.hpp"
15: #include "duckdb/parser/parser.hpp"
16: #include "duckdb/parser/tableref/table_function_ref.hpp"
17: #include "duckdb_python/arrow_array_stream.hpp"
18: #include "duckdb_python/map.hpp"
19: #include "duckdb_python/pandas_scan.hpp"
20: #include "duckdb_python/pyrelation.hpp"
21: #include "duckdb_python/pyresult.hpp"
22: #include "duckdb_python/python_conversion.hpp"
23: 
24: #include <random>
25: 
26: namespace duckdb {
27: 
28: shared_ptr<DuckDBPyConnection> DuckDBPyConnection::default_connection = nullptr;
29: DBInstanceCache instance_cache;
30: shared_ptr<PythonImportCache> DuckDBPyConnection::import_cache = nullptr;
31: 
32: void DuckDBPyConnection::Initialize(py::handle &m) {
33: 	py::class_<DuckDBPyConnection, shared_ptr<DuckDBPyConnection>>(m, "DuckDBPyConnection", py::module_local())
34: 	    .def("cursor", &DuckDBPyConnection::Cursor, "Create a duplicate of the current connection")
35: 	    .def("duplicate", &DuckDBPyConnection::Cursor, "Create a duplicate of the current connection")
36: 	    .def("execute", &DuckDBPyConnection::Execute,
37: 	         "Execute the given SQL query, optionally using prepared statements with parameters set", py::arg("query"),
38: 	         py::arg("parameters") = py::none(), py::arg("multiple_parameter_sets") = false)
39: 	    .def("executemany", &DuckDBPyConnection::ExecuteMany,
40: 	         "Execute the given prepared statement multiple times using the list of parameter sets in parameters",
41: 	         py::arg("query"), py::arg("parameters") = py::none())
42: 	    .def("close", &DuckDBPyConnection::Close, "Close the connection")
43: 	    .def("fetchone", &DuckDBPyConnection::FetchOne, "Fetch a single row from a result following execute")
44: 	    .def("fetchmany", &DuckDBPyConnection::FetchMany, "Fetch the next set of rows from a result following execute",
45: 	         py::arg("size") = 1)
46: 	    .def("fetchall", &DuckDBPyConnection::FetchAll, "Fetch all rows from a result following execute")
47: 	    .def("fetchnumpy", &DuckDBPyConnection::FetchNumpy, "Fetch a result as list of NumPy arrays following execute")
48: 	    .def("fetchdf", &DuckDBPyConnection::FetchDF, "Fetch a result as Data.Frame following execute()", py::kw_only(),
49: 	         py::arg("date_as_object") = false)
50: 	    .def("fetch_df", &DuckDBPyConnection::FetchDF, "Fetch a result as Data.Frame following execute()",
51: 	         py::kw_only(), py::arg("date_as_object") = false)
52: 	    .def("fetch_df_chunk", &DuckDBPyConnection::FetchDFChunk,
53: 	         "Fetch a chunk of the result as Data.Frame following execute()", py::arg("vectors_per_chunk") = 1,
54: 	         py::kw_only(), py::arg("date_as_object") = false)
55: 	    .def("df", &DuckDBPyConnection::FetchDF, "Fetch a result as Data.Frame following execute()", py::kw_only(),
56: 	         py::arg("date_as_object") = false)
57: 	    .def("fetch_arrow_table", &DuckDBPyConnection::FetchArrow, "Fetch a result as Arrow table following execute()",
58: 	         py::arg("chunk_size") = 1000000)
59: 	    .def("fetch_record_batch", &DuckDBPyConnection::FetchRecordBatchReader,
60: 	         "Fetch an Arrow RecordBatchReader following execute()", py::arg("chunk_size") = 1000000)
61: 	    .def("arrow", &DuckDBPyConnection::FetchArrow, "Fetch a result as Arrow table following execute()",
62: 	         py::arg("chunk_size") = 1000000)
63: 	    .def("begin", &DuckDBPyConnection::Begin, "Start a new transaction")
64: 	    .def("commit", &DuckDBPyConnection::Commit, "Commit changes performed within a transaction")
65: 	    .def("rollback", &DuckDBPyConnection::Rollback, "Roll back changes performed within a transaction")
66: 	    .def("append", &DuckDBPyConnection::Append, "Append the passed Data.Frame to the named table",
67: 	         py::arg("table_name"), py::arg("df"))
68: 	    .def("register", &DuckDBPyConnection::RegisterPythonObject,
69: 	         "Register the passed Python Object value for querying with a view", py::arg("view_name"),
70: 	         py::arg("python_object"))
71: 	    .def("unregister", &DuckDBPyConnection::UnregisterPythonObject, "Unregister the view name",
72: 	         py::arg("view_name"))
73: 	    .def("table", &DuckDBPyConnection::Table, "Create a relation object for the name'd table",
74: 	         py::arg("table_name"))
75: 	    .def("view", &DuckDBPyConnection::View, "Create a relation object for the name'd view", py::arg("view_name"))
76: 	    .def("values", &DuckDBPyConnection::Values, "Create a relation object from the passed values",
77: 	         py::arg("values"))
78: 	    .def("table_function", &DuckDBPyConnection::TableFunction,
79: 	         "Create a relation object from the name'd table function with given parameters", py::arg("name"),
80: 	         py::arg("parameters") = py::none())
81: 	    .def("from_query", &DuckDBPyConnection::FromQuery, "Create a relation object from the given SQL query",
82: 	         py::arg("query"), py::arg("alias") = "query_relation")
83: 	    .def("query", &DuckDBPyConnection::RunQuery,
84: 	         "Run a SQL query. If it is a SELECT statement, create a relation object from the given SQL query, "
85: 	         "otherwise run the query as-is.",
86: 	         py::arg("query"), py::arg("alias") = "query_relation")
87: 	    .def("from_df", &DuckDBPyConnection::FromDF, "Create a relation object from the Data.Frame in df",
88: 	         py::arg("df") = py::none())
89: 	    .def("from_arrow", &DuckDBPyConnection::FromArrow, "Create a relation object from an Arrow object",
90: 	         py::arg("arrow_object"))
91: 	    .def("df", &DuckDBPyConnection::FromDF,
92: 	         "Create a relation object from the Data.Frame in df. This is an alias of from_df", py::arg("df"))
93: 	    .def("from_csv_auto", &DuckDBPyConnection::FromCsvAuto,
94: 	         "Create a relation object from the CSV file in file_name", py::arg("file_name"))
95: 	    .def("from_parquet", &DuckDBPyConnection::FromParquet,
96: 	         "Create a relation object from the Parquet file in file_name", py::arg("file_name"),
97: 	         py::arg("binary_as_string") = false)
98: 	    .def("from_substrait", &DuckDBPyConnection::FromSubstrait, "Create a query object from protobuf plan",
99: 	         py::arg("proto"))
100: 	    .def("get_substrait", &DuckDBPyConnection::GetSubstrait, "Serialize a query to protobuf", py::arg("query"))
101: 	    .def("get_substrait_json", &DuckDBPyConnection::GetSubstraitJSON,
102: 	         "Serialize a query to protobuf on the JSON format", py::arg("query"))
103: 	    .def("get_table_names", &DuckDBPyConnection::GetTableNames, "Extract the required table names from a query",
104: 	         py::arg("query"))
105: 	    .def("__enter__", &DuckDBPyConnection::Enter)
106: 	    .def("__exit__", &DuckDBPyConnection::Exit, py::arg("exc_type"), py::arg("exc"), py::arg("traceback"))
107: 	    .def_property_readonly("description", &DuckDBPyConnection::GetDescription,
108: 	                           "Get result set attributes, mainly column names")
109: 	    .def("install_extension", &DuckDBPyConnection::InstallExtension, "Install an extension by name",
110: 	         py::arg("extension"), py::kw_only(), py::arg("force_install") = false)
111: 	    .def("load_extension", &DuckDBPyConnection::LoadExtension, "Load an installed extension", py::arg("extension"));
112: 
113: 	PyDateTime_IMPORT;
114: 	DuckDBPyConnection::ImportCache();
115: }
116: 
117: DuckDBPyConnection *DuckDBPyConnection::ExecuteMany(const string &query, py::object params) {
118: 	if (params.is_none()) {
119: 		params = py::list();
120: 	}
121: 	Execute(query, std::move(params), true);
122: 	return this;
123: }
124: 
125: static unique_ptr<QueryResult> CompletePendingQuery(PendingQueryResult &pending_query) {
126: 	PendingExecutionResult execution_result;
127: 	do {
128: 		execution_result = pending_query.ExecuteTask();
129: 	} while (execution_result == PendingExecutionResult::RESULT_NOT_READY);
130: 	if (execution_result == PendingExecutionResult::EXECUTION_ERROR) {
131: 		pending_query.ThrowError();
132: 	}
133: 	return pending_query.Execute();
134: }
135: 
136: DuckDBPyConnection *DuckDBPyConnection::Execute(const string &query, py::object params, bool many) {
137: 	if (!connection) {
138: 		throw ConnectionException("Connection has already been closed");
139: 	}
140: 	if (params.is_none()) {
141: 		params = py::list();
142: 	}
143: 	result = nullptr;
144: 	unique_ptr<PreparedStatement> prep;
145: 	{
146: 		py::gil_scoped_release release;
147: 		unique_lock<std::mutex> lock(py_connection_lock);
148: 
149: 		auto statements = connection->ExtractStatements(query);
150: 		if (statements.empty()) {
151: 			// no statements to execute
152: 			return this;
153: 		}
154: 		// if there are multiple statements, we directly execute the statements besides the last one
155: 		// we only return the result of the last statement to the user, unless one of the previous statements fails
156: 		for (idx_t i = 0; i + 1 < statements.size(); i++) {
157: 			auto pending_query = connection->PendingQuery(move(statements[i]));
158: 			auto res = CompletePendingQuery(*pending_query);
159: 
160: 			if (res->HasError()) {
161: 				res->ThrowError();
162: 			}
163: 		}
164: 
165: 		prep = connection->Prepare(move(statements.back()));
166: 		if (prep->HasError()) {
167: 			prep->error.Throw();
168: 		}
169: 	}
170: 
171: 	// this is a list of a list of parameters in executemany
172: 	py::list params_set;
173: 	if (!many) {
174: 		params_set = py::list(1);
175: 		params_set[0] = params;
176: 	} else {
177: 		params_set = params;
178: 	}
179: 
180: 	for (pybind11::handle single_query_params : params_set) {
181: 		if (prep->n_param != py::len(single_query_params)) {
182: 			throw InvalidInputException("Prepared statement needs %d parameters, %d given", prep->n_param,
183: 			                            py::len(single_query_params));
184: 		}
185: 		auto args = DuckDBPyConnection::TransformPythonParamList(single_query_params);
186: 		auto res = make_unique<DuckDBPyResult>();
187: 		{
188: 			py::gil_scoped_release release;
189: 			unique_lock<std::mutex> lock(py_connection_lock);
190: 			auto pending_query = prep->PendingQuery(args);
191: 			res->result = CompletePendingQuery(*pending_query);
192: 
193: 			if (res->result->HasError()) {
194: 				res->result->ThrowError();
195: 			}
196: 		}
197: 
198: 		if (!many) {
199: 			result = move(res);
200: 		}
201: 	}
202: 	return this;
203: }
204: 
205: DuckDBPyConnection *DuckDBPyConnection::Append(const string &name, DataFrame value) {
206: 	RegisterPythonObject("__append_df", std::move(value));
207: 	return Execute("INSERT INTO \"" + name + "\" SELECT * FROM __append_df");
208: }
209: 
210: DuckDBPyConnection *DuckDBPyConnection::RegisterPythonObject(const string &name, py::object python_object) {
211: 	if (!connection) {
212: 		throw ConnectionException("Connection has already been closed");
213: 	}
214: 
215: 	if (DuckDBPyConnection::IsPandasDataframe(python_object)) {
216: 		auto new_df = PandasScanFunction::PandasReplaceCopiedNames(python_object);
217: 		{
218: 			py::gil_scoped_release release;
219: 			temporary_views[name] = connection->TableFunction("pandas_scan", {Value::POINTER((uintptr_t)new_df.ptr())})
220: 			                            ->CreateView(name, true, true);
221: 		}
222: 
223: 		// keep a reference
224: 		vector<shared_ptr<ExternalDependency>> dependencies;
225: 		dependencies.push_back(make_shared<PythonDependencies>(make_unique<RegisteredObject>(python_object),
226: 		                                                       make_unique<RegisteredObject>(new_df)));
227: 		connection->context->external_dependencies[name] = move(dependencies);
228: 	} else if (IsAcceptedArrowObject(python_object)) {
229: 		auto stream_factory =
230: 		    make_unique<PythonTableArrowArrayStreamFactory>(python_object.ptr(), connection->context->config);
231: 		auto stream_factory_produce = PythonTableArrowArrayStreamFactory::Produce;
232: 		auto stream_factory_get_schema = PythonTableArrowArrayStreamFactory::GetSchema;
233: 		{
234: 			py::gil_scoped_release release;
235: 			temporary_views[name] =
236: 			    connection
237: 			        ->TableFunction("arrow_scan", {Value::POINTER((uintptr_t)stream_factory.get()),
238: 			                                       Value::POINTER((uintptr_t)stream_factory_produce),
239: 			                                       Value::POINTER((uintptr_t)stream_factory_get_schema)})
240: 			        ->CreateView(name, true, true);
241: 		}
242: 		vector<shared_ptr<ExternalDependency>> dependencies;
243: 		dependencies.push_back(
244: 		    make_shared<PythonDependencies>(make_unique<RegisteredArrow>(move(stream_factory), python_object)));
245: 		connection->context->external_dependencies[name] = move(dependencies);
246: 	} else {
247: 		auto py_object_type = string(py::str(python_object.get_type().attr("__name__")));
248: 		throw InvalidInputException("Python Object %s not suitable to be registered as a view", py_object_type);
249: 	}
250: 	return this;
251: }
252: 
253: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::FromQuery(const string &query, const string &alias) {
254: 	if (!connection) {
255: 		throw ConnectionException("Connection has already been closed");
256: 	}
257: 	const char *duckdb_query_error = R"(duckdb.from_query cannot be used to run arbitrary SQL queries.
258: It can only be used to run individual SELECT statements, and converts the result of that SELECT
259: statement into a Relation object.
260: Use duckdb.query to run arbitrary SQL queries.)";
261: 	return make_unique<DuckDBPyRelation>(connection->RelationFromQuery(query, alias, duckdb_query_error));
262: }
263: 
264: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::RunQuery(const string &query, const string &alias) {
265: 	if (!connection) {
266: 		throw ConnectionException("Connection has already been closed");
267: 	}
268: 	Parser parser(connection->context->GetParserOptions());
269: 	parser.ParseQuery(query);
270: 	if (parser.statements.size() == 1 && parser.statements[0]->type == StatementType::SELECT_STATEMENT) {
271: 		return make_unique<DuckDBPyRelation>(connection->RelationFromQuery(
272: 		    unique_ptr_cast<SQLStatement, SelectStatement>(move(parser.statements[0])), alias));
273: 	}
274: 	Execute(query);
275: 	if (result) {
276: 		FetchAll();
277: 	}
278: 	return nullptr;
279: }
280: 
281: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::Table(const string &tname) {
282: 	if (!connection) {
283: 		throw ConnectionException("Connection has already been closed");
284: 	}
285: 	return make_unique<DuckDBPyRelation>(connection->Table(tname));
286: }
287: 
288: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::Values(py::object params) {
289: 	if (!connection) {
290: 		throw ConnectionException("Connection has already been closed");
291: 	}
292: 	if (params.is_none()) {
293: 		params = py::list();
294: 	}
295: 	if (!py::hasattr(params, "__len__")) {
296: 		throw InvalidInputException("Type of object passed to parameter 'values' must be iterable");
297: 	}
298: 	vector<vector<Value>> values {DuckDBPyConnection::TransformPythonParamList(std::move(params))};
299: 	return make_unique<DuckDBPyRelation>(connection->Values(values));
300: }
301: 
302: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::View(const string &vname) {
303: 	if (!connection) {
304: 		throw ConnectionException("Connection has already been closed");
305: 	}
306: 	// First check our temporary view
307: 	if (temporary_views.find(vname) != temporary_views.end()) {
308: 		return make_unique<DuckDBPyRelation>(temporary_views[vname]);
309: 	}
310: 	return make_unique<DuckDBPyRelation>(connection->View(vname));
311: }
312: 
313: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::TableFunction(const string &fname, py::object params) {
314: 	if (params.is_none()) {
315: 		params = py::list();
316: 	}
317: 	if (!connection) {
318: 		throw ConnectionException("Connection has already been closed");
319: 	}
320: 
321: 	return make_unique<DuckDBPyRelation>(
322: 	    connection->TableFunction(fname, DuckDBPyConnection::TransformPythonParamList(std::move(params))));
323: }
324: 
325: static std::string GenerateRandomName() {
326: 	std::random_device rd;
327: 	std::mt19937 gen(rd());
328: 	std::uniform_int_distribution<> dis(0, 15);
329: 
330: 	std::stringstream ss;
331: 	int i;
332: 	ss << std::hex;
333: 	for (i = 0; i < 16; i++) {
334: 		ss << dis(gen);
335: 	}
336: 	return ss.str();
337: }
338: 
339: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::FromDF(const DataFrame &value) {
340: 	if (!connection) {
341: 		throw ConnectionException("Connection has already been closed");
342: 	}
343: 	string name = "df_" + GenerateRandomName();
344: 	auto new_df = PandasScanFunction::PandasReplaceCopiedNames(value);
345: 	vector<Value> params;
346: 	params.emplace_back(Value::POINTER((uintptr_t)new_df.ptr()));
347: 	auto rel = make_unique<DuckDBPyRelation>(connection->TableFunction("pandas_scan", params)->Alias(name));
348: 	rel->rel->extra_dependencies =
349: 	    make_unique<PythonDependencies>(make_unique<RegisteredObject>(value), make_unique<RegisteredObject>(new_df));
350: 	return rel;
351: }
352: 
353: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::FromCsvAuto(const string &filename) {
354: 	if (!connection) {
355: 		throw ConnectionException("Connection has already been closed");
356: 	}
357: 	vector<Value> params;
358: 	params.emplace_back(filename);
359: 	return make_unique<DuckDBPyRelation>(connection->TableFunction("read_csv_auto", params)->Alias(filename));
360: }
361: 
362: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::FromParquet(const string &filename, bool binary_as_string) {
363: 	if (!connection) {
364: 		throw ConnectionException("Connection has already been closed");
365: 	}
366: 	vector<Value> params;
367: 	params.emplace_back(filename);
368: 	named_parameter_map_t named_parameters({{"binary_as_string", Value::BOOLEAN(binary_as_string)}});
369: 	return make_unique<DuckDBPyRelation>(
370: 	    connection->TableFunction("parquet_scan", params, named_parameters)->Alias(filename));
371: }
372: 
373: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::FromArrow(py::object &arrow_object) {
374: 	if (!connection) {
375: 		throw ConnectionException("Connection has already been closed");
376: 	}
377: 	py::gil_scoped_acquire acquire;
378: 	string name = "arrow_object_" + GenerateRandomName();
379: 	if (!IsAcceptedArrowObject(arrow_object)) {
380: 		auto py_object_type = string(py::str(arrow_object.get_type().attr("__name__")));
381: 		throw InvalidInputException("Python Object Type %s is not an accepted Arrow Object.", py_object_type);
382: 	}
383: 	auto stream_factory =
384: 	    make_unique<PythonTableArrowArrayStreamFactory>(arrow_object.ptr(), connection->context->config);
385: 
386: 	auto stream_factory_produce = PythonTableArrowArrayStreamFactory::Produce;
387: 	auto stream_factory_get_schema = PythonTableArrowArrayStreamFactory::GetSchema;
388: 
389: 	auto rel = make_unique<DuckDBPyRelation>(
390: 	    connection
391: 	        ->TableFunction("arrow_scan", {Value::POINTER((uintptr_t)stream_factory.get()),
392: 	                                       Value::POINTER((uintptr_t)stream_factory_produce),
393: 	                                       Value::POINTER((uintptr_t)stream_factory_get_schema)})
394: 	        ->Alias(name));
395: 	rel->rel->extra_dependencies =
396: 	    make_unique<PythonDependencies>(make_unique<RegisteredArrow>(move(stream_factory), arrow_object));
397: 	return rel;
398: }
399: 
400: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::FromSubstrait(py::bytes &proto) {
401: 	if (!connection) {
402: 		throw ConnectionException("Connection has already been closed");
403: 	}
404: 	string name = "substrait_" + GenerateRandomName();
405: 	vector<Value> params;
406: 	params.emplace_back(Value::BLOB_RAW(proto));
407: 	return make_unique<DuckDBPyRelation>(connection->TableFunction("from_substrait", params)->Alias(name));
408: }
409: 
410: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::GetSubstrait(const string &query) {
411: 	if (!connection) {
412: 		throw ConnectionException("Connection has already been closed");
413: 	}
414: 	vector<Value> params;
415: 	params.emplace_back(query);
416: 	return make_unique<DuckDBPyRelation>(connection->TableFunction("get_substrait", params)->Alias(query));
417: }
418: 
419: unique_ptr<DuckDBPyRelation> DuckDBPyConnection::GetSubstraitJSON(const string &query) {
420: 	if (!connection) {
421: 		throw ConnectionException("Connection has already been closed");
422: 	}
423: 	vector<Value> params;
424: 	params.emplace_back(query);
425: 	return make_unique<DuckDBPyRelation>(connection->TableFunction("get_substrait_json", params)->Alias(query));
426: }
427: 
428: unordered_set<string> DuckDBPyConnection::GetTableNames(const string &query) {
429: 	if (!connection) {
430: 		throw ConnectionException("Connection has already been closed");
431: 	}
432: 	return connection->GetTableNames(query);
433: }
434: 
435: DuckDBPyConnection *DuckDBPyConnection::UnregisterPythonObject(const string &name) {
436: 	connection->context->external_dependencies.erase(name);
437: 	temporary_views.erase(name);
438: 	py::gil_scoped_release release;
439: 	if (connection) {
440: 		connection->Query("DROP VIEW \"" + name + "\"");
441: 	}
442: 	return this;
443: }
444: 
445: DuckDBPyConnection *DuckDBPyConnection::Begin() {
446: 	Execute("BEGIN TRANSACTION");
447: 	return this;
448: }
449: 
450: DuckDBPyConnection *DuckDBPyConnection::Commit() {
451: 	if (connection->context->transaction.IsAutoCommit()) {
452: 		return this;
453: 	}
454: 	Execute("COMMIT");
455: 	return this;
456: }
457: 
458: DuckDBPyConnection *DuckDBPyConnection::Rollback() {
459: 	Execute("ROLLBACK");
460: 	return this;
461: }
462: 
463: py::object DuckDBPyConnection::GetDescription() {
464: 	if (!result) {
465: 		return py::none();
466: 	}
467: 	return result->Description();
468: }
469: 
470: void DuckDBPyConnection::Close() {
471: 	result = nullptr;
472: 	connection = nullptr;
473: 	database = nullptr;
474: 	for (auto &cur : cursors) {
475: 		cur->Close();
476: 	}
477: 	cursors.clear();
478: }
479: 
480: void DuckDBPyConnection::InstallExtension(const string &extension, bool force_install) {
481: 	ExtensionHelper::InstallExtension(*connection->context, extension, force_install);
482: }
483: 
484: void DuckDBPyConnection::LoadExtension(const string &extension) {
485: 	ExtensionHelper::LoadExternalExtension(*connection->context, extension);
486: }
487: 
488: // cursor() is stupid
489: shared_ptr<DuckDBPyConnection> DuckDBPyConnection::Cursor() {
490: 	auto res = make_shared<DuckDBPyConnection>();
491: 	res->database = database;
492: 	res->connection = make_unique<Connection>(*res->database);
493: 	cursors.push_back(res);
494: 	return res;
495: }
496: 
497: // these should be functions on the result but well
498: py::object DuckDBPyConnection::FetchOne() {
499: 	if (!result) {
500: 		throw InvalidInputException("No open result set");
501: 	}
502: 	return result->Fetchone();
503: }
504: 
505: py::list DuckDBPyConnection::FetchMany(idx_t size) {
506: 	if (!result) {
507: 		throw InvalidInputException("No open result set");
508: 	}
509: 	return result->Fetchmany(size);
510: }
511: 
512: py::list DuckDBPyConnection::FetchAll() {
513: 	if (!result) {
514: 		throw InvalidInputException("No open result set");
515: 	}
516: 	return result->Fetchall();
517: }
518: 
519: py::dict DuckDBPyConnection::FetchNumpy() {
520: 	if (!result) {
521: 		throw InvalidInputException("No open result set");
522: 	}
523: 	return result->FetchNumpyInternal();
524: }
525: DataFrame DuckDBPyConnection::FetchDF(bool date_as_object) {
526: 	if (!result) {
527: 		throw InvalidInputException("No open result set");
528: 	}
529: 	return result->FetchDF(date_as_object);
530: }
531: 
532: DataFrame DuckDBPyConnection::FetchDFChunk(const idx_t vectors_per_chunk, bool date_as_object) const {
533: 	if (!result) {
534: 		throw InvalidInputException("No open result set");
535: 	}
536: 	return result->FetchDFChunk(vectors_per_chunk, date_as_object);
537: }
538: 
539: duckdb::pyarrow::Table DuckDBPyConnection::FetchArrow(idx_t chunk_size) {
540: 	if (!result) {
541: 		throw InvalidInputException("No open result set");
542: 	}
543: 	return result->FetchArrowTable(chunk_size);
544: }
545: 
546: duckdb::pyarrow::RecordBatchReader DuckDBPyConnection::FetchRecordBatchReader(const idx_t chunk_size) const {
547: 	if (!result) {
548: 		throw InvalidInputException("No open result set");
549: 	}
550: 	return result->FetchRecordBatchReader(chunk_size);
551: }
552: static unique_ptr<TableFunctionRef> TryReplacement(py::dict &dict, py::str &table_name, ClientConfig &config,
553:                                                    py::object &current_frame) {
554: 	if (!dict.contains(table_name)) {
555: 		// not present in the globals
556: 		return nullptr;
557: 	}
558: 	auto entry = dict[table_name];
559: 	auto table_function = make_unique<TableFunctionRef>();
560: 	vector<unique_ptr<ParsedExpression>> children;
561: 	if (DuckDBPyConnection::IsPandasDataframe(entry)) {
562: 		string name = "df_" + GenerateRandomName();
563: 		auto new_df = PandasScanFunction::PandasReplaceCopiedNames(entry);
564: 		children.push_back(make_unique<ConstantExpression>(Value::POINTER((uintptr_t)new_df.ptr())));
565: 		table_function->function = make_unique<FunctionExpression>("pandas_scan", move(children));
566: 		table_function->external_dependency = make_unique<PythonDependencies>(make_unique<RegisteredObject>(entry),
567: 		                                                                      make_unique<RegisteredObject>(new_df));
568: 	} else if (DuckDBPyConnection::IsAcceptedArrowObject(entry)) {
569: 		string name = "arrow_" + GenerateRandomName();
570: 		auto stream_factory = make_unique<PythonTableArrowArrayStreamFactory>(entry.ptr(), config);
571: 		auto stream_factory_produce = PythonTableArrowArrayStreamFactory::Produce;
572: 		auto stream_factory_get_schema = PythonTableArrowArrayStreamFactory::GetSchema;
573: 
574: 		children.push_back(make_unique<ConstantExpression>(Value::POINTER((uintptr_t)stream_factory.get())));
575: 		children.push_back(make_unique<ConstantExpression>(Value::POINTER((uintptr_t)stream_factory_produce)));
576: 		children.push_back(make_unique<ConstantExpression>(Value::POINTER((uintptr_t)stream_factory_get_schema)));
577: 
578: 		table_function->function = make_unique<FunctionExpression>("arrow_scan", move(children));
579: 		table_function->external_dependency =
580: 		    make_unique<PythonDependencies>(make_unique<RegisteredArrow>(move(stream_factory), entry));
581: 	} else {
582: 		std::string location = py::cast<py::str>(current_frame.attr("f_code").attr("co_filename"));
583: 		location += ":";
584: 		location += py::cast<py::str>(current_frame.attr("f_lineno"));
585: 		std::string cpp_table_name = table_name;
586: 		auto py_object_type = string(py::str(entry.get_type().attr("__name__")));
587: 
588: 		throw InvalidInputException(
589: 		    "Python Object \"%s\" of type \"%s\" found on line \"%s\" not suitable for replacement scans.\nMake sure "
590: 		    "that \"%s\" is either a pandas.DataFrame, or pyarrow Table, FileSystemDataset, InMemoryDataset, "
591: 		    "RecordBatchReader, or Scanner",
592: 		    cpp_table_name, py_object_type, location, cpp_table_name);
593: 	}
594: 	return table_function;
595: }
596: 
597: static unique_ptr<TableFunctionRef> ScanReplacement(ClientContext &context, const string &table_name,
598:                                                     ReplacementScanData *data) {
599: 	py::gil_scoped_acquire acquire;
600: 	auto py_table_name = py::str(table_name);
601: 	// Here we do an exhaustive search on the frame lineage
602: 	auto current_frame = py::module::import("inspect").attr("currentframe")();
603: 	while (hasattr(current_frame, "f_locals")) {
604: 		auto local_dict = py::reinterpret_borrow<py::dict>(current_frame.attr("f_locals"));
605: 		// search local dictionary
606: 		if (local_dict) {
607: 			auto result = TryReplacement(local_dict, py_table_name, context.config, current_frame);
608: 			if (result) {
609: 				return result;
610: 			}
611: 		}
612: 		// search global dictionary
613: 		auto global_dict = py::reinterpret_borrow<py::dict>(current_frame.attr("f_globals"));
614: 		if (global_dict) {
615: 			auto result = TryReplacement(global_dict, py_table_name, context.config, current_frame);
616: 			if (result) {
617: 				return result;
618: 			}
619: 		}
620: 		current_frame = current_frame.attr("f_back");
621: 	}
622: 	// Not found :(
623: 	return nullptr;
624: }
625: 
626: unordered_map<string, string> TransformPyConfigDict(const py::dict &py_config_dict) {
627: 	unordered_map<string, string> config_dict;
628: 	for (auto &kv : py_config_dict) {
629: 		auto key = py::str(kv.first);
630: 		auto val = py::str(kv.second);
631: 		config_dict[key] = val;
632: 	}
633: 	return config_dict;
634: }
635: 
636: void CreateNewInstance(DuckDBPyConnection &res, const string &database, DBConfig &config) {
637: 	// We don't cache unnamed memory instances (i.e., :memory:)
638: 	bool cache_instance = database != ":memory:" && !database.empty();
639: 	res.database = instance_cache.CreateInstance(database, config, cache_instance);
640: 	res.connection = make_unique<Connection>(*res.database);
641: 	auto &context = *res.connection->context;
642: 	PandasScanFunction scan_fun;
643: 	CreateTableFunctionInfo scan_info(scan_fun);
644: 	MapFunction map_fun;
645: 	CreateTableFunctionInfo map_info(map_fun);
646: 	auto &catalog = Catalog::GetCatalog(context);
647: 	context.transaction.BeginTransaction();
648: 	catalog.CreateTableFunction(context, &scan_info);
649: 	catalog.CreateTableFunction(context, &map_info);
650: 	context.transaction.Commit();
651: 	auto &db_config = res.database->instance->config;
652: 	db_config.AddExtensionOption("pandas_analyze_sample",
653: 	                             "The maximum number of rows to sample when analyzing a pandas object column.",
654: 	                             LogicalType::UBIGINT);
655: 	db_config.options.set_variables["pandas_analyze_sample"] = Value::UBIGINT(1000);
656: 	if (db_config.options.enable_external_access) {
657: 		db_config.replacement_scans.emplace_back(ScanReplacement);
658: 	}
659: }
660: 
661: shared_ptr<DuckDBPyConnection> DuckDBPyConnection::Connect(const string &database, bool read_only,
662:                                                            py::object config_options) {
663: 	if (config_options.is_none()) {
664: 		config_options = py::dict();
665: 	}
666: 	auto res = make_shared<DuckDBPyConnection>();
667: 	if (!py::isinstance<py::dict>(config_options)) {
668: 		throw InvalidInputException("Type of object passed to parameter 'config' has to be <dict>");
669: 	}
670: 	py::dict py_config_dict = config_options;
671: 	auto config_dict = TransformPyConfigDict(py_config_dict);
672: 	DBConfig config(config_dict, read_only);
673: 
674: 	res->database = instance_cache.GetInstance(database, config);
675: 	if (!res->database) {
676: 		//! No cached database, we must create a new instance
677: 		CreateNewInstance(*res, database, config);
678: 		return res;
679: 	}
680: 	res->connection = make_unique<Connection>(*res->database);
681: 	return res;
682: }
683: 
684: vector<Value> DuckDBPyConnection::TransformPythonParamList(py::handle params) {
685: 	vector<Value> args;
686: 	args.reserve(py::len(params));
687: 
688: 	for (auto param : params) {
689: 		args.emplace_back(TransformPythonValue(param, LogicalType::UNKNOWN, false));
690: 	}
691: 	return args;
692: }
693: 
694: DuckDBPyConnection *DuckDBPyConnection::DefaultConnection() {
695: 	if (!default_connection) {
696: 		py::dict config_dict;
697: 		default_connection = DuckDBPyConnection::Connect(":memory:", false, config_dict);
698: 	}
699: 	return default_connection.get();
700: }
701: 
702: PythonImportCache *DuckDBPyConnection::ImportCache() {
703: 	if (!import_cache) {
704: 		import_cache = make_shared<PythonImportCache>();
705: 	}
706: 	return import_cache.get();
707: }
708: 
709: DuckDBPyConnection *DuckDBPyConnection::Enter() {
710: 	return this;
711: }
712: 
713: bool DuckDBPyConnection::Exit(DuckDBPyConnection &self, const py::object &exc_type, const py::object &exc,
714:                               const py::object &traceback) {
715: 	self.Close();
716: 	return true;
717: }
718: 
719: void DuckDBPyConnection::Cleanup() {
720: 	default_connection.reset();
721: 	import_cache.reset();
722: }
723: 
724: bool DuckDBPyConnection::IsPandasDataframe(const py::object &object) {
725: 	auto &import_cache = *DuckDBPyConnection::ImportCache();
726: 	return import_cache.pandas.DataFrame.IsInstance(object);
727: }
728: 
729: bool DuckDBPyConnection::IsAcceptedArrowObject(const py::object &object) {
730: 	auto &import_cache = *DuckDBPyConnection::ImportCache();
731: 	return import_cache.arrow.lib.Table.IsInstance(object) ||
732: 	       import_cache.arrow.lib.RecordBatchReader.IsInstance(object) ||
733: 	       import_cache.arrow.dataset.FileSystemDataset.IsInstance(object) ||
734: 	       import_cache.arrow.dataset.InMemoryDataset.IsInstance(object) ||
735: 	       import_cache.arrow.dataset.Scanner.IsInstance(object);
736: }
737: 
738: unique_lock<std::mutex> DuckDBPyConnection::AcquireConnectionLock() {
739: 	// we first release the gil and then acquire the connection lock
740: 	unique_lock<std::mutex> lock(py_connection_lock, std::defer_lock);
741: 	{
742: 		py::gil_scoped_release release;
743: 		lock.lock();
744: 	}
745: 	return lock;
746: }
747: 
748: } // namespace duckdb
[end of tools/pythonpkg/src/pyconnection.cpp]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: