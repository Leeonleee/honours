You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes

<issue>
Fuzzer 54. Negative shift
```sql
PRAGMA CALENDAR='japanese';
SELECT strftime(TIMESTAMPTZ '-23831-1-15 2:5:17 America/La_Paz',TIMETZ '0:8:29 America/Cayman');
```

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=master" alt="Github Actions Badge">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The detail of benchmarks is in our [Benchmark Guide](benchmark/README.md).
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
[end of README.md]
[start of extension/icu/third_party/icu/i18n/erarules.cpp]
1: // © 2018 and later: Unicode, Inc. and others.
2: // License & terms of use: http://www.unicode.org/copyright.html
3: 
4: #include <utility>
5: 
6: #include "unicode/utypes.h"
7: 
8: #if !UCONFIG_NO_FORMATTING
9: 
10: #include <stdlib.h>
11: #include "unicode/ucal.h"
12: #include "unicode/ures.h"
13: #include "unicode/ustring.h"
14: #include "unicode/timezone.h"
15: #include "cmemory.h"
16: #include "cstring.h"
17: #include "erarules.h"
18: #include "gregoimp.h"
19: #include "uassert.h"
20: 
21: U_NAMESPACE_BEGIN
22: 
23: static const int32_t MAX_ENCODED_START_YEAR = 32767;
24: static const int32_t MIN_ENCODED_START_YEAR = -32768;
25: static const int32_t MIN_ENCODED_START = -2147483391;   // encodeDate(MIN_ENCODED_START_YEAR, 1, 1, ...);
26: 
27: static const int32_t YEAR_MASK = 0xFFFF0000;
28: static const int32_t MONTH_MASK = 0x0000FF00;
29: static const int32_t DAY_MASK = 0x000000FF;
30: 
31: static const int32_t MAX_INT32 = 0x7FFFFFFF;
32: static const int32_t MIN_INT32 = 0xFFFFFFFF;
33: 
34: static const UChar VAL_FALSE[] = {0x66, 0x61, 0x6c, 0x73, 0x65};    // "false"
35: static const UChar VAL_FALSE_LEN = 5;
36: 
37: static UBool isSet(int startDate) {
38:     return startDate != 0;
39: }
40: 
41: static UBool isValidRuleStartDate(int32_t year, int32_t month, int32_t day) {
42:     return year >= MIN_ENCODED_START_YEAR && year <= MAX_ENCODED_START_YEAR
43:             && month >= 1 && month <= 12 && day >=1 && day <= 31;
44: }
45: 
46: /**
47:  * Encode year/month/date to a single integer.
48:  * year is high 16 bits (-32768 to 32767), month is
49:  * next 8 bits and day of month is last 8 bits.
50:  *
51:  * @param year  year
52:  * @param month month (1-base)
53:  * @param day   day of month
54:  * @return  an encoded date.
55:  */
56: static int32_t encodeDate(int32_t year, int32_t month, int32_t day) {
57:     return year << 16 | month << 8 | day;
58: }
59: 
60: static void decodeDate(int32_t encodedDate, int32_t (&fields)[3]) {
61:     if (encodedDate == MIN_ENCODED_START) {
62:         fields[0] = MIN_INT32;
63:         fields[1] = 1;
64:         fields[2] = 1;
65:     } else {
66:         fields[0] = (encodedDate & YEAR_MASK) >> 16;
67:         fields[1] = (encodedDate & MONTH_MASK) >> 8;
68:         fields[2] = encodedDate & DAY_MASK;
69:     }
70: }
71: 
72: /**
73:  * Compare an encoded date with another date specified by year/month/day.
74:  * @param encoded   An encoded date
75:  * @param year      Year of another date
76:  * @param month     Month of another date
77:  * @param day       Day of another date
78:  * @return -1 when encoded date is earlier, 0 when two dates are same,
79:  *          and 1 when encoded date is later.
80:  */
81: static int32_t compareEncodedDateWithYMD(int encoded, int year, int month, int day) {
82:     if (year < MIN_ENCODED_START_YEAR) {
83:         if (encoded == MIN_ENCODED_START) {
84:             if (year > MIN_INT32 || month > 1 || day > 1) {
85:                 return -1;
86:             }
87:             return 0;
88:         } else {
89:             return 1;
90:         }
91:     } else if (year > MAX_ENCODED_START_YEAR) {
92:         return -1;
93:     } else {
94:         int tmp = encodeDate(year, month, day);
95:         if (encoded < tmp) {
96:             return -1;
97:         } else if (encoded == tmp) {
98:             return 0;
99:         } else {
100:             return 1;
101:         }
102:     }
103: }
104: 
105: EraRules::EraRules(LocalMemory<int32_t>& eraStartDates, int32_t numEras)
106:     : numEras(numEras) {
107:     startDates = std::move(eraStartDates);
108:     initCurrentEra();
109: }
110: 
111: EraRules::~EraRules() {
112: }
113: 
114: EraRules* EraRules::createInstance(const char *calType, UBool includeTentativeEra, UErrorCode& status) {
115:     if(U_FAILURE(status)) {
116:         return nullptr;
117:     }
118:     LocalUResourceBundlePointer rb(ures_openDirect(nullptr, "supplementalData", &status));
119:     ures_getByKey(rb.getAlias(), "calendarData", rb.getAlias(), &status);
120:     ures_getByKey(rb.getAlias(), calType, rb.getAlias(), &status);
121:     ures_getByKey(rb.getAlias(), "eras", rb.getAlias(), &status);
122: 
123:     if (U_FAILURE(status)) {
124:         return nullptr;
125:     }
126: 
127:     int32_t numEras = ures_getSize(rb.getAlias());
128:     int32_t firstTentativeIdx = MAX_INT32;
129: 
130:     LocalMemory<int32_t> startDates(static_cast<int32_t *>(uprv_malloc(numEras * sizeof(int32_t))));
131:     if (startDates.isNull()) {
132:         status = U_MEMORY_ALLOCATION_ERROR;
133:         return nullptr;
134:     }
135:     uprv_memset(startDates.getAlias(), 0 , numEras * sizeof(int32_t));
136: 
137:     while (ures_hasNext(rb.getAlias())) {
138:         LocalUResourceBundlePointer eraRuleRes(ures_getNextResource(rb.getAlias(), nullptr, &status));
139:         if (U_FAILURE(status)) {
140:             return nullptr;
141:         }
142:         const char *eraIdxStr = ures_getKey(eraRuleRes.getAlias());
143:         char *endp;
144:         int32_t eraIdx = (int32_t)strtol(eraIdxStr, &endp, 10);
145:         if ((size_t)(endp - eraIdxStr) != uprv_strlen(eraIdxStr)) {
146:             status = U_INVALID_FORMAT_ERROR;
147:             return nullptr;
148:         }
149:         if (eraIdx < 0 || eraIdx >= numEras) {
150:             status = U_INVALID_FORMAT_ERROR;
151:             return nullptr;
152:         }
153:         if (isSet(startDates[eraIdx])) {
154:             // start date of the index was already set
155:             status = U_INVALID_FORMAT_ERROR;
156:             return nullptr;
157:         }
158: 
159:         UBool hasName = TRUE;
160:         UBool hasEnd = TRUE;
161:         int32_t len;
162:         while (ures_hasNext(eraRuleRes.getAlias())) {
163:             LocalUResourceBundlePointer res(ures_getNextResource(eraRuleRes.getAlias(), nullptr, &status));
164:             if (U_FAILURE(status)) {
165:                 return nullptr;
166:             }
167:             const char *key = ures_getKey(res.getAlias());
168:             if (uprv_strcmp(key, "start") == 0) {
169:                 const int32_t *fields = ures_getIntVector(res.getAlias(), &len, &status);
170:                 if (U_FAILURE(status)) {
171:                     return nullptr;
172:                 }
173:                 if (len != 3 || !isValidRuleStartDate(fields[0], fields[1], fields[2])) {
174:                     status = U_INVALID_FORMAT_ERROR;
175:                     return nullptr;
176:                 }
177:                 startDates[eraIdx] = encodeDate(fields[0], fields[1], fields[2]);
178:             } else if (uprv_strcmp(key, "named") == 0) {
179:                 const UChar *val = ures_getString(res.getAlias(), &len, &status);
180:                 if (u_strncmp(val, VAL_FALSE, VAL_FALSE_LEN) == 0) {
181:                     hasName = FALSE;
182:                 }
183:             } else if (uprv_strcmp(key, "end") == 0) {
184:                 hasEnd = TRUE;
185:             }
186:         }
187: 
188:         if (isSet(startDates[eraIdx])) {
189:             if (hasEnd) {
190:                 // This implementation assumes either start or end is available, not both.
191:                 // For now, just ignore the end rule.
192:             }
193:         } else {
194:             if (hasEnd) {
195:                 if (eraIdx != 0) {
196:                     // This implementation does not support end only rule for eras other than
197:                     // the first one.
198:                     status = U_INVALID_FORMAT_ERROR;
199:                     return nullptr;
200:                 }
201:                 U_ASSERT(eraIdx == 0);
202:                 startDates[eraIdx] = MIN_ENCODED_START;
203:             } else {
204:                 status = U_INVALID_FORMAT_ERROR;
205:                 return nullptr;
206:             }
207:         }
208: 
209:         if (hasName) {
210:             if (eraIdx >= firstTentativeIdx) {
211:                 status = U_INVALID_FORMAT_ERROR;
212:                 return nullptr;
213:             }
214:         } else {
215:             if (eraIdx < firstTentativeIdx) {
216:                 firstTentativeIdx = eraIdx;
217:             }
218:         }
219:     }
220: 
221:     EraRules *result;
222:     if (firstTentativeIdx < MAX_INT32 && !includeTentativeEra) {
223:         result = new EraRules(startDates, firstTentativeIdx);
224:     } else {
225:         result = new EraRules(startDates, numEras);
226:     }
227: 
228:     if (result == nullptr) {
229:         status = U_MEMORY_ALLOCATION_ERROR;
230:     }
231:     return result;
232: }
233: 
234: void EraRules::getStartDate(int32_t eraIdx, int32_t (&fields)[3], UErrorCode& status) const {
235:     if(U_FAILURE(status)) {
236:         return;
237:     }
238:     if (eraIdx < 0 || eraIdx >= numEras) {
239:         status = U_ILLEGAL_ARGUMENT_ERROR;
240:         return;
241:     }
242:     decodeDate(startDates[eraIdx], fields);
243: }
244: 
245: int32_t EraRules::getStartYear(int32_t eraIdx, UErrorCode& status) const {
246:     int year = MAX_INT32;   // bogus value
247:     if(U_FAILURE(status)) {
248:         return year;
249:     }
250:     if (eraIdx < 0 || eraIdx >= numEras) {
251:         status = U_ILLEGAL_ARGUMENT_ERROR;
252:         return year;
253:     }
254:     int fields[3];
255:     decodeDate(startDates[eraIdx], fields);
256:     year = fields[0];
257: 
258:     return year;
259: }
260: 
261: int32_t EraRules::getEraIndex(int32_t year, int32_t month, int32_t day, UErrorCode& status) const {
262:     if(U_FAILURE(status)) {
263:         return -1;
264:     }
265: 
266:     if (month < 1 || month > 12 || day < 1 || day > 31) {
267:         status = U_ILLEGAL_ARGUMENT_ERROR;
268:         return -1;
269:     }
270:     int32_t high = numEras; // last index + 1
271:     int32_t low;
272: 
273:     // Short circuit for recent years.  Most modern computations will
274:     // occur in the last few eras.
275:     if (compareEncodedDateWithYMD(startDates[getCurrentEraIndex()], year, month, day) <= 0) {
276:         low = getCurrentEraIndex();
277:     } else {
278:         low = 0;
279:     }
280: 
281:     // Do binary search
282:     while (low < high - 1) {
283:         int i = (low + high) / 2;
284:         if (compareEncodedDateWithYMD(startDates[i], year, month, day) <= 0) {
285:             low = i;
286:         } else {
287:             high = i;
288:         }
289:     }
290:     return low;
291: }
292: 
293: void EraRules::initCurrentEra() {
294:     // Compute local wall time in millis using ICU's default time zone.
295:     UErrorCode ec = U_ZERO_ERROR;
296:     UDate localMillis = ucal_getNow();
297: 
298:     int32_t rawOffset, dstOffset;
299:     TimeZone* zone = TimeZone::createDefault();
300:     // If we failed to create the default time zone, we are in a bad state and don't
301:     // really have many options. Carry on using UTC millis as a fallback.
302:     if (zone != nullptr) {
303:         zone->getOffset(localMillis, FALSE, rawOffset, dstOffset, ec);
304:         delete zone;
305:         localMillis += (rawOffset + dstOffset);
306:     }
307: 
308:     int year, month0, dom, dow, doy, mid;
309:     Grego::timeToFields(localMillis, year, month0, dom, dow, doy, mid);
310:     int currentEncodedDate = encodeDate(year, month0 + 1 /* changes to 1-base */, dom);
311:     int eraIdx = numEras - 1;
312:     while (eraIdx > 0) {
313:         if (currentEncodedDate >= startDates[eraIdx]) {
314:             break;
315:         }
316:         eraIdx--;
317:     }
318:     // Note: current era could be before the first era.
319:     // In this case, this implementation returns the first era index (0).
320:     currentEra = eraIdx;
321: }
322: 
323: U_NAMESPACE_END
324: #endif /* #if !UCONFIG_NO_FORMATTING */
325: 
326: 
[end of extension/icu/third_party/icu/i18n/erarules.cpp]
[start of extension/icu/third_party/icu/i18n/indiancal.cpp]
1: // © 2016 and later: Unicode, Inc. and others.
2: // License & terms of use: http://www.unicode.org/copyright.html
3: /*
4:  * Copyright (C) 2003-2014, International Business Machines Corporation
5:  * and others. All Rights Reserved.
6:  ******************************************************************************
7:  *
8:  * File INDIANCAL.CPP
9:  *****************************************************************************
10:  */
11: 
12: #include "indiancal.h"
13: #include <stdlib.h>
14: #if !UCONFIG_NO_FORMATTING
15: 
16: #include "mutex.h"
17: #include <float.h>
18: #include "gregoimp.h" // Math
19: #include "astro.h" // CalendarAstronomer
20: #include "uhash.h"
21: 
22: // Debugging
23: #ifdef U_DEBUG_INDIANCAL
24: #include <stdio.h>
25: #include <stdarg.h>
26: 
27: #endif
28: 
29: U_NAMESPACE_BEGIN
30: 
31: // Implementation of the IndianCalendar class
32: 
33: //-------------------------------------------------------------------------
34: // Constructors...
35: //-------------------------------------------------------------------------
36: 
37: 
38: IndianCalendar* IndianCalendar::clone() const {
39:   return new IndianCalendar(*this);
40: }
41: 
42: IndianCalendar::IndianCalendar(const Locale& aLocale, UErrorCode& success)
43:   :   Calendar(TimeZone::createDefault(), aLocale, success)
44: {
45:   setTimeInMillis(getNow(), success); // Call this again now that the vtable is set up properly.
46: }
47: 
48: IndianCalendar::IndianCalendar(const IndianCalendar& other) : Calendar(other) {
49: }
50: 
51: IndianCalendar::~IndianCalendar()
52: {
53: }
54: const char *IndianCalendar::getType() const {
55:    return "indian";
56: }
57: 
58: static const int32_t INDIANCAL_LIMITS[UCAL_FIELD_COUNT][4] = {
59:     // Minimum  Greatest     Least   Maximum
60:     //           Minimum   Maximum
61:     {        0,        0,        0,        0}, // ERA
62:     { -5000000, -5000000,  5000000,  5000000}, // YEAR
63:     {        0,        0,       11,       11}, // MONTH
64:     {        1,        1,       52,       53}, // WEEK_OF_YEAR
65:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // WEEK_OF_MONTH
66:     {        1,        1,       30,       31}, // DAY_OF_MONTH
67:     {        1,        1,      365,      366}, // DAY_OF_YEAR
68:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // DAY_OF_WEEK
69:     {       -1,       -1,        5,        5}, // DAY_OF_WEEK_IN_MONTH
70:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // AM_PM
71:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // HOUR
72:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // HOUR_OF_DAY
73:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // MINUTE
74:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // SECOND
75:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // MILLISECOND
76:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // ZONE_OFFSET
77:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // DST_OFFSET
78:     { -5000000, -5000000,  5000000,  5000000}, // YEAR_WOY
79:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // DOW_LOCAL
80:     { -5000000, -5000000,  5000000,  5000000}, // EXTENDED_YEAR
81:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // JULIAN_DAY
82:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // MILLISECONDS_IN_DAY
83:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // IS_LEAP_MONTH
84: };
85: 
86: static const double JULIAN_EPOCH = 1721425.5;
87: static const int32_t INDIAN_ERA_START  = 78;
88: static const int32_t INDIAN_YEAR_START = 80;
89: 
90: int32_t IndianCalendar::handleGetLimit(UCalendarDateFields field, ELimitType limitType) const {
91:   return INDIANCAL_LIMITS[field][limitType];
92: }
93: 
94: /*
95:  * Determine whether the given gregorian year is a Leap year
96:  */
97: static UBool isGregorianLeap(int32_t year)
98: {
99:     return ((year % 4) == 0) && (!(((year % 100) == 0) && ((year % 400) != 0)));
100: }
101: 
102: //----------------------------------------------------------------------
103: // Calendar framework
104: //----------------------------------------------------------------------
105: 
106: /*
107:  * Return the length (in days) of the given month.
108:  *
109:  * @param eyear  The year in Saka Era
110:  * @param month  The month(0-based) in Indian calendar
111:  */
112: int32_t IndianCalendar::handleGetMonthLength(int32_t eyear, int32_t month) const {
113:    if (month < 0 || month > 11) {
114:       eyear += ClockMath::floorDivide(month, 12, month);
115:    }
116: 
117:    if (isGregorianLeap(eyear + INDIAN_ERA_START) && month == 0) {
118:        return 31;
119:    }
120: 
121:    if (month >= 1 && month <= 5) {
122:        return 31;
123:    }
124: 
125:    return 30;
126: }
127: 
128: /*
129:  * Return the number of days in the given Indian year
130:  *
131:  * @param eyear The year in Saka Era.
132:  */
133: int32_t IndianCalendar::handleGetYearLength(int32_t eyear) const {
134:     return isGregorianLeap(eyear + INDIAN_ERA_START) ? 366 : 365;
135: }
136: /*
137:  * Returns the Julian Day corresponding to gregorian date
138:  *
139:  * @param year The Gregorian year
140:  * @param month The month in Gregorian Year
141:  * @param date The date in Gregorian day in month
142:  */
143: static double gregorianToJD(int32_t year, int32_t month, int32_t date) {
144:    double julianDay = (JULIAN_EPOCH - 1) +
145:       (365 * (year - 1)) +
146:       uprv_floor((year - 1) / 4) +
147:       (-uprv_floor((year - 1) / 100)) +
148:       uprv_floor((year - 1) / 400) +
149:       uprv_floor((((367 * month) - 362) / 12) +
150:             ((month <= 2) ? 0 :
151:              (isGregorianLeap(year) ? -1 : -2)
152:             ) +
153:             date);
154: 
155:    return julianDay;
156: }
157: 
158: /*
159:  * Returns the Gregorian Date corresponding to a given Julian Day
160:  * @param jd The Julian Day
161:  */
162: static int32_t* jdToGregorian(double jd, int32_t gregorianDate[3]) {
163:    double wjd, depoch, quadricent, dqc, cent, dcent, quad, dquad, yindex, yearday, leapadj;
164:    int32_t year, month, day;
165:    wjd = uprv_floor(jd - 0.5) + 0.5;
166:    depoch = wjd - JULIAN_EPOCH;
167:    quadricent = uprv_floor(depoch / 146097);
168:    dqc = (int32_t)uprv_floor(depoch) % 146097;
169:    cent = uprv_floor(dqc / 36524);
170:    dcent = (int32_t)uprv_floor(dqc) % 36524;
171:    quad = uprv_floor(dcent / 1461);
172:    dquad = (int32_t)uprv_floor(dcent) % 1461;
173:    yindex = uprv_floor(dquad / 365);
174:    year = (int32_t)((quadricent * 400) + (cent * 100) + (quad * 4) + yindex);
175:    if (!((cent == 4) || (yindex == 4))) {
176:       year++;
177:    }
178:    yearday = wjd - gregorianToJD(year, 1, 1);
179:    leapadj = ((wjd < gregorianToJD(year, 3, 1)) ? 0
180:          :
181:          (isGregorianLeap(year) ? 1 : 2)
182:          );
183:    month = (int32_t)uprv_floor((((yearday + leapadj) * 12) + 373) / 367);
184:    day = (int32_t)(wjd - gregorianToJD(year, month, 1)) + 1;
185: 
186:    gregorianDate[0] = year;
187:    gregorianDate[1] = month;
188:    gregorianDate[2] = day;
189: 
190:    return gregorianDate;
191: }
192: 
193: 
194: //-------------------------------------------------------------------------
195: // Functions for converting from field values to milliseconds....
196: //-------------------------------------------------------------------------
197: static double IndianToJD(int32_t year, int32_t month, int32_t date) {
198:    int32_t leapMonth, gyear, m;
199:    double start, jd;
200: 
201:    gyear = year + INDIAN_ERA_START;
202: 
203: 
204:    if(isGregorianLeap(gyear)) {
205:       leapMonth = 31;
206:       start = gregorianToJD(gyear, 3, 21);
207:    }
208:    else {
209:       leapMonth = 30;
210:       start = gregorianToJD(gyear, 3, 22);
211:    }
212: 
213:    if (month == 1) {
214:       jd = start + (date - 1);
215:    } else {
216:       jd = start + leapMonth;
217:       m = month - 2;
218: 
219:       //m = Math.min(m, 5);
220:       if (m > 5) {
221:           m = 5;
222:       }
223: 
224:       jd += m * 31;
225: 
226:       if (month >= 8) {
227:          m = month - 7;
228:          jd += m * 30;
229:       }
230:       jd += date - 1;
231:    }
232: 
233:    return jd;
234: }
235: 
236: /*
237:  * Return JD of start of given month/year of Indian Calendar
238:  * @param eyear The year in Indian Calendar measured from Saka Era (78 AD).
239:  * @param month The month in Indian calendar
240:  */
241: int32_t IndianCalendar::handleComputeMonthStart(int32_t eyear, int32_t month, UBool /* useMonth */ ) const {
242: 
243:    //month is 0 based; converting it to 1-based
244:    int32_t imonth;
245: 
246:     // If the month is out of range, adjust it into range, and adjust the extended eyar accordingly
247:    if (month < 0 || month > 11) {
248:       eyear += (int32_t)ClockMath::floorDivide(month, 12, month);
249:    }
250: 
251:    if(month == 12){
252:        imonth = 1;
253:    } else {
254:        imonth = month + 1;
255:    }
256: 
257:    double jd = IndianToJD(eyear ,imonth, 1);
258: 
259:    return (int32_t)jd;
260: }
261: 
262: //-------------------------------------------------------------------------
263: // Functions for converting from milliseconds to field values
264: //-------------------------------------------------------------------------
265: 
266: int32_t IndianCalendar::handleGetExtendedYear() {
267:     int32_t year;
268: 
269:     if (newerField(UCAL_EXTENDED_YEAR, UCAL_YEAR) == UCAL_EXTENDED_YEAR) {
270:         year = internalGet(UCAL_EXTENDED_YEAR, 1); // Default to year 1
271:     } else {
272:         year = internalGet(UCAL_YEAR, 1); // Default to year 1
273:     }
274: 
275:     return year;
276: }
277: 
278: /*
279:  * Override Calendar to compute several fields specific to the Indian
280:  * calendar system.  These are:
281:  *
282:  * <ul><li>ERA
283:  * <li>YEAR
284:  * <li>MONTH
285:  * <li>DAY_OF_MONTH
286:  * <li>EXTENDED_YEAR</ul>
287:  *
288:  * The DAY_OF_WEEK and DOW_LOCAL fields are already set when this
289:  * method is called. The getGregorianXxx() methods return Gregorian
290:  * calendar equivalents for the given Julian day.
291:  */
292: void IndianCalendar::handleComputeFields(int32_t julianDay, UErrorCode&  /* status */) {
293:     double jdAtStartOfGregYear;
294:     int32_t leapMonth, IndianYear, yday, IndianMonth, IndianDayOfMonth, mday;
295:     int32_t gregorianYear;      // Stores gregorian date corresponding to Julian day;
296:     int32_t gd[3];
297: 
298:     gregorianYear = jdToGregorian(julianDay, gd)[0];          // Gregorian date for Julian day
299:     IndianYear = gregorianYear - INDIAN_ERA_START;            // Year in Saka era
300:     jdAtStartOfGregYear = gregorianToJD(gregorianYear, 1, 1); // JD at start of Gregorian year
301:     yday = (int32_t)(julianDay - jdAtStartOfGregYear);        // Day number in Gregorian year (starting from 0)
302: 
303:     if (yday < INDIAN_YEAR_START) {
304:         // Day is at the end of the preceding Saka year
305:         IndianYear -= 1;
306:         leapMonth = isGregorianLeap(gregorianYear - 1) ? 31 : 30; // Days in leapMonth this year, previous Gregorian year
307:         yday += leapMonth + (31 * 5) + (30 * 3) + 10;
308:     } else {
309:         leapMonth = isGregorianLeap(gregorianYear) ? 31 : 30; // Days in leapMonth this year
310:         yday -= INDIAN_YEAR_START;
311:     }
312: 
313:     if (yday < leapMonth) {
314:         IndianMonth = 0;
315:         IndianDayOfMonth = yday + 1;
316:     } else {
317:         mday = yday - leapMonth;
318:         if (mday < (31 * 5)) {
319:             IndianMonth = (int32_t)uprv_floor(mday / 31) + 1;
320:             IndianDayOfMonth = (mday % 31) + 1;
321:         } else {
322:             mday -= 31 * 5;
323:             IndianMonth = (int32_t)uprv_floor(mday / 30) + 6;
324:             IndianDayOfMonth = (mday % 30) + 1;
325:         }
326:    }
327: 
328:    internalSet(UCAL_ERA, 0);
329:    internalSet(UCAL_EXTENDED_YEAR, IndianYear);
330:    internalSet(UCAL_YEAR, IndianYear);
331:    internalSet(UCAL_MONTH, IndianMonth);
332:    internalSet(UCAL_DAY_OF_MONTH, IndianDayOfMonth);
333:    internalSet(UCAL_DAY_OF_YEAR, yday + 1); // yday is 0-based
334: }
335: 
336: UBool
337: IndianCalendar::inDaylightTime(UErrorCode& status) const
338: {
339:     // copied from GregorianCalendar
340:     if (U_FAILURE(status) || !getTimeZone().useDaylightTime()) {
341:         return FALSE;
342:     }
343: 
344:     // Force an update of the state of the Calendar.
345:     ((IndianCalendar*)this)->complete(status); // cast away const
346: 
347:     return (UBool)(U_SUCCESS(status) ? (internalGet(UCAL_DST_OFFSET) != 0) : FALSE);
348: }
349: 
350: 
351: /**
352:  * The system maintains a static default century start date and Year.  They are
353:  * initialized the first time they are used.  Once the system default century date
354:  * and year are set, they do not change.
355:  */
356: static UDate           indiancal_gSystemDefaultCenturyStart       = DBL_MIN;
357: static int32_t         indiancal_gSystemDefaultCenturyStartYear   = -1;
358: static icu::UInitOnce  indiancal_gSystemDefaultCenturyInit        = U_INITONCE_INITIALIZER;
359: 
360: 
361: UBool IndianCalendar::haveDefaultCentury() const
362: {
363:     return TRUE;
364: }
365: 
366: static void U_CALLCONV
367: indiancal_initializeSystemDefaultCentury()
368: {
369:     // initialize systemDefaultCentury and systemDefaultCenturyYear based
370:     // on the current time.  They'll be set to 80 years before
371:     // the current time.
372:     UErrorCode status = U_ZERO_ERROR;
373: 
374:     IndianCalendar calendar ( Locale ( "@calendar=Indian" ), status);
375:     if ( U_SUCCESS ( status ) ) {
376:         calendar.setTime ( Calendar::getNow(), status );
377:         calendar.add ( UCAL_YEAR, -80, status );
378: 
379:         UDate    newStart = calendar.getTime ( status );
380:         int32_t  newYear  = calendar.get ( UCAL_YEAR, status );
381: 
382:         indiancal_gSystemDefaultCenturyStart = newStart;
383:         indiancal_gSystemDefaultCenturyStartYear = newYear;
384:     }
385:     // We have no recourse upon failure.
386: }
387: 
388: 
389: UDate
390: IndianCalendar::defaultCenturyStart() const
391: {
392:     // lazy-evaluate systemDefaultCenturyStart
393:     umtx_initOnce(indiancal_gSystemDefaultCenturyInit, &indiancal_initializeSystemDefaultCentury);
394:     return indiancal_gSystemDefaultCenturyStart;
395: }
396: 
397: int32_t
398: IndianCalendar::defaultCenturyStartYear() const
399: {
400:     // lazy-evaluate systemDefaultCenturyStartYear
401:     umtx_initOnce(indiancal_gSystemDefaultCenturyInit, &indiancal_initializeSystemDefaultCentury);
402:     return    indiancal_gSystemDefaultCenturyStartYear;
403: }
404: 
405: 
406: UOBJECT_DEFINE_RTTI_IMPLEMENTATION(IndianCalendar)
407: 
408: U_NAMESPACE_END
409: 
410: #endif
411: 
[end of extension/icu/third_party/icu/i18n/indiancal.cpp]
[start of extension/icu/third_party/icu/i18n/islamcal.cpp]
1: // © 2016 and later: Unicode, Inc. and others.
2: // License & terms of use: http://www.unicode.org/copyright.html
3: /*
4: ******************************************************************************
5: * Copyright (C) 2003-2015, International Business Machines Corporation
6: * and others. All Rights Reserved.
7: ******************************************************************************
8: *
9: * File ISLAMCAL.H
10: *
11: * Modification History:
12: *
13: *   Date        Name        Description
14: *   10/14/2003  srl         ported from java IslamicCalendar
15: *****************************************************************************
16: */
17: 
18: #include "islamcal.h"
19: 
20: #if !UCONFIG_NO_FORMATTING
21: 
22: #include "umutex.h"
23: #include <float.h>
24: #include "gregoimp.h" // Math
25: #include "astro.h" // CalendarAstronomer
26: #include "uhash.h"
27: #include "ucln_in.h"
28: #include "uassert.h"
29: 
30: static const UDate HIJRA_MILLIS = -42521587200000.0;    // 7/16/622 AD 00:00
31: 
32: // Debugging
33: #ifdef U_DEBUG_ISLAMCAL
34: # include <stdio.h>
35: # include <stdarg.h>
36: static void debug_islamcal_loc(const char *f, int32_t l)
37: {
38:     fprintf(stderr, "%s:%d: ", f, l);
39: }
40: 
41: static void debug_islamcal_msg(const char *pat, ...)
42: {
43:     va_list ap;
44:     va_start(ap, pat);
45:     vfprintf(stderr, pat, ap);
46:     fflush(stderr);
47: }
48: // must use double parens, i.e.:  U_DEBUG_ISLAMCAL_MSG(("four is: %d",4));
49: #define U_DEBUG_ISLAMCAL_MSG(x) {debug_islamcal_loc(__FILE__,__LINE__);debug_islamcal_msg x;}
50: #else
51: #define U_DEBUG_ISLAMCAL_MSG(x)
52: #endif
53: 
54: 
55: // --- The cache --
56: // cache of months
57: static icu::CalendarCache *gMonthCache = NULL;
58: static icu::CalendarAstronomer *gIslamicCalendarAstro = NULL;
59: 
60: U_CDECL_BEGIN
61: static UBool calendar_islamic_cleanup(void) {
62:     if (gMonthCache) {
63:         delete gMonthCache;
64:         gMonthCache = NULL;
65:     }
66:     if (gIslamicCalendarAstro) {
67:         delete gIslamicCalendarAstro;
68:         gIslamicCalendarAstro = NULL;
69:     }
70:     return TRUE;
71: }
72: U_CDECL_END
73: 
74: U_NAMESPACE_BEGIN
75: 
76: // Implementation of the IslamicCalendar class
77: 
78: /**
79:  * Friday EPOC
80:  */
81: static const int32_t CIVIL_EPOC = 1948440; // CE 622 July 16 Friday (Julian calendar) / CE 622 July 19 (Gregorian calendar)
82: 
83: /**
84:   * Thursday EPOC
85:   */
86: static const int32_t ASTRONOMICAL_EPOC = 1948439; // CE 622 July 15 Thursday (Julian calendar)
87: 
88: 
89: static const int32_t UMALQURA_YEAR_START = 1300;
90: static const int32_t UMALQURA_YEAR_END = 1600;
91: 
92: static const int UMALQURA_MONTHLENGTH[] = {
93:     //* 1300 -1302 */ "1010 1010 1010", "1101 0101 0100", "1110 1100 1001",
94:                             0x0AAA,           0x0D54,           0x0EC9,
95:     //* 1303 -1307 */ "0110 1101 0100", "0110 1110 1010", "0011 0110 1100", "1010 1010 1101", "0101 0101 0101",
96:                             0x06D4,           0x06EA,           0x036C,           0x0AAD,           0x0555,
97:     //* 1308 -1312 */ "0110 1010 1001", "0111 1001 0010", "1011 1010 1001", "0101 1101 0100", "1010 1101 1010",
98:                             0x06A9,           0x0792,           0x0BA9,           0x05D4,           0x0ADA,
99:     //* 1313 -1317 */ "0101 0101 1100", "1101 0010 1101", "0110 1001 0101", "0111 0100 1010", "1011 0101 0100",
100:                             0x055C,           0x0D2D,           0x0695,           0x074A,           0x0B54,
101:     //* 1318 -1322 */ "1011 0110 1010", "0101 1010 1101", "0100 1010 1110", "1010 0100 1111", "0101 0001 0111",
102:                             0x0B6A,           0x05AD,           0x04AE,           0x0A4F,           0x0517,
103:     //* 1323 -1327 */ "0110 1000 1011", "0110 1010 0101", "1010 1101 0101", "0010 1101 0110", "1001 0101 1011",
104:                             0x068B,           0x06A5,           0x0AD5,           0x02D6,           0x095B,
105:     //* 1328 -1332 */ "0100 1001 1101", "1010 0100 1101", "1101 0010 0110", "1101 1001 0101", "0101 1010 1100",
106:                             0x049D,           0x0A4D,           0x0D26,           0x0D95,           0x05AC,
107:     //* 1333 -1337 */ "1001 1011 0110", "0010 1011 1010", "1010 0101 1011", "0101 0010 1011", "1010 1001 0101",
108:                             0x09B6,           0x02BA,           0x0A5B,           0x052B,           0x0A95,
109:     //* 1338 -1342 */ "0110 1100 1010", "1010 1110 1001", "0010 1111 0100", "1001 0111 0110", "0010 1011 0110",
110:                             0x06CA,           0x0AE9,           0x02F4,           0x0976,           0x02B6,
111:     //* 1343 -1347 */ "1001 0101 0110", "1010 1100 1010", "1011 1010 0100", "1011 1101 0010", "0101 1101 1001",
112:                             0x0956,           0x0ACA,           0x0BA4,           0x0BD2,           0x05D9,
113:     //* 1348 -1352 */ "0010 1101 1100", "1001 0110 1101", "0101 0100 1101", "1010 1010 0101", "1011 0101 0010",
114:                             0x02DC,           0x096D,           0x054D,           0x0AA5,           0x0B52,
115:     //* 1353 -1357 */ "1011 1010 0101", "0101 1011 0100", "1001 1011 0110", "0101 0101 0111", "0010 1001 0111",
116:                             0x0BA5,           0x05B4,           0x09B6,           0x0557,           0x0297,
117:     //* 1358 -1362 */ "0101 0100 1011", "0110 1010 0011", "0111 0101 0010", "1011 0110 0101", "0101 0110 1010",
118:                             0x054B,           0x06A3,           0x0752,           0x0B65,           0x056A,
119:     //* 1363 -1367 */ "1010 1010 1011", "0101 0010 1011", "1100 1001 0101", "1101 0100 1010", "1101 1010 0101",
120:                             0x0AAB,           0x052B,           0x0C95,           0x0D4A,           0x0DA5,
121:     //* 1368 -1372 */ "0101 1100 1010", "1010 1101 0110", "1001 0101 0111", "0100 1010 1011", "1001 0100 1011",
122:                             0x05CA,           0x0AD6,           0x0957,           0x04AB,           0x094B,
123:     //* 1373 -1377 */ "1010 1010 0101", "1011 0101 0010", "1011 0110 1010", "0101 0111 0101", "0010 0111 0110",
124:                             0x0AA5,           0x0B52,           0x0B6A,           0x0575,           0x0276,
125:     //* 1378 -1382 */ "1000 1011 0111", "0100 0101 1011", "0101 0101 0101", "0101 1010 1001", "0101 1011 0100",
126:                             0x08B7,           0x045B,           0x0555,           0x05A9,           0x05B4,
127:     //* 1383 -1387 */ "1001 1101 1010", "0100 1101 1101", "0010 0110 1110", "1001 0011 0110", "1010 1010 1010",
128:                             0x09DA,           0x04DD,           0x026E,           0x0936,           0x0AAA,
129:     //* 1388 -1392 */ "1101 0101 0100", "1101 1011 0010", "0101 1101 0101", "0010 1101 1010", "1001 0101 1011",
130:                             0x0D54,           0x0DB2,           0x05D5,           0x02DA,           0x095B,
131:     //* 1393 -1397 */ "0100 1010 1011", "1010 0101 0101", "1011 0100 1001", "1011 0110 0100", "1011 0111 0001",
132:                             0x04AB,           0x0A55,           0x0B49,           0x0B64,           0x0B71,
133:     //* 1398 -1402 */ "0101 1011 0100", "1010 1011 0101", "1010 0101 0101", "1101 0010 0101", "1110 1001 0010",
134:                             0x05B4,           0x0AB5,           0x0A55,           0x0D25,           0x0E92,
135:     //* 1403 -1407 */ "1110 1100 1001", "0110 1101 0100", "1010 1110 1001", "1001 0110 1011", "0100 1010 1011",
136:                             0x0EC9,           0x06D4,           0x0AE9,           0x096B,           0x04AB,
137:     //* 1408 -1412 */ "1010 1001 0011", "1101 0100 1001", "1101 1010 0100", "1101 1011 0010", "1010 1011 1001",
138:                             0x0A93,           0x0D49,         0x0DA4,           0x0DB2,           0x0AB9,
139:     //* 1413 -1417 */ "0100 1011 1010", "1010 0101 1011", "0101 0010 1011", "1010 1001 0101", "1011 0010 1010",
140:                             0x04BA,           0x0A5B,           0x052B,           0x0A95,           0x0B2A,
141:     //* 1418 -1422 */ "1011 0101 0101", "0101 0101 1100", "0100 1011 1101", "0010 0011 1101", "1001 0001 1101",
142:                             0x0B55,           0x055C,           0x04BD,           0x023D,           0x091D,
143:     //* 1423 -1427 */ "1010 1001 0101", "1011 0100 1010", "1011 0101 1010", "0101 0110 1101", "0010 1011 0110",
144:                             0x0A95,           0x0B4A,           0x0B5A,           0x056D,           0x02B6,
145:     //* 1428 -1432 */ "1001 0011 1011", "0100 1001 1011", "0110 0101 0101", "0110 1010 1001", "0111 0101 0100",
146:                             0x093B,           0x049B,           0x0655,           0x06A9,           0x0754,
147:     //* 1433 -1437 */ "1011 0110 1010", "0101 0110 1100", "1010 1010 1101", "0101 0101 0101", "1011 0010 1001",
148:                             0x0B6A,           0x056C,           0x0AAD,           0x0555,           0x0B29,
149:     //* 1438 -1442 */ "1011 1001 0010", "1011 1010 1001", "0101 1101 0100", "1010 1101 1010", "0101 0101 1010",
150:                             0x0B92,           0x0BA9,           0x05D4,           0x0ADA,           0x055A,
151:     //* 1443 -1447 */ "1010 1010 1011", "0101 1001 0101", "0111 0100 1001", "0111 0110 0100", "1011 1010 1010",
152:                             0x0AAB,           0x0595,           0x0749,           0x0764,           0x0BAA,
153:     //* 1448 -1452 */ "0101 1011 0101", "0010 1011 0110", "1010 0101 0110", "1110 0100 1101", "1011 0010 0101",
154:                             0x05B5,           0x02B6,           0x0A56,           0x0E4D,           0x0B25,
155:     //* 1453 -1457 */ "1011 0101 0010", "1011 0110 1010", "0101 1010 1101", "0010 1010 1110", "1001 0010 1111",
156:                             0x0B52,           0x0B6A,           0x05AD,           0x02AE,           0x092F,
157:     //* 1458 -1462 */ "0100 1001 0111", "0110 0100 1011", "0110 1010 0101", "0110 1010 1100", "1010 1101 0110",
158:                             0x0497,           0x064B,           0x06A5,           0x06AC,           0x0AD6,
159:     //* 1463 -1467 */ "0101 0101 1101", "0100 1001 1101", "1010 0100 1101", "1101 0001 0110", "1101 1001 0101",
160:                             0x055D,           0x049D,           0x0A4D,           0x0D16,           0x0D95,
161:     //* 1468 -1472 */ "0101 1010 1010", "0101 1011 0101", "0010 1101 1010", "1001 0101 1011", "0100 1010 1101",
162:                             0x05AA,           0x05B5,           0x02DA,           0x095B,           0x04AD,
163:     //* 1473 -1477 */ "0101 1001 0101", "0110 1100 1010", "0110 1110 0100", "1010 1110 1010", "0100 1111 0101",
164:                             0x0595,           0x06CA,           0x06E4,           0x0AEA,           0x04F5,
165:     //* 1478 -1482 */ "0010 1011 0110", "1001 0101 0110", "1010 1010 1010", "1011 0101 0100", "1011 1101 0010",
166:                             0x02B6,           0x0956,           0x0AAA,           0x0B54,           0x0BD2,
167:     //* 1483 -1487 */ "0101 1101 1001", "0010 1110 1010", "1001 0110 1101", "0100 1010 1101", "1010 1001 0101",
168:                             0x05D9,           0x02EA,           0x096D,           0x04AD,           0x0A95,
169:     //* 1488 -1492 */ "1011 0100 1010", "1011 1010 0101", "0101 1011 0010", "1001 1011 0101", "0100 1101 0110",
170:                             0x0B4A,           0x0BA5,           0x05B2,           0x09B5,           0x04D6,
171:     //* 1493 -1497 */ "1010 1001 0111", "0101 0100 0111", "0110 1001 0011", "0111 0100 1001", "1011 0101 0101",
172:                             0x0A97,           0x0547,           0x0693,           0x0749,           0x0B55,
173:     //* 1498 -1508 */ "0101 0110 1010", "1010 0110 1011", "0101 0010 1011", "1010 1000 1011", "1101 0100 0110", "1101 1010 0011", "0101 1100 1010", "1010 1101 0110", "0100 1101 1011", "0010 0110 1011", "1001 0100 1011",
174:                             0x056A,           0x0A6B,           0x052B,           0x0A8B,           0x0D46,           0x0DA3,           0x05CA,           0x0AD6,           0x04DB,           0x026B,           0x094B,
175:     //* 1509 -1519 */ "1010 1010 0101", "1011 0101 0010", "1011 0110 1001", "0101 0111 0101", "0001 0111 0110", "1000 1011 0111", "0010 0101 1011", "0101 0010 1011", "0101 0110 0101", "0101 1011 0100", "1001 1101 1010",
176:                             0x0AA5,           0x0B52,           0x0B69,           0x0575,           0x0176,           0x08B7,           0x025B,           0x052B,           0x0565,           0x05B4,           0x09DA,
177:     //* 1520 -1530 */ "0100 1110 1101", "0001 0110 1101", "1000 1011 0110", "1010 1010 0110", "1101 0101 0010", "1101 1010 1001", "0101 1101 0100", "1010 1101 1010", "1001 0101 1011", "0100 1010 1011", "0110 0101 0011",
178:                             0x04ED,           0x016D,           0x08B6,           0x0AA6,           0x0D52,           0x0DA9,           0x05D4,           0x0ADA,           0x095B,           0x04AB,           0x0653,
179:     //* 1531 -1541 */ "0111 0010 1001", "0111 0110 0010", "1011 1010 1001", "0101 1011 0010", "1010 1011 0101", "0101 0101 0101", "1011 0010 0101", "1101 1001 0010", "1110 1100 1001", "0110 1101 0010", "1010 1110 1001",
180:                             0x0729,           0x0762,           0x0BA9,           0x05B2,           0x0AB5,           0x0555,           0x0B25,           0x0D92,           0x0EC9,           0x06D2,           0x0AE9,
181:     //* 1542 -1552 */ "0101 0110 1011", "0100 1010 1011", "1010 0101 0101", "1101 0010 1001", "1101 0101 0100", "1101 1010 1010", "1001 1011 0101", "0100 1011 1010", "1010 0011 1011", "0100 1001 1011", "1010 0100 1101",
182:                             0x056B,           0x04AB,           0x0A55,           0x0D29,           0x0D54,           0x0DAA,           0x09B5,           0x04BA,           0x0A3B,           0x049B,           0x0A4D,
183:     //* 1553 -1563 */ "1010 1010 1010", "1010 1101 0101", "0010 1101 1010", "1001 0101 1101", "0100 0101 1110", "1010 0010 1110", "1100 1001 1010", "1101 0101 0101", "0110 1011 0010", "0110 1011 1001", "0100 1011 1010",
184:                             0x0AAA,           0x0AD5,           0x02DA,           0x095D,           0x045E,           0x0A2E,           0x0C9A,           0x0D55,           0x06B2,           0x06B9,           0x04BA,
185:     //* 1564 -1574 */ "1010 0101 1101", "0101 0010 1101", "1010 1001 0101", "1011 0101 0010", "1011 1010 1000", "1011 1011 0100", "0101 1011 1001", "0010 1101 1010", "1001 0101 1010", "1011 0100 1010", "1101 1010 0100",
186:                             0x0A5D,           0x052D,           0x0A95,           0x0B52,           0x0BA8,           0x0BB4,           0x05B9,           0x02DA,           0x095A,           0x0B4A,           0x0DA4,
187:     //* 1575 -1585 */ "1110 1101 0001", "0110 1110 1000", "1011 0110 1010", "0101 0110 1101", "0101 0011 0101", "0110 1001 0101", "1101 0100 1010", "1101 1010 1000", "1101 1101 0100", "0110 1101 1010", "0101 0101 1011",
188:                             0x0ED1,           0x06E8,           0x0B6A,           0x056D,           0x0535,           0x0695,           0x0D4A,           0x0DA8,           0x0DD4,           0x06DA,           0x055B,
189:     //* 1586 -1596 */ "0010 1001 1101", "0110 0010 1011", "1011 0001 0101", "1011 0100 1010", "1011 1001 0101", "0101 1010 1010", "1010 1010 1110", "1001 0010 1110", "1100 1000 1111", "0101 0010 0111", "0110 1001 0101",
190:                             0x029D,           0x062B,           0x0B15,           0x0B4A,           0x0B95,           0x05AA,           0x0AAE,           0x092E,           0x0C8F,           0x0527,           0x0695,
191:     //* 1597 -1600 */ "0110 1010 1010", "1010 1101 0110", "0101 0101 1101", "0010 1001 1101", };
192:                             0x06AA,           0x0AD6,           0x055D,           0x029D
193: };
194: 
195: int32_t getUmalqura_MonthLength(int32_t y, int32_t m) {
196:     int32_t mask = (int32_t) (0x01 << (11 - m));    // set mask for bit corresponding to month
197:     if((UMALQURA_MONTHLENGTH[y] & mask) == 0 )
198:         return 29;
199:     else
200:         return 30;
201: 
202: }
203: 
204: //-------------------------------------------------------------------------
205: // Constructors...
206: //-------------------------------------------------------------------------
207: 
208: const char *IslamicCalendar::getType() const {
209:     const char *sType = NULL;
210: 
211:     switch (cType) {
212:     case CIVIL:
213:         sType = "islamic-civil";
214:         break;
215:     case ASTRONOMICAL:
216:         sType = "islamic";
217:         break;
218:     case TBLA:
219:         sType = "islamic-tbla";
220:         break;
221:     case UMALQURA:
222:         sType = "islamic-umalqura";
223:         break;
224:     default:
225:         UPRV_UNREACHABLE; // out of range
226:     }
227:     return sType;
228: }
229: 
230: IslamicCalendar* IslamicCalendar::clone() const {
231:     return new IslamicCalendar(*this);
232: }
233: 
234: IslamicCalendar::IslamicCalendar(const Locale& aLocale, UErrorCode& success, ECalculationType type)
235: :   Calendar(TimeZone::createDefault(), aLocale, success),
236: cType(type)
237: {
238:     setTimeInMillis(getNow(), success); // Call this again now that the vtable is set up properly.
239: }
240: 
241: IslamicCalendar::IslamicCalendar(const IslamicCalendar& other) : Calendar(other), cType(other.cType) {
242: }
243: 
244: IslamicCalendar::~IslamicCalendar()
245: {
246: }
247: 
248: void IslamicCalendar::setCalculationType(ECalculationType type, UErrorCode &status)
249: {
250:     if (cType != type) {
251:         // The fields of the calendar will become invalid, because the calendar
252:         // rules are different
253:         UDate m = getTimeInMillis(status);
254:         cType = type;
255:         clear();
256:         setTimeInMillis(m, status);
257:     }
258: }
259: 
260: /**
261: * Returns <code>true</code> if this object is using the fixed-cycle civil
262: * calendar, or <code>false</code> if using the religious, astronomical
263: * calendar.
264: * @draft ICU 2.4
265: */
266: UBool IslamicCalendar::isCivil() {
267:     return (cType == CIVIL);
268: }
269: 
270: //-------------------------------------------------------------------------
271: // Minimum / Maximum access functions
272: //-------------------------------------------------------------------------
273: 
274: // Note: Current IslamicCalendar implementation does not work
275: // well with negative years.
276: 
277: // TODO: In some cases the current ICU Islamic calendar implementation shows
278: // a month as having 31 days. Since date parsing now uses range checks based
279: // on the table below, we need to change the range for last day of month to
280: // include 31 as a workaround until the implementation is fixed.
281: static const int32_t ISLAMCAL_LIMITS[UCAL_FIELD_COUNT][4] = {
282:     // Minimum  Greatest    Least  Maximum
283:     //           Minimum  Maximum
284:     {        0,        0,        0,        0}, // ERA
285:     {        1,        1,  5000000,  5000000}, // YEAR
286:     {        0,        0,       11,       11}, // MONTH
287:     {        1,        1,       50,       51}, // WEEK_OF_YEAR
288:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // WEEK_OF_MONTH
289:     {        1,        1,       29,       31}, // DAY_OF_MONTH - 31 to workaround for cal implementation bug, should be 30
290:     {        1,        1,      354,      355}, // DAY_OF_YEAR
291:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // DAY_OF_WEEK
292:     {       -1,       -1,        5,        5}, // DAY_OF_WEEK_IN_MONTH
293:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // AM_PM
294:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // HOUR
295:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // HOUR_OF_DAY
296:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // MINUTE
297:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // SECOND
298:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // MILLISECOND
299:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // ZONE_OFFSET
300:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // DST_OFFSET
301:     {        1,        1,  5000000,  5000000}, // YEAR_WOY
302:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // DOW_LOCAL
303:     {        1,        1,  5000000,  5000000}, // EXTENDED_YEAR
304:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // JULIAN_DAY
305:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // MILLISECONDS_IN_DAY
306:     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // IS_LEAP_MONTH
307: };
308: 
309: /**
310: * @draft ICU 2.4
311: */
312: int32_t IslamicCalendar::handleGetLimit(UCalendarDateFields field, ELimitType limitType) const {
313:     return ISLAMCAL_LIMITS[field][limitType];
314: }
315: 
316: //-------------------------------------------------------------------------
317: // Assorted calculation utilities
318: //
319: 
320: // we could compress this down more if we need to
321: static const int8_t umAlQuraYrStartEstimateFix[] = {
322:      0,  0, -1,  0, -1,  0,  0,  0,  0,  0, // 1300..
323:     -1,  0,  0,  0,  0,  0,  0,  0, -1,  0, // 1310..
324:      1,  0,  1,  1,  0,  0,  0,  0,  1,  0, // 1320..
325:      0,  0,  0,  0,  0,  0,  1,  0,  0,  0, // 1330..
326:      0,  0,  1,  0,  0, -1, -1,  0,  0,  0, // 1340..
327:      1,  0,  0, -1,  0,  0,  0,  1,  1,  0, // 1350..
328:      0,  0,  0,  0,  0,  0,  0, -1,  0,  0, // 1360..
329:      0,  1,  1,  0,  0, -1,  0,  1,  0,  1, // 1370..
330:      1,  0,  0, -1,  0,  1,  0,  0,  0, -1, // 1380..
331:      0,  1,  0,  1,  0,  0,  0, -1,  0,  0, // 1390..
332:      0,  0, -1, -1,  0, -1,  0,  1,  0,  0, // 1400..
333:      0, -1,  0,  0,  0,  1,  0,  0,  0,  0, // 1410..
334:      0,  1,  0,  0, -1, -1,  0,  0,  0,  1, // 1420..
335:      0,  0, -1, -1,  0, -1,  0,  0, -1, -1, // 1430..
336:      0, -1,  0, -1,  0,  0, -1, -1,  0,  0, // 1440..
337:      0,  0,  0,  0, -1,  0,  1,  0,  1,  1, // 1450..
338:      0,  0, -1,  0,  1,  0,  0,  0,  0,  0, // 1460..
339:      1,  0,  1,  0,  0,  0, -1,  0,  1,  0, // 1470..
340:      0, -1, -1,  0,  0,  0,  1,  0,  0,  0, // 1480..
341:      0,  0,  0,  0,  1,  0,  0,  0,  0,  0, // 1490..
342:      1,  0,  0, -1,  0,  0,  0,  1,  1,  0, // 1500..
343:      0, -1,  0,  1,  0,  1,  1,  0,  0,  0, // 1510..
344:      0,  1,  0,  0,  0, -1,  0,  0,  0,  1, // 1520..
345:      0,  0,  0, -1,  0,  0,  0,  0,  0, -1, // 1530..
346:      0, -1,  0,  1,  0,  0,  0, -1,  0,  1, // 1540..
347:      0,  1,  0,  0,  0,  0,  0,  1,  0,  0, // 1550..
348:     -1,  0,  0,  0,  0,  1,  0,  0,  0, -1, // 1560..
349:      0,  0,  0,  0, -1, -1,  0, -1,  0,  1, // 1570..
350:      0,  0, -1, -1,  0,  0,  1,  1,  0,  0, // 1580..
351:     -1,  0,  0,  0,  0,  1,  0,  0,  0,  0, // 1590..
352:      1 // 1600
353: };
354: 
355: /**
356: * Determine whether a year is a leap year in the Islamic civil calendar
357: */
358: UBool IslamicCalendar::civilLeapYear(int32_t year)
359: {
360:     return (14 + 11 * year) % 30 < 11;
361: }
362: 
363: /**
364: * Return the day # on which the given year starts.  Days are counted
365: * from the Hijri epoch, origin 0.
366: */
367: int32_t IslamicCalendar::yearStart(int32_t year) const{
368:     if (cType == CIVIL || cType == TBLA ||
369:         (cType == UMALQURA && (year < UMALQURA_YEAR_START || year > UMALQURA_YEAR_END)))
370:     {
371:         return (year-1)*354 + ClockMath::floorDivide((3+11*year),30);
372:     } else if(cType==ASTRONOMICAL){
373:         return trueMonthStart(12*(year-1));
374:     } else {
375:         year -= UMALQURA_YEAR_START;
376:         // rounded least-squares fit of the dates previously calculated from UMALQURA_MONTHLENGTH iteration
377:         int32_t yrStartLinearEstimate = (int32_t)((354.36720 * (double)year) + 460322.05 + 0.5);
378:         // need a slight correction to some
379:         return yrStartLinearEstimate + umAlQuraYrStartEstimateFix[year];
380:     }
381: }
382: 
383: /**
384: * Return the day # on which the given month starts.  Days are counted
385: * from the Hijri epoch, origin 0.
386: *
387: * @param year  The hijri year
388: * @param month The hijri month, 0-based (assumed to be in range 0..11)
389: */
390: int32_t IslamicCalendar::monthStart(int32_t year, int32_t month) const {
391:     if (cType == CIVIL || cType == TBLA) {
392:         // This does not handle months out of the range 0..11
393:         return (int32_t)uprv_ceil(29.5*month)
394:             + (year-1)*354 + (int32_t)ClockMath::floorDivide((3+11*year),30);
395:     } else if(cType==ASTRONOMICAL){
396:         return trueMonthStart(12*(year-1) + month);
397:     } else {
398:         int32_t ms = yearStart(year);
399:         for(int i=0; i< month; i++){
400:             ms+= handleGetMonthLength(year, i);
401:         }
402:         return ms;
403:     }
404: }
405: 
406: /**
407: * Find the day number on which a particular month of the true/lunar
408: * Islamic calendar starts.
409: *
410: * @param month The month in question, origin 0 from the Hijri epoch
411: *
412: * @return The day number on which the given month starts.
413: */
414: int32_t IslamicCalendar::trueMonthStart(int32_t month) const
415: {
416:     UErrorCode status = U_ZERO_ERROR;
417:     int32_t start = CalendarCache::get(&gMonthCache, month, status);
418: 
419:     if (start==0) {
420:         // Make a guess at when the month started, using the average length
421:         UDate origin = HIJRA_MILLIS
422:             + uprv_floor(month * CalendarAstronomer::SYNODIC_MONTH) * kOneDay;
423: 
424:         // moonAge will fail due to memory allocation error
425:         double age = moonAge(origin, status);
426:         if (U_FAILURE(status)) {
427:             goto trueMonthStartEnd;
428:         }
429: 
430:         if (age >= 0) {
431:             // The month has already started
432:             do {
433:                 origin -= kOneDay;
434:                 age = moonAge(origin, status);
435:                 if (U_FAILURE(status)) {
436:                     goto trueMonthStartEnd;
437:                 }
438:             } while (age >= 0);
439:         }
440:         else {
441:             // Preceding month has not ended yet.
442:             do {
443:                 origin += kOneDay;
444:                 age = moonAge(origin, status);
445:                 if (U_FAILURE(status)) {
446:                     goto trueMonthStartEnd;
447:                 }
448:             } while (age < 0);
449:         }
450:         start = (int32_t)ClockMath::floorDivide((origin - HIJRA_MILLIS), (double)kOneDay) + 1;
451:         CalendarCache::put(&gMonthCache, month, start, status);
452:     }
453: trueMonthStartEnd :
454:     if(U_FAILURE(status)) {
455:         start = 0;
456:     }
457:     return start;
458: }
459: 
460: /**
461: * Return the "age" of the moon at the given time; this is the difference
462: * in ecliptic latitude between the moon and the sun.  This method simply
463: * calls CalendarAstronomer.moonAge, converts to degrees,
464: * and adjusts the result to be in the range [-180, 180].
465: *
466: * @param time  The time at which the moon's age is desired,
467: *              in millis since 1/1/1970.
468: */
469: double IslamicCalendar::moonAge(UDate time, UErrorCode &status)
470: {
471:     double age = 0;
472: 
473:     static UMutex astroLock;      // pod bay door lock
474:     umtx_lock(&astroLock);
475:     if(gIslamicCalendarAstro == NULL) {
476:         gIslamicCalendarAstro = new CalendarAstronomer();
477:         if (gIslamicCalendarAstro == NULL) {
478:             status = U_MEMORY_ALLOCATION_ERROR;
479:             return age;
480:         }
481:         ucln_i18n_registerCleanup(UCLN_I18N_ISLAMIC_CALENDAR, calendar_islamic_cleanup);
482:     }
483:     gIslamicCalendarAstro->setTime(time);
484:     age = gIslamicCalendarAstro->getMoonAge();
485:     umtx_unlock(&astroLock);
486: 
487:     // Convert to degrees and normalize...
488:     age = age * 180 / CalendarAstronomer::PI;
489:     if (age > 180) {
490:         age = age - 360;
491:     }
492: 
493:     return age;
494: }
495: 
496: //----------------------------------------------------------------------
497: // Calendar framework
498: //----------------------------------------------------------------------
499: 
500: /**
501: * Return the length (in days) of the given month.
502: *
503: * @param year  The hijri year
504: * @param year  The hijri month, 0-based
505: * @draft ICU 2.4
506: */
507: int32_t IslamicCalendar::handleGetMonthLength(int32_t extendedYear, int32_t month) const {
508: 
509:     int32_t length = 0;
510: 
511:     if (cType == CIVIL || cType == TBLA ||
512:         (cType == UMALQURA && (extendedYear<UMALQURA_YEAR_START || extendedYear>UMALQURA_YEAR_END)) ) {
513:         length = 29 + (month+1) % 2;
514:         if (month == DHU_AL_HIJJAH && civilLeapYear(extendedYear)) {
515:             length++;
516:         }
517:     } else if(cType == ASTRONOMICAL){
518:         month = 12*(extendedYear-1) + month;
519:         length =  trueMonthStart(month+1) - trueMonthStart(month) ;
520:     } else {
521:         length = getUmalqura_MonthLength(extendedYear - UMALQURA_YEAR_START, month);
522:     }
523:     return length;
524: }
525: 
526: /**
527: * Return the number of days in the given Islamic year
528: * @draft ICU 2.4
529: */
530: int32_t IslamicCalendar::handleGetYearLength(int32_t extendedYear) const {
531:     if (cType == CIVIL || cType == TBLA ||
532:         (cType == UMALQURA && (extendedYear<UMALQURA_YEAR_START || extendedYear>UMALQURA_YEAR_END)) ) {
533:         return 354 + (civilLeapYear(extendedYear) ? 1 : 0);
534:     } else if(cType == ASTRONOMICAL){
535:         int32_t month = 12*(extendedYear-1);
536:         return (trueMonthStart(month + 12) - trueMonthStart(month));
537:     } else {
538:         int len = 0;
539:         for(int i=0; i<12; i++) {
540:             len += handleGetMonthLength(extendedYear, i);
541:         }
542:         return len;
543:     }
544: }
545: 
546: //-------------------------------------------------------------------------
547: // Functions for converting from field values to milliseconds....
548: //-------------------------------------------------------------------------
549: 
550: // Return JD of start of given month/year
551: // Calendar says:
552: // Get the Julian day of the day BEFORE the start of this year.
553: // If useMonth is true, get the day before the start of the month.
554: // Hence the -1
555: /**
556: * @draft ICU 2.4
557: */
558: int32_t IslamicCalendar::handleComputeMonthStart(int32_t eyear, int32_t month, UBool /* useMonth */) const {
559:     // This may be called by Calendar::handleComputeJulianDay with months out of the range
560:     // 0..11. Need to handle that here since monthStart requires months in the range 0.11.
561:     if (month > 11) {
562:         eyear += (month / 12);
563:         month %= 12;
564:     } else if (month < 0) {
565:         month++;
566:         eyear += (month / 12) - 1;
567:         month = (month % 12) + 11;
568:     }
569:     return monthStart(eyear, month) + ((cType == TBLA)? ASTRONOMICAL_EPOC: CIVIL_EPOC) - 1;
570: }
571: 
572: //-------------------------------------------------------------------------
573: // Functions for converting from milliseconds to field values
574: //-------------------------------------------------------------------------
575: 
576: /**
577: * @draft ICU 2.4
578: */
579: int32_t IslamicCalendar::handleGetExtendedYear() {
580:     int32_t year;
581:     if (newerField(UCAL_EXTENDED_YEAR, UCAL_YEAR) == UCAL_EXTENDED_YEAR) {
582:         year = internalGet(UCAL_EXTENDED_YEAR, 1); // Default to year 1
583:     } else {
584:         year = internalGet(UCAL_YEAR, 1); // Default to year 1
585:     }
586:     return year;
587: }
588: 
589: /**
590: * Override Calendar to compute several fields specific to the Islamic
591: * calendar system.  These are:
592: *
593: * <ul><li>ERA
594: * <li>YEAR
595: * <li>MONTH
596: * <li>DAY_OF_MONTH
597: * <li>DAY_OF_YEAR
598: * <li>EXTENDED_YEAR</ul>
599: *
600: * The DAY_OF_WEEK and DOW_LOCAL fields are already set when this
601: * method is called. The getGregorianXxx() methods return Gregorian
602: * calendar equivalents for the given Julian day.
603: * @draft ICU 2.4
604: */
605: void IslamicCalendar::handleComputeFields(int32_t julianDay, UErrorCode &status) {
606:     int32_t year, month, dayOfMonth, dayOfYear;
607:     int32_t startDate;
608:     int32_t days = julianDay - CIVIL_EPOC;
609: 
610:     if (cType == CIVIL || cType == TBLA) {
611:         if(cType == TBLA) {
612:             days = julianDay - ASTRONOMICAL_EPOC;
613:         }
614:         // Use the civil calendar approximation, which is just arithmetic
615:         year  = (int32_t)ClockMath::floorDivide(30 * (int64_t)days + 10646, (int64_t)10631);
616:         month = (int32_t)uprv_ceil((days - 29 - yearStart(year)) / 29.5 );
617:         month = month<11?month:11;
618:         startDate = monthStart(year, month);
619:     } else if(cType == ASTRONOMICAL){
620:         // Guess at the number of elapsed full months since the epoch
621:         int32_t months = (int32_t)uprv_floor((double)days / CalendarAstronomer::SYNODIC_MONTH);
622: 
623:         startDate = (int32_t)uprv_floor(months * CalendarAstronomer::SYNODIC_MONTH);
624: 
625:         double age = moonAge(internalGetTime(), status);
626:         if (U_FAILURE(status)) {
627:             status = U_MEMORY_ALLOCATION_ERROR;
628:             return;
629:         }
630:         if ( days - startDate >= 25 && age > 0) {
631:             // If we're near the end of the month, assume next month and search backwards
632:             months++;
633:         }
634: 
635:         // Find out the last time that the new moon was actually visible at this longitude
636:         // This returns midnight the night that the moon was visible at sunset.
637:         while ((startDate = trueMonthStart(months)) > days) {
638:             // If it was after the date in question, back up a month and try again
639:             months--;
640:         }
641: 
642:         year = months / 12 + 1;
643:         month = months % 12;
644:     } else if(cType == UMALQURA) {
645:         int32_t umalquraStartdays = yearStart(UMALQURA_YEAR_START) ;
646:         if( days < umalquraStartdays){
647:                 //Use Civil calculation
648:                 year  = (int)ClockMath::floorDivide( (double)(30 * days + 10646) , 10631.0 );
649:                 month = (int32_t)uprv_ceil((days - 29 - yearStart(year)) / 29.5 );
650:                 month = month<11?month:11;
651:                 startDate = monthStart(year, month);
652:             }else{
653:                 int y =UMALQURA_YEAR_START-1, m =0;
654:                 long d = 1;
655:                 while(d > 0){
656:                     y++;
657:                     d = days - yearStart(y) +1;
658:                     if(d == handleGetYearLength(y)){
659:                         m=11;
660:                         break;
661:                     }else if(d < handleGetYearLength(y) ){
662:                         int monthLen = handleGetMonthLength(y, m);
663:                         m=0;
664:                         while(d > monthLen){
665:                             d -= monthLen;
666:                             m++;
667:                             monthLen = handleGetMonthLength(y, m);
668:                         }
669:                         break;
670:                     }
671:                 }
672:                 year = y;
673:                 month = m;
674:             }
675:     } else { // invalid 'civil'
676:       UPRV_UNREACHABLE; // should not get here, out of range
677:     }
678: 
679:     dayOfMonth = (days - monthStart(year, month)) + 1;
680: 
681:     // Now figure out the day of the year.
682:     dayOfYear = (days - monthStart(year, 0)) + 1;
683: 
684: 
685:     internalSet(UCAL_ERA, 0);
686:     internalSet(UCAL_YEAR, year);
687:     internalSet(UCAL_EXTENDED_YEAR, year);
688:     internalSet(UCAL_MONTH, month);
689:     internalSet(UCAL_DAY_OF_MONTH, dayOfMonth);
690:     internalSet(UCAL_DAY_OF_YEAR, dayOfYear);
691: }
692: 
693: UBool
694: IslamicCalendar::inDaylightTime(UErrorCode& status) const
695: {
696:     // copied from GregorianCalendar
697:     if (U_FAILURE(status) || !getTimeZone().useDaylightTime())
698:         return FALSE;
699: 
700:     // Force an update of the state of the Calendar.
701:     ((IslamicCalendar*)this)->complete(status); // cast away const
702: 
703:     return (UBool)(U_SUCCESS(status) ? (internalGet(UCAL_DST_OFFSET) != 0) : FALSE);
704: }
705: 
706: /**
707:  * The system maintains a static default century start date and Year.  They are
708:  * initialized the first time they are used.  Once the system default century date
709:  * and year are set, they do not change.
710:  */
711: static UDate           islamcal_gSystemDefaultCenturyStart       = DBL_MIN;
712: static int32_t         islamcal_gSystemDefaultCenturyStartYear   = -1;
713: static icu::UInitOnce  islamcal_gSystemDefaultCenturyInit        = U_INITONCE_INITIALIZER;
714: 
715: 
716: UBool IslamicCalendar::haveDefaultCentury() const
717: {
718:     return TRUE;
719: }
720: 
721: UDate IslamicCalendar::defaultCenturyStart() const
722: {
723:     // lazy-evaluate systemDefaultCenturyStart
724:     umtx_initOnce(islamcal_gSystemDefaultCenturyInit, &initializeSystemDefaultCentury);
725:     return islamcal_gSystemDefaultCenturyStart;
726: }
727: 
728: int32_t IslamicCalendar::defaultCenturyStartYear() const
729: {
730:     // lazy-evaluate systemDefaultCenturyStartYear
731:     umtx_initOnce(islamcal_gSystemDefaultCenturyInit, &initializeSystemDefaultCentury);
732:     return islamcal_gSystemDefaultCenturyStartYear;
733: }
734: 
735: 
736: U_CFUNC void U_CALLCONV
737: IslamicCalendar::initializeSystemDefaultCentury()
738: {
739:     // initialize systemDefaultCentury and systemDefaultCenturyYear based
740:     // on the current time.  They'll be set to 80 years before
741:     // the current time.
742:     UErrorCode status = U_ZERO_ERROR;
743:     IslamicCalendar calendar(Locale("@calendar=islamic-civil"),status);
744:     if (U_SUCCESS(status)) {
745:         calendar.setTime(Calendar::getNow(), status);
746:         calendar.add(UCAL_YEAR, -80, status);
747: 
748:         islamcal_gSystemDefaultCenturyStart = calendar.getTime(status);
749:         islamcal_gSystemDefaultCenturyStartYear = calendar.get(UCAL_YEAR, status);
750:     }
751:     // We have no recourse upon failure unless we want to propagate the failure
752:     // out.
753: }
754: 
755: 
756: 
757: UOBJECT_DEFINE_RTTI_IMPLEMENTATION(IslamicCalendar)
758: 
759: U_NAMESPACE_END
760: 
761: #endif
762: 
[end of extension/icu/third_party/icu/i18n/islamcal.cpp]
[start of scripts/format.py]
1: #!/usr/bin/python
2: 
3: # this script is used to format the source directory
4: 
5: import os
6: import time
7: import sys
8: import inspect
9: import subprocess
10: import difflib
11: import re
12: from python_helpers import open_utf8
13: 
14: cpp_format_command = 'clang-format --sort-includes=0 -style=file'
15: cmake_format_command = 'cmake-format'
16: extensions = ['.cpp', '.c', '.hpp', '.h', '.cc', '.hh', 'CMakeLists.txt', '.test', '.test_slow', '.test_coverage', '.benchmark']
17: formatted_directories = ['src', 'benchmark', 'test', 'tools', 'examples', 'extension']
18: ignored_files = ['tpch_constants.hpp', 'tpcds_constants.hpp', '_generated', 'tpce_flat_input.hpp',
19:                  'test_csv_header.hpp', 'duckdb.cpp', 'duckdb.hpp', 'json.hpp', 'sqlite3.h', 'shell.c',
20:                  'termcolor.hpp', 'test_insert_invalid.test', 'httplib.hpp', 'os_win.c', 'glob.c', 'printf.c',
21:                  'helper.hpp', 'single_thread_ptr.hpp', 'types.hpp', 'default_views.cpp', 'default_functions.cpp',
22:                  'release.h', 'genrand.cpp', 'address.cpp', 'visualizer_constants.hpp', 'icu-collate.cpp', 'icu-collate.hpp',
23:                  'yyjson.cpp', 'yyjson.hpp', 'duckdb_pdqsort.hpp', 'stubdata.cpp',
24:                  'nf_calendar.cpp', 'nf_calendar.h', 'nf_localedata.cpp', 'nf_localedata.h', 'nf_zformat.cpp', 'nf_zformat.h', 'expr.cc']
25: ignored_directories = ['.eggs', '__pycache__', 'icu', 'dbgen', os.path.join('tools', 'pythonpkg', 'duckdb'),
26:                        os.path.join('tools', 'pythonpkg', 'build'), os.path.join('tools', 'rpkg', 'src', 'duckdb'),
27:                        os.path.join('tools', 'rpkg', 'inst', 'include', 'cpp11'),
28:                        os.path.join('extension', 'tpcds', 'dsdgen'), os.path.join('extension', 'jemalloc', 'jemalloc'),
29:                        os.path.join('extension', 'json', 'yyjson')]
30: format_all = False
31: check_only = True
32: confirm = True
33: silent = False
34: 
35: def print_usage():
36:     print("Usage: python scripts/format.py [revision|--all] [--check|--fix]")
37:     print("   [revision]     is an optional revision number, all files that changed since that revision will be formatted (default=HEAD)")
38:     print(
39:         "                  if [revision] is set to --all, all files will be formatted")
40:     print("   --check only prints differences, --fix also fixes the files (--check is default)")
41:     exit(1)
42: 
43: 
44: if len(sys.argv) == 1:
45:     revision = "HEAD"
46: elif len(sys.argv) >= 2:
47:     revision = sys.argv[1]
48: else:
49:     print_usage()
50: 
51: if len(sys.argv) > 2:
52:     for arg in sys.argv[2:]:
53:         if arg == '--check':
54:             check_only = True
55:         elif arg == '--fix':
56:             check_only = False
57:         elif arg == '--noconfirm':
58:             confirm = False
59:         elif arg == '--confirm':
60:             confirm = True
61:         elif arg == '--silent':
62:             silent = True
63:         else:
64:             print_usage()
65: 
66: if revision == '--all':
67:     format_all = True
68: 
69: def can_format_file(full_path):
70:     global extensions, formatted_directories, ignored_files
71:     if not os.path.isfile(full_path):
72:         return False
73:     fname = full_path.split(os.path.sep)[-1]
74:     # check ignored files
75:     if fname in ignored_files:
76:         return False
77:     # check ignored directories
78:     dirnames = full_path.split(os.path.sep)[:-1]
79:     for i in range(1, len(dirnames)):
80:         if os.path.join(*dirnames[:i]) in ignored_directories:
81:             return False
82:     found = False
83:     # check file extension
84:     for ext in extensions:
85:         if full_path.endswith(ext):
86:             found = True
87:             break
88:     if not found:
89:         return False
90:     # now check file directory
91:     for dname in formatted_directories:
92:         if full_path.startswith(dname):
93:             return True
94:     return False
95: 
96: 
97: action = "Formatting"
98: if check_only:
99:     action = "Checking"
100: 
101: def get_changed_files(revision):
102:     proc = subprocess.Popen(
103:         ['git', 'diff', '--name-only', revision], stdout=subprocess.PIPE)
104:     files = proc.stdout.read().decode('utf8').split('\n')
105:     changed_files = []
106:     for f in files:
107:         if not can_format_file(f):
108:             continue
109:         if os.path.basename(f) in ignored_files:
110:             continue
111:         if f.split(os.sep)[0] in ignored_directories:
112:             continue
113:         changed_files.append(f)
114:     return changed_files
115: 
116: if os.path.isfile(revision):
117:     print(action + " individual file: " + revision)
118:     changed_files = [revision]
119: elif os.path.isdir(revision):
120:     print(action + " files in directory: " + revision)
121:     changed_files = [os.path.join(revision, x) for x in os.listdir(revision)]
122: 
123:     print("Changeset:")
124:     for fname in changed_files:
125:         print(fname)
126: elif not format_all:
127:     if revision == 'master':
128:         # fetch new changes when comparing to the master
129:         os.system("git fetch origin master:master")
130:     print(action + " since branch or revision: " + revision)
131:     changed_files = get_changed_files(revision)
132:     if len(changed_files) == 0:
133:         print("No changed files found!")
134:         exit(0)
135: 
136:     print("Changeset:")
137:     for fname in changed_files:
138:         print(fname)
139: else:
140:     print(action + " all files")
141: 
142: if confirm and not check_only:
143:     print("The files listed above will be reformatted.")
144:     result = input("Continue with changes (y/n)?\n")
145:     if result != 'y':
146:         print("Aborting.")
147:         exit(0)
148: 
149: format_commands = {
150:     '.cpp': cpp_format_command,
151:     '.c': cpp_format_command,
152:     '.hpp': cpp_format_command,
153:     '.h': cpp_format_command,
154:     '.hh': cpp_format_command,
155:     '.cc': cpp_format_command,
156:     '.txt': cmake_format_command
157: }
158: 
159: difference_files = []
160: 
161: header_top = "//===----------------------------------------------------------------------===//\n"
162: header_top += "//                         DuckDB\n" + "//\n"
163: header_bottom = "//\n" + "//\n"
164: header_bottom += "//===----------------------------------------------------------------------===//\n\n"
165: base_dir = os.path.join(os.getcwd(), 'src/include')
166: 
167: def get_formatted_text(f, full_path, directory, ext):
168:     if not can_format_file(full_path):
169:         print("Eek, cannot format file " + full_path + " but attempted to format anyway")
170:         exit(1)
171:     if f == 'list.hpp':
172:         # fill in list file
173:         file_list = [os.path.join(dp, f) for dp, dn, filenames in os.walk(
174:             directory) for f in filenames if os.path.splitext(f)[1] == '.hpp' and not f.endswith("list.hpp")]
175:         file_list = [x.replace('src/include/', '') for x in file_list]
176:         file_list.sort()
177:         result = ""
178:         for x in file_list:
179:             result += '#include "%s"\n' % (x)
180:         return result
181: 
182:     if ext == ".hpp" and directory.startswith("src/include"):
183:         with open_utf8(full_path, 'r') as f:
184:             lines = f.readlines()
185: 
186:         # format header in files
187:         header_middle = "// " + os.path.relpath(full_path, base_dir) + "\n"
188:         text = header_top + header_middle + header_bottom
189:         is_old_header = True
190:         for line in lines:
191:             if not (line.startswith("//") or line.startswith("\n")) and is_old_header:
192:                 is_old_header = False
193:             if not is_old_header:
194:                 text += line
195: 
196:     if ext == '.test' or ext == '.test_slow' or ext == '.test_coverage' or ext == '.benchmark':
197:         f = open_utf8(full_path, 'r')
198:         lines = f.readlines()
199:         f.close()
200: 
201:         found_name = False
202:         found_group = False
203:         group_name = full_path.split('/')[-2]
204:         new_path_line = '# name: ' + full_path + '\n'
205:         new_group_line =  '# group: [' + group_name + ']' + '\n'
206:         found_diff = False
207:         # Find description.
208:         found_description = False
209:         for line in lines:
210:             if line.lower().startswith('# description:') or line.lower().startswith('#description:'):
211:                 if found_description:
212:                     print("Error formatting file " + full_path + ", multiple lines starting with # description found")
213:                     exit(1)
214:                 found_description = True
215:                 new_description_line = '# description: ' + line.split(':', 1)[1].strip() + '\n'
216:         # Filter old meta.
217:         meta = ['#name:', '# name:', '#description:', '# description:', '#group:', '# group:']
218:         lines = [line for line in lines if not any(line.lower().startswith(m) for m in meta)]
219:         # Clean up empty leading lines.
220:         while lines and not lines[0].strip():
221:             lines.pop(0)
222:         # Ensure header is prepended.
223:         header = [new_path_line]
224:         if found_description: header.append(new_description_line)
225:         header.append(new_group_line)
226:         header.append('\n')
227:         return ''.join(header + lines)
228:     proc_command = format_commands[ext].split(' ') + [full_path]
229:     proc = subprocess.Popen(proc_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
230:     new_text = proc.stdout.read().decode('utf8')
231:     stderr = proc.stderr.read().decode('utf8')
232:     if len(stderr) > 0:
233:         print(os.getcwd())
234:         print("Failed to format file " + full_path)
235:         print(' '.join(proc_command))
236:         print(stderr)
237:         exit(1)
238:     new_text = new_text.replace('\r', '')
239:     new_text = re.sub(r'\n*$', '', new_text)
240:     return new_text + '\n'
241: 
242: def format_file(f, full_path, directory, ext):
243:     global difference_files
244:     with open_utf8(full_path, 'r') as f:
245:         old_text = f.read()
246:     old_lines = old_text.split('\n')
247: 
248:     new_text = get_formatted_text(f, full_path, directory, ext)
249:     if check_only:
250:         new_lines = new_text.split('\n')
251:         old_lines = [x for x in old_lines if '...' not in x]
252:         new_lines = [x for x in new_lines if '...' not in x]
253:         diff_result = difflib.unified_diff(old_lines, new_lines)
254:         total_diff = ""
255:         for diff_line in diff_result:
256:             total_diff += diff_line + "\n"
257:         total_diff = total_diff.strip()
258: 
259:         if len(total_diff) > 0:
260:             print("----------------------------------------")
261:             print("----------------------------------------")
262:             print("Found differences in file " + full_path)
263:             print("----------------------------------------")
264:             print("----------------------------------------")
265:             print(total_diff)
266:             difference_files.append(full_path)
267:     else:
268:         tmpfile = full_path + ".tmp"
269:         with open_utf8(tmpfile, 'w+') as f:
270:             f.write(new_text)
271:         os.rename(tmpfile, full_path)
272: 
273: 
274: def format_directory(directory):
275:     files = os.listdir(directory)
276:     files.sort()
277:     for f in files:
278:         full_path = os.path.join(directory, f)
279:         if os.path.isdir(full_path):
280:             if f in ignored_directories or full_path in ignored_directories:
281:                 continue
282:             if not silent:
283:                 print(full_path)
284:             format_directory(full_path)
285:         elif can_format_file(full_path):
286:             format_file(f, full_path, directory, '.' +
287:                         f.split('.')[-1])
288: 
289: 
290: if format_all:
291:     try:
292:         os.system(cmake_format_command.replace("${FILE}", "CMakeLists.txt"))
293:     except:
294:         pass
295:     format_directory('src')
296:     format_directory('benchmark')
297:     format_directory('test')
298:     format_directory('tools')
299:     format_directory('examples')
300:     format_directory('extension')
301: 
302: else:
303:     for full_path in changed_files:
304:         splits = full_path.split(os.path.sep)
305:         fname = splits[-1]
306:         dirname = os.path.sep.join(splits[:-1])
307:         ext = '.' + full_path.split('.')[-1]
308:         format_file(fname, full_path, dirname, ext)
309: 
310: if check_only:
311:     if len(difference_files) > 0:
312:         print("")
313:         print("")
314:         print("")
315:         print("Failed format-check: differences were found in the following files:")
316:         for fname in difference_files:
317:             print("- " + fname)
318:         print('Run "make format-fix" to fix these differences automatically')
319:         exit(1)
320:     else:
321:         print("Passed format-check")
322:         exit(0)
[end of scripts/format.py]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: