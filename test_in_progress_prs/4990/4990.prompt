You will be provided with a partial code base and an issue statement explaining a problem to resolve.
In your output, give nothing but the code (no markdown) so that your output can be copy pasted and run immediately with no changes.
In the patch file, please make sure to include the line numbers and a blank line at the end so it can be applied using git apply.

<issue>
JDBC - rss and threads not being released
Hello,

It looks like there is an issue somewhere in the JDBC driver where the resident memory and thread count of the process just continues to rise.  I am able to reproduce this using this simple loop:

```
for (int i = 0; i < 500; i++) {
    Connection conn = DriverManager.getConnection("jdbc:duckdb:test-database.db");
    conn.close();
}
```

It gets significantly worse if I also grab a result set (I am testing with a fairly large database) and am able to spike the rss usage quite high with just a handful of iterations.

From what I've noticed, the thread count of the process - at least according to osx - doesn't decrease, and the rss continues to rise, until I trigger a manual java garbage collection.

The java heap never gets particularly large... even with an rss of ~3gb, the heap is reported to only be 35mb... which might explain why the GC isn't kicking in. :)

I've tried the latest master build, since I know there was recently a "connection closing" jdbc issue fixed.

</issue>
<code>
[start of README.md]
1: <div align="center">
2:   <img src="https://duckdb.org/images/DuckDB_Logo_dl.png" height="50">
3: </div>
4: <p>&nbsp;</p>
5: 
6: <p align="center">
7:   <a href="https://github.com/duckdb/duckdb/actions">
8:     <img src="https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=master" alt="Github Actions Badge">
9:   </a>
10:   <a href="https://www.codefactor.io/repository/github/cwida/duckdb">
11:     <img src="https://www.codefactor.io/repository/github/cwida/duckdb/badge" alt="CodeFactor"/>
12:   </a>
13:   <a href="https://app.codecov.io/gh/duckdb/duckdb">
14:     <img src="https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN" alt="codecov"/>
15:   </a>
16:   <a href="https://discord.gg/tcvwpjfnZx">
17:     <img src="https://shields.io/discord/909674491309850675" alt="discord" />
18:   </a>
19: </p>
20: 
21: ## DuckDB
22: DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to [the Why DuckDB page on our website](https://duckdb.org/why_duckdb).
23: 
24: ## Installation
25: If you want to install and use DuckDB, please see [our website](https://www.duckdb.org) for installation and usage instructions.
26: 
27: ## Data Import
28: For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:
29: 
30: ```sql
31: SELECT * FROM 'myfile.csv';
32: SELECT * FROM 'myfile.parquet';
33: ```
34: 
35: Refer to our [Data Import](https://duckdb.org/docs/data/overview) section for more information.
36: 
37: ## SQL Reference
38: The [website](https://duckdb.org/docs/sql/introduction) contains a reference of functions and SQL constructs available in DuckDB.
39: 
40: ## Development
41: For development, DuckDB requires [CMake](https://cmake.org), Python3 and a `C++11` compliant compiler. Run `make` in the root directory to compile the sources. For development, use `make debug` to build a non-optimized debug version. You should run `make unit` and `make allunit` to verify that your version works properly after making changes. To test performance, you can run `BUILD_BENCHMARK=1 BUILD_TPCH=1 make` and then perform several standard benchmarks from the root directory by executing `./build/release/benchmark/benchmark_runner`. The detail of benchmarks is in our [Benchmark Guide](benchmark/README.md).
42: 
43: Please also refer to our [Contribution Guide](CONTRIBUTING.md).
[end of README.md]
[start of tools/jdbc/src/main/java/org/duckdb/DuckDBConnection.java]
1: package org.duckdb;
2: 
3: import java.nio.ByteBuffer;
4: import java.sql.Array;
5: import java.sql.Blob;
6: import java.sql.CallableStatement;
7: import java.sql.Clob;
8: import java.sql.Connection;
9: import java.sql.DatabaseMetaData;
10: import java.sql.NClob;
11: import java.sql.PreparedStatement;
12: import java.sql.ResultSet;
13: import java.sql.SQLClientInfoException;
14: import java.sql.SQLException;
15: import java.sql.SQLFeatureNotSupportedException;
16: import java.sql.SQLWarning;
17: import java.sql.SQLXML;
18: import java.sql.Savepoint;
19: import java.sql.Statement;
20: import java.sql.Struct;
21: import java.util.Map;
22: import java.util.Properties;
23: import java.util.concurrent.Executor;
24: 
25: public class DuckDBConnection implements java.sql.Connection {
26: 	protected ByteBuffer conn_ref = null;
27: 	protected DuckDBDatabase db;
28: 	protected boolean autoCommit = true;
29: 	protected boolean transactionRunning = false;
30: 
31: 	public DuckDBConnection(DuckDBDatabase db) throws SQLException {
32: 		if (db.db_ref == null) {
33: 			throw new SQLException("Database was shutdown");
34: 		}
35: 		conn_ref = DuckDBNative.duckdb_jdbc_connect(db.db_ref);
36: 		DuckDBNative.duckdb_jdbc_set_auto_commit(conn_ref, true);
37: 		this.db = db;
38: 	}
39: 
40: 	public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability)
41: 			throws SQLException {
42: 		if (isClosed()) {
43: 			throw new SQLException("Connection was closed");
44: 		}
45: 		if (resultSetConcurrency == ResultSet.CONCUR_READ_ONLY && resultSetType == ResultSet.TYPE_FORWARD_ONLY) {
46: 			return new DuckDBPreparedStatement(this);
47: 		}
48: 		throw new SQLFeatureNotSupportedException();
49: 	}
50: 
51: 	public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency,
52: 			int resultSetHoldability) throws SQLException {
53: 		if (isClosed()) {
54: 			throw new SQLException("Connection was closed");
55: 		}
56: 		if (resultSetConcurrency == ResultSet.CONCUR_READ_ONLY && resultSetType == ResultSet.TYPE_FORWARD_ONLY) {
57: 			return new DuckDBPreparedStatement(this, sql);
58: 		}
59: 		throw new SQLFeatureNotSupportedException();
60: 	}
61: 
62: 	public Statement createStatement() throws SQLException {
63: 		return createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
64: 	}
65: 
66: 	public Connection duplicate() throws SQLException {
67: 		if (db == null) {
68: 			throw new SQLException("Connection was closed");
69: 		}
70: 		if (db.db_ref == null) {
71: 			throw new SQLException("Database was shutdown");
72: 		}
73: 		return new DuckDBConnection(db);
74: 	}
75: 
76: 	public DuckDBDatabase getDatabase() {
77: 		return db;
78: 	}
79: 
80: 	public void commit() throws SQLException {
81: 		Statement s = createStatement();
82: 		s.execute("COMMIT");
83: 		transactionRunning = false;
84: 		s.close();
85: 	}
86: 
87: 	public void rollback() throws SQLException {
88: 		Statement s = createStatement();
89: 		s.execute("ROLLBACK");
90: 		transactionRunning = false;
91: 		s.close();
92: 	}
93: 
94: 	protected void finalize() throws Throwable {
95: 		close();
96: 	}
97: 
98: 	public synchronized void close() throws SQLException {
99: 		if (conn_ref != null) {
100: 			DuckDBNative.duckdb_jdbc_disconnect(conn_ref);
101: 			conn_ref = null;
102: 		}
103: 		db = null;
104: 	}
105: 
106: 	public boolean isClosed() throws SQLException {
107: 		return conn_ref == null;
108: 	}
109: 
110: 	public boolean isValid(int timeout) throws SQLException {
111: 		if (isClosed()) {
112: 			return false;
113: 		}
114: 		// run a query just to be sure
115: 		Statement s = createStatement();
116: 		ResultSet rs = s.executeQuery("SELECT 42");
117: 		if (!rs.next() || rs.getInt(1) != 42) {
118: 			rs.close();
119: 			s.close();
120: 			return false;
121: 		}
122: 		rs.close();
123: 		s.close();
124: 
125: 		return true;
126: 	}
127: 
128: 	public SQLWarning getWarnings() throws SQLException {
129: 		return null;
130: 	}
131: 
132: 	public void clearWarnings() throws SQLException {
133: 	}
134: 
135: 	public void setTransactionIsolation(int level) throws SQLException {
136: 		if (level > TRANSACTION_REPEATABLE_READ) {
137: 			throw new SQLFeatureNotSupportedException();
138: 		}
139: 	}
140: 
141: 	public int getTransactionIsolation() throws SQLException {
142: 		return TRANSACTION_REPEATABLE_READ;
143: 	}
144: 
145: 	public void setReadOnly(boolean readOnly) throws SQLException {
146: 		if (readOnly != db.read_only) {
147: 			throw new SQLFeatureNotSupportedException("Can't change read-only status on connection level.");
148: 		}
149: 	}
150: 
151: 	public boolean isReadOnly() throws SQLException {
152: 		return db.read_only;
153: 	}
154: 
155: 	public void setAutoCommit(boolean autoCommit) throws SQLException {
156: 		if (isClosed()) {
157: 			throw new SQLException("Connection was closed");
158: 		}
159: 
160: 		if (this.autoCommit != autoCommit) {
161: 			this.autoCommit = autoCommit;
162: 
163: 			// A running transaction is committed if switched to auto-commit
164: 			if (transactionRunning && autoCommit) {
165: 				this.commit();
166: 			}
167: 		}
168: 		return;
169: 
170: 		// Native method is not working as one would expect ... uncomment maybe later
171: 		// DuckDBNative.duckdb_jdbc_set_auto_commit(conn_ref, autoCommit);
172: 	}
173: 
174: 	public boolean getAutoCommit() throws SQLException {
175: 		if (isClosed()) {
176: 			throw new SQLException("Connection was closed");
177: 		}
178: 		return this.autoCommit;
179: 
180: 		// Native method is not working as one would expect ... uncomment maybe later
181: 		// return DuckDBNative.duckdb_jdbc_get_auto_commit(conn_ref);
182: 	}
183: 
184: 	public PreparedStatement prepareStatement(String sql) throws SQLException {
185: 		return prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, 0);
186: 	}
187: 
188: 	public DatabaseMetaData getMetaData() throws SQLException {
189: 		return new DuckDBDatabaseMetaData(this);
190: 	}
191: 
192: 	public void setCatalog(String catalog) throws SQLException {
193: 		// not supported => no-op
194: 	}
195: 
196: 	public String getCatalog() throws SQLException {
197: 		return null;
198: 	}
199: 
200: 	public void setSchema(String schema) throws SQLException {
201: 		throw new SQLFeatureNotSupportedException();
202: 	}
203: 
204: 	public String getSchema() throws SQLException {
205: 		return DuckDBNative.duckdb_jdbc_get_schema(conn_ref);
206: 	}
207: 
208: 	public void abort(Executor executor) throws SQLException {
209: 		throw new SQLFeatureNotSupportedException();
210: 	}
211: 
212: 	public Clob createClob() throws SQLException {
213: 		throw new SQLFeatureNotSupportedException();
214: 	}
215: 
216: 	public Blob createBlob() throws SQLException {
217: 		throw new SQLFeatureNotSupportedException();
218: 	}
219: 
220: 	// less likely to implement this stuff
221: 
222: 	public <T> T unwrap(Class<T> iface) throws SQLException {
223: 		throw new SQLFeatureNotSupportedException();
224: 	}
225: 
226: 	public boolean isWrapperFor(Class<?> iface) throws SQLException {
227: 		throw new SQLFeatureNotSupportedException();
228: 	}
229: 
230: 	public CallableStatement prepareCall(String sql) throws SQLException {
231: 		throw new SQLFeatureNotSupportedException();
232: 	}
233: 
234: 	public String nativeSQL(String sql) throws SQLException {
235: 		throw new SQLFeatureNotSupportedException();
236: 	}
237: 
238: 	public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
239: 		return createStatement(resultSetType, resultSetConcurrency, 0);
240: 	}
241: 
242: 	public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency)
243: 			throws SQLException {
244: 		return prepareStatement(sql, resultSetType, resultSetConcurrency, 0);
245: 	}
246: 
247: 	public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
248: 		throw new SQLFeatureNotSupportedException();
249: 	}
250: 
251: 	public Map<String, Class<?>> getTypeMap() throws SQLException {
252: 		throw new SQLFeatureNotSupportedException();
253: 	}
254: 
255: 	public void setTypeMap(Map<String, Class<?>> map) throws SQLException {
256: 		throw new SQLFeatureNotSupportedException();
257: 	}
258: 
259: 	public void setHoldability(int holdability) throws SQLException {
260: 		throw new SQLFeatureNotSupportedException();
261: 	}
262: 
263: 	public int getHoldability() throws SQLException {
264: 		throw new SQLFeatureNotSupportedException();
265: 	}
266: 
267: 	public Savepoint setSavepoint() throws SQLException {
268: 		throw new SQLFeatureNotSupportedException();
269: 	}
270: 
271: 	public Savepoint setSavepoint(String name) throws SQLException {
272: 		throw new SQLFeatureNotSupportedException();
273: 	}
274: 
275: 	public void rollback(Savepoint savepoint) throws SQLException {
276: 		throw new SQLFeatureNotSupportedException();
277: 	}
278: 
279: 	public void releaseSavepoint(Savepoint savepoint) throws SQLException {
280: 		throw new SQLFeatureNotSupportedException();
281: 	}
282: 
283: 	public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency,
284: 			int resultSetHoldability) throws SQLException {
285: 		throw new SQLFeatureNotSupportedException();
286: 	}
287: 
288: 	public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
289: 		throw new SQLFeatureNotSupportedException();
290: 	}
291: 
292: 	public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
293: 		throw new SQLFeatureNotSupportedException();
294: 	}
295: 
296: 	public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
297: 		throw new SQLFeatureNotSupportedException();
298: 	}
299: 
300: 	public NClob createNClob() throws SQLException {
301: 		throw new SQLFeatureNotSupportedException();
302: 	}
303: 
304: 	public SQLXML createSQLXML() throws SQLException {
305: 		throw new SQLFeatureNotSupportedException(); // hell no
306: 	}
307: 
308: 	public void setClientInfo(String name, String value) throws SQLClientInfoException {
309: 		throw new SQLClientInfoException();
310: 	}
311: 
312: 	public void setClientInfo(Properties properties) throws SQLClientInfoException {
313: 		throw new SQLClientInfoException();
314: 	}
315: 
316: 	public String getClientInfo(String name) throws SQLException {
317: 		throw new SQLFeatureNotSupportedException();
318: 	}
319: 
320: 	public Properties getClientInfo() throws SQLException {
321: 		throw new SQLFeatureNotSupportedException();
322: 	}
323: 
324: 	public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
325: 		throw new SQLFeatureNotSupportedException();
326: 	}
327: 
328: 	public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
329: 		throw new SQLFeatureNotSupportedException();
330: 	}
331: 
332: 	public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {
333: 		throw new SQLFeatureNotSupportedException();
334: 	}
335: 
336: 	public int getNetworkTimeout() throws SQLException {
337: 		throw new SQLFeatureNotSupportedException();
338: 	}
339: 
340: 	public DuckDBAppender createAppender(String schemaName, String tableName) throws SQLException {
341: 		return new DuckDBAppender(this, schemaName, tableName);
342: 	}
343: }
[end of tools/jdbc/src/main/java/org/duckdb/DuckDBConnection.java]
[start of tools/jdbc/src/main/java/org/duckdb/DuckDBDatabase.java]
1: package org.duckdb;
2: 
3: import java.nio.ByteBuffer;
4: import java.nio.charset.StandardCharsets;
5: import java.sql.SQLException;
6: import java.util.Properties;
7: 
8: public class DuckDBDatabase {
9: 
10: 	protected String url;
11: 	protected boolean read_only;
12: 
13: 	public DuckDBDatabase(String url, boolean read_only, Properties props) throws SQLException {
14: 		if (!url.startsWith("jdbc:duckdb")) {
15: 			throw new SQLException("DuckDB JDBC URL needs to start with 'jdbc:duckdb:'");
16: 		}
17: 		this.url = url;
18: 		String db_dir = url.replaceFirst("^jdbc:duckdb:", "").trim();
19: 		if (db_dir.length() == 0) {
20: 			db_dir = ":memory:";
21: 		}
22: 		this.read_only = read_only;
23: 		db_ref = DuckDBNative.duckdb_jdbc_startup(db_dir.getBytes(StandardCharsets.UTF_8), read_only, props);
24: 	}
25: 
26: 	public void shutdown() {
27: 		try {
28: 			finalize();
29: 		} catch (Throwable e) {
30: 		}
31: 	}
32: 
33: 	protected synchronized void finalize() throws Throwable {
34: 		if (db_ref != null) {
35: 			DuckDBNative.duckdb_jdbc_shutdown(db_ref);
36: 			db_ref = null;
37: 		}
38: 	}
39: 
40: 	protected ByteBuffer db_ref;
41: 
42: }
[end of tools/jdbc/src/main/java/org/duckdb/DuckDBDatabase.java]
</code>
Here is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.
<patch>
--- a/file.cpp
+++ b/file.cpp
@@ -3,35 +3,44 @@
 #include <cstdlib>
 
 int euclidean(int a, int b) {
-    while (b) {
-        int temp = b;
-        b = a % b;
-        a = temp;
+    if (b == 0) {
+        return a;
     }
-    return a;
+    return euclidean(b, a % b);
 }
 
 std::vector<std::pair<int, int>> bresenham(int x0, int y0, int x1, int y1) {
     std::vector<std::pair<int, int>> points;
     int dx = abs(x1 - x0);
     int dy = abs(y1 - y0);
+    int x = x0, y = y0;
     int sx = (x0 < x1) ? 1 : -1;
     int sy = (y0 < y1) ? 1 : -1;
-    int err = dx - dy;
 
-    while (true) {
-        points.emplace_back(x0, y0);
-        if (x0 == x1 && y0 == y1) break;
-        int e2 = 2 * err;
-        if (e2 > -dy) {
+    if (dx > dy) {
+        int err = dx / 2;
+        while (x != x1) {
+            points.emplace_back(x, y);
             err -= dy;
-            x0 += sx;
+            if (err < 0) {
+                y += sy;
+                err += dx;
+            }
+            x += sx;
         }
-        if (e2 < dx) {
-            err += dx;
-            y0 += sy;
+    } else {
+        int err = dy / 2;
+        while (y != y1) {
+            points.emplace_back(x, y);
+            err -= dx;
+            if (err < 0) {
+                x += sx;
+                err += dy;
+            }
+            y += sy;
         }
     }
 
+    points.emplace_back(x, y);
     return points;
 }

</patch>

I need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply.
Please respond with a single patch file in the format shown above.
Make sure to only include the patch file contents so that the contents of your output can be copied into a patch file and applied directly

Respond below: