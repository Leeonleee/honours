diff --git a/.github/workflows/Main.yml b/.github/workflows/Main.yml
index f3df7b291758..86c5bd7d5acd 100644
--- a/.github/workflows/Main.yml
+++ b/.github/workflows/Main.yml
@@ -147,6 +147,47 @@ jobs:
       shell: bash
       run: build/reldebug/test/unittest "*" --force-reload --force-storage
 
+ no-string-inline:
+    name: No String Inline
+    runs-on: ubuntu-20.04
+    needs: linux-debug
+    env:
+      CC: gcc-10
+      CXX: g++-10
+      GEN: ninja
+      BUILD_ICU: 1
+      BUILD_INET: 1
+      BUILD_PARQUET: 1
+      BUILD_TPCH: 1
+      BUILD_TPCDS: 1
+      BUILD_FTS: 1
+      BUILD_VISUALIZER: 1
+      BUILD_JSON: 1
+      BUILD_EXCEL: 1
+      DISABLE_STRING_INLINE: 1
+
+    steps:
+    - uses: actions/checkout@v3
+      with:
+        fetch-depth: 0
+
+    - name: Install
+      shell: bash
+      run: sudo apt-get update -y -qq && sudo apt-get install -y -qq ninja-build
+
+    - name: Setup Ccache
+      uses: hendrikmuhs/ccache-action@main
+      with:
+        key: ${{ github.job }}
+
+    - name: Build
+      shell: bash
+      run: make debug
+
+    - name: Test
+      shell: bash
+      run: build/debug/test/unittest
+
  linux-arrow:
       name: Linux Debug (Arrow Tests)
       runs-on: ubuntu-20.04
diff --git a/CMakeLists.txt b/CMakeLists.txt
index dd60167f0313..2355f5ccf55c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -268,6 +268,7 @@ option(USER_SPACE "Build the DuckDB Python in the user space" FALSE)
 option(FORCE_QUERY_LOG "If enabled, all queries will be logged to the specified path" OFF)
 option(BUILD_SHELL "Build the DuckDB Shell and SQLite API Wrappers" TRUE)
 option(DISABLE_THREADS "Disable support for multi-threading" FALSE)
+option(DISABLE_STR_INLINE "Debug setting: disable inlining of strings" FALSE)
 option(CLANG_TIDY "Enable build for clang-tidy, this disables all source files excluding the core database. This does not produce a working build." FALSE)
 option(BUILD_UNITTESTS "Build the C++ Unit Tests." TRUE)
 option(
@@ -325,6 +326,10 @@ else()
   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DDUCKDB_CRASH_ON_ASSERT")
 endif()
 
+if(DISABLE_STR_INLINE)
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DDUCKDB_DEBUG_NO_INLINE")
+endif()
+
 if(FORCE_ASSERT)
   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DDUCKDB_FORCE_ASSERT")
 endif()
diff --git a/Makefile b/Makefile
index 45b3698f974e..c0845dc17a96 100644
--- a/Makefile
+++ b/Makefile
@@ -141,6 +141,9 @@ endif
 ifeq (${CRASH_ON_ASSERT}, 1)
 	EXTENSIONS:=${EXTENSIONS} -DASSERT_EXCEPTION=0
 endif
+ifeq (${DISABLE_STRING_INLINE}, 1)
+	EXTENSIONS:=${EXTENSIONS} -DDISABLE_STR_INLINE=1
+endif
 
 clean:
 	rm -rf build
diff --git a/src/common/row_operations/row_external.cpp b/src/common/row_operations/row_external.cpp
index fb6aa99ffd8d..b118572c5b08 100644
--- a/src/common/row_operations/row_external.cpp
+++ b/src/common/row_operations/row_external.cpp
@@ -33,7 +33,7 @@ void RowOperations::SwizzleColumns(const RowLayout &layout, const data_ptr_t bas
 			}
 			data_ptr_t col_ptr = row_ptr + layout.GetOffsets()[col_idx];
 			if (physical_type == PhysicalType::VARCHAR) {
-				data_ptr_t string_ptr = col_ptr + sizeof(uint32_t) + string_t::PREFIX_LENGTH;
+				data_ptr_t string_ptr = col_ptr + string_t::HEADER_SIZE;
 				for (idx_t i = 0; i < next; i++) {
 					if (Load<uint32_t>(col_ptr) > string_t::INLINE_LENGTH) {
 						// Overwrite the string pointer with the within-row offset (if not inlined)
@@ -137,7 +137,7 @@ void RowOperations::UnswizzlePointers(const RowLayout &layout, const data_ptr_t
 			}
 			data_ptr_t col_ptr = row_ptr + layout.GetOffsets()[col_idx];
 			if (physical_type == PhysicalType::VARCHAR) {
-				data_ptr_t string_ptr = col_ptr + sizeof(uint32_t) + string_t::PREFIX_LENGTH;
+				data_ptr_t string_ptr = col_ptr + string_t::HEADER_SIZE;
 				for (idx_t i = 0; i < next; i++) {
 					if (Load<uint32_t>(col_ptr) > string_t::INLINE_LENGTH) {
 						// Overwrite the string offset with the pointer (if not inlined)
diff --git a/src/common/row_operations/row_gather.cpp b/src/common/row_operations/row_gather.cpp
index c7f155343110..010eda3ce8af 100644
--- a/src/common/row_operations/row_gather.cpp
+++ b/src/common/row_operations/row_gather.cpp
@@ -76,7 +76,7 @@ static void GatherVarchar(Vector &rows, const SelectionVector &row_sel, Vector &
 			//	Not inline, so unswizzle the copied pointer the pointer
 			auto heap_ptr_ptr = row + heap_offset;
 			auto heap_row_ptr = base_heap_ptr + Load<idx_t>(heap_ptr_ptr);
-			auto string_ptr = data_ptr_t(data + col_idx) + sizeof(uint32_t) + string_t::PREFIX_LENGTH;
+			auto string_ptr = data_ptr_t(data + col_idx) + string_t::HEADER_SIZE;
 			Store<data_ptr_t>(heap_row_ptr + Load<idx_t>(string_ptr), string_ptr);
 #ifdef DEBUG
 			data[col_idx].Verify();
diff --git a/src/common/sort/comparators.cpp b/src/common/sort/comparators.cpp
index 90e0fbfcc8e4..3ea4b91ed6fd 100644
--- a/src/common/sort/comparators.cpp
+++ b/src/common/sort/comparators.cpp
@@ -349,14 +349,14 @@ int Comparators::TemplatedCompareListLoop(data_ptr_t &left_ptr, data_ptr_t &righ
 
 void Comparators::UnswizzleSingleValue(data_ptr_t data_ptr, const data_ptr_t &heap_ptr, const LogicalType &type) {
 	if (type.InternalType() == PhysicalType::VARCHAR) {
-		data_ptr += sizeof(uint32_t) + string_t::PREFIX_LENGTH;
+		data_ptr += string_t::HEADER_SIZE;
 	}
 	Store<data_ptr_t>(heap_ptr + Load<idx_t>(data_ptr), data_ptr);
 }
 
 void Comparators::SwizzleSingleValue(data_ptr_t data_ptr, const data_ptr_t &heap_ptr, const LogicalType &type) {
 	if (type.InternalType() == PhysicalType::VARCHAR) {
-		data_ptr += sizeof(uint32_t) + string_t::PREFIX_LENGTH;
+		data_ptr += string_t::HEADER_SIZE;
 	}
 	Store<idx_t>(Load<data_ptr_t>(data_ptr) - heap_ptr, data_ptr);
 }
diff --git a/src/function/aggregate/distributive/first.cpp b/src/function/aggregate/distributive/first.cpp
index d0a9ebc03449..c19ee090d8ff 100644
--- a/src/function/aggregate/distributive/first.cpp
+++ b/src/function/aggregate/distributive/first.cpp
@@ -69,6 +69,9 @@ template <bool LAST, bool SKIP_NULLS>
 struct FirstFunctionString : public FirstFunctionBase {
 	template <class STATE>
 	static void SetValue(STATE *state, string_t value, bool is_null) {
+		if (LAST && state->is_set) {
+			Destroy(state);
+		}
 		if (is_null) {
 			if (!SKIP_NULLS) {
 				state->is_set = true;
diff --git a/src/include/duckdb/common/operator/comparison_operators.hpp b/src/include/duckdb/common/operator/comparison_operators.hpp
index a814e591c9dc..64ea3595eb88 100644
--- a/src/include/duckdb/common/operator/comparison_operators.hpp
+++ b/src/include/duckdb/common/operator/comparison_operators.hpp
@@ -165,7 +165,7 @@ struct StringComparisonOperators {
 			}
 		} else {
 			// large string: first check prefix and length
-			if (memcmp(&a, &b, sizeof(uint32_t) + string_t::PREFIX_LENGTH) == 0) {
+			if (memcmp(&a, &b, string_t::HEADER_SIZE) == 0) {
 				// prefix and length are equal: check main string
 				if (memcmp(a.value.pointer.ptr, b.value.pointer.ptr, a.GetSize()) == 0) {
 					// entire string is equal
diff --git a/src/include/duckdb/common/types/string_type.hpp b/src/include/duckdb/common/types/string_type.hpp
index 5a12e233797c..e8890a8f7bb6 100644
--- a/src/include/duckdb/common/types/string_type.hpp
+++ b/src/include/duckdb/common/types/string_type.hpp
@@ -20,8 +20,16 @@ struct string_t {
 	friend class StringSegment;
 
 public:
-	static constexpr idx_t PREFIX_LENGTH = 4 * sizeof(char);
-	static constexpr idx_t INLINE_LENGTH = 12;
+	static constexpr idx_t PREFIX_BYTES = 4 * sizeof(char);
+	static constexpr idx_t INLINE_BYTES = 12 * sizeof(char);
+	static constexpr idx_t HEADER_SIZE = sizeof(uint32_t) + PREFIX_BYTES;
+#ifndef DUCKDB_DEBUG_NO_INLINE
+	static constexpr idx_t PREFIX_LENGTH = PREFIX_BYTES;
+	static constexpr idx_t INLINE_LENGTH = INLINE_BYTES;
+#else
+	static constexpr idx_t PREFIX_LENGTH = 0;
+	static constexpr idx_t INLINE_LENGTH = 0;
+#endif
 
 	string_t() = default;
 	explicit string_t(uint32_t len) {
@@ -33,7 +41,7 @@ struct string_t {
 		if (IsInlined()) {
 			// zero initialize the prefix first
 			// this makes sure that strings with length smaller than 4 still have an equal prefix
-			memset(value.inlined.inlined, 0, INLINE_LENGTH);
+			memset(value.inlined.inlined, 0, INLINE_BYTES);
 			if (GetSize() == 0) {
 				return;
 			}
@@ -41,7 +49,11 @@ struct string_t {
 			memcpy(value.inlined.inlined, data, GetSize());
 		} else {
 			// large string: store pointer
+#ifndef DUCKDB_DEBUG_NO_INLINE
 			memcpy(value.pointer.prefix, data, PREFIX_LENGTH);
+#else
+			memset(value.pointer.prefix, 0, PREFIX_BYTES);
+#endif
 			value.pointer.ptr = (char *)data;
 		}
 	}
@@ -82,15 +94,19 @@ struct string_t {
 
 	void Finalize() {
 		// set trailing NULL byte
-		auto dataptr = (char *)GetDataUnsafe();
 		if (GetSize() <= INLINE_LENGTH) {
 			// fill prefix with zeros if the length is smaller than the prefix length
-			for (idx_t i = GetSize(); i < INLINE_LENGTH; i++) {
+			for (idx_t i = GetSize(); i < INLINE_BYTES; i++) {
 				value.inlined.inlined[i] = '\0';
 			}
 		} else {
 			// copy the data into the prefix
+#ifndef DUCKDB_DEBUG_NO_INLINE
+			auto dataptr = (char *)GetDataUnsafe();
 			memcpy(value.pointer.prefix, dataptr, PREFIX_LENGTH);
+#else
+			memset(value.pointer.prefix, 0, PREFIX_BYTES);
+#endif
 		}
 	}
 
