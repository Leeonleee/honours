{
  "repo": "duckdb/duckdb",
  "pull_number": 3120,
  "instance_id": "duckdb__duckdb-3120",
  "issue_numbers": [
    "3119",
    "3119"
  ],
  "base_commit": "45068ac8298d899da0666ee0ba29fe9a26105b50",
  "patch": "diff --git a/src/catalog/default/default_functions.cpp b/src/catalog/default/default_functions.cpp\nindex 5d6418aab1ac..d52edfce8018 100644\n--- a/src/catalog/default/default_functions.cpp\n+++ b/src/catalog/default/default_functions.cpp\n@@ -95,7 +95,9 @@ static DefaultMacro internal_macros[] = {\n \t{DEFAULT_SCHEMA, \"fmod\", {\"x\", \"y\", nullptr}, \"(x-y*floor(x/y))\"},\n \t{nullptr, nullptr, {nullptr}, nullptr}};\n \n-static unique_ptr<CreateFunctionInfo> GetDefaultFunction(const string &schema, const string &name) {\n+static unique_ptr<CreateFunctionInfo> GetDefaultFunction(const string &input_schema, const string &input_name) {\n+\tauto schema = StringUtil::Lower(input_schema);\n+\tauto name = StringUtil::Lower(input_name);\n \tfor (idx_t index = 0; internal_macros[index].name != nullptr; index++) {\n \t\tif (internal_macros[index].schema == schema && internal_macros[index].name == name) {\n \t\t\t// parse the expression\ndiff --git a/src/catalog/default/default_schemas.cpp b/src/catalog/default/default_schemas.cpp\nindex 63ea8abde05d..6921dbda621b 100644\n--- a/src/catalog/default/default_schemas.cpp\n+++ b/src/catalog/default/default_schemas.cpp\n@@ -1,5 +1,6 @@\n #include \"duckdb/catalog/default/default_schemas.hpp\"\n #include \"duckdb/catalog/catalog_entry/schema_catalog_entry.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n \n namespace duckdb {\n \n@@ -9,7 +10,8 @@ struct DefaultSchema {\n \n static DefaultSchema internal_schemas[] = {{\"information_schema\"}, {\"pg_catalog\"}, {nullptr}};\n \n-static bool GetDefaultSchema(const string &schema) {\n+static bool GetDefaultSchema(const string &input_schema) {\n+\tauto schema = StringUtil::Lower(input_schema);\n \tfor (idx_t index = 0; internal_schemas[index].name != nullptr; index++) {\n \t\tif (internal_schemas[index].name == schema) {\n \t\t\treturn true;\n@@ -23,7 +25,7 @@ DefaultSchemaGenerator::DefaultSchemaGenerator(Catalog &catalog) : DefaultGenera\n \n unique_ptr<CatalogEntry> DefaultSchemaGenerator::CreateDefaultEntry(ClientContext &context, const string &entry_name) {\n \tif (GetDefaultSchema(entry_name)) {\n-\t\treturn make_unique_base<CatalogEntry, SchemaCatalogEntry>(&catalog, entry_name, true);\n+\t\treturn make_unique_base<CatalogEntry, SchemaCatalogEntry>(&catalog, StringUtil::Lower(entry_name), true);\n \t}\n \treturn nullptr;\n }\ndiff --git a/src/catalog/default/default_views.cpp b/src/catalog/default/default_views.cpp\nindex e3695ef0bfc0..cd23a41784a9 100644\n--- a/src/catalog/default/default_views.cpp\n+++ b/src/catalog/default/default_views.cpp\n@@ -4,6 +4,7 @@\n #include \"duckdb/planner/binder.hpp\"\n #include \"duckdb/catalog/catalog_entry/schema_catalog_entry.hpp\"\n #include \"duckdb/catalog/catalog_entry/view_catalog_entry.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n \n namespace duckdb {\n \n@@ -48,7 +49,9 @@ static DefaultView internal_views[] = {\n     {\"information_schema\", \"tables\", \"SELECT NULL table_catalog, schema_name table_schema, table_name, CASE WHEN temporary THEN 'LOCAL TEMPORARY' ELSE 'BASE TABLE' END table_type, NULL self_referencing_column_name, NULL reference_generation, NULL user_defined_type_catalog, NULL user_defined_type_schema, NULL user_defined_type_name, 'YES' is_insertable_into, 'NO' is_typed, CASE WHEN temporary THEN 'PRESERVE' ELSE NULL END commit_action FROM duckdb_tables() UNION ALL SELECT NULL table_catalog, schema_name table_schema, view_name table_name, 'VIEW' table_type, NULL self_referencing_column_name, NULL reference_generation, NULL user_defined_type_catalog, NULL user_defined_type_schema, NULL user_defined_type_name, 'NO' is_insertable_into, 'NO' is_typed, NULL commit_action FROM duckdb_views;\"},\n     {nullptr, nullptr, nullptr}};\n \n-static unique_ptr<CreateViewInfo> GetDefaultView(const string &schema, const string &name) {\n+static unique_ptr<CreateViewInfo> GetDefaultView(const string &input_schema, const string &input_name) {\n+\tauto schema = StringUtil::Lower(input_schema);\n+\tauto name = StringUtil::Lower(input_name);\n \tfor (idx_t index = 0; internal_views[index].name != nullptr; index++) {\n \t\tif (internal_views[index].schema == schema && internal_views[index].name == name) {\n \t\t\tauto result = make_unique<CreateViewInfo>();\n",
  "test_patch": "diff --git a/test/sql/table_function/information_schema.test b/test/sql/table_function/information_schema.test\nindex e6a05e7b1b2e..e1868ec1da01 100644\n--- a/test/sql/table_function/information_schema.test\n+++ b/test/sql/table_function/information_schema.test\n@@ -2,6 +2,9 @@\n # description: Test information_schema functions\n # group: [table_function]\n \n+statement ok\n+SELECT * FROM INFORMATION_SCHEMA.SCHEMATA;\n+\n statement ok\n SELECT * FROM information_schema.schemata;\n \n",
  "problem_statement": "Querying INFORMATION_SCHEMA in uppercase results in error\n#### What happens?\r\nA short, clear and concise description of what the bug is.\r\nAfter connecting to an in-memory database in Python, querying tables from \"INFORMATION_SCHEMA\" results in an error. With 0.3.2, after querying it once using lowercase `information_schema`, subsequent queries succeed regardless of case. With 0.3.3-dev255 the query seems to be always case sensitive.\r\n\r\n#### To Reproduce\r\nSteps to reproduce the behavior. Bonus points if those are only SQL queries. \r\n```\r\nimport duckdb\r\ndb=duckdb.connect(\":memory:\")\r\ndb.query(\"\"\"select * from INFORMATION_SCHEMA.tables\"\"\")\r\n```\r\nThrows `RuntimeError: Catalog Error: Schema with name INFORMATION_SCHEMA does not exist!`\r\n\r\n\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Mac OS X\r\n - DuckDB Version: 0.3.2, 0.3.3-dev255\r\n - DuckDB Client: Python\r\n\r\n#### Before Submitting\r\n\r\n- [X] **Have you tried this on the latest `master` branch?**\r\n\r\n- [X] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\nQuerying INFORMATION_SCHEMA in uppercase results in error\n#### What happens?\r\nA short, clear and concise description of what the bug is.\r\nAfter connecting to an in-memory database in Python, querying tables from \"INFORMATION_SCHEMA\" results in an error. With 0.3.2, after querying it once using lowercase `information_schema`, subsequent queries succeed regardless of case. With 0.3.3-dev255 the query seems to be always case sensitive.\r\n\r\n#### To Reproduce\r\nSteps to reproduce the behavior. Bonus points if those are only SQL queries. \r\n```\r\nimport duckdb\r\ndb=duckdb.connect(\":memory:\")\r\ndb.query(\"\"\"select * from INFORMATION_SCHEMA.tables\"\"\")\r\n```\r\nThrows `RuntimeError: Catalog Error: Schema with name INFORMATION_SCHEMA does not exist!`\r\n\r\n\r\n\r\n#### Environment (please complete the following information):\r\n - OS: Mac OS X\r\n - DuckDB Version: 0.3.2, 0.3.3-dev255\r\n - DuckDB Client: Python\r\n\r\n#### Before Submitting\r\n\r\n- [X] **Have you tried this on the latest `master` branch?**\r\n\r\n- [X] **Have you tried the steps to reproduce? Do they include all relevant data and configuration? Does the issue you report still appear there?**\r\n\n",
  "hints_text": "Thanks for the report! I think I know what causes this.\nThanks for the report! I think I know what causes this.",
  "created_at": "2022-02-20T11:56:20Z",
  "modified_files": [
    "src/catalog/default/default_functions.cpp",
    "src/catalog/default/default_schemas.cpp",
    "src/catalog/default/default_views.cpp"
  ],
  "modified_test_files": [
    "test/sql/table_function/information_schema.test"
  ]
}