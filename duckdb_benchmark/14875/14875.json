{
  "repo": "duckdb/duckdb",
  "pull_number": 14875,
  "instance_id": "duckdb__duckdb-14875",
  "issue_numbers": [
    "14833",
    "14833"
  ],
  "base_commit": "4982c3f135d0f55cbb896ca35a0cd8dc458fc4ee",
  "patch": "diff --git a/src/catalog/default/default_functions.cpp b/src/catalog/default/default_functions.cpp\nindex 2479983635fb..59e27632e7b4 100644\n--- a/src/catalog/default/default_functions.cpp\n+++ b/src/catalog/default/default_functions.cpp\n@@ -63,7 +63,7 @@ static const DefaultMacro internal_macros[] = {\n \t{\"pg_catalog\", \"pg_get_expr\", {\"pg_node_tree\", \"relation_oid\", nullptr}, {{nullptr, nullptr}}, \"pg_node_tree\"},\n \t{\"pg_catalog\", \"format_pg_type\", {\"logical_type\", \"type_name\", nullptr}, {{nullptr, nullptr}}, \"case upper(logical_type) when 'FLOAT' then 'float4' when 'DOUBLE' then 'float8' when 'DECIMAL' then 'numeric' when 'ENUM' then lower(type_name) when 'VARCHAR' then 'varchar' when 'BLOB' then 'bytea' when 'TIMESTAMP' then 'timestamp' when 'TIME' then 'time' when 'TIMESTAMP WITH TIME ZONE' then 'timestamptz' when 'TIME WITH TIME ZONE' then 'timetz' when 'SMALLINT' then 'int2' when 'INTEGER' then 'int4' when 'BIGINT' then 'int8' when 'BOOLEAN' then 'bool' else lower(logical_type) end\"},\n \t{\"pg_catalog\", \"format_type\", {\"type_oid\", \"typemod\", nullptr}, {{nullptr, nullptr}}, \"(select format_pg_type(logical_type, type_name) from duckdb_types() t where t.type_oid=type_oid) || case when typemod>0 then concat('(', typemod//1000, ',', typemod%1000, ')') else '' end\"},\n-\t{\"pg_catalog\", \"map_to_pg_oid\", {\"type_name\", nullptr}, {{nullptr, nullptr}}, \"case type_name when 'bool' then 16 when 'int16' then 21 when 'int' then 23 when 'bigint' then 20 when 'date' then 1082 when 'time' then 1083 when 'datetime' then 1114 when 'dec' then 1700 when 'float' then 700 when 'double' then 701 when 'bpchar' then 1043 when 'binary' then 17 when 'interval' then 1186 when 'timestamptz' then 1184 when 'timetz' then 1266 when 'bit' then 1560 when 'guid' then 2950 else null end\"}, // map duckdb_oid to pg_oid. If no corresponding type, return null \n+\t{\"pg_catalog\", \"map_to_pg_oid\", {\"type_name\", nullptr}, {{nullptr, nullptr}}, \"case type_name when 'bool' then 16 when 'int16' then 21 when 'int' then 23 when 'bigint' then 20 when 'date' then 1082 when 'time' then 1083 when 'datetime' then 1114 when 'dec' then 1700 when 'float' then 700 when 'double' then 701 when 'bpchar' then 1043 when 'binary' then 17 when 'interval' then 1186 when 'timestamptz' then 1184 when 'timetz' then 1266 when 'bit' then 1560 when 'guid' then 2950 else null end\"}, // map duckdb_oid to pg_oid. If no corresponding type, return null\n \n \t{\"pg_catalog\", \"pg_has_role\", {\"user\", \"role\", \"privilege\", nullptr}, {{nullptr, nullptr}}, \"true\"},  //boolean  //does user have privilege for role\n \t{\"pg_catalog\", \"pg_has_role\", {\"role\", \"privilege\", nullptr}, {{nullptr, nullptr}}, \"true\"},  //boolean  //does current user have privilege for role\n@@ -102,12 +102,12 @@ static const DefaultMacro internal_macros[] = {\n \t{DEFAULT_SCHEMA, \"array_to_string\", {\"arr\", \"sep\", nullptr}, {{nullptr, nullptr}}, \"list_aggr(arr::varchar[], 'string_agg', sep)\"},\n \t// Test default parameters\n \t{DEFAULT_SCHEMA, \"array_to_string_comma_default\", {\"arr\", nullptr}, {{\"sep\", \"','\"}, {nullptr, nullptr}}, \"list_aggr(arr::varchar[], 'string_agg', sep)\"},\n-\t\n+\n \t{DEFAULT_SCHEMA, \"generate_subscripts\", {\"arr\", \"dim\", nullptr}, {{nullptr, nullptr}}, \"unnest(generate_series(1, array_length(arr, dim)))\"},\n \t{DEFAULT_SCHEMA, \"fdiv\", {\"x\", \"y\", nullptr}, {{nullptr, nullptr}}, \"floor(x/y)\"},\n \t{DEFAULT_SCHEMA, \"fmod\", {\"x\", \"y\", nullptr}, {{nullptr, nullptr}}, \"(x-y*floor(x/y))\"},\n \t{DEFAULT_SCHEMA, \"count_if\", {\"l\", nullptr}, {{nullptr, nullptr}}, \"sum(if(l, 1, 0))\"},\n-\t{DEFAULT_SCHEMA, \"split_part\", {\"string\", \"delimiter\", \"position\", nullptr}, {{nullptr, nullptr}}, \"coalesce(string_split(string, delimiter)[position],'')\"},\n+\t{DEFAULT_SCHEMA, \"split_part\", {\"string\", \"delimiter\", \"position\", nullptr}, {{nullptr, nullptr}}, \"if(string IS NOT NULL AND delimiter IS NOT NULL AND position IS NOT NULL, coalesce(string_split(string, delimiter)[position],''), NULL)\"},\n \t{DEFAULT_SCHEMA, \"geomean\", {\"x\", nullptr}, {{nullptr, nullptr}}, \"exp(avg(ln(x)))\"},\n \t{DEFAULT_SCHEMA, \"geometric_mean\", {\"x\", nullptr}, {{nullptr, nullptr}}, \"geomean(x)\"},\n \n",
  "test_patch": "diff --git a/test/sql/function/string/test_split_part.test b/test/sql/function/string/test_split_part.test\nindex 2e3b8a595d73..e2acb1a6edec 100644\n--- a/test/sql/function/string/test_split_part.test\n+++ b/test/sql/function/string/test_split_part.test\n@@ -73,17 +73,22 @@ select split_part('',',',1)\n query T\n select split_part(NULL,NULL,1)\n ----\n-(empty)\n+NULL\n \n query T\n select split_part('a,b,c',NULL,1)\n ----\n-a,b,c\n+NULL\n \n query T\n select split_part(NULL,',',1)\n ----\n-(empty)\n+NULL\n+\n+query T\n+select split_part('a,b,c', ',',  NULL)\n+----\n+NULL\n \n # test incorrect usage\n statement error\n",
  "problem_statement": "`split_part` does not return `null` when first input is `null`\n### What happens?\r\n\r\n[`split_part`](https://duckdb.org/docs/sql/functions/char.html#split_partstring-separator-index) takes three arguments. The first is the string to split. The documentation states that index outside of range behavior for this function is designed to mimic Postgres behavior (and it does). However, Postgres returns `null` when the first input is `null` but DuckDB returns the empty string. This can cause hard-to-diagnose downstream effects, especially when the result of a `split_part` is used as a join key (empty strings match with other empty strings, but `null`s do not match with other `null`s).\r\n\r\n### To Reproduce\r\n\r\nSimple example:\r\n```sql\r\n.nullvalue NULL\r\ncreate table foo (a varchar);\r\ninsert into foo values ('hello$there'), ('apples'), (''), (null);\r\nselect * from foo;\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502      a      \u2502\r\n\u2502   varchar   \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 hello$there \u2502\r\n\u2502 apples      \u2502\r\n\u2502             \u2502\r\n\u2502 NULL        \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n```sql\r\nselect count(*) from foo where a is not null;\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 count_star() \u2502\r\n\u2502    int64     \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502            3 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n```sql\r\nselect split_part(a, '$', -1) as s from foo;\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502    s    \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 there   \u2502\r\n\u2502 apples  \u2502\r\n\u2502         \u2502\r\n\u2502         \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n```sql\r\nselect count(*) from foo where split_part(a, '$', -1) is not null;\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 count_star() \u2502\r\n\u2502    int64     \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502            4 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nNote that since the result of the last query was 4, the function value on `null` input was the empty string, not `null`. This differs from Postgres behavior as shown below:\r\n\r\n```sql\r\npostgres: create table foo (a varchar);\r\nCREATE TABLE\r\npostgres: insert into foo values ('hello$there'), ('apples'), (''), (null);\r\nINSERT 0 4\r\npostgres: select count(*) from foo where a is not null;\r\n count\r\n-------\r\n     3\r\n(1 row)\r\n\r\npostgres: select split_part(a, '$', -1) as s from foo;\r\n   s\r\n--------\r\n there\r\n apples\r\n\r\n\r\n(4 rows)\r\n\r\npostgres: select count(*) from foo where split_part(a, '$', -1) is not null;\r\n count\r\n-------\r\n     3\r\n(1 row)\r\n```\r\n\r\n### OS:\r\n\r\nManjaro Linus x86_64\r\n\r\n### DuckDB Version:\r\n\r\nv1.1.1 af39bd0dcf\r\n\r\n### DuckDB Client:\r\n\r\nCLI\r\n\r\n### Hardware:\r\n\r\n_No response_\r\n\r\n### Full Name:\r\n\r\nDoeke Buursma\r\n\r\n### Affiliation:\r\n\r\nUDisc, LLC\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNot applicable - the reproduction does not require a data set\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n`split_part` does not return `null` when first input is `null`\n### What happens?\r\n\r\n[`split_part`](https://duckdb.org/docs/sql/functions/char.html#split_partstring-separator-index) takes three arguments. The first is the string to split. The documentation states that index outside of range behavior for this function is designed to mimic Postgres behavior (and it does). However, Postgres returns `null` when the first input is `null` but DuckDB returns the empty string. This can cause hard-to-diagnose downstream effects, especially when the result of a `split_part` is used as a join key (empty strings match with other empty strings, but `null`s do not match with other `null`s).\r\n\r\n### To Reproduce\r\n\r\nSimple example:\r\n```sql\r\n.nullvalue NULL\r\ncreate table foo (a varchar);\r\ninsert into foo values ('hello$there'), ('apples'), (''), (null);\r\nselect * from foo;\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502      a      \u2502\r\n\u2502   varchar   \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 hello$there \u2502\r\n\u2502 apples      \u2502\r\n\u2502             \u2502\r\n\u2502 NULL        \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n```sql\r\nselect count(*) from foo where a is not null;\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 count_star() \u2502\r\n\u2502    int64     \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502            3 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n```sql\r\nselect split_part(a, '$', -1) as s from foo;\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502    s    \u2502\r\n\u2502 varchar \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 there   \u2502\r\n\u2502 apples  \u2502\r\n\u2502         \u2502\r\n\u2502         \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n```sql\r\nselect count(*) from foo where split_part(a, '$', -1) is not null;\r\n```\r\n```\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 count_star() \u2502\r\n\u2502    int64     \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502            4 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nNote that since the result of the last query was 4, the function value on `null` input was the empty string, not `null`. This differs from Postgres behavior as shown below:\r\n\r\n```sql\r\npostgres: create table foo (a varchar);\r\nCREATE TABLE\r\npostgres: insert into foo values ('hello$there'), ('apples'), (''), (null);\r\nINSERT 0 4\r\npostgres: select count(*) from foo where a is not null;\r\n count\r\n-------\r\n     3\r\n(1 row)\r\n\r\npostgres: select split_part(a, '$', -1) as s from foo;\r\n   s\r\n--------\r\n there\r\n apples\r\n\r\n\r\n(4 rows)\r\n\r\npostgres: select count(*) from foo where split_part(a, '$', -1) is not null;\r\n count\r\n-------\r\n     3\r\n(1 row)\r\n```\r\n\r\n### OS:\r\n\r\nManjaro Linus x86_64\r\n\r\n### DuckDB Version:\r\n\r\nv1.1.1 af39bd0dcf\r\n\r\n### DuckDB Client:\r\n\r\nCLI\r\n\r\n### Hardware:\r\n\r\n_No response_\r\n\r\n### Full Name:\r\n\r\nDoeke Buursma\r\n\r\n### Affiliation:\r\n\r\nUDisc, LLC\r\n\r\n### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.\r\n\r\nI have tested with a stable release\r\n\r\n### Did you include all relevant data sets for reproducing the issue?\r\n\r\nNot applicable - the reproduction does not require a data set\r\n\r\n### Did you include all code required to reproduce the issue?\r\n\r\n- [X] Yes, I have\r\n\r\n### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?\r\n\r\n- [X] Yes, I have\n",
  "hints_text": "Hi @Doekeb, thanks for opening this issue. Indeed we strive to achieve Postgres-compatibility, so this should be fixed. We'll take a look.\nHi @Doekeb, thanks for opening this issue. Indeed we strive to achieve Postgres-compatibility, so this should be fixed. We'll take a look.",
  "created_at": "2024-11-18T12:54:42Z",
  "modified_files": [
    "src/catalog/default/default_functions.cpp"
  ],
  "modified_test_files": [
    "test/sql/function/string/test_split_part.test"
  ]
}