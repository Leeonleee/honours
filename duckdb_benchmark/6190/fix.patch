diff --git a/src/parser/column_definition.cpp b/src/parser/column_definition.cpp
index cd1f57b073cf..f6f5cc6bc43f 100644
--- a/src/parser/column_definition.cpp
+++ b/src/parser/column_definition.cpp
@@ -162,6 +162,9 @@ static void InnerGetListOfDependencies(ParsedExpression &expr, vector<string> &d
 		dependencies.push_back(name);
 	}
 	ParsedExpressionIterator::EnumerateChildren(expr, [&](const ParsedExpression &child) {
+		if (expr.type == ExpressionType::LAMBDA) {
+			throw NotImplementedException("Lambda functions are currently not supported in generated columns.");
+		}
 		InnerGetListOfDependencies((ParsedExpression &)child, dependencies);
 	});
 }
diff --git a/src/planner/expression_binder/check_binder.cpp b/src/planner/expression_binder/check_binder.cpp
index 2974867af13d..4ecf55103333 100644
--- a/src/planner/expression_binder/check_binder.cpp
+++ b/src/planner/expression_binder/check_binder.cpp
@@ -1,5 +1,6 @@
 #include "duckdb/planner/expression_binder/check_binder.hpp"
 
+#include "duckdb/planner/table_binding.hpp"
 #include "duckdb/parser/expression/columnref_expression.hpp"
 #include "duckdb/planner/expression/bound_reference_expression.hpp"
 
@@ -42,6 +43,19 @@ BindResult ExpressionBinder::BindQualifiedColumnName(ColumnRefExpression &colref
 }
 
 BindResult CheckBinder::BindCheckColumn(ColumnRefExpression &colref) {
+
+	// if this is a lambda parameters, then we temporarily add a BoundLambdaRef,
+	// which we capture and remove later
+	if (lambda_bindings) {
+		for (idx_t i = 0; i < lambda_bindings->size(); i++) {
+			if (colref.GetColumnName() == (*lambda_bindings)[i].dummy_name) {
+				// FIXME: support lambdas in CHECK constraints
+				// FIXME: like so: return (*lambda_bindings)[i].Bind(colref, i, depth);
+				throw NotImplementedException("Lambda functions are currently not supported in CHECK constraints.");
+			}
+		}
+	}
+
 	if (colref.column_names.size() > 1) {
 		return BindQualifiedColumnName(colref, table);
 	}
