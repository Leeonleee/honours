diff --git a/ydb/core/cms/cms_ut.cpp b/ydb/core/cms/cms_ut.cpp
index 132f666844b0..48215541e37c 100644
--- a/ydb/core/cms/cms_ut.cpp
+++ b/ydb/core/cms/cms_ut.cpp
@@ -2484,7 +2484,7 @@ Y_UNIT_TEST_SUITE(TCmsTest) {
         // Pile #1: There are 0 rings locked on this pile => it is possible to lock.
         env.CheckPermissionRequest("user", true, false, true, true, MODE_MAX_AVAILABILITY, TStatus::ALLOW,
                                     MakeAction(TAction::RESTART_SERVICES, env.GetNodeId(0), 60000000, "storage"));
-        // Pile #0: There are 0 rings locked on this pile => it is possible to lock.                            
+        // Pile #0: There are 0 rings locked on this pile => it is possible to lock.
         env.CheckPermissionRequest("user", true, false, true, true, MODE_MAX_AVAILABILITY, TStatus::ALLOW,
                                     MakeAction(TAction::RESTART_SERVICES, env.GetNodeId(1), 60000000, "storage"));
         // Pile #1: There is already one ring locked on this pile => it is not possible to lock.
diff --git a/ydb/core/cms/cms_ut_common.cpp b/ydb/core/cms/cms_ut_common.cpp
index 271f4f42b2ba..7b76ddb88744 100644
--- a/ydb/core/cms/cms_ut_common.cpp
+++ b/ydb/core/cms/cms_ut_common.cpp
@@ -586,10 +586,12 @@ static void SetupServices(TTestBasicRuntime &runtime, const TTestEnvOpts &option
     runtime.GetAppData().BootstrapConfig = TFakeNodeWhiteboardService::BootstrapConfig;
     
     if (options.IsBridgeMode) {
-        for (ui32 pileId = 0; pileId < options.PileCount; ++pileId) {
-            runtime.GetAppData().BridgeConfig.AddPiles()->SetName("r" + ToString(pileId));
+        for (ui32 nodeIndex = 0; nodeIndex < runtime.GetNodeCount(); ++nodeIndex) {
+            for (ui32 pileId = 0; pileId < options.PileCount; ++pileId) {
+                runtime.GetAppData(nodeIndex).BridgeConfig.AddPiles()->SetName("r" + ToString(pileId));
+            }
+            runtime.GetAppData(nodeIndex).BridgeModeEnabled = true;
         }
-        runtime.GetAppData().BridgeModeEnabled = true;
     }
 
     NKikimrCms::TCmsConfig cmsConfig;
@@ -680,6 +682,9 @@ TCmsTestEnv::TCmsTestEnv(const TTestEnvOpts &options)
     Sender = AllocateEdgeActor();
     ClientId = TActorId();
 
+    // Make sure default empty configs are handled first
+    SimulateSleep(TDuration::MilliSeconds(100));
+
     NKikimrCms::TCmsConfig cmsConfig;
     cmsConfig.MutableTenantLimits()->SetDisabledNodesRatioLimit(0);
     cmsConfig.MutableClusterLimits()->SetDisabledNodesRatioLimit(0);
diff --git a/ydb/core/cms/console/feature_flags_configurator_ut.cpp b/ydb/core/cms/console/feature_flags_configurator_ut.cpp
index 9618a42d9f1b..a87fc03e2543 100644
--- a/ydb/core/cms/console/feature_flags_configurator_ut.cpp
+++ b/ydb/core/cms/console/feature_flags_configurator_ut.cpp
@@ -86,33 +86,46 @@ void InitFeatureFlagsConfigurator(TTenantTestRuntime& runtime) {
     runtime.DispatchEvents(options);
 }
 
-void WaitForUpdate(TTenantTestRuntime& runtime) {
-    struct TIsConfigNotificationProcessed {
-        bool operator()(IEventHandle& ev) {
-            if (ev.GetTypeRewrite() == NConsole::TEvConsole::EvConfigNotificationResponse) {
-                auto& rec = ev.Get<NConsole::TEvConsole::TEvConfigNotificationResponse>()->Record;
-                if (rec.GetConfigId().ItemIdsSize() != 1 || rec.GetConfigId().GetItemIds(0).GetId())
-                    return true;
-            }
-
-            return false;
-        }
-    };
+class TConfigUpdatesObserver {
+public:
+    TConfigUpdatesObserver(TTestActorRuntime& runtime)
+        : Runtime(runtime)
+        , Holder(Runtime.AddObserver<NConsole::TEvConsole::TEvConfigNotificationResponse>(
+            [this](auto& ev) {
+                auto& rec = ev->Get()->Record;
+                if (rec.GetConfigId().ItemIdsSize() != 1 || rec.GetConfigId().GetItemIds(0).GetId()) {
+                    ++Count;
+                }
+            }))
+    {}
+
+    void Clear() {
+        Count = 0;
+    }
 
-    TDispatchOptions options;
-    options.FinalEvents.emplace_back(TIsConfigNotificationProcessed(), 1);
-    runtime.DispatchEvents(options);
-}
+    void Wait() {
+        Runtime.WaitFor("config update", [this]{ return this->Count > 0; });
+        --Count;
+    }
+
+private:
+    TTestActorRuntime& Runtime;
+    TTestActorRuntime::TEventObserverHolder Holder;
+    size_t Count = 0;
+};
 
 template <class ...Ts>
 void ConfigureAndWaitUpdate(
-    TTenantTestRuntime& runtime, Ts&&... args)
+    TTenantTestRuntime& runtime, TConfigUpdatesObserver& updates, Ts&&... args)
 {
     auto* event = new TEvConsole::TEvConfigureRequest;
     CollectActions(event->Record, std::forward<Ts>(args)...);
 
+    updates.Clear();
     runtime.SendToConsole(event);
-    WaitForUpdate(runtime);
+    auto ev = runtime.GrabEdgeEventRethrow<TEvConsole::TEvConfigureResponse>(runtime.Sender);
+    UNIT_ASSERT_VALUES_EQUAL(ev->Get()->Record.GetStatus().GetCode(), Ydb::StatusIds::SUCCESS);
+    updates.Wait();
 }
 
 void CompareFeatureFlags(TTenantTestRuntime& runtime, const TString& expected) {
@@ -127,8 +140,11 @@ Y_UNIT_TEST_SUITE(FeatureFlagsConfiguratorTest) {
 
     Y_UNIT_TEST(TestFeatureFlagsUpdates) {
         TTenantTestRuntime runtime(DefaultConsoleTestConfig());
+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down
+
+        TConfigUpdatesObserver updates(runtime);
         InitFeatureFlagsConfigurator(runtime);
-        WaitForUpdate(runtime); // initial update
+        updates.Wait(); // initial update
 
         CompareFeatureFlags(runtime,
             "EnableExternalHive: false
"
@@ -141,14 +157,14 @@ Y_UNIT_TEST_SUITE(FeatureFlagsConfiguratorTest) {
         // We must receive the first (spurious) notification
         runtime.GrabEdgeEventRethrow<TEvFeatureFlags::TEvChanged>(sender);
 
-        ConfigureAndWaitUpdate(runtime, MakeAddAction(ITEM_FEATURE_FLAGS_DEFAULT));
+        ConfigureAndWaitUpdate(runtime, updates, MakeAddAction(ITEM_FEATURE_FLAGS_DEFAULT));
         CompareFeatureFlags(runtime,
             "EnableExternalHive: false
");
 
         // We must receive a notification (contents are not checked)
         runtime.GrabEdgeEventRethrow<TEvFeatureFlags::TEvChanged>(sender);
 
-        ConfigureAndWaitUpdate(runtime, MakeAddAction(ITEM_FEATURE_FLAGS_1));
+        ConfigureAndWaitUpdate(runtime, updates, MakeAddAction(ITEM_FEATURE_FLAGS_1));
         CompareFeatureFlags(runtime,
             "EnableExternalHive: false
"
             "EnableDataShardVolatileTransactions: false
");
@@ -156,7 +172,7 @@ Y_UNIT_TEST_SUITE(FeatureFlagsConfiguratorTest) {
         // We must receive a notification on every change
         runtime.GrabEdgeEventRethrow<TEvFeatureFlags::TEvChanged>(sender);
 
-        ConfigureAndWaitUpdate(runtime, MakeAddAction(ITEM_FEATURE_FLAGS_2));
+        ConfigureAndWaitUpdate(runtime, updates, MakeAddAction(ITEM_FEATURE_FLAGS_2));
         CompareFeatureFlags(runtime,
             "EnableVolatileTransactionArbiters: false
");
 
diff --git a/ydb/core/cms/console/immediate_controls_configurator_ut.cpp b/ydb/core/cms/console/immediate_controls_configurator_ut.cpp
index 9e13a6510893..8de68b4ce27a 100644
--- a/ydb/core/cms/console/immediate_controls_configurator_ut.cpp
+++ b/ydb/core/cms/console/immediate_controls_configurator_ut.cpp
@@ -149,35 +149,46 @@ void InitImmediateControlsConfigurator(TTenantTestRuntime &runtime)
     }
 }
 
-void WaitForUpdate(TTenantTestRuntime &runtime)
-{
-    struct TIsConfigNotificationProcessed {
-        bool operator()(IEventHandle& ev)
-        {
-            if (ev.GetTypeRewrite() == NConsole::TEvConsole::EvConfigNotificationResponse) {
-                auto &rec = ev.Get<NConsole::TEvConsole::TEvConfigNotificationResponse>()->Record;
-                if (rec.GetConfigId().ItemIdsSize() != 1 || rec.GetConfigId().GetItemIds(0).GetId())
-                    return true;
-            }
+class TConfigUpdatesObserver {
+public:
+    TConfigUpdatesObserver(TTestActorRuntime& runtime)
+        : Runtime(runtime)
+        , Holder(Runtime.AddObserver<NConsole::TEvConsole::TEvConfigNotificationResponse>(
+            [this](auto& ev) {
+                auto& rec = ev->Get()->Record;
+                if (rec.GetConfigId().ItemIdsSize() != 1 || rec.GetConfigId().GetItemIds(0).GetId()) {
+                    ++Count;
+                }
+            }))
+    {}
+
+    void Clear() {
+        Count = 0;
+    }
 
-            return false;
-        }
-    };
+    void Wait() {
+        Runtime.WaitFor("config update", [this]{ return this->Count > 0; });
+        --Count;
+    }
 
-    TDispatchOptions options;
-    options.FinalEvents.emplace_back(TIsConfigNotificationProcessed(), 1);
-    runtime.DispatchEvents(options);
-}
+private:
+    TTestActorRuntime& Runtime;
+    TTestActorRuntime::TEventObserverHolder Holder;
+    size_t Count = 0;
+};
 
 template <typename ...Ts>
-void ConfigureAndWaitUpdate(TTenantTestRuntime &runtime,
+void ConfigureAndWaitUpdate(TTenantTestRuntime &runtime, TConfigUpdatesObserver &updates,
                             Ts... args)
 {
     auto *event = new TEvConsole::TEvConfigureRequest;
     CollectActions(event->Record, args...);
 
+    updates.Clear();
     runtime.SendToConsole(event);
-    WaitForUpdate(runtime);
+    auto ev = runtime.GrabEdgeEventRethrow<TEvConsole::TEvConfigureResponse>(runtime.Sender);
+    UNIT_ASSERT_VALUES_EQUAL(ev->Get()->Record.GetStatus().GetCode(), Ydb::StatusIds::SUCCESS);
+    updates.Wait();
 }
 
 void CompareControls(TTenantTestRuntime &runtime,
@@ -210,8 +221,11 @@ Y_UNIT_TEST_SUITE(TImmediateControlsConfiguratorTests)
     Y_UNIT_TEST(TestControlsInitialization)
     {
         TTenantTestRuntime runtime(DefaultConsoleTestConfig());
+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down
+        TConfigUpdatesObserver updates(runtime);
+
         InitImmediateControlsConfigurator(runtime);
-        WaitForUpdate(runtime); // initial update
+        updates.Wait(); // initial update
 
         CompareControls(runtime, ITEM_CONTROLS_DEFAULT.GetConfig().GetImmediateControlsConfig());
     }
@@ -219,10 +233,13 @@ Y_UNIT_TEST_SUITE(TImmediateControlsConfiguratorTests)
     Y_UNIT_TEST(TestModifiedControls)
     {
         TTenantTestRuntime runtime(DefaultConsoleTestConfig());
+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down
+        TConfigUpdatesObserver updates(runtime);
+
         InitImmediateControlsConfigurator(runtime);
-        WaitForUpdate(runtime); // initial update
+        updates.Wait(); // initial update
 
-        ConfigureAndWaitUpdate(runtime,
+        ConfigureAndWaitUpdate(runtime, updates,
                                MakeAddAction(ITEM_CONTROLS1));
         CompareControls(runtime, ITEM_CONTROLS1.GetConfig().GetImmediateControlsConfig());
     }
@@ -230,18 +247,21 @@ Y_UNIT_TEST_SUITE(TImmediateControlsConfiguratorTests)
     Y_UNIT_TEST(TestResetToDefault)
     {
         TTenantTestRuntime runtime(DefaultConsoleTestConfig());
+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down
+        TConfigUpdatesObserver updates(runtime);
+
         InitImmediateControlsConfigurator(runtime);
-        WaitForUpdate(runtime); // initial update
+        updates.Wait(); // initial update
 
-        ConfigureAndWaitUpdate(runtime,
+        ConfigureAndWaitUpdate(runtime, updates,
                                MakeAddAction(ITEM_CONTROLS1));
         CompareControls(runtime, ITEM_CONTROLS1.GetConfig().GetImmediateControlsConfig());
 
-        ConfigureAndWaitUpdate(runtime,
+        ConfigureAndWaitUpdate(runtime, updates,
                                MakeAddAction(ITEM_CONTROLS2));
         CompareControls(runtime, ITEM_CONTROLS2_RES.GetConfig().GetImmediateControlsConfig());
 
-        ConfigureAndWaitUpdate(runtime,
+        ConfigureAndWaitUpdate(runtime, updates,
                                MakeRemoveAction(1, 1),
                                MakeRemoveAction(2, 1));
 
@@ -251,10 +271,13 @@ Y_UNIT_TEST_SUITE(TImmediateControlsConfiguratorTests)
     Y_UNIT_TEST(TestMaxLimit)
     {
         TTenantTestRuntime runtime(DefaultConsoleTestConfig());
+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down
+        TConfigUpdatesObserver updates(runtime);
+
         InitImmediateControlsConfigurator(runtime);
-        WaitForUpdate(runtime); // initial update
+        updates.Wait(); // initial update
 
-        ConfigureAndWaitUpdate(runtime,
+        ConfigureAndWaitUpdate(runtime, updates,
                                MakeAddAction(ITEM_CONTROLS_EXCEED_MAX));
         CompareControls(runtime, ITEM_CONTROLS_MAX.GetConfig().GetImmediateControlsConfig());
     }
@@ -262,8 +285,11 @@ Y_UNIT_TEST_SUITE(TImmediateControlsConfiguratorTests)
     Y_UNIT_TEST(TestDynamicMap)
     {
         TTenantTestRuntime runtime(DefaultConsoleTestConfig());
+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down
+        TConfigUpdatesObserver updates(runtime);
+
         InitImmediateControlsConfigurator(runtime);
-        WaitForUpdate(runtime); // initial update
+        updates.Wait(); // initial update
 
         NKikimrConsole::TConfigItem dynamicMapValue;
         {
@@ -275,7 +301,7 @@ Y_UNIT_TEST_SUITE(TImmediateControlsConfiguratorTests)
             r.SetMaxInFlight(10);
         }
 
-        ConfigureAndWaitUpdate(runtime, MakeAddAction(dynamicMapValue));
+        ConfigureAndWaitUpdate(runtime, updates, MakeAddAction(dynamicMapValue));
 
         auto icb = runtime.GetAppData().Icb;
 
diff --git a/ydb/core/cms/console/jaeger_tracing_configurator_ut.cpp b/ydb/core/cms/console/jaeger_tracing_configurator_ut.cpp
index ce32b8948bcd..90db87a1be4b 100644
--- a/ydb/core/cms/console/jaeger_tracing_configurator_ut.cpp
+++ b/ydb/core/cms/console/jaeger_tracing_configurator_ut.cpp
@@ -62,13 +62,32 @@ void InitJaegerTracingConfigurator(
     runtime.DispatchEvents(std::move(options));
 }
 
-void WaitForUpdate(TTenantTestRuntime& runtime) {
-    TDispatchOptions options;
-    options.FinalEvents.emplace_back(TEvConsole::EvConfigNotificationResponse, 1);
-    runtime.DispatchEvents(std::move(options));
-}
+class TConfigUpdatesObserver {
+public:
+    TConfigUpdatesObserver(TTestActorRuntime& runtime)
+        : Runtime(runtime)
+        , Holder(Runtime.AddObserver<NConsole::TEvConsole::TEvConfigNotificationResponse>(
+            [this](auto&) {
+                ++Count;
+            }))
+    {}
+
+    void Clear() {
+        Count = 0;
+    }
+
+    void Wait() {
+        Runtime.WaitFor("config update", [this]{ return this->Count > 0; });
+        --Count;
+    }
+
+private:
+    TTestActorRuntime& Runtime;
+    TTestActorRuntime::TEventObserverHolder Holder;
+    size_t Count = 0;
+};
 
-void ConfigureAndWaitUpdate(TTenantTestRuntime& runtime, const NKikimrConfig::TTracingConfig& cfg, ui32 order) {
+void Configure(TTenantTestRuntime& runtime, const NKikimrConfig::TTracingConfig& cfg, ui32 order) {
     auto configItem = MakeConfigItem(NKikimrConsole::TConfigItem::TracingConfigItem,
                                      NKikimrConfig::TAppConfig(), {}, {}, "", "", order,
                                      NKikimrConsole::TConfigItem::OVERWRITE, "");
@@ -78,7 +97,15 @@ void ConfigureAndWaitUpdate(TTenantTestRuntime& runtime, const NKikimrConfig::TT
     event->Record.AddActions()->CopyFrom(MakeAddAction(configItem));
 
     runtime.SendToConsole(event);
-    WaitForUpdate(runtime);
+
+    auto ev = runtime.GrabEdgeEventRethrow<TEvConsole::TEvConfigureResponse>(runtime.Sender);
+    UNIT_ASSERT_VALUES_EQUAL(ev->Get()->Record.GetStatus().GetCode(), Ydb::StatusIds::SUCCESS);
+}
+
+void ConfigureAndWaitUpdate(TTenantTestRuntime& runtime, TConfigUpdatesObserver& updates, const NKikimrConfig::TTracingConfig& cfg, ui32 order) {
+    updates.Clear();
+    Configure(runtime, cfg, order);
+    updates.Wait();
 }
 
 auto& RandomChoice(auto& Container) {
@@ -183,9 +210,13 @@ struct TTimeProviderMock : public ITimeProvider {
 Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
     Y_UNIT_TEST(DefaultConfig) {
         TTenantTestRuntime runtime(DefaultConsoleTestConfig());
+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down
+
+        TConfigUpdatesObserver updates(runtime);
         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());
         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);
         InitJaegerTracingConfigurator(runtime, std::move(configurator), {});
+        updates.Wait(); // Initial update
 
         for (size_t i = 0; i < 100; ++i) {
             auto [state, _] = controls.HandleTracing(false, {});
@@ -196,11 +227,13 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
             auto [state, _] = controls.HandleTracing(true, {});
             UNIT_ASSERT_EQUAL(state, TTracingControls::OFF); // No request with trace-id are traced
         }
-        WaitForUpdate(runtime); // Initial update
     }
 
     Y_UNIT_TEST(GlobalRules) {
         TTenantTestRuntime runtime(DefaultConsoleTestConfig());
+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down
+
+        TConfigUpdatesObserver updates(runtime);
         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());
         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);
         NKikimrConfig::TTracingConfig cfg;
@@ -216,7 +249,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
             rule->SetMaxTracesBurst(10);
             rule->SetMaxTracesPerMinute(30);
         }
+        Configure(runtime, cfg, 1);
         InitJaegerTracingConfigurator(runtime, std::move(configurator), cfg);
+        updates.Wait(); // Initial update
 
         std::array discriminators{
             TRequestDiscriminator{
@@ -282,6 +317,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
 
     Y_UNIT_TEST(ExternalTracePlusSampling) {
         TTenantTestRuntime runtime(DefaultConsoleTestConfig());
+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down
+
+        TConfigUpdatesObserver updates(runtime);
         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());
         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);
         NKikimrConfig::TTracingConfig cfg;
@@ -297,7 +335,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
             rule->SetMaxTracesBurst(10);
             rule->SetMaxTracesPerMinute(90);
         }
+        Configure(runtime, cfg, 1);
         InitJaegerTracingConfigurator(runtime, std::move(configurator), cfg);
+        updates.Wait(); // Initial update
 
         std::array discriminators{
             TRequestDiscriminator{
@@ -336,6 +376,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
 
     Y_UNIT_TEST(RequestTypeThrottler) {
         TTenantTestRuntime runtime(DefaultConsoleTestConfig());
+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down
+
+        TConfigUpdatesObserver updates(runtime);
         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());
         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);
         NKikimrConfig::TTracingConfig cfg;
@@ -345,7 +388,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
             rule->SetMaxTracesPerMinute(120);
             rule->MutableScope()->AddRequestTypes()->assign("KeyValue.ExecuteTransaction");
         }
+        Configure(runtime, cfg, 1);
         InitJaegerTracingConfigurator(runtime, std::move(configurator), cfg);
+        updates.Wait(); // Initial update
 
         for (size_t i = 0; i < 100; ++i) {
             auto [state, _] = controls.HandleTracing(false, {});
@@ -383,10 +428,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
             controls.HandleTracing(true, RandomChoice(executeTransactionDiscriminators)).first,
             TTracingControls::OFF);
 
-        WaitForUpdate(runtime); // Initial update
         cfg.MutableExternalThrottling(0)->SetMaxTracesPerMinute(10);
         cfg.MutableExternalThrottling(0)->SetMaxTracesBurst(2);
-        ConfigureAndWaitUpdate(runtime, cfg, 1);
+        ConfigureAndWaitUpdate(runtime, updates, cfg, 2);
 
         for (size_t i = 0; i < 3; ++i) {
             UNIT_ASSERT_EQUAL(
@@ -421,6 +465,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
 
     Y_UNIT_TEST(RequestTypeSampler) {
         TTenantTestRuntime runtime(DefaultConsoleTestConfig());
+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down
+
+        TConfigUpdatesObserver updates(runtime);
         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());
         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);
         NKikimrConfig::TTracingConfig cfg;
@@ -432,7 +479,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
             rule->SetLevel(10);
             rule->MutableScope()->AddRequestTypes()->assign("KeyValue.ExecuteTransaction");
         }
+        Configure(runtime, cfg, 1);
         InitJaegerTracingConfigurator(runtime, std::move(configurator), cfg);
+        updates.Wait(); // Initial update
 
         for (size_t i = 0; i < 1000; ++i) {
             auto [state, level] = controls.HandleTracing(false, {});
@@ -489,7 +538,6 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
         }
         timeProvider->Advance(TDuration::Seconds(10));
 
-        WaitForUpdate(runtime); // Initial update
         {
             auto& rule = *cfg.MutableSampling(0);
             rule.SetMaxTracesPerMinute(10);
@@ -498,7 +546,7 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
             rule.SetFraction(0.25);
             rule.MutableScope()->MutableRequestTypes(0)->assign("KeyValue.ReadRange");
         }
-        ConfigureAndWaitUpdate(runtime, cfg, 1);
+        ConfigureAndWaitUpdate(runtime, updates, cfg, 2);
 
         std::array readRangeDiscriminators{
             TRequestDiscriminator{
@@ -530,6 +578,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
 
     Y_UNIT_TEST(SamplingSameScope) {
         TTenantTestRuntime runtime(DefaultConsoleTestConfig());
+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down
+
+        TConfigUpdatesObserver updates(runtime);
         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());
         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);
         NKikimrConfig::TTracingConfig cfg;
@@ -547,7 +598,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
             rule->SetFraction(1. / 3);
             rule->SetLevel(10);
         }
+        Configure(runtime, cfg, 1);
         InitJaegerTracingConfigurator(runtime, std::move(configurator), cfg);
+        updates.Wait(); // Initial update
 
         {
             size_t level8 = 0;
@@ -593,6 +646,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
 
     Y_UNIT_TEST(ThrottlingByDb) {
         TTenantTestRuntime runtime(DefaultConsoleTestConfig());
+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down
+
+        TConfigUpdatesObserver updates(runtime);
         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());
         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);
         NKikimrConfig::TTracingConfig cfg;
@@ -602,7 +658,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
             rule->SetMaxTracesPerMinute(60);
             rule->MutableScope()->MutableDatabase()->assign("/Root/db1");
         }
+        Configure(runtime, cfg, 1);
         InitJaegerTracingConfigurator(runtime, std::move(configurator), cfg);
+        updates.Wait(); // Initial update
 
         std::array discriminators{
             TRequestDiscriminator{
@@ -637,8 +695,7 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
         }
 
         cfg.MutableExternalThrottling(0)->MutableScope()->AddRequestTypes()->assign("Table.ReadRows");
-        WaitForUpdate(runtime); // Initial update
-        ConfigureAndWaitUpdate(runtime, cfg, 1);
+        ConfigureAndWaitUpdate(runtime, updates, cfg, 2);
         timeProvider->Advance(TDuration::Minutes(1));
 
         {
@@ -681,6 +738,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
 
     Y_UNIT_TEST(SamplingByDb) {
         TTenantTestRuntime runtime(DefaultConsoleTestConfig());
+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down
+
+        TConfigUpdatesObserver updates(runtime);
         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());
         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);
         NKikimrConfig::TTracingConfig cfg;
@@ -692,7 +752,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
             rule->SetFraction(0.5);
             rule->MutableScope()->MutableDatabase()->assign("/Root/db1");
         }
+        Configure(runtime, cfg, 1);
         InitJaegerTracingConfigurator(runtime, std::move(configurator), cfg);
+        updates.Wait(); // Initial update
 
         std::array discriminators{
             TRequestDiscriminator{
@@ -732,8 +794,7 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
         }
 
         cfg.MutableSampling(0)->MutableScope()->AddRequestTypes()->assign("Table.ReadRows");
-        WaitForUpdate(runtime); // Initial update
-        ConfigureAndWaitUpdate(runtime, cfg, 1);
+        ConfigureAndWaitUpdate(runtime, updates, cfg, 2);
         timeProvider->Advance(TDuration::Minutes(1));
 
         {
@@ -780,6 +841,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
 
     Y_UNIT_TEST(SharedThrottlingLimits) {
         TTenantTestRuntime runtime(DefaultConsoleTestConfig());
+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down
+
+        TConfigUpdatesObserver updates(runtime);
         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());
         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);
         NKikimrConfig::TTracingConfig cfg;
@@ -792,7 +856,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
             scope->AddRequestTypes("Table.ReadRows");
             scope->AddRequestTypes("Table.AlterTable");
         }
+        Configure(runtime, cfg, 1);
         InitJaegerTracingConfigurator(runtime, std::move(configurator), cfg);
+        updates.Wait(); // Initial update
 
         std::array matchingDiscriminators{
             TRequestDiscriminator{
@@ -826,6 +892,7 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
 
     Y_UNIT_TEST(SharedSamplingLimits) {
         TTenantTestRuntime runtime(DefaultConsoleTestConfig());
+        TConfigUpdatesObserver updates(runtime);
         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());
         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);
         NKikimrConfig::TTracingConfig cfg;
@@ -840,7 +907,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {
             scope->AddRequestTypes("Table.ReadRows");
             scope->AddRequestTypes("Table.AlterTable");
         }
+        Configure(runtime, cfg, 1);
         InitJaegerTracingConfigurator(runtime, std::move(configurator), cfg);
+        updates.Wait(); // Initial update
 
         std::array matchingDiscriminators{
             TRequestDiscriminator{
diff --git a/ydb/core/cms/console/log_settings_configurator_ut.cpp b/ydb/core/cms/console/log_settings_configurator_ut.cpp
index a5ee661d74dc..06ec4fee08c6 100644
--- a/ydb/core/cms/console/log_settings_configurator_ut.cpp
+++ b/ydb/core/cms/console/log_settings_configurator_ut.cpp
@@ -164,35 +164,44 @@ void SetDefaultLogConfig(NKikimrConsole::TConfigItem &item)
     AddEntry(item, "CMS_CONFIGS", PRI_TRACE, Max<ui32>(), Max<ui32>());
 }
 
-void WaitForUpdate(TTenantTestRuntime &runtime)
-{
-    struct TIsConfigNotificationProcessed {
-        bool operator()(IEventHandle& ev)
-        {
-            if (ev.GetTypeRewrite() == NConsole::TEvConsole::EvConfigNotificationResponse) {
-                auto &rec = ev.Get<NConsole::TEvConsole::TEvConfigNotificationResponse>()->Record;
-                if (rec.GetConfigId().ItemIdsSize() != 1 || rec.GetConfigId().GetItemIds(0).GetId())
-                    return true;
-            }
-
-            return false;
-        }
-    };
+class TConfigUpdatesObserver {
+public:
+    TConfigUpdatesObserver(TTestActorRuntime& runtime)
+        : Runtime(runtime)
+        , Holder(Runtime.AddObserver<NConsole::TEvConsole::TEvConfigNotificationResponse>(
+            [this](auto& ev) {
+                auto& rec = ev->Get()->Record;
+                if (rec.GetConfigId().ItemIdsSize() != 1 || rec.GetConfigId().GetItemIds(0).GetId()) {
+                    ++Count;
+                }
+            }))
+    {}
+
+    void Clear() {
+        Count = 0;
+    }
 
-    TDispatchOptions options;
-    options.FinalEvents.emplace_back(TIsConfigNotificationProcessed(), 1);
-    runtime.DispatchEvents(options);
-}
+    void Wait() {
+        Runtime.WaitFor("config update", [this]{ return this->Count > 0; });
+        --Count;
+    }
+
+private:
+    TTestActorRuntime& Runtime;
+    TTestActorRuntime::TEventObserverHolder Holder;
+    size_t Count = 0;
+};
 
 template <typename ...Ts>
-void ConfigureAndWaitUpdate(TTenantTestRuntime &runtime,
+void ConfigureAndWaitUpdate(TTenantTestRuntime &runtime, TConfigUpdatesObserver &updates,
                             Ts... args)
 {
     auto *event = new TEvConsole::TEvConfigureRequest;
     CollectActions(event->Record, args...);
 
+    updates.Clear();
     runtime.SendToConsole(event);
-    WaitForUpdate(runtime);
+    updates.Wait();
 }
 
 void CompareSettings(TTenantTestRuntime &runtime,
@@ -234,11 +243,14 @@ Y_UNIT_TEST_SUITE(TLogSettingsConfiguratorTests)
     Y_UNIT_TEST(TestNoChanges)
     {
         TTenantTestRuntime runtime(DefaultConsoleTestConfig());
+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down
+
+        TConfigUpdatesObserver updates(runtime);
         auto settings = InitLogSettingsConfigurator(runtime);
-        WaitForUpdate(runtime); // initial update
+        updates.Wait(); // initial update
 
         SetDefaultLogConfig(ITEM_DOMAIN_LOG_1);
-        ConfigureAndWaitUpdate(runtime,
+        ConfigureAndWaitUpdate(runtime, updates,
                                MakeAddAction(ITEM_DOMAIN_LOG_1));
         CompareSettings(runtime, settings);
     }
@@ -246,14 +258,17 @@ Y_UNIT_TEST_SUITE(TLogSettingsConfiguratorTests)
     Y_UNIT_TEST(TestAddComponentEntries)
     {
         TTenantTestRuntime runtime(DefaultConsoleTestConfig());
+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down
+
+        TConfigUpdatesObserver updates(runtime);
         auto settings = InitLogSettingsConfigurator(runtime);
-        WaitForUpdate(runtime); // initial update
+        updates.Wait(); // initial update
 
         SetDefaultLogConfig(ITEM_DOMAIN_LOG_1);
         AddEntry(ITEM_DOMAIN_LOG_1, "CMS_CLUSTER", 5, Max<ui32>(), Max<ui32>());
         AddEntry(ITEM_DOMAIN_LOG_1, "CMS_CONFIGS", Max<ui32>(), 5, Max<ui32>());
         AddEntry(ITEM_DOMAIN_LOG_1, "CMS_TENANTS", Max<ui32>(), Max<ui32>(), 5);
-        ConfigureAndWaitUpdate(runtime,
+        ConfigureAndWaitUpdate(runtime, updates,
                                MakeAddAction(ITEM_DOMAIN_LOG_1));
         settings[NKikimrServices::CMS_CLUSTER].Raw.X.Level = 5;
         settings[NKikimrServices::CMS_CONFIGS].Raw.X.SamplingLevel = 5;
@@ -268,14 +283,17 @@ Y_UNIT_TEST_SUITE(TLogSettingsConfiguratorTests)
         label.SetName("tenant");
         label.SetValue(TENANT1_1_NAME);
         TTenantTestRuntime runtime(DefaultConsoleTestConfig(), ext);
+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down
+
+        TConfigUpdatesObserver updates(runtime);
         auto settings = InitLogSettingsConfigurator(runtime);
-        WaitForUpdate(runtime); // initial update
+        updates.Wait(); // initial update
 
         SetDefaultLogConfig(ITEM_DOMAIN_LOG_1);
         AddEntry(ITEM_TENANT1_LOG_1, "CMS_CLUSTER", 5, Max<ui32>(), Max<ui32>());
         AddEntry(ITEM_TENANT1_LOG_1, "CMS_CONFIGS", Max<ui32>(), 5, Max<ui32>());
         AddEntry(ITEM_TENANT1_LOG_1, "CMS_TENANTS", Max<ui32>(), Max<ui32>(), 5);
-        ConfigureAndWaitUpdate(runtime,
+        ConfigureAndWaitUpdate(runtime, updates,
                                MakeAddAction(ITEM_DOMAIN_LOG_1),
                                MakeAddAction(ITEM_TENANT1_LOG_1));
         settings[NKikimrServices::CMS_CLUSTER].Raw.X.Level = 5;
@@ -286,7 +304,7 @@ Y_UNIT_TEST_SUITE(TLogSettingsConfiguratorTests)
         auto ids = GetTenantItemIds(runtime, TENANT1_1_NAME);
         AssignIds(ids, ITEM_TENANT1_LOG_1);
 
-        ConfigureAndWaitUpdate(runtime,
+        ConfigureAndWaitUpdate(runtime, updates,
                                MakeRemoveAction(ITEM_TENANT1_LOG_1));
         settings[NKikimrServices::CMS_CLUSTER].Raw.X.Level = 4;
         settings[NKikimrServices::CMS_CONFIGS].Raw.X.SamplingLevel = 4;
@@ -301,12 +319,15 @@ Y_UNIT_TEST_SUITE(TLogSettingsConfiguratorTests)
         label.SetName("tenant");
         label.SetValue(TENANT1_1_NAME);
         TTenantTestRuntime runtime(DefaultConsoleTestConfig(), ext);
+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down
+
+        TConfigUpdatesObserver updates(runtime);
         auto settings = InitLogSettingsConfigurator(runtime);
-        WaitForUpdate(runtime); // initial update
+        updates.Wait(); // initial update
 
         SetDefaultLogConfig(ITEM_DOMAIN_LOG_1);
         SetDefaults(ITEM_TENANT1_LOG_1, PRI_ALERT, PRI_ALERT, 10);
-        ConfigureAndWaitUpdate(runtime,
+        ConfigureAndWaitUpdate(runtime, updates,
                                MakeAddAction(ITEM_DOMAIN_LOG_1),
                                MakeAddAction(ITEM_TENANT1_LOG_1));
         for (auto &set : settings)
diff --git a/ydb/core/mind/dynamic_nameserver.cpp b/ydb/core/mind/dynamic_nameserver.cpp
index 74d6d7df7639..e60315168c88 100644
--- a/ydb/core/mind/dynamic_nameserver.cpp
+++ b/ydb/core/mind/dynamic_nameserver.cpp
@@ -260,6 +260,7 @@ void TDynamicNameserver::Handle(TEvNodeWardenStorageConfig::TPtr ev) {
     const auto& config = *ev->Get()->Config;
 
     BridgeInfo = std::move(ev->Get()->BridgeInfo);
+    ListNodesCache->Invalidate();
 
     if (ev->Get()->SelfManagementEnabled) {
         // self-management through distconf is enabled and we are operating based on their tables, so apply them now
@@ -1010,7 +1011,13 @@ void TListNodesCache::Invalidate() {
 }
 
 bool TListNodesCache::NeedUpdate(TInstant now) const {
-    return Nodes == nullptr || now > Expire;
+    if (Nodes == nullptr || now > Expire) {
+        return true;
+    }
+    if (!PileMap && AppData()->BridgeModeEnabled) {
+        return true;
+    }
+    return false;
 }
 
 TIntrusiveVector<TEvInterconnect::TNodeInfo>::TConstPtr TListNodesCache::GetNodes() const {
diff --git a/ydb/core/mind/hive/hive_ut.cpp b/ydb/core/mind/hive/hive_ut.cpp
index 6cb391039f3a..a4ec41443759 100644
--- a/ydb/core/mind/hive/hive_ut.cpp
+++ b/ydb/core/mind/hive/hive_ut.cpp
@@ -1488,6 +1488,7 @@ Y_UNIT_TEST_SUITE(THiveTest) {
 
         ui32 nodeId = runtime.GetNodeId(0);
         {
+            runtime.SimulateSleep(TDuration::MilliSeconds(100));
             runtime.SendToPipe(hiveTablet, sender, new TEvHive::TEvDrainNode(nodeId));
             {
                 TDispatchOptions options;
@@ -1496,15 +1497,25 @@ Y_UNIT_TEST_SUITE(THiveTest) {
             }
             Ctest << "Register killer
";
             runtime.Register(CreateTabletKiller(hiveTablet));
+
             bool wasDedup = false;
             auto observerHolder = runtime.AddObserver<TEvHive::TEvDrainNodeResult>([&](auto&& event) {
                 if (event->Get()->Record.GetStatus() == NKikimrProto::EReplyStatus::ALREADY) {
                     wasDedup = true;
                 }
             });
-            while (!wasDedup) {
-                runtime.DispatchEvents({});
-            }
+
+            // Wait until domain hive retries drain
+            TBlockEvents<TEvHive::TEvDrainNode> blockedDrain(runtime);
+            runtime.WaitFor("drain retry", [&]{ return blockedDrain.size() >= 1; }, TDuration::Seconds(1));
+
+            // Let tenant hive finish its drain
+            runtime.SimulateSleep(TDuration::MilliSeconds(100));
+
+            // Unblock the drain retry
+            blockedDrain.Stop().Unblock();
+
+            runtime.WaitFor("dedup", [&]{ return wasDedup; }, TDuration::Seconds(1));
         }
     }
 
diff --git a/ydb/core/mind/node_broker_ut.cpp b/ydb/core/mind/node_broker_ut.cpp
index 41b6aa8d8378..f7afc8d854a4 100644
--- a/ydb/core/mind/node_broker_ut.cpp
+++ b/ydb/core/mind/node_broker_ut.cpp
@@ -905,6 +905,7 @@ void CheckAsyncResolveNode(TTestActorRuntime &runtime, ui32 nodeId, const TStrin
     UNIT_ASSERT(reply);
 
     UNIT_ASSERT_VALUES_EQUAL(reply->NodeId, nodeId);
+    UNIT_ASSERT(!reply->Addresses.empty());
     UNIT_ASSERT_VALUES_EQUAL(reply->Addresses[0].GetAddress(), addr);
 }
 
@@ -4608,10 +4609,25 @@ Y_UNIT_TEST_SUITE(TDynamicNameserverTest) {
         TVector<NKikimrNodeBroker::TResolveNode> resolveRequests;
 
         auto logRequests = [&](TAutoPtr<IEventHandle> &event) -> auto {
-            if (event->GetTypeRewrite() == TEvNodeBroker::EvListNodes)
-                listRequests.push_back(event->Get<TEvNodeBroker::TEvListNodes>()->Record);
-            else if (event->GetTypeRewrite() == TEvNodeBroker::EvResolveNode)
-                resolveRequests.push_back(event->Get<TEvNodeBroker::TEvResolveNode>()->Record);
+            switch (event->GetTypeRewrite()) {
+                case TEvInterconnect::EvListNodes:
+                    if (runtime.FindActorName(event->Sender) == "TABLET_RESOLVER_ACTOR") {
+                        // block TEvListNodes from tablet resolver
+                        return TTestActorRuntime::EEventAction::DROP;
+                    }
+                    break;
+
+                case TEvNodeBroker::EvListNodes:
+                    listRequests.push_back(event->Get<TEvNodeBroker::TEvListNodes>()->Record);
+                    break;
+
+                case TEvNodeBroker::EvResolveNode:
+                    resolveRequests.push_back(event->Get<TEvNodeBroker::TEvResolveNode>()->Record);
+                    break;
+
+                default:
+                    break;
+            }
             return TTestActorRuntime::EEventAction::PROCESS;
         };
 
@@ -4763,6 +4779,10 @@ Y_UNIT_TEST_SUITE(TDynamicNameserverTest) {
         runtime.WaitFor("cache miss", [&]{return resolveBlock.size() >= 1 || syncBlock.size() >= 1; });
 
         // Reboot NodeBroker to break pipe
+        TBlockEvents<TEvTabletPipe::TEvClientConnected> connectBlock(runtime,
+            [&](auto& ev) {
+                return runtime.FindActorName(ev->GetRecipientRewrite()) == "NAMESERVICE";
+            });
         RebootTablet(runtime, MakeNodeBrokerID(), sender);
 
         // Resolve request is failed, because pipe was broken
@@ -4772,6 +4792,7 @@ Y_UNIT_TEST_SUITE(TDynamicNameserverTest) {
         resolveBlock.Stop();
         syncBlock.Stop();
         deltaBlock.Stop();
+        connectBlock.Stop().Unblock();
 
         // The following requests should be OK
         CheckResolveNode(runtime, sender, NODE1, "1.2.3.4");
diff --git a/ydb/core/quoter/kesus_quoter_ut.cpp b/ydb/core/quoter/kesus_quoter_ut.cpp
index b8fe08efc47a..5f92e83c4daf 100644
--- a/ydb/core/quoter/kesus_quoter_ut.cpp
+++ b/ydb/core/quoter/kesus_quoter_ut.cpp
@@ -109,7 +109,7 @@ Y_UNIT_TEST_SUITE(QuoterWithKesusTest) {
         setup.GetQuota(TKesusQuoterTestSetup::DEFAULT_KESUS_PATH, TKesusQuoterTestSetup::DEFAULT_KESUS_RESOURCE);
 
         setup.GetClient().DeleteKesus(TKesusQuoterTestSetup::DEFAULT_KESUS_PARENT_PATH, TKesusQuoterTestSetup::DEFAULT_KESUS_NAME);
-        Sleep(TDuration::MilliSeconds(500)); // Wait for pipe disconnection, reconnection and passing info that old kesus was destroyed
+        Sleep(TDuration::MilliSeconds(2000)); // Wait for pipe disconnection, reconnection and passing info that old kesus was destroyed
         setup.GetClient().RefreshPathCache(setup.GetServer().GetRuntime(), TKesusQuoterTestSetup::DEFAULT_KESUS_PATH);
 
         setup.CreateDefaultKesusAndResource();
diff --git a/ydb/core/tablet/tablet_pipe_ut.cpp b/ydb/core/tablet/tablet_pipe_ut.cpp
index 1ba60fad825a..1e9c52d77b9c 100644
--- a/ydb/core/tablet/tablet_pipe_ut.cpp
+++ b/ydb/core/tablet/tablet_pipe_ut.cpp
@@ -1470,6 +1470,177 @@ Y_UNIT_TEST_SUITE(TTabletPipeTest) {
         UNIT_ASSERT_C(gen2 > gen1, "gen1: " << gen1 << ", gen2: " << gen2);
     }
 
+    Y_UNIT_TEST(TestPipeConnectAfterKillWithoutRetries) {
+        TTestBasicRuntime runtime(3);
+        // runtime.SetLogPriority(NKikimrServices::TABLET_RESOLVER, NActors::NLog::PRI_TRACE);
+        SetupTabletServices(runtime);
+
+        auto tablet1 = StartTestTablet(runtime,
+            CreateTestTabletInfo(TTestTxConfig::TxTablet0, TTabletTypes::Dummy),
+            [](const TActorId & tablet, TTabletStorageInfo* info) {
+                return new TTabletStuckOnStop(tablet, info);
+            },
+            1);
+
+        {
+            Cerr << "... waiting for boot1" << Endl;
+            TDispatchOptions options;
+            options.FinalEvents.push_back(TDispatchOptions::TFinalEventCondition(TEvTablet::EvBoot, 1));
+            runtime.DispatchEvents(options);
+        }
+
+        auto sender1 = runtime.AllocateEdgeActor();
+        auto client1 = runtime.Register(NTabletPipe::CreateClient(sender1, TTestTxConfig::TxTablet0, NTabletPipe::TClientConfig{
+            .RetryPolicy = NTabletPipe::TClientRetryPolicy::WithoutRetries(),
+        }));
+        Y_UNUSED(client1);
+
+        ui32 gen1;
+        {
+            Cerr << "... waiting for connect1" << Endl;
+            auto ev = runtime.GrabEdgeEvent<TEvTabletPipe::TEvClientConnected>(sender1);
+            UNIT_ASSERT(ev);
+            auto* msg = ev->Get();
+            UNIT_ASSERT_VALUES_EQUAL(msg->Status, NKikimrProto::OK);
+            gen1 = msg->Generation;
+        }
+
+        runtime.Send(client1, sender1, new TEvents::TEvPoison);
+        {
+            Cerr << "... waiting for client destroyed notification" << Endl;
+            auto ev = runtime.GrabEdgeEvent<TEvTabletPipe::TEvClientDestroyed>(sender1);
+            UNIT_ASSERT(ev);
+        }
+
+        runtime.Send(tablet1, TActorId(), new TEvents::TEvPoison);
+        runtime.SimulateSleep(TDuration::MilliSeconds(1));
+
+        StartTestTablet(runtime,
+            CreateTestTabletInfo(TTestTxConfig::TxTablet0, TTabletTypes::Dummy),
+            [](const TActorId & tablet, TTabletStorageInfo* info) {
+                return new TTabletStuckOnStop(tablet, info);
+            },
+            2);
+
+        {
+            Cerr << "... waiting for boot2" << Endl;
+            TDispatchOptions options;
+            options.FinalEvents.push_back(TDispatchOptions::TFinalEventCondition(TEvTablet::EvBoot, 1));
+            runtime.DispatchEvents(options);
+        }
+
+        auto sender2 = runtime.AllocateEdgeActor();
+        for (int i = 0; i < 30; ++i) {
+            // overload tablet resolver with unrelated queries
+            runtime.Send(new IEventHandle(MakeTabletResolverID(), TActorId(),
+                new TEvTabletResolver::TEvForward(TTestTxConfig::TxTablet0 + 1 + i, nullptr, {})));
+        }
+        auto client2 = runtime.Register(NTabletPipe::CreateClient(sender2, TTestTxConfig::TxTablet0, NTabletPipe::TClientConfig{
+            .RetryPolicy = NTabletPipe::TClientRetryPolicy::WithoutRetries(),
+        }));
+        Y_UNUSED(client2);
+
+        ui32 gen2;
+        {
+            Cerr << "... waiting for connect2" << Endl;
+            auto ev = runtime.GrabEdgeEvent<TEvTabletPipe::TEvClientConnected>(sender2);
+            UNIT_ASSERT(ev);
+            auto* msg = ev->Get();
+            UNIT_ASSERT_VALUES_EQUAL(msg->Status, NKikimrProto::OK);
+            gen2 = msg->Generation;
+        }
+
+        UNIT_ASSERT_C(gen2 > gen1, "gen1: " << gen1 << ", gen2: " << gen2);
+    }
+
+    Y_UNIT_TEST(TestPipeConnectLoopUnknownTabletWithoutRetries) {
+        TTestBasicRuntime runtime(3);
+        // runtime.SetLogPriority(NKikimrServices::STATESTORAGE, NActors::NLog::PRI_TRACE);
+        // runtime.SetLogPriority(NKikimrServices::TABLET_RESOLVER, NActors::NLog::PRI_TRACE);
+        SetupTabletServices(runtime);
+
+        auto ts1 = runtime.GetCurrentTime();
+        for (int i = 1; i <= 10; ++i) {
+            auto sender2 = runtime.AllocateEdgeActor();
+            auto client2 = runtime.Register(NTabletPipe::CreateClient(sender2, TTestTxConfig::TxTablet0, NTabletPipe::TClientConfig{
+                .RetryPolicy = NTabletPipe::TClientRetryPolicy::WithoutRetries(),
+            }));
+            Y_UNUSED(client2);
+            Cerr << "... waiting for connect" << i << Endl;
+            auto ev = runtime.GrabEdgeEvent<TEvTabletPipe::TEvClientConnected>(sender2);
+            UNIT_ASSERT(ev);
+            auto* msg = ev->Get();
+            UNIT_ASSERT_VALUES_EQUAL(msg->Status, NKikimrProto::ERROR);
+        }
+        auto ts2 = runtime.GetCurrentTime();
+        auto d = ts2 - ts1;
+
+        UNIT_ASSERT_C(d > TDuration::MilliSeconds(10), "10 connect attempts required " << d);
+    }
+
+    Y_UNIT_TEST(TestPipeConnectLoopLeaderDownWithoutRetries) {
+        TTestBasicRuntime runtime(3);
+        // runtime.SetLogPriority(NKikimrServices::STATESTORAGE, NActors::NLog::PRI_TRACE);
+        // runtime.SetLogPriority(NKikimrServices::TABLET_RESOLVER, NActors::NLog::PRI_TRACE);
+        SetupTabletServices(runtime);
+
+        auto tablet1 = StartTestTablet(runtime,
+            CreateTestTabletInfo(TTestTxConfig::TxTablet0, TTabletTypes::Dummy),
+            [](const TActorId & tablet, TTabletStorageInfo* info) {
+                return new TTabletStuckOnStop(tablet, info);
+            },
+            1);
+
+        {
+            Cerr << "... waiting for boot1" << Endl;
+            TDispatchOptions options;
+            options.FinalEvents.push_back(TDispatchOptions::TFinalEventCondition(TEvTablet::EvBoot, 1));
+            runtime.DispatchEvents(options);
+        }
+
+        auto sender1 = runtime.AllocateEdgeActor();
+        auto client1 = runtime.Register(NTabletPipe::CreateClient(sender1, TTestTxConfig::TxTablet0, NTabletPipe::TClientConfig{
+            .RetryPolicy = NTabletPipe::TClientRetryPolicy::WithoutRetries(),
+        }));
+        Y_UNUSED(client1);
+
+        {
+            Cerr << "... waiting for connect1" << Endl;
+            auto ev = runtime.GrabEdgeEvent<TEvTabletPipe::TEvClientConnected>(sender1);
+            UNIT_ASSERT(ev);
+            auto* msg = ev->Get();
+            UNIT_ASSERT_VALUES_EQUAL(msg->Status, NKikimrProto::OK);
+        }
+
+        runtime.Send(client1, sender1, new TEvents::TEvPoison);
+        {
+            Cerr << "... waiting for client destroyed notification" << Endl;
+            auto ev = runtime.GrabEdgeEvent<TEvTabletPipe::TEvClientDestroyed>(sender1);
+            UNIT_ASSERT(ev);
+        }
+
+        runtime.Send(tablet1, TActorId(), new TEvents::TEvPoison);
+        runtime.SimulateSleep(TDuration::MilliSeconds(1));
+
+        auto ts1 = runtime.GetCurrentTime();
+        for (int i = 2; i <= 11; ++i) {
+            auto sender2 = runtime.AllocateEdgeActor();
+            auto client2 = runtime.Register(NTabletPipe::CreateClient(sender2, TTestTxConfig::TxTablet0, NTabletPipe::TClientConfig{
+                .RetryPolicy = NTabletPipe::TClientRetryPolicy::WithoutRetries(),
+            }));
+            Y_UNUSED(client2);
+            Cerr << "... waiting for connect" << i << Endl;
+            auto ev = runtime.GrabEdgeEvent<TEvTabletPipe::TEvClientConnected>(sender2);
+            UNIT_ASSERT(ev);
+            auto* msg = ev->Get();
+            UNIT_ASSERT_VALUES_EQUAL(msg->Status, NKikimrProto::ERROR);
+        }
+        auto ts2 = runtime.GetCurrentTime();
+        auto d = ts2 - ts1;
+
+        UNIT_ASSERT_C(d > TDuration::MilliSeconds(10), "10 reconnect attempts required " << d);
+    }
+
 }
 
 }
diff --git a/ydb/core/tablet/tablet_resolver.cpp b/ydb/core/tablet/tablet_resolver.cpp
index c534fb994bda..0ecba7cafe7c 100644
--- a/ydb/core/tablet/tablet_resolver.cpp
+++ b/ydb/core/tablet/tablet_resolver.cpp
@@ -5,6 +5,10 @@
 #include <ydb/core/base/tabletid.h>
 #include <ydb/core/base/tablet.h>
 #include <ydb/core/base/appdata.h>
+#include <ydb/library/actors/async/async.h>
+#include <ydb/library/actors/async/cancellation.h>
+#include <ydb/library/actors/async/event.h>
+#include <ydb/library/actors/async/sleep.h>
 #include <ydb/library/actors/core/hfunc.h>
 #include <ydb/library/actors/core/log.h>
 #include <ydb/library/actors/core/interconnect.h>
@@ -19,49 +23,29 @@
 
 namespace NKikimr {
 
-const TDuration TabletResolverNegativeCacheTimeout = TDuration::MilliSeconds(300);
 const TDuration TabletResolverRefreshNodesPeriod = TDuration::Seconds(60);
 
+static constexpr ui32 TabletSuspectInstantRetryCount = 0;
+static constexpr TDuration TabletSuspectMinRetryDelay = TDuration::MilliSeconds(1);
+static constexpr TDuration TabletSuspectMaxRetryDelay = TDuration::MilliSeconds(50);
+
+static constexpr ui32 TabletSubscriptionInstantRetryCount = 1;
+static constexpr TDuration TabletSubscriptionMinRetryDelay = TDuration::MilliSeconds(1);
+static constexpr TDuration TabletSubscriptionMaxRetryDelay = TDuration::MilliSeconds(10);
+
+#define BLOG_TRACE(stream) LOG_TRACE_S(*TlsActivationContext, NKikimrServices::TABLET_RESOLVER, stream)
+#define BLOG_DEBUG(stream) LOG_DEBUG_S(*TlsActivationContext, NKikimrServices::TABLET_RESOLVER, stream)
+#define BLOG_INFO(stream) LOG_INFO_S(*TlsActivationContext, NKikimrServices::TABLET_RESOLVER, stream)
+#define BLOG_WARN(stream) LOG_WARN_S(*TlsActivationContext, NKikimrServices::TABLET_RESOLVER, stream)
+#define BLOG_ERROR(stream) LOG_ERROR_S(*TlsActivationContext, NKikimrServices::TABLET_RESOLVER, stream)
+
 class TTabletResolver : public TActorBootstrapped<TTabletResolver> {
     struct TEvPrivate {
         enum EEv {
-            EvPingTimeout = EventSpaceBegin(TEvents::ES_PRIVATE),
-            EvStopListRemoval,
-            EvRefreshNodes,
+            EvRefreshNodes = EventSpaceBegin(TEvents::ES_PRIVATE),
             EvEnd
         };
 
-        struct TEvPingTimeout : public TEventLocal<TEvPingTimeout, EvPingTimeout> {
-            const ui64 TabletID;
-            TSchedulerCookieHolder Cookie;
-
-            TEvPingTimeout(ui64 tabletId, ISchedulerCookie *cookie)
-                : TabletID(tabletId)
-                , Cookie(cookie)
-            {}
-
-            TString ToString() const {
-                TStringStream str;
-                str << "{EvPingTimeout TabletID: " << TabletID;
-                if (Cookie.Get()) {
-                    str << " Cookie: present";
-                }
-                else {
-                    str << " Cookie: nullptr";
-                }
-                str << "}";
-                return str.Str();
-            }
-        };
-
-        struct TEvStopListRemoval : public TEventLocal<TEvStopListRemoval, EvStopListRemoval> {
-            const ui64 TabletID;
-
-            TEvStopListRemoval(ui64 tabletId)
-                : TabletID(tabletId)
-            {}
-        };
-
         struct TEvRefreshNodes : public TEventLocal<TEvRefreshNodes, EvRefreshNodes> {
         };
 
@@ -69,24 +53,17 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {
     };
 
     struct TEntry {
-        enum EState {
-            StInit,
-            StInitResolve,
+        enum EState : ui8 {
+            StResolve,
             StNormal,
-            StProblemResolve,
-            StProblemPing,
-            StFollowerUpdate,
+            StRemove,
         };
 
         static const char* StateToString(EState state) {
             switch (state) {
-            case StInit: return "StInit";
-            case StInitResolve: return "StInitResolve";
+            case StResolve: return "StResolve";
             case StNormal: return "StNormal";
-            case StProblemResolve: return "StProblemResolve";
-            case StProblemPing: return "StProblemPing";
-            case StFollowerUpdate: return "StFollowerUpdate";
-            default: return "Unknown";
+            case StRemove: return "StRemove";
             }
         }
 
@@ -100,23 +77,36 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {
             {}
         };
 
-        EState State = StInit;
+        void MarkLeaderAlive() {
+            CurrentLeaderSuspect = false;
+            CurrentLeaderProblem = false;
+            CurrentLeaderProblemPermanent = false;
+        }
+
+        const ui64 TabletId;
+        EState State = StResolve;
+
+        bool InCache : 1 = false;
+        bool CurrentLeaderSuspect : 1 = false;
+        bool CurrentLeaderProblem : 1 = false;
+        bool CurrentLeaderProblemPermanent : 1 = false;
 
         TQueueInplace<TQueueEntry, 128> Queue;
         TActorId KnownLeader;
         TActorId KnownLeaderTablet;
 
-        TInstant LastResolved;
-        TInstant LastPing;
-
-        TSchedulerCookieHolder Cookie;
+        TMonotonic LastResolved;
 
         TVector<std::pair<TActorId, TActorId>> KnownFollowers;
 
         ui64 CacheEpoch = 0;
         ui64 LastCheckEpoch = 0;
 
-        TEntry() {}
+        TAsyncEvent Wakeup;
+
+        explicit TEntry(ui64 tabletId)
+            : TabletId(tabletId)
+        {}
     };
 
     struct TResolveInfo {
@@ -126,9 +116,9 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {
         ui32 NumLocal;
         ui32 NumLocalDc;
         ui32 NumOtherDc;
-        bool * NeedFollowerUpdate;
+        bool* NeedFollowerUpdate;
 
-        TResolveInfo(const TEvTabletResolver::TEvForward& msg, const TDuration& sinceResolve, bool * needFollowerUpdate)
+        TResolveInfo(const TEvTabletResolver::TEvForward& msg, const TDuration& sinceResolve, bool* needFollowerUpdate)
             : ResFlags(msg.ResolveFlags)
             , SinceLastResolve(sinceResolve)
             , NumLocal(0)
@@ -158,14 +148,76 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {
         }
     };
 
-    typedef NCache::TUnboundedCacheOnMap<ui64, TAutoPtr<TEntry>> TUnresolvedTablets;
-    typedef NCache::T2QCache<ui64, TAutoPtr<TEntry>> TResolvedTablets;
+    /**
+     * Allows local coroutines to receive supported events with a specific cookie
+     */
+    class TEventStream : public TIntrusiveListItem<TEventStream> {
+    public:
+        TEventStream(TTabletResolver* self, ui64 cookie)
+            : Self(self)
+            , Cookie(cookie)
+        {
+            Self->EventStreams[Cookie] = this;
+        }
+
+        ~TEventStream() {
+            Self->EventStreams.erase(Cookie);
+        }
+
+        async<IEventHandle::TPtr> Next() {
+            Y_ABORT_UNLESS(!NextEvent, "Unexpected event pending before Next()");
+            co_await ReceivedEvent.Wait();
+            // Note: NextEvent is nullptr on TEvNodeDisconnected
+            co_return std::move(NextEvent);
+        }
+
+        void OnConnect() {
+            Connected = true;
+        }
+
+        void OnEvent(IEventHandle::TPtr&& ev) {
+            Y_ABORT_UNLESS(ReceivedEvent.HasAwaiters(), "Nobody is waiting");
+            NextEvent = std::move(ev);
+            ReceivedEvent.NotifyOne();
+        }
+
+        void OnDisconnect() {
+            Y_ABORT_UNLESS(ReceivedEvent.HasAwaiters(), "Nobody is waiting");
+            Y_ABORT_UNLESS(!NextEvent, "Unexpected event pending in OnDisconnect()");
+            ReceivedEvent.NotifyOne();
+        }
+
+        bool HadConnect() const {
+            return Connected;
+        }
+
+    private:
+        TTabletResolver* const Self;
+        const ui64 Cookie;
+        IEventHandle::TPtr NextEvent;
+        TAsyncEvent ReceivedEvent;
+        bool Connected = false;
+    };
+
+    absl::flat_hash_map<ui64, TEventStream*> EventStreams;
+
+    struct TTabletStateSubscription {
+        TActorId ActorId;
+        ui64 TabletId = 0;
+        ui64 SeqNo = 0;
+        NKikimrTabletBase::TEvTabletStateUpdate::EState State = NKikimrTabletBase::TEvTabletStateUpdate::StateUnknown;
+        TAsyncCancellationScope Scope;
+    };
+
+    struct TInterconnectSession {
+        TIntrusiveList<TEventStream> EventStreams;
+    };
+
+    typedef NCache::T2QCache<ui64, TEntry*> TTabletCache;
 
     TIntrusivePtr<TTabletResolverConfig> Config;
-    TActorSystem* ActorSystem;
-    TUnresolvedTablets UnresolvedTablets;
-    TResolvedTablets ResolvedTablets;
-    THashSet<ui64> TabletsOnStopList;
+    THashMap<ui64, TEntry> Tablets;
+    TTabletCache TabletCache;
     THashMap<ui32, TString> NodeToDcMapping;
 
     THashMap<ui32, ui64> NodeProblems;
@@ -173,6 +225,10 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {
 
     ui64 LastCacheEpoch = 0;
 
+    THashMap<TActorId, TTabletStateSubscription> TabletStateSubscriptions;
+    THashMap<TActorId, TInterconnectSession> InterconnectSessions;
+    ui64 LastSeqNo = 0;
+
     ::NMonitoring::TDynamicCounters::TCounterPtr SelectedLeaderLocal;
     ::NMonitoring::TDynamicCounters::TCounterPtr SelectedLeaderLocalDc;
     ::NMonitoring::TDynamicCounters::TCounterPtr SelectedLeaderOtherDc;
@@ -190,21 +246,339 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {
         return it != NodeToDcMapping.end() ? std::make_optional(it->second) : std::nullopt;
     }
 
-    void ResolveRequest(ui64 tabletId, const TActorContext &ctx) {
-        const TActorId ssproxy = MakeStateStorageProxyID();
-        ctx.Send(ssproxy, new TEvStateStorage::TEvLookup(tabletId, 0), IEventHandle::FlagTrackDelivery, tabletId);
+    async<TEvStateStorage::TEvInfo::TPtr> LookupTablet(ui64 tabletId) {
+        const ui64 cookie = ++LastSeqNo;
+        const TActorId proxy = MakeStateStorageProxyID();
+        Send(proxy, new TEvStateStorage::TEvLookup(tabletId, 0), IEventHandle::FlagTrackDelivery, cookie);
 
         InFlyResolveCounter->Inc();
+        Y_DEFER { InFlyResolveCounter->Dec(); };
+
+        // We may receive either TEvStateStorage::TEvInfo or TEvUndelivered
+        TEventStream stream(this, cookie);
+        auto ev = co_await stream.Next();
+        Y_ABORT_UNLESS(ev); // local event cannot disconnect
+        switch (ev->GetTypeRewrite()) {
+            case TEvStateStorage::TEvInfo::EventType:
+                co_return std::move(reinterpret_cast<TEvStateStorage::TEvInfo::TPtr&>(ev));
+
+            case TEvents::TEvUndelivered::EventType:
+                co_return nullptr;
+
+            default:
+                Y_ABORT_S("Unexpected resolve reply " << Hex(ev->GetTypeRewrite()) << " " << ev->ToString());
+        }
     }
 
-    bool PushQueue(TEvTabletResolver::TEvForward::TPtr &ev, TEntry &entry, const TActorContext &ctx) {
-        entry.Queue.Emplace(ctx.Now(), std::move(ev));
-        return true;
+    void TabletResolveLoop(ui64 tabletId) {
+        TEntry& entry = Tablets.at(tabletId);
+        Y_ABORT_UNLESS(entry.State == TEntry::StResolve);
+
+        Y_DEFER {
+            TabletCache.Erase(tabletId);
+            Tablets.erase(tabletId);
+        };
+
+        Y_DEFER {
+            if (TlsActivationContext && entry.KnownLeader) {
+                UnsubscribeTabletState(entry.KnownLeader);
+            }
+        };
+
+        ui32 retryNumber = 0;
+        TDuration retryDelay;
+        for (;;) {
+            // On every iteration we make a new resolve request
+            Y_ABORT_UNLESS(entry.State == TEntry::StResolve,
+                "Unexpected entry.State: %s", TEntry::StateToString(entry.State));
+
+            if (retryDelay) {
+                TDuration delay = (entry.LastResolved + retryDelay) - TActivationContext::Monotonic();
+                if (delay) {
+                    BLOG_TRACE("TabletResolveLoop tabletId: " << tabletId
+                        << " sleeping for retry delay " << delay);
+                    co_await AsyncSleepFor(delay);
+                }
+            }
+
+            {
+                BLOG_TRACE("TabletResolveLoop tabletId: " << tabletId
+                        << " sending TEvLookup");
+                auto ev = co_await LookupTablet(tabletId);
+                if (!ev) {
+                    // StateStorage proxy is not configured on this node
+                    BLOG_INFO("TabletResolveLoop tabletId: " << tabletId
+                            << " StateStorage proxy not configured");
+                    SendQueuedError(entry, NKikimrProto::ERROR);
+                    break;
+                }
+
+                auto* msg = ev->Get();
+
+                BLOG_TRACE("TabletResolveLoop tabletId: " << tabletId
+                    << " received TEvInfo Status: " << msg->Status
+                    << " event: " << msg->ToString());
+
+                // This will handle errors and send replies
+                ApplyEntryInfo(entry, *msg);
+            }
+
+            if (!entry.InCache) {
+                // This entry was evicted while resolving, stop processing
+                BLOG_TRACE("TabletResolveLoop tabletId: " << tabletId
+                    << " processing stopped for an evicted entry");
+                break;
+            }
+
+            if (entry.KnownLeader && entry.CurrentLeaderSuspect && !entry.CurrentLeaderProblemPermanent) {
+                // Send a best-effort ping request to a suspicious leader
+                // Don't track delivery or node disconnections, since this is
+                // only needed when older stable versions don't support tablet
+                // state subscriptions.
+                // TODO(snaury): remove in 2026.
+                Send(entry.KnownLeader, new TEvTablet::TEvPing(tabletId, 0), 0, entry.CacheEpoch);
+            }
+
+            // Note: we move to StNormal and wait even when resolve fails, but
+            // any attempt to resolve leader will wake us up and we will retry
+            // with an appropriate delay when necessary.
+            entry.State = TEntry::StNormal;
+
+            // Wait until the next iteration
+            co_await entry.Wakeup.Wait();
+
+            if (!entry.InCache || entry.State == TEntry::StRemove) {
+                BLOG_TRACE("TabletResolveLoop tabletId: " << tabletId
+                    << " processing stopped for an evicted entry");
+                break;
+            }
+
+            // Don't overload state storage when leader is inaccessible
+            if (entry.CurrentLeaderSuspect && entry.CurrentLeaderProblem) {
+                if (++retryNumber <= TabletSuspectInstantRetryCount) {
+                    retryDelay = {};
+                } else if (!retryDelay) {
+                    retryDelay = TabletSuspectMinRetryDelay;
+                } else {
+                    retryDelay = Min(retryDelay * 2, TabletSuspectMaxRetryDelay);
+                }
+            } else {
+                retryNumber = 0;
+                retryDelay = {};
+            }
+        }
     }
 
-    std::pair<TActorId, TActorId> SelectForward(const TActorContext& ctx, const TEntry& entry, TResolveInfo& info, ui64 tabletId)
-    {
-        const ui32 selfNode = ctx.SelfID.NodeId();
+    void OnTabletAlive(ui64 tabletId, const TActorId& actorId) {
+        auto it = Tablets.find(tabletId);
+        if (it == Tablets.end()) {
+            return;
+        }
+
+        TEntry& entry = it->second;
+        if (entry.KnownLeader == actorId) {
+            // We just confirmed this leader is alive
+            entry.MarkLeaderAlive();
+        }
+    }
+
+    void OnTabletActive(ui64 tabletId, const TActorId& actorId, const TActorId& userActorId) {
+        auto it = Tablets.find(tabletId);
+        if (it == Tablets.end()) {
+            return;
+        }
+
+        TEntry& entry = it->second;
+        if (entry.KnownLeader == actorId) {
+            // When leader is active it implies it's alive
+            entry.MarkLeaderAlive();
+            if (!entry.KnownLeaderTablet) {
+                entry.KnownLeaderTablet = userActorId;
+            }
+            return;
+        }
+
+        for (auto& pr : entry.KnownFollowers) {
+            if (pr.first == actorId) {
+                if (!pr.second) {
+                    pr.second = userActorId;
+                }
+                break;
+            }
+        }
+    }
+
+    void OnTabletProblem(ui64 tabletId, const TActorId& actorId, bool permanent = false) {
+        auto it = Tablets.find(tabletId);
+        if (it == Tablets.end()) {
+            return;
+        }
+
+        TEntry& entry = it->second;
+        BLOG_TRACE("OnTabletProblem tabletId: " << tabletId << " actorId: " << actorId
+            << " entry.State: " << TEntry::StateToString(entry.State));
+
+        if (!actorId) {
+            // TEvTabletProblem without actorId is used for forced eviction
+            if (entry.State == TEntry::StNormal) {
+                entry.State = TEntry::StRemove;
+                entry.Wakeup.NotifyOne();
+            }
+            return;
+        }
+
+        if (entry.KnownLeader == actorId || entry.KnownLeaderTablet == actorId) {
+            BLOG_TRACE("OnTabletProblem tabletId: " << tabletId
+                << " marking leader " << entry.KnownLeader
+                << " with a" << (permanent ? " permanent" : "") << " problem");
+            entry.CurrentLeaderProblem = true;
+            if (permanent) {
+                entry.CurrentLeaderProblemPermanent = true;
+            }
+            // Note: we want to delay resolve until the next request
+            return;
+        }
+
+        for (auto it = entry.KnownFollowers.begin(), end = entry.KnownFollowers.end(); it != end; ++it) {
+            if (it->first == actorId || it->second == actorId) {
+                BLOG_TRACE("OnTabletProblem tabletId: " << tabletId
+                    << " removing follower " << it->first);
+                entry.KnownFollowers.erase(it);
+                if (entry.State == TEntry::StNormal) {
+                    entry.State = TEntry::StResolve;
+                    entry.Wakeup.NotifyOne();
+                }
+                break;
+            }
+        }
+    }
+
+    void TabletStateSubscriptionLoop(ui64 tabletId, TActorId actorId) {
+        Y_ABORT_UNLESS(!TabletStateSubscriptions.contains(actorId));
+        auto& subscription = TabletStateSubscriptions[actorId];
+        subscription.ActorId = actorId;
+        subscription.TabletId = tabletId;
+        Y_DEFER { TabletStateSubscriptions.erase(actorId); };
+
+        subscription.Scope = co_await TAsyncCancellationScope::WithCurrentHandler();
+
+        ui32 retryNumber = 0;
+        TDuration retryDelay;
+        for (;;) {
+            subscription.SeqNo = -1;
+            subscription.State = NKikimrTabletBase::TEvTabletStateUpdate::StateUnknown;
+
+            if (retryDelay) {
+                BLOG_TRACE("TabletStateSubscriptionLoop tabletId: " << tabletId << " actor: " << actorId
+                    << " sleeping for " << retryDelay);
+            }
+            // Note: this yields and checks for scope cancellation even when delay is zero
+            co_await AsyncSleepFor(retryDelay);
+
+            const ui64 seqNo = ++LastSeqNo;
+            subscription.SeqNo = seqNo;
+            ui32 flags = IEventHandle::FlagTrackDelivery;
+            if (actorId.NodeId() != SelfId().NodeId()) {
+                flags |= IEventHandle::FlagSubscribeOnSession;
+            }
+            BLOG_TRACE("TabletStateSubscriptionLoop tabletId: " << tabletId << " actor: " << actorId
+                    << " sending TEvTabletStateSubscribe seqNo=" << seqNo);
+            Send(actorId, new TEvTablet::TEvTabletStateSubscribe(tabletId, seqNo), flags, seqNo);
+
+            bool subscribed = true;
+            auto unsubscribe = [&]() {
+                if (subscribed) {
+                    BLOG_TRACE("TabletStateSubscriptionLoop tabletId: " << tabletId << " actor: " << actorId
+                        << " sending TEvTabletStateUnsubscribe seqNo=" << seqNo);
+                    Send(actorId, new TEvTablet::TEvTabletStateUnsubscribe(tabletId, seqNo));
+                    subscribed = false;
+                }
+            };
+
+            Y_DEFER {
+                // Note: don't unsubscribe during actor system shutdown
+                if (TlsActivationContext) {
+                    unsubscribe();
+                }
+            };
+
+            TEventStream stream(this, seqNo);
+            while (subscribed) {
+                auto ev = co_await stream.Next();
+                if (!ev) {
+                    // Node disconnected, start a new iteration
+                    subscribed = false;
+                    BLOG_TRACE("TabletStateSubscriptionLoop tabletId: " << tabletId << " actor: " << actorId
+                        << " node disconnected");
+                    OnTabletProblem(tabletId, actorId);
+                    break;
+                }
+
+                switch (ev->GetTypeRewrite()) {
+                    case TEvents::TEvUndelivered::EventType: {
+                        // Tablet actor doesn't exist (note: this will not be delivered after a disconnect)
+                        subscribed = false;
+                        BLOG_TRACE("TabletStateSubscriptionLoop tabletId: " << tabletId << " actor: " << actorId
+                            << " undelivered, assuming actor permanently unavailable");
+                        OnTabletProblem(tabletId, actorId, /* permanent */ true);
+                        co_return;
+                    }
+                    case TEvTablet::TEvTabletStateUpdate::EventType: {
+                        retryNumber = 0;
+                        auto* msg = ev->Get<TEvTablet::TEvTabletStateUpdate>();
+                        BLOG_TRACE("TabletStateSubscriptionLoop tabletId: " << tabletId << " actor: " << actorId
+                            << " received state update: " << msg->ToString());
+                        subscription.State = msg->Record.GetState();
+                        switch (subscription.State) {
+                            case NKikimrTabletBase::TEvTabletStateUpdate::StateTerminating:
+                            case NKikimrTabletBase::TEvTabletStateUpdate::StateDead:
+                                OnTabletProblem(tabletId, actorId, /* permanent */ true);
+                                unsubscribe();
+                                co_return;
+
+                            case NKikimrTabletBase::TEvTabletStateUpdate::StateActive:
+                                OnTabletActive(tabletId, actorId, msg->GetUserActorId());
+                                break;
+
+                            default:
+                                OnTabletAlive(tabletId, actorId);
+                                break;
+                        }
+                        break;
+                    }
+                    default: {
+                        Y_ABORT_S("Unexpected tablet state notification " << Hex(ev->GetTypeRewrite()) << " " << ev->ToString());
+                    }
+                }
+            }
+
+            // A small exponential backoff on retries: 0ms, 1ms, 2ms, 4ms, 8ms, 10ms
+            if (++retryNumber <= TabletSubscriptionInstantRetryCount) {
+                retryDelay = {};
+            } else if (!retryDelay) {
+                retryDelay = TabletSubscriptionMinRetryDelay;
+            } else {
+                retryDelay = Min(retryDelay * 2, TabletSubscriptionMaxRetryDelay);
+            }
+        }
+    }
+
+    void SubscribeTabletState(ui64 tabletId, const TActorId& actorId) {
+        if (!TabletStateSubscriptions.contains(actorId)) {
+            TabletStateSubscriptionLoop(tabletId, actorId);
+            Y_DEBUG_ABORT_UNLESS(TabletStateSubscriptions.contains(actorId));
+        }
+    }
+
+    void UnsubscribeTabletState(const TActorId& actorId) {
+        auto it = TabletStateSubscriptions.find(actorId);
+        if (it != TabletStateSubscriptions.end()) {
+            it->second.Scope.Cancel();
+        }
+    }
+
+    std::pair<TActorId, TActorId> SelectForward(const TEntry& entry, TResolveInfo& info, ui64 tabletId) {
+        const ui32 selfNode = SelfId().NodeId();
         const std::optional<TString> selfDc = FindNodeDc(selfNode);
         const std::optional<TString> leaderDc = FindNodeDc(entry.KnownLeader.NodeId());
 
@@ -231,7 +605,7 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {
             }
         };
 
-        bool countLeader = (entry.State == TEntry::StNormal || entry.State == TEntry::StFollowerUpdate);
+        bool countLeader = (entry.KnownLeader && !entry.CurrentLeaderProblem);
         if (countLeader) {
             bool isLocal = (entry.KnownLeader.NodeId() == selfNode);
             bool isLocalDc = selfDc && leaderDc == selfDc;
@@ -245,7 +619,7 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {
         }
 
         if (info.ResFlags.AllowFollower()) {
-            for (const auto &x : entry.KnownFollowers) {
+            for (const auto& x : entry.KnownFollowers) {
                 bool isLocal = (x.first.NodeId() == selfNode);
                 bool isLocalDc = selfDc && FindNodeDc(x.first.NodeId()) == selfDc;
                 info.Count(isLocal, isLocalDc);
@@ -261,18 +635,21 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {
         auto dcName = [](const std::optional<TString>& x) { return x ? x->data() : "<none>"; };
 
         if (!winners.empty()) {
-            size_t winnerIndex = (winners.size() == 1 ? 0 : (AppData(ctx)->RandomProvider->GenRand64() % winners.size()));
+            size_t winnerIndex = (winners.size() == 1 ? 0 : (AppData()->RandomProvider->GenRand64() % winners.size()));
             const TCandidate& winner = winners[winnerIndex];
 
-            LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER,
-                "SelectForward node %" PRIu32 " selfDC %s leaderDC %s %s"
-                " local %" PRIu32 " localDc %" PRIu32 " other %" PRIu32 " disallowed %" PRIu32
-                " tabletId: %" PRIu64 " followers: %" PRIu64 " countLeader %" PRIu32
-                " allowFollowers %" PRIu32 " winner: %s",
-                selfNode, dcName(selfDc), dcName(leaderDc), info.ResFlags.ToString().data(),
-                info.NumLocal, info.NumLocalDc, info.NumOtherDc, disallowed,
-                tabletId, entry.KnownFollowers.size(), countLeader, info.ResFlags.AllowFollower(),
-                winner.KnownLeader.ToString().c_str());
+            BLOG_DEBUG("SelectForward"
+                << " node " << selfNode
+                << " selfDC " << dcName(selfDc)
+                << " leaderDC " << dcName(leaderDc)
+                << " " << info.ResFlags.ToString()
+                << " local " << info.NumLocal << " localDc " << info.NumLocalDc << " other " << info.NumOtherDc
+                << " disallowed " << disallowed
+                << " tabletId: " << tabletId
+                << " followers: " << entry.KnownFollowers.size()
+                << " countLeader " << countLeader
+                << " allowFollowers " << info.ResFlags.AllowFollower()
+                << " winner: " << winner.KnownLeader);
 
             if (winner.IsLeader) {
                 if (winner.IsLocal)
@@ -293,25 +670,29 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {
             return std::make_pair(winner.KnownLeader, winner.KnownLeaderTablet);
         }
 
-        LOG_INFO(ctx, NKikimrServices::TABLET_RESOLVER,
-            "No candidates for SelectForward, node %" PRIu32 " selfDC %s leaderDC %s %s"
-            " local %" PRIu32 " localDc %" PRIu32 " other %" PRIu32 " disallowed %" PRIu32,
-            selfNode, dcName(selfDc), dcName(leaderDc), info.ResFlags.ToString().data(),
-            info.NumLocal, info.NumLocalDc, info.NumOtherDc, disallowed);
+        BLOG_INFO("No candidates for SelectForward,"
+            << " node " << selfNode
+            << " selfDC " << dcName(selfDc)
+            << " leaderDC " << dcName(leaderDc)
+            << " " << info.ResFlags.ToString()
+            << " local " << info.NumLocal
+            << " localDc " << info.NumLocalDc
+            << " other " << info.NumOtherDc
+            << " disallowed " << disallowed);
 
         SelectedNone->Inc();
 
         return std::make_pair(TActorId(), TActorId());
     }
 
-    bool SendForward(const TActorId &sender, const TEntry &entry, TEvTabletResolver::TEvForward *msg,
-                     const TActorContext &ctx, bool * needFollowerUpdate = nullptr) {
-        TResolveInfo info(*msg, ctx.Now() - entry.LastResolved, needFollowerUpdate); // fills needFollowerUpdate in dtor
-        const std::pair<TActorId, TActorId> endpoint = SelectForward(ctx, entry, info, msg->TabletID);
+    bool SendForward(const TActorId& sender, ui64 cookie, const TEntry& entry, TEvTabletResolver::TEvForward* msg,
+                     bool* needFollowerUpdate = nullptr) {
+        TResolveInfo info(*msg, TActivationContext::Monotonic() - entry.LastResolved, needFollowerUpdate); // fills needFollowerUpdate in dtor
+        const std::pair<TActorId, TActorId> endpoint = SelectForward(entry, info, msg->TabletID);
         if (endpoint.first) {
-            ctx.Send(sender, new TEvTabletResolver::TEvForwardResult(msg->TabletID, endpoint.second, endpoint.first, LastCacheEpoch));
+            Send(sender, new TEvTabletResolver::TEvForwardResult(msg->TabletID, endpoint.second, endpoint.first, LastCacheEpoch), 0, cookie);
             if (!!msg->Ev) {
-                ctx.Send(IEventHandle::Forward(std::move(msg->Ev), msg->SelectActor(endpoint.second, endpoint.first)));
+                Send(IEventHandle::Forward(std::move(msg->Ev), msg->SelectActor(endpoint.second, endpoint.first)));
             }
             return true;
         } else {
@@ -319,11 +700,16 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {
         }
     }
 
-    void SendQueued(ui64 tabletId, TEntry &entry, const TActorContext &ctx) {
+    bool PushQueue(TEntry& entry, TEvTabletResolver::TEvForward::TPtr& ev) {
+        entry.Queue.Emplace(TActivationContext::Now(), std::move(ev));
+        return true;
+    }
+
+    void SendQueued(TEntry& entry) {
         while (TEntry::TQueueEntry* x = entry.Queue.Head()) {
-            TEvTabletResolver::TEvForward *msg = x->Ev->Get();
-            if (!SendForward(x->Ev->Sender, entry, msg, ctx)) {
-                ctx.Send(x->Ev->Sender, new TEvTabletResolver::TEvForwardResult(NKikimrProto::ERROR, tabletId));
+            TEvTabletResolver::TEvForward* msg = x->Ev->Get();
+            if (!SendForward(x->Ev->Sender, x->Ev->Cookie, entry, msg)) {
+                Send(x->Ev->Sender, new TEvTabletResolver::TEvForwardResult(NKikimrProto::ERROR, entry.TabletId), 0, x->Ev->Cookie);
             }
             entry.Queue.Pop();
         }
@@ -331,476 +717,275 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {
         entry.Queue.Clear();
     }
 
-    void SendPing(ui64 tabletId, TEntry &entry, const TActorContext &ctx) {
-        ctx.Send(entry.KnownLeader, new TEvTablet::TEvPing(tabletId, 0), IEventHandle::FlagTrackDelivery, tabletId); // no subscribe for reason
-        entry.Cookie.Reset(ISchedulerCookie::Make3Way());
-
-        const TDuration timeout = TDuration::MilliSeconds(500);
-        ctx.Schedule(timeout, new TEvPrivate::TEvPingTimeout(tabletId, entry.Cookie.Get()), entry.Cookie.Get());
-    }
-
-    void ApplyEntryInfo(TEvStateStorage::TEvInfo& msg, TEntry &entry, const TActorContext &ctx) {
-        entry.KnownLeader = msg.CurrentLeader;
-        entry.KnownLeaderTablet = msg.CurrentLeaderTablet;
-        entry.LastResolved = ctx.Now();
-        entry.KnownFollowers = std::move(msg.Followers);
-        entry.CacheEpoch = ++LastCacheEpoch;
-
-        LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER,
-                  "ApplyEntry leader tabletId: %" PRIu64 " followers: %" PRIu64,
-                  msg.TabletID, entry.KnownFollowers.size());
-        SendQueued(msg.TabletID, entry, ctx);
-    }
-
-    void DropEntry(ui64 tabletId, TEntry& entry, bool cacheNegative, const TActorContext &ctx) {
-        LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER,
-                  "DropEntry tabletId: %" PRIu64 " followers: %" PRIu64,
-                  tabletId, entry.KnownFollowers.size());
+    void SendQueuedError(TEntry& entry, NKikimrProto::EReplyStatus status) {
         while (TEntry::TQueueEntry* x = entry.Queue.Head()) {
-            ctx.Send(x->Ev->Sender, new TEvTabletResolver::TEvForwardResult(NKikimrProto::ERROR, tabletId));
+            Send(x->Ev->Sender, new TEvTabletResolver::TEvForwardResult(status, entry.TabletId), 0, x->Ev->Cookie);
             entry.Queue.Pop();
         }
-        ResolvedTablets.Erase(tabletId);
-        UnresolvedTablets.Erase(tabletId);
-
-        if (TabletResolverNegativeCacheTimeout && cacheNegative) {
-            if (TabletsOnStopList.emplace(tabletId).second)
-                Schedule(TabletResolverNegativeCacheTimeout, new TEvPrivate::TEvStopListRemoval(tabletId));
-        }
-    }
-
-    void DropEntry(ui64 tabletId, TEntry& entry, const TActorContext &ctx) {
-        DropEntry(tabletId, entry, true, ctx);
+        // Free buffer memory
+        entry.Queue.Clear();
     }
 
-    TAutoPtr<TEntry>& GetEntry(ui64 tabletId, const TActorContext &ctx) {
-        TAutoPtr<TEntry>* entryPtr;
-        if (!ResolvedTablets.Find(tabletId, entryPtr)) {
-            if (!UnresolvedTablets.Find(tabletId, entryPtr)) {
-                ActorSystem = ctx.ActorSystem();
-                UnresolvedTablets.Insert(tabletId, TAutoPtr<TEntry>(new TEntry()), entryPtr);
+    void ApplyEntryInfo(TEntry& entry, TEvStateStorage::TEvInfo& msg) {
+        if (entry.KnownLeader != msg.CurrentLeader || !msg.CurrentLeader) {
+            if (entry.KnownLeader) {
+                UnsubscribeTabletState(entry.KnownLeader);
+            }
+            entry.KnownLeader = msg.CurrentLeader;
+            entry.KnownLeaderTablet = msg.CurrentLeaderTablet;
+            if (entry.KnownLeader) {
+                entry.MarkLeaderAlive();
+                if (entry.InCache) {
+                    SubscribeTabletState(entry.TabletId, entry.KnownLeader);
+                }
+            } else {
+                // Note: currently state storage will reply with an error when
+                // the leader is missing, but this code path will handle
+                // followers without a leader in the future.
+                entry.CurrentLeaderSuspect = true;
+                entry.CurrentLeaderProblem = true;
+                entry.CurrentLeaderProblemPermanent = true;
+            }
+        } else {
+            if (entry.CurrentLeaderProblem) {
+                entry.CurrentLeaderSuspect = true;
+            }
+            if (!entry.CurrentLeaderProblemPermanent) {
+                entry.CurrentLeaderProblem = false;
+            }
+            if (msg.CurrentLeaderTablet) {
+                entry.KnownLeaderTablet = msg.CurrentLeaderTablet;
             }
         }
 
-        return *entryPtr;
+        entry.KnownFollowers = std::move(msg.Followers);
+
+        entry.LastResolved = TActivationContext::Monotonic();
+        entry.CacheEpoch = ++LastCacheEpoch;
+
+        BLOG_DEBUG("ApplyEntry tabletId: " << msg.TabletID
+            << " leader: " << entry.KnownLeader
+            << " followers: " << entry.KnownFollowers.size());
+
+        if (msg.Status == NKikimrProto::OK || !entry.KnownFollowers.empty()) {
+            SendQueued(entry);
+        } else {
+            SendQueuedError(entry, NKikimrProto::ERROR);
+        }
     }
 
-    TAutoPtr<TEntry>* FindEntry(ui64 tabletId) {
-        TAutoPtr<TEntry>* entryPtr;
-        if (!ResolvedTablets.Find(tabletId, entryPtr)) {
-            if (!UnresolvedTablets.Find(tabletId, entryPtr)) {
-                return nullptr;
-            }
+    TEntry& GetEntry(ui64 tabletId) {
+        bool created = false;
+        auto it = Tablets.find(tabletId);
+        if (it == Tablets.end()) {
+            auto res = Tablets.emplace(
+                std::piecewise_construct,
+                std::forward_as_tuple(tabletId),
+                std::forward_as_tuple(tabletId));
+            it = res.first;
+            created = true;
         }
 
-        return entryPtr;
-    }
+        TEntry& entry = it->second;
+        if (created) {
+            TabletResolveLoop(tabletId);
+        }
 
-    void MoveEntryToResolved(ui64 tabletId, TAutoPtr<TEntry>& entry) {
-        TAutoPtr<TEntry>* resolvedEntryPtr;
-        Y_ABORT_UNLESS(ResolvedTablets.Insert(tabletId, entry, resolvedEntryPtr));
-        Y_ABORT_UNLESS(UnresolvedTablets.Erase(tabletId));
-    }
+        // Entry may be evicted while resolving, reinsert back into cache on additional hits
+        TEntry** ignored;
+        if (!entry.InCache) {
+            bool ok = TabletCache.Insert(tabletId, &entry, ignored);
+            Y_DEBUG_ABORT_UNLESS(ok, "Unexpected failure to reinsert previously evicted tablet");
+            entry.InCache = true;
+        } else {
+            bool ok = TabletCache.Find(tabletId, ignored);
+            Y_DEBUG_ABORT_UNLESS(ok, "Unexpected failure to find an unevicted tablet");
+        }
 
-    void MoveEntryToUnresolved(ui64 tabletId, TAutoPtr<TEntry>& entry) {
-        TAutoPtr<TEntry>* unresolvedEntryPtr;
-        Y_ABORT_UNLESS(UnresolvedTablets.Insert(tabletId, entry, unresolvedEntryPtr));
-        Y_ABORT_UNLESS(ResolvedTablets.Erase(tabletId));
+        return entry;
     }
 
-    void CheckDelayedNodeProblem(ui64 tabletId, const TActorContext &ctx) {
-        TAutoPtr<TEntry>* entryHolder = FindEntry(tabletId);
-        if (!entryHolder) {
+    void CheckDelayedNodeProblem(ui64 tabletId) {
+        auto it = Tablets.find(tabletId);
+        if (it == Tablets.end()) {
             return;
         }
 
-        TEntry &entry = *entryHolder->Get();
-
-        switch (entry.State) {
-        case TEntry::StNormal:
-        case TEntry::StFollowerUpdate:
-            if (entry.CacheEpoch < LastNodeProblemsUpdateEpoch && entry.LastCheckEpoch < LastNodeProblemsUpdateEpoch) {
-                entry.LastCheckEpoch = LastCacheEpoch;
+        TEntry& entry = it->second;
+        if (entry.CacheEpoch < LastNodeProblemsUpdateEpoch && entry.LastCheckEpoch < LastNodeProblemsUpdateEpoch) {
+            entry.LastCheckEpoch = LastCacheEpoch;
 
-                auto *pMaxProblemEpoch = NodeProblems.FindPtr(entry.KnownLeader.NodeId());
+            if (entry.State == TEntry::StNormal) {
+                auto* pMaxProblemEpoch = NodeProblems.FindPtr(entry.KnownLeader.NodeId());
                 if (pMaxProblemEpoch && entry.CacheEpoch <= *pMaxProblemEpoch) {
-                    LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER,
-                            "Delayed invalidation of tabletId: %" PRIu64
-                            " leader: %s by NodeId", tabletId, entry.KnownLeader.ToString().c_str());
-                    if (entry.KnownFollowers.empty()) {
-                        // Avoid resolving preemptively until the next request
-                        DropEntry(tabletId, entry, /* cacheNegative */ false, ctx);
-                        return;
-                    }
-                    ResolveRequest(tabletId, ctx);
-                    entry.State = TEntry::StProblemResolve;
-                    MoveEntryToUnresolved(tabletId, *entryHolder);
-                    return;
+                    BLOG_DEBUG("Delayed invalidation of tabletId: " << tabletId
+                        << " leader: " << entry.KnownLeader << " by nodeId");
+                    entry.CurrentLeaderProblem = true;
                 }
+            }
 
-                auto itDst = entry.KnownFollowers.begin();
-                auto itSrc = entry.KnownFollowers.begin();
-                while (itSrc != entry.KnownFollowers.end()) {
-                    pMaxProblemEpoch = NodeProblems.FindPtr(itSrc->first.NodeId());
-                    if (pMaxProblemEpoch && entry.CacheEpoch <= *pMaxProblemEpoch) {
-                        LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER,
-                            "Delayed invalidation of tabletId: %" PRIu64
-                            " follower: %s by nodeId", tabletId, itSrc->first.ToString().c_str());
-                        ++itSrc;
-                        continue;
-                    }
-                    if (itDst != itSrc) {
-                        *itDst = *itSrc;
-                    }
-                    ++itDst;
+            auto itDst = entry.KnownFollowers.begin();
+            auto itSrc = entry.KnownFollowers.begin();
+            while (itSrc != entry.KnownFollowers.end()) {
+                auto* pMaxProblemEpoch = NodeProblems.FindPtr(itSrc->first.NodeId());
+                if (pMaxProblemEpoch && entry.CacheEpoch <= *pMaxProblemEpoch) {
+                    BLOG_DEBUG("Delayed invalidation of tabletId: " << tabletId
+                        << " follower: " << itSrc->first << " by nodeId");
                     ++itSrc;
+                    continue;
                 }
-
                 if (itDst != itSrc) {
-                    entry.KnownFollowers.erase(itDst, itSrc);
-                    ResolveRequest(tabletId, ctx);
-                    entry.State = TEntry::StFollowerUpdate;
+                    *itDst = *itSrc;
+                }
+                ++itDst;
+                ++itSrc;
+            }
+            if (itDst != itSrc) {
+                entry.KnownFollowers.erase(itDst, itSrc);
+                if (entry.State == TEntry::StNormal) {
+                    entry.State = TEntry::StResolve;
+                    entry.Wakeup.NotifyOne();
                 }
             }
-            break;
-
-        default:
-            break;
         }
     }
 
-    void Handle(TEvTabletResolver::TEvForward::TPtr &ev, const TActorContext &ctx) {
-        TEvTabletResolver::TEvForward *msg = ev->Get();
+    void Handle(TEvTabletResolver::TEvForward::TPtr& ev) {
+        TEvTabletResolver::TEvForward* msg = ev->Get();
         const ui64 tabletId = msg->TabletID;
 
-        // allow some requests to bypass negative caching in low-load case
-        if (InFlyResolveCounter->Val() > 20 && TabletsOnStopList.contains(tabletId)) {
-            Send(ev->Sender, new TEvTabletResolver::TEvForwardResult(NKikimrProto::ERROR, tabletId));
-            return;
-        }
-
-        CheckDelayedNodeProblem(tabletId, ctx);
+        CheckDelayedNodeProblem(tabletId);
 
-        TAutoPtr<TEntry> &entryHolder = GetEntry(tabletId, ctx);
-        TEntry& entry = *entryHolder.Get();
-
-        LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER,
-                  "Handle TEvForward tabletId: %" PRIu64 " entry.State: %s ev: %s",
-                  tabletId, TEntry::StateToString(entry.State), msg->ToString().data());
-
-        switch (entry.State) {
-        case TEntry::StInit:
-            {
-                PushQueue(ev, entry, ctx);
-                ResolveRequest(tabletId, ctx);
-                entry.State = TEntry::StInitResolve;
-            }
-            break;
-        case TEntry::StInitResolve:
-            PushQueue(ev, entry, ctx);
-            break;
-        case TEntry::StNormal: {
-            bool needFollowerUpdate = false;
-            if (!SendForward(ev->Sender, entry, msg, ctx, &needFollowerUpdate)) {
-                PushQueue(ev, entry, ctx);
-                ResolveRequest(tabletId, ctx);
-                entry.State = TEntry::StFollowerUpdate;
-            }
-            if (needFollowerUpdate) {
-                ResolveRequest(tabletId, ctx);
-                entry.State = TEntry::StFollowerUpdate;
-            }
-            break;
-        }
-        case TEntry::StProblemResolve:
-        case TEntry::StProblemPing:
-            PushQueue(ev, entry, ctx);
-            break;
-        case TEntry::StFollowerUpdate:
-            if (!SendForward(ev->Sender, entry, msg, ctx))
-                PushQueue(ev, entry, ctx);
-            break;
-        default:
-            Y_ABORT();
-        }
-    }
-
-    void Handle(TEvTabletResolver::TEvTabletProblem::TPtr &ev, const TActorContext &ctx) {
-        TEvTabletResolver::TEvTabletProblem *msg = ev->Get();
-        const ui64 tabletId = msg->TabletID;
-
-        TAutoPtr<TEntry>* entryHolder = FindEntry(tabletId);
-        if (!entryHolder) {
-            LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, "Handle TEvTabletProblem tabletId: %" PRIu64
-                " no entyHolder", tabletId);
-            return;
-        }
-        TEntry &entry = *entryHolder->Get();
-
-        LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, "Handle TEvTabletProblem tabletId: %" PRIu64
-            " entry.State: %s", tabletId, TEntry::StateToString(entry.State));
+        TEntry& entry = GetEntry(tabletId);
+        BLOG_DEBUG("Handle TEvForward tabletId: " << tabletId
+                << " entry.State: " << TEntry::StateToString(entry.State)
+                << " leader: " << entry.KnownLeader
+                << (entry.CurrentLeaderProblem ? " (known problem)" : "")
+                << " followers: " << entry.KnownFollowers.size()
+                << " ev: " << msg->ToString());
 
         switch (entry.State) {
-        case TEntry::StInit:
-        case TEntry::StInitResolve:
-            break;
-        case TEntry::StNormal:
-            if (!msg->Actor || entry.KnownLeader == msg->Actor || entry.KnownLeaderTablet == msg->Actor) {
-                if (entry.KnownFollowers.empty()) {
-                    // Avoid resolving preemptively until the next request
-                    DropEntry(tabletId, entry, /* cacheNegative */ false, ctx);
-                    return;
+            case TEntry::StNormal: {
+                bool needUpdate = false;
+                if (!SendForward(ev->Sender, ev->Cookie, entry, msg, &needUpdate)) {
+                    PushQueue(entry, ev);
+                    needUpdate = true;
                 }
-                ResolveRequest(tabletId, ctx);
-                entry.State = TEntry::StProblemResolve;
-                MoveEntryToUnresolved(tabletId, *entryHolder);
-            } else {
-                // find in follower list
-                for (auto it = entry.KnownFollowers.begin(), end = entry.KnownFollowers.end(); it != end; ++it) {
-                    if (it->first == msg->Actor || it->second == msg->Actor) {
-                        entry.KnownFollowers.erase(it);
-                        ResolveRequest(tabletId, ctx);
-                        entry.State = TEntry::StFollowerUpdate;
-                        break;
-                    }
+                if (needUpdate) {
+                    entry.State = TEntry::StResolve;
+                    entry.Wakeup.NotifyOne();
                 }
-            }
-            break;
-        case TEntry::StFollowerUpdate:
-            if (!msg->Actor || entry.KnownLeader == msg->Actor || entry.KnownLeaderTablet == msg->Actor) {
-                // Reuse previously sent resolve request for StProblemResolve
-                entry.State = TEntry::StProblemResolve;
-                MoveEntryToUnresolved(tabletId, *entryHolder);
                 break;
             }
-            [[fallthrough]];
-        case TEntry::StProblemResolve:
-        case TEntry::StProblemPing:
-            for (auto it = entry.KnownFollowers.begin(), end = entry.KnownFollowers.end(); it != end; ++it) {
-                if (it->first == msg->Actor || it->second == msg->Actor) {
-                    entry.KnownFollowers.erase(it);
-                    break;
+            case TEntry::StResolve: {
+                // Try to handle requests even while resolving
+                if (entry.CacheEpoch == 0 || !SendForward(ev->Sender, ev->Cookie, entry, msg)) {
+                    PushQueue(entry, ev);
                 }
+                break;
+            }
+            case TEntry::StRemove: {
+                Y_ABORT("Unexpected StRemove state");
             }
-            break;
-        default:
-            Y_ABORT();
         }
     }
 
-    void Handle(TEvTabletResolver::TEvNodeProblem::TPtr &ev, const TActorContext &ctx) {
-        TEvTabletResolver::TEvNodeProblem *msg = ev->Get();
+    void Handle(TEvTabletResolver::TEvTabletProblem::TPtr& ev) {
+        TEvTabletResolver::TEvTabletProblem* msg = ev->Get();
+        const ui64 tabletId = msg->TabletID;
+
+        // Note: avoid promoting tablet entry in the cache
+        auto it = Tablets.find(tabletId);
+        if (it == Tablets.end()) {
+            BLOG_DEBUG("Handle TEvTabletProblem tabletId: " << tabletId << " not cached");
+            return;
+        }
+
+        TEntry& entry = it->second;
+        BLOG_DEBUG("Handle TEvTabletProblem tabletId: " << tabletId << " actor: " << msg->Actor
+            << " entry.State: " << TEntry::StateToString(entry.State));
+
+        OnTabletProblem(tabletId, msg->Actor, /* permanent */ false);
+    }
+
+    void Handle(TEvTabletResolver::TEvNodeProblem::TPtr& ev) {
+        TEvTabletResolver::TEvNodeProblem* msg = ev->Get();
         const ui32 nodeId = msg->NodeId;
         const ui64 problemEpoch = msg->CacheEpoch;
 
-        ui64 &maxProblemEpoch = NodeProblems[nodeId];
+        ui64& maxProblemEpoch = NodeProblems[nodeId];
         if (maxProblemEpoch < problemEpoch) {
-            LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, "Handle TEvNodeProblem nodeId: %" PRIu32
-                " max(problemEpoch): %" PRIu64, nodeId, problemEpoch);
+            BLOG_DEBUG("Handle TEvNodeProblem nodeId: " << nodeId
+                << " max(problemEpoch): " << problemEpoch);
             maxProblemEpoch = problemEpoch;
             LastNodeProblemsUpdateEpoch = ++LastCacheEpoch;
         } else {
-            LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, "Handle TEvNodeProblem nodeId: %" PRIu32
-                " problemEpoch: %" PRIu64 " <= max(problemEpoch): %" PRIu64,
-                nodeId, problemEpoch, maxProblemEpoch);
+            BLOG_DEBUG("Handle TEvNodeProblem nodeId: " << nodeId
+                << " problemEpoch: " << problemEpoch << " <= max(problemEpoch): " << maxProblemEpoch);
         }
     }
 
-    void Handle(TEvStateStorage::TEvInfo::TPtr &ev, const TActorContext &ctx) {
-        InFlyResolveCounter->Dec();
-
-        TEvStateStorage::TEvInfo *msg = ev->Get();
-        const ui64 tabletId = msg->TabletID;
-        const bool success = (msg->Status == NKikimrProto::OK); // todo: handle 'locked' state
-
-        TAutoPtr<TEntry>* entryHolder = FindEntry(tabletId);
-        if (!entryHolder) {
-            LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, "Handle TEvInfo tabletId: %" PRIu64 " no entryHolder",
-                tabletId);
-            return;
-        }
-        TEntry &entry = *entryHolder->Get();
-
-        LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, "Handle TEvInfo tabletId: %" PRIu64
-            " entry.State: %s success: %s ev: %s", tabletId, TEntry::StateToString(entry.State),
-            (success ? "true" : "false"), ev->GetBase()->ToString().data());
-
-        switch (entry.State) {
-        case TEntry::StInit:
-            Y_ABORT("must not happens");
-        case TEntry::StInitResolve:
-            if (success) {
-                if (msg->CurrentLeaderTablet) {
-                    entry.State = TEntry::StNormal;
-                    ApplyEntryInfo(*msg, entry, ctx);
-                    MoveEntryToResolved(tabletId, *entryHolder);
-                } else {
-                    // HACK: Don't cache invalid CurrentLeaderTablet
-                    // FIXME: Use subscription + cache here to reduce the workload
-                    ApplyEntryInfo(*msg, entry, ctx);
-                    DropEntry(tabletId, entry, ctx);
-                }
-            } else {
-                DropEntry(tabletId, entry, ctx);
-            }
-            break;
-        case TEntry::StFollowerUpdate:
-            if (success) {
-                if (msg->CurrentLeaderTablet) {
-                    entry.State = TEntry::StNormal;
-                    ApplyEntryInfo(*msg, entry, ctx);
-                } else {
-                    // HACK: Don't cache invalid CurrentLeaderTablet
-                    // FIXME: Use subscription + cache here to reduce the workload
-                    ApplyEntryInfo(*msg, entry, ctx);
-                    DropEntry(tabletId, entry, ctx);
-                }
-            } else {
-                DropEntry(tabletId, entry, ctx);
-            }
-            break;
-        case TEntry::StProblemResolve:
-            if (success) {
-                if (entry.KnownLeader == msg->CurrentLeader) {
-                    if (!(entry.KnownLeaderTablet == msg->CurrentLeaderTablet || !entry.KnownLeaderTablet)) {
-                        DropEntry(tabletId, entry, ctx); // got info but not full, occurs on transitional cluster states
-                    } else {
-                        entry.State = TEntry::StProblemPing;
-                        entry.KnownLeaderTablet = msg->CurrentLeaderTablet;
-                        entry.KnownFollowers = std::move(msg->Followers);
-                        SendPing(tabletId, entry, ctx);
-                    }
-                } else {
-                    if (msg->CurrentLeaderTablet) {
-                        entry.State = TEntry::StNormal;
-                        ApplyEntryInfo(*msg, entry, ctx);
-                        MoveEntryToResolved(tabletId, *entryHolder);
-                    } else {
-                        ApplyEntryInfo(*msg, entry, ctx);
-                        DropEntry(tabletId, entry, ctx);
-                    }
-                }
-            } else {
-                DropEntry(tabletId, entry, ctx);
-            }
-            break;
-        case TEntry::StProblemPing:
-        case TEntry::StNormal:
-            break;
-        default:
-            Y_ABORT();
-        }
-    }
+    void Handle(TEvTablet::TEvPong::TPtr& ev) {
+        auto* msg = ev->Get();
+        const ui64 tabletId = msg->Record.GetTabletID();
 
-    void Handle(TEvTablet::TEvPong::TPtr &ev, const TActorContext &ctx) {
-        NKikimrTabletBase::TEvPong &record = ev->Get()->Record;
-        const ui64 tabletId = record.GetTabletID();
+        BLOG_TRACE("Handle TEvPong tabletId: " << tabletId << " actor: " << ev->Sender << " cookie: " << ev->Cookie);
 
-        TAutoPtr<TEntry>* entryHolder = FindEntry(tabletId);
-        if (!entryHolder) {
-            LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, "Handle TEvPong tabletId: %" PRIu64 " no entryHolder",
-                tabletId);
+        auto it = Tablets.find(tabletId);
+        if (it == Tablets.end()) {
             return;
         }
-        TEntry &entry = *entryHolder->Get();
-
-        LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, "Handle TEvPong tabletId: %" PRIu64 " entry.State: %s",
-            tabletId, TEntry::StateToString(entry.State));
-
-        switch (entry.State) {
-        case TEntry::StInit:
-        case TEntry::StInitResolve:
-        case TEntry::StNormal:
-        case TEntry::StProblemResolve:
-        case TEntry::StFollowerUpdate:
-            break;
-        case TEntry::StProblemPing:
-            if (ev->Sender == entry.KnownLeader) {
-                entry.Cookie.Detach();
-                entry.State = TEntry::StNormal;
-                SendQueued(tabletId, entry, ctx);
-                MoveEntryToResolved(tabletId, *entryHolder);
-            }
-            break;
-        default:
-            Y_ABORT();
-        }
-    }
-
-    void Handle(TEvents::TEvUndelivered::TPtr &ev, const TActorContext &ctx) {
-        // cold be Ping or Initial Statestorage resolve
-        const ui64 tabletId = ev->Cookie;
-        TAutoPtr<TEntry>* entryHolder = FindEntry(tabletId);
-        if (!entryHolder)
-            return;
 
-        TEntry &entry = *entryHolder->Get();
-        if (ev->Get()->SourceType == TEvStateStorage::TEvLookup::EventType) {
-            InFlyResolveCounter->Dec();
-            DropEntry(tabletId, entry, ctx);
+        TEntry& entry = it->second;
+        if (ev->Sender != entry.KnownLeader || entry.CurrentLeaderProblemPermanent) {
             return;
         }
 
-        switch (entry.State) {
-        case TEntry::StInit:
-        case TEntry::StInitResolve:
-        case TEntry::StNormal:
-        case TEntry::StProblemResolve:
-        case TEntry::StFollowerUpdate:
-            break;
-        case TEntry::StProblemPing:
-            if (ev->Sender == entry.KnownLeader) {
-                DropEntry(tabletId, entry, ctx);
-            }
-            break;
-        default:
-            Y_ABORT();
+        if (ev->Cookie == 0 || ev->Cookie == entry.CacheEpoch) {
+            // We have confirmed this tablet instance was alive in the current cache epoch
+            // Note: older versions don't relay request cookie and it will always be zero
+            entry.MarkLeaderAlive();
         }
     }
 
-    void Handle(TEvPrivate::TEvPingTimeout::TPtr &ev, const TActorContext &ctx) {
-        TEvPrivate::TEvPingTimeout *msg = ev->Get();
-        const ui64 tabletId = msg->TabletID;
+    void Handle(TEvInterconnect::TEvNodeConnected::TPtr& ev) {
+        auto& session = InterconnectSessions[ev->Sender];
 
-        TAutoPtr<TEntry>* entryHolder = FindEntry(tabletId);
-        if (!entryHolder) {
-            LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, "Handle TEvPingTimeout tabletId: %" PRIu64
-                " no entryHolder", tabletId);
-            return;
+        auto it = EventStreams.find(ev->Cookie);
+        if (it != EventStreams.end()) {
+            session.EventStreams.PushBack(it->second);
+            it->second->OnConnect();
         }
-        TEntry &entry = *entryHolder->Get();
-
-        LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, "Handle TEvPingTimeout tabletId: %" PRIu64 " entry.State: %s",
-            tabletId, TEntry::StateToString(entry.State));
+    }
 
-        switch (entry.State) {
-        case TEntry::StInit:
-        case TEntry::StInitResolve:
-        case TEntry::StNormal:
-        case TEntry::StProblemResolve:
-        case TEntry::StFollowerUpdate:
-            break;
-        case TEntry::StProblemPing:
-            if (msg->Cookie.DetachEvent()) {
-                DropEntry(tabletId, entry, ctx);
+    void Handle(TEvInterconnect::TEvNodeDisconnected::TPtr& ev) {
+        auto itSession = InterconnectSessions.find(ev->Sender);
+        if (itSession != InterconnectSessions.end()) {
+            auto& session = itSession->second;
+            while (!session.EventStreams.Empty()) {
+                auto* stream = session.EventStreams.PopFront();
+                stream->OnDisconnect();
             }
-            break;
-        default:
-            Y_ABORT();
+            InterconnectSessions.erase(itSession);
         }
-    }
 
-    void Handle(TEvPrivate::TEvStopListRemoval::TPtr &ev, const TActorContext &) {
-        TEvPrivate::TEvStopListRemoval *msg = ev->Get();
-        TabletsOnStopList.erase(msg->TabletID);
+        auto it = EventStreams.find(ev->Cookie);
+        if (it != EventStreams.end() && !it->second->HadConnect()) {
+            it->second->OnDisconnect();
+        }
     }
 
-    void Handle(TEvInterconnect::TEvNodesInfo::TPtr &ev, const TActorContext &ctx) {
-        Y_UNUSED(ctx);
+    void HandleStream(IEventHandle::TPtr& ev) {
+        auto it = EventStreams.find(ev->Cookie);
+        if (it != EventStreams.end()) {
+            it->second->OnEvent(std::move(ev));
+        }
+    }
 
-        const TEvInterconnect::TEvNodesInfo *msg = ev->Get();
+    void Handle(TEvInterconnect::TEvNodesInfo::TPtr& ev) {
+        const TEvInterconnect::TEvNodesInfo* msg = ev->Get();
         bool distinct = false;
-        for (const auto &nodeInfo : msg->Nodes) {
+        for (const auto& nodeInfo : msg->Nodes) {
             if (nodeInfo.Location.GetDataCenterId() != msg->Nodes[0].Location.GetDataCenterId())
                 distinct = true;
             NodeToDcMapping[nodeInfo.NodeId] = nodeInfo.Location.GetDataCenterId();
@@ -809,15 +994,23 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {
         if (!distinct)
             NodeToDcMapping.clear();
 
-        ctx.Schedule(TabletResolverRefreshNodesPeriod, new TEvPrivate::TEvRefreshNodes);
+        Schedule(TabletResolverRefreshNodesPeriod, new TEvPrivate::TEvRefreshNodes);
+    }
+
+    void Handle(TEvPrivate::TEvRefreshNodes::TPtr&) {
+        RefreshNodes();
     }
 
-    void Handle(TEvPrivate::TEvRefreshNodes::TPtr &, const TActorContext &ctx) {
-        RefreshNodes(ctx);
+    void RefreshNodes() {
+        Send(GetNameserviceActorId(), new TEvInterconnect::TEvListNodes());
     }
 
-    void RefreshNodes(const TActorContext &ctx) {
-        ctx.Send(GetNameserviceActorId(), new TEvInterconnect::TEvListNodes());
+    void OnEvictEntry(TEntry& entry) {
+        entry.InCache = false;
+        if (entry.State == TEntry::StNormal) {
+            entry.State = TEntry::StRemove;
+            entry.Wakeup.NotifyOne();
+        }
     }
 
 public:
@@ -825,35 +1018,34 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {
         return NKikimrServices::TActivity::TABLET_RESOLVER_ACTOR;
     }
 
-    TTabletResolver(const TIntrusivePtr<TTabletResolverConfig> &config)
+    TTabletResolver(const TIntrusivePtr<TTabletResolverConfig>& config)
         : Config(config)
-        , ActorSystem(nullptr)
-        , ResolvedTablets(new NCache::T2QCacheConfig())
+        , TabletCache(new NCache::T2QCacheConfig())
     {
-        ResolvedTablets.SetOverflowCallback([=, this](const NCache::ICache<ui64, TAutoPtr<TEntry>>& cache) {
+        TabletCache.SetOverflowCallback([this](const NCache::ICache<ui64, TEntry*>& cache) {
             return cache.GetUsedSize() >= Config->TabletCacheLimit;
         });
 
-        ResolvedTablets.SetEvictionCallback([&](const ui64& key, TAutoPtr<TEntry>& value, ui64 size) {
+        TabletCache.SetEvictionCallback([this](const ui64& key, TEntry*& value, ui64 size) {
+            Y_UNUSED(key);
             Y_UNUSED(size);
 
-            if (!value)
+            if (!value) {
+                // Moved from, but not erased?
                 return;
-
-            auto& queue = value->Queue;
-            while (TEntry::TQueueEntry* x = queue.Head()) {
-                ActorSystem->Send(x->Ev->Sender, new TEvTabletResolver::TEvForwardResult(NKikimrProto::RACE, key));
-                queue.Pop();
             }
+
+            OnEvictEntry(*value);
         });
     }
 
     ~TTabletResolver() {
-        ResolvedTablets.SetEvictionCallback(&TResolvedTablets::DefaultEvictionCallback);
+        TabletCache.SetEvictionCallback(&TTabletCache::DefaultEvictionCallback);
+        TabletCache.SetOverflowCallback(&TTabletCache::DefaultOverflowCallback);
     }
 
-    void Bootstrap(const TActorContext &ctx) {
-        RefreshNodes(ctx);
+    void Bootstrap() {
+        RefreshNodes();
         Become(&TThis::StateWork);
 
         auto tablets = GetServiceCounters(AppData()->Counters, "tablets");
@@ -871,25 +1063,25 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {
 
     STFUNC(StateWork) {
         switch (ev->GetTypeRewrite()) {
-            HFunc(TEvTabletResolver::TEvForward, Handle);
-            HFunc(TEvTabletResolver::TEvTabletProblem, Handle);
-            HFunc(TEvTabletResolver::TEvNodeProblem, Handle);
-            HFunc(TEvStateStorage::TEvInfo, Handle);
-            HFunc(TEvTablet::TEvPong, Handle);
-            HFunc(TEvPrivate::TEvPingTimeout, Handle);
-            HFunc(TEvPrivate::TEvStopListRemoval, Handle);
-            HFunc(TEvInterconnect::TEvNodesInfo, Handle);
-            HFunc(TEvPrivate::TEvRefreshNodes, Handle);
-            HFunc(TEvents::TEvUndelivered, Handle);
+            hFunc(TEvTabletResolver::TEvForward, Handle);
+            hFunc(TEvTabletResolver::TEvTabletProblem, Handle);
+            hFunc(TEvTabletResolver::TEvNodeProblem, Handle);
+            hFunc(TEvTablet::TEvPong, Handle);
+            hFunc(TEvInterconnect::TEvNodeConnected, Handle);
+            hFunc(TEvInterconnect::TEvNodeDisconnected, Handle);
+            fFunc(TEvStateStorage::TEvInfo::EventType, HandleStream);
+            fFunc(TEvTablet::TEvTabletStateUpdate::EventType, HandleStream);
+            fFunc(TEvents::TEvUndelivered::EventType, HandleStream);
+            hFunc(TEvInterconnect::TEvNodesInfo, Handle);
+            hFunc(TEvPrivate::TEvRefreshNodes, Handle);
             default:
-                LOG_WARN(*TlsActivationContext, NKikimrServices::TABLET_RESOLVER, "TTabletResolver::StateWork unexpected event type: %" PRIx32
-                    " event: %s", ev->GetTypeRewrite(), ev->ToString().data());
+                BLOG_WARN("TTabletResolver::StateWork unexpected event type: " << Hex(ev->GetTypeRewrite()) << " event: " << ev->ToString());
                 break;
         }
     }
 };
 
-IActor* CreateTabletResolver(const TIntrusivePtr<TTabletResolverConfig> &config) {
+IActor* CreateTabletResolver(const TIntrusivePtr<TTabletResolverConfig>& config) {
     return new TTabletResolver(config);
 }
 
diff --git a/ydb/core/tablet/tablet_sys.cpp b/ydb/core/tablet/tablet_sys.cpp
index e1800cf7a1f5..b41c8655c43c 100644
--- a/ydb/core/tablet/tablet_sys.cpp
+++ b/ydb/core/tablet/tablet_sys.cpp
@@ -305,13 +305,13 @@ void TTablet::HandlePingBoot(TEvTablet::TEvPing::TPtr &ev) {
     // todo: handle wait-boot flag
     NKikimrTabletBase::TEvPing &record = ev->Get()->Record;
     Y_ABORT_UNLESS(record.GetTabletID() == TabletID());
-    Send(ev->Sender, new TEvTablet::TEvPong(TabletID(), TEvTablet::TEvPong::FlagBoot | TEvTablet::TEvPong::FlagLeader));
+    Send(ev->Sender, new TEvTablet::TEvPong(TabletID(), TEvTablet::TEvPong::FlagBoot | TEvTablet::TEvPong::FlagLeader), 0, ev->Cookie);
 }
 
 void TTablet::HandlePingFollower(TEvTablet::TEvPing::TPtr &ev) {
     NKikimrTabletBase::TEvPing &record = ev->Get()->Record;
     Y_ABORT_UNLESS(record.GetTabletID() == TabletID());
-    Send(ev->Sender, new TEvTablet::TEvPong(TabletID(), TEvTablet::TEvPong::FlagFollower));
+    Send(ev->Sender, new TEvTablet::TEvPong(TabletID(), TEvTablet::TEvPong::FlagFollower), 0, ev->Cookie);
 }
 
 void TTablet::HandleStateStorageLeaderResolve(TEvStateStorage::TEvInfo::TPtr &ev) {
@@ -1063,7 +1063,7 @@ void TTablet::HandleWriteZeroEntry(TEvTabletBase::TEvWriteLogResult::TPtr &ev) {
 void TTablet::Handle(TEvTablet::TEvPing::TPtr &ev) {
     NKikimrTabletBase::TEvPing &record = ev->Get()->Record;
     Y_ABORT_UNLESS(record.GetTabletID() == TabletID());
-    Send(ev->Sender, new TEvTablet::TEvPong(TabletID(), TEvTablet::TEvPong::FlagLeader));
+    Send(ev->Sender, new TEvTablet::TEvPong(TabletID(), TEvTablet::TEvPong::FlagLeader), 0, ev->Cookie);
 }
 
 void TTablet::HandleByLeader(TEvTablet::TEvTabletActive::TPtr &ev) {
diff --git a/ydb/core/tablet/ya.make b/ydb/core/tablet/ya.make
index a9979cc56375..c1586e88a35d 100644
--- a/ydb/core/tablet/ya.make
+++ b/ydb/core/tablet/ya.make
@@ -58,6 +58,7 @@ SRCS(
 )
 
 PEERDIR(
+    ydb/library/actors/async
     ydb/library/actors/core
     ydb/library/actors/helpers
     ydb/library/actors/protos
