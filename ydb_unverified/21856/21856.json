{
  "repo": "ydb-platform/ydb",
  "pull_number": 21856,
  "instance_id": "ydb-platform__ydb-21856",
  "issue_numbers": [
    "21053"
  ],
  "base_commit": "0b506f56e399e0b4e6a6a4267799da68a3164bf7",
  "patch": "diff --git a/ydb/core/cms/cms_ut.cpp b/ydb/core/cms/cms_ut.cpp\nindex 132f666844b0..48215541e37c 100644\n--- a/ydb/core/cms/cms_ut.cpp\n+++ b/ydb/core/cms/cms_ut.cpp\n@@ -2484,7 +2484,7 @@ Y_UNIT_TEST_SUITE(TCmsTest) {\n         // Pile #1: There are 0 rings locked on this pile => it is possible to lock.\n         env.CheckPermissionRequest(\"user\", true, false, true, true, MODE_MAX_AVAILABILITY, TStatus::ALLOW,\n                                     MakeAction(TAction::RESTART_SERVICES, env.GetNodeId(0), 60000000, \"storage\"));\n-        // Pile #0: There are 0 rings locked on this pile => it is possible to lock.                            \n+        // Pile #0: There are 0 rings locked on this pile => it is possible to lock.\n         env.CheckPermissionRequest(\"user\", true, false, true, true, MODE_MAX_AVAILABILITY, TStatus::ALLOW,\n                                     MakeAction(TAction::RESTART_SERVICES, env.GetNodeId(1), 60000000, \"storage\"));\n         // Pile #1: There is already one ring locked on this pile => it is not possible to lock.\ndiff --git a/ydb/core/cms/cms_ut_common.cpp b/ydb/core/cms/cms_ut_common.cpp\nindex 271f4f42b2ba..7b76ddb88744 100644\n--- a/ydb/core/cms/cms_ut_common.cpp\n+++ b/ydb/core/cms/cms_ut_common.cpp\n@@ -586,10 +586,12 @@ static void SetupServices(TTestBasicRuntime &runtime, const TTestEnvOpts &option\n     runtime.GetAppData().BootstrapConfig = TFakeNodeWhiteboardService::BootstrapConfig;\n     \n     if (options.IsBridgeMode) {\n-        for (ui32 pileId = 0; pileId < options.PileCount; ++pileId) {\n-            runtime.GetAppData().BridgeConfig.AddPiles()->SetName(\"r\" + ToString(pileId));\n+        for (ui32 nodeIndex = 0; nodeIndex < runtime.GetNodeCount(); ++nodeIndex) {\n+            for (ui32 pileId = 0; pileId < options.PileCount; ++pileId) {\n+                runtime.GetAppData(nodeIndex).BridgeConfig.AddPiles()->SetName(\"r\" + ToString(pileId));\n+            }\n+            runtime.GetAppData(nodeIndex).BridgeModeEnabled = true;\n         }\n-        runtime.GetAppData().BridgeModeEnabled = true;\n     }\n \n     NKikimrCms::TCmsConfig cmsConfig;\n@@ -680,6 +682,9 @@ TCmsTestEnv::TCmsTestEnv(const TTestEnvOpts &options)\n     Sender = AllocateEdgeActor();\n     ClientId = TActorId();\n \n+    // Make sure default empty configs are handled first\n+    SimulateSleep(TDuration::MilliSeconds(100));\n+\n     NKikimrCms::TCmsConfig cmsConfig;\n     cmsConfig.MutableTenantLimits()->SetDisabledNodesRatioLimit(0);\n     cmsConfig.MutableClusterLimits()->SetDisabledNodesRatioLimit(0);\ndiff --git a/ydb/core/cms/console/feature_flags_configurator_ut.cpp b/ydb/core/cms/console/feature_flags_configurator_ut.cpp\nindex 9618a42d9f1b..a87fc03e2543 100644\n--- a/ydb/core/cms/console/feature_flags_configurator_ut.cpp\n+++ b/ydb/core/cms/console/feature_flags_configurator_ut.cpp\n@@ -86,33 +86,46 @@ void InitFeatureFlagsConfigurator(TTenantTestRuntime& runtime) {\n     runtime.DispatchEvents(options);\n }\n \n-void WaitForUpdate(TTenantTestRuntime& runtime) {\n-    struct TIsConfigNotificationProcessed {\n-        bool operator()(IEventHandle& ev) {\n-            if (ev.GetTypeRewrite() == NConsole::TEvConsole::EvConfigNotificationResponse) {\n-                auto& rec = ev.Get<NConsole::TEvConsole::TEvConfigNotificationResponse>()->Record;\n-                if (rec.GetConfigId().ItemIdsSize() != 1 || rec.GetConfigId().GetItemIds(0).GetId())\n-                    return true;\n-            }\n-\n-            return false;\n-        }\n-    };\n+class TConfigUpdatesObserver {\n+public:\n+    TConfigUpdatesObserver(TTestActorRuntime& runtime)\n+        : Runtime(runtime)\n+        , Holder(Runtime.AddObserver<NConsole::TEvConsole::TEvConfigNotificationResponse>(\n+            [this](auto& ev) {\n+                auto& rec = ev->Get()->Record;\n+                if (rec.GetConfigId().ItemIdsSize() != 1 || rec.GetConfigId().GetItemIds(0).GetId()) {\n+                    ++Count;\n+                }\n+            }))\n+    {}\n+\n+    void Clear() {\n+        Count = 0;\n+    }\n \n-    TDispatchOptions options;\n-    options.FinalEvents.emplace_back(TIsConfigNotificationProcessed(), 1);\n-    runtime.DispatchEvents(options);\n-}\n+    void Wait() {\n+        Runtime.WaitFor(\"config update\", [this]{ return this->Count > 0; });\n+        --Count;\n+    }\n+\n+private:\n+    TTestActorRuntime& Runtime;\n+    TTestActorRuntime::TEventObserverHolder Holder;\n+    size_t Count = 0;\n+};\n \n template <class ...Ts>\n void ConfigureAndWaitUpdate(\n-    TTenantTestRuntime& runtime, Ts&&... args)\n+    TTenantTestRuntime& runtime, TConfigUpdatesObserver& updates, Ts&&... args)\n {\n     auto* event = new TEvConsole::TEvConfigureRequest;\n     CollectActions(event->Record, std::forward<Ts>(args)...);\n \n+    updates.Clear();\n     runtime.SendToConsole(event);\n-    WaitForUpdate(runtime);\n+    auto ev = runtime.GrabEdgeEventRethrow<TEvConsole::TEvConfigureResponse>(runtime.Sender);\n+    UNIT_ASSERT_VALUES_EQUAL(ev->Get()->Record.GetStatus().GetCode(), Ydb::StatusIds::SUCCESS);\n+    updates.Wait();\n }\n \n void CompareFeatureFlags(TTenantTestRuntime& runtime, const TString& expected) {\n@@ -127,8 +140,11 @@ Y_UNIT_TEST_SUITE(FeatureFlagsConfiguratorTest) {\n \n     Y_UNIT_TEST(TestFeatureFlagsUpdates) {\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig());\n+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down\n+\n+        TConfigUpdatesObserver updates(runtime);\n         InitFeatureFlagsConfigurator(runtime);\n-        WaitForUpdate(runtime); // initial update\n+        updates.Wait(); // initial update\n \n         CompareFeatureFlags(runtime,\n             \"EnableExternalHive: false\\n\"\n@@ -141,14 +157,14 @@ Y_UNIT_TEST_SUITE(FeatureFlagsConfiguratorTest) {\n         // We must receive the first (spurious) notification\n         runtime.GrabEdgeEventRethrow<TEvFeatureFlags::TEvChanged>(sender);\n \n-        ConfigureAndWaitUpdate(runtime, MakeAddAction(ITEM_FEATURE_FLAGS_DEFAULT));\n+        ConfigureAndWaitUpdate(runtime, updates, MakeAddAction(ITEM_FEATURE_FLAGS_DEFAULT));\n         CompareFeatureFlags(runtime,\n             \"EnableExternalHive: false\\n\");\n \n         // We must receive a notification (contents are not checked)\n         runtime.GrabEdgeEventRethrow<TEvFeatureFlags::TEvChanged>(sender);\n \n-        ConfigureAndWaitUpdate(runtime, MakeAddAction(ITEM_FEATURE_FLAGS_1));\n+        ConfigureAndWaitUpdate(runtime, updates, MakeAddAction(ITEM_FEATURE_FLAGS_1));\n         CompareFeatureFlags(runtime,\n             \"EnableExternalHive: false\\n\"\n             \"EnableDataShardVolatileTransactions: false\\n\");\n@@ -156,7 +172,7 @@ Y_UNIT_TEST_SUITE(FeatureFlagsConfiguratorTest) {\n         // We must receive a notification on every change\n         runtime.GrabEdgeEventRethrow<TEvFeatureFlags::TEvChanged>(sender);\n \n-        ConfigureAndWaitUpdate(runtime, MakeAddAction(ITEM_FEATURE_FLAGS_2));\n+        ConfigureAndWaitUpdate(runtime, updates, MakeAddAction(ITEM_FEATURE_FLAGS_2));\n         CompareFeatureFlags(runtime,\n             \"EnableVolatileTransactionArbiters: false\\n\");\n \ndiff --git a/ydb/core/cms/console/immediate_controls_configurator_ut.cpp b/ydb/core/cms/console/immediate_controls_configurator_ut.cpp\nindex 9e13a6510893..8de68b4ce27a 100644\n--- a/ydb/core/cms/console/immediate_controls_configurator_ut.cpp\n+++ b/ydb/core/cms/console/immediate_controls_configurator_ut.cpp\n@@ -149,35 +149,46 @@ void InitImmediateControlsConfigurator(TTenantTestRuntime &runtime)\n     }\n }\n \n-void WaitForUpdate(TTenantTestRuntime &runtime)\n-{\n-    struct TIsConfigNotificationProcessed {\n-        bool operator()(IEventHandle& ev)\n-        {\n-            if (ev.GetTypeRewrite() == NConsole::TEvConsole::EvConfigNotificationResponse) {\n-                auto &rec = ev.Get<NConsole::TEvConsole::TEvConfigNotificationResponse>()->Record;\n-                if (rec.GetConfigId().ItemIdsSize() != 1 || rec.GetConfigId().GetItemIds(0).GetId())\n-                    return true;\n-            }\n+class TConfigUpdatesObserver {\n+public:\n+    TConfigUpdatesObserver(TTestActorRuntime& runtime)\n+        : Runtime(runtime)\n+        , Holder(Runtime.AddObserver<NConsole::TEvConsole::TEvConfigNotificationResponse>(\n+            [this](auto& ev) {\n+                auto& rec = ev->Get()->Record;\n+                if (rec.GetConfigId().ItemIdsSize() != 1 || rec.GetConfigId().GetItemIds(0).GetId()) {\n+                    ++Count;\n+                }\n+            }))\n+    {}\n+\n+    void Clear() {\n+        Count = 0;\n+    }\n \n-            return false;\n-        }\n-    };\n+    void Wait() {\n+        Runtime.WaitFor(\"config update\", [this]{ return this->Count > 0; });\n+        --Count;\n+    }\n \n-    TDispatchOptions options;\n-    options.FinalEvents.emplace_back(TIsConfigNotificationProcessed(), 1);\n-    runtime.DispatchEvents(options);\n-}\n+private:\n+    TTestActorRuntime& Runtime;\n+    TTestActorRuntime::TEventObserverHolder Holder;\n+    size_t Count = 0;\n+};\n \n template <typename ...Ts>\n-void ConfigureAndWaitUpdate(TTenantTestRuntime &runtime,\n+void ConfigureAndWaitUpdate(TTenantTestRuntime &runtime, TConfigUpdatesObserver &updates,\n                             Ts... args)\n {\n     auto *event = new TEvConsole::TEvConfigureRequest;\n     CollectActions(event->Record, args...);\n \n+    updates.Clear();\n     runtime.SendToConsole(event);\n-    WaitForUpdate(runtime);\n+    auto ev = runtime.GrabEdgeEventRethrow<TEvConsole::TEvConfigureResponse>(runtime.Sender);\n+    UNIT_ASSERT_VALUES_EQUAL(ev->Get()->Record.GetStatus().GetCode(), Ydb::StatusIds::SUCCESS);\n+    updates.Wait();\n }\n \n void CompareControls(TTenantTestRuntime &runtime,\n@@ -210,8 +221,11 @@ Y_UNIT_TEST_SUITE(TImmediateControlsConfiguratorTests)\n     Y_UNIT_TEST(TestControlsInitialization)\n     {\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig());\n+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down\n+        TConfigUpdatesObserver updates(runtime);\n+\n         InitImmediateControlsConfigurator(runtime);\n-        WaitForUpdate(runtime); // initial update\n+        updates.Wait(); // initial update\n \n         CompareControls(runtime, ITEM_CONTROLS_DEFAULT.GetConfig().GetImmediateControlsConfig());\n     }\n@@ -219,10 +233,13 @@ Y_UNIT_TEST_SUITE(TImmediateControlsConfiguratorTests)\n     Y_UNIT_TEST(TestModifiedControls)\n     {\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig());\n+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down\n+        TConfigUpdatesObserver updates(runtime);\n+\n         InitImmediateControlsConfigurator(runtime);\n-        WaitForUpdate(runtime); // initial update\n+        updates.Wait(); // initial update\n \n-        ConfigureAndWaitUpdate(runtime,\n+        ConfigureAndWaitUpdate(runtime, updates,\n                                MakeAddAction(ITEM_CONTROLS1));\n         CompareControls(runtime, ITEM_CONTROLS1.GetConfig().GetImmediateControlsConfig());\n     }\n@@ -230,18 +247,21 @@ Y_UNIT_TEST_SUITE(TImmediateControlsConfiguratorTests)\n     Y_UNIT_TEST(TestResetToDefault)\n     {\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig());\n+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down\n+        TConfigUpdatesObserver updates(runtime);\n+\n         InitImmediateControlsConfigurator(runtime);\n-        WaitForUpdate(runtime); // initial update\n+        updates.Wait(); // initial update\n \n-        ConfigureAndWaitUpdate(runtime,\n+        ConfigureAndWaitUpdate(runtime, updates,\n                                MakeAddAction(ITEM_CONTROLS1));\n         CompareControls(runtime, ITEM_CONTROLS1.GetConfig().GetImmediateControlsConfig());\n \n-        ConfigureAndWaitUpdate(runtime,\n+        ConfigureAndWaitUpdate(runtime, updates,\n                                MakeAddAction(ITEM_CONTROLS2));\n         CompareControls(runtime, ITEM_CONTROLS2_RES.GetConfig().GetImmediateControlsConfig());\n \n-        ConfigureAndWaitUpdate(runtime,\n+        ConfigureAndWaitUpdate(runtime, updates,\n                                MakeRemoveAction(1, 1),\n                                MakeRemoveAction(2, 1));\n \n@@ -251,10 +271,13 @@ Y_UNIT_TEST_SUITE(TImmediateControlsConfiguratorTests)\n     Y_UNIT_TEST(TestMaxLimit)\n     {\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig());\n+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down\n+        TConfigUpdatesObserver updates(runtime);\n+\n         InitImmediateControlsConfigurator(runtime);\n-        WaitForUpdate(runtime); // initial update\n+        updates.Wait(); // initial update\n \n-        ConfigureAndWaitUpdate(runtime,\n+        ConfigureAndWaitUpdate(runtime, updates,\n                                MakeAddAction(ITEM_CONTROLS_EXCEED_MAX));\n         CompareControls(runtime, ITEM_CONTROLS_MAX.GetConfig().GetImmediateControlsConfig());\n     }\n@@ -262,8 +285,11 @@ Y_UNIT_TEST_SUITE(TImmediateControlsConfiguratorTests)\n     Y_UNIT_TEST(TestDynamicMap)\n     {\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig());\n+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down\n+        TConfigUpdatesObserver updates(runtime);\n+\n         InitImmediateControlsConfigurator(runtime);\n-        WaitForUpdate(runtime); // initial update\n+        updates.Wait(); // initial update\n \n         NKikimrConsole::TConfigItem dynamicMapValue;\n         {\n@@ -275,7 +301,7 @@ Y_UNIT_TEST_SUITE(TImmediateControlsConfiguratorTests)\n             r.SetMaxInFlight(10);\n         }\n \n-        ConfigureAndWaitUpdate(runtime, MakeAddAction(dynamicMapValue));\n+        ConfigureAndWaitUpdate(runtime, updates, MakeAddAction(dynamicMapValue));\n \n         auto icb = runtime.GetAppData().Icb;\n \ndiff --git a/ydb/core/cms/console/jaeger_tracing_configurator_ut.cpp b/ydb/core/cms/console/jaeger_tracing_configurator_ut.cpp\nindex ce32b8948bcd..90db87a1be4b 100644\n--- a/ydb/core/cms/console/jaeger_tracing_configurator_ut.cpp\n+++ b/ydb/core/cms/console/jaeger_tracing_configurator_ut.cpp\n@@ -62,13 +62,32 @@ void InitJaegerTracingConfigurator(\n     runtime.DispatchEvents(std::move(options));\n }\n \n-void WaitForUpdate(TTenantTestRuntime& runtime) {\n-    TDispatchOptions options;\n-    options.FinalEvents.emplace_back(TEvConsole::EvConfigNotificationResponse, 1);\n-    runtime.DispatchEvents(std::move(options));\n-}\n+class TConfigUpdatesObserver {\n+public:\n+    TConfigUpdatesObserver(TTestActorRuntime& runtime)\n+        : Runtime(runtime)\n+        , Holder(Runtime.AddObserver<NConsole::TEvConsole::TEvConfigNotificationResponse>(\n+            [this](auto&) {\n+                ++Count;\n+            }))\n+    {}\n+\n+    void Clear() {\n+        Count = 0;\n+    }\n+\n+    void Wait() {\n+        Runtime.WaitFor(\"config update\", [this]{ return this->Count > 0; });\n+        --Count;\n+    }\n+\n+private:\n+    TTestActorRuntime& Runtime;\n+    TTestActorRuntime::TEventObserverHolder Holder;\n+    size_t Count = 0;\n+};\n \n-void ConfigureAndWaitUpdate(TTenantTestRuntime& runtime, const NKikimrConfig::TTracingConfig& cfg, ui32 order) {\n+void Configure(TTenantTestRuntime& runtime, const NKikimrConfig::TTracingConfig& cfg, ui32 order) {\n     auto configItem = MakeConfigItem(NKikimrConsole::TConfigItem::TracingConfigItem,\n                                      NKikimrConfig::TAppConfig(), {}, {}, \"\", \"\", order,\n                                      NKikimrConsole::TConfigItem::OVERWRITE, \"\");\n@@ -78,7 +97,15 @@ void ConfigureAndWaitUpdate(TTenantTestRuntime& runtime, const NKikimrConfig::TT\n     event->Record.AddActions()->CopyFrom(MakeAddAction(configItem));\n \n     runtime.SendToConsole(event);\n-    WaitForUpdate(runtime);\n+\n+    auto ev = runtime.GrabEdgeEventRethrow<TEvConsole::TEvConfigureResponse>(runtime.Sender);\n+    UNIT_ASSERT_VALUES_EQUAL(ev->Get()->Record.GetStatus().GetCode(), Ydb::StatusIds::SUCCESS);\n+}\n+\n+void ConfigureAndWaitUpdate(TTenantTestRuntime& runtime, TConfigUpdatesObserver& updates, const NKikimrConfig::TTracingConfig& cfg, ui32 order) {\n+    updates.Clear();\n+    Configure(runtime, cfg, order);\n+    updates.Wait();\n }\n \n auto& RandomChoice(auto& Container) {\n@@ -183,9 +210,13 @@ struct TTimeProviderMock : public ITimeProvider {\n Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n     Y_UNIT_TEST(DefaultConfig) {\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig());\n+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down\n+\n+        TConfigUpdatesObserver updates(runtime);\n         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());\n         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);\n         InitJaegerTracingConfigurator(runtime, std::move(configurator), {});\n+        updates.Wait(); // Initial update\n \n         for (size_t i = 0; i < 100; ++i) {\n             auto [state, _] = controls.HandleTracing(false, {});\n@@ -196,11 +227,13 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n             auto [state, _] = controls.HandleTracing(true, {});\n             UNIT_ASSERT_EQUAL(state, TTracingControls::OFF); // No request with trace-id are traced\n         }\n-        WaitForUpdate(runtime); // Initial update\n     }\n \n     Y_UNIT_TEST(GlobalRules) {\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig());\n+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down\n+\n+        TConfigUpdatesObserver updates(runtime);\n         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());\n         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);\n         NKikimrConfig::TTracingConfig cfg;\n@@ -216,7 +249,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n             rule->SetMaxTracesBurst(10);\n             rule->SetMaxTracesPerMinute(30);\n         }\n+        Configure(runtime, cfg, 1);\n         InitJaegerTracingConfigurator(runtime, std::move(configurator), cfg);\n+        updates.Wait(); // Initial update\n \n         std::array discriminators{\n             TRequestDiscriminator{\n@@ -282,6 +317,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n \n     Y_UNIT_TEST(ExternalTracePlusSampling) {\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig());\n+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down\n+\n+        TConfigUpdatesObserver updates(runtime);\n         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());\n         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);\n         NKikimrConfig::TTracingConfig cfg;\n@@ -297,7 +335,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n             rule->SetMaxTracesBurst(10);\n             rule->SetMaxTracesPerMinute(90);\n         }\n+        Configure(runtime, cfg, 1);\n         InitJaegerTracingConfigurator(runtime, std::move(configurator), cfg);\n+        updates.Wait(); // Initial update\n \n         std::array discriminators{\n             TRequestDiscriminator{\n@@ -336,6 +376,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n \n     Y_UNIT_TEST(RequestTypeThrottler) {\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig());\n+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down\n+\n+        TConfigUpdatesObserver updates(runtime);\n         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());\n         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);\n         NKikimrConfig::TTracingConfig cfg;\n@@ -345,7 +388,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n             rule->SetMaxTracesPerMinute(120);\n             rule->MutableScope()->AddRequestTypes()->assign(\"KeyValue.ExecuteTransaction\");\n         }\n+        Configure(runtime, cfg, 1);\n         InitJaegerTracingConfigurator(runtime, std::move(configurator), cfg);\n+        updates.Wait(); // Initial update\n \n         for (size_t i = 0; i < 100; ++i) {\n             auto [state, _] = controls.HandleTracing(false, {});\n@@ -383,10 +428,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n             controls.HandleTracing(true, RandomChoice(executeTransactionDiscriminators)).first,\n             TTracingControls::OFF);\n \n-        WaitForUpdate(runtime); // Initial update\n         cfg.MutableExternalThrottling(0)->SetMaxTracesPerMinute(10);\n         cfg.MutableExternalThrottling(0)->SetMaxTracesBurst(2);\n-        ConfigureAndWaitUpdate(runtime, cfg, 1);\n+        ConfigureAndWaitUpdate(runtime, updates, cfg, 2);\n \n         for (size_t i = 0; i < 3; ++i) {\n             UNIT_ASSERT_EQUAL(\n@@ -421,6 +465,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n \n     Y_UNIT_TEST(RequestTypeSampler) {\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig());\n+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down\n+\n+        TConfigUpdatesObserver updates(runtime);\n         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());\n         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);\n         NKikimrConfig::TTracingConfig cfg;\n@@ -432,7 +479,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n             rule->SetLevel(10);\n             rule->MutableScope()->AddRequestTypes()->assign(\"KeyValue.ExecuteTransaction\");\n         }\n+        Configure(runtime, cfg, 1);\n         InitJaegerTracingConfigurator(runtime, std::move(configurator), cfg);\n+        updates.Wait(); // Initial update\n \n         for (size_t i = 0; i < 1000; ++i) {\n             auto [state, level] = controls.HandleTracing(false, {});\n@@ -489,7 +538,6 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n         }\n         timeProvider->Advance(TDuration::Seconds(10));\n \n-        WaitForUpdate(runtime); // Initial update\n         {\n             auto& rule = *cfg.MutableSampling(0);\n             rule.SetMaxTracesPerMinute(10);\n@@ -498,7 +546,7 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n             rule.SetFraction(0.25);\n             rule.MutableScope()->MutableRequestTypes(0)->assign(\"KeyValue.ReadRange\");\n         }\n-        ConfigureAndWaitUpdate(runtime, cfg, 1);\n+        ConfigureAndWaitUpdate(runtime, updates, cfg, 2);\n \n         std::array readRangeDiscriminators{\n             TRequestDiscriminator{\n@@ -530,6 +578,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n \n     Y_UNIT_TEST(SamplingSameScope) {\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig());\n+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down\n+\n+        TConfigUpdatesObserver updates(runtime);\n         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());\n         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);\n         NKikimrConfig::TTracingConfig cfg;\n@@ -547,7 +598,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n             rule->SetFraction(1. / 3);\n             rule->SetLevel(10);\n         }\n+        Configure(runtime, cfg, 1);\n         InitJaegerTracingConfigurator(runtime, std::move(configurator), cfg);\n+        updates.Wait(); // Initial update\n \n         {\n             size_t level8 = 0;\n@@ -593,6 +646,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n \n     Y_UNIT_TEST(ThrottlingByDb) {\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig());\n+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down\n+\n+        TConfigUpdatesObserver updates(runtime);\n         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());\n         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);\n         NKikimrConfig::TTracingConfig cfg;\n@@ -602,7 +658,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n             rule->SetMaxTracesPerMinute(60);\n             rule->MutableScope()->MutableDatabase()->assign(\"/Root/db1\");\n         }\n+        Configure(runtime, cfg, 1);\n         InitJaegerTracingConfigurator(runtime, std::move(configurator), cfg);\n+        updates.Wait(); // Initial update\n \n         std::array discriminators{\n             TRequestDiscriminator{\n@@ -637,8 +695,7 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n         }\n \n         cfg.MutableExternalThrottling(0)->MutableScope()->AddRequestTypes()->assign(\"Table.ReadRows\");\n-        WaitForUpdate(runtime); // Initial update\n-        ConfigureAndWaitUpdate(runtime, cfg, 1);\n+        ConfigureAndWaitUpdate(runtime, updates, cfg, 2);\n         timeProvider->Advance(TDuration::Minutes(1));\n \n         {\n@@ -681,6 +738,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n \n     Y_UNIT_TEST(SamplingByDb) {\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig());\n+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down\n+\n+        TConfigUpdatesObserver updates(runtime);\n         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());\n         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);\n         NKikimrConfig::TTracingConfig cfg;\n@@ -692,7 +752,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n             rule->SetFraction(0.5);\n             rule->MutableScope()->MutableDatabase()->assign(\"/Root/db1\");\n         }\n+        Configure(runtime, cfg, 1);\n         InitJaegerTracingConfigurator(runtime, std::move(configurator), cfg);\n+        updates.Wait(); // Initial update\n \n         std::array discriminators{\n             TRequestDiscriminator{\n@@ -732,8 +794,7 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n         }\n \n         cfg.MutableSampling(0)->MutableScope()->AddRequestTypes()->assign(\"Table.ReadRows\");\n-        WaitForUpdate(runtime); // Initial update\n-        ConfigureAndWaitUpdate(runtime, cfg, 1);\n+        ConfigureAndWaitUpdate(runtime, updates, cfg, 2);\n         timeProvider->Advance(TDuration::Minutes(1));\n \n         {\n@@ -780,6 +841,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n \n     Y_UNIT_TEST(SharedThrottlingLimits) {\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig());\n+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down\n+\n+        TConfigUpdatesObserver updates(runtime);\n         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());\n         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);\n         NKikimrConfig::TTracingConfig cfg;\n@@ -792,7 +856,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n             scope->AddRequestTypes(\"Table.ReadRows\");\n             scope->AddRequestTypes(\"Table.AlterTable\");\n         }\n+        Configure(runtime, cfg, 1);\n         InitJaegerTracingConfigurator(runtime, std::move(configurator), cfg);\n+        updates.Wait(); // Initial update\n \n         std::array matchingDiscriminators{\n             TRequestDiscriminator{\n@@ -826,6 +892,7 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n \n     Y_UNIT_TEST(SharedSamplingLimits) {\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig());\n+        TConfigUpdatesObserver updates(runtime);\n         auto timeProvider = MakeIntrusive<TTimeProviderMock>(TInstant::Now());\n         auto [controls, configurator] = CreateSamplingThrottlingConfigurator(10, timeProvider);\n         NKikimrConfig::TTracingConfig cfg;\n@@ -840,7 +907,9 @@ Y_UNIT_TEST_SUITE(TJaegerTracingConfiguratorTests) {\n             scope->AddRequestTypes(\"Table.ReadRows\");\n             scope->AddRequestTypes(\"Table.AlterTable\");\n         }\n+        Configure(runtime, cfg, 1);\n         InitJaegerTracingConfigurator(runtime, std::move(configurator), cfg);\n+        updates.Wait(); // Initial update\n \n         std::array matchingDiscriminators{\n             TRequestDiscriminator{\ndiff --git a/ydb/core/cms/console/log_settings_configurator_ut.cpp b/ydb/core/cms/console/log_settings_configurator_ut.cpp\nindex a5ee661d74dc..06ec4fee08c6 100644\n--- a/ydb/core/cms/console/log_settings_configurator_ut.cpp\n+++ b/ydb/core/cms/console/log_settings_configurator_ut.cpp\n@@ -164,35 +164,44 @@ void SetDefaultLogConfig(NKikimrConsole::TConfigItem &item)\n     AddEntry(item, \"CMS_CONFIGS\", PRI_TRACE, Max<ui32>(), Max<ui32>());\n }\n \n-void WaitForUpdate(TTenantTestRuntime &runtime)\n-{\n-    struct TIsConfigNotificationProcessed {\n-        bool operator()(IEventHandle& ev)\n-        {\n-            if (ev.GetTypeRewrite() == NConsole::TEvConsole::EvConfigNotificationResponse) {\n-                auto &rec = ev.Get<NConsole::TEvConsole::TEvConfigNotificationResponse>()->Record;\n-                if (rec.GetConfigId().ItemIdsSize() != 1 || rec.GetConfigId().GetItemIds(0).GetId())\n-                    return true;\n-            }\n-\n-            return false;\n-        }\n-    };\n+class TConfigUpdatesObserver {\n+public:\n+    TConfigUpdatesObserver(TTestActorRuntime& runtime)\n+        : Runtime(runtime)\n+        , Holder(Runtime.AddObserver<NConsole::TEvConsole::TEvConfigNotificationResponse>(\n+            [this](auto& ev) {\n+                auto& rec = ev->Get()->Record;\n+                if (rec.GetConfigId().ItemIdsSize() != 1 || rec.GetConfigId().GetItemIds(0).GetId()) {\n+                    ++Count;\n+                }\n+            }))\n+    {}\n+\n+    void Clear() {\n+        Count = 0;\n+    }\n \n-    TDispatchOptions options;\n-    options.FinalEvents.emplace_back(TIsConfigNotificationProcessed(), 1);\n-    runtime.DispatchEvents(options);\n-}\n+    void Wait() {\n+        Runtime.WaitFor(\"config update\", [this]{ return this->Count > 0; });\n+        --Count;\n+    }\n+\n+private:\n+    TTestActorRuntime& Runtime;\n+    TTestActorRuntime::TEventObserverHolder Holder;\n+    size_t Count = 0;\n+};\n \n template <typename ...Ts>\n-void ConfigureAndWaitUpdate(TTenantTestRuntime &runtime,\n+void ConfigureAndWaitUpdate(TTenantTestRuntime &runtime, TConfigUpdatesObserver &updates,\n                             Ts... args)\n {\n     auto *event = new TEvConsole::TEvConfigureRequest;\n     CollectActions(event->Record, args...);\n \n+    updates.Clear();\n     runtime.SendToConsole(event);\n-    WaitForUpdate(runtime);\n+    updates.Wait();\n }\n \n void CompareSettings(TTenantTestRuntime &runtime,\n@@ -234,11 +243,14 @@ Y_UNIT_TEST_SUITE(TLogSettingsConfiguratorTests)\n     Y_UNIT_TEST(TestNoChanges)\n     {\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig());\n+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down\n+\n+        TConfigUpdatesObserver updates(runtime);\n         auto settings = InitLogSettingsConfigurator(runtime);\n-        WaitForUpdate(runtime); // initial update\n+        updates.Wait(); // initial update\n \n         SetDefaultLogConfig(ITEM_DOMAIN_LOG_1);\n-        ConfigureAndWaitUpdate(runtime,\n+        ConfigureAndWaitUpdate(runtime, updates,\n                                MakeAddAction(ITEM_DOMAIN_LOG_1));\n         CompareSettings(runtime, settings);\n     }\n@@ -246,14 +258,17 @@ Y_UNIT_TEST_SUITE(TLogSettingsConfiguratorTests)\n     Y_UNIT_TEST(TestAddComponentEntries)\n     {\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig());\n+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down\n+\n+        TConfigUpdatesObserver updates(runtime);\n         auto settings = InitLogSettingsConfigurator(runtime);\n-        WaitForUpdate(runtime); // initial update\n+        updates.Wait(); // initial update\n \n         SetDefaultLogConfig(ITEM_DOMAIN_LOG_1);\n         AddEntry(ITEM_DOMAIN_LOG_1, \"CMS_CLUSTER\", 5, Max<ui32>(), Max<ui32>());\n         AddEntry(ITEM_DOMAIN_LOG_1, \"CMS_CONFIGS\", Max<ui32>(), 5, Max<ui32>());\n         AddEntry(ITEM_DOMAIN_LOG_1, \"CMS_TENANTS\", Max<ui32>(), Max<ui32>(), 5);\n-        ConfigureAndWaitUpdate(runtime,\n+        ConfigureAndWaitUpdate(runtime, updates,\n                                MakeAddAction(ITEM_DOMAIN_LOG_1));\n         settings[NKikimrServices::CMS_CLUSTER].Raw.X.Level = 5;\n         settings[NKikimrServices::CMS_CONFIGS].Raw.X.SamplingLevel = 5;\n@@ -268,14 +283,17 @@ Y_UNIT_TEST_SUITE(TLogSettingsConfiguratorTests)\n         label.SetName(\"tenant\");\n         label.SetValue(TENANT1_1_NAME);\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig(), ext);\n+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down\n+\n+        TConfigUpdatesObserver updates(runtime);\n         auto settings = InitLogSettingsConfigurator(runtime);\n-        WaitForUpdate(runtime); // initial update\n+        updates.Wait(); // initial update\n \n         SetDefaultLogConfig(ITEM_DOMAIN_LOG_1);\n         AddEntry(ITEM_TENANT1_LOG_1, \"CMS_CLUSTER\", 5, Max<ui32>(), Max<ui32>());\n         AddEntry(ITEM_TENANT1_LOG_1, \"CMS_CONFIGS\", Max<ui32>(), 5, Max<ui32>());\n         AddEntry(ITEM_TENANT1_LOG_1, \"CMS_TENANTS\", Max<ui32>(), Max<ui32>(), 5);\n-        ConfigureAndWaitUpdate(runtime,\n+        ConfigureAndWaitUpdate(runtime, updates,\n                                MakeAddAction(ITEM_DOMAIN_LOG_1),\n                                MakeAddAction(ITEM_TENANT1_LOG_1));\n         settings[NKikimrServices::CMS_CLUSTER].Raw.X.Level = 5;\n@@ -286,7 +304,7 @@ Y_UNIT_TEST_SUITE(TLogSettingsConfiguratorTests)\n         auto ids = GetTenantItemIds(runtime, TENANT1_1_NAME);\n         AssignIds(ids, ITEM_TENANT1_LOG_1);\n \n-        ConfigureAndWaitUpdate(runtime,\n+        ConfigureAndWaitUpdate(runtime, updates,\n                                MakeRemoveAction(ITEM_TENANT1_LOG_1));\n         settings[NKikimrServices::CMS_CLUSTER].Raw.X.Level = 4;\n         settings[NKikimrServices::CMS_CONFIGS].Raw.X.SamplingLevel = 4;\n@@ -301,12 +319,15 @@ Y_UNIT_TEST_SUITE(TLogSettingsConfiguratorTests)\n         label.SetName(\"tenant\");\n         label.SetValue(TENANT1_1_NAME);\n         TTenantTestRuntime runtime(DefaultConsoleTestConfig(), ext);\n+        runtime.SimulateSleep(TDuration::MilliSeconds(100)); // settle down\n+\n+        TConfigUpdatesObserver updates(runtime);\n         auto settings = InitLogSettingsConfigurator(runtime);\n-        WaitForUpdate(runtime); // initial update\n+        updates.Wait(); // initial update\n \n         SetDefaultLogConfig(ITEM_DOMAIN_LOG_1);\n         SetDefaults(ITEM_TENANT1_LOG_1, PRI_ALERT, PRI_ALERT, 10);\n-        ConfigureAndWaitUpdate(runtime,\n+        ConfigureAndWaitUpdate(runtime, updates,\n                                MakeAddAction(ITEM_DOMAIN_LOG_1),\n                                MakeAddAction(ITEM_TENANT1_LOG_1));\n         for (auto &set : settings)\ndiff --git a/ydb/core/mind/dynamic_nameserver.cpp b/ydb/core/mind/dynamic_nameserver.cpp\nindex 74d6d7df7639..e60315168c88 100644\n--- a/ydb/core/mind/dynamic_nameserver.cpp\n+++ b/ydb/core/mind/dynamic_nameserver.cpp\n@@ -260,6 +260,7 @@ void TDynamicNameserver::Handle(TEvNodeWardenStorageConfig::TPtr ev) {\n     const auto& config = *ev->Get()->Config;\n \n     BridgeInfo = std::move(ev->Get()->BridgeInfo);\n+    ListNodesCache->Invalidate();\n \n     if (ev->Get()->SelfManagementEnabled) {\n         // self-management through distconf is enabled and we are operating based on their tables, so apply them now\n@@ -1010,7 +1011,13 @@ void TListNodesCache::Invalidate() {\n }\n \n bool TListNodesCache::NeedUpdate(TInstant now) const {\n-    return Nodes == nullptr || now > Expire;\n+    if (Nodes == nullptr || now > Expire) {\n+        return true;\n+    }\n+    if (!PileMap && AppData()->BridgeModeEnabled) {\n+        return true;\n+    }\n+    return false;\n }\n \n TIntrusiveVector<TEvInterconnect::TNodeInfo>::TConstPtr TListNodesCache::GetNodes() const {\ndiff --git a/ydb/core/mind/hive/hive_ut.cpp b/ydb/core/mind/hive/hive_ut.cpp\nindex 6cb391039f3a..a4ec41443759 100644\n--- a/ydb/core/mind/hive/hive_ut.cpp\n+++ b/ydb/core/mind/hive/hive_ut.cpp\n@@ -1488,6 +1488,7 @@ Y_UNIT_TEST_SUITE(THiveTest) {\n \n         ui32 nodeId = runtime.GetNodeId(0);\n         {\n+            runtime.SimulateSleep(TDuration::MilliSeconds(100));\n             runtime.SendToPipe(hiveTablet, sender, new TEvHive::TEvDrainNode(nodeId));\n             {\n                 TDispatchOptions options;\n@@ -1496,15 +1497,25 @@ Y_UNIT_TEST_SUITE(THiveTest) {\n             }\n             Ctest << \"Register killer\\n\";\n             runtime.Register(CreateTabletKiller(hiveTablet));\n+\n             bool wasDedup = false;\n             auto observerHolder = runtime.AddObserver<TEvHive::TEvDrainNodeResult>([&](auto&& event) {\n                 if (event->Get()->Record.GetStatus() == NKikimrProto::EReplyStatus::ALREADY) {\n                     wasDedup = true;\n                 }\n             });\n-            while (!wasDedup) {\n-                runtime.DispatchEvents({});\n-            }\n+\n+            // Wait until domain hive retries drain\n+            TBlockEvents<TEvHive::TEvDrainNode> blockedDrain(runtime);\n+            runtime.WaitFor(\"drain retry\", [&]{ return blockedDrain.size() >= 1; }, TDuration::Seconds(1));\n+\n+            // Let tenant hive finish its drain\n+            runtime.SimulateSleep(TDuration::MilliSeconds(100));\n+\n+            // Unblock the drain retry\n+            blockedDrain.Stop().Unblock();\n+\n+            runtime.WaitFor(\"dedup\", [&]{ return wasDedup; }, TDuration::Seconds(1));\n         }\n     }\n \ndiff --git a/ydb/core/mind/node_broker_ut.cpp b/ydb/core/mind/node_broker_ut.cpp\nindex 41b6aa8d8378..f7afc8d854a4 100644\n--- a/ydb/core/mind/node_broker_ut.cpp\n+++ b/ydb/core/mind/node_broker_ut.cpp\n@@ -905,6 +905,7 @@ void CheckAsyncResolveNode(TTestActorRuntime &runtime, ui32 nodeId, const TStrin\n     UNIT_ASSERT(reply);\n \n     UNIT_ASSERT_VALUES_EQUAL(reply->NodeId, nodeId);\n+    UNIT_ASSERT(!reply->Addresses.empty());\n     UNIT_ASSERT_VALUES_EQUAL(reply->Addresses[0].GetAddress(), addr);\n }\n \n@@ -4608,10 +4609,25 @@ Y_UNIT_TEST_SUITE(TDynamicNameserverTest) {\n         TVector<NKikimrNodeBroker::TResolveNode> resolveRequests;\n \n         auto logRequests = [&](TAutoPtr<IEventHandle> &event) -> auto {\n-            if (event->GetTypeRewrite() == TEvNodeBroker::EvListNodes)\n-                listRequests.push_back(event->Get<TEvNodeBroker::TEvListNodes>()->Record);\n-            else if (event->GetTypeRewrite() == TEvNodeBroker::EvResolveNode)\n-                resolveRequests.push_back(event->Get<TEvNodeBroker::TEvResolveNode>()->Record);\n+            switch (event->GetTypeRewrite()) {\n+                case TEvInterconnect::EvListNodes:\n+                    if (runtime.FindActorName(event->Sender) == \"TABLET_RESOLVER_ACTOR\") {\n+                        // block TEvListNodes from tablet resolver\n+                        return TTestActorRuntime::EEventAction::DROP;\n+                    }\n+                    break;\n+\n+                case TEvNodeBroker::EvListNodes:\n+                    listRequests.push_back(event->Get<TEvNodeBroker::TEvListNodes>()->Record);\n+                    break;\n+\n+                case TEvNodeBroker::EvResolveNode:\n+                    resolveRequests.push_back(event->Get<TEvNodeBroker::TEvResolveNode>()->Record);\n+                    break;\n+\n+                default:\n+                    break;\n+            }\n             return TTestActorRuntime::EEventAction::PROCESS;\n         };\n \n@@ -4763,6 +4779,10 @@ Y_UNIT_TEST_SUITE(TDynamicNameserverTest) {\n         runtime.WaitFor(\"cache miss\", [&]{return resolveBlock.size() >= 1 || syncBlock.size() >= 1; });\n \n         // Reboot NodeBroker to break pipe\n+        TBlockEvents<TEvTabletPipe::TEvClientConnected> connectBlock(runtime,\n+            [&](auto& ev) {\n+                return runtime.FindActorName(ev->GetRecipientRewrite()) == \"NAMESERVICE\";\n+            });\n         RebootTablet(runtime, MakeNodeBrokerID(), sender);\n \n         // Resolve request is failed, because pipe was broken\n@@ -4772,6 +4792,7 @@ Y_UNIT_TEST_SUITE(TDynamicNameserverTest) {\n         resolveBlock.Stop();\n         syncBlock.Stop();\n         deltaBlock.Stop();\n+        connectBlock.Stop().Unblock();\n \n         // The following requests should be OK\n         CheckResolveNode(runtime, sender, NODE1, \"1.2.3.4\");\ndiff --git a/ydb/core/quoter/kesus_quoter_ut.cpp b/ydb/core/quoter/kesus_quoter_ut.cpp\nindex b8fe08efc47a..5f92e83c4daf 100644\n--- a/ydb/core/quoter/kesus_quoter_ut.cpp\n+++ b/ydb/core/quoter/kesus_quoter_ut.cpp\n@@ -109,7 +109,7 @@ Y_UNIT_TEST_SUITE(QuoterWithKesusTest) {\n         setup.GetQuota(TKesusQuoterTestSetup::DEFAULT_KESUS_PATH, TKesusQuoterTestSetup::DEFAULT_KESUS_RESOURCE);\n \n         setup.GetClient().DeleteKesus(TKesusQuoterTestSetup::DEFAULT_KESUS_PARENT_PATH, TKesusQuoterTestSetup::DEFAULT_KESUS_NAME);\n-        Sleep(TDuration::MilliSeconds(500)); // Wait for pipe disconnection, reconnection and passing info that old kesus was destroyed\n+        Sleep(TDuration::MilliSeconds(2000)); // Wait for pipe disconnection, reconnection and passing info that old kesus was destroyed\n         setup.GetClient().RefreshPathCache(setup.GetServer().GetRuntime(), TKesusQuoterTestSetup::DEFAULT_KESUS_PATH);\n \n         setup.CreateDefaultKesusAndResource();\ndiff --git a/ydb/core/tablet/tablet_pipe_ut.cpp b/ydb/core/tablet/tablet_pipe_ut.cpp\nindex 1ba60fad825a..1e9c52d77b9c 100644\n--- a/ydb/core/tablet/tablet_pipe_ut.cpp\n+++ b/ydb/core/tablet/tablet_pipe_ut.cpp\n@@ -1470,6 +1470,177 @@ Y_UNIT_TEST_SUITE(TTabletPipeTest) {\n         UNIT_ASSERT_C(gen2 > gen1, \"gen1: \" << gen1 << \", gen2: \" << gen2);\n     }\n \n+    Y_UNIT_TEST(TestPipeConnectAfterKillWithoutRetries) {\n+        TTestBasicRuntime runtime(3);\n+        // runtime.SetLogPriority(NKikimrServices::TABLET_RESOLVER, NActors::NLog::PRI_TRACE);\n+        SetupTabletServices(runtime);\n+\n+        auto tablet1 = StartTestTablet(runtime,\n+            CreateTestTabletInfo(TTestTxConfig::TxTablet0, TTabletTypes::Dummy),\n+            [](const TActorId & tablet, TTabletStorageInfo* info) {\n+                return new TTabletStuckOnStop(tablet, info);\n+            },\n+            1);\n+\n+        {\n+            Cerr << \"... waiting for boot1\" << Endl;\n+            TDispatchOptions options;\n+            options.FinalEvents.push_back(TDispatchOptions::TFinalEventCondition(TEvTablet::EvBoot, 1));\n+            runtime.DispatchEvents(options);\n+        }\n+\n+        auto sender1 = runtime.AllocateEdgeActor();\n+        auto client1 = runtime.Register(NTabletPipe::CreateClient(sender1, TTestTxConfig::TxTablet0, NTabletPipe::TClientConfig{\n+            .RetryPolicy = NTabletPipe::TClientRetryPolicy::WithoutRetries(),\n+        }));\n+        Y_UNUSED(client1);\n+\n+        ui32 gen1;\n+        {\n+            Cerr << \"... waiting for connect1\" << Endl;\n+            auto ev = runtime.GrabEdgeEvent<TEvTabletPipe::TEvClientConnected>(sender1);\n+            UNIT_ASSERT(ev);\n+            auto* msg = ev->Get();\n+            UNIT_ASSERT_VALUES_EQUAL(msg->Status, NKikimrProto::OK);\n+            gen1 = msg->Generation;\n+        }\n+\n+        runtime.Send(client1, sender1, new TEvents::TEvPoison);\n+        {\n+            Cerr << \"... waiting for client destroyed notification\" << Endl;\n+            auto ev = runtime.GrabEdgeEvent<TEvTabletPipe::TEvClientDestroyed>(sender1);\n+            UNIT_ASSERT(ev);\n+        }\n+\n+        runtime.Send(tablet1, TActorId(), new TEvents::TEvPoison);\n+        runtime.SimulateSleep(TDuration::MilliSeconds(1));\n+\n+        StartTestTablet(runtime,\n+            CreateTestTabletInfo(TTestTxConfig::TxTablet0, TTabletTypes::Dummy),\n+            [](const TActorId & tablet, TTabletStorageInfo* info) {\n+                return new TTabletStuckOnStop(tablet, info);\n+            },\n+            2);\n+\n+        {\n+            Cerr << \"... waiting for boot2\" << Endl;\n+            TDispatchOptions options;\n+            options.FinalEvents.push_back(TDispatchOptions::TFinalEventCondition(TEvTablet::EvBoot, 1));\n+            runtime.DispatchEvents(options);\n+        }\n+\n+        auto sender2 = runtime.AllocateEdgeActor();\n+        for (int i = 0; i < 30; ++i) {\n+            // overload tablet resolver with unrelated queries\n+            runtime.Send(new IEventHandle(MakeTabletResolverID(), TActorId(),\n+                new TEvTabletResolver::TEvForward(TTestTxConfig::TxTablet0 + 1 + i, nullptr, {})));\n+        }\n+        auto client2 = runtime.Register(NTabletPipe::CreateClient(sender2, TTestTxConfig::TxTablet0, NTabletPipe::TClientConfig{\n+            .RetryPolicy = NTabletPipe::TClientRetryPolicy::WithoutRetries(),\n+        }));\n+        Y_UNUSED(client2);\n+\n+        ui32 gen2;\n+        {\n+            Cerr << \"... waiting for connect2\" << Endl;\n+            auto ev = runtime.GrabEdgeEvent<TEvTabletPipe::TEvClientConnected>(sender2);\n+            UNIT_ASSERT(ev);\n+            auto* msg = ev->Get();\n+            UNIT_ASSERT_VALUES_EQUAL(msg->Status, NKikimrProto::OK);\n+            gen2 = msg->Generation;\n+        }\n+\n+        UNIT_ASSERT_C(gen2 > gen1, \"gen1: \" << gen1 << \", gen2: \" << gen2);\n+    }\n+\n+    Y_UNIT_TEST(TestPipeConnectLoopUnknownTabletWithoutRetries) {\n+        TTestBasicRuntime runtime(3);\n+        // runtime.SetLogPriority(NKikimrServices::STATESTORAGE, NActors::NLog::PRI_TRACE);\n+        // runtime.SetLogPriority(NKikimrServices::TABLET_RESOLVER, NActors::NLog::PRI_TRACE);\n+        SetupTabletServices(runtime);\n+\n+        auto ts1 = runtime.GetCurrentTime();\n+        for (int i = 1; i <= 10; ++i) {\n+            auto sender2 = runtime.AllocateEdgeActor();\n+            auto client2 = runtime.Register(NTabletPipe::CreateClient(sender2, TTestTxConfig::TxTablet0, NTabletPipe::TClientConfig{\n+                .RetryPolicy = NTabletPipe::TClientRetryPolicy::WithoutRetries(),\n+            }));\n+            Y_UNUSED(client2);\n+            Cerr << \"... waiting for connect\" << i << Endl;\n+            auto ev = runtime.GrabEdgeEvent<TEvTabletPipe::TEvClientConnected>(sender2);\n+            UNIT_ASSERT(ev);\n+            auto* msg = ev->Get();\n+            UNIT_ASSERT_VALUES_EQUAL(msg->Status, NKikimrProto::ERROR);\n+        }\n+        auto ts2 = runtime.GetCurrentTime();\n+        auto d = ts2 - ts1;\n+\n+        UNIT_ASSERT_C(d > TDuration::MilliSeconds(10), \"10 connect attempts required \" << d);\n+    }\n+\n+    Y_UNIT_TEST(TestPipeConnectLoopLeaderDownWithoutRetries) {\n+        TTestBasicRuntime runtime(3);\n+        // runtime.SetLogPriority(NKikimrServices::STATESTORAGE, NActors::NLog::PRI_TRACE);\n+        // runtime.SetLogPriority(NKikimrServices::TABLET_RESOLVER, NActors::NLog::PRI_TRACE);\n+        SetupTabletServices(runtime);\n+\n+        auto tablet1 = StartTestTablet(runtime,\n+            CreateTestTabletInfo(TTestTxConfig::TxTablet0, TTabletTypes::Dummy),\n+            [](const TActorId & tablet, TTabletStorageInfo* info) {\n+                return new TTabletStuckOnStop(tablet, info);\n+            },\n+            1);\n+\n+        {\n+            Cerr << \"... waiting for boot1\" << Endl;\n+            TDispatchOptions options;\n+            options.FinalEvents.push_back(TDispatchOptions::TFinalEventCondition(TEvTablet::EvBoot, 1));\n+            runtime.DispatchEvents(options);\n+        }\n+\n+        auto sender1 = runtime.AllocateEdgeActor();\n+        auto client1 = runtime.Register(NTabletPipe::CreateClient(sender1, TTestTxConfig::TxTablet0, NTabletPipe::TClientConfig{\n+            .RetryPolicy = NTabletPipe::TClientRetryPolicy::WithoutRetries(),\n+        }));\n+        Y_UNUSED(client1);\n+\n+        {\n+            Cerr << \"... waiting for connect1\" << Endl;\n+            auto ev = runtime.GrabEdgeEvent<TEvTabletPipe::TEvClientConnected>(sender1);\n+            UNIT_ASSERT(ev);\n+            auto* msg = ev->Get();\n+            UNIT_ASSERT_VALUES_EQUAL(msg->Status, NKikimrProto::OK);\n+        }\n+\n+        runtime.Send(client1, sender1, new TEvents::TEvPoison);\n+        {\n+            Cerr << \"... waiting for client destroyed notification\" << Endl;\n+            auto ev = runtime.GrabEdgeEvent<TEvTabletPipe::TEvClientDestroyed>(sender1);\n+            UNIT_ASSERT(ev);\n+        }\n+\n+        runtime.Send(tablet1, TActorId(), new TEvents::TEvPoison);\n+        runtime.SimulateSleep(TDuration::MilliSeconds(1));\n+\n+        auto ts1 = runtime.GetCurrentTime();\n+        for (int i = 2; i <= 11; ++i) {\n+            auto sender2 = runtime.AllocateEdgeActor();\n+            auto client2 = runtime.Register(NTabletPipe::CreateClient(sender2, TTestTxConfig::TxTablet0, NTabletPipe::TClientConfig{\n+                .RetryPolicy = NTabletPipe::TClientRetryPolicy::WithoutRetries(),\n+            }));\n+            Y_UNUSED(client2);\n+            Cerr << \"... waiting for connect\" << i << Endl;\n+            auto ev = runtime.GrabEdgeEvent<TEvTabletPipe::TEvClientConnected>(sender2);\n+            UNIT_ASSERT(ev);\n+            auto* msg = ev->Get();\n+            UNIT_ASSERT_VALUES_EQUAL(msg->Status, NKikimrProto::ERROR);\n+        }\n+        auto ts2 = runtime.GetCurrentTime();\n+        auto d = ts2 - ts1;\n+\n+        UNIT_ASSERT_C(d > TDuration::MilliSeconds(10), \"10 reconnect attempts required \" << d);\n+    }\n+\n }\n \n }\ndiff --git a/ydb/core/tablet/tablet_resolver.cpp b/ydb/core/tablet/tablet_resolver.cpp\nindex c534fb994bda..0ecba7cafe7c 100644\n--- a/ydb/core/tablet/tablet_resolver.cpp\n+++ b/ydb/core/tablet/tablet_resolver.cpp\n@@ -5,6 +5,10 @@\n #include <ydb/core/base/tabletid.h>\n #include <ydb/core/base/tablet.h>\n #include <ydb/core/base/appdata.h>\n+#include <ydb/library/actors/async/async.h>\n+#include <ydb/library/actors/async/cancellation.h>\n+#include <ydb/library/actors/async/event.h>\n+#include <ydb/library/actors/async/sleep.h>\n #include <ydb/library/actors/core/hfunc.h>\n #include <ydb/library/actors/core/log.h>\n #include <ydb/library/actors/core/interconnect.h>\n@@ -19,49 +23,29 @@\n \n namespace NKikimr {\n \n-const TDuration TabletResolverNegativeCacheTimeout = TDuration::MilliSeconds(300);\n const TDuration TabletResolverRefreshNodesPeriod = TDuration::Seconds(60);\n \n+static constexpr ui32 TabletSuspectInstantRetryCount = 0;\n+static constexpr TDuration TabletSuspectMinRetryDelay = TDuration::MilliSeconds(1);\n+static constexpr TDuration TabletSuspectMaxRetryDelay = TDuration::MilliSeconds(50);\n+\n+static constexpr ui32 TabletSubscriptionInstantRetryCount = 1;\n+static constexpr TDuration TabletSubscriptionMinRetryDelay = TDuration::MilliSeconds(1);\n+static constexpr TDuration TabletSubscriptionMaxRetryDelay = TDuration::MilliSeconds(10);\n+\n+#define BLOG_TRACE(stream) LOG_TRACE_S(*TlsActivationContext, NKikimrServices::TABLET_RESOLVER, stream)\n+#define BLOG_DEBUG(stream) LOG_DEBUG_S(*TlsActivationContext, NKikimrServices::TABLET_RESOLVER, stream)\n+#define BLOG_INFO(stream) LOG_INFO_S(*TlsActivationContext, NKikimrServices::TABLET_RESOLVER, stream)\n+#define BLOG_WARN(stream) LOG_WARN_S(*TlsActivationContext, NKikimrServices::TABLET_RESOLVER, stream)\n+#define BLOG_ERROR(stream) LOG_ERROR_S(*TlsActivationContext, NKikimrServices::TABLET_RESOLVER, stream)\n+\n class TTabletResolver : public TActorBootstrapped<TTabletResolver> {\n     struct TEvPrivate {\n         enum EEv {\n-            EvPingTimeout = EventSpaceBegin(TEvents::ES_PRIVATE),\n-            EvStopListRemoval,\n-            EvRefreshNodes,\n+            EvRefreshNodes = EventSpaceBegin(TEvents::ES_PRIVATE),\n             EvEnd\n         };\n \n-        struct TEvPingTimeout : public TEventLocal<TEvPingTimeout, EvPingTimeout> {\n-            const ui64 TabletID;\n-            TSchedulerCookieHolder Cookie;\n-\n-            TEvPingTimeout(ui64 tabletId, ISchedulerCookie *cookie)\n-                : TabletID(tabletId)\n-                , Cookie(cookie)\n-            {}\n-\n-            TString ToString() const {\n-                TStringStream str;\n-                str << \"{EvPingTimeout TabletID: \" << TabletID;\n-                if (Cookie.Get()) {\n-                    str << \" Cookie: present\";\n-                }\n-                else {\n-                    str << \" Cookie: nullptr\";\n-                }\n-                str << \"}\";\n-                return str.Str();\n-            }\n-        };\n-\n-        struct TEvStopListRemoval : public TEventLocal<TEvStopListRemoval, EvStopListRemoval> {\n-            const ui64 TabletID;\n-\n-            TEvStopListRemoval(ui64 tabletId)\n-                : TabletID(tabletId)\n-            {}\n-        };\n-\n         struct TEvRefreshNodes : public TEventLocal<TEvRefreshNodes, EvRefreshNodes> {\n         };\n \n@@ -69,24 +53,17 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {\n     };\n \n     struct TEntry {\n-        enum EState {\n-            StInit,\n-            StInitResolve,\n+        enum EState : ui8 {\n+            StResolve,\n             StNormal,\n-            StProblemResolve,\n-            StProblemPing,\n-            StFollowerUpdate,\n+            StRemove,\n         };\n \n         static const char* StateToString(EState state) {\n             switch (state) {\n-            case StInit: return \"StInit\";\n-            case StInitResolve: return \"StInitResolve\";\n+            case StResolve: return \"StResolve\";\n             case StNormal: return \"StNormal\";\n-            case StProblemResolve: return \"StProblemResolve\";\n-            case StProblemPing: return \"StProblemPing\";\n-            case StFollowerUpdate: return \"StFollowerUpdate\";\n-            default: return \"Unknown\";\n+            case StRemove: return \"StRemove\";\n             }\n         }\n \n@@ -100,23 +77,36 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {\n             {}\n         };\n \n-        EState State = StInit;\n+        void MarkLeaderAlive() {\n+            CurrentLeaderSuspect = false;\n+            CurrentLeaderProblem = false;\n+            CurrentLeaderProblemPermanent = false;\n+        }\n+\n+        const ui64 TabletId;\n+        EState State = StResolve;\n+\n+        bool InCache : 1 = false;\n+        bool CurrentLeaderSuspect : 1 = false;\n+        bool CurrentLeaderProblem : 1 = false;\n+        bool CurrentLeaderProblemPermanent : 1 = false;\n \n         TQueueInplace<TQueueEntry, 128> Queue;\n         TActorId KnownLeader;\n         TActorId KnownLeaderTablet;\n \n-        TInstant LastResolved;\n-        TInstant LastPing;\n-\n-        TSchedulerCookieHolder Cookie;\n+        TMonotonic LastResolved;\n \n         TVector<std::pair<TActorId, TActorId>> KnownFollowers;\n \n         ui64 CacheEpoch = 0;\n         ui64 LastCheckEpoch = 0;\n \n-        TEntry() {}\n+        TAsyncEvent Wakeup;\n+\n+        explicit TEntry(ui64 tabletId)\n+            : TabletId(tabletId)\n+        {}\n     };\n \n     struct TResolveInfo {\n@@ -126,9 +116,9 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {\n         ui32 NumLocal;\n         ui32 NumLocalDc;\n         ui32 NumOtherDc;\n-        bool * NeedFollowerUpdate;\n+        bool* NeedFollowerUpdate;\n \n-        TResolveInfo(const TEvTabletResolver::TEvForward& msg, const TDuration& sinceResolve, bool * needFollowerUpdate)\n+        TResolveInfo(const TEvTabletResolver::TEvForward& msg, const TDuration& sinceResolve, bool* needFollowerUpdate)\n             : ResFlags(msg.ResolveFlags)\n             , SinceLastResolve(sinceResolve)\n             , NumLocal(0)\n@@ -158,14 +148,76 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {\n         }\n     };\n \n-    typedef NCache::TUnboundedCacheOnMap<ui64, TAutoPtr<TEntry>> TUnresolvedTablets;\n-    typedef NCache::T2QCache<ui64, TAutoPtr<TEntry>> TResolvedTablets;\n+    /**\n+     * Allows local coroutines to receive supported events with a specific cookie\n+     */\n+    class TEventStream : public TIntrusiveListItem<TEventStream> {\n+    public:\n+        TEventStream(TTabletResolver* self, ui64 cookie)\n+            : Self(self)\n+            , Cookie(cookie)\n+        {\n+            Self->EventStreams[Cookie] = this;\n+        }\n+\n+        ~TEventStream() {\n+            Self->EventStreams.erase(Cookie);\n+        }\n+\n+        async<IEventHandle::TPtr> Next() {\n+            Y_ABORT_UNLESS(!NextEvent, \"Unexpected event pending before Next()\");\n+            co_await ReceivedEvent.Wait();\n+            // Note: NextEvent is nullptr on TEvNodeDisconnected\n+            co_return std::move(NextEvent);\n+        }\n+\n+        void OnConnect() {\n+            Connected = true;\n+        }\n+\n+        void OnEvent(IEventHandle::TPtr&& ev) {\n+            Y_ABORT_UNLESS(ReceivedEvent.HasAwaiters(), \"Nobody is waiting\");\n+            NextEvent = std::move(ev);\n+            ReceivedEvent.NotifyOne();\n+        }\n+\n+        void OnDisconnect() {\n+            Y_ABORT_UNLESS(ReceivedEvent.HasAwaiters(), \"Nobody is waiting\");\n+            Y_ABORT_UNLESS(!NextEvent, \"Unexpected event pending in OnDisconnect()\");\n+            ReceivedEvent.NotifyOne();\n+        }\n+\n+        bool HadConnect() const {\n+            return Connected;\n+        }\n+\n+    private:\n+        TTabletResolver* const Self;\n+        const ui64 Cookie;\n+        IEventHandle::TPtr NextEvent;\n+        TAsyncEvent ReceivedEvent;\n+        bool Connected = false;\n+    };\n+\n+    absl::flat_hash_map<ui64, TEventStream*> EventStreams;\n+\n+    struct TTabletStateSubscription {\n+        TActorId ActorId;\n+        ui64 TabletId = 0;\n+        ui64 SeqNo = 0;\n+        NKikimrTabletBase::TEvTabletStateUpdate::EState State = NKikimrTabletBase::TEvTabletStateUpdate::StateUnknown;\n+        TAsyncCancellationScope Scope;\n+    };\n+\n+    struct TInterconnectSession {\n+        TIntrusiveList<TEventStream> EventStreams;\n+    };\n+\n+    typedef NCache::T2QCache<ui64, TEntry*> TTabletCache;\n \n     TIntrusivePtr<TTabletResolverConfig> Config;\n-    TActorSystem* ActorSystem;\n-    TUnresolvedTablets UnresolvedTablets;\n-    TResolvedTablets ResolvedTablets;\n-    THashSet<ui64> TabletsOnStopList;\n+    THashMap<ui64, TEntry> Tablets;\n+    TTabletCache TabletCache;\n     THashMap<ui32, TString> NodeToDcMapping;\n \n     THashMap<ui32, ui64> NodeProblems;\n@@ -173,6 +225,10 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {\n \n     ui64 LastCacheEpoch = 0;\n \n+    THashMap<TActorId, TTabletStateSubscription> TabletStateSubscriptions;\n+    THashMap<TActorId, TInterconnectSession> InterconnectSessions;\n+    ui64 LastSeqNo = 0;\n+\n     ::NMonitoring::TDynamicCounters::TCounterPtr SelectedLeaderLocal;\n     ::NMonitoring::TDynamicCounters::TCounterPtr SelectedLeaderLocalDc;\n     ::NMonitoring::TDynamicCounters::TCounterPtr SelectedLeaderOtherDc;\n@@ -190,21 +246,339 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {\n         return it != NodeToDcMapping.end() ? std::make_optional(it->second) : std::nullopt;\n     }\n \n-    void ResolveRequest(ui64 tabletId, const TActorContext &ctx) {\n-        const TActorId ssproxy = MakeStateStorageProxyID();\n-        ctx.Send(ssproxy, new TEvStateStorage::TEvLookup(tabletId, 0), IEventHandle::FlagTrackDelivery, tabletId);\n+    async<TEvStateStorage::TEvInfo::TPtr> LookupTablet(ui64 tabletId) {\n+        const ui64 cookie = ++LastSeqNo;\n+        const TActorId proxy = MakeStateStorageProxyID();\n+        Send(proxy, new TEvStateStorage::TEvLookup(tabletId, 0), IEventHandle::FlagTrackDelivery, cookie);\n \n         InFlyResolveCounter->Inc();\n+        Y_DEFER { InFlyResolveCounter->Dec(); };\n+\n+        // We may receive either TEvStateStorage::TEvInfo or TEvUndelivered\n+        TEventStream stream(this, cookie);\n+        auto ev = co_await stream.Next();\n+        Y_ABORT_UNLESS(ev); // local event cannot disconnect\n+        switch (ev->GetTypeRewrite()) {\n+            case TEvStateStorage::TEvInfo::EventType:\n+                co_return std::move(reinterpret_cast<TEvStateStorage::TEvInfo::TPtr&>(ev));\n+\n+            case TEvents::TEvUndelivered::EventType:\n+                co_return nullptr;\n+\n+            default:\n+                Y_ABORT_S(\"Unexpected resolve reply \" << Hex(ev->GetTypeRewrite()) << \" \" << ev->ToString());\n+        }\n     }\n \n-    bool PushQueue(TEvTabletResolver::TEvForward::TPtr &ev, TEntry &entry, const TActorContext &ctx) {\n-        entry.Queue.Emplace(ctx.Now(), std::move(ev));\n-        return true;\n+    void TabletResolveLoop(ui64 tabletId) {\n+        TEntry& entry = Tablets.at(tabletId);\n+        Y_ABORT_UNLESS(entry.State == TEntry::StResolve);\n+\n+        Y_DEFER {\n+            TabletCache.Erase(tabletId);\n+            Tablets.erase(tabletId);\n+        };\n+\n+        Y_DEFER {\n+            if (TlsActivationContext && entry.KnownLeader) {\n+                UnsubscribeTabletState(entry.KnownLeader);\n+            }\n+        };\n+\n+        ui32 retryNumber = 0;\n+        TDuration retryDelay;\n+        for (;;) {\n+            // On every iteration we make a new resolve request\n+            Y_ABORT_UNLESS(entry.State == TEntry::StResolve,\n+                \"Unexpected entry.State: %s\", TEntry::StateToString(entry.State));\n+\n+            if (retryDelay) {\n+                TDuration delay = (entry.LastResolved + retryDelay) - TActivationContext::Monotonic();\n+                if (delay) {\n+                    BLOG_TRACE(\"TabletResolveLoop tabletId: \" << tabletId\n+                        << \" sleeping for retry delay \" << delay);\n+                    co_await AsyncSleepFor(delay);\n+                }\n+            }\n+\n+            {\n+                BLOG_TRACE(\"TabletResolveLoop tabletId: \" << tabletId\n+                        << \" sending TEvLookup\");\n+                auto ev = co_await LookupTablet(tabletId);\n+                if (!ev) {\n+                    // StateStorage proxy is not configured on this node\n+                    BLOG_INFO(\"TabletResolveLoop tabletId: \" << tabletId\n+                            << \" StateStorage proxy not configured\");\n+                    SendQueuedError(entry, NKikimrProto::ERROR);\n+                    break;\n+                }\n+\n+                auto* msg = ev->Get();\n+\n+                BLOG_TRACE(\"TabletResolveLoop tabletId: \" << tabletId\n+                    << \" received TEvInfo Status: \" << msg->Status\n+                    << \" event: \" << msg->ToString());\n+\n+                // This will handle errors and send replies\n+                ApplyEntryInfo(entry, *msg);\n+            }\n+\n+            if (!entry.InCache) {\n+                // This entry was evicted while resolving, stop processing\n+                BLOG_TRACE(\"TabletResolveLoop tabletId: \" << tabletId\n+                    << \" processing stopped for an evicted entry\");\n+                break;\n+            }\n+\n+            if (entry.KnownLeader && entry.CurrentLeaderSuspect && !entry.CurrentLeaderProblemPermanent) {\n+                // Send a best-effort ping request to a suspicious leader\n+                // Don't track delivery or node disconnections, since this is\n+                // only needed when older stable versions don't support tablet\n+                // state subscriptions.\n+                // TODO(snaury): remove in 2026.\n+                Send(entry.KnownLeader, new TEvTablet::TEvPing(tabletId, 0), 0, entry.CacheEpoch);\n+            }\n+\n+            // Note: we move to StNormal and wait even when resolve fails, but\n+            // any attempt to resolve leader will wake us up and we will retry\n+            // with an appropriate delay when necessary.\n+            entry.State = TEntry::StNormal;\n+\n+            // Wait until the next iteration\n+            co_await entry.Wakeup.Wait();\n+\n+            if (!entry.InCache || entry.State == TEntry::StRemove) {\n+                BLOG_TRACE(\"TabletResolveLoop tabletId: \" << tabletId\n+                    << \" processing stopped for an evicted entry\");\n+                break;\n+            }\n+\n+            // Don't overload state storage when leader is inaccessible\n+            if (entry.CurrentLeaderSuspect && entry.CurrentLeaderProblem) {\n+                if (++retryNumber <= TabletSuspectInstantRetryCount) {\n+                    retryDelay = {};\n+                } else if (!retryDelay) {\n+                    retryDelay = TabletSuspectMinRetryDelay;\n+                } else {\n+                    retryDelay = Min(retryDelay * 2, TabletSuspectMaxRetryDelay);\n+                }\n+            } else {\n+                retryNumber = 0;\n+                retryDelay = {};\n+            }\n+        }\n     }\n \n-    std::pair<TActorId, TActorId> SelectForward(const TActorContext& ctx, const TEntry& entry, TResolveInfo& info, ui64 tabletId)\n-    {\n-        const ui32 selfNode = ctx.SelfID.NodeId();\n+    void OnTabletAlive(ui64 tabletId, const TActorId& actorId) {\n+        auto it = Tablets.find(tabletId);\n+        if (it == Tablets.end()) {\n+            return;\n+        }\n+\n+        TEntry& entry = it->second;\n+        if (entry.KnownLeader == actorId) {\n+            // We just confirmed this leader is alive\n+            entry.MarkLeaderAlive();\n+        }\n+    }\n+\n+    void OnTabletActive(ui64 tabletId, const TActorId& actorId, const TActorId& userActorId) {\n+        auto it = Tablets.find(tabletId);\n+        if (it == Tablets.end()) {\n+            return;\n+        }\n+\n+        TEntry& entry = it->second;\n+        if (entry.KnownLeader == actorId) {\n+            // When leader is active it implies it's alive\n+            entry.MarkLeaderAlive();\n+            if (!entry.KnownLeaderTablet) {\n+                entry.KnownLeaderTablet = userActorId;\n+            }\n+            return;\n+        }\n+\n+        for (auto& pr : entry.KnownFollowers) {\n+            if (pr.first == actorId) {\n+                if (!pr.second) {\n+                    pr.second = userActorId;\n+                }\n+                break;\n+            }\n+        }\n+    }\n+\n+    void OnTabletProblem(ui64 tabletId, const TActorId& actorId, bool permanent = false) {\n+        auto it = Tablets.find(tabletId);\n+        if (it == Tablets.end()) {\n+            return;\n+        }\n+\n+        TEntry& entry = it->second;\n+        BLOG_TRACE(\"OnTabletProblem tabletId: \" << tabletId << \" actorId: \" << actorId\n+            << \" entry.State: \" << TEntry::StateToString(entry.State));\n+\n+        if (!actorId) {\n+            // TEvTabletProblem without actorId is used for forced eviction\n+            if (entry.State == TEntry::StNormal) {\n+                entry.State = TEntry::StRemove;\n+                entry.Wakeup.NotifyOne();\n+            }\n+            return;\n+        }\n+\n+        if (entry.KnownLeader == actorId || entry.KnownLeaderTablet == actorId) {\n+            BLOG_TRACE(\"OnTabletProblem tabletId: \" << tabletId\n+                << \" marking leader \" << entry.KnownLeader\n+                << \" with a\" << (permanent ? \" permanent\" : \"\") << \" problem\");\n+            entry.CurrentLeaderProblem = true;\n+            if (permanent) {\n+                entry.CurrentLeaderProblemPermanent = true;\n+            }\n+            // Note: we want to delay resolve until the next request\n+            return;\n+        }\n+\n+        for (auto it = entry.KnownFollowers.begin(), end = entry.KnownFollowers.end(); it != end; ++it) {\n+            if (it->first == actorId || it->second == actorId) {\n+                BLOG_TRACE(\"OnTabletProblem tabletId: \" << tabletId\n+                    << \" removing follower \" << it->first);\n+                entry.KnownFollowers.erase(it);\n+                if (entry.State == TEntry::StNormal) {\n+                    entry.State = TEntry::StResolve;\n+                    entry.Wakeup.NotifyOne();\n+                }\n+                break;\n+            }\n+        }\n+    }\n+\n+    void TabletStateSubscriptionLoop(ui64 tabletId, TActorId actorId) {\n+        Y_ABORT_UNLESS(!TabletStateSubscriptions.contains(actorId));\n+        auto& subscription = TabletStateSubscriptions[actorId];\n+        subscription.ActorId = actorId;\n+        subscription.TabletId = tabletId;\n+        Y_DEFER { TabletStateSubscriptions.erase(actorId); };\n+\n+        subscription.Scope = co_await TAsyncCancellationScope::WithCurrentHandler();\n+\n+        ui32 retryNumber = 0;\n+        TDuration retryDelay;\n+        for (;;) {\n+            subscription.SeqNo = -1;\n+            subscription.State = NKikimrTabletBase::TEvTabletStateUpdate::StateUnknown;\n+\n+            if (retryDelay) {\n+                BLOG_TRACE(\"TabletStateSubscriptionLoop tabletId: \" << tabletId << \" actor: \" << actorId\n+                    << \" sleeping for \" << retryDelay);\n+            }\n+            // Note: this yields and checks for scope cancellation even when delay is zero\n+            co_await AsyncSleepFor(retryDelay);\n+\n+            const ui64 seqNo = ++LastSeqNo;\n+            subscription.SeqNo = seqNo;\n+            ui32 flags = IEventHandle::FlagTrackDelivery;\n+            if (actorId.NodeId() != SelfId().NodeId()) {\n+                flags |= IEventHandle::FlagSubscribeOnSession;\n+            }\n+            BLOG_TRACE(\"TabletStateSubscriptionLoop tabletId: \" << tabletId << \" actor: \" << actorId\n+                    << \" sending TEvTabletStateSubscribe seqNo=\" << seqNo);\n+            Send(actorId, new TEvTablet::TEvTabletStateSubscribe(tabletId, seqNo), flags, seqNo);\n+\n+            bool subscribed = true;\n+            auto unsubscribe = [&]() {\n+                if (subscribed) {\n+                    BLOG_TRACE(\"TabletStateSubscriptionLoop tabletId: \" << tabletId << \" actor: \" << actorId\n+                        << \" sending TEvTabletStateUnsubscribe seqNo=\" << seqNo);\n+                    Send(actorId, new TEvTablet::TEvTabletStateUnsubscribe(tabletId, seqNo));\n+                    subscribed = false;\n+                }\n+            };\n+\n+            Y_DEFER {\n+                // Note: don't unsubscribe during actor system shutdown\n+                if (TlsActivationContext) {\n+                    unsubscribe();\n+                }\n+            };\n+\n+            TEventStream stream(this, seqNo);\n+            while (subscribed) {\n+                auto ev = co_await stream.Next();\n+                if (!ev) {\n+                    // Node disconnected, start a new iteration\n+                    subscribed = false;\n+                    BLOG_TRACE(\"TabletStateSubscriptionLoop tabletId: \" << tabletId << \" actor: \" << actorId\n+                        << \" node disconnected\");\n+                    OnTabletProblem(tabletId, actorId);\n+                    break;\n+                }\n+\n+                switch (ev->GetTypeRewrite()) {\n+                    case TEvents::TEvUndelivered::EventType: {\n+                        // Tablet actor doesn't exist (note: this will not be delivered after a disconnect)\n+                        subscribed = false;\n+                        BLOG_TRACE(\"TabletStateSubscriptionLoop tabletId: \" << tabletId << \" actor: \" << actorId\n+                            << \" undelivered, assuming actor permanently unavailable\");\n+                        OnTabletProblem(tabletId, actorId, /* permanent */ true);\n+                        co_return;\n+                    }\n+                    case TEvTablet::TEvTabletStateUpdate::EventType: {\n+                        retryNumber = 0;\n+                        auto* msg = ev->Get<TEvTablet::TEvTabletStateUpdate>();\n+                        BLOG_TRACE(\"TabletStateSubscriptionLoop tabletId: \" << tabletId << \" actor: \" << actorId\n+                            << \" received state update: \" << msg->ToString());\n+                        subscription.State = msg->Record.GetState();\n+                        switch (subscription.State) {\n+                            case NKikimrTabletBase::TEvTabletStateUpdate::StateTerminating:\n+                            case NKikimrTabletBase::TEvTabletStateUpdate::StateDead:\n+                                OnTabletProblem(tabletId, actorId, /* permanent */ true);\n+                                unsubscribe();\n+                                co_return;\n+\n+                            case NKikimrTabletBase::TEvTabletStateUpdate::StateActive:\n+                                OnTabletActive(tabletId, actorId, msg->GetUserActorId());\n+                                break;\n+\n+                            default:\n+                                OnTabletAlive(tabletId, actorId);\n+                                break;\n+                        }\n+                        break;\n+                    }\n+                    default: {\n+                        Y_ABORT_S(\"Unexpected tablet state notification \" << Hex(ev->GetTypeRewrite()) << \" \" << ev->ToString());\n+                    }\n+                }\n+            }\n+\n+            // A small exponential backoff on retries: 0ms, 1ms, 2ms, 4ms, 8ms, 10ms\n+            if (++retryNumber <= TabletSubscriptionInstantRetryCount) {\n+                retryDelay = {};\n+            } else if (!retryDelay) {\n+                retryDelay = TabletSubscriptionMinRetryDelay;\n+            } else {\n+                retryDelay = Min(retryDelay * 2, TabletSubscriptionMaxRetryDelay);\n+            }\n+        }\n+    }\n+\n+    void SubscribeTabletState(ui64 tabletId, const TActorId& actorId) {\n+        if (!TabletStateSubscriptions.contains(actorId)) {\n+            TabletStateSubscriptionLoop(tabletId, actorId);\n+            Y_DEBUG_ABORT_UNLESS(TabletStateSubscriptions.contains(actorId));\n+        }\n+    }\n+\n+    void UnsubscribeTabletState(const TActorId& actorId) {\n+        auto it = TabletStateSubscriptions.find(actorId);\n+        if (it != TabletStateSubscriptions.end()) {\n+            it->second.Scope.Cancel();\n+        }\n+    }\n+\n+    std::pair<TActorId, TActorId> SelectForward(const TEntry& entry, TResolveInfo& info, ui64 tabletId) {\n+        const ui32 selfNode = SelfId().NodeId();\n         const std::optional<TString> selfDc = FindNodeDc(selfNode);\n         const std::optional<TString> leaderDc = FindNodeDc(entry.KnownLeader.NodeId());\n \n@@ -231,7 +605,7 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {\n             }\n         };\n \n-        bool countLeader = (entry.State == TEntry::StNormal || entry.State == TEntry::StFollowerUpdate);\n+        bool countLeader = (entry.KnownLeader && !entry.CurrentLeaderProblem);\n         if (countLeader) {\n             bool isLocal = (entry.KnownLeader.NodeId() == selfNode);\n             bool isLocalDc = selfDc && leaderDc == selfDc;\n@@ -245,7 +619,7 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {\n         }\n \n         if (info.ResFlags.AllowFollower()) {\n-            for (const auto &x : entry.KnownFollowers) {\n+            for (const auto& x : entry.KnownFollowers) {\n                 bool isLocal = (x.first.NodeId() == selfNode);\n                 bool isLocalDc = selfDc && FindNodeDc(x.first.NodeId()) == selfDc;\n                 info.Count(isLocal, isLocalDc);\n@@ -261,18 +635,21 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {\n         auto dcName = [](const std::optional<TString>& x) { return x ? x->data() : \"<none>\"; };\n \n         if (!winners.empty()) {\n-            size_t winnerIndex = (winners.size() == 1 ? 0 : (AppData(ctx)->RandomProvider->GenRand64() % winners.size()));\n+            size_t winnerIndex = (winners.size() == 1 ? 0 : (AppData()->RandomProvider->GenRand64() % winners.size()));\n             const TCandidate& winner = winners[winnerIndex];\n \n-            LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER,\n-                \"SelectForward node %\" PRIu32 \" selfDC %s leaderDC %s %s\"\n-                \" local %\" PRIu32 \" localDc %\" PRIu32 \" other %\" PRIu32 \" disallowed %\" PRIu32\n-                \" tabletId: %\" PRIu64 \" followers: %\" PRIu64 \" countLeader %\" PRIu32\n-                \" allowFollowers %\" PRIu32 \" winner: %s\",\n-                selfNode, dcName(selfDc), dcName(leaderDc), info.ResFlags.ToString().data(),\n-                info.NumLocal, info.NumLocalDc, info.NumOtherDc, disallowed,\n-                tabletId, entry.KnownFollowers.size(), countLeader, info.ResFlags.AllowFollower(),\n-                winner.KnownLeader.ToString().c_str());\n+            BLOG_DEBUG(\"SelectForward\"\n+                << \" node \" << selfNode\n+                << \" selfDC \" << dcName(selfDc)\n+                << \" leaderDC \" << dcName(leaderDc)\n+                << \" \" << info.ResFlags.ToString()\n+                << \" local \" << info.NumLocal << \" localDc \" << info.NumLocalDc << \" other \" << info.NumOtherDc\n+                << \" disallowed \" << disallowed\n+                << \" tabletId: \" << tabletId\n+                << \" followers: \" << entry.KnownFollowers.size()\n+                << \" countLeader \" << countLeader\n+                << \" allowFollowers \" << info.ResFlags.AllowFollower()\n+                << \" winner: \" << winner.KnownLeader);\n \n             if (winner.IsLeader) {\n                 if (winner.IsLocal)\n@@ -293,25 +670,29 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {\n             return std::make_pair(winner.KnownLeader, winner.KnownLeaderTablet);\n         }\n \n-        LOG_INFO(ctx, NKikimrServices::TABLET_RESOLVER,\n-            \"No candidates for SelectForward, node %\" PRIu32 \" selfDC %s leaderDC %s %s\"\n-            \" local %\" PRIu32 \" localDc %\" PRIu32 \" other %\" PRIu32 \" disallowed %\" PRIu32,\n-            selfNode, dcName(selfDc), dcName(leaderDc), info.ResFlags.ToString().data(),\n-            info.NumLocal, info.NumLocalDc, info.NumOtherDc, disallowed);\n+        BLOG_INFO(\"No candidates for SelectForward,\"\n+            << \" node \" << selfNode\n+            << \" selfDC \" << dcName(selfDc)\n+            << \" leaderDC \" << dcName(leaderDc)\n+            << \" \" << info.ResFlags.ToString()\n+            << \" local \" << info.NumLocal\n+            << \" localDc \" << info.NumLocalDc\n+            << \" other \" << info.NumOtherDc\n+            << \" disallowed \" << disallowed);\n \n         SelectedNone->Inc();\n \n         return std::make_pair(TActorId(), TActorId());\n     }\n \n-    bool SendForward(const TActorId &sender, const TEntry &entry, TEvTabletResolver::TEvForward *msg,\n-                     const TActorContext &ctx, bool * needFollowerUpdate = nullptr) {\n-        TResolveInfo info(*msg, ctx.Now() - entry.LastResolved, needFollowerUpdate); // fills needFollowerUpdate in dtor\n-        const std::pair<TActorId, TActorId> endpoint = SelectForward(ctx, entry, info, msg->TabletID);\n+    bool SendForward(const TActorId& sender, ui64 cookie, const TEntry& entry, TEvTabletResolver::TEvForward* msg,\n+                     bool* needFollowerUpdate = nullptr) {\n+        TResolveInfo info(*msg, TActivationContext::Monotonic() - entry.LastResolved, needFollowerUpdate); // fills needFollowerUpdate in dtor\n+        const std::pair<TActorId, TActorId> endpoint = SelectForward(entry, info, msg->TabletID);\n         if (endpoint.first) {\n-            ctx.Send(sender, new TEvTabletResolver::TEvForwardResult(msg->TabletID, endpoint.second, endpoint.first, LastCacheEpoch));\n+            Send(sender, new TEvTabletResolver::TEvForwardResult(msg->TabletID, endpoint.second, endpoint.first, LastCacheEpoch), 0, cookie);\n             if (!!msg->Ev) {\n-                ctx.Send(IEventHandle::Forward(std::move(msg->Ev), msg->SelectActor(endpoint.second, endpoint.first)));\n+                Send(IEventHandle::Forward(std::move(msg->Ev), msg->SelectActor(endpoint.second, endpoint.first)));\n             }\n             return true;\n         } else {\n@@ -319,11 +700,16 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {\n         }\n     }\n \n-    void SendQueued(ui64 tabletId, TEntry &entry, const TActorContext &ctx) {\n+    bool PushQueue(TEntry& entry, TEvTabletResolver::TEvForward::TPtr& ev) {\n+        entry.Queue.Emplace(TActivationContext::Now(), std::move(ev));\n+        return true;\n+    }\n+\n+    void SendQueued(TEntry& entry) {\n         while (TEntry::TQueueEntry* x = entry.Queue.Head()) {\n-            TEvTabletResolver::TEvForward *msg = x->Ev->Get();\n-            if (!SendForward(x->Ev->Sender, entry, msg, ctx)) {\n-                ctx.Send(x->Ev->Sender, new TEvTabletResolver::TEvForwardResult(NKikimrProto::ERROR, tabletId));\n+            TEvTabletResolver::TEvForward* msg = x->Ev->Get();\n+            if (!SendForward(x->Ev->Sender, x->Ev->Cookie, entry, msg)) {\n+                Send(x->Ev->Sender, new TEvTabletResolver::TEvForwardResult(NKikimrProto::ERROR, entry.TabletId), 0, x->Ev->Cookie);\n             }\n             entry.Queue.Pop();\n         }\n@@ -331,476 +717,275 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {\n         entry.Queue.Clear();\n     }\n \n-    void SendPing(ui64 tabletId, TEntry &entry, const TActorContext &ctx) {\n-        ctx.Send(entry.KnownLeader, new TEvTablet::TEvPing(tabletId, 0), IEventHandle::FlagTrackDelivery, tabletId); // no subscribe for reason\n-        entry.Cookie.Reset(ISchedulerCookie::Make3Way());\n-\n-        const TDuration timeout = TDuration::MilliSeconds(500);\n-        ctx.Schedule(timeout, new TEvPrivate::TEvPingTimeout(tabletId, entry.Cookie.Get()), entry.Cookie.Get());\n-    }\n-\n-    void ApplyEntryInfo(TEvStateStorage::TEvInfo& msg, TEntry &entry, const TActorContext &ctx) {\n-        entry.KnownLeader = msg.CurrentLeader;\n-        entry.KnownLeaderTablet = msg.CurrentLeaderTablet;\n-        entry.LastResolved = ctx.Now();\n-        entry.KnownFollowers = std::move(msg.Followers);\n-        entry.CacheEpoch = ++LastCacheEpoch;\n-\n-        LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER,\n-                  \"ApplyEntry leader tabletId: %\" PRIu64 \" followers: %\" PRIu64,\n-                  msg.TabletID, entry.KnownFollowers.size());\n-        SendQueued(msg.TabletID, entry, ctx);\n-    }\n-\n-    void DropEntry(ui64 tabletId, TEntry& entry, bool cacheNegative, const TActorContext &ctx) {\n-        LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER,\n-                  \"DropEntry tabletId: %\" PRIu64 \" followers: %\" PRIu64,\n-                  tabletId, entry.KnownFollowers.size());\n+    void SendQueuedError(TEntry& entry, NKikimrProto::EReplyStatus status) {\n         while (TEntry::TQueueEntry* x = entry.Queue.Head()) {\n-            ctx.Send(x->Ev->Sender, new TEvTabletResolver::TEvForwardResult(NKikimrProto::ERROR, tabletId));\n+            Send(x->Ev->Sender, new TEvTabletResolver::TEvForwardResult(status, entry.TabletId), 0, x->Ev->Cookie);\n             entry.Queue.Pop();\n         }\n-        ResolvedTablets.Erase(tabletId);\n-        UnresolvedTablets.Erase(tabletId);\n-\n-        if (TabletResolverNegativeCacheTimeout && cacheNegative) {\n-            if (TabletsOnStopList.emplace(tabletId).second)\n-                Schedule(TabletResolverNegativeCacheTimeout, new TEvPrivate::TEvStopListRemoval(tabletId));\n-        }\n-    }\n-\n-    void DropEntry(ui64 tabletId, TEntry& entry, const TActorContext &ctx) {\n-        DropEntry(tabletId, entry, true, ctx);\n+        // Free buffer memory\n+        entry.Queue.Clear();\n     }\n \n-    TAutoPtr<TEntry>& GetEntry(ui64 tabletId, const TActorContext &ctx) {\n-        TAutoPtr<TEntry>* entryPtr;\n-        if (!ResolvedTablets.Find(tabletId, entryPtr)) {\n-            if (!UnresolvedTablets.Find(tabletId, entryPtr)) {\n-                ActorSystem = ctx.ActorSystem();\n-                UnresolvedTablets.Insert(tabletId, TAutoPtr<TEntry>(new TEntry()), entryPtr);\n+    void ApplyEntryInfo(TEntry& entry, TEvStateStorage::TEvInfo& msg) {\n+        if (entry.KnownLeader != msg.CurrentLeader || !msg.CurrentLeader) {\n+            if (entry.KnownLeader) {\n+                UnsubscribeTabletState(entry.KnownLeader);\n+            }\n+            entry.KnownLeader = msg.CurrentLeader;\n+            entry.KnownLeaderTablet = msg.CurrentLeaderTablet;\n+            if (entry.KnownLeader) {\n+                entry.MarkLeaderAlive();\n+                if (entry.InCache) {\n+                    SubscribeTabletState(entry.TabletId, entry.KnownLeader);\n+                }\n+            } else {\n+                // Note: currently state storage will reply with an error when\n+                // the leader is missing, but this code path will handle\n+                // followers without a leader in the future.\n+                entry.CurrentLeaderSuspect = true;\n+                entry.CurrentLeaderProblem = true;\n+                entry.CurrentLeaderProblemPermanent = true;\n+            }\n+        } else {\n+            if (entry.CurrentLeaderProblem) {\n+                entry.CurrentLeaderSuspect = true;\n+            }\n+            if (!entry.CurrentLeaderProblemPermanent) {\n+                entry.CurrentLeaderProblem = false;\n+            }\n+            if (msg.CurrentLeaderTablet) {\n+                entry.KnownLeaderTablet = msg.CurrentLeaderTablet;\n             }\n         }\n \n-        return *entryPtr;\n+        entry.KnownFollowers = std::move(msg.Followers);\n+\n+        entry.LastResolved = TActivationContext::Monotonic();\n+        entry.CacheEpoch = ++LastCacheEpoch;\n+\n+        BLOG_DEBUG(\"ApplyEntry tabletId: \" << msg.TabletID\n+            << \" leader: \" << entry.KnownLeader\n+            << \" followers: \" << entry.KnownFollowers.size());\n+\n+        if (msg.Status == NKikimrProto::OK || !entry.KnownFollowers.empty()) {\n+            SendQueued(entry);\n+        } else {\n+            SendQueuedError(entry, NKikimrProto::ERROR);\n+        }\n     }\n \n-    TAutoPtr<TEntry>* FindEntry(ui64 tabletId) {\n-        TAutoPtr<TEntry>* entryPtr;\n-        if (!ResolvedTablets.Find(tabletId, entryPtr)) {\n-            if (!UnresolvedTablets.Find(tabletId, entryPtr)) {\n-                return nullptr;\n-            }\n+    TEntry& GetEntry(ui64 tabletId) {\n+        bool created = false;\n+        auto it = Tablets.find(tabletId);\n+        if (it == Tablets.end()) {\n+            auto res = Tablets.emplace(\n+                std::piecewise_construct,\n+                std::forward_as_tuple(tabletId),\n+                std::forward_as_tuple(tabletId));\n+            it = res.first;\n+            created = true;\n         }\n \n-        return entryPtr;\n-    }\n+        TEntry& entry = it->second;\n+        if (created) {\n+            TabletResolveLoop(tabletId);\n+        }\n \n-    void MoveEntryToResolved(ui64 tabletId, TAutoPtr<TEntry>& entry) {\n-        TAutoPtr<TEntry>* resolvedEntryPtr;\n-        Y_ABORT_UNLESS(ResolvedTablets.Insert(tabletId, entry, resolvedEntryPtr));\n-        Y_ABORT_UNLESS(UnresolvedTablets.Erase(tabletId));\n-    }\n+        // Entry may be evicted while resolving, reinsert back into cache on additional hits\n+        TEntry** ignored;\n+        if (!entry.InCache) {\n+            bool ok = TabletCache.Insert(tabletId, &entry, ignored);\n+            Y_DEBUG_ABORT_UNLESS(ok, \"Unexpected failure to reinsert previously evicted tablet\");\n+            entry.InCache = true;\n+        } else {\n+            bool ok = TabletCache.Find(tabletId, ignored);\n+            Y_DEBUG_ABORT_UNLESS(ok, \"Unexpected failure to find an unevicted tablet\");\n+        }\n \n-    void MoveEntryToUnresolved(ui64 tabletId, TAutoPtr<TEntry>& entry) {\n-        TAutoPtr<TEntry>* unresolvedEntryPtr;\n-        Y_ABORT_UNLESS(UnresolvedTablets.Insert(tabletId, entry, unresolvedEntryPtr));\n-        Y_ABORT_UNLESS(ResolvedTablets.Erase(tabletId));\n+        return entry;\n     }\n \n-    void CheckDelayedNodeProblem(ui64 tabletId, const TActorContext &ctx) {\n-        TAutoPtr<TEntry>* entryHolder = FindEntry(tabletId);\n-        if (!entryHolder) {\n+    void CheckDelayedNodeProblem(ui64 tabletId) {\n+        auto it = Tablets.find(tabletId);\n+        if (it == Tablets.end()) {\n             return;\n         }\n \n-        TEntry &entry = *entryHolder->Get();\n-\n-        switch (entry.State) {\n-        case TEntry::StNormal:\n-        case TEntry::StFollowerUpdate:\n-            if (entry.CacheEpoch < LastNodeProblemsUpdateEpoch && entry.LastCheckEpoch < LastNodeProblemsUpdateEpoch) {\n-                entry.LastCheckEpoch = LastCacheEpoch;\n+        TEntry& entry = it->second;\n+        if (entry.CacheEpoch < LastNodeProblemsUpdateEpoch && entry.LastCheckEpoch < LastNodeProblemsUpdateEpoch) {\n+            entry.LastCheckEpoch = LastCacheEpoch;\n \n-                auto *pMaxProblemEpoch = NodeProblems.FindPtr(entry.KnownLeader.NodeId());\n+            if (entry.State == TEntry::StNormal) {\n+                auto* pMaxProblemEpoch = NodeProblems.FindPtr(entry.KnownLeader.NodeId());\n                 if (pMaxProblemEpoch && entry.CacheEpoch <= *pMaxProblemEpoch) {\n-                    LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER,\n-                            \"Delayed invalidation of tabletId: %\" PRIu64\n-                            \" leader: %s by NodeId\", tabletId, entry.KnownLeader.ToString().c_str());\n-                    if (entry.KnownFollowers.empty()) {\n-                        // Avoid resolving preemptively until the next request\n-                        DropEntry(tabletId, entry, /* cacheNegative */ false, ctx);\n-                        return;\n-                    }\n-                    ResolveRequest(tabletId, ctx);\n-                    entry.State = TEntry::StProblemResolve;\n-                    MoveEntryToUnresolved(tabletId, *entryHolder);\n-                    return;\n+                    BLOG_DEBUG(\"Delayed invalidation of tabletId: \" << tabletId\n+                        << \" leader: \" << entry.KnownLeader << \" by nodeId\");\n+                    entry.CurrentLeaderProblem = true;\n                 }\n+            }\n \n-                auto itDst = entry.KnownFollowers.begin();\n-                auto itSrc = entry.KnownFollowers.begin();\n-                while (itSrc != entry.KnownFollowers.end()) {\n-                    pMaxProblemEpoch = NodeProblems.FindPtr(itSrc->first.NodeId());\n-                    if (pMaxProblemEpoch && entry.CacheEpoch <= *pMaxProblemEpoch) {\n-                        LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER,\n-                            \"Delayed invalidation of tabletId: %\" PRIu64\n-                            \" follower: %s by nodeId\", tabletId, itSrc->first.ToString().c_str());\n-                        ++itSrc;\n-                        continue;\n-                    }\n-                    if (itDst != itSrc) {\n-                        *itDst = *itSrc;\n-                    }\n-                    ++itDst;\n+            auto itDst = entry.KnownFollowers.begin();\n+            auto itSrc = entry.KnownFollowers.begin();\n+            while (itSrc != entry.KnownFollowers.end()) {\n+                auto* pMaxProblemEpoch = NodeProblems.FindPtr(itSrc->first.NodeId());\n+                if (pMaxProblemEpoch && entry.CacheEpoch <= *pMaxProblemEpoch) {\n+                    BLOG_DEBUG(\"Delayed invalidation of tabletId: \" << tabletId\n+                        << \" follower: \" << itSrc->first << \" by nodeId\");\n                     ++itSrc;\n+                    continue;\n                 }\n-\n                 if (itDst != itSrc) {\n-                    entry.KnownFollowers.erase(itDst, itSrc);\n-                    ResolveRequest(tabletId, ctx);\n-                    entry.State = TEntry::StFollowerUpdate;\n+                    *itDst = *itSrc;\n+                }\n+                ++itDst;\n+                ++itSrc;\n+            }\n+            if (itDst != itSrc) {\n+                entry.KnownFollowers.erase(itDst, itSrc);\n+                if (entry.State == TEntry::StNormal) {\n+                    entry.State = TEntry::StResolve;\n+                    entry.Wakeup.NotifyOne();\n                 }\n             }\n-            break;\n-\n-        default:\n-            break;\n         }\n     }\n \n-    void Handle(TEvTabletResolver::TEvForward::TPtr &ev, const TActorContext &ctx) {\n-        TEvTabletResolver::TEvForward *msg = ev->Get();\n+    void Handle(TEvTabletResolver::TEvForward::TPtr& ev) {\n+        TEvTabletResolver::TEvForward* msg = ev->Get();\n         const ui64 tabletId = msg->TabletID;\n \n-        // allow some requests to bypass negative caching in low-load case\n-        if (InFlyResolveCounter->Val() > 20 && TabletsOnStopList.contains(tabletId)) {\n-            Send(ev->Sender, new TEvTabletResolver::TEvForwardResult(NKikimrProto::ERROR, tabletId));\n-            return;\n-        }\n-\n-        CheckDelayedNodeProblem(tabletId, ctx);\n+        CheckDelayedNodeProblem(tabletId);\n \n-        TAutoPtr<TEntry> &entryHolder = GetEntry(tabletId, ctx);\n-        TEntry& entry = *entryHolder.Get();\n-\n-        LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER,\n-                  \"Handle TEvForward tabletId: %\" PRIu64 \" entry.State: %s ev: %s\",\n-                  tabletId, TEntry::StateToString(entry.State), msg->ToString().data());\n-\n-        switch (entry.State) {\n-        case TEntry::StInit:\n-            {\n-                PushQueue(ev, entry, ctx);\n-                ResolveRequest(tabletId, ctx);\n-                entry.State = TEntry::StInitResolve;\n-            }\n-            break;\n-        case TEntry::StInitResolve:\n-            PushQueue(ev, entry, ctx);\n-            break;\n-        case TEntry::StNormal: {\n-            bool needFollowerUpdate = false;\n-            if (!SendForward(ev->Sender, entry, msg, ctx, &needFollowerUpdate)) {\n-                PushQueue(ev, entry, ctx);\n-                ResolveRequest(tabletId, ctx);\n-                entry.State = TEntry::StFollowerUpdate;\n-            }\n-            if (needFollowerUpdate) {\n-                ResolveRequest(tabletId, ctx);\n-                entry.State = TEntry::StFollowerUpdate;\n-            }\n-            break;\n-        }\n-        case TEntry::StProblemResolve:\n-        case TEntry::StProblemPing:\n-            PushQueue(ev, entry, ctx);\n-            break;\n-        case TEntry::StFollowerUpdate:\n-            if (!SendForward(ev->Sender, entry, msg, ctx))\n-                PushQueue(ev, entry, ctx);\n-            break;\n-        default:\n-            Y_ABORT();\n-        }\n-    }\n-\n-    void Handle(TEvTabletResolver::TEvTabletProblem::TPtr &ev, const TActorContext &ctx) {\n-        TEvTabletResolver::TEvTabletProblem *msg = ev->Get();\n-        const ui64 tabletId = msg->TabletID;\n-\n-        TAutoPtr<TEntry>* entryHolder = FindEntry(tabletId);\n-        if (!entryHolder) {\n-            LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, \"Handle TEvTabletProblem tabletId: %\" PRIu64\n-                \" no entyHolder\", tabletId);\n-            return;\n-        }\n-        TEntry &entry = *entryHolder->Get();\n-\n-        LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, \"Handle TEvTabletProblem tabletId: %\" PRIu64\n-            \" entry.State: %s\", tabletId, TEntry::StateToString(entry.State));\n+        TEntry& entry = GetEntry(tabletId);\n+        BLOG_DEBUG(\"Handle TEvForward tabletId: \" << tabletId\n+                << \" entry.State: \" << TEntry::StateToString(entry.State)\n+                << \" leader: \" << entry.KnownLeader\n+                << (entry.CurrentLeaderProblem ? \" (known problem)\" : \"\")\n+                << \" followers: \" << entry.KnownFollowers.size()\n+                << \" ev: \" << msg->ToString());\n \n         switch (entry.State) {\n-        case TEntry::StInit:\n-        case TEntry::StInitResolve:\n-            break;\n-        case TEntry::StNormal:\n-            if (!msg->Actor || entry.KnownLeader == msg->Actor || entry.KnownLeaderTablet == msg->Actor) {\n-                if (entry.KnownFollowers.empty()) {\n-                    // Avoid resolving preemptively until the next request\n-                    DropEntry(tabletId, entry, /* cacheNegative */ false, ctx);\n-                    return;\n+            case TEntry::StNormal: {\n+                bool needUpdate = false;\n+                if (!SendForward(ev->Sender, ev->Cookie, entry, msg, &needUpdate)) {\n+                    PushQueue(entry, ev);\n+                    needUpdate = true;\n                 }\n-                ResolveRequest(tabletId, ctx);\n-                entry.State = TEntry::StProblemResolve;\n-                MoveEntryToUnresolved(tabletId, *entryHolder);\n-            } else {\n-                // find in follower list\n-                for (auto it = entry.KnownFollowers.begin(), end = entry.KnownFollowers.end(); it != end; ++it) {\n-                    if (it->first == msg->Actor || it->second == msg->Actor) {\n-                        entry.KnownFollowers.erase(it);\n-                        ResolveRequest(tabletId, ctx);\n-                        entry.State = TEntry::StFollowerUpdate;\n-                        break;\n-                    }\n+                if (needUpdate) {\n+                    entry.State = TEntry::StResolve;\n+                    entry.Wakeup.NotifyOne();\n                 }\n-            }\n-            break;\n-        case TEntry::StFollowerUpdate:\n-            if (!msg->Actor || entry.KnownLeader == msg->Actor || entry.KnownLeaderTablet == msg->Actor) {\n-                // Reuse previously sent resolve request for StProblemResolve\n-                entry.State = TEntry::StProblemResolve;\n-                MoveEntryToUnresolved(tabletId, *entryHolder);\n                 break;\n             }\n-            [[fallthrough]];\n-        case TEntry::StProblemResolve:\n-        case TEntry::StProblemPing:\n-            for (auto it = entry.KnownFollowers.begin(), end = entry.KnownFollowers.end(); it != end; ++it) {\n-                if (it->first == msg->Actor || it->second == msg->Actor) {\n-                    entry.KnownFollowers.erase(it);\n-                    break;\n+            case TEntry::StResolve: {\n+                // Try to handle requests even while resolving\n+                if (entry.CacheEpoch == 0 || !SendForward(ev->Sender, ev->Cookie, entry, msg)) {\n+                    PushQueue(entry, ev);\n                 }\n+                break;\n+            }\n+            case TEntry::StRemove: {\n+                Y_ABORT(\"Unexpected StRemove state\");\n             }\n-            break;\n-        default:\n-            Y_ABORT();\n         }\n     }\n \n-    void Handle(TEvTabletResolver::TEvNodeProblem::TPtr &ev, const TActorContext &ctx) {\n-        TEvTabletResolver::TEvNodeProblem *msg = ev->Get();\n+    void Handle(TEvTabletResolver::TEvTabletProblem::TPtr& ev) {\n+        TEvTabletResolver::TEvTabletProblem* msg = ev->Get();\n+        const ui64 tabletId = msg->TabletID;\n+\n+        // Note: avoid promoting tablet entry in the cache\n+        auto it = Tablets.find(tabletId);\n+        if (it == Tablets.end()) {\n+            BLOG_DEBUG(\"Handle TEvTabletProblem tabletId: \" << tabletId << \" not cached\");\n+            return;\n+        }\n+\n+        TEntry& entry = it->second;\n+        BLOG_DEBUG(\"Handle TEvTabletProblem tabletId: \" << tabletId << \" actor: \" << msg->Actor\n+            << \" entry.State: \" << TEntry::StateToString(entry.State));\n+\n+        OnTabletProblem(tabletId, msg->Actor, /* permanent */ false);\n+    }\n+\n+    void Handle(TEvTabletResolver::TEvNodeProblem::TPtr& ev) {\n+        TEvTabletResolver::TEvNodeProblem* msg = ev->Get();\n         const ui32 nodeId = msg->NodeId;\n         const ui64 problemEpoch = msg->CacheEpoch;\n \n-        ui64 &maxProblemEpoch = NodeProblems[nodeId];\n+        ui64& maxProblemEpoch = NodeProblems[nodeId];\n         if (maxProblemEpoch < problemEpoch) {\n-            LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, \"Handle TEvNodeProblem nodeId: %\" PRIu32\n-                \" max(problemEpoch): %\" PRIu64, nodeId, problemEpoch);\n+            BLOG_DEBUG(\"Handle TEvNodeProblem nodeId: \" << nodeId\n+                << \" max(problemEpoch): \" << problemEpoch);\n             maxProblemEpoch = problemEpoch;\n             LastNodeProblemsUpdateEpoch = ++LastCacheEpoch;\n         } else {\n-            LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, \"Handle TEvNodeProblem nodeId: %\" PRIu32\n-                \" problemEpoch: %\" PRIu64 \" <= max(problemEpoch): %\" PRIu64,\n-                nodeId, problemEpoch, maxProblemEpoch);\n+            BLOG_DEBUG(\"Handle TEvNodeProblem nodeId: \" << nodeId\n+                << \" problemEpoch: \" << problemEpoch << \" <= max(problemEpoch): \" << maxProblemEpoch);\n         }\n     }\n \n-    void Handle(TEvStateStorage::TEvInfo::TPtr &ev, const TActorContext &ctx) {\n-        InFlyResolveCounter->Dec();\n-\n-        TEvStateStorage::TEvInfo *msg = ev->Get();\n-        const ui64 tabletId = msg->TabletID;\n-        const bool success = (msg->Status == NKikimrProto::OK); // todo: handle 'locked' state\n-\n-        TAutoPtr<TEntry>* entryHolder = FindEntry(tabletId);\n-        if (!entryHolder) {\n-            LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, \"Handle TEvInfo tabletId: %\" PRIu64 \" no entryHolder\",\n-                tabletId);\n-            return;\n-        }\n-        TEntry &entry = *entryHolder->Get();\n-\n-        LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, \"Handle TEvInfo tabletId: %\" PRIu64\n-            \" entry.State: %s success: %s ev: %s\", tabletId, TEntry::StateToString(entry.State),\n-            (success ? \"true\" : \"false\"), ev->GetBase()->ToString().data());\n-\n-        switch (entry.State) {\n-        case TEntry::StInit:\n-            Y_ABORT(\"must not happens\");\n-        case TEntry::StInitResolve:\n-            if (success) {\n-                if (msg->CurrentLeaderTablet) {\n-                    entry.State = TEntry::StNormal;\n-                    ApplyEntryInfo(*msg, entry, ctx);\n-                    MoveEntryToResolved(tabletId, *entryHolder);\n-                } else {\n-                    // HACK: Don't cache invalid CurrentLeaderTablet\n-                    // FIXME: Use subscription + cache here to reduce the workload\n-                    ApplyEntryInfo(*msg, entry, ctx);\n-                    DropEntry(tabletId, entry, ctx);\n-                }\n-            } else {\n-                DropEntry(tabletId, entry, ctx);\n-            }\n-            break;\n-        case TEntry::StFollowerUpdate:\n-            if (success) {\n-                if (msg->CurrentLeaderTablet) {\n-                    entry.State = TEntry::StNormal;\n-                    ApplyEntryInfo(*msg, entry, ctx);\n-                } else {\n-                    // HACK: Don't cache invalid CurrentLeaderTablet\n-                    // FIXME: Use subscription + cache here to reduce the workload\n-                    ApplyEntryInfo(*msg, entry, ctx);\n-                    DropEntry(tabletId, entry, ctx);\n-                }\n-            } else {\n-                DropEntry(tabletId, entry, ctx);\n-            }\n-            break;\n-        case TEntry::StProblemResolve:\n-            if (success) {\n-                if (entry.KnownLeader == msg->CurrentLeader) {\n-                    if (!(entry.KnownLeaderTablet == msg->CurrentLeaderTablet || !entry.KnownLeaderTablet)) {\n-                        DropEntry(tabletId, entry, ctx); // got info but not full, occurs on transitional cluster states\n-                    } else {\n-                        entry.State = TEntry::StProblemPing;\n-                        entry.KnownLeaderTablet = msg->CurrentLeaderTablet;\n-                        entry.KnownFollowers = std::move(msg->Followers);\n-                        SendPing(tabletId, entry, ctx);\n-                    }\n-                } else {\n-                    if (msg->CurrentLeaderTablet) {\n-                        entry.State = TEntry::StNormal;\n-                        ApplyEntryInfo(*msg, entry, ctx);\n-                        MoveEntryToResolved(tabletId, *entryHolder);\n-                    } else {\n-                        ApplyEntryInfo(*msg, entry, ctx);\n-                        DropEntry(tabletId, entry, ctx);\n-                    }\n-                }\n-            } else {\n-                DropEntry(tabletId, entry, ctx);\n-            }\n-            break;\n-        case TEntry::StProblemPing:\n-        case TEntry::StNormal:\n-            break;\n-        default:\n-            Y_ABORT();\n-        }\n-    }\n+    void Handle(TEvTablet::TEvPong::TPtr& ev) {\n+        auto* msg = ev->Get();\n+        const ui64 tabletId = msg->Record.GetTabletID();\n \n-    void Handle(TEvTablet::TEvPong::TPtr &ev, const TActorContext &ctx) {\n-        NKikimrTabletBase::TEvPong &record = ev->Get()->Record;\n-        const ui64 tabletId = record.GetTabletID();\n+        BLOG_TRACE(\"Handle TEvPong tabletId: \" << tabletId << \" actor: \" << ev->Sender << \" cookie: \" << ev->Cookie);\n \n-        TAutoPtr<TEntry>* entryHolder = FindEntry(tabletId);\n-        if (!entryHolder) {\n-            LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, \"Handle TEvPong tabletId: %\" PRIu64 \" no entryHolder\",\n-                tabletId);\n+        auto it = Tablets.find(tabletId);\n+        if (it == Tablets.end()) {\n             return;\n         }\n-        TEntry &entry = *entryHolder->Get();\n-\n-        LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, \"Handle TEvPong tabletId: %\" PRIu64 \" entry.State: %s\",\n-            tabletId, TEntry::StateToString(entry.State));\n-\n-        switch (entry.State) {\n-        case TEntry::StInit:\n-        case TEntry::StInitResolve:\n-        case TEntry::StNormal:\n-        case TEntry::StProblemResolve:\n-        case TEntry::StFollowerUpdate:\n-            break;\n-        case TEntry::StProblemPing:\n-            if (ev->Sender == entry.KnownLeader) {\n-                entry.Cookie.Detach();\n-                entry.State = TEntry::StNormal;\n-                SendQueued(tabletId, entry, ctx);\n-                MoveEntryToResolved(tabletId, *entryHolder);\n-            }\n-            break;\n-        default:\n-            Y_ABORT();\n-        }\n-    }\n-\n-    void Handle(TEvents::TEvUndelivered::TPtr &ev, const TActorContext &ctx) {\n-        // cold be Ping or Initial Statestorage resolve\n-        const ui64 tabletId = ev->Cookie;\n-        TAutoPtr<TEntry>* entryHolder = FindEntry(tabletId);\n-        if (!entryHolder)\n-            return;\n \n-        TEntry &entry = *entryHolder->Get();\n-        if (ev->Get()->SourceType == TEvStateStorage::TEvLookup::EventType) {\n-            InFlyResolveCounter->Dec();\n-            DropEntry(tabletId, entry, ctx);\n+        TEntry& entry = it->second;\n+        if (ev->Sender != entry.KnownLeader || entry.CurrentLeaderProblemPermanent) {\n             return;\n         }\n \n-        switch (entry.State) {\n-        case TEntry::StInit:\n-        case TEntry::StInitResolve:\n-        case TEntry::StNormal:\n-        case TEntry::StProblemResolve:\n-        case TEntry::StFollowerUpdate:\n-            break;\n-        case TEntry::StProblemPing:\n-            if (ev->Sender == entry.KnownLeader) {\n-                DropEntry(tabletId, entry, ctx);\n-            }\n-            break;\n-        default:\n-            Y_ABORT();\n+        if (ev->Cookie == 0 || ev->Cookie == entry.CacheEpoch) {\n+            // We have confirmed this tablet instance was alive in the current cache epoch\n+            // Note: older versions don't relay request cookie and it will always be zero\n+            entry.MarkLeaderAlive();\n         }\n     }\n \n-    void Handle(TEvPrivate::TEvPingTimeout::TPtr &ev, const TActorContext &ctx) {\n-        TEvPrivate::TEvPingTimeout *msg = ev->Get();\n-        const ui64 tabletId = msg->TabletID;\n+    void Handle(TEvInterconnect::TEvNodeConnected::TPtr& ev) {\n+        auto& session = InterconnectSessions[ev->Sender];\n \n-        TAutoPtr<TEntry>* entryHolder = FindEntry(tabletId);\n-        if (!entryHolder) {\n-            LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, \"Handle TEvPingTimeout tabletId: %\" PRIu64\n-                \" no entryHolder\", tabletId);\n-            return;\n+        auto it = EventStreams.find(ev->Cookie);\n+        if (it != EventStreams.end()) {\n+            session.EventStreams.PushBack(it->second);\n+            it->second->OnConnect();\n         }\n-        TEntry &entry = *entryHolder->Get();\n-\n-        LOG_DEBUG(ctx, NKikimrServices::TABLET_RESOLVER, \"Handle TEvPingTimeout tabletId: %\" PRIu64 \" entry.State: %s\",\n-            tabletId, TEntry::StateToString(entry.State));\n+    }\n \n-        switch (entry.State) {\n-        case TEntry::StInit:\n-        case TEntry::StInitResolve:\n-        case TEntry::StNormal:\n-        case TEntry::StProblemResolve:\n-        case TEntry::StFollowerUpdate:\n-            break;\n-        case TEntry::StProblemPing:\n-            if (msg->Cookie.DetachEvent()) {\n-                DropEntry(tabletId, entry, ctx);\n+    void Handle(TEvInterconnect::TEvNodeDisconnected::TPtr& ev) {\n+        auto itSession = InterconnectSessions.find(ev->Sender);\n+        if (itSession != InterconnectSessions.end()) {\n+            auto& session = itSession->second;\n+            while (!session.EventStreams.Empty()) {\n+                auto* stream = session.EventStreams.PopFront();\n+                stream->OnDisconnect();\n             }\n-            break;\n-        default:\n-            Y_ABORT();\n+            InterconnectSessions.erase(itSession);\n         }\n-    }\n \n-    void Handle(TEvPrivate::TEvStopListRemoval::TPtr &ev, const TActorContext &) {\n-        TEvPrivate::TEvStopListRemoval *msg = ev->Get();\n-        TabletsOnStopList.erase(msg->TabletID);\n+        auto it = EventStreams.find(ev->Cookie);\n+        if (it != EventStreams.end() && !it->second->HadConnect()) {\n+            it->second->OnDisconnect();\n+        }\n     }\n \n-    void Handle(TEvInterconnect::TEvNodesInfo::TPtr &ev, const TActorContext &ctx) {\n-        Y_UNUSED(ctx);\n+    void HandleStream(IEventHandle::TPtr& ev) {\n+        auto it = EventStreams.find(ev->Cookie);\n+        if (it != EventStreams.end()) {\n+            it->second->OnEvent(std::move(ev));\n+        }\n+    }\n \n-        const TEvInterconnect::TEvNodesInfo *msg = ev->Get();\n+    void Handle(TEvInterconnect::TEvNodesInfo::TPtr& ev) {\n+        const TEvInterconnect::TEvNodesInfo* msg = ev->Get();\n         bool distinct = false;\n-        for (const auto &nodeInfo : msg->Nodes) {\n+        for (const auto& nodeInfo : msg->Nodes) {\n             if (nodeInfo.Location.GetDataCenterId() != msg->Nodes[0].Location.GetDataCenterId())\n                 distinct = true;\n             NodeToDcMapping[nodeInfo.NodeId] = nodeInfo.Location.GetDataCenterId();\n@@ -809,15 +994,23 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {\n         if (!distinct)\n             NodeToDcMapping.clear();\n \n-        ctx.Schedule(TabletResolverRefreshNodesPeriod, new TEvPrivate::TEvRefreshNodes);\n+        Schedule(TabletResolverRefreshNodesPeriod, new TEvPrivate::TEvRefreshNodes);\n+    }\n+\n+    void Handle(TEvPrivate::TEvRefreshNodes::TPtr&) {\n+        RefreshNodes();\n     }\n \n-    void Handle(TEvPrivate::TEvRefreshNodes::TPtr &, const TActorContext &ctx) {\n-        RefreshNodes(ctx);\n+    void RefreshNodes() {\n+        Send(GetNameserviceActorId(), new TEvInterconnect::TEvListNodes());\n     }\n \n-    void RefreshNodes(const TActorContext &ctx) {\n-        ctx.Send(GetNameserviceActorId(), new TEvInterconnect::TEvListNodes());\n+    void OnEvictEntry(TEntry& entry) {\n+        entry.InCache = false;\n+        if (entry.State == TEntry::StNormal) {\n+            entry.State = TEntry::StRemove;\n+            entry.Wakeup.NotifyOne();\n+        }\n     }\n \n public:\n@@ -825,35 +1018,34 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {\n         return NKikimrServices::TActivity::TABLET_RESOLVER_ACTOR;\n     }\n \n-    TTabletResolver(const TIntrusivePtr<TTabletResolverConfig> &config)\n+    TTabletResolver(const TIntrusivePtr<TTabletResolverConfig>& config)\n         : Config(config)\n-        , ActorSystem(nullptr)\n-        , ResolvedTablets(new NCache::T2QCacheConfig())\n+        , TabletCache(new NCache::T2QCacheConfig())\n     {\n-        ResolvedTablets.SetOverflowCallback([=, this](const NCache::ICache<ui64, TAutoPtr<TEntry>>& cache) {\n+        TabletCache.SetOverflowCallback([this](const NCache::ICache<ui64, TEntry*>& cache) {\n             return cache.GetUsedSize() >= Config->TabletCacheLimit;\n         });\n \n-        ResolvedTablets.SetEvictionCallback([&](const ui64& key, TAutoPtr<TEntry>& value, ui64 size) {\n+        TabletCache.SetEvictionCallback([this](const ui64& key, TEntry*& value, ui64 size) {\n+            Y_UNUSED(key);\n             Y_UNUSED(size);\n \n-            if (!value)\n+            if (!value) {\n+                // Moved from, but not erased?\n                 return;\n-\n-            auto& queue = value->Queue;\n-            while (TEntry::TQueueEntry* x = queue.Head()) {\n-                ActorSystem->Send(x->Ev->Sender, new TEvTabletResolver::TEvForwardResult(NKikimrProto::RACE, key));\n-                queue.Pop();\n             }\n+\n+            OnEvictEntry(*value);\n         });\n     }\n \n     ~TTabletResolver() {\n-        ResolvedTablets.SetEvictionCallback(&TResolvedTablets::DefaultEvictionCallback);\n+        TabletCache.SetEvictionCallback(&TTabletCache::DefaultEvictionCallback);\n+        TabletCache.SetOverflowCallback(&TTabletCache::DefaultOverflowCallback);\n     }\n \n-    void Bootstrap(const TActorContext &ctx) {\n-        RefreshNodes(ctx);\n+    void Bootstrap() {\n+        RefreshNodes();\n         Become(&TThis::StateWork);\n \n         auto tablets = GetServiceCounters(AppData()->Counters, \"tablets\");\n@@ -871,25 +1063,25 @@ class TTabletResolver : public TActorBootstrapped<TTabletResolver> {\n \n     STFUNC(StateWork) {\n         switch (ev->GetTypeRewrite()) {\n-            HFunc(TEvTabletResolver::TEvForward, Handle);\n-            HFunc(TEvTabletResolver::TEvTabletProblem, Handle);\n-            HFunc(TEvTabletResolver::TEvNodeProblem, Handle);\n-            HFunc(TEvStateStorage::TEvInfo, Handle);\n-            HFunc(TEvTablet::TEvPong, Handle);\n-            HFunc(TEvPrivate::TEvPingTimeout, Handle);\n-            HFunc(TEvPrivate::TEvStopListRemoval, Handle);\n-            HFunc(TEvInterconnect::TEvNodesInfo, Handle);\n-            HFunc(TEvPrivate::TEvRefreshNodes, Handle);\n-            HFunc(TEvents::TEvUndelivered, Handle);\n+            hFunc(TEvTabletResolver::TEvForward, Handle);\n+            hFunc(TEvTabletResolver::TEvTabletProblem, Handle);\n+            hFunc(TEvTabletResolver::TEvNodeProblem, Handle);\n+            hFunc(TEvTablet::TEvPong, Handle);\n+            hFunc(TEvInterconnect::TEvNodeConnected, Handle);\n+            hFunc(TEvInterconnect::TEvNodeDisconnected, Handle);\n+            fFunc(TEvStateStorage::TEvInfo::EventType, HandleStream);\n+            fFunc(TEvTablet::TEvTabletStateUpdate::EventType, HandleStream);\n+            fFunc(TEvents::TEvUndelivered::EventType, HandleStream);\n+            hFunc(TEvInterconnect::TEvNodesInfo, Handle);\n+            hFunc(TEvPrivate::TEvRefreshNodes, Handle);\n             default:\n-                LOG_WARN(*TlsActivationContext, NKikimrServices::TABLET_RESOLVER, \"TTabletResolver::StateWork unexpected event type: %\" PRIx32\n-                    \" event: %s\", ev->GetTypeRewrite(), ev->ToString().data());\n+                BLOG_WARN(\"TTabletResolver::StateWork unexpected event type: \" << Hex(ev->GetTypeRewrite()) << \" event: \" << ev->ToString());\n                 break;\n         }\n     }\n };\n \n-IActor* CreateTabletResolver(const TIntrusivePtr<TTabletResolverConfig> &config) {\n+IActor* CreateTabletResolver(const TIntrusivePtr<TTabletResolverConfig>& config) {\n     return new TTabletResolver(config);\n }\n \ndiff --git a/ydb/core/tablet/tablet_sys.cpp b/ydb/core/tablet/tablet_sys.cpp\nindex e1800cf7a1f5..b41c8655c43c 100644\n--- a/ydb/core/tablet/tablet_sys.cpp\n+++ b/ydb/core/tablet/tablet_sys.cpp\n@@ -305,13 +305,13 @@ void TTablet::HandlePingBoot(TEvTablet::TEvPing::TPtr &ev) {\n     // todo: handle wait-boot flag\n     NKikimrTabletBase::TEvPing &record = ev->Get()->Record;\n     Y_ABORT_UNLESS(record.GetTabletID() == TabletID());\n-    Send(ev->Sender, new TEvTablet::TEvPong(TabletID(), TEvTablet::TEvPong::FlagBoot | TEvTablet::TEvPong::FlagLeader));\n+    Send(ev->Sender, new TEvTablet::TEvPong(TabletID(), TEvTablet::TEvPong::FlagBoot | TEvTablet::TEvPong::FlagLeader), 0, ev->Cookie);\n }\n \n void TTablet::HandlePingFollower(TEvTablet::TEvPing::TPtr &ev) {\n     NKikimrTabletBase::TEvPing &record = ev->Get()->Record;\n     Y_ABORT_UNLESS(record.GetTabletID() == TabletID());\n-    Send(ev->Sender, new TEvTablet::TEvPong(TabletID(), TEvTablet::TEvPong::FlagFollower));\n+    Send(ev->Sender, new TEvTablet::TEvPong(TabletID(), TEvTablet::TEvPong::FlagFollower), 0, ev->Cookie);\n }\n \n void TTablet::HandleStateStorageLeaderResolve(TEvStateStorage::TEvInfo::TPtr &ev) {\n@@ -1063,7 +1063,7 @@ void TTablet::HandleWriteZeroEntry(TEvTabletBase::TEvWriteLogResult::TPtr &ev) {\n void TTablet::Handle(TEvTablet::TEvPing::TPtr &ev) {\n     NKikimrTabletBase::TEvPing &record = ev->Get()->Record;\n     Y_ABORT_UNLESS(record.GetTabletID() == TabletID());\n-    Send(ev->Sender, new TEvTablet::TEvPong(TabletID(), TEvTablet::TEvPong::FlagLeader));\n+    Send(ev->Sender, new TEvTablet::TEvPong(TabletID(), TEvTablet::TEvPong::FlagLeader), 0, ev->Cookie);\n }\n \n void TTablet::HandleByLeader(TEvTablet::TEvTabletActive::TPtr &ev) {\ndiff --git a/ydb/core/tablet/ya.make b/ydb/core/tablet/ya.make\nindex a9979cc56375..c1586e88a35d 100644\n--- a/ydb/core/tablet/ya.make\n+++ b/ydb/core/tablet/ya.make\n@@ -58,6 +58,7 @@ SRCS(\n )\n \n PEERDIR(\n+    ydb/library/actors/async\n     ydb/library/actors/core\n     ydb/library/actors/helpers\n     ydb/library/actors/protos\n",
  "test_patch": "diff --git a/ydb/core/base/statestorage_proxy.cpp b/ydb/core/base/statestorage_proxy.cpp\nindex 9c01435c226a..90579cde3c6f 100644\n--- a/ydb/core/base/statestorage_proxy.cpp\n+++ b/ydb/core/base/statestorage_proxy.cpp\n@@ -39,6 +39,7 @@ class TStateStorageProxyRequest : public TActor<TStateStorageProxyRequest> {\n     TActorId SuggestedLeader;\n     TActorId SuggestedLeaderTablet;\n     TActorId Source;\n+    ui64 SourceCookie = 0;\n \n     ui32 Replicas;\n     THolder<TStateStorageInfo::TSelection> ReplicaSelection;\n@@ -91,12 +92,12 @@ class TStateStorageProxyRequest : public TActor<TStateStorageProxyRequest> {\n             }\n         }\n         if (NotifyRingGroupProxy)\n-            Send(Source, new TEvStateStorage::TEvRingGroupPassAway());\n+            Send(Source, new TEvStateStorage::TEvRingGroupPassAway(), 0, SourceCookie);\n         TActor::PassAway();\n     }\n \n     void Reply(NKikimrProto::EReplyStatus status) {\n-        Send(Source, new TEvStateStorage::TEvInfo(status, TabletID, Cookie, ReplyLeader, ReplyLeaderTablet, ReplyGeneration, ReplyStep, ReplyLocked, ReplyLockedFor, Signature, Followers));\n+        Send(Source, new TEvStateStorage::TEvInfo(status, TabletID, Cookie, ReplyLeader, ReplyLeaderTablet, ReplyGeneration, ReplyStep, ReplyLocked, ReplyLockedFor, Signature, Followers), 0, SourceCookie);\n     }\n \n     void ReplyAndDie(NKikimrProto::EReplyStatus status) {\n@@ -193,7 +194,7 @@ class TStateStorageProxyRequest : public TActor<TStateStorageProxyRequest> {\n             (Info->ClusterStateGeneration == clusterStateGeneration && Info->ClusterStateGuid != clusterStateGuid)) {\n             BLOG_D(\"StateStorageProxy TEvNodeWardenNotifyConfigMismatch: Info->ClusterStateGeneration=\" << Info->ClusterStateGeneration << \" clusterStateGeneration=\" << clusterStateGeneration <<\" Info->ClusterStateGuid=\" << Info->ClusterStateGuid << \" clusterStateGuid=\" << clusterStateGuid);\n             if (NotifyRingGroupProxy) {\n-                Send(Source, new TEvStateStorage::TEvConfigVersionInfo(clusterStateGeneration, clusterStateGuid));\n+                Send(Source, new TEvStateStorage::TEvConfigVersionInfo(clusterStateGeneration, clusterStateGuid), 0, SourceCookie);\n             }\n             Send(MakeBlobStorageNodeWardenID(SelfId().NodeId()),\n                 new NStorage::TEvNodeWardenNotifyConfigMismatch(sender.NodeId(), clusterStateGeneration, clusterStateGuid));\n@@ -285,6 +286,7 @@ class TStateStorageProxyRequest : public TActor<TStateStorageProxyRequest> {\n         TEvStateStorage::TEvLookup *msg = ev->Get();\n         BLOG_D(\"ProxyRequest::HandleInit ringGroup:\" << RingGroupIndex << \" ev: \" << msg->ToString());\n         Source = ev->Sender;\n+        SourceCookie = ev->Cookie;\n \n         PrepareInit(msg);\n         SendRequest([this](ui64 cookie, TActorId /*replica*/) { return new TEvStateStorage::TEvReplicaLookup(TabletID, cookie, Info->ClusterStateGeneration, Info->ClusterStateGuid); });\n@@ -296,6 +298,7 @@ class TStateStorageProxyRequest : public TActor<TStateStorageProxyRequest> {\n         TEvStateStorage::TEvUpdate *msg = ev->Get();\n         BLOG_D(\"ProxyRequest::HandleInit ringGroup:\" << RingGroupIndex << \" ev: \" << msg->ToString());\n         Source = ev->Sender;\n+        SourceCookie = ev->Cookie;\n \n         PrepareInit(msg);\n \n@@ -313,6 +316,7 @@ class TStateStorageProxyRequest : public TActor<TStateStorageProxyRequest> {\n         TEvStateStorage::TEvLock *msg = ev->Get();\n         BLOG_D(\"ProxyRequest::HandleInit ringGroup:\" << RingGroupIndex << \" ev: \" << msg->ToString());\n         Source = ev->Sender;\n+        SourceCookie = ev->Cookie;\n \n         PrepareInit(msg);\n \n@@ -496,7 +500,7 @@ class TStateStorageProxyRequest : public TActor<TStateStorageProxyRequest> {\n             ++SignaturesMerged;\n \n             if (RepliesMerged + RepliesAfterReply == Replicas) {\n-                Send(Source, new TEvStateStorage::TEvUpdateSignature(TabletID, Signature));\n+                Send(Source, new TEvStateStorage::TEvUpdateSignature(TabletID, Signature), 0, SourceCookie);\n                 return PassAway();\n             }\n         }\n@@ -514,7 +518,7 @@ class TStateStorageProxyRequest : public TActor<TStateStorageProxyRequest> {\n         MergeSigNodeError(node);\n \n         if (RepliesMerged + RepliesAfterReply == Replicas) {\n-            Send(Source, new TEvStateStorage::TEvUpdateSignature(TabletID, Signature));\n+            Send(Source, new TEvStateStorage::TEvUpdateSignature(TabletID, Signature), 0, SourceCookie);\n             return PassAway();\n         }\n     }\n@@ -543,7 +547,7 @@ class TStateStorageProxyRequest : public TActor<TStateStorageProxyRequest> {\n     void HandleUpdateSigTimeout() {\n         BLOG_D(\"ProxyRequest::HandleUpdateSigTimeout ringGroup:\" << RingGroupIndex << \" RepliesAfterReply# \" << (ui32)RepliesAfterReply);\n         if (RepliesAfterReply > 0)\n-            Send(Source, new TEvStateStorage::TEvUpdateSignature(TabletID, Signature));\n+            Send(Source, new TEvStateStorage::TEvUpdateSignature(TabletID, Signature), 0, SourceCookie);\n         PassAway();\n     }\n \n@@ -646,6 +650,7 @@ class TStateStorageRingGroupProxyRequest : public TActorBootstrapped<TStateStora\n     THashMap<ui32, TActorId> RingGroupActorsByIndex;\n \n     TActorId Source;\n+    ui64 SourceCookie = 0;\n     THashSet<TActorId> Replies;\n     ui32 RingGroupPassAwayCounter;\n     bool WaitAllReplies;\n@@ -666,6 +671,7 @@ class TStateStorageRingGroupProxyRequest : public TActorBootstrapped<TStateStora\n     void HandleInit(TEvStateStorage::TEvLookup::TPtr &ev) {\n         TEvStateStorage::TEvLookup *msg = ev->Get();\n         Source = ev->Sender;\n+        SourceCookie = ev->Cookie;\n         WaitAllReplies = msg->ProxyOptions.SigWaitMode != msg->ProxyOptions.SigNone;\n         BLOG_D(\"RingGroupProxyRequest::HandleInit ev: \" << msg->ToString());\n         for (ui32 ringGroupIndex = 0; ringGroupIndex < Info->RingGroups.size(); ++ringGroupIndex) {\n@@ -685,6 +691,7 @@ class TStateStorageRingGroupProxyRequest : public TActorBootstrapped<TStateStora\n     void HandleInit(T::TPtr &ev) {\n         T *msg = ev->Get();\n         Source = ev->Sender;\n+        SourceCookie = ev->Cookie;\n         WaitAllReplies = true;\n         BLOG_D(\"RingGroupProxyRequest::HandleInit ev: \" << msg->ToString());\n         for (ui32 ringGroupIndex = 0; ringGroupIndex < Info->RingGroups.size(); ++ringGroupIndex) {\n@@ -720,7 +727,7 @@ class TStateStorageRingGroupProxyRequest : public TActorBootstrapped<TStateStora\n     void Reply(NKikimrProto::EReplyStatus status) {\n         auto* msg = new TEvStateStorage::TEvInfo(status, TabletID, Cookie, CurrentLeader, CurrentLeaderTablet, CurrentGeneration, CurrentStep, Locked, LockedFor, Signature, Followers);\n         BLOG_D(\"RingGroupProxyRequest::Reply ev: \" << msg->ToString());\n-        Send(Source, msg);\n+        Send(Source, msg, 0, SourceCookie);\n     }\n \n     bool ShouldReply() {\n@@ -750,7 +757,7 @@ class TStateStorageRingGroupProxyRequest : public TActorBootstrapped<TStateStora\n     void HandleResult(TEvStateStorage::TEvUpdateSignature::TPtr &ev) {\n         TEvStateStorage::TEvUpdateSignature *msg = ev->Get();\n         Signature.Merge(msg->Signature);\n-        Send(Source, new TEvStateStorage::TEvUpdateSignature(msg->TabletID, Signature));\n+        Send(Source, new TEvStateStorage::TEvUpdateSignature(msg->TabletID, Signature), 0, SourceCookie);\n     }\n \n     void HandleConfigVersion(TEvStateStorage::TEvConfigVersionInfo::TPtr &ev) {\n@@ -806,6 +813,7 @@ class TStateStorageRingGroupProxyRequest : public TActorBootstrapped<TStateStora\n class TStateStorageDumpRequest : public TActorBootstrapped<TStateStorageDumpRequest> {\n protected:\n     const TActorId Sender;\n+    const ui64 Cookie;\n     TIntrusivePtr<TStateStorageInfo> Info;\n     TList<TActorId> AllReplicas;\n     TAutoPtr<TEvStateStorage::TEvResponseReplicasDumps> Response;\n@@ -816,14 +824,15 @@ class TStateStorageDumpRequest : public TActorBootstrapped<TStateStorageDumpRequ\n         return NKikimrServices::TActivity::TABLET_FORWARDING_ACTOR;\n     }\n \n-    TStateStorageDumpRequest(const TActorId &sender, const TIntrusivePtr<TStateStorageInfo> &info)\n+    TStateStorageDumpRequest(const TActorId &sender, ui64 cookie, const TIntrusivePtr<TStateStorageInfo> &info)\n         : Sender(sender)\n+        , Cookie(cookie)\n         , Info(info)\n         , UndeliveredCount(0)\n     {}\n \n     void SendResponse() {\n-        Send(Sender, Response.Release());\n+        Send(Sender, Response.Release(), 0, Cookie);\n         PassAway();\n     }\n \n@@ -873,6 +882,7 @@ class TStateStorageDumpRequest : public TActorBootstrapped<TStateStorageDumpRequ\n class TStateStorageDeleteRequest : public TActorBootstrapped<TStateStorageDeleteRequest> {\n protected:\n     const TActorId Sender;\n+    const ui64 Cookie;\n     TIntrusivePtr<TStateStorageInfo> Info;\n     TList<TActorId> AllReplicas;\n     ui32 Count;\n@@ -884,8 +894,9 @@ class TStateStorageDeleteRequest : public TActorBootstrapped<TStateStorageDelete\n         return NKikimrServices::TActivity::TABLET_FORWARDING_ACTOR;\n     }\n \n-    TStateStorageDeleteRequest(const TActorId &sender, const TIntrusivePtr<TStateStorageInfo> &info, ui64 tabletId)\n+    TStateStorageDeleteRequest(const TActorId &sender, ui64 cookie, const TIntrusivePtr<TStateStorageInfo> &info, ui64 tabletId)\n         : Sender(sender)\n+        , Cookie(cookie)\n         , Info(info)\n         , Count(0)\n         , UndeliveredCount(0)\n@@ -893,7 +904,7 @@ class TStateStorageDeleteRequest : public TActorBootstrapped<TStateStorageDelete\n     {}\n \n     void SendResponse() {\n-        Send(Sender, new TEvStateStorage::TEvDeleteResult(TabletID, Count > AllReplicas.size() / 2 ? NKikimrProto::OK : NKikimrProto::ERROR));\n+        Send(Sender, new TEvStateStorage::TEvDeleteResult(TabletID, Count > AllReplicas.size() / 2 ? NKikimrProto::OK : NKikimrProto::ERROR), 0, Cookie);\n         PassAway();\n     }\n \n@@ -957,11 +968,11 @@ class TStateStorageProxy : public TActor<TStateStorageProxy> {\n     THashSet<std::tuple<TActorId, ui64>> SchemeBoardSubscriptions;\n \n     void Handle(TEvStateStorage::TEvRequestReplicasDumps::TPtr &ev) {\n-        TActivationContext::Register(new TStateStorageDumpRequest(ev->Sender, Info));\n+        TActivationContext::Register(new TStateStorageDumpRequest(ev->Sender, ev->Cookie, Info));\n     }\n \n     void Handle(TEvStateStorage::TEvDelete::TPtr &ev) {\n-        TActivationContext::Register(new TStateStorageDeleteRequest(ev->Sender, Info, ev->Get()->TabletID));\n+        TActivationContext::Register(new TStateStorageDeleteRequest(ev->Sender, ev->Cookie, Info, ev->Get()->TabletID));\n     }\n \n     void SpreadCleanupRequest(const TStateStorageInfo::TSelection &selection, ui64 tabletId, TActorId proposedLeader) {\ndiff --git a/ydb/core/testlib/actors/test_runtime.cpp b/ydb/core/testlib/actors/test_runtime.cpp\nindex 30ebf1ceb3b3..e52f92f2f15d 100644\n--- a/ydb/core/testlib/actors/test_runtime.cpp\n+++ b/ydb/core/testlib/actors/test_runtime.cpp\n@@ -243,7 +243,8 @@ namespace NActors {\n                 MonPorts.push_back(port);\n             }\n \n-            node->ActorSystem->Start();\n+            StartActorSystem(nodeIndex, node);\n+\n             if (nodeAppData->Mon) {\n                 nodeAppData->Mon->Start(node->ActorSystem.Get());\n             }\ndiff --git a/ydb/core/testlib/basics/services.cpp b/ydb/core/testlib/basics/services.cpp\nindex f0a16ca8bde0..f0b17579a00f 100644\n--- a/ydb/core/testlib/basics/services.cpp\n+++ b/ydb/core/testlib/basics/services.cpp\n@@ -86,6 +86,9 @@ namespace NPDisk {\n         IActor* tabletResolver = CreateTabletResolver(tabletResolverConfig);\n         runtime.AddLocalService(MakeTabletResolverID(),\n             TActorSetupCmd(tabletResolver, TMailboxType::Revolving, 0), nodeIndex);\n+\n+        // TabletResolver needs timers for retries\n+        runtime.EnableScheduleForActor(MakeTabletResolverID());\n     }\n \n     void SetupTabletPipePerNodeCaches(TTestActorRuntime& runtime, ui32 nodeIndex, bool forceFollowers)\ndiff --git a/ydb/library/actors/testlib/test_runtime.cpp b/ydb/library/actors/testlib/test_runtime.cpp\nindex 951b35910a28..290f65b30e36 100644\n--- a/ydb/library/actors/testlib/test_runtime.cpp\n+++ b/ydb/library/actors/testlib/test_runtime.cpp\n@@ -557,7 +557,7 @@ namespace NActors {\n             node->ActorSystem = MakeActorSystem(nodeIndex, node);\n         }\n \n-        node->ActorSystem->Start();\n+        StartActorSystem(nodeIndex, node);\n     }\n \n     bool TTestActorRuntimeBase::AllowSendFrom(TNodeDataBase* node, TAutoPtr<IEventHandle>& ev) {\n@@ -1606,12 +1606,12 @@ namespace NActors {\n         TGuard<TMutex> guard(Mutex);\n         if (allow) {\n             if (VERBOSE) {\n-                Cerr << \"Actor \" << actorId << \" added to schedule whitelist\";\n+                Cerr << \"Actor \" << actorId << \" added to schedule whitelist\\n\";\n             }\n             ScheduleWhiteList.insert(actorId);\n         } else {\n             if (VERBOSE) {\n-                Cerr << \"Actor \" << actorId << \" removed from schedule whitelist\";\n+                Cerr << \"Actor \" << actorId << \" removed from schedule whitelist\\n\";\n             }\n             ScheduleWhiteList.erase(actorId);\n         }\n@@ -1842,6 +1842,27 @@ namespace NActors {\n         return actorSystem;\n     }\n \n+    void TTestActorRuntimeBase::StartActorSystem(ui32 nodeIndex, TNodeDataBase* node) {\n+        Y_UNUSED(nodeIndex);\n+\n+        node->ActorSystem->Start();\n+\n+        if (!UseRealThreads) {\n+            for (const auto& cmd : node->LocalServices) {\n+                auto it = ScheduleWhiteList.find(cmd.first);\n+                if (it != ScheduleWhiteList.end()) {\n+                    if (TActorId actorId = node->ActorSystem->LookupLocalService(cmd.first)) {\n+                        if (VERBOSE) {\n+                            Cerr << \"Service \" << cmd.first << \" actor \" << actorId << \" added to schedule whitelist\\n\";\n+                        }\n+                        ScheduleWhiteList.insert(actorId);\n+                        ScheduleWhiteListParent[actorId] = cmd.first;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     TActorSystem* TTestActorRuntimeBase::SingleSys() const {\n         Y_ABORT_UNLESS(Nodes.size() == 1, \"Works only for single system env\");\n \ndiff --git a/ydb/library/actors/testlib/test_runtime.h b/ydb/library/actors/testlib/test_runtime.h\nindex 1c2ce82138cc..c6f1c5f602ce 100644\n--- a/ydb/library/actors/testlib/test_runtime.h\n+++ b/ydb/library/actors/testlib/test_runtime.h\n@@ -679,6 +679,7 @@ namespace NActors {\n \n         THolder<TActorSystemSetup> MakeActorSystemSetup(ui32 nodeIndex, TNodeDataBase* node);\n         THolder<TActorSystem> MakeActorSystem(ui32 nodeIndex, TNodeDataBase* node);\n+        void StartActorSystem(ui32 nodeIndex, TNodeDataBase* node);\n         virtual void InitActorSystemSetup(TActorSystemSetup& setup, TNodeDataBase* node) {\n             Y_UNUSED(setup, node);\n         }\n",
  "problem_statement": "TabletResolver: track leader state and invalidate without pipes\nRFC: https://github.com/ydb-platform/ydb-rfc/blob/main/tablet_resolver_cache_invalidation.md\n",
  "hints_text": "",
  "created_at": "2025-07-29T10:37:24Z",
  "modified_files": [
    "ydb/core/cms/cms_ut.cpp",
    "ydb/core/cms/cms_ut_common.cpp",
    "ydb/core/cms/console/feature_flags_configurator_ut.cpp",
    "ydb/core/cms/console/immediate_controls_configurator_ut.cpp",
    "ydb/core/cms/console/jaeger_tracing_configurator_ut.cpp",
    "ydb/core/cms/console/log_settings_configurator_ut.cpp",
    "ydb/core/mind/dynamic_nameserver.cpp",
    "ydb/core/mind/hive/hive_ut.cpp",
    "ydb/core/mind/node_broker_ut.cpp",
    "ydb/core/quoter/kesus_quoter_ut.cpp",
    "ydb/core/tablet/tablet_pipe_ut.cpp",
    "ydb/core/tablet/tablet_resolver.cpp",
    "ydb/core/tablet/tablet_sys.cpp",
    "ydb/core/tablet/ya.make"
  ],
  "modified_test_files": [
    "ydb/core/base/statestorage_proxy.cpp",
    "ydb/core/testlib/actors/test_runtime.cpp",
    "ydb/core/testlib/basics/services.cpp",
    "ydb/library/actors/testlib/test_runtime.cpp",
    "ydb/library/actors/testlib/test_runtime.h"
  ]
}