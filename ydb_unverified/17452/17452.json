{
  "repo": "ydb-platform/ydb",
  "pull_number": 17452,
  "instance_id": "ydb-platform__ydb-17452",
  "issue_numbers": [
    "14903"
  ],
  "base_commit": "a709348f000d7b935edabb61364f9a365c1aee4b",
  "patch": "diff --git a/.github/config/muted_ya.txt b/.github/config/muted_ya.txt\nindex 32c1efeb9123..8c1ac1272637 100644\n--- a/.github/config/muted_ya.txt\n+++ b/.github/config/muted_ya.txt\n@@ -20,25 +20,6 @@ ydb/core/keyvalue/ut_trace TKeyValueTracingTest.WriteSmall\n ydb/core/kqp/ut/cost KqpCost.OlapWriteRow\n ydb/core/kqp/ut/olap KqpDecimalColumnShard.TestAggregation\n ydb/core/kqp/ut/olap KqpDecimalColumnShard.TestFilterCompare\n-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.BlobsSharingSplit1_1\n-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.BlobsSharingSplit1_1_clean\n-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.BlobsSharingSplit1_1_clean_with_restarts\n-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.BlobsSharingSplit1_3_1\n-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.BlobsSharingSplit1_3_2_1_clean\n-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.BlobsSharingSplit3_1\n-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.ChangeSchemaAndSplit\n-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.HugeSchemeHistory\n-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.MultipleMerge\n-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.MultipleMergesWithRestartsAfterWait\n-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.MultipleMergesWithRestartsWhenWait\n-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.MultipleSchemaVersions\n-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.MultipleSplits\n-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.MultipleSplitsThenMerges\n-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.MultipleSplitsWithRestartsAfterWait\n-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.MultipleSplitsWithRestartsWhenWait\n-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.TableReshardingConsistency64\n-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.TableReshardingModuloN\n-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.UpsertWhileSplitTest\n ydb/core/kqp/ut/olap KqpOlapJson.BloomIndexesVariants\n ydb/core/kqp/ut/olap KqpOlapSysView.StatsSysViewBytesDictActualization\n ydb/core/kqp/ut/olap KqpOlapSysView.StatsSysViewBytesDictStatActualization\n@@ -47,6 +28,9 @@ ydb/core/kqp/ut/olap [*/*] chunk chunk\n ydb/core/kqp/ut/query KqpAnalyze.AnalyzeTable+ColumnStore\n ydb/core/kqp/ut/query KqpAnalyze.AnalyzeTable-ColumnStore\n ydb/core/kqp/ut/query KqpStats.SysViewClientLost\n+ydb/core/kqp/ut/query KqpLimits.OutOfSpaceYQLUpsertFail+useSink\n+ydb/core/kqp/ut/query KqpLimits.QSReplySizeEnsureMemoryLimits+useSink\n+ydb/core/kqp/ut/query KqpStats.SysViewClientLost\n ydb/core/kqp/ut/scheme KqpOlapScheme.TenThousandColumns\n ydb/core/kqp/ut/scheme KqpScheme.AlterAsyncReplication\n ydb/core/kqp/ut/scheme [*/*] chunk chunk\n@@ -163,6 +147,13 @@ ydb/tests/functional/tpc/large test_tpcds.py.TestTpcdsS1.test_tpcds[36]\n ydb/tests/functional/tpc/large test_tpcds.py.TestTpcdsS1.test_tpcds[67]\n ydb/tests/functional/tpc/large test_tpcds.py.TestTpcdsS1.test_tpcds[86]\n ydb/tests/functional/tpc/large test_tpcds.py.TestTpcdsS1.test_tpcds[9]\n+ydb/tests/functional/tpc/large test_tpch_spilling.py.TestTpchSpillingS10.test_tpch[7]\n+ydb/tests/olap sole chunk chunk\n+ydb/tests/olap test_quota_exhaustion.py.TestYdbWorkload.test_delete\n+ydb/tests/olap/data_quotas test_quota_exhaustion.py.TestYdbWorkload.test_duplicates\n+ydb/tests/olap/column_family/compression alter_compression.py.TestAlterCompression.test_all_supported_compression\n+ydb/tests/olap/column_family/compression sole chunk chunk\n+ydb/tests/olap/oom overlapping_portions.py.TestOverlappingPortions.test\n ydb/tests/olap/scenario sole chunk chunk\n ydb/tests/olap/scenario test_alter_compression.py.TestAlterCompression.test[alter_compression]\n ydb/tests/olap/scenario test_alter_tiering.py.TestAlterTiering.test[many_tables]\n@@ -172,6 +163,7 @@ ydb/tests/olap/ttl_tiering data_migration_when_alter_ttl.py.TestDataMigrationWhe\n ydb/tests/olap/ttl_tiering sole chunk chunk\n ydb/tests/olap/ttl_tiering ttl_delete_s3.py.TestDeleteS3Ttl.test_data_unchanged_after_ttl_change\n ydb/tests/olap/ttl_tiering ttl_delete_s3.py.TestDeleteS3Ttl.test_ttl_delete\n+ydb/tests/olap/ttl_tiering ttl_delete_s3.py.TestDeleteS3Ttl.test_delete_s3_tiering\n ydb/tests/olap/ttl_tiering ttl_unavailable_s3.py.TestUnavailableS3.test\n ydb/tests/olap/ttl_tiering ttl_delete_s3.py.TestDeleteS3Ttl.test_delete_s3_tiering\n ydb/tests/olap/ttl_tiering unstable_connection.py.TestUnstableConnection.test\ndiff --git a/ydb/core/driver_lib/run/run.cpp b/ydb/core/driver_lib/run/run.cpp\nindex 30b9e40eb53c..4dfdb3a4e4a2 100644\n--- a/ydb/core/driver_lib/run/run.cpp\n+++ b/ydb/core/driver_lib/run/run.cpp\n@@ -149,6 +149,7 @@\n #include <ydb/library/actors/util/memory_track.h>\n #include <ydb/library/actors/prof/tag.h>\n #include <ydb/library/security/ydb_credentials_provider_factory.h>\n+#include <ydb/library/signal_backtrace/signal_backtrace.h>\n #include <yql/essentials/minikql/invoke_builtins/mkql_builtins.h>\n \n #include <util/charset/wide.h>\n@@ -1939,6 +1940,10 @@ void TKikimrRunner::SetSignalHandlers() {\n     signal(SIGINT, &TKikimrRunner::OnTerminate);\n     signal(SIGTERM, &TKikimrRunner::OnTerminate);\n \n+    if (IsTrue(GetEnv(\"YDB_ENABLE_SIGNAL_BACKTRACE\"))) {\n+        Singleton<TTraceCollector>(TTraceCollector::DEFAULT_SIGNALS);\n+    }\n+\n #if !defined(_win_)\n     SetAsyncSignalHandler(SIGHUP, [](int) {\n         TLogBackend::ReopenAllBackends();\ndiff --git a/ydb/core/driver_lib/run/ya.make b/ydb/core/driver_lib/run/ya.make\nindex 3be3072c6751..c1027bcef99f 100644\n--- a/ydb/core/driver_lib/run/ya.make\n+++ b/ydb/core/driver_lib/run/ya.make\n@@ -138,6 +138,7 @@ PEERDIR(\n     ydb/library/grpc/server/actors\n     ydb/library/pdisk_io\n     ydb/library/security\n+    ydb/library/signal_backtrace\n     ydb/library/yql/providers/pq/cm_client\n     ydb/library/yql/providers/s3/actors\n     ydb/public/lib/base\ndiff --git a/ydb/core/formats/arrow/accessor/abstract/accessor.cpp b/ydb/core/formats/arrow/accessor/abstract/accessor.cpp\nindex b1221c1bf8b6..152bae082d2e 100644\n--- a/ydb/core/formats/arrow/accessor/abstract/accessor.cpp\n+++ b/ydb/core/formats/arrow/accessor/abstract/accessor.cpp\n@@ -24,26 +24,7 @@ std::shared_ptr<arrow::Array> IChunkedArray::TReader::CopyRecord(const ui64 reco\n }\n \n std::shared_ptr<arrow::ChunkedArray> IChunkedArray::Slice(const ui32 offset, const ui32 count) const {\n-    AFL_VERIFY(offset + count <= (ui64)GetRecordsCount())(\"offset\", offset)(\"count\", count)(\"length\", GetRecordsCount());\n-    ui32 currentOffset = offset;\n-    ui32 countLeast = count;\n-    std::vector<std::shared_ptr<arrow::Array>> chunks;\n-    auto address = GetChunkSlow(offset);\n-    while (countLeast) {\n-        address = GetChunk(address.GetAddress(), currentOffset);\n-        const ui64 internalPos = address.GetAddress().GetLocalIndex(currentOffset);\n-        if (internalPos + countLeast <= (ui64)address.GetArray()->length()) {\n-            chunks.emplace_back(address.GetArray()->Slice(internalPos, countLeast));\n-            break;\n-        } else {\n-            const ui32 deltaCount = address.GetArray()->length() - internalPos;\n-            chunks.emplace_back(address.GetArray()->Slice(internalPos, deltaCount));\n-            AFL_VERIFY(countLeast >= deltaCount);\n-            countLeast -= deltaCount;\n-            currentOffset += deltaCount;\n-        }\n-    }\n-    return std::make_shared<arrow::ChunkedArray>(chunks, DataType);\n+    return GetChunkedArray(TColumnConstructionContext().SetStartIndex(offset).SetRecordsCount(count));\n }\n \n IChunkedArray::TFullDataAddress IChunkedArray::GetChunk(const std::optional<TAddressChain>& chunkCurrent, const ui64 position) const {\n@@ -62,10 +43,10 @@ IChunkedArray::TFullDataAddress IChunkedArray::GetChunk(const std::optional<TAdd\n         return TFullDataAddress(localAddress.GetArray(), std::move(addressChain));\n     } else {\n         auto chunkedArrayAddress = GetArray(chunkCurrent, position, nullptr);\n-        if (chunkCurrent) {\n-            AFL_VERIFY(chunkCurrent->GetSize() == 1 + chunkedArrayAddress.GetAddress().GetSize())(\"current\", chunkCurrent->GetSize())(\n-                                                      \"chunked\", chunkedArrayAddress.GetAddress().GetSize());\n-        }\n+        //        if (chunkCurrent) {\n+        //            AFL_VERIFY(chunkCurrent->GetSize() == chunkedArrayAddress.GetAddress().GetSize())(\"current\", chunkCurrent->GetSize())(\n+        //                                                      \"chunked\", chunkedArrayAddress.GetAddress().GetSize());\n+        //        }\n         auto localAddress = chunkedArrayAddress.GetArray()->GetLocalData(address, chunkedArrayAddress.GetAddress().GetLocalIndex(position));\n         auto fullAddress = std::move(chunkedArrayAddress.MutableAddress());\n         fullAddress.Add(localAddress.GetAddress());\n@@ -112,7 +93,7 @@ std::shared_ptr<IChunkedArray> IChunkedArray::DoApplyFilter(const TColumnFilter&\n     auto schema = std::make_shared<arrow::Schema>(fields);\n     auto table = arrow::Table::Make(schema, { arr }, GetRecordsCount());\n     AFL_VERIFY(table->num_columns() == 1);\n-    AFL_VERIFY(filter.Apply(table));\n+    filter.Apply(table);\n     if (table->column(0)->num_chunks() == 1) {\n         return std::make_shared<TTrivialArray>(table->column(0)->chunk(0));\n     } else {\n@@ -121,8 +102,8 @@ std::shared_ptr<IChunkedArray> IChunkedArray::DoApplyFilter(const TColumnFilter&\n }\n \n std::shared_ptr<IChunkedArray> IChunkedArray::ApplyFilter(const TColumnFilter& filter, const std::shared_ptr<IChunkedArray>& selfPtr) const {\n-    AFL_VERIFY(selfPtr);\n     if (filter.IsTotalAllowFilter()) {\n+        AFL_VERIFY(selfPtr);\n         return selfPtr;\n     }\n     if (filter.IsTotalDenyFilter()) {\n@@ -134,7 +115,7 @@ std::shared_ptr<IChunkedArray> IChunkedArray::ApplyFilter(const TColumnFilter& f\n     return result;\n }\n \n-std::shared_ptr<arrow::ChunkedArray> IChunkedArray::GetChunkedArray() const {\n+std::shared_ptr<arrow::ChunkedArray> IChunkedArray::GetChunkedArrayTrivial() const {\n     std::vector<std::shared_ptr<arrow::Array>> chunks;\n     std::optional<TFullDataAddress> address;\n     for (ui32 position = 0; position < GetRecordsCount();) {\n@@ -145,6 +126,23 @@ std::shared_ptr<arrow::ChunkedArray> IChunkedArray::GetChunkedArray() const {\n     return std::make_shared<arrow::ChunkedArray>(chunks, GetDataType());\n }\n \n+std::shared_ptr<arrow::ChunkedArray> IChunkedArray::GetChunkedArray(const TColumnConstructionContext& context) const {\n+    if (context.GetStartIndex() || context.GetRecordsCount()) {\n+        const ui32 start = context.GetStartIndex().value_or(0);\n+        const ui32 count = context.GetRecordsCount().value_or(GetRecordsCount() - start);\n+        auto slice = ISlice(start, count);\n+        if (context.GetFilter() && !context.GetFilter()->IsTotalAllowFilter()) {\n+            return slice->ApplyFilter(context.GetFilter()->Slice(start, count), slice)->GetChunkedArrayTrivial();\n+        } else {\n+            return slice->GetChunkedArrayTrivial();\n+        }\n+    } else if (context.GetFilter() && !context.GetFilter()->IsTotalAllowFilter()) {\n+        return ApplyFilter(*context.GetFilter(), nullptr)->GetChunkedArrayTrivial();\n+    } else {\n+        return GetChunkedArrayTrivial();\n+    }\n+}\n+\n TString IChunkedArray::TReader::DebugString(const ui32 position) const {\n     auto address = GetReadChunk(position);\n     return NArrow::DebugString(address.GetArray(), address.GetPosition());\ndiff --git a/ydb/core/formats/arrow/accessor/abstract/accessor.h b/ydb/core/formats/arrow/accessor/abstract/accessor.h\nindex 1bcd5989ebd4..09b5cea3e051 100644\n--- a/ydb/core/formats/arrow/accessor/abstract/accessor.h\n+++ b/ydb/core/formats/arrow/accessor/abstract/accessor.h\n@@ -1,5 +1,7 @@\n #pragma once\n \n+#include \"common.h\"\n+\n #include <ydb/library/accessor/accessor.h>\n #include <ydb/library/accessor/validator.h>\n #include <ydb/library/formats/arrow/splitter/similar_packer.h>\n@@ -264,6 +266,8 @@ class IChunkedArray {\n     virtual void DoVisitValues(const TValuesSimpleVisitor& visitor) const = 0;\n \n protected:\n+    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArrayTrivial() const;\n+\n     std::shared_ptr<arrow::Schema> GetArraySchema() const {\n         const arrow::FieldVector fields = { std::make_shared<arrow::Field>(\"val\", GetDataType()) };\n         return std::make_shared<arrow::Schema>(fields);\n@@ -344,7 +348,6 @@ class IChunkedArray {\n     }\n \n     virtual void Reallocate() {\n-\n     }\n \n     void VisitValues(const TValuesSimpleVisitor& visitor) const {\n@@ -444,7 +447,8 @@ class IChunkedArray {\n         return *result;\n     }\n \n-    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArray() const;\n+    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArray(\n+        const TColumnConstructionContext& context = Default<TColumnConstructionContext>()) const;\n     virtual ~IChunkedArray() = default;\n \n     std::shared_ptr<arrow::ChunkedArray> Slice(const ui32 offset, const ui32 count) const;\ndiff --git a/ydb/core/formats/arrow/accessor/abstract/common.cpp b/ydb/core/formats/arrow/accessor/abstract/common.cpp\nnew file mode 100644\nindex 000000000000..04fc014e1ee0\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/abstract/common.cpp\n@@ -0,0 +1,31 @@\n+#include \"common.h\"\n+\n+#include <ydb/core/formats/arrow/arrow_filter.h>\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+TColumnConstructionContext& TColumnConstructionContext::SetFilter(const std::shared_ptr<TColumnFilter>& val) {\n+    if (!val || val->IsTotalAllowFilter()) {\n+        Filter = nullptr;\n+    } else {\n+        Filter = val;\n+    }\n+    return *this;\n+}\n+\n+std::optional<TColumnConstructionContext> TColumnConstructionContext::Slice(const ui32 offset, const ui32 count) const {\n+    std::optional<TColumnConstructionContext> result;\n+    const ui32 start = std::max<ui32>(offset, StartIndex.value_or(0));\n+    const ui32 finish = std::min<ui32>(offset + count, StartIndex.value_or(0) + RecordsCount.value_or(offset + count));\n+    if (finish <= start) {\n+        result = std::nullopt;\n+    } else {\n+        result = TColumnConstructionContext().SetStartIndex(start - offset).SetRecordsCount(finish - start, count);\n+    }\n+    if (result && Filter) {\n+        result->SetFilter(std::make_shared<TColumnFilter>(Filter->Slice(offset, count)));\n+    }\n+    return result;\n+}\n+\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/core/formats/arrow/accessor/abstract/common.h b/ydb/core/formats/arrow/accessor/abstract/common.h\nnew file mode 100644\nindex 000000000000..95a8409451d5\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/abstract/common.h\n@@ -0,0 +1,47 @@\n+#pragma once\n+#include <ydb/library/accessor/accessor.h>\n+\n+#include <util/system/types.h>\n+\n+#include <memory>\n+#include <optional>\n+\n+namespace NKikimr::NArrow {\n+class TColumnFilter;\n+}\n+\n+namespace NKikimr::NArrow::NAccessor {\n+\n+class TColumnConstructionContext {\n+private:\n+    YDB_READONLY_DEF(std::optional<ui32>, StartIndex);\n+    YDB_ACCESSOR_DEF(std::optional<ui32>, RecordsCount);\n+    YDB_READONLY_DEF(std::shared_ptr<TColumnFilter>, Filter);\n+\n+public:\n+    TColumnConstructionContext& SetRecordsCount(const ui32 recordsCount, const ui32 defValue) {\n+        if (recordsCount == defValue) {\n+            RecordsCount.reset();\n+        } else {\n+            RecordsCount = recordsCount;\n+        }\n+        return *this;\n+    }\n+\n+    TColumnConstructionContext& SetStartIndex(const ui32 startIndex) {\n+        if (startIndex) {\n+            StartIndex = startIndex;\n+        } else {\n+            StartIndex.reset();\n+        }\n+        return *this;\n+    }\n+\n+    TColumnConstructionContext& SetFilter(const std::shared_ptr<TColumnFilter>& val);\n+\n+    std::optional<TColumnConstructionContext> Slice(const ui32 offset, const ui32 count) const;\n+\n+    TColumnConstructionContext() = default;\n+};\n+\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/core/formats/arrow/accessor/abstract/constructor.h b/ydb/core/formats/arrow/accessor/abstract/constructor.h\nindex 4dd908a82299..56b981e08edd 100644\n--- a/ydb/core/formats/arrow/accessor/abstract/constructor.h\n+++ b/ydb/core/formats/arrow/accessor/abstract/constructor.h\n@@ -33,6 +33,10 @@ class IConstructor {\n         const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& originalArray, const TChunkConstructionData& externalInfo) const = 0;\n \n public:\n+    virtual bool HasInternalConversion() const {\n+        return false;\n+    }\n+\n     IConstructor(const IChunkedArray::EType type)\n         : Type(type) {\n     }\ndiff --git a/ydb/core/formats/arrow/accessor/abstract/ya.make b/ydb/core/formats/arrow/accessor/abstract/ya.make\nindex 6b239c4ad15d..2940495d2a5c 100644\n--- a/ydb/core/formats/arrow/accessor/abstract/ya.make\n+++ b/ydb/core/formats/arrow/accessor/abstract/ya.make\n@@ -10,6 +10,7 @@ PEERDIR(\n )\n \n SRCS(\n+    common.cpp\n     constructor.cpp\n     request.cpp\n     accessor.cpp\ndiff --git a/ydb/core/formats/arrow/accessor/composite/accessor.cpp b/ydb/core/formats/arrow/accessor/composite/accessor.cpp\nindex 7afe8199c9fc..eef73d9970d2 100644\n--- a/ydb/core/formats/arrow/accessor/composite/accessor.cpp\n+++ b/ydb/core/formats/arrow/accessor/composite/accessor.cpp\n@@ -110,4 +110,24 @@ std::optional<bool> TCompositeChunkedArray::DoCheckOneValueAccessor(std::shared_\n     return true;\n }\n \n+std::shared_ptr<arrow::ChunkedArray> TCompositeChunkedArray::GetChunkedArray(const TColumnConstructionContext& context) const {\n+    ui32 pos = 0;\n+    std::vector<std::shared_ptr<arrow::Array>> chunks;\n+    for (auto&& i : Chunks) {\n+        auto sliceCtx = context.Slice(pos, i->GetRecordsCount());\n+        if (!sliceCtx) {\n+            if (chunks.size()) {\n+                break;\n+            } else {\n+                pos += i->GetRecordsCount();\n+                continue;\n+            }\n+        }\n+        std::shared_ptr<arrow::ChunkedArray> arr = i->GetChunkedArray(*sliceCtx);\n+        chunks.insert(chunks.end(), arr->chunks().begin(), arr->chunks().end());\n+        pos += i->GetRecordsCount();\n+    }\n+    return std::make_shared<arrow::ChunkedArray>(std::move(chunks));\n+}\n+\n }   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/core/formats/arrow/accessor/composite/accessor.h b/ydb/core/formats/arrow/accessor/composite/accessor.h\nindex 558b4046b3e1..dfce2c8d1f4d 100644\n--- a/ydb/core/formats/arrow/accessor/composite/accessor.h\n+++ b/ydb/core/formats/arrow/accessor/composite/accessor.h\n@@ -22,6 +22,8 @@ class TCompositeChunkedArray: public ICompositeChunkedArray {\n private:\n     YDB_READONLY_DEF(std::vector<std::shared_ptr<IChunkedArray>>, Chunks);\n \n+    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArray(const TColumnConstructionContext& context) const override;\n+\n     virtual void DoVisitValues(const TValuesSimpleVisitor& visitor) const override {\n         for (auto&& i : Chunks) {\n             i->VisitValues(visitor);\ndiff --git a/ydb/core/formats/arrow/accessor/composite_serial/accessor.cpp b/ydb/core/formats/arrow/accessor/composite_serial/accessor.cpp\nindex 7bd74612008a..bcebf9136f2a 100644\n--- a/ydb/core/formats/arrow/accessor/composite_serial/accessor.cpp\n+++ b/ydb/core/formats/arrow/accessor/composite_serial/accessor.cpp\n@@ -2,62 +2,26 @@\n \n #include <ydb/core/formats/arrow/accessor/sparsed/constructor.h>\n \n+#include <ydb/library/actors/core/log.h>\n #include <ydb/library/actors/prof/tag.h>\n \n namespace NKikimr::NArrow::NAccessor {\n \n-namespace {\n-class TSerializedChunkAccessor {\n-private:\n-    const std::vector<TDeserializeChunkedArray::TChunk>& Chunks;\n-    const std::shared_ptr<TColumnLoader>& Loader;\n-    std::optional<IChunkedArray::TLocalChunkedArrayAddress>& Result;\n-\n-public:\n-    TSerializedChunkAccessor(const std::vector<TDeserializeChunkedArray::TChunk>& chunks, const std::shared_ptr<TColumnLoader>& loader,\n-        std::optional<IChunkedArray::TLocalChunkedArrayAddress>& result)\n-        : Chunks(chunks)\n-        , Loader(loader)\n-        , Result(result) {\n-    }\n-    ui64 GetChunksCount() const {\n-        return Chunks.size();\n-    }\n-    ui64 GetChunkLength(const ui32 idx) const {\n-        return Chunks[idx].GetRecordsCount();\n-    }\n-    void OnArray(const ui32 chunkIdx, const ui32 startPosition) const {\n-        Result = IChunkedArray::TLocalChunkedArrayAddress(Chunks[chunkIdx].GetArrayVerified(Loader), startPosition, chunkIdx);\n-    }\n-};\n-\n-}   // namespace\n-\n-std::shared_ptr<IChunkedArray> TDeserializeChunkedArray::TChunk::GetArrayVerified(const std::shared_ptr<TColumnLoader>& loader) const {\n+IChunkedArray::TLocalChunkedArrayAddress TDeserializeChunkedArray::DoGetLocalChunkedArray(\n+    const std::optional<TCommonChunkAddress>& /*chunkCurrent*/, const ui64 /*position*/) const {\n     if (PredefinedArray) {\n-        return PredefinedArray;\n+        return TLocalChunkedArrayAddress(PredefinedArray, 0, 0);\n+    }\n+    if (Counter.Inc() > 1) {\n+        AFL_WARN(NKikimrServices::ARROW_HELPER)(\"event\", \"many_deserializations\")(\"counter\", Counter.Val())(\"size\", Data.size())(\n+            \"buffer\", DataBuffer.size());\n     }\n     if (!!Data) {\n-        return loader->ApplyVerified(Data, RecordsCount);\n+        return TLocalChunkedArrayAddress(Loader->ApplyVerified(Data, GetRecordsCount()), 0, 0);\n     } else {\n         AFL_VERIFY(!!DataBuffer);\n-        return loader->ApplyVerified(TString(DataBuffer.data(), DataBuffer.size()), RecordsCount);\n+        return TLocalChunkedArrayAddress(Loader->ApplyVerified(TString(DataBuffer.data(), DataBuffer.size()), GetRecordsCount()), 0, 0);\n     }\n }\n \n-IChunkedArray::TLocalDataAddress TDeserializeChunkedArray::DoGetLocalData(\n-    const std::optional<TCommonChunkAddress>& /*chunkCurrent*/, const ui64 /*position*/) const {\n-    AFL_VERIFY(false);\n-    return IChunkedArray::TLocalDataAddress(nullptr, 0, 0);\n-}\n-\n-IChunkedArray::TLocalChunkedArrayAddress TDeserializeChunkedArray::DoGetLocalChunkedArray(\n-    const std::optional<TCommonChunkAddress>& chunkCurrent, const ui64 position) const {\n-    std::optional<IChunkedArray::TLocalChunkedArrayAddress> result;\n-    TSerializedChunkAccessor accessor(Chunks, Loader, result);\n-    SelectChunk(chunkCurrent, position, accessor);\n-    AFL_VERIFY(result);\n-    return *result;\n-}\n-\n }   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/core/formats/arrow/accessor/composite_serial/accessor.h b/ydb/core/formats/arrow/accessor/composite_serial/accessor.h\nindex 1eb6459a4b41..81c9828fb4a3 100644\n--- a/ydb/core/formats/arrow/accessor/composite_serial/accessor.h\n+++ b/ydb/core/formats/arrow/accessor/composite_serial/accessor.h\n@@ -5,50 +5,23 @@\n \n namespace NKikimr::NArrow::NAccessor {\n \n-class TDeserializeChunkedArray: public ICompositeChunkedArray {\n+class TDeserializeChunkedArray: public IChunkedArray {\n private:\n-    using TBase = ICompositeChunkedArray;\n-\n-public:\n-    class TChunk {\n-    private:\n-        YDB_READONLY(ui32, RecordsCount, 0);\n-        std::shared_ptr<IChunkedArray> PredefinedArray;\n-        const TString Data;\n-        const TStringBuf DataBuffer;\n-\n-    public:\n-        TChunk(const std::shared_ptr<IChunkedArray>& predefinedArray)\n-            : PredefinedArray(predefinedArray) {\n-            AFL_VERIFY(PredefinedArray);\n-            RecordsCount = PredefinedArray->GetRecordsCount();\n-        }\n-\n-        TChunk(const ui32 recordsCount, const TString& data)\n-            : RecordsCount(recordsCount)\n-            , Data(data) {\n-        }\n-\n-        TChunk(const ui32 recordsCount, const TStringBuf dataBuffer)\n-            : RecordsCount(recordsCount)\n-            , DataBuffer(dataBuffer) {\n-        }\n-\n-        std::shared_ptr<IChunkedArray> GetArrayVerified(const std::shared_ptr<TColumnLoader>& loader) const;\n-    };\n-\n-private:\n-    std::shared_ptr<TColumnLoader> Loader;\n-    std::vector<TChunk> Chunks;\n-    const bool ForLazyInitialization = false;\n+    using TBase = IChunkedArray;\n+    const std::shared_ptr<TColumnLoader> Loader;\n+    std::shared_ptr<IChunkedArray> PredefinedArray;\n+    const TString Data;\n+    const TStringBuf DataBuffer;\n+    const bool ForLazyInitialization;\n+    mutable TAtomicCounter Counter = 0;\n \n+protected:\n+    virtual std::shared_ptr<IChunkedArray> DoISlice(const ui32 offset, const ui32 count) const override {\n+        return GetLocalChunkedArray(std::nullopt, 0).GetArray()->ISlice(offset, count);\n+    }\n     virtual void DoVisitValues(const TValuesSimpleVisitor& visitor) const override {\n-        for (auto&& i : Chunks) {\n-            i.GetArrayVerified(Loader)->VisitValues(visitor);\n-        }\n+        return GetLocalChunkedArray(std::nullopt, 0).GetArray()->VisitValues(visitor);\n     }\n-\n-protected:\n     virtual ui32 DoGetNullsCount() const override {\n         AFL_VERIFY(false);\n         return 0;\n@@ -60,7 +33,10 @@ class TDeserializeChunkedArray: public ICompositeChunkedArray {\n \n     virtual TLocalChunkedArrayAddress DoGetLocalChunkedArray(\n         const std::optional<TCommonChunkAddress>& chunkCurrent, const ui64 position) const override;\n-    virtual TLocalDataAddress DoGetLocalData(const std::optional<TCommonChunkAddress>& chunkCurrent, const ui64 position) const override;\n+    virtual TLocalDataAddress DoGetLocalData(const std::optional<TCommonChunkAddress>& /*chunkCurrent*/, const ui64 /*position*/) const override {\n+        AFL_VERIFY(false);\n+        return TLocalDataAddress(nullptr, 0, 0);\n+    }\n \n     virtual std::shared_ptr<arrow::Scalar> DoGetScalar(const ui32 /*index*/) const override {\n         AFL_VERIFY(false)(\"problem\", \"cannot use method\");\n@@ -73,21 +49,39 @@ class TDeserializeChunkedArray: public ICompositeChunkedArray {\n         AFL_VERIFY(false);\n         return nullptr;\n     }\n-    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArray() const override {\n+    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArrayTrivial() const override {\n         if (!ForLazyInitialization) {\n             AFL_VERIFY(false);\n             return nullptr;\n         } else {\n-            return TBase::GetChunkedArray();\n+            return TBase::GetChunkedArrayTrivial();\n         }\n     }\n \n public:\n-    TDeserializeChunkedArray(const ui64 recordsCount, const std::shared_ptr<TColumnLoader>& loader, std::vector<TChunk>&& chunks,\n+    TDeserializeChunkedArray(const ui64 recordsCount, const std::shared_ptr<TColumnLoader>& loader, const TString& data,\n+        const bool forLazyInitialization = false)\n+        : TBase(recordsCount, NArrow::NAccessor::IChunkedArray::EType::SerializedChunkedArray, loader->GetField()->type())\n+        , Loader(loader)\n+        , Data(data)\n+        , ForLazyInitialization(forLazyInitialization) {\n+        AFL_VERIFY(Loader);\n+    }\n+\n+    TDeserializeChunkedArray(\n+        const ui64 recordsCount, const std::shared_ptr<TColumnLoader>& loader, const TStringBuf data, const bool forLazyInitialization = false)\n+        : TBase(recordsCount, NArrow::NAccessor::IChunkedArray::EType::SerializedChunkedArray, loader->GetField()->type())\n+        , Loader(loader)\n+        , DataBuffer(data)\n+        , ForLazyInitialization(forLazyInitialization) {\n+        AFL_VERIFY(Loader);\n+    }\n+\n+    TDeserializeChunkedArray(const ui64 recordsCount, const std::shared_ptr<TColumnLoader>& loader, const std::shared_ptr<IChunkedArray>& data,\n         const bool forLazyInitialization = false)\n         : TBase(recordsCount, NArrow::NAccessor::IChunkedArray::EType::SerializedChunkedArray, loader->GetField()->type())\n         , Loader(loader)\n-        , Chunks(std::move(chunks))\n+        , PredefinedArray(data)\n         , ForLazyInitialization(forLazyInitialization) {\n         AFL_VERIFY(Loader);\n     }\ndiff --git a/ydb/core/formats/arrow/accessor/plain/accessor.cpp b/ydb/core/formats/arrow/accessor/plain/accessor.cpp\nindex 4d217a596c39..5967eb45786a 100644\n--- a/ydb/core/formats/arrow/accessor/plain/accessor.cpp\n+++ b/ydb/core/formats/arrow/accessor/plain/accessor.cpp\n@@ -31,16 +31,25 @@ void TTrivialArray::Reallocate() {\n }\n \n std::shared_ptr<arrow::Array> TTrivialArray::BuildArrayFromOptionalScalar(\n-    const std::shared_ptr<arrow::Scalar>& scalar, const std::shared_ptr<arrow::DataType>& type) {\n+    const std::shared_ptr<arrow::Scalar>& scalar, const std::shared_ptr<arrow::DataType>& typePtr) {\n     if (scalar) {\n-        AFL_VERIFY(scalar->type->id() == type->id());\n+        AFL_VERIFY(scalar->type->id() == typePtr->id());\n         auto builder = NArrow::MakeBuilder(scalar->type, 1);\n         TStatusValidator::Validate(builder->AppendScalar(*scalar));\n         return NArrow::FinishBuilder(std::move(builder));\n     } else {\n-        auto builder = NArrow::MakeBuilder(type, 1);\n-        TStatusValidator::Validate(builder->AppendNull());\n-        return NArrow::FinishBuilder(std::move(builder));\n+        std::shared_ptr<arrow::Array> result;\n+        NArrow::SwitchType(typePtr->id(), [&](const auto& /*type*/) {\n+            static const std::shared_ptr<arrow::Array> arrResult = [&]() {\n+                auto builder = NArrow::MakeBuilder(typePtr, 1);\n+                TStatusValidator::Validate(builder->AppendNull());\n+                return NArrow::FinishBuilder(std::move(builder));\n+            }();\n+            result = arrResult;\n+            return true;\n+        });\n+        AFL_VERIFY(result);\n+        return result;\n     }\n }\n \ndiff --git a/ydb/core/formats/arrow/accessor/plain/accessor.h b/ydb/core/formats/arrow/accessor/plain/accessor.h\nindex 3b9cbad85e39..d05d72f3d266 100644\n--- a/ydb/core/formats/arrow/accessor/plain/accessor.h\n+++ b/ydb/core/formats/arrow/accessor/plain/accessor.h\n@@ -41,7 +41,7 @@ class TTrivialArray: public IChunkedArray {\n \n     virtual void Reallocate() override;\n \n-    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArray() const override {\n+    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArrayTrivial() const override {\n         return std::make_shared<arrow::ChunkedArray>(Array);\n     }\n \n@@ -93,6 +93,16 @@ class TTrivialArray: public IChunkedArray {\n             AFL_VERIFY(NArrow::Append<TArrowDataType>(*Builder, arrow::util::string_view(value.data(), value.size())));\n         }\n \n+        void AddNull(const ui32 recordIndex) {\n+            if (LastRecordIndex) {\n+                AFL_VERIFY(*LastRecordIndex < recordIndex)(\"last\", LastRecordIndex)(\"index\", recordIndex);\n+                TStatusValidator::Validate(Builder->AppendNulls(recordIndex - *LastRecordIndex));\n+            } else {\n+                TStatusValidator::Validate(Builder->AppendNulls(recordIndex + 1));\n+            }\n+            LastRecordIndex = recordIndex;\n+        }\n+\n         std::shared_ptr<IChunkedArray> Finish(const ui32 recordsCount) {\n             if (LastRecordIndex) {\n                 AFL_VERIFY(*LastRecordIndex < recordsCount)(\"last\", LastRecordIndex)(\"count\", recordsCount);\n@@ -120,6 +130,10 @@ class TTrivialChunkedArray: public IChunkedArray {\n         }\n     }\n \n+    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArrayTrivial() const override {\n+        return Array;\n+    }\n+\n protected:\n     virtual ui32 DoGetValueRawBytes() const override;\n     virtual ui32 DoGetNullsCount() const override {\n@@ -139,10 +153,6 @@ class TTrivialChunkedArray: public IChunkedArray {\n     virtual std::shared_ptr<arrow::Scalar> DoGetMaxScalar() const override;\n \n public:\n-    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArray() const override {\n-        return Array;\n-    }\n-\n     TTrivialChunkedArray(const std::shared_ptr<arrow::ChunkedArray>& data)\n         : TBase(data->length(), EType::ChunkedArray, data->type())\n         , Array(data) {\ndiff --git a/ydb/core/formats/arrow/accessor/plain/constructor.cpp b/ydb/core/formats/arrow/accessor/plain/constructor.cpp\nindex 757b4c129885..1f34cb796254 100644\n--- a/ydb/core/formats/arrow/accessor/plain/constructor.cpp\n+++ b/ydb/core/formats/arrow/accessor/plain/constructor.cpp\n@@ -56,6 +56,10 @@ TString TConstructor::DoSerializeToString(const std::shared_ptr<IChunkedArray>&\n \n TConclusion<std::shared_ptr<IChunkedArray>> TConstructor::DoConstruct(\n     const std::shared_ptr<IChunkedArray>& originalArray, const TChunkConstructionData& externalInfo) const {\n+    if (!originalArray->GetDataType()->Equals(externalInfo.GetColumnType())) {\n+        return TConclusionStatus::Fail(\"plain accessor cannot convert types for transfer: \" + originalArray->GetDataType()->ToString() + \" to \" +\n+                                       externalInfo.GetColumnType()->ToString());\n+    }\n     auto schema = std::make_shared<arrow::Schema>(arrow::FieldVector({ std::make_shared<arrow::Field>(\"val\", externalInfo.GetColumnType()) }));\n     auto chunked = originalArray->GetChunkedArray();\n     auto table = arrow::Table::Make(schema, { chunked }, originalArray->GetRecordsCount());\ndiff --git a/ydb/core/formats/arrow/accessor/sparsed/accessor.cpp b/ydb/core/formats/arrow/accessor/sparsed/accessor.cpp\nindex c60df733ba73..75786aa95a85 100644\n--- a/ydb/core/formats/arrow/accessor/sparsed/accessor.cpp\n+++ b/ydb/core/formats/arrow/accessor/sparsed/accessor.cpp\n@@ -110,8 +110,13 @@ IChunkedArray::TLocalDataAddress TSparsedArrayChunk::GetChunk(\n     AFL_VERIFY(it != RemapExternalToInternal.begin());\n     --it;\n     if (it->GetIsDefault()) {\n-        return IChunkedArray::TLocalDataAddress(\n-            NArrow::TThreadSimpleArraysCache::Get(ColValue->type(), DefaultValue, it->GetSize()), it->GetStartExt(), 0);\n+        std::shared_ptr<arrow::Array> arr;\n+        if (!DefaultValue) {\n+            arr = NArrow::TThreadSimpleArraysCache::Get(ColValue->type(), DefaultValue, it->GetSize());\n+        } else {\n+            arr = NArrow::TStatusValidator::GetValid(arrow::MakeArrayFromScalar(*DefaultValue, it->GetSize()));\n+        }\n+        return IChunkedArray::TLocalDataAddress(arr, it->GetStartExt(), 0);\n     } else {\n         return IChunkedArray::TLocalDataAddress(ColValue->Slice(it->GetStartInt(), it->GetSize()), it->GetStartExt(), 0);\n     }\n@@ -217,8 +222,8 @@ TSparsedArrayChunk TSparsedArrayChunk::ApplyFilter(const TColumnFilter& filter)\n     ui32 filteredCount = 0;\n     bool currentAcceptance = filter.GetStartValue();\n     TColumnFilter filterNew = TColumnFilter::BuildAllowFilter();\n-    auto indexesBuilder = NArrow::MakeBuilder(arrow::uint32());\n-    auto valuesBuilder = NArrow::MakeBuilder(ColValue->type());\n+    auto indexesBuilder = NArrow::MakeBuilder(arrow::uint32(), filter.GetFilteredCountVerified());\n+    auto valuesBuilder = NArrow::MakeBuilder(ColValue->type(), filter.GetFilteredCountVerified());\n     for (auto it = filter.GetFilter().begin(); it != filter.GetFilter().end(); ++it) {\n         for (; recordIndex < UI32ColIndex->length(); ++recordIndex) {\n             if (UI32ColIndex->Value(recordIndex) < filterIntervalStart) {\ndiff --git a/ydb/core/formats/arrow/accessor/sparsed/accessor.h b/ydb/core/formats/arrow/accessor/sparsed/accessor.h\nindex d125fba0733e..42eafb46dea4 100644\n--- a/ydb/core/formats/arrow/accessor/sparsed/accessor.h\n+++ b/ydb/core/formats/arrow/accessor/sparsed/accessor.h\n@@ -58,6 +58,11 @@ class TSparsedArrayChunk {\n         : TSparsedArrayChunk(original) {\n         AFL_VERIFY(!original.GetNotDefaultRecordsCount());\n         RecordsCount = recordsCount;\n+        AFL_VERIFY(RemapExternalToInternal.size() == 1);\n+        AFL_VERIFY(RemapExternalToInternal[0].GetStartExt() == 0);\n+        AFL_VERIFY(RemapExternalToInternal[0].GetStartInt() == 0);\n+        AFL_VERIFY(RemapExternalToInternal[0].GetIsDefault());\n+        RemapExternalToInternal[0] = TInternalChunkInfo(0, 0, recordsCount, true);\n     }\n \n public:\n@@ -170,10 +175,19 @@ class TSparsedArray: public IChunkedArray {\n \n     static ui32 GetLastIndex(const std::shared_ptr<arrow::RecordBatch>& batch);\n \n-    static std::shared_ptr<arrow::Schema> BuildSchema(const std::shared_ptr<arrow::DataType>& type) {\n-        std::vector<std::shared_ptr<arrow::Field>> fields = { std::make_shared<arrow::Field>(\"index\", arrow::uint32()),\n-            std::make_shared<arrow::Field>(\"value\", type) };\n-        return std::make_shared<arrow::Schema>(fields);\n+    static std::shared_ptr<arrow::Schema> BuildSchema(const std::shared_ptr<arrow::DataType>& typePtr) {\n+        std::shared_ptr<arrow::Schema> result;\n+        NArrow::SwitchType(typePtr->id(), [&](const auto& /*type*/) {\n+            static const std::shared_ptr<arrow::Schema> schemaResult = [&]() {\n+                std::vector<std::shared_ptr<arrow::Field>> fields = { std::make_shared<arrow::Field>(\"index\", arrow::uint32()),\n+                    std::make_shared<arrow::Field>(\"value\", typePtr) };\n+                return std::make_shared<arrow::Schema>(fields);\n+            }();\n+            result = schemaResult;\n+            return true;\n+        });\n+        AFL_VERIFY(result);\n+        return result;\n     }\n \n     static TSparsedArrayChunk MakeDefaultChunk(\n@@ -224,7 +238,7 @@ class TSparsedArray: public IChunkedArray {\n         std::unique_ptr<arrow::ArrayBuilder> ValueBuilder;\n         ui32 RecordsCount = 0;\n         const std::shared_ptr<arrow::Scalar> DefaultValue;\n-\n+        std::optional<ui32> LastRecordIndex;\n     public:\n         TSparsedBuilder(const std::shared_ptr<arrow::Scalar>& defaultValue, const ui32 reserveItems, const ui32 reserveData)\n             : DefaultValue(defaultValue) {\n@@ -233,11 +247,26 @@ class TSparsedArray: public IChunkedArray {\n         }\n \n         void AddRecord(const ui32 recordIndex, const std::string_view value) {\n+            if (!!LastRecordIndex) {\n+                AFL_VERIFY(*LastRecordIndex < recordIndex);\n+            }\n+            LastRecordIndex = recordIndex;\n             AFL_VERIFY(NArrow::Append<arrow::UInt32Type>(*IndexBuilder, recordIndex));\n             AFL_VERIFY(NArrow::Append<TDataType>(*ValueBuilder, arrow::util::string_view(value.data(), value.size())));\n             ++RecordsCount;\n         }\n \n+        void AddNull(const ui32 recordIndex) {\n+            if (!!LastRecordIndex) {\n+                AFL_VERIFY(*LastRecordIndex < recordIndex);\n+            }\n+            LastRecordIndex = recordIndex;\n+            if (!!DefaultValue && DefaultValue->type->id() != arrow::null()->id()) {\n+                AFL_VERIFY(NArrow::Append<arrow::UInt32Type>(*IndexBuilder, recordIndex));\n+                TStatusValidator::Validate(ValueBuilder->AppendNull());\n+            }\n+        }\n+\n         std::shared_ptr<IChunkedArray> Finish(const ui32 recordsCount) {\n             TSparsedArray::TBuilder builder(DefaultValue, arrow::TypeTraits<TDataType>::type_singleton());\n             std::vector<std::unique_ptr<arrow::ArrayBuilder>> builders;\ndiff --git a/ydb/core/formats/arrow/accessor/sparsed/constructor.cpp b/ydb/core/formats/arrow/accessor/sparsed/constructor.cpp\nindex 3d4a3574afd5..ab7d309fc7e5 100644\n--- a/ydb/core/formats/arrow/accessor/sparsed/constructor.cpp\n+++ b/ydb/core/formats/arrow/accessor/sparsed/constructor.cpp\n@@ -42,7 +42,10 @@ TString TConstructor::DoSerializeToString(const std::shared_ptr<IChunkedArray>&\n \n TConclusion<std::shared_ptr<IChunkedArray>> TConstructor::DoConstruct(\n     const std::shared_ptr<IChunkedArray>& originalArray, const TChunkConstructionData& externalInfo) const {\n-    AFL_VERIFY(originalArray);\n+    if (!externalInfo.GetColumnType()->Equals(originalArray->GetDataType())) {\n+        return TConclusionStatus::Fail(\"sparsed accessor cannot convert types for transfer: \" + originalArray->GetDataType()->ToString() + \" to \" +\n+                                       externalInfo.GetColumnType()->ToString());\n+    }\n     return TSparsedArray::Make(*originalArray, externalInfo.GetDefaultValue());\n }\n \ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/accessor.cpp b/ydb/core/formats/arrow/accessor/sub_columns/accessor.cpp\nindex 327cf5bb279f..f33a04785e61 100644\n--- a/ydb/core/formats/arrow/accessor/sub_columns/accessor.cpp\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/accessor.cpp\n@@ -1,4 +1,6 @@\n #include \"accessor.h\"\n+#include \"direct_builder.h\"\n+#include \"signals.h\"\n \n #include <ydb/core/formats/arrow/accessor/composite_serial/accessor.h>\n #include <ydb/core/formats/arrow/accessor/plain/constructor.h>\n@@ -14,9 +16,8 @@\n \n namespace NKikimr::NArrow::NAccessor {\n \n-TConclusion<std::shared_ptr<TSubColumnsArray>> TSubColumnsArray::Make(const std::shared_ptr<IChunkedArray>& sourceArray,\n-    const std::shared_ptr<NSubColumns::IDataAdapter>& adapter, const NSubColumns::TSettings& settings) {\n-    AFL_VERIFY(adapter);\n+TConclusion<std::shared_ptr<TSubColumnsArray>> TSubColumnsArray::Make(\n+    const std::shared_ptr<IChunkedArray>& sourceArray, const NSubColumns::TSettings& settings) {\n     AFL_VERIFY(sourceArray);\n     NSubColumns::TDataBuilder builder(sourceArray->GetDataType(), settings);\n     IChunkedArray::TReader reader(sourceArray);\n@@ -24,7 +25,7 @@ TConclusion<std::shared_ptr<TSubColumnsArray>> TSubColumnsArray::Make(const std:\n     for (ui32 i = 0; i < reader.GetRecordsCount();) {\n         auto address = reader.GetReadChunk(i);\n         storage.emplace_back(address.GetArray());\n-        auto conclusion = adapter->AddDataToBuilders(address.GetArray(), builder);\n+        auto conclusion = settings.GetDataExtractor()->AddDataToBuilders(address.GetArray(), builder);\n         if (conclusion.IsFail()) {\n             return conclusion;\n         }\n@@ -67,19 +68,26 @@ TString TSubColumnsArray::SerializeToString(const TChunkConstructionData& extern\n         proto.SetOtherStatsSize(0);\n     }\n     ui32 columnIdx = 0;\n+    TMonotonic pred = TMonotonic::Now();\n     for (auto&& i : ColumnsData.GetRecords()->GetColumns()) {\n         TChunkConstructionData cData(GetRecordsCount(), nullptr, arrow::utf8(), externalInfo.GetDefaultSerializer());\n-        blobRanges.emplace_back(\n-            ColumnsData.GetStats().GetAccessorConstructor(columnIdx).SerializeToString(i, cData));\n+        blobRanges.emplace_back(ColumnsData.GetStats().GetAccessorConstructor(columnIdx).SerializeToString(i, cData));\n         auto* cInfo = proto.AddKeyColumns();\n         cInfo->SetSize(blobRanges.back().size());\n+        TMonotonic next = TMonotonic::Now();\n+        NSubColumns::TSignals::GetColumnSignals().OnBlobSize(ColumnsData.GetStats().GetColumnSize(columnIdx), blobRanges.back().size(), next - pred);\n+        pred = next;\n         ++columnIdx;\n     }\n \n     if (OthersData.GetRecords()->GetRecordsCount()) {\n+        TMonotonic pred = TMonotonic::Now();\n         for (auto&& i : OthersData.GetRecords()->GetColumns()) {\n             TChunkConstructionData cData(i->GetRecordsCount(), nullptr, i->GetDataType(), externalInfo.GetDefaultSerializer());\n             blobRanges.emplace_back(NPlain::TConstructor().SerializeToString(i, cData));\n+            TMonotonic next = TMonotonic::Now();\n+            NSubColumns::TSignals::GetOtherSignals().OnBlobSize(i->GetRawSizeVerified(), blobRanges.back().size(), next - pred);\n+            pred = next;\n             auto* cInfo = proto.AddOtherColumns();\n             cInfo->SetSize(blobRanges.back().size());\n         }\n@@ -105,42 +113,160 @@ TString TSubColumnsArray::SerializeToString(const TChunkConstructionData& extern\n     return result;\n }\n \n-IChunkedArray::TLocalDataAddress TSubColumnsArray::DoGetLocalData(\n-    const std::optional<TCommonChunkAddress>& /*chunkCurrent*/, const ui64 /*position*/) const {\n+class TJsonRestorer {\n+private:\n+    NJson::TJsonValue Result;\n+\n+public:\n+    bool IsNull() const {\n+        return !Result.IsDefined();\n+    }\n+\n+    TConclusion<NBinaryJson::TBinaryJson> Finish() {\n+        auto str = Result.GetStringRobust();\n+        auto bJson = NBinaryJson::SerializeToBinaryJson(Result.GetStringRobust());\n+        if (const TString* val = std::get_if<TString>(&bJson)) {\n+            return TConclusionStatus::Fail(*val);\n+        } else if (const NBinaryJson::TBinaryJson* val = std::get_if<NBinaryJson::TBinaryJson>(&bJson)) {\n+            return std::move(*val);\n+        } else {\n+            return TConclusionStatus::Fail(\"undefined case for binary json construction\");\n+        }\n+    }\n+\n+    void SetValueByPath(const TString& path, const TString& valueStr) {\n+        ui32 start = 0;\n+        bool enqueue = false;\n+        bool wasEnqueue = false;\n+        NJson::TJsonValue* current = &Result;\n+        for (ui32 i = 0; i < path.size(); ++i) {\n+            if (path[i] == '\\\\') {\n+                ++i;\n+                continue;\n+            }\n+            if (path[i] == '\\'' || path[i] == '\\\"') {\n+                wasEnqueue = true;\n+                enqueue = !enqueue;\n+                continue;\n+            }\n+            if (enqueue) {\n+                continue;\n+            }\n+            if (path[i] == '.') {\n+                if (wasEnqueue) {\n+                    AFL_VERIFY(i > start + 2);\n+                    TStringBuf key(path.data() + start + 1, (i - 1) - start - 1);\n+                    NJson::TJsonValue* currentNext = nullptr;\n+                    if (current->GetValuePointer(key, &currentNext)) {\n+                        current = currentNext;\n+                    } else {\n+                        current = &current->InsertValue(key, NJson::JSON_MAP);\n+                    }\n+                } else {\n+                    AFL_VERIFY(i > start);\n+                    TStringBuf key(path.data() + start, i - start);\n+                    NJson::TJsonValue* currentNext = nullptr;\n+                    if (current->GetValuePointer(key, &currentNext)) {\n+                        current = currentNext;\n+                    } else {\n+                        ui32 keyIndex;\n+                        if (key.StartsWith(\"[\") && key.EndsWith(\"]\") && TryFromString<ui32>(key.data() + 1, key.size() - 2, keyIndex)) {\n+                            AFL_VERIFY(!current->IsDefined() || current->IsArray() || (current->IsMap() && current->GetMapSafe().empty()));\n+                            current->SetType(NJson::JSON_ARRAY);\n+                            if (current->GetArraySafe().size() <= keyIndex) {\n+                                current->GetArraySafe().resize(keyIndex + 1);\n+                            }\n+                            current = &current->GetArraySafe()[keyIndex];\n+                        } else {\n+                            AFL_VERIFY(!current->IsArray())(\"current_type\", current->GetType())(\"current\", current->GetStringRobust());\n+                            current = &current->InsertValue(key, NJson::JSON_MAP);\n+                        }\n+                    }\n+                }\n+                wasEnqueue = false;\n+                start = i + 1;\n+            }\n+        }\n+        if (wasEnqueue) {\n+            AFL_VERIFY(path.size() > start + 2)(\"path\", path)(\"start\", start);\n+            TStringBuf key(path.data() + start + 1, (path.size() - 1) - start - 1);\n+            current->InsertValue(key, valueStr);\n+        } else {\n+            AFL_VERIFY(path.size() > start);\n+            TStringBuf key(path.data() + start, (path.size()) - start);\n+            ui32 keyIndex;\n+            if (key.StartsWith(\"[\") && key.EndsWith(\"]\") && TryFromString<ui32>(key.data() + 1, key.size() - 2, keyIndex)) {\n+                AFL_VERIFY(!current->IsDefined() || current->IsArray() || (current->IsMap() && current->GetMapSafe().empty()));\n+                current->SetType(NJson::JSON_ARRAY);\n+\n+                if (current->GetArraySafe().size() <= keyIndex) {\n+                    current->GetArraySafe().resize(keyIndex + 1);\n+                }\n+                current->GetArraySafe()[keyIndex] = valueStr;\n+            } else {\n+                AFL_VERIFY(!current->IsArray())(\"key\", key)(\"current\", current->GetStringRobust())(\"full\", Result.GetStringRobust())(\n+                    \"current_type\", current->GetType());\n+                current->InsertValue(key, valueStr);\n+            }\n+        }\n+    }\n+};\n+\n+std::shared_ptr<arrow::Array> TSubColumnsArray::BuildBJsonArray(const TColumnConstructionContext& context) const {\n     auto it = BuildUnorderedIterator();\n     auto builder = NArrow::MakeBuilder(GetDataType());\n-    for (ui32 recordIndex = 0; recordIndex < GetRecordsCount(); ++recordIndex) {\n-        NJson::TJsonValue value;\n+    const ui32 start = context.GetStartIndex().value_or(0);\n+    const ui32 finish = start + context.GetRecordsCount().value_or(GetRecordsCount() - start);\n+    std::optional<std::vector<bool>> simpleFilter;\n+    if (context.GetFilter()) {\n+        simpleFilter = context.GetFilter()->BuildSimpleFilter();\n+    }\n+    for (ui32 recordIndex = start; recordIndex < finish; ++recordIndex) {\n+        if (simpleFilter && !(*simpleFilter)[recordIndex]) {\n+            continue;\n+        }\n+        it.SkipRecordTo(recordIndex);\n+        TJsonRestorer value;\n         auto onStartRecord = [&](const ui32 index) {\n             AFL_VERIFY(recordIndex == index)(\"count\", recordIndex)(\"index\", index);\n         };\n         auto onFinishRecord = [&]() {\n-            auto str = value.GetStringRobust();\n-            //            NArrow::Append<arrow::BinaryType>(*builder, arrow::util::string_view(str.data(), str.size()));\n-            //\n-            auto bJson = NBinaryJson::SerializeToBinaryJson(value.GetStringRobust());\n-            if (const TString* val = std::get_if<TString>(&bJson)) {\n-                AFL_VERIFY(false)(\"error\", *val);\n-            } else if (const NBinaryJson::TBinaryJson* val = std::get_if<NBinaryJson::TBinaryJson>(&bJson)) {\n-                if (value.IsNull() || !value.IsDefined()) {\n-                    TStatusValidator::Validate(builder->AppendNull());\n-                } else {\n-                    NArrow::Append<arrow::BinaryType>(*builder, arrow::util::string_view(val->data(), val->size()));\n-                }\n+            if (value.IsNull()) {\n+                TStatusValidator::Validate(builder->AppendNull());\n             } else {\n-                AFL_VERIFY(false);\n+                const TConclusion<NBinaryJson::TBinaryJson> bJson = value.Finish();\n+                NArrow::Append<arrow::BinaryType>(*builder, arrow::util::string_view(bJson->data(), bJson->size()));\n             }\n         };\n+\n+        const auto addValueToJson = [&](const TString& path, const TString& valueStr) {\n+            value.SetValueByPath(path, valueStr);\n+        };\n+\n         auto onRecordKV = [&](const ui32 index, const std::string_view valueView, const bool isColumn) {\n             if (isColumn) {\n-                value.InsertValue(ColumnsData.GetStats().GetColumnNameString(index), TString(valueView.data(), valueView.size()));\n+                addValueToJson(ColumnsData.GetStats().GetColumnNameString(index), TString(valueView.data(), valueView.size()));\n             } else {\n-                value.InsertValue(OthersData.GetStats().GetColumnNameString(index), TString(valueView.data(), valueView.size()));\n+                addValueToJson(OthersData.GetStats().GetColumnNameString(index), TString(valueView.data(), valueView.size()));\n             }\n         };\n         it.ReadRecord(recordIndex, onStartRecord, onRecordKV, onFinishRecord);\n     }\n-    return TLocalDataAddress(NArrow::FinishBuilder(std::move(builder)), 0, 0);\n+    return NArrow::FinishBuilder(std::move(builder));\n+}\n+\n+std::shared_ptr<arrow::ChunkedArray> TSubColumnsArray::GetChunkedArray(const TColumnConstructionContext& context) const {\n+    auto chunk = BuildBJsonArray(context);\n+    if (chunk->length()) {\n+        return std::make_shared<arrow::ChunkedArray>(chunk);\n+    } else {\n+        return std::make_shared<arrow::ChunkedArray>(arrow::ArrayVector(), GetDataType());\n+    }\n+}\n+\n+IChunkedArray::TLocalDataAddress TSubColumnsArray::DoGetLocalData(\n+    const std::optional<TCommonChunkAddress>& /*chunkCurrent*/, const ui64 /*position*/) const {\n+    return TLocalDataAddress(BuildBJsonArray(TColumnConstructionContext()), 0, 0);\n }\n \n }   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/accessor.h b/ydb/core/formats/arrow/accessor/sub_columns/accessor.h\nindex c1abe025199a..2fd9f60329f3 100644\n--- a/ydb/core/formats/arrow/accessor/sub_columns/accessor.h\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/accessor.h\n@@ -62,7 +62,11 @@ class TSubColumnsArray: public IChunkedArray {\n             ColumnsData.Slice(offset, count), OthersData.Slice(offset, count, Settings), GetDataType(), count, Settings);\n     }\n \n+    std::shared_ptr<arrow::Array> BuildBJsonArray(const TColumnConstructionContext& context) const;\n+\n public:\n+    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArray(\n+        const TColumnConstructionContext& context = Default<TColumnConstructionContext>()) const override;\n     virtual void DoVisitValues(const std::function<void(std::shared_ptr<arrow::Array>)>& /*visitor*/) const override {\n         AFL_VERIFY(false);\n     }\n@@ -97,8 +101,8 @@ class TSubColumnsArray: public IChunkedArray {\n     TSubColumnsArray(NSubColumns::TColumnsData&& columns, NSubColumns::TOthersData&& others, const std::shared_ptr<arrow::DataType>& type,\n         const ui32 recordsCount, const NSubColumns::TSettings& settings);\n \n-    static TConclusion<std::shared_ptr<TSubColumnsArray>> Make(const std::shared_ptr<IChunkedArray>& sourceArray,\n-        const std::shared_ptr<NSubColumns::IDataAdapter>& adapter, const NSubColumns::TSettings& settings);\n+    static TConclusion<std::shared_ptr<TSubColumnsArray>> Make(\n+        const std::shared_ptr<IChunkedArray>& sourceArray, const NSubColumns::TSettings& settings);\n \n     TSubColumnsArray(const std::shared_ptr<arrow::DataType>& type, const ui32 recordsCount, const NSubColumns::TSettings& settings);\n \ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/columns_storage.cpp b/ydb/core/formats/arrow/accessor/sub_columns/columns_storage.cpp\nindex 86838382a29d..219353a866af 100644\n--- a/ydb/core/formats/arrow/accessor/sub_columns/columns_storage.cpp\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/columns_storage.cpp\n@@ -31,7 +31,7 @@ TColumnsData TColumnsData::ApplyFilter(const TColumnFilter& filter) const {\n         return *this;\n     }\n     auto records = Records;\n-    AFL_VERIFY(filter.Apply(records));\n+    filter.Apply(records);\n     if (records->GetRecordsCount()) {\n         TDictStats::TBuilder builder;\n         ui32 idx = 0;\n@@ -53,4 +53,33 @@ TColumnsData TColumnsData::ApplyFilter(const TColumnFilter& filter) const {\n     }\n }\n \n+void TColumnsData::TIterator::InitArrays() {\n+    while (CurrentIndex < GlobalChunkedArray->GetRecordsCount()) {\n+        if (!FullArrayAddress || !FullArrayAddress->GetAddress().Contains(CurrentIndex)) {\n+            FullArrayAddress = GlobalChunkedArray->GetArray(FullArrayAddress, CurrentIndex, GlobalChunkedArray);\n+            ChunkAddress = std::nullopt;\n+        }\n+        const ui32 localIndex = FullArrayAddress->GetAddress().GetLocalIndex(CurrentIndex);\n+        ChunkAddress = FullArrayAddress->GetArray()->GetChunk(ChunkAddress, localIndex);\n+        AFL_VERIFY(ChunkAddress->GetArray()->type()->id() == arrow::utf8()->id());\n+        CurrentArrayData = static_cast<const arrow::StringArray*>(ChunkAddress->GetArray().get());\n+        if (FullArrayAddress->GetArray()->GetType() == IChunkedArray::EType::Array) {\n+            if (CurrentArrayData->IsNull(localIndex)) {\n+                Next();\n+            }\n+            break;\n+        } else if (FullArrayAddress->GetArray()->GetType() == IChunkedArray::EType::SparsedArray) {\n+            if (CurrentArrayData->IsNull(localIndex) &&\n+                std::static_pointer_cast<TSparsedArray>(FullArrayAddress->GetArray())->GetDefaultValue() == nullptr) {\n+                CurrentIndex = ChunkAddress->GetAddress().GetGlobalFinishPosition();\n+            } else {\n+                break;\n+            }\n+        } else {\n+            AFL_VERIFY(false)(\"type\", FullArrayAddress->GetArray()->GetType());\n+        }\n+    }\n+    AFL_VERIFY(CurrentIndex <= GlobalChunkedArray->GetRecordsCount())(\"index\", CurrentIndex)(\"count\", GlobalChunkedArray->GetRecordsCount());\n+}\n+\n }   // namespace NKikimr::NArrow::NAccessor::NSubColumns\ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/columns_storage.h b/ydb/core/formats/arrow/accessor/sub_columns/columns_storage.h\nindex 4fdbaf8c848e..9c7f4ac609e3 100644\n--- a/ydb/core/formats/arrow/accessor/sub_columns/columns_storage.h\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/columns_storage.h\n@@ -29,7 +29,7 @@ class TColumnsData {\n     NJson::TJsonValue DebugJson() const {\n         NJson::TJsonValue result = NJson::JSON_MAP;\n         result.InsertValue(\"stats\", Stats.DebugJson());\n-        result.InsertValue(\"records\", Records->DebugJson(true));\n+        result.InsertValue(\"records\", Records->DebugJson());\n         return result;\n     }\n \n@@ -54,34 +54,7 @@ class TColumnsData {\n         std::optional<IChunkedArray::TFullDataAddress> ChunkAddress;\n         ui32 CurrentIndex = 0;\n \n-        void InitArrays() {\n-            while (CurrentIndex < GlobalChunkedArray->GetRecordsCount()) {\n-                if (!FullArrayAddress || !FullArrayAddress->GetAddress().Contains(CurrentIndex)) {\n-                    FullArrayAddress = GlobalChunkedArray->GetArray(FullArrayAddress, CurrentIndex, GlobalChunkedArray);\n-                    ChunkAddress = std::nullopt;\n-                }\n-                const ui32 localIndex = FullArrayAddress->GetAddress().GetLocalIndex(CurrentIndex);\n-                ChunkAddress = FullArrayAddress->GetArray()->GetChunk(ChunkAddress, localIndex);\n-                AFL_VERIFY(ChunkAddress->GetArray()->type()->id() == arrow::utf8()->id());\n-                CurrentArrayData = static_cast<const arrow::StringArray*>(ChunkAddress->GetArray().get());\n-                if (FullArrayAddress->GetArray()->GetType() == IChunkedArray::EType::Array) {\n-                    if (CurrentArrayData->IsNull(localIndex)) {\n-                        Next();\n-                    }\n-                    break;\n-                } else if (FullArrayAddress->GetArray()->GetType() == IChunkedArray::EType::SparsedArray) {\n-                    if (CurrentArrayData->IsNull(localIndex) &&\n-                        std::static_pointer_cast<TSparsedArray>(FullArrayAddress->GetArray())->GetDefaultValue() == nullptr) {\n-                        CurrentIndex += ChunkAddress->GetArray()->length();\n-                    } else {\n-                        break;\n-                    }\n-                } else {\n-                    AFL_VERIFY(false)(\"type\", FullArrayAddress->GetArray()->GetType());\n-                }\n-            }\n-            AFL_VERIFY(CurrentIndex <= GlobalChunkedArray->GetRecordsCount());\n-        }\n+        void InitArrays();\n \n     public:\n         TIterator(const ui32 keyIndex, const std::shared_ptr<IChunkedArray>& chunkedArray)\n@@ -111,6 +84,23 @@ class TColumnsData {\n             return CurrentIndex < GlobalChunkedArray->GetRecordsCount();\n         }\n \n+        bool SkipRecordTo(const ui32 recordIndex) {\n+            if (recordIndex <= CurrentIndex) {\n+                return true;\n+            }\n+            AFL_VERIFY(IsValid());\n+            AFL_VERIFY(ChunkAddress->GetAddress().Contains(CurrentIndex));\n+            CurrentIndex = recordIndex;\n+            for (; CurrentIndex < ChunkAddress->GetAddress().GetGlobalFinishPosition(); ++CurrentIndex) {\n+                if (CurrentArrayData->IsNull(CurrentIndex - ChunkAddress->GetAddress().GetGlobalStartPosition())) {\n+                    continue;\n+                }\n+                return true;\n+            }\n+            InitArrays();\n+            return IsValid();\n+        }\n+\n         bool Next() {\n             AFL_VERIFY(IsValid());\n             AFL_VERIFY(ChunkAddress->GetAddress().Contains(CurrentIndex));\ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/constructor.cpp b/ydb/core/formats/arrow/accessor/sub_columns/constructor.cpp\nindex 73e4cbe8ce0a..900049f303b5 100644\n--- a/ydb/core/formats/arrow/accessor/sub_columns/constructor.cpp\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/constructor.cpp\n@@ -27,13 +27,13 @@ TConclusion<std::shared_ptr<IChunkedArray>> TConstructor::DoDeserializeFromStrin\n         auto schema = headerConclusion->GetColumnStats().BuildColumnsSchema();\n         AFL_VERIFY(headerConclusion->GetColumnStats().GetColumnsCount() == (ui32)proto.GetKeyColumns().size())(\n                                                                              \"schema\", headerConclusion->GetColumnStats().GetColumnsCount())(\n-                                                  \"proto\", proto.GetKeyColumns().size());\n+                                                                             \"proto\", proto.GetKeyColumns().size());\n         for (ui32 i = 0; i < (ui32)proto.GetKeyColumns().size(); ++i) {\n             std::shared_ptr<TColumnLoader> columnLoader = std::make_shared<TColumnLoader>(\n                 externalInfo.GetDefaultSerializer(), headerConclusion->GetColumnStats().GetAccessorConstructor(i), schema->field(i), nullptr, 0);\n-            std::vector<TDeserializeChunkedArray::TChunk> chunks = { TDeserializeChunkedArray::TChunk(\n-                externalInfo.GetRecordsCount(), TStringBuf(originalData.data() + currentIndex, proto.GetKeyColumns(i).GetSize())) };\n-            columns.emplace_back(std::make_shared<TDeserializeChunkedArray>(externalInfo.GetRecordsCount(), columnLoader, std::move(chunks), true));\n+            std::shared_ptr<IChunkedArray> chunk = std::make_shared<TDeserializeChunkedArray>(externalInfo.GetRecordsCount(), columnLoader,\n+                TStringBuf(originalData.data() + currentIndex, proto.GetKeyColumns(i).GetSize()), true);\n+            columns.emplace_back(chunk);\n             currentIndex += proto.GetKeyColumns(i).GetSize();\n         }\n         columnKeysContainer = std::make_shared<TGeneralContainer>(schema, std::move(columns));\n@@ -67,7 +67,11 @@ bool TConstructor::DoDeserializeFromProto(const NKikimrArrowAccessorProto::TCons\n \n TConclusion<std::shared_ptr<IChunkedArray>> TConstructor::DoConstruct(\n     const std::shared_ptr<IChunkedArray>& originalData, const TChunkConstructionData& /*externalInfo*/) const {\n-    return NAccessor::TSubColumnsArray::Make(originalData, DataExtractor, Settings).DetachResult();\n+    auto conclusion = NAccessor::TSubColumnsArray::Make(originalData, Settings);\n+    if (conclusion.IsFail()) {\n+        return conclusion;\n+    }\n+    return conclusion.DetachResult();\n }\n \n TString TConstructor::DoSerializeToString(const std::shared_ptr<IChunkedArray>& columnData, const TChunkConstructionData& externalInfo) const {\n@@ -89,10 +93,8 @@ TConclusion<std::shared_ptr<TGeneralContainer>> TConstructor::BuildOthersContain\n             columns.emplace_back(columnLoader->ApplyVerified(\n                 TString(data.data() + currentIndex, proto.GetOtherColumns(i).GetSize()), proto.GetOtherRecordsCount()));\n         } else {\n-            std::vector<TDeserializeChunkedArray::TChunk> chunks = { TDeserializeChunkedArray::TChunk(\n-                proto.GetOtherRecordsCount(), TStringBuf(data.data() + currentIndex, proto.GetOtherColumns(i).GetSize())) };\n-            columns.emplace_back(\n-                std::make_shared<TDeserializeChunkedArray>(proto.GetOtherRecordsCount(), columnLoader, std::move(chunks), true));\n+            columns.emplace_back(std::make_shared<TDeserializeChunkedArray>(\n+                proto.GetOtherRecordsCount(), columnLoader, TStringBuf(data.data() + currentIndex, proto.GetOtherColumns(i).GetSize()), true));\n         }\n         currentIndex += proto.GetOtherColumns(i).GetSize();\n     }\ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/constructor.h b/ydb/core/formats/arrow/accessor/sub_columns/constructor.h\nindex c9ef9bd1a352..dca602a38b7b 100644\n--- a/ydb/core/formats/arrow/accessor/sub_columns/constructor.h\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/constructor.h\n@@ -10,7 +10,6 @@ namespace NKikimr::NArrow::NAccessor::NSubColumns {\n class TConstructor: public IConstructor {\n private:\n     using TBase = IConstructor;\n-    std::shared_ptr<IDataAdapter> DataExtractor = std::make_shared<TFirstLevelSchemaData>();\n     TSettings Settings;\n \n public:\n@@ -43,6 +42,10 @@ class TConstructor: public IConstructor {\n         : TBase(IChunkedArray::EType::SubColumnsArray) {\n     }\n \n+    virtual bool HasInternalConversion() const override {\n+        return Settings.GetDataExtractor()->HasInternalConversion();\n+    }\n+\n     static TConclusion<std::shared_ptr<TGeneralContainer>> BuildOthersContainer(\n         const TStringBuf data, const NKikimrArrowAccessorProto::TSubColumnsAccessor& proto, const TChunkConstructionData& externalInfo, const bool deserialize);\n \ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/data_extractor.cpp b/ydb/core/formats/arrow/accessor/sub_columns/data_extractor.cpp\nindex 7fe91d74686a..0bbf7abb273b 100644\n--- a/ydb/core/formats/arrow/accessor/sub_columns/data_extractor.cpp\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/data_extractor.cpp\n@@ -1,4 +1,6 @@\n #include \"data_extractor.h\"\n+#include \"direct_builder.h\"\n+#include \"json_extractors.h\"\n \n #include <util/string/split.h>\n #include <util/string/vector.h>\n@@ -8,53 +10,103 @@\n \n namespace NKikimr::NArrow::NAccessor::NSubColumns {\n \n-TConclusionStatus TFirstLevelSchemaData::DoAddDataToBuilders(\n-    const std::shared_ptr<arrow::Array>& sourceArray, TDataBuilder& dataBuilder) const noexcept {\n-    if (sourceArray->type()->id() != arrow::binary()->id()) {\n-        return TConclusionStatus::Fail(\"incorrect base type for subcolumns schema usage\");\n+class TSimdBuffers: public TDataBuilder::IBuffers {\n+private:\n+    std::vector<simdjson::padded_string> PaddedStrings;\n+    std::vector<TString> Strings;\n+\n+public:\n+    TSimdBuffers(std::vector<simdjson::padded_string>&& paddedStrings, std::vector<TString>&& strings)\n+        : PaddedStrings(std::move(paddedStrings))\n+        , Strings(std::move(strings)) {\n     }\n+};\n \n-    auto arr = std::static_pointer_cast<arrow::StringArray>(sourceArray);\n+TConclusionStatus TJsonScanExtractor::DoAddDataToBuilders(const std::shared_ptr<arrow::Array>& sourceArray, TDataBuilder& dataBuilder) const {\n+    auto arr = std::static_pointer_cast<arrow::BinaryArray>(sourceArray);\n+    std::optional<bool> isBinaryJson;\n+    if (arr->type()->id() == arrow::utf8()->id()) {\n+        isBinaryJson = false;\n+    }\n+    if (!arr->length()) {\n+        return TConclusionStatus::Success();\n+    }\n+    simdjson::ondemand::parser simdParser;\n+    std::vector<simdjson::padded_string> paddedStrings;\n+    std::vector<TString> forceSIMDStrings;\n+    ui32 sumBuf = 0;\n+    ui32 paddedBorder = 0;\n+    for (i32 i = arr->length() - 1; i >= 1; --i) {\n+        sumBuf += arr->GetView(i).size();\n+        if (sumBuf > simdjson::SIMDJSON_PADDING) {\n+            paddedBorder = i;\n+            break;\n+        }\n+    }\n     for (ui32 i = 0; i < arr->length(); ++i) {\n         const auto view = arr->GetView(i);\n         if (view.size() && !arr->IsNull(i)) {\n-            //        NBinaryJson::TBinaryJson bJson(view.data(), view.size());\n-            //        auto bJson = NBinaryJson::SerializeToBinaryJson(TStringBuf(view.data(), view.size()));\n-            //        const NBinaryJson::TBinaryJson* bJsonParsed = std::get_if<NBinaryJson::TBinaryJson>(&bJson);\n-            //        AFL_VERIFY(bJsonParsed)(\"error\", *std::get_if<TString>(&bJson))(\"json\", TStringBuf(view.data(), view.size()));\n-            //        const NBinaryJson::TBinaryJson* bJsonParsed = &bJson;\n-            auto reader = NBinaryJson::TBinaryJsonReader::Make(TStringBuf(view.data(), view.size()));\n-            auto cursor = reader->GetRootCursor();\n-            if (cursor.GetType() == NBinaryJson::EContainerType::Object) {\n-                auto it = cursor.GetObjectIterator();\n-                while (it.HasNext()) {\n-                    auto [key, value] = it.Next();\n-                    if (key.GetType() != NBinaryJson::EEntryType::String) {\n-                        continue;\n-                    }\n-                    if (value.GetType() == NBinaryJson::EEntryType::String) {\n-                        dataBuilder.AddKV(key.GetString(), value.GetString());\n-                    } else if (value.GetType() == NBinaryJson::EEntryType::Number) {\n-                        dataBuilder.AddKVOwn(key.GetString(), ::ToString(value.GetNumber()));\n-                    } else if (value.GetType() == NBinaryJson::EEntryType::BoolFalse) {\n-                        dataBuilder.AddKVOwn(key.GetString(), \"0\");\n-                    } else if (value.GetType() == NBinaryJson::EEntryType::BoolTrue) {\n-                        dataBuilder.AddKVOwn(key.GetString(), \"1\");\n-                    } else {\n-                        continue;\n+            TStringBuf sbJson(view.data(), view.size());\n+            if (!isBinaryJson) {\n+                isBinaryJson = NBinaryJson::IsValidBinaryJson(sbJson);\n+            }\n+            TString json;\n+            if (*isBinaryJson && ForceSIMDJsonParsing) {\n+                json = NBinaryJson::SerializeToJson(sbJson);\n+                forceSIMDStrings.emplace_back(json);\n+                sbJson = TStringBuf(json.data(), json.size());\n+            }\n+            if (!json && *isBinaryJson) {\n+                auto reader = NBinaryJson::TBinaryJsonReader::Make(sbJson);\n+                auto cursor = reader->GetRootCursor();\n+                std::deque<std::unique_ptr<IJsonObjectExtractor>> iterators;\n+                if (cursor.GetType() == NBinaryJson::EContainerType::Object) {\n+                    iterators.push_back(std::make_unique<TKVExtractor>(cursor.GetObjectIterator(), TStringBuf(), FirstLevelOnly));\n+                } else if (cursor.GetType() == NBinaryJson::EContainerType::Array) {\n+                    iterators.push_back(std::make_unique<TArrayExtractor>(cursor.GetArrayIterator(), TStringBuf(), FirstLevelOnly));\n+                }\n+                while (iterators.size()) {\n+                    const auto conclusion = iterators.front()->Fill(dataBuilder, iterators);\n+                    if (conclusion.IsFail()) {\n+                        return conclusion;\n                     }\n+                    iterators.pop_front();\n                 }\n             } else {\n-            //    return TConclusionStatus::Fail(\"incorrect json data: \" + ::ToString((int)cursor.GetType()));\n+                std::deque<std::unique_ptr<IJsonObjectExtractor>> iterators;\n+                simdjson::simdjson_result<simdjson::ondemand::document> doc;\n+                if (i < paddedBorder) {\n+                    doc = simdParser.iterate(\n+                        simdjson::padded_string_view(sbJson.data(), sbJson.size(), sbJson.size() + simdjson::SIMDJSON_PADDING));\n+                } else {\n+                    paddedStrings.emplace_back(simdjson::padded_string(sbJson.data(), sbJson.size()));\n+                    doc = simdParser.iterate(paddedStrings.back());\n+                }\n+                auto conclusion = TSIMDExtractor(doc, FirstLevelOnly).Fill(dataBuilder, iterators);\n+                if (conclusion.IsFail()) {\n+                    return conclusion;\n+                }\n             }\n         }\n         dataBuilder.StartNextRecord();\n     }\n+    if (paddedStrings.size()) {\n+        dataBuilder.StoreBuffer(std::make_shared<TSimdBuffers>(std::move(paddedStrings), std::move(forceSIMDStrings)));\n+    }\n     return TConclusionStatus::Success();\n }\n \n TConclusionStatus IDataAdapter::AddDataToBuilders(const std::shared_ptr<arrow::Array>& sourceArray, TDataBuilder& dataBuilder) const noexcept {\n-    return DoAddDataToBuilders(sourceArray, dataBuilder);\n+    try {\n+        return DoAddDataToBuilders(sourceArray, dataBuilder);\n+    } catch (...) {\n+        return TConclusionStatus::Fail(\"exception on data extraction: \" + CurrentExceptionMessage());\n+    }\n+}\n+\n+TDataAdapterContainer TDataAdapterContainer::GetDefault() {\n+    static TDataAdapterContainer result(std::make_shared<NSubColumns::TJsonScanExtractor>());\n+    return result;\n }\n \n }   // namespace NKikimr::NArrow::NAccessor::NSubColumns\ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/data_extractor.h b/ydb/core/formats/arrow/accessor/sub_columns/data_extractor.h\nindex 631728c7ac00..aff5f957ada6 100644\n--- a/ydb/core/formats/arrow/accessor/sub_columns/data_extractor.h\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/data_extractor.h\n@@ -1,30 +1,121 @@\n #pragma once\n-#include \"direct_builder.h\"\n \n #include <ydb/core/formats/arrow/accessor/abstract/accessor.h>\n #include <ydb/core/formats/arrow/arrow_helpers.h>\n \n+#include <ydb/library/formats/arrow/protos/accessor.pb.h>\n+#include <ydb/services/bg_tasks/abstract/interface.h>\n+#include <ydb/services/metadata/abstract/request_features.h>\n+\n #include <contrib/libs/apache/arrow/cpp/src/arrow/array/builder_base.h>\n+#include <library/cpp/object_factory/object_factory.h>\n \n namespace NKikimr::NArrow::NAccessor::NSubColumns {\n \n+class TDataBuilder;\n+\n class IDataAdapter {\n+public:\n+    using TProto = NKikimrArrowAccessorProto::TDataExtractor;\n+    using TFactory = NObjectFactory::TObjectFactory<IDataAdapter, TString>;\n+\n private:\n     virtual TConclusionStatus DoAddDataToBuilders(\n-        const std::shared_ptr<arrow::Array>& sourceArray, TDataBuilder& dataBuilder) const noexcept = 0;\n+        const std::shared_ptr<arrow::Array>& sourceArray, TDataBuilder& dataBuilder) const = 0;\n+    virtual bool DoDeserializeFromProto(const TProto& proto) = 0;\n+    virtual void DoSerializeToProto(TProto& proto) const = 0;\n+    virtual NJson::TJsonValue DoDebugJson() const {\n+        return NJson::JSON_MAP;\n+    }\n+    virtual TConclusionStatus DoDeserializeFromRequest(NYql::TFeaturesExtractor& features) = 0;\n \n public:\n+    virtual bool HasInternalConversion() const = 0;\n+    virtual TString GetClassName() const = 0;\n+    bool DeserializeFromProto(const TProto& proto) {\n+        return DoDeserializeFromProto(proto);\n+    }\n+\n+    TConclusionStatus DeserializeFromRequest(NYql::TFeaturesExtractor& features) {\n+        return DoDeserializeFromRequest(features);\n+    }\n+\n+    NJson::TJsonValue DebugJson() const {\n+        NJson::TJsonValue result = NJson::JSON_MAP;\n+        result.InsertValue(\"class_name\", GetClassName());\n+        result.InsertValue(\"details\", DoDebugJson());\n+        return result;\n+    }\n+    void SerializeToProto(TProto& proto) const {\n+        DoSerializeToProto(proto);\n+    }\n+\n     virtual ~IDataAdapter() = default;\n \n-    [[nodiscard]] TConclusionStatus AddDataToBuilders(const std::shared_ptr<arrow::Array>& sourceArray, TDataBuilder& dataBuilder) const noexcept;\n+    [[nodiscard]] TConclusionStatus AddDataToBuilders(\n+        const std::shared_ptr<arrow::Array>& sourceArray, TDataBuilder& dataBuilder) const noexcept;\n };\n \n-class TFirstLevelSchemaData: public IDataAdapter {\n+class TJsonScanExtractor: public IDataAdapter {\n+public:\n+    static TString GetClassNameStatic() {\n+        return \"JSON_SCANNER\";\n+    }\n+\n private:\n+    virtual bool HasInternalConversion() const override {\n+        return true;\n+    }\n+\n+    bool FirstLevelOnly = false;\n+    bool ForceSIMDJsonParsing = false;\n+    virtual TConclusionStatus DoDeserializeFromRequest(NYql::TFeaturesExtractor& features) override {\n+        if (auto scanFlag = features.Extract<bool>(\"SCAN_FIRST_LEVEL_ONLY\")) {\n+            FirstLevelOnly = *scanFlag;\n+        }\n+        if (auto scanFlag = features.Extract<bool>(\"FORCE_SIMD_PARSING\")) {\n+            ForceSIMDJsonParsing = *scanFlag;\n+        }\n+        return TConclusionStatus::Success();\n+    }\n+\n     virtual TConclusionStatus DoAddDataToBuilders(\n-        const std::shared_ptr<arrow::Array>& sourceArray, TDataBuilder& dataBuilder) const noexcept override;\n+        const std::shared_ptr<arrow::Array>& sourceArray, TDataBuilder& dataBuilder) const override;\n+    virtual bool DoDeserializeFromProto(const TProto& proto) override {\n+        if (!proto.HasJsonScanner() && !proto.HasSIMDJsonScanner()) {\n+            return true;\n+        }\n+        FirstLevelOnly = proto.GetJsonScanner().GetFirstLevelOnly() || proto.GetSIMDJsonScanner().GetFirstLevelOnly();\n+        ForceSIMDJsonParsing = proto.GetJsonScanner().GetForceSIMDJsonParsing();\n+        return true;\n+    }\n+    virtual void DoSerializeToProto(TProto& proto) const override {\n+        proto.MutableJsonScanner()->SetFirstLevelOnly(FirstLevelOnly);\n+        proto.MutableJsonScanner()->SetForceSIMDJsonParsing(ForceSIMDJsonParsing);\n+    }\n+    virtual TString GetClassName() const override {\n+        return GetClassNameStatic();\n+    }\n+\n+    static const inline auto Registrator = TFactory::TRegistrator<TJsonScanExtractor>(GetClassNameStatic());\n+    static const inline auto Registrator1 = TFactory::TRegistrator<TJsonScanExtractor>(\"BINARY_JSON_SCANNER\");\n+    static const inline auto Registrator2 = TFactory::TRegistrator<TJsonScanExtractor>(\"SIMD_JSON_SCANNER\");\n \n public:\n+    TJsonScanExtractor() = default;\n+    TJsonScanExtractor(const bool firstLevelOnly)\n+        : FirstLevelOnly(firstLevelOnly) {\n+    }\n+};\n+\n+class TDataAdapterContainer: public NBackgroundTasks::TInterfaceProtoContainer<IDataAdapter> {\n+private:\n+    using TBase = NBackgroundTasks::TInterfaceProtoContainer<IDataAdapter>;\n+\n+public:\n+    static TDataAdapterContainer GetDefault();\n+\n+    using TBase::TBase;\n };\n \n }   // namespace NKikimr::NArrow::NAccessor::NSubColumns\ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/direct_builder.cpp b/ydb/core/formats/arrow/accessor/sub_columns/direct_builder.cpp\nindex e5126a64dcf6..5b858f8787a5 100644\n--- a/ydb/core/formats/arrow/accessor/sub_columns/direct_builder.cpp\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/direct_builder.cpp\n@@ -5,6 +5,13 @@\n #include <ydb/core/formats/arrow/accessor/plain/accessor.h>\n #include <ydb/core/formats/arrow/accessor/sparsed/accessor.h>\n \n+#include <contrib/libs/simdjson/include/simdjson/dom/array-inl.h>\n+#include <contrib/libs/simdjson/include/simdjson/dom/document-inl.h>\n+#include <contrib/libs/simdjson/include/simdjson/dom/element-inl.h>\n+#include <contrib/libs/simdjson/include/simdjson/dom/object-inl.h>\n+#include <contrib/libs/simdjson/include/simdjson/dom/parser-inl.h>\n+#include <contrib/libs/simdjson/include/simdjson/ondemand.h>\n+\n namespace NKikimr::NArrow::NAccessor::NSubColumns {\n \n void TColumnElements::BuildSparsedAccessor(const ui32 recordsCount) {\n@@ -37,7 +44,7 @@ std::shared_ptr<TSubColumnsArray> TDataBuilder::Finish() {\n     TSettings::TColumnsDistributor distributor = Settings.BuildDistributor(sumSize, CurrentRecordIndex);\n     for (auto rIt = elementsBySize.rbegin(); rIt != elementsBySize.rend(); ++rIt) {\n         for (auto&& i : rIt->second) {\n-            switch (distributor.TakeAndDetect(rIt->first, i->GetRecordIndexes().size())) { \n+            switch (distributor.TakeAndDetect(rIt->first, i->GetRecordIndexes().size())) {\n                 case TSettings::TColumnsDistributor::EColumnType::Separated:\n                     columnElements.emplace_back(i);\n                     break;\n@@ -97,7 +104,7 @@ TOthersData TDataBuilder::MergeOthers(const std::vector<TColumnElements*>& other\n     auto othersBuilder = TOthersData::MakeMergedBuilder();\n     while (heap.size()) {\n         std::pop_heap(heap.begin(), heap.end());\n-        othersBuilder->Add(heap.back().GetRecordIndex(), heap.back().GetKeyIndex(), heap.back().GetValue());\n+        othersBuilder->AddImpl(heap.back().GetRecordIndex(), heap.back().GetKeyIndex(), heap.back().GetValuePointer());\n         if (!heap.back().Next()) {\n             heap.pop_back();\n         } else {\n@@ -107,4 +114,44 @@ TOthersData TDataBuilder::MergeOthers(const std::vector<TColumnElements*>& other\n     return othersBuilder->Finish(TOthersData::TFinishContext(BuildStats(otherKeys, Settings, recordsCount)));\n }\n \n+std::string BuildString(const TStringBuf currentPrefix, const TStringBuf key) {\n+    if (key.find(\".\") != std::string::npos) {\n+        if (currentPrefix.size()) {\n+            return Sprintf(\"%.*s.\\\"%.*s\\\"\", currentPrefix.size(), currentPrefix.data(), key.size(), key.data());\n+        } else {\n+            return Sprintf(\"\\\"%.*s\\\"\", key.size(), key.data());\n+        }\n+    } else {\n+        if (currentPrefix.size()) {\n+            return Sprintf(\"%.*s.%.*s\", currentPrefix.size(), currentPrefix.data(), key.size(), key.data());\n+        } else {\n+            return std::string(key.data(), key.size());\n+        }\n+    }\n+}\n+\n+TStringBuf TDataBuilder::AddKeyOwn(const TStringBuf currentPrefix, std::string&& key) {\n+    auto it = StorageHash.find(TStorageAddress(currentPrefix, TStringBuf(key.data(), key.size())));\n+    if (it == StorageHash.end()) {\n+        Storage.emplace_back(std::move(key));\n+        TStringBuf sbKey(Storage.back().data(), Storage.back().size());\n+        it = StorageHash.emplace(TStorageAddress(currentPrefix, sbKey), BuildString(currentPrefix, sbKey)).first;\n+    }\n+    return TStringBuf(it->second.data(), it->second.size());\n+}\n+\n+TStringBuf TDataBuilder::AddKey(const TStringBuf currentPrefix, const TStringBuf key) {\n+    TStorageAddress keyAddress(currentPrefix, key);\n+    auto it = StorageHash.find(keyAddress);\n+    if (it == StorageHash.end()) {\n+        it = StorageHash.emplace(keyAddress, BuildString(currentPrefix, key)).first;\n+    }\n+    return TStringBuf(it->second.data(), it->second.size());\n+}\n+\n+TDataBuilder::TDataBuilder(const std::shared_ptr<arrow::DataType>& type, const TSettings& settings)\n+    : Type(type)\n+    , Settings(settings) {\n+}\n+\n }   // namespace NKikimr::NArrow::NAccessor::NSubColumns\ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/direct_builder.h b/ydb/core/formats/arrow/accessor/sub_columns/direct_builder.h\nindex 5e7365b271c4..59a1d9ea93da 100644\n--- a/ydb/core/formats/arrow/accessor/sub_columns/direct_builder.h\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/direct_builder.h\n@@ -7,6 +7,8 @@\n #include <ydb/core/formats/arrow/arrow_helpers.h>\n \n #include <contrib/libs/apache/arrow/cpp/src/arrow/array/builder_base.h>\n+#include <contrib/libs/xxhash/xxhash.h>\n+#include <util/string/join.h>\n \n namespace NKikimr::NArrow::NAccessor {\n class TSubColumnsArray;\n@@ -18,7 +20,6 @@ class TColumnElements {\n private:\n     YDB_READONLY_DEF(TStringBuf, KeyName);\n     YDB_READONLY_DEF(std::deque<TStringBuf>, Values);\n-    std::vector<TString> ValuesStorage;\n     YDB_READONLY_DEF(std::vector<ui32>, RecordIndexes);\n     YDB_READONLY(ui32, DataSize, 0);\n     std::shared_ptr<IChunkedArray> Accessor;\n@@ -38,34 +39,82 @@ class TColumnElements {\n \n     void AddData(const TStringBuf sb, const ui32 index) {\n         Values.emplace_back(sb);\n+        AFL_VERIFY(RecordIndexes.empty() || RecordIndexes.back() < index);\n         RecordIndexes.emplace_back(index);\n         DataSize += sb.size();\n     }\n-\n-    void AddDataToOwn(const TString& value, const ui32 index) {\n-        ValuesStorage.emplace_back(value);\n-        AddData(TStringBuf(value.data(), value.size()), index);\n-    }\n };\n \n class TDataBuilder {\n+public:\n+    class IBuffers {\n+    public:\n+        virtual ~IBuffers() = default;\n+    };\n+\n private:\n+    class TStorageAddress {\n+    private:\n+        const TStringBuf Prefix;\n+        const TStringBuf Key;\n+        const size_t Hash;\n+\n+    public:\n+        TStorageAddress(const TStringBuf prefix, const TStringBuf key)\n+            : Prefix(prefix)\n+            , Key(key)\n+            , Hash(XXH3_64bits(Prefix.data(), Prefix.size()) ^ XXH3_64bits(Key.data(), Key.size())) {\n+        }\n+\n+        operator size_t() const {\n+            return Hash;\n+        }\n+\n+        bool operator==(const TStorageAddress& item) const {\n+            return Hash == item.Hash && Prefix == item.Prefix && Key == item.Key;\n+        }\n+    };\n+\n     ui32 CurrentRecordIndex = 0;\n     THashMap<TStringBuf, TColumnElements> Elements;\n-    std::deque<TString> Storage;\n+    THashMap<TStorageAddress, std::string> StorageHash;\n+    std::deque<std::string> Storage;\n+    std::deque<TString> StorageStrings;\n     const std::shared_ptr<arrow::DataType> Type;\n     const TSettings Settings;\n+    std::vector<std::shared_ptr<IBuffers>> Buffers;\n \n public:\n-    TDataBuilder(const std::shared_ptr<arrow::DataType>& type, const TSettings& settings)\n-        : Type(type)\n-        , Settings(settings) {\n+    TDataBuilder(const std::shared_ptr<arrow::DataType>& type, const TSettings& settings);\n+\n+    void StoreBuffer(const std::shared_ptr<IBuffers>& data) {\n+        Buffers.emplace_back(data);\n     }\n \n     void StartNextRecord() {\n         ++CurrentRecordIndex;\n     }\n \n+    TStringBuf AddKeyOwn(const TStringBuf currentPrefix, std::string&& key);\n+    TStringBuf AddKey(const TStringBuf currentPrefix, const TStringBuf key);\n+\n+    void AddKVNull(const TStringBuf key) {\n+        auto itElements = Elements.find(key);\n+        if (itElements == Elements.end()) {\n+            itElements = Elements.emplace(key, key).first;\n+        }\n+        itElements->second.AddData(GetNullString(), CurrentRecordIndex);\n+    }\n+\n+    static const TString& GetNullString() {\n+        const static TString nullString = \"NULL\";\n+        return nullString;\n+    }\n+\n+    static std::string_view GetNullStringView() {\n+        return std::string_view(GetNullString().data(), GetNullString().size());\n+    }\n+\n     void AddKV(const TStringBuf key, const TStringBuf value) {\n         auto itElements = Elements.find(key);\n         if (itElements == Elements.end()) {\n@@ -74,13 +123,22 @@ class TDataBuilder {\n         itElements->second.AddData(value, CurrentRecordIndex);\n     }\n \n-    void AddKVOwn(const TStringBuf key, const TString& value) {\n-        Storage.emplace_back(value);\n+    void AddKVOwn(const TStringBuf key, std::string&& value) {\n+        Storage.emplace_back(std::move(value));\n         auto itElements = Elements.find(key);\n         if (itElements == Elements.end()) {\n             itElements = Elements.emplace(key, key).first;\n         }\n-        itElements->second.AddData(value, CurrentRecordIndex);\n+        itElements->second.AddData(Storage.back(), CurrentRecordIndex);\n+    }\n+\n+    void AddKVOwn(const TStringBuf key, TString&& value) {\n+        StorageStrings.emplace_back(std::move(value));\n+        auto itElements = Elements.find(key);\n+        if (itElements == Elements.end()) {\n+            itElements = Elements.emplace(key, key).first;\n+        }\n+        itElements->second.AddData(StorageStrings.back(), CurrentRecordIndex);\n     }\n \n     class THeapElements {\n@@ -108,8 +166,8 @@ class TDataBuilder {\n             return KeyIndex;\n         }\n \n-        TStringBuf GetValue() const {\n-            return Elements->GetValues()[Index];\n+        const TStringBuf* GetValuePointer() const {\n+            return &Elements->GetValues()[Index];\n         }\n \n         bool operator<(const THeapElements& item) const {\ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/iterators.h b/ydb/core/formats/arrow/accessor/sub_columns/iterators.h\nindex bf642e0e330f..52c6453155c0 100644\n--- a/ydb/core/formats/arrow/accessor/sub_columns/iterators.h\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/iterators.h\n@@ -76,6 +76,38 @@ class TGeneralIterator {\n     bool IsColumnKey() const {\n         return IsColumnKeyFlag;\n     }\n+\n+    bool SkipRecordTo(const ui32 recordIndex) {\n+        struct TVisitor {\n+        private:\n+            TGeneralIterator& Owner;\n+            const ui32 RecordIndex;\n+        public:\n+            TVisitor(TGeneralIterator& owner, const ui32 recordIndex)\n+                : Owner(owner)\n+                , RecordIndex(recordIndex)\n+            {\n+            }\n+            bool operator()(TOthersData::TIterator& iterator) {\n+                if (iterator.SkipRecordTo(RecordIndex)) {\n+                    Owner.InitFromIterator(iterator);\n+                } else {\n+                    Owner.IsValidFlag = false;\n+                }\n+                return Owner.IsValidFlag;\n+            }\n+            bool operator()(TColumnsData::TIterator& iterator) {\n+                if (iterator.SkipRecordTo(RecordIndex)) {\n+                    Owner.InitFromIterator(iterator);\n+                } else {\n+                    Owner.IsValidFlag = false;\n+                }\n+                return Owner.IsValidFlag;\n+            }\n+        };\n+        return std::visit(TVisitor(*this, recordIndex), Iterator);\n+    }\n+\n     bool Next() {\n         struct TVisitor {\n         private:\n@@ -182,6 +214,18 @@ class TReadIteratorUnorderedKeys {\n         }\n         finishRecordActor();\n     }\n+\n+    void SkipRecordTo(const ui32 recordIndex) {\n+        for (ui32 iIter = 0; iIter < SortedIterators.size();) {\n+            if (!SortedIterators[iIter]->SkipRecordTo(recordIndex)) {\n+                std::swap(SortedIterators[iIter], SortedIterators[SortedIterators.size() - 1]);\n+                SortedIterators.pop_back();\n+            } else {\n+                AFL_VERIFY(recordIndex <= SortedIterators[iIter]->GetRecordIndex());\n+                ++iIter;\n+            }\n+        }\n+    }\n };\n \n class TReadIteratorOrderedKeys {\ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/json_extractors.cpp b/ydb/core/formats/arrow/accessor/sub_columns/json_extractors.cpp\nnew file mode 100644\nindex 000000000000..3483ae1369b0\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/json_extractors.cpp\n@@ -0,0 +1,79 @@\n+#include \"json_extractors.h\"\n+\n+#include <util/string/split.h>\n+#include <util/string/vector.h>\n+#include <yql/essentials/types/binary_json/format.h>\n+#include <yql/essentials/types/binary_json/read.h>\n+#include <yql/essentials/types/binary_json/write.h>\n+\n+#include <math.h>\n+\n+namespace NKikimr::NArrow::NAccessor::NSubColumns {\n+\n+TConclusionStatus TArrayExtractor::DoFill(TDataBuilder& dataBuilder, std::deque<std::unique_ptr<IJsonObjectExtractor>>& iterators) {\n+    ui32 idx = 0;\n+    while (Iterator.HasNext()) {\n+        auto value = Iterator.Next();\n+        const TStringBuf key = dataBuilder.AddKeyOwn(GetPrefix(), \"[\" + std::to_string(idx++) + \"]\");\n+        auto conclusion = AddDataToBuilder(dataBuilder, iterators, key, value);\n+        if (conclusion.IsFail()) {\n+            return conclusion;\n+        }\n+    }\n+    return TConclusionStatus::Success();\n+}\n+\n+TConclusionStatus TKVExtractor::DoFill(TDataBuilder& dataBuilder, std::deque<std::unique_ptr<IJsonObjectExtractor>>& iterators) {\n+    while (Iterator.HasNext()) {\n+        auto [jsonKey, value] = Iterator.Next();\n+        if (jsonKey.GetType() != NBinaryJson::EEntryType::String) {\n+            continue;\n+        }\n+        const TStringBuf key = dataBuilder.AddKey(GetPrefix(), jsonKey.GetString());\n+        auto conclusion = AddDataToBuilder(dataBuilder, iterators, key, value);\n+        if (conclusion.IsFail()) {\n+            return conclusion;\n+        }\n+    }\n+    return TConclusionStatus::Success();\n+}\n+\n+TConclusionStatus IJsonObjectExtractor::AddDataToBuilder(TDataBuilder& dataBuilder,\n+    std::deque<std::unique_ptr<IJsonObjectExtractor>>& iterators, const TStringBuf key, NBinaryJson::TEntryCursor& value) const {\n+    if (value.GetType() == NBinaryJson::EEntryType::String) {\n+        dataBuilder.AddKV(key, value.GetString());\n+    } else if (value.GetType() == NBinaryJson::EEntryType::Number) {\n+        const double val = value.GetNumber();\n+        double integer;\n+        if (modf(val, &integer)) {\n+            dataBuilder.AddKVOwn(key, std::to_string(val));\n+        } else {\n+            dataBuilder.AddKVOwn(key, std::to_string((i64)integer));\n+        }\n+    } else if (value.GetType() == NBinaryJson::EEntryType::BoolFalse) {\n+        static const TString zeroString = \"0\";\n+        dataBuilder.AddKV(key, TStringBuf(zeroString.data(), zeroString.size()));\n+    } else if (value.GetType() == NBinaryJson::EEntryType::BoolTrue) {\n+        static const TString oneString = \"1\";\n+        dataBuilder.AddKV(key, TStringBuf(oneString.data(), oneString.size()));\n+    } else if (value.GetType() == NBinaryJson::EEntryType::Container) {\n+        auto container = value.GetContainer();\n+        if (FirstLevelOnly) {\n+            dataBuilder.AddKVOwn(key, NBinaryJson::SerializeToJson(container));\n+        } else if (container.GetType() == NBinaryJson::EContainerType::Array) {\n+            iterators.emplace_back(std::make_unique<TArrayExtractor>(container.GetArrayIterator(), key));\n+        } else if (container.GetType() == NBinaryJson::EContainerType::Object) {\n+            iterators.emplace_back(std::make_unique<TKVExtractor>(container.GetObjectIterator(), key));\n+        } else {\n+            return TConclusionStatus::Fail(\"unexpected top value scalar in container iterator\");\n+        }\n+\n+    } else if (value.GetType() == NBinaryJson::EEntryType::Null) {\n+        dataBuilder.AddKVNull(key);\n+    } else {\n+        return TConclusionStatus::Fail(\"unexpected json value type: \" + ::ToString((int)value.GetType()));\n+    }\n+    return TConclusionStatus::Success();\n+}\n+\n+}   // namespace NKikimr::NArrow::NAccessor::NSubColumns\ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/json_extractors.h b/ydb/core/formats/arrow/accessor/sub_columns/json_extractors.h\nnew file mode 100644\nindex 000000000000..c0e61456c15c\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/json_extractors.h\n@@ -0,0 +1,188 @@\n+#pragma once\n+#include \"direct_builder.h\"\n+\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/array/builder_base.h>\n+#include <contrib/libs/simdjson/include/simdjson/dom/array-inl.h>\n+#include <contrib/libs/simdjson/include/simdjson/dom/document-inl.h>\n+#include <contrib/libs/simdjson/include/simdjson/dom/element-inl.h>\n+#include <contrib/libs/simdjson/include/simdjson/dom/object-inl.h>\n+#include <contrib/libs/simdjson/include/simdjson/dom/parser-inl.h>\n+#include <contrib/libs/simdjson/include/simdjson/ondemand.h>\n+#include <yql/essentials/types/binary_json/read.h>\n+\n+namespace NKikimr::NArrow::NAccessor::NSubColumns {\n+\n+class IJsonObjectExtractor {\n+private:\n+    const TStringBuf Prefix;\n+    virtual TConclusionStatus DoFill(TDataBuilder& dataBuilder, std::deque<std::unique_ptr<IJsonObjectExtractor>>& iterators) = 0;\n+\n+protected:\n+    const bool FirstLevelOnly = false;\n+    TStringBuf GetPrefix() const {\n+        return Prefix;\n+    }\n+\n+    [[nodiscard]] TConclusionStatus AddDataToBuilder(TDataBuilder& dataBuilder, std::deque<std::unique_ptr<IJsonObjectExtractor>>& iterators,\n+        const TStringBuf key, NBinaryJson::TEntryCursor& value) const;\n+\n+public:\n+    virtual ~IJsonObjectExtractor() = default;\n+\n+    IJsonObjectExtractor(const TStringBuf prefix, const bool firstLevelOnly)\n+        : Prefix(prefix)\n+        , FirstLevelOnly(firstLevelOnly) {\n+    }\n+\n+    [[nodiscard]] TConclusionStatus Fill(TDataBuilder& dataBuilder, std::deque<std::unique_ptr<IJsonObjectExtractor>>& iterators) {\n+        return DoFill(dataBuilder, iterators);\n+    }\n+};\n+\n+class TKVExtractor: public IJsonObjectExtractor {\n+private:\n+    using TBase = IJsonObjectExtractor;\n+    NBinaryJson::TObjectIterator Iterator;\n+    virtual TConclusionStatus DoFill(TDataBuilder& dataBuilder, std::deque<std::unique_ptr<IJsonObjectExtractor>>& iterators) override;\n+\n+public:\n+    TKVExtractor(const NBinaryJson::TObjectIterator& iterator, const TStringBuf prefix, const bool firstLevelOnly = false)\n+        : TBase(prefix, firstLevelOnly)\n+        , Iterator(iterator) {\n+    }\n+};\n+\n+class TArrayExtractor: public IJsonObjectExtractor {\n+private:\n+    using TBase = IJsonObjectExtractor;\n+    NBinaryJson::TArrayIterator Iterator;\n+    virtual TConclusionStatus DoFill(TDataBuilder& dataBuilder, std::deque<std::unique_ptr<IJsonObjectExtractor>>& iterators) override;\n+\n+public:\n+    TArrayExtractor(const NBinaryJson::TArrayIterator& iterator, const TStringBuf prefix, const bool firstLevelOnly = false)\n+        : TBase(prefix, firstLevelOnly)\n+        , Iterator(iterator) {\n+    }\n+};\n+\n+class TSIMDExtractor: public IJsonObjectExtractor {\n+private:\n+    using TBase = IJsonObjectExtractor;\n+    simdjson::simdjson_result<simdjson::ondemand::document>& Document;\n+\n+#define RETURN_IF_NOT_SUCCESS(expr)                                                                        \\\n+    if (const auto& status = expr; Y_UNLIKELY(status != simdjson::SUCCESS)) {                              \\\n+        return TConclusionStatus::Fail(\"json parsing error: \" + TString(simdjson::error_message(status))); \\\n+    }\n+\n+    TConclusion<std::string_view> PrintObject(simdjson::ondemand::value& value) const {\n+        switch (value.type()) {\n+            case simdjson::ondemand::json_type::string: {\n+                auto sv = (std::string_view)value.raw_json_token();\n+                AFL_VERIFY(sv.size() >= 2);\n+                return std::string_view(sv.data() + 1, sv.size() - 2);\n+            }\n+            case simdjson::ondemand::json_type::null: {\n+                return TDataBuilder::GetNullStringView();\n+            }\n+            case simdjson::ondemand::json_type::number:\n+            case simdjson::ondemand::json_type::boolean: {\n+                return (std::string_view)value.raw_json_token();\n+            }\n+            case simdjson::ondemand::json_type::object: {\n+                simdjson::ondemand::object v;\n+                RETURN_IF_NOT_SUCCESS(value.get(v));\n+                return v.raw_json();\n+            }\n+            case simdjson::ondemand::json_type::array: {\n+                simdjson::ondemand::array v;\n+                RETURN_IF_NOT_SUCCESS(value.get(v));\n+                return v.raw_json();\n+            }\n+        }\n+    }\n+\n+    template <typename TOnDemandValue>\n+        requires std::is_same_v<TOnDemandValue, simdjson::ondemand::value> || std::is_same_v<TOnDemandValue, simdjson::ondemand::document>\n+    [[nodiscard]] TConclusionStatus ProcessValue(TDataBuilder& dataBuilder, TOnDemandValue& value, const TStringBuf currentKey) {\n+        switch (value.type()) {\n+            case simdjson::ondemand::json_type::string: {\n+                auto sv = (std::string_view)value.raw_json_token();\n+                AFL_VERIFY(sv.size() >= 2);\n+                dataBuilder.AddKV(currentKey, TStringBuf(sv.data() + 1, sv.size() - 2));\n+                break;\n+            }\n+            case simdjson::ondemand::json_type::null: {\n+                dataBuilder.AddKVNull(currentKey);\n+                break;\n+            }\n+            case simdjson::ondemand::json_type::number:\n+            case simdjson::ondemand::json_type::boolean: {\n+                dataBuilder.AddKV(currentKey, (std::string_view)value.raw_json_token());\n+                break;\n+            }\n+            case simdjson::ondemand::json_type::array: {\n+                simdjson::ondemand::array v;\n+                RETURN_IF_NOT_SUCCESS(value.get(v));\n+                ui32 idx = 0;\n+                for (auto item : v) {\n+                    RETURN_IF_NOT_SUCCESS(item.error());\n+                    const TStringBuf sbKey = dataBuilder.AddKeyOwn(currentKey, \"[\" + std::to_string(idx++) + \"]\");\n+                    if (FirstLevelOnly) {\n+                        auto conclusion = PrintObject(item.value_unsafe());\n+                        if (conclusion.IsFail()) {\n+                            return conclusion;\n+                        }\n+                        dataBuilder.AddKV(sbKey, conclusion.DetachResult());\n+                    } else {\n+                        auto conclusion =\n+                            ProcessValue(dataBuilder, item.value_unsafe(), sbKey);\n+                        if (conclusion.IsFail()) {\n+                            return conclusion;\n+                        }\n+                    }\n+                }\n+                break;\n+            }\n+            case simdjson::ondemand::json_type::object: {\n+                simdjson::ondemand::object v;\n+                RETURN_IF_NOT_SUCCESS(value.get(v));\n+                for (auto item : v) {\n+                    RETURN_IF_NOT_SUCCESS(item.error());\n+                    auto& keyValue = item.value_unsafe();\n+                    const auto key = keyValue.escaped_key();\n+                    const auto sbKey = dataBuilder.AddKey(currentKey, key);\n+                    if (FirstLevelOnly) {\n+                        auto conclusion = PrintObject(keyValue.value());\n+                        if (conclusion.IsFail()) {\n+                            return conclusion;\n+                        }\n+                        dataBuilder.AddKV(sbKey, conclusion.DetachResult());\n+                    } else {\n+                        auto conclusion = ProcessValue(dataBuilder, keyValue.value(), sbKey);\n+                        if (conclusion.IsFail()) {\n+                            return conclusion;\n+                        }\n+                    }\n+                }\n+                break;\n+            }\n+        }\n+\n+        return TConclusionStatus::Success();\n+    }\n+\n+    virtual TConclusionStatus DoFill(TDataBuilder& dataBuilder, std::deque<std::unique_ptr<IJsonObjectExtractor>>& /*iterators*/) override {\n+        RETURN_IF_NOT_SUCCESS(Document.error());\n+        return ProcessValue(dataBuilder, Document.value_unsafe(), TStringBuf());\n+    }\n+\n+public:\n+#undef RETURN_IF_NOT_SUCCESS\n+    TSIMDExtractor(simdjson::simdjson_result<simdjson::ondemand::document>& document, const bool firstLevelOnly = false)\n+        : TBase(TStringBuf(), firstLevelOnly)\n+        , Document(document) {\n+    }\n+};\n+\n+}   // namespace NKikimr::NArrow::NAccessor::NSubColumns\ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/others_storage.cpp b/ydb/core/formats/arrow/accessor/sub_columns/others_storage.cpp\nindex 58d1877d6496..36c8a7fe3edc 100644\n--- a/ydb/core/formats/arrow/accessor/sub_columns/others_storage.cpp\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/others_storage.cpp\n@@ -21,12 +21,14 @@ TOthersData::TBuilderWithStats::TBuilderWithStats() {\n     Values = static_cast<arrow::StringBuilder*>(Builders[2].get());\n }\n \n-void TOthersData::TBuilderWithStats::Add(const ui32 recordIndex, const ui32 keyIndex, const std::string_view value) {\n+void TOthersData::TBuilderWithStats::AddImpl(const ui32 recordIndex, const ui32 keyIndex, const std::string_view* value) {\n     AFL_VERIFY(Builders.size());\n     if (StatsByKeyIndex.size() <= keyIndex) {\n         StatsByKeyIndex.resize((keyIndex + 1) * 2);\n     }\n-    StatsByKeyIndex[keyIndex].AddValue(value);\n+    if (value) {\n+        StatsByKeyIndex[keyIndex].AddValue(*value);\n+    }\n     if (!LastRecordIndex) {\n         LastRecordIndex = recordIndex;\n         LastKeyIndex = keyIndex;\n@@ -35,7 +37,11 @@ void TOthersData::TBuilderWithStats::Add(const ui32 recordIndex, const ui32 keyI\n     }\n     TStatusValidator::Validate(RecordIndex->Append(recordIndex));\n     RTKeyIndexes.emplace_back(keyIndex);\n-    TStatusValidator::Validate(Values->Append(value.data(), value.size()));\n+    if (value) {\n+        TStatusValidator::Validate(Values->Append(value->data(), value->size()));\n+    } else {\n+        TStatusValidator::Validate(Values->AppendNull());\n+    }\n     ++RecordsCount;\n }\n \n@@ -247,7 +253,7 @@ std::shared_ptr<IChunkedArray> TOthersData::GetPathAccessor(const std::string_vi\n         filter.Add(it.GetKeyIndex() == *idx);\n     }\n     auto recordsFiltered = Records;\n-    AFL_VERIFY(filter.Apply(recordsFiltered));\n+    filter.Apply(recordsFiltered);\n     auto table = recordsFiltered->BuildTableVerified(std::set<std::string>({ \"record_idx\", \"value\" }));\n \n     TSparsedArray::TBuilder builder(nullptr, arrow::utf8());\ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/others_storage.h b/ydb/core/formats/arrow/accessor/sub_columns/others_storage.h\nindex 84ba8071f1e0..8917d6de63ec 100644\n--- a/ydb/core/formats/arrow/accessor/sub_columns/others_storage.h\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/others_storage.h\n@@ -73,6 +73,22 @@ class TOthersData {\n             CurrentIndex = 0;\n         }\n \n+        bool SkipRecordTo(const ui32 recordIndex) {\n+            AFL_VERIFY(IsValid());\n+            if (recordIndex <= RecordIndex->Value(CurrentIndex)) {\n+                return true;\n+            }\n+            auto idx = NArrow::FindUpperOrEqualPosition(*RecordIndex, recordIndex, CurrentIndex);\n+            if (!idx) {\n+                CurrentIndex = RecordIndex->length();\n+                return false;\n+            } else {\n+                CurrentIndex = *idx;\n+                AFL_VERIFY(recordIndex <= RecordIndex->Value(CurrentIndex));\n+                return CurrentIndex < RecordsCount;\n+            }\n+        }\n+\n         std::optional<ui32> FindPosition(const ui32 findRecordIndex) const {\n             return NArrow::FindUpperOrEqualPosition(*RecordIndex, findRecordIndex);\n         }\n@@ -173,11 +189,16 @@ class TOthersData {\n         std::optional<ui32> LastKeyIndex;\n         ui32 RecordsCount = 0;\n         YDB_READONLY_DEF(std::vector<TDictStats::TRTStatsValue>, StatsByKeyIndex);\n-\n     public:\n         TBuilderWithStats();\n \n-        void Add(const ui32 recordIndex, const ui32 keyIndex, const std::string_view value);\n+        void AddImpl(const ui32 recordIndex, const ui32 keyIndex, const std::string_view* value);\n+        void Add(const ui32 recordIndex, const ui32 keyIndex, const std::string_view value) {\n+            return AddImpl(recordIndex, keyIndex, &value);\n+        }\n+        void AddNull(const ui32 recordIndex, const ui32 keyIndex) {\n+            return AddImpl(recordIndex, keyIndex, nullptr);\n+        }\n \n         TOthersData Finish(const TFinishContext& finishContext);\n     };\ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/request.cpp b/ydb/core/formats/arrow/accessor/sub_columns/request.cpp\nindex 82315e89737c..e0483ec58e6e 100644\n--- a/ydb/core/formats/arrow/accessor/sub_columns/request.cpp\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/request.cpp\n@@ -1,5 +1,6 @@\n-#include \"request.h\"\n #include \"constructor.h\"\n+#include \"data_extractor.h\"\n+#include \"request.h\"\n \n namespace NKikimr::NArrow::NAccessor::NSubColumns {\n \n@@ -20,6 +21,20 @@ TConclusionStatus TRequestedConstuctor::DoDeserializeFromRequest(NYql::TFeatures\n     if (auto kff = features.Extract<ui32>(\"SPARSED_DETECTOR_KFF\")) {\n         Settings.SetSparsedDetectorKff(*kff);\n     }\n+    THolder<IDataAdapter> extractor;\n+    if (auto dataExtractorClassName = features.Extract<TString>(\"DATA_EXTRACTOR_CLASS_NAME\")) {\n+        extractor = IDataAdapter::TFactory::MakeHolder(*dataExtractorClassName);\n+        if (!extractor) {\n+            return TConclusionStatus::Fail(\"incorrect data extractor class name\");\n+        }\n+    } else {\n+        extractor = MakeHolder<TJsonScanExtractor>(false);\n+    }\n+    auto parseConclusion = extractor->DeserializeFromRequest(features);\n+    if (parseConclusion.IsFail()) {\n+        return parseConclusion;\n+    }\n+    Settings.SetDataExtractor(std::shared_ptr<IDataAdapter>(extractor.Release()));\n     if (auto memLimit = features.Extract<ui32>(\"MEM_LIMIT_CHUNK\")) {\n         Settings.SetChunkMemoryLimit(*memLimit);\n     }\n@@ -36,4 +51,4 @@ NKikimr::TConclusion<TConstructorContainer> TRequestedConstuctor::DoBuildConstru\n     return std::make_shared<TConstructor>(Settings);\n }\n \n-}\n+}   // namespace NKikimr::NArrow::NAccessor::NSubColumns\ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/settings.h b/ydb/core/formats/arrow/accessor/sub_columns/settings.h\nindex 45dda39ae0c4..0a6c38d5cb68 100644\n--- a/ydb/core/formats/arrow/accessor/sub_columns/settings.h\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/settings.h\n@@ -1,4 +1,6 @@\n #pragma once\n+#include \"data_extractor.h\"\n+\n #include <ydb/core/formats/arrow/accessor/abstract/accessor.h>\n #include <ydb/core/formats/arrow/arrow_helpers.h>\n \n@@ -14,6 +16,7 @@ class TSettings {\n     YDB_ACCESSOR(ui32, ColumnsLimit, 1024);\n     YDB_ACCESSOR(ui32, ChunkMemoryLimit, 50 * 1024 * 1024);\n     YDB_READONLY(double, OthersAllowedFraction, 0.05);\n+    YDB_ACCESSOR_DEF(TDataAdapterContainer, DataExtractor);\n \n public:\n     class TColumnsDistributor {\n@@ -45,11 +48,14 @@ class TSettings {\n     }\n \n     TSettings() = default;\n-    TSettings(const ui32 sparsedDetectorKff, const ui32 columnsLimit, const ui32 chunkMemoryLimit, const double othersAllowedFraction)\n+    TSettings(const ui32 sparsedDetectorKff, const ui32 columnsLimit, const ui32 chunkMemoryLimit, const double othersAllowedFraction,\n+        const TDataAdapterContainer& dataExtractor)\n         : SparsedDetectorKff(sparsedDetectorKff)\n         , ColumnsLimit(columnsLimit)\n         , ChunkMemoryLimit(chunkMemoryLimit)\n-        , OthersAllowedFraction(othersAllowedFraction) {\n+        , OthersAllowedFraction(othersAllowedFraction)\n+        , DataExtractor(dataExtractor) {\n+        AFL_VERIFY(!!DataExtractor);\n         AFL_VERIFY(OthersAllowedFraction >= 0 && OthersAllowedFraction <= 1)(\"others_fraction\", OthersAllowedFraction);\n     }\n \n@@ -65,6 +71,7 @@ class TSettings {\n         result.InsertValue(\"columns_limit\", ColumnsLimit);\n         result.InsertValue(\"memory_limit\", ChunkMemoryLimit);\n         result.InsertValue(\"others_allowed_fraction\", OthersAllowedFraction);\n+        result.InsertValue(\"data_extractor\", DataExtractor->DebugJson());\n         return result;\n     }\n \n@@ -79,6 +86,7 @@ class TSettings {\n         result.SetColumnsLimit(ColumnsLimit);\n         result.SetChunkMemoryLimit(ChunkMemoryLimit);\n         result.SetOthersAllowedFraction(OthersAllowedFraction);\n+        DataExtractor.SerializeToProto(*result.MutableDataExtractor());\n     }\n \n     template <class TProto>\n@@ -87,6 +95,11 @@ class TSettings {\n         ColumnsLimit = proto.GetColumnsLimit();\n         ChunkMemoryLimit = proto.GetChunkMemoryLimit();\n         OthersAllowedFraction = proto.GetOthersAllowedFraction();\n+        if (!proto.HasDataExtractor()) {\n+            AFL_VERIFY(DataExtractor.Initialize(TJsonScanExtractor::GetClassNameStatic()));\n+        } else if (!DataExtractor.DeserializeFromProto(proto.GetDataExtractor())) {\n+            return false;\n+        }\n         return true;\n     }\n \ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/signals.cpp b/ydb/core/formats/arrow/accessor/sub_columns/signals.cpp\nnew file mode 100644\nindex 000000000000..b8e60c8c8793\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/signals.cpp\n@@ -0,0 +1,5 @@\n+#include \"signals.h\"\n+\n+namespace NKikimr::NArrow::NAccessor ::NSubColumns{\n+\n+}   // namespace NKikimr::NArrow::NAccessor\ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/signals.h b/ydb/core/formats/arrow/accessor/sub_columns/signals.h\nnew file mode 100644\nindex 000000000000..51c27b05af3d\n--- /dev/null\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/signals.h\n@@ -0,0 +1,73 @@\n+#pragma once\n+#include <ydb/library/signals/owner.h>\n+\n+#include <library/cpp/monlib/dynamic_counters/counters.h>\n+\n+namespace NKikimr::NArrow::NAccessor::NSubColumns {\n+\n+class TCategorySignals: public NColumnShard::TCommonCountersOwner {\n+private:\n+    using TBase = NColumnShard::TCommonCountersOwner;\n+\n+    NMonitoring::THistogramPtr HistogramRawDataSizeBytes;\n+    NMonitoring::THistogramPtr HistogramRawDataSizeCount;\n+    NMonitoring::THistogramPtr HistogramRawDataSizeDuration;\n+\n+    NMonitoring::THistogramPtr HistogramBlobDataSizeBytes;\n+    NMonitoring::THistogramPtr HistogramBlobDataSizeCount;\n+    NMonitoring::THistogramPtr HistogramBlobDataSizeDuration;\n+\n+public:\n+    TCategorySignals(NColumnShard::TCommonCountersOwner& owner, const TString& categoryName)\n+        : TBase(owner, \"category\", categoryName)\n+        , HistogramRawDataSizeBytes(TBase::GetHistogram(\"RawData/BySize/Bytes\", NMonitoring::ExponentialHistogram(15, 2, 100)))\n+        , HistogramRawDataSizeCount(TBase::GetHistogram(\"RawData/BySize/Count\", NMonitoring::ExponentialHistogram(15, 2, 100)))\n+        , HistogramRawDataSizeDuration(TBase::GetHistogram(\"RawData/BySize/Duration/Us\", NMonitoring::ExponentialHistogram(15, 2, 100)))\n+        , HistogramBlobDataSizeBytes(TBase::GetHistogram(\"BlobData/BySize/Bytes\", NMonitoring::ExponentialHistogram(15, 2, 100)))\n+        , HistogramBlobDataSizeCount(TBase::GetHistogram(\"BlobData/BySize/Count\", NMonitoring::ExponentialHistogram(15, 2, 100)))\n+        , HistogramBlobDataSizeDuration(TBase::GetHistogram(\"BlobData/BySize/Duration/Us\", NMonitoring::ExponentialHistogram(15, 2, 100))) {\n+    }\n+\n+    void OnBlobSize(const i64 rawDataSize, const i64 blobDataSize, const TDuration d) const {\n+        HistogramBlobDataSizeBytes->Collect(blobDataSize, blobDataSize);\n+        HistogramBlobDataSizeCount->Collect(blobDataSize);\n+        HistogramBlobDataSizeDuration->Collect(blobDataSize, d.MicroSeconds());\n+\n+        HistogramRawDataSizeBytes->Collect(rawDataSize, rawDataSize);\n+        HistogramRawDataSizeCount->Collect(rawDataSize);\n+        HistogramRawDataSizeDuration->Collect(rawDataSize, d.MicroSeconds());\n+    }\n+};\n+\n+class TSignalsImpl: public NColumnShard::TCommonCountersOwner {\n+private:\n+    using TBase = NColumnShard::TCommonCountersOwner;\n+\n+    TCategorySignals ColumnSignals;\n+    TCategorySignals OtherSignals;\n+\n+public:\n+    TSignalsImpl()\n+        : TBase(\"sub_columns\")\n+        , ColumnSignals(*this, \"columns\")\n+        , OtherSignals(*this, \"other\") {\n+    }\n+\n+    const TCategorySignals& GetColumnSignals() const {\n+        return ColumnSignals;\n+    }\n+    const TCategorySignals& GetOtherSignals() const {\n+        return OtherSignals;\n+    }\n+};\n+\n+class TSignals {\n+public:\n+    static const TCategorySignals& GetColumnSignals() {\n+        return Singleton<TSignalsImpl>()->GetColumnSignals();\n+    }\n+    static const TCategorySignals& GetOtherSignals() {\n+        return Singleton<TSignalsImpl>()->GetOtherSignals();\n+    }\n+};\n+}   // namespace NKikimr::NArrow::NAccessor::NSubColumns\ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/ut/ut_sub_columns.cpp b/ydb/core/formats/arrow/accessor/sub_columns/ut/ut_sub_columns.cpp\nindex 40513d522380..edeef71ee950 100644\n--- a/ydb/core/formats/arrow/accessor/sub_columns/ut/ut_sub_columns.cpp\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/ut/ut_sub_columns.cpp\n@@ -49,7 +49,7 @@ Y_UNIT_TEST_SUITE(SubColumnsArrayAccessor) {\n \n     Y_UNIT_TEST(SlicesDef) {\n         for (ui32 colsCount = 0; colsCount < 5; ++colsCount) {\n-            NSubColumns::TSettings settings(4, colsCount, 0, 0);\n+            NSubColumns::TSettings settings(4, colsCount, 0, 0, NKikimr::NArrow::NAccessor::NSubColumns::TDataAdapterContainer::GetDefault());\n \n             const std::vector<TString> jsons = {\n                 R\"({\"a\" : 1, \"b\" : 1, \"c\" : \"111\"})\",\n@@ -71,7 +71,7 @@ Y_UNIT_TEST_SUITE(SubColumnsArrayAccessor) {\n                 ++idx;\n             }\n             auto bJsonArr = arrBuilder.Finish(jsons.size());\n-            auto arrData = TSubColumnsArray::Make(bJsonArr, std::make_shared<NSubColumns::TFirstLevelSchemaData>(), settings).DetachResult();\n+            auto arrData = TSubColumnsArray::Make(bJsonArr, settings).DetachResult();\n             Cerr << arrData->DebugJson() << Endl;\n             AFL_VERIFY(PrintBinaryJsons(arrData->GetChunkedArray()) == R\"([[{\"a\":\"1\",\"b\":\"1\",\"c\":\"111\"},null,{\"a1\":\"2\",\"b\":\"2\",\"c\":\"222\"},{\"a\":\"3\",\"b\":\"3\",\"c\":\"333\"},null,{\"a\":\"5\",\"b1\":\"5\"}]])\")(\n                     \"string\", PrintBinaryJsons(arrData->GetChunkedArray()));\n@@ -141,7 +141,7 @@ Y_UNIT_TEST_SUITE(SubColumnsArrayAccessor) {\n \n     Y_UNIT_TEST(FiltersDef) {\n         for (ui32 colsCount = 0; colsCount < 5; ++colsCount) {\n-            NSubColumns::TSettings settings(4, colsCount, 0, 0);\n+            NSubColumns::TSettings settings(4, colsCount, 0, 0, NKikimr::NArrow::NAccessor::NSubColumns::TDataAdapterContainer::GetDefault());\n \n             const std::vector<TString> jsons = {\n                 R\"({\"a\" : 1, \"b\" : 1, \"c\" : \"111\"})\",\n@@ -163,7 +163,7 @@ Y_UNIT_TEST_SUITE(SubColumnsArrayAccessor) {\n                 ++idx;\n             }\n             auto bJsonArr = arrBuilder.Finish(jsons.size());\n-            auto arrData = TSubColumnsArray::Make(bJsonArr, std::make_shared<NSubColumns::TFirstLevelSchemaData>(), settings).DetachResult();\n+            auto arrData = TSubColumnsArray::Make(bJsonArr, settings).DetachResult();\n             Cerr << arrData->DebugJson() << Endl;\n             AFL_VERIFY(PrintBinaryJsons(arrData->GetChunkedArray()) == R\"([[{\"a\":\"1\",\"b\":\"1\",\"c\":\"111\"},null,{\"a1\":\"2\",\"b\":\"2\",\"c\":\"222\"},{\"a\":\"3\",\"b\":\"3\",\"c\":\"333\"},null,{\"a\":\"5\",\"b1\":\"5\"}]])\")(\n                     \"string\", PrintBinaryJsons(arrData->GetChunkedArray()));\ndiff --git a/ydb/core/formats/arrow/accessor/sub_columns/ya.make b/ydb/core/formats/arrow/accessor/sub_columns/ya.make\nindex 9b2f1d220205..13a710f8f96a 100644\n--- a/ydb/core/formats/arrow/accessor/sub_columns/ya.make\n+++ b/ydb/core/formats/arrow/accessor/sub_columns/ya.make\n@@ -7,6 +7,7 @@ PEERDIR(\n     ydb/core/formats/arrow/accessor/composite_serial\n     ydb/core/formats/arrow/save_load\n     ydb/core/formats/arrow/common\n+    ydb/library/signals\n     ydb/library/formats/arrow\n     ydb/library/formats/arrow/protos\n     yql/essentials/types/binary_json\n@@ -18,6 +19,7 @@ SRCS(\n     header.cpp\n     partial.cpp\n     data_extractor.cpp\n+    json_extractors.cpp\n     accessor.cpp\n     direct_builder.cpp\n     settings.cpp\n@@ -25,10 +27,15 @@ SRCS(\n     others_storage.cpp\n     columns_storage.cpp\n     iterators.cpp\n+    signals.cpp\n )\n \n YQL_LAST_ABI_VERSION()\n \n+CFLAGS(\n+    -Wno-assume\n+)\n+\n END()\n \n RECURSE_FOR_TESTS(\ndiff --git a/ydb/core/formats/arrow/arrow_batch_builder.cpp b/ydb/core/formats/arrow/arrow_batch_builder.cpp\nindex ebd955833c8e..7db800ffd816 100644\n--- a/ydb/core/formats/arrow/arrow_batch_builder.cpp\n+++ b/ydb/core/formats/arrow/arrow_batch_builder.cpp\n@@ -183,9 +183,13 @@ bool TRecordBatchReader::DeserializeFromStrings(const TString& schemaString, con\n     return true;\n }\n \n-TArrowBatchBuilder::TArrowBatchBuilder(arrow::Compression::type codec, const std::set<std::string>& notNullColumns)\n+TArrowBatchBuilder::TArrowBatchBuilder(\n+        arrow::Compression::type codec,\n+        const std::set<std::string>& notNullColumns,\n+        arrow::MemoryPool* memoryPool)\n     : WriteOptions(arrow::ipc::IpcWriteOptions::Defaults())\n     , NotNullColumns(notNullColumns)\n+    , MemoryPool(memoryPool)\n {\n     Y_ABORT_UNLESS(arrow::util::Codec::IsAvailable(codec));\n     auto resCodec = arrow::util::Codec::Create(codec);\n@@ -201,7 +205,7 @@ arrow::Status TArrowBatchBuilder::Start(const std::vector<std::pair<TString, NSc\n     if (!schema.ok()) {\n         return arrow::Status::FromArgs(schema.status().code(), \"Cannot make arrow schema: \", schema.status().ToString());\n     }\n-    auto status = arrow::RecordBatchBuilder::Make(*schema, arrow::default_memory_pool(), RowsToReserve, &BatchBuilder);\n+    auto status = arrow::RecordBatchBuilder::Make(*schema, MemoryPool, RowsToReserve, &BatchBuilder);\n     NumRows = NumBytes = 0;\n     if (!status.ok()) {\n         return arrow::Status::FromArgs(schema.status().code(), \"Cannot make arrow builder: \", status.ToString());\ndiff --git a/ydb/core/formats/arrow/arrow_batch_builder.h b/ydb/core/formats/arrow/arrow_batch_builder.h\nindex cacf7fd7882f..042d1bf35555 100644\n--- a/ydb/core/formats/arrow/arrow_batch_builder.h\n+++ b/ydb/core/formats/arrow/arrow_batch_builder.h\n@@ -149,7 +149,10 @@ class TArrowBatchBuilder : public NKikimr::IBlockBuilder {\n \n     /// @note compression is disabled by default KIKIMR-11690\n     // Allowed codecs: UNCOMPRESSED, LZ4_FRAME, ZSTD\n-    TArrowBatchBuilder(arrow::Compression::type codec = arrow::Compression::UNCOMPRESSED, const std::set<std::string>& notNullColumns = {});\n+    TArrowBatchBuilder(\n+        arrow::Compression::type codec = arrow::Compression::UNCOMPRESSED,\n+        const std::set<std::string>& notNullColumns = {},\n+        arrow::MemoryPool* memoryPool = arrow::default_memory_pool());\n     ~TArrowBatchBuilder() = default;\n \n     bool Start(const std::vector<std::pair<TString, NScheme::TTypeInfo>>& columns,\n@@ -197,6 +200,7 @@ class TArrowBatchBuilder : public NKikimr::IBlockBuilder {\n     std::shared_ptr<arrow::RecordBatch> Batch;\n     size_t RowsToReserve{DEFAULT_ROWS_TO_RESERVE};\n     const std::set<std::string> NotNullColumns;\n+    arrow::MemoryPool* MemoryPool;\n \n protected:\n     size_t NumRows{0};\ndiff --git a/ydb/core/formats/arrow/arrow_filter.cpp b/ydb/core/formats/arrow/arrow_filter.cpp\nindex d0e127dc91e8..7be4883bea85 100644\n--- a/ydb/core/formats/arrow/arrow_filter.cpp\n+++ b/ydb/core/formats/arrow/arrow_filter.cpp\n@@ -16,127 +16,6 @@ namespace NKikimr::NArrow {\n \n #define Y_VERIFY_OK(status) Y_ABORT_UNLESS(status.ok(), \"%s\", status.ToString().c_str())\n \n-namespace {\n-enum class ECompareResult : i8 {\n-    LESS = -1,\n-    BORDER = 0,\n-    GREATER = 1\n-};\n-\n-template <typename TArray>\n-inline auto GetValue(const std::shared_ptr<TArray>& array, int pos) {\n-    return array->GetView(pos);\n-}\n-\n-template <typename T>\n-inline void UpdateCompare(const T& value, const T& border, ECompareResult& res) {\n-    if (res == ECompareResult::BORDER) {\n-        if constexpr (std::is_same_v<T, arrow::util::string_view>) {\n-            size_t minSize = (value.size() < border.size()) ? value.size() : border.size();\n-            int cmp = memcmp(value.data(), border.data(), minSize);\n-            if (cmp < 0) {\n-                res = ECompareResult::LESS;\n-            } else if (cmp > 0) {\n-                res = ECompareResult::GREATER;\n-            } else {\n-                UpdateCompare(value.size(), border.size(), res);\n-            }\n-        } else {\n-            if (value < border) {\n-                res = ECompareResult::LESS;\n-            } else if (value > border) {\n-                res = ECompareResult::GREATER;\n-            }\n-        }\n-    }\n-}\n-\n-template <typename TArray, typename T>\n-bool CompareImpl(const std::shared_ptr<arrow::Array>& column, const T& border, std::vector<NArrow::ECompareResult>& rowsCmp) {\n-    bool hasBorder = false;\n-    ECompareResult* res = &rowsCmp[0];\n-    auto array = std::static_pointer_cast<TArray>(column);\n-\n-    for (int i = 0; i < array->length(); ++i, ++res) {\n-        UpdateCompare(GetValue(array, i), border, *res);\n-        hasBorder = hasBorder || (*res == ECompareResult::BORDER);\n-    }\n-    return !hasBorder;\n-}\n-\n-template <typename TArray, typename T>\n-bool CompareImpl(const std::shared_ptr<arrow::ChunkedArray>& column, const T& border, std::vector<NArrow::ECompareResult>& rowsCmp) {\n-    bool hasBorder = false;\n-    ECompareResult* res = &rowsCmp[0];\n-\n-    for (auto& chunk : column->chunks()) {\n-        auto array = std::static_pointer_cast<TArray>(chunk);\n-\n-        for (int i = 0; i < chunk->length(); ++i, ++res) {\n-            UpdateCompare(GetValue(array, i), border, *res);\n-            hasBorder = hasBorder || (*res == ECompareResult::BORDER);\n-        }\n-    }\n-    return !hasBorder;\n-}\n-\n-/// @return true in case we have no borders in compare: no need for future keys, allow early exit\n-template <typename TArray>\n-bool Compare(const arrow::Datum& column, const std::shared_ptr<arrow::Array>& borderArray, std::vector<NArrow::ECompareResult>& rowsCmp) {\n-    auto border = GetValue(std::static_pointer_cast<TArray>(borderArray), 0);\n-\n-    switch (column.kind()) {\n-        case arrow::Datum::ARRAY:\n-            return CompareImpl<TArray>(column.make_array(), border, rowsCmp);\n-        case arrow::Datum::CHUNKED_ARRAY:\n-            return CompareImpl<TArray>(column.chunked_array(), border, rowsCmp);\n-        default:\n-            break;\n-    }\n-    Y_ABORT_UNLESS(false);\n-    return false;\n-}\n-\n-bool SwitchCompare(const arrow::Datum& column, const std::shared_ptr<arrow::Array>& border, std::vector<NArrow::ECompareResult>& rowsCmp) {\n-    Y_ABORT_UNLESS(border->length() == 1);\n-\n-    // first time it's empty\n-    if (rowsCmp.empty()) {\n-        rowsCmp.resize(column.length(), ECompareResult::BORDER);\n-    }\n-\n-    return SwitchArrayType(column, [&](const auto& type) -> bool {\n-        using TWrap = std::decay_t<decltype(type)>;\n-        using TArray = typename arrow::TypeTraits<typename TWrap::T>::ArrayType;\n-        return Compare<TArray>(column, border, rowsCmp);\n-    });\n-}\n-\n-template <typename T>\n-void CompositeCompare(std::shared_ptr<T> some, std::shared_ptr<arrow::RecordBatch> borderBatch, std::vector<NArrow::ECompareResult>& rowsCmp) {\n-    AFL_VERIFY(some);\n-    AFL_VERIFY(borderBatch);\n-    auto key = borderBatch->schema()->fields();\n-    AFL_VERIFY(key.size());\n-\n-    for (size_t i = 0; i < key.size(); ++i) {\n-        auto& field = key[i];\n-        auto typeId = field->type()->id();\n-        auto column = some->GetColumnByName(field->name());\n-        std::shared_ptr<arrow::Array> border = borderBatch->GetColumnByName(field->name());\n-        AFL_VERIFY(column)(\"schema1\", some->schema()->ToString())(\"schema2\", borderBatch->schema()->ToString())(\"f\", field->name());\n-        AFL_VERIFY(border)(\"schema1\", some->schema()->ToString())(\"schema2\", borderBatch->schema()->ToString())(\"f\", field->name());\n-        AFL_VERIFY(some->schema()->GetFieldByName(field->name())->type()->id() == typeId)(\"schema1\", some->schema()->ToString())(\n-            \"schema2\", borderBatch->schema()->ToString())(\"f\", field->name());\n-\n-        if (SwitchCompare(column, border, rowsCmp)) {\n-            break;   // early exit in case we have all rows compared: no borders, can omit key tail\n-        }\n-    }\n-}\n-\n-}   // namespace\n-\n TColumnFilter::TSlicesIterator::TSlicesIterator(const TColumnFilter& owner, const std::optional<ui32> start, const std::optional<ui32> count)\n     : Owner(owner)\n     , StartIndex(start)\n@@ -307,65 +186,10 @@ ui32 TColumnFilter::CrossSize(const ui32 s1, const ui32 f1, const ui32 s2, const\n     return f - s;\n }\n \n-NKikimr::NArrow::TColumnFilter TColumnFilter::MakePredicateFilter(\n-    const arrow::Datum& datum, const arrow::Datum& border, ECompareType compareType) {\n-    std::vector<ECompareResult> cmps;\n-\n-    switch (datum.kind()) {\n-        case arrow::Datum::ARRAY:\n-            Y_ABORT_UNLESS(border.kind() == arrow::Datum::ARRAY);\n-            SwitchCompare(datum, border.make_array(), cmps);\n-            break;\n-        case arrow::Datum::CHUNKED_ARRAY:\n-            Y_ABORT_UNLESS(border.kind() == arrow::Datum::ARRAY);\n-            SwitchCompare(datum, border.make_array(), cmps);\n-            break;\n-        case arrow::Datum::RECORD_BATCH:\n-            Y_ABORT_UNLESS(border.kind() == arrow::Datum::RECORD_BATCH);\n-            CompositeCompare(datum.record_batch(), border.record_batch(), cmps);\n-            break;\n-        case arrow::Datum::TABLE:\n-            Y_ABORT_UNLESS(border.kind() == arrow::Datum::RECORD_BATCH);\n-            CompositeCompare(datum.table(), border.record_batch(), cmps);\n-            break;\n-        default:\n-            Y_ABORT_UNLESS(false);\n-            break;\n-    }\n-\n-    std::vector<bool> bits;\n-    bits.reserve(cmps.size());\n-\n-    switch (compareType) {\n-        case ECompareType::LESS:\n-            for (size_t i = 0; i < cmps.size(); ++i) {\n-                bits.emplace_back(cmps[i] < ECompareResult::BORDER);\n-            }\n-            break;\n-        case ECompareType::LESS_OR_EQUAL:\n-            for (size_t i = 0; i < cmps.size(); ++i) {\n-                bits.emplace_back(cmps[i] <= ECompareResult::BORDER);\n-            }\n-            break;\n-        case ECompareType::GREATER:\n-            for (size_t i = 0; i < cmps.size(); ++i) {\n-                bits.emplace_back(cmps[i] > ECompareResult::BORDER);\n-            }\n-            break;\n-        case ECompareType::GREATER_OR_EQUAL:\n-            for (size_t i = 0; i < cmps.size(); ++i) {\n-                bits.emplace_back(cmps[i] >= ECompareResult::BORDER);\n-            }\n-            break;\n-    }\n-\n-    return NArrow::TColumnFilter(std::move(bits));\n-}\n-\n template <class TData>\n-bool ApplyImpl(const TColumnFilter& filter, std::shared_ptr<TData>& batch, const TColumnFilter::TApplyContext& context) {\n+void ApplyImpl(const TColumnFilter& filter, std::shared_ptr<TData>& batch, const TColumnFilter::TApplyContext& context) {\n     if (!batch || !batch->num_rows()) {\n-        return false;\n+        return;\n     }\n     if (!filter.IsEmpty()) {\n         if (context.HasSlice()) {\n@@ -380,10 +204,10 @@ bool ApplyImpl(const TColumnFilter& filter, std::shared_ptr<TData>& batch, const\n     }\n     if (filter.IsTotalDenyFilter()) {\n         batch = NAdapter::TDataBuilderPolicy<TData>::GetEmptySame(batch);\n-        return true;\n+        return;\n     }\n     if (filter.IsTotalAllowFilter()) {\n-        return true;\n+        return;\n     }\n     if (context.GetTrySlices() && filter.GetFilter().size() * 10 < filter.GetRecordsCountVerified() &&\n         filter.GetRecordsCountVerified() < filter.GetFilteredCountVerified() * 50) {\n@@ -394,18 +218,17 @@ bool ApplyImpl(const TColumnFilter& filter, std::shared_ptr<TData>& batch, const\n     } else {\n         batch = NAdapter::TDataBuilderPolicy<TData>::ApplyArrowFilter(batch, filter);\n     }\n-    return batch->num_rows();\n }\n \n-bool TColumnFilter::Apply(std::shared_ptr<TGeneralContainer>& batch, const TApplyContext& context) const {\n+void TColumnFilter::Apply(std::shared_ptr<TGeneralContainer>& batch, const TApplyContext& context) const {\n     return ApplyImpl(*this, batch, context);\n }\n \n-bool TColumnFilter::Apply(std::shared_ptr<arrow::Table>& batch, const TApplyContext& context) const {\n+void TColumnFilter::Apply(std::shared_ptr<arrow::Table>& batch, const TApplyContext& context) const {\n     return ApplyImpl(*this, batch, context);\n }\n \n-bool TColumnFilter::Apply(std::shared_ptr<arrow::RecordBatch>& batch, const TApplyContext& context) const {\n+void TColumnFilter::Apply(std::shared_ptr<arrow::RecordBatch>& batch, const TApplyContext& context) const {\n     return ApplyImpl(*this, batch, context);\n }\n \n@@ -785,25 +608,24 @@ TString TColumnFilter::DebugString() const {\n     return sb;\n }\n \n-TColumnFilter TColumnFilter::Cut(const ui32 filteredRecordsCount, const ui32 limit, const bool reverse) const {\n+TColumnFilter TColumnFilter::Cut(const ui32 totalRecordsCount, const ui32 limit, const bool reverse) const {\n     if (IsTotalDenyFilter()) {\n         return TColumnFilter::BuildDenyFilter();\n     }\n     TColumnFilter result = TColumnFilter::BuildAllowFilter();\n     if (IsTotalAllowFilter()) {\n-        if (filteredRecordsCount <= limit) {\n+        if (totalRecordsCount <= limit) {\n             return result;\n         }\n         if (reverse) {\n-            result.Add(false, filteredRecordsCount - limit);\n+            result.Add(false, totalRecordsCount - limit);\n             result.Add(true, limit);\n         } else {\n             result.Add(true, limit);\n-            result.Add(false, filteredRecordsCount - limit);\n+            result.Add(false, totalRecordsCount - limit);\n         }\n     } else {\n-        AFL_VERIFY_DEBUG(GetFilteredCountVerified() == filteredRecordsCount)\n-        (\"filter\", GetFilteredCountVerified())(\"total\", GetRecordsCountVerified())(\"ext\", filteredRecordsCount);\n+        AFL_VERIFY(GetRecordsCountVerified() == totalRecordsCount)(\"total\", GetRecordsCountVerified())(\"ext\", totalRecordsCount);\n         ui32 cutCount = 0;\n         bool currentValue = reverse ? LastValue : GetStartValue();\n         const auto scan = [&](auto begin, auto end) {\ndiff --git a/ydb/core/formats/arrow/arrow_filter.h b/ydb/core/formats/arrow/arrow_filter.h\nindex c93b086080ca..9a135f5961ae 100644\n--- a/ydb/core/formats/arrow/arrow_filter.h\n+++ b/ydb/core/formats/arrow/arrow_filter.h\n@@ -86,7 +86,7 @@ class TColumnFilter {\n         bool Next();\n     };\n \n-    TColumnFilter Cut(const ui32 filteredRecordsCount, const ui32 limit, const bool reverse) const;\n+    TColumnFilter Cut(const ui32 totalRecordsCount, const ui32 limit, const bool reverse) const;\n \n     TSlicesIterator BuildSlicesIterator(const std::optional<ui32> startIndex, const std::optional<ui32> count) const {\n         return TSlicesIterator(*this, startIndex, count);\n@@ -266,9 +266,6 @@ class TColumnFilter {\n     TColumnFilter And(const TColumnFilter& extFilter) const Y_WARN_UNUSED_RESULT;\n     TColumnFilter Or(const TColumnFilter& extFilter) const Y_WARN_UNUSED_RESULT;\n \n-    // It makes a filter using composite predicate\n-    static TColumnFilter MakePredicateFilter(const arrow::Datum& datum, const arrow::Datum& border, ECompareType compareType);\n-\n     class TApplyContext {\n     private:\n         YDB_READONLY_DEF(std::optional<ui32>, StartPos);\n@@ -289,9 +286,9 @@ class TColumnFilter {\n         TApplyContext& Slice(const ui32 start, const ui32 count);\n     };\n \n-    [[nodiscard]] bool Apply(std::shared_ptr<TGeneralContainer>& batch, const TApplyContext& context = Default<TApplyContext>()) const;\n-    [[nodiscard]] bool Apply(std::shared_ptr<arrow::Table>& batch, const TApplyContext& context = Default<TApplyContext>()) const;\n-    [[nodiscard]] bool Apply(std::shared_ptr<arrow::RecordBatch>& batch, const TApplyContext& context = Default<TApplyContext>()) const;\n+    void Apply(std::shared_ptr<TGeneralContainer>& batch, const TApplyContext& context = Default<TApplyContext>()) const;\n+    void Apply(std::shared_ptr<arrow::Table>& batch, const TApplyContext& context = Default<TApplyContext>()) const;\n+    void Apply(std::shared_ptr<arrow::RecordBatch>& batch, const TApplyContext& context = Default<TApplyContext>()) const;\n     void Apply(const ui32 expectedRecordsCount, std::vector<arrow::Datum*>& datums) const;\n     [[nodiscard]] std::shared_ptr<NAccessor::IChunkedArray> Apply(\n         const std::shared_ptr<NAccessor::IChunkedArray>& source, const TApplyContext& context = Default<TApplyContext>()) const;\ndiff --git a/ydb/core/formats/arrow/arrow_helpers.h b/ydb/core/formats/arrow/arrow_helpers.h\nindex f9bc678d6278..893c78af0ef7 100644\n--- a/ydb/core/formats/arrow/arrow_helpers.h\n+++ b/ydb/core/formats/arrow/arrow_helpers.h\n@@ -12,18 +12,18 @@\n namespace NKikimr::NArrow {\n \n template <class TArray, class TValue>\n-std::optional<ui32> FindUpperOrEqualPosition(const TArray& arr, const TValue val) {\n+std::optional<ui32> FindUpperOrEqualPosition(const TArray& arr, const TValue val, const ui32 startIndex = 0) {\n     if (!arr.length()) {\n         return std::nullopt;\n     }\n-    TValue left = arr.Value(0);\n+    TValue left = arr.Value(startIndex);\n     TValue right = arr.Value(arr.length() - 1);\n     if (val < left) {\n-        return 0;\n+        return startIndex;\n     } else if (right < val) {\n         return std::nullopt;\n     } else if (val == left) {\n-        return 0;\n+        return startIndex;\n     }\n     ui32 idxLeft = 0;\n     ui32 idxRight = arr.length() - 1;\n@@ -40,6 +40,9 @@ std::optional<ui32> FindUpperOrEqualPosition(const TArray& arr, const TValue val\n             idxRight = idxMiddle;\n         }\n     }\n+    while (idxRight && arr.Value(idxRight) == arr.Value(idxRight - 1)) {\n+        --idxRight;\n+    }\n     return idxRight;\n }\n arrow::Result<std::shared_ptr<arrow::DataType>> GetArrowType(NScheme::TTypeInfo typeInfo);\ndiff --git a/ydb/core/formats/arrow/common/container.cpp b/ydb/core/formats/arrow/common/container.cpp\nindex 8d7ff97342b1..fa382e9ede3f 100644\n--- a/ydb/core/formats/arrow/common/container.cpp\n+++ b/ydb/core/formats/arrow/common/container.cpp\n@@ -155,23 +155,24 @@ std::shared_ptr<NKikimr::NArrow::TGeneralContainer> TGeneralContainer::BuildEmpt\n std::shared_ptr<arrow::Table> TGeneralContainer::BuildTableOptional(const TTableConstructionContext& context) const {\n     std::vector<std::shared_ptr<arrow::ChunkedArray>> columns;\n     std::vector<std::shared_ptr<arrow::Field>> fields;\n+    std::optional<ui32> count;\n     for (i32 i = 0; i < Schema->num_fields(); ++i) {\n         if (context.GetColumnNames() && !context.GetColumnNames()->contains(Schema->field(i)->name())) {\n             continue;\n         }\n-        if (context.GetRecordsCount() || context.GetStartIndex()) {\n-            columns.emplace_back(Columns[i]->Slice(context.GetStartIndex().value_or(0),\n-                context.GetRecordsCount().value_or(GetRecordsCount() - context.GetStartIndex().value_or(0))));\n+        columns.emplace_back(Columns[i]->GetChunkedArray(context));\n+        if (!count) {\n+            count = columns.back()->length();\n         } else {\n-            columns.emplace_back(Columns[i]->GetChunkedArray());\n+            AFL_VERIFY(*count == columns.back()->length())(\"count\", count)(\"local\", columns.back()->length());\n         }\n         fields.emplace_back(Schema->field(i));\n     }\n     if (fields.empty()) {\n         return nullptr;\n     }\n-    AFL_VERIFY(RecordsCount);\n-    return arrow::Table::Make(std::make_shared<arrow::Schema>(fields), columns, context.GetRecordsCount().value_or(*RecordsCount));\n+    AFL_VERIFY(count);\n+    return arrow::Table::Make(std::make_shared<arrow::Schema>(fields), columns, *count);\n }\n \n std::shared_ptr<arrow::Table> TGeneralContainer::BuildTableVerified(const TTableConstructionContext& context) const {\ndiff --git a/ydb/core/formats/arrow/common/container.h b/ydb/core/formats/arrow/common/container.h\nindex 0f78e2492527..28f9247e767e 100644\n--- a/ydb/core/formats/arrow/common/container.h\n+++ b/ydb/core/formats/arrow/common/container.h\n@@ -86,11 +86,9 @@ class TGeneralContainer {\n         return Columns[idx];\n     }\n \n-    class TTableConstructionContext {\n+    class TTableConstructionContext: public NAccessor::TColumnConstructionContext {\n     private:\n         YDB_ACCESSOR_DEF(std::optional<std::set<std::string>>, ColumnNames);\n-        YDB_ACCESSOR_DEF(std::optional<ui32>, StartIndex);\n-        YDB_ACCESSOR_DEF(std::optional<ui32>, RecordsCount);\n \n     public:\n         TTableConstructionContext() = default;\ndiff --git a/ydb/core/formats/arrow/program/abstract.h b/ydb/core/formats/arrow/program/abstract.h\nindex 01724d31aeca..32e73482e962 100644\n--- a/ydb/core/formats/arrow/program/abstract.h\n+++ b/ydb/core/formats/arrow/program/abstract.h\n@@ -13,6 +13,85 @@ class TAccessorsCollection;\n \n namespace NKikimr::NArrow::NSSA {\n \n+class IMemoryCalculationPolicy {\n+public:\n+    enum class EStage {\n+        Accessors = 0 /* \"ACCESSORS\" */,\n+        Filter = 1 /* \"FILTER\" */,\n+        Fetching = 2 /* \"FETCHING\" */,\n+        Merge = 3 /* \"MERGE\" */\n+    };\n+\n+    virtual ~IMemoryCalculationPolicy() = default;\n+\n+    virtual EStage GetStage() const = 0;\n+    virtual ui64 GetReserveMemorySize(\n+        const ui64 blobsSize, const ui64 rawSize, const std::optional<ui32> limit, const ui32 recordsCount) const = 0;\n+};\n+\n+class TFilterCalculationPolicy: public IMemoryCalculationPolicy {\n+public:\n+    virtual EStage GetStage() const override {\n+        return EStage::Filter;\n+    }\n+    virtual ui64 GetReserveMemorySize(\n+        const ui64 blobsSize, const ui64 /*rawSize*/, const std::optional<ui32> /*limit*/, const ui32 /*recordsCount*/) const override {\n+        return blobsSize;\n+    }\n+};\n+\n+class TFetchingCalculationPolicy: public IMemoryCalculationPolicy {\n+public:\n+    virtual EStage GetStage() const override {\n+        return EStage::Fetching;\n+    }\n+    virtual ui64 GetReserveMemorySize(const ui64 blobsSize, const ui64 rawSize, const std::optional<ui32> limit, const ui32 recordsCount) const override {\n+        if (limit) {\n+            return std::max<ui64>(blobsSize, rawSize * (1.0 * *limit) / recordsCount);\n+        } else {\n+            return std::max<ui64>(blobsSize, rawSize);\n+        }\n+    }\n+};\n+\n+class TIndexCheckOperation {\n+public:\n+    enum class EOperation : ui32 {\n+        Equals,\n+        StartsWith,\n+        EndsWith,\n+        Contains\n+    };\n+\n+private:\n+    const EOperation Operation;\n+    YDB_READONLY(bool, CaseSensitive, true);\n+\n+public:\n+    TString GetSignalId() const {\n+        return TStringBuilder() << Operation << \"::\" << (CaseSensitive ? 1 : 0);\n+    }\n+\n+    TString DebugString() const {\n+        return TStringBuilder() << \"{\" << Operation << \",\" << CaseSensitive << \"}\";\n+    }\n+\n+    EOperation GetOperation() const {\n+        return Operation;\n+    }\n+\n+    TIndexCheckOperation(const EOperation op, const bool caseSensitive)\n+        : Operation(op)\n+        , CaseSensitive(caseSensitive) {\n+    }\n+\n+    explicit operator size_t() const {\n+        return (size_t)Operation;\n+    }\n+\n+    bool operator==(const TIndexCheckOperation& op) const = default;\n+};\n+\n using IChunkedArray = NAccessor::IChunkedArray;\n using TAccessorsCollection = NAccessor::TAccessorsCollection;\n \n@@ -176,7 +255,8 @@ enum class EProcessorType {\n     AssembleOriginalData,\n     CheckIndexData,\n     CheckHeaderData,\n-    StreamLogic\n+    StreamLogic,\n+    ReserveMemory\n };\n \n class TFetchingInfo {\n@@ -265,6 +345,13 @@ class IResourceProcessor {\n         Input.emplace_back(TColumnChainInfo(resourceId));\n     }\n \n+    void AddOutput(const ui32 resourceId) {\n+        for (auto&& i : Output) {\n+            AFL_VERIFY(i.GetColumnId() != resourceId);\n+        }\n+        Output.emplace_back(TColumnChainInfo(resourceId));\n+    }\n+\n     void RemoveInput(const ui32 resourceId) {\n         for (ui32 idx = 0; idx < Input.size(); ++idx) {\n             if (Input[idx].GetColumnId() == resourceId) {\ndiff --git a/ydb/core/formats/arrow/program/assign_internal.cpp b/ydb/core/formats/arrow/program/assign_internal.cpp\nindex a1432806e6c1..3493c8fc4394 100644\n--- a/ydb/core/formats/arrow/program/assign_internal.cpp\n+++ b/ydb/core/formats/arrow/program/assign_internal.cpp\n@@ -40,40 +40,16 @@ TConclusion<std::shared_ptr<TCalculationProcessor>> TCalculationProcessor::Build\n \n NJson::TJsonValue TCalculationProcessor::DoDebugJson() const {\n     NJson::TJsonValue result = NJson::JSON_MAP;\n-    if (!!YqlOperationId) {\n-        result.InsertValue(\"yql_op\", ::ToString((NYql::TKernelRequestBuilder::EBinaryOp)*YqlOperationId));\n-    }\n-    if (!!KernelLogic) {\n-        result.InsertValue(\"kernel\", KernelLogic->GetClassName());\n-    }\n+    result.InsertValue(\"kernel\", KernelLogic->DebugJson());\n     return result;\n }\n \n ui64 TCalculationProcessor::DoGetWeight() const {\n-    if (KernelLogic) {\n-        return 0;\n-    }\n-    if (!YqlOperationId) {\n-        return 10;\n-    } else if ((NYql::TKernelRequestBuilder::EBinaryOp)*YqlOperationId == NYql::TKernelRequestBuilder::EBinaryOp::StartsWith ||\n-               (NYql::TKernelRequestBuilder::EBinaryOp)*YqlOperationId == NYql::TKernelRequestBuilder::EBinaryOp::EndsWith) {\n-        return 7;\n-    } else if ((NYql::TKernelRequestBuilder::EBinaryOp)*YqlOperationId == NYql::TKernelRequestBuilder::EBinaryOp::StringContains) {\n-        return 10;\n-    } else if ((NYql::TKernelRequestBuilder::EBinaryOp)*YqlOperationId == NYql::TKernelRequestBuilder::EBinaryOp::Equals) {\n-        return 5;\n-    }\n-    return 0;\n+    return (ui64)KernelLogic->GetWeight();\n }\n \n TString TCalculationProcessor::DoGetSignalCategoryName() const {\n-    if (KernelLogic) {\n-        return ::ToString(GetProcessorType()) + \"::\" + KernelLogic->GetClassName();\n-    } else if (YqlOperationId) {\n-        return ::ToString(GetProcessorType()) + \"::\" + ::ToString((NYql::TKernelRequestBuilder::EBinaryOp)*YqlOperationId);\n-    } else {\n-        return ::ToString(GetProcessorType());\n-    }\n+    return ::ToString(GetProcessorType()) + \"::\" + KernelLogic->SignalDescription();\n }\n \n }   // namespace NKikimr::NArrow::NSSA\ndiff --git a/ydb/core/formats/arrow/program/assign_internal.h b/ydb/core/formats/arrow/program/assign_internal.h\nindex fb67c3c7de6c..213a7299b06a 100644\n--- a/ydb/core/formats/arrow/program/assign_internal.h\n+++ b/ydb/core/formats/arrow/program/assign_internal.h\n@@ -11,7 +11,6 @@ class TCalculationProcessor: public IResourceProcessor {\n private:\n     using TBase = IResourceProcessor;\n \n-    YDB_ACCESSOR_DEF(std::optional<ui32>, YqlOperationId);\n     YDB_ACCESSOR_DEF(std::shared_ptr<IKernelLogic>, KernelLogic);\n \n     std::shared_ptr<IStepFunction> Function;\n@@ -27,6 +26,7 @@ class TCalculationProcessor: public IResourceProcessor {\n         : TBase(std::move(input), std::move(output), EProcessorType::Calculation)\n         , KernelLogic(kernelLogic)\n         , Function(function) {\n+        AFL_VERIFY(KernelLogic);\n     }\n \n     virtual bool IsAggregation() const override {\n@@ -37,7 +37,7 @@ class TCalculationProcessor: public IResourceProcessor {\n \n public:\n     static TConclusion<std::shared_ptr<TCalculationProcessor>> Build(std::vector<TColumnChainInfo>&& input, const TColumnChainInfo& output, \n-        const std::shared_ptr<IStepFunction>& function, const std::shared_ptr<IKernelLogic>& kernelLogic = nullptr);\n+        const std::shared_ptr<IStepFunction>& function, const std::shared_ptr<IKernelLogic>& kernelLogic);\n };\n \n }   // namespace NKikimr::NArrow::NSSA\ndiff --git a/ydb/core/formats/arrow/program/collection.cpp b/ydb/core/formats/arrow/program/collection.cpp\nindex 194fd984b59c..728a7a169345 100644\n--- a/ydb/core/formats/arrow/program/collection.cpp\n+++ b/ydb/core/formats/arrow/program/collection.cpp\n@@ -9,6 +9,11 @@\n \n namespace NKikimr::NArrow::NAccessor {\n \n+void TAccessorsCollection::Upsert(const ui32 columnId, const std::shared_ptr<IChunkedArray>& data, const bool withFilter) {\n+    Remove(columnId, true);\n+    AddVerified(columnId, data, withFilter);\n+}\n+\n void TAccessorsCollection::AddVerified(const ui32 columnId, const arrow::Datum& data, const bool withFilter) {\n     AddVerified(columnId, TAccessorCollectedContainer(data), withFilter);\n }\ndiff --git a/ydb/core/formats/arrow/program/collection.h b/ydb/core/formats/arrow/program/collection.h\nindex 046f7a4c51d9..5d1f6a5b2996 100644\n--- a/ydb/core/formats/arrow/program/collection.h\n+++ b/ydb/core/formats/arrow/program/collection.h\n@@ -43,6 +43,7 @@ class TAccessorsCollection {\n     std::shared_ptr<TColumnFilter> Filter = std::make_shared<TColumnFilter>(TColumnFilter::BuildAllowFilter());\n     bool UseFilter = true;\n     std::optional<ui32> RecordsCountActual;\n+    const std::optional<ui32> RecordsCountOriginal;\n     THashSet<i64> Markers;\n \n public:\n@@ -58,12 +59,19 @@ class TAccessorsCollection {\n         AFL_VERIFY(Markers.erase(marker));\n     }\n \n-    bool IsEmptyFiltered() const {\n+    bool IsEmptyFilter() const {\n         return Filter->IsTotalDenyFilter();\n     }\n \n-    bool HasAccessors() const {\n-        return Accessors.size();\n+    bool HasData() const {\n+        return Accessors.size() || !!RecordsCountActual;\n+    }\n+\n+    bool HasDataAndResultIsEmpty() const {\n+        if (!HasData()) {\n+            return false;\n+        }\n+        return !GetRecordsCountActualVerified() || IsEmptyFilter();\n     }\n \n     std::optional<ui32> GetRecordsCountActualOptional() const {\n@@ -75,9 +83,21 @@ class TAccessorsCollection {\n         return *RecordsCountActual;\n     }\n \n+    ui32 GetRecordsCountRobustVerified() const {\n+        if (UseFilter) {\n+            AFL_VERIFY(!!RecordsCountActual);\n+            return *RecordsCountActual;\n+        } else {\n+            AFL_VERIFY(!!RecordsCountOriginal);\n+            return *RecordsCountOriginal;\n+        }\n+    }\n+\n     TAccessorsCollection() = default;\n     TAccessorsCollection(const ui32 baseRecordsCount)\n-        : RecordsCountActual(baseRecordsCount) {\n+        : RecordsCountActual(baseRecordsCount)\n+        , RecordsCountOriginal(baseRecordsCount)\n+    {\n     }\n \n     std::optional<TAccessorsCollection> SelectOptional(const std::vector<ui32>& indexes, const bool withFilters) const;\n@@ -149,6 +169,7 @@ class TAccessorsCollection {\n     void AddVerified(const ui32 columnId, const arrow::Datum& data, const bool withFilter);\n     void AddVerified(const ui32 columnId, const std::shared_ptr<IChunkedArray>& data, const bool withFilter);\n     void AddVerified(const ui32 columnId, const TAccessorCollectedContainer& data, const bool withFilter);\n+    void Upsert(const ui32 columnId, const std::shared_ptr<IChunkedArray>& data, const bool withFilter);\n \n     void AddConstantVerified(const ui32 columnId, const std::shared_ptr<arrow::Scalar>& scalar) {\n         AFL_VERIFY(columnId);\n@@ -359,15 +380,14 @@ class TAccessorsCollection {\n     }\n \n     void CutFilter(const ui32 recordsCount, const ui32 limit, const bool reverse) {\n-        const ui32 recordsCountImpl = Filter->GetFilteredCount().value_or(recordsCount);\n-        if (recordsCountImpl < limit) {\n+        if (recordsCount < limit) {\n             return;\n         }\n         if (UseFilter) {\n-            auto filter = NArrow::TColumnFilter::BuildAllowFilter().Cut(recordsCountImpl, limit, reverse);\n+            auto filter = NArrow::TColumnFilter::BuildAllowFilter().Cut(recordsCount, limit, reverse);\n             AddFilter(filter);\n         } else {\n-            *Filter = Filter->Cut(recordsCountImpl, limit, reverse);\n+            *Filter = Filter->Cut(recordsCount, limit, reverse);\n         }\n     }\n \ndiff --git a/ydb/core/formats/arrow/program/execution.h b/ydb/core/formats/arrow/program/execution.h\nindex 348dea253feb..48b454f052a2 100644\n--- a/ydb/core/formats/arrow/program/execution.h\n+++ b/ydb/core/formats/arrow/program/execution.h\n@@ -10,13 +10,6 @@\n \n namespace NKikimr::NArrow::NSSA {\n \n-enum class EIndexCheckOperation {\n-    Equals,\n-    StartsWith,\n-    EndsWith,\n-    Contains\n-};\n-\n class TProcessorContext;\n \n class IFetchLogic {\n@@ -153,15 +146,15 @@ class IDataSource {\n \n     class TFetchIndexContext {\n     public:\n-        using EOperation = EIndexCheckOperation;\n+        using TOperation = TIndexCheckOperation;\n \n         class TOperationsBySubColumn {\n         private:\n             std::optional<bool> FullColumnOperations;\n-            THashMap<TString, THashSet<EOperation>> Data;\n+            THashMap<TString, THashSet<TOperation>> Data;\n \n         public:\n-            const THashMap<TString, THashSet<EOperation>>& GetData() const {\n+            const THashMap<TString, THashSet<TOperation>>& GetData() const {\n                 return Data;\n             }\n \n@@ -170,7 +163,7 @@ class IDataSource {\n                 return !*FullColumnOperations;\n             }\n \n-            TOperationsBySubColumn& Add(const TString& subColumn, const EOperation operation, const bool strict = true) {\n+            TOperationsBySubColumn& Add(const TString& subColumn, const TOperation operation, const bool strict = true) {\n                 if (FullColumnOperations) {\n                     AFL_VERIFY(*FullColumnOperations == !subColumn);\n                 } else {\n@@ -196,7 +189,7 @@ class IDataSource {\n             for (auto&& i : OperationsBySubColumn.GetData()) {\n                 auto& subColumnJson = result.InsertValue(i.first, NJson::JSON_ARRAY);\n                 for (auto&& op : i.second) {\n-                    subColumnJson.AppendValue(::ToString(op));\n+                    subColumnJson.AppendValue(op.DebugString());\n                 }\n             }\n             return result;\n@@ -231,15 +224,19 @@ class IDataSource {\n     private:\n         YDB_READONLY(ui32, ColumnId, 0);\n         YDB_READONLY_DEF(TString, SubColumnName);\n-        YDB_READONLY(EIndexCheckOperation, Operation, EIndexCheckOperation::Equals);\n+        TIndexCheckOperation Operation;\n \n     public:\n-        TCheckIndexContext(const ui32 columnId, const TString& subColumnName, const EIndexCheckOperation operation)\n+        TCheckIndexContext(const ui32 columnId, const TString& subColumnName, const TIndexCheckOperation& operation)\n             : ColumnId(columnId)\n             , SubColumnName(subColumnName)\n             , Operation(operation) {\n         }\n \n+        const TIndexCheckOperation& GetOperation() const {\n+            return Operation;\n+        }\n+\n         bool operator==(const TCheckIndexContext& item) const {\n             return std::tie(ColumnId, SubColumnName, Operation) == std::tie(item.ColumnId, item.SubColumnName, item.Operation);\n         }\n@@ -279,9 +276,23 @@ class IDataSource {\n     virtual TConclusion<bool> DoStartFetch(\n         const NArrow::NSSA::TProcessorContext& context, const std::vector<std::shared_ptr<NArrow::NSSA::IFetchLogic>>& fetchers) = 0;\n \n+    virtual TConclusion<bool> DoStartReserveMemory(const NArrow::NSSA::TProcessorContext& /*context*/,\n+        const THashMap<ui32, IDataSource::TDataAddress>& /*columns*/, const THashMap<ui32, IDataSource::TFetchIndexContext>& /*indexes*/,\n+        const THashMap<ui32, IDataSource::TFetchHeaderContext>& /*headers*/,\n+        const std::shared_ptr<NArrow::NSSA::IMemoryCalculationPolicy>& /*policy*/) {\n+        return false;\n+    }\n+\n public:\n     virtual ~IDataSource() = default;\n \n+    TConclusion<bool> StartReserveMemory(const NArrow::NSSA::TProcessorContext& context,\n+        const THashMap<ui32, IDataSource::TDataAddress>& columns, const THashMap<ui32, IDataSource::TFetchIndexContext>& indexes,\n+        const THashMap<ui32, IDataSource::TFetchHeaderContext>& headers, const std::shared_ptr<NArrow::NSSA::IMemoryCalculationPolicy>& policy) {\n+        AFL_VERIFY(policy);\n+        return DoStartReserveMemory(context, columns, indexes, headers, policy);\n+    }\n+\n     TConclusion<bool> StartFetch(\n         const NArrow::NSSA::TProcessorContext& context, const std::vector<std::shared_ptr<NArrow::NSSA::IFetchLogic>>& fetchers) {\n         return DoStartFetch(context, fetchers);\ndiff --git a/ydb/core/formats/arrow/program/filter.cpp b/ydb/core/formats/arrow/program/filter.cpp\nindex 22d40ddbef6c..cd6bc9024047 100644\n--- a/ydb/core/formats/arrow/program/filter.cpp\n+++ b/ydb/core/formats/arrow/program/filter.cpp\n@@ -105,7 +105,7 @@ TConclusion<IResourceProcessor::EExecutionResult> TFilterProcessor::DoExecute(\n                                                      \"input\", inputColumns.front()->GetRecordsCount());\n     if (context.GetLimit()) {\n         context.GetResources()->AddFilter(\n-            filter.Cut(context.GetResources()->GetRecordsCountActualVerified(), *context.GetLimit(), context.GetReverse()));\n+            filter.Cut(context.GetResources()->GetRecordsCountRobustVerified(), *context.GetLimit(), context.GetReverse()));\n     } else {\n         context.GetResources()->AddFilter(filter);\n     }\ndiff --git a/ydb/core/formats/arrow/program/graph_execute.cpp b/ydb/core/formats/arrow/program/graph_execute.cpp\nindex 0bd1f099f1a8..8628efe74738 100644\n--- a/ydb/core/formats/arrow/program/graph_execute.cpp\n+++ b/ydb/core/formats/arrow/program/graph_execute.cpp\n@@ -3,6 +3,8 @@\n #include \"graph_optimization.h\"\n #include \"visitor.h\"\n \n+#include <yql/essentials/minikql/mkql_terminator.h>\n+\n namespace NKikimr::NArrow::NSSA::NGraph::NExecution {\n \n class TResourceUsageInfo {\n@@ -102,7 +104,7 @@ TCompiledGraph::TCompiledGraph(const NOptimization::TGraph& original, const ICol\n                 if (i.second->GetProcessor()->GetProcessorType() == EProcessorType::Filter) {\n                     AFL_VERIFY(!IsFilterRoot(i.second->GetIdentifier()));\n                     FilterRoot.emplace_back(i.second);\n-                } else if (i.second->GetProcessor()->GetProcessorType() != EProcessorType::Const) {\n+                } else if (i.second->GetProcessor()->GetProcessorType() == EProcessorType::Projection) {\n                     AFL_VERIFY(!ResultRoot)(\"debug\", DebugDOT());\n                     ResultRoot = i.second;\n                 } else {\n@@ -122,6 +124,9 @@ TCompiledGraph::TCompiledGraph(const NOptimization::TGraph& original, const ICol\n         for (; it->IsValid(); it->Next()) {\n             it->MutableCurrentNode().SetSequentialIdx(currentIndex);\n             for (auto&& i : it->GetProcessorVerified()->GetInput()) {\n+                if (!i.GetColumnId()) {\n+                    continue;\n+                }\n                 if (resolver.HasColumn(i.GetColumnId())) {\n                     if (IsFilterRoot(it->GetCurrentGraphNode()->GetIdentifier())) {\n                         FilterColumns.emplace(i.GetColumnId());\n@@ -131,6 +136,9 @@ TCompiledGraph::TCompiledGraph(const NOptimization::TGraph& original, const ICol\n                 usage[i.GetColumnId()].InUsage(currentIndex);\n             }\n             for (auto&& i : it->GetProcessorVerified()->GetOutput()) {\n+                if (!i.GetColumnId()) {\n+                    continue;\n+                }\n                 usage[i.GetColumnId()].Constructed(currentIndex);\n             }\n             sortedNodes.emplace_back(&it->MutableCurrentNode());\n@@ -152,12 +160,13 @@ TCompiledGraph::TCompiledGraph(const NOptimization::TGraph& original, const ICol\n         }\n     }\n     AFL_TRACE(NKikimrServices::SSA_GRAPH_EXECUTION)(\"graph_constructed\", DebugDOT());\n-//    Cerr << DebugDOT() << Endl;\n+    //    Cerr << DebugDOT() << Endl;\n }\n \n TConclusionStatus TCompiledGraph::Apply(\n     const std::shared_ptr<IDataSource>& source, const std::shared_ptr<TAccessorsCollection>& resources) const {\n     TProcessorContext context(source, resources, std::nullopt, false);\n+    NMiniKQL::TThrowingBindTerminator bind;\n     std::shared_ptr<TExecutionVisitor> visitor = std::make_shared<TExecutionVisitor>(context);\n     for (auto it = BuildIterator(visitor); it->IsValid();) {\n         {\n@@ -168,7 +177,7 @@ TConclusionStatus TCompiledGraph::Apply(\n                 AFL_VERIFY(*conclusion != IResourceProcessor::EExecutionResult::InBackground);\n             }\n         }\n-        if (resources->IsEmptyFiltered()) {\n+        if (resources->HasDataAndResultIsEmpty()) {\n             resources->Clear();\n             return TConclusionStatus::Success();\n         }\ndiff --git a/ydb/core/formats/arrow/program/graph_optimization.cpp b/ydb/core/formats/arrow/program/graph_optimization.cpp\nindex a907512237d9..54169173e0ab 100644\n--- a/ydb/core/formats/arrow/program/graph_optimization.cpp\n+++ b/ydb/core/formats/arrow/program/graph_optimization.cpp\n@@ -5,12 +5,15 @@\n #include \"header.h\"\n #include \"index.h\"\n #include \"original.h\"\n+#include \"reserve.h\"\n #include \"stream_logic.h\"\n \n #include <ydb/library/arrow_kernels/operations.h>\n #include <ydb/library/formats/arrow/switch/switch_type.h>\n \n+#include <library/cpp/string_utils/quote/quote.h>\n #include <util/string/builder.h>\n+#include <util/string/escape.h>\n #include <yql/essentials/core/arrow_kernels/request/request.h>\n \n namespace NKikimr::NArrow::NSSA::NGraph::NOptimization {\n@@ -199,9 +202,12 @@ TConclusion<bool> TGraph::OptimizeMergeFetching(TGraphNode* baseNode) {\n         if (!i.second->Is(EProcessorType::FetchOriginalData)) {\n             continue;\n         }\n-        if (i.second->GetProcessorAs<TOriginalColumnDataProcessor>()->GetDataAddresses().size() + \n-            i.second->GetProcessorAs<TOriginalColumnDataProcessor>()->GetIndexContext().size() + \n-            i.second->GetProcessorAs<TOriginalColumnDataProcessor>()->GetHeaderContext().size() > 1) {\n+        if (!i.second->AddOptimizerMarker(EOptimizerMarkers::FetchMerged)) {\n+            continue;\n+        }\n+        if (i.second->GetProcessorAs<TOriginalColumnDataProcessor>()->GetDataAddresses().size() +\n+                i.second->GetProcessorAs<TOriginalColumnDataProcessor>()->GetIndexContext().size() +\n+                i.second->GetProcessorAs<TOriginalColumnDataProcessor>()->GetHeaderContext().size() > 1) {\n             continue;\n         }\n         if (i.second->GetProcessorAs<TOriginalColumnDataProcessor>()->GetDataAddresses().size()) {\n@@ -215,28 +221,44 @@ TConclusion<bool> TGraph::OptimizeMergeFetching(TGraphNode* baseNode) {\n         }\n     }\n     bool changed = false;\n+    TGraphNode* nodeFetch = nullptr;\n     if (dataAddresses.size() > 1) {\n         THashSet<ui32> columnIds;\n         for (auto&& i : dataAddresses) {\n             columnIds.emplace(i->GetProcessorAs<TOriginalColumnDataProcessor>()->GetOutputColumnIdOnce());\n         }\n-        auto proc =\n-            std::make_shared<TOriginalColumnDataProcessor>(std::vector<ui32>(columnIds.begin(), columnIds.end()));\n+        auto proc = std::make_shared<TOriginalColumnDataProcessor>(std::vector<ui32>(columnIds.begin(), columnIds.end()));\n         for (auto&& i : dataAddresses) {\n             for (auto&& addr : i->GetProcessorAs<TOriginalColumnDataProcessor>()->GetDataAddresses()) {\n                 proc->Add(addr.second);\n             }\n         }\n-        auto nodeFetch = AddNode(proc);\n+        nodeFetch = AddNode(proc).get();\n         FetchersMerged.emplace(nodeFetch->GetIdentifier());\n         for (auto&& i : dataAddresses) {\n-            for (auto&& to: i->GetOutputEdges()) {\n-                AddEdge(nodeFetch.get(), to.second, to.first.GetResourceId());\n+            for (auto&& to : i->GetOutputEdges()) {\n+                AddEdge(nodeFetch, to.second, to.first.GetResourceId());\n             }\n             RemoveNode(i->GetIdentifier());\n         }\n         changed = true;\n+    } else if (dataAddresses.size() == 1) {\n+        nodeFetch = dataAddresses.front();\n     }\n+    if (nodeFetch) {\n+        std::shared_ptr<IMemoryCalculationPolicy> policy;\n+        if (baseNode->Is(EProcessorType::Filter)) {\n+            policy = std::make_shared<TFilterCalculationPolicy>();\n+        } else if (baseNode->Is(EProcessorType::Projection)) {\n+            policy = std::make_shared<TFetchingCalculationPolicy>();\n+        }\n+        auto reserveMemory = std::make_shared<TReserveMemoryProcessor>(*nodeFetch->GetProcessorAs<TOriginalColumnDataProcessor>(), policy);\n+        auto nodeReserve = AddNode(reserveMemory);\n+        nodeReserve->GetProcessor()->AddOutput(0);\n+        nodeFetch->GetProcessor()->AddInput(0);\n+        AddEdge(nodeReserve.get(), nodeFetch, 0);\n+    }\n+\n     if (indexes.size() + headers.size() > 1) {\n         THashSet<ui32> columnIds;\n         for (auto&& i : indexes) {\n@@ -245,8 +267,7 @@ TConclusion<bool> TGraph::OptimizeMergeFetching(TGraphNode* baseNode) {\n         for (auto&& i : headers) {\n             columnIds.emplace(i->GetProcessorAs<TOriginalColumnDataProcessor>()->GetOutputColumnIdOnce());\n         }\n-        auto proc =\n-            std::make_shared<TOriginalColumnDataProcessor>(std::vector<ui32>(columnIds.begin(), columnIds.end()));\n+        auto proc = std::make_shared<TOriginalColumnDataProcessor>(std::vector<ui32>(columnIds.begin(), columnIds.end()));\n         for (auto&& i : indexes) {\n             for (auto&& addr : i->GetProcessorAs<TOriginalColumnDataProcessor>()->GetIndexContext()) {\n                 proc->Add(addr.second);\n@@ -345,12 +366,6 @@ std::optional<TResourceAddress> TGraph::GetOriginalAddress(TGraphNode* condNode)\n             if (path.StartsWith(\"$.\")) {\n                 path = path.substr(2);\n             }\n-            if (path.StartsWith(\"\\\"\") && path.EndsWith(\"\\\"\")) {\n-                if (path.size() < 2) {\n-                    return std::nullopt;\n-                }\n-                path = path.substr(1, path.size() - 2);\n-            }\n             if (!path) {\n                 return std::nullopt;\n             }\n@@ -367,11 +382,11 @@ TConclusion<bool> TGraph::OptimizeConditionsForIndexes(TGraphNode* condNode) {\n     if (condNode->GetProcessor()->GetProcessorType() != EProcessorType::Calculation) {\n         return false;\n     }\n-    if (condNode->GetProcessor()->GetInput().size() != 2) {\n+    auto calc = condNode->GetProcessorAs<TCalculationProcessor>();\n+    if (!calc->GetKernelLogic()) {\n         return false;\n     }\n-    auto calc = condNode->GetProcessorAs<TCalculationProcessor>();\n-    if (!calc->GetYqlOperationId()) {\n+    if (condNode->GetProcessor()->GetInput().size() != 2) {\n         return false;\n     }\n     if (condNode->GetOutputEdges().size() != 1) {\n@@ -382,17 +397,7 @@ TConclusion<bool> TGraph::OptimizeConditionsForIndexes(TGraphNode* condNode) {\n     if (constNode->GetProcessor()->GetProcessorType() != EProcessorType::Const) {\n         return false;\n     }\n-    if (!!calc->GetKernelLogic()) {\n-        if (!calc->GetKernelLogic()->IsBoolInResult()) {\n-            return false;\n-        }\n-    }\n-    if (calc->GetYqlOperationId()) {\n-        if (!IsBoolResultYqlOperator((NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId())) {\n-            return false;\n-        }\n-    }\n-    if (!calc->GetYqlOperationId() && !calc->GetKernelLogic()) {\n+    if (!calc->GetKernelLogic()->IsBoolInResult()) {\n         return false;\n     }\n     std::optional<TResourceAddress> dataAddr = GetOriginalAddress(dataNode);\n@@ -401,91 +406,44 @@ TConclusion<bool> TGraph::OptimizeConditionsForIndexes(TGraphNode* condNode) {\n     }\n     auto* dest = condNode->GetOutputEdges().begin()->second;\n     const ui32 destResourceId = condNode->GetOutputEdges().begin()->first.GetResourceId();\n-    if ((NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId() == NYql::TKernelRequestBuilder::EBinaryOp::Equals ||\n-        (NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId() == NYql::TKernelRequestBuilder::EBinaryOp::StartsWith ||\n-        (NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId() == NYql::TKernelRequestBuilder::EBinaryOp::EndsWith ||\n-        (NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId() == NYql::TKernelRequestBuilder::EBinaryOp::StringContains) {\n-        if (!IndexesConstructed.emplace(condNode->GetIdentifier()).second) {\n-            return false;\n-        }\n-        RemoveEdge(condNode, dest, destResourceId);\n-\n-        const EIndexCheckOperation indexOperation = [&]() {\n-            if ((NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId() == NYql::TKernelRequestBuilder::EBinaryOp::Equals) {\n-                return EIndexCheckOperation::Equals;\n-            }\n-            if ((NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId() == NYql::TKernelRequestBuilder::EBinaryOp::StartsWith) {\n-                return EIndexCheckOperation::StartsWith;\n-            }\n-            if ((NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId() == NYql::TKernelRequestBuilder::EBinaryOp::EndsWith) {\n-                return EIndexCheckOperation::EndsWith;\n-            }\n-            if ((NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId() == NYql::TKernelRequestBuilder::EBinaryOp::StringContains) {\n-                return EIndexCheckOperation::Contains;\n-            }\n-            return EIndexCheckOperation::Contains;\n-            AFL_VERIFY(false);\n-        }();\n-\n-        const ui32 resourceIdxFetch = BuildNextResourceId();\n-        IDataSource::TFetchIndexContext indexContext(dataAddr->GetColumnId(),\n-            IDataSource::TFetchIndexContext::TOperationsBySubColumn().Add(dataAddr->GetSubColumnName(), indexOperation));\n-        auto indexFetchProc = std::make_shared<TOriginalColumnDataProcessor>(resourceIdxFetch, indexContext);\n-        auto indexFetchNode = AddNode(indexFetchProc);\n-        RegisterProducer(resourceIdxFetch, indexFetchNode.get());\n-\n-        const ui32 resourceIdIndexToAnd = BuildNextResourceId();\n-        IDataSource::TCheckIndexContext checkIndexContext(dataAddr->GetColumnId(), dataAddr->GetSubColumnName(), indexOperation);\n-        auto indexCheckProc = std::make_shared<TIndexCheckerProcessor>(\n-            resourceIdxFetch, constNode->GetProcessor()->GetOutputColumnIdOnce(), checkIndexContext, resourceIdIndexToAnd);\n-        auto indexProcNode = AddNode(indexCheckProc);\n-        RegisterProducer(resourceIdIndexToAnd, indexProcNode.get());\n-        AddEdge(indexFetchNode.get(), indexProcNode.get(), resourceIdxFetch);\n-        AddEdge(constNode, indexProcNode.get(), constNode->GetProcessor()->GetOutputColumnIdOnce());\n-\n-        const ui32 resourceIdEqToAnd = BuildNextResourceId();\n-        RegisterProducer(resourceIdEqToAnd, condNode);\n-        calc->SetOutputResourceIdOnce(resourceIdEqToAnd);\n-\n-        auto andProcessor = std::make_shared<TStreamLogicProcessor>(TColumnChainInfo::BuildVector({ resourceIdEqToAnd, resourceIdIndexToAnd }),\n-            TColumnChainInfo(destResourceId), NKernels::EOperation::And);\n-        auto andNode = AddNode(andProcessor);\n-        AddEdge(andNode.get(), dest, destResourceId);\n-\n-        AddEdge(indexProcNode.get(), andNode.get(), resourceIdIndexToAnd);\n-        AddEdge(condNode, andNode.get(), resourceIdEqToAnd);\n-        ResetProducer(destResourceId, andNode.get());\n-        return true;\n+    auto indexChecker = calc->GetKernelLogic()->GetIndexCheckerOperation();\n+    if (!indexChecker) {\n+        return false;\n     }\n-    return false;\n-}\n+    if (!IndexesConstructed.emplace(condNode->GetIdentifier()).second) {\n+        return false;\n+    }\n+    RemoveEdge(condNode, dest, destResourceId);\n \n-bool TGraph::IsBoolResultYqlOperator(const NYql::TKernelRequestBuilder::EBinaryOp op) const {\n-    switch (op) {\n-        case NYql::TKernelRequestBuilder::EBinaryOp::And:\n-        case NYql::TKernelRequestBuilder::EBinaryOp::Or:\n-        case NYql::TKernelRequestBuilder::EBinaryOp::Xor:\n-            return true;\n-        case NYql::TKernelRequestBuilder::EBinaryOp::Add:\n-        case NYql::TKernelRequestBuilder::EBinaryOp::Sub:\n-        case NYql::TKernelRequestBuilder::EBinaryOp::Mul:\n-        case NYql::TKernelRequestBuilder::EBinaryOp::Div:\n-        case NYql::TKernelRequestBuilder::EBinaryOp::Mod:\n-        case NYql::TKernelRequestBuilder::EBinaryOp::Coalesce:\n-            return false;\n+    const ui32 resourceIdxFetch = BuildNextResourceId();\n+    IDataSource::TFetchIndexContext indexContext(\n+        dataAddr->GetColumnId(), IDataSource::TFetchIndexContext::TOperationsBySubColumn().Add(dataAddr->GetSubColumnName(), *indexChecker));\n+    auto indexFetchProc = std::make_shared<TOriginalColumnDataProcessor>(resourceIdxFetch, indexContext);\n+    auto indexFetchNode = AddNode(indexFetchProc);\n+    RegisterProducer(resourceIdxFetch, indexFetchNode.get());\n \n-        case NYql::TKernelRequestBuilder::EBinaryOp::StartsWith:\n-        case NYql::TKernelRequestBuilder::EBinaryOp::EndsWith:\n-        case NYql::TKernelRequestBuilder::EBinaryOp::StringContains:\n+    const ui32 resourceIdIndexToAnd = BuildNextResourceId();\n+    IDataSource::TCheckIndexContext checkIndexContext(dataAddr->GetColumnId(), dataAddr->GetSubColumnName(), *indexChecker);\n+    auto indexCheckProc = std::make_shared<TIndexCheckerProcessor>(\n+        resourceIdxFetch, constNode->GetProcessor()->GetOutputColumnIdOnce(), checkIndexContext, resourceIdIndexToAnd);\n+    auto indexProcNode = AddNode(indexCheckProc);\n+    RegisterProducer(resourceIdIndexToAnd, indexProcNode.get());\n+    AddEdge(indexFetchNode.get(), indexProcNode.get(), resourceIdxFetch);\n+    AddEdge(constNode, indexProcNode.get(), constNode->GetProcessor()->GetOutputColumnIdOnce());\n \n-        case NYql::TKernelRequestBuilder::EBinaryOp::Equals:\n-        case NYql::TKernelRequestBuilder::EBinaryOp::NotEquals:\n-        case NYql::TKernelRequestBuilder::EBinaryOp::Less:\n-        case NYql::TKernelRequestBuilder::EBinaryOp::LessOrEqual:\n-        case NYql::TKernelRequestBuilder::EBinaryOp::Greater:\n-        case NYql::TKernelRequestBuilder::EBinaryOp::GreaterOrEqual:\n-            return true;\n-    }\n+    const ui32 resourceIdEqToAnd = BuildNextResourceId();\n+    RegisterProducer(resourceIdEqToAnd, condNode);\n+    calc->SetOutputResourceIdOnce(resourceIdEqToAnd);\n+\n+    auto andProcessor = std::make_shared<TStreamLogicProcessor>(\n+        TColumnChainInfo::BuildVector({ resourceIdEqToAnd, resourceIdIndexToAnd }), TColumnChainInfo(destResourceId), NKernels::EOperation::And);\n+    auto andNode = AddNode(andProcessor);\n+    AddEdge(andNode.get(), dest, destResourceId);\n+\n+    AddEdge(indexProcNode.get(), andNode.get(), resourceIdIndexToAnd);\n+    AddEdge(condNode, andNode.get(), resourceIdEqToAnd);\n+    ResetProducer(destResourceId, andNode.get());\n+    return true;\n }\n \n TConclusion<bool> TGraph::OptimizeConditionsForHeadersCheck(TGraphNode* condNode) {\n@@ -501,17 +459,7 @@ TConclusion<bool> TGraph::OptimizeConditionsForHeadersCheck(TGraphNode* condNode\n     }\n     auto* dest = condNode->GetOutputEdges().begin()->second;\n     const ui32 destResourceId = condNode->GetOutputEdges().begin()->first.GetResourceId();\n-    if (!!calc->GetKernelLogic()) {\n-        if (!calc->GetKernelLogic()->IsBoolInResult()) {\n-            return false;\n-        }\n-    }\n-    if (calc->GetYqlOperationId()) {\n-        if (!IsBoolResultYqlOperator((NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId())) {\n-            return false;\n-        }\n-    }\n-    if (!calc->GetYqlOperationId() && !calc->GetKernelLogic()) {\n+    if (!calc->GetKernelLogic() || !calc->GetKernelLogic()->IsBoolInResult()) {\n         return false;\n     }\n     auto* node = GetProducerVerified(condNode->GetProcessor()->GetInput()[0].GetColumnId());\n@@ -561,10 +509,11 @@ TConclusion<bool> TGraph::OptimizeFilterWithCoalesce(TGraphNode* cNode) {\n         return false;\n     }\n     const auto calc = cNode->GetProcessorAs<TCalculationProcessor>();\n-    if (!calc->GetYqlOperationId()) {\n+    if (!calc->GetKernelLogic()->GetYqlOperationId()) {\n         return false;\n     }\n-    if ((NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId() != NYql::TKernelRequestBuilder::EBinaryOp::Coalesce) {\n+    if ((NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetKernelLogic()->GetYqlOperationId() !=\n+        NYql::TKernelRequestBuilder::EBinaryOp::Coalesce) {\n         return false;\n     }\n     if (cNode->GetOutputEdges().size() != 1) {\n@@ -585,30 +534,14 @@ TConclusion<bool> TGraph::OptimizeFilterWithCoalesce(TGraphNode* cNode) {\n \n     auto* nextNode = cNode->GetOutputEdges().begin()->second;\n     if (nextNode->GetProcessor()->GetProcessorType() != EProcessorType::Filter) {\n-        if (nextNode->GetProcessor()->GetProcessorType() == EProcessorType::Calculation) {\n-            const auto outputCalc = nextNode->GetProcessorAs<TCalculationProcessor>();\n-            if (!outputCalc->GetYqlOperationId()) {\n-                return false;\n-            }\n-            if ((NYql::TKernelRequestBuilder::EBinaryOp)*outputCalc->GetYqlOperationId() != NYql::TKernelRequestBuilder::EBinaryOp::And) {\n-                return false;\n-            }\n-        } else if (nextNode->GetProcessor()->GetProcessorType() == EProcessorType::StreamLogic) {\n-            const auto outputCalc = nextNode->GetProcessorAs<TStreamLogicProcessor>();\n-            if (outputCalc->GetOperation() != NKernels::EOperation::And) {\n-                return false;\n-            }\n+        if (nextNode->GetProcessor()->GetProcessorType() != EProcessorType::StreamLogic) {\n+            return false;\n         }\n-        if (nextNode->GetOutputEdges().size() != 1) {\n+        const auto outputCalc = nextNode->GetProcessorAs<TStreamLogicProcessor>();\n+        if (outputCalc->GetOperation() != NKernels::EOperation::And) {\n             return false;\n         }\n-        if (nextNode->GetOutputEdges().begin()->second->GetProcessor()->GetProcessorType() == EProcessorType::StreamLogic) {\n-            const auto outputCalc = nextNode->GetOutputEdges().begin()->second->GetProcessorAs<TStreamLogicProcessor>();\n-            if (outputCalc->GetOperation() != NKernels::EOperation::And) {\n-                return false;\n-            }\n-        } else if (nextNode->GetOutputEdges().begin()->second->GetProcessor()->GetProcessorType() == EProcessorType::Filter) {\n-        } else {\n+        if (nextNode->GetOutputEdges().size() != 1) {\n             return false;\n         }\n     }\n@@ -693,16 +626,16 @@ TConclusionStatus TGraph::Collapse() {\n                 }\n             }\n \n-            {\n-                auto conclusion = OptimizeConditionsForHeadersCheck(n.get());\n-                if (conclusion.IsFail()) {\n-                    return conclusion;\n-                }\n-                if (*conclusion) {\n-                    hasChanges = true;\n-                    break;\n-                }\n-            }\n+            //            {\n+            //                auto conclusion = OptimizeConditionsForHeadersCheck(n.get());\n+            //                if (conclusion.IsFail()) {\n+            //                    return conclusion;\n+            //                }\n+            //                if (*conclusion) {\n+            //                    hasChanges = true;\n+            //                    break;\n+            //                }\n+            //            }\n \n             {\n                 auto conclusion = OptimizeConditionsForStream(n.get());\ndiff --git a/ydb/core/formats/arrow/program/graph_optimization.h b/ydb/core/formats/arrow/program/graph_optimization.h\nindex 5fcf22495e12..ec5b97a138e2 100644\n--- a/ydb/core/formats/arrow/program/graph_optimization.h\n+++ b/ydb/core/formats/arrow/program/graph_optimization.h\n@@ -47,8 +47,13 @@ class TResourceAddress {\n     TString DebugString() const;\n };\n \n+enum class EOptimizerMarkers {\n+    FetchMerged\n+};\n+\n class TGraphNode {\n private:\n+    std::set<EOptimizerMarkers> OptimizerMarkers;\n     YDB_READONLY(i64, Identifier, 0);\n     YDB_READONLY_DEF(std::shared_ptr<IResourceProcessor>, Processor);\n     class TAddress {\n@@ -81,6 +86,15 @@ class TGraphNode {\n     std::map<TAddress, TGraphNode*> OutputEdges;\n \n public:\n+\n+    bool AddOptimizerMarker(const EOptimizerMarkers marker) {\n+        return OptimizerMarkers.emplace(marker).second;\n+    }\n+\n+    bool HasOptimizerMarker(const EOptimizerMarkers marker) {\n+        return OptimizerMarkers.contains(marker);\n+    }\n+\n     void AddEdgeTo(TGraphNode* to, const ui32 resourceId);\n     void AddEdgeFrom(TGraphNode* from, const ui32 resourceId);\n     void RemoveEdgeTo(const ui32 identifier, const ui32 resourceId);\n@@ -147,7 +161,6 @@ class TGraph {\n     std::optional<TResourceAddress> GetOriginalAddress(TGraphNode* condNode) const;\n     TConclusion<bool> OptimizeForFetchSubColumns(TGraphNode* condNode);\n     TConclusion<bool> OptimizeConditionsForHeadersCheck(TGraphNode* condNode);\n-    bool IsBoolResultYqlOperator(const NYql::TKernelRequestBuilder::EBinaryOp op) const;\n \n     TConclusion<bool> OptimizeConditionsForStream(TGraphNode* condNode);\n     TConclusion<bool> OptimizeConditionsForIndexes(TGraphNode* condNode);\ndiff --git a/ydb/core/formats/arrow/program/header.cpp b/ydb/core/formats/arrow/program/header.cpp\nindex d2b9bc0010b2..9d80d38abe69 100644\n--- a/ydb/core/formats/arrow/program/header.cpp\n+++ b/ydb/core/formats/arrow/program/header.cpp\n@@ -17,10 +17,10 @@ TConclusion<IResourceProcessor::EExecutionResult> THeaderCheckerProcessor::DoExe\n     }\n     if (conclusion->IsTotalDenyFilter()) {\n         context.GetResources()->AddVerified(GetOutputColumnIdOnce(),\n-            NAccessor::TSparsedArray::BuildFalseArrayUI8(context.GetResources()->GetRecordsCountActualVerified()), false);\n+            NAccessor::TSparsedArray::BuildFalseArrayUI8(context.GetResources()->GetRecordsCountRobustVerified()), false);\n     } else if (conclusion->IsTotalAllowFilter() || !ApplyToFilterFlag) {\n         context.GetResources()->AddVerified(GetOutputColumnIdOnce(),\n-            NAccessor::TSparsedArray::BuildTrueArrayUI8(context.GetResources()->GetRecordsCountActualVerified()), false);\n+            NAccessor::TSparsedArray::BuildTrueArrayUI8(context.GetResources()->GetRecordsCountRobustVerified()), false);\n     } else {\n         context.GetResources()->AddFilter(*conclusion);\n     }\ndiff --git a/ydb/core/formats/arrow/program/index.cpp b/ydb/core/formats/arrow/program/index.cpp\nindex bf955a4106a6..43ab8445caab 100644\n--- a/ydb/core/formats/arrow/program/index.cpp\n+++ b/ydb/core/formats/arrow/program/index.cpp\n@@ -19,10 +19,10 @@ TConclusion<IResourceProcessor::EExecutionResult> TIndexCheckerProcessor::DoExec\n     }\n     if (conclusion->IsTotalDenyFilter()) {\n         context.GetResources()->AddVerified(GetOutputColumnIdOnce(),\n-            NAccessor::TSparsedArray::BuildFalseArrayUI8(context.GetResources()->GetRecordsCountActualVerified()), false);\n+            NAccessor::TSparsedArray::BuildFalseArrayUI8(context.GetResources()->GetRecordsCountRobustVerified()), false);\n     } else if (conclusion->IsTotalAllowFilter() || !ApplyToFilterFlag) {\n         context.GetResources()->AddVerified(GetOutputColumnIdOnce(),\n-            NAccessor::TSparsedArray::BuildTrueArrayUI8(context.GetResources()->GetRecordsCountActualVerified()), false);\n+            NAccessor::TSparsedArray::BuildTrueArrayUI8(context.GetResources()->GetRecordsCountRobustVerified()), false);\n     } else {\n         context.GetResources()->AddFilter(*conclusion);\n     }\ndiff --git a/ydb/core/formats/arrow/program/index.h b/ydb/core/formats/arrow/program/index.h\nindex 3a54dd9c5b14..1ff82c80164b 100644\n--- a/ydb/core/formats/arrow/program/index.h\n+++ b/ydb/core/formats/arrow/program/index.h\n@@ -28,7 +28,7 @@ class TIndexCheckerProcessor: public IResourceProcessor {\n     bool ApplyToFilterFlag = false;\n \n     virtual TString DoGetSignalCategoryName() const override {\n-        return ::ToString(GetProcessorType()) + \"::\" + ::ToString(IndexContext.GetOperation());\n+        return ::ToString(GetProcessorType()) + \"::\" + IndexContext.GetOperation().GetSignalId();\n     }\n \n public:\ndiff --git a/ydb/core/formats/arrow/program/kernel_logic.cpp b/ydb/core/formats/arrow/program/kernel_logic.cpp\nindex f20d22d9f55f..e0986354e88e 100644\n--- a/ydb/core/formats/arrow/program/kernel_logic.cpp\n+++ b/ydb/core/formats/arrow/program/kernel_logic.cpp\n@@ -5,6 +5,8 @@\n #include <ydb/core/formats/arrow/accessor/sub_columns/accessor.h>\n #include <ydb/core/formats/arrow/accessor/sub_columns/partial.h>\n \n+#include <yql/essentials/core/arrow_kernels/request/request.h>\n+\n namespace NKikimr::NArrow::NSSA {\n \n TConclusion<bool> TGetJsonPath::DoExecute(const std::vector<TColumnChainInfo>& input, const std::vector<TColumnChainInfo>& output,\n@@ -47,37 +49,6 @@ std::shared_ptr<IChunkedArray> TGetJsonPath::ExtractArray(const std::shared_ptr<\n     }\n }\n \n-std::optional<TFetchingInfo> TGetJsonPath::BuildFetchTask(const ui32 columnId, const NAccessor::IChunkedArray::EType arrType,\n-    const std::vector<TColumnChainInfo>& input, const std::shared_ptr<TAccessorsCollection>& resources) const {\n-    if (arrType != NAccessor::IChunkedArray::EType::SubColumnsArray) {\n-        return TFetchingInfo::BuildFullRestore(false);\n-    }\n-    AFL_VERIFY(input.size() == 2 && input.front().GetColumnId() == columnId);\n-    auto description = BuildDescription(input, resources).DetachResult();\n-    const std::vector<TString> subColumns = { TString(description.GetJsonPath().data(), description.GetJsonPath().size()) };\n-    if (!description.GetInputAccessor()) {\n-        return TFetchingInfo::BuildSubColumnsRestore(subColumns);\n-    }\n-\n-    std::optional<bool> hasSubColumns;\n-    return NAccessor::TCompositeChunkedArray::VisitDataOwners<TFetchingInfo>(\n-        description.GetInputAccessor(), [&](const std::shared_ptr<NAccessor::IChunkedArray>& arr) {\n-            if (arr->GetType() == NAccessor::IChunkedArray::EType::SubColumnsPartialArray) {\n-                AFL_VERIFY(!hasSubColumns || *hasSubColumns);\n-                hasSubColumns = true;\n-                auto scArr = std::static_pointer_cast<NAccessor::TSubColumnsPartialArray>(arr);\n-                if (scArr->NeedFetch(description.GetJsonPath())) {\n-                    return std::optional<TFetchingInfo>(TFetchingInfo::BuildSubColumnsRestore(subColumns));\n-                }\n-            } else {\n-                AFL_VERIFY(arr->GetType() == NAccessor::IChunkedArray::EType::SubColumnsArray);\n-                AFL_VERIFY(!hasSubColumns || !*hasSubColumns);\n-                hasSubColumns = false;\n-            }\n-            return std::optional<TFetchingInfo>();\n-        });\n-}\n-\n NAccessor::TCompositeChunkedArray::TBuilder TGetJsonPath::MakeCompositeBuilder() const {\n     return NAccessor::TCompositeChunkedArray::TBuilder(arrow::utf8());\n }\n@@ -99,4 +70,52 @@ NAccessor::TCompositeChunkedArray::TBuilder TExistsJsonPath::MakeCompositeBuilde\n     return NAccessor::TCompositeChunkedArray::TBuilder(arrow::uint8());\n }\n \n+TString TSimpleKernelLogic::SignalDescription() const {\n+    if (YqlOperationId) {\n+        return ::ToString((NYql::TKernelRequestBuilder::EBinaryOp)*YqlOperationId);\n+    } else {\n+        return \"UNKNOWN\";\n+    }\n+}\n+\n+bool TSimpleKernelLogic::IsBoolInResult() const {\n+    if (YqlOperationId) {\n+        switch ((NYql::TKernelRequestBuilder::EBinaryOp)*YqlOperationId) {\n+            case NYql::TKernelRequestBuilder::EBinaryOp::And:\n+            case NYql::TKernelRequestBuilder::EBinaryOp::Or:\n+            case NYql::TKernelRequestBuilder::EBinaryOp::Xor:\n+                return true;\n+            case NYql::TKernelRequestBuilder::EBinaryOp::Add:\n+            case NYql::TKernelRequestBuilder::EBinaryOp::Sub:\n+            case NYql::TKernelRequestBuilder::EBinaryOp::Mul:\n+            case NYql::TKernelRequestBuilder::EBinaryOp::Div:\n+            case NYql::TKernelRequestBuilder::EBinaryOp::Mod:\n+            case NYql::TKernelRequestBuilder::EBinaryOp::Coalesce:\n+                return false;\n+\n+            case NYql::TKernelRequestBuilder::EBinaryOp::StartsWith:\n+            case NYql::TKernelRequestBuilder::EBinaryOp::EndsWith:\n+            case NYql::TKernelRequestBuilder::EBinaryOp::StringContains:\n+\n+            case NYql::TKernelRequestBuilder::EBinaryOp::Equals:\n+            case NYql::TKernelRequestBuilder::EBinaryOp::NotEquals:\n+            case NYql::TKernelRequestBuilder::EBinaryOp::Less:\n+            case NYql::TKernelRequestBuilder::EBinaryOp::LessOrEqual:\n+            case NYql::TKernelRequestBuilder::EBinaryOp::Greater:\n+            case NYql::TKernelRequestBuilder::EBinaryOp::GreaterOrEqual:\n+                return true;\n+        }\n+    } else {\n+        return false;\n+    }\n+}\n+\n+NJson::TJsonValue TSimpleKernelLogic::DoDebugJson() const {\n+    if (YqlOperationId) {\n+        return ::ToString((NYql::TKernelRequestBuilder::EBinaryOp)*YqlOperationId);\n+    } else {\n+        return NJson::JSON_NULL;\n+    }\n+}\n+\n }   // namespace NKikimr::NArrow::NSSA\ndiff --git a/ydb/core/formats/arrow/program/kernel_logic.h b/ydb/core/formats/arrow/program/kernel_logic.h\nindex c6488f691c57..d65405053c42 100644\n--- a/ydb/core/formats/arrow/program/kernel_logic.h\n+++ b/ydb/core/formats/arrow/program/kernel_logic.h\n@@ -8,21 +8,52 @@\n \n namespace NKikimr::NArrow::NSSA {\n \n+enum class ECalculationHardness {\n+    JustAccessorUsage = 1,\n+    NotSpecified = 3,\n+    Equals = 5,\n+    StringMatching = 10,\n+    Unknown = 8\n+};\n+\n class IKernelLogic {\n private:\n     virtual TConclusion<bool> DoExecute(const std::vector<TColumnChainInfo>& input, const std::vector<TColumnChainInfo>& output,\n         const std::shared_ptr<TAccessorsCollection>& resources) const = 0;\n \n+    virtual std::optional<TIndexCheckOperation> DoGetIndexCheckerOperation() const = 0;\n+    YDB_ACCESSOR_DEF(std::optional<ui32>, YqlOperationId);\n+    virtual NJson::TJsonValue DoDebugJson() const {\n+        return NJson::JSON_NULL;\n+    }\n public:\n+    NJson::TJsonValue DebugJson() const {\n+        NJson::TJsonValue result = NJson::JSON_MAP;\n+        result.InsertValue(\"class_name\", GetClassName());\n+        auto details = DoDebugJson();\n+        if (details.IsDefined()) {\n+            result.InsertValue(\"details\", std::move(details));\n+        }\n+        return result;\n+    }\n+\n+    IKernelLogic() = default;\n+\n+    IKernelLogic(const ui32 yqlOperationId)\n+        : YqlOperationId(yqlOperationId) {\n+    }\n+\n     virtual ~IKernelLogic() = default;\n \n+    virtual TString SignalDescription() const {\n+        return GetClassName();\n+    }\n+    virtual ECalculationHardness GetWeight() const = 0;\n+\n     using TFactory = NObjectFactory::TObjectFactory<IKernelLogic, TString>;\n \n     virtual TString GetClassName() const = 0;\n \n-    virtual std::optional<TFetchingInfo> BuildFetchTask(const ui32 columnId, const NAccessor::IChunkedArray::EType arrType,\n-        const std::vector<TColumnChainInfo>& input, const std::shared_ptr<TAccessorsCollection>& resources) const = 0;\n-\n     TConclusion<bool> Execute(const std::vector<TColumnChainInfo>& input, const std::vector<TColumnChainInfo>& output,\n         const std::shared_ptr<TAccessorsCollection>& resources) const {\n         if (!resources) {\n@@ -32,6 +63,119 @@ class IKernelLogic {\n     }\n \n     virtual bool IsBoolInResult() const = 0;\n+    std::optional<TIndexCheckOperation> GetIndexCheckerOperation() const {\n+        return DoGetIndexCheckerOperation();\n+    }\n+};\n+\n+class TSimpleKernelLogic: public IKernelLogic {\n+private:\n+    using TBase = IKernelLogic;\n+    YDB_READONLY_DEF(std::optional<ui32>, YqlOperationId);\n+\n+    virtual TConclusion<bool> DoExecute(const std::vector<TColumnChainInfo>& /*input*/, const std::vector<TColumnChainInfo>& /*output*/,\n+        const std::shared_ptr<TAccessorsCollection>& /*resources*/) const override {\n+        return false;\n+    }\n+\n+    virtual NJson::TJsonValue DoDebugJson() const override;\n+    virtual std::optional<TIndexCheckOperation> DoGetIndexCheckerOperation() const override {\n+        return std::nullopt;\n+    }\n+\n+public:\n+    TSimpleKernelLogic() = default;\n+    TSimpleKernelLogic(const ui32 yqlOperationId)\n+        : TBase(yqlOperationId)\n+        , YqlOperationId(yqlOperationId) {\n+    }\n+\n+    virtual TString SignalDescription() const override;\n+\n+    virtual ECalculationHardness GetWeight() const override {\n+        if (!YqlOperationId) {\n+            return ECalculationHardness::Unknown;\n+        }\n+        return ECalculationHardness::NotSpecified;\n+    }\n+\n+    virtual TString GetClassName() const override {\n+        return \"SIMPLE\";\n+    }\n+\n+    virtual bool IsBoolInResult() const override;\n+};\n+\n+class TLogicMatchString: public IKernelLogic {\n+private:\n+    using TBase = IKernelLogic;\n+    virtual TConclusion<bool> DoExecute(const std::vector<TColumnChainInfo>& /*input*/, const std::vector<TColumnChainInfo>& /*output*/,\n+        const std::shared_ptr<TAccessorsCollection>& /*resources*/) const override {\n+        return false;\n+    }\n+    virtual std::optional<TIndexCheckOperation> DoGetIndexCheckerOperation() const override {\n+        return TIndexCheckOperation(Operation, CaseSensitive);\n+    }\n+    virtual ECalculationHardness GetWeight() const override {\n+        return ECalculationHardness::StringMatching;\n+    }\n+\n+    const TIndexCheckOperation::EOperation Operation;\n+    const bool CaseSensitive;\n+    const bool IsSimpleFunction;\n+\n+    virtual NJson::TJsonValue DoDebugJson() const override {\n+        return ::ToString(Operation) + \"::\" + ::ToString(CaseSensitive) + \"::\" + ::ToString(IsSimpleFunction);\n+    }\n+\n+public:\n+    TLogicMatchString(const TIndexCheckOperation::EOperation operation, const bool caseSensitive, const bool isSimpleFunction)\n+        : Operation(operation)\n+        , CaseSensitive(caseSensitive)\n+        , IsSimpleFunction(isSimpleFunction) {\n+    }\n+\n+    virtual TString SignalDescription() const override {\n+        return \"MATCH_STRING::\" + ::ToString(Operation) + \"::\" + ::ToString(CaseSensitive);\n+    }\n+\n+    virtual TString GetClassName() const override {\n+        return \"MATCH_STRING\";\n+    }\n+\n+    virtual bool IsBoolInResult() const override {\n+        return !IsSimpleFunction;\n+    }\n+};\n+\n+class TLogicEquals: public IKernelLogic {\n+private:\n+    using TBase = IKernelLogic;\n+    virtual TConclusion<bool> DoExecute(const std::vector<TColumnChainInfo>& /*input*/, const std::vector<TColumnChainInfo>& /*output*/,\n+        const std::shared_ptr<TAccessorsCollection>& /*resources*/) const override {\n+        return false;\n+    }\n+    virtual std::optional<TIndexCheckOperation> DoGetIndexCheckerOperation() const override {\n+        return TIndexCheckOperation(TIndexCheckOperation::EOperation::Equals, true);\n+    }\n+    const bool IsSimpleFunction;\n+\n+    virtual ECalculationHardness GetWeight() const override {\n+        return ECalculationHardness::Equals;\n+    }\n+\n+public:\n+    TLogicEquals(const bool isSimpleFunction)\n+        : IsSimpleFunction(isSimpleFunction) {\n+    }\n+\n+    virtual TString GetClassName() const override {\n+        return \"EQUALS\";\n+    }\n+\n+    virtual bool IsBoolInResult() const override {\n+        return !IsSimpleFunction;\n+    }\n };\n \n class TGetJsonPath: public IKernelLogic {\n@@ -39,6 +183,13 @@ class TGetJsonPath: public IKernelLogic {\n     static TString GetClassNameStatic() {\n         return \"JsonValue\";\n     }\n+    virtual std::optional<TIndexCheckOperation> DoGetIndexCheckerOperation() const override {\n+        return std::nullopt;\n+    }\n+\n+    virtual ECalculationHardness GetWeight() const override {\n+        return ECalculationHardness::JustAccessorUsage;\n+    }\n \n private:\n     virtual bool IsBoolInResult() const override {\n@@ -81,9 +232,6 @@ class TGetJsonPath: public IKernelLogic {\n             return TConclusionStatus::Fail(\"incorrect path format: have to be as '$.**...**'\");\n         }\n         svPath = svPath.substr(2);\n-        if (svPath.starts_with(\"\\\"\") && svPath.ends_with(\"\\\"\") && svPath.size() > 2) {\n-            svPath = svPath.substr(1, svPath.size() - 2);\n-        }\n \n         return TDescription(resources->GetAccessorOptional(input.front().GetColumnId()), svPath);\n     }\n@@ -94,9 +242,6 @@ class TGetJsonPath: public IKernelLogic {\n \n     static const inline TFactory::TRegistrator<TGetJsonPath> Registrator = TFactory::TRegistrator<TGetJsonPath>(GetClassNameStatic());\n \n-    virtual std::optional<TFetchingInfo> BuildFetchTask(const ui32 columnId, const NAccessor::IChunkedArray::EType arrType,\n-        const std::vector<TColumnChainInfo>& input, const std::shared_ptr<TAccessorsCollection>& resources) const override;\n-\n     virtual TConclusion<bool> DoExecute(const std::vector<TColumnChainInfo>& input, const std::vector<TColumnChainInfo>& output,\n         const std::shared_ptr<TAccessorsCollection>& resources) const override;\n \ndiff --git a/ydb/core/formats/arrow/program/original.h b/ydb/core/formats/arrow/program/original.h\nindex 3d3ab3d1fc1a..0ba877b54f73 100644\n--- a/ydb/core/formats/arrow/program/original.h\n+++ b/ydb/core/formats/arrow/program/original.h\n@@ -2,6 +2,7 @@\n #include \"abstract.h\"\n #include \"functions.h\"\n #include \"kernel_logic.h\"\n+#include \"execution.h\"\n \n namespace NKikimr::NArrow::NSSA {\n \ndiff --git a/ydb/core/formats/arrow/program/projection.cpp b/ydb/core/formats/arrow/program/projection.cpp\nindex 216cd3103c89..472161f73a9d 100644\n--- a/ydb/core/formats/arrow/program/projection.cpp\n+++ b/ydb/core/formats/arrow/program/projection.cpp\n@@ -8,7 +8,7 @@ TConclusion<IResourceProcessor::EExecutionResult> TProjectionProcessor::DoExecut\n     const TProcessorContext& context, const TExecutionNodeContext& /*nodeContext*/) const {\n     context.GetResources()->RemainOnly(TColumnChainInfo::ExtractColumnIds(GetInput()), true);\n     if (context.GetLimit()) {\n-        context.GetResources()->CutFilter(context.GetResources()->GetRecordsCountActualVerified(), *context.GetLimit(), context.GetReverse());\n+        context.GetResources()->CutFilter(context.GetResources()->GetRecordsCountRobustVerified(), *context.GetLimit(), context.GetReverse());\n     }\n     return EExecutionResult::Success;\n }\ndiff --git a/ydb/core/formats/arrow/program/reserve.cpp b/ydb/core/formats/arrow/program/reserve.cpp\nnew file mode 100644\nindex 000000000000..f10c87602003\n--- /dev/null\n+++ b/ydb/core/formats/arrow/program/reserve.cpp\n@@ -0,0 +1,6 @@\n+#include \"execution.h\"\n+#include \"original.h\"\n+\n+namespace NKikimr::NArrow::NSSA {\n+\n+}   // namespace NKikimr::NArrow::NSSA\ndiff --git a/ydb/core/formats/arrow/program/reserve.h b/ydb/core/formats/arrow/program/reserve.h\nnew file mode 100644\nindex 000000000000..0ecadb8b3003\n--- /dev/null\n+++ b/ydb/core/formats/arrow/program/reserve.h\n@@ -0,0 +1,74 @@\n+#pragma once\n+#include \"abstract.h\"\n+#include \"original.h\"\n+\n+namespace NKikimr::NArrow::NSSA {\n+\n+class TReserveMemoryProcessor: public IResourceProcessor {\n+private:\n+    using TBase = IResourceProcessor;\n+\n+    THashMap<ui32, IDataSource::TDataAddress> DataAddresses;\n+    THashMap<ui32, IDataSource::TFetchIndexContext> IndexContext;\n+    THashMap<ui32, IDataSource::TFetchHeaderContext> HeaderContext;\n+    std::shared_ptr<IMemoryCalculationPolicy> Policy;\n+\n+    virtual NJson::TJsonValue DoDebugJson() const override {\n+        NJson::TJsonValue result = NJson::JSON_MAP;\n+        if (DataAddresses.size()) {\n+            auto& arrAddr = result.InsertValue(\"data\", NJson::JSON_ARRAY);\n+            for (auto&& i : DataAddresses) {\n+                arrAddr.AppendValue(i.second.DebugJson());\n+            }\n+        }\n+        if (IndexContext.size()) {\n+            auto& indexesArr = result.InsertValue(\"indexes\", NJson::JSON_ARRAY);\n+            for (auto&& i : IndexContext) {\n+                indexesArr.AppendValue(i.second.DebugJson());\n+            }\n+        }\n+        if (HeaderContext.size()) {\n+            auto& headersArr = result.InsertValue(\"headers\", NJson::JSON_ARRAY);\n+            for (auto&& i : HeaderContext) {\n+                headersArr.AppendValue(i.second.DebugJson());\n+            }\n+        }\n+        return result;\n+    }\n+\n+    virtual TConclusion<EExecutionResult> DoExecute(const TProcessorContext& context, const TExecutionNodeContext& /*nodeContext*/) const override {\n+        auto source = context.GetDataSource().lock();\n+        if (!source) {\n+            return TConclusionStatus::Fail(\"source was destroyed before (original fetch start)\");\n+        }\n+        auto conclusion = source->StartReserveMemory(context, DataAddresses, IndexContext, HeaderContext, Policy);\n+        if (conclusion.IsFail()) {\n+            return conclusion;\n+        } else if (conclusion.GetResult()) {\n+            return EExecutionResult::InBackground;\n+        } else {\n+            return EExecutionResult::Success;\n+        }\n+    }\n+\n+    virtual bool IsAggregation() const override {\n+        return false;\n+    }\n+\n+    virtual ui64 DoGetWeight() const override {\n+        return 0;\n+    }\n+\n+public:\n+    TReserveMemoryProcessor(const TOriginalColumnDataProcessor& original, const std::shared_ptr<IMemoryCalculationPolicy>& policy)\n+        : TBase({}, {}, EProcessorType::ReserveMemory)\n+        , DataAddresses(original.GetDataAddresses())\n+        , IndexContext(original.GetIndexContext())\n+        , HeaderContext(original.GetHeaderContext())\n+        , Policy(policy)\n+    {\n+        AFL_VERIFY(policy);\n+    }\n+};\n+\n+}   // namespace NKikimr::NArrow::NSSA\ndiff --git a/ydb/core/formats/arrow/program/stream_logic.cpp b/ydb/core/formats/arrow/program/stream_logic.cpp\nindex 58079b6d98a4..6c467d6f984a 100644\n--- a/ydb/core/formats/arrow/program/stream_logic.cpp\n+++ b/ydb/core/formats/arrow/program/stream_logic.cpp\n@@ -29,72 +29,59 @@ TConclusion<bool> TStreamLogicProcessor::OnInputReady(\n     const ui32 inputId, const TProcessorContext& context, const TExecutionNodeContext& /*nodeContext*/) const {\n     auto accInput = context.GetResources()->GetAccessorVerified(inputId);\n \n-    std::shared_ptr<arrow::Scalar> monoValue;\n     AFL_VERIFY(!context.GetResources()->HasMarker(FinishMarker));\n     const auto accResult = context.GetResources()->GetAccessorOptional(GetOutputColumnIdOnce());\n \n-    const auto isMonoValue = accInput->CheckOneValueAccessor(monoValue);\n-    if (isMonoValue && *isMonoValue) {\n-        const auto isFalseConclusion = ScalarIsFalse(monoValue);\n-        if (isFalseConclusion.IsFail()) {\n-            return isFalseConclusion;\n-        }\n-        const auto isTrueConclusion = ScalarIsTrue(monoValue);\n-        if (isTrueConclusion.IsFail()) {\n-            return isTrueConclusion;\n-        }\n-        AFL_VERIFY(*isFalseConclusion || *isTrueConclusion);\n+    TConclusion<std::optional<bool>> isMonoInput = GetMonoInput(accInput);\n+    if (isMonoInput.IsFail()) {\n+        return isMonoInput;\n+    }\n+\n+    if (isMonoInput.GetResult()) {\n+        const bool monoValue = *isMonoInput.GetResult();\n         if (Operation == NKernels::EOperation::And) {\n-            if (*isTrueConclusion) {\n+            if (monoValue) {\n                 if (!accResult) {\n                     context.GetResources()->AddVerified(GetOutputColumnIdOnce(),\n-                        std::make_shared<NAccessor::TSparsedArray>(\n-                            std::make_shared<arrow::UInt8Scalar>(1), arrow::uint8(), context.GetResources()->GetRecordsCountActualVerified()),\n-                        false);\n+                        NAccessor::TSparsedArray::BuildTrueArrayUI8(context.GetResources()->GetRecordsCountRobustVerified()), false);\n                 }\n                 return false;\n             } else {\n-                if (accResult) {\n-                    context.GetResources()->Remove(GetOutputColumnIdOnce(), true);\n-                }\n-                context.GetResources()->AddVerified(GetOutputColumnIdOnce(),\n-                    std::make_shared<NAccessor::TSparsedArray>(\n-                        std::make_shared<arrow::UInt8Scalar>(0), arrow::uint8(), context.GetResources()->GetRecordsCountActualVerified()),\n-                    false);\n+                context.GetResources()->Upsert(GetOutputColumnIdOnce(),\n+                    NAccessor::TSparsedArray::BuildFalseArrayUI8(context.GetResources()->GetRecordsCountRobustVerified()), false);\n                 return true;\n             }\n         } else if (Operation == NKernels::EOperation::Or) {\n-            if (*isFalseConclusion) {\n+            if (!monoValue) {\n                 if (!accResult) {\n                     context.GetResources()->AddVerified(GetOutputColumnIdOnce(),\n-                        std::make_shared<NAccessor::TSparsedArray>(\n-                            std::make_shared<arrow::UInt8Scalar>(0), arrow::uint8(), context.GetResources()->GetRecordsCountActualVerified()),\n-                        false);\n+                        NAccessor::TSparsedArray::BuildFalseArrayUI8(context.GetResources()->GetRecordsCountRobustVerified()), false);\n                 }\n                 return false;\n             } else {\n-                if (accResult) {\n-                    context.GetResources()->Remove(GetOutputColumnIdOnce(), true);\n-                }\n-                context.GetResources()->AddVerified(GetOutputColumnIdOnce(),\n-                    std::make_shared<NAccessor::TSparsedArray>(\n-                        std::make_shared<arrow::UInt8Scalar>(1), arrow::uint8(), context.GetResources()->GetRecordsCountActualVerified()),\n-                    false);\n+                context.GetResources()->Upsert(GetOutputColumnIdOnce(),\n+                    NAccessor::TSparsedArray::BuildTrueArrayUI8(context.GetResources()->GetRecordsCountRobustVerified()), false);\n                 return true;\n             }\n         }\n     }\n \n     if (!accResult) {\n+        AFL_VERIFY(accInput->GetDataType()->id() == arrow::uint8()->id())(\"type\", accInput->GetDataType()->ToString());\n         context.GetResources()->AddVerified(GetOutputColumnIdOnce(), accInput, false);\n     } else {\n         auto result = Function->Call(TColumnChainInfo::BuildVector({ GetOutputColumnIdOnce(), inputId }), context.GetResources());\n         if (result.IsFail()) {\n             return result;\n         }\n+        auto datum = result.DetachResult();\n         context.GetResources()->Remove(GetOutputColumnIdOnce());\n-        context.GetResources()->AddVerified(GetOutputColumnIdOnce(), std::move(*result), false);\n+        context.GetResources()->AddVerified(GetOutputColumnIdOnce(), datum, false);\n+        if (IsFinishDatum(datum)) {\n+            return true;\n+        }\n     }\n+\n     return false;\n }\n \n@@ -162,4 +149,57 @@ NJson::TJsonValue TStreamLogicProcessor::DoDebugJson() const {\n     return result;\n }\n \n+bool TStreamLogicProcessor::IsFinishDatum(const arrow::Datum& datum) const {\n+    const auto arrChecker = [&](const arrow::Array& arr) {\n+        AFL_VERIFY(arr.type()->id() == arrow::uint8()->id());\n+        const arrow::UInt8Array& ui8Arr = static_cast<const arrow::UInt8Array&>(arr);\n+        const ui8* values = ui8Arr.raw_values();\n+        if (Operation == NKernels::EOperation::And) {\n+            for (ui32 i = 0; i < ui8Arr.length(); ++i) {\n+                if (values[i] != 0) {\n+                    return false;\n+                }\n+            }\n+        } else if (Operation == NKernels::EOperation::Or) {\n+            for (ui32 i = 0; i < ui8Arr.length(); ++i) {\n+                if (values[i] == 0) {\n+                    return false;\n+                }\n+            }\n+        } else {\n+            AFL_VERIFY(false)(\"op\", Operation);\n+        }\n+        return true;\n+    };\n+    if (datum.is_array()) {\n+        auto arr = datum.make_array();\n+        return arrChecker(*arr);\n+    } else if (datum.is_arraylike()) {\n+        auto arr = datum.chunked_array();\n+        AFL_VERIFY(arr->type()->id() == arrow::uint8()->id());\n+        for (auto&& chunk : arr->chunks()) {\n+            if (!arrChecker(*chunk)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    } else {\n+        AFL_VERIFY(false)(\"kind\", (ui32)datum.kind());\n+        return false;\n+    }\n+}\n+\n+TConclusion<std::optional<bool>> TStreamLogicProcessor::GetMonoInput(const std::shared_ptr<IChunkedArray>& inputArray) const {\n+    std::shared_ptr<arrow::Scalar> monoValue;\n+    const auto isMonoValue = inputArray->CheckOneValueAccessor(monoValue);\n+    if (!isMonoValue || !*isMonoValue) {\n+        return std::optional<bool>();\n+    }\n+    const auto isFalseConclusion = ScalarIsFalse(monoValue);\n+    if (isFalseConclusion.IsFail()) {\n+        return isFalseConclusion;\n+    }\n+    return !*isFalseConclusion;\n+}\n+\n }   // namespace NKikimr::NArrow::NSSA\ndiff --git a/ydb/core/formats/arrow/program/stream_logic.h b/ydb/core/formats/arrow/program/stream_logic.h\nindex f78619b8cff2..3855cedf546a 100644\n--- a/ydb/core/formats/arrow/program/stream_logic.h\n+++ b/ydb/core/formats/arrow/program/stream_logic.h\n@@ -21,15 +21,16 @@ class TStreamLogicProcessor: public IResourceProcessor {\n         return false;\n     }\n \n+    TConclusion<std::optional<bool>> GetMonoInput(const std::shared_ptr<IChunkedArray>& inputArray) const;\n+\n+    bool IsFinishDatum(const arrow::Datum& datum) const;\n     virtual ui64 DoGetWeight() const override;\n \n public:\n     NKernels::EOperation GetOperation() const {\n         return Operation;\n     }\n-\n     TConclusion<bool> OnInputReady(const ui32 inputId, const TProcessorContext& context, const TExecutionNodeContext& nodeContext) const;\n-\n     TStreamLogicProcessor(std::vector<TColumnChainInfo>&& input, const TColumnChainInfo& output, const NKernels::EOperation op);\n };\n \ndiff --git a/ydb/core/formats/arrow/program/ya.make b/ydb/core/formats/arrow/program/ya.make\nindex 114660d3251e..720b0f0b3180 100644\n--- a/ydb/core/formats/arrow/program/ya.make\n+++ b/ydb/core/formats/arrow/program/ya.make\n@@ -48,6 +48,7 @@ SRCS(\n     assign_internal.cpp\n     custom_registry.cpp\n     GLOBAL kernel_logic.cpp\n+    reserve.cpp\n )\n \n GENERATE_ENUM_SERIALIZATION(abstract.h)\ndiff --git a/ydb/core/formats/arrow/reader/merger.cpp b/ydb/core/formats/arrow/reader/merger.cpp\nindex b6c56ba23183..bdf212696b8c 100644\n--- a/ydb/core/formats/arrow/reader/merger.cpp\n+++ b/ydb/core/formats/arrow/reader/merger.cpp\n@@ -105,7 +105,7 @@ std::shared_ptr<arrow::Table> TMergePartialStream::SingleSourceDrain(const TSort\n             *lastResultPosition = TCursor(keys, 0, SortSchema->field_names());\n         }\n         if (SortHeap.Current().GetFilter()) {\n-            AFL_VERIFY(SortHeap.Current().GetFilter()->Apply(result, TColumnFilter::TApplyContext(pos.GetPosition() + (include ? 0 : 1), resultSize)));\n+            SortHeap.Current().GetFilter()->Apply(result, TColumnFilter::TApplyContext(pos.GetPosition() + (include ? 0 : 1), resultSize));\n         }\n     } else {\n         result = SortHeap.Current().GetKeyColumns().SliceData(startPos, resultSize);\n@@ -114,7 +114,7 @@ std::shared_ptr<arrow::Table> TMergePartialStream::SingleSourceDrain(const TSort\n             *lastResultPosition = TCursor(keys, keys->num_rows() - 1, SortSchema->field_names());\n         }\n         if (SortHeap.Current().GetFilter()) {\n-            AFL_VERIFY(SortHeap.Current().GetFilter()->Apply(result, TColumnFilter::TApplyContext(startPos, resultSize)));\n+            SortHeap.Current().GetFilter()->Apply(result, TColumnFilter::TApplyContext(startPos, resultSize));\n         }\n     }\n     if (!result || !result->num_rows()) {\n@@ -214,7 +214,7 @@ std::vector<std::shared_ptr<arrow::RecordBatch>> TMergePartialStream::DrainAllPa\n     return result;\n }\n \n-void TMergePartialStream::SkipToLowerBound(const TSortableBatchPosition& pos, const bool include) {\n+void TMergePartialStream::SkipToBound(const TSortableBatchPosition& pos, const bool lower) {\n     if (SortHeap.Empty()) {\n         return;\n     }\n@@ -224,13 +224,13 @@ void TMergePartialStream::SkipToLowerBound(const TSortableBatchPosition& pos, co\n         if (cmpResult == std::partial_ordering::greater) {\n             break;\n         }\n-        if (cmpResult == std::partial_ordering::equivalent && include) {\n+        if (cmpResult == std::partial_ordering::equivalent && lower) {\n             break;\n         }\n         const TSortableBatchPosition::TFoundPosition skipPos = SortHeap.MutableCurrent().SkipToLower(pos);\n         AFL_DEBUG(NKikimrServices::ARROW_HELPER)(\"pos\", pos.DebugJson().GetStringRobust())(\"heap\", SortHeap.Current().GetKeyColumns().DebugJson().GetStringRobust());\n         if (skipPos.IsEqual()) {\n-            if (!include && !SortHeap.MutableCurrent().Next()) {\n+            if (!lower && !SortHeap.MutableCurrent().Next()) {\n                 SortHeap.RemoveTop();\n             } else {\n                 SortHeap.UpdateTop();\ndiff --git a/ydb/core/formats/arrow/reader/merger.h b/ydb/core/formats/arrow/reader/merger.h\nindex c30aba0f384f..4950e49bee34 100644\n--- a/ydb/core/formats/arrow/reader/merger.h\n+++ b/ydb/core/formats/arrow/reader/merger.h\n@@ -53,7 +53,7 @@ class TMergePartialStream {\n     }\n \n     void PutControlPoint(const TSortableBatchPosition& point, const bool deepCopy);\n-    void SkipToLowerBound(const TSortableBatchPosition& pos, const bool include);\n+    void SkipToBound(const TSortableBatchPosition& pos, const bool lower);\n \n     void SetPossibleSameVersion(const bool value) {\n         PossibleSameVersionFlag = value;\ndiff --git a/ydb/core/formats/arrow/reader/position.cpp b/ydb/core/formats/arrow/reader/position.cpp\nindex e4f4d799a5a1..5476975998e0 100644\n--- a/ydb/core/formats/arrow/reader/position.cpp\n+++ b/ydb/core/formats/arrow/reader/position.cpp\n@@ -18,51 +18,51 @@ NJson::TJsonValue TSortableBatchPosition::DebugJson() const {\n     return result;\n }\n \n-std::optional<TSortableBatchPosition::TFoundPosition> TSortableBatchPosition::FindPosition(TRWSortableBatchPosition& position,\n-    const ui64 posStartExt, const ui64 posFinishExt, const TSortableBatchPosition& forFound, const bool greater) {\n+std::optional<TSortableBatchPosition::TFoundPosition> TSortableBatchPosition::FindBound(TRWSortableBatchPosition& position,\n+    const ui64 posStartExt, const ui64 posFinishExt, const TSortableBatchPosition& forFound, const bool upper) {\n     ui64 posStart = posStartExt;\n     ui64 posFinish = posFinishExt;\n     auto guard = position.CreateAsymmetricAccessGuard();\n+    const auto cond = upper ?\n+        [](const std::partial_ordering cmp) {\n+            return cmp == std::partial_ordering::greater;\n+        } :\n+        [](const std::partial_ordering cmp) {\n+            return cmp == std::partial_ordering::greater || cmp == std::partial_ordering::equivalent;\n+        };\n+\n     {\n         AFL_VERIFY(guard.InitSortingPosition(posStart));\n         auto cmp = position.Compare(forFound);\n-        if (cmp == std::partial_ordering::greater) {\n-            return TFoundPosition::Greater(posStart);\n-        } else if (cmp == std::partial_ordering::equivalent) {\n-            return TFoundPosition::Equal(posStart);\n+        if (cond(cmp)) {\n+            return TFoundPosition(posStart, cmp);\n         }\n     }\n     {\n         AFL_VERIFY(guard.InitSortingPosition(posFinish));\n         auto cmp = position.Compare(forFound);\n-        if (cmp == std::partial_ordering::less) {\n-            return TFoundPosition::Less(posFinish);\n-        } else if (cmp == std::partial_ordering::equivalent) {\n-            return TFoundPosition::Equal(posFinish);\n+        if (!cond(cmp)) {\n+            return std::nullopt;\n         }\n     }\n-    while (posFinish > posStart + 1) {\n+    while (posFinish != posStart + 1) {\n+        AFL_VERIFY(posFinish > posStart + 1)(\"finish\", posFinish)(\"start\", posStart);\n         AFL_VERIFY(guard.InitSortingPosition(0.5 * (posStart + posFinish)));\n         const auto comparision = position.Compare(forFound);\n-        if (comparision == std::partial_ordering::less) {\n-            posStart = position.Position;\n-        } else if (comparision == std::partial_ordering::greater) {\n+        if (cond(comparision)) {\n             posFinish = position.Position;\n         } else {\n-            return TFoundPosition::Equal(position.Position);\n+            posStart = position.Position;\n         }\n     }\n-    AFL_VERIFY(posFinish != posStart);\n-    if (greater) {\n-        AFL_VERIFY(guard.InitSortingPosition(posFinish));\n-        return TFoundPosition::Greater(posFinish);\n-    } else {\n-        AFL_VERIFY(guard.InitSortingPosition(posStart));\n-        return TFoundPosition::Less(posStart);\n-    }\n+    AFL_VERIFY(posFinish == posStart + 1)(\"finish\", posFinish)(\"start\", posStart);\n+    AFL_VERIFY(guard.InitSortingPosition(posFinish));\n+    const auto comparision = position.Compare(forFound);\n+    AFL_VERIFY(cond(comparision));\n+    return TFoundPosition(posFinish, comparision);\n }\n \n-std::optional<TSortableBatchPosition::TFoundPosition> TSortableBatchPosition::FindPosition(const std::shared_ptr<arrow::RecordBatch>& batch,\n+std::optional<TSortableBatchPosition::TFoundPosition> TSortableBatchPosition::FindBound(const std::shared_ptr<arrow::RecordBatch>& batch,\n     const TSortableBatchPosition& forFound, const bool greater, const std::optional<ui32> includedStartPosition) {\n     if (!batch || !batch->num_rows()) {\n         return {};\n@@ -77,12 +77,11 @@ std::optional<TSortableBatchPosition::TFoundPosition> TSortableBatchPosition::Fi\n     }\n \n     TRWSortableBatchPosition position = forFound.BuildRWPosition(batch, posStart);\n-    return FindPosition(position, posStart, posFinish, forFound, greater);\n+    return FindBound(position, posStart, posFinish, forFound, greater);\n }\n \n NKikimr::NArrow::NMerger::TRWSortableBatchPosition TSortableBatchPosition::BuildRWPosition(const bool needData, const bool deepCopy) const {\n-    return TRWSortableBatchPosition(Position, RecordsCount, ReverseSort,\n-        deepCopy ? Sorting->BuildCopy(Position) : Sorting,\n+    return TRWSortableBatchPosition(Position, RecordsCount, ReverseSort, deepCopy ? Sorting->BuildCopy(Position) : Sorting,\n         (needData && Data) ? (deepCopy ? Data->BuildCopy(Position) : Data) : nullptr);\n }\n \n@@ -96,9 +95,15 @@ NKikimr::NArrow::NMerger::TRWSortableBatchPosition TSortableBatchPosition::Build\n }\n \n TSortableBatchPosition::TFoundPosition TRWSortableBatchPosition::SkipToLower(const TSortableBatchPosition& forFound) {\n+    AFL_VERIFY(RecordsCount);\n     const ui32 posStart = Position;\n-    auto pos = FindPosition(*this, posStart, ReverseSort ? 0 : (RecordsCount - 1), forFound, true);\n-    AFL_VERIFY(pos)(\"cursor\", DebugJson())(\"found\", forFound.DebugJson());\n+    AFL_VERIFY(!ReverseSort)(\"reason\", \"unimplemented\");\n+    auto pos = FindBound(*this, posStart, RecordsCount - 1, forFound, false);\n+    if (!pos) {\n+        auto guard = CreateAsymmetricAccessGuard();\n+        AFL_VERIFY(guard.InitSortingPosition(RecordsCount - 1));\n+        return TFoundPosition(RecordsCount - 1, Compare(forFound));\n+    }\n     if (ReverseSort) {\n         AFL_VERIFY(Position <= posStart)(\"pos\", Position)(\"pos_skip\", pos->GetPosition())(\"reverse\", true);\n     } else {\n@@ -120,6 +125,12 @@ TSortableScanData::TSortableScanData(\n     BuildPosition(position);\n }\n \n+TSortableScanData::TSortableScanData(const ui64 position, const std::shared_ptr<TGeneralContainer>& batch) {\n+    Fields = batch->GetSchema()->GetFields();\n+    Columns = batch->GetColumns();\n+    BuildPosition(position);\n+}\n+\n TSortableScanData::TSortableScanData(\n     const ui64 position, const std::shared_ptr<arrow::RecordBatch>& batch, const std::vector<std::string>& columns) {\n     for (auto&& i : columns) {\n@@ -133,8 +144,7 @@ TSortableScanData::TSortableScanData(\n     BuildPosition(position);\n }\n \n-TSortableScanData::TSortableScanData(\n-    const ui64 position, const std::shared_ptr<arrow::RecordBatch>& batch) {\n+TSortableScanData::TSortableScanData(const ui64 position, const std::shared_ptr<arrow::RecordBatch>& batch) {\n     for (auto&& c : batch->columns()) {\n         Columns.emplace_back(std::make_shared<NAccessor::TTrivialArray>(c));\n     }\ndiff --git a/ydb/core/formats/arrow/reader/position.h b/ydb/core/formats/arrow/reader/position.h\nindex f403dd7fe3af..a902744fe6e8 100644\n--- a/ydb/core/formats/arrow/reader/position.h\n+++ b/ydb/core/formats/arrow/reader/position.h\n@@ -73,11 +73,47 @@ class TSortableScanData {\n         return StartPosition <= position && position < FinishPosition;\n     }\n \n+    std::partial_ordering CompareImpl(const ui64 position, const TSortableScanData& item, const ui64 itemPosition, const ui32 size) const {\n+        AFL_VERIFY(size <= PositionAddress.size() && size <= item.PositionAddress.size());\n+        AFL_VERIFY(size);\n+        if (Contains(position) && item.Contains(itemPosition)) {\n+            for (ui32 idx = 0; idx < size; ++idx) {\n+                std::partial_ordering cmp = PositionAddress[idx].Compare(position, item.PositionAddress[idx], itemPosition);\n+                if (cmp != std::partial_ordering::equivalent) {\n+                    return cmp;\n+                }\n+            }\n+        } else {\n+            for (ui32 idx = 0; idx < size; ++idx) {\n+                std::partial_ordering cmp = std::partial_ordering::equivalent;\n+                const bool containsSelf = PositionAddress[idx].GetAddress().Contains(position);\n+                const bool containsItem = item.PositionAddress[idx].GetAddress().Contains(itemPosition);\n+                if (containsSelf && containsItem) {\n+                    cmp = PositionAddress[idx].Compare(position, item.PositionAddress[idx], itemPosition);\n+                } else if (containsSelf) {\n+                    auto temporaryAddress = item.Columns[idx]->GetChunk(item.PositionAddress[idx].GetAddress(), itemPosition);\n+                    cmp = PositionAddress[idx].Compare(position, temporaryAddress, itemPosition);\n+                } else if (containsItem) {\n+                    auto temporaryAddress = Columns[idx]->GetChunk(PositionAddress[idx].GetAddress(), position);\n+                    cmp = temporaryAddress.Compare(position, item.PositionAddress[idx], itemPosition);\n+                } else {\n+                    AFL_VERIFY(false);\n+                }\n+                if (cmp != std::partial_ordering::equivalent) {\n+                    return cmp;\n+                }\n+            }\n+        }\n+\n+        return std::partial_ordering::equivalent;\n+    }\n+\n public:\n     TSortableScanData(const ui64 position, const std::shared_ptr<arrow::RecordBatch>& batch);\n     TSortableScanData(const ui64 position, const std::shared_ptr<arrow::RecordBatch>& batch, const std::vector<std::string>& columns);\n     TSortableScanData(const ui64 position, const std::shared_ptr<arrow::Table>& batch, const std::vector<std::string>& columns);\n     TSortableScanData(const ui64 position, const std::shared_ptr<TGeneralContainer>& batch, const std::vector<std::string>& columns);\n+    TSortableScanData(const ui64 position, const std::shared_ptr<TGeneralContainer>& batch);\n     TSortableScanData(const ui64 position, const ui64 recordsCount, const std::vector<std::shared_ptr<NAccessor::IChunkedArray>>& columns,\n         const std::vector<std::shared_ptr<arrow::Field>>& fields)\n         : RecordsCount(recordsCount)\n@@ -117,36 +153,11 @@ class TSortableScanData {\n \n     std::partial_ordering Compare(const ui64 position, const TSortableScanData& item, const ui64 itemPosition) const {\n         AFL_VERIFY(PositionAddress.size() == item.PositionAddress.size());\n-        if (Contains(position) && item.Contains(itemPosition)) {\n-            for (ui32 idx = 0; idx < PositionAddress.size(); ++idx) {\n-                std::partial_ordering cmp = PositionAddress[idx].Compare(position, item.PositionAddress[idx], itemPosition);\n-                if (cmp != std::partial_ordering::equivalent) {\n-                    return cmp;\n-                }\n-            }\n-        } else {\n-            for (ui32 idx = 0; idx < PositionAddress.size(); ++idx) {\n-                std::partial_ordering cmp = std::partial_ordering::equivalent;\n-                const bool containsSelf = PositionAddress[idx].GetAddress().Contains(position);\n-                const bool containsItem = item.PositionAddress[idx].GetAddress().Contains(itemPosition);\n-                if (containsSelf && containsItem) {\n-                    cmp = PositionAddress[idx].Compare(position, item.PositionAddress[idx], itemPosition);\n-                } else if (containsSelf) {\n-                    auto temporaryAddress = item.Columns[idx]->GetChunk(item.PositionAddress[idx].GetAddress(), itemPosition);\n-                    cmp = PositionAddress[idx].Compare(position, temporaryAddress, itemPosition);\n-                } else if (containsItem) {\n-                    auto temporaryAddress = Columns[idx]->GetChunk(PositionAddress[idx].GetAddress(), position);\n-                    cmp = temporaryAddress.Compare(position, item.PositionAddress[idx], itemPosition);\n-                } else {\n-                    AFL_VERIFY(false);\n-                }\n-                if (cmp != std::partial_ordering::equivalent) {\n-                    return cmp;\n-                }\n-            }\n-        }\n+        return CompareImpl(position, item, itemPosition, item.PositionAddress.size());\n+    }\n \n-        return std::partial_ordering::equivalent;\n+    std::partial_ordering ComparePartial(const ui64 position, const TSortableScanData& item, const ui64 itemPosition) const {\n+        return CompareImpl(position, item, itemPosition, std::min<ui32>(PositionAddress.size(), item.PositionAddress.size()));\n     }\n \n     void AppendPositionTo(const std::vector<std::unique_ptr<arrow::ArrayBuilder>>& builders, const ui64 position, ui64* recordSize) const;\n@@ -314,15 +325,24 @@ class TSortableBatchPosition {\n         static TFoundPosition Equal(const ui32 pos) {\n             return TFoundPosition(pos);\n         }\n+\n+        TFoundPosition(const ui32 pos, const std::partial_ordering cmp)\n+            : Position(pos) {\n+            if (cmp == std::partial_ordering::less) {\n+                GreaterIfNotEqual = false;\n+            } else if (cmp == std::partial_ordering::greater) {\n+                GreaterIfNotEqual = true;\n+            }\n+        }\n     };\n \n     [[nodiscard]] bool IsAvailablePosition(const i64 position) const {\n         return 0 <= position && position < RecordsCount;\n     }\n \n-    static std::optional<TFoundPosition> FindPosition(const std::shared_ptr<arrow::RecordBatch>& batch, const TSortableBatchPosition& forFound,\n+    static std::optional<TFoundPosition> FindBound(const std::shared_ptr<arrow::RecordBatch>& batch, const TSortableBatchPosition& forFound,\n         const bool needGreater, const std::optional<ui32> includedStartPosition);\n-    static std::optional<TSortableBatchPosition::TFoundPosition> FindPosition(TRWSortableBatchPosition& position, const ui64 posStart,\n+    static std::optional<TSortableBatchPosition::TFoundPosition> FindBound(TRWSortableBatchPosition& position, const ui64 posStart,\n         const ui64 posFinish, const TSortableBatchPosition& forFound, const bool greater);\n \n     const TSortableScanData& GetData() const {\n@@ -405,6 +425,12 @@ class TSortableBatchPosition {\n         return ApplyOptionalReverseForCompareResult(directResult);\n     }\n \n+    std::partial_ordering ComparePartial(const TSortableBatchPosition& item) const {\n+        Y_ABORT_UNLESS(item.ReverseSort == ReverseSort);\n+        const auto directResult = Sorting->ComparePartial(Position, *item.Sorting, item.GetPosition());\n+        return ApplyOptionalReverseForCompareResult(directResult);\n+    }\n+\n     std::partial_ordering Compare(const TSortableScanData& data, const ui64 dataPosition) const {\n         return Sorting->Compare(Position, data, dataPosition);\n     }\ndiff --git a/ydb/core/formats/arrow/ssa_runtime_version.h b/ydb/core/formats/arrow/ssa_runtime_version.h\nindex 500074420fda..5e46ec37cb4f 100644\n--- a/ydb/core/formats/arrow/ssa_runtime_version.h\n+++ b/ydb/core/formats/arrow/ssa_runtime_version.h\n@@ -27,6 +27,9 @@ namespace NKikimr::NSsa {\n // v2 is the version supported by kikimr-23-1. Supports LIKE filter for Utf8 type, COUNT(col), COUNT(*), SUM(), MIN(), MAX(), AVG(), SOME() aggregations.\n // v3 is the version supported by kikimr-23-3. Supports LIKE filter for String type, JSON_VALUE and JSON_EXISTS functions in filters\n // v4 is the version supported by kikimr-24-1. Supports any comparsions and arithmetics on YQL kernels.\n+// v5 supports generic ast pushdouwn via KqpOlapApply\n constexpr ui32 RuntimeVersion = SSA_RUNTIME_VERSION;\n \n+static_assert(RuntimeVersion >= 4);\n+\n }\ndiff --git a/ydb/core/formats/arrow/ut/ut_arrow.cpp b/ydb/core/formats/arrow/ut/ut_arrow.cpp\nindex 6f12504187e9..bc46b4f329f7 100644\n--- a/ydb/core/formats/arrow/ut/ut_arrow.cpp\n+++ b/ydb/core/formats/arrow/ut/ut_arrow.cpp\n@@ -480,21 +480,6 @@ std::vector<TDataRow> TestRows() {\n     return rows;\n }\n \n-bool CheckFilter(const std::vector<bool>& f, size_t count, bool value) {\n-    for (size_t i = 0; i < f.size(); ++i) {\n-        if (i < count) {\n-            if (f[i] != value) {\n-                return false;\n-            }\n-        } else {\n-            if (f[i] == value) {\n-                return false;\n-            }\n-        }\n-    }\n-    return true;\n-}\n-\n std::shared_ptr<arrow::Table> MakeTable1000() {\n     TDataRowTableBuilder builder;\n \n@@ -672,38 +657,6 @@ Y_UNIT_TEST_SUITE(ArrowTest) {\n         }\n     }\n \n-    Y_UNIT_TEST(KeyComparison) {\n-        auto table = MakeTable1000();\n-\n-        std::shared_ptr<arrow::RecordBatch> border; // {2, 3, 4}\n-        {\n-            arrow::ScalarVector scalars{\n-                std::make_shared<arrow::Int8Scalar>(2),\n-                std::make_shared<arrow::Int16Scalar>(3),\n-                std::make_shared<arrow::Int32Scalar>(4),\n-            };\n-\n-            std::vector<std::shared_ptr<arrow::Array>> columns;\n-            for (auto scalar : scalars) {\n-                auto res = arrow::MakeArrayFromScalar(*scalar, 1);\n-                UNIT_ASSERT(res.ok());\n-                columns.push_back(*res);\n-            }\n-\n-            border = arrow::RecordBatch::Make(table->schema(), 1, columns);\n-        }\n-\n-        const NArrow::TColumnFilter lt = NArrow::TColumnFilter::MakePredicateFilter(table, border, NArrow::ECompareType::LESS);\n-        const NArrow::TColumnFilter le = NArrow::TColumnFilter::MakePredicateFilter(table, border, NArrow::ECompareType::LESS_OR_EQUAL);\n-        const NArrow::TColumnFilter gt = NArrow::TColumnFilter::MakePredicateFilter(table, border, NArrow::ECompareType::GREATER);\n-        const NArrow::TColumnFilter ge = NArrow::TColumnFilter::MakePredicateFilter(table, border, NArrow::ECompareType::GREATER_OR_EQUAL);\n-\n-        UNIT_ASSERT(CheckFilter(lt.BuildSimpleFilter(), 234, true));\n-        UNIT_ASSERT(CheckFilter(le.BuildSimpleFilter(), 235, true));\n-        UNIT_ASSERT(CheckFilter(gt.BuildSimpleFilter(), 235, false));\n-        UNIT_ASSERT(CheckFilter(ge.BuildSimpleFilter(), 234, false));\n-    }\n-\n     Y_UNIT_TEST(SortWithCompositeKey) {\n         std::shared_ptr<arrow::Table> table = Shuffle(MakeTable1000());\n \ndiff --git a/ydb/core/formats/arrow/ut/ut_column_filter.cpp b/ydb/core/formats/arrow/ut/ut_column_filter.cpp\nindex f12fe1898b65..5994e8c45ce6 100644\n--- a/ydb/core/formats/arrow/ut/ut_column_filter.cpp\n+++ b/ydb/core/formats/arrow/ut/ut_column_filter.cpp\n@@ -82,15 +82,15 @@ Y_UNIT_TEST_SUITE(ColumnFilter) {\n         {\n             auto cut = filter.Cut(100, 10, false);\n             AFL_VERIFY(cut.DebugString() == \"{1}[10,90]\")(\"val\", cut.DebugString());\n-            auto cut1 = cut.Cut(10, 3, false);\n+            auto cut1 = cut.Cut(100, 3, false);\n             AFL_VERIFY(cut1.DebugString() == \"{1}[3,97]\")(\"val\", cut1.DebugString());\n-            auto cut2 = cut.Cut(10, 3, true);\n+            auto cut2 = cut.Cut(100, 3, true);\n             AFL_VERIFY(cut2.DebugString() == \"{0}[7,3,90]\")(\"val\", cut2.DebugString());\n         }\n         {\n             auto cut = filter.Cut(100, 10, true);\n             AFL_VERIFY(cut.DebugString() == \"{0}[90,10]\")(\"val\", cut.DebugString());\n-            auto cut1 = cut.Cut(10, 0, true);\n+            auto cut1 = cut.Cut(100, 0, true);\n             AFL_VERIFY(cut1.DebugString() == \"{0}[100]\")(\"val\", cut1.DebugString());\n         }\n     }\n@@ -108,27 +108,27 @@ Y_UNIT_TEST_SUITE(ColumnFilter) {\n         filter.Add(true, 3);\n         filter.Add(false, 2);\n         {\n-            auto cut = filter.Cut(filter.GetFilteredCountVerified(), 10, false);\n+            auto cut = filter.Cut(filter.GetRecordsCountVerified(), 10, false);\n             AFL_VERIFY(cut.DebugString() == \"{1}[4,3,2,1,4,18]\")(\"val\", cut.DebugString());\n             AFL_VERIFY(cut.GetRecordsCountVerified() == filter.GetRecordsCountVerified());\n         }\n         {\n-            auto cut = filter.Cut(filter.GetFilteredCountVerified(), 1, false);\n+            auto cut = filter.Cut(filter.GetRecordsCountVerified(), 1, false);\n             AFL_VERIFY(cut.DebugString() == \"{1}[1,31]\")(\"val\", cut.DebugString());\n             AFL_VERIFY(cut.GetRecordsCountVerified() == filter.GetRecordsCountVerified());\n         }\n         {\n-            auto cut = filter.Cut(filter.GetFilteredCountVerified(), 8, false);\n+            auto cut = filter.Cut(filter.GetRecordsCountVerified(), 8, false);\n             AFL_VERIFY(cut.DebugString() == \"{1}[4,3,2,1,2,20]\")(\"val\", cut.DebugString());\n             AFL_VERIFY(cut.GetRecordsCountVerified() == filter.GetRecordsCountVerified());\n         }\n         {\n-            auto cut = filter.Cut(filter.GetFilteredCountVerified(), 10, true);\n+            auto cut = filter.Cut(filter.GetRecordsCountVerified(), 10, true);\n             AFL_VERIFY(cut.DebugString() == \"{0}[13,1,6,6,1,3,2]\")(\"val\", cut.DebugString());\n             AFL_VERIFY(cut.GetRecordsCountVerified() == filter.GetRecordsCountVerified());\n         }\n         {\n-            auto cut = filter.Cut(filter.GetFilteredCountVerified(), 1000, true);\n+            auto cut = filter.Cut(filter.GetRecordsCountVerified(), 1000, true);\n             AFL_VERIFY(cut.DebugString() == \"{1}[4,3,2,1,4,6,6,1,3,2]\")(\"val\", cut.DebugString());\n             AFL_VERIFY(cut.GetRecordsCountVerified() == filter.GetRecordsCountVerified());\n         }\ndiff --git a/ydb/core/formats/arrow/ut/ut_program_step.cpp b/ydb/core/formats/arrow/ut/ut_program_step.cpp\nindex bea0dcc463af..8f3f403a2af2 100644\n--- a/ydb/core/formats/arrow/ut/ut_program_step.cpp\n+++ b/ydb/core/formats/arrow/ut/ut_program_step.cpp\n@@ -43,8 +43,8 @@ size_t FilterTest(const std::vector<std::shared_ptr<arrow::Array>>& args, const\n         std::make_shared<arrow::Field>(\"y\", args.at(1)->type()), std::make_shared<arrow::Field>(\"z\", args.at(2)->type()) });\n     TSchemaColumnResolver resolver(schema);\n     NOptimization::TGraph::TBuilder builder(resolver);\n-    builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1, 2}), TColumnChainInfo(4), std::make_shared<TSimpleFunction>(op1)).DetachResult());\n-    builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({4, 3}), TColumnChainInfo(5), std::make_shared<TSimpleFunction>(op2)).DetachResult());\n+    builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1, 2}), TColumnChainInfo(4), std::make_shared<TSimpleFunction>(op1), std::make_shared<TSimpleKernelLogic>()).DetachResult());\n+    builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({4, 3}), TColumnChainInfo(5), std::make_shared<TSimpleFunction>(op2), std::make_shared<TSimpleKernelLogic>()).DetachResult());\n     builder.Add(std::make_shared<TFilterProcessor>(TColumnChainInfo(5)));\n     builder.Add(std::make_shared<TProjectionProcessor>(TColumnChainInfo::BuildVector({ 4, 5 })));\n     auto chain = builder.Finish().DetachResult();\n@@ -74,8 +74,8 @@ size_t FilterTestUnary(std::vector<std::shared_ptr<arrow::Array>> args, const EO\n     }\n \n     NOptimization::TGraph::TBuilder builder(resolver);\n-    builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1}), TColumnChainInfo(4), std::make_shared<TSimpleFunction>(op1)).DetachResult());\n-    builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({2, 4}), TColumnChainInfo(5), std::make_shared<TSimpleFunction>(op2)).DetachResult());\n+    builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1}), TColumnChainInfo(4), std::make_shared<TSimpleFunction>(op1), std::make_shared<TSimpleKernelLogic>()).DetachResult());\n+    builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({2, 4}), TColumnChainInfo(5), std::make_shared<TSimpleFunction>(op2), std::make_shared<TSimpleKernelLogic>()).DetachResult());\n     builder.Add(std::make_shared<TFilterProcessor>(TColumnChainInfo(5)));\n     builder.Add(std::make_shared<TProjectionProcessor>(TColumnChainInfo::BuildVector({ 4, 5 })));\n     auto chain = builder.Finish().DetachResult();\n@@ -103,7 +103,7 @@ std::vector<bool> LikeTest(const std::vector<std::string>& data, EOperation op,\n \n     NOptimization::TGraph::TBuilder builder(resolver);\n     builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1}), TColumnChainInfo(2), \n-        std::make_shared<TSimpleFunction>(op, std::make_shared<arrow::compute::MatchSubstringOptions>(pattern, ignoreCase))).DetachResult());\n+        std::make_shared<TSimpleFunction>(op, std::make_shared<arrow::compute::MatchSubstringOptions>(pattern, ignoreCase)), std::make_shared<TSimpleKernelLogic>()).DetachResult());\n     builder.Add(std::make_shared<TProjectionProcessor>(TColumnChainInfo::BuildVector({ 2 })));\n     auto chain = builder.Finish().DetachResult();\n \n@@ -149,7 +149,13 @@ struct TSumData {\n     }\n \n     static void CheckResult(ETest test, const std::shared_ptr<TAccessorsCollection>& batch, ui32 numKeys, bool nullable) {\n-        AFL_VERIFY(batch->GetColumnsCount() == numKeys + 2);\n+        if (test == ETest::EMPTY) {\n+            UNIT_ASSERT(!batch->HasData());\n+            return;\n+        } else {\n+            AFL_VERIFY(batch->GetColumnsCount() == numKeys + 2);\n+        }\n+\n         auto aggXOriginal = batch->GetArrayVerified(3);\n         auto aggYOriginal = batch->GetArrayVerified(4);\n         auto colXOriginal = batch->GetArrayVerified(1);\n@@ -505,7 +511,7 @@ Y_UNIT_TEST_SUITE(ProgramStep) {\n         TSchemaColumnResolver resolver(schema);\n         NOptimization::TGraph::TBuilder builder(resolver);\n         builder.Add(std::make_shared<TConstProcessor>(std::make_shared<arrow::Int64Scalar>(56), 3));\n-        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1, 3}), TColumnChainInfo(4), std::make_shared<TSimpleFunction>(EOperation::Add)).DetachResult());\n+        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1, 3}), TColumnChainInfo(4), std::make_shared<TSimpleFunction>(EOperation::Add), std::make_shared<TSimpleKernelLogic>()).DetachResult());\n         builder.Add(std::make_shared<TFilterProcessor>(TColumnChainInfo(2)));\n         builder.Add(std::make_shared<TProjectionProcessor>(TColumnChainInfo::BuildVector({ 2, 4 })));\n         auto chain = builder.Finish().DetachResult();\n@@ -533,6 +539,7 @@ Y_UNIT_TEST_SUITE(ProgramStep) {\n         std::vector<std::string> data = { \"aa\", \"aaa\", \"aaaa\", \"bbbbb\" };\n         arrow::StringBuilder sb;\n         sb.AppendValues(data).ok();\n+        using namespace NKikimr::NArrow::NSSA;\n \n         auto schema = std::make_shared<arrow::Schema>(\n             std::vector{ std::make_shared<arrow::Field>(\"int\", arrow::int64()), std::make_shared<arrow::Field>(\"string\", arrow::utf8()) });\n@@ -551,33 +558,33 @@ Y_UNIT_TEST_SUITE(ProgramStep) {\n             builder.Add(proc);\n         }\n         {\n-            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({10001}), TColumnChainInfo(1001), std::make_shared<TSimpleFunction>(EOperation::MatchSubstring)).DetachResult();\n-            proc->SetYqlOperationId((ui32)NYql::TKernelRequestBuilder::EBinaryOp::StringContains);\n+            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({10001}), TColumnChainInfo(1001), std::make_shared<TSimpleFunction>(EOperation::MatchSubstring), \n+                std::make_shared<NKikimr::NArrow::NSSA::TLogicMatchString>(TIndexCheckOperation::EOperation::Contains, true, false)).DetachResult();\n             builder.Add(proc);\n         }\n         {\n-            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1001, 4}), TColumnChainInfo(1101), std::make_shared<TSimpleFunction>(EOperation::Add)).DetachResult();\n-            proc->SetYqlOperationId((ui32)NYql::TKernelRequestBuilder::EBinaryOp::Coalesce);\n+            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1001, 4}), TColumnChainInfo(1101), std::make_shared<TSimpleFunction>(EOperation::Add), \n+                std::make_shared<TSimpleKernelLogic>((ui32)NYql::TKernelRequestBuilder::EBinaryOp::Coalesce)).DetachResult();\n             builder.Add(proc);\n         }\n         {\n-            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({2}), TColumnChainInfo(1002), std::make_shared<TSimpleFunction>(EOperation::StartsWith)).DetachResult();\n-            proc->SetYqlOperationId((ui32)NYql::TKernelRequestBuilder::EBinaryOp::StartsWith);\n+            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({2}), TColumnChainInfo(1002), std::make_shared<TSimpleFunction>(EOperation::StartsWith), std::make_shared<NKikimr::NArrow::NSSA::TLogicMatchString>(\n+                NKikimr::NArrow::NSSA::TIndexCheckOperation::EOperation::StartsWith, true, false)).DetachResult();\n             builder.Add(proc);\n         }\n         {\n-            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1002, 4}), TColumnChainInfo(1102), std::make_shared<TSimpleFunction>(EOperation::Add)).DetachResult();\n-            proc->SetYqlOperationId((ui32)NYql::TKernelRequestBuilder::EBinaryOp::Coalesce);\n+            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1002, 4}), TColumnChainInfo(1102), std::make_shared<TSimpleFunction>(EOperation::Add),\n+                std::make_shared<TSimpleKernelLogic>((ui32)NYql::TKernelRequestBuilder::EBinaryOp::Coalesce)).DetachResult();\n             builder.Add(proc);\n         }\n         {\n-            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1, 3}), TColumnChainInfo(1003), std::make_shared<TSimpleFunction>(EOperation::Equal)).DetachResult();\n-            proc->SetYqlOperationId((ui32)NYql::TKernelRequestBuilder::EBinaryOp::Equals);\n+            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1, 3}), TColumnChainInfo(1003), std::make_shared<TSimpleFunction>(EOperation::Equal),\n+                std::make_shared<TLogicEquals>(false)).DetachResult();\n             builder.Add(proc);\n         }\n         {\n-            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1003, 4}), TColumnChainInfo(1103), std::make_shared<TSimpleFunction>(EOperation::Add)).DetachResult();\n-            proc->SetYqlOperationId((ui32)NYql::TKernelRequestBuilder::EBinaryOp::Coalesce);\n+            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1003, 4}), TColumnChainInfo(1103), std::make_shared<TSimpleFunction>(EOperation::Add),\n+                std::make_shared<TSimpleKernelLogic>((ui32)NYql::TKernelRequestBuilder::EBinaryOp::Coalesce)).DetachResult();\n             builder.Add(proc);\n         }\n \n@@ -587,7 +594,7 @@ Y_UNIT_TEST_SUITE(ProgramStep) {\n         builder.Add(std::make_shared<TProjectionProcessor>(TColumnChainInfo::BuildVector({ 1, 2 })));\n         auto chain = builder.Finish().DetachResult();\n         Cerr << chain->DebugDOT() << Endl;\n-        AFL_VERIFY(chain->DebugStats() == \"[TOTAL:Const:2;Calculation:4;Projection:1;Filter:1;FetchOriginalData:2;AssembleOriginalData:3;CheckIndexData:1;CheckHeaderData:1;StreamLogic:1;];SUB:[FetchOriginalData:1;AssembleOriginalData:1;CheckHeaderData:1;];\")(\"debug\", chain->DebugStats());\n+        AFL_VERIFY(chain->DebugStats() == \"[TOTAL:Const:2;Calculation:4;Projection:1;Filter:1;FetchOriginalData:2;AssembleOriginalData:3;CheckIndexData:1;StreamLogic:1;ReserveMemory:1;];SUB:[AssembleOriginalData:1;];\")(\"debug\", chain->DebugStats());\n     }\n \n     Y_UNIT_TEST(Projection) {\n@@ -626,8 +633,8 @@ Y_UNIT_TEST_SUITE(ProgramStep) {\n         TSchemaColumnResolver resolver(schema);\n         NOptimization::TGraph::TBuilder builder(resolver);\n         NAggregation::TWithKeysAggregationProcessor::TBuilder aggrBuilder;\n-        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1}), TColumnChainInfo(3), std::make_shared<NAggregation::TAggregateFunction>(EAggregate::Min)).DetachResult());\n-        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({2}), TColumnChainInfo(4), std::make_shared<NAggregation::TAggregateFunction>(EAggregate::Max)).DetachResult());\n+        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1}), TColumnChainInfo(3), std::make_shared<NAggregation::TAggregateFunction>(EAggregate::Min), std::make_shared<TSimpleKernelLogic>()).DetachResult());\n+        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({2}), TColumnChainInfo(4), std::make_shared<NAggregation::TAggregateFunction>(EAggregate::Max), std::make_shared<TSimpleKernelLogic>()).DetachResult());\n         builder.Add(std::make_shared<TProjectionProcessor>(TColumnChainInfo::BuildVector({ 3, 4 })));\n         auto chain = builder.Finish().DetachResult();\n         auto sds = std::make_shared<TSimpleDataSource>();\n@@ -655,8 +662,8 @@ Y_UNIT_TEST_SUITE(ProgramStep) {\n \n         TSchemaColumnResolver resolver(schema);\n         NOptimization::TGraph::TBuilder builder(resolver);\n-        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1}), TColumnChainInfo(3), std::make_shared<NAggregation::TAggregateFunction>(EAggregate::Sum)).DetachResult());\n-        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({2}), TColumnChainInfo(4), std::make_shared<NAggregation::TAggregateFunction>(EAggregate::Sum)).DetachResult());\n+        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1}), TColumnChainInfo(3), std::make_shared<NAggregation::TAggregateFunction>(EAggregate::Sum), std::make_shared<TSimpleKernelLogic>()).DetachResult());\n+        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({2}), TColumnChainInfo(4), std::make_shared<NAggregation::TAggregateFunction>(EAggregate::Sum), std::make_shared<TSimpleKernelLogic>()).DetachResult());\n         builder.Add(std::make_shared<TProjectionProcessor>(TColumnChainInfo::BuildVector({ 3, 4 })));\n         auto chain = builder.Finish().DetachResult();\n \ndiff --git a/ydb/core/formats/arrow/ut/ut_reader.cpp b/ydb/core/formats/arrow/ut/ut_reader.cpp\nnew file mode 100644\nindex 000000000000..68b1cd2090b8\n--- /dev/null\n+++ b/ydb/core/formats/arrow/ut/ut_reader.cpp\n@@ -0,0 +1,58 @@\n+#include <ydb/core/formats/arrow/reader/position.h>\n+\n+#include <library/cpp/testing/unittest/registar.h>\n+\n+namespace NKikimr::NArrow {\n+\n+Y_UNIT_TEST_SUITE(SortableBatchPosition) {\n+    Y_UNIT_TEST(FindPosition) {\n+        std::shared_ptr<arrow::RecordBatch> data;\n+        std::shared_ptr<arrow::Schema> schema =\n+            std::make_shared<arrow::Schema>(arrow::Schema({ std::make_shared<arrow::Field>(\"class\", std::make_shared<arrow::StringType>()),\n+                std::make_shared<arrow::Field>(\"name\", std::make_shared<arrow::StringType>()) }));\n+        {\n+            std::unique_ptr<arrow::RecordBatchBuilder> batchBuilder;\n+            UNIT_ASSERT(arrow::RecordBatchBuilder::Make(schema, arrow::default_memory_pool(), &batchBuilder).ok());\n+\n+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(0)->Append(\"a\").ok());\n+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(0)->Append(\"a\").ok());\n+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(0)->Append(\"a\").ok());\n+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(0)->Append(\"a\").ok());\n+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(0)->Append(\"c\").ok());\n+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(0)->Append(\"c\").ok());\n+\n+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(1)->Append(\"a\").ok());\n+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(1)->Append(\"a\").ok());\n+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(1)->Append(\"c\").ok());\n+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(1)->Append(\"c\").ok());\n+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(1)->Append(\"a\").ok());\n+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(1)->Append(\"c\").ok());\n+\n+            UNIT_ASSERT(batchBuilder->Flush(&data).ok());\n+        }\n+\n+        std::shared_ptr<arrow::RecordBatch> search;\n+        {\n+            std::unique_ptr<arrow::RecordBatchBuilder> batchBuilder;\n+            UNIT_ASSERT(arrow::RecordBatchBuilder::Make(schema, arrow::default_memory_pool(), &batchBuilder).ok());\n+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(0)->Append(\"a\").ok());\n+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(1)->Append(\"c\").ok());\n+            UNIT_ASSERT(batchBuilder->Flush(&search).ok());\n+        }\n+\n+        NMerger::TSortableBatchPosition searchPosition(search, 0, false);\n+        {\n+            auto findPosition = NMerger::TSortableBatchPosition::FindBound(data, searchPosition, false, std::nullopt);\n+            UNIT_ASSERT(!!findPosition);\n+            UNIT_ASSERT_VALUES_EQUAL(findPosition->GetPosition(), 2);\n+        }\n+\n+        {\n+            auto findPosition = NMerger::TSortableBatchPosition::FindBound(data, searchPosition, true, std::nullopt);\n+            UNIT_ASSERT(!!findPosition);\n+            UNIT_ASSERT_VALUES_EQUAL(findPosition->GetPosition(), 4);\n+        }\n+    }\n+}\n+\n+}   // namespace NKikimr::NArrow\ndiff --git a/ydb/core/formats/arrow/ut/ya.make b/ydb/core/formats/arrow/ut/ya.make\nindex 6d82dd0a6d11..f3f2f255017b 100644\n--- a/ydb/core/formats/arrow/ut/ya.make\n+++ b/ydb/core/formats/arrow/ut/ya.make\n@@ -33,6 +33,7 @@ SRCS(\n     ut_dictionary.cpp\n     ut_column_filter.cpp\n     ut_hash.cpp\n+    ut_reader.cpp\n )\n \n END()\ndiff --git a/ydb/core/grpc_services/rpc_load_rows.cpp b/ydb/core/grpc_services/rpc_load_rows.cpp\nindex ffe6527fed87..108594bb57be 100644\n--- a/ydb/core/grpc_services/rpc_load_rows.cpp\n+++ b/ydb/core/grpc_services/rpc_load_rows.cpp\n@@ -208,9 +208,7 @@ class TUploadRowsRPCPublic : public NTxProxy::TUploadRowsBase<NKikimrServices::T\n         return true;\n     }\n \n-    TVector<std::pair<TString, Ydb::Type>> GetRequestColumns(TString& errorMessage) const override {\n-        Y_UNUSED(errorMessage);\n-\n+    TConclusion<TVector<std::pair<TString, Ydb::Type>>> GetRequestColumns() const override {\n         const auto& type = GetProtoRequest(Request.get())->Getrows().Gettype();\n         const auto& rowType = type.Getlist_type();\n         const auto& rowFields = rowType.Getitem().Getstruct_type().Getmembers();\n@@ -398,19 +396,18 @@ class TUploadColumnsRPCPublic : public NTxProxy::TUploadRowsBase<NKikimrServices\n         return true;\n     }\n \n-    TVector<std::pair<TString, Ydb::Type>> GetRequestColumns(TString& errorMessage) const override {\n+    TConclusion<TVector<std::pair<TString, Ydb::Type>>> GetRequestColumns() const override {\n+        TVector<std::pair<TString, Ydb::Type>> out;\n         if (GetSourceType() == EUploadSource::CSV) {\n             // TODO: for CSV with header we have to extract columns from data (from first batch in file stream)\n-            return {};\n+            return out;\n         }\n \n         auto schema = NArrow::DeserializeSchema(GetSourceSchema());\n         if (!schema) {\n-            errorMessage = TString(\"Wrong schema in bulk upsert data\");\n-            return {};\n+            return TConclusionStatus::Fail(\"Wrong schema in bulk upsert data\");\n         }\n \n-        TVector<std::pair<TString, Ydb::Type>> out;\n         out.reserve(schema->num_fields());\n \n         for (auto& field : schema->fields()) {\n@@ -419,8 +416,7 @@ class TUploadColumnsRPCPublic : public NTxProxy::TUploadRowsBase<NKikimrServices\n \n             Ydb::Type ydbType;\n             if (!ConvertArrowToYdbPrimitive(*type, ydbType)) {\n-                errorMessage = TString(\"Cannot convert arrow type to ydb one: \" + type->ToString());\n-                return {};\n+                return TConclusionStatus::Fail(\"Cannot convert arrow type to ydb one: \" + type->ToString());\n             }\n             out.emplace_back(name, std::move(ydbType));\n         }\ndiff --git a/ydb/core/kqp/common/buffer/buffer.h b/ydb/core/kqp/common/buffer/buffer.h\nindex 226273440269..8025335215e9 100644\n--- a/ydb/core/kqp/common/buffer/buffer.h\n+++ b/ydb/core/kqp/common/buffer/buffer.h\n@@ -12,6 +12,7 @@ struct TKqpBufferWriterSettings {\n     NWilson::TTraceId TraceId;\n     TIntrusivePtr<TKqpCounters> Counters;\n     TIntrusivePtr<NTxProxy::TTxProxyMon> TxProxyMon;\n+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;\n };\n \n NActors::IActor* CreateKqpBufferWriterActor(TKqpBufferWriterSettings&& settings);\ndiff --git a/ydb/core/kqp/common/buffer/events.h b/ydb/core/kqp/common/buffer/events.h\nindex 3d21caea1c14..b05159518e0d 100644\n--- a/ydb/core/kqp/common/buffer/events.h\n+++ b/ydb/core/kqp/common/buffer/events.h\n@@ -11,9 +11,7 @@ namespace NKqp {\n \n struct TEvKqpBuffer {\n \n-struct TEvPrepare : public TEventLocal<TEvPrepare, TKqpBufferWriterEvents::EvPrepare> {\n-    TActorId ExecuterActorId;\n-};\n+// To BufferActor\n \n struct TEvCommit : public TEventLocal<TEvCommit, TKqpBufferWriterEvents::EvCommit> {\n     TActorId ExecuterActorId;\n@@ -28,6 +26,11 @@ struct TEvFlush : public TEventLocal<TEvFlush, TKqpBufferWriterEvents::EvFlush>\n     TActorId ExecuterActorId;\n };\n \n+struct TEvTerminate : public TEventLocal<TEvTerminate, TKqpBufferWriterEvents::EvTerminate> {\n+};\n+\n+// From BufferActor\n+\n struct TEvResult : public TEventLocal<TEvResult, TKqpBufferWriterEvents::EvResult> {\n     TEvResult() = default;\n     TEvResult(NYql::NDqProto::TDqTaskStats&& stats) : Stats(std::move(stats)) {}\n@@ -42,9 +45,6 @@ struct TEvError : public TEventLocal<TEvError, TKqpBufferWriterEvents::EvError>\n     TEvError(NYql::NDqProto::StatusIds::StatusCode statusCode, NYql::TIssues&& issues);\n };\n \n-struct TEvTerminate : public TEventLocal<TEvTerminate, TKqpBufferWriterEvents::EvTerminate> {\n-};\n-\n };\n \n }\ndiff --git a/ydb/core/kqp/common/kqp_data_integrity_trails.h b/ydb/core/kqp/common/kqp_data_integrity_trails.h\nindex 71198204a55b..28566a975d53 100644\n--- a/ydb/core/kqp/common/kqp_data_integrity_trails.h\n+++ b/ydb/core/kqp/common/kqp_data_integrity_trails.h\n@@ -6,6 +6,8 @@\n #include <library/cpp/string_utils/base64/base64.h>\n \n #include <ydb/core/data_integrity_trails/data_integrity_trails.h>\n+#include <ydb/core/tx/data_events/events.h>\n+#include <ydb/core/tx/datashard/datashard.h>\n \n namespace NKikimr {\n namespace NDataIntegrity {\n@@ -97,23 +99,110 @@ inline void LogIntegrityTrails(const TString& traceId, NKikimrKqp::EQueryAction\n }\n \n // DataExecuter\n-inline void LogIntegrityTrails(const TString& txType, const TString& traceId, ui64 txId, TMaybe<ui64> shardId, const TActorContext& ctx) {\n-    auto log = [](const auto& type, const auto& traceId, const auto& txId, const auto& shardId) {\n+inline void LogIntegrityTrails(const TString& txType, const TString& txLocksDebugStr, const TString& traceId, ui64 txId, TMaybe<ui64> shardId, const TActorContext& ctx) {\n+    auto log = [](const auto& type, const auto& txLocksDebugStr, const auto& traceId, const auto& txId, const auto& shardId) {\n         TStringStream ss;\n         LogKeyValue(\"Component\", \"Executer\", ss);\n+        LogKeyValue(\"Type\", \"Request\", ss);\n         LogKeyValue(\"TraceId\", traceId, ss);\n         LogKeyValue(\"PhyTxId\", ToString(txId), ss);\n+        LogKeyValue(\"Locks\", \"[\" + txLocksDebugStr + \"]\", ss);\n \n         if (shardId) {\n             LogKeyValue(\"ShardId\", ToString(*shardId), ss);\n         }\n \n-        LogKeyValue(\"Type\", type, ss, /*last*/ true);\n+        LogKeyValue(\"TxType\", type, ss, /*last*/ true);\n+\n+        return ss.Str();\n+    };\n+\n+    LOG_INFO_S(ctx, NKikimrServices::DATA_INTEGRITY, log(txType, txLocksDebugStr, traceId, txId, shardId));\n+}\n+\n+inline void LogIntegrityTrails(const TString& state, const TString& traceId, const NEvents::TDataEvents::TEvWriteResult::TPtr& ev, const TActorContext& ctx) {\n+    auto log = [](const auto& state, const auto& traceId, const auto& ev) {\n+        const auto& record = ev->Get()->Record;\n+\n+        TStringStream ss;\n+        LogKeyValue(\"Component\", \"Executer\", ss);\n+        LogKeyValue(\"Type\", \"Response\", ss);\n+        LogKeyValue(\"State\", state, ss);\n+        LogKeyValue(\"TraceId\", traceId, ss);\n+        LogKeyValue(\"PhyTxId\", ToString(record.GetTxId()), ss);\n+        LogKeyValue(\"ShardId\", ToString(record.GetOrigin()), ss);\n+\n+        TStringBuilder locksDebugStr;\n+        locksDebugStr << \"[\";\n+        for (const auto& lock : record.GetTxLocks()) {\n+            locksDebugStr << lock.ShortDebugString() << \" \";\n+        }\n+        locksDebugStr << \"]\";\n+\n+        LogKeyValue(\"Locks\", locksDebugStr, ss);\n+        LogKeyValue(\"Status\",  NKikimrDataEvents::TEvWriteResult::EStatus_Name(ev->Get()->GetStatus()), ss);\n+\n+        NYql::TIssues issues;\n+        NYql::IssuesFromMessage(record.GetIssues(), issues);\n+        LogKeyValue(\"Issues\", issues.ToString(), ss, /*last*/ true);\n+\n+        return ss.Str();\n+    };\n+\n+    LOG_INFO_S(ctx, NKikimrServices::DATA_INTEGRITY, log(state, traceId, ev));\n+}\n+\n+inline void LogIntegrityTrails(const TString& state, const TString& traceId, const TEvDataShard::TEvProposeTransactionResult::TPtr& ev, const TActorContext& ctx) {\n+    auto log = [](const auto& state, const auto& traceId, const auto& ev) {\n+        const auto& record = ev->Get()->Record;\n+\n+        TStringStream ss;\n+        LogKeyValue(\"Component\", \"Executer\", ss);\n+        LogKeyValue(\"Type\", \"Response\", ss);\n+        LogKeyValue(\"State\", state, ss);\n+        LogKeyValue(\"TraceId\", traceId, ss);\n+        LogKeyValue(\"PhyTxId\", ToString(record.GetTxId()), ss);\n+        LogKeyValue(\"ShardId\", ToString(record.GetOrigin()), ss);\n+\n+        TStringBuilder locksDebugStr;\n+        locksDebugStr << \"[\";\n+        for (const auto& lock : record.GetTxLocks()) {\n+            locksDebugStr << lock.ShortDebugString() << \" \";\n+        }\n+        locksDebugStr << \"]\";\n+\n+        LogKeyValue(\"Locks\", locksDebugStr, ss);\n+        LogKeyValue(\"Status\",  NKikimrTxDataShard::TEvProposeTransactionResult_EStatus_Name(ev->Get()->GetStatus()), ss);\n+        LogKeyValue(\"Issues\", ev->Get()->GetError(), ss, /*last*/ true);\n+\n+        return ss.Str();\n+    };\n+\n+    LOG_INFO_S(ctx, NKikimrServices::DATA_INTEGRITY, log(state, traceId, ev));\n+}\n+\n+template <typename TActorResultInfo>\n+inline void LogIntegrityTrails(const TString& type, const TString& traceId, ui64 txId, const TActorResultInfo& info, const TActorContext& ctx) {\n+    auto log = [](const auto& type, const auto& traceId, const auto& txId, const auto& info) {\n+        TStringStream ss;\n+        LogKeyValue(\"Component\", \"Executer\", ss);\n+        LogKeyValue(\"Type\", type, ss);\n+        LogKeyValue(\"TraceId\", traceId, ss);\n+        LogKeyValue(\"PhyTxId\", ToString(txId), ss);\n+\n+        TStringBuilder locksDebugStr;\n+        locksDebugStr << \"[\";\n+        for (const auto& lock : info.GetLocks()) {\n+            locksDebugStr << lock.ShortDebugString() << \" \";\n+        }\n+        locksDebugStr << \"]\";\n+\n+        LogKeyValue(\"Locks\", locksDebugStr, ss);\n \n         return ss.Str();\n     };\n \n-    LOG_INFO_S(ctx, NKikimrServices::DATA_INTEGRITY, log(txType, traceId, txId, shardId));\n+    LOG_INFO_S(ctx, NKikimrServices::DATA_INTEGRITY, log(type, traceId, txId, info));\n }\n \n // WriteActor,BufferActor\ndiff --git a/ydb/core/kqp/common/kqp_tx.cpp b/ydb/core/kqp/common/kqp_tx.cpp\nindex e9b02b093c37..f6022c112c52 100644\n--- a/ydb/core/kqp/common/kqp_tx.cpp\n+++ b/ydb/core/kqp/common/kqp_tx.cpp\n@@ -335,7 +335,7 @@ bool HasOltpTableWriteInTx(const NKqpProto::TKqpPhyQuery& physicalQuery) {\n     return false;\n }\n \n-bool HasUncommittedChangesRead(THashSet<NKikimr::TTableId>& modifiedTables, const NKqpProto::TKqpPhyQuery& physicalQuery) {\n+bool HasUncommittedChangesRead(THashSet<NKikimr::TTableId>& modifiedTables, const NKqpProto::TKqpPhyQuery& physicalQuery, const bool commit) {\n     auto getTable = [](const NKqpProto::TKqpPhyTableId& table) {\n         return NKikimr::TTableId(table.GetOwnerId(), table.GetTableId());\n     };\n@@ -402,6 +402,10 @@ bool HasUncommittedChangesRead(THashSet<NKikimr::TTableId>& modifiedTables, cons\n                     NKikimrKqp::TKqpTableSinkSettings settings;\n                     YQL_ENSURE(sink.GetInternalSink().GetSettings().UnpackTo(&settings), \"Failed to unpack settings\");\n                     modifiedTables.insert(getTable(settings.GetTable()));\n+                    if (settings.GetType() == NKikimrKqp::TKqpTableSinkSettings::MODE_INSERT && !commit) {\n+                        // INSERT with sink should be executed immediately, because it returns an error in case of duplicate rows.\n+                        return true;\n+                    }\n                 } else {\n                     return true;\n                 }\ndiff --git a/ydb/core/kqp/common/kqp_tx.h b/ydb/core/kqp/common/kqp_tx.h\nindex d7353de0540a..68a34c7186b0 100644\n--- a/ydb/core/kqp/common/kqp_tx.h\n+++ b/ydb/core/kqp/common/kqp_tx.h\n@@ -160,7 +160,7 @@ class TShardIdToTableInfo {\n };\n using TShardIdToTableInfoPtr = std::shared_ptr<TShardIdToTableInfo>;\n \n-bool HasUncommittedChangesRead(THashSet<NKikimr::TTableId>& modifiedTables, const NKqpProto::TKqpPhyQuery& physicalQuery);\n+bool HasUncommittedChangesRead(THashSet<NKikimr::TTableId>& modifiedTables, const NKqpProto::TKqpPhyQuery& physicalQuery, const bool commit);\n \n class TKqpTransactionContext : public NYql::TKikimrTransactionContextBase  {\n public:\n@@ -316,8 +316,8 @@ class TKqpTransactionContext : public NYql::TKikimrTransactionContextBase  {\n         return true;\n     }\n \n-    void ApplyPhysicalQuery(const NKqpProto::TKqpPhyQuery& phyQuery) {\n-        NeedUncommittedChangesFlush = HasUncommittedChangesRead(ModifiedTablesSinceLastFlush, phyQuery);\n+    void ApplyPhysicalQuery(const NKqpProto::TKqpPhyQuery& phyQuery, const bool commit) {\n+        NeedUncommittedChangesFlush = HasUncommittedChangesRead(ModifiedTablesSinceLastFlush, phyQuery, commit);\n         if (NeedUncommittedChangesFlush) {\n             ModifiedTablesSinceLastFlush.clear();   \n         }\ndiff --git a/ydb/core/kqp/common/kqp_tx_manager.cpp b/ydb/core/kqp/common/kqp_tx_manager.cpp\nindex a23ed7d5c7e6..2d973deea186 100644\n--- a/ydb/core/kqp/common/kqp_tx_manager.cpp\n+++ b/ydb/core/kqp/common/kqp_tx_manager.cpp\n@@ -91,7 +91,6 @@ class TKqpTransactionManager : public IKqpTransactionManager {\n         auto& shardInfo = ShardsInfo.at(shardId);\n         if (auto lockPtr = shardInfo.Locks.FindPtr(lock.GetKey()); lockPtr) {\n             if (lock.Proto.GetHasWrites()) {\n-                AFL_ENSURE(!ReadOnly);\n                 lockPtr->Lock.Proto.SetHasWrites(true);\n             }\n \n@@ -163,6 +162,14 @@ class TKqpTransactionManager : public IKqpTransactionManager {\n         return nullptr;\n     }\n \n+    void AddParticipantNode(const ui32 nodeId) override {\n+        ParticipantNodes.insert(nodeId);\n+    }\n+\n+    const THashSet<ui32>& GetParticipantNodes() const override {\n+        return ParticipantNodes;\n+    }\n+\n     void SetTopicOperations(NTopic::TTopicOperations&& topicOperations) override {\n         TopicOperations = std::move(topicOperations);\n     }\n@@ -307,6 +314,10 @@ class TKqpTransactionManager : public IKqpTransactionManager {\n         return !dontNeedCommit;\n     }\n \n+    virtual ui64 GetCoordinator() const override {\n+        return Coordinator;\n+    }\n+\n     void StartPrepare() override {\n         AFL_ENSURE(!CollectOnly);\n         AFL_ENSURE(State == ETransactionState::COLLECTING);\n@@ -485,7 +496,8 @@ class TKqpTransactionManager : public IKqpTransactionManager {\n \n     void MakeLocksIssue(const TShardInfo& shardInfo) {\n         TStringBuilder message;\n-        message << \"Transaction locks invalidated. Tables: \";\n+        message << \"Transaction locks invalidated. \";\n+        message << (shardInfo.Pathes.size() == 1 ? \"Table: \" : \"Tables: \");\n         bool first = true;\n         // TODO: add error by pathid\n         for (const auto& path : shardInfo.Pathes) {\n@@ -502,6 +514,8 @@ class TKqpTransactionManager : public IKqpTransactionManager {\n     THashMap<ui64, TShardInfo> ShardsInfo;\n     std::unordered_set<TString> TablePathes;\n \n+    THashSet<ui32> ParticipantNodes;\n+\n     THashMap<TTableId, std::shared_ptr<const TVector<TKeyDesc::TPartitionInfo>>> TablePartitioning;\n \n     bool AllowVolatile = false;\ndiff --git a/ydb/core/kqp/common/kqp_tx_manager.h b/ydb/core/kqp/common/kqp_tx_manager.h\nindex 18ba29d93299..dc11e0b12bec 100644\n--- a/ydb/core/kqp/common/kqp_tx_manager.h\n+++ b/ydb/core/kqp/common/kqp_tx_manager.h\n@@ -71,6 +71,9 @@ class IKqpTransactionManager {\n     virtual void BuildTopicTxs(NTopic::TTopicOperationTransactions& txs) = 0;\n     virtual bool HasTopics() const = 0;\n \n+    virtual void AddParticipantNode(const ui32 nodeId) = 0;\n+    virtual const THashSet<ui32>& GetParticipantNodes() const = 0;\n+\n     virtual bool IsTxPrepared() const = 0;\n     virtual bool IsTxFinished() const = 0;\n \n@@ -95,6 +98,8 @@ class IKqpTransactionManager {\n \n     virtual bool NeedCommit() const = 0;\n \n+    virtual ui64 GetCoordinator() const = 0;\n+\n     virtual void StartPrepare() = 0;\n \n     struct TPrepareInfo {\ndiff --git a/ydb/core/kqp/common/kqp_yql.cpp b/ydb/core/kqp/common/kqp_yql.cpp\nindex 0ff2491c2a0b..050f527db95b 100644\n--- a/ydb/core/kqp/common/kqp_yql.cpp\n+++ b/ydb/core/kqp/common/kqp_yql.cpp\n@@ -158,10 +158,11 @@ TKqpReadTableSettings ParseInternal(const TCoNameValueTupleList& node) {\n             settings.ItemsLimit = tuple.Value().Cast().Ptr();\n         } else if (name == TKqpReadTableSettings::ReverseSettingName) {\n             YQL_ENSURE(tuple.Ref().ChildrenSize() == 1);\n-            settings.Reverse = true;\n+            settings.SetSorting(ERequestSorting::DESC);\n         } else if (name == TKqpReadTableSettings::SortedSettingName) {\n-            YQL_ENSURE(tuple.Ref().ChildrenSize() == 1);\n-            settings.Sorted = true;\n+            if (settings.GetSorting() == ERequestSorting::NONE) {\n+                settings.SetSorting(ERequestSorting::ASC);\n+            }\n         } else if (name == TKqpReadTableSettings::SequentialSettingName) {\n             YQL_ENSURE(tuple.Ref().ChildrenSize() == 2);\n             settings.SequentialInFlight = FromString<ui64>(tuple.Value().Cast<TCoAtom>().Value());\n@@ -224,7 +225,7 @@ NNodes::TCoNameValueTupleList TKqpReadTableSettings::BuildNode(TExprContext& ctx\n                 .Done());\n     }\n \n-    if (Reverse) {\n+    if (IsReverse()) {\n         settings.emplace_back(\n             Build<TCoNameValueTuple>(ctx, pos)\n                 .Name()\n@@ -240,7 +241,7 @@ NNodes::TCoNameValueTupleList TKqpReadTableSettings::BuildNode(TExprContext& ctx\n                 .Done());\n     }\n \n-    if (Sorted) {\n+    if (IsSorted()) {\n         settings.emplace_back(\n             Build<TCoNameValueTuple>(ctx, pos)\n                 .Name()\ndiff --git a/ydb/core/kqp/common/kqp_yql.h b/ydb/core/kqp/common/kqp_yql.h\nindex 2765c35b9335..4372406e1c35 100644\n--- a/ydb/core/kqp/common/kqp_yql.h\n+++ b/ydb/core/kqp/common/kqp_yql.h\n@@ -44,7 +44,7 @@ struct TKqpPhyTxSettings {\n };\n \n constexpr TStringBuf KqpReadRangesSourceName = \"KqpReadRangesSource\";\n-constexpr TStringBuf KqpTableSinkName = \"KqpTableSinkName\";\n+constexpr TStringBuf KqpTableSinkName = \"KqpTableSink\";\n \n enum class EStreamLookupStrategyType {\n     Unspecified,\n@@ -72,7 +72,35 @@ struct TKqpStreamLookupSettings {\n     static TKqpStreamLookupSettings Parse(const NNodes::TCoNameValueTupleList& node);\n };\n \n-struct TKqpReadTableSettings {\n+enum class ERequestSorting {\n+    NONE = 0,\n+    ASC,\n+    DESC\n+};\n+\n+template <ERequestSorting DefaultValue = ERequestSorting::NONE>\n+class TSortingOperator {\n+private:\n+    ERequestSorting Sorting = DefaultValue;\n+public:\n+    void SetSorting(const ERequestSorting sorting) {\n+        Sorting = sorting;\n+    }\n+    ERequestSorting GetSorting() const {\n+        return Sorting;\n+    }\n+\n+    bool IsSorted() const {\n+        return Sorting != ERequestSorting::NONE;\n+    }\n+\n+    bool IsReverse() const {\n+        return Sorting == ERequestSorting::DESC;\n+    }\n+};\n+\n+struct TKqpReadTableSettings: public TSortingOperator<ERequestSorting::NONE> {\n+public:\n     static constexpr TStringBuf SkipNullKeysSettingName = \"SkipNullKeys\";\n     static constexpr TStringBuf ItemsLimitSettingName = \"ItemsLimit\";\n     static constexpr TStringBuf ReverseSettingName = \"Reverse\";\n@@ -84,16 +112,12 @@ struct TKqpReadTableSettings {\n \n     TVector<TString> SkipNullKeys;\n     TExprNode::TPtr ItemsLimit;\n-    bool Reverse = false;\n-    bool Sorted = false;\n     TMaybe<ui64> SequentialInFlight;\n     TMaybe<ui64> TabletId;\n     bool ForcePrimary = false;\n \n     void AddSkipNullKey(const TString& key);\n     void SetItemsLimit(const TExprNode::TPtr& expr) { ItemsLimit = expr; }\n-    void SetReverse() { Reverse = true; }\n-    void SetSorted() { Sorted = true; }\n \n     bool operator == (const TKqpReadTableSettings&) const = default;\n \ndiff --git a/ydb/core/kqp/common/simple/kqp_event_ids.h b/ydb/core/kqp/common/simple/kqp_event_ids.h\nindex a54408006423..b9ad1addb195 100644\n--- a/ydb/core/kqp/common/simple/kqp_event_ids.h\n+++ b/ydb/core/kqp/common/simple/kqp_event_ids.h\n@@ -94,6 +94,7 @@ struct TKqpComputeEvents {\n         EvScanInitActor,\n         EvRemoteScanData,\n         EvRemoteScanDataAck,\n+        EvScanPing,\n     };\n \n     static_assert(Unused0 == EventSpaceBegin(TKikimrEvents::ES_KQP) + 200);\ndiff --git a/ydb/core/kqp/compute_actor/kqp_compute_actor_factory.cpp b/ydb/core/kqp/compute_actor/kqp_compute_actor_factory.cpp\nindex 46267030ba46..0dff7085bdcd 100644\n--- a/ydb/core/kqp/compute_actor/kqp_compute_actor_factory.cpp\n+++ b/ydb/core/kqp/compute_actor/kqp_compute_actor_factory.cpp\n@@ -86,7 +86,7 @@ class TKqpCaFactory : public IKqpNodeComputeActorFactory {\n     std::atomic<ui64> MkqlLightProgramMemoryLimit = 0;\n     std::atomic<ui64> MkqlHeavyProgramMemoryLimit = 0;\n     std::atomic<ui64> MinChannelBufferSize = 0;\n-    std::atomic<ui64> MinMemAllocSize = 8_MB;\n+    std::atomic<ui64> MinMemAllocSize = 1_MB;\n     std::atomic<ui64> MinMemFreeSize = 32_MB;\n \n public:\ndiff --git a/ydb/core/kqp/compute_actor/kqp_compute_events.h b/ydb/core/kqp/compute_actor/kqp_compute_events.h\nindex 4b9d3f292420..cdb0496fe4df 100644\n--- a/ydb/core/kqp/compute_actor/kqp_compute_events.h\n+++ b/ydb/core/kqp/compute_actor/kqp_compute_events.h\n@@ -250,16 +250,22 @@ struct TEvKqpCompute {\n         }\n     };\n \n+    struct TEvScanPing : public NActors::TEventPB<TEvScanPing, NKikimrKqp::TEvScanPing,\n+        TKqpComputeEvents::EvScanPing>\n+    {\n+    };\n+\n     struct TEvScanInitActor : public NActors::TEventPB<TEvScanInitActor, NKikimrKqp::TEvScanInitActor,\n         TKqpComputeEvents::EvScanInitActor>\n     {\n         TEvScanInitActor() = default;\n \n-        TEvScanInitActor(ui64 scanId, const NActors::TActorId& scanActor, ui32 generation, const ui64 tabletId) {\n+        TEvScanInitActor(ui64 scanId, const NActors::TActorId& scanActor, ui32 generation, const ui64 tabletId, bool allowPings = false) {\n             Record.SetScanId(scanId);\n             ActorIdToProto(scanActor, Record.MutableScanActorId());\n             Record.SetGeneration(generation);\n             Record.SetTabletId(tabletId);\n+            Record.SetAllowPings(allowPings);\n         }\n     };\n \ndiff --git a/ydb/core/kqp/compute_actor/kqp_pure_compute_actor.cpp b/ydb/core/kqp/compute_actor/kqp_pure_compute_actor.cpp\nindex 2e019e53797e..4b08dca16f42 100644\n--- a/ydb/core/kqp/compute_actor/kqp_pure_compute_actor.cpp\n+++ b/ydb/core/kqp/compute_actor/kqp_pure_compute_actor.cpp\n@@ -84,7 +84,7 @@ void TKqpComputeActor::DoBootstrap() {\n     try {\n         PrepareTaskRunner(TKqpTaskRunnerExecutionContext(std::get<ui64>(TxId), RuntimeSettings.UseSpilling, ArrayBufferMinFillPercentage, std::move(wakeupCallback), std::move(errorCallback)));\n     } catch (const NMiniKQL::TKqpEnsureFail& e) {\n-        InternalError((TIssuesIds::EIssueCode) e.GetCode(), e.GetMessage());\n+        ErrorFromIssue((TIssuesIds::EIssueCode) e.GetCode(), e.GetMessage());\n         return;\n     }\n \n@@ -120,7 +120,7 @@ void TKqpComputeActor::DoBootstrap() {\n         auto scanActor = NSysView::CreateSystemViewScan(SelfId(), 0, ScanData->TableId, ScanData->TablePath, ranges, columns, UserToken, Database, reverse);\n \n         if (!scanActor) {\n-            InternalError(TIssuesIds::DEFAULT_ERROR, TStringBuilder()\n+            ErrorFromIssue(TIssuesIds::DEFAULT_ERROR, TStringBuilder()\n                 << \"Failed to create system view scan, table id: \" << ScanData->TableId);\n             return;\n         }\n@@ -148,9 +148,9 @@ STFUNC(TKqpComputeActor::StateFunc) {\n     } catch (const TMemoryLimitExceededException& e) {\n         TBase::OnMemoryLimitExceptionHandler();\n     } catch (const NMiniKQL::TKqpEnsureFail& e) {\n-        InternalError((TIssuesIds::EIssueCode) e.GetCode(), e.GetMessage());\n-    } catch (const yexception& e) {\n-        InternalError(TIssuesIds::DEFAULT_ERROR, e.what());\n+        ErrorFromIssue((TIssuesIds::EIssueCode) e.GetCode(), e.GetMessage());\n+    } catch (const std::exception& e) {\n+        ErrorFromIssue(TIssuesIds::DEFAULT_ERROR, e.what());\n     }\n \n     ReportEventElapsedTime();\ndiff --git a/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.cpp b/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.cpp\nindex 7eab5ef78196..1b408cdf6f82 100644\n--- a/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.cpp\n+++ b/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.cpp\n@@ -27,10 +27,9 @@ std::vector<std::unique_ptr<TComputeTaskData>> TShardScannerInfo::OnReceiveData(\n         AFL_ENSURE(data.Finished);\n         result.emplace_back(std::make_unique<TComputeTaskData>(selfPtr, std::make_unique<TEvScanExchange::TEvSendData>(TabletId, data.LocksInfo)));\n     } else if (data.SplittedBatches.size() > 1) {\n-        ui32 idx = 0;\n         AFL_ENSURE(data.ArrowBatch);\n         for (auto&& i : data.SplittedBatches) {\n-            result.emplace_back(std::make_unique<TComputeTaskData>(selfPtr, std::make_unique<TEvScanExchange::TEvSendData>(data.ArrowBatch, TabletId, std::move(i), data.LocksInfo), idx++));\n+            result.emplace_back(std::make_unique<TComputeTaskData>(selfPtr, std::make_unique<TEvScanExchange::TEvSendData>(data.ArrowBatch, TabletId, std::move(i), data.LocksInfo)));\n         }\n     } else if (data.ArrowBatch) {\n         result.emplace_back(std::make_unique<TComputeTaskData>(selfPtr, std::make_unique<TEvScanExchange::TEvSendData>(data.ArrowBatch, TabletId, data.LocksInfo)));\ndiff --git a/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.h b/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.h\nindex 67b7ff64beee..bcc0e28fe4ce 100644\n--- a/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.h\n+++ b/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.h\n@@ -32,6 +32,7 @@ class TShardScannerInfo {\n     const ui64 FreeSpace = (ui64)8 << 20;\n     bool NeedAck = true;\n     bool Finished = false;\n+    bool AllowPings = false;\n \n     void DoAck() {\n         if (Finished) {\n@@ -105,10 +106,17 @@ class TShardScannerInfo {\n         return !ActorId.has_value();\n     }\n \n-    void Start(const TActorId& actorId) {\n+    void PingIfNeeded() {\n+        if (AllowPings && !!ActorId) {\n+            NActors::TActivationContext::AsActorContext().Send(*ActorId, new TEvKqpCompute::TEvScanPing());\n+        }\n+    }\n+\n+    void Start(const TActorId& actorId, bool allowPings) {\n         AFL_DEBUG(NKikimrServices::KQP_COMPUTE)(\"event\", \"start_scanner\")(\"actor_id\", actorId);\n         AFL_ENSURE(!ActorId);\n         ActorId = actorId;\n+        AllowPings = allowPings;\n         DoAck();\n     }\n \n@@ -284,6 +292,12 @@ class TInFlightShards: public NComputeActor::TScanShardsStatistics {\n         }\n     }\n \n+    void PingAllScanners() {\n+        for (auto&& itTablet : ShardScanners) {\n+            itTablet.second->PingIfNeeded();\n+        }\n+    }\n+\n     std::shared_ptr<TShardState> GetShardStateByActorId(const NActors::TActorId& actorId) const {\n         auto it = ShardsByActorId.find(actorId);\n         if (it == ShardsByActorId.end()) {\n@@ -307,7 +321,7 @@ class TInFlightShards: public NComputeActor::TScanShardsStatistics {\n         }\n     }\n \n-    void RegisterScannerActor(const ui64 tabletId, const ui64 generation, const TActorId& scanActorId) {\n+    void RegisterScannerActor(const ui64 tabletId, const ui64 generation, const TActorId& scanActorId, bool allowPings) {\n         auto state = GetShardState(tabletId);\n         if (!state || generation != state->Generation) {\n             AFL_DEBUG(NKikimrServices::KQP_COMPUTE)(\"event\", \"register_scanner_actor_dropped\")\n@@ -326,7 +340,7 @@ class TInFlightShards: public NComputeActor::TScanShardsStatistics {\n         state->ResetRetry();\n         AFL_ENSURE(ShardsByActorId.emplace(scanActorId, state).second);\n \n-        GetShardScannerVerified(tabletId)->Start(scanActorId);\n+        GetShardScannerVerified(tabletId)->Start(scanActorId, allowPings);\n     }\n \n     void StartScanner(TShardState& state) {\ndiff --git a/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.cpp b/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.cpp\nindex 0a383b154a6f..45064976e208 100644\n--- a/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.cpp\n+++ b/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.cpp\n@@ -1,10 +1,12 @@\n #include \"kqp_scan_fetcher_actor.h\"\n-#include <ydb/library/wilson_ids/wilson.h>\n-#include <ydb/core/kqp/common/kqp_resolve.h>\n-#include <ydb/core/tx/datashard/range_ops.h>\n+\n #include <ydb/core/actorlib_impl/long_timer.h>\n+#include <ydb/core/kqp/common/kqp_resolve.h>\n+#include <ydb/core/kqp/common/kqp_yql.h>\n #include <ydb/core/scheme/scheme_types_proto.h>\n+#include <ydb/core/tx/datashard/range_ops.h>\n \n+#include <ydb/library/wilson_ids/wilson.h>\n #include <ydb/library/yql/dq/actors/compute/dq_compute_actor_impl.h>\n \n namespace NKikimr::NKqp::NScanPrivate {\n@@ -15,18 +17,16 @@ using namespace NYql;\n using namespace NYql::NDq;\n using namespace NKikimr::NKqp::NComputeActor;\n \n-static constexpr ui64 MAX_SHARD_RETRIES = 5; // retry after: 0, 250, 500, 1000, 2000\n+static constexpr ui64 MAX_SHARD_RETRIES = 5;   // retry after: 0, 250, 500, 1000, 2000\n static constexpr ui64 MAX_TOTAL_SHARD_RETRIES = 20;\n static constexpr ui64 MAX_SHARD_RESOLVES = 3;\n \n-} // anonymous namespace\n-\n+}   // anonymous namespace\n \n-TKqpScanFetcherActor::TKqpScanFetcherActor(const NKikimrKqp::TKqpSnapshot& snapshot,\n-    const TComputeRuntimeSettings& settings, std::vector<NActors::TActorId>&& computeActors,\n-    const ui64 txId, const TMaybe<ui64> lockTxId, const ui32 lockNodeId, const TMaybe<NKikimrDataEvents::ELockMode> lockMode,\n-    const NKikimrTxDataShard::TKqpTransaction_TScanTaskMeta& meta, const TShardsScanningPolicy& shardsScanningPolicy,\n-    TIntrusivePtr<TKqpCounters> counters, NWilson::TTraceId traceId)\n+TKqpScanFetcherActor::TKqpScanFetcherActor(const NKikimrKqp::TKqpSnapshot& snapshot, const TComputeRuntimeSettings& settings,\n+    std::vector<NActors::TActorId>&& computeActors, const ui64 txId, const TMaybe<ui64> lockTxId, const ui32 lockNodeId,\n+    const TMaybe<NKikimrDataEvents::ELockMode> lockMode, const NKikimrTxDataShard::TKqpTransaction_TScanTaskMeta& meta,\n+    const TShardsScanningPolicy& shardsScanningPolicy, TIntrusivePtr<TKqpCounters> counters, NWilson::TTraceId traceId)\n     : Meta(meta)\n     , ScanDataMeta(Meta)\n     , RuntimeSettings(settings)\n@@ -47,14 +47,15 @@ TKqpScanFetcherActor::TKqpScanFetcherActor(const NKikimrKqp::TKqpSnapshot& snaps\n     KeyColumnTypes.reserve(Meta.GetKeyColumnTypes().size());\n     for (size_t i = 0; i < Meta.KeyColumnTypesSize(); i++) {\n         NScheme::TTypeId typeId = Meta.GetKeyColumnTypes().at(i);\n-        NScheme::TTypeInfo typeInfo = NScheme::NTypeIds::IsParametrizedType(typeId) ?\n-            NScheme::TypeInfoFromProto(typeId, Meta.GetKeyColumnTypeInfos().at(i)) :\n-            NScheme::TTypeInfo(typeId);\n+        NScheme::TTypeInfo typeInfo = NScheme::NTypeIds::IsParametrizedType(typeId)\n+                                          ? NScheme::TypeInfoFromProto(typeId, Meta.GetKeyColumnTypeInfos().at(i))\n+                                          : NScheme::TTypeInfo(typeId);\n         KeyColumnTypes.push_back(typeInfo);\n     }\n }\n \n-TVector<NKikimr::TSerializedTableRange> TKqpScanFetcherActor::BuildSerializedTableRanges(const NKikimrTxDataShard::TKqpTransaction::TScanTaskMeta::TReadOpMeta& readData) {\n+TVector<NKikimr::TSerializedTableRange> TKqpScanFetcherActor::BuildSerializedTableRanges(\n+    const NKikimrTxDataShard::TKqpTransaction::TScanTaskMeta::TReadOpMeta& readData) {\n     TVector<TSerializedTableRange> resultLocal;\n     resultLocal.reserve(readData.GetKeyRanges().size());\n     for (const auto& range : readData.GetKeyRanges()) {\n@@ -82,21 +83,21 @@ void TKqpScanFetcherActor::Bootstrap() {\n     AFL_DEBUG(NKikimrServices::KQP_COMPUTE)(\"event\", \"bootstrap\")(\"compute\", ComputeActorIds.size())(\"shards\", PendingShards.size());\n     StartTableScan();\n     Become(&TKqpScanFetcherActor::StateFunc);\n+    Schedule(TDuration::Seconds(30), new NActors::TEvents::TEvWakeup());\n }\n \n void TKqpScanFetcherActor::HandleExecute(TEvScanExchange::TEvAckData::TPtr& ev) {\n     AFL_ENSURE(ev->Get()->GetFreeSpace());\n-    AFL_DEBUG(NKikimrServices::KQP_COMPUTE)(\"event\", \"AckDataFromCompute\")(\"self_id\", SelfId())(\"scan_id\", ScanId)\n-        (\"packs_to_send\", InFlightComputes.GetPacksToSendCount())\n-        (\"from\", ev->Sender)(\"shards remain\", PendingShards.size())\n-        (\"in flight scans\", InFlightShards.GetScansCount())\n-        (\"in flight shards\", InFlightShards.GetShardsCount());\n+    AFL_DEBUG(NKikimrServices::KQP_COMPUTE)(\"event\", \"AckDataFromCompute\")(\"self_id\", SelfId())(\"scan_id\", ScanId)(\n+        \"packs_to_send\", InFlightComputes.GetPacksToSendCount())(\"from\", ev->Sender)(\"shards remain\", PendingShards.size())(\n+        \"in flight scans\", InFlightShards.GetScansCount())(\"in flight shards\", InFlightShards.GetShardsCount());\n     InFlightComputes.OnComputeAck(ev->Sender, ev->Get()->GetFreeSpace());\n     CheckFinish();\n }\n \n void TKqpScanFetcherActor::HandleExecute(TEvScanExchange::TEvTerminateFromCompute::TPtr& ev) {\n-    AFL_DEBUG(NKikimrServices::KQP_COMPUTE)(\"event\", \"TEvTerminateFromCompute\")(\"sender\", ev->Sender)(\"info\", ev->Get()->GetIssues().ToOneLineString());\n+    AFL_DEBUG(NKikimrServices::KQP_COMPUTE)(\"event\", \"TEvTerminateFromCompute\")(\"sender\", ev->Sender)(\n+        \"info\", ev->Get()->GetIssues().ToOneLineString());\n     TStringBuilder sb;\n     sb << \"Send abort execution from compute actor, message: \" << ev->Get()->GetIssues().ToOneLineString();\n \n@@ -110,7 +111,7 @@ void TKqpScanFetcherActor::HandleExecute(TEvKqpCompute::TEvScanInitActor::TPtr&\n     }\n     auto& msg = ev->Get()->Record;\n     auto scanActorId = ActorIdFromProto(msg.GetScanActorId());\n-    InFlightShards.RegisterScannerActor(msg.GetTabletId(), msg.GetGeneration(), scanActorId);\n+    InFlightShards.RegisterScannerActor(msg.GetTabletId(), msg.GetGeneration(), scanActorId, msg.GetAllowPings());\n }\n \n void TKqpScanFetcherActor::HandleExecute(TEvKqpCompute::TEvScanData::TPtr& ev) {\n@@ -124,17 +125,13 @@ void TKqpScanFetcherActor::HandleExecute(TEvKqpCompute::TEvScanData::TPtr& ev) {\n     AFL_ENSURE(state->State == EShardState::Running)(\"state\", state->State)(\"actor_id\", state->ActorId)(\"ev_sender\", ev->Sender);\n \n     AFL_DEBUG(NKikimrServices::KQP_COMPUTE)\n-        (\"Recv TEvScanData from ShardID=\", ev->Sender)\n-        (\"ScanId\", ev->Get()->ScanId)\n-        (\"Finished\", ev->Get()->Finished)\n-        (\"Lock\", [&]() {\n+    (\"Recv TEvScanData from ShardID=\", ev->Sender)(\"ScanId\", ev->Get()->ScanId)(\"Finished\", ev->Get()->Finished)(\"Lock\", [&]() {\n         TStringBuilder builder;\n         for (const auto& lock : ev->Get()->LocksInfo.Locks) {\n             builder << lock.ShortDebugString();\n         }\n         return builder;\n-    }())\n-        (\"BrokenLocks\", [&]() {\n+    }())(\"BrokenLocks\", [&]() {\n         TStringBuilder builder;\n         for (const auto& lock : ev->Get()->LocksInfo.BrokenLocks) {\n             builder << lock.ShortDebugString();\n@@ -162,10 +159,8 @@ void TKqpScanFetcherActor::HandleExecute(TEvKqpCompute::TEvScanError::TPtr& ev)\n     TIssues issues;\n     IssuesFromMessage(msg.GetIssues(), issues);\n \n-    CA_LOG_W(\"Got EvScanError scan state: \"\n-        << \", status: \" << Ydb::StatusIds_StatusCode_Name(status)\n-        << \", reason: \" << issues.ToString()\n-        << \", tablet id: \" << msg.GetTabletId() << \", actor_id: \" << ev->Sender);\n+    CA_LOG_W(\"Got EvScanError scan state: \" << \", status: \" << Ydb::StatusIds_StatusCode_Name(status) << \", reason: \" << issues.ToString()\n+                                            << \", tablet id: \" << msg.GetTabletId() << \", actor_id: \" << ev->Sender);\n \n     auto state = InFlightShards.GetShardStateByActorId(ev->Sender);\n     if (!state) {\n@@ -182,8 +177,8 @@ void TKqpScanFetcherActor::HandleExecute(TEvKqpCompute::TEvScanError::TPtr& ev)\n     if (state->State == EShardState::Starting) {\n         ++TotalRetries;\n         if (TotalRetries >= MAX_TOTAL_SHARD_RETRIES) {\n-            CA_LOG_E(\"TKqpScanFetcherActor: broken tablet for this request \" << state->TabletId\n-                << \", retries limit exceeded (\" << state->TotalRetries << \"/\" << TotalRetries << \")\");\n+            CA_LOG_E(\"TKqpScanFetcherActor: broken tablet for this request \" << state->TabletId << \", retries limit exceeded (\"\n+                                                                             << state->TotalRetries << \"/\" << TotalRetries << \")\");\n             SendGlobalFail(NDqProto::COMPUTE_STATE_FAILURE, YdbStatusToDqStatus(status), issues);\n             return PassAway();\n         }\n@@ -203,8 +198,8 @@ void TKqpScanFetcherActor::HandleExecute(TEvKqpCompute::TEvScanError::TPtr& ev)\n     }\n \n     if (state->State == EShardState::PostRunning || state->State == EShardState::Running) {\n-        CA_LOG_E(\"TKqpScanFetcherActor: broken tablet for this request \" << state->TabletId\n-            << \", retries limit exceeded (\" << state->TotalRetries << \"/\" << TotalRetries << \")\");\n+        CA_LOG_E(\"TKqpScanFetcherActor: broken tablet for this request \" << state->TabletId << \", retries limit exceeded (\"\n+                                                                         << state->TotalRetries << \"/\" << TotalRetries << \")\");\n         SendGlobalFail(NDqProto::COMPUTE_STATE_FAILURE, YdbStatusToDqStatus(status), issues);\n         return PassAway();\n     }\n@@ -299,68 +294,82 @@ void TKqpScanFetcherActor::HandleExecute(TEvTxProxySchemeCache::TEvResolveKeySet\n     }\n \n     const auto& tr = *AppData()->TypeRegistry;\n-\n-    TVector<TShardState> newShards;\n-    newShards.reserve(keyDesc->GetPartitions().size());\n-\n-    for (ui64 idx = 0, i = 0; idx < keyDesc->GetPartitions().size(); ++idx) {\n-        const auto& partition = keyDesc->GetPartitions()[idx];\n-\n-        TTableRange partitionRange{\n-            idx == 0 ? state.Ranges.front().From.GetCells() : keyDesc->GetPartitions()[idx - 1].Range->EndKeyPrefix.GetCells(),\n-            idx == 0 ? state.Ranges.front().FromInclusive : !keyDesc->GetPartitions()[idx - 1].Range->IsInclusive,\n-            keyDesc->GetPartitions()[idx].Range->EndKeyPrefix.GetCells(),\n-            keyDesc->GetPartitions()[idx].Range->IsInclusive\n-        };\n-\n-        CA_LOG_D(\"Processing resolved ShardId# \" << partition.ShardId\n-            << \", partition range: \" << DebugPrintRange(KeyColumnTypes, partitionRange, tr)\n-            << \", i: \" << i << \", state ranges: \" << state.Ranges.size());\n-\n-        auto newShard = TShardState(partition.ShardId);\n-\n-        for (ui64 j = i; j < state.Ranges.size(); ++j) {\n-            auto comparison = CompareRanges(partitionRange, state.Ranges[j].ToTableRange(), KeyColumnTypes);\n-            CA_LOG_D(\"Compare range #\" << j << \" \" << DebugPrintRange(KeyColumnTypes, state.Ranges[j].ToTableRange(), tr)\n-                << \" with partition range \" << DebugPrintRange(KeyColumnTypes, partitionRange, tr)\n-                << \" : \" << comparison);\n-\n-            if (comparison > 0) {\n+    if (Meta.HasOlapProgram()) {\n+        bool found = false;\n+        for (auto&& partition : keyDesc->GetPartitions()) {\n+            if (partition.ShardId != state.TabletId) {\n                 continue;\n-            } else if (comparison == 0) {\n-                auto intersection = Intersect(KeyColumnTypes, partitionRange, state.Ranges[j].ToTableRange());\n-                CA_LOG_D(\"Add range to new shardId: \" << partition.ShardId\n-                    << \", range: \" << DebugPrintRange(KeyColumnTypes, intersection, tr));\n-\n-                newShard.Ranges.emplace_back(TSerializedTableRange(intersection));\n-            } else {\n-                break;\n             }\n-            i = j;\n+            auto newShard = TShardState(partition.ShardId);\n+            AFL_ENSURE(!found);\n+            newShard.LastKey = std::move(state.LastKey);\n+            newShard.LastCursorProto = std::move(state.LastCursorProto);\n+            newShard.Ranges = state.Ranges;\n+            PendingShards.emplace_front(std::move(newShard));\n+            found = true;\n         }\n+        AFL_ENSURE(found);\n+    } else {\n+        TVector<TShardState> newShards;\n+        newShards.reserve(keyDesc->GetPartitions().size());\n+\n+        for (ui64 idx = 0, i = 0; idx < keyDesc->GetPartitions().size(); ++idx) {\n+            const auto& partition = keyDesc->GetPartitions()[idx];\n+\n+            TTableRange partitionRange{ idx == 0 ? state.Ranges.front().From.GetCells()\n+                                                 : keyDesc->GetPartitions()[idx - 1].Range->EndKeyPrefix.GetCells(),\n+                idx == 0 ? state.Ranges.front().FromInclusive : !keyDesc->GetPartitions()[idx - 1].Range->IsInclusive,\n+                keyDesc->GetPartitions()[idx].Range->EndKeyPrefix.GetCells(), keyDesc->GetPartitions()[idx].Range->IsInclusive };\n+\n+            CA_LOG_D(\"Processing resolved ShardId# \"\n+                     << partition.ShardId << \", partition range: \" << DebugPrintRange(KeyColumnTypes, partitionRange, tr) << \", i: \" << i\n+                     << \", state ranges: \" << state.Ranges.size());\n+\n+            auto newShard = TShardState(partition.ShardId);\n+\n+            for (ui64 j = i; j < state.Ranges.size(); ++j) {\n+                auto comparison = CompareRanges(partitionRange, state.Ranges[j].ToTableRange(), KeyColumnTypes);\n+                CA_LOG_D(\"Compare range #\" << j << \" \" << DebugPrintRange(KeyColumnTypes, state.Ranges[j].ToTableRange(), tr)\n+                                           << \" with partition range \" << DebugPrintRange(KeyColumnTypes, partitionRange, tr) << \" : \"\n+                                           << comparison);\n+\n+                if (comparison > 0) {\n+                    continue;\n+                } else if (comparison == 0) {\n+                    auto intersection = Intersect(KeyColumnTypes, partitionRange, state.Ranges[j].ToTableRange());\n+                    CA_LOG_D(\n+                        \"Add range to new shardId: \" << partition.ShardId << \", range: \" << DebugPrintRange(KeyColumnTypes, intersection, tr));\n+\n+                    newShard.Ranges.emplace_back(TSerializedTableRange(intersection));\n+                } else {\n+                    break;\n+                }\n+                i = j;\n+            }\n \n-        if (!newShard.Ranges.empty()) {\n-            newShards.emplace_back(std::move(newShard));\n+            if (!newShard.Ranges.empty()) {\n+                newShards.emplace_back(std::move(newShard));\n+            }\n         }\n-    }\n \n-    AFL_ENSURE(!newShards.empty());\n+        AFL_ENSURE(!newShards.empty());\n \n-    for (int i = newShards.ysize() - 1; i >= 0; --i) {\n-        PendingShards.emplace_front(std::move(newShards[i]));\n-    }\n-\n-    if (!state.LastKey.empty()) {\n-        PendingShards.front().LastKey = std::move(state.LastKey);\n-        while (!PendingShards.empty() && PendingShards.front().GetScanRanges(KeyColumnTypes).empty()) {\n-            CA_LOG_D(\"Nothing to read \" << PendingShards.front().ToString(KeyColumnTypes));\n-            auto readShard = std::move(PendingShards.front());\n-            PendingShards.pop_front();\n-            PendingShards.front().LastKey = std::move(readShard.LastKey);\n-            PendingShards.front().LastCursorProto = std::move(readShard.LastCursorProto);\n+        for (int i = newShards.ysize() - 1; i >= 0; --i) {\n+            PendingShards.emplace_front(std::move(newShards[i]));\n         }\n \n-        AFL_ENSURE(!PendingShards.empty());\n+        if (!state.LastKey.empty()) {\n+            PendingShards.front().LastKey = std::move(state.LastKey);\n+            while (!PendingShards.empty() && PendingShards.front().GetScanRanges(KeyColumnTypes).empty()) {\n+                CA_LOG_D(\"Nothing to read \" << PendingShards.front().ToString(KeyColumnTypes));\n+                auto readShard = std::move(PendingShards.front());\n+                PendingShards.pop_front();\n+                PendingShards.front().LastKey = std::move(readShard.LastKey);\n+                PendingShards.front().LastCursorProto = std::move(readShard.LastCursorProto);\n+            }\n+\n+            AFL_ENSURE(!PendingShards.empty());\n+        }\n     }\n     StartTableScan();\n }\n@@ -374,8 +383,8 @@ void TKqpScanFetcherActor::HandleExecute(TEvents::TEvUndelivered::TPtr& ev) {\n             auto info = InFlightShards.GetShardScanner(ev->Cookie);\n             if (!!info) {\n                 auto state = InFlightShards.GetShardStateVerified(info->GetTabletId());\n-                AFL_WARN(NKikimrServices::KQP_COMPUTE)(\"event\", \"TEvents::TEvUndelivered\")(\"from_tablet\", info->GetTabletId())\n-                    (\"state\", state->State)(\"details\", info->ToString())(\"node\", SelfId().NodeId());\n+                AFL_WARN(NKikimrServices::KQP_COMPUTE)(\"event\", \"TEvents::TEvUndelivered\")(\"from_tablet\", info->GetTabletId())(\n+                    \"state\", state->State)(\"details\", info->ToString())(\"node\", SelfId().NodeId());\n                 AFL_ENSURE(state->State == EShardState::Running || state->State == EShardState::Starting)(\"state\", state->State);\n                 RetryDeliveryProblem(state);\n             }\n@@ -390,18 +399,20 @@ void TKqpScanFetcherActor::HandleExecute(TEvInterconnect::TEvNodeDisconnected::T\n     CA_LOG_N(\"Disconnected node \" << nodeId);\n \n     TrackingNodes.erase(nodeId);\n-    SendGlobalFail(NDqProto::StatusIds::UNAVAILABLE, TIssuesIds::DEFAULT_ERROR,\n-        TStringBuilder() << \"Connection with node \" << nodeId << \" lost.\");\n+    SendGlobalFail(\n+        NDqProto::StatusIds::UNAVAILABLE, TIssuesIds::DEFAULT_ERROR, TStringBuilder() << \"Connection with node \" << nodeId << \" lost.\");\n }\n \n-bool TKqpScanFetcherActor::SendGlobalFail(const NYql::NDqProto::StatusIds::StatusCode statusCode, const TIssuesIds::EIssueCode issueCode, const TString& message) const {\n+bool TKqpScanFetcherActor::SendGlobalFail(\n+    const NYql::NDqProto::StatusIds::StatusCode statusCode, const TIssuesIds::EIssueCode issueCode, const TString& message) const {\n     for (auto&& i : ComputeActorIds) {\n         Send(i, new TEvScanExchange::TEvTerminateFromFetcher(statusCode, issueCode, message));\n     }\n     return true;\n }\n \n-bool TKqpScanFetcherActor::SendGlobalFail(const NDqProto::EComputeState state, NYql::NDqProto::StatusIds::StatusCode statusCode, const TIssues& issues) const {\n+bool TKqpScanFetcherActor::SendGlobalFail(\n+    const NDqProto::EComputeState state, NYql::NDqProto::StatusIds::StatusCode statusCode, const TIssues& issues) const {\n     for (auto&& i : ComputeActorIds) {\n         Send(i, new TEvScanExchange::TEvTerminateFromFetcher(state, statusCode, issues));\n     }\n@@ -461,7 +472,15 @@ std::unique_ptr<NKikimr::TEvDataShard::TEvKqpScan> TKqpScanFetcherActor::BuildEv\n \n     ev->Record.SetGeneration(gen);\n \n-    ev->Record.SetReverse(Meta.GetReverse());\n+    if (Meta.HasOptionalSorting()) {\n+        if (Meta.GetOptionalSorting() == (ui32)ERequestSorting::DESC) {\n+            ev->Record.SetReverse(true);\n+        } else if (Meta.GetOptionalSorting() == (ui32)ERequestSorting::ASC) {\n+            ev->Record.SetReverse(false);\n+        }\n+    } else {\n+        ev->Record.SetReverse(Meta.GetReverse());\n+    }\n     ev->Record.SetItemsLimit(Meta.GetItemsLimit());\n \n     if (Meta.GroupByColumnNamesSize()) {\n@@ -476,9 +495,7 @@ std::unique_ptr<NKikimr::TEvDataShard::TEvKqpScan> TKqpScanFetcherActor::BuildEv\n         TStringOutput stream(programBytes);\n         Meta.GetOlapProgram().SerializeToArcadiaStream(&stream);\n         ev->Record.SetOlapProgram(programBytes);\n-        ev->Record.SetOlapProgramType(\n-            NKikimrSchemeOp::EOlapProgramType::OLAP_PROGRAM_SSA_PROGRAM_WITH_PARAMETERS\n-        );\n+        ev->Record.SetOlapProgramType(NKikimrSchemeOp::EOlapProgramType::OLAP_PROGRAM_SSA_PROGRAM_WITH_PARAMETERS);\n     }\n \n     ev->Record.SetDataFormat(Meta.GetDataFormat());\n@@ -504,18 +521,15 @@ void TKqpScanFetcherActor::ProcessPendingScanDataItem(TEvKqpCompute::TEvScanData\n     state->LastKey = std::move(msg.LastKey);\n     state->LastCursorProto = std::move(msg.LastCursorProto);\n     const ui64 rowsCount = msg.GetRowsCount();\n-    AFL_DEBUG(NKikimrServices::KQP_COMPUTE)(\"action\", \"got EvScanData\")(\"rows\", rowsCount)(\"finished\", msg.Finished)(\"exceeded\", msg.RequestedBytesLimitReached)\n-        (\"scan\", ScanId)(\"packs_to_send\", InFlightComputes.GetPacksToSendCount())\n-        (\"from\", ev->Sender)(\"shards remain\", PendingShards.size())\n-        (\"in flight scans\", InFlightShards.GetScansCount())\n-        (\"in flight shards\", InFlightShards.GetShardsCount())\n-        (\"delayed_for_seconds_by_ratelimiter\", latency.SecondsFloat())\n-        (\"tablet_id\", state->TabletId)\n-        (\"locks\", msg.LocksInfo.Locks.size())\n-        (\"broken locks\", msg.LocksInfo.BrokenLocks.size());\n+    AFL_DEBUG(NKikimrServices::KQP_COMPUTE)(\"action\", \"got EvScanData\")(\"rows\", rowsCount)(\"finished\", msg.Finished)(\n+        \"exceeded\", msg.RequestedBytesLimitReached)(\"scan\", ScanId)(\"packs_to_send\", InFlightComputes.GetPacksToSendCount())(\"from\", ev->Sender)(\n+        \"shards remain\", PendingShards.size())(\"in flight scans\", InFlightShards.GetScansCount())(\n+        \"in flight shards\", InFlightShards.GetShardsCount())(\"delayed_for_seconds_by_ratelimiter\", latency.SecondsFloat())(\n+        \"tablet_id\", state->TabletId)(\"locks\", msg.LocksInfo.Locks.size())(\"broken locks\", msg.LocksInfo.BrokenLocks.size());\n     auto shardScanner = InFlightShards.GetShardScannerVerified(state->TabletId);\n     auto tasksForCompute = shardScanner->OnReceiveData(msg, shardScanner);\n-    AFL_ENSURE(tasksForCompute.size() == 1 || tasksForCompute.size() == 0 || tasksForCompute.size() == ComputeActorIds.size())(\"size\", tasksForCompute.size())(\"compute_size\", ComputeActorIds.size());\n+    AFL_ENSURE(tasksForCompute.size() == 1 || tasksForCompute.size() == 0 || tasksForCompute.size() == ComputeActorIds.size())(\n+        \"size\", tasksForCompute.size())(\"compute_size\", ComputeActorIds.size());\n     for (auto&& i : tasksForCompute) {\n         const std::optional<ui32> computeShardId = i->GetComputeShardId();\n         InFlightComputes.OnReceiveData(computeShardId, std::move(i));\n@@ -525,7 +539,8 @@ void TKqpScanFetcherActor::ProcessPendingScanDataItem(TEvKqpCompute::TEvScanData\n     InFlightShards.MutableStatistics(state->TabletId).AddPack(rowsCount, 0);\n     Stats.AddReadStat(state->TabletId, rowsCount, 0);\n \n-    CA_LOG_D(\"EVLOGKQP:\" << IsAggregationRequest << \"/\" << Meta.GetItemsLimit() << \"/\" << InFlightShards.GetTotalRowsCount() << \"/\" << rowsCount);\n+    CA_LOG_D(\n+        \"EVLOGKQP:\" << IsAggregationRequest << \"/\" << Meta.GetItemsLimit() << \"/\" << InFlightShards.GetTotalRowsCount() << \"/\" << rowsCount);\n     if (msg.Finished) {\n         Stats.CompleteShard(state);\n         InFlightShards.StopScanner(state->TabletId);\n@@ -541,8 +556,9 @@ void TKqpScanFetcherActor::ProcessScanData() {\n     PendingScanData.pop_front();\n \n     auto state = InFlightShards.GetShardStateByActorId(ev->Sender);\n-    if (!state)\n+    if (!state) {\n         return;\n+    }\n \n     AFL_ENSURE(state->State == EShardState::Running || state->State == EShardState::PostRunning)(\"state\", state->State);\n     ProcessPendingScanDataItem(ev, enqueuedAt);\n@@ -565,11 +581,10 @@ void TKqpScanFetcherActor::StartTableScan() {\n     }\n \n     CA_LOG_D(\"Scheduled table scans, in flight: \" << InFlightShards.GetScansCount() << \" shards. \"\n-        << \"pending shards to read: \" << PendingShards.size() << \", \"\n-        << \"pending resolve shards: \" << PendingResolveShards.size() << \", \"\n-        << \"average read rows: \" << Stats.AverageReadRows() << \", \"\n-        << \"average read bytes: \" << Stats.AverageReadBytes() << \", \");\n-\n+                                                  << \"pending shards to read: \" << PendingShards.size() << \", \"\n+                                                  << \"pending resolve shards: \" << PendingResolveShards.size() << \", \"\n+                                                  << \"average read rows: \" << Stats.AverageReadRows() << \", \"\n+                                                  << \"average read bytes: \" << Stats.AverageReadBytes() << \", \");\n }\n \n void TKqpScanFetcherActor::RetryDeliveryProblem(TShardState::TPtr state) {\n@@ -577,8 +592,8 @@ void TKqpScanFetcherActor::RetryDeliveryProblem(TShardState::TPtr state) {\n     Counters->ScanQueryShardDisconnect->Inc();\n \n     if (state->TotalRetries >= MAX_TOTAL_SHARD_RETRIES) {\n-        CA_LOG_E(\"TKqpScanFetcherActor: broken pipe with tablet \" << state->TabletId\n-            << \", retries limit exceeded (\" << state->TotalRetries << \")\");\n+        CA_LOG_E(\n+            \"TKqpScanFetcherActor: broken pipe with tablet \" << state->TabletId << \", retries limit exceeded (\" << state->TotalRetries << \")\");\n         SendGlobalFail(NDqProto::StatusIds::UNAVAILABLE, TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,\n             TStringBuilder() << \"Retries limit with shard \" << state->TabletId << \" exceeded.\");\n         return;\n@@ -596,10 +611,10 @@ void TKqpScanFetcherActor::RetryDeliveryProblem(TShardState::TPtr state) {\n \n     ++TotalRetries;\n     auto retryDelay = state->CalcRetryDelay();\n-    CA_LOG_W(\"TKqpScanFetcherActor: broken pipe with tablet \" << state->TabletId\n-        << \", restarting scan from last received key \" << state->PrintLastKey(KeyColumnTypes)\n-        << \", attempt #\" << state->RetryAttempt << \" (total \" << state->TotalRetries << \")\"\n-        << \" schedule after \" << retryDelay);\n+    CA_LOG_W(\"TKqpScanFetcherActor: broken pipe with tablet \" << state->TabletId << \", restarting scan from last received key \"\n+                                                              << state->PrintLastKey(KeyColumnTypes) << \", attempt #\" << state->RetryAttempt\n+                                                              << \" (total \" << state->TotalRetries << \")\"\n+                                                              << \" schedule after \" << retryDelay);\n \n     state->RetryTimer = CreateLongTimer(TlsActivationContext->AsActorContext(), retryDelay,\n         new IEventHandle(SelfId(), SelfId(), new TEvPrivate::TEvRetryShard(state->TabletId, state->Generation)));\n@@ -617,9 +632,10 @@ void TKqpScanFetcherActor::ResolveShard(TShardState& state) {\n     state.State = EShardState::Resolving;\n     state.ResolveAttempt++;\n     state.SubscribedOnTablet = false;\n+    AFL_ENSURE(state.Ranges.size());\n \n-    auto range = TTableRange(state.Ranges.front().From.GetCells(), state.Ranges.front().FromInclusive,\n-        state.Ranges.back().To.GetCells(), state.Ranges.back().ToInclusive);\n+    auto range = TTableRange(state.Ranges.front().From.GetCells(), state.Ranges.front().FromInclusive, state.Ranges.back().To.GetCells(),\n+        state.Ranges.back().ToInclusive);\n \n     TVector<TKeyDesc::TColumnOp> columns;\n     columns.reserve(ScanDataMeta.GetColumns().size());\n@@ -631,12 +647,11 @@ void TKqpScanFetcherActor::ResolveShard(TShardState& state) {\n         columns.emplace_back(std::move(op));\n     }\n \n-    auto keyDesc = MakeHolder<TKeyDesc>(ScanDataMeta.TableId, range, TKeyDesc::ERowOperation::Read,\n-        KeyColumnTypes, columns);\n+    auto keyDesc = MakeHolder<TKeyDesc>(ScanDataMeta.TableId, range, TKeyDesc::ERowOperation::Read, KeyColumnTypes, columns);\n \n     CA_LOG_D(\"Sending TEvResolveKeySet update for table '\" << ScanDataMeta.TablePath << \"'\"\n-        << \", range: \" << DebugPrintRange(KeyColumnTypes, range, *AppData()->TypeRegistry)\n-        << \", attempt #\" << state.ResolveAttempt);\n+                                                           << \", range: \" << DebugPrintRange(KeyColumnTypes, range, *AppData()->TypeRegistry)\n+                                                           << \", attempt #\" << state.ResolveAttempt);\n \n     auto request = MakeHolder<NSchemeCache::TSchemeCacheRequest>();\n     request->ResultSet.emplace_back(std::move(keyDesc));\n@@ -668,12 +683,15 @@ void TKqpScanFetcherActor::CheckFinish() {\n     if (GetShardsInProgressCount() == 0 && InFlightComputes.GetPacksToSendCount() == 0) {\n         SendScanFinished();\n         InFlightShards.Stop();\n-        CA_LOG_D(\"EVLOGKQP(max_in_flight:\" << MaxInFlight << \")\"\n-            << Endl << InFlightShards.GetDurationStats()\n-            << Endl << InFlightShards.StatisticsToString()\n-        );\n+        CA_LOG_D(\"EVLOGKQP(max_in_flight:\" << MaxInFlight << \")\" << Endl << InFlightShards.GetDurationStats() << Endl\n+                                           << InFlightShards.StatisticsToString());\n         PassAway();\n     }\n }\n \n+void TKqpScanFetcherActor::HandleExecute(NActors::TEvents::TEvWakeup::TPtr&) {\n+    InFlightShards.PingAllScanners();\n+    Schedule(TDuration::Seconds(30), new NActors::TEvents::TEvWakeup());\n }\n+\n+}   // namespace NKikimr::NKqp::NScanPrivate\ndiff --git a/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.h b/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.h\nindex 73ead0a5ef0e..18d6e0500398 100644\n--- a/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.h\n+++ b/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.h\n@@ -82,6 +82,7 @@ class TKqpScanFetcherActor: public NActors::TActorBootstrapped<TKqpScanFetcherAc\n                 hFunc(TEvInterconnect::TEvNodeDisconnected, HandleExecute);\n                 hFunc(TEvScanExchange::TEvTerminateFromCompute, HandleExecute);\n                 hFunc(TEvScanExchange::TEvAckData, HandleExecute);\n+                hFunc(NActors::TEvents::TEvWakeup, HandleExecute);\n                 IgnoreFunc(TEvInterconnect::TEvNodeConnected);\n                 IgnoreFunc(TEvTxProxySchemeCache::TEvInvalidateTableResult);\n                 default:\n@@ -97,6 +98,8 @@ class TKqpScanFetcherActor: public NActors::TActorBootstrapped<TKqpScanFetcherAc\n \n     void HandleExecute(TEvScanExchange::TEvTerminateFromCompute::TPtr& ev);\n \n+    void HandleExecute(NActors::TEvents::TEvWakeup::TPtr& ev);\n+\n private:\n \n     void CheckFinish();\ndiff --git a/ydb/core/kqp/executer_actor/kqp_data_executer.cpp b/ydb/core/kqp/executer_actor/kqp_data_executer.cpp\nindex 614442fd57a1..238710d6a3a8 100644\n--- a/ydb/core/kqp/executer_actor/kqp_data_executer.cpp\n+++ b/ydb/core/kqp/executer_actor/kqp_data_executer.cpp\n@@ -198,6 +198,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n             if (data.GetData().template Is<NKikimrTxDataShard::TEvKqpInputActorResultInfo>()) {\n                 NKikimrTxDataShard::TEvKqpInputActorResultInfo info;\n                 YQL_ENSURE(data.GetData().UnpackTo(&info), \"Failed to unpack settings\");\n+                NDataIntegrity::LogIntegrityTrails(\"InputActorResult\", Request.UserTraceId, TxId, info, TlsActivationContext->AsActorContext());\n                 for (auto& lock : info.GetLocks()) {\n                     if (!TxManager) {\n                         Locks.push_back(lock);\n@@ -216,6 +217,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n             } else if (data.GetData().template Is<NKikimrKqp::TEvKqpOutputActorResultInfo>()) {\n                 NKikimrKqp::TEvKqpOutputActorResultInfo info;\n                 YQL_ENSURE(data.GetData().UnpackTo(&info), \"Failed to unpack settings\");\n+                NDataIntegrity::LogIntegrityTrails(\"OutputActorResult\", Request.UserTraceId, TxId, info, TlsActivationContext->AsActorContext());\n                 for (auto& lock : info.GetLocks()) {\n                     if (!TxManager) {\n                         Locks.push_back(lock);\n@@ -256,6 +258,10 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n \n         if (TxManager) {\n             TxManager->SetHasSnapshot(GetSnapshot().IsValid());\n+\n+            for (const ui64& shardId : TxManager->GetShards()) {\n+                Stats->AffectedShards.insert(shardId);\n+            }\n         }\n \n         if (!BufferActorId || (ReadOnlyTx && Request.LocksOp != ELocksOp::Rollback)) {\n@@ -269,7 +275,12 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n             auto event = std::make_unique<NKikimr::NKqp::TEvKqpBuffer::TEvCommit>();\n             event->ExecuterActorId = SelfId();\n             event->TxId = TxId;\n-            Send<ESendingType::Tail>(BufferActorId, event.release(), IEventHandle::FlagTrackDelivery);\n+            Send<ESendingType::Tail>(\n+                BufferActorId,\n+                event.release(),\n+                IEventHandle::FlagTrackDelivery,\n+                0,\n+                ExecuterSpan.GetTraceId());\n             return;\n         } else if (Request.LocksOp == ELocksOp::Rollback) {\n             Become(&TKqpDataExecuter::FinalizeState);\n@@ -277,7 +288,12 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n \n             auto event = std::make_unique<NKikimr::NKqp::TEvKqpBuffer::TEvRollback>();\n             event->ExecuterActorId = SelfId();\n-            Send<ESendingType::Tail>(BufferActorId, event.release(), IEventHandle::FlagTrackDelivery);\n+            Send<ESendingType::Tail>(\n+                BufferActorId,\n+                event.release(),\n+                IEventHandle::FlagTrackDelivery,\n+                0,\n+                ExecuterSpan.GetTraceId());\n             MakeResponseAndPassAway();\n             return;\n         } else if (Request.UseImmediateEffects) {\n@@ -286,7 +302,12 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n \n             auto event = std::make_unique<NKikimr::NKqp::TEvKqpBuffer::TEvFlush>();\n             event->ExecuterActorId = SelfId();\n-            Send<ESendingType::Tail>(BufferActorId, event.release(), IEventHandle::FlagTrackDelivery);\n+            Send<ESendingType::Tail>(\n+                BufferActorId,\n+                event.release(),\n+                IEventHandle::FlagTrackDelivery,\n+                0,\n+                ExecuterSpan.GetTraceId());\n             return;\n         } else {\n             Become(&TKqpDataExecuter::FinalizeState);\n@@ -298,7 +319,8 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n     STATEFN(FinalizeState) {\n         try {\n             switch(ev->GetTypeRewrite()) {\n-                hFunc(TEvKqp::TEvAbortExecution, HandleAbortExecution);\n+                hFunc(TEvKqp::TEvAbortExecution, HandleFinalize);\n+                hFunc(TEvKqpBuffer::TEvError, Handle);\n                 hFunc(TEvKqpBuffer::TEvResult, HandleFinalize);\n                 hFunc(TEvents::TEvUndelivered, HandleFinalize);\n \n@@ -325,6 +347,14 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n         ReportEventElapsedTime();\n     }\n \n+    void HandleFinalize(TEvKqp::TEvAbortExecution::TPtr& ev) {\n+        if (IsCancelAfterAllowed(ev)) {\n+            TBase::HandleAbortExecution(ev);\n+        } else {\n+            LOG_D(\"Got TEvAbortExecution from : \" << ev->Sender << \" but cancelation is not alowed\");\n+        }\n+    }\n+\n     void HandleFinalize(TEvKqpBuffer::TEvResult::TPtr& ev) {\n         if (ev->Get()->Stats) {\n             if (Stats) {\n@@ -335,13 +365,8 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n     }\n \n     void HandleFinalize(TEvents::TEvUndelivered::TPtr&) {\n-        if (Request.LocksOp == ELocksOp::Commit && !ReadOnlyTx) {\n-            auto issue = YqlIssue({}, TIssuesIds::KIKIMR_OPERATION_STATE_UNKNOWN, \"Buffer actor isn't available. Operation state unknown.\");\n-            ReplyErrorAndDie(Ydb::StatusIds::UNDETERMINED, issue);\n-        } else {\n-            auto issue = YqlIssue({}, TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE, \"Buffer actor isn't available.\");\n-            ReplyErrorAndDie(Ydb::StatusIds::UNAVAILABLE, issue);\n-        }\n+        auto issue = YqlIssue({}, TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE, \"Buffer actor isn't available.\");\n+        ReplyErrorAndDie(Ydb::StatusIds::UNAVAILABLE, issue);\n     }\n \n     void MakeResponseAndPassAway() {\n@@ -395,6 +420,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n                 hFunc(TEvSaveScriptExternalEffectResponse, HandleResolve);\n                 hFunc(TEvDescribeSecretsResponse, HandleResolve);\n                 hFunc(TEvKqp::TEvAbortExecution, HandleAbortExecution);\n+                hFunc(TEvKqpBuffer::TEvError, Handle);\n                 default:\n                     UnexpectedEvent(\"WaitResolveState\", ev->GetTypeRewrite());\n             }\n@@ -446,6 +472,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n                 hFunc(TEvKqpExecuter::TEvStreamDataAck, HandleStreamAck);\n                 hFunc(TEvPipeCache::TEvDeliveryProblem, HandlePrepare);\n                 hFunc(TEvKqp::TEvAbortExecution, HandlePrepare);\n+                hFunc(TEvKqpBuffer::TEvError, Handle);\n                 hFunc(TEvents::TEvUndelivered, HandleUndelivered);\n                 hFunc(TEvInterconnect::TEvNodeDisconnected, HandleDisconnected);\n                 hFunc(TEvKqpNode::TEvStartKqpTasksResponse, HandleStartKqpTasksResponse);\n@@ -498,6 +525,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n         TShardState* shardState = ShardStates.FindPtr(shardId);\n         YQL_ENSURE(shardState, \"Unexpected propose result from unknown tabletId \" << shardId);\n \n+        NDataIntegrity::LogIntegrityTrails(\"Prepare\", Request.UserTraceId, ev, TlsActivationContext->AsActorContext());\n         LOG_D(\"Got propose result, shard: \" << shardId << \", status: \"\n             << NKikimrTxDataShard::TEvProposeTransactionResult_EStatus_Name(res->GetStatus())\n             << \", error: \" << res->GetError());\n@@ -567,6 +595,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n         NYql::TIssues issues;\n         NYql::IssuesFromMessage(res->Record.GetIssues(), issues);\n \n+        NDataIntegrity::LogIntegrityTrails(\"Prepare\", Request.UserTraceId, ev, TlsActivationContext->AsActorContext());\n         LOG_D(\"Recv EvWriteResult (prepare) from ShardID=\" << shardId\n             << \", Status=\" << NKikimrDataEvents::TEvWriteResult::EStatus_Name(ev->Get()->GetStatus())\n             << \", TxId=\" << ev->Get()->Record.GetTxId()\n@@ -889,6 +918,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n                         case NKikimrTxDataShard::TError::SCHEME_ERROR:\n                             return ReplyErrorAndDie(Ydb::StatusIds::SCHEME_ERROR, YqlIssue({},\n                                 TIssuesIds::KIKIMR_SCHEME_MISMATCH, er.GetReason()));\n+                        //TODO Split OUT_OF_SPACE and DISK_SPACE_EXHAUSTED cases. The first one is temporary, the second one is permanent.\n                         case NKikimrTxDataShard::TError::OUT_OF_SPACE:\n                         case NKikimrTxDataShard::TError::DISK_SPACE_EXHAUSTED: {\n                             auto issue = YqlIssue({}, TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE);\n@@ -1097,7 +1127,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n             transaction.SetFlags(TEvTxProxy::TEvProposeTransaction::FlagVolatile);\n         }\n \n-        NDataIntegrity::LogIntegrityTrails(\"PlannedTx\", Request.UserTraceId, TxId, {}, TlsActivationContext->AsActorContext());\n+        NDataIntegrity::LogIntegrityTrails(\"PlannedTx\", \"\", Request.UserTraceId, TxId, {}, TlsActivationContext->AsActorContext());\n \n         LOG_D(\"Execute planned transaction, coordinator: \" << TxCoordinator << \" for \" << affectedSet.size() << \"shards\");\n         Send(MakePipePerNodeCacheID(false), new TEvPipeCache::TEvForward(ev.Release(), TxCoordinator, /* subscribe */ true));\n@@ -1124,6 +1154,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n                 hFunc(NYql::NDq::TEvDqCompute::TEvChannelData, HandleChannelData);\n                 hFunc(TEvKqpExecuter::TEvStreamDataAck, HandleStreamAck);\n                 hFunc(TEvKqp::TEvAbortExecution, HandleExecute);\n+                hFunc(TEvKqpBuffer::TEvError, Handle);\n                 IgnoreFunc(TEvInterconnect::TEvNodeConnected);\n                 default:\n                     UnexpectedEvent(\"ExecuteState\", ev->GetTypeRewrite());\n@@ -1180,6 +1211,11 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n         }\n     }\n \n+    void Handle(TEvKqpBuffer::TEvError::TPtr& ev) {\n+        auto& msg = *ev->Get();\n+        TBase::HandleAbortExecution(msg.StatusCode, msg.Issues, false);\n+    }\n+\n     void HandleExecute(TEvColumnShard::TEvProposeTransactionResult::TPtr& ev) {\n         TEvColumnShard::TEvProposeTransactionResult* res = ev->Get();\n         const ui64 shardId = res->Record.GetOrigin();\n@@ -1238,6 +1274,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n         NYql::TIssues issues;\n         NYql::IssuesFromMessage(res->Record.GetIssues(), issues);\n \n+        NDataIntegrity::LogIntegrityTrails(\"Execute\", Request.UserTraceId, ev, TlsActivationContext->AsActorContext());\n         LOG_D(\"Recv EvWriteResult (execute) from ShardID=\" << shardId\n             << \", Status=\" << NKikimrDataEvents::TEvWriteResult::EStatus_Name(ev->Get()->GetStatus())\n             << \", TxId=\" << ev->Get()->Record.GetTxId()\n@@ -1255,6 +1292,10 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n             Stats->AddDatashardStats(std::move(*res->Record.MutableTxStats()));\n         }\n \n+        if (TxManager) {\n+            TxManager->AddParticipantNode(ev->Sender.NodeId());\n+        }\n+\n         switch (ev->Get()->GetStatus()) {\n             case NKikimrDataEvents::TEvWriteResult::STATUS_UNSPECIFIED: {\n                 YQL_ENSURE(false);\n@@ -1309,6 +1350,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n         TShardState* shardState = ShardStates.FindPtr(shardId);\n         YQL_ENSURE(shardState);\n \n+        NDataIntegrity::LogIntegrityTrails(\"Execute\", Request.UserTraceId, ev, TlsActivationContext->AsActorContext());\n         LOG_D(\"Got propose result, shard: \" << shardId << \", status: \"\n             << NKikimrTxDataShard::TEvProposeTransactionResult_EStatus_Name(res->GetStatus())\n             << \", error: \" << res->GetError());\n@@ -1712,7 +1754,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n \n     void ExecuteDatashardTransaction(ui64 shardId, NKikimrTxDataShard::TKqpTransaction& kqpTx, const bool isOlap)\n     {\n-        YQL_ENSURE(!TxManager);\n+        YQL_ENSURE(ReadOnlyTx || !TxManager);\n         TShardState shardState;\n         shardState.State = ImmediateTx ? TShardState::EState::Executing : TShardState::EState::Preparing;\n         shardState.DatashardState.ConstructInPlace();\n@@ -1799,7 +1841,8 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n                     flags));\n             }\n \n-            NDataIntegrity::LogIntegrityTrails(\"DatashardTx\", Request.UserTraceId, TxId, shardId, TlsActivationContext->AsActorContext());\n+            NDataIntegrity::LogIntegrityTrails(\"DatashardTx\", dataTransaction.GetKqpTransaction().GetLocks().ShortDebugString(), \n+                Request.UserTraceId, TxId, shardId, TlsActivationContext->AsActorContext());\n \n             ResponseEv->Orbit.Fork(evData->Orbit);\n             ev = std::move(evData);\n@@ -1835,7 +1878,8 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n \n         auto traceId = ExecuterSpan.GetTraceId();\n \n-        NDataIntegrity::LogIntegrityTrails(\"EvWriteTx\", Request.UserTraceId, TxId, shardId, TlsActivationContext->AsActorContext());\n+        NDataIntegrity::LogIntegrityTrails(\"EvWriteTx\", evWriteTransaction->Record.GetLocks().ShortDebugString(), \n+            Request.UserTraceId, TxId, shardId, TlsActivationContext->AsActorContext());\n \n         auto shardsToString = [](const auto& shards) {\n             TStringBuilder builder;\n@@ -1974,9 +2018,12 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n         for (ui32 txIdx = 0; txIdx < Request.Transactions.size(); ++txIdx) {\n             auto& tx = Request.Transactions[txIdx];\n             auto scheduledTaskCount = ScheduleByCost(tx, ResourcesSnapshot);\n+            AFL_ENSURE(tx.Body->StagesSize() < (static_cast<ui64>(1) << PriorityTxShift));\n             for (ui32 stageIdx = 0; stageIdx < tx.Body->StagesSize(); ++stageIdx) {\n                 auto& stage = tx.Body->GetStages(stageIdx);\n-                auto& stageInfo = TasksGraph.GetStageInfo(TStageId(txIdx, stageIdx));\n+                const auto stageId = TStageId(txIdx, stageIdx);\n+                auto& stageInfo = TasksGraph.GetStageInfo(stageId);\n+                AFL_ENSURE(stageInfo.Id == stageId);\n \n                 if (stageInfo.Meta.ShardKind == NSchemeCache::TSchemeCacheRequest::KindAsyncIndexTable) {\n                     TMaybe<TString> error;\n@@ -2279,6 +2326,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n             switch (ev->GetTypeRewrite()) {\n                 hFunc(NLongTxService::TEvLongTxService::TEvAcquireReadSnapshotResult, Handle);\n                 hFunc(TEvKqp::TEvAbortExecution, HandleAbortExecution);\n+                hFunc(TEvKqpBuffer::TEvError, Handle);\n                 default:\n                     UnexpectedEvent(\"WaitSnapshotState\", ev->GetTypeRewrite());\n             }\ndiff --git a/ydb/core/kqp/executer_actor/kqp_executer_impl.h b/ydb/core/kqp/executer_actor/kqp_executer_impl.h\nindex 0c498d0562fc..120c2fa4a11a 100644\n--- a/ydb/core/kqp/executer_actor/kqp_executer_impl.h\n+++ b/ydb/core/kqp/executer_actor/kqp_executer_impl.h\n@@ -70,6 +70,7 @@ using EExecType = TEvKqpExecuter::TEvTxResponse::EExecutionType;\n \n const ui64 MaxTaskSize = 48_MB;\n constexpr ui64 PotentialUnsigned64OverflowLimit = (std::numeric_limits<ui64>::max() >> 1);\n+constexpr ui64 PriorityTxShift = 32;\n \n std::pair<TString, TString> SerializeKqpTasksParametersForOlap(const TStageInfo& stageInfo, const TTask& task);\n \n@@ -264,6 +265,9 @@ class TKqpExecuterBase : public TActor<TDerived> {\n         for (auto& [shardId, nodeId] : ShardIdToNodeId) {\n             ShardsOnNode[nodeId].push_back(shardId);\n             ParticipantNodes.emplace(nodeId);\n+            if (TxManager) {\n+                TxManager->AddParticipantNode(nodeId);\n+            }\n         }\n \n         if (IsDebugLogEnabled()) {\n@@ -568,7 +572,6 @@ class TKqpExecuterBase : public TActor<TDerived> {\n         }\n \n         if (BufferActorId && Request.LocksOp == ELocksOp::Rollback) {\n-            YQL_ENSURE(Request.Transactions.empty());\n             static_cast<TDerived*>(this)->Finalize();\n             return;\n         }\n@@ -762,15 +765,22 @@ class TKqpExecuterBase : public TActor<TDerived> {\n     void HandleAbortExecution(TEvKqp::TEvAbortExecution::TPtr& ev) {\n         auto& msg = ev->Get()->Record;\n         NYql::TIssues issues = ev->Get()->GetIssues();\n-        LOG_D(\"Got EvAbortExecution, status: \" << NYql::NDqProto::StatusIds_StatusCode_Name(msg.GetStatusCode())\n+        HandleAbortExecution(msg.GetStatusCode(), ev->Get()->GetIssues(), ev->Sender != Target);\n+    }\n+\n+    void HandleAbortExecution(\n+            NYql::NDqProto::StatusIds::StatusCode statusCode, \n+            const NYql::TIssues& issues,\n+            const bool sessionSender) {\n+        LOG_D(\"Got EvAbortExecution, status: \" << NYql::NDqProto::StatusIds_StatusCode_Name(statusCode)\n             << \", message: \" << issues.ToOneLineString());\n-        auto statusCode = NYql::NDq::DqStatusToYdbStatus(msg.GetStatusCode());\n-        if (statusCode == Ydb::StatusIds::INTERNAL_ERROR) {\n+        auto ydbStatusCode = NYql::NDq::DqStatusToYdbStatus(statusCode);\n+        if (ydbStatusCode == Ydb::StatusIds::INTERNAL_ERROR) {\n             InternalError(issues);\n-        } else if (statusCode == Ydb::StatusIds::TIMEOUT) {\n-            TimeoutError(ev->Sender, issues);\n+        } else if (ydbStatusCode == Ydb::StatusIds::TIMEOUT) {\n+            TimeoutError(sessionSender, issues);\n         } else {\n-            RuntimeError(NYql::NDq::DqStatusToYdbStatus(msg.GetStatusCode()), issues);\n+            RuntimeError(NYql::NDq::DqStatusToYdbStatus(statusCode), issues);\n         }\n     }\n \n@@ -964,7 +974,7 @@ class TKqpExecuterBase : public TActor<TDerived> {\n             auto readSettings = ExtractReadSettings(op, stageInfo, HolderFactory(), TypeEnv());\n             task.Meta.Reads.ConstructInPlace();\n             task.Meta.Reads->emplace_back(std::move(readInfo));\n-            task.Meta.ReadInfo.Reverse = readSettings.Reverse;\n+            task.Meta.ReadInfo.SetSorting(readSettings.GetSorting());\n             task.Meta.Type = TTaskMeta::TTaskType::Compute;\n \n             FillSecureParamsFromStage(task.Meta.SecureParams, stage);\n@@ -1019,6 +1029,8 @@ class TKqpExecuterBase : public TActor<TDerived> {\n                 settings.SetLockMode(*TasksGraph.GetMeta().LockMode);\n             }\n \n+            settings.SetPriority((task.StageId.TxId << PriorityTxShift) + settings.GetPriority());\n+\n             output.SinkSettings.ConstructInPlace();\n             output.SinkSettings->PackFrom(settings);\n         } else {\n@@ -1479,18 +1491,17 @@ class TKqpExecuterBase : public TActor<TDerived> {\n         }\n     }\n \n-    void FillReadInfo(TTaskMeta& taskMeta, ui64 itemsLimit, bool reverse, bool sorted) const\n+    void FillReadInfo(TTaskMeta& taskMeta, ui64 itemsLimit, const NYql::ERequestSorting sorting) const\n     {\n         if (taskMeta.Reads && !taskMeta.Reads.GetRef().empty()) {\n             // Validate parameters\n             YQL_ENSURE(taskMeta.ReadInfo.ItemsLimit == itemsLimit);\n-            YQL_ENSURE(taskMeta.ReadInfo.Reverse == reverse);\n+            YQL_ENSURE(taskMeta.ReadInfo.GetSorting() == sorting);\n             return;\n         }\n \n         taskMeta.ReadInfo.ItemsLimit = itemsLimit;\n-        taskMeta.ReadInfo.Reverse = reverse;\n-        taskMeta.ReadInfo.Sorted = sorted;\n+        taskMeta.ReadInfo.SetSorting(sorting);\n         taskMeta.ReadInfo.ReadType = TTaskMeta::TReadInfo::EReadType::Rows;\n     }\n \n@@ -1564,7 +1575,7 @@ class TKqpExecuterBase : public TActor<TDerived> {\n             readInfo.ShardId = shardId;\n         }\n \n-        FillReadInfo(meta, readSettings.ItemsLimit, readSettings.Reverse, readSettings.Sorted);\n+        FillReadInfo(meta, readSettings.ItemsLimit, readSettings.GetSorting());\n         if (op.GetTypeCase() == NKqpProto::TKqpPhyTableOperation::kReadOlapRange) {\n             FillOlapReadInfo(meta, readSettings.ResultType, op.GetReadOlapRange());\n         }\n@@ -1698,7 +1709,7 @@ class TKqpExecuterBase : public TActor<TDerived> {\n                 stageInfo.Meta.SkipNullKeys.assign(op.GetReadRange().GetSkipNullKeys().begin(),\n                                                    op.GetReadRange().GetSkipNullKeys().end());\n                 // not supported for scan queries\n-                YQL_ENSURE(!readSettings.Reverse);\n+                YQL_ENSURE(!readSettings.IsReverse());\n             }\n \n             for (auto&& i: partitions) {\n@@ -1712,11 +1723,11 @@ class TKqpExecuterBase : public TActor<TDerived> {\n                 }\n             }\n \n-            if (!AppData()->FeatureFlags.GetEnableSeparationComputeActorsFromRead() || (!isOlapScan && readSettings.Sorted)) {\n+            if (!AppData()->FeatureFlags.GetEnableSeparationComputeActorsFromRead() || (!isOlapScan && readSettings.IsSorted())) {\n                 for (auto&& pair : nodeShards) {\n                     auto& shardsInfo = pair.second;\n                     for (auto&& shardInfo : shardsInfo) {\n-                        auto& task = AssignScanTaskToShard(stageInfo, shardInfo.ShardId, nodeTasks, assignedShardsCount, readSettings.Sorted, isOlapScan);\n+                        auto& task = AssignScanTaskToShard(stageInfo, shardInfo.ShardId, nodeTasks, assignedShardsCount, readSettings.IsSorted(), isOlapScan);\n                         MergeReadInfoToTaskMeta(task.Meta, shardInfo.ShardId, shardInfo.KeyReadRanges, readSettings,\n                             columns, op, /*isPersistentScan*/ true);\n                     }\n@@ -1725,7 +1736,7 @@ class TKqpExecuterBase : public TActor<TDerived> {\n                 for (const auto& pair : nodeTasks) {\n                     for (const auto& taskIdx : pair.second) {\n                         auto& task = TasksGraph.GetTask(taskIdx);\n-                        task.Meta.SetEnableShardsSequentialScan(readSettings.Sorted);\n+                        task.Meta.SetEnableShardsSequentialScan(readSettings.IsSorted());\n                         PrepareScanMetaForUsage(task.Meta, keyTypes);\n                         BuildSinks(stage, task);\n                     }\n@@ -1877,7 +1888,7 @@ class TKqpExecuterBase : public TActor<TDerived> {\n         ReplyErrorAndDie(status, &issues);\n     }\n \n-    void TimeoutError(TActorId abortSender, NYql::TIssues issues) {\n+    void TimeoutError(bool sessionSender, NYql::TIssues issues) {\n         if (AlreadyReplied) {\n             LOG_E(\"Timeout when we already replied - not good\" << Endl << TBackTrace().PrintToString() << Endl);\n             return;\n@@ -1901,7 +1912,7 @@ class TKqpExecuterBase : public TActor<TDerived> {\n         NYql::IssuesToMessage(issues, ResponseEv->Record.MutableResponse()->MutableIssues());\n \n         // TEvAbortExecution can come from either ComputeActor or SessionActor (== Target).\n-        if (abortSender != Target) {\n+        if (!sessionSender) {\n             auto abortEv = MakeHolder<TEvKqp::TEvAbortExecution>(status, issues);\n             this->Send(Target, abortEv.Release());\n         }\ndiff --git a/ydb/core/kqp/executer_actor/kqp_executer_stats.cpp b/ydb/core/kqp/executer_actor/kqp_executer_stats.cpp\nindex 360c39ffde3a..60dae26fb9df 100644\n--- a/ydb/core/kqp/executer_actor/kqp_executer_stats.cpp\n+++ b/ydb/core/kqp/executer_actor/kqp_executer_stats.cpp\n@@ -836,7 +836,10 @@ void TQueryExecutionStats::AddComputeActorStats(ui32 /* nodeId */, NYql::NDqProt\n         // TODO(ilezhankin): investigate - for some reason `task.FinishTimeMs` may be large (or small?)\n         //      enough to result in an enormous duration - triggering the \"long tasks\" mode.\n \n-        auto taskDuration = TDuration::MilliSeconds(task.GetFinishTimeMs() - task.GetStartTimeMs());\n+        auto taskDuration = TDuration::MilliSeconds(\n+            task.GetStartTimeMs() != 0 && task.GetFinishTimeMs() >= task.GetStartTimeMs()\n+            ? task.GetFinishTimeMs() - task.GetStartTimeMs()\n+            : 0);\n         auto& longestTaskDuration = LongestTaskDurations[task.GetStageId()];\n         if (taskDuration > Max(collectLongTaskStatsTimeout, longestTaskDuration)) {\n             CollectStatsByLongTasks = true;\n@@ -982,7 +985,10 @@ void TQueryExecutionStats::AddDatashardStats(NYql::NDqProto::TDqComputeActorStat\n \n         // checking whether the task is long\n \n-        auto taskDuration = TDuration::MilliSeconds(task.GetFinishTimeMs() - task.GetStartTimeMs());\n+        auto taskDuration = TDuration::MilliSeconds(\n+            task.GetStartTimeMs() != 0 && task.GetFinishTimeMs() >= task.GetStartTimeMs()\n+            ? task.GetFinishTimeMs() - task.GetStartTimeMs()\n+            : 0);\n         auto& longestTaskDuration = LongestTaskDurations[task.GetStageId()];\n         if (taskDuration > Max(collectLongTaskStatsTimeout, longestTaskDuration)) {\n             CollectStatsByLongTasks = true;\n@@ -1045,7 +1051,7 @@ void TQueryExecutionStats::AddBufferStats(NYql::NDqProto::TDqTaskStats&& taskSta\n         tableAggr->SetWriteRows(tableAggr->GetWriteRows() + table.GetWriteRows());\n         tableAggr->SetWriteBytes(tableAggr->GetWriteBytes() + table.GetWriteBytes());\n         tableAggr->SetEraseRows(tableAggr->GetEraseRows() + table.GetEraseRows());\n-        tableAggr->SetAffectedPartitions(table.GetAffectedPartitions());\n+        tableAggr->SetAffectedPartitions(tableAggr->GetAffectedPartitions() + table.GetAffectedPartitions());\n     }\n }\n \ndiff --git a/ydb/core/kqp/executer_actor/kqp_partition_helper.cpp b/ydb/core/kqp/executer_actor/kqp_partition_helper.cpp\nindex d7bb8faf2fc9..e0acc8b98b41 100644\n--- a/ydb/core/kqp/executer_actor/kqp_partition_helper.cpp\n+++ b/ydb/core/kqp/executer_actor/kqp_partition_helper.cpp\n@@ -1017,19 +1017,28 @@ TPhysicalShardReadSettings ExtractReadSettings(const NKqpProto::TKqpPhyTableOper\n     switch(operation.GetTypeCase()){\n         case NKqpProto::TKqpPhyTableOperation::kReadRanges: {\n             readSettings.ItemsLimit = ExtractItemsLimit(stageInfo, operation.GetReadRanges().GetItemsLimit(), holderFactory, typeEnv);\n-            readSettings.Reverse = operation.GetReadRanges().GetReverse();\n+            if (operation.GetReadRanges().GetReverse()) {\n+                readSettings.SetSorting(ERequestSorting::DESC);\n+            }\n             break;\n         }\n \n         case NKqpProto::TKqpPhyTableOperation::kReadRange: {\n             readSettings.ItemsLimit = ExtractItemsLimit(stageInfo, operation.GetReadRange().GetItemsLimit(), holderFactory, typeEnv);\n-            readSettings.Reverse = operation.GetReadRange().GetReverse();\n+            if (operation.GetReadRange().GetReverse()) {\n+                readSettings.SetSorting(ERequestSorting::DESC);\n+            }\n             break;\n         }\n \n         case NKqpProto::TKqpPhyTableOperation::kReadOlapRange: {\n-            readSettings.Sorted = operation.GetReadOlapRange().GetSorted();\n-            readSettings.Reverse = operation.GetReadOlapRange().GetReverse();\n+            if (operation.GetReadOlapRange().GetReverse()) {\n+                readSettings.SetSorting(ERequestSorting::DESC);\n+            } else if (operation.GetReadOlapRange().GetSorted()) {\n+                readSettings.SetSorting(ERequestSorting::ASC);\n+            } else {\n+                readSettings.SetSorting(ERequestSorting::NONE);\n+            }\n             readSettings.ItemsLimit = ExtractItemsLimit(stageInfo, operation.GetReadOlapRange().GetItemsLimit(), holderFactory, typeEnv);\n             NKikimrMiniKQL::TType minikqlProtoResultType;\n             ConvertYdbTypeToMiniKQLType(operation.GetReadOlapRange().GetResultType(), minikqlProtoResultType);\ndiff --git a/ydb/core/kqp/executer_actor/kqp_partition_helper.h b/ydb/core/kqp/executer_actor/kqp_partition_helper.h\nindex c3d54b17faab..03a1679436e6 100644\n--- a/ydb/core/kqp/executer_actor/kqp_partition_helper.h\n+++ b/ydb/core/kqp/executer_actor/kqp_partition_helper.h\n@@ -2,7 +2,7 @@\n \n #include \"kqp_tasks_graph.h\"\n \n-\n+#include <ydb/core/kqp/common/kqp_yql.h>\n #include <yql/essentials/minikql/computation/mkql_computation_node_holders.h>\n \n #include <util/generic/variant.h>\n@@ -26,15 +26,12 @@ class TShardInfoWithId: public TShardInfo {\n     ui64 ShardId;\n     TShardInfoWithId(const ui64 shardId, TShardInfo&& base)\n         : TShardInfo(std::move(base))\n-        , ShardId(shardId)\n-    {\n+        , ShardId(shardId) {\n \n     }\n };\n \n-struct TPhysicalShardReadSettings {\n-    bool Sorted = true;\n-    bool Reverse = false;\n+struct TPhysicalShardReadSettings: public NYql::TSortingOperator<NYql::ERequestSorting::ASC> {\n     ui64 ItemsLimit = 0;\n     NKikimr::NMiniKQL::TType* ResultType = nullptr;\n };\ndiff --git a/ydb/core/kqp/executer_actor/kqp_planner.cpp b/ydb/core/kqp/executer_actor/kqp_planner.cpp\nindex 592a57590add..5e862f5b8116 100644\n--- a/ydb/core/kqp/executer_actor/kqp_planner.cpp\n+++ b/ydb/core/kqp/executer_actor/kqp_planner.cpp\n@@ -105,6 +105,7 @@ TKqpPlanner::TKqpPlanner(TKqpPlanner::TArgs&& args)\n     , ArrayBufferMinFillPercentage(args.ArrayBufferMinFillPercentage)\n     , VerboseMemoryLimitException(args.VerboseMemoryLimitException)\n {\n+    Y_UNUSED(MkqlMemoryLimit);\n     if (GUCSettings) {\n         SerializedGUCSettings = GUCSettings->SerializeToString();\n     }\ndiff --git a/ydb/core/kqp/executer_actor/kqp_tasks_graph.cpp b/ydb/core/kqp/executer_actor/kqp_tasks_graph.cpp\nindex 1824280f9adb..8dd771747072 100644\n--- a/ydb/core/kqp/executer_actor/kqp_tasks_graph.cpp\n+++ b/ydb/core/kqp/executer_actor/kqp_tasks_graph.cpp\n@@ -859,7 +859,7 @@ void FillTaskMeta(const TStageInfo& stageInfo, const TTask& task, NYql::NDqProto\n                     protoColumn->SetName(column.Name);\n                 }\n                 protoReadMeta->SetItemsLimit(task.Meta.ReadInfo.ItemsLimit);\n-                protoReadMeta->SetReverse(task.Meta.ReadInfo.Reverse);\n+                protoReadMeta->SetReverse(task.Meta.ReadInfo.IsReverse());\n             }\n         }\n         if (task.Meta.Writes) {\n@@ -930,7 +930,8 @@ void FillTaskMeta(const TStageInfo& stageInfo, const TTask& task, NYql::NDqProto\n         YQL_ENSURE(!task.Meta.Writes);\n \n         if (!task.Meta.Reads->empty()) {\n-            protoTaskMeta.SetReverse(task.Meta.ReadInfo.Reverse);\n+            protoTaskMeta.SetReverse(task.Meta.ReadInfo.IsReverse());\n+            protoTaskMeta.SetOptionalSorting((ui32)task.Meta.ReadInfo.GetSorting());\n             protoTaskMeta.SetItemsLimit(task.Meta.ReadInfo.ItemsLimit);\n             if (task.Meta.HasEnableShardsSequentialScan()) {\n                 protoTaskMeta.SetEnableShardsSequentialScan(task.Meta.GetEnableShardsSequentialScanUnsafe());\ndiff --git a/ydb/core/kqp/executer_actor/kqp_tasks_graph.h b/ydb/core/kqp/executer_actor/kqp_tasks_graph.h\nindex 87be6dfae907..e74ff181b706 100644\n--- a/ydb/core/kqp/executer_actor/kqp_tasks_graph.h\n+++ b/ydb/core/kqp/executer_actor/kqp_tasks_graph.h\n@@ -2,6 +2,7 @@\n \n #include <ydb/core/kqp/common/kqp_resolve.h>\n #include <ydb/core/kqp/common/kqp_user_request_context.h>\n+#include <ydb/core/kqp/common/kqp_yql.h>\n #include <ydb/core/kqp/gateway/kqp_gateway.h>\n #include <ydb/core/scheme/scheme_tabledefs.h>\n #include <ydb/core/tx/scheme_cache/scheme_cache.h>\n@@ -222,14 +223,13 @@ struct TTaskMeta {\n         std::set<TString> ParameterNames;\n     };\n \n-    struct TReadInfo {\n+    struct TReadInfo: public NYql::TSortingOperator<NYql::ERequestSorting::NONE> {\n+    public:\n         enum class EReadType {\n             Rows,\n             Blocks\n         };\n         ui64 ItemsLimit = 0;\n-        bool Reverse = false;\n-        bool Sorted = false;\n         EReadType ReadType = EReadType::Rows;\n         TKqpOlapProgram OlapProgram;\n         TVector<NScheme::TTypeInfo> ResultColumnsTypes;\ndiff --git a/ydb/core/kqp/expr_nodes/kqp_expr_nodes.json b/ydb/core/kqp/expr_nodes/kqp_expr_nodes.json\nindex 3f1efc86bad2..9f2b033f353b 100644\n--- a/ydb/core/kqp/expr_nodes/kqp_expr_nodes.json\n+++ b/ydb/core/kqp/expr_nodes/kqp_expr_nodes.json\n@@ -679,7 +679,8 @@\n             \"Children\": [\n                 {\"Index\": 0, \"Name\": \"Type\", \"Type\": \"TExprBase\"},\n                 {\"Index\": 1, \"Name\": \"Columns\", \"Type\": \"TCoAtomList\"},\n-                {\"Index\": 2, \"Name\": \"Lambda\", \"Type\": \"TCoLambda\"}\n+                {\"Index\": 2, \"Name\": \"Parameters\", \"Type\": \"TExprList\"},\n+                {\"Index\": 3, \"Name\": \"Lambda\", \"Type\": \"TCoLambda\"}\n             ]\n         },\n         {\ndiff --git a/ydb/core/kqp/gateway/kqp_ic_gateway.cpp b/ydb/core/kqp/gateway/kqp_ic_gateway.cpp\nindex 24e93ab246d9..e785ddbcc1d8 100644\n--- a/ydb/core/kqp/gateway/kqp_ic_gateway.cpp\n+++ b/ydb/core/kqp/gateway/kqp_ic_gateway.cpp\n@@ -722,9 +722,6 @@ namespace {\n }\n \n class TKikimrIcGateway : public IKqpGateway {\n-private:\n-    using TNavigate = NSchemeCache::TSchemeCacheNavigate;\n-\n public:\n     TKikimrIcGateway(const TString& cluster, NKikimrKqp::EQueryType queryType, const TString& database, const TString& databaseId, std::shared_ptr<IKqpTableMetadataLoader>&& metadataLoader,\n         TActorSystem* actorSystem, ui32 nodeId, TKqpRequestCounters::TPtr counters, const NKikimrConfig::TQueryServiceConfig& queryServiceConfig)\n@@ -914,6 +911,48 @@ class TKikimrIcGateway : public IKqpGateway {\n         return tablePromise.GetFuture();\n     }\n \n+    TFuture<TGenericResult> AlterDatabase(const TString& cluster, const NYql::TAlterDatabaseSettings& settings) override {\n+        using TRequest = TEvTxUserProxy::TEvProposeTransaction;\n+\n+        try {\n+            if (!CheckCluster(cluster)) {\n+                return InvalidCluster<TGenericResult>(cluster);\n+            }\n+\n+            auto alterDatabasePromise = NewPromise<TGenericResult>();\n+\n+            auto ev = MakeHolder<TRequest>();\n+\n+            ev->Record.SetDatabaseName(Database);\n+            if (UserToken) {\n+                ev->Record.SetUserToken(UserToken->GetSerializedToken());\n+            }\n+\n+            const auto& [dirname, basename] = NSchemeHelpers::SplitPathByDirAndBaseNames(settings.DatabasePath);\n+\n+            NKikimrSchemeOp::TModifyScheme* modifyScheme = ev->Record.MutableTransaction()->MutableModifyScheme();\n+            modifyScheme->SetOperationType(NKikimrSchemeOp::ESchemeOpModifyACL);\n+            modifyScheme->SetWorkingDir(dirname);\n+            modifyScheme->MutableModifyACL()->SetNewOwner(settings.Owner.value());\n+            modifyScheme->MutableModifyACL()->SetName(basename);\n+\n+            auto condition = modifyScheme->AddApplyIf();\n+            condition->AddPathTypes(NKikimrSchemeOp::EPathType::EPathTypeSubDomain);\n+            condition->AddPathTypes(NKikimrSchemeOp::EPathType::EPathTypeExtSubDomain);\n+\n+            SendSchemeRequest(ev.Release()).Apply(\n+                [alterDatabasePromise](const TFuture<TGenericResult>& future) mutable {\n+                    alterDatabasePromise.SetValue(future.GetValue());\n+                }\n+            );\n+\n+            return alterDatabasePromise.GetFuture();\n+        }\n+        catch (yexception& e) {\n+            return MakeFuture(ResultFromException<TGenericResult>(e));\n+        }\n+    }\n+\n     TFuture<TGenericResult> CreateColumnTable(NYql::TKikimrTableMetadataPtr metadata,\n             bool createDir, bool existingOk) override {\n         Y_UNUSED(metadata);\n@@ -1437,8 +1476,8 @@ class TKikimrIcGateway : public IKqpGateway {\n \n             SendSchemeRequest(ev.Release()).Apply(\n                 [alterUserPromise](const TFuture<TGenericResult>& future) mutable {\n-                alterUserPromise.SetValue(future.GetValue());\n-            }\n+                    alterUserPromise.SetValue(future.GetValue());\n+                }\n             );\n \n             return alterUserPromise.GetFuture();\ndiff --git a/ydb/core/kqp/host/kqp_gateway_proxy.cpp b/ydb/core/kqp/host/kqp_gateway_proxy.cpp\nindex 0e614df185fc..d1f52070882e 100644\n--- a/ydb/core/kqp/host/kqp_gateway_proxy.cpp\n+++ b/ydb/core/kqp/host/kqp_gateway_proxy.cpp\n@@ -439,6 +439,18 @@ bool FillColumnTableSchema(NKikimrSchemeOp::TColumnTableSchema& schema, const T&\n         auto columnIt = metadata.Columns.find(name);\n         Y_ENSURE(columnIt != metadata.Columns.end());\n \n+        if (columnIt->second.IsDefaultFromLiteral()) {\n+            code = Ydb::StatusIds::BAD_REQUEST;\n+            error = TStringBuilder() << \"Default values are not supported in column tables\";\n+            return false;\n+        }\n+\n+        if (columnIt->second.IsDefaultFromSequence()) {\n+            code = Ydb::StatusIds::BAD_REQUEST;\n+            error = TStringBuilder() << \"Default sequences are not supported in column tables\";\n+            return false;\n+        }\n+\n         NKikimrSchemeOp::TOlapColumnDescription& columnDesc = *schema.AddColumns();\n         columnDesc.SetName(columnIt->second.Name);\n         columnDesc.SetType(columnIt->second.Type);\n@@ -624,6 +636,38 @@ class TKqpGatewayProxy : public IKikimrGateway {\n         return Gateway->LoadTableMetadata(cluster, table, settings);\n     }\n \n+    TFuture<TGenericResult> AlterDatabase(const TString& cluster, const TAlterDatabaseSettings& settings) override {\n+        CHECK_PREPARED_DDL(AlterDatabase);\n+\n+        if (IsPrepare()) {\n+            auto alterDatabasePromise = NewPromise<TGenericResult>();\n+\n+            const auto& [dirname, basename] = NSchemeHelpers::SplitPathByDirAndBaseNames(settings.DatabasePath);\n+\n+            NKikimrSchemeOp::TModifyScheme schemeTx;\n+            schemeTx.SetOperationType(NKikimrSchemeOp::ESchemeOpModifyACL);\n+            schemeTx.SetWorkingDir(dirname);\n+            schemeTx.MutableModifyACL()->SetNewOwner(settings.Owner.value());\n+            schemeTx.MutableModifyACL()->SetName(basename);\n+\n+            auto condition = schemeTx.AddApplyIf();\n+            condition->AddPathTypes(NKikimrSchemeOp::EPathType::EPathTypeSubDomain);\n+            condition->AddPathTypes(NKikimrSchemeOp::EPathType::EPathTypeExtSubDomain);\n+\n+            auto& phyQuery = *SessionCtx->Query().PreparingQuery->MutablePhysicalQuery();\n+            auto& phyTx = *phyQuery.AddTransactions();\n+            phyTx.SetType(NKqpProto::TKqpPhyTx::TYPE_SCHEME);\n+\n+            phyTx.MutableSchemeOperation()->MutableModifyPermissions()->Swap(&schemeTx);\n+            TGenericResult result;\n+            result.SetSuccess();\n+            alterDatabasePromise.SetValue(result);\n+            return alterDatabasePromise.GetFuture();\n+        } else {\n+            return Gateway->AlterDatabase(cluster, settings);\n+        }\n+    }\n+\n     TFuture<TGenericResult> CreateTable(TKikimrTableMetadataPtr metadata, bool createDir, bool existingOk, bool replaceIfExists) override {\n         Y_UNUSED(replaceIfExists);\n         CHECK_PREPARED_DDL(CreateTable);\ndiff --git a/ydb/core/kqp/host/kqp_runner.cpp b/ydb/core/kqp/host/kqp_runner.cpp\nindex 81ea7ec9df6c..2c11d6ad2a87 100644\n--- a/ydb/core/kqp/host/kqp_runner.cpp\n+++ b/ydb/core/kqp/host/kqp_runner.cpp\n@@ -23,6 +23,7 @@\n #include <yql/essentials/core/yql_opt_proposed_by_data.h>\n \n #include <ydb/library/yql/providers/dq/common/yql_dq_settings.h>\n+#include <ydb/library/yql/providers/dq/opt/dqs_opt.h>\n \n #include <util/generic/is_in.h>\n \n@@ -278,7 +279,7 @@ class TKqpRunner : public IKqpRunner {\n         auto preparedExplainTransformer = CreateKqpExplainPreparedTransformer(\n             Gateway, Cluster, TransformCtx, &funcRegistry, *typesCtx, OptimizeCtx);\n \n-        auto physicalOptimizeTransformer = CreateKqpQueryBlocksTransformer(TTransformationPipeline(typesCtx)\n+        auto physicalOptimizePipeline = TTransformationPipeline(typesCtx)\n             .AddServiceTransformers()\n             .Add(Log(\"PhysicalOptimize\"), \"LogPhysicalOptimize\")\n             .AddPreTypeAnnotation()\n@@ -294,7 +295,13 @@ class TKqpRunner : public IKqpRunner {\n             .Add(CreateKqpStatisticsTransformer(OptimizeCtx, *typesCtx, Config, Pctx), \"Statistics\")\n             .Add(CreateKqpLogOptTransformer(OptimizeCtx, *typesCtx, Config), \"LogicalOptimize\")\n             .Add(CreateLogicalDataProposalsInspector(*typesCtx), \"ProvidersLogicalOptimize\")\n-            .Add(CreateKqpPhyOptTransformer(OptimizeCtx, *typesCtx, Config), \"KqpPhysicalOptimize\")\n+            .Add(CreateKqpPhyOptTransformer(OptimizeCtx, *typesCtx, Config), \"KqpPhysicalOptimize\");\n+\n+        if (sessionCtx->Config().UseBlockReader.Get().GetOrElse(false)) {\n+            physicalOptimizePipeline.Add(NDqs::CreateDqsRewritePhyBlockReadOnDqIntegrationTransformer(*typesCtx), \"ReplaceWideReadsWithBlock\");\n+        }\n+\n+        auto physicalOptimizeTransformer = CreateKqpQueryBlocksTransformer(physicalOptimizePipeline\n             .Add(CreatePhysicalDataProposalsInspector(*typesCtx), \"ProvidersPhysicalOptimize\")\n             .Add(CreateKqpFinalizingOptTransformer(OptimizeCtx), \"FinalizingOptimize\")\n             .Add(CreateKqpQueryPhasesTransformer(), \"QueryPhases\")\ndiff --git a/ydb/core/kqp/host/kqp_type_ann.cpp b/ydb/core/kqp/host/kqp_type_ann.cpp\nindex d1ea8fa1c562..2c4aed2bcc73 100644\n--- a/ydb/core/kqp/host/kqp_type_ann.cpp\n+++ b/ydb/core/kqp/host/kqp_type_ann.cpp\n@@ -1077,7 +1077,7 @@ TStatus AnnotateOlapFilter(const TExprNode::TPtr& node, TExprContext& ctx) {\n }\n \n TStatus AnnotateOlapApply(const TExprNode::TPtr& node, TExprContext& ctx) {\n-    if (!EnsureArgsCount(*node, 3U, ctx)) {\n+    if (!EnsureArgsCount(*node, 4U, ctx)) {\n         return TStatus::Error;\n     }\n \n@@ -1097,7 +1097,8 @@ TStatus AnnotateOlapApply(const TExprNode::TPtr& node, TExprContext& ctx) {\n     }\n \n     const auto structType = argsType->Cast<TStructExprType>();\n-    TTypeAnnotationNode::TListType argsTypes(columns->ChildrenSize());\n+    std::vector<const NYql::TTypeAnnotationNode*> argsTypes(columns->ChildrenSize());\n+\n     for (auto i = 0U; i < argsTypes.size(); ++i) {\n         if (const auto argType = structType->FindItemType(columns->Child(i)->Content()))\n             argsTypes[i] = argType;\n@@ -1109,6 +1110,22 @@ TStatus AnnotateOlapApply(const TExprNode::TPtr& node, TExprContext& ctx) {\n         }\n     }\n \n+    TExprList parameters = TExprList(node->Child(TKqpOlapApply::idx_Parameters));\n+\n+    for(auto expr: parameters) {\n+        if (!EnsureArgsCount(*expr.Ptr(), 2U, ctx)) {\n+            return TStatus::Error;\n+        }\n+\n+        TCoParameter param = TMaybeNode<TCoParameter>(expr.Ptr()).Cast();\n+        const auto& paramType = expr.Ptr()->Child(TCoParameter::idx_Type);\n+        if (!EnsureType(*paramType, ctx)) {\n+            return TStatus::Error;\n+        }\n+\n+        argsTypes.push_back(paramType->GetTypeAnn()->Cast<TTypeExprType>()->GetType());\n+    }\n+\n     if (!EnsureLambda(node->Tail(), ctx)) {\n         return TStatus::Error;\n     }\ndiff --git a/ydb/core/kqp/node_service/kqp_node_service.cpp b/ydb/core/kqp/node_service/kqp_node_service.cpp\nindex eacc6bdb39d6..77748787004f 100644\n--- a/ydb/core/kqp/node_service/kqp_node_service.cpp\n+++ b/ydb/core/kqp/node_service/kqp_node_service.cpp\n@@ -457,7 +457,6 @@ class TKqpNodeService : public TActorBootstrapped<TKqpNodeService> {\n \n         ptr->InFlightMemoryLimitPerActorBytes = settings.GetInFlightMemoryLimitPerActorBytes();\n         ptr->MemoryLimitPerMessageBytes = settings.GetMemoryLimitPerMessageBytes();\n-        ptr->MaxBatchesPerMessage = settings.GetMaxBatchesPerMessage();\n \n         ptr->StartRetryDelay = TDuration::MilliSeconds(settings.GetStartRetryDelayMs());\n         ptr->MaxRetryDelay = TDuration::MilliSeconds(settings.GetMaxRetryDelayMs());\ndiff --git a/ydb/core/kqp/opt/kqp_opt_kql.cpp b/ydb/core/kqp/opt/kqp_opt_kql.cpp\nindex 1eae92aabd71..be7616830f5a 100644\n--- a/ydb/core/kqp/opt/kqp_opt_kql.cpp\n+++ b/ydb/core/kqp/opt/kqp_opt_kql.cpp\n@@ -217,11 +217,10 @@ TCoAtomList BuildUpsertInputColumns(const TCoAtomList& inputColumns,\n }\n \n std::pair<TExprBase, TCoAtomList> BuildWriteInput(const TKiWriteTable& write, const TKikimrTableDescription& table,\n-    const TCoAtomList& inputColumns, const TCoAtomList& autoIncrement, const bool isSink,\n+    const TCoAtomList& inputColumns, const TCoAtomList& autoIncrement, const bool /*isSink*/,\n     TPositionHandle pos, TExprContext& ctx)\n {\n     auto input = write.Input();\n-    const bool isWriteReplace = (GetTableOp(write) == TYdbOperation::Replace) && !isSink;\n \n     TCoAtomList inputCols = BuildUpsertInputColumns(inputColumns, autoIncrement, pos, ctx);\n \n@@ -229,7 +228,9 @@ std::pair<TExprBase, TCoAtomList> BuildWriteInput(const TKiWriteTable& write, co\n         input = BuildKqlSequencer(input, table, inputCols, autoIncrement, pos, ctx);\n     }\n \n+    const bool isWriteReplace = (GetTableOp(write) == TYdbOperation::Replace);\n     if (isWriteReplace) {\n+        // TODO: don't need it for sinks (can be disabled when secondary indexes are supported inside write actor)\n         std::tie(input, inputCols) = CreateRowsToReplace(input, inputCols, table, write.Pos(), ctx);\n     }\n \ndiff --git a/ydb/core/kqp/opt/kqp_query_plan.cpp b/ydb/core/kqp/opt/kqp_query_plan.cpp\nindex 95cf7bdf1734..c0c859ef0413 100644\n--- a/ydb/core/kqp/opt/kqp_query_plan.cpp\n+++ b/ydb/core/kqp/opt/kqp_query_plan.cpp\n@@ -65,13 +65,12 @@ std::string RemoveForbiddenChars(std::string s) {\n     return NYql::IsUtf8(s)? s: \"Non-UTF8 string\";\n }\n \n-struct TTableRead {\n+struct TTableRead: public NYql::TSortingOperator<NYql::ERequestSorting::ASC> {\n     EPlanTableReadType Type = EPlanTableReadType::Unspecified;\n     TVector<TString> LookupBy;\n     TVector<TString> ScanBy;\n     TVector<TString> Columns;\n     TMaybe<TString> Limit;\n-    bool Reverse = false;\n };\n \n struct TTableWrite {\n@@ -795,7 +794,7 @@ class TxPlanSerializer {\n         AddOperator(stagePlanNode, \"Source\", op);\n     }\n \n-    void Visit(const TDqSink& sink, TQueryPlanNode& stagePlanNode) {\n+    void Visit(const TDqSink& sink, const TDqStageBase& stage, TQueryPlanNode& stagePlanNode) {\n         // Federated providers\n         TOperator op;\n         TCoDataSink dataSink = sink.DataSink().Cast<TCoDataSink>();\n@@ -811,7 +810,50 @@ class TxPlanSerializer {\n \n         // Common settings that can be overwritten by provider\n         op.Properties[\"SinkType\"] = dataSinkCategory;\n-        if (auto cluster = TryGetCluster(dataSink)) {\n+        if (dataSinkCategory == NYql::KqpTableSinkName) {\n+            auto settings = sink.Settings().Cast<TKqpTableSinkSettings>();\n+\n+            TTableWrite writeInfo;\n+            if (settings.Mode().StringValue() == \"replace\") {\n+                op.Properties[\"Name\"] = \"Replace\";\n+                writeInfo.Type = EPlanTableWriteType::MultiReplace;\n+            } else if (settings.Mode().StringValue() == \"upsert\" || settings.Mode().StringValue().empty()) {\n+                op.Properties[\"Name\"] = \"Upsert\";\n+                writeInfo.Type = EPlanTableWriteType::MultiUpsert;\n+            } else if (settings.Mode().StringValue() == \"insert\") {\n+                op.Properties[\"Name\"] = \"Insert\";\n+                writeInfo.Type = EPlanTableWriteType::MultiInsert;\n+            } else if (settings.Mode().StringValue() == \"delete\") {\n+                op.Properties[\"Name\"] = \"Delete\";\n+                writeInfo.Type = EPlanTableWriteType::MultiErase;\n+            } else if (settings.Mode().StringValue() == \"update\") {\n+                op.Properties[\"Name\"] = \"Update\";\n+                writeInfo.Type = EPlanTableWriteType::MultiUpdate;\n+            } else {\n+                YQL_ENSURE(false, \"Unsupported sink mode\");\n+            }\n+\n+            const auto tablePath = settings.Table().Path().StringValue();\n+            const auto& tableData = SerializerCtx.TablesData->GetTable(SerializerCtx.Cluster, tablePath);\n+            op.Properties[\"Table\"] = tableData.RelativePath ? *tableData.RelativePath : tablePath;\n+            op.Properties[\"Path\"] = tablePath;\n+\n+            if (writeInfo.Type != EPlanTableWriteType::MultiErase) {\n+                const auto& tupleType = stage.Ref().GetTypeAnn()->Cast<TTupleExprType>();\n+                YQL_ENSURE(tupleType);\n+                YQL_ENSURE(tupleType->GetSize() == 1);\n+                const auto& listType = tupleType->GetItems()[0]->Cast<TListExprType>();\n+                YQL_ENSURE(listType);\n+                const auto& structType = listType->GetItemType()->Cast<TStructExprType>();\n+                YQL_ENSURE(structType);\n+                for (const auto& item : structType->GetItems()) {\n+                    writeInfo.Columns.push_back(TString(item->GetName()));\n+                }\n+            }\n+\n+            SerializerCtx.Tables[tablePath].Writes.push_back(writeInfo);\n+            stagePlanNode.NodeInfo[\"Tables\"].AppendValue(op.Properties[\"Table\"]);\n+        } else if (auto cluster = TryGetCluster(dataSink)) {\n             TString dataSource = RemovePathPrefix(std::move(*cluster));\n             op.Properties[\"ExternalDataSource\"] = dataSource;\n             op.Properties[\"Name\"] = TStringBuilder() << \"Write \" << dataSource;\n@@ -896,7 +938,7 @@ class TxPlanSerializer {\n             if (auto outputs = expr.Cast<TDqStageBase>().Outputs()) {\n                 for (auto output : outputs.Cast()) {\n                     if (auto sink = output.Maybe<TDqSink>()) {\n-                        Visit(sink.Cast(), stagePlanNode);\n+                        Visit(sink.Cast(), expr.Cast<TDqStageBase>(), stagePlanNode);\n                     }\n                 }\n             }\n@@ -1871,9 +1913,11 @@ class TxPlanSerializer {\n             readInfo.Limit = limit;\n             op.Properties[\"ReadLimit\"] = limit;\n         }\n-        if (settings.Reverse) {\n-            readInfo.Reverse = true;\n+        readInfo.SetSorting(settings.GetSorting());\n+        if (settings.GetSorting() == ERequestSorting::DESC) {\n             op.Properties[\"Reverse\"] = true;\n+        } else if (settings.GetSorting() == ERequestSorting::ASC) {\n+            op.Properties[\"Reverse\"] = false;\n         }\n \n         if (settings.SequentialInFlight) {\n@@ -1963,7 +2007,7 @@ void WriteCommonTablesInfo(NJsonWriter::TBuf& writer, TMap<TString, TTableInfo>&\n                 if (read.Limit) {\n                     writer.WriteKey(\"limit\").WriteString(*read.Limit);\n                 }\n-                if (read.Reverse) {\n+                if (read.IsReverse()) {\n                     writer.WriteKey(\"reverse\").WriteBool(true);\n                 }\n \ndiff --git a/ydb/core/kqp/opt/kqp_query_plan.h b/ydb/core/kqp/opt/kqp_query_plan.h\nindex 6facebe4574b..d1ac3f73020d 100644\n--- a/ydb/core/kqp/opt/kqp_query_plan.h\n+++ b/ydb/core/kqp/opt/kqp_query_plan.h\n@@ -27,6 +27,9 @@ enum class EPlanTableWriteType {\n     MultiUpsert,\n     Erase,\n     MultiErase,\n+    MultiReplace,\n+    MultiInsert,\n+    MultiUpdate,\n };\n \n /*\ndiff --git a/ydb/core/kqp/opt/logical/kqp_opt_log_extract.cpp b/ydb/core/kqp/opt/logical/kqp_opt_log_extract.cpp\nindex 2507d3b31c86..f9c03d710d1f 100644\n--- a/ydb/core/kqp/opt/logical/kqp_opt_log_extract.cpp\n+++ b/ydb/core/kqp/opt/logical/kqp_opt_log_extract.cpp\n@@ -157,6 +157,10 @@ TExprBase KqpApplyExtractMembersToReadOlapTable(TExprBase node, TExprContext& ct\n \n     auto read = node.Cast<TKqpReadOlapTableRangesBase>();\n \n+    if (read.Columns().Size() == 1) {\n+        return node;\n+    }\n+\n     auto usedColumns = GetUsedColumns(read, read.Columns(), parentsMap, allowMultiUsage, ctx);\n     if (!usedColumns) {\n         return node;\ndiff --git a/ydb/core/kqp/opt/logical/kqp_opt_log_indexes.cpp b/ydb/core/kqp/opt/logical/kqp_opt_log_indexes.cpp\nindex 258012939b0a..bcc70a1d961a 100644\n--- a/ydb/core/kqp/opt/logical/kqp_opt_log_indexes.cpp\n+++ b/ydb/core/kqp/opt/logical/kqp_opt_log_indexes.cpp\n@@ -150,7 +150,7 @@ bool CanUseVectorIndex(const TIndexDescription& indexDesc, const TExprBase& lamb\n     // TODO(mbkkt) We need to account top.Count(), but not clear what to if it's value is runtime?\n     auto checkMember = [&] (const TExprBase& expr) {\n         auto member = expr.Maybe<TCoMember>();\n-        return member && member.Cast().Name().Value() == indexDesc.KeyColumns[0];\n+        return member && member.Cast().Name().Value() == indexDesc.KeyColumns.back();\n     };\n     auto checkUdf = [&] (const TExprBase& expr, bool checkMembers) {\n         auto apply = expr.Maybe<TCoApply>();\n@@ -452,7 +452,7 @@ TExprBase DoRewriteTopSortOverKMeansTree(\n             auto apply = newLambda.Body().Cast<TCoApply>();\n             for (auto arg : apply.Args()) {\n                 auto oldMember = arg.Maybe<TCoMember>();\n-                if (oldMember && oldMember.Cast().Name().Value() == indexDesc.KeyColumns[0]) {\n+                if (oldMember && oldMember.Cast().Name().Value() == indexDesc.KeyColumns.back()) {\n                     auto newMember = Build<TCoMember>(ctx, pos)\n                         .Name().Build(NTableIndex::NTableVectorKmeansTreeIndex::CentroidColumn)\n                         .Struct(oldMember.Cast().Struct())\ndiff --git a/ydb/core/kqp/opt/physical/kqp_opt_phy.cpp b/ydb/core/kqp/opt/physical/kqp_opt_phy.cpp\nindex e52c87424631..b760a26ae8ea 100644\n--- a/ydb/core/kqp/opt/physical/kqp_opt_phy.cpp\n+++ b/ydb/core/kqp/opt/physical/kqp_opt_phy.cpp\n@@ -124,7 +124,10 @@ class TKqpPhysicalOptTransformer : public TOptimizeTransformerBase {\n         AddHandler(1, &TCoTake::Match, HNDL(PropagatePrecomuteTake<true>));\n         AddHandler(1, &TCoFlatMap::Match, HNDL(PropagatePrecomuteFlatmap<true>));\n         AddHandler(1, &TKqpWriteConstraint::Match, HNDL(BuildWriteConstraint<true>));\n+        AddHandler(1, &TKqpWriteConstraint::Match, HNDL(BuildWriteConstraint<true>));\n+        AddHandler(1, &TKqpReadOlapTableRanges::Match, HNDL(AddColumnForEmptyColumnsOlapRead));\n \n+        \n         AddHandler(2, &TDqStage::Match, HNDL(RewriteKqpReadTable));\n         AddHandler(2, &TDqStage::Match, HNDL(RewriteKqpLookupTable));\n         AddHandler(2, &TKqlUpsertRows::Match, HNDL(RewriteReturningUpsert));\n@@ -525,6 +528,13 @@ class TKqpPhysicalOptTransformer : public TOptimizeTransformerBase {\n         return output;\n     }\n \n+    TMaybeNode<TExprBase> AddColumnForEmptyColumnsOlapRead(TExprBase node, TExprContext& ctx)\n+    {\n+        TExprBase output = KqpAddColumnForEmptyColumnsOlapRead(node, ctx, KqpCtx);\n+        DumpAppliedRule(\"AddColumnForEmptyColumnsOlapRead\", node.Ptr(), output.Ptr(), ctx);\n+        return output;\n+    }\n+\n     TMaybeNode<TExprBase> DropUnordered(TExprBase node, TExprContext& ctx) {\n         TExprBase output = node;\n         if (node.Maybe<TCoUnorderedBase>().Input().Maybe<TDqCnUnionAll>()) {\ndiff --git a/ydb/core/kqp/opt/physical/kqp_opt_phy_limit.cpp b/ydb/core/kqp/opt/physical/kqp_opt_phy_limit.cpp\nindex f89cf425ad02..69ed31b6004a 100644\n--- a/ydb/core/kqp/opt/physical/kqp_opt_phy_limit.cpp\n+++ b/ydb/core/kqp/opt/physical/kqp_opt_phy_limit.cpp\n@@ -122,7 +122,9 @@ TExprBase KqpApplyLimitToOlapReadTable(TExprBase node, TExprContext& ctx, const\n         return node; // already set\n     }\n     if (direction == ESortDirection::Reverse) {\n-        settings.SetReverse();\n+        settings.SetSorting(ERequestSorting::DESC);\n+    } else if (direction == ESortDirection::Forward) {\n+        settings.SetSorting(ERequestSorting::ASC);\n     }\n \n     auto keySelector = topSort.KeySelectorLambda();\ndiff --git a/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_agg.cpp b/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_agg.cpp\nindex 592f77fb6e5d..c061e0ac579f 100644\n--- a/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_agg.cpp\n+++ b/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_agg.cpp\n@@ -245,11 +245,6 @@ TExprBase KqpPushDownOlapGroupByKeysImpl(TExprBase node, TExprContext& ctx, bool\n }\n \n TExprBase KqpPushDownOlapGroupByKeys(TExprBase node, TExprContext& ctx, const TKqpOptimizeContext& kqpCtx) {\n-    if (NKikimr::NSsa::RuntimeVersion < 2U) {\n-        // We introduced aggregate pushdown in v2 of SSA program\n-        return node;\n-    }\n-\n     if (!kqpCtx.Config->HasOptEnableOlapPushdown() || !kqpCtx.Config->HasOptEnableOlapProvideComputeSharding()) {\n         return node;\n     }\n@@ -271,11 +266,6 @@ TExprBase KqpPushDownOlapGroupByKeys(TExprBase node, TExprContext& ctx, const TK\n \n TExprBase KqpPushOlapAggregate(TExprBase node, TExprContext& ctx, const TKqpOptimizeContext& kqpCtx)\n {\n-    if (NKikimr::NSsa::RuntimeVersion < 2U) {\n-        // We introduced aggregate pushdown in v2 of SSA program\n-        return node;\n-    }\n-\n     if (!kqpCtx.Config->HasOptEnableOlapPushdown()) {\n         return node;\n     }\n@@ -373,11 +363,6 @@ TExprBase KqpPushOlapAggregate(TExprBase node, TExprContext& ctx, const TKqpOpti\n \n TExprBase KqpPushOlapLength(TExprBase node, TExprContext& ctx, const TKqpOptimizeContext& kqpCtx)\n {\n-    if (NKikimr::NSsa::RuntimeVersion < 2U) {\n-        // We introduced aggregate pushdown in v2 of SSA program\n-        return node;\n-    }\n-\n     if (!kqpCtx.Config->HasOptEnableOlapPushdown()) {\n         return node;\n     }\ndiff --git a/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_filter.cpp b/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_filter.cpp\nindex 13ea4fb1c257..542137581e62 100644\n--- a/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_filter.cpp\n+++ b/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_filter.cpp\n@@ -24,6 +24,32 @@ static const std::unordered_set<std::string> SecondLevelFilters = {\n     \"ends_with\"\n };\n \n+static TMaybeNode<TExprBase> CombinePredicatesWithAnd(const TVector<TExprBase>& conjuncts, TExprContext& ctx, TPositionHandle pos, bool useOlapAnd, bool trueForEmpty) {\n+    if (conjuncts.empty()) {\n+        return trueForEmpty ? TMaybeNode<TExprBase>{MakeBool<true>(pos, ctx)} : TMaybeNode<TExprBase>{};\n+    } else if (conjuncts.size() == 1) {\n+        return conjuncts[0];\n+    } else {\n+        if (useOlapAnd) {\n+            return Build<TKqpOlapAnd>(ctx, pos)\n+                .Add(conjuncts)\n+            .Done();\n+        } else {\n+            return Build<TCoAnd>(ctx, pos)\n+                .Add(conjuncts)\n+            .Done();\n+        }\n+    }\n+}\n+\n+static TMaybeNode<TExprBase> CombinePredicatesWithAnd(const TVector<TOLAPPredicateNode>& conjuncts, TExprContext& ctx, TPositionHandle pos, bool useOlapAnd, bool trueForEmpty) {\n+    TVector<TExprBase> exprs;\n+    for(const auto& c: conjuncts) {\n+        exprs.emplace_back(c.ExprNode);\n+    }\n+    return CombinePredicatesWithAnd(exprs, ctx, pos, useOlapAnd, trueForEmpty);\n+}\n+\n struct TFilterOpsLevels {\n     TFilterOpsLevels(const TMaybeNode<TExprBase>& firstLevel, const TMaybeNode<TExprBase>& secondLevel)\n         : FirstLevelOps(firstLevel)\n@@ -69,6 +95,23 @@ struct TFilterOpsLevels {\n     }\n \n \n+    static TFilterOpsLevels Merge(TVector<TFilterOpsLevels> predicates, TExprContext& ctx, TPositionHandle pos) {\n+        TVector<TExprBase> predicatesFirstLevel;\n+        TVector<TExprBase> predicatesSecondLevel;\n+        for (const auto& p: predicates) {\n+            if (p.FirstLevelOps.IsValid()) {\n+                predicatesFirstLevel.emplace_back(p.FirstLevelOps.Cast());\n+            }\n+            if (p.SecondLevelOps.IsValid()) {\n+                predicatesSecondLevel.emplace_back(p.SecondLevelOps.Cast());\n+            }\n+        }\n+        return {\n+            CombinePredicatesWithAnd(predicatesFirstLevel, ctx, pos, true, false),\n+            CombinePredicatesWithAnd(predicatesSecondLevel, ctx, pos, true, false),\n+        };\n+    }\n+\n     TMaybeNode<TExprBase> FirstLevelOps;\n     TMaybeNode<TExprBase> SecondLevelOps;\n };\n@@ -139,7 +182,7 @@ std::vector<std::pair<TExprBase, TExprBase>> ExtractComparisonParameters(const T\n TMaybeNode<TExprBase> ComparisonPushdown(const std::vector<std::pair<TExprBase, TExprBase>>& parameters, const TCoCompare& predicate, TExprContext& ctx, TPositionHandle pos);\n \n [[maybe_unused]]\n-TMaybeNode<TExprBase> YqlCoalescePushdown(const TCoCoalesce& coalesce, const TExprNode& argument, TExprContext& ctx) {\n+TMaybeNode<TExprBase> CoalescePushdown(const TCoCoalesce& coalesce, const TExprNode& argument, TExprContext& ctx) {\n     if (const auto params = ExtractBinaryFunctionParameters(coalesce, argument, ctx, coalesce.Pos())) {\n         return Build<TKqpOlapFilterBinaryOp>(ctx, coalesce.Pos())\n                 .Operator().Value(\"??\", TNodeFlags::Default).Build()\n@@ -171,11 +214,6 @@ TMaybeNode<TExprBase> YqlApplyPushdown(const TExprBase& apply, const TExprNode&\n         return false;\n     });\n \n-    // Temporary fix for https://st.yandex-team.ru/KIKIMR-22216\n-    if (parameters.size()!=0) {\n-        return nullptr;\n-    }\n-\n     const auto members = FindNodes(apply.Ptr(), [&argument] (const TExprNode::TPtr& node) {\n         if (const auto maybeMember = TMaybeNode<TCoMember>(node))\n             return maybeMember.Cast().Struct().Raw() == &argument;\n@@ -188,10 +226,18 @@ TMaybeNode<TExprBase> YqlApplyPushdown(const TExprBase& apply, const TExprNode&\n     arguments.reserve(members.size());\n     for (const auto& member : members) {\n         columns.emplace_back(member->TailPtr());\n-        arguments.emplace_back(ctx.NewArgument(member->Pos(), columns.back()->Content()));\n+        TString argumentName = \"members_\" + TString(columns.back()->Content());\n+        arguments.emplace_back(ctx.NewArgument(member->Pos(), TStringBuf(argumentName)));\n         replacements.emplace(member.Get(), arguments.back());\n     }\n \n+    for(const auto& pptr : parameters) {\n+        TCoParameter parameter = TMaybeNode<TCoParameter>(pptr).Cast();\n+        TString argumentName = \"parameter_\" + TString(parameter.Name().StringValue());\n+        arguments.emplace_back(ctx.NewArgument(pptr->Pos(), TStringBuf(argumentName)));\n+        replacements.emplace(pptr.Get(), arguments.back());\n+    }\n+\n     // Temporary fix for https://st.yandex-team.ru/KIKIMR-22560\n     if (!columns.size()) {\n         return nullptr;\n@@ -200,13 +246,69 @@ TMaybeNode<TExprBase> YqlApplyPushdown(const TExprBase& apply, const TExprNode&\n     return Build<TKqpOlapApply>(ctx, apply.Pos())\n         .Type(ExpandType(argument.Pos(), *argument.GetTypeAnn(), ctx))\n         .Columns().Add(std::move(columns)).Build()\n+        .Parameters().Add(std::move(parameters)).Build()\n         .Lambda(ctx.NewLambda(apply.Pos(), ctx.NewArguments(argument.Pos(), std::move(arguments)), ctx.ReplaceNodes(apply.Ptr(), replacements)))\n         .Done();\n }\n \n+TMaybeNode<TExprBase> JsonExistsPushdown(const TCoJsonExists& jsonExists, TExprContext& ctx, TPositionHandle pos)\n+{\n+    auto columnName = jsonExists.Json().Cast<TCoMember>().Name();\n+    return Build<TKqpOlapJsonExists>(ctx, pos)\n+        .Column(columnName)\n+        .Path(jsonExists.JsonPath().Cast<TCoUtf8>())\n+        .Done();\n+}\n+TMaybeNode<TExprBase> SimplePredicatePushdown(const TCoCompare& predicate, const TExprNode& argument, TExprContext& ctx, TPositionHandle pos)\n+{\n+    const auto parameters = ExtractComparisonParameters(predicate, argument, ctx, pos);\n+    if (parameters.empty()) {\n+        return NullNode;\n+    }\n+\n+    return ComparisonPushdown(parameters, predicate, ctx, pos);\n+}\n+\n+TMaybeNode<TExprBase> SafeCastPredicatePushdown(const TCoFlatMap& inputFlatmap, const TExprNode& argument, TExprContext& ctx, TPositionHandle pos)\n+{\n+    /*\n+     * There are three ways of comparison in following format:\n+     *\n+     * FlatMap (LeftArgument, FlatMap(RightArgument(), Just(Predicate))\n+     *\n+     * Examples:\n+     * FlatMap (SafeCast(), FlatMap(Member(), Just(Comparison))\n+     * FlatMap (Member(), FlatMap(SafeCast(), Just(Comparison))\n+     * FlatMap (SafeCast(), FlatMap(SafeCast(), Just(Comparison))\n+     */\n+    auto left = ConvertComparisonNode(inputFlatmap.Input(), argument, ctx, pos);\n+    if (left.empty()) {\n+        return NullNode;\n+    }\n+\n+    auto flatmap = inputFlatmap.Lambda().Body().Cast<TCoFlatMap>();\n+    auto right = ConvertComparisonNode(flatmap.Input(), argument, ctx, pos);\n+    if (right.empty()) {\n+        return NullNode;\n+    }\n+\n+    auto predicate = flatmap.Lambda().Body().Cast<TCoJust>().Input().Cast<TCoCompare>();\n+\n+    std::vector<std::pair<TExprBase, TExprBase>> parameters;\n+    if (left.size() != right.size()) {\n+        return NullNode;\n+    }\n+\n+    for (ui32 i = 0; i < left.size(); ++i) {\n+        parameters.emplace_back(std::move(std::make_pair(left[i], right[i])));\n+    }\n+\n+    return ComparisonPushdown(parameters, predicate, ctx, pos);\n+}\n+\n+\n std::vector<TExprBase> ConvertComparisonNode(const TExprBase& nodeIn, const TExprNode& argument, TExprContext& ctx, TPositionHandle pos)\n {\n-    std::vector<TExprBase> out;\n     const auto convertNode = [&ctx, &pos, &argument](const TExprBase& node) -> TMaybeNode<TExprBase> {\n         if (node.Maybe<TCoNull>()) {\n             return node;\n@@ -249,6 +351,10 @@ std::vector<TExprBase> ConvertComparisonNode(const TExprBase& nodeIn, const TExp\n             return builder.Done();\n         }\n \n+        if (auto maybeJsonExists = node.Maybe<TCoJsonExists>()) {\n+            return JsonExistsPushdown(maybeJsonExists.Cast(), ctx, pos);\n+        }\n+\n         if (const auto maybeJust = node.Maybe<TCoJust>()) {\n             if (const auto params = ConvertComparisonNode(maybeJust.Cast().Input(), argument, ctx, pos); 1U == params.size()) {\n                 return Build<TKqpOlapFilterUnaryOp>(ctx, node.Pos())\n@@ -262,33 +368,31 @@ std::vector<TExprBase> ConvertComparisonNode(const TExprBase& nodeIn, const TExp\n             return YqlIfPushdown(maybeIf.Cast(), argument, ctx);\n         }\n \n-        if constexpr (NKikimr::NSsa::RuntimeVersion >= 4U) {\n-            if (const auto maybeArithmetic = node.Maybe<TCoBinaryArithmetic>()) {\n-                const auto arithmetic = maybeArithmetic.Cast();\n-                if (const auto params = ExtractBinaryFunctionParameters(arithmetic, argument, ctx, pos)) {\n-                    return Build<TKqpOlapFilterBinaryOp>(ctx, pos)\n-                            .Operator().Value(arithmetic.Ref().Content(), TNodeFlags::Default).Build()\n-                            .Left(params->first)\n-                            .Right(params->second)\n-                            .Done();\n-                }\n+        if (const auto maybeArithmetic = node.Maybe<TCoBinaryArithmetic>()) {\n+            const auto arithmetic = maybeArithmetic.Cast();\n+            if (const auto params = ExtractBinaryFunctionParameters(arithmetic, argument, ctx, pos)) {\n+                return Build<TKqpOlapFilterBinaryOp>(ctx, pos)\n+                        .Operator().Value(arithmetic.Ref().Content(), TNodeFlags::Default).Build()\n+                        .Left(params->first)\n+                        .Right(params->second)\n+                        .Done();\n             }\n+        }\n \n-            if (const auto maybeArithmetic = node.Maybe<TCoUnaryArithmetic>()) {\n-                const auto arithmetic = maybeArithmetic.Cast();\n-                if (const auto params = ConvertComparisonNode(arithmetic.Arg(), argument, ctx, pos); 1U == params.size()) {\n-                    TString oper(arithmetic.Ref().Content());\n-                    YQL_ENSURE(oper.to_lower());\n-                    return Build<TKqpOlapFilterUnaryOp>(ctx, pos)\n-                            .Operator().Value(oper, TNodeFlags::Default).Build()\n-                            .Arg(params.front())\n-                            .Done();\n-                }\n+        if (const auto maybeArithmetic = node.Maybe<TCoUnaryArithmetic>()) {\n+            const auto arithmetic = maybeArithmetic.Cast();\n+            if (const auto params = ConvertComparisonNode(arithmetic.Arg(), argument, ctx, pos); 1U == params.size()) {\n+                TString oper(arithmetic.Ref().Content());\n+                YQL_ENSURE(oper.to_lower());\n+                return Build<TKqpOlapFilterUnaryOp>(ctx, pos)\n+                        .Operator().Value(oper, TNodeFlags::Default).Build()\n+                        .Arg(params.front())\n+                        .Done();\n             }\n+        }\n \n-            if (const auto maybeCoalesce = node.Maybe<TCoCoalesce>()) {\n-                return YqlCoalescePushdown(maybeCoalesce.Cast(), argument, ctx);\n-            }\n+        if (const auto maybeCoalesce = node.Maybe<TCoCoalesce>()) {\n+            return CoalescePushdown(maybeCoalesce.Cast(), argument, ctx);\n         }\n \n         if (const auto maybeCompare = node.Maybe<TCoCompare>()) {\n@@ -297,6 +401,11 @@ std::vector<TExprBase> ConvertComparisonNode(const TExprBase& nodeIn, const TExp\n             }\n         }\n \n+        if (const auto maybeFlatmap = node.Maybe<TCoFlatMap>()) {\n+            return SafeCastPredicatePushdown(maybeFlatmap.Cast(), argument, ctx, pos);\n+        } else if (auto maybePredicate = node.Maybe<TCoCompare>()) {\n+            return SimplePredicatePushdown(maybePredicate.Cast(), argument, ctx, pos);\n+        }\n \n         if constexpr (NKikimr::NSsa::RuntimeVersion >= 5U) {\n             return YqlApplyPushdown(node, argument, ctx);\n@@ -305,36 +414,27 @@ std::vector<TExprBase> ConvertComparisonNode(const TExprBase& nodeIn, const TExp\n         }\n     };\n \n-    // Columns & values may be single element\n-    TMaybeNode<TExprBase> node = convertNode(nodeIn);\n+    if (const auto& list = nodeIn.Maybe<TExprList>()) {\n+        const auto& tuple = list.Cast();\n+        std::vector<TExprBase> out;\n \n-    if (node.IsValid()) {\n-        out.emplace_back(std::move(node.Cast()));\n-        return out;\n-    }\n+        out.reserve(tuple.Size());\n+        for (ui32 i = 0; i < tuple.Size(); ++i) {\n+            TMaybeNode<TExprBase> node = convertNode(tuple.Item(i));\n \n-    // Or columns and values can be Tuple\n-    if (!nodeIn.Maybe<TExprList>()) {\n-        // something unusual found, return empty vector\n-        return out;\n-    }\n-\n-    auto tuple = nodeIn.Cast<TExprList>();\n-\n-    out.reserve(tuple.Size());\n-\n-    for (ui32 i = 0; i < tuple.Size(); ++i) {\n-        TMaybeNode<TExprBase> node = convertNode(tuple.Item(i));\n+            if (!node.IsValid()) {\n+                // Return empty vector\n+                return TVector<TExprBase>();\n+            }\n \n-        if (!node.IsValid()) {\n-            // Return empty vector\n-            return TVector<TExprBase>();\n+            out.emplace_back(node.Cast());\n         }\n-\n-        out.emplace_back(node.Cast());\n+        return out;\n+    } else if (const auto& node = convertNode(nodeIn); node.IsValid()) {\n+        return {node.Cast()};\n+    } else {\n+        return {};\n     }\n-\n-    return out;\n }\n \n TExprBase BuildOneElementComparison(const std::pair<TExprBase, TExprBase>& parameter, const TCoCompare& predicate,\n@@ -375,7 +475,7 @@ TExprBase BuildOneElementComparison(const std::pair<TExprBase, TExprBase>& param\n         compareOperator = \"gt\";\n     } else if (predicate.Maybe<TCoCmpGreaterOrEqual>() && !forceStrictComparison) {\n         compareOperator = \"gte\";\n-    } else if constexpr (NKikimr::NSsa::RuntimeVersion >= 2U) {\n+    } else {\n         // We introduced LIKE pushdown in v2 of SSA program\n         if (predicate.Maybe<TCoCmpStringContains>()) {\n             compareOperator = \"string_contains\";\n@@ -469,16 +569,6 @@ TMaybeNode<TExprBase> ComparisonPushdown(const std::vector<std::pair<TExprBase,\n         .Done();\n }\n \n-TMaybeNode<TExprBase> SimplePredicatePushdown(const TCoCompare& predicate, const TExprNode& argument, TExprContext& ctx, TPositionHandle pos)\n-{\n-    const auto parameters = ExtractComparisonParameters(predicate, argument, ctx, pos);\n-    if (parameters.empty()) {\n-        return NullNode;\n-    }\n-\n-    return ComparisonPushdown(parameters, predicate, ctx, pos);\n-}\n-\n // TODO: Check how to reduce columns if they are not needed. Unfortunately columnshard need columns list\n // for every column present in program even if it is not used in result set.\n //#define ENABLE_COLUMNS_PRUNING\n@@ -511,88 +601,16 @@ template<bool Empty>\n TMaybeNode<TExprBase> ExistsPushdown(const TCoExists& exists, TExprContext& ctx, TPositionHandle pos)\n {\n     const auto columnName = exists.Optional().Cast<TCoMember>().Name();\n-    if constexpr (NSsa::RuntimeVersion >= 4U) {\n-        return Build<TKqpOlapFilterUnaryOp>(ctx, pos)\n-                .Operator().Value(Empty ? \"empty\" : \"exists\", TNodeFlags::Default).Build()\n-                .Arg(columnName)\n-                .Done();\n-    } else {\n-        return Build<TKqpOlapFilterExists>(ctx, pos)\n-            .Column(columnName)\n+    return Build<TKqpOlapFilterUnaryOp>(ctx, pos)\n+            .Operator().Value(Empty ? \"empty\" : \"exists\", TNodeFlags::Default).Build()\n+            .Arg(columnName)\n             .Done();\n-    }\n-}\n-\n-TMaybeNode<TExprBase> JsonExistsPushdown(const TCoJsonExists& jsonExists, TExprContext& ctx, TPositionHandle pos)\n-{\n-    auto columnName = jsonExists.Json().Cast<TCoMember>().Name();\n-    return Build<TKqpOlapJsonExists>(ctx, pos)\n-        .Column(columnName)\n-        .Path(jsonExists.JsonPath().Cast<TCoUtf8>())\n-        .Done();\n-}\n-\n-TMaybeNode<TExprBase> SafeCastPredicatePushdown(const TCoFlatMap& inputFlatmap, const TExprNode& argument, TExprContext& ctx, TPositionHandle pos)\n-{\n-    /*\n-     * There are three ways of comparison in following format:\n-     *\n-     * FlatMap (LeftArgument, FlatMap(RightArgument(), Just(Predicate))\n-     *\n-     * Examples:\n-     * FlatMap (SafeCast(), FlatMap(Member(), Just(Comparison))\n-     * FlatMap (Member(), FlatMap(SafeCast(), Just(Comparison))\n-     * FlatMap (SafeCast(), FlatMap(SafeCast(), Just(Comparison))\n-     */\n-    auto left = ConvertComparisonNode(inputFlatmap.Input(), argument, ctx, pos);\n-    if (left.empty()) {\n-        return NullNode;\n-    }\n-\n-    auto flatmap = inputFlatmap.Lambda().Body().Cast<TCoFlatMap>();\n-    auto right = ConvertComparisonNode(flatmap.Input(), argument, ctx, pos);\n-    if (right.empty()) {\n-        return NullNode;\n-    }\n-\n-    auto predicate = flatmap.Lambda().Body().Cast<TCoJust>().Input().Cast<TCoCompare>();\n-\n-    std::vector<std::pair<TExprBase, TExprBase>> parameters;\n-    if (left.size() != right.size()) {\n-        return NullNode;\n-    }\n-\n-    for (ui32 i = 0; i < left.size(); ++i) {\n-        parameters.emplace_back(std::move(std::make_pair(left[i], right[i])));\n-    }\n-\n-    return ComparisonPushdown(parameters, predicate, ctx, pos);\n-}\n-\n-TMaybeNode<TExprBase> CoalescePushdown(const TCoCoalesce& coalesce, const TExprNode& argument, TExprContext& ctx, TPositionHandle pos)\n-{\n-    if constexpr (NSsa::RuntimeVersion >= 4U) {\n-        if (const auto node = YqlCoalescePushdown(coalesce, argument, ctx)) {\n-            return node;\n-        }\n-    }\n-\n-    auto predicate = coalesce.Predicate();\n-    if (const auto maybeFlatmap = predicate.Maybe<TCoFlatMap>()) {\n-        return SafeCastPredicatePushdown(maybeFlatmap.Cast(), argument, ctx, pos);\n-    } else if (auto maybePredicate = predicate.Maybe<TCoCompare>()) {\n-        return SimplePredicatePushdown(maybePredicate.Cast(), argument, ctx, pos);\n-    } else if (auto maybeJsonExists = predicate.Maybe<TCoJsonExists>()) {\n-        return JsonExistsPushdown(maybeJsonExists.Cast(), ctx, pos);\n-    }\n-\n-    return NullNode;\n }\n \n TFilterOpsLevels PredicatePushdown(const TExprBase& predicate, const TExprNode& argument, TExprContext& ctx, TPositionHandle pos)\n {\n     if (const auto maybeCoalesce = predicate.Maybe<TCoCoalesce>()) {\n-        auto coalescePred = CoalescePushdown(maybeCoalesce.Cast(), argument, ctx, pos);\n+        auto coalescePred = CoalescePushdown(maybeCoalesce.Cast(), argument, ctx);\n         return TFilterOpsLevels(coalescePred);\n     }\n \n@@ -617,10 +635,8 @@ TFilterOpsLevels PredicatePushdown(const TExprBase& predicate, const TExprNode&\n \n     if (const auto maybeNot = predicate.Maybe<TCoNot>()) {\n         const auto notNode = maybeNot.Cast();\n-        if constexpr (NSsa::RuntimeVersion >= 4U) {\n-            if (const auto maybeExists = notNode.Value().Maybe<TCoExists>()) {\n-                return TFilterOpsLevels(ExistsPushdown<true>(maybeExists.Cast(), ctx, pos));\n-            }\n+        if (const auto maybeExists = notNode.Value().Maybe<TCoExists>()) {\n+            return TFilterOpsLevels(ExistsPushdown<true>(maybeExists.Cast(), ctx, pos));\n         }\n         auto pushedFilters = PredicatePushdown(notNode.Value(), argument, ctx, pos);\n         pushedFilters.WrapToNotOp(ctx, pos);\n@@ -684,50 +700,22 @@ TFilterOpsLevels PredicatePushdown(const TExprBase& predicate, const TExprNode&\n     return YqlApplyPushdown(predicate, argument, ctx);\n }\n \n-TOLAPPredicateNode WrapPredicates(const std::vector<TOLAPPredicateNode>& predicates, TExprContext& ctx, TPositionHandle pos) {\n-    if (predicates.empty()) {\n-        return {};\n-    }\n-\n-    if (const auto predicatesSize = predicates.size(); 1U == predicatesSize) {\n-        return predicates.front();\n-    } else {\n-        TOLAPPredicateNode result;\n-        result.Children = predicates;\n-        result.CanBePushed = true;\n-\n-        TVector<NNodes::TExprBase> exprNodes;\n-        exprNodes.reserve(predicatesSize);\n-        for (const auto& pred : predicates) {\n-            exprNodes.emplace_back(pred.ExprNode);\n-            result.CanBePushed &= pred.CanBePushed;\n-        }\n-        result.ExprNode = NNodes::Build<NNodes::TCoAnd>(ctx, pos)\n-            .Add(exprNodes)\n-            .Done().Ptr();\n-        return result;\n-    }\n-}\n-\n-void SplitForPartialPushdown(const TOLAPPredicateNode& predicateTree, TOLAPPredicateNode& predicatesToPush, TOLAPPredicateNode& remainingPredicates,\n-    TExprContext& ctx, TPositionHandle pos)\n+std::pair<TVector<TOLAPPredicateNode>, TVector<TOLAPPredicateNode>> SplitForPartialPushdown(const TOLAPPredicateNode& predicateTree)\n {\n     if (predicateTree.CanBePushed) {\n-        predicatesToPush = predicateTree;\n-        remainingPredicates.ExprNode = MakeBool<true>(pos, ctx);\n-        return;\n+        return {{predicateTree}, {}};\n     }\n \n     if (!TCoAnd::Match(predicateTree.ExprNode.Get())) {\n         // We can partially pushdown predicates from AND operator only.\n         // For OR operator we would need to have several read operators which is not acceptable.\n         // TODO: Add support for NOT(op1 OR op2), because it expands to (!op1 AND !op2).\n-        remainingPredicates = predicateTree;\n-        return;\n+        return {{}, {predicateTree}};\n     }\n \n     bool isFoundNotStrictOp = false;\n-    std::vector<TOLAPPredicateNode> pushable, remaining;\n+    TVector<TOLAPPredicateNode> pushable;\n+    TVector<TOLAPPredicateNode> remaining;\n     for (const auto& predicate : predicateTree.Children) {\n         if (predicate.CanBePushed && !isFoundNotStrictOp) {\n             pushable.emplace_back(predicate);\n@@ -738,8 +726,7 @@ void SplitForPartialPushdown(const TOLAPPredicateNode& predicateTree, TOLAPPredi\n             remaining.emplace_back(predicate);\n         }\n     }\n-    predicatesToPush = WrapPredicates(pushable, ctx, pos);\n-    remainingPredicates = WrapPredicates(remaining, ctx, pos);\n+    return {pushable, remaining};\n }\n \n } // anonymous namespace end\n@@ -763,6 +750,7 @@ TExprBase KqpPushOlapFilter(TExprBase node, TExprContext& ctx, const TKqpOptimiz\n     }\n \n     const auto& lambda = flatmap.Lambda();\n+    const auto& lambdaArg = lambda.Args().Arg(0).Ref();\n \n     YQL_CLOG(TRACE, ProviderKqp) << \"Initial OLAP lambda: \" << KqpExprToPrettyString(lambda, ctx);\n \n@@ -775,55 +763,68 @@ TExprBase KqpPushOlapFilter(TExprBase node, TExprContext& ctx, const TKqpOptimiz\n     auto predicate = optionaIf.Predicate();\n     auto value = optionaIf.Value();\n \n-    if constexpr (NSsa::RuntimeVersion >= 5U) {\n-        TExprNode::TPtr afterPeephole;\n-        bool hasNonDeterministicFunctions;\n-        if (const auto status = PeepHoleOptimizeNode(optionaIf.Ptr(), afterPeephole, ctx, typesCtx, nullptr, hasNonDeterministicFunctions);\n-            status != IGraphTransformer::TStatus::Ok) {\n-            YQL_CLOG(ERROR, ProviderKqp) << \"Peephole OLAP failed.\" << Endl << ctx.IssueManager.GetIssues().ToString();\n-            return node;\n-        }\n-\n-        const TCoIf simplified(std::move(afterPeephole));\n-        predicate = simplified.Predicate();\n-        value = simplified.ThenValue().Cast<TCoJust>().Input();\n-    }\n-\n     TOLAPPredicateNode predicateTree;\n     predicateTree.ExprNode = predicate.Ptr();\n-    const auto& lambdaArg = lambda.Args().Arg(0).Ref();\n-    CollectPredicates(predicate, predicateTree, &lambdaArg, read.Process().Body());\n+    CollectPredicates(predicate, predicateTree, &lambdaArg, read.Process().Body(), false);\n     YQL_ENSURE(predicateTree.IsValid(), \"Collected OLAP predicates are invalid\");\n \n-    TOLAPPredicateNode predicatesToPush, remainingPredicates;\n-    SplitForPartialPushdown(predicateTree, predicatesToPush, remainingPredicates, ctx, node.Pos());\n-    if (!predicatesToPush.IsValid()) {\n-        return node;\n+    auto [pushable, remaining] = SplitForPartialPushdown(predicateTree);\n+    TVector<TFilterOpsLevels> pushedPredicates;\n+    for (const auto& p: pushable) {\n+        pushedPredicates.emplace_back(PredicatePushdown(TExprBase(p.ExprNode), lambdaArg, ctx, node.Pos()));\n     }\n \n-    YQL_ENSURE(predicatesToPush.IsValid(), \"Predicates to push is invalid\");\n-    YQL_ENSURE(remainingPredicates.IsValid(), \"Remaining predicates is invalid\");\n-\n-    const auto pushedFilters = PredicatePushdown(TExprBase(predicatesToPush.ExprNode), lambdaArg, ctx, node.Pos());\n-    // Temporary fix for https://st.yandex-team.ru/KIKIMR-22560\n-    // YQL_ENSURE(pushedFilters.IsValid(), \"Pushed predicate should be always valid!\");\n+    if constexpr (NSsa::RuntimeVersion >= 5U) {\n+        TVector<TOLAPPredicateNode> remainingAfterApply;\n+        for(const auto& p: remaining) {\n+            const auto recoveredOptinalIfForNonPushedDownPredicates = Build<TCoOptionalIf>(ctx, node.Pos())\n+                .Predicate(p.ExprNode)\n+                .Value(value)\n+            .Build();\n+            TExprNode::TPtr afterPeephole;\n+            bool hasNonDeterministicFunctions;\n+            if (const auto status = PeepHoleOptimizeNode(recoveredOptinalIfForNonPushedDownPredicates.Value().Ptr(), afterPeephole, ctx, typesCtx, nullptr, hasNonDeterministicFunctions);\n+                status != IGraphTransformer::TStatus::Ok) {\n+                YQL_CLOG(ERROR, ProviderKqp) << \"Peephole OLAP failed.\" << Endl << ctx.IssueManager.GetIssues().ToString();\n+                return node;\n+            }\n+            const TCoIf simplified(std::move(afterPeephole));\n+            predicate = simplified.Predicate();\n+            value = simplified.ThenValue().Cast<TCoJust>().Input();\n+\n+            TOLAPPredicateNode predicateTree;\n+            predicateTree.ExprNode = predicate.Ptr();\n+            CollectPredicates(predicate, predicateTree, &lambdaArg, read.Process().Body(), true);\n+            YQL_ENSURE(predicateTree.IsValid(), \"Collected OLAP predicates are invalid\");\n+            auto [pushableWithApply, remaining] = SplitForPartialPushdown(predicateTree);\n+            for (const auto& p: pushableWithApply) {\n+               pushedPredicates.emplace_back(PredicatePushdown(TExprBase(p.ExprNode), lambdaArg, ctx, node.Pos()));\n+            }\n+            remainingAfterApply.insert(remainingAfterApply.end(), remaining.begin(), remaining.end());\n+        }\n+        remaining = std::move(remainingAfterApply);\n+    }\n \n-    if (!pushedFilters.IsValid()) {\n+    if (pushedPredicates.empty()) {\n         return node;\n     }\n \n+    const auto& pushedFilter = TFilterOpsLevels::Merge(pushedPredicates, ctx, node.Pos());\n+\n+    const auto remainingFilter = CombinePredicatesWithAnd(remaining, ctx, node.Pos(), false, true);\n+\n     TMaybeNode<TExprBase> olapFilter;\n-    if (pushedFilters.FirstLevelOps.IsValid()) {    \n+    if (pushedFilter.FirstLevelOps.IsValid()) {\n         olapFilter = Build<TKqpOlapFilter>(ctx, node.Pos())\n             .Input(read.Process().Body())\n-            .Condition(pushedFilters.FirstLevelOps.Cast())\n+            .Condition(pushedFilter.FirstLevelOps.Cast())\n             .Done();\n     }\n \n-    if (pushedFilters.SecondLevelOps.IsValid()) {\n+    if (pushedFilter.SecondLevelOps.IsValid()) {\n         olapFilter = Build<TKqpOlapFilter>(ctx, node.Pos())\n             .Input(olapFilter.IsValid() ? olapFilter.Cast() : read.Process().Body())\n-            .Condition(pushedFilters.SecondLevelOps.Cast())\n+            .Condition(pushedFilter.SecondLevelOps.Cast())\n             .Done();\n     }\n \n@@ -867,7 +868,7 @@ TExprBase KqpPushOlapFilter(TExprBase node, TExprContext& ctx, const TKqpOptimiz\n             .Args({\"new_arg\"})\n             .Body<TCoOptionalIf>()\n                 .Predicate<TExprApplier>()\n-                    .Apply(TExprBase(remainingPredicates.ExprNode))\n+                    .Apply(remainingFilter.Cast())\n                     .With(lambda.Args().Arg(0), \"new_arg\")\n                     .Build()\n                 .Value<TExprApplier>()\n@@ -882,4 +883,32 @@ TExprBase KqpPushOlapFilter(TExprBase node, TExprContext& ctx, const TKqpOptimiz\n #endif\n }\n \n+TExprBase KqpAddColumnForEmptyColumnsOlapRead(TExprBase node, TExprContext& ctx, const TKqpOptimizeContext& kqpCtx) {\n+    if (!node.Maybe<TKqpReadOlapTableRanges>()) {\n+        return node;\n+    }\n+\n+    auto readOlap = node.Cast<TKqpReadOlapTableRanges>();\n+    if (readOlap.Columns().Size()!=0) {\n+        return node;\n+    }\n+\n+    const auto& tableData = kqpCtx.Tables->ExistingTable(kqpCtx.Cluster, readOlap.Table().Path().Value());\n+    auto keyColumns = tableData.Metadata->KeyColumnNames;\n+\n+    TVector<TExprNode::TPtr> newColumns;\n+    newColumns.push_back(ctx.NewAtom(node.Pos(), keyColumns[0]));\n+\n+    return Build<TKqpReadOlapTableRanges>(ctx, node.Pos())\n+        .Table(readOlap.Table())\n+        .Ranges(readOlap.Ranges())\n+        .Columns()\n+            .Add(newColumns)\n+            .Build()\n+        .Settings(readOlap.Settings())\n+        .ExplainPrompt(readOlap.ExplainPrompt())\n+        .Process(readOlap.Process())\n+        .Done();\n+}\n+\n } // namespace NKikimr::NKqp::NOpt\ndiff --git a/ydb/core/kqp/opt/physical/kqp_opt_phy_rules.h b/ydb/core/kqp/opt/physical/kqp_opt_phy_rules.h\nindex 7128016625dd..587672cb413a 100644\n--- a/ydb/core/kqp/opt/physical/kqp_opt_phy_rules.h\n+++ b/ydb/core/kqp/opt/physical/kqp_opt_phy_rules.h\n@@ -67,6 +67,9 @@ NYql::NNodes::TExprBase KqpPropagatePrecomuteScalarRowset(NYql::NNodes::TExprBas\n NYql::NNodes::TExprBase KqpBuildWriteConstraint(NYql::NNodes::TExprBase node, NYql::TExprContext& ctx,\n     NYql::IOptimizationContext& optCtx, const NYql::TParentsMap& parentsMap, bool allowStageMultiUsage);\n \n+NYql::NNodes::TExprBase KqpAddColumnForEmptyColumnsOlapRead(NYql::NNodes::TExprBase node, NYql::TExprContext& ctx, \n+    const TKqpOptimizeContext& kqpCtx);\n+\n bool AllowFuseJoinInputs(NYql::NNodes::TExprBase node);\n \n bool UseSource(const TKqpOptimizeContext& kqpCtx, const NYql::TKikimrTableDescription& tableDesc);\ndiff --git a/ydb/core/kqp/opt/physical/kqp_opt_phy_sort.cpp b/ydb/core/kqp/opt/physical/kqp_opt_phy_sort.cpp\nindex efa9804fce29..f1630e3bca44 100644\n--- a/ydb/core/kqp/opt/physical/kqp_opt_phy_sort.cpp\n+++ b/ydb/core/kqp/opt/physical/kqp_opt_phy_sort.cpp\n@@ -72,17 +72,13 @@ TExprBase KqpRemoveRedundantSortByPk(TExprBase node, TExprContext& ctx, const TK\n             return node;\n         }\n \n-        if (settings.Reverse) {\n-            return node;\n-        }\n-\n-        settings.SetReverse();\n-        settings.SetSorted();\n-\n+        AFL_ENSURE(settings.GetSorting() == ERequestSorting::NONE);\n+        settings.SetSorting(ERequestSorting::DESC);\n         input = BuildReadNode(input.Pos(), ctx, input, settings);\n     } else if (direction == ESortDirection::Forward) {\n         if (UseSource(kqpCtx, tableDesc)) {\n-            settings.SetSorted();\n+            AFL_ENSURE(settings.GetSorting() == ERequestSorting::NONE);\n+            settings.SetSorting(ERequestSorting::ASC);\n             input = BuildReadNode(input.Pos(), ctx, input, settings);\n         }\n     }\ndiff --git a/ydb/core/kqp/opt/physical/predicate_collector.cpp b/ydb/core/kqp/opt/physical/predicate_collector.cpp\nindex 57fa8b334d05..5e911f1de104 100644\n--- a/ydb/core/kqp/opt/physical/predicate_collector.cpp\n+++ b/ydb/core/kqp/opt/physical/predicate_collector.cpp\n@@ -15,7 +15,7 @@ bool IsSupportedPredicate(const TCoCompare& predicate) {\n     return !predicate.Ref().Content().starts_with(\"Aggr\");\n }\n \n-bool IsSupportedDataType(const TCoDataCtor& node) {\n+bool IsSupportedDataType(const TCoDataCtor& node, bool allowOlapApply) {\n     if (node.Maybe<TCoBool>() ||\n         node.Maybe<TCoFloat>() ||\n         node.Maybe<TCoDouble>() ||\n@@ -32,13 +32,11 @@ bool IsSupportedDataType(const TCoDataCtor& node) {\n         return true;\n     }\n \n-    if constexpr (NKikimr::NSsa::RuntimeVersion >= 4U) {\n-        if (node.Maybe<TCoTimestamp>()) {\n-            return true;\n-        }\n+    if (node.Maybe<TCoTimestamp>()) {\n+        return true;\n     }\n \n-    if constexpr (NKikimr::NSsa::RuntimeVersion >= 5U) {\n+    if (allowOlapApply) {\n         if (node.Maybe<TCoDate32>() ||  node.Maybe<TCoDatetime64>() || node.Maybe<TCoTimestamp64>() || node.Maybe<TCoInterval64>()) {\n             return true;\n         }\n@@ -88,17 +86,17 @@ bool IsMemberColumn(const TExprBase& node, const TExprNode* lambdaArg) {\n     return false;\n }\n \n-bool IsGoodTypeForArithmeticPushdown(const TTypeAnnotationNode& type) {\n+bool IsGoodTypeForArithmeticPushdown(const TTypeAnnotationNode& type, bool allowOlapApply) {\n     const auto fatures = NUdf::GetDataTypeInfo(RemoveOptionality(type).Cast<TDataExprType>()->GetSlot()).Features;\n     return NUdf::EDataTypeFeatures::NumericType & fatures\n-        || (NKikimr::NSsa::RuntimeVersion >= 5U && (NUdf::EDataTypeFeatures::BigDateType & fatures) && !(NUdf::EDataTypeFeatures::TzDateType & fatures));\n+        || (allowOlapApply && (NUdf::EDataTypeFeatures::BigDateType & fatures) && !(NUdf::EDataTypeFeatures::TzDateType & fatures));\n }\n \n-bool IsGoodTypeForComparsionPushdown(const TTypeAnnotationNode& type) {\n+bool IsGoodTypeForComparsionPushdown(const TTypeAnnotationNode& type, bool allowOlapApply) {\n     const auto fatures = NUdf::GetDataTypeInfo(RemoveOptionality(type).Cast<TDataExprType>()->GetSlot()).Features;\n     return (NUdf::EDataTypeFeatures::CanCompare  & fatures)\n         && (((NUdf::EDataTypeFeatures::NumericType | NUdf::EDataTypeFeatures::StringType) & fatures) ||\n-            (NKikimr::NSsa::RuntimeVersion >= 5U && (NUdf::EDataTypeFeatures::BigDateType & fatures) && !(NUdf::EDataTypeFeatures::TzDateType & fatures)));\n+            (allowOlapApply && (NUdf::EDataTypeFeatures::BigDateType & fatures) && !(NUdf::EDataTypeFeatures::TzDateType & fatures)));\n }\n \n [[maybe_unused]]\n@@ -141,8 +139,8 @@ bool AbstractTreeCanBePushed(const TExprBase& expr, const TExprNode* ) {\n     return true;\n }\n \n-bool CheckExpressionNodeForPushdown(const TExprBase& node, const TExprNode* lambdaArg) {\n-    if constexpr (NKikimr::NSsa::RuntimeVersion >= 5U) {\n+bool CheckExpressionNodeForPushdown(const TExprBase& node, const TExprNode* lambdaArg, bool allowOlapApply) {\n+    if (allowOlapApply) {\n         if (node.Maybe<TCoJust>() || node.Maybe<TCoCoalesce>()) {\n             return true;\n         }\n@@ -158,7 +156,7 @@ bool CheckExpressionNodeForPushdown(const TExprBase& node, const TExprNode* lamb\n     if (const auto maybeSafeCast = node.Maybe<TCoSafeCast>()) {\n         return IsSupportedCast(maybeSafeCast.Cast());\n     } else if (const auto maybeData = node.Maybe<TCoDataCtor>()) {\n-        return IsSupportedDataType(maybeData.Cast());\n+        return IsSupportedDataType(maybeData.Cast(), allowOlapApply);\n     } else if (const auto maybeMember = node.Maybe<TCoMember>()) {\n         return IsMemberColumn(maybeMember.Cast(), lambdaArg);\n     } else if (const auto maybeJsonValue = node.Maybe<TCoJsonValue>()) {\n@@ -168,23 +166,21 @@ bool CheckExpressionNodeForPushdown(const TExprBase& node, const TExprNode* lamb\n         return true;\n     }\n \n-    if constexpr (NKikimr::NSsa::RuntimeVersion >= 4U) {\n-        if (const auto op = node.Maybe<TCoUnaryArithmetic>()) {\n-            return CheckExpressionNodeForPushdown(op.Cast().Arg(), lambdaArg) && IsGoodTypeForArithmeticPushdown(*op.Cast().Ref().GetTypeAnn());\n-        } else if (const auto op = node.Maybe<TCoBinaryArithmetic>()) {\n-            return CheckExpressionNodeForPushdown(op.Cast().Left(), lambdaArg) && CheckExpressionNodeForPushdown(op.Cast().Right(), lambdaArg)\n-                && IsGoodTypeForArithmeticPushdown(*op.Cast().Ref().GetTypeAnn()) && !op.Cast().Maybe<TCoAggrAdd>();\n-        }\n+    if (const auto op = node.Maybe<TCoUnaryArithmetic>()) {\n+        return CheckExpressionNodeForPushdown(op.Cast().Arg(), lambdaArg, allowOlapApply) && IsGoodTypeForArithmeticPushdown(*op.Cast().Ref().GetTypeAnn(), allowOlapApply);\n+    } else if (const auto op = node.Maybe<TCoBinaryArithmetic>()) {\n+        return CheckExpressionNodeForPushdown(op.Cast().Left(), lambdaArg, allowOlapApply) && CheckExpressionNodeForPushdown(op.Cast().Right(), lambdaArg, allowOlapApply)\n+            && IsGoodTypeForArithmeticPushdown(*op.Cast().Ref().GetTypeAnn(), allowOlapApply) && !op.Cast().Maybe<TCoAggrAdd>();\n     }\n \n-    if constexpr (NKikimr::NSsa::RuntimeVersion >= 5U) {\n+    if (allowOlapApply) {\n         return AbstractTreeCanBePushed(node, lambdaArg);\n     }\n \n     return false;\n }\n \n-bool IsGoodTypesForPushdownCompare(const TTypeAnnotationNode& typeOne, const TTypeAnnotationNode& typeTwo) {\n+bool IsGoodTypesForPushdownCompare(const TTypeAnnotationNode& typeOne, const TTypeAnnotationNode& typeTwo, bool allowOlapApply) {\n     const auto& rawOne = RemoveOptionality(typeOne);\n     const auto& rawTwo = RemoveOptionality(typeTwo);\n     if (IsSameAnnotation(rawOne, rawTwo))\n@@ -206,21 +202,21 @@ bool IsGoodTypesForPushdownCompare(const TTypeAnnotationNode& typeOne, const TTy\n             if (size != itemsTwo.size())\n                 return false;\n             for (auto i = 0U; i < size; ++i) {\n-                if (!IsGoodTypesForPushdownCompare(*itemsOne[i], *itemsTwo[i])) {\n+                if (!IsGoodTypesForPushdownCompare(*itemsOne[i], *itemsTwo[i], allowOlapApply)) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n         case ETypeAnnotationKind::Data:\n-            return IsGoodTypeForComparsionPushdown(typeOne) && IsGoodTypeForComparsionPushdown(typeTwo);\n+            return IsGoodTypeForComparsionPushdown(typeOne, allowOlapApply) && IsGoodTypeForComparsionPushdown(typeTwo, allowOlapApply);\n         default:\n             break;\n     }\n     return false;\n }\n \n-bool CheckComparisonParametersForPushdown(const TCoCompare& compare, const TExprNode* lambdaArg, const TExprBase& input) {\n+bool CheckComparisonParametersForPushdown(const TCoCompare& compare, const TExprNode* lambdaArg, const TExprBase& input, bool allowOlapApply) {\n     const auto* inputType = input.Ref().GetTypeAnn();\n     switch (inputType->GetKind()) {\n         case ETypeAnnotationKind::Flow:\n@@ -243,7 +239,7 @@ bool CheckComparisonParametersForPushdown(const TCoCompare& compare, const TExpr\n         return false;\n     }\n \n-    if (!IsGoodTypesForPushdownCompare(*compare.Left().Ref().GetTypeAnn(), *compare.Right().Ref().GetTypeAnn())) {\n+    if (!IsGoodTypesForPushdownCompare(*compare.Left().Ref().GetTypeAnn(), *compare.Right().Ref().GetTypeAnn(), allowOlapApply)) {\n         return false;\n     }\n \n@@ -252,7 +248,7 @@ bool CheckComparisonParametersForPushdown(const TCoCompare& compare, const TExpr\n     YQL_ENSURE(leftList.size() == rightList.size(), \"Different sizes of lists in comparison!\");\n \n     for (size_t i = 0; i < leftList.size(); ++i) {\n-        if (!CheckExpressionNodeForPushdown(leftList[i], lambdaArg) || !CheckExpressionNodeForPushdown(rightList[i], lambdaArg)) {\n+        if (!CheckExpressionNodeForPushdown(leftList[i], lambdaArg, allowOlapApply) || !CheckExpressionNodeForPushdown(rightList[i], lambdaArg, allowOlapApply)) {\n             return false;\n         }\n     }\n@@ -260,11 +256,11 @@ bool CheckComparisonParametersForPushdown(const TCoCompare& compare, const TExpr\n     return true;\n }\n \n-bool CompareCanBePushed(const TCoCompare& compare, const TExprNode* lambdaArg, const TExprBase& lambdaBody) {\n-    return IsSupportedPredicate(compare) && CheckComparisonParametersForPushdown(compare, lambdaArg, lambdaBody);\n+bool CompareCanBePushed(const TCoCompare& compare, const TExprNode* lambdaArg, const TExprBase& lambdaBody, bool allowOlapApply) {\n+    return IsSupportedPredicate(compare) && CheckComparisonParametersForPushdown(compare, lambdaArg, lambdaBody, allowOlapApply);\n }\n \n-bool SafeCastCanBePushed(const TCoFlatMap& flatmap, const TExprNode* lambdaArg) {\n+bool SafeCastCanBePushed(const TCoFlatMap& flatmap, const TExprNode* lambdaArg, bool allowOlapApply) {\n     /*\n      * There are three ways of comparison in following format:\n      *\n@@ -285,7 +281,7 @@ bool SafeCastCanBePushed(const TCoFlatMap& flatmap, const TExprNode* lambdaArg)\n     YQL_ENSURE(leftList.size() == rightList.size(), \"Different sizes of lists in comparison!\");\n \n     for (size_t i = 0; i < leftList.size(); ++i) {\n-        if (!CheckExpressionNodeForPushdown(leftList[i], lambdaArg) || !CheckExpressionNodeForPushdown(rightList[i], lambdaArg)) {\n+        if (!CheckExpressionNodeForPushdown(leftList[i], lambdaArg, allowOlapApply) || !CheckExpressionNodeForPushdown(rightList[i], lambdaArg, allowOlapApply)) {\n             return false;\n         }\n     }\n@@ -319,16 +315,16 @@ bool JsonExistsCanBePushed(const TCoJsonExists& jsonExists, const TExprNode* lam\n     return true;\n }\n \n-bool CoalesceCanBePushed(const TCoCoalesce& coalesce, const TExprNode* lambdaArg, const TExprBase& lambdaBody) {\n+bool CoalesceCanBePushed(const TCoCoalesce& coalesce, const TExprNode* lambdaArg, const TExprBase& lambdaBody, bool allowOlapApply) {\n     if (!coalesce.Value().Maybe<TCoBool>()) {\n         return false;\n     }\n \n     const auto predicate = coalesce.Predicate();\n     if (const auto maybeCompare = predicate.Maybe<TCoCompare>()) {\n-        return CompareCanBePushed(maybeCompare.Cast(), lambdaArg, lambdaBody);\n+        return CompareCanBePushed(maybeCompare.Cast(), lambdaArg, lambdaBody, allowOlapApply);\n     } else if (const auto maybeFlatmap = predicate.Maybe<TCoFlatMap>()) {\n-        return SafeCastCanBePushed(maybeFlatmap.Cast(), lambdaArg);\n+        return SafeCastCanBePushed(maybeFlatmap.Cast(), lambdaArg, allowOlapApply);\n     } else if (const auto maybeJsonExists = predicate.Maybe<TCoJsonExists>()) {\n         return JsonExistsCanBePushed(maybeJsonExists.Cast(), lambdaArg);\n     }\n@@ -340,47 +336,42 @@ bool ExistsCanBePushed(const TCoExists& exists, const TExprNode* lambdaArg) {\n     return IsMemberColumn(exists.Optional(), lambdaArg);\n }\n \n-void CollectChildrenPredicates(const TExprNode& opNode, TOLAPPredicateNode& predicateTree, const TExprNode* lambdaArg, const TExprBase& lambdaBody) {\n+void CollectChildrenPredicates(const TExprNode& opNode, TOLAPPredicateNode& predicateTree, const TExprNode* lambdaArg, const TExprBase& lambdaBody, bool allowOlapApply) {\n     predicateTree.Children.reserve(opNode.ChildrenSize());\n     predicateTree.CanBePushed = true;\n     for (const auto& childNodePtr: opNode.Children()) {\n         TOLAPPredicateNode child;\n         child.ExprNode = childNodePtr;\n         if (const auto maybeCtor = TMaybeNode<TCoDataCtor>(child.ExprNode))\n-            child.CanBePushed = IsSupportedDataType(maybeCtor.Cast());\n+            child.CanBePushed = IsSupportedDataType(maybeCtor.Cast(), allowOlapApply);\n         else\n-            CollectPredicates(TExprBase(child.ExprNode), child, lambdaArg, lambdaBody);\n+            CollectPredicates(TExprBase(child.ExprNode), child, lambdaArg, lambdaBody, allowOlapApply);\n         predicateTree.Children.emplace_back(child);\n         predicateTree.CanBePushed &= child.CanBePushed;\n     }\n }\n \n-}\n-\n-void CollectPredicates(const TExprBase& predicate, TOLAPPredicateNode& predicateTree, const TExprNode* lambdaArg, const TExprBase& lambdaBody) {\n-    if constexpr (NKikimr::NSsa::RuntimeVersion >= 5U) {\n-        if (predicate.Maybe<TCoIf>() || predicate.Maybe<TCoJust>() || predicate.Maybe<TCoCoalesce>()) {\n-            return CollectChildrenPredicates(predicate.Ref(), predicateTree, lambdaArg, lambdaBody);\n-        }\n-    }\n+} // namespace\n \n+void CollectPredicates(const TExprBase& predicate, TOLAPPredicateNode& predicateTree, const TExprNode* lambdaArg, const TExprBase& lambdaBody, bool allowOlapApply) {\n     if (predicate.Maybe<TCoNot>() || predicate.Maybe<TCoAnd>() || predicate.Maybe<TCoOr>() || predicate.Maybe<TCoXor>()) {\n-        return CollectChildrenPredicates(predicate.Ref(), predicateTree, lambdaArg, lambdaBody);\n+        return CollectChildrenPredicates(predicate.Ref(), predicateTree, lambdaArg, lambdaBody, allowOlapApply);\n     } else if (const auto maybeCoalesce = predicate.Maybe<TCoCoalesce>()) {\n-        predicateTree.CanBePushed = CoalesceCanBePushed(maybeCoalesce.Cast(), lambdaArg, lambdaBody);\n+        predicateTree.CanBePushed = CoalesceCanBePushed(maybeCoalesce.Cast(), lambdaArg, lambdaBody, allowOlapApply);\n     } else if (const auto maybeCompare = predicate.Maybe<TCoCompare>()) {\n-        predicateTree.CanBePushed = CompareCanBePushed(maybeCompare.Cast(), lambdaArg, lambdaBody);\n+        predicateTree.CanBePushed = CompareCanBePushed(maybeCompare.Cast(), lambdaArg, lambdaBody, allowOlapApply);\n     } else if (const auto maybeExists = predicate.Maybe<TCoExists>()) {\n         predicateTree.CanBePushed = ExistsCanBePushed(maybeExists.Cast(), lambdaArg);\n     } else if (const auto maybeJsonExists = predicate.Maybe<TCoJsonExists>()) {\n         predicateTree.CanBePushed = JsonExistsCanBePushed(maybeJsonExists.Cast(), lambdaArg);\n-    } else {\n-        if constexpr (NKikimr::NSsa::RuntimeVersion >= 5U) {\n-            predicateTree.CanBePushed = AbstractTreeCanBePushed(predicate, lambdaArg);\n-        } else {\n-            predicateTree.CanBePushed = false;\n+    }\n+    if (predicateTree.CanBePushed) {\n+        return;\n+    } else if (allowOlapApply){\n+        if (predicate.Maybe<TCoIf>() || predicate.Maybe<TCoJust>() || predicate.Maybe<TCoCoalesce>()) {\n+            return CollectChildrenPredicates(predicate.Ref(), predicateTree, lambdaArg, lambdaBody, allowOlapApply);\n         }\n+        predicateTree.CanBePushed =  AbstractTreeCanBePushed(predicate, lambdaArg);\n     }\n }\n-\n-}\n+} //namespace NKikimr::NKqp::NOpt\ndiff --git a/ydb/core/kqp/opt/physical/predicate_collector.h b/ydb/core/kqp/opt/physical/predicate_collector.h\nindex d6663c9d6ab0..f65ac2ebdd45 100644\n--- a/ydb/core/kqp/opt/physical/predicate_collector.h\n+++ b/ydb/core/kqp/opt/physical/predicate_collector.h\n@@ -15,6 +15,6 @@ struct TOLAPPredicateNode {\n     }\n };\n \n-void CollectPredicates(const NNodes::TExprBase& predicate, TOLAPPredicateNode& predicateTree, const TExprNode* lambdaArg, const NNodes::TExprBase& lambdaBody);\n+void CollectPredicates(const NNodes::TExprBase& predicate, TOLAPPredicateNode& predicateTree, const TExprNode* lambdaArg, const NNodes::TExprBase& lambdaBody, bool allowOlapApply);\n \n }\ndiff --git a/ydb/core/kqp/provider/yql_kikimr_datasink.cpp b/ydb/core/kqp/provider/yql_kikimr_datasink.cpp\nindex a4202e48c5d8..045207c56815 100644\n--- a/ydb/core/kqp/provider/yql_kikimr_datasink.cpp\n+++ b/ydb/core/kqp/provider/yql_kikimr_datasink.cpp\n@@ -225,6 +225,12 @@ class TKiSinkIntentDeterminationTransformer: public TKiSinkVisitorTransformer {\n         return TStatus::Ok;\n     }\n \n+    TStatus HandleAlterDatabase(TKiAlterDatabase node, TExprContext& ctx) override {\n+        Y_UNUSED(ctx);\n+        Y_UNUSED(node);\n+        return TStatus::Ok;\n+    }\n+\n     TStatus HandleCreateTopic(TKiCreateTopic node, TExprContext& ctx) override {\n         Y_UNUSED(ctx);\n         Y_UNUSED(node);\n@@ -549,7 +555,8 @@ class TKiSinkIntentDeterminationTransformer: public TKiSinkVisitorTransformer {\n \n             case TKikimrKey::Type::TableList:\n                 break;\n-\n+            case TKikimrKey::Type::Database:\n+                return TStatus::Ok;\n             case TKikimrKey::Type::Role:\n                 return TStatus::Ok;\n             case TKikimrKey::Type::Object:\n@@ -724,6 +731,10 @@ class TKikimrDataSink : public TDataProviderBase\n     }\n \n     bool CanExecute(const TExprNode& node) override {\n+        if (node.IsCallable(TKiAlterDatabase::CallableName())) {\n+            return true;\n+        }\n+\n         if (node.IsCallable(TKiExecDataQuery::CallableName())) {\n             return true;\n         }\n@@ -1153,6 +1164,23 @@ class TKikimrDataSink : public TDataProviderBase\n         YQL_ENSURE(key.Extract(*node->Child(2)), \"Failed to extract ydb key.\");\n \n         switch (key.GetKeyType()) {\n+            case TKikimrKey::Type::Database: {\n+                NCommon::TDatabaseSettings settings = NCommon::ParseDatabaseSettings(TExprList(node->Child(4)), ctx);\n+                YQL_ENSURE(settings.Mode);\n+                auto mode = settings.Mode.Cast();\n+\n+                if (mode == \"alterDatabase\") {\n+                    return Build<TKiAlterDatabase>(ctx, node->Pos())\n+                        .World(node->Child(0))\n+                        .DataSink(node->Child(1))\n+                        .DatabasePath().Build(key.GetDatabasePath())\n+                        .Settings(settings.Other)\n+                        .Done()\n+                        .Ptr();\n+                }\n+\n+                break;\n+            }\n             case TKikimrKey::Type::Table: {\n                 NCommon::TWriteTableSettings settings = NCommon::ParseWriteTableSettings(TExprList(node->Child(4)), ctx);\n                 YQL_ENSURE(settings.Mode);\n@@ -1954,6 +1982,10 @@ IGraphTransformer::TStatus TKiSinkVisitorTransformer::DoTransform(TExprNode::TPt\n \n     auto callable = TCallable(input);\n \n+    if (auto node = callable.Maybe<TKiAlterDatabase>()) {\n+        return HandleAlterDatabase(node.Cast(), ctx);\n+    }\n+\n     if (auto node = callable.Maybe<TKiWriteTable>()) {\n         return HandleWriteTable(node.Cast(), ctx);\n     }\ndiff --git a/ydb/core/kqp/provider/yql_kikimr_datasource.cpp b/ydb/core/kqp/provider/yql_kikimr_datasource.cpp\nindex 731bcaa10526..89c224b295f2 100644\n--- a/ydb/core/kqp/provider/yql_kikimr_datasource.cpp\n+++ b/ydb/core/kqp/provider/yql_kikimr_datasource.cpp\n@@ -136,6 +136,9 @@ class TKiSourceIntentDeterminationTransformer: public TKiSourceVisitorTransforme\n private:\n     TStatus HandleKey(const TStringBuf& cluster, const TKikimrKey& key) {\n         switch (key.GetKeyType()) {\n+            case TKikimrKey::Type::Database:\n+                return TStatus::Ok;\n+\n             case TKikimrKey::Type::Table:\n             case TKikimrKey::Type::TableScheme: {\n                 auto& table = SessionCtx->Tables().GetOrAddTable(TString(cluster), SessionCtx->GetDatabase(),\n@@ -617,6 +620,7 @@ class TKikimrDataSource : public TDataProviderBase {\n                 node.IsCallable(TDqSourceWideBlockWrap::CallableName()) ||\n                 node.IsCallable(TDqReadWrap::CallableName()) ||\n                 node.IsCallable(TDqReadWideWrap::CallableName()) ||\n+                node.IsCallable(TDqReadBlockWideWrap::CallableName()) ||\n                 node.IsCallable(TDqSource::CallableName())\n             )\n         )\ndiff --git a/ydb/core/kqp/provider/yql_kikimr_exec.cpp b/ydb/core/kqp/provider/yql_kikimr_exec.cpp\nindex 58869268fd3a..6bef12c2e7a2 100644\n--- a/ydb/core/kqp/provider/yql_kikimr_exec.cpp\n+++ b/ydb/core/kqp/provider/yql_kikimr_exec.cpp\n@@ -100,13 +100,31 @@ namespace {\n         return permissionsSettings;\n     }\n \n+    TAlterDatabaseSettings ParseAlterDatabaseSettings(TKiAlterDatabase alterDatabase) {\n+        TAlterDatabaseSettings alterDatabaseSettings;\n+        YQL_ENSURE(alterDatabase.DatabasePath().Value().size() > 0);\n+        alterDatabaseSettings.DatabasePath = alterDatabase.DatabasePath().Value();\n+\n+        for (auto setting : alterDatabase.Settings()) {\n+            const auto& name = setting.Name().Value();\n+\n+            if (name == \"owner\") {\n+                alterDatabaseSettings.Owner = setting.Value().Cast<TCoAtom>().StringValue();\n+            } else {\n+                YQL_ENSURE(false);\n+            }\n+        }\n+\n+        return alterDatabaseSettings;\n+    }\n+\n     TCreateUserSettings ParseCreateUserSettings(TKiCreateUser createUser) {\n         TCreateUserSettings createUserSettings;\n         createUserSettings.UserName = TString(createUser.UserName());\n         createUserSettings.CanLogin = true;\n \n         for (auto setting : createUser.Settings()) {\n-            auto name = setting.Name().Value();\n+            const auto& name = setting.Name().Value();\n             if (name == \"password\") {\n                 createUserSettings.Password = setting.Value().Cast<TCoAtom>().StringValue();\n             } else if (name == \"nullPassword\") {\n@@ -120,6 +138,8 @@ namespace {\n                 createUserSettings.CanLogin = true;\n             } else if (name == \"noLogin\") {\n                 createUserSettings.CanLogin = false;\n+            } else {\n+                YQL_ENSURE(false);\n             }\n         }\n         return createUserSettings;\n@@ -130,7 +150,7 @@ namespace {\n         alterUserSettings.UserName = TString(alterUser.UserName());\n \n         for (auto setting : alterUser.Settings()) {\n-            auto name = setting.Name().Value();\n+            const auto& name = setting.Name().Value();\n             if (name == \"password\") {\n                 alterUserSettings.Password = setting.Value().Cast<TCoAtom>().StringValue();\n             } else if (name == \"nullPassword\") {\n@@ -144,6 +164,8 @@ namespace {\n                 alterUserSettings.CanLogin = true;\n             } else if (name == \"noLogin\") {\n                 alterUserSettings.CanLogin = false;\n+            } else {\n+                YQL_ENSURE(false);\n             }\n         }\n         return alterUserSettings;\n@@ -1290,6 +1312,25 @@ class TKiSinkCallableExecutionTransformer : public TAsyncCallbackTransformer<TKi\n             return SyncOk();\n         }\n \n+        if (auto maybeAlterDatabase = TMaybeNode<TKiAlterDatabase>(input)) {\n+            auto requireStatus = RequireChild(*input, TKiExecDataQuery::idx_World);\n+            if (requireStatus.Level != TStatus::Ok) {\n+                return SyncStatus(requireStatus);\n+            }\n+\n+            auto cluster = TString(maybeAlterDatabase.Cast().DataSink().Cluster());\n+            TAlterDatabaseSettings alterDatabaseSettings = ParseAlterDatabaseSettings(maybeAlterDatabase.Cast());\n+\n+            auto future = Gateway->AlterDatabase(cluster, alterDatabaseSettings);\n+\n+            return WrapFuture(future,\n+                [](const IKikimrGateway::TGenericResult& res, const TExprNode::TPtr& input, TExprContext& ctx) {\n+                Y_UNUSED(res);\n+                auto resultNode = ctx.NewWorld(input->Pos());\n+                return resultNode;\n+            }, \"Executing ALTER DATABASE\");\n+        }\n+\n         if (auto maybeCreate = TMaybeNode<TKiCreateTable>(input)) {\n             auto requireStatus = RequireChild(*input, 0);\n             if (requireStatus.Level != TStatus::Ok) {\n@@ -1413,10 +1454,6 @@ class TKiSinkCallableExecutionTransformer : public TAsyncCallbackTransformer<TKi\n                     auto resultNode = ctx.NewWorld(input->Pos());\n                     return resultNode;\n                 }, GetDropTableDebugString(tableTypeItem));\n-\n-            input->SetState(TExprNode::EState::ExecutionComplete);\n-            input->SetResult(ctx.NewWorld(input->Pos()));\n-            return SyncOk();\n         }\n \n         if (auto maybeAlter = TMaybeNode<TKiAlterTable>(input)) {\ndiff --git a/ydb/core/kqp/provider/yql_kikimr_expr_nodes.json b/ydb/core/kqp/provider/yql_kikimr_expr_nodes.json\nindex 86f1b84023e3..76ae5ffb828a 100644\n--- a/ydb/core/kqp/provider/yql_kikimr_expr_nodes.json\n+++ b/ydb/core/kqp/provider/yql_kikimr_expr_nodes.json\n@@ -25,6 +25,17 @@\n                 {\"Index\": 1, \"Name\": \"Cluster\", \"Type\": \"TCoAtom\"}\n             ]\n         },\n+        {\n+            \"Name\": \"TKiAlterDatabase\",\n+            \"Base\": \"TCallable\",\n+            \"Match\": {\"Type\": \"Callable\", \"Name\": \"KiAlterDatabase!\"},\n+            \"Children\": [\n+                {\"Index\": 0, \"Name\": \"World\", \"Type\": \"TExprBase\"},\n+                {\"Index\": 1, \"Name\": \"DataSink\", \"Type\": \"TKiDataSink\"},\n+                {\"Index\": 2, \"Name\": \"DatabasePath\", \"Type\": \"TCoAtom\"},\n+                {\"Index\": 3, \"Name\": \"Settings\", \"Type\": \"TCoNameValueTupleList\"}\n+            ]\n+        },\n         {\n             \"Name\": \"TKiVersionedTable\",\n             \"Base\": \"TExprBase\",\ndiff --git a/ydb/core/kqp/provider/yql_kikimr_gateway.h b/ydb/core/kqp/provider/yql_kikimr_gateway.h\nindex c45b1ceb959c..d6ae138c15c9 100644\n--- a/ydb/core/kqp/provider/yql_kikimr_gateway.h\n+++ b/ydb/core/kqp/provider/yql_kikimr_gateway.h\n@@ -667,6 +667,11 @@ struct TKikimrTableMetadata : public TThrRefBase {\n     }\n };\n \n+struct TAlterDatabaseSettings {\n+    TString DatabasePath;\n+    std::optional<TString> Owner;\n+};\n+\n struct TCreateUserSettings {\n     TString UserName;\n     TString Password;\n@@ -1123,6 +1128,8 @@ class IKikimrGateway : public TThrRefBase {\n     virtual NThreading::TFuture<TTableMetadataResult> LoadTableMetadata(\n         const TString& cluster, const TString& table, TLoadTableMetadataSettings settings) = 0;\n \n+    virtual NThreading::TFuture<TGenericResult> AlterDatabase(const TString& cluster, const TAlterDatabaseSettings& settings) = 0;\n+\n     virtual NThreading::TFuture<TGenericResult> CreateTable(TKikimrTableMetadataPtr metadata, bool createDir, bool existingOk = false, bool replaceIfExists = false) = 0;\n \n     virtual NThreading::TFuture<TGenericResult> SendSchemeExecuterRequest(const TString& cluster,\ndiff --git a/ydb/core/kqp/provider/yql_kikimr_opt_build.cpp b/ydb/core/kqp/provider/yql_kikimr_opt_build.cpp\nindex 0c4812371e3d..5bccf947583d 100644\n--- a/ydb/core/kqp/provider/yql_kikimr_opt_build.cpp\n+++ b/ydb/core/kqp/provider/yql_kikimr_opt_build.cpp\n@@ -688,6 +688,17 @@ bool ExploreNode(TExprBase node, TExprContext& ctx, const TKiDataSink& dataSink,\n         return true;\n     }\n \n+    if (auto maybeAlterDatabase = node.Maybe<TKiAlterDatabase>()) {\n+        auto alterDatabase = maybeAlterDatabase.Cast();\n+        if (!checkDataSink(alterDatabase.DataSink())) {\n+            return false;\n+        }\n+\n+        txRes.Ops.insert(node.Raw());\n+        txRes.AddTableOperation(BuildYdbOpNode(cluster, TYdbOperation::AlterDatabase, alterDatabase.Pos(), ctx));\n+        return true;\n+    }\n+\n     if (node.Maybe<TCoCommit>()) {\n         return true;\n     }\ndiff --git a/ydb/core/kqp/provider/yql_kikimr_provider.cpp b/ydb/core/kqp/provider/yql_kikimr_provider.cpp\nindex 587fa657cd50..330bd19957b3 100644\n--- a/ydb/core/kqp/provider/yql_kikimr_provider.cpp\n+++ b/ydb/core/kqp/provider/yql_kikimr_provider.cpp\n@@ -40,6 +40,8 @@ struct TKikimrData {\n         DataSourceNames.insert(TKiReadTableScheme::CallableName());\n         DataSourceNames.insert(TKiReadTableList::CallableName());\n \n+        DataSinkNames.insert(TKiAlterDatabase::CallableName());\n+\n         DataSinkNames.insert(TKiWriteTable::CallableName());\n         DataSinkNames.insert(TKiUpdateTable::CallableName());\n         DataSinkNames.insert(TKiDeleteTable::CallableName());\n@@ -113,6 +115,7 @@ struct TKikimrData {\n         DataOps = ModifyOps | ReadOps;\n \n         SchemeOps =\n+            TYdbOperation::AlterDatabase |\n             TYdbOperation::CreateTable |\n             TYdbOperation::DropTable |\n             TYdbOperation::AlterTable |\n@@ -465,6 +468,9 @@ bool TKikimrKey::Extract(const TExprNode& key) {\n         KeyType = Type::BackupCollection;\n         Target = key.Child(0)->Child(1)->Child(0)->Content();\n         ExplicitPrefix = key.Child(0)->Child(2)->Child(0)->Content();\n+    } else if (tagName == \"databasePath\") {\n+        KeyType = Type::Database;\n+        Target = key.Child(0)->Child(1)->Child(0)->Content();\n     } else {\n         Ctx.AddError(TIssue(Ctx.GetPosition(key.Child(0)->Pos()), TString(\"Unexpected tag for kikimr key: \") + tagName));\n         return false;\ndiff --git a/ydb/core/kqp/provider/yql_kikimr_provider.h b/ydb/core/kqp/provider/yql_kikimr_provider.h\nindex 789e1db8ccf0..9db6cfb305a5 100644\n--- a/ydb/core/kqp/provider/yql_kikimr_provider.h\n+++ b/ydb/core/kqp/provider/yql_kikimr_provider.h\n@@ -254,6 +254,7 @@ enum class TYdbOperation : ui64 {\n     CreateTransfer         = 1ull << 34,\n     AlterTransfer          = 1ull << 35,\n     DropTransfer           = 1ull << 36,\n+    AlterDatabase          = 1ull << 37,\n };\n \n Y_DECLARE_FLAGS(TYdbOperations, TYdbOperation);\ndiff --git a/ydb/core/kqp/provider/yql_kikimr_provider_impl.h b/ydb/core/kqp/provider/yql_kikimr_provider_impl.h\nindex 0a15fff6d8cd..3c37d2b4f079 100644\n--- a/ydb/core/kqp/provider/yql_kikimr_provider_impl.h\n+++ b/ydb/core/kqp/provider/yql_kikimr_provider_impl.h\n@@ -31,6 +31,8 @@ class TKiSinkVisitorTransformer : public TSyncTransformerBase {\n     void Rewind() override {\n     }\n private:\n+    virtual TStatus HandleAlterDatabase(NNodes::TKiAlterDatabase node, TExprContext& ctx) = 0;\n+\n     virtual TStatus HandleWriteTable(NNodes::TKiWriteTable node, TExprContext& ctx) = 0;\n     virtual TStatus HandleUpdateTable(NNodes::TKiUpdateTable node, TExprContext& ctx) = 0;\n     virtual TStatus HandleDeleteTable(NNodes::TKiDeleteTable node, TExprContext& ctx) = 0;\n@@ -91,6 +93,7 @@ class TKiSinkVisitorTransformer : public TSyncTransformerBase {\n class TKikimrKey {\n public:\n     enum class Type {\n+        Database,\n         Table,\n         TableList,\n         TableScheme,\n@@ -130,6 +133,12 @@ class TKikimrKey {\n         return Target;\n     }\n \n+    TString GetDatabasePath() const {\n+        Y_DEBUG_ABORT_UNLESS(KeyType.Defined());\n+        Y_DEBUG_ABORT_UNLESS(KeyType == Type::Database);\n+        return Target;\n+    }\n+\n     TString GetTopicPath() const {\n         Y_DEBUG_ABORT_UNLESS(KeyType.Defined());\n         Y_DEBUG_ABORT_UNLESS(KeyType == Type::Topic);\ndiff --git a/ydb/core/kqp/provider/yql_kikimr_settings.cpp b/ydb/core/kqp/provider/yql_kikimr_settings.cpp\nindex 07cfe81b23dd..36bf85a0f50c 100644\n--- a/ydb/core/kqp/provider/yql_kikimr_settings.cpp\n+++ b/ydb/core/kqp/provider/yql_kikimr_settings.cpp\n@@ -93,6 +93,7 @@ TKikimrConfiguration::TKikimrConfiguration() {\n     REGISTER_SETTING(*this, CostBasedOptimizationLevel);\n     REGISTER_SETTING(*this, EnableSpillingNodes)\n         .Parser([](const TString& v) { return ParseEnableSpillingNodes(v); });\n+    REGISTER_SETTING(*this, UseBlockReader);\n \n     REGISTER_SETTING(*this, MaxDPHypDPTableSize);\n \ndiff --git a/ydb/core/kqp/provider/yql_kikimr_settings.h b/ydb/core/kqp/provider/yql_kikimr_settings.h\nindex 80f13ef811c6..3d7365c954fb 100644\n--- a/ydb/core/kqp/provider/yql_kikimr_settings.h\n+++ b/ydb/core/kqp/provider/yql_kikimr_settings.h\n@@ -69,6 +69,7 @@ struct TKikimrSettings {\n     NCommon::TConfSetting<bool, false> OptEnableOlapProvideComputeSharding;\n     NCommon::TConfSetting<bool, false> OptUseFinalizeByKey;\n     NCommon::TConfSetting<ui32, false> CostBasedOptimizationLevel;\n+    NCommon::TConfSetting<bool, false> UseBlockReader;\n \n     NCommon::TConfSetting<ui32, false> MaxDPHypDPTableSize;\n \ndiff --git a/ydb/core/kqp/provider/yql_kikimr_type_ann.cpp b/ydb/core/kqp/provider/yql_kikimr_type_ann.cpp\nindex 194229e36dc1..b28857f6e179 100644\n--- a/ydb/core/kqp/provider/yql_kikimr_type_ann.cpp\n+++ b/ydb/core/kqp/provider/yql_kikimr_type_ann.cpp\n@@ -198,6 +198,11 @@ class TKiSourceTypeAnnotationTransformer : public TKiSourceVisitorTransformer {\n                 return TStatus::Ok;\n             }\n \n+            case TKikimrKey::Type::Database:\n+            {\n+                return TStatus::Ok;\n+            }\n+\n             case TKikimrKey::Type::Role:\n             {\n                 return TStatus::Ok;\n@@ -1885,6 +1890,40 @@ virtual TStatus HandleCreateTable(TKiCreateTable create, TExprContext& ctx) over\n         return TStatus::Ok;\n     }\n \n+    virtual TStatus HandleAlterDatabase(NNodes::TKiAlterDatabase node, TExprContext& ctx) override {\n+        if (!SessionCtx->Config().FeatureFlags.GetEnableAlterDatabase()) {\n+            ctx.AddError(TIssue(ctx.GetPosition(node.Pos()),\n+                TStringBuilder() << \"ALTER DATABASE statement is not supported\"));\n+            return TStatus::Error;\n+        }\n+\n+        if (!node.DatabasePath().Value()) {\n+                ctx.AddError(TIssue(ctx.GetPosition(node.DatabasePath().Pos()), \"DatabasePath can't be empty.\"));\n+            return TStatus::Error;\n+        }\n+\n+        const THashSet<TString> supportedSettings = {\n+            \"owner\"\n+        };\n+\n+        for (const auto& setting : node.Settings()) {\n+            auto name = setting.Name().Value();\n+\n+            if (!supportedSettings.contains(name)) {\n+                ctx.AddError(TIssue(ctx.GetPosition(setting.Name().Pos()),\n+                    TStringBuilder() << \"Unknown create user setting: \" << name));\n+                return TStatus::Error;\n+            }\n+\n+            if (!EnsureAtom(setting.Value().Ref(), ctx)) {\n+                return TStatus::Error;\n+            }\n+        }\n+\n+        node.Ptr()->SetTypeAnn(node.World().Ref().GetTypeAnn());\n+        return TStatus::Ok;\n+    }\n+\n     virtual TStatus HandleCreateUser(TKiCreateUser node, TExprContext& ctx) override {\n         const THashSet<TString> supportedSettings = {\n             \"password\",\ndiff --git a/ydb/core/kqp/query_compiler/kqp_mkql_compiler.cpp b/ydb/core/kqp/query_compiler/kqp_mkql_compiler.cpp\nindex fa57a3889940..6158910b6b9a 100644\n--- a/ydb/core/kqp/query_compiler/kqp_mkql_compiler.cpp\n+++ b/ydb/core/kqp/query_compiler/kqp_mkql_compiler.cpp\n@@ -197,7 +197,7 @@ TKqpKeyRange MakeKeyRange(const TKqlReadTableBase& readTable, const TKqlCompileC\n     if (settings.ItemsLimit) {\n         keyRange.ItemsLimit = MkqlBuildExpr(*settings.ItemsLimit, buildCtx);\n     }\n-    keyRange.Reverse = settings.Reverse;\n+    keyRange.Reverse = settings.IsReverse();\n \n     return keyRange;\n }\n@@ -210,7 +210,7 @@ TKqpKeyRanges MakeComputedKeyRanges(const TKqlReadTableRangesBase& readTable, co\n     TKqpKeyRanges ranges = {\n         .Ranges = MkqlBuildExpr(readTable.Ranges().Ref(), buildCtx),\n         .ItemsLimit = settings.ItemsLimit ? MkqlBuildExpr(*settings.ItemsLimit, buildCtx) : ctx.PgmBuilder().NewNull(),\n-        .Reverse = settings.Reverse,\n+        .Reverse = settings.IsReverse(),\n     };\n \n     return ranges;\ndiff --git a/ydb/core/kqp/query_compiler/kqp_olap_compiler.cpp b/ydb/core/kqp/query_compiler/kqp_olap_compiler.cpp\nindex 326de9203b06..ba0f3136039e 100644\n--- a/ydb/core/kqp/query_compiler/kqp_olap_compiler.cpp\n+++ b/ydb/core/kqp/query_compiler/kqp_olap_compiler.cpp\n@@ -279,7 +279,6 @@ ui64 GetOrCreateColumnId(const TExprBase& node, TKqpOlapCompileContext& ctx);\n \n ui64 ConvertValueToColumn(const TCoDataCtor& value, TKqpOlapCompileContext& ctx)\n {\n-    constexpr bool yqlTypes = NKikimr::NSsa::RuntimeVersion >= 4U;\n     auto *const ssaValue = ctx.CreateAssignCmd();\n     const auto& nodeValue = value.Cast<TCoDataCtor>().Literal().Value();\n     if (value.Maybe<TCoUtf8>()) {\n@@ -287,38 +286,23 @@ ui64 ConvertValueToColumn(const TCoDataCtor& value, TKqpOlapCompileContext& ctx)\n     } else if (value.Maybe<TCoString>()) {\n         ssaValue->MutableConstant()->SetBytes(TString(nodeValue));\n     } else if (value.Maybe<TCoBool>()) {\n-        if constexpr (yqlTypes)\n-            ssaValue->MutableConstant()->SetUint8(FromString<bool>(nodeValue) ? 1U : 0U);\n-        else\n-            ssaValue->MutableConstant()->SetBool(FromString<bool>(nodeValue));\n+        ssaValue->MutableConstant()->SetUint8(FromString<bool>(nodeValue) ? 1U : 0U);\n     } else if (value.Maybe<TCoFloat>()) {\n         ssaValue->MutableConstant()->SetFloat(FromString<float>(nodeValue));\n     } else if (value.Maybe<TCoDouble>()) {\n         ssaValue->MutableConstant()->SetDouble(FromString<double>(nodeValue));\n     } else if (value.Maybe<TCoInt8>()) {\n-        if constexpr (yqlTypes)\n-            ssaValue->MutableConstant()->SetInt8(FromString<i8>(nodeValue));\n-        else\n-            ssaValue->MutableConstant()->SetInt32(FromString<i32>(nodeValue));\n+        ssaValue->MutableConstant()->SetInt8(FromString<i8>(nodeValue));\n     } else if (value.Maybe<TCoInt16>()) {\n-        if constexpr (yqlTypes)\n-            ssaValue->MutableConstant()->SetInt16(FromString<i16>(nodeValue));\n-        else\n-            ssaValue->MutableConstant()->SetInt32(FromString<i32>(nodeValue));\n+        ssaValue->MutableConstant()->SetInt16(FromString<i16>(nodeValue));\n     } else if (value.Maybe<TCoInt32>() || value.Maybe<TCoDate32>()) {\n         ssaValue->MutableConstant()->SetInt32(FromString<i32>(nodeValue));\n     } else if (value.Maybe<TCoInt64>() || value.Maybe<TCoInterval64>() || value.Maybe<TCoDatetime64>() || value.Maybe<TCoTimestamp64>()) {\n         ssaValue->MutableConstant()->SetInt64(FromString<i64>(nodeValue));\n     } else if (value.Maybe<TCoUint8>()) {\n-        if constexpr (yqlTypes)\n-            ssaValue->MutableConstant()->SetUint8(FromString<ui8>(nodeValue));\n-        else\n-            ssaValue->MutableConstant()->SetUint32(FromString<ui32>(nodeValue));\n+        ssaValue->MutableConstant()->SetUint8(FromString<ui8>(nodeValue));\n     } else if (value.Maybe<TCoUint16>()) {\n-        if constexpr (yqlTypes)\n-            ssaValue->MutableConstant()->SetUint16(FromString<ui16>(nodeValue));\n-        else\n-            ssaValue->MutableConstant()->SetUint32(FromString<ui32>(nodeValue));\n+        ssaValue->MutableConstant()->SetUint16(FromString<ui16>(nodeValue));\n     } else if (value.Maybe<TCoUint32>()) {\n         ssaValue->MutableConstant()->SetUint32(FromString<ui32>(nodeValue));\n     } else if (value.Maybe<TCoUint64>()) {\n@@ -408,8 +392,6 @@ struct TTypedColumn {\n };\n \n const TTypedColumn ConvertJsonValueToColumn(const TKqpOlapJsonValue& jsonValueCallable, TKqpOlapCompileContext& ctx) {\n-    Y_ABORT_UNLESS(NKikimr::NSsa::RuntimeVersion >= 3, \"JSON_VALUE pushdown is supported starting from the v3 of SSA runtime.\");\n-\n     const auto columnId = GetOrCreateColumnId(jsonValueCallable.Column(), ctx);\n     const auto pathId = GetOrCreateColumnId(jsonValueCallable.Path(), ctx);\n \n@@ -433,8 +415,6 @@ const TTypedColumn ConvertJsonValueToColumn(const TKqpOlapJsonValue& jsonValueCa\n }\n \n const TTypedColumn CompileJsonExists(const TKqpOlapJsonExists& jsonExistsCallable, TKqpOlapCompileContext& ctx) {\n-    Y_ABORT_UNLESS(NKikimr::NSsa::RuntimeVersion >= 3, \"JSON_EXISTS pushdown is supported starting from the v3 of SSA runtime.\");\n-\n     const auto columnId = GetOrCreateColumnId(jsonExistsCallable.Column(), ctx);\n     const auto pathId = GetOrCreateColumnId(jsonExistsCallable.Path(), ctx);\n \n@@ -453,11 +433,7 @@ const TTypedColumn CompileJsonExists(const TKqpOlapJsonExists& jsonExistsCallabl\n     jsonExistsFunc->SetKernelName(\"JsonExists\");\n     jsonExistsFunc->SetKernelIdx(idx);\n \n-    if constexpr (NSsa::RuntimeVersion >= 4U) {\n-        return {ConvertSafeCastToColumn(command->GetColumn().GetId(), \"Uint8\", ctx), ctx.ConvertToBlockType(type)};\n-    } else {\n-        return {command->GetColumn().GetId(), ctx.ConvertToBlockType(type)};\n-    }\n+    return {ConvertSafeCastToColumn(command->GetColumn().GetId(), \"Uint8\", ctx), ctx.ConvertToBlockType(type)};\n }\n \n ui64 GetOrCreateColumnId(const TExprBase& node, TKqpOlapCompileContext& ctx) {\n@@ -498,42 +474,35 @@ ui64 CompileYqlKernelComparison(const TKqpOlapFilterBinaryOp& comparison, TKqpOl\n     auto *const cmpFunc = command->MutableFunction();\n \n     ui32 function = TProgram::TAssignment::FUNC_UNSPECIFIED;\n-    bool isYqlKernelsSupported = (NKikimr::NSsa::RuntimeVersion >= 3);\n     bool needCastToBool = false;\n \n     if (comparison.Operator() == \"string_contains\") {\n         function = TProgram::TAssignment::FUNC_STR_MATCH;\n-        if (isYqlKernelsSupported) {\n-            cmpFunc->SetFunctionType(TProgram::YQL_KERNEL);\n-            auto idx = ctx.AddYqlKernelBinaryFunc(comparison.Pos(), TKernelRequestBuilder::EBinaryOp::StringContains,\n-                comparison.Left(),\n-                comparison.Right(),\n-                ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool));\n-            cmpFunc->SetKernelIdx(idx);\n-            needCastToBool = true;\n-        }\n+        cmpFunc->SetFunctionType(TProgram::YQL_KERNEL);\n+        auto idx = ctx.AddYqlKernelBinaryFunc(comparison.Pos(), TKernelRequestBuilder::EBinaryOp::StringContains,\n+            comparison.Left(),\n+            comparison.Right(),\n+            ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool));\n+        cmpFunc->SetKernelIdx(idx);\n+        needCastToBool = true;\n     } else if (comparison.Operator() == \"starts_with\") {\n         function = TProgram::TAssignment::FUNC_STR_STARTS_WITH;\n-        if (isYqlKernelsSupported) {\n-            cmpFunc->SetFunctionType(TProgram::YQL_KERNEL);\n-            auto idx = ctx.AddYqlKernelBinaryFunc(comparison.Pos(), TKernelRequestBuilder::EBinaryOp::StartsWith,\n-                comparison.Left(),\n-                comparison.Right(),\n-                ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool));\n-            cmpFunc->SetKernelIdx(idx);\n-            needCastToBool = true;\n-        }\n+        cmpFunc->SetFunctionType(TProgram::YQL_KERNEL);\n+        auto idx = ctx.AddYqlKernelBinaryFunc(comparison.Pos(), TKernelRequestBuilder::EBinaryOp::StartsWith,\n+            comparison.Left(),\n+            comparison.Right(),\n+            ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool));\n+        cmpFunc->SetKernelIdx(idx);\n+        needCastToBool = true;\n     } else if (comparison.Operator() == \"ends_with\") {\n         function = TProgram::TAssignment::FUNC_STR_ENDS_WITH;\n-        if (isYqlKernelsSupported) {\n-            cmpFunc->SetFunctionType(TProgram::YQL_KERNEL);\n-            auto idx = ctx.AddYqlKernelBinaryFunc(comparison.Pos(), TKernelRequestBuilder::EBinaryOp::EndsWith,\n-                comparison.Left(),\n-                comparison.Right(),\n-                ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool));\n-            cmpFunc->SetKernelIdx(idx);\n-            needCastToBool = true;\n-        }\n+        cmpFunc->SetFunctionType(TProgram::YQL_KERNEL);\n+        auto idx = ctx.AddYqlKernelBinaryFunc(comparison.Pos(), TKernelRequestBuilder::EBinaryOp::EndsWith,\n+            comparison.Left(),\n+            comparison.Right(),\n+            ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool));\n+        cmpFunc->SetKernelIdx(idx);\n+        needCastToBool = true;\n     }\n \n     cmpFunc->SetId(function);\n@@ -613,19 +582,11 @@ const TTypedColumn CompileExists(const TExprBase& arg, TKqpOlapCompileContext& c\n     isNullFunc->AddArguments()->SetId(column.Id);\n \n     if constexpr (Empty) {\n-        if constexpr (NSsa::RuntimeVersion >= 4U) {\n-            return {ConvertSafeCastToColumn(command->GetColumn().GetId(), \"Uint8\", ctx), ctx.ConvertToBlockType(type)};\n-        } else {\n-            return {command->GetColumn().GetId(), type};\n-        }\n+        return {ConvertSafeCastToColumn(command->GetColumn().GetId(), \"Uint8\", ctx), ctx.ConvertToBlockType(type)};\n     }\n \n     auto *const notCommand = InvertResult(command, ctx);\n-    if constexpr (NSsa::RuntimeVersion >= 4U) {\n-        return {ConvertSafeCastToColumn(notCommand->GetColumn().GetId(), \"Uint8\", ctx), ctx.ConvertToBlockType(type)};\n-    } else {\n-        return {notCommand->GetColumn().GetId(), type};\n-    }\n+    return {ConvertSafeCastToColumn(notCommand->GetColumn().GetId(), \"Uint8\", ctx), ctx.ConvertToBlockType(type)};\n }\n \n TTypedColumn CompileYqlKernelScalarApply(const TKqpOlapApply& apply, TKqpOlapCompileContext& ctx) {\n@@ -639,6 +600,12 @@ TTypedColumn CompileYqlKernelScalarApply(const TKqpOlapApply& apply, TKqpOlapCom\n         argTypes.emplace_back(arg.Type);\n     }\n \n+    for(const auto& param: apply.Parameters()) {\n+        const auto& arg = GetOrCreateColumnIdAndType(param, ctx);\n+        ids.emplace_back(arg.Id);\n+        argTypes.emplace_back(arg.Type);\n+    }\n+\n     auto *const command = ctx.CreateAssignCmd();\n     auto *const function = command->MutableFunction();\n     const auto idx = ctx.GetKernelRequestBuilder().AddScalarApply(apply.Lambda().Ref(), argTypes, ctx.ExprCtx());\n@@ -809,31 +776,21 @@ const TTypedColumn BuildLogicalNot(const TExprBase& arg, TKqpOlapCompileContext&\n \n     notFunc->AddArguments()->SetId(value.Id);\n \n-    if constexpr (NSsa::RuntimeVersion >= 4U) {\n-        const auto block = ctx.ExprCtx().MakeType<TBlockExprType>(ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool));\n-        const auto idx = ctx.GetKernelRequestBuilder().AddUnaryOp(TKernelRequestBuilder::EUnaryOp::Not, block, block);\n-        notFunc->SetKernelIdx(idx);\n-        notFunc->SetFunctionType(TProgram::YQL_KERNEL);\n-    } else\n-        notFunc->SetId(TProgram::TAssignment::FUNC_BINARY_NOT);\n+    const auto block = ctx.ExprCtx().MakeType<TBlockExprType>(ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool));\n+    const auto idx = ctx.GetKernelRequestBuilder().AddUnaryOp(TKernelRequestBuilder::EUnaryOp::Not, block, block);\n+    notFunc->SetKernelIdx(idx);\n+    notFunc->SetFunctionType(TProgram::YQL_KERNEL);\n \n     return {notOp->GetColumn().GetId(), value.Type};\n }\n \n TTypedColumn GetOrCreateColumnIdAndType(const TExprBase& node, TKqpOlapCompileContext& ctx) {\n     if (const auto& maybeBinaryOp = node.Maybe<TKqpOlapFilterBinaryOp>()) {\n-        if constexpr (NSsa::RuntimeVersion >= 4U) {\n-            if (const auto& binaryOp = maybeBinaryOp.Cast(); ctx.CheckYqlCompatibleArgsTypes(binaryOp)) {\n-                return CompileYqlKernelBinaryOperation(binaryOp, ctx);\n-            } else {\n-                return {\n-                    ConvertSafeCastToColumn(CompileSimpleArrowComparison(binaryOp, ctx), \"Uint8\", ctx),\n-                    ctx.ExprCtx().MakeType<TBlockExprType>(ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool))\n-                };\n-            }\n+        if (const auto& binaryOp = maybeBinaryOp.Cast(); ctx.CheckYqlCompatibleArgsTypes(binaryOp)) {\n+            return CompileYqlKernelBinaryOperation(binaryOp, ctx);\n         } else {\n             return {\n-                CompileSimpleArrowComparison(maybeBinaryOp.Cast(), ctx),\n+                ConvertSafeCastToColumn(CompileSimpleArrowComparison(binaryOp, ctx), \"Uint8\", ctx),\n                 ctx.ExprCtx().MakeType<TBlockExprType>(ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool))\n             };\n         }\n@@ -842,20 +799,11 @@ TTypedColumn GetOrCreateColumnIdAndType(const TExprBase& node, TKqpOlapCompileCo\n     } else if (const auto& maybeTernaryOp = node.Maybe<TKqpOlapFilterTernaryOp>()) {\n         return CompileYqlKernelTernaryOperation(maybeTernaryOp.Cast(), ctx);\n     } else if (const auto& maybeAnd = node.Maybe<TKqpOlapAnd>()) {\n-        if constexpr (NSsa::RuntimeVersion >= 4U)\n-            return BuildLogicalProgram(node.Pos(), maybeAnd.Ref().Children(), TKernelRequestBuilder::EBinaryOp::And, ctx);\n-        else\n-            return BuildLogicalProgram(node.Pos(), maybeAnd.Ref().Children(), TProgram::TAssignment::FUNC_BINARY_AND, ctx);\n+        return BuildLogicalProgram(node.Pos(), maybeAnd.Ref().Children(), TKernelRequestBuilder::EBinaryOp::And, ctx);\n     } else if (const auto& maybeOr = node.Maybe<TKqpOlapOr>()) {\n-        if constexpr (NSsa::RuntimeVersion >= 4U)\n-            return BuildLogicalProgram(node.Pos(), maybeOr.Ref().Children(), TKernelRequestBuilder::EBinaryOp::Or, ctx);\n-        else\n-            return BuildLogicalProgram(node.Pos(), maybeOr.Ref().Children(), TProgram::TAssignment::FUNC_BINARY_OR, ctx);\n+        return BuildLogicalProgram(node.Pos(), maybeOr.Ref().Children(), TKernelRequestBuilder::EBinaryOp::Or, ctx);\n     } else if (const auto& maybeXor = node.Maybe<TKqpOlapXor>()) {\n-        if constexpr (NSsa::RuntimeVersion >= 4U)\n-            return BuildLogicalProgram(node.Pos(), maybeXor.Ref().Children(), TKernelRequestBuilder::EBinaryOp::Xor, ctx);\n-        else\n-            return BuildLogicalProgram(node.Pos(), maybeXor.Ref().Children(), TProgram::TAssignment::FUNC_BINARY_XOR, ctx);\n+        return BuildLogicalProgram(node.Pos(), maybeXor.Ref().Children(), TKernelRequestBuilder::EBinaryOp::Xor, ctx);\n     } else if (const auto& maybeNot = node.Maybe<TKqpOlapNot>()) {\n         return BuildLogicalNot(maybeNot.Cast().Value(), ctx);\n     } else if (const auto& maybeJsonValue = node.Maybe<TKqpOlapJsonValue>()) {\n@@ -871,12 +819,10 @@ TTypedColumn GetOrCreateColumnIdAndType(const TExprBase& node, TKqpOlapCompileCo\n \n ui64 CompileComparison(const TKqpOlapFilterBinaryOp& comparison, TKqpOlapCompileContext& ctx)\n {\n-    if constexpr (NKikimr::NSsa::RuntimeVersion >= 4U) {\n-        if (ctx.CheckYqlCompatibleArgsTypes(comparison)) {\n-            return CompileYqlKernelBinaryOperation(comparison, ctx).Id;\n-        } else {\n-            return ConvertSafeCastToColumn(CompileSimpleArrowComparison(comparison, ctx), \"Uint8\", ctx);\n-        }\n+    if (ctx.CheckYqlCompatibleArgsTypes(comparison)) {\n+        return CompileYqlKernelBinaryOperation(comparison, ctx).Id;\n+    } else {\n+        return ConvertSafeCastToColumn(CompileSimpleArrowComparison(comparison, ctx), \"Uint8\", ctx);\n     }\n \n     std::string op = comparison.Operator().StringValue().c_str();\n@@ -918,26 +864,18 @@ ui64 CompileCondition(const TExprBase& condition, TKqpOlapCompileContext& ctx) {\n         return BuildLogicalNot(maybeNot.Cast().Value(), ctx).Id;\n     }\n \n-    ui32 function = TProgram::TAssignment::FUNC_UNSPECIFIED;\n     TKernelRequestBuilder::EBinaryOp op;\n \n     if (condition.Maybe<TKqpOlapAnd>()) {\n-        function = TProgram::TAssignment::FUNC_BINARY_AND;\n         op = TKernelRequestBuilder::EBinaryOp::And;\n     } else if (condition.Maybe<TKqpOlapOr>()) {\n-        function = TProgram::TAssignment::FUNC_BINARY_OR;\n         op = TKernelRequestBuilder::EBinaryOp::Or;\n     } else if (condition.Maybe<TKqpOlapXor>()) {\n-        function = TProgram::TAssignment::FUNC_BINARY_XOR;\n         op = TKernelRequestBuilder::EBinaryOp::Xor;\n     } else {\n         YQL_ENSURE(false, \"Unsuppoted logical operation: \" << condition.Ref().Content());\n     }\n-\n-    if constexpr (NSsa::RuntimeVersion >= 4U)\n-        return BuildLogicalProgram(condition.Pos(), condition.Ref().Children(), op, ctx).Id;\n-    else\n-        return BuildLogicalProgram(condition.Pos(), condition.Ref().Children(), function, ctx).Id;\n+    return BuildLogicalProgram(condition.Pos(), condition.Ref().Children(), op, ctx).Id;\n }\n \n void CompileFilter(const TKqpOlapFilter& filterNode, TKqpOlapCompileContext& ctx) {\ndiff --git a/ydb/core/kqp/query_compiler/kqp_query_compiler.cpp b/ydb/core/kqp/query_compiler/kqp_query_compiler.cpp\nindex c73e29753c7e..fa93d605c726 100644\n--- a/ydb/core/kqp/query_compiler/kqp_query_compiler.cpp\n+++ b/ydb/core/kqp/query_compiler/kqp_query_compiler.cpp\n@@ -359,7 +359,7 @@ void FillReadRange(const TKqpWideReadTable& read, const TKikimrTableMetadata& ta\n         }\n     }\n \n-    readProto.SetReverse(settings.Reverse);\n+    readProto.SetReverse(settings.IsReverse());\n }\n \n template <typename TReader, typename TProto>\n@@ -395,13 +395,13 @@ void FillReadRanges(const TReader& read, const TKikimrTableMetadata&, TProto& re\n     }\n \n     if constexpr (std::is_same_v<TProto, NKqpProto::TKqpPhyOpReadOlapRanges>) {\n-        readProto.SetSorted(settings.Sorted);\n+        readProto.SetSorted(settings.IsSorted());\n         if (settings.TabletId) {\n             readProto.SetTabletId(*settings.TabletId);\n         }\n     }\n \n-    readProto.SetReverse(settings.Reverse);\n+    readProto.SetReverse(settings.IsReverse());\n }\n \n template <typename TEffectCallable, typename TEffectProto>\n@@ -1032,8 +1032,8 @@ class TKqpQueryCompiler : public IKqpQueryCompiler {\n             }\n             auto readSettings = TKqpReadTableSettings::Parse(settings.Settings().Cast());\n \n-            readProto.SetReverse(readSettings.Reverse);\n-            readProto.SetSorted(readSettings.Sorted);\n+            readProto.SetReverse(readSettings.IsReverse());\n+            readProto.SetSorted(readSettings.IsSorted());\n             YQL_ENSURE(readSettings.SkipNullKeys.empty());\n \n             if (readSettings.SequentialInFlight) {\ndiff --git a/ydb/core/kqp/query_data/kqp_query_data.cpp b/ydb/core/kqp/query_data/kqp_query_data.cpp\nindex 08ed96d0d944..e2c65ac7d0ca 100644\n--- a/ydb/core/kqp/query_data/kqp_query_data.cpp\n+++ b/ydb/core/kqp/query_data/kqp_query_data.cpp\n@@ -276,12 +276,16 @@ void TQueryData::ValidateParameter(const TString& name, const NKikimrMiniKQL::TT\n void TQueryData::PrepareParameters(const TKqpPhyTxHolder::TConstPtr& tx, const TPreparedQueryHolder::TConstPtr& preparedQuery,\n     NMiniKQL::TTypeEnvironment& txTypeEnv)\n {\n-    for (const auto& paramDesc : preparedQuery->GetParameters()) {\n-        ValidateParameter(paramDesc.GetName(), paramDesc.GetType(), txTypeEnv);\n+    if (preparedQuery) {\n+        for (const auto& paramDesc : preparedQuery->GetParameters()) {\n+            ValidateParameter(paramDesc.GetName(), paramDesc.GetType(), txTypeEnv);\n+        }\n     }\n \n-    for(const auto& paramBinding: tx->GetParamBindings()) {\n-        MaterializeParamValue(true, paramBinding);\n+    if (tx) {\n+        for(const auto& paramBinding: tx->GetParamBindings()) {\n+            MaterializeParamValue(true, paramBinding);\n+        }\n     }\n }\n \ndiff --git a/ydb/core/kqp/runtime/kqp_read_actor.cpp b/ydb/core/kqp/runtime/kqp_read_actor.cpp\nindex fe1669341609..9a5b91ededae 100644\n--- a/ydb/core/kqp/runtime/kqp_read_actor.cpp\n+++ b/ydb/core/kqp/runtime/kqp_read_actor.cpp\n@@ -723,6 +723,20 @@ class TKqpReadActor : public TActorBootstrapped<TKqpReadActor>, public NYql::NDq\n         }\n     }\n \n+    bool CheckTotalRetriesExeeded() {\n+        const auto limit = MaxTotalRetries();\n+        return limit && TotalRetries + 1 > *limit;\n+    }\n+\n+    bool CheckShardRetriesExeeded(ui64 id) {\n+        if (!Reads[id] || Reads[id].Finished) {\n+            return false;\n+        }\n+\n+        const auto& state = Reads[id].Shard;\n+        return state->RetryAttempt + 1 > MaxShardRetries();\n+    }\n+\n     void RetryRead(ui64 id, bool allowInstantRetry = true) {\n         if (!Reads[id] || Reads[id].Finished) {\n             return;\n@@ -730,18 +744,17 @@ class TKqpReadActor : public TActorBootstrapped<TKqpReadActor>, public NYql::NDq\n \n         auto state = Reads[id].Shard;\n \n-        TotalRetries += 1;\n-        auto limit = MaxTotalRetries();\n-        if (limit && TotalRetries > *limit) {\n+        if (CheckTotalRetriesExeeded()) {\n             return RuntimeError(TStringBuilder() << \"Table '\" << Settings->GetTable().GetTablePath() << \"' retry limit exceeded\",\n                 NDqProto::StatusIds::UNAVAILABLE);\n         }\n+        ++TotalRetries;\n \n-        state->RetryAttempt += 1;\n-        if (state->RetryAttempt > MaxShardRetries()) {\n+        if (CheckShardRetriesExeeded(id)) {\n             ResetRead(id);\n             return ResolveShard(state);\n         }\n+        ++state->RetryAttempt;\n \n         auto delay = CalcDelay(state->RetryAttempt, allowInstantRetry);\n         if (delay == TDuration::Zero()) {\n@@ -825,7 +838,11 @@ class TKqpReadActor : public TActorBootstrapped<TKqpReadActor>, public NYql::NDq\n         record.MutableTableId()->SetTableId(Settings->GetTable().GetTableId().GetTableId());\n         record.MutableTableId()->SetSchemaVersion(Settings->GetTable().GetSchemaVersion());\n \n-        record.SetReverse(Settings->GetReverse());\n+        if (Settings->HasOptionalSorting()) {\n+            record.SetReverse(Settings->GetOptionalSorting() == (ui32)ERequestSorting::DESC);\n+        } else {\n+            record.SetReverse(Settings->GetReverse());\n+        }\n         if (limit) {\n             record.SetMaxRows(*limit);\n             record.SetTotalRowsLimit(*limit);\n@@ -954,12 +971,16 @@ class TKqpReadActor : public TActorBootstrapped<TKqpReadActor>, public NYql::NDq\n             Reads[id].Shard->Issues.push_back(issue);\n         }\n \n+        auto replyError = [&](auto message, auto status) {\n+            NYql::TIssues issues;\n+            NYql::IssuesFromMessage(record.GetStatus().GetIssues(), issues);\n+            return RuntimeError(message, status, issues);\n+        };\n+\n         if (UseFollowers && record.GetStatus().GetCode() != Ydb::StatusIds::SUCCESS && Reads[id].Shard->SuccessBatches > 0) {\n             // read from follower is interrupted with error after several successful responses.\n             // in this case read is not safe because we can return inconsistent data.\n-            NYql::TIssues issues;\n-            NYql::IssuesFromMessage(record.GetStatus().GetIssues(), issues);\n-            return RuntimeError(\"Failed to read from follower\", NYql::NDqProto::StatusIds::UNAVAILABLE, issues);\n+            return replyError(\"Failed to read from follower\", NYql::NDqProto::StatusIds::UNAVAILABLE);\n         }\n \n         switch (record.GetStatus().GetCode()) {\n@@ -968,20 +989,33 @@ class TKqpReadActor : public TActorBootstrapped<TKqpReadActor>, public NYql::NDq\n                 break;\n             }\n             case Ydb::StatusIds::OVERLOADED: {\n+                if (CheckTotalRetriesExeeded() || CheckShardRetriesExeeded(id)) {\n+                    return replyError(\n+                        TStringBuilder() << \"Table '\" << Settings->GetTable().GetTablePath() << \"' retry limit exceeded.\",\n+                        NYql::NDqProto::StatusIds::OVERLOADED);\n+                }\n                 return RetryRead(id, false);\n             }\n             case Ydb::StatusIds::INTERNAL_ERROR: {\n+                if (CheckTotalRetriesExeeded() || CheckShardRetriesExeeded(id)) {\n+                    return replyError(\n+                        TStringBuilder() << \"Table '\" << Settings->GetTable().GetTablePath() << \"' retry limit exceeded.\",\n+                        NYql::NDqProto::StatusIds::INTERNAL_ERROR);\n+                }\n                 return RetryRead(id);\n             }\n             case Ydb::StatusIds::NOT_FOUND: {\n+                if (CheckTotalRetriesExeeded() || CheckShardRetriesExeeded(id)) {\n+                    return replyError(\n+                        TStringBuilder() << \"Table '\" << Settings->GetTable().GetTablePath() << \"' retry limit exceeded.\",\n+                        NYql::NDqProto::StatusIds::UNAVAILABLE);\n+                }\n                 auto shard = Reads[id].Shard;\n                 ResetRead(id);\n                 return ResolveShard(shard);\n             }\n             default: {\n-                NYql::TIssues issues;\n-                NYql::IssuesFromMessage(record.GetStatus().GetIssues(), issues);\n-                return RuntimeError(\"Read request aborted\", NYql::NDqProto::StatusIds::ABORTED, issues);\n+                return replyError(\"Read request aborted\", NYql::NDqProto::StatusIds::ABORTED);\n             }\n         }\n \ndiff --git a/ydb/core/kqp/runtime/kqp_stream_lookup_actor.cpp b/ydb/core/kqp/runtime/kqp_stream_lookup_actor.cpp\nindex d52e826fd378..5f5a51d47622 100644\n--- a/ydb/core/kqp/runtime/kqp_stream_lookup_actor.cpp\n+++ b/ydb/core/kqp/runtime/kqp_stream_lookup_actor.cpp\n@@ -118,6 +118,7 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku\n     enum class EReadState {\n         Initial,\n         Running,\n+        Blocked, // Read can't accept new data, but not finished yet\n         Finished,\n     };\n \n@@ -125,6 +126,7 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku\n         switch (state) {\n             case EReadState::Initial: return \"Initial\"sv;\n             case EReadState::Running: return \"Running\"sv;\n+            case EReadState::Blocked: return \"Blocked\"sv;\n             case EReadState::Finished: return \"Finished\"sv;\n         }\n     }\n@@ -143,6 +145,10 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku\n             return (State == EReadState::Finished);\n         }\n \n+        void SetBlocked() {\n+            State = EReadState::Blocked;\n+        }\n+\n         const ui64 Id;\n         const ui64 ShardId;\n         EReadState State;\n@@ -277,6 +283,7 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku\n     }\n \n     void Handle(TEvTxProxySchemeCache::TEvResolveKeySetResult::TPtr& ev) {\n+        ResoleShardsInProgress = false;\n         CA_LOG_D(\"TEvResolveKeySetResult was received for table: \" << StreamLookupWorker->GetTablePath());\n         if (ev->Get()->Request->ErrorCount > 0) {\n             TString errorMsg = TStringBuilder() << \"Failed to get partitioning for table: \"\n@@ -301,7 +308,7 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku\n \n         auto readIt = Reads.find(record.GetReadId());\n         if (readIt == Reads.end() || readIt->second.State != EReadState::Running) {\n-            CA_LOG_D(\"Drop read with readId: \" << record.GetReadId() << \", because it's already completed\");\n+            CA_LOG_D(\"Drop read with readId: \" << record.GetReadId() << \", because it's already completed or blocked\");\n             return;\n         }\n \n@@ -309,7 +316,8 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku\n \n         CA_LOG_D(\"Recv TEvReadResult (stream lookup) from ShardID=\" << read.ShardId\n             << \", Table = \" << StreamLookupWorker->GetTablePath()\n-            << \", ReadId=\" << record.GetReadId()\n+            << \", ReadId=\" << record.GetReadId() << \" (current ReadId=\" << ReadId << \")\"\n+            << \", SeqNo=\" << record.GetSeqNo()\n             << \", Status=\" << Ydb::StatusIds::StatusCode_Name(record.GetStatus().GetCode())\n             << \", Finished=\" << record.GetFinished()\n             << \", RowCount=\" << record.GetRowCount()\n@@ -345,27 +353,55 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku\n             Counters->DataShardIteratorFails->Inc();\n         }\n \n+        auto getIssues = [&record]() {\n+            NYql::TIssues issues;\n+            NYql::IssuesFromMessage(record.GetStatus().GetIssues(), issues);\n+            return issues;\n+        };\n+\n+        auto replyError = [&](auto message, auto status) {\n+            return RuntimeError(message, status, getIssues());\n+        };\n+\n         switch (record.GetStatus().GetCode()) {\n             case Ydb::StatusIds::SUCCESS:\n                 break;\n-            case Ydb::StatusIds::NOT_FOUND: {\n+            case Ydb::StatusIds::NOT_FOUND:\n+            {\n                 StreamLookupWorker->ResetRowsProcessing(read.Id, read.FirstUnprocessedQuery, read.LastProcessedKey);\n                 read.SetFinished();\n+                CA_LOG_D(\"NOT_FOUND was received from tablet: \" << read.ShardId << \". \"\n+                    << getIssues().ToOneLineString());\n                 return ResolveTableShards();\n             }\n             case Ydb::StatusIds::OVERLOADED: {\n+                if (CheckTotalRetriesExeeded() || CheckShardRetriesExeeded(read)) {\n+                    return replyError(\n+                        TStringBuilder() << \"Table '\" << StreamLookupWorker->GetTablePath() << \"' retry limit exceeded.\",\n+                        NYql::NDqProto::StatusIds::OVERLOADED);\n+                }\n+                CA_LOG_D(\"OVERLOADED was received from tablet: \" << read.ShardId << \".\"\n+                    << getIssues().ToOneLineString());\n+                read.SetBlocked();\n                 return RetryTableRead(read, /*allowInstantRetry = */false);\n             }\n             case Ydb::StatusIds::INTERNAL_ERROR: {\n+                if (CheckTotalRetriesExeeded() || CheckShardRetriesExeeded(read)) {\n+                    return replyError(\n+                        TStringBuilder() << \"Table '\" << StreamLookupWorker->GetTablePath() << \"' retry limit exceeded.\",\n+                        NYql::NDqProto::StatusIds::INTERNAL_ERROR);\n+                }\n+                CA_LOG_D(\"INTERNAL_ERROR was received from tablet: \" << read.ShardId << \".\"\n+                    << getIssues().ToOneLineString());\n+                read.SetBlocked();\n                 return RetryTableRead(read);\n             }\n             default: {\n-                NYql::TIssues issues;\n-                NYql::IssuesFromMessage(record.GetStatus().GetIssues(), issues);\n-                return RuntimeError(\"Read request aborted\", NYql::NDqProto::StatusIds::ABORTED, issues);\n+                return replyError(\"Read request aborted\", NYql::NDqProto::StatusIds::ABORTED);\n             }\n         }\n \n+        YQL_ENSURE(read.LastSeqNo < record.GetSeqNo());\n         read.LastSeqNo = record.GetSeqNo();\n \n         if (record.GetFinished()) {\n@@ -380,6 +416,8 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku\n             if (continuationToken.HasLastProcessedKey()) {\n                 TSerializedCellVec lastKey(continuationToken.GetLastProcessedKey());\n                 read.LastProcessedKey = TOwnedCellVec(lastKey.GetCells());\n+            } else {\n+                read.LastProcessedKey.Clear();\n             }\n \n             Counters->SentIteratorAcks->Inc();\n@@ -425,6 +463,7 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku\n             }\n         }\n         for (auto* read : toRetry) {\n+            read->SetBlocked();\n             RetryTableRead(*read);\n         }\n     }\n@@ -436,6 +475,7 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku\n         if (!Partitioning) {\n             LookupActorStateSpan.EndError(\"timeout exceeded\");\n             CA_LOG_D(\"Retry attempt to resolve shards for table: \" << StreamLookupWorker->GetTablePath());\n+            ResoleShardsInProgress = false;\n             ResolveTableShards();\n         }\n     }\n@@ -445,7 +485,9 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku\n         YQL_ENSURE(readIt != Reads.end(), \"Unexpected readId: \" << ev->Get()->ReadId);\n         auto& read = readIt->second;\n \n-        if (read.State == EReadState::Running && read.LastSeqNo <= ev->Get()->LastSeqNo) {\n+        YQL_ENSURE(read.State != EReadState::Blocked || read.LastSeqNo <= ev->Get()->LastSeqNo);\n+\n+        if ((read.State == EReadState::Running && read.LastSeqNo <= ev->Get()->LastSeqNo) || read.State == EReadState::Blocked) {\n             if (ev->Get()->InstantStart) {\n                 read.SetFinished();\n                 auto requests = StreamLookupWorker->RebuildRequest(read.Id, read.FirstUnprocessedQuery, read.LastProcessedKey, ReadId);\n@@ -538,24 +580,33 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku\n         }\n     }\n \n+    bool CheckTotalRetriesExeeded() {\n+        const auto limit = MaxTotalRetries();\n+        return limit && TotalRetryAttempts + 1 > *limit;\n+    }\n+\n+    bool CheckShardRetriesExeeded(TReadState& failedRead) {\n+        const auto& shardState = ReadsPerShard[failedRead.ShardId];\n+        return shardState.RetryAttempts + 1 > MaxShardRetries();\n+    }\n+\n     void RetryTableRead(TReadState& failedRead, bool allowInstantRetry = true) {\n         CA_LOG_D(\"Retry reading of table: \" << StreamLookupWorker->GetTablePath() << \", readId: \" << failedRead.Id\n             << \", shardId: \" << failedRead.ShardId);\n \n-        ++TotalRetryAttempts;\n-        auto totalRetriesLimit = MaxTotalRetries();\n-        if (totalRetriesLimit && TotalRetryAttempts > *totalRetriesLimit) {\n+        if (CheckTotalRetriesExeeded()) {\n             return RuntimeError(TStringBuilder() << \"Table '\" << StreamLookupWorker->GetTablePath() << \"' retry limit exceeded\",\n                 NYql::NDqProto::StatusIds::UNAVAILABLE);\n         }\n+        ++TotalRetryAttempts;\n \n-        auto& shardState = ReadsPerShard[failedRead.ShardId];\n-        ++shardState.RetryAttempts;\n-        if (shardState.RetryAttempts > MaxShardRetries()) {\n+        if (CheckShardRetriesExeeded(failedRead)) {\n             StreamLookupWorker->ResetRowsProcessing(failedRead.Id, failedRead.FirstUnprocessedQuery, failedRead.LastProcessedKey);\n             failedRead.SetFinished();\n             return ResolveTableShards();\n         }\n+        auto& shardState = ReadsPerShard[failedRead.ShardId];\n+        ++shardState.RetryAttempts;\n \n         auto delay = CalcDelay(shardState.RetryAttempts, allowInstantRetry);\n         if (delay == TDuration::Zero()) {\n@@ -573,12 +624,17 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku\n     }\n \n     void ResolveTableShards() {\n+        if (ResoleShardsInProgress) {\n+            return;\n+        }\n+\n         if (++TotalResolveShardsAttempts > MaxShardResolves()) {\n             return RuntimeError(TStringBuilder() << \"Table '\" << StreamLookupWorker->GetTablePath() << \"' resolve attempts limit exceeded\",\n                 NYql::NDqProto::StatusIds::UNAVAILABLE);\n         }\n \n         CA_LOG_D(\"Resolve shards for table: \" << StreamLookupWorker->GetTablePath());\n+        ResoleShardsInProgress = true;\n \n         Partitioning.reset();\n \n@@ -658,6 +714,7 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku\n     ui64 ReadId = 0;\n     size_t TotalRetryAttempts = 0;\n     size_t TotalResolveShardsAttempts = 0;\n+    bool ResoleShardsInProgress = false;\n \n     // stats\n     ui64 ReadRowsCount = 0;\ndiff --git a/ydb/core/kqp/runtime/kqp_write_actor.cpp b/ydb/core/kqp/runtime/kqp_write_actor.cpp\nindex 847b4a6ac41e..afe48dfffd16 100644\n--- a/ydb/core/kqp/runtime/kqp_write_actor.cpp\n+++ b/ydb/core/kqp/runtime/kqp_write_actor.cpp\n@@ -214,16 +214,13 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n         const bool inconsistentTx,\n         const bool isOlap,\n         TVector<NScheme::TTypeInfo> keyColumnTypes,\n-        const NMiniKQL::TTypeEnvironment& typeEnv,\n         std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc,\n         const std::optional<NKikimrDataEvents::TMvccSnapshot>& mvccSnapshot,\n         const NKikimrDataEvents::ELockMode lockMode,\n         const IKqpTransactionManagerPtr& txManager,\n         const TActorId sessionActorId,\n-        TIntrusivePtr<TKqpCounters> counters,\n-        NWilson::TTraceId traceId)\n+        TIntrusivePtr<TKqpCounters> counters)\n         : MessageSettings(GetWriteActorSettings())\n-        , TypeEnv(typeEnv)\n         , Alloc(alloc)\n         , MvccSnapshot(mvccSnapshot)\n         , LockMode(lockMode)\n@@ -237,16 +234,16 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n         , Callbacks(callbacks)\n         , TxManager(txManager ? txManager : CreateKqpTransactionManager(/* collectOnly= */ true))\n         , Counters(counters)\n-        , TableWriteActorSpan(TWilsonKqp::TableWriteActor, NWilson::TTraceId(traceId), \"TKqpTableWriteActor\")\n     {\n         LogPrefix = TStringBuilder() << \"Table: `\" << TablePath << \"` (\" << TableId << \"), \" << \"SessionActorId: \" << sessionActorId;\n         ShardedWriteController = CreateShardedWriteController(\n             TShardedWriteControllerSettings {\n                 .MemoryLimitTotal = MessageSettings.InFlightMemoryLimitPerActorBytes,\n-                .MemoryLimitPerMessage = MessageSettings.MemoryLimitPerMessageBytes,\n-                .MaxBatchesPerMessage = MessageSettings.MaxBatchesPerMessage,\n+                .MemoryLimitPerMessage = std::min(\n+                    MessageSettings.InFlightMemoryLimitPerActorBytes,\n+                    MessageSettings.MemoryLimitPerMessageBytes),\n+                .Inconsistent = InconsistentTx,\n             },\n-            TypeEnv,\n             Alloc);\n \n         Counters->WriteActorsCount->Inc();\n@@ -254,13 +251,29 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n \n     void Bootstrap() {\n         LogPrefix = TStringBuilder() << \"SelfId: \" << this->SelfId() << \", \" << LogPrefix;\n-        const auto partitioning = TxManager->GetPartitioning(TableId);\n-        if (!partitioning) {\n-            Resolve();\n-        } else {\n-            Partitioning = partitioning;\n-            Prepare();\n+        try {\n+            const auto partitioning = TxManager->GetPartitioning(TableId);\n+            if (!partitioning) {\n+                Resolve();\n+            } else {\n+                Partitioning = partitioning;\n+                Prepare();\n+            }\n+        } catch (const TMemoryLimitExceededException&) {\n+            RuntimeError(\n+                NYql::NDqProto::StatusIds::PRECONDITION_FAILED,\n+                NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED,\n+                TStringBuilder() << \"Memory limit exception\"\n+                    << \", current limit is \" << Alloc->GetLimit() << \" bytes.\");\n+            return;\n+        } catch (...) {\n+            RuntimeError(\n+                NYql::NDqProto::StatusIds::INTERNAL_ERROR,\n+                NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,\n+                CurrentExceptionMessage());\n+            return;\n         }\n+\n         Become(&TKqpTableWriteActor::StateProcessing);\n     }\n \n@@ -318,30 +331,17 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n         YQL_ENSURE(!Closed);\n         YQL_ENSURE(ShardedWriteController);\n         CA_LOG_D(\"Write: token=\" << token);\n-        try {\n-            ShardedWriteController->Write(token, std::move(data));\n-            UpdateShards();\n-        } catch (...) {\n-            RuntimeError(\n-                NYql::NDqProto::StatusIds::INTERNAL_ERROR,\n-                NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,\n-                CurrentExceptionMessage());\n-        }\n+        ShardedWriteController->Write(token, std::move(data));\n+        UpdateShards();\n     }\n \n     void Close(TWriteToken token) {\n         YQL_ENSURE(!Closed);\n         YQL_ENSURE(ShardedWriteController);\n         CA_LOG_D(\"Close: token=\" << token);\n-        try {\n-            ShardedWriteController->Close(token);\n-            UpdateShards();\n-        } catch (...) {\n-            RuntimeError(\n-                NYql::NDqProto::StatusIds::INTERNAL_ERROR,\n-                NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,\n-                CurrentExceptionMessage());\n-        }\n+\n+        ShardedWriteController->Close(token);\n+        UpdateShards();\n     }\n \n     void Close() {\n@@ -352,6 +352,10 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n         ShardedWriteController->Close();\n     }\n \n+    void SetParentTraceId(NWilson::TTraceId traceId) {\n+        ParentTraceId = std::move(traceId);\n+    }\n+\n     void UpdateShards() {\n         // TODO: Maybe there are better ways to initialize new shards...\n         for (const auto& shardInfo : ShardedWriteController->GetPendingShards()) {\n@@ -389,11 +393,19 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n             default:\n                 AFL_ENSURE(false)(\"unknown message\", ev->GetTypeRewrite());\n             }\n+        } catch (const TMemoryLimitExceededException&) {\n+            RuntimeError(\n+                NYql::NDqProto::StatusIds::PRECONDITION_FAILED,\n+                NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED,\n+                TStringBuilder() << \"Memory limit exception\"\n+                    << \", current limit is \" << Alloc->GetLimit() << \" bytes.\");\n+            return;\n         } catch (...) {\n             RuntimeError(\n                 NYql::NDqProto::StatusIds::INTERNAL_ERROR,\n                 NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,\n                 CurrentExceptionMessage());\n+            return;\n         }\n     }\n \n@@ -409,6 +421,9 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n \n     void Resolve() {\n         AFL_ENSURE(InconsistentTx || IsOlap);\n+        TableWriteActorSpan = NWilson::TSpan(TWilsonKqp::TableWriteActor, NWilson::TTraceId(ParentTraceId),\n+            \"WaitForTableResolve\", NWilson::EFlags::AUTO_END);\n+\n         if (IsOlap) {\n             ResolveTable();\n         } else {\n@@ -424,7 +439,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n     }\n \n     void Handle(TEvPrivate::TEvResolveRequestPlanned::TPtr&) {\n-        Resolve();\n+        RetryResolve();\n     }\n \n     void ResolveTable() {\n@@ -453,10 +468,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n         entry.ShowPrivatePath = true;\n         request->ResultSet.emplace_back(entry);\n \n-        TableWriteActorStateSpan = NWilson::TSpan(TWilsonKqp::TableWriteActorTableNavigate, TableWriteActorSpan.GetTraceId(),\n-            \"WaitForShardsResolve\", NWilson::EFlags::AUTO_END);\n-\n-        Send(MakeSchemeCacheID(), new TEvTxProxySchemeCache::TEvNavigateKeySet(request), 0, 0, TableWriteActorStateSpan.GetTraceId());\n+        Send(MakeSchemeCacheID(), new TEvTxProxySchemeCache::TEvNavigateKeySet(request), 0, 0, TableWriteActorSpan.GetTraceId());\n     }\n \n     void Handle(TEvTxProxySchemeCache::TEvNavigateKeySetResult::TPtr& ev) {\n@@ -473,7 +485,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n         SchemeEntry = resultSet[0];\n \n         CA_LOG_D(\"Resolved TableId=\" << TableId << \" (\"\n-            << TableId.PathId.ToString() << \" \"\n+            << TablePath << \" \"\n             << TableId.SchemaVersion << \")\");\n \n         if (TableId.SchemaVersion != SchemeEntry->TableId.SchemaVersion) {\n@@ -486,20 +498,22 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n \n         YQL_ENSURE(IsOlap && (SchemeEntry->Kind == NSchemeCache::TSchemeCacheNavigate::KindColumnTable));\n \n-        ResolveShards();\n+        Prepare();\n     }\n \n     void ResolveShards() {\n         YQL_ENSURE(!KeyColumnTypes.empty());\n         CA_LOG_D(\"Resolve shards for TableId=\" << TableId);\n \n+        AFL_ENSURE(InconsistentTx); // Only for CTAS\n+\n         const TVector<TCell> minKey(KeyColumnTypes.size());\n         const TTableRange range(minKey, true, {}, false, false);\n         YQL_ENSURE(range.IsFullRange(KeyColumnTypes.size()));\n         auto keyRange = MakeHolder<TKeyDesc>(\n             TableId,\n             range,\n-            TKeyDesc::ERowOperation::Update,\n+            TKeyDesc::ERowOperation::Update, // Only for CTAS\n             KeyColumnTypes,\n             TVector<TKeyDesc::TColumnOp>{});\n \n@@ -507,7 +521,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n         request->ResultSet.emplace_back(std::move(keyRange));\n \n         TAutoPtr<TEvTxProxySchemeCache::TEvResolveKeySet> resolveReq(new TEvTxProxySchemeCache::TEvResolveKeySet(request));\n-        Send(MakeSchemeCacheID(), resolveReq.Release(), 0, 0, TableWriteActorStateSpan.GetTraceId());\n+        Send(MakeSchemeCacheID(), resolveReq.Release(), 0, 0, TableWriteActorSpan.GetTraceId());\n     }\n \n     void Handle(TEvTxProxySchemeCache::TEvResolveKeySetResult::TPtr& ev) {\n@@ -548,10 +562,12 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n             << \", Cookie=\" << ev->Cookie);\n         UpdateStats(ev->Get()->Record.GetTxStats());\n \n+        TxManager->AddParticipantNode(ev->Sender.NodeId());\n+\n         switch (ev->Get()->GetStatus()) {\n         case NKikimrDataEvents::TEvWriteResult::STATUS_UNSPECIFIED: {\n             CA_LOG_E(\"Got UNSPECIFIED for table `\"\n-                    << TableId.PathId.ToString() << \"`.\"\n+                    << TablePath << \"`.\"\n                     << \" ShardID=\" << ev->Get()->Record.GetOrigin() << \",\"\n                     << \" Sink=\" << this->SelfId() << \".\"\n                     << getIssues().ToOneLineString());\n@@ -559,7 +575,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n             RuntimeError(\n                 NYql::NDqProto::StatusIds::UNSPECIFIED,\n                 NYql::TIssuesIds::DEFAULT_ERROR,\n-                TStringBuilder() << \"Unspecified error for table `\"\n+                TStringBuilder() << \"Unspecified error. Table `\"\n                     << TablePath << \"`.\",\n                 getIssues());\n             return;\n@@ -574,7 +590,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n         }\n         case NKikimrDataEvents::TEvWriteResult::STATUS_ABORTED: {\n             CA_LOG_E(\"Got ABORTED for table `\"\n-                    << TableId.PathId.ToString() << \"`.\"\n+                    << TablePath << \"`.\"\n                     << \" ShardID=\" << ev->Get()->Record.GetOrigin() << \",\"\n                     << \" Sink=\" << this->SelfId() << \".\"\n                     << getIssues().ToOneLineString());\n@@ -582,14 +598,13 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n             RuntimeError(\n                 NYql::NDqProto::StatusIds::ABORTED,\n                 NYql::TIssuesIds::KIKIMR_OPERATION_ABORTED,\n-                TStringBuilder() << \"Aborted for table `\"\n-                    << TablePath << \"`.\",\n+                TStringBuilder() << \"Operation aborted.\",\n                 getIssues());\n             return;\n         }\n         case NKikimrDataEvents::TEvWriteResult::STATUS_WRONG_SHARD_STATE:\n             CA_LOG_E(\"Got WRONG SHARD STATE for table `\"\n-                    << SchemeEntry->TableId.PathId.ToString() << \"`.\"\n+                    << TablePath << \"`.\"\n                     << \" ShardID=\" << ev->Get()->Record.GetOrigin() << \",\"\n                     << \" Sink=\" << this->SelfId() << \".\"\n                     << getIssues().ToOneLineString());\n@@ -600,16 +615,16 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n                 RetryResolve();\n             } else {\n                 RuntimeError(\n-                    NYql::NDqProto::StatusIds::PRECONDITION_FAILED,\n+                    NYql::NDqProto::StatusIds::UNAVAILABLE,\n                     NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,\n-                    TStringBuilder() << \"Wrong shard state for table `\"\n+                    TStringBuilder() << \"Wrong shard state. Table `\"\n                         << TablePath << \"`.\",\n                     getIssues());\n             }\n             return;\n         case NKikimrDataEvents::TEvWriteResult::STATUS_INTERNAL_ERROR: {\n             CA_LOG_E(\"Got INTERNAL ERROR for table `\"\n-                    << TableId.PathId.ToString() << \"`.\"\n+                    << TablePath << \"`.\"\n                     << \" ShardID=\" << ev->Get()->Record.GetOrigin() << \",\"\n                     << \" Sink=\" << this->SelfId() << \".\"\n                     << getIssues().ToOneLineString());\n@@ -617,14 +632,13 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n             RuntimeError(\n                 NYql::NDqProto::StatusIds::INTERNAL_ERROR,\n                 NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,\n-                TStringBuilder() << \"Internal error for table `\"\n-                    << TablePath << \"`.\",\n+                TStringBuilder() << \"Internal error while executing transaction.\",\n                 getIssues());\n             return;\n         }\n         case NKikimrDataEvents::TEvWriteResult::STATUS_DISK_SPACE_EXHAUSTED: {\n             CA_LOG_E(\"Got DISK_SPACE_EXHAUSTED for table `\"\n-                    << TableId.PathId.ToString() << \"`.\"\n+                    << TablePath << \"`.\"\n                     << \" ShardID=\" << ev->Get()->Record.GetOrigin() << \",\"\n                     << \" Sink=\" << this->SelfId() << \".\"\n                     << getIssues().ToOneLineString());\n@@ -632,14 +646,33 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n             RuntimeError(\n                 NYql::NDqProto::StatusIds::UNAVAILABLE,\n                 NYql::TIssuesIds::KIKIMR_DISK_SPACE_EXHAUSTED,\n-                TStringBuilder() << \"Disk space exhausted for table `\"\n+                TStringBuilder() << \"Disk space exhausted. Table `\"\n                     << TablePath << \"`.\",\n                 getIssues());\n             return;\n         }\n+        case NKikimrDataEvents::TEvWriteResult::STATUS_OUT_OF_SPACE: {\n+            CA_LOG_W(\"Got OUT_OF_SPACE for table `\"\n+                << TablePath << \"`.\"\n+                << \" ShardID=\" << ev->Get()->Record.GetOrigin() << \",\"\n+                << \" Sink=\" << this->SelfId() << \".\"\n+                << \" Ignored this error.\"\n+                << getIssues().ToOneLineString());\n+            // TODO: support waiting\n+            if (!InconsistentTx)  {\n+                TxManager->SetError(ev->Get()->Record.GetOrigin());\n+                RuntimeError(\n+                    NYql::NDqProto::StatusIds::OVERLOADED,\n+                    NYql::TIssuesIds::KIKIMR_OVERLOADED,\n+                    TStringBuilder() << \"Tablet \" << ev->Get()->Record.GetOrigin() << \" is out of space. Table `\"\n+                        << TablePath << \"`.\",\n+                    getIssues());\n+            }\n+            return;\n+        }        \n         case NKikimrDataEvents::TEvWriteResult::STATUS_OVERLOADED: {\n             CA_LOG_W(\"Got OVERLOADED for table `\"\n-                << TableId.PathId.ToString() << \"`.\"\n+                << TablePath << \"`.\"\n                 << \" ShardID=\" << ev->Get()->Record.GetOrigin() << \",\"\n                 << \" Sink=\" << this->SelfId() << \".\"\n                 << \" Ignored this error.\"\n@@ -650,7 +683,8 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n                 RuntimeError(\n                     NYql::NDqProto::StatusIds::OVERLOADED,\n                     NYql::TIssuesIds::KIKIMR_OVERLOADED,\n-                    TStringBuilder() << \"Tablet \" << ev->Get()->Record.GetOrigin() << \" is overloaded. Table `\"\n+                    TStringBuilder() << \"Kikimr cluster or one of its subsystems is overloaded.\"\n+                        << \" Tablet \" << ev->Get()->Record.GetOrigin() << \" is overloaded. Table `\"\n                         << TablePath << \"`.\",\n                     getIssues());\n             }\n@@ -658,7 +692,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n         }\n         case NKikimrDataEvents::TEvWriteResult::STATUS_CANCELLED: {\n             CA_LOG_E(\"Got CANCELLED for table `\"\n-                    << TableId.PathId.ToString() << \"`.\"\n+                    << TablePath << \"`.\"\n                     << \" ShardID=\" << ev->Get()->Record.GetOrigin() << \",\"\n                     << \" Sink=\" << this->SelfId() << \".\"\n                     << getIssues().ToOneLineString());\n@@ -666,14 +700,13 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n             RuntimeError(\n                 NYql::NDqProto::StatusIds::CANCELLED,\n                 NYql::TIssuesIds::KIKIMR_OPERATION_CANCELLED,\n-                TStringBuilder() << \"Cancelled request to table `\"\n-                    << TablePath << \"`.\",\n+                TStringBuilder() << \"Operation cancelled.\",\n                 getIssues());\n             return;\n         }\n         case NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST: {\n             CA_LOG_E(\"Got BAD REQUEST for table `\"\n-                    << TableId.PathId.ToString() << \"`.\"\n+                    << TablePath << \"`.\"\n                     << \" ShardID=\" << ev->Get()->Record.GetOrigin() << \",\"\n                     << \" Sink=\" << this->SelfId() << \".\"\n                     << getIssues().ToOneLineString());\n@@ -688,7 +721,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n         }\n         case NKikimrDataEvents::TEvWriteResult::STATUS_SCHEME_CHANGED: {\n             CA_LOG_E(\"Got SCHEME CHANGED for table `\"\n-                    << TableId.PathId.ToString() << \"`.\"\n+                    << TablePath << \"`.\"\n                     << \" ShardID=\" << ev->Get()->Record.GetOrigin() << \",\"\n                     << \" Sink=\" << this->SelfId() << \".\"\n                     << getIssues().ToOneLineString());\n@@ -708,7 +741,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n         }\n         case NKikimrDataEvents::TEvWriteResult::STATUS_LOCKS_BROKEN: {\n             CA_LOG_E(\"Got LOCKS BROKEN for table `\"\n-                    << TableId.PathId.ToString() << \"`.\"\n+                    << TablePath << \"`.\"\n                     << \" ShardID=\" << ev->Get()->Record.GetOrigin() << \",\"\n                     << \" Sink=\" << this->SelfId() << \".\"\n                     << getIssues().ToOneLineString());\n@@ -725,7 +758,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n             return;\n         }\n         case NKikimrDataEvents::TEvWriteResult::STATUS_CONSTRAINT_VIOLATION: {\n-            CA_LOG_E(\"Got CONSTRAINT VIOLATION for table.\"\n+            CA_LOG_E(\"Got CONSTRAINT VIOLATION for table `\" << TablePath << \"`.\"\n                     << \" ShardID=\" << ev->Get()->Record.GetOrigin() << \",\"\n                     << \" Sink=\" << this->SelfId() << \".\"\n                     << getIssues().ToOneLineString());\n@@ -778,19 +811,20 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n                 return builder;\n             }());\n \n-        for (const auto& lock : ev->Get()->Record.GetTxLocks()) {\n-            Y_ABORT_UNLESS(Mode == EMode::WRITE);\n-            if (!TxManager->AddLock(ev->Get()->Record.GetOrigin(), lock)) {\n-                YQL_ENSURE(TxManager->BrokenLocks());\n-                NYql::TIssues issues;\n-                issues.AddIssue(*TxManager->GetLockIssue());\n-                RuntimeError(\n-                    NYql::NDqProto::StatusIds::ABORTED,\n-                    NYql::TIssuesIds::KIKIMR_OPERATION_ABORTED,\n-                    TStringBuilder() << \"Transaction locks invalidated. Table `\"\n-                        << TablePath << \"`.\",\n-                    issues);\n-                return;\n+        if (Mode == EMode::WRITE) {\n+            for (const auto& lock : ev->Get()->Record.GetTxLocks()) {\n+                if (!TxManager->AddLock(ev->Get()->Record.GetOrigin(), lock)) {\n+                    YQL_ENSURE(TxManager->BrokenLocks());\n+                    NYql::TIssues issues;\n+                    issues.AddIssue(*TxManager->GetLockIssue());\n+                    RuntimeError(\n+                        NYql::NDqProto::StatusIds::ABORTED,\n+                        NYql::TIssuesIds::KIKIMR_OPERATION_ABORTED,\n+                        TStringBuilder() << \"Transaction locks invalidated. Table `\"\n+                            << TablePath << \"`.\",\n+                        issues);\n+                    return;\n+                }\n             }\n         }\n \n@@ -847,13 +881,16 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n         UpdateShards();\n     }\n \n-    void Flush() {\n+    bool Flush() {\n         for (const auto& shardInfo : ShardedWriteController->GetPendingShards()) {\n-            SendDataToShard(shardInfo.ShardId);\n+            if (!SendDataToShard(shardInfo.ShardId)) {\n+                return false;\n+            }\n         }\n+        return true;\n     }\n \n-    void SendDataToShard(const ui64 shardId) {\n+    bool SendDataToShard(const ui64 shardId) {\n         YQL_ENSURE(Mode != EMode::COMMIT);\n \n         const auto metadata = ShardedWriteController->GetMessageMetadata(shardId);\n@@ -870,7 +907,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n                     << \"ShardId=\" << shardId\n                     << \" for table '\" << TablePath\n                     << \"': retry limit exceeded.\");\n-            return;\n+            return false;\n         }\n \n         const bool isPrepare = metadata->IsFinal && Mode == EMode::PREPARE;\n@@ -945,7 +982,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n             new TEvPipeCache::TEvForward(evWrite.release(), shardId, /* subscribe */ true),\n             0,\n             metadata->Cookie,\n-            TableWriteActorSpan.GetTraceId());\n+            NWilson::TTraceId(ParentTraceId));\n \n         ShardedWriteController->OnMessageSent(shardId, metadata->Cookie);\n \n@@ -959,6 +996,8 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n                     0,\n                     metadata->Cookie));\n         }\n+\n+        return true;\n     }\n \n     void RetryShard(const ui64 shardId, const std::optional<ui64> ifCookieEqual) {\n@@ -996,21 +1035,26 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n \n             Schedule(reattachState.ReattachInfo.Delay, new TEvPrivate::TEvReattachToShard(ev->Get()->TabletId));\n         } else {\n-            TxManager->SetError(ev->Get()->TabletId);\n-            if (Mode == EMode::IMMEDIATE_COMMIT || Mode == EMode::COMMIT) {\n+            if (TxManager->GetState(ev->Get()->TabletId) == IKqpTransactionManager::EXECUTING) {\n+                TxManager->SetError(ev->Get()->TabletId);\n                 RuntimeError(\n                     NYql::NDqProto::StatusIds::UNDETERMINED,\n                     NYql::TIssuesIds::KIKIMR_OPERATION_STATE_UNKNOWN,\n                     TStringBuilder()\n-                        << \"Error writing to table `\" << TableId.PathId.ToString() << \"`\"\n-                        << \". Transaction state unknown for shard \" << ev->Get()->TabletId << \".\");\n+                        << \"State of operation is unknown. \"\n+                        << \"Error writing to table `\" << TablePath << \"`\"\n+                        << \". Transaction state unknown for tablet \" << ev->Get()->TabletId << \".\");\n+                return;\n             } else {\n+                TxManager->SetError(ev->Get()->TabletId);\n                 RuntimeError(\n                     NYql::NDqProto::StatusIds::UNAVAILABLE,\n                     NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,\n                     TStringBuilder()\n-                        << \"Error writing to table `\" << TableId.PathId.ToString() << \"`\"\n+                        << \"Kikimr cluster or one of its subsystems was unavailable. \"\n+                        << \"Error writing to table `\" << TablePath << \"`\"\n                         << \": can't deliver message to tablet \" << ev->Get()->TabletId << \".\");\n+                return;\n             }\n         }\n     }\n@@ -1028,8 +1072,10 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n         switch (shardState) {\n             case IKqpTransactionManager::EXECUTING:\n                 YQL_ENSURE(Mode == EMode::COMMIT || Mode == EMode::IMMEDIATE_COMMIT);\n+                break;\n             case IKqpTransactionManager::PREPARED:\n                 YQL_ENSURE(Mode == EMode::PREPARE);\n+                break;\n             case IKqpTransactionManager::PREPARING:\n             case IKqpTransactionManager::FINISHED:\n             case IKqpTransactionManager::ERROR:\n@@ -1052,14 +1098,16 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n                     << \"ShardId=\" << shardId\n                     << \" for table '\" << TablePath\n                     << \"': attach transaction failed.\");\n+            return;\n         } else {\n             RuntimeError(\n-                NYql::NDqProto::StatusIds::UNAVAILABLE,\n+                NYql::NDqProto::StatusIds::UNDETERMINED,\n                 NYql::TIssuesIds::KIKIMR_OPERATION_STATE_UNKNOWN,\n                 TStringBuilder()\n                     << \"ShardId=\" << shardId\n                     << \" for table '\" << TablePath\n                     << \"': attach transaction failed.\");\n+            return;\n         }\n     }\n \n@@ -1099,31 +1147,24 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n     }\n \n     void Prepare() {\n-        TableWriteActorStateSpan.EndOk();\n+        if (TableWriteActorSpan) {\n+            TableWriteActorSpan.EndOk(); // Resolve finished\n+        }\n+\n         ResolveAttempts = 0;\n \n-        try {\n-            if (IsOlap) {\n-                YQL_ENSURE(SchemeEntry);\n-                ShardedWriteController->OnPartitioningChanged(*SchemeEntry);\n-            } else {\n-                ShardedWriteController->OnPartitioningChanged(Partitioning);\n-                Partitioning.reset();\n-            }\n-        } catch (...) {\n-            RuntimeError(\n-                NYql::NDqProto::StatusIds::INTERNAL_ERROR,\n-                NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,\n-                CurrentExceptionMessage());\n+        if (IsOlap) {\n+            YQL_ENSURE(SchemeEntry);\n+            ShardedWriteController->OnPartitioningChanged(*SchemeEntry);\n+        } else {\n+            ShardedWriteController->OnPartitioningChanged(Partitioning);\n+            Partitioning.reset();\n         }\n \n         Callbacks->OnReady();\n     }\n \n     void RuntimeError(NYql::NDqProto::StatusIds::StatusCode statusCode, NYql::EYqlIssueCode id, const TString& message, const NYql::TIssues& subIssues = {}) {\n-        if (TableWriteActorStateSpan) {\n-            TableWriteActorStateSpan.EndError(message);\n-        }\n         if (TableWriteActorSpan) {\n             TableWriteActorSpan.EndError(message);\n         }\n@@ -1132,9 +1173,6 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n     }\n \n     void RuntimeError(NYql::NDqProto::StatusIds::StatusCode statusCode, NYql::TIssues&& issues) {\n-        if (TableWriteActorStateSpan) {\n-            TableWriteActorStateSpan.EndError(issues.ToOneLineString());\n-        }\n         if (TableWriteActorSpan) {\n             TableWriteActorSpan.EndError(issues.ToOneLineString());\n         }\n@@ -1142,7 +1180,16 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n         Callbacks->OnError(statusCode, std::move(issues));\n     }\n \n-    void PassAway() override {;\n+    void Unlink() {\n+        Send(PipeCacheId, new TEvPipeCache::TEvUnlink(0));\n+    }\n+\n+    void PassAway() override {\n+        {\n+            Y_ABORT_UNLESS(Alloc);\n+            TGuard<NMiniKQL::TScopedAlloc> allocGuard(*Alloc);\n+            ShardedWriteController.Reset();\n+        }\n         Counters->WriteActorsCount->Dec();\n         Send(PipeCacheId, new TEvPipeCache::TEvUnlink(0));\n         TActorBootstrapped<TKqpTableWriteActor>::PassAway();\n@@ -1171,6 +1218,10 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n     }\n \n     void FillStats(NYql::NDqProto::TDqTaskStats* stats) {\n+        if (Stats.ReadRows + Stats.WriteRows + Stats.EraseRows == 0) {\n+            // Avoid empty table_access stats\n+            return;\n+        }\n         NYql::NDqProto::TDqTableStats* tableStats = nullptr;\n         for (size_t i = 0; i < stats->TablesSize(); ++i) {\n             auto* table = stats->MutableTables(i);\n@@ -1206,7 +1257,6 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n \n     TString LogPrefix;\n     TWriteActorSettings MessageSettings;\n-    const NMiniKQL::TTypeEnvironment& TypeEnv;\n     std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;\n \n     const std::optional<NKikimrDataEvents::TMvccSnapshot> MvccSnapshot;\n@@ -1239,8 +1289,8 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {\n \n     TKqpTableWriterStatistics Stats;\n \n+    NWilson::TTraceId ParentTraceId;\n     NWilson::TSpan TableWriteActorSpan;\n-    NWilson::TSpan TableWriteActorStateSpan;\n };\n \n class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, public NYql::NDq::IDqComputeActorAsyncOutput, public IKqpTableWriterCallbacks {\n@@ -1257,7 +1307,6 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu\n         , OutputIndex(args.OutputIndex)\n         , Callbacks(args.Callback)\n         , Counters(counters)\n-        , TypeEnv(args.TypeEnv)\n         , Alloc(args.Alloc)\n         , TxId(std::get<ui64>(args.TxId))\n         , TableId(\n@@ -1275,10 +1324,11 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu\n             Settings.GetWriteIndexes().begin(),\n             Settings.GetWriteIndexes().end());\n \n+        TGuard guard(*Alloc);\n         if (Settings.GetIsOlap()) {\n-            Batcher = CreateColumnDataBatcher(columnsMetadata, std::move(writeIndex));\n+            Batcher = CreateColumnDataBatcher(columnsMetadata, std::move(writeIndex), Alloc);\n         } else {\n-            Batcher = CreateRowDataBatcher(columnsMetadata, std::move(writeIndex));\n+            Batcher = CreateRowDataBatcher(columnsMetadata, std::move(writeIndex), Alloc);\n         }\n     }\n \n@@ -1303,15 +1353,13 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu\n                 Settings.GetInconsistentTx(),\n                 Settings.GetIsOlap(),\n                 std::move(keyColumnTypes),\n-                TypeEnv,\n                 Alloc,\n                 Settings.GetMvccSnapshot(),\n                 Settings.GetLockMode(),\n                 nullptr,\n                 TActorId{},\n-                Counters,\n-                DirectWriteActorSpan.GetTraceId());\n-\n+                Counters);\n+            WriteTableActor->SetParentTraceId(DirectWriteActorSpan.GetTraceId());\n             WriteTableActorId = RegisterWithSameMailbox(WriteTableActor);\n \n             TVector<NKikimrKqp::TKqpColumnMetadataProto> keyColumnsMetadata(\n@@ -1331,12 +1379,21 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu\n                 std::move(writeIndex),\n                 Settings.GetPriority());\n             WaitingForTableActor = true;\n+        } catch (const TMemoryLimitExceededException&) {\n+            RuntimeError(\n+                NYql::NDqProto::StatusIds::PRECONDITION_FAILED,\n+                NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED,\n+                TStringBuilder() << \"Memory limit exception\"\n+                    << \", current limit is \" << Alloc->GetLimit() << \" bytes.\",\n+                {});\n+            return;\n         } catch (...) {\n             RuntimeError(\n                 NYql::NDqProto::StatusIds::INTERNAL_ERROR,\n                 NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,\n                 CurrentExceptionMessage(),\n                 {});\n+            return;\n         }\n     }\n \n@@ -1392,40 +1449,77 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu\n         EgressStats.Resume();\n         Y_UNUSED(size);\n \n-        Batcher->AddData(data);\n-        YQL_ENSURE(WriteTableActor);\n-        WriteTableActor->Write(*WriteToken, Batcher->Build());\n-        if (Closed) {\n-            WriteTableActor->Close(*WriteToken);\n-            WriteTableActor->Close();\n+        try {\n+            Batcher->AddData(data);\n+            YQL_ENSURE(WriteTableActor);\n+            WriteTableActor->Write(*WriteToken, Batcher->Build());\n+            if (Closed) {\n+                WriteTableActor->Close(*WriteToken);\n+                WriteTableActor->Close();\n+            }\n+        } catch (const TMemoryLimitExceededException&) {\n+            RuntimeError(\n+                NYql::NDqProto::StatusIds::PRECONDITION_FAILED,\n+                NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED,\n+                TStringBuilder() << \"Memory limit exception\"\n+                    << \", current limit is \" << Alloc->GetLimit() << \" bytes.\",\n+                {});\n+            return;\n+        } catch (...) {\n+            RuntimeError(\n+                NYql::NDqProto::StatusIds::INTERNAL_ERROR,\n+                NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,\n+                CurrentExceptionMessage(),\n+                {});\n+            return;\n         }\n+\n         Process();\n     }\n \n     void Process() {\n-        const bool outOfMemory = GetFreeSpace() <= 0;\n-        if (outOfMemory) {\n-            WaitingForTableActor = true;\n-        } else if (WaitingForTableActor) {\n-            ResumeExecution();\n-        }\n+        try {\n+            const bool outOfMemory = GetFreeSpace() <= 0;\n+            if (outOfMemory) {\n+                WaitingForTableActor = true;\n+            } else if (WaitingForTableActor) {\n+                ResumeExecution();\n+            }\n \n-        if (outOfMemory && !Settings.GetEnableStreamWrite()) {\n+            if (outOfMemory && !Settings.GetEnableStreamWrite()) {\n+                RuntimeError(\n+                    NYql::NDqProto::StatusIds::PRECONDITION_FAILED,\n+                    NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED,\n+                    TStringBuilder() << \"Stream write can't be used for this query.\",\n+                    {});\n+                return;\n+            }\n+\n+            if (Closed || outOfMemory) {\n+                if (!WriteTableActor->Flush()) {\n+                    return;\n+                }\n+            }\n+\n+            if (Closed && WriteTableActor->IsFinished()) {\n+                CA_LOG_D(\"Write actor finished\");\n+                Callbacks->OnAsyncOutputFinished(GetOutputIndex());\n+            }\n+        } catch (const TMemoryLimitExceededException&) {\n             RuntimeError(\n                 NYql::NDqProto::StatusIds::PRECONDITION_FAILED,\n                 NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED,\n-                TStringBuilder() << \"Stream write can't be used for this query.\",\n+                TStringBuilder() << \"Memory limit exception\"\n+                    << \", current limit is \" << Alloc->GetLimit() << \" bytes.\",\n+                {});\n+            return;\n+        } catch (...) {\n+            RuntimeError(\n+                NYql::NDqProto::StatusIds::INTERNAL_ERROR,\n+                NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,\n+                CurrentExceptionMessage(),\n                 {});\n             return;\n-        }\n-\n-        if (Closed || outOfMemory) {\n-            WriteTableActor->Flush();\n-        }\n-\n-        if (Closed && WriteTableActor->IsFinished()) {\n-            CA_LOG_D(\"Write actor finished\");\n-            Callbacks->OnAsyncOutputFinished(GetOutputIndex());\n         }\n     }\n \n@@ -1504,7 +1598,6 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu\n     NYql::NDq::TDqAsyncStats EgressStats;\n     NYql::NDq::IDqComputeActorAsyncOutput::ICallbacks * Callbacks = nullptr;\n     TIntrusivePtr<TKqpCounters> Counters;\n-    const NMiniKQL::TTypeEnvironment& TypeEnv;\n     std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;\n     IDataBatcherPtr Batcher;\n \n@@ -1599,17 +1692,14 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n         : SessionActorId(settings.SessionActorId)\n         , MessageSettings(GetWriteActorSettings())\n         , TxManager(settings.TxManager)\n-        , Alloc(std::make_shared<NKikimr::NMiniKQL::TScopedAlloc>(__LOCATION__))\n-        , TypeEnv(*Alloc)\n+        , Alloc(settings.Alloc)\n         , Counters(settings.Counters)\n         , TxProxyMon(settings.TxProxyMon)\n-        , BufferWriteActor(TWilsonKqp::BufferWriteActor, NWilson::TTraceId(settings.TraceId), \"TKqpBufferWriteActor\", NWilson::EFlags::AUTO_END)\n-        , BufferWriteActorState(TWilsonKqp::BufferWriteActorState, BufferWriteActor.GetTraceId(),\n-            \"BufferWriteActorState::Writing\", NWilson::EFlags::AUTO_END)\n+        , BufferWriteActorSpan(TWilsonKqp::BufferWriteActor, NWilson::TTraceId(settings.TraceId), \"BufferWriteActor\", NWilson::EFlags::AUTO_END)\n     {\n         State = EState::WRITING;\n-        Alloc->Release();\n         Counters->BufferActorsCount->Inc();\n+        UpdateTracingState(\"Write\", BufferWriteActorSpan.GetTraceId());\n     }\n \n     void Bootstrap() {\n@@ -1636,12 +1726,21 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n             default:\n                 AFL_ENSURE(false)(\"unknown message\", ev->GetTypeRewrite());\n             }\n+        } catch (const TMemoryLimitExceededException&) {\n+            ReplyErrorAndDie(\n+                NYql::NDqProto::StatusIds::PRECONDITION_FAILED,\n+                NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED,\n+                TStringBuilder() << \"Memory limit exception\"\n+                    << \", current limit is \" << Alloc->GetLimit() << \" bytes.\",\n+                {});\n+            return;\n         } catch (...) {\n             ReplyErrorAndDie(\n                 NYql::NDqProto::StatusIds::INTERNAL_ERROR,\n                 NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,\n                 CurrentExceptionMessage(),\n                 {});\n+            return;\n         }\n     }\n \n@@ -1680,14 +1779,13 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n                     InconsistentTx,\n                     settings.IsOlap,\n                     std::move(keyColumnTypes),\n-                    TypeEnv,\n                     Alloc,\n                     settings.TransactionSettings.MvccSnapshot,\n                     settings.TransactionSettings.LockMode,\n                     TxManager,\n                     SessionActorId,\n-                    Counters,\n-                    BufferWriteActor.GetTraceId());\n+                    Counters);\n+                writeInfo.WriteTableActor->SetParentTraceId(BufferWriteActorStateSpan.GetTraceId());\n                 writeInfo.WriteTableActorId = RegisterWithSameMailbox(writeInfo.WriteTableActor);\n                 CA_LOG_D(\"Create new TableWriteActor for table `\" << settings.TablePath << \"` (\" << settings.TableId << \"). lockId=\" << LockTxId << \" \" << writeInfo.WriteTableActorId);\n             }\n@@ -1716,9 +1814,11 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n         Process();\n     }\n \n-    void Process() {\n+    bool Process() {\n         ProcessRequestQueue();\n-        ProcessWrite();\n+        if (!ProcessWrite()) {\n+            return false;\n+        }\n         ProcessAckQueue();\n \n         if (State == EState::FLUSHING) {\n@@ -1730,6 +1830,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n                 OnFlushed();\n             }\n         }\n+        return true;\n     }\n \n     void ProcessRequestQueue() {\n@@ -1777,7 +1878,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n         }\n     }\n \n-    void ProcessWrite() {\n+    bool ProcessWrite() {\n         const bool outOfMemory = GetTotalFreeSpace() <= 0;\n         const bool needToFlush = outOfMemory\n             || State == EState::FLUSHING\n@@ -1785,28 +1886,31 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n             || State == EState::COMMITTING\n             || State == EState::ROLLINGBACK;\n \n-        if (EnableStreamWrite && outOfMemory) {\n+        if (!EnableStreamWrite && outOfMemory) {\n             ReplyErrorAndDie(\n                 NYql::NDqProto::StatusIds::PRECONDITION_FAILED,\n                 NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED,\n                 TStringBuilder() << \"Stream write queries aren't allowed.\",\n                 {});\n+            return false;\n         }\n \n         if (needToFlush) {\n             CA_LOG_D(\"Flush data\");\n             for (auto& [_, info] : WriteInfos) {\n                 if (info.WriteTableActor->IsReady()) {\n-                    info.WriteTableActor->Flush();\n+                    if (!info.WriteTableActor->Flush()) {\n+                        return false;\n+                    }\n                 }\n             }\n         }\n+        return true;\n     }\n \n-    void Flush() {\n+    bool Flush(NWilson::TTraceId traceId) {\n         Counters->BufferActorFlushes->Inc();\n-        BufferWriteActorState = NWilson::TSpan(TWilsonKqp::BufferWriteActorState, BufferWriteActor.GetTraceId(),\n-            \"BufferWriteActorState::Flushing\", NWilson::EFlags::AUTO_END);\n+        UpdateTracingState(\"Flush\", std::move(traceId));\n         OperationStartTime = TInstant::Now();\n \n         CA_LOG_D(\"Start flush\");\n@@ -1815,12 +1919,11 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n         for (auto& [_, queue] : DataQueues) {\n             YQL_ENSURE(queue.empty());\n         }\n-        Process();\n+        return Process();\n     }\n \n-    void Prepare(const ui64 txId) {\n-        BufferWriteActorState = NWilson::TSpan(TWilsonKqp::BufferWriteActorState, BufferWriteActor.GetTraceId(),\n-            \"BufferWriteActorState::Preparing\", NWilson::EFlags::AUTO_END);\n+    bool Prepare(const ui64 txId, NWilson::TTraceId traceId) {\n+        UpdateTracingState(\"Commit\", std::move(traceId));\n         OperationStartTime = TInstant::Now();\n \n         CA_LOG_D(\"Start prepare for distributed commit\");\n@@ -1834,15 +1937,17 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n             info.WriteTableActor->SetPrepare(txId);\n         }\n         Close();\n-        Process();\n+        if (!Process()) {\n+            return false;\n+        }\n         SendToExternalShards(false);\n         SendToTopics(false);\n+        return true;\n     }\n \n-    void ImmediateCommit() {\n+    bool ImmediateCommit(NWilson::TTraceId traceId) {\n         Counters->BufferActorImmediateCommits->Inc();\n-        BufferWriteActorState = NWilson::TSpan(TWilsonKqp::BufferWriteActorState, BufferWriteActor.GetTraceId(),\n-            \"BufferWriteActorState::Committing\", NWilson::EFlags::AUTO_END);\n+        UpdateTracingState(\"Commit\", std::move(traceId));\n         OperationStartTime = TInstant::Now();\n \n         CA_LOG_D(\"Start immediate commit\");\n@@ -1856,14 +1961,15 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n             info.WriteTableActor->SetImmediateCommit();\n         }\n         Close();\n-        Process();\n+        if (!Process()) {\n+            return false;\n+        }\n         SendToTopics(true);\n+        return true;\n     }\n \n     void DistributedCommit() {\n         Counters->BufferActorDistributedCommits->Inc();\n-        BufferWriteActorState = NWilson::TSpan(TWilsonKqp::BufferWriteActorState, BufferWriteActor.GetTraceId(),\n-            \"BufferWriteActorState::Committing\", NWilson::EFlags::AUTO_END);\n         OperationStartTime = TInstant::Now();\n \n         CA_LOG_D(\"Start distributed commit with TxId=\" << *TxId);\n@@ -1878,10 +1984,9 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n         SendCommitToCoordinator();\n     }\n \n-    void Rollback() {\n+    void Rollback(NWilson::TTraceId traceId) {\n         Counters->BufferActorRollbacks->Inc();\n-        BufferWriteActorState = NWilson::TSpan(TWilsonKqp::BufferWriteActorState, BufferWriteActor.GetTraceId(),\n-            \"BufferWriteActorState::RollingBack\", NWilson::EFlags::AUTO_END);\n+        UpdateTracingState(\"RollBack\", std::move(traceId));\n \n         CA_LOG_D(\"Start rollback\");\n         State = EState::ROLLINGBACK;\n@@ -1938,7 +2043,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n                 new TEvPipeCache::TEvForward(evWrite.release(), shardId, /* subscribe */ true),\n                 0,\n                 0,\n-                BufferWriteActor.GetTraceId());\n+                BufferWriteActorStateSpan.GetTraceId());\n         }\n     }\n \n@@ -1980,7 +2085,6 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n             }\n \n             SendTime[tabletId] = TInstant::Now();\n-            auto traceId = BufferWriteActor.GetTraceId();\n \n             CA_LOG_D(\"Executing KQP transaction on topic tablet: \" << tabletId\n             << \", writeId: \" << writeId << \", isImmediateCommit: \" << isImmediateCommit);\n@@ -1990,7 +2094,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n                 new TEvPipeCache::TEvForward(ev.release(), tabletId, /* subscribe */ true),\n                 0,\n                 0,\n-                std::move(traceId));\n+                BufferWriteActorStateSpan.GetTraceId());\n         }\n     }\n \n@@ -2029,7 +2133,10 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n             << \", shards: \" << affectedSet.size());\n         Send(\n             MakePipePerNodeCacheID(false),\n-            new TEvPipeCache::TEvForward(ev.Release(), *Coordinator, /* subscribe */ true));\n+            new TEvPipeCache::TEvForward(ev.Release(), *Coordinator, /* subscribe */ true),\n+            0,\n+            0,\n+            BufferWriteActorStateSpan.GetTraceId());\n     }\n \n     void Close() {\n@@ -2209,7 +2316,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n                 ReplyErrorAndDie(\n                     NYql::NDqProto::StatusIds::UNAVAILABLE,\n                     NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,\n-                    TStringBuilder() << \"Failed to deviler message to coordinator.\",\n+                    TStringBuilder() << \"Kikimr cluster or one of its subsystems was unavailable. Failed to deviler message to coordinator.\",\n                     {});\n                 return;\n             }\n@@ -2222,22 +2329,32 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n             ReplyErrorAndDie(\n                     NYql::NDqProto::StatusIds::UNDETERMINED,\n                     NYql::TIssuesIds::KIKIMR_OPERATION_STATE_UNKNOWN,\n-                    TStringBuilder() << \"Failed to deviler message to coordinator.\",\n+                    TStringBuilder() << \"State of operation is unknown. Failed to deviler message to coordinator.\",\n                     {});\n             return;\n         }\n \n-        ReplyErrorAndDie(\n-            NYql::NDqProto::StatusIds::UNAVAILABLE,\n-            NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,\n-            TStringBuilder() << \"Failed to deviler message.\",\n-            {});\n+        if (State == EState::COMMITTING) {\n+            ReplyErrorAndDie(\n+                NYql::NDqProto::StatusIds::UNDETERMINED,\n+                NYql::TIssuesIds::KIKIMR_OPERATION_STATE_UNKNOWN,\n+                TStringBuilder() << \"State of operation is unknown. Failed to deviler message.\",\n+                {});\n+            return;\n+        } else {\n+            ReplyErrorAndDie(\n+                NYql::NDqProto::StatusIds::UNAVAILABLE,\n+                NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,\n+                TStringBuilder() << \"Kikimr cluster or one of its subsystems was unavailable. Failed to deviler message.\",\n+                {});\n+            return;\n+        }\n     }\n \n     void Handle(TEvKqpBuffer::TEvTerminate::TPtr&) {\n         if (State != EState::ROLLINGBACK && State != EState::FINISHED) {\n             CancelProposal();\n-            Rollback();\n+            Rollback(BufferWriteActorSpan.GetTraceId());\n         }\n         PassAway();\n     }\n@@ -2247,7 +2364,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n         for (auto& [_, info] : WriteInfos) {\n             info.WriteTableActor->FlushBuffers();\n         }\n-        Flush();\n+        Flush(std::move(ev->TraceId));\n     }\n \n     void Handle(TEvKqpBuffer::TEvCommit::TPtr& ev) {\n@@ -2257,23 +2374,23 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n         }\n \n         if (!TxManager->NeedCommit()) {\n-            RollbackAndDie();\n+            RollbackAndDie(std::move(ev->TraceId));\n         } else if (TxManager->IsSingleShard() && !TxManager->HasOlapTable() && (!WriteInfos.empty() || TxManager->HasTopics())) {\n             TxManager->StartExecute();\n-            ImmediateCommit();\n+            ImmediateCommit(std::move(ev->TraceId));\n         } else {\n             TxManager->StartPrepare();\n-            Prepare(ev->Get()->TxId);\n+            Prepare(ev->Get()->TxId, std::move(ev->TraceId));\n         }\n     }\n \n     void Handle(TEvKqpBuffer::TEvRollback::TPtr& ev) {\n         ExecuterActorId = ev->Get()->ExecuterActorId;\n-        RollbackAndDie();\n+        RollbackAndDie(std::move(ev->TraceId));\n     }\n \n-    void RollbackAndDie() {\n-        Rollback();\n+    void RollbackAndDie(NWilson::TTraceId traceId) {\n+        Rollback(std::move(traceId));\n         Send<ESendingType::Tail>(ExecuterActorId, new TEvKqpBuffer::TEvResult{});\n         PassAway();\n     }\n@@ -2306,9 +2423,11 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n                 }\n                 builder << \"`\" << path << \"`\";\n             }\n-            return builder;\n+            return (tableInfo.Pathes.size() == 1 ? \"Table: \" : \"Tables: \")  + builder;\n         };\n \n+        TxManager->AddParticipantNode(ev->Sender.NodeId());\n+\n         // TODO: get rid of copy-paste\n         switch (ev->Get()->GetStatus()) {\n         case NKikimrDataEvents::TEvWriteResult::STATUS_UNSPECIFIED: {\n@@ -2320,7 +2439,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n             ReplyErrorAndDie(\n                 NYql::NDqProto::StatusIds::UNSPECIFIED,\n                 NYql::TIssuesIds::DEFAULT_ERROR,\n-                TStringBuilder() << \"Unspecified error for tables `\" << getPathes() << \"`. \"\n+                TStringBuilder() << \"Unspecified error. \" << getPathes() << \". \"\n                     << getIssues().ToOneLineString(),\n                 getIssues());\n             return;\n@@ -2342,7 +2461,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n             ReplyErrorAndDie(\n                 NYql::NDqProto::StatusIds::ABORTED,\n                 NYql::TIssuesIds::KIKIMR_OPERATION_ABORTED,\n-                TStringBuilder() << \"Aborted for tables \" << getPathes() << \". \",\n+                TStringBuilder() << \"Operation aborted.\",\n                 getIssues());\n             return;\n         }\n@@ -2353,9 +2472,9 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n                     << getIssues().ToOneLineString());\n             TxManager->SetError(ev->Get()->Record.GetOrigin());\n             ReplyErrorAndDie(\n-                NYql::NDqProto::StatusIds::PRECONDITION_FAILED,\n+                NYql::NDqProto::StatusIds::UNAVAILABLE,\n                 NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,\n-                TStringBuilder() << \"Wrong shard state for tables \" << getPathes() << \".\",\n+                TStringBuilder() << \"Wrong shard state. \" << getPathes() << \".\",\n                 getIssues());\n             return;\n         }\n@@ -2368,7 +2487,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n             ReplyErrorAndDie(\n                 NYql::NDqProto::StatusIds::INTERNAL_ERROR,\n                 NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,\n-                TStringBuilder() << \"Internal error for tables \" << getPathes() << \".\",\n+                TStringBuilder() << \"Internal error while executing transaction.\",\n                 getIssues());\n             return;\n         }\n@@ -2381,9 +2500,23 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n             ReplyErrorAndDie(\n                 NYql::NDqProto::StatusIds::UNAVAILABLE,\n                 NYql::TIssuesIds::KIKIMR_DISK_SPACE_EXHAUSTED,\n-                TStringBuilder() << \"Disk space exhausted for tables \" << getPathes() << \".\",\n+                TStringBuilder() << \"Disk space exhausted. \" << getPathes() << \".\",\n                 getIssues());\n-                return;\n+            return;\n+        }\n+        case NKikimrDataEvents::TEvWriteResult::STATUS_OUT_OF_SPACE: {\n+            CA_LOG_W(\"Got OUT_OF_SPACE for tables.\"\n+                << \" ShardID=\" << ev->Get()->Record.GetOrigin() << \",\"\n+                << \" Sink=\" << this->SelfId() << \".\"\n+                << \" Ignored this error.\"\n+                << getIssues().ToOneLineString());\n+            TxManager->SetError(ev->Get()->Record.GetOrigin());\n+            ReplyErrorAndDie(\n+                NYql::NDqProto::StatusIds::OVERLOADED,\n+                NYql::TIssuesIds::KIKIMR_OVERLOADED,\n+                TStringBuilder() << \"Tablet \" << ev->Get()->Record.GetOrigin() << \" is out of space. \" << getPathes() << \".\",\n+                getIssues());\n+            return;\n         }\n         case NKikimrDataEvents::TEvWriteResult::STATUS_OVERLOADED: {\n             CA_LOG_W(\"Got OVERLOADED for tables.\"\n@@ -2395,7 +2528,9 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n             ReplyErrorAndDie(\n                 NYql::NDqProto::StatusIds::OVERLOADED,\n                 NYql::TIssuesIds::KIKIMR_OVERLOADED,\n-                TStringBuilder() << \"Tablet \" << ev->Get()->Record.GetOrigin() << \"(\" << getPathes() << \")\" << \" is overloaded.\",\n+                TStringBuilder() << \"Kikimr cluster or one of its subsystems is overloaded.\"\n+                    << \" Tablet \" << ev->Get()->Record.GetOrigin() << \" is overloaded.\"\n+                    << \" \" << getPathes() << \".\",\n                 getIssues());\n             return;\n         }\n@@ -2408,7 +2543,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n             ReplyErrorAndDie(\n                 NYql::NDqProto::StatusIds::CANCELLED,\n                 NYql::TIssuesIds::KIKIMR_OPERATION_CANCELLED,\n-                TStringBuilder() << \"Cancelled request to tables \" << getPathes() << \".\",\n+                TStringBuilder() << \"Operation cancelled.\",\n                 getIssues());\n             return;\n         }\n@@ -2421,7 +2556,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n             ReplyErrorAndDie(\n                 NYql::NDqProto::StatusIds::BAD_REQUEST,\n                 NYql::TIssuesIds::KIKIMR_BAD_REQUEST,\n-                TStringBuilder() << \"Bad request. Tables: \" << getPathes() << \".\",\n+                TStringBuilder() << \"Bad request. \" << getPathes() << \".\",\n                 getIssues());\n             return;\n         }\n@@ -2434,7 +2569,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n             ReplyErrorAndDie(\n                 NYql::NDqProto::StatusIds::SCHEME_ERROR,\n                 NYql::TIssuesIds::KIKIMR_SCHEME_MISMATCH,\n-                TStringBuilder() << \"Scheme changed. Tables: \" << getPathes() << \".\",\n+                TStringBuilder() << \"Scheme changed. \" << getPathes() << \".\",\n                 getIssues());\n             return;\n         }\n@@ -2449,7 +2584,9 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n             ReplyErrorAndDie(\n                 NYql::NDqProto::StatusIds::ABORTED,\n                 NYql::TIssuesIds::KIKIMR_LOCKS_INVALIDATED,\n-                TStringBuilder() << \"Transaction locks invalidated. Tables: \" << getPathes() << \".\",\n+                TStringBuilder()\n+                    << \"Transaction locks invalidated. \"\n+                    << getPathes() << \".\",\n                 getIssues());\n             return;\n         }\n@@ -2462,7 +2599,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n             ReplyErrorAndDie(\n                 NYql::NDqProto::StatusIds::PRECONDITION_FAILED,\n                 NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION,\n-                TStringBuilder() << \"Constraint violated. Tables: \" << getPathes() << \".\",\n+                TStringBuilder() << \"Constraint violated. \" << getPathes() << \".\",\n                 getIssues());\n             return;\n         }\n@@ -2571,11 +2708,21 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n         Process();\n     }\n \n-    void OnPrepared(IKqpTransactionManager::TPrepareResult&& preparedInfo, ui64 dataSize) override {\n+    void OnPrepared(IKqpTransactionManager::TPrepareResult&& preparedInfo, ui64) override {\n         if (State != EState::PREPARING) {\n             return;\n         }\n-        Y_UNUSED(preparedInfo, dataSize);\n+        if (!preparedInfo.Coordinator || (TxManager->GetCoordinator() && preparedInfo.Coordinator != TxManager->GetCoordinator())) {\n+            CA_LOG_E(\"Handle TEvWriteResult: unable to select coordinator. Tx canceled, actorId: \" << SelfId()\n+                << \", previously selected coordinator: \" << TxManager->GetCoordinator()\n+                << \", coordinator selected at propose result: \" << preparedInfo.Coordinator);\n+\n+            TxProxyMon->TxResultAborted->Inc();\n+            ReplyErrorAndDie(NYql::NDqProto::StatusIds::CANCELLED,\n+                NKikimrIssues::TIssuesIds::TX_DECLINED_IMPLICIT_COORDINATOR,\n+                \"Unable to choose coordinator.\");\n+            return;\n+        }\n         if (TxManager->ConsumePrepareTransactionResult(std::move(preparedInfo))) {\n             OnOperationFinished(Counters->BufferActorPrepareLatencyHistogram);\n             TxManager->StartExecute();\n@@ -2586,11 +2733,10 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n         Process();\n     }\n \n-    void OnCommitted(ui64 shardId, ui64 dataSize) override {\n+    void OnCommitted(ui64 shardId, ui64) override {\n         if (State != EState::COMMITTING) {\n             return;\n         }\n-        Y_UNUSED(dataSize);\n         if (TxManager->ConsumeCommitResult(shardId)) {\n             CA_LOG_D(\"Committed TxId=\" << TxId.value_or(0));\n             OnOperationFinished(Counters->BufferActorCommitLatencyHistogram);\n@@ -2605,15 +2751,13 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n         }\n     }\n \n-    void OnMessageAcknowledged(ui64 dataSize) override {\n-        Y_UNUSED(dataSize);\n+    void OnMessageAcknowledged(ui64) override {\n         Process();\n     }\n \n     void OnFlushed() {\n         YQL_ENSURE(State == EState::FLUSHING);\n-        BufferWriteActorState = NWilson::TSpan(TWilsonKqp::BufferWriteActorState, BufferWriteActor.GetTraceId(),\n-            \"BufferWriteActorState::Writing\", NWilson::EFlags::AUTO_END);\n+        UpdateTracingState(\"Write\", BufferWriteActorSpan.GetTraceId());\n         OnOperationFinished(Counters->BufferActorFlushLatencyHistogram);\n         State = EState::WRITING;\n         Send<ESendingType::Tail>(ExecuterActorId, new TEvKqpBuffer::TEvResult{\n@@ -2621,6 +2765,10 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n         });\n         ExecuterActorId = {};\n         Y_ABORT_UNLESS(GetTotalMemory() == 0);\n+\n+        for (auto& [_, info] : WriteInfos) {\n+            info.WriteTableActor->Unlink();\n+        }\n     }\n \n     void OnError(NYql::NDqProto::StatusIds::StatusCode statusCode, NYql::EYqlIssueCode id, const TString& message, const NYql::TIssues& subIssues) override {\n@@ -2631,9 +2779,8 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n         ReplyErrorAndDie(statusCode, std::move(issues));\n     }\n \n-    void ReplyErrorAndDie(NYql::NDqProto::StatusIds::StatusCode statusCode, NYql::EYqlIssueCode id, const TString& message, const NYql::TIssues& subIssues = {}) {\n-        BufferWriteActorState.EndError(message);\n-        BufferWriteActor.EndError(message);\n+    void ReplyErrorAndDie(NYql::NDqProto::StatusIds::StatusCode statusCode, auto id, const TString& message, const NYql::TIssues& subIssues = {}) {\n+        BufferWriteActorStateSpan.EndError(message);\n \n         NYql::TIssue issue(message);\n         SetIssueCode(id, issue);\n@@ -2648,12 +2795,22 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n     }\n \n     void ReplyErrorAndDie(NYql::NDqProto::StatusIds::StatusCode statusCode, NYql::TIssues&& issues) {\n-        BufferWriteActorState.EndError(issues.ToOneLineString());\n-        BufferWriteActor.EndError(issues.ToOneLineString());\n+        BufferWriteActorStateSpan.EndError(issues.ToOneLineString());\n \n         ReplyErrorAndDieImpl(statusCode, std::move(issues));\n     }\n \n+    void UpdateTracingState(const char* name, NWilson::TTraceId traceId) {\n+        BufferWriteActorStateSpan = NWilson::TSpan(TWilsonKqp::BufferWriteActorState, std::move(traceId),\n+            name, NWilson::EFlags::AUTO_END);\n+        if (BufferWriteActorStateSpan.GetTraceId() != BufferWriteActorSpan.GetTraceId()) {\n+            BufferWriteActorStateSpan.Link(BufferWriteActorSpan.GetTraceId());\n+        }\n+        for (auto& [_, info] : WriteInfos) {\n+            info.WriteTableActor->SetParentTraceId(BufferWriteActorStateSpan.GetTraceId());\n+        }\n+    }\n+\n     void ReplyErrorAndDieImpl(NYql::NDqProto::StatusIds::StatusCode statusCode, NYql::TIssues&& issues) {\n         CA_LOG_E(\"statusCode=\" << NYql::NDqProto::StatusIds_StatusCode_Name(statusCode) << \". Issue=\" << issues.ToString() << \". sessionActorId=\" << SessionActorId << \". isRollback=\" << (State == EState::ROLLINGBACK));\n \n@@ -2662,7 +2819,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n \n         CancelProposal();\n         if (State != EState::ROLLINGBACK) {\n-            Rollback();\n+            Rollback(BufferWriteActorSpan.GetTraceId());\n             // Rollback can't finish with error\n             Send<ESendingType::Tail>(SessionActorId, new TEvKqpBuffer::TEvError{\n                 statusCode,\n@@ -2716,7 +2873,6 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n     std::optional<ui64> Coordinator;\n \n     std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;\n-    NMiniKQL::TTypeEnvironment TypeEnv;\n \n     struct TWriteInfo {\n         TKqpTableWriteActor* WriteTableActor = nullptr;\n@@ -2736,15 +2892,13 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub\n     };\n     std::queue<TAckMessage> AckQueue;\n \n-    IShardedWriteControllerPtr ShardedWriteController = nullptr;\n-\n     TIntrusivePtr<TKqpCounters> Counters;\n     TIntrusivePtr<NTxProxy::TTxProxyMon> TxProxyMon;\n     THashMap<ui64, TInstant> SendTime;\n     TInstant OperationStartTime;\n \n-    NWilson::TSpan BufferWriteActor;\n-    NWilson::TSpan BufferWriteActorState;\n+    NWilson::TSpan BufferWriteActorSpan;\n+    NWilson::TSpan BufferWriteActorStateSpan;\n };\n \n class TKqpForwardWriteActor : public TActorBootstrapped<TKqpForwardWriteActor>, public NYql::NDq::IDqComputeActorAsyncOutput {\n@@ -2758,6 +2912,7 @@ class TKqpForwardWriteActor : public TActorBootstrapped<TKqpForwardWriteActor>,\n         : LogPrefix(TStringBuilder() << \"TxId: \" << args.TxId << \", task: \" << args.TaskId << \". \")\n         , Settings(std::move(settings))\n         , MessageSettings(GetWriteActorSettings())\n+        , Alloc(args.Alloc)\n         , OutputIndex(args.OutputIndex)\n         , Callbacks(args.Callback)\n         , Counters(counters)\n@@ -2767,7 +2922,7 @@ class TKqpForwardWriteActor : public TActorBootstrapped<TKqpForwardWriteActor>,\n             Settings.GetTable().GetOwnerId(),\n             Settings.GetTable().GetTableId(),\n             Settings.GetTable().GetVersion())\n-        , ForwardWriteActorSpan(TWilsonKqp::ForwardWriteActor, NWilson::TTraceId(args.TraceId), \"TKqpForwardWriteActor\")\n+        , ForwardWriteActorSpan(TWilsonKqp::ForwardWriteActor, NWilson::TTraceId(args.TraceId), \"ForwardWriteActor\")\n     {\n         EgressStats.Level = args.StatsLevel;\n \n@@ -2777,10 +2932,11 @@ class TKqpForwardWriteActor : public TActorBootstrapped<TKqpForwardWriteActor>,\n         std::vector<ui32> writeIndex(\n             Settings.GetWriteIndexes().begin(),\n             Settings.GetWriteIndexes().end());\n+        TGuard guard(*Alloc);\n         if (Settings.GetIsOlap()) {\n-            Batcher = CreateColumnDataBatcher(columnsMetadata, std::move(writeIndex));\n+            Batcher = CreateColumnDataBatcher(columnsMetadata, std::move(writeIndex), Alloc);\n         } else {\n-            Batcher = CreateRowDataBatcher(columnsMetadata, std::move(writeIndex));\n+            Batcher = CreateRowDataBatcher(columnsMetadata, std::move(writeIndex), Alloc);\n         }\n \n         Counters->ForwardActorsCount->Inc();\n@@ -2805,6 +2961,7 @@ class TKqpForwardWriteActor : public TActorBootstrapped<TKqpForwardWriteActor>,\n             RuntimeError(\n                 CurrentExceptionMessage(),\n                 NYql::NDqProto::StatusIds::INTERNAL_ERROR);\n+            return;\n         }\n     }\n \n@@ -2836,6 +2993,7 @@ class TKqpForwardWriteActor : public TActorBootstrapped<TKqpForwardWriteActor>,\n         auto ev = std::make_unique<TEvBufferWrite>();\n \n         ev->Data = Batcher->Build();\n+        ev->Data->DetachAlloc();\n         ev->Close = Closed;\n \n         if (!WriteToken.IsEmpty()) {\n@@ -2934,6 +3092,7 @@ class TKqpForwardWriteActor : public TActorBootstrapped<TKqpForwardWriteActor>,\n     TString LogPrefix;\n     const NKikimrKqp::TKqpTableSinkSettings Settings;\n     TWriteActorSettings MessageSettings;\n+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;\n     const ui64 OutputIndex;\n     NYql::NDq::TDqAsyncStats EgressStats;\n     NYql::NDq::IDqComputeActorAsyncOutput::ICallbacks * Callbacks = nullptr;\ndiff --git a/ydb/core/kqp/runtime/kqp_write_actor_settings.h b/ydb/core/kqp/runtime/kqp_write_actor_settings.h\nindex 37e8bfe91055..9b02d8e246b9 100644\n--- a/ydb/core/kqp/runtime/kqp_write_actor_settings.h\n+++ b/ydb/core/kqp/runtime/kqp_write_actor_settings.h\n@@ -10,7 +10,6 @@ namespace NKqp {\n struct TWriteActorSettings : TAtomicRefCount<TWriteActorSettings> {\n     i64 InFlightMemoryLimitPerActorBytes = 64_MB;\n     i64 MemoryLimitPerMessageBytes = 64_MB;\n-    i64 MaxBatchesPerMessage = 1000;\n     i64 MaxForwardedSize = 64_MB;\n \n     TDuration StartRetryDelay = TDuration::Seconds(1);\ndiff --git a/ydb/core/kqp/runtime/kqp_write_table.cpp b/ydb/core/kqp/runtime/kqp_write_table.cpp\nindex a917a72c1382..a96793dd1ab6 100644\n--- a/ydb/core/kqp/runtime/kqp_write_table.cpp\n+++ b/ydb/core/kqp/runtime/kqp_write_table.cpp\n@@ -4,6 +4,7 @@\n #include <util/generic/yexception.h>\n #include <ydb/core/engine/mkql_keys.h>\n #include <ydb/core/formats/arrow/arrow_batch_builder.h>\n+#include <ydb/core/kqp/runtime/kqp_arrow_memory_pool.h>\n #include <ydb/core/tx/data_events/events.h>\n #include <ydb/core/tx/data_events/payload_helper.h>\n #include <ydb/core/tx/schemeshard/olap/schema/schema.h>\n@@ -17,87 +18,244 @@ namespace NKqp {\n \n namespace {\n \n-constexpr ui64 DataShardMaxOperationBytes = 8_MB;\n-constexpr ui64 ColumnShardMaxOperationBytes = 64_MB;\n+constexpr i64 DataShardMaxOperationBytes = 8_MB;\n+constexpr i64 ColumnShardMaxOperationBytes = 64_MB;\n+\n+constexpr size_t InitialBatchPoolSize = 64_KB;\n+\n+class TOffloadedPoolAllocator : public IAllocator {\n+public:\n+    TOffloadedPoolAllocator(std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> scopedAlloc)\n+        : Alloc(TDefaultAllocator::Instance())\n+        , ScopedAlloc(std::move(scopedAlloc)) \n+        , AllocatedSize(0) {\n+    }\n+\n+    ~TOffloadedPoolAllocator() {\n+        Y_DEBUG_ABORT_UNLESS(AllocatedSize == 0);\n+    }\n+\n+    TBlock Allocate(size_t len) override {\n+        if (ScopedAlloc) {\n+            TGuard guard(*ScopedAlloc);\n+            ScopedAlloc->Ref().OffloadAlloc(len);\n+        }\n+        AllocatedSize += len;\n+        return Alloc->Allocate(len);\n+    }\n+\n+    void Release(const TBlock& block) override {\n+        if (ScopedAlloc) {\n+            TGuard guard(*ScopedAlloc);\n+            ScopedAlloc->Ref().OffloadFree(block.Len);\n+        }\n+        AllocatedSize -= block.Len;\n+        Alloc->Release(block);\n+    }\n+\n+    void Attach(std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> scopedAlloc) {\n+        AFL_ENSURE(!ScopedAlloc);\n+        {\n+            TGuard guard(*scopedAlloc);\n+            scopedAlloc->Ref().OffloadAlloc(AllocatedSize);\n+        }\n+        ScopedAlloc = std::move(scopedAlloc);\n+    }\n+\n+    void Detach() {\n+        AFL_ENSURE(ScopedAlloc);\n+        {\n+            TGuard guard(*ScopedAlloc);\n+            ScopedAlloc->Ref().OffloadFree(AllocatedSize);\n+        }\n+        ScopedAlloc.reset();\n+    }\n+\n+    bool Attached() const {\n+        return ScopedAlloc != nullptr;\n+    }\n+\n+    std::unique_ptr<TMemoryPool> CreateMemoryPool() {\n+        return std::make_unique<TMemoryPool>(InitialBatchPoolSize, TMemoryPool::TExpGrow::Instance(), this);\n+    }\n+\n+private:\n+    IAllocator* Alloc;\n+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> ScopedAlloc;\n+\n+    size_t AllocatedSize;\n+};\n+\n+using TOffloadedPoolAllocatorPtr = std::shared_ptr<TOffloadedPoolAllocator>;\n+\n+TOffloadedPoolAllocatorPtr CreateOffloadedPoolAllocator(\n+        std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> scopedAlloc) {\n+    return std::make_shared<TOffloadedPoolAllocator>(std::move(scopedAlloc));\n+}\n+\n+template <class T>\n+struct TNullableAllocLockOps {\n+    static inline void Acquire(T* t) noexcept {\n+        if (t) {\n+            t->Acquire();\n+        }\n+    }\n+\n+    static inline void Release(T* t) noexcept {\n+        if (t) {\n+            t->Release();\n+        }\n+    }\n+};\n+\n+using TNullableAllocGuard = TGuard<NKikimr::NMiniKQL::TScopedAlloc, TNullableAllocLockOps<NKikimr::NMiniKQL::TScopedAlloc>>;\n \n-using TCharVectorPtr = std::unique_ptr<TVector<char>>;\n \n class TColumnBatch : public IDataBatch {\n public:\n     using TRecordBatchPtr = std::shared_ptr<arrow::RecordBatch>;\n \n     TString SerializeToString() const override {\n+        AFL_ENSURE(!Extracted);\n         return NArrow::SerializeBatchNoCompression(Data);\n     }\n \n+    i64 GetSerializedMemory() const override {\n+        AFL_ENSURE(!Extracted);\n+        return SerializedMemory;\n+    }\n+\n     i64 GetMemory() const override {\n+        AFL_ENSURE(!Extracted);\n         return Memory;\n     }\n \n     bool IsEmpty() const override {\n-        return GetMemory() == 0;\n+        AFL_ENSURE(!Extracted);\n+        return !Data || Data->num_rows() == 0;\n     }\n \n     TRecordBatchPtr Extract() {\n+        AFL_ENSURE(!Extracted);\n+        Extracted = true;\n+        SerializedMemory = 0;\n         Memory = 0;\n-        TRecordBatchPtr result = std::move(Data);\n-        return result;\n+        return std::move(Data);\n     }\n \n     std::shared_ptr<void> ExtractBatch() override {\n         return std::dynamic_pointer_cast<void>(Extract());\n     }\n \n-    explicit TColumnBatch(const TRecordBatchPtr& data)\n-        : Data(data)\n-        , Memory(NArrow::GetBatchDataSize(Data)) {\n+    void DetachAlloc() override {\n+        Y_ABORT_UNLESS(false); // Write to CS doesn't need to move data between allocators.\n+    }\n+\n+    void AttachAlloc(std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc) override {\n+        Y_ABORT_UNLESS(Alloc == alloc); // Write to CS doesn't need to move data between allocators.\n+    }\n+\n+    bool AttachedAlloc() const override {\n+        return true;\n+    }\n+\n+    explicit TColumnBatch(const TRecordBatchPtr& data, std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc = nullptr)\n+        : Alloc(alloc) \n+        , Data(data)\n+        , SerializedMemory(NArrow::GetBatchDataSize(Data))\n+        , Memory(NArrow::GetBatchMemorySize(Data)) {\n+    }\n+\n+    ~TColumnBatch() {\n+        TNullableAllocGuard guard(Alloc.get());\n+        Data.reset();\n     }\n \n private:\n+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc = nullptr;\n     TRecordBatchPtr Data;\n-    i64 Memory;\n+    i64 SerializedMemory = 0;\n+    i64 Memory = 0;\n+\n+    bool Extracted = false;\n };\n \n \n class TRowBatch : public IDataBatch {\n public:\n     TString SerializeToString() const override {\n-        return TSerializedCellMatrix::Serialize(Cells, Rows, Columns);\n+        AFL_ENSURE(!Extracted);\n+        TVector<TCell> cells;\n+        if (!Rows.empty()) {\n+            cells.reserve(Rows.Size() * Rows.front().size());\n+        }\n+        for (const auto& row : Rows) {\n+            for (const auto& cell : row) {\n+                cells.push_back(cell);\n+            }\n+        }\n+        return TSerializedCellMatrix::Serialize(cells, Rows.Size(), !IsEmpty() ? Rows.front().size() : 0);\n+    }\n+\n+    i64 GetSerializedMemory() const override {\n+        AFL_ENSURE(!Extracted);\n+        return SerializedMemory;\n     }\n \n     i64 GetMemory() const override {\n-        return Size;\n+        AFL_ENSURE(!Extracted);\n+        return Memory;\n     }\n \n     bool IsEmpty() const override {\n-        return Cells.empty();\n+        AFL_ENSURE(!Extracted);\n+        return Rows.empty();\n     }\n \n-    std::pair<std::vector<TCell>, std::vector<TCharVectorPtr>> Extract() {\n-        Size = 0;\n-        Rows = 0;\n-        return {std::move(Cells), std::move(Data)};\n+    TOwnedCellVecBatch Extract() {\n+        AFL_ENSURE(!Extracted);\n+        Extracted = true;\n+        return std::move(Rows);\n     }\n \n     std::shared_ptr<void> ExtractBatch() override {\n-        auto r = std::make_shared<std::pair<std::vector<TCell>, std::vector<TCharVectorPtr>>>(std::move(Extract()));\n+        auto r = std::make_shared<TOwnedCellVecBatch>(std::move(Extract()));\n         return std::reinterpret_pointer_cast<void>(r);\n     }\n \n-    TRowBatch(std::vector<TCell>&& cells, std::vector<TCharVectorPtr>&& data, i64 size, ui32 rows, ui16 columns)\n-        : Cells(std::move(cells))\n-        , Data(std::move(data))\n-        , Size(size)\n-        , Rows(rows)\n-        , Columns(columns) {\n+    void DetachAlloc() override {\n+        OffloadedAlloc->Detach();\n+    }\n+\n+    void AttachAlloc(std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc) override {\n+        OffloadedAlloc->Attach(alloc);\n+    }\n+\n+    bool AttachedAlloc() const override {\n+        return OffloadedAlloc->Attached();\n+    }\n+\n+    TRowBatch(\n+        TOwnedCellVecBatch&& rows,\n+        TOffloadedPoolAllocatorPtr offloadedAlloc)\n+            : OffloadedAlloc(std::move(offloadedAlloc))\n+            , Rows(std::move(rows)) {\n+        SerializedMemory = GetCellMatrixHeaderSize();\n+        Memory = 0;\n+        for (const auto& row : Rows) {\n+            AFL_ENSURE(row.size() == Rows.front().size());\n+            const auto size = EstimateSize(row);\n+            SerializedMemory += GetCellHeaderSize() * row.size() + size;\n+            Memory += size;\n+        }\n     }\n \n private:\n-    std::vector<TCell> Cells;\n-    std::vector<TCharVectorPtr> Data;\n-    ui64 Size = 0;\n-    ui32 Rows = 0;\n-    ui16 Columns = 0;\n+    TOffloadedPoolAllocatorPtr OffloadedAlloc;\n+    TOwnedCellVecBatch Rows;\n+    i64 SerializedMemory = 0;\n+    i64 Memory = 0;\n+    bool Extracted = false;\n };\n \n class IPayloadSerializer : public TThrRefBase {\n@@ -170,7 +328,7 @@ std::vector<std::pair<TString, NScheme::TTypeInfo>> BuildBatchBuilderColumns(\n     std::vector<std::pair<TString, NScheme::TTypeInfo>> result(writeIndex.size());\n     for (size_t index = 0; index < inputColumns.size(); ++index) {\n         const auto& column = inputColumns[index];\n-        YQL_ENSURE(column.HasTypeId());\n+        AFL_ENSURE(column.HasTypeId());\n         auto typeInfoMod = NScheme::TypeInfoModFromProtoColumnType(column.GetTypeId(),\n             column.HasTypeInfo() ? &column.GetTypeInfo() : nullptr);\n         result[writeIndex[index]].first = column.GetName();\n@@ -191,17 +349,14 @@ TVector<NScheme::TTypeInfo> BuildKeyColumnTypes(\n     return keyColumnTypes;\n }\n \n-struct TRowWithData {\n-    TVector<TCell> Cells;\n-    TCharVectorPtr Data;\n-};\n-\n class TRowBuilder {\n private:\n     struct TCellInfo {\n         NScheme::TTypeInfo Type;\n         NUdf::TUnboxedValuePod Value;\n         TString PgBinaryValue;\n+\n+        NYql::NDecimal::TInt128 DecimalBuf;\n     };\n \n public:\n@@ -211,12 +366,16 @@ class TRowBuilder {\n \n     TRowBuilder& AddCell(\n             const size_t index,\n-            const NScheme::TTypeInfo type,\n+            const NScheme::TTypeInfo& type,\n             const NUdf::TUnboxedValuePod& value,\n             const TString& typeMod) {\n         CellsInfo[index].Type = type;\n         CellsInfo[index].Value = value;\n \n+        if (CellsInfo[index].Type.GetTypeId() == NUdf::TDataType<NUdf::TDecimal>::Id && value) {\n+            CellsInfo[index].DecimalBuf = value.GetInt128();\n+        }\n+\n         if (type.GetTypeId() == NScheme::NTypeIds::Pg && value) {\n             auto typeDesc = type.GetPgTypeDesc();\n             if (!typeMod.empty() && NPg::TypeDescNeedsCoercion(typeDesc)) {\n@@ -226,7 +385,7 @@ class TRowBuilder {\n                     ythrow yexception() << \"BinaryTypeModFromTextTypeMod error: \" << *typeModResult.Error;\n                 }\n \n-                YQL_ENSURE(typeModResult.Typmod != -1);\n+                AFL_ENSURE(typeModResult.Typmod != -1);\n                 TMaybe<TString> err;\n                 CellsInfo[index].PgBinaryValue = NYql::NCommon::PgValueCoerce(value, NPg::PgTypeIdFromTypeDesc(typeDesc), typeModResult.Typmod, &err);\n                 if (err) {\n@@ -241,35 +400,18 @@ class TRowBuilder {\n         return *this;\n     }\n \n-    size_t DataSize() const {\n-        size_t result = 0;\n-        for (const auto& cellInfo : CellsInfo) {\n-            result += GetCellSize(cellInfo);\n-        }\n-        return result;\n-    }\n-\n-    TRowWithData Build() {\n-        TVector<TCell> cells;\n-        cells.reserve(CellsInfo.size());\n-        const auto size = DataSize();\n-        auto data = Allocate(size);\n-        char* ptr = data->data();\n-\n+    TConstArrayRef<TCell> BuildCells() {\n+        Cells.clear();\n+        Cells.reserve(CellsInfo.size());\n+        \n         for (const auto& cellInfo : CellsInfo) {\n-            cells.push_back(BuildCell(cellInfo, ptr));\n+            Cells.emplace_back(BuildCell(cellInfo));\n         }\n-\n-        AFL_ENSURE(ptr == data->data() + size);\n-\n-        return TRowWithData {\n-            .Cells = std::move(cells),\n-            .Data = std::move(data),\n-        };\n+        return Cells;\n     }\n \n private:\n-    TCell BuildCell(const TCellInfo& cellInfo, char*& dataPtr) {\n+    TCell BuildCell(const TCellInfo& cellInfo) {\n         if (!cellInfo.Value) {\n             return TCell();\n         }\n@@ -280,13 +422,8 @@ class TRowBuilder {\n             KNOWN_FIXED_VALUE_TYPES(MAKE_PRIMITIVE_TYPE_CELL_CASE)\n         case NUdf::TDataType<NUdf::TDecimal>::Id:\n             {\n-                auto intValue = cellInfo.Value.GetInt128();\n-                constexpr auto valueSize = sizeof(intValue);\n-\n-                char* initialPtr = dataPtr;\n-                std::memcpy(initialPtr, reinterpret_cast<const char*>(&intValue), valueSize);\n-                dataPtr += valueSize;\n-                return TCell(initialPtr, valueSize);\n+                constexpr auto valueSize = sizeof(cellInfo.DecimalBuf);\n+                return TCell(reinterpret_cast<const char*>(&cellInfo.DecimalBuf), valueSize);\n             }\n         }\n \n@@ -296,44 +433,13 @@ class TRowBuilder {\n             ? NYql::NUdf::TStringRef(cellInfo.PgBinaryValue)\n             : cellInfo.Value.AsStringRef();\n \n-        if (!isPg && TCell::CanInline(ref.Size())) {\n-            return TCell(ref.Data(), ref.Size());\n-        } else {\n-            char* initialPtr = dataPtr;\n-            std::memcpy(initialPtr, ref.Data(), ref.Size());\n-            dataPtr += ref.Size();\n-            return TCell(initialPtr, ref.Size());\n-        }\n-    }\n-\n-    size_t GetCellSize(const TCellInfo& cellInfo) const {\n-        if (!cellInfo.Value) {\n-            return 0;\n-        }\n-\n-        switch(cellInfo.Type.GetTypeId()) {\n-    #define MAKE_PRIMITIVE_TYPE_CELL_CASE_SIZE(type, layout) \\\n-        case NUdf::TDataType<type>::Id:\n-            KNOWN_FIXED_VALUE_TYPES(MAKE_PRIMITIVE_TYPE_CELL_CASE_SIZE)\n-            return 0;\n-        case NUdf::TDataType<NUdf::TDecimal>::Id:\n-            return sizeof(cellInfo.Value.GetInt128());\n-        }\n-\n-        const bool isPg = cellInfo.Type.GetTypeId() == NScheme::NTypeIds::Pg;\n-\n-        const auto ref = isPg\n-            ? NYql::NUdf::TStringRef(cellInfo.PgBinaryValue)\n-            : cellInfo.Value.AsStringRef();\n-\n-        return (!isPg && TCell::CanInline(ref.Size())) ? 0 : ref.Size();\n-    }\n-\n-    TCharVectorPtr Allocate(size_t size) {\n-        return std::make_unique<TVector<char>>(size);\n+        return TCell(ref.Data(), ref.Size());\n     }\n \n     TVector<TCellInfo> CellsInfo;\n+    TVector<TCell> Cells;\n+\n+    TOwnedCellVecBatch Batch;\n };\n \n class TColumnDataBatcher : public IDataBatcher {\n@@ -342,17 +448,28 @@ class TColumnDataBatcher : public IDataBatcher {\n \n     TColumnDataBatcher(\n         const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,\n-        std::vector<ui32> writeIndex)\n+        std::vector<ui32> writeIndex,\n+        std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc)\n             : Columns(BuildColumns(inputColumns))\n             , WriteIndex(std::move(writeIndex))\n-            , BatchBuilder(arrow::Compression::UNCOMPRESSED, BuildNotNullColumns(inputColumns)) {\n+            , BatchBuilder(std::make_unique<NArrow::TArrowBatchBuilder>(\n+                arrow::Compression::UNCOMPRESSED,\n+                BuildNotNullColumns(inputColumns),\n+                alloc ? NKikimr::NMiniKQL::GetArrowMemoryPool() : arrow::default_memory_pool()))\n+            , Alloc(std::move(alloc)) {\n         TString err;\n-        if (!BatchBuilder.Start(BuildBatchBuilderColumns(WriteIndex, inputColumns), 0, 0, err)) {\n+        if (!BatchBuilder->Start(BuildBatchBuilderColumns(WriteIndex, inputColumns), 0, 0, err)) {\n             yexception() << \"Failed to start batch builder: \" + err;\n         }\n     }\n \n+    ~TColumnDataBatcher() {\n+        TNullableAllocGuard guard(Alloc.get());\n+        BatchBuilder.reset();\n+    }\n+\n     void AddData(const NMiniKQL::TUnboxedValueBatch& data) override {\n+        TNullableAllocGuard guard(Alloc.get());\n         TRowBuilder rowBuilder(Columns.size());\n         data.ForEachRow([&](const auto& row) {\n             for (size_t index = 0; index < Columns.size(); ++index) {\n@@ -362,28 +479,30 @@ class TColumnDataBatcher : public IDataBatcher {\n                     row.GetElement(index),\n                     Columns[index].PTypeMod);\n             }\n-            auto rowWithData = rowBuilder.Build();\n-            BatchBuilder.AddRow(TConstArrayRef<TCell>{rowWithData.Cells.begin(), rowWithData.Cells.end()});\n+            BatchBuilder->AddRow(rowBuilder.BuildCells());\n         });\n     }\n \n     i64 GetMemory() const override {\n-        return BatchBuilder.Bytes();\n+        return BatchBuilder->Bytes();\n     }\n \n     IDataBatchPtr Build() override {\n-        return MakeIntrusive<TColumnBatch>(BatchBuilder.FlushBatch(true));\n+        TNullableAllocGuard guard(Alloc.get());\n+        auto batch = BatchBuilder->FlushBatch(true);\n+        return MakeIntrusive<TColumnBatch>(std::move(batch), Alloc);\n     }\n \n private:\n     const TVector<TSysTables::TTableColumnInfo> Columns;\n     const std::vector<ui32> WriteIndex;\n-    NArrow::TArrowBatchBuilder BatchBuilder;\n+    std::unique_ptr<NArrow::TArrowBatchBuilder> BatchBuilder;\n+\n+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;\n };\n \n class TColumnShardPayloadSerializer : public IPayloadSerializer {\n     using TRecordBatchPtr = std::shared_ptr<arrow::RecordBatch>;\n-    using TBatch = TColumnBatch;\n \n     struct TUnpreparedBatch {\n         ui64 TotalDataSize = 0;\n@@ -394,14 +513,17 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {\n     TColumnShardPayloadSerializer(\n         const NSchemeCache::TSchemeCacheNavigate::TEntry& schemeEntry,\n         const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,\n-        const std::vector<ui32> writeIndex) // key columns then value columns\n+        const std::vector<ui32> writeIndex,\n+        std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc) // key columns then value columns\n             : Columns(BuildColumns(inputColumns))\n-            , WriteColumnIds(BuildWriteColumnIds(inputColumns, writeIndex)) {\n-        YQL_ENSURE(schemeEntry.ColumnTableInfo);\n+            , WriteColumnIds(BuildWriteColumnIds(inputColumns, writeIndex))\n+            , Alloc(std::move(alloc)) {\n+        AFL_ENSURE(Alloc);\n+        AFL_ENSURE(schemeEntry.ColumnTableInfo);\n         const auto& description = schemeEntry.ColumnTableInfo->Description;\n-        YQL_ENSURE(description.HasSchema());\n+        AFL_ENSURE(description.HasSchema());\n         const auto& scheme = description.GetSchema();\n-        YQL_ENSURE(description.HasSharding());\n+        AFL_ENSURE(description.HasSharding());\n         const auto& sharding = description.GetSharding();\n \n         NSchemeShard::TOlapSchema olapSchema;\n@@ -410,36 +532,44 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {\n         if (shardingConclusion.IsFail()) {\n             ythrow yexception() << \"Ydb::StatusIds::SCHEME_ERROR : \" <<  shardingConclusion.GetErrorMessage();\n         }\n-        YQL_ENSURE(shardingConclusion.GetResult() != nullptr);\n+        AFL_ENSURE(shardingConclusion.GetResult() != nullptr);\n         Sharding = shardingConclusion.DetachResult();\n     }\n \n+    ~TColumnShardPayloadSerializer() {\n+        TGuard guard(*Alloc);\n+        UnpreparedBatches.clear();\n+        Batches.clear();\n+    }\n+\n     void AddData(IDataBatchPtr&& batch) override {\n-        YQL_ENSURE(!Closed);\n+        AFL_ENSURE(!Closed);\n         AddBatch(std::move(batch));\n     }\n \n     void AddBatch(IDataBatchPtr&& batch) override {\n-        auto columnshardBatch = dynamic_cast<TBatch*>(batch.Get());\n-        YQL_ENSURE(columnshardBatch);\n+        TGuard guard(*Alloc);\n+        auto columnshardBatch = dynamic_cast<TColumnBatch*>(batch.Get());\n+        AFL_ENSURE(columnshardBatch);\n         if (columnshardBatch->IsEmpty()) {\n             return;\n         }\n         auto data = columnshardBatch->Extract();\n-        YQL_ENSURE(data);\n-        ShardAndFlushBatch(data, false);\n+        AFL_ENSURE(data);\n+        ShardAndFlushBatch(std::move(data), false);\n     }\n \n-    void ShardAndFlushBatch(const TRecordBatchPtr& unshardedBatch, bool force) {\n-        for (auto [shardId, shardBatch] : Sharding->SplitByShardsToArrowBatches(unshardedBatch)) {\n+    void ShardAndFlushBatch(TRecordBatchPtr&& unshardedBatch, bool force) {\n+        for (auto [shardId, shardBatch] : Sharding->SplitByShardsToArrowBatches(\n+                                                    unshardedBatch, NKikimr::NMiniKQL::GetArrowMemoryPool())) {\n             const i64 shardBatchMemory = NArrow::GetBatchDataSize(shardBatch);\n-            YQL_ENSURE(shardBatchMemory != 0);\n+            AFL_ENSURE(shardBatchMemory != 0);\n \n             ShardIds.insert(shardId);\n             auto& unpreparedBatch = UnpreparedBatches[shardId];\n             unpreparedBatch.TotalDataSize += shardBatchMemory;\n-            unpreparedBatch.Batches.emplace_back(shardBatch);\n             Memory += shardBatchMemory;\n+            unpreparedBatch.Batches.emplace_back(shardBatch);\n \n             FlushUnpreparedBatch(shardId, unpreparedBatch, force);\n         }\n@@ -452,7 +582,7 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {\n             while (!unpreparedBatch.Batches.empty()) {\n                 auto batch = unpreparedBatch.Batches.front();\n                 unpreparedBatch.Batches.pop_front();\n-                YQL_ENSURE(batch->num_rows() > 0);\n+                AFL_ENSURE(batch->num_rows() > 0);\n                 const auto batchDataSize = NArrow::GetBatchDataSize(batch);\n                 unpreparedBatch.TotalDataSize -= batchDataSize;\n                 Memory -= batchDataSize;\n@@ -467,14 +597,14 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {\n                     i64 nextRowSize = rowCalculator.GetRowBytesSize(index);\n \n                     if (toPrepareSize + nextRowSize >= (i64)ColumnShardMaxOperationBytes) {\n-                        YQL_ENSURE(index > 0);\n+                        AFL_ENSURE(index > 0);\n \n                         toPrepare.push_back(batch->Slice(0, index));\n                         unpreparedBatch.Batches.push_front(batch->Slice(index, batch->num_rows() - index));\n \n                         const auto newBatchDataSize = NArrow::GetBatchDataSize(unpreparedBatch.Batches.front());\n \n-                        unpreparedBatch.TotalDataSize += batchDataSize;\n+                        unpreparedBatch.TotalDataSize += newBatchDataSize;\n                         Memory += newBatchDataSize;\n \n                         splitted = true;\n@@ -491,10 +621,10 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {\n                 toPrepare.push_back(batch);\n             }\n \n-            auto batch = MakeIntrusive<TBatch>(NArrow::CombineBatches(toPrepare));\n+            auto batch = MakeIntrusive<TColumnBatch>(NArrow::CombineBatches(toPrepare), Alloc);\n             Batches[shardId].emplace_back(batch);\n             Memory += batch->GetMemory();\n-            YQL_ENSURE(batch->GetMemory() != 0);\n+            AFL_ENSURE(batch->GetMemory() != 0);\n         }\n     }\n \n@@ -517,7 +647,8 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {\n     }\n \n     void Close() override {\n-        YQL_ENSURE(!Closed);\n+        TGuard guard(*Alloc);\n+        AFL_ENSURE(!Closed);\n         Closed = true;\n         FlushUnpreparedForce();\n     }\n@@ -535,6 +666,7 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {\n     }\n \n     TBatches FlushBatchesForce() override {\n+        TGuard guard(*Alloc);\n         FlushUnpreparedForce();\n \n         TBatches newBatches;\n@@ -548,6 +680,7 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {\n     }\n \n     IDataBatchPtr FlushBatch(ui64 shardId) override {\n+        TGuard guard(*Alloc);\n         if (!Batches.contains(shardId)) {\n             return {};\n         }\n@@ -573,6 +706,8 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {\n     const TVector<TSysTables::TTableColumnInfo> Columns;\n     const std::vector<ui32> WriteColumnIds;\n \n+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;\n+\n     THashMap<ui64, TUnpreparedBatch> UnpreparedBatches;\n     TBatches Batches;\n     THashSet<ui64> ShardIds;\n@@ -583,56 +718,91 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {\n };\n \n class TRowsBatcher {\n+    class TBatch {\n+    private:\n+        i64 Memory;\n+        i64 MemorySerialized;\n+        TOffloadedPoolAllocatorPtr Alloc;\n+        TOwnedCellVecBatch Rows;\n+\n+        TOwnedCellVecBatch Extract() {\n+            Memory = 0;\n+            MemorySerialized = 0;\n+            return std::move(Rows);\n+        }\n+\n+    public:\n+        TBatch(std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc)\n+            : Memory(0)\n+            , MemorySerialized(GetCellMatrixHeaderSize())\n+            , Alloc(CreateOffloadedPoolAllocator(std::move(alloc)))\n+            , Rows(Alloc->CreateMemoryPool()) {\n+        }\n+\n+        i64 AddRow(TConstArrayRef<TCell> row) {\n+            const i64 memory = EstimateSize(row);\n+            const i64 memorySerialized = memory + GetCellHeaderSize() * row.size();\n+\n+            Memory += memory;\n+            MemorySerialized += memorySerialized;\n+\n+            Rows.Append(row);\n+\n+            return memory;\n+        }\n+\n+        i64 GetMemorySerialized() {\n+            return MemorySerialized;\n+        }\n+\n+        i64 GetMemory() {\n+            return Memory;\n+        }\n+\n+        IDataBatchPtr Build() {\n+            return MakeIntrusive<TRowBatch>(Extract(), std::move(Alloc));\n+        }\n+    };\n+    \n public:\n-    explicit TRowsBatcher(ui16 columnCount, std::optional<ui64> maxBytesPerBatch)\n+    explicit TRowsBatcher(\n+            ui16 columnCount,\n+            std::optional<i64> maxBytesPerBatch,\n+            std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc)\n         : ColumnCount(columnCount)\n-        , MaxBytesPerBatch(maxBytesPerBatch) {\n+        , MaxBytesPerBatch(maxBytesPerBatch)\n+        , Alloc(std::move(alloc)) {\n     }\n \n     bool IsEmpty() const {\n         return Batches.empty();\n     }\n \n-    struct TBatch {\n-        i64 Memory = 0;\n-        i64 MemorySerialized = 0;\n-        TVector<TCell> Cells;\n-        TVector<TCharVectorPtr> Data;\n-    };\n-\n-    TBatch Flush(bool force) {\n-        TBatch res;\n+    IDataBatchPtr Flush(bool force) {\n         if ((!Batches.empty() && force) || Batches.size() > 1) {\n-            YQL_ENSURE(MaxBytesPerBatch || Batches.size() == 1);\n-            res = std::move(Batches.front());\n+            AFL_ENSURE(MaxBytesPerBatch || Batches.size() == 1);\n+            Memory -= Batches.front()->GetMemory();\n+            auto res = Batches.front()->Build();\n             Batches.pop_front();\n-            Memory -= res.Memory;\n+\n+            return res;\n         }\n-        return res;\n+\n+        auto poolAlloc = CreateOffloadedPoolAllocator(std::move(Alloc));\n+        return MakeIntrusive<TRowBatch>(TOwnedCellVecBatch(poolAlloc->CreateMemoryPool()), poolAlloc);\n     }\n \n-    ui64 AddRow(TRowWithData&& rowWithData) {\n-        YQL_ENSURE(rowWithData.Cells.size() == ColumnCount);\n-        i64 newMemory = 0;\n-        for (const auto& cell : rowWithData.Cells) {\n-            newMemory += cell.Size();\n-        }\n-        if (Batches.empty() || (MaxBytesPerBatch && newMemory + GetCellHeaderSize() * ColumnCount + Batches.back().MemorySerialized > *MaxBytesPerBatch)) {\n-            Batches.emplace_back();\n-            Batches.back().Memory = 0;\n-            Batches.back().MemorySerialized = GetCellMatrixHeaderSize();\n-        }\n+    void AddRow(TConstArrayRef<TCell> row) {\n+        AFL_ENSURE(row.size() == ColumnCount);\n \n-        for (auto& cell : rowWithData.Cells) {\n-            Batches.back().Cells.emplace_back(std::move(cell));\n+        const i64 newMemory = EstimateSize(row);\n+        const i64 newMemorySerialized = newMemory + GetCellHeaderSize() * ColumnCount;\n+        if (Batches.empty() || (MaxBytesPerBatch && newMemorySerialized + Batches.back()->GetMemorySerialized() > *MaxBytesPerBatch)) {\n+            Batches.emplace_back(std::make_unique<TBatch>(Alloc));\n         }\n-        Batches.back().Data.emplace_back(std::move(rowWithData.Data));\n-\n+        \n+        AFL_ENSURE(newMemory == Batches.back()->AddRow(std::move(row)));\n         Memory += newMemory;\n-        Batches.back().Memory += newMemory;\n-        Batches.back().MemorySerialized += newMemory + GetCellHeaderSize() * ColumnCount;\n-\n-        return newMemory;\n     }\n \n     i64 GetMemory() const {\n@@ -640,22 +810,24 @@ class TRowsBatcher {\n     }\n \n private:\n-    std::deque<TBatch> Batches;\n+    std::deque<std::unique_ptr<TBatch>> Batches;\n     ui16 ColumnCount;\n-    std::optional<ui64> MaxBytesPerBatch;\n+    std::optional<i64> MaxBytesPerBatch;\n     i64 Memory = 0;\n+\n+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;\n };\n \n class TRowDataBatcher : public IDataBatcher {\n public:\n-    using TRecordBatchPtr = std::shared_ptr<arrow::RecordBatch>;\n-\n     TRowDataBatcher(\n         const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,\n-        std::vector<ui32> writeIndex)\n+        std::vector<ui32> writeIndex,\n+        std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc)\n             : Columns(BuildColumns(inputColumns))\n             , WriteIndex(std::move(writeIndex))\n-            , RowBatcher(Columns.size(), std::nullopt) {\n+            , RowBatcher(Columns.size(), std::nullopt, alloc)\n+            , Alloc(alloc) {\n     }\n \n     void AddData(const NMiniKQL::TUnboxedValueBatch& data) override {\n@@ -668,8 +840,8 @@ class TRowDataBatcher : public IDataBatcher {\n                     row.GetElement(index),\n                     Columns[index].PTypeMod);\n             }\n-            auto rowWithData = rowBuilder.Build();\n-            RowBatcher.AddRow(std::move(rowWithData));\n+            auto cells = rowBuilder.BuildCells();\n+            RowBatcher.AddRow(cells);\n         });\n     }\n \n@@ -678,82 +850,73 @@ class TRowDataBatcher : public IDataBatcher {\n     }\n \n     IDataBatchPtr Build() override {\n-        auto batch = RowBatcher.Flush(true);\n-        const ui32 rows = batch.Cells.size() / Columns.size();\n-\n-        return MakeIntrusive<TRowBatch>(\n-            std::move(batch.Cells),\n-            std::move(batch.Data),\n-            batch.MemorySerialized,\n-            rows,\n-            static_cast<ui16>(Columns.size()));\n+        return RowBatcher.Flush(true);\n     }\n \n private:\n     const TVector<TSysTables::TTableColumnInfo> Columns;\n     const std::vector<ui32> WriteIndex;\n     TRowsBatcher RowBatcher;\n+\n+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;\n };\n \n class TDataShardPayloadSerializer : public IPayloadSerializer {\n-    using TBatch = TRowBatch;\n-\n public:\n     TDataShardPayloadSerializer(\n         const TVector<TKeyDesc::TPartitionInfo>& partitioning,\n         const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto>& keyColumns,\n         const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto>& inputColumns,\n-        std::vector<ui32> writeIndex)\n+        std::vector<ui32> writeIndex,\n+        std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc)\n         : Partitioning(partitioning)\n         , Columns(BuildColumns(inputColumns))\n         , WriteIndex(std::move(writeIndex))\n         , WriteColumnIds(BuildWriteColumnIds(inputColumns, WriteIndex))\n-        , KeyColumnTypes(BuildKeyColumnTypes(keyColumns)) {\n+        , KeyColumnTypes(BuildKeyColumnTypes(keyColumns))\n+        , Alloc(std::move(alloc)) {\n+        AFL_ENSURE(Alloc);\n+        AFL_ENSURE(Columns.size() <= std::numeric_limits<ui16>::max());\n     }\n \n-    void AddRow(TRowWithData&& row, const TVector<TKeyDesc::TPartitionInfo>& partitioning) {\n-        YQL_ENSURE(row.Cells.size() >= KeyColumnTypes.size());\n+    void AddRow(TConstArrayRef<TCell> row, const TVector<TKeyDesc::TPartitionInfo>& partitioning) {\n+        AFL_ENSURE(row.size() >= KeyColumnTypes.size());\n         auto shardIter = std::lower_bound(\n             std::begin(partitioning),\n             std::end(partitioning),\n-            TArrayRef(row.Cells.data(), KeyColumnTypes.size()),\n+            TArrayRef(row.data(), KeyColumnTypes.size()),\n             [this](const auto &partition, const auto& key) {\n                 const auto& range = *partition.Range;\n                 return 0 > CompareBorders<true, false>(range.EndKeyPrefix.GetCells(), key,\n                     range.IsInclusive || range.IsPoint, true, KeyColumnTypes);\n             });\n \n-        YQL_ENSURE(shardIter != partitioning.end());\n+        AFL_ENSURE(shardIter != partitioning.end());\n \n         auto batcherIter = Batchers.find(shardIter->ShardId);\n         if (batcherIter == std::end(Batchers)) {\n             Batchers.emplace(\n                 shardIter->ShardId,\n-                TRowsBatcher(Columns.size(), DataShardMaxOperationBytes));\n+                TRowsBatcher(Columns.size(), DataShardMaxOperationBytes, Alloc));\n         }\n \n-        Memory += Batchers.at(shardIter->ShardId).AddRow(std::move(row));\n+        Batchers.at(shardIter->ShardId).AddRow(row);\n         ShardIds.insert(shardIter->ShardId);\n     }\n \n     void AddData(IDataBatchPtr&& data) override {\n-        YQL_ENSURE(!Closed);\n+        AFL_ENSURE(!Closed);\n         AddBatch(std::move(data));\n     }\n \n     void AddBatch(IDataBatchPtr&& batch) override {\n-        auto datashardBatch = dynamic_cast<TBatch*>(batch.Get());\n-        YQL_ENSURE(datashardBatch);\n-        auto [cells, data] = datashardBatch->Extract();\n-        const auto rows = cells.size() / Columns.size();\n-        YQL_ENSURE(cells.size() == rows * Columns.size());\n+        auto datashardBatch = dynamic_cast<TRowBatch*>(batch.Get());\n+        AFL_ENSURE(datashardBatch);\n+        auto rows = datashardBatch->Extract();\n \n-        for (size_t rowIndex = 0; rowIndex < rows; ++rowIndex) {\n+        for (const auto& row : rows) {\n             AddRow(\n-                TRowWithData{\n-                    TVector<TCell>(cells.begin() + (rowIndex * Columns.size()), cells.begin() + (rowIndex * Columns.size()) + Columns.size()),\n-                    std::move(data[rowIndex]),\n-                },\n+                row,\n                 Partitioning);\n         }\n     }\n@@ -767,11 +930,15 @@ class TDataShardPayloadSerializer : public IPayloadSerializer {\n     }\n \n     i64 GetMemory() override {\n-        return Memory;\n+        i64 memory = 0;\n+        for (const auto& [_, batcher] : Batchers) {\n+            memory += batcher.GetMemory();\n+        }\n+        return memory;\n     }\n \n     void Close() override {\n-        YQL_ENSURE(!Closed);\n+        AFL_ENSURE(!Closed);\n         Closed = true;\n     }\n \n@@ -788,16 +955,7 @@ class TDataShardPayloadSerializer : public IPayloadSerializer {\n     }\n \n     IDataBatchPtr ExtractNextBatch(TRowsBatcher& batcher, bool force) {\n-        auto batchResult = batcher.Flush(force);\n-        Memory -= batchResult.Memory;\n-        const ui32 rows = batchResult.Cells.size() / Columns.size();\n-        YQL_ENSURE(Columns.size() <= std::numeric_limits<ui16>::max());\n-        return MakeIntrusive<TRowBatch>(\n-            std::move(batchResult.Cells),\n-            std::move(batchResult.Data),\n-            static_cast<i64>(batchResult.MemorySerialized),\n-            rows,\n-            static_cast<ui16>(Columns.size()));\n+        return batcher.Flush(force);\n     }\n \n     TBatches FlushBatchesForce() override {\n@@ -833,41 +991,42 @@ class TDataShardPayloadSerializer : public IPayloadSerializer {\n     const std::vector<ui32> WriteIndex;\n     const std::vector<ui32> WriteColumnIds;\n     const TVector<NScheme::TTypeInfo> KeyColumnTypes;\n+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;\n \n     THashMap<ui64, TRowsBatcher> Batchers;\n     THashSet<ui64> ShardIds;\n \n-    i64 Memory = 0;\n-\n     bool Closed = false;\n };\n IPayloadSerializerPtr CreateColumnShardPayloadSerializer(\n         const NSchemeCache::TSchemeCacheNavigate::TEntry& schemeEntry,\n         const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,\n-        const std::vector<ui32> writeIndex) {\n+        const std::vector<ui32> writeIndex,\n+        std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc) {\n     return MakeIntrusive<TColumnShardPayloadSerializer>(\n-        schemeEntry, inputColumns, std::move(writeIndex));\n+        schemeEntry, inputColumns, std::move(writeIndex), std::move(alloc));\n }\n \n IPayloadSerializerPtr CreateDataShardPayloadSerializer(\n         const TVector<TKeyDesc::TPartitionInfo>& partitioning,\n         const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> keyColumns,\n         const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,\n-        const std::vector<ui32> writeIndex) {\n+        const std::vector<ui32> writeIndex,\n+        std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc) {\n     return MakeIntrusive<TDataShardPayloadSerializer>(\n-        partitioning, keyColumns, inputColumns, std::move(writeIndex));\n+        partitioning, keyColumns, inputColumns, std::move(writeIndex), std::move(alloc));\n }\n \n }\n \n IDataBatcherPtr CreateColumnDataBatcher(const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,\n-        std::vector<ui32> writeIndex) {\n-    return MakeIntrusive<TColumnDataBatcher>(inputColumns, std::move(writeIndex));\n+        std::vector<ui32> writeIndex, std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc) {\n+    return MakeIntrusive<TColumnDataBatcher>(inputColumns, std::move(writeIndex), std::move(alloc));\n }\n \n IDataBatcherPtr CreateRowDataBatcher(const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,\n-        std::vector<ui32> writeIndex) {\n-    return MakeIntrusive<TRowDataBatcher>(inputColumns, std::move(writeIndex));\n+        std::vector<ui32> writeIndex, std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc) {\n+    return MakeIntrusive<TRowDataBatcher>(inputColumns, std::move(writeIndex), std::move(alloc));\n }\n \n bool IDataBatch::IsEmpty() const {\n@@ -894,6 +1053,10 @@ struct TBatchWithMetadata {\n         return Data == nullptr;\n     }\n \n+    i64 GetSerializedMemory() const {\n+        return IsCoveringBatch() ? 0 : Data->GetSerializedMemory();\n+    }\n+\n     i64 GetMemory() const {\n         return IsCoveringBatch() ? 0 : Data->GetMemory();\n     }\n@@ -927,20 +1090,21 @@ class TShardsInfo {\n             return IsClosed() && IsEmpty();\n         }\n \n-        void MakeNextBatches(i64 maxDataSize, ui64 maxCount) {\n-            YQL_ENSURE(BatchesInFlight == 0);\n-            YQL_ENSURE(!IsEmpty());\n-            YQL_ENSURE(maxCount != 0);\n+        void MakeNextBatches(i64 maxDataSize, std::optional<ui64> maxCount) {\n+            AFL_ENSURE(BatchesInFlight == 0);\n+            AFL_ENSURE(!IsEmpty());\n             i64 dataSize = 0;\n             // For columnshard batch can be slightly larger than the limit.\n-            while (BatchesInFlight < maxCount\n+            while ((!maxCount || BatchesInFlight < *maxCount)\n                     && BatchesInFlight < Batches.size()\n-                    && (dataSize + GetBatch(BatchesInFlight).GetMemory() <= maxDataSize || BatchesInFlight == 0)) {\n-                dataSize += GetBatch(BatchesInFlight).GetMemory();\n+                    && (dataSize + GetBatch(BatchesInFlight).GetSerializedMemory() <= maxDataSize || BatchesInFlight == 0)) {\n+                dataSize += GetBatch(BatchesInFlight).GetSerializedMemory();\n                 ++BatchesInFlight;\n             }\n-            YQL_ENSURE(BatchesInFlight != 0);\n-            YQL_ENSURE(BatchesInFlight == Batches.size() || BatchesInFlight >= maxCount || dataSize + GetBatch(BatchesInFlight).GetMemory() > maxDataSize);\n+            AFL_ENSURE(BatchesInFlight != 0);\n+            AFL_ENSURE(BatchesInFlight == Batches.size()\n+                || (maxCount && BatchesInFlight >= *maxCount)\n+                || dataSize + GetBatch(BatchesInFlight).GetSerializedMemory() > maxDataSize);\n         }\n \n         TBatchWithMetadata& GetBatch(size_t index) {\n@@ -958,7 +1122,9 @@ class TShardsInfo {\n             if (BatchesInFlight != 0 && Cookie == cookie) {\n                 TBatchInfo result;\n                 for (size_t index = 0; index < BatchesInFlight; ++index) {\n-                    result.DataSize += Batches.front().GetMemory();\n+                    const i64 batchMemory = Batches.front().GetMemory();\n+                    result.DataSize += batchMemory;\n+                    Memory -= batchMemory;\n                     Batches.pop_front();\n                 }\n \n@@ -966,14 +1132,13 @@ class TShardsInfo {\n                 SendAttempts = 0;\n                 BatchesInFlight = 0;\n \n-                Memory -= result.DataSize;\n                 return result;\n             }\n             return std::nullopt;\n         }\n \n         void PushBatch(TBatchWithMetadata&& batch) {\n-            YQL_ENSURE(!IsClosed());\n+            AFL_ENSURE(!IsClosed());\n             Batches.emplace_back(std::move(batch));\n             Memory += Batches.back().GetMemory();\n             HasReadInBatch |= Batches.back().HasRead;\n@@ -1101,7 +1266,8 @@ class TShardedWriteController : public IShardedWriteController {\n             writeInfo.Serializer = CreateColumnShardPayloadSerializer(\n                 *SchemeEntry,\n                 writeInfo.Metadata.InputColumnsMetadata,\n-                writeInfo.Metadata.WriteIndex);\n+                writeInfo.Metadata.WriteIndex,\n+                Alloc);\n         }\n         AfterPartitioningChanged();\n     }\n@@ -1116,7 +1282,8 @@ class TShardedWriteController : public IShardedWriteController {\n                 *Partitioning,\n                 writeInfo.Metadata.KeyColumnsMetadata,\n                 writeInfo.Metadata.InputColumnsMetadata,\n-                writeInfo.Metadata.WriteIndex);\n+                writeInfo.Metadata.WriteIndex,\n+                Alloc);\n         }\n         AfterPartitioningChanged();\n     }\n@@ -1181,22 +1348,27 @@ class TShardedWriteController : public IShardedWriteController {\n                 *Partitioning,\n                 iter->second.Metadata.KeyColumnsMetadata,\n                 iter->second.Metadata.InputColumnsMetadata,\n-                iter->second.Metadata.WriteIndex);\n+                iter->second.Metadata.WriteIndex,\n+                Alloc);\n         } else if (SchemeEntry) {\n             iter->second.Serializer = CreateColumnShardPayloadSerializer(\n                 *SchemeEntry,\n                 iter->second.Metadata.InputColumnsMetadata,\n-                iter->second.Metadata.WriteIndex);\n+                iter->second.Metadata.WriteIndex,\n+                Alloc);\n         }\n         return token;\n     }\n \n     void Write(TWriteToken token, IDataBatchPtr&& data) override {\n         auto& info = WriteInfos.at(token);\n-        YQL_ENSURE(!info.Closed);\n+        AFL_ENSURE(!info.Closed);\n \n-        auto allocGuard = TypeEnv.BindAllocator();\n-        YQL_ENSURE(info.Serializer);\n+        AFL_ENSURE(info.Serializer);\n+        if (!data->AttachedAlloc()) {\n+            AFL_ENSURE(!Settings.Inconsistent);\n+            data->AttachAlloc(Alloc);\n+        }\n         info.Serializer->AddData(std::move(data));\n \n         if (info.Metadata.Priority == 0) {\n@@ -1205,27 +1377,26 @@ class TShardedWriteController : public IShardedWriteController {\n     }\n \n     void Close(TWriteToken token) override {\n-        auto allocGuard = TypeEnv.BindAllocator();\n         auto& info = WriteInfos.at(token);\n-        YQL_ENSURE(info.Serializer);\n+        AFL_ENSURE(info.Serializer);\n         info.Closed = true;\n         info.Serializer->Close();\n         if (info.Metadata.Priority == 0) {\n             FlushSerializer(token, true);\n-            YQL_ENSURE(info.Serializer->IsFinished());\n+            AFL_ENSURE(info.Serializer->IsFinished());\n         }\n     }\n \n     void FlushBuffers() override {\n         TVector<TWriteToken> writeTokensFoFlush;\n         for (const auto& [token, writeInfo] : WriteInfos) {\n-            YQL_ENSURE(writeInfo.Closed);\n+            AFL_ENSURE(writeInfo.Closed);\n             if (writeInfo.Metadata.Priority != 0) {\n                 if (!writeInfo.Serializer->IsFinished()) {\n                     writeTokensFoFlush.push_back(token);\n                 }\n             } else {\n-                YQL_ENSURE(writeInfo.Serializer->IsFinished());\n+                AFL_ENSURE(writeInfo.Serializer->IsFinished());\n             }\n         }\n \n@@ -1240,7 +1411,7 @@ class TShardedWriteController : public IShardedWriteController {\n         \n         for (const TWriteToken token : writeTokensFoFlush) {\n             FlushSerializer(token, true);\n-            YQL_ENSURE(WriteInfos.at(token).Serializer->IsFinished());\n+            AFL_ENSURE(WriteInfos.at(token).Serializer->IsFinished());\n         }\n     }\n \n@@ -1294,7 +1465,7 @@ class TShardedWriteController : public IShardedWriteController {\n         for (size_t index = 0; index < shardInfo.GetBatchesInFlight(); ++index) {\n             const auto& inFlightBatch = shardInfo.GetBatch(index);\n             if (inFlightBatch.Data) {\n-                YQL_ENSURE(!inFlightBatch.Data->IsEmpty());\n+                AFL_ENSURE(!inFlightBatch.Data->IsEmpty());\n                 result.TotalDataSize += inFlightBatch.Data->GetMemory();\n                 const ui64 payloadIndex = NKikimr::NEvWrite::TPayloadWriter<NKikimr::NEvents::TDataEvents::TEvWrite>(evWrite)\n                         .AddDataToPayload(inFlightBatch.Data->SerializeToString());\n@@ -1306,7 +1477,7 @@ class TShardedWriteController : public IShardedWriteController {\n                     payloadIndex,\n                     writeInfo.Serializer->GetDataFormat());\n             } else {\n-                YQL_ENSURE(index + 1 == shardInfo.GetBatchesInFlight());   \n+                AFL_ENSURE(index + 1 == shardInfo.GetBatchesInFlight());   \n             }\n         }\n \n@@ -1314,7 +1485,6 @@ class TShardedWriteController : public IShardedWriteController {\n     }\n \n     std::optional<TMessageAcknowledgedResult> OnMessageAcknowledged(ui64 shardId, ui64 cookie) override {\n-        auto allocGuard = TypeEnv.BindAllocator();\n         auto& shardInfo = ShardsInfo.GetShard(shardId);\n         const auto result = shardInfo.PopBatches(cookie);\n         if (result) {\n@@ -1348,7 +1518,7 @@ class TShardedWriteController : public IShardedWriteController {\n             if (writeInfo.Serializer) {\n                 total += writeInfo.Serializer->GetMemory();\n             } else {\n-                YQL_ENSURE(writeInfo.Closed);\n+                AFL_ENSURE(writeInfo.Closed);\n             }\n         }\n         return total;\n@@ -1396,16 +1566,12 @@ class TShardedWriteController : public IShardedWriteController {\n \n     TShardedWriteController(\n         const TShardedWriteControllerSettings settings,\n-        const NMiniKQL::TTypeEnvironment& typeEnv,\n         std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc)\n         : Settings(settings)\n-        , TypeEnv(typeEnv)\n-        , Alloc(alloc) {\n+        , Alloc(std::move(alloc)) {\n     }\n \n     ~TShardedWriteController() {\n-        Y_ABORT_UNLESS(Alloc);\n-        TGuard<NMiniKQL::TScopedAlloc> allocGuard(*Alloc);\n         ShardsInfo.Clear();\n         for (auto& [_, writeInfo] : WriteInfos) {\n             writeInfo.Serializer = nullptr;\n@@ -1414,8 +1580,8 @@ class TShardedWriteController : public IShardedWriteController {\n \n private:\n     void FlushSerializer(TWriteToken token, bool force) {\n+        const auto& writeInfo = WriteInfos.at(token);\n         if (force) {\n-            const auto& writeInfo = WriteInfos.at(token);\n             for (auto& [shardId, batches] : writeInfo.Serializer->FlushBatchesForce()) {\n                 for (auto& batch : batches) {\n                     if (batch && !batch->IsEmpty()) {\n@@ -1429,7 +1595,6 @@ class TShardedWriteController : public IShardedWriteController {\n                 }\n             }\n         } else {\n-            const auto& writeInfo = WriteInfos.at(token);\n             for (const ui64 shardId : writeInfo.Serializer->GetShardIds()) {\n                 auto& shard = ShardsInfo.GetShard(shardId);\n                 while (true) {\n@@ -1450,29 +1615,30 @@ class TShardedWriteController : public IShardedWriteController {\n \n     void BuildBatchesForShard(TShardsInfo::TShardInfo& shard) {\n         if (shard.GetBatchesInFlight() == 0) {\n-            YQL_ENSURE(IsOlap != std::nullopt);\n-            shard.MakeNextBatches(\n-                Settings.MemoryLimitPerMessage,\n-                (*IsOlap) ? 1 : Settings.MaxBatchesPerMessage);\n+            AFL_ENSURE(IsOlap != std::nullopt);\n+            if (*IsOlap) {\n+                shard.MakeNextBatches(Settings.MemoryLimitPerMessage, 1);\n+            } else {\n+                shard.MakeNextBatches(Settings.MemoryLimitPerMessage, std::nullopt);\n+            }\n         }\n     }\n \n     void ReshardData() {\n-        YQL_ENSURE(!Settings.Inconsistent);\n+        AFL_ENSURE(Settings.Inconsistent);\n         for (auto& [_, shardInfo] : ShardsInfo.GetShards()) {\n             for (size_t index = 0; index < shardInfo.Size(); ++index) {\n                 auto& batch = shardInfo.GetBatch(index);\n                 const auto& writeInfo = WriteInfos.at(batch.Token);\n                 // Resharding supported only for inconsistent write,\n                 // so convering empty batches don't exist in this case.\n-                YQL_ENSURE(batch.Data);\n+                AFL_ENSURE(batch.Data);\n                 writeInfo.Serializer->AddBatch(std::move(batch.Data));\n             }\n         }\n     }\n \n     TShardedWriteControllerSettings Settings;\n-    const NMiniKQL::TTypeEnvironment& TypeEnv;\n     std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;\n \n     struct TWriteInfo {\n@@ -1496,10 +1662,8 @@ class TShardedWriteController : public IShardedWriteController {\n \n IShardedWriteControllerPtr CreateShardedWriteController(\n         const TShardedWriteControllerSettings& settings,\n-        const NMiniKQL::TTypeEnvironment& typeEnv,\n         std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc) {\n-    return MakeIntrusive<TShardedWriteController>(\n-        settings, typeEnv, alloc);\n+    return MakeIntrusive<TShardedWriteController>(settings, std::move(alloc));\n }\n \n }\ndiff --git a/ydb/core/kqp/runtime/kqp_write_table.h b/ydb/core/kqp/runtime/kqp_write_table.h\nindex 83aa4e69f9a8..d1612e6caece 100644\n--- a/ydb/core/kqp/runtime/kqp_write_table.h\n+++ b/ydb/core/kqp/runtime/kqp_write_table.h\n@@ -13,10 +13,15 @@ namespace NKqp {\n class IDataBatch : public TThrRefBase {\n public:\n     virtual TString SerializeToString() const = 0;\n+    virtual i64 GetSerializedMemory() const = 0;\n     virtual i64 GetMemory() const = 0;\n     virtual bool IsEmpty() const = 0;\n \n     virtual std::shared_ptr<void> ExtractBatch() = 0;\n+\n+    virtual void AttachAlloc(std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc) = 0;\n+    virtual void DetachAlloc() = 0;\n+    virtual bool AttachedAlloc() const = 0;\n };\n \n using IDataBatchPtr = TIntrusivePtr<IDataBatch>;\n@@ -33,11 +38,13 @@ using IDataBatcherPtr = TIntrusivePtr<IDataBatcher>;\n \n IDataBatcherPtr CreateRowDataBatcher(\n     const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,\n-    std::vector<ui32> writeIndex);\n+    std::vector<ui32> writeIndex,\n+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc = nullptr);\n \n IDataBatcherPtr CreateColumnDataBatcher(\n     const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,\n-    std::vector<ui32> writeIndex);\n+    std::vector<ui32> writeIndex,\n+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc = nullptr);\n \n class IShardedWriteController : public TThrRefBase {\n public:\n@@ -114,15 +121,13 @@ using IShardedWriteControllerPtr = TIntrusivePtr<IShardedWriteController>;\n \n \n struct TShardedWriteControllerSettings {\n-    i64 MemoryLimitTotal;\n-    i64 MemoryLimitPerMessage;\n-    i64 MaxBatchesPerMessage;\n-    bool Inconsistent;\n+    i64 MemoryLimitTotal = 0;\n+    i64 MemoryLimitPerMessage = 0;\n+    bool Inconsistent = false;\n };\n \n IShardedWriteControllerPtr CreateShardedWriteController(\n     const TShardedWriteControllerSettings& settings,\n-    const NMiniKQL::TTypeEnvironment& typeEnv,\n     std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc);\n \n }\ndiff --git a/ydb/core/kqp/session_actor/kqp_query_state.h b/ydb/core/kqp/session_actor/kqp_query_state.h\nindex ecbd3a5348ed..57411dde5964 100644\n--- a/ydb/core/kqp/session_actor/kqp_query_state.h\n+++ b/ydb/core/kqp/session_actor/kqp_query_state.h\n@@ -176,12 +176,16 @@ class TKqpQueryState : public TNonCopyable {\n         if (RequestEv->GetRequestCtx() == nullptr) {\n             return false;\n         }\n-        if (ParticipantNodes.size() == 1) {\n+        if (IsSingleNodeExecution()) {\n             return *ParticipantNodes.begin() == nodeId;\n         }\n         return false;\n     }\n \n+    bool IsSingleNodeExecution() const {\n+        return ParticipantNodes.size() == 1;\n+    }\n+\n     NKikimrKqp::EQueryAction GetAction() const {\n         return QueryAction;\n     }\ndiff --git a/ydb/core/kqp/session_actor/kqp_session_actor.cpp b/ydb/core/kqp/session_actor/kqp_session_actor.cpp\nindex 07c5c58d1f1e..5695f1ea390a 100644\n--- a/ydb/core/kqp/session_actor/kqp_session_actor.cpp\n+++ b/ydb/core/kqp/session_actor/kqp_session_actor.cpp\n@@ -944,7 +944,7 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {\n         }\n \n         QueryState->TxCtx->SetTempTables(QueryState->TempTablesState);\n-        QueryState->TxCtx->ApplyPhysicalQuery(phyQuery);\n+        QueryState->TxCtx->ApplyPhysicalQuery(phyQuery, QueryState->Commit);\n         auto [success, issues] = QueryState->TxCtx->ApplyTableOperations(phyQuery.GetTableOps(), phyQuery.GetTableInfos(),\n             EKikimrQueryType::Dml);\n         if (!success) {\n@@ -1259,6 +1259,7 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {\n             return true;\n         }\n \n+        YQL_ENSURE(tx || commit);\n         if (tx) {\n             switch (tx->GetType()) {\n                 case NKqpProto::TKqpPhyTx::TYPE_COMPUTE:\n@@ -1285,15 +1286,16 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {\n \n                 QueryState->QueryData->AddUVParam(paramDesc.GetName(), paramType, value);\n             }\n+        }\n \n-            try {\n-                QueryState->QueryData->PrepareParameters(tx, QueryState->PreparedQuery, txCtx.TxAlloc->TypeEnv);\n-            } catch (const yexception& ex) {\n-                ythrow TRequestFail(Ydb::StatusIds::BAD_REQUEST) << ex.what();\n-            }\n+        try {\n+            QueryState->QueryData->PrepareParameters(tx, QueryState->PreparedQuery, txCtx.TxAlloc->TypeEnv);\n+        } catch (const yexception& ex) {\n+            ythrow TRequestFail(Ydb::StatusIds::BAD_REQUEST) << ex.what();\n+        }\n+\n+        if (tx) {\n             request.Transactions.emplace_back(tx, QueryState->QueryData);\n-        } else {\n-            YQL_ENSURE(commit);\n         }\n \n         QueryState->TxCtx->OnNewExecutor(literal);\n@@ -1448,12 +1450,32 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {\n             txCtx->TxManager->SetTopicOperations(std::move(request.TopicOperations));\n             txCtx->TxManager->AddTopicsToShards();\n \n+            auto alloc = std::make_shared<NKikimr::NMiniKQL::TScopedAlloc>(\n+                __LOCATION__, NKikimr::TAlignedPagePoolCounters(), true, false);\n+\n+            const auto& queryLimitsProto = Settings.TableService.GetQueryLimits();\n+            const auto& bufferLimitsProto = queryLimitsProto.GetBufferLimits();\n+            const ui64 writeBufferMemoryLimit = bufferLimitsProto.HasWriteBufferMemoryLimitBytes()\n+                ? bufferLimitsProto.GetWriteBufferMemoryLimitBytes()\n+                : ui64(Settings.MkqlMaxMemoryLimit);\n+            const ui64 writeBufferInitialMemoryLimit = writeBufferMemoryLimit < ui64(Settings.MkqlInitialMemoryLimit)\n+                ? writeBufferMemoryLimit\n+                : ui64(Settings.MkqlInitialMemoryLimit);\n+            alloc->SetLimit(writeBufferInitialMemoryLimit);\n+            alloc->Ref().SetIncreaseMemoryLimitCallback([this, alloc=alloc.get(), writeBufferMemoryLimit](ui64 currentLimit, ui64 required) {\n+                if (required < writeBufferMemoryLimit) {\n+                    LOG_D(\"Increase memory limit from \" << currentLimit << \" to \" << required);\n+                    alloc->SetLimit(required);\n+                }\n+            });\n+\n             TKqpBufferWriterSettings settings {\n                 .SessionActorId = SelfId(),\n                 .TxManager = txCtx->TxManager,\n                 .TraceId = request.TraceId.GetTraceId(),\n                 .Counters = Counters,\n                 .TxProxyMon = RequestCounters->TxProxyMon,\n+                .Alloc = std::move(alloc),\n             };\n             auto* actor = CreateKqpBufferWriterActor(std::move(settings));\n             txCtx->BufferActorId = RegisterWithSameMailbox(actor);\n@@ -1468,7 +1490,7 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {\n             AsyncIoFactory, QueryState ? QueryState->PreparedQuery : nullptr, SelfId(),\n             QueryState ? QueryState->UserRequestContext : MakeIntrusive<TUserRequestContext>(\"\", Settings.Database, SessionId),\n             QueryState ? QueryState->StatementResultIndex : 0, FederatedQuerySetup,\n-            (!Settings.TableService.GetEnableOltpSink() && QueryState && QueryState->RequestEv->GetSyntax() == Ydb::Query::Syntax::SYNTAX_PG)\n+            (QueryState && QueryState->RequestEv->GetSyntax() == Ydb::Query::Syntax::SYNTAX_PG)\n                 ? GUCSettings : nullptr,\n             txCtx->ShardIdToTableInfo, txCtx->TxManager, txCtx->BufferActorId);\n \n@@ -1625,8 +1647,12 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {\n             QueryState->QueryStats.Executions.back().Swap(executerResults.MutableStats());\n         }\n \n-        for (auto nodeId : ev->ParticipantNodes) {\n-            QueryState->ParticipantNodes.emplace(nodeId);\n+        if (QueryState->TxCtx->TxManager) {\n+            QueryState->ParticipantNodes = QueryState->TxCtx->TxManager->GetParticipantNodes();\n+        } else {\n+            for (auto nodeId : ev->ParticipantNodes) {\n+                QueryState->ParticipantNodes.emplace(nodeId);\n+            }\n         }\n \n         if (response->GetStatus() != Ydb::StatusIds::SUCCESS) {\n@@ -1743,21 +1769,20 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {\n     }\n \n     void Handle(TEvKqpBuffer::TEvError::TPtr& ev) {\n-        const auto& msg = *ev->Get();\n+        auto& msg = *ev->Get();\n \n         TString logMsg = TStringBuilder() << \"got TEvKqpBuffer::TEvError in \" << CurrentStateFuncName()\n             << \", status: \" << NYql::NDqProto::StatusIds_StatusCode_Name(msg.StatusCode) << \" send to: \" << ExecuterId << \" from: \" << ev->Sender;\n \n         if (!QueryState || !QueryState->TxCtx || QueryState->TxCtx->BufferActorId != ev->Sender) {\n-            LOG_E(logMsg <<  \": Old error.\");\n+            LOG_E(logMsg <<  \": Ignored error.\");\n             return;\n         } else {\n             LOG_W(logMsg);\n         }\n \n         if (ExecuterId) {\n-            auto abortEv = MakeHolder<TEvKqp::TEvAbortExecution>(msg.StatusCode, msg.Issues);\n-            Send(ExecuterId, abortEv.Release(), IEventHandle::FlagTrackDelivery);\n+            Send(ExecuterId, new TEvKqpBuffer::TEvError{msg.StatusCode, std::move(msg.Issues)}, IEventHandle::FlagTrackDelivery);\n         } else {\n             ReplyQueryError(NYql::NDq::DqStatusToYdbStatus(msg.StatusCode), logMsg, MessageFromIssues(msg.Issues));\n         }\n@@ -2003,7 +2028,6 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {\n             size_t trailingResultsCount = 0;\n             for (size_t i = 0; i < phyQuery.ResultBindingsSize(); ++i) {\n                 if (QueryState->IsStreamResult()) {\n-\n                     if (QueryState->QueryData->HasTrailingTxResult(phyQuery.GetResultBindings(i))) {\n                         auto ydbResult = QueryState->QueryData->GetYdbTxResult(\n                             phyQuery.GetResultBindings(i), response->GetArena(), {});\n@@ -2377,7 +2401,7 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {\n             QueryState->PoolHandlerActor = Nothing();\n         }\n \n-        if (QueryState && QueryState->ParticipantNodes.size() == 1) {\n+        if (QueryState && QueryState->IsSingleNodeExecution()) {\n             Counters->TotalSingleNodeReqCount->Inc();\n             if (!QueryState->IsLocalExecution(SelfId().NodeId())) {\n                 Counters->NonLocalSingleNodeReqCount->Inc();\ndiff --git a/ydb/core/kqp/ut/common/kqp_ut_common.cpp b/ydb/core/kqp/ut/common/kqp_ut_common.cpp\nindex 86ab759c81c0..fd957cced050 100644\n--- a/ydb/core/kqp/ut/common/kqp_ut_common.cpp\n+++ b/ydb/core/kqp/ut/common/kqp_ut_common.cpp\n@@ -527,6 +527,8 @@ void TKikimrRunner::Initialize(const TKikimrSettings& settings) {\n     SetupLogLevelFromTestParam(NKikimrServices::TX_COLUMNSHARD);\n     SetupLogLevelFromTestParam(NKikimrServices::TX_COLUMNSHARD_SCAN);\n     SetupLogLevelFromTestParam(NKikimrServices::LOCAL_PGWIRE);\n+    SetupLogLevelFromTestParam(NKikimrServices::SSA_GRAPH_EXECUTION);\n+\n \n     RunCall([this, domain = settings.DomainRoot]{\n         this->Client->InitRootScheme(domain);\n@@ -1612,5 +1614,64 @@ NJson::TJsonValue GetJoinOrderFromDetailedJoinOrder(const TString& deserializedD\n     return GetJoinOrderFromDetailedJoinOrderImpl(optRoot);\n }\n \n+TTestExtEnv::TTestExtEnv(TTestExtEnv::TEnvSettings envSettings) {\n+    auto mbusPort = PortManager.GetPort();\n+    auto grpcPort = PortManager.GetPort();\n+\n+    Settings = new Tests::TServerSettings(mbusPort);\n+    EnvSettings = envSettings;\n+\n+    Settings->SetDomainName(\"Root\");\n+    Settings->SetNodeCount(EnvSettings.StaticNodeCount);\n+    Settings->SetDynamicNodeCount(EnvSettings.DynamicNodeCount);\n+    Settings->SetUseRealThreads(EnvSettings.UseRealThreads);\n+    Settings->AddStoragePoolType(EnvSettings.PoolName);\n+    Settings->SetFeatureFlags(EnvSettings.FeatureFlags);\n+\n+    Server = new Tests::TServer(*Settings);\n+    Server->EnableGRpc(grpcPort);\n+\n+    auto sender = Server->GetRuntime()->AllocateEdgeActor();\n+    Server->SetupRootStoragePools(sender);\n+\n+    Client = MakeHolder<Tests::TClient>(*Settings);\n+\n+    Tenants = MakeHolder<Tests::TTenants>(Server);\n+\n+    Endpoint = \"localhost:\" + ToString(grpcPort);\n+    DriverConfig = NYdb::TDriverConfig().SetEndpoint(Endpoint);\n+    Driver = MakeHolder<NYdb::TDriver>(DriverConfig);\n+}\n+\n+TTestExtEnv::~TTestExtEnv() {\n+    Driver->Stop(true);\n+}\n+\n+void TTestExtEnv::CreateDatabase(const TString& databaseName) {\n+    auto& runtime = *Server->GetRuntime();\n+    auto fullDbName = \"/Root/\" + databaseName;\n+\n+    using TEvCreateDatabaseRequest = NKikimr::NGRpcService::TGrpcRequestOperationCall\n+    <\n+        Ydb::Cms::CreateDatabaseRequest,\n+        Ydb::Cms::CreateDatabaseResponse\n+    >;\n+\n+    Ydb::Cms::CreateDatabaseRequest request;\n+    request.set_path(fullDbName);\n+\n+    auto* resources = request.mutable_resources();\n+    auto* storage = resources->add_storage_units();\n+    storage->set_unit_kind(EnvSettings.PoolName);\n+    storage->set_count(1);\n+\n+    auto future = NRpcService::DoLocalRpc<TEvCreateDatabaseRequest>(std::move(request), \"\", \"\", runtime.GetActorSystem(0));\n+    auto response = runtime.WaitFuture(std::move(future));\n+    UNIT_ASSERT(response.operation().ready());\n+    UNIT_ASSERT_VALUES_EQUAL(response.operation().status(), Ydb::StatusIds::SUCCESS);\n+\n+    Tenants->Run(fullDbName, EnvSettings.DynamicNodeCount);\n+}\n+\n } // namspace NKqp\n } // namespace NKikimr\ndiff --git a/ydb/core/kqp/ut/common/kqp_ut_common.h b/ydb/core/kqp/ut/common/kqp_ut_common.h\nindex 50d82afd2f2c..f2f9bbe559ff 100644\n--- a/ydb/core/kqp/ut/common/kqp_ut_common.h\n+++ b/ydb/core/kqp/ut/common/kqp_ut_common.h\n@@ -403,5 +403,39 @@ NJson::TJsonValue GetJoinOrder(const TString& deserializedPlan);\n \n NJson::TJsonValue GetJoinOrderFromDetailedJoinOrder(const TString& deserializedDetailedJoinOrder);\n \n+class TTestExtEnv {\n+public:\n+    struct TEnvSettings {\n+        size_t StaticNodeCount = 1;\n+        size_t DynamicNodeCount = 1;\n+        TString PoolName = \"hdd1\";\n+        bool UseRealThreads = true;\n+        NKikimrConfig::TFeatureFlags FeatureFlags;\n+    };\n+\n+    TTestExtEnv(TEnvSettings envSettings);\n+    ~TTestExtEnv();\n+\n+    NYdb::TDriver& GetDriver() const {\n+        return *Driver;\n+    }\n+\n+    void CreateDatabase(const TString& databaseName);\n+\n+private:\n+    TPortManager PortManager;\n+\n+    Tests::TServerSettings::TPtr Settings;\n+    Tests::TServer::TPtr Server;\n+    THolder<Tests::TClient> Client;\n+    THolder<Tests::TTenants> Tenants;\n+\n+    TString Endpoint;\n+    NYdb::TDriverConfig DriverConfig;\n+    THolder<NYdb::TDriver> Driver;\n+\n+    TEnvSettings EnvSettings;\n+};\n+\n } // namespace NKqp\n } // namespace NKikimr\ndiff --git a/ydb/core/kqp/ut/data_integrity/kqp_data_integrity_trails_ut.cpp b/ydb/core/kqp/ut/data_integrity/kqp_data_integrity_trails_ut.cpp\nindex f8d362bb530e..962bfce88ee2 100644\n--- a/ydb/core/kqp/ut/data_integrity/kqp_data_integrity_trails_ut.cpp\n+++ b/ydb/core/kqp/ut/data_integrity/kqp_data_integrity_trails_ut.cpp\n@@ -1,5 +1,7 @@\n #include <ydb/core/kqp/ut/common/kqp_ut_common.h>\n \n+#include <regex>\n+\n namespace NKikimr {\n namespace NKqp {\n \n@@ -17,10 +19,13 @@ namespace {\n }\n \n Y_UNIT_TEST_SUITE(KqpDataIntegrityTrails) {\n-    Y_UNIT_TEST_TWIN(Upsert, LogEnabled) {\n+    Y_UNIT_TEST_QUAD(Upsert, LogEnabled, UseSink) {\n         TStringStream ss;\n         {\n+            NKikimrConfig::TAppConfig appConfig;\n+            appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n             TKikimrSettings serverSettings;\n+            serverSettings.SetAppConfig(appConfig);\n             serverSettings.LogStream = &ss;\n             TKikimrRunner kikimr(serverSettings);\n \n@@ -42,8 +47,13 @@ Y_UNIT_TEST_SUITE(KqpDataIntegrityTrails) {\n             UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n         }\n \n-        // check executer logs\n-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY INFO: Component: Executer\"), LogEnabled ? 1 : 0);\n+        if (UseSink) {\n+            // check write actor logs\n+            UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY INFO: Component: WriteActor\"), LogEnabled ? 1 : 0);\n+        } else {\n+            // check executer logs\n+            UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY INFO: Component: Executer\"), LogEnabled ? 2 : 0);\n+        }\n         // check session actor logs\n         UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY DEBUG: Component: SessionActor\"), LogEnabled ? 2 : 0);\n         // check grpc logs\n@@ -52,49 +62,13 @@ Y_UNIT_TEST_SUITE(KqpDataIntegrityTrails) {\n         UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY INFO: Component: DataShard\"), LogEnabled ? 2 : 0);\n     }\n \n-    Y_UNIT_TEST(UpsertEvWrite) {\n+    Y_UNIT_TEST_QUAD(UpsertEvWriteQueryService, isOlap, useOltpSink) {\n         TStringStream ss;\n         {\n             NKikimrConfig::TAppConfig AppConfig;\n-            AppConfig.MutableTableServiceConfig()->SetEnableOltpSink(true);\n-            TKikimrSettings serverSettings = TKikimrSettings().SetAppConfig(AppConfig);\n-            serverSettings.LogStream = &ss;\n-            TKikimrRunner kikimr(serverSettings);\n-            kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::DATA_INTEGRITY, NLog::PRI_TRACE);\n-            \n-            auto db = kikimr.GetTableClient();\n-            auto session = db.CreateSession().GetValueSync().GetSession();\n-\n-            auto result = session.ExecuteDataQuery(R\"(\n-                --!syntax_v1\n-\n-                UPSERT INTO `/Root/KeyValue` (Key, Value) VALUES\n-                    (3u, \"Value3\"),\n-                    (101u, \"Value101\"),\n-                    (201u, \"Value201\");\n-            )\", TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n-            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n-        }\n+            AppConfig.MutableTableServiceConfig()->SetEnableOltpSink(useOltpSink);\n+            AppConfig.MutableTableServiceConfig()->SetEnableOlapSink(isOlap);\n \n-        // check write actor logs\n-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY INFO: Component: WriteActor\"), 1);\n-        // check session actor logs\n-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY DEBUG: Component: SessionActor\"), 2);\n-        // check grpc logs\n-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY TRACE: Component: Grpc\"), 2);\n-        // check datashard logs\n-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY INFO: Component: DataShard\"), 2);\n-    }\n-\n-    Y_UNIT_TEST_TWIN(UpsertEvWriteQueryService, isOlap) {\n-        TStringStream ss;\n-        {\n-            NKikimrConfig::TAppConfig AppConfig;\n-            if (!isOlap) {\n-                AppConfig.MutableTableServiceConfig()->SetEnableOltpSink(true);\n-            } else {\n-                AppConfig.MutableTableServiceConfig()->SetEnableOlapSink(true);\n-            }\n             TKikimrSettings serverSettings = TKikimrSettings().SetAppConfig(AppConfig);\n             serverSettings.LogStream = &ss;\n             TKikimrRunner kikimr(serverSettings);\n@@ -130,8 +104,13 @@ Y_UNIT_TEST_SUITE(KqpDataIntegrityTrails) {\n         }\n \n         if (!isOlap) {\n-            // check write actor logs\n-            UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY INFO: Component: WriteActor\"), 1);\n+            if (useOltpSink) {\n+                // check write actor logs\n+                UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY INFO: Component: WriteActor\"), 1);\n+            } else {\n+                // check executer logs\n+                UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY INFO: Component: Executer\"), 2);\n+            }\n             // check session actor logs\n             UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY DEBUG: Component: SessionActor\"), 2);\n             // check grpc logs\n@@ -141,8 +120,13 @@ Y_UNIT_TEST_SUITE(KqpDataIntegrityTrails) {\n         } else {\n             // check write actor logs\n             UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY INFO: Component: WriteActor\"), 3);\n-            // check executer logs\n-            UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY INFO: Component: Executer\"), 4);\n+            if (useOltpSink) {\n+                // check executer logs\n+                UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY INFO: Component: Executer\"), 1);\n+            } else {\n+                // check executer logs\n+                UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY INFO: Component: Executer\"), 11);\n+            }\n             // check session actor logs\n             UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY DEBUG: Component: SessionActor\"), 2);\n             // check grpc logs\n@@ -203,8 +187,8 @@ Y_UNIT_TEST_SUITE(KqpDataIntegrityTrails) {\n             UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n         }\n \n-        // check executer logs (should be empty, because executer only logs modification operations)\n-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY INFO: Component: Executer\"), 0);\n+        // check executer logs (should be 1, because executer only logs result for read actor)\n+        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY INFO: Component: Executer\"), 1);\n         // check session actor logs\n         UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY DEBUG: Component: SessionActor\"), 2);\n         // check grpc logs\n@@ -213,45 +197,146 @@ Y_UNIT_TEST_SUITE(KqpDataIntegrityTrails) {\n         UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY INFO: Component: DataShard\"), 0);\n     }\n \n-    Y_UNIT_TEST_TWIN(UpsertViaLegacyScripting, Streaming) {\n+    Y_UNIT_TEST_TWIN(BrokenReadLock, UseSink) {\n         TStringStream ss;\n         {\n+            NKikimrConfig::TAppConfig AppConfig;\n+            AppConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n             TKikimrSettings serverSettings;\n+            serverSettings.SetAppConfig(AppConfig);\n             serverSettings.LogStream = &ss;\n             TKikimrRunner kikimr(serverSettings);\n             kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::DATA_INTEGRITY, NLog::PRI_TRACE);\n-            NYdb::NScripting::TScriptingClient client(kikimr.GetDriver());\n+            auto db = kikimr.GetTableClient();\n+            auto session = db.CreateSession().GetValueSync().GetSession();\n \n+            std::optional<TTransaction> tx1;\n \n-            const auto query = R\"(\n-                --!syntax_v1\n+            {  // tx1: read\n+                auto result = session.ExecuteDataQuery(R\"(\n+                    --!syntax_v1\n \n-                UPSERT INTO `/Root/KeyValue` (Key, Value) VALUES\n-                    (3u, \"Value3\"),\n-                    (101u, \"Value101\"),\n-                    (201u, \"Value201\");\n-            )\";\n+                    SELECT * FROM `/Root/KeyValue` WHERE Key = 1u OR Key = 2u;\n+                )\", TTxControl::BeginTx()).ExtractValueSync();\n+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+                CompareYson(R\"([\n+                    [[1u];[\"One\"]];\n+                    [[2u];[\"Two\"]]\n+                ])\", FormatResultSetYson(result.GetResultSet(0)));\n+                tx1 = result.GetTransaction();\n+                UNIT_ASSERT(tx1);\n+            }\n \n-            if (Streaming) {\n-                auto result = client.StreamExecuteYqlScript(query).GetValueSync();        \n+            {  // tx2: write + commit\n+                auto result = session.ExecuteDataQuery(R\"(\n+                    --!syntax_v1\n+\n+                    UPSERT INTO `/Root/KeyValue` (Key, Value) VALUES\n+                        (1u, \"NewValue1\");\n+                )\", TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n                 UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n-                CollectStreamResult(result);\n-            } else {\n-                auto result = client.ExecuteYqlScript(query).GetValueSync();        \n+            }\n+\n+            {  // tx1: commit\n+                auto result = tx1->Commit().ExtractValueSync();\n                 UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n             }\n         }\n-            \n-        // check executer logs\n-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY INFO: Component: Executer\"), 1);\n-        // check session actor logs (should contain double logs because this query was executed via worker actor)\n-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY DEBUG: Component: SessionActor\"), 4);\n-        // check grpc logs\n-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY TRACE: Component: Grpc\"), 2);\n-        // check datashard logs\n-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), \"DATA_INTEGRITY INFO: Component: DataShard\"), 2);\n \n-        Cout << ss.Str() << Endl;\n+        auto logRows = SplitString(ss.Str(), \"DATA_INTEGRITY\");\n+        std::string readLock;\n+        std::string brokenLock;\n+        for (const auto& row : logRows) {\n+            // we need to find row with info about read physical tx and extract lock id\n+            if (row.Contains(\"Component: Executer,Type: InputActorResult\")) {\n+                std::regex lockIdRegex(R\"(LockId:\\s*(\\d+))\");\n+                std::smatch lockIdMatch;\n+                UNIT_ASSERT_C(std::regex_search(row.data(), lockIdMatch, lockIdRegex) || lockIdMatch.size() != 2, \"failed to extract read lock id\");\n+                readLock = lockIdMatch[1].str();\n+            }\n+\n+            // we need to find row with info about broken locks and extract lock id\n+            if (row.Contains(\"Component: DataShard,Type: Locks\")) {\n+                std::regex lockIdRegex(R\"(BreakLocks:\\s*\\[(\\d+)\\s*\\])\");\n+                std::smatch lockIdMatch;\n+                UNIT_ASSERT_C(std::regex_search(row.data(), lockIdMatch, lockIdRegex) || lockIdMatch.size() != 2, \"failed to extract broken lock id\");\n+                brokenLock = lockIdMatch[1].str();\n+            } \n+        }\n+\n+        UNIT_ASSERT_C(!readLock.empty() && readLock == brokenLock, \"read lock should be broken\");\n+    }\n+\n+    Y_UNIT_TEST(BrokenReadLockAbortedTx) {\n+        TStringStream ss;\n+        {\n+            TKikimrSettings serverSettings;\n+            serverSettings.LogStream = &ss;\n+            TKikimrRunner kikimr(serverSettings);\n+            kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::DATA_INTEGRITY, NLog::PRI_TRACE);\n+            auto db = kikimr.GetTableClient();\n+            auto session = db.CreateSession().GetValueSync().GetSession();\n+\n+            std::optional<TTransaction> tx1;\n+\n+            {  // tx1: read\n+                auto result = session.ExecuteDataQuery(R\"(\n+                    --!syntax_v1\n+\n+                    SELECT * FROM `/Root/KeyValue` WHERE Key = 1u OR Key = 2u;\n+                )\", TTxControl::BeginTx()).ExtractValueSync();\n+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+                CompareYson(R\"([\n+                    [[1u];[\"One\"]];\n+                    [[2u];[\"Two\"]]\n+                ])\", FormatResultSetYson(result.GetResultSet(0)));\n+                tx1 = result.GetTransaction();\n+                UNIT_ASSERT(tx1);\n+            }\n+\n+            {  // tx2: write + commit\n+                auto result = session.ExecuteDataQuery(R\"(\n+                    --!syntax_v1\n+\n+                    UPSERT INTO `/Root/KeyValue` (Key, Value) VALUES\n+                        (1u, \"NewValue1\");\n+                )\", TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            }\n+\n+            {  // tx1: write + commit\n+                auto result = session.ExecuteDataQuery(R\"(\n+                    --!syntax_v1\n+\n+                    UPSERT INTO `/Root/KeyValue` (Key, Value) VALUES\n+                        (1000u, \"Value1000\");\n+                )\", TTxControl::Tx(*tx1).CommitTx()).ExtractValueSync();\n+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::ABORTED, result.GetIssues().ToString());\n+            }\n+        }\n+\n+        auto logRows = SplitString(ss.Str(), \"DATA_INTEGRITY\");\n+        std::string readLock;\n+        std::string brokenLock;\n+        for (const auto& row : logRows) {\n+            // we need to find row with info about read physical tx and extract lock id\n+            if (row.Contains(\"Component: Executer,Type: InputActorResult\")) {\n+                std::regex lockIdRegex(R\"(LockId:\\s*(\\d+))\");\n+                std::smatch lockIdMatch;\n+                UNIT_ASSERT_C(std::regex_search(row.data(), lockIdMatch, lockIdRegex) || lockIdMatch.size() != 2, \"failed to extract read lock id\");\n+                readLock = lockIdMatch[1].str();\n+            }\n+\n+            // we need to find row with info about broken locks and extract lock id\n+            if (row.Contains(\"Component: DataShard,Type: Locks\")) {\n+                std::regex lockIdRegex(R\"(BreakLocks:\\s*\\[(\\d+)\\s*\\])\");\n+                std::smatch lockIdMatch;\n+                UNIT_ASSERT_C(std::regex_search(row.data(), lockIdMatch, lockIdRegex) || lockIdMatch.size() != 2, \"failed to extract broken lock id\");\n+                brokenLock = lockIdMatch[1].str();\n+            } \n+        }\n+\n+        UNIT_ASSERT_C(!readLock.empty() && readLock == brokenLock, \"read lock should be broken\");\n     }\n }\n \ndiff --git a/ydb/core/kqp/ut/effects/kqp_effects_ut.cpp b/ydb/core/kqp/ut/effects/kqp_effects_ut.cpp\nindex 6474a18b0bf2..244743575bfb 100644\n--- a/ydb/core/kqp/ut/effects/kqp_effects_ut.cpp\n+++ b/ydb/core/kqp/ut/effects/kqp_effects_ut.cpp\n@@ -31,8 +31,10 @@ Y_UNIT_TEST_SUITE(KqpEffects) {\n         ])\", FormatResultSetYson(result.GetResultSet(0)));\n     }\n \n-    Y_UNIT_TEST(InsertAbort_Literal_Duplicates) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_TWIN(InsertAbort_Literal_Duplicates, UseSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, appConfig);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n \n@@ -41,8 +43,8 @@ Y_UNIT_TEST_SUITE(KqpEffects) {\n                 (\"foo\", 10u), (\"bar\", 11u), (\"baz\", 10u)\n         )\", TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());\n-        UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, [](const auto& issue) {\n-            return issue.GetMessage().contains(\"Duplicated keys found.\");\n+        UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, [&](const auto& issue) {\n+            return issue.GetMessage().contains(UseSink ? \"Duplicate keys have been found.\" : \"Duplicated keys found.\");\n         }));\n \n         result = session.ExecuteDataQuery(R\"(\n@@ -53,8 +55,10 @@ Y_UNIT_TEST_SUITE(KqpEffects) {\n         CompareYson(R\"([])\", FormatResultSetYson(result.GetResultSet(0)));\n     }\n \n-    Y_UNIT_TEST(InsertAbort_Literal_Conflict) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_TWIN(InsertAbort_Literal_Conflict, UseSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, appConfig);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n \n@@ -64,7 +68,7 @@ Y_UNIT_TEST_SUITE(KqpEffects) {\n         )\", TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());\n         UNIT_ASSERT_C(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, [](const auto& issue) {\n-            return issue.GetMessage().contains(\"Conflict with existing key.\");\n+            return issue.GetMessage().contains(UseSink ? \"Duplicate keys have been found.\" : \"Conflict with existing key.\");\n         }), result.GetIssues().ToString());\n \n         result = session.ExecuteDataQuery(R\"(\n@@ -114,8 +118,10 @@ Y_UNIT_TEST_SUITE(KqpEffects) {\n         ])\", FormatResultSetYson(result.GetResultSet(0)));\n     }\n \n-    Y_UNIT_TEST(InsertAbort_Params_Duplicates) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_TWIN(InsertAbort_Params_Duplicates, UseSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, appConfig);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n \n@@ -145,7 +151,7 @@ Y_UNIT_TEST_SUITE(KqpEffects) {\n         )\", TTxControl::BeginTx().CommitTx(), std::move(params)).ExtractValueSync();\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());\n         UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, [](const auto& issue) {\n-            return issue.GetMessage().contains(\"Duplicated keys found.\");\n+            return issue.GetMessage().contains(UseSink ? \"Duplicate keys have been found.\" : \"Duplicated keys found.\");\n         }));\n \n         result = session.ExecuteDataQuery(R\"(\n@@ -158,8 +164,10 @@ Y_UNIT_TEST_SUITE(KqpEffects) {\n         ])\", FormatResultSetYson(result.GetResultSet(0)));\n     }\n \n-    Y_UNIT_TEST(InsertAbort_Params_Conflict) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_TWIN(InsertAbort_Params_Conflict, UseSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, appConfig);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n \n@@ -184,7 +192,7 @@ Y_UNIT_TEST_SUITE(KqpEffects) {\n         )\", TTxControl::BeginTx().CommitTx(), std::move(params)).ExtractValueSync();\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());\n         UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, [](const auto& issue) {\n-            return issue.GetMessage().contains(\"Conflict with existing key.\");\n+            return issue.GetMessage().contains(UseSink ? \"Duplicate keys have been found.\" : \"Conflict with existing key.\");\n         }));\n \n         result = session.ExecuteDataQuery(R\"(\n@@ -234,8 +242,10 @@ Y_UNIT_TEST_SUITE(KqpEffects) {\n         ])\", FormatResultSetYson(result.GetResultSet(0)));\n     }\n \n-    Y_UNIT_TEST(InsertAbort_Select_Duplicates) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_TWIN(InsertAbort_Select_Duplicates, UseSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, appConfig);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n \n@@ -261,7 +271,7 @@ Y_UNIT_TEST_SUITE(KqpEffects) {\n         )\", TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());\n         UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, [](const auto& issue) {\n-            return issue.GetMessage().contains(\"Duplicated keys found.\");\n+            return issue.GetMessage().contains(UseSink ? \"Duplicate keys have been found.\" : \"Duplicated keys found.\");\n         }));\n \n         result = session.ExecuteDataQuery(R\"(\n@@ -274,8 +284,10 @@ Y_UNIT_TEST_SUITE(KqpEffects) {\n         ])\", FormatResultSetYson(result.GetResultSet(0)));\n     }\n \n-    Y_UNIT_TEST(InsertAbort_Select_Conflict) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_TWIN(InsertAbort_Select_Conflict, UseSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, appConfig);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n \n@@ -300,7 +312,7 @@ Y_UNIT_TEST_SUITE(KqpEffects) {\n         )\", TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());\n         UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, [](const auto& issue) {\n-            return issue.GetMessage().contains(\"Conflict with existing key.\");\n+            return issue.GetMessage().contains(UseSink ? \"Duplicate keys have been found.\" : \"Conflict with existing key.\");\n         }));\n \n         result = session.ExecuteDataQuery(R\"(\ndiff --git a/ydb/core/kqp/ut/effects/kqp_immediate_effects_ut.cpp b/ydb/core/kqp/ut/effects/kqp_immediate_effects_ut.cpp\nindex 94ef94ccab1a..0e5e78cacfd0 100644\n--- a/ydb/core/kqp/ut/effects/kqp_immediate_effects_ut.cpp\n+++ b/ydb/core/kqp/ut/effects/kqp_immediate_effects_ut.cpp\n@@ -382,8 +382,9 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {\n         }\n     }\n \n-    Y_UNIT_TEST(InsertDuplicates) {\n+    Y_UNIT_TEST_TWIN(InsertDuplicates, UseSink) {\n         NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         auto serverSettings = TKikimrSettings().SetAppConfig(appConfig);\n         TKikimrRunner kikimr(serverSettings);\n         auto db = kikimr.GetTableClient();\n@@ -404,13 +405,14 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {\n             )\", TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n             UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());\n             UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, [](const auto& issue) {\n-                return issue.GetMessage().contains(\"Duplicated keys found.\");\n+                return issue.GetMessage().contains(UseSink ? \"Duplicate keys have been found.\" : \"Duplicated keys found.\");\n             }));\n         }\n     }\n \n-    Y_UNIT_TEST(InsertExistingKey) {\n+    Y_UNIT_TEST_TWIN(InsertExistingKey, UseSink) {\n         NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         auto serverSettings = TKikimrSettings().SetAppConfig(appConfig);\n         TKikimrRunner kikimr(serverSettings);\n         auto db = kikimr.GetTableClient();\n@@ -430,7 +432,7 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {\n             )\", TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n             UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());\n             UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, [](const auto& issue) {\n-                return issue.GetMessage().contains(\"Conflict with existing key.\");\n+                return issue.GetMessage().contains(UseSink ? \"Duplicate keys have been found.\" : \"Conflict with existing key.\");\n             }));\n         }\n     }\n@@ -1015,8 +1017,9 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {\n         }\n     }\n \n-    Y_UNIT_TEST(TxWithReadAtTheEnd) {\n+    Y_UNIT_TEST_TWIN(TxWithReadAtTheEnd, UseSink) {\n         NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         auto serverSettings = TKikimrSettings().SetAppConfig(appConfig);\n         TKikimrRunner kikimr(serverSettings);\n         auto db = kikimr.GetTableClient();\n@@ -1058,8 +1061,9 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {\n         UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(stats.query_phases().size() - 1).table_access().size(), 0);\n     }\n \n-    Y_UNIT_TEST(InteractiveTxWithReadAtTheEnd) {\n+    Y_UNIT_TEST_TWIN(InteractiveTxWithReadAtTheEnd, UseSink) {\n         NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         auto serverSettings = TKikimrSettings().SetAppConfig(appConfig);\n         TKikimrRunner kikimr(serverSettings);\n         auto db = kikimr.GetTableClient();\n@@ -1115,13 +1119,15 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {\n             ])\", FormatResultSetYson(result.GetResultSet(0)));\n \n             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 4 : 5);\n             // check that last (commit) phase is empty\n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(stats.query_phases().size() - 1).table_access().size(), 0);\n         }\n     }\n \n-    Y_UNIT_TEST(TxWithWriteAtTheEnd) {\n+    Y_UNIT_TEST_TWIN(TxWithWriteAtTheEnd, UseSink) {\n         NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         auto serverSettings = TKikimrSettings().SetAppConfig(appConfig);\n         TKikimrRunner kikimr(serverSettings);\n         auto db = kikimr.GetTableClient();\n@@ -2075,8 +2081,9 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {\n         }\n     }\n \n-    Y_UNIT_TEST(ForceImmediateEffectsExecution) {\n+    Y_UNIT_TEST_TWIN(ForceImmediateEffectsExecution, UseSink) {\n         NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         auto serverSettings = TKikimrSettings().SetAppConfig(appConfig).SetEnableForceImmediateEffectsExecution(true);\n         TKikimrRunner kikimr(serverSettings);\n         auto db = kikimr.GetTableClient();\n@@ -2101,12 +2108,14 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {\n \n             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n             // compute phase + effect phase\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);\n \n-            const auto& literalPhase = stats.query_phases(0);\n-            const auto& effectPhase = stats.query_phases(1);\n+            if (!UseSink) {\n+                const auto& literalPhase = stats.query_phases(0);\n+                UNIT_ASSERT_VALUES_EQUAL(literalPhase.table_access().size(), 0);\n+            }\n \n-            UNIT_ASSERT_VALUES_EQUAL(literalPhase.table_access().size(), 0);\n+            const auto& effectPhase = stats.query_phases(UseSink ? 0 : 1);\n             UNIT_ASSERT_VALUES_EQUAL(effectPhase.table_access().size(), 1);\n             UNIT_ASSERT_VALUES_EQUAL(effectPhase.table_access(0).name(), \"/Root/TestImmediateEffects\");\n             UNIT_ASSERT_VALUES_EQUAL(effectPhase.table_access(0).updates().rows(), 1);\n@@ -2122,12 +2131,14 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {\n \n             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n             // compute phase + effect phase\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);\n \n-            const auto& literalPhase = stats.query_phases(0);\n-            const auto& effectPhase = stats.query_phases(1);\n+            if (!UseSink) {\n+                const auto& literalPhase = stats.query_phases(0);\n+                UNIT_ASSERT_VALUES_EQUAL(literalPhase.table_access().size(), 0);\n+            }\n \n-            UNIT_ASSERT_VALUES_EQUAL(literalPhase.table_access().size(), 0);\n+            const auto& effectPhase = stats.query_phases(UseSink ? 0 : 1);\n             UNIT_ASSERT_VALUES_EQUAL(effectPhase.table_access().size(), 1);\n             UNIT_ASSERT_VALUES_EQUAL(effectPhase.table_access(0).name(), \"/Root/TestImmediateEffects\");\n             UNIT_ASSERT_VALUES_EQUAL(effectPhase.table_access(0).deletes().rows(), 1);\n@@ -2227,6 +2238,160 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {\n         }\n     }\n \n+    Y_UNIT_TEST(ManyFlushes) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        auto serverSettings = TKikimrSettings().SetAppConfig(appConfig);\n+        TKikimrRunner kikimr(serverSettings);\n+        auto db = kikimr.GetTableClient();\n+        auto session = db.CreateSession().GetValueSync().GetSession();\n+\n+        CreateTestTable(session);\n+\n+        {\n+            auto result = session.ExecuteDataQuery(R\"(\n+                --!syntax_v1\n+\n+                SELECT * FROM TestImmediateEffects;\n+                UPSERT INTO TestImmediateEffects (Key, Value) VALUES\n+                    (3u, \"Three\"),\n+                    (4u, \"Four\");\n+\n+                SELECT * FROM TestImmediateEffects;\n+            )\", TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([\n+                [[1u];[\"One\"]];\n+                [[2u];[\"Two\"]]\n+            ])\", FormatResultSetYson(result.GetResultSet(0)));\n+            CompareYson(R\"([\n+                [[1u];[\"One\"]];\n+                [[2u];[\"Two\"]];\n+                [[3u];[\"Three\"]];\n+                [[4u];[\"Four\"]]\n+            ])\", FormatResultSetYson(result.GetResultSet(1)));\n+        }\n+\n+        {  // multiple effects\n+            auto result = session.ExecuteDataQuery(R\"(\n+                --!syntax_v1\n+\n+                UPSERT INTO TestImmediateEffects (Key, Value) VALUES (5u, \"Five\");\n+                SELECT * FROM TestImmediateEffects;\n+                UPSERT INTO TestImmediateEffects (Key, Value) VALUES (6u, \"Six\");\n+                SELECT * FROM TestImmediateEffects;\n+                UPSERT INTO TestImmediateEffects (Key, Value) VALUES (7u, \"Seven\");\n+                SELECT * FROM TestImmediateEffects;\n+            )\", TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([\n+                [[1u];[\"One\"]];\n+                [[2u];[\"Two\"]];\n+                [[3u];[\"Three\"]];\n+                [[4u];[\"Four\"]];\n+                [[5u];[\"Five\"]]\n+            ])\", FormatResultSetYson(result.GetResultSet(0)));\n+            CompareYson(R\"([\n+                [[1u];[\"One\"]];\n+                [[2u];[\"Two\"]];\n+                [[3u];[\"Three\"]];\n+                [[4u];[\"Four\"]];\n+                [[5u];[\"Five\"]];\n+                [[6u];[\"Six\"]]\n+            ])\", FormatResultSetYson(result.GetResultSet(1)));\n+            CompareYson(R\"([\n+                [[1u];[\"One\"]];\n+                [[2u];[\"Two\"]];\n+                [[3u];[\"Three\"]];\n+                [[4u];[\"Four\"]];\n+                [[5u];[\"Five\"]];\n+                [[6u];[\"Six\"]];\n+                [[7u];[\"Seven\"]]\n+            ])\", FormatResultSetYson(result.GetResultSet(2)));\n+        }\n+    }\n+\n+     Y_UNIT_TEST(Interactive) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        auto serverSettings = TKikimrSettings().SetAppConfig(appConfig);\n+        TKikimrRunner kikimr(serverSettings);\n+        auto db = kikimr.GetTableClient();\n+        auto session = db.CreateSession().GetValueSync().GetSession();\n+\n+        CreateTestTable(session);\n+\n+        {\n+            auto result = session.ExecuteDataQuery(R\"(\n+                --!syntax_v1\n+\n+                SELECT * FROM TestImmediateEffects;\n+                UPSERT INTO TestImmediateEffects (Key, Value) VALUES\n+                    (3u, \"Three\"),\n+                    (4u, \"Four\");\n+\n+                SELECT * FROM TestImmediateEffects;\n+            )\", TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([\n+                [[1u];[\"One\"]];\n+                [[2u];[\"Two\"]]\n+            ])\", FormatResultSetYson(result.GetResultSet(0)));\n+            CompareYson(R\"([\n+                [[1u];[\"One\"]];\n+                [[2u];[\"Two\"]];\n+                [[3u];[\"Three\"]];\n+                [[4u];[\"Four\"]]\n+            ])\", FormatResultSetYson(result.GetResultSet(1)));\n+        }\n+\n+        {\n+            auto result = session.ExecuteDataQuery(R\"(\n+                --!syntax_v1\n+\n+                UPSERT INTO TestImmediateEffects (Key, Value) VALUES (5u, \"Five\");\n+            )\", TTxControl::BeginTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+            auto tx = result.GetTransaction();\n+\n+            result = session.ExecuteDataQuery(R\"(\n+                --!syntax_v1\n+\n+                SELECT * FROM TestImmediateEffects;\n+                UPSERT INTO TestImmediateEffects (Key, Value) VALUES (6u, \"Six\");\n+                SELECT * FROM TestImmediateEffects;\n+                UPSERT INTO TestImmediateEffects (Key, Value) VALUES (7u, \"Seven\");\n+                SELECT * FROM TestImmediateEffects;\n+            )\", TTxControl::Tx(*tx)).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+            CompareYson(R\"([\n+                [[1u];[\"One\"]];\n+                [[2u];[\"Two\"]];\n+                [[3u];[\"Three\"]];\n+                [[4u];[\"Four\"]];\n+                [[5u];[\"Five\"]]\n+            ])\", FormatResultSetYson(result.GetResultSet(0)));\n+            CompareYson(R\"([\n+                [[1u];[\"One\"]];\n+                [[2u];[\"Two\"]];\n+                [[3u];[\"Three\"]];\n+                [[4u];[\"Four\"]];\n+                [[5u];[\"Five\"]];\n+                [[6u];[\"Six\"]]\n+            ])\", FormatResultSetYson(result.GetResultSet(1)));\n+            CompareYson(R\"([\n+                [[1u];[\"One\"]];\n+                [[2u];[\"Two\"]];\n+                [[3u];[\"Three\"]];\n+                [[4u];[\"Four\"]];\n+                [[5u];[\"Five\"]];\n+                [[6u];[\"Six\"]];\n+                [[7u];[\"Seven\"]]\n+            ])\", FormatResultSetYson(result.GetResultSet(2)));\n+\n+            auto commitResult = tx->Commit().ExtractValueSync();\n+            UNIT_ASSERT(commitResult.IsSuccess());\n+        }\n+    }\n }\n \n } // namespace NKqp\ndiff --git a/ydb/core/kqp/ut/effects/kqp_inplace_update_ut.cpp b/ydb/core/kqp/ut/effects/kqp_inplace_update_ut.cpp\nindex 64130b3546f6..d8cced26c6e5 100644\n--- a/ydb/core/kqp/ut/effects/kqp_inplace_update_ut.cpp\n+++ b/ydb/core/kqp/ut/effects/kqp_inplace_update_ut.cpp\n@@ -61,7 +61,8 @@ void Test(\n     TParams&& params,\n     const TString& expectedResult,\n     std::function<void(const Ydb::TableStats::QueryStats&)>&& check,\n-    const std::function<void(TSession& session)>& prepareTable = &PrepareTable\n+    const std::function<void(TSession& session)>& prepareTable = &PrepareTable,\n+    std::optional<bool> useSink = std::nullopt\n ) {\n     auto setting = NKikimrKqp::TKqpSetting();\n     setting.SetName(\"_KqpAllowUnsafeCommit\");\n@@ -69,6 +70,9 @@ void Test(\n \n     // source read and stream lookup use iterator interface, that doesn't use datashard transactions\n     NKikimrConfig::TAppConfig appConfig;\n+    if (useSink) {\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(*useSink);\n+    }\n \n     auto settings = TKikimrSettings()\n         .SetAppConfig(appConfig)\n@@ -105,15 +109,18 @@ void Test(\n #define ASSERT_LITERAL_PHASE(stats, phaseNo) \\\n     UNIT_ASSERT_C(stats.query_phases(phaseNo).table_access().empty(), stats.DebugString());\n \n-#define ASSERT_PHASE(stats, phaseNo, table, readsCnt, updatesCnt) \\\n+#define ASSERT_PHASE_FULL(stats, phaseNo, table, readsCnt, updatesCnt, partitionsCnt) \\\n     UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases(phaseNo).table_access().size(), 1, stats.DebugString());                     \\\n     UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases(phaseNo).table_access(0).name(), table, stats.DebugString());                \\\n     UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases(phaseNo).table_access(0).reads().rows(), readsCnt, stats.DebugString());     \\\n     UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases(phaseNo).table_access(0).updates().rows(), updatesCnt, stats.DebugString()); \\\n-    UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases(phaseNo).table_access(0).partitions_count(), std::max(readsCnt, updatesCnt), stats.DebugString());\n+    UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases(phaseNo).table_access(0).partitions_count(), partitionsCnt, stats.DebugString());\n+\n+#define ASSERT_PHASE(stats, phaseNo, table, readsCnt, updatesCnt) \\\n+    ASSERT_PHASE_FULL(stats, phaseNo, table, readsCnt, updatesCnt, std::max(readsCnt, updatesCnt));\n \n \n-Y_UNIT_TEST(SingleRowSimple) {\n+Y_UNIT_TEST_TWIN(SingleRowSimple, UseSink) {\n     Test(\n         R\"( DECLARE $key AS Uint64;\n             DECLARE $value AS String;\n@@ -130,14 +137,21 @@ Y_UNIT_TEST(SingleRowSimple) {\n             [[1u];[\"updated\"];[100u];[101.]];\n             [[20u];[\"Two\"];[200u];[202.]]\n            ])\",\n-        [](const Ydb::TableStats::QueryStats& stats) {\n-            UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());\n-            ASSERT_PHASE(stats, 0, \"/Root/InplaceUpdate\", 1, 0);\n-            ASSERT_PHASE(stats, 1, \"/Root/InplaceUpdate\", 0, 1);\n-        });\n+        [&](const Ydb::TableStats::QueryStats& stats) {\n+            if (UseSink) {\n+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 1, stats.DebugString());\n+                ASSERT_PHASE_FULL(stats, 0, \"/Root/InplaceUpdate\", 1, 1, 2);\n+            } else {\n+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());\n+                ASSERT_PHASE(stats, 0, \"/Root/InplaceUpdate\", 1, 0);\n+                ASSERT_PHASE(stats, 1, \"/Root/InplaceUpdate\", 0, 1);\n+            }\n+        },\n+        &PrepareTable,\n+        UseSink);\n }\n \n-Y_UNIT_TEST(SingleRowStr) {\n+Y_UNIT_TEST_TWIN(SingleRowStr, UseSink) {\n     Test(\n         R\"( DECLARE $key AS Uint64;\n             DECLARE $value AS String;\n@@ -154,14 +168,21 @@ Y_UNIT_TEST(SingleRowStr) {\n             [[1u];[\"neupdated\"];[100u];[101.]];\n             [[20u];[\"Two\"];[200u];[202.]]\n            ])\",\n-        [](const Ydb::TableStats::QueryStats& stats) {\n-            UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());\n-            ASSERT_PHASE(stats, 0, \"/Root/InplaceUpdate\", 1, 0);\n-            ASSERT_PHASE(stats, 1, \"/Root/InplaceUpdate\", 0, 1);\n-        });\n+        [&](const Ydb::TableStats::QueryStats& stats) {\n+            if (UseSink) {\n+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 1, stats.DebugString());\n+                ASSERT_PHASE_FULL(stats, 0, \"/Root/InplaceUpdate\", 1, 1, 2);\n+            } else {\n+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());\n+                ASSERT_PHASE(stats, 0, \"/Root/InplaceUpdate\", 1, 0);\n+                ASSERT_PHASE(stats, 1, \"/Root/InplaceUpdate\", 0, 1);\n+            }\n+        },\n+        &PrepareTable,\n+        UseSink);\n }\n \n-Y_UNIT_TEST(SingleRowArithm) {\n+Y_UNIT_TEST_TWIN(SingleRowArithm, UseSink) {\n     Test(\n         R\"( DECLARE $key AS Uint64;\n             DECLARE $x AS Uint64;\n@@ -181,14 +202,21 @@ Y_UNIT_TEST(SingleRowArithm) {\n             [[1u];[\"One\"];[1210u];[16.]];\n             [[20u];[\"Two\"];[200u];[202.]]\n            ])\",\n-        [](const Ydb::TableStats::QueryStats& stats) {\n-            UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());\n-            ASSERT_PHASE(stats, 0, \"/Root/InplaceUpdate\", 1, 0);\n-            ASSERT_PHASE(stats, 1, \"/Root/InplaceUpdate\", 0, 1);\n-        });\n+        [&](const Ydb::TableStats::QueryStats& stats) {\n+            if (UseSink) {\n+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 1, stats.DebugString());\n+                ASSERT_PHASE_FULL(stats, 0, \"/Root/InplaceUpdate\", 1, 1, 2);\n+            } else {\n+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());\n+                ASSERT_PHASE(stats, 0, \"/Root/InplaceUpdate\", 1, 0);\n+                ASSERT_PHASE(stats, 1, \"/Root/InplaceUpdate\", 0, 1);\n+            }\n+        },\n+        &PrepareTable,\n+        UseSink);\n }\n \n-Y_UNIT_TEST(SingleRowIf) {\n+Y_UNIT_TEST_TWIN(SingleRowIf, UseSink) {\n     Test(\n         R\"( DECLARE $key AS Uint64;\n \n@@ -212,15 +240,22 @@ Y_UNIT_TEST(SingleRowIf) {\n             [[1u];[\"One\"];[11u];[1.]];\n             [[20u];[\"Two\"];[200u];[202.]]\n            ])\",\n-        [](const Ydb::TableStats::QueryStats& stats) {\n-            UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());\n-            ASSERT_PHASE(stats, 0, \"/Root/InplaceUpdate\", 1, 0);\n-            ASSERT_PHASE(stats, 1, \"/Root/InplaceUpdate\", 0, 1);\n-        });\n+        [&](const Ydb::TableStats::QueryStats& stats) {\n+            if (UseSink) {\n+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 1, stats.DebugString());\n+                ASSERT_PHASE_FULL(stats, 0, \"/Root/InplaceUpdate\", 1, 1, 2);\n+            } else {\n+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());\n+                ASSERT_PHASE(stats, 0, \"/Root/InplaceUpdate\", 1, 0);\n+                ASSERT_PHASE(stats, 1, \"/Root/InplaceUpdate\", 0, 1);\n+            }\n+        },\n+        &PrepareTable,\n+        UseSink);\n }\n \n // allow multiple keys in KqpLookupTable to enable this test\n-Y_UNIT_TEST(Negative_SingleRowWithKeyCast) {\n+Y_UNIT_TEST_TWIN(Negative_SingleRowWithKeyCast, UseSink) {\n     Test(\n         R\"( DECLARE $key AS Uint32; -- not Uint64\n             DECLARE $value AS String;\n@@ -237,21 +272,29 @@ Y_UNIT_TEST(Negative_SingleRowWithKeyCast) {\n             [[1u];[\"updated\"];[100u];[101.]];\n             [[20u];[\"Two\"];[200u];[202.]]\n            ])\",\n-        [](const Ydb::TableStats::QueryStats& stats) {\n+        [&](const Ydb::TableStats::QueryStats& stats) {\n             // if constexpr (EnableInplaceUpdate) {\n             //     UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());\n             //     ASSERT_LITERAL_PHASE(stats, 0);\n             //     ASSERT_PHASE(stats, 1, \"/Root/InplaceUpdate\", 1, 1);\n             // } else {\n+            if (UseSink) {\n+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());\n+                ASSERT_LITERAL_PHASE(stats, 0);\n+                ASSERT_PHASE_FULL(stats, 1, \"/Root/InplaceUpdate\", 1, 1, 2);\n+            } else {\n                 UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 3, stats.DebugString());\n                 ASSERT_LITERAL_PHASE(stats, 0);\n                 ASSERT_PHASE(stats, 1, \"/Root/InplaceUpdate\", 1, 0);\n                 ASSERT_PHASE(stats, 2, \"/Root/InplaceUpdate\", 0, 1);\n+            }\n             // }\n-        });\n+        },\n+        &PrepareTable,\n+        UseSink);\n }\n \n-Y_UNIT_TEST(Negative_SingleRowWithValueCast) {\n+Y_UNIT_TEST_TWIN(Negative_SingleRowWithValueCast, UseSink) {\n /*\n     (\n     (declare $key (DataType 'Uint64))\n@@ -280,14 +323,21 @@ Y_UNIT_TEST(Negative_SingleRowWithValueCast) {\n             [[1u];[\"One\"];[1u];[101.]];\n             [[20u];[\"Two\"];[200u];[202.]]\n            ])\",\n-        [](const Ydb::TableStats::QueryStats& stats) {\n-            UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());\n-            ASSERT_PHASE(stats, 0, \"/Root/InplaceUpdate\", 1, 0);\n-            ASSERT_PHASE(stats, 1, \"/Root/InplaceUpdate\", 0, 1);\n-        });\n+        [&](const Ydb::TableStats::QueryStats& stats) {\n+            if (UseSink) {\n+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 1, stats.DebugString());\n+                ASSERT_PHASE_FULL(stats, 0, \"/Root/InplaceUpdate\", 1, 1, 2);\n+            } else {\n+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());\n+                ASSERT_PHASE(stats, 0, \"/Root/InplaceUpdate\", 1, 0);\n+                ASSERT_PHASE(stats, 1, \"/Root/InplaceUpdate\", 0, 1);\n+            }\n+        },\n+        &PrepareTable,\n+        UseSink);\n }\n \n-Y_UNIT_TEST(Negative_SingleRowListFromRange) {\n+Y_UNIT_TEST_TWIN(Negative_SingleRowListFromRange, UseSink) {\n     Test(\n         R\"( DECLARE $key AS Uint64;\n \n@@ -307,15 +357,22 @@ Y_UNIT_TEST(Negative_SingleRowListFromRange) {\n             [[1u];[\"One1..2..3..4..5..6..7..8..9\"];[100u];[101.]];\n             [[20u];[\"Two\"];[200u];[202.]]\n            ])\",\n-        [](const Ydb::TableStats::QueryStats& stats) {\n-            UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());\n-            ASSERT_PHASE(stats, 0, \"/Root/InplaceUpdate\", 1, 0);\n-            ASSERT_PHASE(stats, 1, \"/Root/InplaceUpdate\", 0, 1);\n-        });\n+        [&](const Ydb::TableStats::QueryStats& stats) {\n+            if (UseSink) {\n+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 1, stats.DebugString());\n+                ASSERT_PHASE_FULL(stats, 0, \"/Root/InplaceUpdate\", 1, 1, 2);\n+            } else {\n+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());\n+                ASSERT_PHASE(stats, 0, \"/Root/InplaceUpdate\", 1, 0);\n+                ASSERT_PHASE(stats, 1, \"/Root/InplaceUpdate\", 0, 1);\n+            }\n+        },\n+        &PrepareTable,\n+        UseSink);\n }\n \n // allow multiple keys in KqpLookupTable to enable this test\n-Y_UNIT_TEST(Negative_BatchUpdate) {\n+Y_UNIT_TEST_TWIN(Negative_BatchUpdate, UseSink) {\n     Test(\n         R\"( DECLARE $key1 AS Uint64;\n             DECLARE $value1 AS String;\n@@ -343,19 +400,27 @@ Y_UNIT_TEST(Negative_BatchUpdate) {\n             [[1u];[\"updated-1\"];[100u];[101.]];\n             [[20u];[\"updated-2\"];[200u];[202.]]\n         ])\",\n-        [](const Ydb::TableStats::QueryStats& stats) {\n+        [&](const Ydb::TableStats::QueryStats& stats) {\n             // if constexpr (EnableInplaceUpdate) {\n             //     UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 3, stats.DebugString());\n             //     ASSERT_LITERAL_PHASE(stats, 0);\n             //     ASSERT_LITERAL_PHASE(stats, 1);\n             //     ASSERT_PHASE(stats, 2, \"/Root/InplaceUpdate\", 2, 2);\n             // } else {\n+            if (UseSink) {\n+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());\n+                ASSERT_LITERAL_PHASE(stats, 0);\n+                ASSERT_PHASE_FULL(stats, 1, \"/Root/InplaceUpdate\", 2, 2, 4);\n+            } else {\n                 UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 3, stats.DebugString());\n                 ASSERT_LITERAL_PHASE(stats, 0);\n                 ASSERT_PHASE(stats, 1, \"/Root/InplaceUpdate\", 2, 0);\n                 ASSERT_PHASE(stats, 2, \"/Root/InplaceUpdate\", 0, 2);\n+            }\n             // }\n-        });\n+        },\n+        &PrepareTable,\n+        UseSink);\n }\n \n Y_UNIT_TEST(BigRow) {\n@@ -421,7 +486,7 @@ Y_UNIT_TEST(BigRow) {\n     ])\", FormatResultSetYson(result.GetResultSet(0)));\n }\n \n-Y_UNIT_TEST(SingleRowPgNotNull) {\n+Y_UNIT_TEST_TWIN(SingleRowPgNotNull, UseSink) {\n     Test(\n         R\"( DECLARE $key AS Uint64;\n             DECLARE $value AS PgInt2;\n@@ -438,12 +503,18 @@ Y_UNIT_TEST(SingleRowPgNotNull) {\n             [[1u];[\"One\"];\"123\";[101.]];\n             [[20u];[\"Two\"];\"200\";[202.]]\n            ])\",\n-        [](const Ydb::TableStats::QueryStats& stats) {\n-            UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());\n-            ASSERT_PHASE(stats, 0, \"/Root/InplaceUpdate\", 1, 0);\n-            ASSERT_PHASE(stats, 1, \"/Root/InplaceUpdate\", 0, 1);\n+        [&](const Ydb::TableStats::QueryStats& stats) {\n+            if (UseSink) {\n+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 1, stats.DebugString());\n+                ASSERT_PHASE_FULL(stats, 0, \"/Root/InplaceUpdate\", 1, 1, 2);\n+            } else {\n+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());\n+                ASSERT_PHASE(stats, 0, \"/Root/InplaceUpdate\", 1, 0);\n+                ASSERT_PHASE(stats, 1, \"/Root/InplaceUpdate\", 0, 1);\n+            }\n         },\n-        &PreparePgTable);\n+        &PreparePgTable,\n+        UseSink);\n }\n \n } // suite\ndiff --git a/ydb/core/kqp/ut/effects/kqp_write_ut.cpp b/ydb/core/kqp/ut/effects/kqp_write_ut.cpp\nindex 8a7e369a605c..7fc16a4ad238 100644\n--- a/ydb/core/kqp/ut/effects/kqp_write_ut.cpp\n+++ b/ydb/core/kqp/ut/effects/kqp_write_ut.cpp\n@@ -323,8 +323,10 @@ Y_UNIT_TEST_SUITE(KqpWrite) {\n         CompareYson(R\"([[[1u]];[[2u]];[[3u]]])\", FormatResultSetYson(result.GetResultSet(1)));\n     }\n \n-    Y_UNIT_TEST(ProjectReplace) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_TWIN(ProjectReplace, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n \n@@ -368,7 +370,7 @@ Y_UNIT_TEST_SUITE(KqpWrite) {\n \n         auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n \n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);\n     }\n \n     Y_UNIT_TEST(CastValues) {\ndiff --git a/ydb/core/kqp/ut/indexes/kqp_indexes_multishard_ut.cpp b/ydb/core/kqp/ut/indexes/kqp_indexes_multishard_ut.cpp\nindex 46b1e84f2ca5..b1284f525719 100644\n--- a/ydb/core/kqp/ut/indexes/kqp_indexes_multishard_ut.cpp\n+++ b/ydb/core/kqp/ut/indexes/kqp_indexes_multishard_ut.cpp\n@@ -1767,8 +1767,9 @@ Y_UNIT_TEST_SUITE(KqpMultishardIndex) {\n         }\n     }\n \n-    Y_UNIT_TEST(DataColumnWrite) {\n+    Y_UNIT_TEST_TWIN(DataColumnWrite, UseSink) {\n         NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n \n         auto setting = NKikimrKqp::TKqpSetting();\n         auto serverSettings = TKikimrSettings()\ndiff --git a/ydb/core/kqp/ut/indexes/kqp_indexes_ut.cpp b/ydb/core/kqp/ut/indexes/kqp_indexes_ut.cpp\nindex f70a7e16ea87..150dd9f20da9 100644\n--- a/ydb/core/kqp/ut/indexes/kqp_indexes_ut.cpp\n+++ b/ydb/core/kqp/ut/indexes/kqp_indexes_ut.cpp\n@@ -899,10 +899,13 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n         }\n     }\n \n-    void DoUpsertWithoutIndexUpdate(bool uniq) {\n+    void DoUpsertWithoutIndexUpdate(bool uniq, bool useSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);\n         auto setting = NKikimrKqp::TKqpSetting();\n         auto serverSettings = TKikimrSettings()\n-            .SetKqpSettings({setting});\n+            .SetKqpSettings({setting})\n+            .SetAppConfig(appConfig);\n         TKikimrRunner kikimr(serverSettings);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n@@ -945,7 +948,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n \n             Cerr << stats.DebugString() << Endl;\n \n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(),  uniqExtraStages + 5);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(),  uniqExtraStages + (useSink ? 4 : 5));\n \n             // One read from main table\n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniq + 1).table_access().size(), 1);\n@@ -953,18 +956,23 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniq + 1).table_access(0).reads().rows(), 0);\n \n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 2).table_access().size(), 0);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 3).table_access().size(), 0);\n \n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 4).table_access().size(), 2);\n+            if (!useSink) {\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 3).table_access().size(), 0);\n+            }\n+\n+            const auto finalStage = useSink ? 3 : 4;\n+\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + finalStage).table_access().size(), 2);\n \n             // One update of main table\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 4).table_access(0).name(), \"/Root/TestTable\");\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 4).table_access(0).updates().rows(), 1);\n-            UNIT_ASSERT(            !stats.query_phases(uniqExtraStages + 4).table_access(0).has_deletes());\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + finalStage).table_access(0).name(), \"/Root/TestTable\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + finalStage).table_access(0).updates().rows(), 1);\n+            UNIT_ASSERT(            !stats.query_phases(uniqExtraStages + finalStage).table_access(0).has_deletes());\n \n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 4).table_access(1).name(), \"/Root/TestTable/Index/indexImplTable\");\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 4).table_access(1).updates().rows(), 1);\n-            UNIT_ASSERT(            !stats.query_phases(uniqExtraStages + 4).table_access(1).has_deletes());\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + finalStage).table_access(1).name(), \"/Root/TestTable/Index/indexImplTable\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + finalStage).table_access(1).updates().rows(), 1);\n+            UNIT_ASSERT(            !stats.query_phases(uniqExtraStages + finalStage).table_access(1).has_deletes());\n \n             {\n                 const auto& yson = ReadTablePartToYson(session, \"/Root/TestTable/Index/indexImplTable\");\n@@ -989,7 +997,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n                           .ExtractValueSync();\n             UNIT_ASSERT(result.IsSuccess());\n             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), uniqExtraStages + 5);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), uniqExtraStages + (useSink ? 4 : 5));\n \n             // One read from main table\n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniq + 1).table_access().size(), 1);\n@@ -997,13 +1005,18 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniq + 1).table_access(0).reads().rows(), 1);\n \n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 2).table_access().size(), 0);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 3).table_access().size(), 0);\n+\n+            if (!useSink) {\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 3).table_access().size(), 0);\n+            }\n+\n+            const auto finalStage = useSink ? 3 : 4;\n \n             // One update of main table\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 4).table_access().size(), 1);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 4).table_access(0).name(), \"/Root/TestTable\");\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 4).table_access(0).updates().rows(), 1);\n-            UNIT_ASSERT(            !stats.query_phases(uniqExtraStages + 4).table_access(0).has_deletes());\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + finalStage).table_access().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + finalStage).table_access(0).name(), \"/Root/TestTable\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + finalStage).table_access(0).updates().rows(), 1);\n+            UNIT_ASSERT(            !stats.query_phases(uniqExtraStages + finalStage).table_access(0).has_deletes());\n \n             {\n                 const auto& yson = ReadTablePartToYson(session, \"/Root/TestTable/Index/indexImplTable\");\n@@ -1013,14 +1026,17 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n         }\n     }\n \n-    Y_UNIT_TEST_TWIN(DoUpsertWithoutIndexUpdate, UniqIndex) {\n-        DoUpsertWithoutIndexUpdate(UniqIndex);\n+    Y_UNIT_TEST_QUAD(DoUpsertWithoutIndexUpdate, UniqIndex, UseSink) {\n+        DoUpsertWithoutIndexUpdate(UniqIndex, UseSink);\n     }\n \n-    Y_UNIT_TEST(UpsertWithoutExtraNullDelete) {\n+    Y_UNIT_TEST_TWIN(UpsertWithoutExtraNullDelete, UseSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         auto setting = NKikimrKqp::TKqpSetting();\n         auto serverSettings = TKikimrSettings()\n-            .SetKqpSettings({setting});\n+            .SetKqpSettings({setting})\n+            .SetAppConfig(appConfig);\n         TKikimrRunner kikimr(serverSettings);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n@@ -1061,22 +1077,27 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n \n             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n \n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 5);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 4 : 5);\n \n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/TestTable\");\n \n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(2).table_access().size(), 0);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(3).table_access().size(), 0);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access().size(), 2);\n \n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(0).name(), \"/Root/TestTable\");\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(0).updates().rows(), 1);\n-            UNIT_ASSERT(            !stats.query_phases(4).table_access(0).has_deletes());\n+            if (!UseSink) {\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(3).table_access().size(), 0);\n+            }\n+\n+            const auto finalStage = UseSink ? 3 : 4;\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access().size(), 2);\n \n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(1).name(), \"/Root/TestTable/Index/indexImplTable\");\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(1).updates().rows(), 1);\n-            UNIT_ASSERT(            !stats.query_phases(4).table_access(1).has_deletes());\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(0).name(), \"/Root/TestTable\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(0).updates().rows(), 1);\n+            UNIT_ASSERT(            !stats.query_phases(finalStage).table_access(0).has_deletes());\n+\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(1).name(), \"/Root/TestTable/Index/indexImplTable\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(1).updates().rows(), 1);\n+            UNIT_ASSERT(            !stats.query_phases(finalStage).table_access(1).has_deletes());\n         }\n \n         {\n@@ -1095,25 +1116,30 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n             UNIT_ASSERT(result.IsSuccess());\n             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n \n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 5);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 4 : 5);\n \n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/TestTable\");\n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).reads().rows(), 1);\n \n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(2).table_access().size(), 0);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(3).table_access().size(), 0);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access().size(), 2);\n+            if (!UseSink) {\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(3).table_access().size(), 0);\n+            }\n+\n+            const auto finalStage = UseSink ? 3 : 4;\n+\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access().size(), 2);\n \n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(0).name(), \"/Root/TestTable\");\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(0).updates().rows(), 1);\n-            UNIT_ASSERT(            !stats.query_phases(4).table_access(0).has_deletes());\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(0).name(), \"/Root/TestTable\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(0).updates().rows(), 1);\n+            UNIT_ASSERT(            !stats.query_phases(finalStage).table_access(0).has_deletes());\n \n \n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(1).name(), \"/Root/TestTable/Index/indexImplTable\");\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(1).updates().rows(), 1);\n-            UNIT_ASSERT(             stats.query_phases(4).table_access(1).has_deletes());\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(1).deletes().rows(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(1).name(), \"/Root/TestTable/Index/indexImplTable\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(1).updates().rows(), 1);\n+            UNIT_ASSERT(             stats.query_phases(finalStage).table_access(1).has_deletes());\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(1).deletes().rows(), 1);\n         }\n \n         {\n@@ -1132,7 +1158,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n                           .ExtractValueSync();\n             UNIT_ASSERT(result.IsSuccess());\n             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 5);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 4 : 5);\n \n             // One read from main table\n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n@@ -1140,13 +1166,17 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).reads().rows(), 1);\n \n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(2).table_access().size(), 0);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(3).table_access().size(), 0);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access().size(), 1);\n+\n+            const auto finalStage = UseSink ? 3 : 4;\n+            if (!UseSink) {\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(3).table_access().size(), 0);\n+            }\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access().size(), 1);\n \n             // One update of main table\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(0).name(), \"/Root/TestTable\");\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(0).updates().rows(), 1);\n-            UNIT_ASSERT(            !stats.query_phases(4).table_access(0).has_deletes());\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(0).name(), \"/Root/TestTable\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(0).updates().rows(), 1);\n+            UNIT_ASSERT(            !stats.query_phases(finalStage).table_access(0).has_deletes());\n \n             {\n                 const auto& yson = ReadTablePartToYson(session, \"/Root/TestTable/Index/indexImplTable\");\n@@ -1171,7 +1201,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n                           .ExtractValueSync();\n             UNIT_ASSERT(result.IsSuccess());\n             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 4);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 3 : 4);\n \n             int idx = 1;\n \n@@ -1181,10 +1211,10 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).reads().rows(), 1);\n \n             // One update of index table\n-            idx += 2;\n+            idx += UseSink ? 1 : 2;\n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access().size(), 1);\n             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).name(), \"/Root/TestTable\");\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).updates().rows(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).updates().rows(), 1);    \n \n             // Thats it, no phase for index table - we remove it on compile time\n             {\n@@ -1210,17 +1240,24 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n                           .ExtractValueSync();\n             UNIT_ASSERT(result.IsSuccess());\n             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);\n \n-            // One read of main table\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/TestTable\");\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 1);\n+            if (!UseSink) {\n+                // One read of main table\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/TestTable\");\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 1);\n \n-            // One update of main table\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/TestTable\");\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);\n+                // One update of main table\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/TestTable\");\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);\n+            } else {\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/TestTable\");\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 1);\n+            }\n \n             {\n                 const auto& yson = ReadTablePartToYson(session, \"/Root/TestTable/Index/indexImplTable\");\n@@ -2313,7 +2350,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n         return session;\n     }\n \n-    Y_UNIT_TEST(VectorIndexOrderByCosineDistanceNotNullableLevel1) {\n+    Y_UNIT_TEST(SimpleVectorIndexOrderByCosineDistanceNotNullableLevel1) {\n         NKikimrConfig::TFeatureFlags featureFlags;\n         featureFlags.SetEnableVectorIndex(true);\n         auto setting = NKikimrKqp::TKqpSetting();\n@@ -2355,7 +2392,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n         DoPositiveQueriesVectorIndexOrderByCosine(session);\n     }\n \n-    Y_UNIT_TEST(VectorIndexOrderByCosineSimilarityNotNullableLevel1) {\n+    Y_UNIT_TEST(SimpleVectorIndexOrderByCosineSimilarityNotNullableLevel1) {\n         NKikimrConfig::TFeatureFlags featureFlags;\n         featureFlags.SetEnableVectorIndex(true);\n         auto setting = NKikimrKqp::TKqpSetting();\n@@ -2397,7 +2434,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n         DoPositiveQueriesVectorIndexOrderByCosine(session);\n     }\n \n-    Y_UNIT_TEST(VectorIndexOrderByCosineDistanceNullableLevel1) {\n+    Y_UNIT_TEST(SimpleVectorIndexOrderByCosineDistanceNullableLevel1) {\n         NKikimrConfig::TFeatureFlags featureFlags;\n         featureFlags.SetEnableVectorIndex(true);\n         auto setting = NKikimrKqp::TKqpSetting();\n@@ -2439,7 +2476,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n         DoPositiveQueriesVectorIndexOrderByCosine(session);\n     }\n \n-    Y_UNIT_TEST(VectorIndexOrderByCosineSimilarityNullableLevel1) {\n+    Y_UNIT_TEST(SimpleVectorIndexOrderByCosineSimilarityNullableLevel1) {\n         NKikimrConfig::TFeatureFlags featureFlags;\n         featureFlags.SetEnableVectorIndex(true);\n         auto setting = NKikimrKqp::TKqpSetting();\n@@ -2481,7 +2518,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n         DoPositiveQueriesVectorIndexOrderByCosine(session);\n     }\n \n-    Y_UNIT_TEST(VectorIndexOrderByCosineDistanceNotNullableLevel2) {\n+    Y_UNIT_TEST(SimpleVectorIndexOrderByCosineDistanceNotNullableLevel2) {\n         NKikimrConfig::TFeatureFlags featureFlags;\n         featureFlags.SetEnableVectorIndex(true);\n         auto setting = NKikimrKqp::TKqpSetting();\n@@ -2523,7 +2560,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n         DoPositiveQueriesVectorIndexOrderByCosine(session);\n     }\n \n-    Y_UNIT_TEST(VectorIndexOrderByCosineSimilarityNotNullableLevel2) {\n+    Y_UNIT_TEST(SimpleVectorIndexOrderByCosineSimilarityNotNullableLevel2) {\n         NKikimrConfig::TFeatureFlags featureFlags;\n         featureFlags.SetEnableVectorIndex(true);\n         auto setting = NKikimrKqp::TKqpSetting();\n@@ -2565,7 +2602,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n         DoPositiveQueriesVectorIndexOrderByCosine(session);\n     }\n \n-    Y_UNIT_TEST(VectorIndexOrderByCosineDistanceNullableLevel2) {\n+    Y_UNIT_TEST(SimpleVectorIndexOrderByCosineDistanceNullableLevel2) {\n         NKikimrConfig::TFeatureFlags featureFlags;\n         featureFlags.SetEnableVectorIndex(true);\n         auto setting = NKikimrKqp::TKqpSetting();\n@@ -2607,7 +2644,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n         DoPositiveQueriesVectorIndexOrderByCosine(session);\n     }\n \n-    Y_UNIT_TEST(VectorIndexOrderByCosineSimilarityNullableLevel2) {\n+    Y_UNIT_TEST(SimpleVectorIndexOrderByCosineSimilarityNullableLevel2) {\n         NKikimrConfig::TFeatureFlags featureFlags;\n         featureFlags.SetEnableVectorIndex(true);\n         auto setting = NKikimrKqp::TKqpSetting();\n@@ -2649,6 +2686,569 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n         DoPositiveQueriesVectorIndexOrderByCosine(session);\n     }\n \n+    std::vector<i64> DoPositiveQueryPrefixedVectorIndex(TSession& session, const TString& query) {\n+        {\n+            auto result = session.ExplainDataQuery(query).ExtractValueSync();\n+            UNIT_ASSERT_C(result.IsSuccess(),\n+                \"Failed to explain: `\" << query << \"` with \" << result.GetIssues().ToString());\n+        }\n+        {\n+            auto result = session.ExecuteDataQuery(query,\n+                TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx()\n+            ).ExtractValueSync();\n+            UNIT_ASSERT_C(result.IsSuccess(),\n+                \"Failed to execute: `\" << query << \"` with \" << result.GetIssues().ToString());\n+\n+            std::vector<i64> r;\n+            auto sets = result.GetResultSets();\n+            for (const auto& set : sets) {\n+                TResultSetParser parser{set};\n+                while (parser.TryNextRow()) {\n+                    auto value = parser.GetValue(\"pk\");\n+                    UNIT_ASSERT_C(value.GetProto().has_int64_value(), value.GetProto().ShortUtf8DebugString());\n+                    r.push_back(value.GetProto().int64_value());\n+                }\n+            }\n+            return r;\n+        }\n+    }\n+\n+    void DoPositiveQueriesPrefixedVectorIndex(TSession& session, const TString& mainQuery, const TString& indexQuery) {\n+        // TODO(mbkkt) results are not precise so for now can differ between main and index\n+        // But they're still should contains exactly 3 unique rows\n+        auto mainResults = DoPositiveQueryPrefixedVectorIndex(session, mainQuery);\n+        UNIT_ASSERT_EQUAL(mainResults.size(), 3);\n+        auto indexResults = DoPositiveQueryPrefixedVectorIndex(session, indexQuery);\n+        UNIT_ASSERT_EQUAL(indexResults.size(), 3);\n+\n+        absl::c_sort(mainResults);\n+        UNIT_ASSERT(std::unique(mainResults.begin(), mainResults.end()) == mainResults.end());\n+\n+        absl::c_sort(indexResults);\n+        UNIT_ASSERT(std::unique(indexResults.begin(), indexResults.end()) == indexResults.end());\n+    }\n+\n+    void DoPositiveQueriesPrefixedVectorIndexOrderBy(\n+        TSession& session,\n+        std::string_view function,\n+        std::string_view direction,\n+        std::string_view left,\n+        std::string_view right) {\n+        constexpr std::string_view target = \"$target = \\\"\\x67\\x73\\x03\\\";\";\n+        std::string metric = std::format(\"Knn::{}({}, {})\", function, left, right);\n+        // no metric in result\n+        {\n+            const TString plainQuery(Q1_(std::format(R\"({}\n+                SELECT * FROM `/Root/TestTable`\n+                ORDER BY {} {}\n+                LIMIT 3;\n+            )\", target, metric, direction)));\n+            const TString indexQuery(Q1_(std::format(R\"(\n+                pragma ydb.KMeansTreeSearchTopSize = \"3\";\n+                {}\n+                SELECT * FROM `/Root/TestTable` VIEW index\n+                ORDER BY {} {}\n+                LIMIT 3;\n+            )\", target, metric, direction)));\n+            DoPositiveQueriesPrefixedVectorIndex(session, plainQuery, indexQuery);\n+        }\n+        // metric in result\n+        {\n+            const TString plainQuery(Q1_(std::format(R\"({}\n+                SELECT {}, `/Root/TestTable`.* FROM `/Root/TestTable`\n+                ORDER BY {} {}\n+                LIMIT 3;\n+            )\", target, metric, metric, direction)));\n+            const TString indexQuery(Q1_(std::format(R\"({}\n+                pragma ydb.KMeansTreeSearchTopSize = \"2\";\n+                SELECT {}, `/Root/TestTable`.* FROM `/Root/TestTable` VIEW index\n+                ORDER BY {} {}\n+                LIMIT 3;\n+            )\", target, metric, metric, direction)));\n+            DoPositiveQueriesPrefixedVectorIndex(session, plainQuery, indexQuery);\n+        }\n+        // metric as result\n+        {\n+            const TString plainQuery(Q1_(std::format(R\"({}\n+                SELECT {} AS m, `/Root/TestTable`.* FROM `/Root/TestTable`\n+                ORDER BY m {}\n+                LIMIT 3;\n+            )\", target, metric, direction)));\n+            const TString indexQuery(Q1_(std::format(R\"(\n+                pragma ydb.KMeansTreeSearchTopSize = \"1\";\n+                {}\n+                SELECT {} AS m, `/Root/TestTable`.* FROM `/Root/TestTable` VIEW index\n+                ORDER BY m {}\n+                LIMIT 3;\n+            )\", target, metric, direction)));\n+            DoPositiveQueriesPrefixedVectorIndex(session, plainQuery, indexQuery);\n+        }\n+    }\n+\n+    void DoPositiveQueriesPrefixedVectorIndexOrderBy(\n+        TSession& session,\n+        std::string_view function,\n+        std::string_view direction) {\n+        // target is left, member is right\n+        DoPositiveQueriesPrefixedVectorIndexOrderBy(session, function, direction, \"$target\", \"emb\");\n+        // target is right, member is left\n+        DoPositiveQueriesPrefixedVectorIndexOrderBy(session, function, direction, \"emb\", \"$target\");\n+    }\n+\n+    void DoPositiveQueriesPrefixedVectorIndexOrderByCosine(TSession& session) {\n+        // distance, default direction\n+        DoPositiveQueriesPrefixedVectorIndexOrderBy(session, \"CosineDistance\", \"\");\n+        // distance, asc direction\n+        DoPositiveQueriesPrefixedVectorIndexOrderBy(session, \"CosineDistance\", \"ASC\");\n+        // similarity, desc direction\n+        DoPositiveQueriesPrefixedVectorIndexOrderBy(session, \"CosineSimilarity\", \"DESC\");\n+    }\n+\n+    TSession DoCreateTableForPrefixedVectorIndex(TTableClient& db, bool nullable) {\n+        auto session = db.CreateSession().GetValueSync().GetSession();\n+\n+        {\n+            auto tableBuilder = db.GetTableBuilder();\n+            if (nullable) {\n+                tableBuilder\n+                    .AddNullableColumn(\"pk\", EPrimitiveType::Int64)\n+                    .AddNullableColumn(\"user\", EPrimitiveType::String)\n+                    .AddNullableColumn(\"emb\", EPrimitiveType::String)\n+                    .AddNullableColumn(\"data\", EPrimitiveType::String);\n+            } else {\n+                tableBuilder\n+                    .AddNonNullableColumn(\"pk\", EPrimitiveType::Int64)\n+                    .AddNonNullableColumn(\"user\", EPrimitiveType::String)\n+                    .AddNonNullableColumn(\"emb\", EPrimitiveType::String)\n+                    .AddNonNullableColumn(\"data\", EPrimitiveType::String);\n+            }\n+            tableBuilder.SetPrimaryKeyColumns({\"pk\"});\n+            tableBuilder.BeginPartitioningSettings()\n+                .SetMinPartitionsCount(3)\n+            .EndPartitioningSettings();\n+            auto partitions = TExplicitPartitions{}\n+                .AppendSplitPoints(TValueBuilder{}.BeginTuple().AddElement().OptionalInt64(4).EndTuple().Build())\n+                .AppendSplitPoints(TValueBuilder{}.BeginTuple().AddElement().OptionalInt64(6).EndTuple().Build());\n+            tableBuilder.SetPartitionAtKeys(partitions);\n+            auto result = session.CreateTable(\"/Root/TestTable\", tableBuilder.Build()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL(result.IsTransportError(), false);\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+        }\n+\n+        {\n+            const TString query1(Q_(R\"(\n+                UPSERT INTO `/Root/TestTable` (pk, user, emb, data) VALUES)\"\n+                \"(0, \\\"user_a\\\", \\\"\\x03\\x30\\x03\\\", \\\"0\\\"),\"\n+                \"(1, \\\"user_a\\\", \\\"\\x13\\x31\\x03\\\", \\\"1\\\"),\"\n+                \"(2, \\\"user_a\\\", \\\"\\x23\\x32\\x03\\\", \\\"2\\\"),\"\n+                \"(3, \\\"user_a\\\", \\\"\\x33\\x33\\x03\\\", \\\"3\\\"),\"\n+                \"(4, \\\"user_a\\\", \\\"\\x43\\x34\\x03\\\", \\\"4\\\"),\"\n+                \"(5, \\\"user_a\\\", \\\"\\x60\\x60\\x03\\\", \\\"5\\\"),\"\n+                \"(6, \\\"user_a\\\", \\\"\\x61\\x61\\x03\\\", \\\"6\\\"),\"\n+                \"(7, \\\"user_a\\\", \\\"\\x62\\x62\\x03\\\", \\\"7\\\"),\"\n+                \"(8, \\\"user_a\\\", \\\"\\x75\\x76\\x03\\\", \\\"8\\\"),\"\n+                \"(9, \\\"user_a\\\", \\\"\\x76\\x76\\x03\\\", \\\"9\\\"),\"\n+\n+                \"(0, \\\"user_b\\\", \\\"\\x03\\x30\\x03\\\", \\\"0\\\"),\"\n+                \"(1, \\\"user_b\\\", \\\"\\x13\\x31\\x03\\\", \\\"1\\\"),\"\n+                \"(2, \\\"user_b\\\", \\\"\\x23\\x32\\x03\\\", \\\"2\\\"),\"\n+                \"(3, \\\"user_b\\\", \\\"\\x33\\x33\\x03\\\", \\\"3\\\"),\"\n+                \"(4, \\\"user_b\\\", \\\"\\x43\\x34\\x03\\\", \\\"4\\\"),\"\n+                \"(5, \\\"user_b\\\", \\\"\\x60\\x60\\x03\\\", \\\"5\\\"),\"\n+                \"(6, \\\"user_b\\\", \\\"\\x61\\x61\\x03\\\", \\\"6\\\"),\"\n+                \"(7, \\\"user_b\\\", \\\"\\x62\\x62\\x03\\\", \\\"7\\\"),\"\n+                \"(8, \\\"user_b\\\", \\\"\\x75\\x76\\x03\\\", \\\"8\\\"),\"\n+                \"(9, \\\"user_b\\\", \\\"\\x76\\x76\\x03\\\", \\\"9\\\"),\"\n+\n+                \"(0, \\\"user_c\\\", \\\"\\x03\\x30\\x03\\\", \\\"0\\\"),\"\n+                \"(1, \\\"user_c\\\", \\\"\\x13\\x31\\x03\\\", \\\"1\\\"),\"\n+                \"(2, \\\"user_c\\\", \\\"\\x23\\x32\\x03\\\", \\\"2\\\"),\"\n+                \"(3, \\\"user_c\\\", \\\"\\x33\\x33\\x03\\\", \\\"3\\\"),\"\n+                \"(4, \\\"user_c\\\", \\\"\\x43\\x34\\x03\\\", \\\"4\\\"),\"\n+                \"(5, \\\"user_c\\\", \\\"\\x60\\x60\\x03\\\", \\\"5\\\"),\"\n+                \"(6, \\\"user_c\\\", \\\"\\x61\\x61\\x03\\\", \\\"6\\\"),\"\n+                \"(7, \\\"user_c\\\", \\\"\\x62\\x62\\x03\\\", \\\"7\\\"),\"\n+                \"(8, \\\"user_c\\\", \\\"\\x75\\x76\\x03\\\", \\\"8\\\"),\"\n+                \"(9, \\\"user_c\\\", \\\"\\x76\\x76\\x03\\\", \\\"9\\\");\"\n+            ));\n+\n+            auto result = session.ExecuteDataQuery(\n+                                 query1,\n+                                 TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx())\n+                          .ExtractValueSync();\n+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());\n+        }\n+        return session;\n+    }\n+\n+    Y_UNIT_TEST(PrefixedVectorIndexOrderByCosineDistanceNotNullableLevel1) {\n+        NKikimrConfig::TFeatureFlags featureFlags;\n+        featureFlags.SetEnableVectorIndex(true);\n+        auto setting = NKikimrKqp::TKqpSetting();\n+        auto serverSettings = TKikimrSettings()\n+            .SetFeatureFlags(featureFlags)\n+            .SetKqpSettings({setting});\n+\n+        TKikimrRunner kikimr(serverSettings);\n+        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_DEBUG);\n+\n+        auto db = kikimr.GetTableClient();\n+        auto session = DoCreateTableForPrefixedVectorIndex(db, false);\n+        {\n+            const TString createIndex(Q_(R\"(\n+                ALTER TABLE `/Root/TestTable`\n+                    ADD INDEX index\n+                    GLOBAL USING vector_kmeans_tree\n+                    ON (user, emb)\n+                    WITH (distance=cosine, vector_type=\"uint8\", vector_dimension=2, levels=1, clusters=2);\n+            )\"));\n+\n+            auto result = session.ExecuteSchemeQuery(createIndex)\n+                          .ExtractValueSync();\n+\n+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());\n+        }\n+        {\n+            auto result = session.DescribeTable(\"/Root/TestTable\").ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);\n+            const auto& indexes = result.GetTableDescription().GetIndexDescriptions();\n+            UNIT_ASSERT_EQUAL(indexes.size(), 1);\n+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexName(), \"index\");\n+            std::vector<std::string> indexKeyColumns{\"user\", \"emb\"};\n+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexColumns(), indexKeyColumns);\n+            const auto& settings = std::get<TKMeansTreeSettings>(indexes[0].GetIndexSettings());\n+            UNIT_ASSERT_EQUAL(settings.Settings.Metric, NYdb::NTable::TVectorIndexSettings::EMetric::CosineDistance);\n+            UNIT_ASSERT_EQUAL(settings.Settings.VectorType, NYdb::NTable::TVectorIndexSettings::EVectorType::Uint8);\n+            UNIT_ASSERT_EQUAL(settings.Settings.VectorDimension, 2);\n+            UNIT_ASSERT_EQUAL(settings.Levels, 1);\n+            UNIT_ASSERT_EQUAL(settings.Clusters, 2);\n+        }\n+        // TODO(mbkkt) enable it when kqp part will be ready\n+        // DoPositiveQueriesPrefixedVectorIndexOrderByCosine(session);\n+    }\n+\n+    Y_UNIT_TEST(PrefixedVectorIndexOrderByCosineSimilarityNotNullableLevel1) {\n+        NKikimrConfig::TFeatureFlags featureFlags;\n+        featureFlags.SetEnableVectorIndex(true);\n+        auto setting = NKikimrKqp::TKqpSetting();\n+        auto serverSettings = TKikimrSettings()\n+            .SetFeatureFlags(featureFlags)\n+            .SetKqpSettings({setting});\n+\n+        TKikimrRunner kikimr(serverSettings);\n+        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_DEBUG);\n+\n+        auto db = kikimr.GetTableClient();\n+        auto session = DoCreateTableForPrefixedVectorIndex(db, false);\n+        {\n+            const TString createIndex(Q_(R\"(\n+                ALTER TABLE `/Root/TestTable`\n+                    ADD INDEX index\n+                    GLOBAL USING vector_kmeans_tree\n+                    ON (user, emb)\n+                    WITH (similarity=cosine, vector_type=\"uint8\", vector_dimension=2, levels=1, clusters=2);\n+            )\"));\n+\n+            auto result = session.ExecuteSchemeQuery(createIndex)\n+                          .ExtractValueSync();\n+\n+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());\n+        }\n+        {\n+            auto result = session.DescribeTable(\"/Root/TestTable\").ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);\n+            const auto& indexes = result.GetTableDescription().GetIndexDescriptions();\n+            UNIT_ASSERT_EQUAL(indexes.size(), 1);\n+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexName(), \"index\");\n+            std::vector<std::string> indexKeyColumns{\"user\", \"emb\"};\n+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexColumns(), indexKeyColumns);\n+            const auto& settings = std::get<TKMeansTreeSettings>(indexes[0].GetIndexSettings());\n+            UNIT_ASSERT_EQUAL(settings.Settings.Metric, NYdb::NTable::TVectorIndexSettings::EMetric::CosineSimilarity);\n+            UNIT_ASSERT_EQUAL(settings.Settings.VectorType, NYdb::NTable::TVectorIndexSettings::EVectorType::Uint8);\n+            UNIT_ASSERT_EQUAL(settings.Settings.VectorDimension, 2);\n+            UNIT_ASSERT_EQUAL(settings.Levels, 1);\n+            UNIT_ASSERT_EQUAL(settings.Clusters, 2);\n+        }\n+        // TODO(mbkkt) enable it when kqp part will be ready\n+        // DoPositiveQueriesPrefixedVectorIndexOrderByCosine(session);\n+    }\n+\n+    Y_UNIT_TEST(PrefixedVectorIndexOrderByCosineDistanceNullableLevel1) {\n+        NKikimrConfig::TFeatureFlags featureFlags;\n+        featureFlags.SetEnableVectorIndex(true);\n+        auto setting = NKikimrKqp::TKqpSetting();\n+        auto serverSettings = TKikimrSettings()\n+            .SetFeatureFlags(featureFlags)\n+            .SetKqpSettings({setting});\n+\n+        TKikimrRunner kikimr(serverSettings);\n+        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_DEBUG);\n+\n+        auto db = kikimr.GetTableClient();\n+        auto session = DoCreateTableForPrefixedVectorIndex(db, true);\n+        {\n+            const TString createIndex(Q_(R\"(\n+                ALTER TABLE `/Root/TestTable`\n+                    ADD INDEX index\n+                    GLOBAL USING vector_kmeans_tree\n+                    ON (user, emb)\n+                    WITH (distance=cosine, vector_type=\"uint8\", vector_dimension=2, levels=1, clusters=2);\n+            )\"));\n+\n+            auto result = session.ExecuteSchemeQuery(createIndex)\n+                          .ExtractValueSync();\n+\n+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());\n+        }\n+        {\n+            auto result = session.DescribeTable(\"/Root/TestTable\").ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);\n+            const auto& indexes = result.GetTableDescription().GetIndexDescriptions();\n+            UNIT_ASSERT_EQUAL(indexes.size(), 1);\n+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexName(), \"index\");\n+            std::vector<std::string> indexKeyColumns{\"user\", \"emb\"};\n+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexColumns(), indexKeyColumns);\n+            const auto& settings = std::get<TKMeansTreeSettings>(indexes[0].GetIndexSettings());\n+            UNIT_ASSERT_EQUAL(settings.Settings.Metric, NYdb::NTable::TVectorIndexSettings::EMetric::CosineDistance);\n+            UNIT_ASSERT_EQUAL(settings.Settings.VectorType, NYdb::NTable::TVectorIndexSettings::EVectorType::Uint8);\n+            UNIT_ASSERT_EQUAL(settings.Settings.VectorDimension, 2);\n+            UNIT_ASSERT_EQUAL(settings.Levels, 1);\n+            UNIT_ASSERT_EQUAL(settings.Clusters, 2);\n+        }\n+        // TODO(mbkkt) enable it when kqp part will be ready\n+        // DoPositiveQueriesPrefixedVectorIndexOrderByCosine(session);\n+    }\n+\n+    Y_UNIT_TEST(PrefixedVectorIndexOrderByCosineSimilarityNullableLevel1) {\n+        NKikimrConfig::TFeatureFlags featureFlags;\n+        featureFlags.SetEnableVectorIndex(true);\n+        auto setting = NKikimrKqp::TKqpSetting();\n+        auto serverSettings = TKikimrSettings()\n+            .SetFeatureFlags(featureFlags)\n+            .SetKqpSettings({setting});\n+\n+        TKikimrRunner kikimr(serverSettings);\n+        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_DEBUG);\n+\n+        auto db = kikimr.GetTableClient();\n+        auto session = DoCreateTableForPrefixedVectorIndex(db, true);\n+        {\n+            const TString createIndex(Q_(R\"(\n+                ALTER TABLE `/Root/TestTable`\n+                    ADD INDEX index\n+                    GLOBAL USING vector_kmeans_tree\n+                    ON (user, emb)\n+                    WITH (similarity=cosine, vector_type=\"uint8\", vector_dimension=2, levels=1, clusters=2);\n+            )\"));\n+\n+            auto result = session.ExecuteSchemeQuery(createIndex)\n+                          .ExtractValueSync();\n+\n+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());\n+        }\n+        {\n+            auto result = session.DescribeTable(\"/Root/TestTable\").ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);\n+            const auto& indexes = result.GetTableDescription().GetIndexDescriptions();\n+            UNIT_ASSERT_EQUAL(indexes.size(), 1);\n+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexName(), \"index\");\n+            std::vector<std::string> indexKeyColumns{\"user\", \"emb\"};\n+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexColumns(), indexKeyColumns);\n+            const auto& settings = std::get<TKMeansTreeSettings>(indexes[0].GetIndexSettings());\n+            UNIT_ASSERT_EQUAL(settings.Settings.Metric, NYdb::NTable::TVectorIndexSettings::EMetric::CosineSimilarity);\n+            UNIT_ASSERT_EQUAL(settings.Settings.VectorType, NYdb::NTable::TVectorIndexSettings::EVectorType::Uint8);\n+            UNIT_ASSERT_EQUAL(settings.Settings.VectorDimension, 2);\n+            UNIT_ASSERT_EQUAL(settings.Levels, 1);\n+            UNIT_ASSERT_EQUAL(settings.Clusters, 2);\n+        }\n+        // TODO(mbkkt) enable it when kqp part will be ready\n+        // DoPositiveQueriesPrefixedVectorIndexOrderByCosine(session);\n+    }\n+\n+    Y_UNIT_TEST(PrefixedVectorIndexOrderByCosineDistanceNotNullableLevel2) {\n+        NKikimrConfig::TFeatureFlags featureFlags;\n+        featureFlags.SetEnableVectorIndex(true);\n+        auto setting = NKikimrKqp::TKqpSetting();\n+        auto serverSettings = TKikimrSettings()\n+            .SetFeatureFlags(featureFlags)\n+            .SetKqpSettings({setting});\n+\n+        TKikimrRunner kikimr(serverSettings);\n+        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_DEBUG);\n+\n+        auto db = kikimr.GetTableClient();\n+        auto session = DoCreateTableForPrefixedVectorIndex(db, false);\n+        {\n+            const TString createIndex(Q_(R\"(\n+                ALTER TABLE `/Root/TestTable`\n+                    ADD INDEX index\n+                    GLOBAL USING vector_kmeans_tree\n+                    ON (user, emb)\n+                    WITH (distance=cosine, vector_type=\"uint8\", vector_dimension=2, levels=2, clusters=2);\n+            )\"));\n+\n+            auto result = session.ExecuteSchemeQuery(createIndex)\n+                          .ExtractValueSync();\n+\n+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());\n+        }\n+        {\n+            auto result = session.DescribeTable(\"/Root/TestTable\").ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);\n+            const auto& indexes = result.GetTableDescription().GetIndexDescriptions();\n+            UNIT_ASSERT_EQUAL(indexes.size(), 1);\n+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexName(), \"index\");\n+            std::vector<std::string> indexKeyColumns{\"user\", \"emb\"};\n+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexColumns(), indexKeyColumns);\n+            const auto& settings = std::get<TKMeansTreeSettings>(indexes[0].GetIndexSettings());\n+            UNIT_ASSERT_EQUAL(settings.Settings.Metric, NYdb::NTable::TVectorIndexSettings::EMetric::CosineDistance);\n+            UNIT_ASSERT_EQUAL(settings.Settings.VectorType, NYdb::NTable::TVectorIndexSettings::EVectorType::Uint8);\n+            UNIT_ASSERT_EQUAL(settings.Settings.VectorDimension, 2);\n+            UNIT_ASSERT_EQUAL(settings.Levels, 2);\n+            UNIT_ASSERT_EQUAL(settings.Clusters, 2);\n+        }\n+        // TODO(mbkkt) enable it when kqp part will be ready\n+        // DoPositiveQueriesPrefixedVectorIndexOrderByCosine(session);\n+    }\n+\n+    Y_UNIT_TEST(PrefixedVectorIndexOrderByCosineSimilarityNotNullableLevel2) {\n+        NKikimrConfig::TFeatureFlags featureFlags;\n+        featureFlags.SetEnableVectorIndex(true);\n+        auto setting = NKikimrKqp::TKqpSetting();\n+        auto serverSettings = TKikimrSettings()\n+            .SetFeatureFlags(featureFlags)\n+            .SetKqpSettings({setting});\n+\n+        TKikimrRunner kikimr(serverSettings);\n+        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_DEBUG);\n+\n+        auto db = kikimr.GetTableClient();\n+        auto session = DoCreateTableForPrefixedVectorIndex(db, false);\n+        {\n+            const TString createIndex(Q_(R\"(\n+                ALTER TABLE `/Root/TestTable`\n+                    ADD INDEX index\n+                    GLOBAL USING vector_kmeans_tree\n+                    ON (user, emb)\n+                    WITH (similarity=cosine, vector_type=\"uint8\", vector_dimension=2, levels=2, clusters=2);\n+            )\"));\n+\n+            auto result = session.ExecuteSchemeQuery(createIndex)\n+                          .ExtractValueSync();\n+\n+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());\n+        }\n+        {\n+            auto result = session.DescribeTable(\"/Root/TestTable\").ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);\n+            const auto& indexes = result.GetTableDescription().GetIndexDescriptions();\n+            UNIT_ASSERT_EQUAL(indexes.size(), 1);\n+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexName(), \"index\");\n+            std::vector<std::string> indexKeyColumns{\"user\", \"emb\"};\n+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexColumns(), indexKeyColumns);\n+            const auto& settings = std::get<TKMeansTreeSettings>(indexes[0].GetIndexSettings());\n+            UNIT_ASSERT_EQUAL(settings.Settings.Metric, NYdb::NTable::TVectorIndexSettings::EMetric::CosineSimilarity);\n+            UNIT_ASSERT_EQUAL(settings.Settings.VectorType, NYdb::NTable::TVectorIndexSettings::EVectorType::Uint8);\n+            UNIT_ASSERT_EQUAL(settings.Settings.VectorDimension, 2);\n+            UNIT_ASSERT_EQUAL(settings.Levels, 2);\n+            UNIT_ASSERT_EQUAL(settings.Clusters, 2);\n+        }\n+        // TODO(mbkkt) enable it when kqp part will be ready\n+        // DoPositiveQueriesPrefixedVectorIndexOrderByCosine(session);\n+    }\n+\n+    Y_UNIT_TEST(PrefixedVectorIndexOrderByCosineDistanceNullableLevel2) {\n+        NKikimrConfig::TFeatureFlags featureFlags;\n+        featureFlags.SetEnableVectorIndex(true);\n+        auto setting = NKikimrKqp::TKqpSetting();\n+        auto serverSettings = TKikimrSettings()\n+            .SetFeatureFlags(featureFlags)\n+            .SetKqpSettings({setting});\n+\n+        TKikimrRunner kikimr(serverSettings);\n+        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_DEBUG);\n+\n+        auto db = kikimr.GetTableClient();\n+        auto session = DoCreateTableForPrefixedVectorIndex(db, true);\n+        {\n+            const TString createIndex(Q_(R\"(\n+                ALTER TABLE `/Root/TestTable`\n+                    ADD INDEX index\n+                    GLOBAL USING vector_kmeans_tree\n+                    ON (user, emb)\n+                    WITH (distance=cosine, vector_type=\"uint8\", vector_dimension=2, levels=2, clusters=2);\n+            )\"));\n+\n+            auto result = session.ExecuteSchemeQuery(createIndex)\n+                          .ExtractValueSync();\n+\n+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());\n+        }\n+        {\n+            auto result = session.DescribeTable(\"/Root/TestTable\").ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);\n+            const auto& indexes = result.GetTableDescription().GetIndexDescriptions();\n+            UNIT_ASSERT_EQUAL(indexes.size(), 1);\n+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexName(), \"index\");\n+            std::vector<std::string> indexKeyColumns{\"user\", \"emb\"};\n+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexColumns(), indexKeyColumns);\n+            const auto& settings = std::get<TKMeansTreeSettings>(indexes[0].GetIndexSettings());\n+            UNIT_ASSERT_EQUAL(settings.Settings.Metric, NYdb::NTable::TVectorIndexSettings::EMetric::CosineDistance);\n+            UNIT_ASSERT_EQUAL(settings.Settings.VectorType, NYdb::NTable::TVectorIndexSettings::EVectorType::Uint8);\n+            UNIT_ASSERT_EQUAL(settings.Settings.VectorDimension, 2);\n+            UNIT_ASSERT_EQUAL(settings.Levels, 2);\n+            UNIT_ASSERT_EQUAL(settings.Clusters, 2);\n+        }\n+        // TODO(mbkkt) enable it when kqp part will be ready\n+        // DoPositiveQueriesPrefixedVectorIndexOrderByCosine(session);\n+    }\n+\n+    Y_UNIT_TEST(PrefixedVectorIndexOrderByCosineSimilarityNullableLevel2) {\n+        NKikimrConfig::TFeatureFlags featureFlags;\n+        featureFlags.SetEnableVectorIndex(true);\n+        auto setting = NKikimrKqp::TKqpSetting();\n+        auto serverSettings = TKikimrSettings()\n+            .SetFeatureFlags(featureFlags)\n+            .SetKqpSettings({setting});\n+\n+        TKikimrRunner kikimr(serverSettings);\n+        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_DEBUG);\n+\n+        auto db = kikimr.GetTableClient();\n+        auto session = DoCreateTableForPrefixedVectorIndex(db, true);\n+        {\n+            const TString createIndex(Q_(R\"(\n+                ALTER TABLE `/Root/TestTable`\n+                    ADD INDEX index\n+                    GLOBAL USING vector_kmeans_tree\n+                    ON (user, emb)\n+                    WITH (similarity=cosine, vector_type=\"uint8\", vector_dimension=2, levels=2, clusters=2);\n+            )\"));\n+\n+            auto result = session.ExecuteSchemeQuery(createIndex)\n+                          .ExtractValueSync();\n+\n+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());\n+        }\n+        {\n+            auto result = session.DescribeTable(\"/Root/TestTable\").ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);\n+            const auto& indexes = result.GetTableDescription().GetIndexDescriptions();\n+            UNIT_ASSERT_EQUAL(indexes.size(), 1);\n+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexName(), \"index\");\n+            std::vector<std::string> indexKeyColumns{\"user\", \"emb\"};\n+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexColumns(), indexKeyColumns);\n+            const auto& settings = std::get<TKMeansTreeSettings>(indexes[0].GetIndexSettings());\n+            UNIT_ASSERT_EQUAL(settings.Settings.Metric, NYdb::NTable::TVectorIndexSettings::EMetric::CosineSimilarity);\n+            UNIT_ASSERT_EQUAL(settings.Settings.VectorType, NYdb::NTable::TVectorIndexSettings::EVectorType::Uint8);\n+            UNIT_ASSERT_EQUAL(settings.Settings.VectorDimension, 2);\n+            UNIT_ASSERT_EQUAL(settings.Levels, 2);\n+            UNIT_ASSERT_EQUAL(settings.Clusters, 2);\n+        }\n+        // TODO(mbkkt) enable it when kqp part will be ready\n+        // DoPositiveQueriesPrefixedVectorIndexOrderByCosine(session);\n+    }\n+\n     Y_UNIT_TEST(ExplainCollectFullDiagnostics) {\n         auto setting = NKikimrKqp::TKqpSetting();\n         auto serverSettings = TKikimrSettings()\n@@ -2873,10 +3473,13 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {\n         }\n     }\n \n-    Y_UNIT_TEST(SecondaryIndexReplace) {\n+    Y_UNIT_TEST_TWIN(SecondaryIndexReplace, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         auto setting = NKikimrKqp::TKqpSetting();\n         auto serverSettings = TKikimrSettings()\n-            .SetKqpSettings({setting});\n+            .SetKqpSettings({setting})\n+            .SetAppConfig(app);\n         TKikimrRunner kikimr(serverSettings);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n@@ -2994,10 +3597,13 @@ R\"([[#;#;[\"Primary1\"];[41u]];[[\"Secondary2\"];[2u];[\"Primary2\"];[42u]];[[\"Seconda\n         }\n     }\n \n-    Y_UNIT_TEST(MultipleSecondaryIndex) {\n+    Y_UNIT_TEST_TWIN(MultipleSecondaryIndex, UseSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         auto setting = NKikimrKqp::TKqpSetting();\n         auto serverSettings = TKikimrSettings()\n-            .SetKqpSettings({setting});\n+            .SetKqpSettings({setting})\n+            .SetAppConfig(appConfig);\n         TKikimrRunner kikimr(serverSettings);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n@@ -3370,10 +3976,13 @@ R\"([[#;#;[\"Primary1\"];[41u]];[[\"Secondary2\"];[2u];[\"Primary2\"];[42u]];[[\"Seconda\n     }\n \n \n-    Y_UNIT_TEST(MultipleSecondaryIndexWithSameComulns) {\n+    Y_UNIT_TEST_TWIN(MultipleSecondaryIndexWithSameComulns, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         auto setting = NKikimrKqp::TKqpSetting();\n         auto serverSettings = TKikimrSettings()\n-            .SetKqpSettings({setting});\n+            .SetKqpSettings({setting})\n+            .SetAppConfig(app);\n         TKikimrRunner kikimr(serverSettings);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n@@ -3706,10 +4315,13 @@ R\"([[#;#;[\"Primary1\"];[41u]];[[\"Secondary2\"];[2u];[\"Primary2\"];[42u]];[[\"Seconda\n         }\n     }\n \n-    Y_UNIT_TEST(SecondaryIndexWithPrimaryKeySameComulns) {\n+    Y_UNIT_TEST_TWIN(SecondaryIndexWithPrimaryKeySameComulns, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         auto setting = NKikimrKqp::TKqpSetting();\n         auto serverSettings = TKikimrSettings()\n-            .SetKqpSettings({setting});\n+            .SetKqpSettings({setting})\n+            .SetAppConfig(app);\n         TKikimrRunner kikimr(serverSettings);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n@@ -4550,10 +5162,13 @@ R\"([[#;#;[\"Primary1\"];[41u]];[[\"Secondary2\"];[2u];[\"Primary2\"];[42u]];[[\"Seconda\n         }\n     }\n \n-    Y_UNIT_TEST(DuplicateUpsertInterleaveParams) {\n+    Y_UNIT_TEST_TWIN(DuplicateUpsertInterleaveParams, UseSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         auto setting = NKikimrKqp::TKqpSetting();\n         auto serverSettings = TKikimrSettings()\n-            .SetKqpSettings({setting});\n+            .SetKqpSettings({setting})\n+            .SetAppConfig(appConfig);\n         TKikimrRunner kikimr(serverSettings);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n@@ -5262,10 +5877,13 @@ R\"([[#;#;[\"Primary1\"];[41u]];[[\"Secondary2\"];[2u];[\"Primary2\"];[42u]];[[\"Seconda\n         ])\", FormatResultSetYson(result.GetResultSet(0)));\n     }\n \n-    Y_UNIT_TEST(UpdateDeletePlan) {\n+    Y_UNIT_TEST_TWIN(UpdateDeletePlan, UseSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         auto setting = NKikimrKqp::TKqpSetting();\n         auto serverSettings = TKikimrSettings()\n-            .SetKqpSettings({setting});\n+            .SetKqpSettings({setting})\n+            .SetAppConfig(appConfig);\n         TKikimrRunner kikimr(serverSettings);\n \n         auto db = kikimr.GetTableClient();\ndiff --git a/ydb/core/kqp/ut/olap/aggregations_ut.cpp b/ydb/core/kqp/ut/olap/aggregations_ut.cpp\nindex 8026a2c5b123..b842b9932ade 100644\n--- a/ydb/core/kqp/ut/olap/aggregations_ut.cpp\n+++ b/ydb/core/kqp/ut/olap/aggregations_ut.cpp\n@@ -145,11 +145,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n             CompareYson(result, R\"([[23000u;]])\");\n \n             // Check plan\n-#if SSA_RUNTIME_VERSION >= 2U\n             CheckPlanForAggregatePushdown(query, tableClient, { \"TKqpOlapAgg\" }, \"TableFullScan\");\n-#else\n-            CheckPlanForAggregatePushdown(query, tableClient, { \"CombineCore\" }, \"\");\n-#endif\n         }\n     }\n \n@@ -189,12 +185,8 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n             CompareYson(result, R\"([[[0];4600u];[[1];4600u];[[2];4600u];[[3];4600u];[[4];4600u]])\");\n \n             // Check plan\n-#if SSA_RUNTIME_VERSION >= 2U\n             CheckPlanForAggregatePushdown(query, tableClient, { \"WideCombiner\" }, \"TableFullScan\");\n //            CheckPlanForAggregatePushdown(query, tableClient, { \"TKqpOlapAgg\" }, \"TableFullScan\");\n-#else\n-            CheckPlanForAggregatePushdown(query, tableClient, { \"CombineCore\" }, \"\");\n-#endif\n         }\n     }\n \n@@ -318,11 +310,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n             CompareYson(result, R\"([[23000u;]])\");\n \n             // Check plan\n-#if SSA_RUNTIME_VERSION >= 2U\n             CheckPlanForAggregatePushdown(query, tableClient, { \"TKqpOlapAgg\" }, \"TableFullScan\");\n-#else\n-            CheckPlanForAggregatePushdown(query, tableClient, { \"Condense\" }, \"\");\n-#endif\n         }\n     }\n \n@@ -361,11 +349,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n             CompareYson(result, R\"([[23000u;]])\");\n \n             // Check plan\n-#if SSA_RUNTIME_VERSION >= 2U\n             CheckPlanForAggregatePushdown(query, tableClient, { \"TKqpOlapAgg\" }, \"TableFullScan\");\n-#else\n-            CheckPlanForAggregatePushdown(query, tableClient, { \"Condense\" }, \"\");\n-#endif\n         }\n     }\n \n@@ -441,12 +425,8 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 )\")\n             .SetExpectedReply(\"[[4600u;]]\")\n             .AddExpectedPlanOptions(\"KqpOlapFilter\")\n-#if SSA_RUNTIME_VERSION >= 2U\n             .AddExpectedPlanOptions(\"TKqpOlapAgg\")\n             .MutableLimitChecker().SetExpectedResultCount(2)\n-#else\n-            .AddExpectedPlanOptions(\"Condense\")\n-#endif\n             ;\n \n         TestAggregations({ testCase });\n@@ -462,13 +442,9 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n             )\")\n             .SetExpectedReply(\"[[4600u;]]\")\n             .AddExpectedPlanOptions(\"KqpOlapFilter\")\n-#if SSA_RUNTIME_VERSION >= 2U\n             .AddExpectedPlanOptions(\"TKqpOlapAgg\")\n             // See https://github.com/ydb-platform/ydb/issues/7299 for explanation, why resultCount = 3\n             .MutableLimitChecker().SetExpectedResultCount(3)\n-#else\n-            .AddExpectedPlanOptions(\"CombineCore\")\n-#endif\n             ;\n \n         TestAggregations({ testCase });\n@@ -484,13 +460,8 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n             )\")\n             .SetExpectedReply(\"[[4600u;]]\")\n             .AddExpectedPlanOptions(\"KqpOlapFilter\")\n-#if SSA_RUNTIME_VERSION >= 2U\n             .AddExpectedPlanOptions(\"TKqpOlapAgg\")\n             .MutableLimitChecker().SetExpectedResultCount(2)\n-#else\n-            .AddExpectedPlanOptions(\"CombineCore\")\n-            .AddExpectedPlanOptions(\"KqpOlapFilter\")\n-#endif\n             ;\n \n         TestAggregations({ testCase });\n@@ -597,11 +568,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 WHERE id > 5;\n             )\")\n             .SetExpectedReply(\"[[0u]]\")\n-#if SSA_RUNTIME_VERSION >= 2U\n             .AddExpectedPlanOptions(\"TKqpOlapAgg\");\n-#else\n-            .AddExpectedPlanOptions(\"CombineCore\");\n-#endif\n \n         TestTableWithNulls({ testCase });\n     }\n@@ -614,11 +581,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 FROM `/Root/tableWithNulls`;\n             )\")\n             .SetExpectedReply(\"[[5u]]\")\n-#if SSA_RUNTIME_VERSION >= 2U\n             .AddExpectedPlanOptions(\"TKqpOlapAgg\");\n-#else\n-            .AddExpectedPlanOptions(\"CombineCore\");\n-#endif\n \n         TestTableWithNulls({ testCase });\n     }\n@@ -730,11 +693,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 WHERE level = 2\n             )\")\n             .SetExpectedReply(\"[[4600u;]]\")\n-#if SSA_RUNTIME_VERSION >= 2U\n             .AddExpectedPlanOptions(\"TKqpOlapAgg\")\n-#else\n-            .AddExpectedPlanOptions(\"CombineCore\")\n-#endif\n             .AddExpectedPlanOptions(\"KqpOlapFilter\");\n \n         TestAggregations({ testCase });\n@@ -748,11 +707,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 FROM `/Root/olapStore/olapTable`\n             )\")\n             .SetExpectedReply(\"[[[2.];[0]]]\")\n-#if SSA_RUNTIME_VERSION >= 2U\n             .AddExpectedPlanOptions(\"TKqpOlapAgg\");\n-#else\n-            .AddExpectedPlanOptions(\"CombineCore\");\n-#endif\n \n         TestAggregations({ testCase });\n     }\n@@ -766,11 +721,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 WHERE id > 5;\n             )\")\n             .SetExpectedReply(\"[[#]]\")\n-#if SSA_RUNTIME_VERSION >= 2U\n             .AddExpectedPlanOptions(\"TKqpOlapAgg\");\n-#else\n-            .AddExpectedPlanOptions(\"CombineCore\");\n-#endif\n \n         TestTableWithNulls({ testCase });\n     }\n@@ -783,11 +734,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 FROM `/Root/tableWithNulls`;\n             )\")\n             .SetExpectedReply(\"[[[3.]]]\")\n-#if SSA_RUNTIME_VERSION >= 2U\n             .AddExpectedPlanOptions(\"TKqpOlapAgg\");\n-#else\n-            .AddExpectedPlanOptions(\"CombineCore\");\n-#endif\n \n         TestTableWithNulls({ testCase });\n     }\n@@ -880,11 +827,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 FROM `/Root/olapStore/olapTable`\n             )\")\n             .SetExpectedReply(\"[[[46000;]]]\")\n-#if SSA_RUNTIME_VERSION >= 2U\n             .AddExpectedPlanOptions(\"TKqpOlapAgg\");\n-#else\n-            .AddExpectedPlanOptions(\"CombineCore\");\n-#endif\n \n         TestAggregations({ testCase });\n     }\n@@ -898,11 +841,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 WHERE id > 5;\n             )\")\n             .SetExpectedReply(\"[[#]]\")\n-#if SSA_RUNTIME_VERSION >= 2U\n             .AddExpectedPlanOptions(\"TKqpOlapAgg\");\n-#else\n-            .AddExpectedPlanOptions(\"CombineCore\");\n-#endif\n \n         TestTableWithNulls({ testCase });\n     }\n@@ -916,11 +855,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 FROM `/Root/tableWithNulls`\n             )\")\n             .SetExpectedReply(\"[[[15];10u;[3.]]]\")\n-#if SSA_RUNTIME_VERSION >= 2U\n             .AddExpectedPlanOptions(\"TKqpOlapAgg\");\n-#else\n-            .AddExpectedPlanOptions(\"CombineCore\");\n-#endif\n \n         TestTableWithNulls({ testCase });\n     }\n@@ -933,11 +868,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 FROM `/Root/tableWithNulls`;\n             )\")\n             .SetExpectedReply(\"[[[15]]]\")\n-#if SSA_RUNTIME_VERSION >= 2U\n             .AddExpectedPlanOptions(\"TKqpOlapAgg\");\n-#else\n-            .AddExpectedPlanOptions(\"CombineCore\");\n-#endif\n \n         TestTableWithNulls({ testCase });\n     }\n@@ -1045,11 +976,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 FROM `/Root/olapStore/olapTable`\n             )\")\n             .SetExpectedReply(\"[[[0]]]\")\n-#if SSA_RUNTIME_VERSION >= 2U\n             .AddExpectedPlanOptions(\"TKqpOlapAgg\");\n-#else\n-            .AddExpectedPlanOptions(\"CombineCore\");\n-#endif\n \n         TestAggregations({ testCase });\n     }\n@@ -1062,11 +989,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 FROM `/Root/olapStore/olapTable`\n             )\")\n             .SetExpectedReply(\"[[[4]]]\")\n-#if SSA_RUNTIME_VERSION >= 2U\n             .AddExpectedPlanOptions(\"TKqpOlapAgg\");\n-#else\n-            .AddExpectedPlanOptions(\"CombineCore\");\n-#endif\n \n         TestAggregations({ testCase });\n     }\n@@ -1122,11 +1045,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 SELECT SOME(level) FROM `/Root/tableWithNulls` WHERE id=1\n             )\")\n             .SetExpectedReply(\"[[[1]]]\")\n-#if SSA_RUNTIME_VERSION >= 2U\n             .AddExpectedPlanOptions(\"TKqpOlapAgg\");\n-#else\n-            .AddExpectedPlanOptions(\"CombineCore\");\n-#endif\n         TestTableWithNulls({ testCase });\n     }\n \n@@ -1136,11 +1055,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 SELECT SOME(level) FROM `/Root/tableWithNulls` WHERE id > 5\n             )\")\n             .SetExpectedReply(\"[[#]]\")\n-#if SSA_RUNTIME_VERSION >= 2U\n             .AddExpectedPlanOptions(\"TKqpOlapAgg\");\n-#else\n-            .AddExpectedPlanOptions(\"CombineCore\");\n-#endif\n         TestTableWithNulls({ testCase });\n     }\n \n@@ -1274,31 +1189,19 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 SELECT id, JSON_VALUE(jsonval, \"$.col1\"), JSON_VALUE(jsondoc, \"$.col1\") FROM `/Root/tableWithNulls`\n                 WHERE JSON_VALUE(jsonval, \"$.col1\") = \"val1\" AND id = 1;\n             )\")\n-#if SSA_RUNTIME_VERSION >= 5U\n-            .AddExpectedPlanOptions(\"KqpOlapApply\")\n-#elif SSA_RUNTIME_VERSION >= 3U\n             .AddExpectedPlanOptions(\"KqpOlapJsonValue\")\n-#else\n-            .AddExpectedPlanOptions(\"Udf\")\n-#endif\n             .SetExpectedReply(R\"([[1;[\"val1\"];#]])\");\n-\n         TestTableWithNulls({testCase});\n     }\n \n+\n     Y_UNIT_TEST(Json_GetValue_Minus) {\n         TAggregationTestCase testCase;\n         testCase.SetQuery(R\"(\n                 SELECT id, JSON_VALUE(jsonval, \"$.'col-abc'\"), JSON_VALUE(jsondoc, \"$.'col-abc'\") FROM `/Root/tableWithNulls`\n                 WHERE JSON_VALUE(jsonval, \"$.'col-abc'\") = \"val-abc\" AND id = 1;\n             )\")\n-#if SSA_RUNTIME_VERSION >= 5U\n-            .AddExpectedPlanOptions(\"KqpOlapApply\")\n-#elif SSA_RUNTIME_VERSION >= 3U\n             .AddExpectedPlanOptions(\"KqpOlapJsonValue\")\n-#else\n-            .AddExpectedPlanOptions(\"Udf\")\n-#endif\n             .SetExpectedReply(R\"([[1;[\"val-abc\"];#]])\");\n \n         TestTableWithNulls({testCase});\n@@ -1310,13 +1213,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 SELECT id, JSON_VALUE(jsonval, \"$.col1\" RETURNING String), JSON_VALUE(jsondoc, \"$.col1\") FROM `/Root/tableWithNulls`\n                 WHERE JSON_VALUE(jsonval, \"$.col1\" RETURNING String) = \"val1\" AND id = 1;\n             )\")\n-#if SSA_RUNTIME_VERSION >= 5U\n-            .AddExpectedPlanOptions(\"KqpOlapApply\")\n-#elif SSA_RUNTIME_VERSION >= 3U\n             .AddExpectedPlanOptions(\"KqpOlapJsonValue\")\n-#else\n-            .AddExpectedPlanOptions(\"Udf\")\n-#endif\n             .SetExpectedReply(R\"([[1;[\"val1\"];#]])\");\n \n         TestTableWithNulls({ testCase });\n@@ -1328,13 +1225,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 SELECT id, JSON_VALUE(jsonval, \"$.obj.obj_col2_int\" RETURNING Int), JSON_VALUE(jsondoc, \"$.obj.obj_col2_int\" RETURNING Int) FROM `/Root/tableWithNulls`\n                 WHERE JSON_VALUE(jsonval, \"$.obj.obj_col2_int\" RETURNING Int) = 16 AND id = 1;\n             )\")\n-#if SSA_RUNTIME_VERSION >= 5U\n-            .AddExpectedPlanOptions(\"KqpOlapApply\")\n-#elif SSA_RUNTIME_VERSION >= 3U\n             .AddExpectedPlanOptions(\"KqpOlapJsonValue\")\n-#else\n-            .AddExpectedPlanOptions(\"Udf\")\n-#endif\n             .SetExpectedReply(R\"([[1;[16];#]])\");\n \n         TestTableWithNulls({ testCase });\n@@ -1346,13 +1237,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 SELECT id, JSON_VALUE(jsonval, \"$.col1\"), JSON_VALUE(jsondoc, \"$.col1\") FROM `/Root/tableWithNulls`\n                 WHERE JSON_VALUE(jsondoc, \"$.col1\") = \"val1\" AND id = 6;\n             )\")\n-#if SSA_RUNTIME_VERSION >= 5U\n-            .AddExpectedPlanOptions(\"KqpOlapApply\")\n-#elif SSA_RUNTIME_VERSION >= 3U\n             .AddExpectedPlanOptions(\"KqpOlapJsonValue\")\n-#else\n-            .AddExpectedPlanOptions(\"Udf\")\n-#endif\n             .SetExpectedReply(R\"([[6;#;[\"val1\"]]])\");\n \n         TestTableWithNulls({ testCase });\n@@ -1364,13 +1249,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 SELECT id, JSON_VALUE(jsonval, \"$.col1\"), JSON_VALUE(jsondoc, \"$.col1\" RETURNING String) FROM `/Root/tableWithNulls`\n                 WHERE JSON_VALUE(jsondoc, \"$.col1\" RETURNING String) = \"val1\" AND id = 6;\n             )\")\n-#if SSA_RUNTIME_VERSION >= 5U\n-            .AddExpectedPlanOptions(\"KqpOlapApply\")\n-#elif SSA_RUNTIME_VERSION >= 3U\n             .AddExpectedPlanOptions(\"KqpOlapJsonValue\")\n-#else\n-            .AddExpectedPlanOptions(\"Udf\")\n-#endif\n             .SetExpectedReply(R\"([[6;#;[\"val1\"]]])\");\n \n         TestTableWithNulls({ testCase });\n@@ -1382,13 +1261,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 SELECT id, JSON_VALUE(jsonval, \"$.obj.obj_col2_int\"), JSON_VALUE(jsondoc, \"$.obj.obj_col2_int\" RETURNING Int) FROM `/Root/tableWithNulls`\n                 WHERE JSON_VALUE(jsondoc, \"$.obj.obj_col2_int\" RETURNING Int) = 16 AND id = 6;\n             )\")\n-#if SSA_RUNTIME_VERSION >= 5U\n-            .AddExpectedPlanOptions(\"KqpOlapApply\")\n-#elif SSA_RUNTIME_VERSION >= 3U\n             .AddExpectedPlanOptions(\"KqpOlapJsonValue\")\n-#else\n-            .AddExpectedPlanOptions(\"Udf\")\n-#endif\n             .SetExpectedReply(R\"([[6;#;[16]]])\");\n \n         TestTableWithNulls({ testCase });\n@@ -1401,13 +1274,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 WHERE\n                     JSON_EXISTS(jsonval, \"$.col1\") AND level = 1;\n             )\")\n-#if SSA_RUNTIME_VERSION >= 5U\n-            .AddExpectedPlanOptions(\"KqpOlapApply\")\n-#elif SSA_RUNTIME_VERSION >= 3U\n             .AddExpectedPlanOptions(\"KqpOlapJsonExists\")\n-#else\n-            .AddExpectedPlanOptions(\"Udf\")\n-#endif\n             .SetExpectedReply(R\"([[1;[%true];#]])\");\n \n         TestTableWithNulls({ testCase });\n@@ -1420,13 +1287,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n                 WHERE\n                     JSON_EXISTS(jsondoc, \"$.col1\") AND id = 6;\n             )\")\n-#if SSA_RUNTIME_VERSION >= 5U\n-            .AddExpectedPlanOptions(\"KqpOlapApply\")\n-#elif SSA_RUNTIME_VERSION >= 3U\n             .AddExpectedPlanOptions(\"KqpOlapJsonExists\")\n-#else\n-            .AddExpectedPlanOptions(\"Udf\")\n-#endif\n             .SetExpectedReply(R\"([[6;#;[%true]]])\");\n \n         TestTableWithNulls({ testCase });\n@@ -1447,6 +1308,26 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {\n         TestTableWithNulls({ testCase });\n     }\n \n+    Y_UNIT_TEST(MixedJsonAndOlapApply) {\n+        TAggregationTestCase testCase;\n+        //(R\"({\"col1\": \"val1\", \"col-abc\": \"val-abc\", \"obj\": {\"obj_col2_int\": 16}})\"\n+        testCase.SetQuery(R\"(\n+                SELECT id, JSON_VALUE(jsonval, \"$.\\\"col-abc\\\"\") FROM `/Root/tableWithNulls`\n+                WHERE id = 1\n+                    AND  JSON_VALUE(jsonval, \"$.col1\") = \"val1\"\n+                    AND  JSON_VALUE(jsonval, \"$.\\\"col-abc\\\"\") ilike \"%A%b%\"\n+                    AND JSON_EXISTS(jsonval, \"$.obj.obj_col2_int\")\n+\n+            )\")\n+            .AddExpectedPlanOptions(\"KqpOlapJsonValue\")\n+            .AddExpectedPlanOptions(\"KqpOlapJsonExists\")\n+            .AddExpectedPlanOptions(\"KqpOlapApply\")\n+            .SetExpectedReply(R\"([[1;[\"val-abc\"]]])\")\n+        ;\n+\n+        TestTableWithNulls({testCase});\n+    }\n+\n     Y_UNIT_TEST(BlockGenericWithDistinct) {\n         TAggregationTestCase testCase;\n         testCase.SetQuery(R\"(\ndiff --git a/ydb/core/kqp/ut/olap/blobs_sharing_ut.cpp b/ydb/core/kqp/ut/olap/blobs_sharing_ut.cpp\nindex 974115f9b6ca..cb222d0a3483 100644\n--- a/ydb/core/kqp/ut/olap/blobs_sharing_ut.cpp\n+++ b/ydb/core/kqp/ut/olap/blobs_sharing_ut.cpp\n@@ -203,68 +203,69 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {\n             Controller->SetOverrideMaxReadStaleness(TDuration::Minutes(5));\n         }\n     };\n-    Y_UNIT_TEST(BlobsSharingSplit1_1) {\n-        TSharingDataTestCase tester(4);\n-        tester.AddRecords(800000);\n-        Sleep(TDuration::Seconds(1));\n-        tester.Execute(0, { 1 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n-    }\n-\n-    Y_UNIT_TEST(BlobsSharingSplit1_1_clean) {\n-        TSharingDataTestCase tester(2);\n-        tester.AddRecords(80000);\n-        CompareYson(tester.GetHelper().GetQueryResult(\"SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`\"), R\"([[80000u;]])\");\n-        Sleep(TDuration::Seconds(1));\n-        tester.Execute(0, { 1 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n-        CompareYson(tester.GetHelper().GetQueryResult(\"SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`\"), R\"([[119928u;]])\");\n-        tester.AddRecords(80000, 0.8);\n-        tester.WaitNormalization();\n-        CompareYson(tester.GetHelper().GetQueryResult(\"SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`\"), R\"([[183928u;]])\");\n-    }\n-\n-    Y_UNIT_TEST(BlobsSharingSplit1_1_clean_with_restarts) {\n-        TSharingDataTestCase tester(2);\n-        tester.SetRebootTablet(true);\n-        tester.AddRecords(80000);\n-        CompareYson(tester.GetHelper().GetQueryResult(\"SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`\"), R\"([[80000u;]])\");\n-        Sleep(TDuration::Seconds(1));\n-        tester.Execute(0, { 1 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n-        CompareYson(tester.GetHelper().GetQueryResult(\"SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`\"), R\"([[119928u;]])\");\n-        tester.AddRecords(80000, 0.8);\n-        tester.WaitNormalization();\n-        CompareYson(tester.GetHelper().GetQueryResult(\"SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`\"), R\"([[183928u;]])\");\n-    }\n-\n-    Y_UNIT_TEST(BlobsSharingSplit3_1) {\n-        TSharingDataTestCase tester(4);\n-        tester.AddRecords(800000);\n-        Sleep(TDuration::Seconds(1));\n-        tester.Execute(0, { 1, 2, 3 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n-    }\n-\n-    Y_UNIT_TEST(BlobsSharingSplit1_3_1) {\n-        TSharingDataTestCase tester(4);\n-        tester.AddRecords(800000);\n-        Sleep(TDuration::Seconds(1));\n-        tester.Execute(1, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n-        tester.Execute(2, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n-        tester.Execute(3, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n-        tester.Execute(0, { 1, 2, 3 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n-    }\n \n-    Y_UNIT_TEST(BlobsSharingSplit1_3_2_1_clean) {\n-        TSharingDataTestCase tester(4);\n-        tester.AddRecords(800000);\n-        Sleep(TDuration::Seconds(1));\n-        tester.Execute(1, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n-        tester.Execute(2, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n-        tester.Execute(3, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n-        tester.AddRecords(800000, 0.9);\n-        Sleep(TDuration::Seconds(1));\n-        tester.Execute(3, { 2 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n-        tester.Execute(0, { 1, 2 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n-        tester.WaitNormalization();\n-    }\n+    // Y_UNIT_TEST(BlobsSharingSplit1_1) {\n+    //     TSharingDataTestCase tester(4);\n+    //     tester.AddRecords(800000);\n+    //     Sleep(TDuration::Seconds(1));\n+    //     tester.Execute(0, { 1 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n+    // }\n+\n+    // Y_UNIT_TEST(BlobsSharingSplit1_1_clean) {\n+    //     TSharingDataTestCase tester(2);\n+    //     tester.AddRecords(80000);\n+    //     CompareYson(tester.GetHelper().GetQueryResult(\"SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`\"), R\"([[80000u;]])\");\n+    //     Sleep(TDuration::Seconds(1));\n+    //     tester.Execute(0, { 1 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n+    //     CompareYson(tester.GetHelper().GetQueryResult(\"SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`\"), R\"([[119928u;]])\");\n+    //     tester.AddRecords(80000, 0.8);\n+    //     tester.WaitNormalization();\n+    //     CompareYson(tester.GetHelper().GetQueryResult(\"SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`\"), R\"([[183928u;]])\");\n+    // }\n+\n+    // Y_UNIT_TEST(BlobsSharingSplit1_1_clean_with_restarts) {\n+    //     TSharingDataTestCase tester(2);\n+    //     tester.SetRebootTablet(true);\n+    //     tester.AddRecords(80000);\n+    //     CompareYson(tester.GetHelper().GetQueryResult(\"SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`\"), R\"([[80000u;]])\");\n+    //     Sleep(TDuration::Seconds(1));\n+    //     tester.Execute(0, { 1 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n+    //     CompareYson(tester.GetHelper().GetQueryResult(\"SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`\"), R\"([[119928u;]])\");\n+    //     tester.AddRecords(80000, 0.8);\n+    //     tester.WaitNormalization();\n+    //     CompareYson(tester.GetHelper().GetQueryResult(\"SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`\"), R\"([[183928u;]])\");\n+    // }\n+\n+    // Y_UNIT_TEST(BlobsSharingSplit3_1) {\n+    //     TSharingDataTestCase tester(4);\n+    //     tester.AddRecords(800000);\n+    //     Sleep(TDuration::Seconds(1));\n+    //     tester.Execute(0, { 1, 2, 3 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n+    // }\n+\n+    // Y_UNIT_TEST(BlobsSharingSplit1_3_1) {\n+    //     TSharingDataTestCase tester(4);\n+    //     tester.AddRecords(800000);\n+    //     Sleep(TDuration::Seconds(1));\n+    //     tester.Execute(1, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n+    //     tester.Execute(2, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n+    //     tester.Execute(3, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n+    //     tester.Execute(0, { 1, 2, 3 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n+    // }\n+\n+    // Y_UNIT_TEST(BlobsSharingSplit1_3_2_1_clean) {\n+    //     TSharingDataTestCase tester(4);\n+    //     tester.AddRecords(800000);\n+    //     Sleep(TDuration::Seconds(1));\n+    //     tester.Execute(1, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n+    //     tester.Execute(2, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n+    //     tester.Execute(3, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n+    //     tester.AddRecords(800000, 0.9);\n+    //     Sleep(TDuration::Seconds(1));\n+    //     tester.Execute(3, { 2 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n+    //     tester.Execute(0, { 1, 2 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });\n+    //     tester.WaitNormalization();\n+    // }\n \n     class TReshardingTest {\n     public:\n@@ -398,13 +399,13 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {\n         }\n     };\n \n-    Y_UNIT_TEST(TableReshardingConsistency64) {\n-        TShardingTypeTest().SetShardingType(\"HASH_FUNCTION_CONSISTENCY_64\").Execute();\n-    }\n+    // Y_UNIT_TEST(TableReshardingConsistency64) {\n+    //     TShardingTypeTest().SetShardingType(\"HASH_FUNCTION_CONSISTENCY_64\").Execute();\n+    // }\n \n-    Y_UNIT_TEST(TableReshardingModuloN) {\n-        TShardingTypeTest().SetShardingType(\"HASH_FUNCTION_MODULO_N\").Execute();\n-    }\n+    // Y_UNIT_TEST(TableReshardingModuloN) {\n+    //     TShardingTypeTest().SetShardingType(\"HASH_FUNCTION_MODULO_N\").Execute();\n+    // }\n \n     class TAsyncReshardingTest: public TReshardingTest {\n         YDB_ACCESSOR(TString, ShardingType, \"HASH_FUNCTION_CONSISTENCY_64\");\n@@ -482,24 +483,24 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {\n         ui64 HasNewCol = false;\n     };\n \n-    Y_UNIT_TEST(UpsertWhileSplitTest) {\n-        TAsyncReshardingTest tester;\n+    // Y_UNIT_TEST(UpsertWhileSplitTest) {\n+    //     TAsyncReshardingTest tester;\n \n-        tester.AddBatch(10000);\n+    //     tester.AddBatch(10000);\n \n-        tester.CheckCount();\n+    //     tester.CheckCount();\n \n-        for (int i = 0; i < 4; i++) {\n-            tester.StartResharding(\"SPLIT\");\n+    //     for (int i = 0; i < 4; i++) {\n+    //         tester.StartResharding(\"SPLIT\");\n \n-            tester.CheckCount();\n-            tester.AddBatch(10000);\n-            tester.CheckCount();\n-            tester.WaitResharding();\n-        }\n-        tester.AddBatch(10000);\n-        tester.CheckCount();\n-    }\n+    //         tester.CheckCount();\n+    //         tester.AddBatch(10000);\n+    //         tester.CheckCount();\n+    //         tester.WaitResharding();\n+    //     }\n+    //     tester.AddBatch(10000);\n+    //     tester.CheckCount();\n+    // }\n \n     Y_UNIT_TEST(SplitEmpty) {\n         TAsyncReshardingTest tester;\n@@ -513,171 +514,171 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {\n         tester.CheckCount();\n     }\n \n-    Y_UNIT_TEST(ChangeSchemaAndSplit) {\n-        TAsyncReshardingTest tester;\n-        tester.DisableCompaction();\n+    // Y_UNIT_TEST(ChangeSchemaAndSplit) {\n+    //     TAsyncReshardingTest tester;\n+    //     tester.DisableCompaction();\n \n-        tester.AddBatch(10000);\n-        tester.ChangeSchema();\n-        tester.AddBatch(10000);\n+    //     tester.AddBatch(10000);\n+    //     tester.ChangeSchema();\n+    //     tester.AddBatch(10000);\n \n-        tester.StartResharding(\"SPLIT\");\n-        tester.WaitResharding();\n+    //     tester.StartResharding(\"SPLIT\");\n+    //     tester.WaitResharding();\n \n-        tester.RestartAllShards();\n+    //     tester.RestartAllShards();\n \n-        tester.CheckCount();\n-    }\n+    //     tester.CheckCount();\n+    // }\n \n-    Y_UNIT_TEST(MultipleSchemaVersions) {\n-        TAsyncReshardingTest tester;\n-        tester.DisableCompaction();\n+    // Y_UNIT_TEST(MultipleSchemaVersions) {\n+    //     TAsyncReshardingTest tester;\n+    //     tester.DisableCompaction();\n \n-        for (int i = 0; i < 3; i++) {\n-            tester.AddBatch(1);\n-            tester.ChangeSchema();\n-        }\n+    //     for (int i = 0; i < 3; i++) {\n+    //         tester.AddBatch(1);\n+    //         tester.ChangeSchema();\n+    //     }\n \n-        tester.StartResharding(\"SPLIT\");\n-        tester.WaitResharding();\n+    //     tester.StartResharding(\"SPLIT\");\n+    //     tester.WaitResharding();\n \n-        tester.RestartAllShards();\n+    //     tester.RestartAllShards();\n \n-        tester.CheckCount();\n-    }\n+    //     tester.CheckCount();\n+    // }\n \n-    Y_UNIT_TEST(HugeSchemeHistory) {\n-        TAsyncReshardingTest tester;\n-        tester.DisableCompaction();\n+    // Y_UNIT_TEST(HugeSchemeHistory) {\n+    //     TAsyncReshardingTest tester;\n+    //     tester.DisableCompaction();\n \n-        tester.AddManyColumns();\n+    //     tester.AddManyColumns();\n \n-        for (int i = 0; i < 100; i++) {\n-            tester.AddBatch(1);\n-            tester.ChangeSchema();\n-        }\n+    //     for (int i = 0; i < 100; i++) {\n+    //         tester.AddBatch(1);\n+    //         tester.ChangeSchema();\n+    //     }\n \n-        tester.StartResharding(\"SPLIT\");\n-        tester.WaitResharding();\n+    //     tester.StartResharding(\"SPLIT\");\n+    //     tester.WaitResharding();\n \n-        tester.RestartAllShards();\n+    //     tester.RestartAllShards();\n \n-        tester.CheckCount();\n-    }\n+    //     tester.CheckCount();\n+    // }\n \n-    Y_UNIT_TEST(MultipleMerge) {\n-        TAsyncReshardingTest tester;\n-        tester.DisableCompaction();\n+    // Y_UNIT_TEST(MultipleMerge) {\n+    //     TAsyncReshardingTest tester;\n+    //     tester.DisableCompaction();\n \n-        tester.AddBatch(10000);\n+    //     tester.AddBatch(10000);\n \n-        for (int i = 0; i < 4; i++) {\n-            tester.StartResharding(\"MERGE\");\n-            tester.WaitResharding();\n-        }\n+    //     for (int i = 0; i < 4; i++) {\n+    //         tester.StartResharding(\"MERGE\");\n+    //         tester.WaitResharding();\n+    //     }\n \n-        tester.RestartAllShards();\n+    //     tester.RestartAllShards();\n \n-        tester.CheckCount();\n-    }\n+    //     tester.CheckCount();\n+    // }\n \n-    Y_UNIT_TEST(MultipleSplits) {\n-        TAsyncReshardingTest tester;\n-        tester.DisableCompaction();\n+    // Y_UNIT_TEST(MultipleSplits) {\n+    //     TAsyncReshardingTest tester;\n+    //     tester.DisableCompaction();\n \n-        tester.AddBatch(10000);\n+    //     tester.AddBatch(10000);\n \n-        for (int i = 0; i < 4; i++) {\n-            tester.StartResharding(\"SPLIT\");\n-            tester.WaitResharding();\n-        }\n+    //     for (int i = 0; i < 4; i++) {\n+    //         tester.StartResharding(\"SPLIT\");\n+    //         tester.WaitResharding();\n+    //     }\n \n-        tester.RestartAllShards();\n+    //     tester.RestartAllShards();\n \n-        tester.CheckCount();\n-    }\n+    //     tester.CheckCount();\n+    // }\n \n-    Y_UNIT_TEST(MultipleSplitsThenMerges) {\n-        TAsyncReshardingTest tester;\n-        tester.DisableCompaction();\n+    // Y_UNIT_TEST(MultipleSplitsThenMerges) {\n+    //     TAsyncReshardingTest tester;\n+    //     tester.DisableCompaction();\n \n-        tester.AddBatch(10000);\n+    //     tester.AddBatch(10000);\n \n-        for (int i = 0; i < 4; i++) {\n-            tester.StartResharding(\"SPLIT\");\n-            tester.WaitResharding();\n-        }\n+    //     for (int i = 0; i < 4; i++) {\n+    //         tester.StartResharding(\"SPLIT\");\n+    //         tester.WaitResharding();\n+    //     }\n \n-        for (int i = 0; i < 8; i++) {\n-            tester.StartResharding(\"MERGE\");\n-            tester.WaitResharding();\n-        }\n+    //     for (int i = 0; i < 8; i++) {\n+    //         tester.StartResharding(\"MERGE\");\n+    //         tester.WaitResharding();\n+    //     }\n \n-        tester.RestartAllShards();\n+    //     tester.RestartAllShards();\n \n-        tester.CheckCount();\n-    }\n+    //     tester.CheckCount();\n+    // }\n \n-    Y_UNIT_TEST(MultipleSplitsWithRestartsAfterWait) {\n-        TAsyncReshardingTest tester;\n-        tester.DisableCompaction();\n+    // Y_UNIT_TEST(MultipleSplitsWithRestartsAfterWait) {\n+    //     TAsyncReshardingTest tester;\n+    //     tester.DisableCompaction();\n \n-        tester.AddBatch(10000);\n+    //     tester.AddBatch(10000);\n \n-        for (int i = 0; i < 4; i++) {\n-            tester.StartResharding(\"SPLIT\");\n-            tester.WaitResharding();\n-            tester.RestartAllShards();\n-        }\n+    //     for (int i = 0; i < 4; i++) {\n+    //         tester.StartResharding(\"SPLIT\");\n+    //         tester.WaitResharding();\n+    //         tester.RestartAllShards();\n+    //     }\n \n-        tester.CheckCount();\n-    }\n+    //     tester.CheckCount();\n+    // }\n \n-    Y_UNIT_TEST(MultipleSplitsWithRestartsWhenWait) {\n-        TAsyncReshardingTest tester;\n-        tester.DisableCompaction();\n+    // Y_UNIT_TEST(MultipleSplitsWithRestartsWhenWait) {\n+    //     TAsyncReshardingTest tester;\n+    //     tester.DisableCompaction();\n \n-        tester.AddBatch(10000);\n+    //     tester.AddBatch(10000);\n \n-        for (int i = 0; i < 4; i++) {\n-            tester.StartResharding(\"SPLIT\");\n-            tester.RestartAllShards();\n-            tester.WaitResharding();\n-        }\n-        tester.RestartAllShards();\n+    //     for (int i = 0; i < 4; i++) {\n+    //         tester.StartResharding(\"SPLIT\");\n+    //         tester.RestartAllShards();\n+    //         tester.WaitResharding();\n+    //     }\n+    //     tester.RestartAllShards();\n \n-        tester.CheckCount();\n-    }\n+    //     tester.CheckCount();\n+    // }\n \n-    Y_UNIT_TEST(MultipleMergesWithRestartsAfterWait) {\n-        TAsyncReshardingTest tester;\n-        tester.DisableCompaction();\n+    // Y_UNIT_TEST(MultipleMergesWithRestartsAfterWait) {\n+    //     TAsyncReshardingTest tester;\n+    //     tester.DisableCompaction();\n \n-        tester.AddBatch(10000);\n+    //     tester.AddBatch(10000);\n \n-        for (int i = 0; i < 4; i++) {\n-            tester.StartResharding(\"MERGE\");\n-            tester.WaitResharding();\n-            tester.RestartAllShards();\n-        }\n+    //     for (int i = 0; i < 4; i++) {\n+    //         tester.StartResharding(\"MERGE\");\n+    //         tester.WaitResharding();\n+    //         tester.RestartAllShards();\n+    //     }\n \n-        tester.CheckCount();\n-    }\n+    //     tester.CheckCount();\n+    // }\n \n-    Y_UNIT_TEST(MultipleMergesWithRestartsWhenWait) {\n-        TAsyncReshardingTest tester;\n-        tester.DisableCompaction();\n+    // Y_UNIT_TEST(MultipleMergesWithRestartsWhenWait) {\n+    //     TAsyncReshardingTest tester;\n+    //     tester.DisableCompaction();\n \n-        tester.AddBatch(10000);\n+    //     tester.AddBatch(10000);\n \n-        for (int i = 0; i < 4; i++) {\n-            tester.StartResharding(\"MERGE\");\n-            tester.RestartAllShards();\n-            tester.WaitResharding();\n-        }\n-        tester.RestartAllShards();\n+    //     for (int i = 0; i < 4; i++) {\n+    //         tester.StartResharding(\"MERGE\");\n+    //         tester.RestartAllShards();\n+    //         tester.WaitResharding();\n+    //     }\n+    //     tester.RestartAllShards();\n \n-        tester.CheckCount();\n-    }\n+    //     tester.CheckCount();\n+    // }\n }\n }\ndiff --git a/ydb/core/kqp/ut/olap/helpers/get_value.cpp b/ydb/core/kqp/ut/olap/helpers/get_value.cpp\nindex 617e78da59aa..5e39202426ef 100644\n--- a/ydb/core/kqp/ut/olap/helpers/get_value.cpp\n+++ b/ydb/core/kqp/ut/olap/helpers/get_value.cpp\n@@ -61,9 +61,24 @@ void PrintValue(IOutputStream& out, const NYdb::TValue& v) {\n             out << value.GetBool();\n             break;\n         }\n+        case NYdb::EPrimitiveType::String:\n+        {\n+            out << value.GetString();\n+            break;\n+        }\n+        case NYdb::EPrimitiveType::Json:\n+        {\n+            out << value.GetJson();\n+            break;\n+        }\n+        case NYdb::EPrimitiveType::JsonDocument:\n+        {\n+            out << value.GetJsonDocument();\n+            break;\n+        }\n         default:\n         {\n-            UNIT_ASSERT_C(false, \"PrintValue not iplemented for this type\");\n+            UNIT_ASSERT_C(false, TStringBuilder() << \"PrintValue not iplemented for this type: \" << (ui64)value.GetPrimitiveType());\n         }\n     }\n }\ndiff --git a/ydb/core/kqp/ut/olap/indexes_ut.cpp b/ydb/core/kqp/ut/olap/indexes_ut.cpp\nindex 95156c78a59c..0cca7681e135 100644\n--- a/ydb/core/kqp/ut/olap/indexes_ut.cpp\n+++ b/ydb/core/kqp/ut/olap/indexes_ut.cpp\n@@ -14,6 +14,43 @@\n namespace NKikimr::NKqp {\n \n Y_UNIT_TEST_SUITE(KqpOlapIndexes) {\n+    Y_UNIT_TEST(TablesInStore) {\n+        auto settings = TKikimrSettings().SetWithSampleTables(false);\n+        TKikimrRunner kikimr(settings);\n+\n+        TLocalHelper(kikimr).CreateTestOlapTable();\n+\n+        auto tableClient = kikimr.GetTableClient();\n+        {\n+            auto alterQuery =\n+                R\"(ALTER OBJECT `/Root/olapStore` (TYPE TABLESTORE) SET (ACTION=UPSERT_INDEX, NAME=index_ngramm_uid, TYPE=BLOOM_NGRAMM_FILTER,\n+                    FEATURES=`{\"column_name\" : \"resource_id\", \"ngramm_size\" : 3, \"hashes_count\" : 2, \"filter_size_bytes\" : 512, \"records_count\" : 1024}`);\n+                )\";\n+            auto session = tableClient.CreateSession().GetValueSync().GetSession();\n+            auto alterResult = session.ExecuteSchemeQuery(alterQuery).GetValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(alterResult.GetStatus(), NYdb::EStatus::SUCCESS, alterResult.GetIssues().ToString());\n+        }\n+        {\n+            auto session = tableClient.CreateSession().GetValueSync().GetSession();\n+\n+            auto query = TStringBuilder() << R\"(\n+            --!syntax_v1\n+            CREATE TABLE `/Root/olapStore/olapTableTest`\n+            (\n+                timestamp Timestamp NOT NULL,\n+                resource_id Utf8,\n+                uid Utf8 NOT NULL,\n+                level Int32,\n+                message Utf8,\n+                PRIMARY KEY (timestamp, uid)\n+            )\n+            PARTITION BY HASH(timestamp, uid)\n+            WITH (STORE = COLUMN, PARTITION_COUNT = 1))\";\n+            auto result = session.ExecuteSchemeQuery(query).GetValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), NYdb::EStatus::SUCCESS, result.GetIssues().ToString());\n+        }\n+    }\n+\n     Y_UNIT_TEST(IndexesActualization) {\n         auto settings = TKikimrSettings().SetWithSampleTables(false);\n         TKikimrRunner kikimr(settings);\ndiff --git a/ydb/core/kqp/ut/olap/json_ut.cpp b/ydb/core/kqp/ut/olap/json_ut.cpp\nindex 4a6822f05523..d3fdb06e4e89 100644\n--- a/ydb/core/kqp/ut/olap/json_ut.cpp\n+++ b/ydb/core/kqp/ut/olap/json_ut.cpp\n@@ -5,14 +5,19 @@\n #include \"helpers/writer.h\"\n \n #include <ydb/core/base/tablet_pipecache.h>\n+#include <ydb/core/formats/arrow/serializer/native.h>\n #include <ydb/core/kqp/ut/common/columnshard.h>\n-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>\n #include <ydb/core/tx/columnshard/engines/reader/common_reader/iterator/source.h>\n #include <ydb/core/tx/columnshard/hooks/testing/controller.h>\n+#include <ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h>\n #include <ydb/core/tx/columnshard/test_helper/controllers.h>\n #include <ydb/core/tx/limiter/grouped_memory/service/process.h>\n #include <ydb/core/wrappers/fake_storage.h>\n \n+#include <ydb/library/signals/object_counter.h>\n+#include <ydb/public/lib/scheme_types/scheme_type_id.h>\n+\n+#include <library/cpp/string_utils/base64/base64.h>\n #include <library/cpp/testing/unittest/registar.h>\n #include <util/string/strip.h>\n \n@@ -106,15 +111,15 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n             Cerr << \"HEADER:\" << hNoData << \"/\" << hSkip << \"/\" << hApproves << Endl;\n             if (ExpectIndexSkip) {\n                 AFL_VERIFY(iSkip + hSkip == *ExpectIndexSkip)(\"expect\", ExpectIndexSkip)(\"ireal\", iSkip)(\"hreal\", hSkip)(\n-                                     \"current\", controller->GetIndexesSkippingOnSelect().Val())(\"pred\", indexSkipStart);\n+                                            \"current\", controller->GetIndexesSkippingOnSelect().Val())(\"pred\", indexSkipStart);\n             }\n             if (ExpectIndexNoData) {\n                 AFL_VERIFY(iNoData == *ExpectIndexNoData)(\"expect\", ExpectIndexNoData)(\"real\", iNoData)(\n-                                       \"current\", controller->GetIndexesSkippedNoData().Val())(\"pred\", indexNoDataStart);\n+                                        \"current\", controller->GetIndexesSkippedNoData().Val())(\"pred\", indexNoDataStart);\n             }\n             if (ExpectIndexApprove) {\n                 AFL_VERIFY(iApproves == *ExpectIndexApprove)(\"expect\", ExpectIndexApprove)(\"real\", iApproves)(\n-                                         \"current\", controller->GetIndexesApprovedOnSelect().Val())(\"pred\", indexApproveStart);\n+                                          \"current\", controller->GetIndexesApprovedOnSelect().Val())(\"pred\", indexApproveStart);\n             }\n             return TConclusionStatus::Success();\n         }\n@@ -243,6 +248,47 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n         }\n     };\n \n+    class TBulkUpsertCommand: public ICommand {\n+    private:\n+        TString TableName;\n+        TString ArrowBatch;\n+        Ydb::StatusIds_StatusCode ExpectedCode = Ydb::StatusIds::SUCCESS;\n+\n+    public:\n+        TBulkUpsertCommand() = default;\n+\n+        virtual TConclusionStatus DoExecute(TKikimrRunner& kikimr) override {\n+            TLocalHelper lHelper(kikimr);\n+            lHelper.SendDataViaActorSystem(TableName,\n+                NArrow::TStatusValidator::GetValid(NArrow::NSerialization::TNativeSerializer().Deserialize(ArrowBatch)), ExpectedCode);\n+            return TConclusionStatus::Success();\n+        }\n+\n+        bool DeserializeFromString(const TString& info) {\n+            auto lines = StringSplitter(info).SplitBySet(\"\\n\").SkipEmpty().ToList<TString>();\n+            if (lines.size() < 2 || lines.size() > 3) {\n+                return false;\n+            }\n+            TableName = Strip(lines[0]);\n+            ArrowBatch = Base64Decode(Strip(lines[1]));\n+            AFL_VERIFY(!!ArrowBatch);\n+            if (lines.size() == 3) {\n+                if (!Ydb::StatusIds_StatusCode_Parse(Strip(lines[2]), &ExpectedCode)) {\n+                    return false;\n+                }\n+                //                if (lines[2] == \"SUCCESS\") {\n+                //                } else if (lines[2] = \"INTERNAL_ERROR\") {\n+                //                    ExpectedCode = Ydb::StatusIds::INTERNAL_ERROR;\n+                //                } else if (lines[2] == \"BAD_REQUEST\") {\n+                //                    ExpectedCode = Ydb::StatusIds::BAD_REQUEST;\n+                //                } else {\n+                //                    return false;\n+                //                }\n+            }\n+            return true;\n+        }\n+    };\n+\n     class TScriptExecutor {\n     private:\n         std::vector<std::shared_ptr<ICommand>> Commands;\n@@ -275,7 +321,12 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n     private:\n         std::vector<TScriptExecutor> Scripts;\n         std::shared_ptr<ICommand> BuildCommand(TString command) {\n-            if (command.StartsWith(\"SCHEMA:\")) {\n+            if (command.StartsWith(\"BULK_UPSERT:\")) {\n+                command = command.substr(12);\n+                auto result = std::make_shared<TBulkUpsertCommand>();\n+                AFL_VERIFY(result->DeserializeFromString(command));\n+                return result;\n+            } else if (command.StartsWith(\"SCHEMA:\")) {\n                 command = command.substr(7);\n                 return std::make_shared<TSchemaCommand>(command);\n             } else if (command.StartsWith(\"DATA:\")) {\n@@ -341,7 +392,13 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n \n     public:\n         TScriptVariator(const TString& script) {\n-            auto commands = StringSplitter(script).SplitByString(\"------\").ToList<TString>();\n+            auto lines = StringSplitter(script).SplitByString(\"\\n\").ToList<TString>();\n+            lines.erase(std::remove_if(lines.begin(), lines.end(),\n+                            [](const TString& l) {\n+                                return Strip(l).StartsWith(\"#\");\n+                            }),\n+                lines.end());\n+            auto commands = StringSplitter(JoinSeq(\"\\n\", lines)).SplitByString(\"------\").ToList<TString>();\n             std::vector<std::vector<std::shared_ptr<ICommand>>> commandsDescription;\n             for (auto&& i : commands) {\n                 auto& cVariants = commandsDescription.emplace_back();\n@@ -380,8 +437,8 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)\n             ------\n             SCHEMA:\n-            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, \n-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`,\n+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n             ------\n             DATA:\n             REPLACE INTO `/Root/ColumnTable` (Col1) VALUES (1u), (2u), (3u), (4u)\n@@ -413,7 +470,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)\n             ------\n             SCHEMA:\n-            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5|1$$`)\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `FORCE_SIMD_PARSING`=`$$true|false$$`, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5|1$$`)\n             ------\n             DATA:\n             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES (1u, JsonDocument('{\"a\" : \"\", \"b\" : \"\", \"c\" : \"\"}'))\n@@ -441,7 +498,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n             ------\n             SCHEMA:\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, \n-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n             ------\n             DATA:\n             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{\"a.b.c\" : \"a1\", \"b.c.d\" : \"b1\", \"c.d.e\" : \"c1\"}')), (2u, JsonDocument('{\"a.b.c\" : \"a2\"}')),\n@@ -469,18 +526,147 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)\n             ------\n             SCHEMA:\n-            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, \n-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_EXTRACTOR_CLASS_NAME`=`JSON_SCANNER`, `SCAN_FIRST_LEVEL_ONLY`=`false`, \n+                      `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`,\n+                      `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n             ------\n             DATA:\n-            REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{\"a\" : \"a1\", \"b\" : \"b1\", \"c\" : \"c1\"}')), (2u, JsonDocument('{\"a\" : \"a2\"}')),\n+            REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{\"a\" : \"a1\", \"b\" : \"b1\", \"c\" : \"c1\", \"d\" : null, \"e.v\" : {\"c\" : 1, \"e\" : {\"c.a\" : 2}}}')), (2u, JsonDocument('{\"a\" : \"a2\"}')),\n                                                                     (3u, JsonDocument('{\"b\" : \"b3\", \"d\" : \"d3\"}')), (4u, JsonDocument('{\"b\" : \"b4asdsasdaa\", \"a\" : \"a4\"}'))\n             ------\n             READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.a\") = \"a2\" ORDER BY Col1;\n             EXPECTED: [[2u;[\"{\\\"a\\\":\\\"a2\\\"}\"]]]\n             ------\n             READ: SELECT * FROM `/Root/ColumnTable` ORDER BY Col1;\n-            EXPECTED: [[1u;[\"{\\\"a\\\":\\\"a1\\\",\\\"b\\\":\\\"b1\\\",\\\"c\\\":\\\"c1\\\"}\"]];[2u;[\"{\\\"a\\\":\\\"a2\\\"}\"]];[3u;[\"{\\\"b\\\":\\\"b3\\\",\\\"d\\\":\\\"d3\\\"}\"]];[4u;[\"{\\\"a\\\":\\\"a4\\\",\\\"b\\\":\\\"b4asdsasdaa\\\"}\"]]]\n+            EXPECTED: [[1u;[\"{\\\"a\\\":\\\"a1\\\",\\\"b\\\":\\\"b1\\\",\\\"c\\\":\\\"c1\\\",\\\"d\\\":\\\"NULL\\\",\\\"e.v\\\":{\\\"c\\\":\\\"1\\\",\\\"e\\\":{\\\"c.a\\\":\\\"2\\\"}}}\"]];[2u;[\"{\\\"a\\\":\\\"a2\\\"}\"]];[3u;[\"{\\\"b\\\":\\\"b3\\\",\\\"d\\\":\\\"d3\\\"}\"]];[4u;[\"{\\\"a\\\":\\\"a4\\\",\\\"b\\\":\\\"b4asdsasdaa\\\"}\"]]]\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"e.v\\\".c\") = \"1\" ORDER BY Col1;\n+            EXPECTED: [[1u;[\"{\\\"a\\\":\\\"a1\\\",\\\"b\\\":\\\"b1\\\",\\\"c\\\":\\\"c1\\\",\\\"d\\\":\\\"NULL\\\",\\\"e.v\\\":{\\\"c\\\":\\\"1\\\",\\\"e\\\":{\\\"c.a\\\":\\\"2\\\"}}}\"]]]\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"e.v\\\".e.\\\"c.a\\\"\") = \"2\" ORDER BY Col1;\n+            EXPECTED: [[1u;[\"{\\\"a\\\":\\\"a1\\\",\\\"b\\\":\\\"b1\\\",\\\"c\\\":\\\"c1\\\",\\\"d\\\":\\\"NULL\\\",\\\"e.v\\\":{\\\"c\\\":\\\"1\\\",\\\"e\\\":{\\\"c.a\\\":\\\"2\\\"}}}\"]]]\n+            \n+        )\";\n+        TScriptVariator(script).Execute();\n+    }\n+\n+    Y_UNIT_TEST(RestoreFirstLevelVariants) {\n+        TString script = R\"(\n+            SCHEMA:            \n+            CREATE TABLE `/Root/ColumnTable` (\n+                Col1 Uint64 NOT NULL,\n+                Col2 JsonDocument,\n+                PRIMARY KEY (Col1)\n+            )\n+            PARTITION BY HASH(Col1)\n+            WITH (STORE = COLUMN, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = $$1|2|10$$);\n+            ------\n+            SCHEMA:\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)\n+            ------\n+            SCHEMA:\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_EXTRACTOR_CLASS_NAME`=`JSON_SCANNER`, `SCAN_FIRST_LEVEL_ONLY`=`true`, \n+                      `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`,\n+                      `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+            ------\n+            DATA:\n+            REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{\"a\" : \"a1\", \"b\" : \"b1\", \"c\" : \"c1\", \"d\" : null, \"e.v\" : {\"c\" : 1, \"e\" : {\"c.a\" : 2}}}')), (2u, JsonDocument('{\"a\" : \"a2\"}')),\n+                                                                    (3u, JsonDocument('{\"b\" : \"b3\", \"d\" : \"d3\", \"e\" : [\"a\", {\"v\" : [\"c\", 5]}]}')), (4u, JsonDocument('{\"b\" : \"b4asdsasdaa\", \"a\" : \"a4\"}'))\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` ORDER BY Col1;\n+            EXPECTED: [[1u;[\"{\\\"a\\\":\\\"a1\\\",\\\"b\\\":\\\"b1\\\",\\\"c\\\":\\\"c1\\\",\\\"d\\\":\\\"NULL\\\",\\\"e.v\\\":\\\"{\\\\\\\"c\\\\\\\":1,\\\\\\\"e\\\\\\\":{\\\\\\\"c.a\\\\\\\":2}}\\\"}\"]];[2u;[\"{\\\"a\\\":\\\"a2\\\"}\"]];[3u;[\"{\\\"b\\\":\\\"b3\\\",\\\"d\\\":\\\"d3\\\",\\\"e\\\":\\\"[\\\\\\\"a\\\\\\\",{\\\\\\\"v\\\\\\\":[\\\\\\\"c\\\\\\\",5]}]\\\"}\"]];[4u;[\"{\\\"a\\\":\\\"a4\\\",\\\"b\\\":\\\"b4asdsasdaa\\\"}\"]]]\n+            \n+        )\";\n+        TScriptVariator(script).Execute();\n+    }\n+\n+    Y_UNIT_TEST(RestoreFullJsonVariants) {\n+        TString script = R\"(\n+            SCHEMA:            \n+            CREATE TABLE `/Root/ColumnTable` (\n+                Col1 Uint64 NOT NULL,\n+                Col2 JsonDocument,\n+                PRIMARY KEY (Col1)\n+            )\n+            PARTITION BY HASH(Col1)\n+            WITH (STORE = COLUMN, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = $$1|2|10$$);\n+            ------\n+            SCHEMA:\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)\n+            ------\n+            SCHEMA:\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_EXTRACTOR_CLASS_NAME`=`JSON_SCANNER`, `SCAN_FIRST_LEVEL_ONLY`=`false`, \n+                      `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`,\n+                      `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+            ------\n+            DATA:\n+            REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{\"a\" : \"a1\", \"b\" : \"b1\", \"c\" : \"c1\", \"d\" : null, \"e.v\" : {\"c\" : 1, \"e\" : {\"c.a\" : 2}}}')), (2u, JsonDocument('{\"a\" : \"a2\"}')),\n+                                                                    (3u, JsonDocument('{\"b\" : \"b3\", \"d\" : \"d3\", \"e\" : [\"a\", {\"v\" : [\"c\", 5]}]}')), (4u, JsonDocument('{\"b\" : \"b4asdsasdaa\", \"a\" : \"a4\"}'))\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` ORDER BY Col1;\n+            EXPECTED: [[1u;[\"{\\\"a\\\":\\\"a1\\\",\\\"b\\\":\\\"b1\\\",\\\"c\\\":\\\"c1\\\",\\\"d\\\":\\\"NULL\\\",\\\"e.v\\\":{\\\"c\\\":\\\"1\\\",\\\"e\\\":{\\\"c.a\\\":\\\"2\\\"}}}\"]];[2u;[\"{\\\"a\\\":\\\"a2\\\"}\"]];[3u;[\"{\\\"b\\\":\\\"b3\\\",\\\"d\\\":\\\"d3\\\",\\\"e\\\":[\\\"a\\\",{\\\"v\\\":[\\\"c\\\",\\\"5\\\"]}]}\"]];[4u;[\"{\\\"a\\\":\\\"a4\\\",\\\"b\\\":\\\"b4asdsasdaa\\\"}\"]]]\n+            \n+        )\";\n+        TScriptVariator(script).Execute();\n+    }\n+\n+    Y_UNIT_TEST(BrokenJsonWriting) {\n+        NColumnShard::TTableUpdatesBuilder updates(NArrow::MakeArrowSchema(\n+            { { \"Col1\", NScheme::TTypeInfo(NScheme::NTypeIds::Uint64) }, { \"Col2\", NScheme::TTypeInfo(NScheme::NTypeIds::Utf8) } }));\n+        updates.AddRow().Add<int64_t>(1).Add(\"{\\\"a\\\" : \\\"c}\");\n+        auto arrowString = Base64Encode(NArrow::NSerialization::TNativeSerializer().SerializeFull(updates.BuildArrow()));\n+\n+        TString script = Sprintf(R\"(\n+            SCHEMA:            \n+            CREATE TABLE `/Root/ColumnTable` (\n+                Col1 Uint64 NOT NULL,\n+                Col2 JsonDocument,\n+                PRIMARY KEY (Col1)\n+            )\n+            PARTITION BY HASH(Col1)\n+            WITH (STORE = COLUMN, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = $$1|2|10$$);\n+            ------\n+            SCHEMA:\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)\n+            ------\n+            SCHEMA:\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_EXTRACTOR_CLASS_NAME`=`JSON_SCANNER`, `SCAN_FIRST_LEVEL_ONLY`=`false`, \n+                      `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`,\n+                      `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+            ------\n+            BULK_UPSERT:\n+                /Root/ColumnTable\n+                %s\n+                BAD_REQUEST\n+        )\",\n+            arrowString.data());\n+        TScriptVariator(script).Execute();\n+    }\n+\n+    Y_UNIT_TEST(RestoreJsonArrayVariants) {\n+        TString script = R\"(\n+            SCHEMA:            \n+            CREATE TABLE `/Root/ColumnTable` (\n+                Col1 Uint64 NOT NULL,\n+                Col2 JsonDocument,\n+                PRIMARY KEY (Col1)\n+            )\n+            PARTITION BY HASH(Col1)\n+            WITH (STORE = COLUMN, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = $$1|2|10$$);\n+            ------\n+            SCHEMA:\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)\n+            ------\n+            SCHEMA:\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_EXTRACTOR_CLASS_NAME`=`JSON_SCANNER`, `SCAN_FIRST_LEVEL_ONLY`=`false`, \n+                      `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`,\n+                      `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+            ------\n+            DATA:\n+            REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('[\"a\", {\"v\" : 4}, 1,2,3,4,5,6,7,8,9,10,11,12]'))\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` ORDER BY Col1;\n+            EXPECTED: [[1u;[\"[\\\"a\\\",{\\\"v\\\":\\\"4\\\"},\\\"1\\\",\\\"2\\\",\\\"3\\\",\\\"4\\\",\\\"5\\\",\\\"6\\\",\\\"7\\\",\\\"8\\\",\\\"9\\\",\\\"10\\\",\\\"11\\\",\\\"12\\\"]\"]]]\n             \n         )\";\n         TScriptVariator(script).Execute();\n@@ -502,7 +688,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n             ------\n             SCHEMA:\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, \n-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n             ------\n             DATA:\n             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{\"a\" : \"a1\", \"b\" : \"b1\", \"c\" : \"c1\"}')), (2u, JsonDocument('{\"a\" : \"a2\"}')),\n@@ -534,7 +720,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n             ------\n             SCHEMA:\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, \n-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n             ------\n             DATA:\n             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{\"a\" : \"a1\", \"b\" : \"b1\", \"c\" : \"c1\"}')), (2u, JsonDocument('{\"a\" : \"a2\"}')),\n@@ -564,7 +750,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n             ------\n             SCHEMA:\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, \n-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n             ------\n             DATA:\n             REPLACE INTO `/Root/ColumnTable` (Col1, Col2, Col3) VALUES(1u, JsonDocument('{\"a\" : \"value_a\", \"b\" : \"b1\", \"c\" : \"c1\"}'), \"value1\"), (2u, JsonDocument('{\"a\" : \"value_a\"}'), \"value1\"),\n@@ -594,7 +780,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n             ------\n             SCHEMA:\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, \n-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n             ------\n             DATA:\n             REPLACE INTO `/Root/ColumnTable` (Col1, Col2, Col3) VALUES(1u, JsonDocument('{\"a\" : \"value_a\", \"b\" : \"b1\", \"c\" : \"c1\"}'), \"value1\"), (2u, JsonDocument('{\"a\" : \"value_a\"}'), \"value1\"),\n@@ -624,7 +810,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n             ------\n             SCHEMA:\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, \n-                      `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n             ------\n             DATA:\n             REPLACE INTO `/Root/ColumnTable` (Col1, Col2, Col3) VALUES(1u, JsonDocument('{\"a\" : \"value_a\", \"b\" : \"b1\", \"c\" : \"c1\"}'), \"value1\"), (2u, JsonDocument('{\"a\" : \"value_a\"}'), \"value1\"),\n@@ -653,7 +839,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n             ------\n             SCHEMA:\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, \n-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n             ------\n             DATA:\n             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{\"a\" : \"a1\", \"b\" : \"b1\", \"c\" : \"c1\"}')), (2u, JsonDocument('{\"a\" : \"a2\"}')),\n@@ -682,7 +868,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n             ------\n             SCHEMA:\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, \n-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n             ------\n             DATA:\n             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{\"a\" : \"a1\"}')), (2u, JsonDocument('{\"a\" : \"a2\"}')),\n@@ -711,7 +897,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n             ------\n             SCHEMA:\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, \n-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n             ------\n             DATA:\n             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{\"a\" : \"a1\"}')), (2u, JsonDocument('{\"a\" : \"a2\"}')),\n@@ -742,7 +928,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n             ------\n             SCHEMA:\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, \n-                      `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n             ------\n             DATA:\n             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{\"a\" : \"a1\"}')), (2u, JsonDocument('{\"a\" : \"a2\"}')), \n@@ -765,7 +951,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n         TScriptVariator(script).Execute();\n     }\n \n-    Y_UNIT_TEST(BloomIndexesVariants) {\n+    Y_UNIT_TEST(BloomMixIndexesVariants) {\n         TString script = R\"(\n             STOP_COMPACTION\n             ------\n@@ -776,14 +962,16 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n                 PRIMARY KEY (Col1)\n             )\n             PARTITION BY HASH(Col1)\n-            WITH (STORE = COLUMN, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = $$2$$);\n+            WITH (STORE = COLUMN, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = 2);\n             ------\n             SCHEMA:\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)\n             ------\n             SCHEMA:\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, \n-                      `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+                      `DATA_EXTRACTOR_CLASS_NAME`=`JSON_SCANNER`, `FORCE_SIMD_PARSING`=`$$true|false$$`, `SCAN_FIRST_LEVEL_ONLY`=`$$true|false$$`,\n+                      `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10$$`,\n+                      `MEM_LIMIT_CHUNK`=`$$0|1000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n             ------\n             DATA:\n             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{\"a.b.c\" : \"a1\"}')), (2u, JsonDocument('{\"a.b.c\" : \"a2\"}')), \n@@ -800,7 +988,12 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n             SCHEMA:\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_INDEX, NAME=index_ngramm_b, TYPE=BLOOM_NGRAMM_FILTER,\n                 FEATURES=`{\"column_name\" : \"Col2\", \"ngramm_size\" : 3, \"hashes_count\" : 2, \"filter_size_bytes\" : 4096, \n-                           \"records_count\" : 1024, \"data_extractor\" : {\"class_name\" : \"SUB_COLUMN\", \"sub_column_name\" : \"b.c.d\"}}`);\n+                           \"records_count\" : 1024, \"case_sensitive\" : false, \"data_extractor\" : {\"class_name\" : \"SUB_COLUMN\", \"sub_column_name\" : '\"b.c.d\"'}}`);\n+            ------\n+            SCHEMA:\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_INDEX, NAME=index_ngramm_a, TYPE=BLOOM_NGRAMM_FILTER,\n+                FEATURES=`{\"column_name\" : \"Col2\", \"ngramm_size\" : 3, \"hashes_count\" : 2, \"filter_size_bytes\" : 4096, \n+                           \"records_count\" : 1024, \"case_sensitive\" : true, \"data_extractor\" : {\"class_name\" : \"SUB_COLUMN\", \"sub_column_name\" : \"a\"}}`);\n             ------\n             DATA:\n             REPLACE INTO `/Root/ColumnTable` (Col1) VALUES(10u)\n@@ -809,14 +1002,14 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n             ------\n             READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"a.b.c\\\"\") = \"a1\" ORDER BY Col1;\n             EXPECTED: [[1u;[\"{\\\"a.b.c\\\":\\\"a1\\\"}\"]]]\n-            IDX_ND_SKIP_APPROVE: 0, 3, 1\n+            IDX_ND_SKIP_APPROVE: 0, 4, 1\n             ------\n             SCHEMA:\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=DROP_INDEX, NAME=a_index)\n             ------\n             READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"a.b.c\\\"\") = \"1a1\" ORDER BY Col1;\n             EXPECTED: [[11u;[\"{\\\"a.b.c\\\":\\\"1a1\\\"}\"]]]\n-            IDX_ND_SKIP_APPROVE: 0, 3, 1\n+            IDX_ND_SKIP_APPROVE: 0, 4, 1\n             ------\n             SCHEMA:\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_INDEX, NAME=b_index, TYPE=CATEGORY_BLOOM_FILTER,\n@@ -824,24 +1017,214 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n             ------\n             READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"b.c.d\\\"\") = \"1b4\" ORDER BY Col1;\n             EXPECTED: [[14u;[\"{\\\"a\\\":\\\"a4\\\",\\\"b.c.d\\\":\\\"1b4\\\"}\"]]]\n-            IDX_ND_SKIP_APPROVE: 0, 3, 1\n+            IDX_ND_SKIP_APPROVE: 0, 4, 1\n             ------\n-            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"b.c.d\\\"\") = \"1b5\" ORDER BY Col1;\n+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"b.c.d\\\"\") like \"%1b4%\" ORDER BY Col1;\n+            EXPECTED: [[14u;[\"{\\\"a\\\":\\\"a4\\\",\\\"b.c.d\\\":\\\"1b4\\\"}\"]]]\n+            IDX_ND_SKIP_APPROVE: 0, 4, 1\n+#            ------\n+#            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"b.c.d\\\"\") ilike \"%1b4%\" ORDER BY Col1;\n+#            EXPECTED: [[14u;[\"{\\\"a\\\":\\\"a4\\\",\\\"b.c.d\\\":\\\"1b4\\\"}\"]]]\n+#            IDX_ND_SKIP_APPROVE: 0, 4, 1\n+#            ------\n+#            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"b.c.d\\\"\") ilike \"%1B4\" ORDER BY Col1;\n+#            EXPECTED: [[14u;[\"{\\\"a\\\":\\\"a4\\\",\\\"b.c.d\\\":\\\"1b4\\\"}\"]]]\n+#            IDX_ND_SKIP_APPROVE: 0, 4, 1\n+#            ------\n+#            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"b.c.d\\\"\") ilike \"1b5\" ORDER BY Col1;\n+#            EXPECTED: []\n+#            IDX_ND_SKIP_APPROVE: 0, 5, 0\n+#            ------\n+#            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.a\") = \"1b5\" ORDER BY Col1;\n+#            EXPECTED: []\n+#            IDX_ND_SKIP_APPROVE: 0, 5, 0\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.a\") = \"a4\" ORDER BY Col1;\n+            EXPECTED: [[4u;[\"{\\\"a\\\":\\\"a4\\\",\\\"b.c.d\\\":\\\"b4\\\"}\"]];[14u;[\"{\\\"a\\\":\\\"a4\\\",\\\"b.c.d\\\":\\\"1b4\\\"}\"]]]\n+            IDX_ND_SKIP_APPROVE: 0, 3, 2\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"b.c.d111\\\"\") = \"1b5\" ORDER BY Col1;\n             EXPECTED: []\n-            IDX_ND_SKIP_APPROVE: 0, 4, 0\n+            IDX_ND_SKIP_APPROVE: 0, 5, 0\n             ------\n             READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"b.c.d\\\"\") like \"1b3\" ORDER BY Col1;\n             EXPECTED: [[13u;[\"{\\\"b.c.d\\\":\\\"1b3\\\"}\"]]]\n-            IDX_ND_SKIP_APPROVE: 0, 3, 1\n+            IDX_ND_SKIP_APPROVE: 0, 4, 1\n             ------\n             READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"b.c.d\\\"\") like \"1b5\" ORDER BY Col1;\n             EXPECTED: []\n-            IDX_ND_SKIP_APPROVE: 0, 4, 0\n+            IDX_ND_SKIP_APPROVE: 0, 5, 0\n             \n         )\";\n         TScriptVariator(script).Execute();\n     }\n \n+    Y_UNIT_TEST(BloomCategoryIndexesVariants) {\n+        TString script = R\"(\n+            STOP_COMPACTION\n+            ------\n+            SCHEMA:            \n+            CREATE TABLE `/Root/ColumnTable` (\n+                Col1 Uint64 NOT NULL,\n+                Col2 JsonDocument,\n+                PRIMARY KEY (Col1)\n+            )\n+            PARTITION BY HASH(Col1)\n+            WITH (STORE = COLUMN, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = 2);\n+            ------\n+            SCHEMA:\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)\n+            ------\n+            SCHEMA:\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, \n+                      `DATA_EXTRACTOR_CLASS_NAME`=`JSON_SCANNER`, `FORCE_SIMD_PARSING`=`$$true|false$$`, `SCAN_FIRST_LEVEL_ONLY`=`$$true|false$$`,\n+                      `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10$$`,\n+                      `MEM_LIMIT_CHUNK`=`$$0|1000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+            ------\n+            DATA:\n+            REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{\"a.b.c\" : \"a1\"}')), (2u, JsonDocument('{\"a.b.c\" : \"a2\"}')), \n+                                                                    (3u, JsonDocument('{\"b.c.d\" : \"b3\"}')), (4u, JsonDocument('{\"b.c.d\" : \"b4\", \"a\" : \"a4\"}'))\n+            ------\n+            DATA:\n+            REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(11u, JsonDocument('{\"a.b.c\" : \"1a1\"}')), (12u, JsonDocument('{\"a.b.c\" : \"1a2\"}')), \n+                                                                    (13u, JsonDocument('{\"b.c.d\" : \"1b3\"}')), (14u, JsonDocument('{\"b.c.d\" : \"1b4\", \"a\" : \"a4\"}'))\n+            ------\n+            SCHEMA:\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_INDEX, NAME=a_index, TYPE=$$CATEGORY_BLOOM_FILTER|BLOOM_FILTER$$,\n+                    FEATURES=`{\"column_name\" : \"Col2\", \"false_positive_probability\" : 0.01}`)\n+            ------\n+            DATA:\n+            REPLACE INTO `/Root/ColumnTable` (Col1) VALUES(10u)\n+            ------\n+            ONE_ACTUALIZATION\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"a.b.c\\\"\") = \"a1\" ORDER BY Col1;\n+            EXPECTED: [[1u;[\"{\\\"a.b.c\\\":\\\"a1\\\"}\"]]]\n+            IDX_ND_SKIP_APPROVE: 0, 4, 1\n+            ------\n+            SCHEMA:\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=DROP_INDEX, NAME=a_index)\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"a.b.c\\\"\") = \"1a1\" ORDER BY Col1;\n+            EXPECTED: [[11u;[\"{\\\"a.b.c\\\":\\\"1a1\\\"}\"]]]\n+            IDX_ND_SKIP_APPROVE: 0, 4, 1\n+            ------\n+            SCHEMA:\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_INDEX, NAME=b_index, TYPE=CATEGORY_BLOOM_FILTER,\n+                    FEATURES=`{\"column_name\" : \"Col2\", \"false_positive_probability\" : 0.01}`)\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"b.c.d\\\"\") = \"1b4\" ORDER BY Col1;\n+            EXPECTED: [[14u;[\"{\\\"a\\\":\\\"a4\\\",\\\"b.c.d\\\":\\\"1b4\\\"}\"]]]\n+            IDX_ND_SKIP_APPROVE: 0, 4, 1\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.a\") = \"1b5\" ORDER BY Col1;\n+            EXPECTED: []\n+            IDX_ND_SKIP_APPROVE: 0, 5, 0\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.a\") = \"a4\" ORDER BY Col1;\n+            EXPECTED: [[4u;[\"{\\\"a\\\":\\\"a4\\\",\\\"b.c.d\\\":\\\"b4\\\"}\"]];[14u;[\"{\\\"a\\\":\\\"a4\\\",\\\"b.c.d\\\":\\\"1b4\\\"}\"]]]\n+            IDX_ND_SKIP_APPROVE: 0, 3, 2\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"b.c.d111\\\"\") = \"1b5\" ORDER BY Col1;\n+            EXPECTED: []\n+            IDX_ND_SKIP_APPROVE: 0, 5, 0\n+            \n+        )\";\n+        TScriptVariator(script).Execute();\n+    }\n+\n+    Y_UNIT_TEST(BloomNGrammIndexesVariants) {\n+        TString script = R\"(\n+            STOP_COMPACTION\n+            ------\n+            SCHEMA:            \n+            CREATE TABLE `/Root/ColumnTable` (\n+                Col1 Uint64 NOT NULL,\n+                Col2 JsonDocument,\n+                PRIMARY KEY (Col1)\n+            )\n+            PARTITION BY HASH(Col1)\n+            WITH (STORE = COLUMN, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = 2);\n+            ------\n+            SCHEMA:\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)\n+            ------\n+            SCHEMA:\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, \n+                      `DATA_EXTRACTOR_CLASS_NAME`=`JSON_SCANNER`, `FORCE_SIMD_PARSING`=`$$true|false$$`, `SCAN_FIRST_LEVEL_ONLY`=`$$true|false$$`,\n+                      `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10$$`,\n+                      `MEM_LIMIT_CHUNK`=`$$0|1000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+            ------\n+            DATA:\n+            REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{\"a.b.c\" : \"a1\"}')), (2u, JsonDocument('{\"a.b.c\" : \"a2\"}')), \n+                                                                    (3u, JsonDocument('{\"b.c.d\" : \"b3\"}')), (4u, JsonDocument('{\"b.c.d\" : \"b4\", \"a\" : \"a4\"}'))\n+            ------\n+            DATA:\n+            REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(11u, JsonDocument('{\"a.b.c\" : \"1a1\"}')), (12u, JsonDocument('{\"a.b.c\" : \"1a2\"}')), \n+                                                                    (13u, JsonDocument('{\"b.c.d\" : \"1b3\"}')), (14u, JsonDocument('{\"b.c.d\" : \"1b4\", \"a\" : \"a4\"}'))\n+            ------\n+            SCHEMA:\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_INDEX, NAME=index_ngramm_b, TYPE=BLOOM_NGRAMM_FILTER,\n+                FEATURES=`{\"column_name\" : \"Col2\", \"ngramm_size\" : 3, \"hashes_count\" : 2, \"filter_size_bytes\" : 4096, \n+                           \"records_count\" : 1024, \"case_sensitive\" : false, \"data_extractor\" : {\"class_name\" : \"SUB_COLUMN\", \"sub_column_name\" : '\"b.c.d\"'}}`);\n+            ------\n+            SCHEMA:\n+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_INDEX, NAME=index_ngramm_a, TYPE=BLOOM_NGRAMM_FILTER,\n+                FEATURES=`{\"column_name\" : \"Col2\", \"ngramm_size\" : 3, \"hashes_count\" : 2, \"filter_size_bytes\" : 4096, \n+                           \"records_count\" : 1024, \"case_sensitive\" : true, \"data_extractor\" : {\"class_name\" : \"SUB_COLUMN\", \"sub_column_name\" : \"a\"}}`);\n+            ------\n+            DATA:\n+            REPLACE INTO `/Root/ColumnTable` (Col1) VALUES(10u)\n+            ------\n+            ONE_ACTUALIZATION\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"a.b.c\\\"\") = \"a1\" ORDER BY Col1;\n+            EXPECTED: [[1u;[\"{\\\"a.b.c\\\":\\\"a1\\\"}\"]]]\n+            IDX_ND_SKIP_APPROVE: 5, 0, 0\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"b.c.d\\\"\") = \"1b4\" ORDER BY Col1;\n+            EXPECTED: [[14u;[\"{\\\"a\\\":\\\"a4\\\",\\\"b.c.d\\\":\\\"1b4\\\"}\"]]]\n+            IDX_ND_SKIP_APPROVE: 0, 4, 1\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"b.c.d\\\"\") like \"%1b4%\" ORDER BY Col1;\n+            EXPECTED: [[14u;[\"{\\\"a\\\":\\\"a4\\\",\\\"b.c.d\\\":\\\"1b4\\\"}\"]]]\n+            IDX_ND_SKIP_APPROVE: 0, 4, 1\n+#            ------\n+#            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"b.c.d\\\"\") ilike \"%1b4%\" ORDER BY Col1;\n+#            EXPECTED: [[14u;[\"{\\\"a\\\":\\\"a4\\\",\\\"b.c.d\\\":\\\"1b4\\\"}\"]]]\n+#            IDX_ND_SKIP_APPROVE: 0, 4, 1\n+#            ------\n+#            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"b.c.d\\\"\") ilike \"%1B4\" ORDER BY Col1;\n+#            EXPECTED: [[14u;[\"{\\\"a\\\":\\\"a4\\\",\\\"b.c.d\\\":\\\"1b4\\\"}\"]]]\n+#            IDX_ND_SKIP_APPROVE: 0, 4, 1\n+#            ------\n+#            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"b.c.d\\\"\") ilike \"1b5\" ORDER BY Col1;\n+#            EXPECTED: []\n+#            IDX_ND_SKIP_APPROVE: 0, 5, 0\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.a\") = \"1b5\" ORDER BY Col1;\n+            EXPECTED: []\n+            IDX_ND_SKIP_APPROVE: 0, 5, 0\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.a\") = \"a4\" ORDER BY Col1;\n+            EXPECTED: [[4u;[\"{\\\"a\\\":\\\"a4\\\",\\\"b.c.d\\\":\\\"b4\\\"}\"]];[14u;[\"{\\\"a\\\":\\\"a4\\\",\\\"b.c.d\\\":\\\"1b4\\\"}\"]]]\n+            IDX_ND_SKIP_APPROVE: 0, 3, 2\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"b.c.d111\\\"\") = \"1b5\" ORDER BY Col1;\n+            EXPECTED: []\n+            IDX_ND_SKIP_APPROVE: 5, 0, 0\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"b.c.d\\\"\") like \"1b3\" ORDER BY Col1;\n+            EXPECTED: [[13u;[\"{\\\"b.c.d\\\":\\\"1b3\\\"}\"]]]\n+            IDX_ND_SKIP_APPROVE: 0, 4, 1\n+            ------\n+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, \"$.\\\"b.c.d\\\"\") like \"1B3\" ORDER BY Col1;\n+            EXPECTED: []\n+            IDX_ND_SKIP_APPROVE: 0, 4, 1\n+        )\";\n+        TScriptVariator(script).Execute();\n+    }\n+\n     Y_UNIT_TEST(SwitchAccessorCompactionVariants) {\n         TString script = R\"(\n             STOP_COMPACTION\n@@ -864,7 +1247,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n             ------\n             SCHEMA:\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, \n-                      `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n             ------\n             DATA:\n             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(11u, JsonDocument('{\"a\" : \"1a1\"}')), (12u, JsonDocument('{\"a\" : \"1a2\"}')), \n@@ -901,7 +1284,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {\n             ------\n             SCHEMA:\n             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, \n-                      `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)\n             ------\n             DATA:\n             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{\"a\" : \"a1\"}')), (2u, JsonDocument('{\"a\" : \"a2\"}')), \ndiff --git a/ydb/core/kqp/ut/olap/kqp_olap_ut.cpp b/ydb/core/kqp/ut/olap/kqp_olap_ut.cpp\nindex c4d7f39de174..f55f162ab42b 100644\n--- a/ydb/core/kqp/ut/olap/kqp_olap_ut.cpp\n+++ b/ydb/core/kqp/ut/olap/kqp_olap_ut.cpp\n@@ -332,6 +332,31 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n         }\n     }\n \n+    Y_UNIT_TEST(EmptyColumnsRead) {\n+        auto settings = TKikimrSettings()\n+            .SetWithSampleTables(false);\n+        TKikimrRunner kikimr(settings);\n+\n+        TLocalHelper(kikimr).CreateTestOlapTable();\n+\n+        WriteTestData(kikimr, \"/Root/olapStore/olapTable\", 0, 1000000, 2);\n+\n+        auto client = kikimr.GetQueryClient();\n+\n+        Tests::NCommon::TLoggerInit(kikimr).Initialize();\n+\n+        {\n+            auto it = client.ExecuteQuery(R\"(\n+                --!syntax_v1\n+\n+                SELECT 1\n+                FROM `/Root/olapStore/olapTable`\n+            )\",NYdb::NQuery::TTxControl::NoTx(), NYdb::NQuery::TExecuteQuerySettings()).ExtractValueSync();\n+\n+            UNIT_ASSERT_C(it.IsSuccess(), it.GetIssues().ToString());\n+        }\n+    }\n+\n     Y_UNIT_TEST(SimpleQueryOlapStats) {\n         auto settings = TKikimrSettings()\n             .SetWithSampleTables(false);\n@@ -812,54 +837,81 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n         WriteTestData(kikimr, \"/Root/olapStore/olapTable\", 0, 1000000, 128);\n \n         auto tableClient = kikimr.GetTableClient();\n-        auto selectQueryWithSort = TString(R\"(\n+        auto selectQuerySortDesc = TString(R\"(\n             --!syntax_v1\n             SELECT `timestamp` FROM `/Root/olapStore/olapTable` ORDER BY `timestamp` DESC LIMIT 4;\n         )\");\n-        auto selectQuery = TString(R\"(\n+        auto selectQuerySortAsc = TString(R\"(\n             --!syntax_v1\n             SELECT `timestamp` FROM `/Root/olapStore/olapTable` ORDER BY `timestamp` LIMIT 4;\n         )\");\n-\n-        auto it = tableClient.StreamExecuteScanQuery(selectQuery, scanSettings).GetValueSync();\n-        auto result = CollectStreamResult(it);\n+        auto selectQueryNoSort = TString(R\"(\n+            --!syntax_v1\n+            SELECT `timestamp` FROM `/Root/olapStore/olapTable` LIMIT 4;\n+        )\");\n \n         NJson::TJsonValue plan, node, reverse, limit, pushedLimit;\n-        NJson::ReadJsonTree(*result.PlanJson, &plan, true);\n-        Cerr << *result.PlanJson << Endl;\n-        Cerr << result.QueryStats->query_plan() << Endl;\n-        Cerr << result.QueryStats->query_ast() << Endl;\n-\n-        node = FindPlanNodeByKv(plan, \"Node Type\", \"TopSort-TableFullScan\");\n-        UNIT_ASSERT(node.IsDefined());\n-        reverse = FindPlanNodeByKv(node, \"Reverse\", \"false\");\n-        UNIT_ASSERT(!reverse.IsDefined());\n-        pushedLimit = FindPlanNodeByKv(node, \"ReadLimit\", \"4\");\n-        UNIT_ASSERT(pushedLimit.IsDefined());\n-        limit = FindPlanNodeByKv(node, \"Limit\", \"4\");\n-        UNIT_ASSERT(limit.IsDefined());\n-\n-        // Check that Reverse flag is set in query plan\n-        it = tableClient.StreamExecuteScanQuery(selectQueryWithSort, scanSettings).GetValueSync();\n-        result = CollectStreamResult(it);\n+        {\n+            auto it = tableClient.StreamExecuteScanQuery(selectQuerySortAsc, scanSettings).GetValueSync();\n+            auto result = CollectStreamResult(it);\n \n-        NJson::ReadJsonTree(*result.PlanJson, &plan, true);\n-        Cerr << \"==============================\" << Endl;\n-        Cerr << *result.PlanJson << Endl;\n-        Cerr << result.QueryStats->query_plan() << Endl;\n-        Cerr << result.QueryStats->query_ast() << Endl;\n-\n-        node = FindPlanNodeByKv(plan, \"Node Type\", \"TopSort-TableFullScan\");\n-        UNIT_ASSERT(node.IsDefined());\n-        reverse = FindPlanNodeByKv(node, \"Reverse\", \"true\");\n-        UNIT_ASSERT(reverse.IsDefined());\n-        limit = FindPlanNodeByKv(node, \"Limit\", \"4\");\n-        UNIT_ASSERT(limit.IsDefined());\n-        pushedLimit = FindPlanNodeByKv(node, \"ReadLimit\", \"4\");\n-        UNIT_ASSERT(pushedLimit.IsDefined());\n+            NJson::ReadJsonTree(*result.PlanJson, &plan, true);\n+            Cerr << *result.PlanJson << Endl;\n+            Cerr << result.QueryStats->query_plan() << Endl;\n+            Cerr << result.QueryStats->query_ast() << Endl;\n+\n+            node = FindPlanNodeByKv(plan, \"Node Type\", \"TopSort-TableFullScan\");\n+            UNIT_ASSERT(node.IsDefined());\n+            reverse = FindPlanNodeByKv(node, \"Reverse\", \"false\");\n+            UNIT_ASSERT(reverse.IsDefined());\n+            pushedLimit = FindPlanNodeByKv(node, \"ReadLimit\", \"4\");\n+            UNIT_ASSERT(pushedLimit.IsDefined());\n+            limit = FindPlanNodeByKv(node, \"Limit\", \"4\");\n+            UNIT_ASSERT(limit.IsDefined());\n+        }\n+\n+        {\n+            // Check that Reverse flag is set in query plan\n+            auto it = tableClient.StreamExecuteScanQuery(selectQuerySortDesc, scanSettings).GetValueSync();\n+            auto result = CollectStreamResult(it);\n+\n+            NJson::ReadJsonTree(*result.PlanJson, &plan, true);\n+            Cerr << \"==============================\" << Endl;\n+            Cerr << *result.PlanJson << Endl;\n+            Cerr << result.QueryStats->query_plan() << Endl;\n+            Cerr << result.QueryStats->query_ast() << Endl;\n+\n+            node = FindPlanNodeByKv(plan, \"Node Type\", \"TopSort-TableFullScan\");\n+            UNIT_ASSERT(node.IsDefined());\n+            reverse = FindPlanNodeByKv(node, \"Reverse\", \"true\");\n+            UNIT_ASSERT(reverse.IsDefined());\n+            limit = FindPlanNodeByKv(node, \"Limit\", \"4\");\n+            UNIT_ASSERT(limit.IsDefined());\n+            pushedLimit = FindPlanNodeByKv(node, \"ReadLimit\", \"4\");\n+            UNIT_ASSERT(pushedLimit.IsDefined());\n+        }\n+\n+        {\n+            // Check that Reverse flag is set in query plan\n+            auto it = tableClient.StreamExecuteScanQuery(selectQueryNoSort, scanSettings).GetValueSync();\n+            auto result = CollectStreamResult(it);\n+\n+            NJson::ReadJsonTree(*result.PlanJson, &plan, true);\n+            Cerr << \"==============================\" << Endl;\n+            Cerr << *result.PlanJson << Endl;\n+            Cerr << result.QueryStats->query_plan() << Endl;\n+            Cerr << result.QueryStats->query_ast() << Endl;\n+\n+            node = FindPlanNodeByKv(plan, \"Node Type\", \"Limit-TableFullScan\");\n+            UNIT_ASSERT(node.IsDefined());\n+            limit = FindPlanNodeByKv(node, \"Limit\", \"4\");\n+            UNIT_ASSERT(limit.IsDefined());\n+            pushedLimit = FindPlanNodeByKv(node, \"ReadLimit\", \"4\");\n+            UNIT_ASSERT(pushedLimit.IsDefined());\n+        }\n \n         // Run actual request in case explain did not execute anything\n-        it = tableClient.StreamExecuteScanQuery(selectQueryWithSort).GetValueSync();\n+        auto it = tableClient.StreamExecuteScanQuery(selectQuerySortDesc).GetValueSync();\n \n         UNIT_ASSERT(it.IsSuccess());\n \n@@ -1019,7 +1071,7 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n         for (const auto& r : rows) {\n             TInstant ts = GetTimestamp(r.at(\"timestamp\"));\n             UNIT_ASSERT_GE_C(ts, tsPrev, \"result is not sorted in ASC order\");\n-            UNIT_ASSERT(results.erase(ts.GetValue()));\n+            UNIT_ASSERT_C(results.erase(ts.GetValue()), Sprintf(\"%d\", ts.GetValue()));\n             tsPrev = ts;\n         }\n         UNIT_ASSERT(rows.size() == 6);\n@@ -1092,11 +1144,7 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n         scanSettings.Explain(true);\n \n         TLocalHelper(kikimr).CreateTestOlapTable();\n-#if SSA_RUNTIME_VERSION >= 4U\n         WriteTestData(kikimr, \"/Root/olapStore/olapTable\", 10000, 3000000, 5, true);\n-#else\n-        WriteTestData(kikimr, \"/Root/olapStore/olapTable\", 10000, 3000000, 5, false);\n-#endif\n         Tests::NCommon::TLoggerInit(kikimr).Initialize();\n \n         auto tableClient = kikimr.GetTableClient();\n@@ -1153,13 +1201,10 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n             R\"((`level`, `uid`) != (Int32(\"1\"), NULL))\",\n             R\"(`level` >= CAST(\"2\" As Int32))\",\n             R\"(CAST(\"2\" As Int32) >= `level`)\",\n-#if SSA_RUNTIME_VERSION >= 2U\n             R\"(`uid` LIKE \"%30000%\")\",\n             R\"(`uid` LIKE \"uid%\")\",\n             R\"(`uid` LIKE \"%001\")\",\n             R\"(`uid` LIKE \"uid%001\")\",\n-#endif\n-#if SSA_RUNTIME_VERSION >= 4U\n             R\"(`level` + 2 < 5)\",\n             R\"(`level` - 2 >= 1)\",\n             R\"(`level` * 3 > 4)\",\n@@ -1187,7 +1232,6 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n             //R\"(`timestamp` >= Timestamp(\"1970-01-01T00:00:00.000001Z\"))\",\n             R\"(`timestamp` >= Timestamp(\"1970-01-01T00:00:03.000001Z\") AND `level` < 4)\",\n             R\"((`timestamp`, `level`) >= (Timestamp(\"1970-01-01T00:00:03.000001Z\"), 3))\",\n-#endif\n #if SSA_RUNTIME_VERSION >= 5U\n             R\"(`resource_id` != \"10001\" XOR \"XXX\" == \"YYY\")\",\n             R\"(IF(`level` > 3, -`level`, +`level`) < 2)\",\n@@ -1257,27 +1301,6 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n             R\"(`level` = NULL)\",\n             R\"(`level` > NULL)\",\n             R\"(Re2::Match('uid.*')(`uid`))\",\n-#if SSA_RUNTIME_VERSION < 2U\n-            R\"(`uid` LIKE \"%30000%\")\",\n-            R\"(`uid` LIKE \"uid%\")\",\n-            R\"(`uid` LIKE \"%001\")\",\n-            R\"(`uid` LIKE \"uid%001\")\",\n-#endif\n-#if SSA_RUNTIME_VERSION < 4U\n-            R\"(`level` * 3.14 > 4)\",\n-            R\"(LENGTH(`uid`) > 0 OR `resource_id` = \"10001\")\",\n-            R\"((LENGTH(`uid`) > 0 AND `resource_id` = \"10001\") OR `resource_id` = \"10002\")\",\n-            R\"((LENGTH(`uid`) > 0 OR `resource_id` = \"10002\") AND (LENGTH(`uid`) < 15 OR `resource_id` = \"10001\"))\",\n-            R\"(NOT(LENGTH(`uid`) > 0 AND `resource_id` = \"10001\"))\",\n-            R\"(Unwrap(`level`/1) = `level` AND `resource_id` = \"10001\")\",\n-            R\"(NOT(LENGTH(`uid`) > 0 OR `resource_id` = \"10001\"))\",\n-            R\"(`level` + 2 < 5)\",\n-            R\"(`level` - 2 >= 1)\",\n-            R\"(`level` * 3 > 4)\",\n-            R\"(`level` / 2 <= 1)\",\n-            R\"(`level` % 3 != 1)\",\n-            R\"(`timestamp` >= Timestamp(\"1970-01-01T00:00:00.000001Z\"))\",\n-#endif\n         };\n \n         for (const auto& predicate: testDataNoPush) {\n@@ -1360,7 +1383,6 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n                           TStringBuilder() << \"NarrowMap was removed. Query: \" << pushQuery);\n         }\n     }\n-#if SSA_RUNTIME_VERSION >= 2U\n     Y_UNIT_TEST(PredicatePushdown_DifferentLvlOfFilters) {\n         auto settings = TKikimrSettings()\n             .SetWithSampleTables(false);\n@@ -1380,11 +1402,7 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n             { R\"(`uid` NOT LIKE \"%30000%\")\", \"Filter-TableFullScan\" },\n             { R\"(`uid` LIKE \"uid%\")\", \"Filter-TableFullScan\" },\n             { R\"(`uid` LIKE \"%001\")\", \"Filter-TableFullScan\" },\n-#if SSA_RUNTIME_VERSION >= 4U\n             { R\"(`uid` LIKE \"uid%001\")\", \"Filter-TableFullScan\" },\n-#else\n-            { R\"(`uid` LIKE \"uid%001\")\", \"Filter-TableFullScan\" }, // We have filter (Size >= 6)\n-#endif\n         };\n         std::string query = R\"(\n             SELECT `timestamp` FROM `/Root/olapStore/olapTable` WHERE\n@@ -1412,13 +1430,8 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n             }\n         }\n     }\n-#endif\n \n-#if SSA_RUNTIME_VERSION >= 3U\n     Y_UNIT_TEST(PredicatePushdown_LikePushedDownForStringType) {\n-#else\n-    Y_UNIT_TEST(PredicatePushdown_LikeNotPushedDownForStringType) {\n-#endif\n         auto settings = TKikimrSettings()\n             .SetWithSampleTables(false);\n         TKikimrRunner kikimr(settings);\n@@ -1437,13 +1450,8 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n \n         auto result = CollectStreamResult(it);\n         auto ast = result.QueryStats->Getquery_ast();\n-#if SSA_RUNTIME_VERSION >= 3U\n         UNIT_ASSERT_C(ast.find(\"KqpOlapFilter\") != std::string::npos,\n                         TStringBuilder() << \"Predicate wasn't pushed down. Query: \" << query);\n-#else\n-        UNIT_ASSERT_C(ast.find(\"KqpOlapFilter\") == std::string::npos,\n-                        TStringBuilder() << \"Predicate was pushed down. Query: \" << query);\n-#endif\n     }\n #if SSA_RUNTIME_VERSION < 5U\n     Y_UNIT_TEST(PredicatePushdown_LikeNotPushedDownIfAnsiLikeDisabled) {\n@@ -1496,9 +1504,15 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n         auto result = CollectStreamResult(it);\n         auto ast = result.QueryStats->Getquery_ast();\n         UNIT_ASSERT_C(ast.find(R\"(('eq '\"resource_id\")\") != std::string::npos,\n-                          TStringBuilder() << \"Predicate not pushed down. Query: \" << query);\n-        UNIT_ASSERT_C(ast.find(R\"(('gt '\"level\")\") == std::string::npos,\n-                          TStringBuilder() << \"Predicate pushed down. Query: \" << query);\n+                          TStringBuilder() << \"Subpredicate is not pushed down. Query: \" << query);\n+        UNIT_ASSERT_C(ast.find(R\"(('gt '\"level\")\") != std::string::npos,\n+                          TStringBuilder() << \"Subpredicate is not pushed down. Query: \" << query);\n+        //This check is based on an assumpltion, that for pushed down predicates column names are preserved in AST\n+        //But for non-pushed down predicates column names are (usually) replaced with a label, started with $. It' not a rule, but a heuristic\n+        //So this check may require a correction when some ast optimization rules are changed\n+        UNIT_ASSERT_C(ast.find(R\"((Unwrap (/ $)\") != std::string::npos,\n+                          TStringBuilder() << \"Unsafe subpredicate is pushed down. Query: \" << query);\n+\n         UNIT_ASSERT_C(ast.find(\"NarrowMap\") != std::string::npos,\n                           TStringBuilder() << \"NarrowMap was removed. Query: \" << query);\n     }\n@@ -1814,6 +1828,87 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n         UNIT_ASSERT_VALUES_EQUAL(result, insertRows);\n     }\n \n+    Y_UNIT_TEST(PredicatePushdownWithParametersILike) {\n+        constexpr bool logQueries = true;\n+        auto settings = TKikimrSettings()\n+            .SetWithSampleTables(false);\n+        TKikimrRunner kikimr(settings);\n+\n+        TStreamExecScanQuerySettings scanSettings;\n+        scanSettings.Explain(true);\n+\n+        TLocalHelper(kikimr.GetTestServer()).CreateTestOlapTable();\n+        WriteTestData(kikimr, \"/Root/olapStore/olapTable\", 10000, 3000000, 1000);\n+\n+        auto tableClient = kikimr.GetTableClient();\n+\n+        auto buildQuery = [](bool pushEnabled) {\n+            TStringBuilder builder;\n+\n+            builder << \"--!syntax_v1\" << Endl;\n+\n+            if (!pushEnabled) {\n+                builder << \"PRAGMA Kikimr.OptEnableOlapPushdown = \\\"false\\\";\" << Endl;\n+            }\n+\n+            builder << R\"(\n+                DECLARE $in_uid AS Utf8;\n+                DECLARE $in_level AS Int32;\n+\n+                SELECT `timestamp` FROM `/Root/olapStore/olapTable` WHERE\n+                    uid ILIKE \"uid_%\" || $in_uid || \"%\" AND level > $in_level\n+                ORDER BY `timestamp`;\n+            )\" << Endl;\n+\n+            return builder;\n+        };\n+\n+        auto normalQuery = buildQuery(false);\n+        auto pushQuery = buildQuery(true);\n+\n+        auto params = tableClient.GetParamsBuilder()\n+            .AddParam(\"$in_uid\")\n+                .Utf8(\"3000\")\n+                .Build()\n+            .AddParam(\"$in_level\")\n+                .Int32(2)\n+                .Build()\n+            .Build();\n+\n+        auto it = tableClient.StreamExecuteScanQuery(normalQuery, params).GetValueSync();\n+        UNIT_ASSERT_C(it.IsSuccess(), it.GetIssues().ToString());\n+        auto goodResult = CollectStreamResult(it);\n+\n+        it = tableClient.StreamExecuteScanQuery(pushQuery, params).GetValueSync();\n+        UNIT_ASSERT_C(it.IsSuccess(), it.GetIssues().ToString());\n+        auto pushResult = CollectStreamResult(it);\n+\n+        if (logQueries) {\n+            Cerr << \"Query: \" << normalQuery << Endl;\n+            Cerr << \"Expected: \" << goodResult.ResultSetYson << Endl;\n+            Cerr << \"Received: \" << pushResult.ResultSetYson << Endl;\n+        }\n+\n+        CompareYson(goodResult.ResultSetYson, pushResult.ResultSetYson);\n+\n+        it = tableClient.StreamExecuteScanQuery(pushQuery, scanSettings).GetValueSync();\n+        UNIT_ASSERT_C(it.IsSuccess(), it.GetIssues().ToString());\n+\n+        auto result = CollectStreamResult(it);\n+        auto ast = result.QueryStats->Getquery_ast();\n+\n+        UNIT_ASSERT_C(ast.find(\"KqpOlapFilter\") != std::string::npos,\n+                      TStringBuilder() << \"Predicate not pushed down. Query: \" << pushQuery);\n+\n+        NJson::TJsonValue plan, readRange;\n+        NJson::ReadJsonTree(*result.PlanJson, &plan, true);\n+\n+        Cerr << result.PlanJson << Endl;\n+\n+        readRange = FindPlanNodeByKv(plan, \"Name\", \"TableFullScan\");\n+        UNIT_ASSERT(readRange.IsDefined());\n+    }\n+\n     Y_UNIT_TEST(PredicatePushdownWithParameters) {\n         constexpr bool logQueries = true;\n         auto settings = TKikimrSettings()\n@@ -2258,7 +2353,6 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n \n         auto tableClient = kikimr.GetTableClient();\n \n-#if SSA_RUNTIME_VERSION >= 4U\n         const std::set<std::string> numerics = {\"Int8\", \"Int16\", \"Int32\", \"Int64\", \"UInt8\", \"UInt16\", \"UInt32\", \"UInt64\", \"Float\", \"Double\"};\n         const std::map<std::string, std::set<std::string>> exceptions = {\n             {\"Int8\", numerics},\n@@ -2274,18 +2368,6 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n             {\"String\", {\"Utf8\"}},\n             {\"Utf8\", {\"String\"}},\n         };\n-#else\n-        std::map<std::string, std::set<std::string>> exceptions = {\n-            {\"Int8\", {\"Int16\", \"Int32\"}},\n-            {\"Int16\", {\"Int8\", \"Int32\"}},\n-            {\"Int32\", {\"Int8\", \"Int16\"}},\n-            {\"UInt8\", {\"UInt16\", \"UInt32\"}},\n-            {\"UInt16\", {\"UInt8\", \"UInt32\"}},\n-            {\"UInt32\", {\"UInt8\", \"UInt16\"}},\n-            {\"String\", {\"Utf8\"}},\n-            {\"Utf8\", {\"String\", \"Json\", \"Yson\"}},\n-        };\n-#endif\n \n         std::vector<std::string> allTypes = {\n             //\"Bool\",\n@@ -3331,9 +3413,9 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n \n             )\", noTx).GetValueSync();\n             UNIT_ASSERT_C(result.GetStatus() == NYdb::EStatus::SUCCESS, result.GetIssues().ToString());\n-            \n+\n             result = queryClient.ExecuteQuery(R\"(\n-                UPSERT INTO Test (Id, Name, Comment) VALUES \n+                UPSERT INTO Test (Id, Name, Comment) VALUES\n                     (10,  \"n1\", \"aa\"),\n                     (20, \"n2\", \"bb\"),\n                     (30, \"n3\", \"cc\"),\n@@ -3387,5 +3469,64 @@ Y_UNIT_TEST_SUITE(KqpOlap) {\n \n         testHelper.ReadData(\"SELECT COUNT(*) FROM `/Root/ColumnTableTest` WHERE time > CurrentUtcTimestamp()\", \"[[1u]]\");\n     }\n+\n+    Y_UNIT_TEST(WithDefaultValue) {\n+        std::unique_ptr<TKikimrRunner> Kikimr;\n+        auto settings = TKikimrSettings().SetWithSampleTables(false);\n+        auto kikimr = std::make_unique<TKikimrRunner>(settings);\n+        Tests::NCommon::TLoggerInit(*kikimr).Initialize();\n+        auto queryClient = kikimr->GetQueryClient();\n+        {\n+            auto result = queryClient.ExecuteQuery(R\"(\n+                CREATE TABLE Test (\n+                    Id Uint32 not null,\n+                    Value String DEFAULT \"aba\",\n+                    PRIMARY KEY (Id)\n+                ) WITH (\n+                    STORE = COLUMN\n+                );\n+            )\", NQuery::TTxControl::NoTx()).GetValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::GENERIC_ERROR);\n+            UNIT_ASSERT_STRING_CONTAINS_C(result.GetIssues().ToString(), \"Default values are not supported in column tables\", result.GetIssues().ToString());\n+        }\n+    }\n+\n+    Y_UNIT_TEST(SimpleRequestHasProjections) {\n+        auto settings = TKikimrSettings()\n+            .SetWithSampleTables(false);\n+        TKikimrRunner kikimr(settings);\n+        TLocalHelper(kikimr).CreateTestOlapTable();\n+        WriteTestData(kikimr, \"/Root/olapStore/olapTable\", 0, 1000000, 20);\n+        auto client = kikimr.GetTableClient();\n+        Tests::NCommon::TLoggerInit(kikimr).Initialize();\n+\n+        {\n+            auto it = client.StreamExecuteScanQuery(R\"(\n+                --!syntax_v1\n+\n+                SELECT 1\n+                FROM `/Root/olapStore/olapTable`\n+            )\").GetValueSync();\n+\n+            UNIT_ASSERT_C(it.IsSuccess(), it.GetIssues().ToString());\n+            TString result = StreamResultToYson(it);\n+\n+            CompareYson(result, R\"([[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1]])\");\n+        }\n+\n+        {\n+            auto it = client.StreamExecuteScanQuery(R\"(\n+                --!syntax_v1\n+\n+                SELECT count(*)\n+                FROM `/Root/olapStore/olapTable`\n+            )\").GetValueSync();\n+\n+            UNIT_ASSERT_C(it.IsSuccess(), it.GetIssues().ToString());\n+            TString result = StreamResultToYson(it);\n+\n+            CompareYson(result, R\"([[20u]])\");\n+        }\n+    }\n }\n }\ndiff --git a/ydb/core/kqp/ut/opt/kqp_ne_ut.cpp b/ydb/core/kqp/ut/opt/kqp_ne_ut.cpp\nindex 280667bf2474..9984729f6244 100644\n--- a/ydb/core/kqp/ut/opt/kqp_ne_ut.cpp\n+++ b/ydb/core/kqp/ut/opt/kqp_ne_ut.cpp\n@@ -1343,8 +1343,10 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {\n         UNIT_ASSERT(stats.query_phases(index).duration_us() > 0);\n     }\n \n-    Y_UNIT_TEST(PruneWritePartitions) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_TWIN(PruneWritePartitions, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n \n@@ -1364,17 +1366,28 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {\n         AssertSuccessResult(result);\n \n         auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n \n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 0);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 0);\n-        UNIT_ASSERT(stats.query_phases(0).table_access().size() == 0);\n+        if (UseSink) {\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);\n+    \n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).partitions_count(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/TwoShard\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 1);\n+        } else {\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n \n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).affected_shards(), 1);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).partitions_count(), 1);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/TwoShard\");\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 0);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 0);\n+            UNIT_ASSERT(stats.query_phases(0).table_access().size() == 0);\n+\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).affected_shards(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).partitions_count(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/TwoShard\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);\n+        }\n \n         result = session.ExecuteDataQuery(R\"(\n             SELECT * FROM `/Root/TwoShard` WHERE Value2 <= -10 ORDER BY Key;\n@@ -1757,8 +1770,10 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {\n         ])\", FormatResultSetYson(result.GetResultSet(0)));\n     }\n \n-    Y_UNIT_TEST(Update) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_TWIN(Update, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n \n@@ -1774,17 +1789,28 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n \n         auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n \n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/TwoShard\");\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 0);\n+        if (UseSink) {\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);\n+    \n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/TwoShard\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 2);\n+            UNIT_ASSERT(stats.query_phases(0).table_access(0).updates().bytes() > 0);\n+            UNIT_ASSERT(stats.query_phases(0).duration_us() > 0); \n+        } else {\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n \n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/TwoShard\");\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 2);\n-        UNIT_ASSERT(stats.query_phases(1).table_access(0).updates().bytes() > 0);\n-        UNIT_ASSERT(stats.query_phases(1).duration_us() > 0);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/TwoShard\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 0);\n+\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/TwoShard\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 2);\n+            UNIT_ASSERT(stats.query_phases(1).table_access(0).updates().bytes() > 0);\n+            UNIT_ASSERT(stats.query_phases(1).duration_us() > 0);\n+        }\n \n         result = session.ExecuteDataQuery(R\"(\n             SELECT * FROM `/Root/TwoShard` ORDER BY Key;\n@@ -1801,8 +1827,10 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {\n         ])\", FormatResultSetYson(result.GetResultSet(0)));\n     }\n \n-    Y_UNIT_TEST(Delete) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_TWIN(Delete, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n \n@@ -1817,19 +1845,30 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n \n         auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n+        if (UseSink) {\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);\n \n-        // Phase reading rows to delete\n-        UNIT_ASSERT(stats.query_phases(0).duration_us() > 0);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/TwoShard\");\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 6);\n+            // Phase reading rows to delete\n+            UNIT_ASSERT(stats.query_phases(0).duration_us() > 0);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/TwoShard\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 6);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).deletes().rows(), 2);\n+        } else {\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n \n-        // Phase deleting rows\n-        UNIT_ASSERT(stats.query_phases(1).duration_us() > 0);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/TwoShard\");\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).deletes().rows(), 2);\n+            // Phase reading rows to delete\n+            UNIT_ASSERT(stats.query_phases(0).duration_us() > 0);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/TwoShard\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 6);\n+\n+            // Phase deleting rows\n+            UNIT_ASSERT(stats.query_phases(1).duration_us() > 0);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/TwoShard\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).deletes().rows(), 2);\n+        }\n \n         result = session.ExecuteDataQuery(R\"(\n \n@@ -1845,8 +1884,10 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {\n         ])\", FormatResultSetYson(result.GetResultSet(0)));\n     }\n \n-    Y_UNIT_TEST(DeleteOn) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_TWIN(DeleteOn, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n \n@@ -1861,19 +1902,30 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n \n         auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n+        if (UseSink) {\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);\n+\n+            // Phase reading rows to delete\n+            UNIT_ASSERT(stats.query_phases(0).duration_us() > 0);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/TwoShard\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 6);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).deletes().rows(), 2);\n+        } else {\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n \n-        // Phase reading rows to delete\n-        UNIT_ASSERT(stats.query_phases(0).duration_us() > 0);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/TwoShard\");\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 6);\n+            // Phase reading rows to delete\n+            UNIT_ASSERT(stats.query_phases(0).duration_us() > 0);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/TwoShard\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 6);\n \n-        // Phase deleting rows\n-        UNIT_ASSERT(stats.query_phases(1).duration_us() > 0);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/TwoShard\");\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).deletes().rows(), 2);\n+            // Phase deleting rows\n+            UNIT_ASSERT(stats.query_phases(1).duration_us() > 0);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/TwoShard\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).deletes().rows(), 2);\n+        }\n \n         result = session.ExecuteDataQuery(R\"(\n \n@@ -1969,8 +2021,11 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {\n             ])\", FormatResultSetYson(result.GetResultSet(0)));\n     }\n \n-    Y_UNIT_TEST(PruneEffectPartitions) {\n+    Y_UNIT_TEST_TWIN(PruneEffectPartitions, UseSink) {\n         TKikimrSettings serverSettings;\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        serverSettings.SetAppConfig(app);\n         TKikimrRunner kikimr(serverSettings);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n@@ -1996,19 +2051,29 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {\n         UNIT_ASSERT_C(it.IsSuccess(), it.GetIssues().ToString());\n \n         auto& stats = NYdb::TProtoAccessor::GetProto(*it.GetStats());\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n+        if (UseSink) {\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);\n+\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/EightShard\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 1);\n+        } else {\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n \n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/EightShard\");\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 1);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 0);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/EightShard\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 0);\n \n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).affected_shards(), 1);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).partitions_count(), 1);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/EightShard\");\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).reads().rows(), 0);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).affected_shards(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).partitions_count(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/EightShard\");\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).reads().rows(), 0);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);\n+        }\n \n         it = session.ExecuteDataQuery(R\"(\n \n@@ -2606,8 +2671,10 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {\n         }\n     }\n \n-    Y_UNIT_TEST(DeleteWithBuiltin) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_TWIN(DeleteWithBuiltin, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);;\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n \n@@ -2620,7 +2687,7 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n \n         auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n-        UNIT_ASSERT_EQUAL(stats.query_phases().size(), 2);\n+        UNIT_ASSERT_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);\n     }\n \n     Y_UNIT_TEST(MultiEffectsOnSameTable) {\n@@ -3034,8 +3101,10 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {\n         ])\", FormatResultSetYson(result.GetResultSet(0)));\n     }\n \n-    Y_UNIT_TEST(DeleteWithInputMultiConsumption) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_TWIN(DeleteWithInputMultiConsumption, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n \n@@ -3055,7 +3124,7 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n \n         AssertTableStats(result, \"/Root/Join1\", {\n-            .ExpectedReads = 9,\n+            .ExpectedReads = UseSink ? 18 : 9, // without sink: precompute\n         });\n \n         AssertTableStats(result, \"/Root/Join2\", {\n@@ -3078,8 +3147,10 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {\n         ])\", FormatResultSetYson(result.GetResultSet(0)));\n     }\n \n-    Y_UNIT_TEST(DeleteWithInputMultiConsumptionLimit) {\n-        TKikimrRunner kikimr;\n+    Y_UNIT_TEST_TWIN(DeleteWithInputMultiConsumptionLimit, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n \n@@ -3106,7 +3177,7 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n \n         AssertTableStats(result, \"/Root/Test\", {\n-            .ExpectedReads = 1,\n+            .ExpectedReads = UseSink ? 2 : 1, // without sink: precompute\n             .ExpectedDeletes = 2,\n         });\n \ndiff --git a/ydb/core/kqp/ut/opt/kqp_not_null_ut.cpp b/ydb/core/kqp/ut/opt/kqp_not_null_ut.cpp\nindex 484bee1fb7af..e361195e91f0 100644\n--- a/ydb/core/kqp/ut/opt/kqp_not_null_ut.cpp\n+++ b/ydb/core/kqp/ut/opt/kqp_not_null_ut.cpp\n@@ -159,8 +159,10 @@ Y_UNIT_TEST_SUITE(KqpNotNullColumns) {\n         }\n     }\n \n-    Y_UNIT_TEST(InsertNotNullPkPg) {\n-        TKikimrRunner kikimr(NKqp::TKikimrSettings().SetWithSampleTables(false));\n+    Y_UNIT_TEST_TWIN(InsertNotNullPkPg, useSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);\n+        TKikimrRunner kikimr(NKqp::TKikimrSettings().SetWithSampleTables(false).SetAppConfig(appConfig));\n         auto client = kikimr.GetTableClient();\n         auto session = client.CreateSession().GetValueSync().GetSession();\n         {\n@@ -193,8 +195,12 @@ Y_UNIT_TEST_SUITE(KqpNotNullColumns) {\n             auto result = session.ExecuteDataQuery(query, TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n             UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::BAD_REQUEST);\n             UNIT_ASSERT_C(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_BAD_COLUMN_TYPE), result.GetIssues().ToString());\n-            UNIT_ASSERT_NO_DIFF(result.GetIssues().ToString(), \"<main>: Error: Execution, code: 1060\\n\"\n-            \"    <main>: Error: Tried to insert NULL value into NOT NULL column: key, code: 2031\\n\");\n+            if (useSink) {\n+                UNIT_ASSERT_NO_DIFF(result.GetIssues().ToString(), \"<main>: Error: Tried to insert NULL value into NOT NULL column: key, code: 2031\\n\");\n+            } else {\n+                UNIT_ASSERT_NO_DIFF(result.GetIssues().ToString(), \"<main>: Error: Execution, code: 1060\\n\"\n+                \"    <main>: Error: Tried to insert NULL value into NOT NULL column: key, code: 2031\\n\");\n+            }\n         }\n \n         {   /* set NULL to not null pk column */\n@@ -206,8 +212,12 @@ Y_UNIT_TEST_SUITE(KqpNotNullColumns) {\n             auto result = session.ExecuteDataQuery(query, TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n             UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::BAD_REQUEST);\n             UNIT_ASSERT_C(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_BAD_COLUMN_TYPE), result.GetIssues().ToString());\n-            UNIT_ASSERT_NO_DIFF(result.GetIssues().ToString(), \"<main>: Error: Execution, code: 1060\\n\"\n-            \"    <main>: Error: Tried to insert NULL value into NOT NULL column: key, code: 2031\\n\");\n+            if (useSink) {\n+                UNIT_ASSERT_NO_DIFF(result.GetIssues().ToString(), \"<main>: Error: Tried to insert NULL value into NOT NULL column: key, code: 2031\\n\");\n+            } else {\n+                UNIT_ASSERT_NO_DIFF(result.GetIssues().ToString(), \"<main>: Error: Execution, code: 1060\\n\"\n+                \"    <main>: Error: Tried to insert NULL value into NOT NULL column: key, code: 2031\\n\");\n+            }\n         }\n \n         {   /* set NULL to nullable column */\n@@ -609,10 +619,13 @@ Y_UNIT_TEST_SUITE(KqpNotNullColumns) {\n         }\n     }\n \n-    Y_UNIT_TEST(InsertNotNullPg) {\n+    Y_UNIT_TEST_TWIN(InsertNotNullPg, useSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);\n         auto settings = TKikimrSettings()\n             .SetWithSampleTables(false)\n-            .SetEnableNotNullDataColumns(true);\n+            .SetEnableNotNullDataColumns(true)\n+            .SetAppConfig(appConfig);\n \n         TKikimrRunner kikimr(settings);\n         auto client = kikimr.GetTableClient();\n@@ -648,8 +661,13 @@ Y_UNIT_TEST_SUITE(KqpNotNullColumns) {\n             auto result = session.ExecuteDataQuery(query, TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n             UNIT_ASSERT(!result.IsSuccess());\n             UNIT_ASSERT_C(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_BAD_COLUMN_TYPE), result.GetIssues().ToString());\n-            UNIT_ASSERT_NO_DIFF(result.GetIssues().ToString(), \"<main>: Error: Execution, code: 1060\\n\"\n-            \"    <main>: Error: Tried to insert NULL value into NOT NULL column: Value, code: 2031\\n\");\n+            if (useSink) {\n+                UNIT_ASSERT_NO_DIFF(result.GetIssues().ToString(),\n+                    \"<main>: Error: Tried to insert NULL value into NOT NULL column: Value, code: 2031\\n\");\n+            } else {\n+                UNIT_ASSERT_NO_DIFF(result.GetIssues().ToString(), \"<main>: Error: Execution, code: 1060\\n\"\n+                    \"    <main>: Error: Tried to insert NULL value into NOT NULL column: Value, code: 2031\\n\");\n+            }\n         }\n     }\n \ndiff --git a/ydb/core/kqp/ut/opt/kqp_ranges_ut.cpp b/ydb/core/kqp/ut/opt/kqp_ranges_ut.cpp\nindex 6e7f71260123..ae96754614e3 100644\n--- a/ydb/core/kqp/ut/opt/kqp_ranges_ut.cpp\n+++ b/ydb/core/kqp/ut/opt/kqp_ranges_ut.cpp\n@@ -627,8 +627,11 @@ Y_UNIT_TEST_SUITE(KqpRanges) {\n         }\n     }\n \n-    Y_UNIT_TEST(UpdateWhereInNoFullScan) {\n+    Y_UNIT_TEST_TWIN(UpdateWhereInNoFullScan, UseSink) {\n         TKikimrSettings settings;\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        settings.SetAppConfig(app);\n         TKikimrRunner kikimr(settings);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n@@ -645,24 +648,38 @@ Y_UNIT_TEST_SUITE(KqpRanges) {\n             UNIT_ASSERT(result.IsSuccess());\n \n             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n-            size_t readPhase = 0;\n-            if (stats.query_phases().size() == 3) {\n-                readPhase = 1;\n-            } else {\n+            if (UseSink) {\n                 UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n-            }\n \n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).affected_shards(), 1);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).table_access().size(), 1);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).table_access(0).name(), \"/Root/MultiShardTable\");\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).table_access(0).reads().rows(), 1);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).table_access(0).partitions_count(), 1);\n-\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).affected_shards(), 1);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).table_access().size(), 1);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).table_access(0).name(), \"/Root/MultiShardTable\");\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).table_access(0).updates().rows(), 1);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).table_access(0).partitions_count(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 0);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 0);\n+\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).affected_shards(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/MultiShardTable\");\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).reads().rows(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).partitions_count(), 2);\n+            } else {\n+                size_t readPhase = 0;\n+                if (stats.query_phases().size() == 3) {\n+                    readPhase = 1;\n+                } else {\n+                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n+                }\n+\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).affected_shards(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).table_access().size(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).table_access(0).name(), \"/Root/MultiShardTable\");\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).table_access(0).reads().rows(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).table_access(0).partitions_count(), 1);\n+\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).affected_shards(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).table_access().size(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).table_access(0).name(), \"/Root/MultiShardTable\");\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).table_access(0).updates().rows(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).table_access(0).partitions_count(), 1);\n+            }\n         }\n     }\n \n@@ -806,8 +823,12 @@ Y_UNIT_TEST_SUITE(KqpRanges) {\n         }\n     }\n \n-    Y_UNIT_TEST(UpdateWhereInFullScan) {\n-        TKikimrRunner kikimr;\n+    Y_UNIT_TEST_TWIN(UpdateWhereInFullScan, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        TKikimrSettings settings;\n+        settings.SetAppConfig(app);\n+        TKikimrRunner kikimr(settings);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n \n@@ -823,19 +844,31 @@ Y_UNIT_TEST_SUITE(KqpRanges) {\n             UNIT_ASSERT(result.IsSuccess());\n \n             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n \n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 5);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/MultiShardTable\");\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 6);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).partitions_count(), 5);\n+            if (UseSink) {\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);\n \n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).affected_shards(), 5);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/MultiShardTable\");\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);\n-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).partitions_count(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 5);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/MultiShardTable\");\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 6);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).partitions_count(), 6); // partitions_count is partition operations count\n+            } else {\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n+\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 5);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/MultiShardTable\");\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 6);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).partitions_count(), 5);\n+\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).affected_shards(), 5);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/MultiShardTable\");\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);\n+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).partitions_count(), 1);\n+            }\n         }\n     }\n \n@@ -1023,8 +1056,11 @@ Y_UNIT_TEST_SUITE(KqpRanges) {\n         UNIT_ASSERT(!read.Has(\"lookup_by\"));\n     }\n \n-    Y_UNIT_TEST(DeleteNotFullScan) {\n+    Y_UNIT_TEST_TWIN(DeleteNotFullScan, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         TKikimrSettings serverSettings;\n+        serverSettings.SetAppConfig(app);\n         TKikimrRunner kikimr(serverSettings);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n@@ -1045,17 +1081,28 @@ Y_UNIT_TEST_SUITE(KqpRanges) {\n         Cerr << result.GetQueryPlan() << Endl;\n \n         auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n+        if (UseSink) {\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);\n \n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 0);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 0);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 0);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 0);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).deletes().rows(), 3);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).partitions_count(), 1);\n+        } else {\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n+\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 0);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 0);\n \n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).affected_shards(), 1);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).reads().rows(), 0);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 0);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).deletes().rows(), 3);\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).partitions_count(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).affected_shards(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).reads().rows(), 0);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 0);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).deletes().rows(), 3);\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).partitions_count(), 1);\n+        }\n     }\n \n     Y_UNIT_TEST(LiteralOr) {\ndiff --git a/ydb/core/kqp/ut/perf/kqp_query_perf_ut.cpp b/ydb/core/kqp/ut/perf/kqp_query_perf_ut.cpp\nindex eeadaf267bf9..edcc7c74a2ee 100644\n--- a/ydb/core/kqp/ut/perf/kqp_query_perf_ut.cpp\n+++ b/ydb/core/kqp/ut/perf/kqp_query_perf_ut.cpp\n@@ -318,8 +318,10 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {\n         UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), EnableStreamLookup ? 1 : 2);\n     }\n \n-    Y_UNIT_TEST_TWIN(Upsert, QueryService) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_QUAD(Upsert, QueryService, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n \n         auto params = BuildUpdateParams();\n \n@@ -338,15 +340,17 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {\n \n \n         // TODO: Get rid of additional precompute stage for adding optionality to row members\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);\n \n         for (const auto& phase : stats.query_phases()) {\n             UNIT_ASSERT(phase.affected_shards() <= 2);\n         }\n     }\n \n-    Y_UNIT_TEST_TWIN(Replace, QueryService) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_QUAD(Replace, QueryService, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n \n         auto params = BuildUpdateParams();\n \n@@ -363,15 +367,17 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {\n         });\n \n         // Single-phase REPLACE require additional runtime write callable\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);\n \n         for (const auto& phase : stats.query_phases()) {\n             UNIT_ASSERT(phase.affected_shards() <= 2);\n         }\n     }\n \n-    Y_UNIT_TEST_TWIN(UpdateOn, QueryService) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_QUAD(UpdateOn, QueryService, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n \n         auto params = BuildUpdateParams();\n \n@@ -383,20 +389,22 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {\n         )\"), params);\n \n         AssertTableStats(stats, \"/Root/EightShard\", {\n-            .ExpectedReads = 1, // Non-existing keys don't count in reads\n+            .ExpectedReads = UseSink ? 0 : 1, // Non-existing keys don't count in reads\n             .ExpectedUpdates = 1,\n         });\n \n         // Two-phase UPDATE ON require more complex runtime callables\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 3);\n+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 3);\n \n         for (const auto& phase : stats.query_phases()) {\n             UNIT_ASSERT(phase.affected_shards() <= 2);\n         }\n     }\n \n-    Y_UNIT_TEST_TWIN(Insert, QueryService) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_QUAD(Insert, QueryService, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n \n         auto params = BuildInsertParams();\n \n@@ -413,15 +421,17 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {\n         });\n \n         // Three-phase INSERT require more complex runtime callables\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 4);\n+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 4);\n \n         for (const auto& phase : stats.query_phases()) {\n             UNIT_ASSERT(phase.affected_shards() <= 2);\n         }\n     }\n \n-    Y_UNIT_TEST_TWIN(DeleteOn, QueryService) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_QUAD(DeleteOn, QueryService, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n \n         auto params = BuildDeleteParams();\n \n@@ -438,15 +448,17 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {\n         });\n \n         // TODO: Get rid of additional precompute stage for adding optionality to row members\n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);\n \n         for (const auto& phase : stats.query_phases()) {\n             UNIT_ASSERT(phase.affected_shards() <= 2);\n         }\n     }\n \n-    Y_UNIT_TEST_TWIN(Update, QueryService) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_QUAD(Update, QueryService, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n \n         auto params = TParamsBuilder()\n             .AddParam(\"$key\").Uint64(201).Build()\n@@ -465,15 +477,17 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {\n             .ExpectedUpdates = 1,\n         });\n \n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);\n \n         for (const auto& phase : stats.query_phases()) {\n             UNIT_ASSERT(phase.affected_shards() <= 1);\n         }\n     }\n \n-    Y_UNIT_TEST_TWIN(Delete, QueryService) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_QUAD(Delete, QueryService, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n \n         auto params = TParamsBuilder()\n             .AddParam(\"$key\").Uint64(201).Build()\n@@ -493,15 +507,17 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {\n             .ExpectedDeletes = 1,\n         });\n \n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);\n \n         for (const auto& phase : stats.query_phases()) {\n             UNIT_ASSERT(phase.affected_shards() <= 1);\n         }\n     }\n \n-    Y_UNIT_TEST_TWIN(IndexUpsert, QueryService) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_QUAD(IndexUpsert, QueryService, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n         CreateSampleTablesWithIndex(session);\n@@ -516,11 +532,13 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {\n         )\"), params);\n \n \n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 5);\n+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 4 : 5);\n     }\n \n-    Y_UNIT_TEST_TWIN(IndexReplace, QueryService) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_QUAD(IndexReplace, QueryService, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n         CreateSampleTablesWithIndex(session);\n@@ -534,11 +552,13 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {\n             SELECT * FROM AS_TABLE($items);\n         )\"), params);\n \n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 5);\n+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 4 : 5);\n     }\n \n-    Y_UNIT_TEST_TWIN(IndexUpdateOn, QueryService) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_QUAD(IndexUpdateOn, QueryService, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n         CreateSampleTablesWithIndex(session);\n@@ -552,11 +572,13 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {\n             SELECT * FROM AS_TABLE($items);\n         )\"), params);\n \n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 5);\n+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 4 : 5);\n     }\n \n-    Y_UNIT_TEST_TWIN(IndexDeleteOn, QueryService) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_QUAD(IndexDeleteOn, QueryService, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n         CreateSampleTablesWithIndex(session);\n@@ -570,11 +592,13 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {\n             SELECT * FROM AS_TABLE($items);\n         )\"), params);\n \n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 4);\n+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 3 : 4);\n     }\n \n-    Y_UNIT_TEST_TWIN(IndexInsert, QueryService) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_QUAD(IndexInsert, QueryService, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n         CreateSampleTablesWithIndex(session);\n@@ -588,7 +612,7 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {\n             SELECT * FROM AS_TABLE($items);\n         )\"), params);\n \n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 5);\n+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 4 : 5);\n     }\n \n     Y_UNIT_TEST_TWIN(IdxLookupJoin, QueryService) {\n@@ -672,8 +696,10 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {\n         UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n     }\n \n-    Y_UNIT_TEST_TWIN(MultiDeleteFromTable, QueryService) {\n-        TKikimrRunner kikimr;\n+    Y_UNIT_TEST_QUAD(MultiDeleteFromTable, QueryService, UseSink) {\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n \n         auto params = TParamsBuilder()\n             .AddParam(\"$key1_1\").Uint32(101).Build()\n@@ -701,7 +727,7 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {\n \n         CompareYson(R\"([[7u]])\", FormatResultSetYson(checkResults[0]));\n \n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);\n \n         AssertTableStats(stats, \"/Root/Join2\", {\n             .ExpectedReads = 3,\ndiff --git a/ydb/core/kqp/ut/pg/pg_catalog_ut.cpp b/ydb/core/kqp/ut/pg/pg_catalog_ut.cpp\nindex abb93736098e..ad9b88a0c48a 100644\n--- a/ydb/core/kqp/ut/pg/pg_catalog_ut.cpp\n+++ b/ydb/core/kqp/ut/pg/pg_catalog_ut.cpp\n@@ -352,8 +352,10 @@ Y_UNIT_TEST_SUITE(PgCatalog) {\n         }\n     }\n \n-    Y_UNIT_TEST(PgDatabase) {\n-        TKikimrRunner kikimr(NKqp::TKikimrSettings().SetWithSampleTables(false));\n+    Y_UNIT_TEST_TWIN(PgDatabase, useSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);\n+        TKikimrRunner kikimr(NKqp::TKikimrSettings().SetWithSampleTables(false).SetAppConfig(appConfig));\n         auto db = kikimr.GetQueryClient();\n         auto settings = NYdb::NQuery::TExecuteQuerySettings().Syntax(NYdb::NQuery::ESyntax::Pg);\n         {\ndiff --git a/ydb/core/kqp/ut/query/kqp_explain_ut.cpp b/ydb/core/kqp/ut/query/kqp_explain_ut.cpp\nindex 218a9e49e6d9..ef533a5d67a2 100644\n--- a/ydb/core/kqp/ut/query/kqp_explain_ut.cpp\n+++ b/ydb/core/kqp/ut/query/kqp_explain_ut.cpp\n@@ -495,8 +495,11 @@ Y_UNIT_TEST_SUITE(KqpExplain) {\n         }\n     }\n \n-    Y_UNIT_TEST(FewEffects) {\n+    Y_UNIT_TEST_TWIN(FewEffects, UseSink) {\n         TKikimrSettings settings;\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        settings.SetAppConfig(app);\n         TKikimrRunner kikimr(settings);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n@@ -514,11 +517,17 @@ Y_UNIT_TEST_SUITE(KqpExplain) {\n \n         Cerr << plan << Endl;\n \n-        auto upsertsCount = CountPlanNodesByKv(plan, \"Node Type\", \"Upsert-ConstantExpr\");\n-        UNIT_ASSERT_VALUES_EQUAL(upsertsCount, 2);\n+        auto upsertsConstCount = CountPlanNodesByKv(plan, \"Node Type\", \"Upsert-ConstantExpr\");\n+        UNIT_ASSERT_VALUES_EQUAL(upsertsConstCount, UseSink ? 0 : 2);\n \n-        auto deletesCount = CountPlanNodesByKv(plan, \"Node Type\", \"Delete-ConstantExpr\");\n-        UNIT_ASSERT_VALUES_EQUAL(deletesCount, 1);\n+        auto deletesConstCount = CountPlanNodesByKv(plan, \"Node Type\", \"Delete-ConstantExpr\");\n+        UNIT_ASSERT_VALUES_EQUAL(deletesConstCount, UseSink ? 0 : 1);\n+\n+        auto upsertsCount = CountPlanNodesByKv(plan, \"Name\", \"Upsert\");\n+        UNIT_ASSERT_VALUES_EQUAL(upsertsCount, UseSink ? 2 : 2);\n+\n+        auto deletesCount = CountPlanNodesByKv(plan, \"Name\", \"Delete\");\n+        UNIT_ASSERT_VALUES_EQUAL(deletesCount, UseSink ? 1 : 1);\n \n         auto fullScansCount = CountPlanNodesByKv(plan, \"Node Type\", \"TableFullScan\");\n         UNIT_ASSERT_VALUES_EQUAL(fullScansCount, 1);\n@@ -540,8 +549,8 @@ Y_UNIT_TEST_SUITE(KqpExplain) {\n         countOperationsByType(\"reads\");\n         countOperationsByType(\"writes\");\n \n-        UNIT_ASSERT_VALUES_EQUAL(counter[\"MultiUpsert\"], upsertsCount);\n-        UNIT_ASSERT_VALUES_EQUAL(counter[\"MultiErase\"], deletesCount);\n+        UNIT_ASSERT_VALUES_EQUAL(counter[\"MultiUpsert\"], UseSink ? upsertsCount : upsertsConstCount);\n+        UNIT_ASSERT_VALUES_EQUAL(counter[\"MultiErase\"], UseSink ? deletesCount : deletesConstCount);\n         UNIT_ASSERT_VALUES_EQUAL(counter[\"FullScan\"], fullScansCount);\n         UNIT_ASSERT_VALUES_EQUAL(counter[\"Scan\"], rangeScansCount);\n     }\ndiff --git a/ydb/core/kqp/ut/query/kqp_limits_ut.cpp b/ydb/core/kqp/ut/query/kqp_limits_ut.cpp\nindex bca95aa56d68..85d59bbf920d 100644\n--- a/ydb/core/kqp/ut/query/kqp_limits_ut.cpp\n+++ b/ydb/core/kqp/ut/query/kqp_limits_ut.cpp\n@@ -54,8 +54,15 @@ namespace {\n }\n \n Y_UNIT_TEST_SUITE(KqpLimits) {\n-    Y_UNIT_TEST(QSReplySizeEnsureMemoryLimits) {\n-        TKikimrRunner kikimr;\n+    Y_UNIT_TEST_TWIN(QSReplySizeEnsureMemoryLimits, useSink) {\n+        auto app = NKikimrConfig::TAppConfig();\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(useSink);\n+\n+        auto settings = TKikimrSettings()\n+            .SetAppConfig(app)\n+            .SetWithSampleTables(true);\n+\n+        TKikimrRunner kikimr(settings);\n         CreateLargeTable(kikimr, 1'000, 100, 1'000, 1'000);\n \n         auto db = kikimr.GetQueryClient();\n@@ -80,7 +87,58 @@ Y_UNIT_TEST_SUITE(KqpLimits) {\n         )\", NQuery::TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n         result.GetIssues().PrintTo(Cerr);\n         UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::PRECONDITION_FAILED);\n-        UNIT_ASSERT(!to_lower(TString{result.GetIssues().ToString()}).Contains(\"query result\"));\n+        UNIT_ASSERT_C(\n+            !to_lower(TString{result.GetIssues().ToString()}).Contains(\"query result\"),\n+            result.GetIssues().ToString());\n+        if (useSink) {\n+            UNIT_ASSERT_C(\n+                result.GetIssues().ToString().contains(\"Memory limit exception, current limit is 1024 bytes.\"),\n+                result.GetIssues().ToString());\n+        }\n+    }\n+\n+    Y_UNIT_TEST_TWIN(StreamWrite, Allowed) {\n+        auto app = NKikimrConfig::TAppConfig();\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(true);\n+        app.MutableTableServiceConfig()->SetEnableStreamWrite(Allowed);\n+        app.MutableTableServiceConfig()->MutableWriteActorSettings()->SetInFlightMemoryLimitPerActorBytes(64);\n+\n+        auto settings = TKikimrSettings()\n+            .SetAppConfig(app)\n+            .SetWithSampleTables(false);\n+\n+        TKikimrRunner kikimr(settings);\n+\n+        auto db = kikimr.GetQueryClient();\n+        \n+        {\n+            auto result = db.ExecuteQuery(R\"(\n+                CREATE TABLE `/Root/DataShard` (\n+                    Col1 Uint64 NOT NULL,\n+                    Col2 String NOT NULL,\n+                    Col3 Int32 NOT NULL,\n+                    PRIMARY KEY (Col1)\n+                )\n+                WITH (UNIFORM_PARTITIONS = 2, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = 2);)\",\n+                NQuery::TTxControl::NoTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::SUCCESS);\n+        }\n+\n+        {\n+            auto result = db.ExecuteQuery(R\"(\n+                UPSERT INTO `/Root/DataShard` (Col1, Col2, Col3) VALUES\n+                    (10u, \"test1\", 10), (20u, \"test2\", 11), (30u, \"test3\", 12), (40u, \"test\", 13);\n+            )\", NQuery::TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            result.GetIssues().PrintTo(Cerr);\n+            if (!Allowed) {\n+                UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::PRECONDITION_FAILED);\n+                UNIT_ASSERT_C(\n+                    result.GetIssues().ToString().contains(\"Stream write queries aren't allowed.\"),\n+                    result.GetIssues().ToString());\n+            } else {\n+                UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::SUCCESS);\n+            }\n+        }\n     }\n \n     Y_UNIT_TEST(KqpMkqlMemoryLimitException) {\n@@ -164,14 +222,19 @@ Y_UNIT_TEST_SUITE(KqpLimits) {\n         UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::BAD_REQUEST);\n     }\n \n-    Y_UNIT_TEST(ComputeActorMemoryAllocationFailure) {\n+    Y_UNIT_TEST_TWIN(ComputeActorMemoryAllocationFailure, useSink) {\n         auto app = NKikimrConfig::TAppConfig();\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(useSink);\n         app.MutableTableServiceConfig()->MutableResourceManager()->SetMkqlLightProgramMemoryLimit(10);\n         app.MutableTableServiceConfig()->MutableResourceManager()->SetQueryMemoryLimit(2000);\n \n         app.MutableResourceBrokerConfig()->CopyFrom(MakeResourceBrokerTestConfig());\n \n-        TKikimrRunner kikimr(app);\n+        auto settings = TKikimrSettings()\n+            .SetAppConfig(app)\n+            .SetWithSampleTables(false);\n+\n+        TKikimrRunner kikimr(settings);\n         CreateLargeTable(kikimr, 0, 0, 0);\n \n         kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::KQP_SLOW_LOG, NActors::NLog::PRI_ERROR);\n@@ -188,8 +251,9 @@ Y_UNIT_TEST_SUITE(KqpLimits) {\n         UNIT_ASSERT_C(result.GetIssues().ToString().contains(\"Mkql memory limit exceeded\"), result.GetIssues().ToString());\n     }\n \n-    Y_UNIT_TEST(ComputeActorMemoryAllocationFailureQueryService) {\n+    Y_UNIT_TEST_TWIN(ComputeActorMemoryAllocationFailureQueryService, useSink) {\n         auto app = NKikimrConfig::TAppConfig();\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(useSink);\n         app.MutableTableServiceConfig()->MutableResourceManager()->SetMkqlLightProgramMemoryLimit(10);\n         app.MutableTableServiceConfig()->MutableResourceManager()->SetQueryMemoryLimit(2000);\n \n@@ -197,7 +261,11 @@ Y_UNIT_TEST_SUITE(KqpLimits) {\n \n         app.MutableFeatureFlags()->SetEnableResourcePools(true);\n \n-        TKikimrRunner kikimr(app);\n+        auto settings = TKikimrSettings()\n+            .SetAppConfig(app)\n+            .SetWithSampleTables(false);\n+\n+        TKikimrRunner kikimr(settings);\n         CreateLargeTable(kikimr, 0, 0, 0);\n \n         kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::KQP_SLOW_LOG, NActors::NLog::PRI_ERROR);\n@@ -220,11 +288,16 @@ Y_UNIT_TEST_SUITE(KqpLimits) {\n         Cerr << stats->ToString(true) << Endl;\n     }\n \n-    Y_UNIT_TEST(DatashardProgramSize) {\n+    Y_UNIT_TEST_TWIN(DatashardProgramSize, useSink) {\n         auto app = NKikimrConfig::TAppConfig();\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(useSink);\n         app.MutableTableServiceConfig()->MutableResourceManager()->SetMkqlLightProgramMemoryLimit(1'000'000'000);\n \n-        TKikimrRunner kikimr(app);\n+        auto settings = TKikimrSettings()\n+            .SetAppConfig(app)\n+            .SetWithSampleTables(false);\n+\n+        TKikimrRunner kikimr(settings);\n         CreateLargeTable(kikimr, 0, 0, 0);\n \n         kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::KQP_SLOW_LOG, NActors::NLog::PRI_ERROR);\n@@ -259,9 +332,12 @@ Y_UNIT_TEST_SUITE(KqpLimits) {\n             SELECT * FROM AS_TABLE($rows);\n         )\"), TTxControl::BeginTx().CommitTx(), paramsBuilder.Build()).ExtractValueSync();\n         result.GetIssues().PrintTo(Cerr);\n-        // UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::PRECONDITION_FAILED);\n-        UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::ABORTED);\n-        UNIT_ASSERT(HasIssue(result.GetIssues(), NKikimrIssues::TIssuesIds::SHARD_PROGRAM_SIZE_EXCEEDED));\n+        if (useSink) {\n+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::SUCCESS);\n+        } else {\n+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::ABORTED);\n+            UNIT_ASSERT(HasIssue(result.GetIssues(), NKikimrIssues::TIssuesIds::SHARD_PROGRAM_SIZE_EXCEEDED));\n+        }\n     }\n \n     Y_UNIT_TEST(DatashardReplySize) {\n@@ -361,13 +437,22 @@ Y_UNIT_TEST_SUITE(KqpLimits) {\n         }\n     }\n \n-    Y_UNIT_TEST(OutOfSpaceYQLUpsertFail) {\n-        TKikimrRunner kikimr(NFake::TStorage{\n-            .UseDisk = false,\n-            .SectorSize = 4096,\n-            .ChunkSize = 32_MB,\n-            .DiskSize = 8_GB\n-        });\n+    Y_UNIT_TEST_TWIN(OutOfSpaceYQLUpsertFail, useSink) {\n+        auto app = NKikimrConfig::TAppConfig();\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(useSink);\n+        app.MutableTableServiceConfig()->MutableResourceManager()->SetMkqlLightProgramMemoryLimit(1'000'000'000);\n+\n+        auto settings = TKikimrSettings()\n+            .SetAppConfig(app)\n+            .SetWithSampleTables(false)\n+            .SetStorage(NFake::TStorage{\n+                .UseDisk = false,\n+                .SectorSize = 4096,\n+                .ChunkSize = 32_MB,\n+                .DiskSize = 8_GB\n+            });\n+\n+        TKikimrRunner kikimr(settings);\n \n         kikimr.GetTestClient().CreateTable(\"/Root\", R\"(\n             Name: \"LargeTable\"\n@@ -384,7 +469,6 @@ Y_UNIT_TEST_SUITE(KqpLimits) {\n \n         auto session = client.CreateSession().GetValueSync().GetSession();\n \n-        bool getOutOfSpace = false;\n         ui32 batchIdx = 0;\n         ui32 cnt = 0;\n \n@@ -412,27 +496,43 @@ Y_UNIT_TEST_SUITE(KqpLimits) {\n                 UPSERT INTO `/Root/LargeTable`\n                 SELECT * FROM AS_TABLE($rows);\n             )\"), TTxControl::BeginTx().CommitTx(), paramsBuilder.Build()).ExtractValueSync();\n-            if (IsRetryable(result.GetStatus())) {\n+ \n+            switch (result.GetStatus()) {\n+            case EStatus::SUCCESS:\n                 continue;\n-            }\n-            if (result.GetStatus() != EStatus::SUCCESS) {\n-                result.GetIssues().PrintTo(Cerr);\n-                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::UNAVAILABLE, result.GetIssues().ToString());\n-                if (result.GetIssues().ToString().contains(\"OUT_OF_SPACE\")) {\n-                    getOutOfSpace = true;\n-                } else if (result.GetIssues().ToString().contains(\"WRONG_SHARD_STATE\")) {\n+            case EStatus::OVERLOADED:\n+                if (result.GetIssues().ToString().contains(\"out of disk space\")) {\n+                    UNIT_ASSERT(useSink);\n+                    Cerr << \"Got out of space. Successfully inserted \" << rowsPerBatch << \" x \" << batchIdx << \" lines, each of size \" << dataTextSize << \"bytes\";\n+                    return;\n+                } else {\n+                    continue;\n+                }\n+            case EStatus::UNAVAILABLE:\n+                if (result.GetIssues().ToString().contains(\"out of disk space\")) {\n+                    UNIT_ASSERT(!useSink);\n+                    //TODO Should be also EStatus::OVERLOADED\n+                    Cerr << \"Got out of space. Successfully inserted \" << rowsPerBatch << \" x \" << batchIdx << \" lines, each of size \" << dataTextSize << \"bytes\";\n+                    return;\n+                } else if (result.GetIssues().ToString().contains(\"WRONG_SHARD_STATE\")\n+                        || result.GetIssues().ToString().contains(\"wrong shard state\")\n+                        || result.GetIssues().ToString().contains(\"can't deliver message to tablet\")) {\n                     // shards are allowed to split\n                     continue;\n                 }\n-                break;\n+                UNIT_ASSERT_C(false, \"Unexpected UNAVAILABLE status\" << result.GetIssues().ToString());\n+            default:\n+                UNIT_ASSERT_C(false, \"Unexpected status\" << result.GetStatus() << result.GetIssues().ToString());\n             }\n+\n             ++batchIdx;\n         }\n-        UNIT_ASSERT_C(getOutOfSpace, \"Successfully inserted \" << rowsPerBatch << \" x \" << batchCount << \" lines, each of size \" << dataTextSize << \"bytes\");\n+        UNIT_FAIL(\"Out of space is expected\");\n     }\n \n-    Y_UNIT_TEST(TooBigQuery) {\n+    Y_UNIT_TEST_TWIN(TooBigQuery, useSink) {\n         auto app = NKikimrConfig::TAppConfig();\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(useSink);\n         app.MutableTableServiceConfig()->MutableResourceManager()->SetMkqlLightProgramMemoryLimit(1'000'000'000);\n         app.MutableTableServiceConfig()->SetCompileTimeoutMs(TDuration::Minutes(5).MilliSeconds());\n \n@@ -468,8 +568,12 @@ Y_UNIT_TEST_SUITE(KqpLimits) {\n         auto result = session.ExecuteDataQuery(query, TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n         result.GetIssues().PrintTo(Cerr);\n         //UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());\n-        UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::ABORTED, result.GetIssues().ToString());\n-        UNIT_ASSERT(HasIssue(result.GetIssues(), NKikimrIssues::TIssuesIds::SHARD_PROGRAM_SIZE_EXCEEDED));\n+        if (useSink) {\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+        } else {\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::ABORTED, result.GetIssues().ToString());\n+            UNIT_ASSERT(HasIssue(result.GetIssues(), NKikimrIssues::TIssuesIds::SHARD_PROGRAM_SIZE_EXCEEDED));\n+        }\n     }\n \n     Y_UNIT_TEST(BigParameter) {\n@@ -522,8 +626,12 @@ Y_UNIT_TEST_SUITE(KqpLimits) {\n         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n     }\n \n-    Y_UNIT_TEST(TooBigKey) {\n-        TKikimrRunner kikimr;\n+    Y_UNIT_TEST_TWIN(TooBigKey, useSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);\n+        appConfig.MutableTableServiceConfig()->MutableWriteActorSettings()->SetInFlightMemoryLimitPerActorBytes(512 * 1024 * 1024); // for ASAN\n+\n+        TKikimrRunner kikimr(appConfig);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n \n@@ -543,14 +651,21 @@ Y_UNIT_TEST_SUITE(KqpLimits) {\n \n         result.GetIssues().PrintTo(Cerr);\n         UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::BAD_REQUEST);\n-        UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::DEFAULT_ERROR,\n-            [] (const auto& issue) {\n-                return issue.GetMessage().contains(\"exceeds limit\");\n-        }));\n+        UNIT_ASSERT_C(HasIssue(result.GetIssues(), useSink ? NYql::TIssuesIds::KIKIMR_BAD_REQUEST : NYql::TIssuesIds::DEFAULT_ERROR,\n+            [&](const auto& issue) {\n+                if (useSink) {\n+                    return issue.GetMessage().contains(\"Row key size of\")\n+                        && issue.GetMessage().contains(\"bytes is larger than the allowed threshold\");\n+                } else {\n+                    return issue.GetMessage().contains(\"exceeds limit\");\n+                }\n+        }), result.GetIssues().ToString());\n     }\n \n-    Y_UNIT_TEST(TooBigColumn) {\n-        TKikimrRunner kikimr;\n+    Y_UNIT_TEST_TWIN(TooBigColumn, useSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);\n+        TKikimrRunner kikimr(appConfig);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n \n@@ -567,11 +682,15 @@ Y_UNIT_TEST_SUITE(KqpLimits) {\n         )\"), TTxControl::BeginTx().CommitTx(), params).ExtractValueSync();\n \n         result.GetIssues().PrintTo(Cerr);\n-        UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::GENERIC_ERROR);\n-        UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::DEFAULT_ERROR,\n-            [] (const auto& issue) {\n-                return issue.GetMessage().contains(\"larger than the allowed threshold\");\n-        }));\n+        if (!useSink) {\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::GENERIC_ERROR, result.GetIssues().ToString());\n+        } else {\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::BAD_REQUEST, result.GetIssues().ToString());\n+        }\n+        UNIT_ASSERT(HasIssue(result.GetIssues(), useSink ? NYql::TIssuesIds::KIKIMR_BAD_REQUEST : NYql::TIssuesIds::DEFAULT_ERROR,\n+                [] (const auto& issue) {\n+                    return issue.GetMessage().contains(\"larger than the allowed threshold\");\n+            }));\n     }\n \n     Y_UNIT_TEST(AffectedShardsLimit) {\n@@ -700,8 +819,10 @@ Y_UNIT_TEST_SUITE(KqpLimits) {\n         }\n     }\n \n-    Y_UNIT_TEST(CancelAfterRwTx) {\n-        TKikimrRunner kikimr;\n+    Y_UNIT_TEST_TWIN(CancelAfterRwTx, useSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);\n+        TKikimrRunner kikimr(appConfig);\n         NKqp::TKqpCounters counters(kikimr.GetTestServer().GetRuntime()->GetAppData().Counters);\n \n         {\n@@ -1350,8 +1471,15 @@ Y_UNIT_TEST_SUITE(KqpLimits) {\n         }\n     }\n \n-    Y_UNIT_TEST(QSReplySize) {\n-        TKikimrRunner kikimr;\n+    Y_UNIT_TEST_TWIN(QSReplySize, useSink) {\n+        auto app = NKikimrConfig::TAppConfig();\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(useSink);\n+\n+        auto settings = TKikimrSettings()\n+            .SetAppConfig(app)\n+            .SetWithSampleTables(true);\n+\n+        TKikimrRunner kikimr(settings);\n         CreateLargeTable(kikimr, 10'000, 100, 1'000, 1'000);\n \n         auto db = kikimr.GetQueryClient();\n@@ -1366,6 +1494,9 @@ Y_UNIT_TEST_SUITE(KqpLimits) {\n         result.GetIssues().PrintTo(Cerr);\n         UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::PRECONDITION_FAILED);\n         UNIT_ASSERT(!to_lower(TString{result.GetIssues().ToString()}).Contains(\"query result\"));\n+        if (useSink) {\n+            UNIT_ASSERT(result.GetIssues().ToString().contains(\"Stream write queries aren't allowed\"));\n+        }\n     }\n }\n \ndiff --git a/ydb/core/kqp/ut/query/kqp_params_ut.cpp b/ydb/core/kqp/ut/query/kqp_params_ut.cpp\nindex 98690721b1ff..510245dfde3f 100644\n--- a/ydb/core/kqp/ut/query/kqp_params_ut.cpp\n+++ b/ydb/core/kqp/ut/query/kqp_params_ut.cpp\n@@ -797,8 +797,10 @@ Y_UNIT_TEST_SUITE(KqpParams) {\n         UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::BAD_REQUEST);\n     }\n \n-    Y_UNIT_TEST_TWIN(Decimal, QueryService) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_QUAD(Decimal, QueryService, UseSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        auto kikimr = DefaultKikimrRunner({}, appConfig);\n         auto tableClient = kikimr.GetTableClient();\n         auto queryClient = kikimr.GetQueryClient();\n         auto session = tableClient.CreateSession().GetValueSync().GetSession();\ndiff --git a/ydb/core/kqp/ut/query/kqp_query_ut.cpp b/ydb/core/kqp/ut/query/kqp_query_ut.cpp\nindex 4549a493ad7f..16bc2da15229 100644\n--- a/ydb/core/kqp/ut/query/kqp_query_ut.cpp\n+++ b/ydb/core/kqp/ut/query/kqp_query_ut.cpp\n@@ -1,6 +1,7 @@\n #include <ydb/core/kqp/ut/common/kqp_ut_common.h>\n \n #include <ydb/core/tx/datashard/datashard_failpoints.h>\n+#include <ydb/core/tx/datashard/datashard.h>\n #include <ydb/core/testlib/common_helper.h>\n #include <ydb/core/kqp/provider/yql_kikimr_expr_nodes.h>\n #include <ydb/core/kqp/counters/kqp_counters.h>\n@@ -953,8 +954,12 @@ Y_UNIT_TEST_SUITE(KqpQuery) {\n         }\n     }\n \n-    Y_UNIT_TEST(QueryStats) {\n-        TKikimrRunner kikimr;\n+    Y_UNIT_TEST_TWIN(QueryStats, UseSink) {\n+        TKikimrSettings serverSettings;\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        serverSettings.SetAppConfig(app);\n+        TKikimrRunner kikimr(serverSettings);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n \n@@ -992,32 +997,51 @@ Y_UNIT_TEST_SUITE(KqpQuery) {\n         UNIT_ASSERT(compile.cpu_time_us() > 0);\n         totalCpuTimeUs += compile.cpu_time_us();\n \n-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n-\n-        auto& phase0 = stats.query_phases(0);\n-        UNIT_ASSERT(phase0.duration_us() > 0);\n-        UNIT_ASSERT(phase0.cpu_time_us() > 0);\n-        totalCpuTimeUs += phase0.cpu_time_us();\n-\n-        UNIT_ASSERT_VALUES_EQUAL(phase0.table_access().size(), 1);\n-        UNIT_ASSERT_VALUES_EQUAL(phase0.table_access(0).name(), \"/Root/TwoShard\");\n-        UNIT_ASSERT_VALUES_EQUAL(phase0.table_access(0).reads().rows(), 3);\n-        UNIT_ASSERT(phase0.table_access(0).reads().bytes() > 0);\n-        UNIT_ASSERT(!phase0.table_access(0).has_updates());\n-        UNIT_ASSERT(!phase0.table_access(0).has_deletes());\n-\n-        auto& phase1 = stats.query_phases(1);\n-        UNIT_ASSERT(phase1.duration_us() > 0);\n-        UNIT_ASSERT(phase1.cpu_time_us() > 0);\n-        totalCpuTimeUs += phase1.cpu_time_us();\n-        UNIT_ASSERT_VALUES_EQUAL(phase1.table_access().size(), 1);\n-        UNIT_ASSERT_VALUES_EQUAL(phase1.table_access(0).name(), \"/Root/EightShard\");\n-        UNIT_ASSERT(!phase1.table_access(0).has_reads());\n-        UNIT_ASSERT_VALUES_EQUAL(phase1.table_access(0).updates().rows(), 3);\n-        UNIT_ASSERT(phase1.table_access(0).updates().bytes() > 0);\n-        UNIT_ASSERT(!phase1.table_access(0).has_deletes());\n-\n-        UNIT_ASSERT_VALUES_EQUAL(stats.total_cpu_time_us(), totalCpuTimeUs);\n+        if (UseSink) {\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);\n+\n+            auto& phase0 = stats.query_phases(0);\n+            UNIT_ASSERT(phase0.duration_us() > 0);\n+            UNIT_ASSERT(phase0.cpu_time_us() > 0);\n+            totalCpuTimeUs += phase0.cpu_time_us();\n+            UNIT_ASSERT_VALUES_EQUAL(phase0.table_access().size(), 2);\n+            UNIT_ASSERT_VALUES_EQUAL(phase0.table_access(0).name(), \"/Root/EightShard\");\n+            UNIT_ASSERT(!phase0.table_access(0).has_reads());\n+            UNIT_ASSERT_VALUES_EQUAL(phase0.table_access(0).updates().rows(), 3);\n+            UNIT_ASSERT_VALUES_EQUAL(phase0.table_access(1).reads().rows(), 3);\n+            UNIT_ASSERT(phase0.table_access(0).updates().bytes() > 0);\n+            UNIT_ASSERT(phase0.table_access(1).reads().bytes() > 0);\n+            UNIT_ASSERT(!phase0.table_access(0).has_deletes());\n+\n+            UNIT_ASSERT_VALUES_EQUAL(stats.total_cpu_time_us(), totalCpuTimeUs);\n+        } else {\n+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n+\n+            auto& phase0 = stats.query_phases(0);\n+            UNIT_ASSERT(phase0.duration_us() > 0);\n+            UNIT_ASSERT(phase0.cpu_time_us() > 0);\n+            totalCpuTimeUs += phase0.cpu_time_us();\n+\n+            UNIT_ASSERT_VALUES_EQUAL(phase0.table_access().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(phase0.table_access(0).name(), \"/Root/TwoShard\");\n+            UNIT_ASSERT_VALUES_EQUAL(phase0.table_access(0).reads().rows(), 3);\n+            UNIT_ASSERT(phase0.table_access(0).reads().bytes() > 0);\n+            UNIT_ASSERT(!phase0.table_access(0).has_updates());\n+            UNIT_ASSERT(!phase0.table_access(0).has_deletes());\n+\n+            auto& phase1 = stats.query_phases(1);\n+            UNIT_ASSERT(phase1.duration_us() > 0);\n+            UNIT_ASSERT(phase1.cpu_time_us() > 0);\n+            totalCpuTimeUs += phase1.cpu_time_us();\n+            UNIT_ASSERT_VALUES_EQUAL(phase1.table_access().size(), 1);\n+            UNIT_ASSERT_VALUES_EQUAL(phase1.table_access(0).name(), \"/Root/EightShard\");\n+            UNIT_ASSERT(!phase1.table_access(0).has_reads());\n+            UNIT_ASSERT_VALUES_EQUAL(phase1.table_access(0).updates().rows(), 3);\n+            UNIT_ASSERT(phase1.table_access(0).updates().bytes() > 0);\n+            UNIT_ASSERT(!phase1.table_access(0).has_deletes());\n+\n+            UNIT_ASSERT_VALUES_EQUAL(stats.total_cpu_time_us(), totalCpuTimeUs);\n+        }\n     }\n \n     Y_UNIT_TEST(RowsLimit) {\n@@ -2142,6 +2166,118 @@ Y_UNIT_TEST_SUITE(KqpQuery) {\n             CompareYson(R\"([[3u]])\", FormatResultSetYson(result.GetResultSet(0)));\n         }\n     }\n+\n+    Y_UNIT_TEST_TWIN(ReadOverloaded, StreamLookup) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        auto setting = NKikimrKqp::TKqpSetting();\n+        TKikimrSettings settings;\n+        settings.SetAppConfig(appConfig);\n+        settings.SetUseRealThreads(false);\n+        TKikimrRunner kikimr(settings);\n+        auto db = kikimr.GetTableClient();\n+        auto session = kikimr.RunCall([&] { return db.CreateSession().GetValueSync().GetSession(); });\n+        auto writeSession = kikimr.RunCall([&] { return db.CreateSession().GetValueSync().GetSession(); });\n+\n+        auto& runtime = *kikimr.GetTestServer().GetRuntime();\n+        \n+        kikimr.RunCall([&]{ CreateSampleTablesWithIndex(session, false /* no need in table data */); return true; });\n+\n+        {\n+            const TString query(StreamLookup\n+                ? Q1_(R\"(\n+                        SELECT Value FROM `/Root/SecondaryKeys` VIEW Index WHERE Fk = 1\n+                    )\")\n+                : Q1_(R\"(\n+                        SELECT COUNT(a.Key) FROM `/Root/SecondaryKeys` as a;\n+                    )\"));\n+\n+            auto grab = [&](TAutoPtr<IEventHandle> &ev) -> auto {\n+                if (ev->GetTypeRewrite() == TEvDataShard::TEvReadResult::EventType) {\n+                    auto* msg = ev->Get<TEvDataShard::TEvReadResult>();\n+                    msg->Record.MutableStatus()->SetCode(::Ydb::StatusIds::OVERLOADED);\n+                }\n+\n+                return TTestActorRuntime::EEventAction::PROCESS;\n+            };\n+\n+            runtime.SetObserverFunc(grab);\n+            auto future = kikimr.RunInThreadPool([&]{\n+                auto txc = TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx();\n+                return session.ExecuteDataQuery(query, txc).ExtractValueSync();\n+            });\n+\n+            auto result = runtime.WaitFuture(future);\n+            UNIT_ASSERT_C(!result.IsSuccess(), result.GetIssues().ToString());\n+            UNIT_ASSERT(result.GetStatus() == NYdb::EStatus::OVERLOADED);\n+        }\n+    }\n+\n+    Y_UNIT_TEST(TableSinkWithSubquery) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        auto settings = TKikimrSettings()\n+            .SetAppConfig(appConfig)\n+            .SetWithSampleTables(false);\n+\n+        TKikimrRunner kikimr(settings);\n+        Tests::NCommon::TLoggerInit(kikimr).Initialize();\n+\n+        auto session = kikimr.GetTableClient().CreateSession().GetValueSync().GetSession();\n+\n+        const TString query = R\"(\n+            CREATE TABLE `/Root/table1` (\n+                p1 Utf8,\n+                PRIMARY KEY (p1)\n+            )\n+            WITH (\n+                STORE = ROW\n+            );\n+\n+            CREATE TABLE `/Root/table2` (\n+                p1 Utf8,\n+                PRIMARY KEY (p1)\n+            )\n+            WITH (\n+                STORE = ROW\n+            );\n+        )\";\n+\n+        auto result = session.ExecuteSchemeQuery(query).GetValueSync();\n+        UNIT_ASSERT_C(result.GetStatus() == NYdb::EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+        auto client = kikimr.GetQueryClient();\n+\n+        {\n+            auto prepareResult = client.ExecuteQuery(R\"(\n+                UPSERT INTO `/Root/table1` (p1) VALUES (\"a\") , (\"b\"), (\"c\");\n+            )\", NYdb::NQuery::TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_C(prepareResult.IsSuccess(), prepareResult.GetIssues().ToString());\n+        }\n+\n+        {\n+            auto result = client.ExecuteQuery(R\"(\n+                $data2 = Cast(AsList() As List<Struct<p1: Utf8>>);\n+\n+                /* query */\n+                SELECT d1.p1 AS p1,\n+                FROM `/Root/table1` AS d1\n+                CROSS JOIN AS_TABLE($data2) AS d2;\n+            )\", NYdb::NQuery::TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());\n+        }\n+\n+        {\n+            auto result = client.ExecuteQuery(R\"(\n+                $data2 = Cast(AsList() As List<Struct<p1: Utf8>>);\n+\n+                /* query */\n+                INSERT INTO `/Root/table1`\n+                SELECT d1.p1 AS p1,\n+                FROM `/Root/table2` AS d1\n+                CROSS JOIN AS_TABLE($data2) AS d2;\n+            )\", NYdb::NQuery::TTxControl::BeginTx().CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());\n+        }\n+    }\n }\n \n } // namespace NKqp\ndiff --git a/ydb/core/kqp/ut/query/kqp_stats_ut.cpp b/ydb/core/kqp/ut/query/kqp_stats_ut.cpp\nindex 5763397cb1c1..8dfbffb136ef 100644\n--- a/ydb/core/kqp/ut/query/kqp_stats_ut.cpp\n+++ b/ydb/core/kqp/ut/query/kqp_stats_ut.cpp\n@@ -193,8 +193,10 @@ Y_UNIT_TEST(MultiTxStatsFullScan) {\n     MultiTxStatsFull<NYdb::NTable::TScanQueryPartIterator>(GetScanStreamIterator);\n }\n \n-Y_UNIT_TEST(DeferredEffects) {\n-    auto kikimr = DefaultKikimrRunner();\n+Y_UNIT_TEST_TWIN(DeferredEffects, UseSink) {\n+    NKikimrConfig::TAppConfig app;\n+    app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+    auto kikimr = DefaultKikimrRunner({}, app);\n     auto db = kikimr.GetTableClient();\n     auto session = db.CreateSession().GetValueSync().GetSession();\n     TString planJson;\n@@ -238,7 +240,7 @@ Y_UNIT_TEST(DeferredEffects) {\n     UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n \n     NJson::ReadJsonTree(result.GetQueryPlan(), &plan, true);\n-    UNIT_ASSERT_VALUES_EQUAL(plan.GetMapSafe().at(\"Plan\").GetMapSafe().at(\"Plans\").GetArraySafe().size(), 3);\n+    UNIT_ASSERT_VALUES_EQUAL(plan.GetMapSafe().at(\"Plan\").GetMapSafe().at(\"Plans\").GetArraySafe().size(), UseSink ? 2 : 3);\n \n     result = session.ExecuteDataQuery(R\"(\n         SELECT * FROM `/Root/TwoShard`;\n@@ -248,7 +250,7 @@ Y_UNIT_TEST(DeferredEffects) {\n     UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n \n     NJson::ReadJsonTree(result.GetQueryPlan(), &plan, true);\n-    UNIT_ASSERT_VALUES_EQUAL(plan.GetMapSafe().at(\"Plan\").GetMapSafe().at(\"Plans\").GetArraySafe().size(), 3);\n+    UNIT_ASSERT_VALUES_EQUAL(plan.GetMapSafe().at(\"Plan\").GetMapSafe().at(\"Plans\").GetArraySafe().size(), UseSink ? 2 : 3);\n \n     auto ru = result.GetResponseMetadata().find(NYdb::YDB_CONSUMED_UNITS_HEADER);\n     UNIT_ASSERT(ru != result.GetResponseMetadata().end());\n@@ -256,8 +258,10 @@ Y_UNIT_TEST(DeferredEffects) {\n     UNIT_ASSERT(std::atoi(ru->second.c_str()) > 1);\n }\n \n-Y_UNIT_TEST(DataQueryWithEffects) {\n-    auto kikimr = DefaultKikimrRunner();\n+Y_UNIT_TEST_TWIN(DataQueryWithEffects, UseSink) {\n+    NKikimrConfig::TAppConfig app;\n+    app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+    auto kikimr = DefaultKikimrRunner({}, app);\n     auto db = kikimr.GetTableClient();\n     auto session = db.CreateSession().GetValueSync().GetSession();\n \n@@ -274,8 +278,13 @@ Y_UNIT_TEST(DataQueryWithEffects) {\n     NJson::TJsonValue plan;\n     NJson::ReadJsonTree(result.GetQueryPlan(), &plan, true);\n \n-    auto node = FindPlanNodeByKv(plan, \"Node Type\", \"Upsert-ConstantExpr\");\n-    UNIT_ASSERT_EQUAL(node.GetMap().at(\"Stats\").GetMapSafe().at(\"Tasks\").GetIntegerSafe(), 2);\n+    if (UseSink) {\n+        auto node = FindPlanNodeByKv(plan, \"Node Type\", \"Stage-Sink\");\n+        UNIT_ASSERT_EQUAL(node.GetMap().at(\"Stats\").GetMapSafe().at(\"Tasks\").GetIntegerSafe(), 1);\n+    } else {\n+        auto node = FindPlanNodeByKv(plan, \"Node Type\", \"Upsert-ConstantExpr\");\n+        UNIT_ASSERT_EQUAL(node.GetMap().at(\"Stats\").GetMapSafe().at(\"Tasks\").GetIntegerSafe(), 2);\n+    }\n }\n \n Y_UNIT_TEST(DataQueryMulti) {\n@@ -449,6 +458,39 @@ Y_UNIT_TEST_TWIN(StreamLookupStats, StreamLookupJoin) {\n     });\n }\n \n+Y_UNIT_TEST(SelfJoin) {\n+    NKikimrConfig::TAppConfig app;\n+    app.MutableTableServiceConfig()->SetEnableKqpDataQueryStreamIdxLookupJoin(true);\n+\n+    TKikimrRunner kikimr(TKikimrSettings().SetAppConfig(app));\n+    auto db = kikimr.GetTableClient();\n+    auto session = db.CreateSession().GetValueSync().GetSession();\n+\n+    TExecDataQuerySettings settings;\n+    settings.CollectQueryStats(ECollectQueryStatsMode::Full);\n+\n+    auto result = session.ExecuteDataQuery(R\"(\n+        SELECT a.Key FROM `/Root/TwoShard` AS a INNER JOIN `/Root/TwoShard` AS b ON a.Key = b.Key;\n+    )\", TTxControl::BeginTx().CommitTx(), settings).ExtractValueSync();\n+    UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+    Cerr << result.GetQueryPlan() << Endl;\n+\n+    NJson::TJsonValue plan;\n+    NJson::ReadJsonTree(result.GetQueryPlan(), &plan, true);\n+\n+    auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n+\n+    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);\n+    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n+    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 2);\n+    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).partitions_count(), 4); // TODO: fix it\n+\n+    AssertTableStats(result, \"/Root/TwoShard\", {\n+        .ExpectedReads = 12,\n+    });\n+}\n+\n Y_UNIT_TEST(SysViewClientLost) {\n     TKikimrRunner kikimr;\n     CreateLargeTable(kikimr, 500000, 10, 100, 5000, 1);\n@@ -635,12 +677,16 @@ Y_UNIT_TEST(SysViewCancelled) {\n     }\n }\n \n-Y_UNIT_TEST(OneShardLocalExec) {\n-    TKikimrRunner kikimr;\n+Y_UNIT_TEST_TWIN(OneShardLocalExec, UseSink) {\n+    NKikimrConfig::TAppConfig app;\n+    app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+    auto kikimr = DefaultKikimrRunner({}, app);\n     auto db = kikimr.GetTableClient();\n     auto session = db.CreateSession().GetValueSync().GetSession();\n \n     TKqpCounters counters(kikimr.GetTestServer().GetRuntime()->GetAppData().Counters);\n+\n+    UNIT_ASSERT_VALUES_EQUAL(counters.TotalSingleNodeReqCount->Val(), 1);\n     {\n         auto result = session.ExecuteDataQuery(R\"(\n             SELECT * FROM `/Root/KeyValue` WHERE Key = 1;\n@@ -672,8 +718,10 @@ Y_UNIT_TEST(OneShardLocalExec) {\n     UNIT_ASSERT_VALUES_EQUAL(counters.NonLocalSingleNodeReqCount->Val(), 0);\n }\n \n-Y_UNIT_TEST(OneShardNonLocalExec) {\n-    TKikimrRunner kikimr(TKikimrSettings().SetNodeCount(2));\n+Y_UNIT_TEST_TWIN(OneShardNonLocalExec, UseSink) {\n+    NKikimrConfig::TAppConfig app;\n+    app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+    TKikimrRunner kikimr(TKikimrSettings().SetNodeCount(2).SetAppConfig(app));\n     auto db = kikimr.GetTableClient();\n     auto session = db.CreateSession().GetValueSync().GetSession();\n     auto monPort = kikimr.GetTestServer().GetRuntime()->GetMonPort();\ndiff --git a/ydb/core/kqp/ut/scheme/kqp_acl_ut.cpp b/ydb/core/kqp/ut/scheme/kqp_acl_ut.cpp\nindex 15f954355ca6..b18d75061448 100644\n--- a/ydb/core/kqp/ut/scheme/kqp_acl_ut.cpp\n+++ b/ydb/core/kqp/ut/scheme/kqp_acl_ut.cpp\n@@ -501,6 +501,200 @@ Y_UNIT_TEST_SUITE(KqpAcl) {\n             driver.Stop(true);\n         }\n     }\n+\n+    Y_UNIT_TEST_QUAD(AclDml, UseSink, IsOlap) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        appConfig.MutableTableServiceConfig()->SetEnableOlapSink(IsOlap);\n+        auto settings = NKqp::TKikimrSettings().SetAppConfig(appConfig);\n+        TKikimrRunner kikimr(appConfig);\n+\n+        {\n+            auto driverConfig = TDriverConfig()\n+                .SetEndpoint(kikimr.GetEndpoint())\n+                .SetAuthToken(\"root@builtin\");\n+            auto driver = TDriver(driverConfig);\n+            auto client = NYdb::NQuery::TQueryClient(driver);\n+\n+            const TString query = Sprintf(R\"(\n+                CREATE TABLE `/Root/test_acl` (\n+                    id Uint64 NOT NULL,\n+                    name String,\n+                    primary key (id)\n+                ) WITH (STORE=%s);\n+            )\", IsOlap ? \"COLUMN\" : \"ROW\");\n+\n+            AssertSuccessResult(client.ExecuteQuery(query, NYdb::NQuery::TTxControl::NoTx()).ExtractValueSync());\n+\n+            driver.Stop(true);\n+        }\n+\n+        AddConnectPermission(kikimr, UserName);\n+        AddPermissions(kikimr, \"/Root/test_acl\", UserName, {\"ydb.deprecated.describe_schema\", \"ydb.deprecated.update_row\"});\n+\n+        auto driverConfig = TDriverConfig()\n+            .SetEndpoint(kikimr.GetEndpoint())\n+            .SetAuthToken(UserName);\n+        auto driver = TDriver(driverConfig);\n+        auto client = NYdb::NQuery::TQueryClient(driver);\n+\n+        auto session = client.GetSession().GetValueSync().GetSession();\n+\n+        {\n+            auto result = session.ExecuteQuery(R\"(\n+                UPSERT INTO `/Root/test_acl` (id, name) VALUES\n+                    (10u, \"One\");\n+            )\", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            AssertSuccessResult(result);\n+        }\n+\n+        {\n+            auto result = session.ExecuteQuery(R\"(\n+                REPLACE INTO `/Root/test_acl` (id, name) VALUES\n+                    (11u, \"Two\");\n+            )\", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            AssertSuccessResult(result);\n+        }\n+\n+        {\n+            auto result = session.ExecuteQuery(R\"(\n+                INSERT INTO `/Root/test_acl` (id, name) VALUES\n+                    (12u, \"Three\");\n+            )\", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            AssertSuccessResult(result);\n+        }\n+\n+        {\n+            auto result = session.ExecuteQuery(R\"(\n+                UPDATE `/Root/test_acl` SET name = \"test\" WHERE id = 10u;\n+            )\", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::ABORTED, result.GetIssues().ToString());\n+        }\n+\n+        {\n+            auto result = session.ExecuteQuery(R\"(\n+                UPDATE `/Root/test_acl` ON SELECT 11u AS id, \"test\" AS name;\n+            )\", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            AssertSuccessResult(result);\n+        }\n+\n+        {\n+            auto result = session.ExecuteQuery(R\"(\n+                DELETE FROM `/Root/test_acl` WHERE id = 10u;\n+            )\", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::ABORTED, result.GetIssues().ToString());\n+        }\n+\n+        {\n+            auto result = session.ExecuteQuery(R\"(\n+                DELETE FROM `/Root/test_acl` ON SELECT 11u AS id;\n+            )\", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::ABORTED, result.GetIssues().ToString());\n+        }\n+\n+        AddPermissions(kikimr, \"/Root/test_acl\", UserName, {\"ydb.deprecated.describe_schema\", \"ydb.deprecated.update_row\", \"ydb.deprecated.erase_row\"});\n+\n+        {\n+            auto result = session.ExecuteQuery(R\"(\n+                DELETE FROM `/Root/test_acl` WHERE id = 10u;\n+            )\", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            AssertSuccessResult(result);\n+        }\n+\n+        {\n+            auto result = session.ExecuteQuery(R\"(\n+                DELETE FROM `/Root/test_acl` ON SELECT 11u AS id;\n+            )\", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            AssertSuccessResult(result);\n+        }\n+\n+        AddPermissions(kikimr, \"/Root/test_acl\", UserName, {\"ydb.deprecated.describe_schema\", \"ydb.deprecated.update_row\", \"ydb.deprecated.erase_row\", \"ydb.deprecated.select_row\"});\n+\n+        {\n+            auto result = session.ExecuteQuery(R\"(\n+                UPDATE `/Root/test_acl` SET name = \"test\" WHERE id = 10u;\n+            )\", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            AssertSuccessResult(result);\n+        }\n+\n+        {\n+            auto result = session.ExecuteQuery(R\"(\n+                DELETE FROM `/Root/test_acl` WHERE id = 10u;\n+            )\", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+            AssertSuccessResult(result);\n+        }\n+\n+        driver.Stop(true);\n+    }\n+\n+    Y_UNIT_TEST_QUAD(AclRevoke, UseSink, IsOlap) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+        appConfig.MutableTableServiceConfig()->SetEnableOlapSink(IsOlap);\n+        auto settings = NKqp::TKikimrSettings().SetAppConfig(appConfig);\n+        TKikimrRunner kikimr(appConfig);\n+\n+        {\n+            auto driverConfig = TDriverConfig()\n+                .SetEndpoint(kikimr.GetEndpoint())\n+                .SetAuthToken(\"root@builtin\");\n+            auto driver = TDriver(driverConfig);\n+            auto client = NYdb::NQuery::TQueryClient(driver);\n+\n+            const TString query = Sprintf(R\"(\n+                CREATE TABLE `/Root/test_acl` (\n+                    id Uint64 NOT NULL,\n+                    name String,\n+                    primary key (id)\n+                ) WITH (STORE=%s);\n+            )\", IsOlap ? \"COLUMN\" : \"ROW\");\n+\n+            AssertSuccessResult(client.ExecuteQuery(query, NYdb::NQuery::TTxControl::NoTx()).ExtractValueSync());\n+\n+            driver.Stop(true);\n+        }\n+\n+        AddConnectPermission(kikimr, UserName);\n+        \n+        for (const auto permission : {\"ydb.deprecated.describe_schema\", \"ydb.deprecated.update_row\"}) {\n+            AddPermissions(kikimr, \"/Root/test_acl\", UserName, {\"ydb.deprecated.describe_schema\", \"ydb.deprecated.update_row\"});\n+\n+            auto driverConfig = TDriverConfig()\n+                .SetEndpoint(kikimr.GetEndpoint())\n+                .SetAuthToken(UserName);\n+            auto driver = TDriver(driverConfig);\n+            auto client = NYdb::NQuery::TQueryClient(driver);\n+\n+            auto session = client.GetSession().GetValueSync().GetSession();\n+\n+            const TString query = R\"(UPSERT INTO `/Root/test_acl` (id, name) VALUES (10u, \"One\");)\";\n+\n+            for (size_t index = 0; index < 10; ++index) {\n+                auto result = session.ExecuteQuery(\n+                    query,\n+                    NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+                AssertSuccessResult(result);\n+            }\n+\n+            {\n+                auto schemeClient = kikimr.GetSchemeClient();\n+                NYdb::NScheme::TPermissions permissions(\"user0@builtin\", {permission});\n+                AssertSuccessResult(schemeClient.ModifyPermissions(\"/Root/test_acl\",\n+                        NYdb::NScheme::TModifyPermissionsSettings().AddRevokePermissions(permissions)\n+                    ).ExtractValueSync()\n+                );\n+            }\n+\n+            {\n+                auto result = session.ExecuteQuery(\n+                    query,\n+                    NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();\n+                UNIT_ASSERT_C(!result.IsSuccess(), result.GetIssues().ToString());\n+            }\n+\n+            driver.Stop(true);\n+        }\n+    }\n }\n \n } // namespace NKqp\ndiff --git a/ydb/core/kqp/ut/scheme/kqp_scheme_ut.cpp b/ydb/core/kqp/ut/scheme/kqp_scheme_ut.cpp\nindex 7787e7bdd1a8..d93a34a5c15f 100644\n--- a/ydb/core/kqp/ut/scheme/kqp_scheme_ut.cpp\n+++ b/ydb/core/kqp/ut/scheme/kqp_scheme_ut.cpp\n@@ -3823,6 +3823,81 @@ Y_UNIT_TEST_SUITE(KqpScheme) {\n             }\n         }\n     }\n+    \n+    void CheckOwner(TSession& session, const TString& path, const TString& name) {\n+        TDescribeTableResult describe = session.DescribeTable(path).GetValueSync();\n+        UNIT_ASSERT_VALUES_EQUAL(describe.GetStatus(), EStatus::SUCCESS);\n+        auto tableDesc = describe.GetTableDescription();\n+        const auto& currentOwner = tableDesc.GetOwner();\n+        UNIT_ASSERT_VALUES_EQUAL_C(name, currentOwner, \"name is not currentOwner\");\n+    }\n+\n+    Y_UNIT_TEST_TWIN(AlterDatabaseChangeOwner, EnableAlterDatabase) {\n+        /* Default Kikimr runner can not create extsubdomain */\n+        TTestExtEnv::TEnvSettings settings;\n+        settings.FeatureFlags.SetEnableAlterDatabase(EnableAlterDatabase);\n+\n+        TTestExtEnv env(settings);\n+        env.CreateDatabase(\"Test\");\n+\n+        TTableClient client(env.GetDriver());\n+        auto session = client.CreateSession().GetValueSync().GetSession();\n+\n+        {\n+            auto createUserSql = TStringBuilder() << R\"(\n+                --!syntax_v1\n+                CREATE USER superuser;\n+            )\";\n+\n+            auto result = session.ExecuteSchemeQuery(createUserSql).GetValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+        }\n+        {\n+            auto createUserSql = TStringBuilder() << R\"(\n+                --!syntax_v1\n+                CREATE TABLE `/Root/Test/table` (\n+                    k Uint64,\n+                    v Uint64,\n+                    PRIMARY KEY(k)\n+                );\n+            )\";\n+\n+            auto result = session.ExecuteSchemeQuery(createUserSql).GetValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+        }\n+        {\n+            auto alterDatabaseSql = TStringBuilder() << R\"(\n+                --!syntax_v1\n+                ALTER DATABASE `/Root/Test/table` OWNER TO superuser;\n+            )\";\n+\n+            auto result = session.ExecuteSchemeQuery(alterDatabaseSql).GetValueSync();\n+\n+            if (EnableAlterDatabase) {\n+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());\n+                UNIT_ASSERT_STRING_CONTAINS(result.GetIssues().ToString(), \"Error: fail in ApplyIf section: wrong Path type.\");\n+            } else {\n+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::GENERIC_ERROR, result.GetIssues().ToString());\n+                UNIT_ASSERT_STRING_CONTAINS(result.GetIssues().ToString(), \"ALTER DATABASE statement is not supported\");\n+            }\n+        }\n+        {\n+            auto alterDatabaseSql = TStringBuilder() << R\"(\n+                --!syntax_v1\n+                ALTER DATABASE `/Root/Test` OWNER TO superuser;\n+            )\";\n+\n+            auto result = session.ExecuteSchemeQuery(alterDatabaseSql).GetValueSync();\n+\n+            if (EnableAlterDatabase) {\n+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+                CheckOwner(session, \"/Root/Test\", \"superuser\");\n+            } else {\n+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::GENERIC_ERROR, result.GetIssues().ToString());\n+                UNIT_ASSERT_STRING_CONTAINS(result.GetIssues().ToString(), \"ALTER DATABASE statement is not supported\");\n+            }\n+        }\n+    }\n \n     Y_UNIT_TEST(ModifyPermissions) {\n         TKikimrRunner kikimr;\n@@ -9151,9 +9226,10 @@ Y_UNIT_TEST_SUITE(KqpScheme) {\n         );\n     }\n \n-    Y_UNIT_TEST(DoubleCreateResourcePoolClassifier) {\n+    Y_UNIT_TEST_TWIN(DoubleCreateResourcePoolClassifier, UseSink) {\n         NKikimrConfig::TAppConfig config;\n         config.MutableFeatureFlags()->SetEnableResourcePools(true);\n+        config.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n \n         TKikimrRunner kikimr(NKqp::TKikimrSettings()\n             .SetAppConfig(config)\n@@ -9180,7 +9256,11 @@ Y_UNIT_TEST_SUITE(KqpScheme) {\n                 );)\";\n             auto result = session.ExecuteSchemeQuery(query).GetValueSync();\n             UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::GENERIC_ERROR);\n-            UNIT_ASSERT_STRING_CONTAINS(result.GetIssues().ToString(), \"Conflict with existing key\");\n+            if (UseSink) {\n+                UNIT_ASSERT_STRING_CONTAINS_C(result.GetIssues().ToString(), \"Duplicate keys have been found\", result.GetIssues().ToString());\n+            } else {\n+                UNIT_ASSERT_STRING_CONTAINS_C(result.GetIssues().ToString(), \"Conflict with existing key\", result.GetIssues().ToString());\n+            }\n         }\n     }\n \n@@ -9732,64 +9812,90 @@ Y_UNIT_TEST_SUITE(KqpOlapScheme) {\n         }\n     }\n \n-    Y_UNIT_TEST(AddColumn) {\n-        TKikimrSettings runnerSettings;\n-        runnerSettings.WithSampleTables = false;\n-        TTestHelper testHelper(runnerSettings);\n+    class TestAddColumn {\n+    private:\n+        TString ReaderPolicyName;\n \n-        TVector<TTestHelper::TColumnSchema> schema = {\n-            TTestHelper::TColumnSchema().SetName(\"id\").SetType(NScheme::NTypeIds::Int32).SetNullable(false),\n-            TTestHelper::TColumnSchema().SetName(\"resource_id\").SetType(NScheme::NTypeIds::Utf8),\n-            TTestHelper::TColumnSchema().SetName(\"level\").SetType(NScheme::NTypeIds::Int32)\n-        };\n+    public:\n+        TestAddColumn(const TString& reader)\n+            : ReaderPolicyName(reader) {\n+        }\n \n-        Tests::NCommon::TLoggerInit(testHelper.GetKikimr()).Initialize();\n-        TTestHelper::TColumnTable testTable;\n+        void Run() {\n+            TKikimrSettings runnerSettings;\n+            runnerSettings.WithSampleTables = false;\n+            runnerSettings.SetColumnShardAlterObjectEnabled(true);\n+            TTestHelper testHelper(runnerSettings);\n \n-        testTable.SetName(\"/Root/ColumnTableTest\").SetPrimaryKey({\"id\"}).SetSharding({\"id\"}).SetSchema(schema);\n-        testHelper.CreateTable(testTable);\n+            TVector<TTestHelper::TColumnSchema> schema = {\n+                TTestHelper::TColumnSchema().SetName(\"id\").SetType(NScheme::NTypeIds::Int32).SetNullable(false),\n+                TTestHelper::TColumnSchema().SetName(\"resource_id\").SetType(NScheme::NTypeIds::Utf8),\n+                TTestHelper::TColumnSchema().SetName(\"level\").SetType(NScheme::NTypeIds::Int32)\n+            };\n \n-        {\n-            TTestHelper::TUpdatesBuilder tableInserter(testTable.GetArrowSchema(schema));\n-            tableInserter.AddRow().Add(1).Add(\"test_res_1\").AddNull();\n-            tableInserter.AddRow().Add(2).Add(\"test_res_2\").Add(123);\n-            testHelper.BulkUpsert(testTable, tableInserter);\n-        }\n+            Tests::NCommon::TLoggerInit(testHelper.GetKikimr()).Initialize();\n+            TTestHelper::TColumnTable testTable;\n \n-        testHelper.ReadData(\"SELECT * FROM `/Root/ColumnTableTest` WHERE id=1\", \"[[1;#;[\\\"test_res_1\\\"]]]\");\n+            testTable.SetName(\"/Root/ColumnTableTest\").SetPrimaryKey({ \"id\" }).SetSharding({ \"id\" }).SetSchema(schema);\n+            testHelper.CreateTable(testTable);\n+            {\n+                auto alterQuery = TStringBuilder()\n+                                  << \"ALTER OBJECT `\" << testTable.GetName()\n+                                  << \"` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`\" << ReaderPolicyName << \"`)\";\n+                auto alterResult = testHelper.GetSession().ExecuteSchemeQuery(alterQuery).GetValueSync();\n+                UNIT_ASSERT_VALUES_EQUAL_C(alterResult.GetStatus(), EStatus::SUCCESS, alterResult.GetIssues().ToString());\n+            }\n \n-        {\n-            schema.push_back(TTestHelper::TColumnSchema().SetName(\"new_column\").SetType(NScheme::NTypeIds::Uint64));\n-            auto alterQuery = TStringBuilder() << \"ALTER TABLE `\" << testTable.GetName() << \"` ADD COLUMN new_column Uint64;\";\n-            auto alterResult = testHelper.GetSession().ExecuteSchemeQuery(alterQuery).GetValueSync();\n-            UNIT_ASSERT_VALUES_EQUAL_C(alterResult.GetStatus(), EStatus::SUCCESS, alterResult.GetIssues().ToString());\n-        }\n+            {\n+                TTestHelper::TUpdatesBuilder tableInserter(testTable.GetArrowSchema(schema));\n+                tableInserter.AddRow().Add(1).Add(\"test_res_1\").AddNull();\n+                tableInserter.AddRow().Add(2).Add(\"test_res_2\").Add(123);\n+                testHelper.BulkUpsert(testTable, tableInserter);\n+            }\n \n-        {\n-            auto settings = TDescribeTableSettings().WithTableStatistics(true);\n-            auto describeResult = testHelper.GetSession().DescribeTable(\"/Root/ColumnTableTest\", settings).GetValueSync();\n-            UNIT_ASSERT_C(describeResult.IsSuccess(), describeResult.GetIssues().ToString());\n+            testHelper.ReadData(\"SELECT * FROM `/Root/ColumnTableTest` WHERE id=1\", \"[[1;#;[\\\"test_res_1\\\"]]]\");\n \n-            const auto& description = describeResult.GetTableDescription();\n-            auto columns = description.GetTableColumns();\n-            UNIT_ASSERT_VALUES_EQUAL(columns.size(), 4);\n-        }\n+            {\n+                schema.push_back(TTestHelper::TColumnSchema().SetName(\"new_column\").SetType(NScheme::NTypeIds::Uint64));\n+                auto alterQuery = TStringBuilder() << \"ALTER TABLE `\" << testTable.GetName() << \"` ADD COLUMN new_column Uint64;\";\n+                auto alterResult = testHelper.GetSession().ExecuteSchemeQuery(alterQuery).GetValueSync();\n+                UNIT_ASSERT_VALUES_EQUAL_C(alterResult.GetStatus(), EStatus::SUCCESS, alterResult.GetIssues().ToString());\n+            }\n \n-        testHelper.ReadData(\"SELECT * FROM `/Root/ColumnTableTest` WHERE id=1\", \"[[1;#;#;[\\\"test_res_1\\\"]]]\");\n-        testHelper.ReadData(\"SELECT new_column FROM `/Root/ColumnTableTest` WHERE id=1\", \"[[#]]\");\n-        testHelper.ReadData(\"SELECT resource_id FROM `/Root/ColumnTableTest` WHERE id=1\", \"[[[\\\"test_res_1\\\"]]]\");\n-        Tests::NCommon::TLoggerInit(testHelper.GetKikimr()).Initialize();\n-        {\n-            TTestHelper::TUpdatesBuilder tableInserter(testTable.GetArrowSchema(schema));\n-            tableInserter.AddRow().Add(3).Add(\"test_res_3\").Add(123).Add<uint64_t>(200);\n-            testHelper.BulkUpsert(testTable, tableInserter);\n+            {\n+                auto settings = TDescribeTableSettings().WithTableStatistics(true);\n+                auto describeResult = testHelper.GetSession().DescribeTable(\"/Root/ColumnTableTest\", settings).GetValueSync();\n+                UNIT_ASSERT_C(describeResult.IsSuccess(), describeResult.GetIssues().ToString());\n+\n+                const auto& description = describeResult.GetTableDescription();\n+                auto columns = description.GetTableColumns();\n+                UNIT_ASSERT_VALUES_EQUAL(columns.size(), 4);\n+            }\n+\n+            testHelper.ReadData(\"SELECT * FROM `/Root/ColumnTableTest` WHERE id=1\", \"[[1;#;#;[\\\"test_res_1\\\"]]]\");\n+            testHelper.ReadData(\"SELECT new_column FROM `/Root/ColumnTableTest` WHERE id=1\", \"[[#]]\");\n+            testHelper.ReadData(\"SELECT resource_id FROM `/Root/ColumnTableTest` WHERE id=1\", \"[[[\\\"test_res_1\\\"]]]\");\n+            Tests::NCommon::TLoggerInit(testHelper.GetKikimr()).Initialize();\n+            {\n+                TTestHelper::TUpdatesBuilder tableInserter(testTable.GetArrowSchema(schema));\n+                tableInserter.AddRow().Add(3).Add(\"test_res_3\").Add(123).Add<uint64_t>(200);\n+                testHelper.BulkUpsert(testTable, tableInserter);\n+            }\n+\n+            testHelper.ReadData(\"SELECT * FROM `/Root/ColumnTableTest` WHERE id=3\", \"[[3;[123];[200u];[\\\"test_res_3\\\"]]]\");\n+            testHelper.ReadData(\"SELECT * FROM `/Root/ColumnTableTest` WHERE new_column=200\", \"[[3;[123];[200u];[\\\"test_res_3\\\"]]]\");\n+            testHelper.ReadData(\"SELECT new_column FROM `/Root/ColumnTableTest` WHERE id=3\", \"[[[200u]]]\");\n+            testHelper.ReadData(\"SELECT resource_id FROM `/Root/ColumnTableTest` WHERE id=3\", \"[[[\\\"test_res_3\\\"]]]\");\n+            testHelper.ReadData(\"SELECT new_column FROM `/Root/ColumnTableTest`\", \"[[#];[#];[[200u]]]\");\n         }\n+    };\n+\n+    Y_UNIT_TEST(AddColumn) {\n+        TestAddColumn(\"PLAIN\").Run();\n+    }\n \n-        testHelper.ReadData(\"SELECT * FROM `/Root/ColumnTableTest` WHERE id=3\", \"[[3;[123];[200u];[\\\"test_res_3\\\"]]]\");\n-        testHelper.ReadData(\"SELECT * FROM `/Root/ColumnTableTest` WHERE new_column=200\", \"[[3;[123];[200u];[\\\"test_res_3\\\"]]]\");\n-        testHelper.ReadData(\"SELECT new_column FROM `/Root/ColumnTableTest` WHERE id=3\", \"[[[200u]]]\");\n-        testHelper.ReadData(\"SELECT resource_id FROM `/Root/ColumnTableTest` WHERE id=3\", \"[[[\\\"test_res_3\\\"]]]\");\n-        testHelper.ReadData(\"SELECT new_column FROM `/Root/ColumnTableTest`\", \"[[#];[#];[[200u]]]\");\n+    Y_UNIT_TEST(AddColumnSimpleReader) {\n+        TestAddColumn(\"SIMPLE\").Run();\n     }\n \n     Y_UNIT_TEST(AddColumnOldSchemeBulkUpsert) {\ndiff --git a/ydb/core/kqp/ut/service/kqp_qs_queries_ut.cpp b/ydb/core/kqp/ut/service/kqp_qs_queries_ut.cpp\nindex bafe07a6c55f..0a6c7ca571e5 100644\n--- a/ydb/core/kqp/ut/service/kqp_qs_queries_ut.cpp\n+++ b/ydb/core/kqp/ut/service/kqp_qs_queries_ut.cpp\n@@ -3420,9 +3420,10 @@ Y_UNIT_TEST_SUITE(KqpQueryService) {\n         }\n     }\n \n-    Y_UNIT_TEST(SeveralCTAS) {\n+    Y_UNIT_TEST_TWIN(SeveralCTAS, UseSink) {\n         NKikimrConfig::TAppConfig appConfig;\n         appConfig.MutableTableServiceConfig()->SetEnableAstCache(true);\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         appConfig.MutableTableServiceConfig()->SetEnableOlapSink(true);\n         appConfig.MutableTableServiceConfig()->SetEnableCreateTableAs(true);\n         appConfig.MutableTableServiceConfig()->SetEnablePerStatementQueryExecution(true);\n@@ -3447,19 +3448,12 @@ Y_UNIT_TEST_SUITE(KqpQueryService) {\n                 CREATE TABLE Table3 (\n                     PRIMARY KEY (Key)\n                 ) AS SELECT * FROM Table2 UNION ALL SELECT * FROM Table1;\n-                SELECT * FROM Table1 ORDER BY Key;\n-                SELECT * FROM Table2 ORDER BY Key;\n-                SELECT * FROM Table3 ORDER BY Key;\n             )\", TTxControl::NoTx(), TExecuteQuerySettings()).ExtractValueSync();\n             UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n-            UNIT_ASSERT_VALUES_EQUAL(result.GetResultSets().size(), 3);\n-            // Results are empty. Snapshot was taken before tables were created, so we don't see changes after snapshot.\n-            // This will be fixed in future, for example, by implicit commit before/after each ddl statement.\n-            CompareYson(R\"([])\", FormatResultSetYson(result.GetResultSet(0)));\n-            CompareYson(R\"([])\", FormatResultSetYson(result.GetResultSet(1)));\n-            CompareYson(R\"([])\", FormatResultSetYson(result.GetResultSet(2)));\n+        }\n \n-            result = db.ExecuteQuery(R\"(\n+        {\n+            auto result = db.ExecuteQuery(R\"(\n                 SELECT * FROM Table1 ORDER BY Key;\n                 SELECT * FROM Table2 ORDER BY Key;\n                 SELECT * FROM Table3 ORDER BY Key;\n@@ -4629,7 +4623,8 @@ Y_UNIT_TEST_SUITE(KqpQueryService) {\n                 UNIT_ASSERT_C(!it.IsSuccess(), it.GetIssues().ToString());\n                 UNIT_ASSERT_C(\n                     it.GetIssues().ToString().contains(\"Operation is aborting because an duplicate key\")\n-                    || it.GetIssues().ToString().contains(\"Conflict with existing key.\"),\n+                    || it.GetIssues().ToString().contains(\"Conflict with existing key.\")\n+                    || it.GetIssues().ToString().contains(\"Duplicate keys have been found.\"),\n                     it.GetIssues().ToString());\n             }\n \n@@ -4812,6 +4807,47 @@ Y_UNIT_TEST_SUITE(KqpQueryService) {\n         tester.Execute();\n     }\n \n+    class TSinkOrderTester: public TTableDataModificationTester {\n+    protected:\n+        void DoExecute() override {\n+            auto client = Kikimr->GetQueryClient();\n+\n+            for (size_t index = 0; index < 100; ++index) {\n+                auto session = client.GetSession().GetValueSync().GetSession();\n+\n+                auto result = session.ExecuteQuery(fmt::format(R\"(\n+                    UPSERT INTO `/Root/DataShard` (Col1, Col2) VALUES ({}u, 0);\n+                )\", index), NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW())).ExtractValueSync();\n+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());\n+\n+                auto tx = result.GetTransaction();\n+                UNIT_ASSERT(tx);\n+\n+                result = session.ExecuteQuery(fmt::format(R\"(\n+                    INSERT INTO `/Root/DataShard` (Col1, Col2) VALUES ({}u, 0);\n+                )\", index), NYdb::NQuery::TTxControl::Tx(tx->GetId()).CommitTx()).ExtractValueSync();\n+                if (GetIsOlap()) {\n+                    // https://github.com/ydb-platform/ydb/issues/14383\n+                    UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::BAD_REQUEST, result.GetIssues().ToString());\n+                } else {\n+                    UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());\n+                }\n+            }\n+        }\n+    };\n+\n+    Y_UNIT_TEST(TableSink_OltpOrder) {\n+        TSinkOrderTester tester;\n+        tester.SetIsOlap(false);\n+        tester.Execute();\n+    }\n+\n+    Y_UNIT_TEST(TableSink_OlapOrder) {\n+        TSinkOrderTester tester;\n+        tester.SetIsOlap(true);\n+        tester.Execute();\n+    }\n+\n     Y_UNIT_TEST(TableSink_ReplaceDuplicatesOlap) {\n         NKikimrConfig::TAppConfig appConfig;\n         appConfig.MutableTableServiceConfig()->SetEnableOlapSink(true);\ndiff --git a/ydb/core/kqp/ut/tx/kqp_locks_ut.cpp b/ydb/core/kqp/ut/tx/kqp_locks_ut.cpp\nindex 735e4f85353a..c25a63f26d74 100644\n--- a/ydb/core/kqp/ut/tx/kqp_locks_ut.cpp\n+++ b/ydb/core/kqp/ut/tx/kqp_locks_ut.cpp\n@@ -241,8 +241,9 @@ Y_UNIT_TEST_SUITE(KqpLocks) {\n             }), commitResult.GetIssues().ToString());\n     }\n \n-    Y_UNIT_TEST(MixedTxFail) {\n+    Y_UNIT_TEST_TWIN(MixedTxFail, useSink) {\n         NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);\n         appConfig.MutableTableServiceConfig()->SetEnableOlapSink(true);\n         appConfig.MutableTableServiceConfig()->SetEnableHtapTx(true);\n         auto settings = TKikimrSettings().SetAppConfig(appConfig).SetWithSampleTables(false);\ndiff --git a/ydb/core/kqp/ut/tx/kqp_sink_tx_ut.cpp b/ydb/core/kqp/ut/tx/kqp_sink_tx_ut.cpp\nindex 085bbf6f12ec..39ddfeb98349 100644\n--- a/ydb/core/kqp/ut/tx/kqp_sink_tx_ut.cpp\n+++ b/ydb/core/kqp/ut/tx/kqp_sink_tx_ut.cpp\n@@ -177,7 +177,6 @@ Y_UNIT_TEST_SUITE(KqpSinkTx) {\n \n             auto result = session.ExecuteQuery(Q_(R\"(\n                 INSERT INTO `/Root/KV` (Key, Value) VALUES (1u, \"New\");\n-                SELECT COUNT(*) FROM `/Root/KV`;\n             )\"), TTxControl::Tx(tx.GetId())).ExtractValueSync();\n             result.GetIssues().PrintTo(Cerr);\n             UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());\ndiff --git a/ydb/core/kqp/ut/tx/kqp_tx_ut.cpp b/ydb/core/kqp/ut/tx/kqp_tx_ut.cpp\nindex 0976bbadcda3..401e5b17e0eb 100644\n--- a/ydb/core/kqp/ut/tx/kqp_tx_ut.cpp\n+++ b/ydb/core/kqp/ut/tx/kqp_tx_ut.cpp\n@@ -82,7 +82,10 @@ Y_UNIT_TEST_SUITE(KqpTx) {\n     }\n \n     Y_UNIT_TEST(LocksAbortOnCommit) {\n-        auto kikimr = DefaultKikimrRunner();\n+        NKikimrConfig::TAppConfig app;\n+        // See KqpSinkTx::LocksAbortOnCommit for sink version of this test\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(false);\n+        auto kikimr = DefaultKikimrRunner({}, app);\n         auto db = kikimr.GetTableClient();\n         auto session = db.CreateSession().GetValueSync().GetSession();\n         {\ndiff --git a/ydb/core/kqp/ut/yql/kqp_yql_ut.cpp b/ydb/core/kqp/ut/yql/kqp_yql_ut.cpp\nindex 9bebac0c3786..a3d38fb8c7c5 100644\n--- a/ydb/core/kqp/ut/yql/kqp_yql_ut.cpp\n+++ b/ydb/core/kqp/ut/yql/kqp_yql_ut.cpp\n@@ -202,8 +202,10 @@ Y_UNIT_TEST_SUITE(KqpYql) {\n         UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::DEFAULT_ERROR));\n     }\n \n-    Y_UNIT_TEST(InsertCV) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_TWIN(InsertCV, useSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);\n+        auto kikimr = DefaultKikimrRunner({}, appConfig);\n         TScriptingClient client(kikimr.GetDriver());\n \n         auto result = client.ExecuteYqlScript(R\"(\n@@ -217,8 +219,10 @@ Y_UNIT_TEST_SUITE(KqpYql) {\n         UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION));\n     }\n \n-    Y_UNIT_TEST(InsertCVList) {\n-        auto kikimr = DefaultKikimrRunner();\n+    Y_UNIT_TEST_TWIN(InsertCVList, useSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);\n+        auto kikimr = DefaultKikimrRunner({}, appConfig);\n         TScriptingClient client(kikimr.GetDriver());\n \n         auto result = client.ExecuteYqlScript(R\"(\ndiff --git a/ydb/core/protos/data_events.proto b/ydb/core/protos/data_events.proto\nindex 2dfe758f0675..cc505d86a9f6 100644\n--- a/ydb/core/protos/data_events.proto\n+++ b/ydb/core/protos/data_events.proto\n@@ -139,6 +139,7 @@ message TEvWriteResult {\n         STATUS_DISK_SPACE_EXHAUSTED = 10;\n         STATUS_WRONG_SHARD_STATE = 11;\n         STATUS_CONSTRAINT_VIOLATION = 12;\n+        STATUS_OUT_OF_SPACE = 13;\n     }\n \n     // Status\ndiff --git a/ydb/core/protos/feature_flags.proto b/ydb/core/protos/feature_flags.proto\nindex f9832ddd78bc..417af4ae787d 100644\n--- a/ydb/core/protos/feature_flags.proto\n+++ b/ydb/core/protos/feature_flags.proto\n@@ -197,4 +197,5 @@ message TFeatureFlags {\n     optional bool EnablePermissionsExport = 171 [default = false];\n     optional bool EnableDataErasure = 172 [default = false];\n     optional bool EnableChangefeedsExport = 174 [default = false];\n+    optional bool EnableAlterDatabase = 182 [default = false];\n }\ndiff --git a/ydb/core/protos/flat_scheme_op.proto b/ydb/core/protos/flat_scheme_op.proto\nindex 30f0cd1b00c4..ec5b30e751df 100644\n--- a/ydb/core/protos/flat_scheme_op.proto\n+++ b/ydb/core/protos/flat_scheme_op.proto\n@@ -430,6 +430,7 @@ message TRequestedBloomNGrammFilter {\n     optional uint32 RecordsCount = 5;\n     optional TIndexDataExtractor DataExtractor = 6;\n     optional TSkipIndexBitSetStorage BitsStorage = 7;\n+    optional bool CaseSensitive = 8 [default = true];\n }\n \n message TRequestedMaxIndex {\n@@ -471,6 +472,7 @@ message TBloomNGrammFilter {\n     optional uint32 RecordsCount = 5;\n     optional TIndexDataExtractor DataExtractor = 6;\n     optional TSkipIndexBitSetStorage BitsStorage = 7;\n+    optional bool CaseSensitive = 8 [default = true];\n }\n \n message TMaxIndex {\n@@ -522,6 +524,7 @@ message TCompactionLevelConstructorContainer {\n         optional uint32 PortionsLiveDurationSeconds = 1;\n         optional uint64 ExpectedBlobsSize = 2;\n         optional uint64 PortionsCountAvailable = 3;\n+        optional uint64 PortionsCountLimit = 4;\n     }\n \n     oneof Implementation {\n@@ -1526,6 +1529,7 @@ message TApplyIf {\n     optional uint64 PathVersion = 2;\n     optional uint64 LockedTxId = 3;\n     optional bool CheckEntityVersion = 4 [default = false];\n+    repeated EPathType PathTypes = 5;\n }\n \n message TUpgradeSubDomain {\ndiff --git a/ydb/core/protos/index_builder.proto b/ydb/core/protos/index_builder.proto\nindex c148577ddeeb..08913a88548c 100644\n--- a/ydb/core/protos/index_builder.proto\n+++ b/ydb/core/protos/index_builder.proto\n@@ -28,7 +28,7 @@ message TIndexBuildSettings {\n     optional bool pg_mode = 8 [ default = false];\n     optional bool if_not_exist = 9 [ default = false];\n \n-    optional uint32 max_batch_rows = 3 [ default = 500 ];\n+    optional uint32 max_batch_rows = 3 [ default = 50000 ];\n     optional uint64 max_batch_bytes = 4 [ default = 8388608 ];\n     optional uint32 max_shards_in_flight = 5 [ default = 32 ];\n     optional uint32 max_retries_upload_batch = 6 [ default = 50 ];\ndiff --git a/ydb/core/protos/kqp.proto b/ydb/core/protos/kqp.proto\nindex 46dee8ed2fd4..5f1a445ef915 100644\n--- a/ydb/core/protos/kqp.proto\n+++ b/ydb/core/protos/kqp.proto\n@@ -639,7 +639,8 @@ message TEvScanInitActor {\n     optional NActorsProto.TActorId ScanActorId = 2;\n     optional uint32 Generation = 3;\n     optional uint64 TabletId = 4;\n-};\n+    optional bool AllowPings = 5;\n+}\n \n message TEvScanError {\n     optional Ydb.StatusIds.StatusCode Status = 1;\n@@ -648,16 +649,26 @@ message TEvScanError {\n     optional uint64 TabletId = 4;\n }\n \n+message TEvScanPing {\n+}\n+\n message TEvKqpScanCursor {\n+    optional uint64 TabletId = 1;\n+\n     message TColumnShardScanPlain {\n     }\n     message TColumnShardScanSimple {\n         optional uint64 SourceId = 1;\n         optional uint32 StartRecordIndex = 2;\n     }\n+    message TColumnShardScanNotSortedSimple {\n+        optional uint64 SourceId = 1;\n+        optional uint32 StartRecordIndex = 2;\n+    }\n     oneof Implementation {\n         TColumnShardScanPlain ColumnShardPlain = 10;\n         TColumnShardScanSimple ColumnShardSimple = 11;\n+        TColumnShardScanNotSortedSimple ColumnShardNotSortedSimple = 12;\n     }\n }\n \ndiff --git a/ydb/core/protos/table_service_config.proto b/ydb/core/protos/table_service_config.proto\nindex f631f2fd9187..376c0b3b308c 100644\n--- a/ydb/core/protos/table_service_config.proto\n+++ b/ydb/core/protos/table_service_config.proto\n@@ -44,7 +44,7 @@ message TTableServiceConfig {\n         optional uint64 KqpPatternCacheCompiledCapacityBytes = 21 [default = 104857600]; // 100 MiB\n         optional double SpillingPercent = 22 [default = 80]; // 100 MiB\n \n-        optional uint64 MinMemAllocSize = 23 [default = 8388608]; // 8 MiB\n+        optional uint64 MinMemAllocSize = 23 [default = 1048576]; // 1 MiB\n         optional uint64 MinMemFreeSize = 24  [default = 33554432]; // 32 MiB\n \n         optional uint64 MaxNonParallelTasksExecutionLimit = 25 [default = 8];\n@@ -84,6 +84,10 @@ message TTableServiceConfig {\n         optional uint64 TotalReadSizeLimitBytes = 4;\n     }\n \n+    message TTxWriteBufferLimits {\n+        optional uint64 WriteBufferMemoryLimitBytes = 1;\n+    }\n+\n     message TQueryLimits {\n         optional TQueryPhaseLimits PhaseLimits = 1;\n         optional uint32 SchemeQueryTimeoutMs = 2 [default = 600000];\n@@ -91,6 +95,7 @@ message TTableServiceConfig {\n         optional uint32 ScanQueryTimeoutMs = 4 [default = 600000];\n         optional uint32 ResultRowsLimit = 5;\n         optional uint32 WaitCAStatsTimeoutMs = 6 [default = 1000];\n+        optional TTxWriteBufferLimits BufferLimits = 7;\n     }\n \n     message TShutdownSettings {\n@@ -293,7 +298,7 @@ message TTableServiceConfig {\n     optional uint64 IdxLookupJoinPointsLimit = 58 [default = 3];\n     reserved 59; //optional bool OldLookupJoinBehaviour = 59 [default = false];\n \n-    optional bool EnableOltpSink = 60 [default = false];\n+    optional bool EnableOltpSink = 60 [default = true];\n \n     enum EBlockChannelsMode {\n         BLOCK_CHANNELS_SCALAR = 0;\n@@ -330,7 +335,6 @@ message TTableServiceConfig {\n     message TWriteActorSettings {\n         optional uint64 InFlightMemoryLimitPerActorBytes = 1 [ default = 67108864 ];\n         optional uint64 MemoryLimitPerMessageBytes = 2 [ default = 67108864 ];\n-        optional uint64 MaxBatchesPerMessage = 3 [ default = 1000 ];\n \n         optional uint64 StartRetryDelayMs = 4 [ default = 1000 ];\n         optional uint64 MaxRetryDelayMs = 5 [ default = 10000 ];\ndiff --git a/ydb/core/protos/tx_datashard.proto b/ydb/core/protos/tx_datashard.proto\nindex 708492d91dca..518f19f63803 100644\n--- a/ydb/core/protos/tx_datashard.proto\n+++ b/ydb/core/protos/tx_datashard.proto\n@@ -214,6 +214,7 @@ message TKqpTransaction {\n         // Type of read result: unboxed values or Arrow blocks of data\n         optional EReadType ReadType = 14;\n         repeated string GroupByColumnNames = 15;\n+        optional uint32 OptionalSorting = 16;\n     }\n \n     optional EKqpTransactionType Type = 1;\n@@ -263,6 +264,7 @@ message TKqpReadRangesSourceSettings {\n     repeated TKqpTransaction.TColumnMeta DuplicateCheckColumns = 19;\n \n     optional NKikimrDataEvents.ELockMode LockMode = 20;\n+    optional uint32 OptionalSorting = 21;\n }\n \n message TKqpTaskInfo {\n@@ -1632,6 +1634,54 @@ message TEvReshuffleKMeansResponse {\n     // optional last written primary key\n }\n \n+message TEvPrefixKMeansRequest {\n+    optional uint64 Id = 1;\n+\n+    optional uint64 TabletId = 2;\n+    optional NKikimrProto.TPathID PathId = 3;\n+\n+    optional uint64 SeqNoGeneration = 4;\n+    optional uint64 SeqNoRound = 5;\n+\n+    optional Ydb.Table.VectorIndexSettings Settings = 6;\n+\n+    optional uint64 Seed = 7;\n+\n+    optional TEvLocalKMeansRequest.EState Upload = 8;\n+\n+    optional uint32 K = 9;\n+    optional uint32 NeedsRounds = 10;\n+\n+    // [Child ... Child + (1 + TableSize) * ShardIndex]\n+    optional uint64 Child = 11;\n+\n+    optional string LevelName = 12;\n+    optional string PostingName = 13;\n+    optional string PrefixName = 14;\n+\n+    optional string EmbeddingColumn = 15;\n+    repeated string DataColumns = 16;\n+    optional uint32 PrefixColumns = 17;\n+}\n+\n+message TEvPrefixKMeansResponse {\n+    optional uint64 Id = 1;\n+\n+    optional uint64 TabletId = 2;\n+    optional NKikimrProto.TPathID PathId = 3;\n+\n+    optional uint64 RequestSeqNoGeneration = 4;\n+    optional uint64 RequestSeqNoRound = 5;\n+\n+    optional NKikimrIndexBuilder.EBuildStatus Status = 6;\n+    repeated Ydb.Issue.IssueMessage Issues = 7;\n+\n+    optional uint64 UploadRows = 8;\n+    optional uint64 UploadBytes = 9;\n+    optional uint64 ReadRows = 10;\n+    optional uint64 ReadBytes = 11;\n+}\n+\n message TEvCdcStreamScanRequest {\n     message TLimits {\n         optional uint32 BatchMaxBytes = 1 [default = 512000];\ndiff --git a/ydb/core/scheme/scheme_tablecell.cpp b/ydb/core/scheme/scheme_tablecell.cpp\nindex 4369b9058964..c376e61eb83f 100644\n--- a/ydb/core/scheme/scheme_tablecell.cpp\n+++ b/ydb/core/scheme/scheme_tablecell.cpp\n@@ -617,6 +617,10 @@ TOwnedCellVecBatch::TOwnedCellVecBatch()\n     : Pool(std::make_unique<TMemoryPool>(InitialPoolSize)) {\n }\n \n+TOwnedCellVecBatch::TOwnedCellVecBatch(std::unique_ptr<TMemoryPool> pool)\n+    : Pool(std::move(pool)) {\n+}\n+\n size_t TOwnedCellVecBatch::Append(TConstArrayRef<TCell> cells) {\n     size_t cellsSize = cells.size();\n     if (cellsSize == 0) {\ndiff --git a/ydb/core/scheme/scheme_tablecell.h b/ydb/core/scheme/scheme_tablecell.h\nindex a40fb60beb75..9d56525dd2d6 100644\n--- a/ydb/core/scheme/scheme_tablecell.h\n+++ b/ydb/core/scheme/scheme_tablecell.h\n@@ -848,11 +848,13 @@ class TOwnedCellVecBatch {\n public:\n     TOwnedCellVecBatch();\n \n+    TOwnedCellVecBatch(std::unique_ptr<TMemoryPool> pool);\n+\n     TOwnedCellVecBatch(const TOwnedCellVecBatch& rhs) = delete;\n \n     TOwnedCellVecBatch & operator=(const TOwnedCellVecBatch& rhs) = delete;\n \n-    TOwnedCellVecBatch(const TOwnedCellVecBatch&& rhs) = default;\n+    TOwnedCellVecBatch(TOwnedCellVecBatch&& rhs) = default;\n \n     TOwnedCellVecBatch & operator=(TOwnedCellVecBatch&& rhs) = default;\n \n@@ -881,6 +883,14 @@ class TOwnedCellVecBatch {\n         return CellVectors.end();\n     }\n \n+    const_iterator begin() const {\n+        return CellVectors.begin();\n+    }\n+\n+    const_iterator end() const {\n+        return CellVectors.end();\n+    }\n+\n     const_iterator cbegin() {\n         return CellVectors.cbegin();\n     }\ndiff --git a/ydb/core/tx/columnshard/blob_cache.cpp b/ydb/core/tx/columnshard/blob_cache.cpp\nindex f404a25536b1..391f57535cf2 100644\n--- a/ydb/core/tx/columnshard/blob_cache.cpp\n+++ b/ydb/core/tx/columnshard/blob_cache.cpp\n@@ -237,7 +237,7 @@ class TBlobCache: public TActorBootstrapped<TBlobCache> {\n         if (it != Cache.End()) {\n             Hits->Inc();\n             HitsBytes->Add(blobRange.Size);\n-            SendResult(sender, blobRange, NKikimrProto::OK, it.Value(), ctx, true);\n+            SendResult(sender, blobRange, NKikimrProto::OK, it.Value(),  {}, ctx, true);\n             return true;\n         }\n \n@@ -423,10 +423,10 @@ class TBlobCache: public TActorBootstrapped<TBlobCache> {\n     }\n \n     void SendResult(const TActorId& to, const TBlobRange& blobRange, NKikimrProto::EReplyStatus status,\n-                    const TString& data, const TActorContext& ctx, const bool fromCache = false) {\n+                    const TString& data, const TString& detailedError, const TActorContext& ctx, const bool fromCache = false) {\n         LOG_S_DEBUG(\"Send result: \" << blobRange << \" to: \" << to << \" status: \" << status);\n \n-        ctx.Send(to, new TEvBlobCache::TEvReadBlobRangeResult(blobRange, status, data, fromCache));\n+        ctx.Send(to, new TEvBlobCache::TEvReadBlobRangeResult(blobRange, status, data, detailedError, fromCache));\n     }\n \n     void Handle(TEvBlobStorage::TEvGetResult::TPtr& ev, const TActorContext& ctx) {\n@@ -436,7 +436,9 @@ class TBlobCache: public TActorBootstrapped<TBlobCache> {\n             Y_ABORT(\"Unexpected reply from blobstorage\");\n         }\n \n+        TString detailedError;\n         if (ev->Get()->Status != NKikimrProto::EReplyStatus::OK) {\n+            detailedError = ev->Get()->ToString();\n             AFL_WARN(NKikimrServices::BLOB_CACHE)(\"fail\", ev->Get()->ToString());\n             ReadSimpleFailedBytes->Add(ev->Get()->ResponseSz);\n             ReadSimpleFailedCount->Add(1);\n@@ -458,14 +460,14 @@ class TBlobCache: public TActorBootstrapped<TBlobCache> {\n \n         for (size_t i = 0; i < ev->Get()->ResponseSz; ++i) {\n             const auto& res = ev->Get()->Responses[i];\n-            ProcessSingleRangeResult(blobRanges[i], readCookie, res.Status, res.Buffer.ConvertToString(), ctx);\n+            ProcessSingleRangeResult(blobRanges[i], readCookie, res.Status, res.Buffer.ConvertToString(), detailedError, ctx);\n         }\n \n         MakeReadRequests(ctx);\n     }\n \n     void ProcessSingleRangeResult(const TBlobRange& blobRange, const ui64 readCookie,\n-        ui32 status, const TString& data, const TActorContext& ctx) noexcept\n+        ui32 status, const TString& data, const TString& detailedError, const TActorContext& ctx) noexcept\n     {\n         AFL_DEBUG(NKikimrServices::BLOB_CACHE)(\"ProcessSingleRangeResult\", blobRange);\n         auto readIt = OutstandingReads.find(blobRange);\n@@ -500,7 +502,7 @@ class TBlobCache: public TActorBootstrapped<TBlobCache> {\n         AFL_DEBUG(NKikimrServices::BLOB_CACHE)(\"ProcessSingleRangeResult\", blobRange)(\"send_replies\", readIt->second.Waiting.size());\n         // Send results to all waiters\n         for (const auto& to : readIt->second.Waiting) {\n-            SendResult(to, blobRange, (NKikimrProto::EReplyStatus)status, data, ctx);\n+            SendResult(to, blobRange, (NKikimrProto::EReplyStatus)status, data, detailedError, ctx);\n         }\n \n         OutstandingReads.erase(readIt);\n@@ -525,7 +527,7 @@ class TBlobCache: public TActorBootstrapped<TBlobCache> {\n \n             for (size_t i = 0; i < blobRanges.size(); ++i) {\n                 Y_ABORT_UNLESS(blobRanges[i].BlobId.GetTabletId() == tabletId);\n-                ProcessSingleRangeResult(blobRanges[i], readCookie, NKikimrProto::EReplyStatus::NOTREADY, {}, ctx);\n+                ProcessSingleRangeResult(blobRanges[i], readCookie, NKikimrProto::EReplyStatus::NOTREADY, {}, {}, ctx);\n             }\n         }\n \ndiff --git a/ydb/core/tx/columnshard/blob_cache.h b/ydb/core/tx/columnshard/blob_cache.h\nindex 75e0ccf0a677..61aa6edcf9e0 100644\n--- a/ydb/core/tx/columnshard/blob_cache.h\n+++ b/ydb/core/tx/columnshard/blob_cache.h\n@@ -72,14 +72,16 @@ struct TEvBlobCache {\n         TBlobRange BlobRange;\n         NKikimrProto::EReplyStatus Status;\n         TString Data;\n+        TString DetailedError;\n         const bool FromCache = false;\n         const TInstant ConstructTime = Now();\n         const TString DataSourceId;\n \n-        TEvReadBlobRangeResult(const TBlobRange& blobRange, NKikimrProto::EReplyStatus status, const TString& data, const bool fromCache = false, const TString& dataSourceId = Default<TString>())\n+        TEvReadBlobRangeResult(const TBlobRange& blobRange, NKikimrProto::EReplyStatus status, const TString& data, const TString& detailedError, const bool fromCache = false, const TString& dataSourceId = Default<TString>())\n             : BlobRange(blobRange)\n             , Status(status)\n             , Data(data)\n+            , DetailedError(detailedError)\n             , FromCache(fromCache)\n             , DataSourceId(dataSourceId)\n         {}\ndiff --git a/ydb/core/tx/columnshard/blobs_action/counters/read.h b/ydb/core/tx/columnshard/blobs_action/counters/read.h\nindex d0e8f736f5b4..e081062c5ec0 100644\n--- a/ydb/core/tx/columnshard/blobs_action/counters/read.h\n+++ b/ydb/core/tx/columnshard/blobs_action/counters/read.h\n@@ -1,6 +1,6 @@\n #pragma once\n #include <library/cpp/monlib/dynamic_counters/counters.h>\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n \n namespace NKikimr::NOlap::NBlobOperations {\n \ndiff --git a/ydb/core/tx/columnshard/blobs_action/counters/remove_declare.h b/ydb/core/tx/columnshard/blobs_action/counters/remove_declare.h\nindex 4e11a6c68f40..e89f66a784ff 100644\n--- a/ydb/core/tx/columnshard/blobs_action/counters/remove_declare.h\n+++ b/ydb/core/tx/columnshard/blobs_action/counters/remove_declare.h\n@@ -1,6 +1,6 @@\n #pragma once\n #include <library/cpp/monlib/dynamic_counters/counters.h>\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n \n namespace NKikimr::NOlap::NBlobOperations {\n \ndiff --git a/ydb/core/tx/columnshard/blobs_action/counters/remove_gc.h b/ydb/core/tx/columnshard/blobs_action/counters/remove_gc.h\nindex f74f7f353f7b..210d730578ef 100644\n--- a/ydb/core/tx/columnshard/blobs_action/counters/remove_gc.h\n+++ b/ydb/core/tx/columnshard/blobs_action/counters/remove_gc.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n \n #include <library/cpp/monlib/dynamic_counters/counters.h>\n \ndiff --git a/ydb/core/tx/columnshard/blobs_action/counters/storage.h b/ydb/core/tx/columnshard/blobs_action/counters/storage.h\nindex f2ded5d3556f..94b66e47e7c8 100644\n--- a/ydb/core/tx/columnshard/blobs_action/counters/storage.h\n+++ b/ydb/core/tx/columnshard/blobs_action/counters/storage.h\n@@ -4,7 +4,7 @@\n #include \"remove_gc.h\"\n #include \"write.h\"\n \n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n \n #include <library/cpp/monlib/dynamic_counters/counters.h>\n #include <util/generic/hash.h>\ndiff --git a/ydb/core/tx/columnshard/blobs_action/counters/write.h b/ydb/core/tx/columnshard/blobs_action/counters/write.h\nindex a9b7f0282817..91576426ccd5 100644\n--- a/ydb/core/tx/columnshard/blobs_action/counters/write.h\n+++ b/ydb/core/tx/columnshard/blobs_action/counters/write.h\n@@ -1,6 +1,6 @@\n #pragma once\n #include <library/cpp/monlib/dynamic_counters/counters.h>\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n \n namespace NKikimr::NOlap::NBlobOperations {\n \ndiff --git a/ydb/core/tx/columnshard/blobs_action/tier/adapter.cpp b/ydb/core/tx/columnshard/blobs_action/tier/adapter.cpp\nindex d0136aa98388..8d42d230ee06 100644\n--- a/ydb/core/tx/columnshard/blobs_action/tier/adapter.cpp\n+++ b/ydb/core/tx/columnshard/blobs_action/tier/adapter.cpp\n@@ -16,11 +16,11 @@ std::unique_ptr<NActors::IEventBase> TRepliesAdapter::RebuildReplyEvent(std::uni\n     }\n     if (ev->IsSuccess()) {\n         AFL_VERIFY(!!ev->Body)(\"key\", ev->Key)(\"interval_from\", ev->GetReadInterval().first)(\"interval_to\", ev->GetReadInterval().second);\n-        return std::make_unique<NBlobCache::TEvBlobCache::TEvReadBlobRangeResult>(bRange, NKikimrProto::EReplyStatus::OK, ev->Body, false, StorageId);\n+        return std::make_unique<NBlobCache::TEvBlobCache::TEvReadBlobRangeResult>(bRange, NKikimrProto::EReplyStatus::OK, ev->Body, TString{}, false, StorageId);\n     } else {\n         AFL_DEBUG(NKikimrServices::TX_TIERING)(\"event\", \"s3_request_failed\")(\"request_type\", \"get_object\")(\n             \"exception\", ev->GetError().GetExceptionName())(\"message\", ev->GetError().GetMessage())(\"storage_id\", StorageId)(\"blob\", logoBlobId);\n-        return std::make_unique<NBlobCache::TEvBlobCache::TEvReadBlobRangeResult>(bRange, NKikimrProto::EReplyStatus::ERROR, TStringBuilder() << ev->Result, false, StorageId);\n+        return std::make_unique<NBlobCache::TEvBlobCache::TEvReadBlobRangeResult>(bRange, NKikimrProto::EReplyStatus::ERROR, TStringBuilder() << ev->Result, TStringBuilder{} << ev->GetError().GetExceptionName() << \", \" << ev->GetError().GetMessage(), false, StorageId);\n     }\n }\n \ndiff --git a/ydb/core/tx/columnshard/blobs_action/transaction/tx_blobs_written.cpp b/ydb/core/tx/columnshard/blobs_action/transaction/tx_blobs_written.cpp\nindex 6c730e7f4ea0..e0c5ab30a6b9 100644\n--- a/ydb/core/tx/columnshard/blobs_action/transaction/tx_blobs_written.cpp\n+++ b/ydb/core/tx/columnshard/blobs_action/transaction/tx_blobs_written.cpp\n@@ -1,7 +1,7 @@\n-#include <ydb/core/tx/columnshard/common/path_id.h>\n #include \"tx_blobs_written.h\"\n \n #include <ydb/core/tx/columnshard/blob_cache.h>\n+#include <ydb/core/tx/columnshard/common/path_id.h>\n #include <ydb/core/tx/columnshard/engines/column_engine_logs.h>\n #include <ydb/core/tx/columnshard/engines/insert_table/user_data.h>\n #include <ydb/core/tx/columnshard/transactions/locks/write.h>\n@@ -97,10 +97,11 @@ void TTxBlobsWritingFinished::DoComplete(const TActorContext& ctx) {\n     }\n     std::set<TInternalPathId> pathIds;\n     for (auto&& writeResult : Pack.GetWriteResults()) {\n+        const auto& writeMeta = writeResult.GetWriteMeta();\n+        writeMeta.OnStage(NEvWrite::EWriteStage::Replied);\n         if (writeResult.GetNoDataToWrite()) {\n             continue;\n         }\n-        const auto& writeMeta = writeResult.GetWriteMeta();\n         auto op = Self->GetOperationsManager().GetOperationVerified((TOperationWriteId)writeMeta.GetWriteId());\n         pathIds.emplace(op->GetPathId());\n         if (op->GetBehaviour() == EOperationBehaviour::WriteWithLock || op->GetBehaviour() == EOperationBehaviour::NoTxWrite) {\n@@ -146,13 +147,16 @@ TTxBlobsWritingFinished::TTxBlobsWritingFinished(TColumnShard* self, const NKiki\n bool TTxBlobsWritingFailed::DoExecute(TTransactionContext& txc, const TActorContext& /* ctx */) {\n     for (auto&& wResult : Pack.GetWriteResults()) {\n         const auto& writeMeta = wResult.GetWriteMeta();\n+        writeMeta.OnStage(NEvWrite::EWriteStage::Replied);\n         AFL_VERIFY(!writeMeta.HasLongTxId());\n         auto op = Self->GetOperationsManager().GetOperationVerified((TOperationWriteId)writeMeta.GetWriteId());\n         Self->OperationsManager->AddTemporaryTxLink(op->GetLockId());\n         Self->OperationsManager->AbortTransactionOnExecute(*Self, op->GetLockId(), txc);\n \n         auto ev = NEvents::TDataEvents::TEvWriteResult::BuildError(Self->TabletID(), op->GetLockId(),\n-            NKikimrDataEvents::TEvWriteResult::STATUS_INTERNAL_ERROR, \"cannot write blob: \" + ::ToString(PutBlobResult));\n+            wResult.IsInternalError() ? NKikimrDataEvents::TEvWriteResult::STATUS_INTERNAL_ERROR\n+                                      : NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST,\n+            wResult.GetErrorMessage());\n         Results.emplace_back(std::move(ev), writeMeta.GetSource(), op->GetCookie());\n     }\n     return true;\ndiff --git a/ydb/core/tx/columnshard/blobs_action/transaction/tx_blobs_written.h b/ydb/core/tx/columnshard/blobs_action/transaction/tx_blobs_written.h\nindex 6bb3549b20d4..738ca1e01675 100644\n--- a/ydb/core/tx/columnshard/blobs_action/transaction/tx_blobs_written.h\n+++ b/ydb/core/tx/columnshard/blobs_action/transaction/tx_blobs_written.h\n@@ -55,7 +55,6 @@ class TTxBlobsWritingFinished: public TExtendedTransactionBase {\n class TTxBlobsWritingFailed: public TExtendedTransactionBase {\n private:\n     using TBase = TExtendedTransactionBase;\n-    const NKikimrProto::EReplyStatus PutBlobResult;\n     TInsertedPortions Pack;\n \n     class TReplyInfo {\n@@ -79,9 +78,8 @@ class TTxBlobsWritingFailed: public TExtendedTransactionBase {\n     std::vector<TReplyInfo> Results;\n \n public:\n-    TTxBlobsWritingFailed(TColumnShard* self, const NKikimrProto::EReplyStatus writeStatus, TInsertedPortions&& pack)\n+    TTxBlobsWritingFailed(TColumnShard* self, TInsertedPortions&& pack)\n         : TBase(self)\n-        , PutBlobResult(writeStatus)\n         , Pack(std::move(pack)) {\n     }\n \ndiff --git a/ydb/core/tx/columnshard/blobs_reader/actor.cpp b/ydb/core/tx/columnshard/blobs_reader/actor.cpp\nindex 3d27b9d8a0e8..2121d308935f 100644\n--- a/ydb/core/tx/columnshard/blobs_reader/actor.cpp\n+++ b/ydb/core/tx/columnshard/blobs_reader/actor.cpp\n@@ -15,7 +15,7 @@ void TActor::Handle(NBlobCache::TEvBlobCache::TEvReadBlobRangeResult::TPtr& ev)\n     bool aborted = false;\n     if (event.Status != NKikimrProto::EReplyStatus::OK) {\n         WaitingBlobsCount.Sub(Task->GetWaitingRangesCount());\n-        if (!Task->AddError(event.DataSourceId, event.BlobRange, IBlobsReadingAction::TErrorStatus::Fail(event.Status, \"cannot get blob: \" + event.Data.substr(0, 1024)))) {\n+        if (!Task->AddError(event.DataSourceId, event.BlobRange, IBlobsReadingAction::TErrorStatus::Fail(event.Status, \"cannot get blob: \" + event.Data.substr(0, 1024) + \", detailed error: \" + event.DetailedError))) {\n             aborted = true;\n         }\n     } else {\ndiff --git a/ydb/core/tx/columnshard/blobs_reader/read_coordinator.cpp b/ydb/core/tx/columnshard/blobs_reader/read_coordinator.cpp\nindex df9a740d230c..207b41f00e9d 100644\n--- a/ydb/core/tx/columnshard/blobs_reader/read_coordinator.cpp\n+++ b/ydb/core/tx/columnshard/blobs_reader/read_coordinator.cpp\n@@ -18,7 +18,7 @@ void TReadCoordinatorActor::Handle(NBlobCache::TEvBlobCache::TEvReadBlobRangeRes\n     auto tasks = BlobTasks.Extract(event.DataSourceId, event.BlobRange);\n     for (auto&& i : tasks) {\n         if (event.Status != NKikimrProto::EReplyStatus::OK) {\n-            i->AddError(event.DataSourceId, event.BlobRange, IBlobsReadingAction::TErrorStatus::Fail(event.Status, \"cannot get blob\"));\n+            i->AddError(event.DataSourceId, event.BlobRange, IBlobsReadingAction::TErrorStatus::Fail(event.Status, \"cannot get blob, detailed error: \" + event.DetailedError));\n         } else {\n             i->AddData(event.DataSourceId, event.BlobRange, event.Data);\n         }\ndiff --git a/ydb/core/tx/columnshard/blobs_reader/task.h b/ydb/core/tx/columnshard/blobs_reader/task.h\nindex 00aaa396c742..a27fa02d069e 100644\n--- a/ydb/core/tx/columnshard/blobs_reader/task.h\n+++ b/ydb/core/tx/columnshard/blobs_reader/task.h\n@@ -3,7 +3,7 @@\n #include <ydb/library/conclusion/status.h>\n #include <ydb/core/tx/columnshard/blob.h>\n #include <ydb/core/tx/columnshard/blobs_action/abstract/read.h>\n-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>\n+#include <ydb/library/signals/object_counter.h>\n #include <ydb/core/protos/base.pb.h>\n #include <ydb/core/tx/columnshard/resource_subscriber/task.h>\n \ndiff --git a/ydb/core/tx/columnshard/columnshard__propose_transaction.cpp b/ydb/core/tx/columnshard/columnshard__propose_transaction.cpp\nindex 82cf16fec496..f864a1015186 100644\n--- a/ydb/core/tx/columnshard/columnshard__propose_transaction.cpp\n+++ b/ydb/core/tx/columnshard/columnshard__propose_transaction.cpp\n@@ -12,6 +12,8 @@ using namespace NTabletFlatExecutor;\n class TTxProposeTransaction: public NTabletFlatExecutor::TTransactionBase<TColumnShard> {\n private:\n     using TBase = NTabletFlatExecutor::TTransactionBase<TColumnShard>;\n+    TEvColumnShard::TEvProposeTransaction::TPtr Ev;\n+    std::shared_ptr<TTxController::ITransactionOperator> TxOperator;\n     std::optional<TTxController::TTxInfo> TxInfo;\n \n public:\n@@ -69,7 +71,7 @@ class TTxProposeTransaction: public NTabletFlatExecutor::TTransactionBase<TColum\n                 msgSeqNo = SeqNoFromProto(schemaTxBody.GetSeqNo());\n             }\n         }\n-        TxInfo.emplace(txKind, txId, Ev->Get()->GetSource(), Ev->Cookie, msgSeqNo);\n+        TxInfo.emplace(txKind, txId, Ev->Get()->GetSource(), Self->GetProgressTxController().GetAllowedStep(), Ev->Cookie, msgSeqNo);\n         TxOperator = Self->GetProgressTxController().StartProposeOnExecute(*TxInfo, txBody, txc);\n         return true;\n     }\n@@ -114,8 +116,6 @@ class TTxProposeTransaction: public NTabletFlatExecutor::TTransactionBase<TColum\n     }\n \n private:\n-    TEvColumnShard::TEvProposeTransaction::TPtr Ev;\n-    std::shared_ptr<TTxController::ITransactionOperator> TxOperator;\n \n };\n \ndiff --git a/ydb/core/tx/columnshard/columnshard__write.cpp b/ydb/core/tx/columnshard/columnshard__write.cpp\nindex 818263c77181..7e407387d861 100644\n--- a/ydb/core/tx/columnshard/columnshard__write.cpp\n+++ b/ydb/core/tx/columnshard/columnshard__write.cpp\n@@ -34,6 +34,9 @@ void TColumnShard::OverloadWriteFail(const EOverloadStatus overloadReason, const\n         case EOverloadStatus::OverloadMetadata:\n             Counters.OnWriteOverloadMetadata(writeSize);\n             break;\n+        case EOverloadStatus::OverloadCompaction:\n+            Counters.OnWriteOverloadCompaction(writeSize);\n+            break;\n         case EOverloadStatus::ShardTxInFly:\n             Counters.OnWriteOverloadShardTx(writeSize);\n             break;\n@@ -58,8 +61,16 @@ TColumnShard::EOverloadStatus TColumnShard::CheckOverloadedWait(const TInternalP\n         return EOverloadStatus::InsertTable;\n     }\n     Counters.GetCSCounters().OnIndexMetadataLimit(NOlap::IColumnEngine::GetMetadataLimit());\n-    if (TablesManager.GetPrimaryIndex() && TablesManager.GetPrimaryIndex()->IsOverloadedByMetadata(NOlap::IColumnEngine::GetMetadataLimit())) {\n-        return EOverloadStatus::OverloadMetadata;\n+    if (TablesManager.GetPrimaryIndex()) {\n+        if (TablesManager.GetPrimaryIndex()->IsOverloadedByMetadata(NOlap::IColumnEngine::GetMetadataLimit())) {\n+            return EOverloadStatus::OverloadMetadata;\n+        }\n+        if (TablesManager.GetPrimaryIndexAsVerified<NOlap::TColumnEngineForLogs>()\n+                .GetGranuleVerified(pathId)\n+                .GetOptimizerPlanner()\n+                .IsOverloaded()) {\n+            return EOverloadStatus::OverloadCompaction;\n+        }\n     }\n     return EOverloadStatus::None;\n }\n@@ -110,12 +121,12 @@ void TColumnShard::Handle(NPrivateEvents::NWrite::TEvWritePortionResult::TPtr& e\n             Counters.OnWritePutBlobsFailed(now - i.GetWriteMeta().GetWriteStartInstant(), i.GetRecordsCount());\n             Counters.GetCSCounters().OnWritePutBlobsFail(now - i.GetWriteMeta().GetWriteStartInstant());\n             AFL_WARN(NKikimrServices::TX_COLUMNSHARD_WRITE)(\"writing_size\", i.GetDataSize())(\"event\", \"data_write_error\")(\n-                \"writing_id\", i.GetWriteMeta().GetId());\n+                \"writing_id\", i.GetWriteMeta().GetId())(\"reason\", i.GetErrorMessage());\n             Counters.GetWritesMonitor()->OnFinishWrite(i.GetDataSize(), 1);\n             i.MutableWriteMeta().OnStage(NEvWrite::EWriteStage::Finished);\n         }\n \n-        Execute(new TTxBlobsWritingFailed(this, ev->Get()->GetWriteStatus(), std::move(writtenData)), ctx);\n+        Execute(new TTxBlobsWritingFailed(this, std::move(writtenData)), ctx);\n     }\n }\n \n@@ -203,7 +214,8 @@ void TColumnShard::Handle(TEvColumnShard::TEvWrite::TPtr& ev, const TActorContex\n     writeMeta.SetLongTxId(NLongTxService::TLongTxId::FromProto(record.GetLongTxId()));\n     writeMeta.SetWritePartId(record.GetWritePartId());\n \n-    const auto returnFail = [&](const NColumnShard::ECumulativeCounters signalIndex, const EWriteFailReason reason, NKikimrTxColumnShard::EResultStatus resultStatus) {\n+    const auto returnFail = [&](const NColumnShard::ECumulativeCounters signalIndex, const EWriteFailReason reason,\n+                                NKikimrTxColumnShard::EResultStatus resultStatus) {\n         Counters.GetTabletCounters()->IncCounter(signalIndex);\n \n         ctx.Send(source, std::make_unique<TEvColumnShard::TEvWriteResult>(TabletID(), writeMeta, resultStatus));\n@@ -211,7 +223,8 @@ void TColumnShard::Handle(TEvColumnShard::TEvWrite::TPtr& ev, const TActorContex\n         return;\n     };\n \n-    if (SpaceWatcher->SubDomainOutOfSpace && (!record.HasModificationType() || (record.GetModificationType() != NKikimrTxColumnShard::TEvWrite::OPERATION_DELETE))) {\n+    if (SpaceWatcher->SubDomainOutOfSpace &&\n+        (!record.HasModificationType() || (record.GetModificationType() != NKikimrTxColumnShard::TEvWrite::OPERATION_DELETE))) {\n         AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"skip_writing\")(\"reason\", \"quota_exceeded\");\n         Counters.GetTabletCounters()->IncCounter(COUNTER_OUT_OF_SPACE);\n         return returnFail(COUNTER_WRITE_FAIL, EWriteFailReason::Overload, NKikimrTxColumnShard::EResultStatus::OVERLOADED);\n@@ -402,7 +415,8 @@ class TProposeWriteTransaction: public TExtendedTransactionBase {\n         }\n         proto.SetLockId(WriteCommit->GetLockId());\n         TxOperator = Self->GetProgressTxController().StartProposeOnExecute(\n-            TTxController::TTxInfo(kind, WriteCommit->GetTxId(), Source, Cookie, {}), proto.SerializeAsString(), txc);\n+            TTxController::TTxInfo(kind, WriteCommit->GetTxId(), Source, Self->GetProgressTxController().GetAllowedStep(), \n+            Cookie, {}), proto.SerializeAsString(), txc);\n         return true;\n     }\n \n@@ -487,7 +501,7 @@ void TColumnShard::Handle(NEvents::TDataEvents::TEvWrite::TPtr& ev, const TActor\n \n     const auto sendError = [&](const TString& message, const NKikimrDataEvents::TEvWriteResult::EStatus status) {\n         Counters.GetTabletCounters()->IncCounter(COUNTER_WRITE_FAIL);\n-        auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(TabletID(), 0, status, message);\n+        auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(TabletID(), record.GetTxId(), status, message);\n         ctx.Send(source, result.release(), 0, cookie);\n     };\n     if (behaviour == EOperationBehaviour::CommitWriteLock) {\ndiff --git a/ydb/core/tx/columnshard/columnshard_impl.cpp b/ydb/core/tx/columnshard/columnshard_impl.cpp\nindex ebaf53c86a37..3f089c2b4d09 100644\n--- a/ydb/core/tx/columnshard/columnshard_impl.cpp\n+++ b/ydb/core/tx/columnshard/columnshard_impl.cpp\n@@ -544,7 +544,7 @@ class TChangesTask: public NConveyor::ITask {\n     NOlap::TSnapshot LastCompletedTx;\n \n protected:\n-    virtual TConclusionStatus DoExecute(const std::shared_ptr<NConveyor::ITask>& /*taskPtr*/) override {\n+    virtual void DoExecute(const std::shared_ptr<NConveyor::ITask>& /*taskPtr*/) override {\n         NActors::TLogContextGuard g(NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"tablet_id\", TabletId)(\"parent_id\", ParentActorId));\n         {\n             NOlap::TConstructionContext context(*TxEvent->IndexInfo, Counters, LastCompletedTx);\n@@ -554,7 +554,6 @@ class TChangesTask: public NConveyor::ITask {\n             }\n         }\n         TActorContext::AsActorContext().Send(ParentActorId, std::move(TxEvent));\n-        return TConclusionStatus::Success();\n     }\n \n public:\n@@ -1394,14 +1393,13 @@ class TAccessorsParsingTask: public NConveyor::ITask {\n     std::shared_ptr<NOlap::NDataAccessorControl::IAccessorCallback> FetchCallback;\n     std::vector<TPortionConstructorV2> Portions;\n \n-    virtual TConclusionStatus DoExecute(const std::shared_ptr<ITask>& /*taskPtr*/) override {\n+    virtual void DoExecute(const std::shared_ptr<ITask>& /*taskPtr*/) override {\n         std::vector<NOlap::TPortionDataAccessor> accessors;\n         accessors.reserve(Portions.size());\n         for (auto&& i : Portions) {\n             accessors.emplace_back(i.BuildAccessor());\n         }\n         FetchCallback->OnAccessorsFetched(std::move(accessors));\n-        return TConclusionStatus::Success();\n     }\n     virtual void DoOnCannotExecute(const TString& reason) override {\n         AFL_VERIFY(false)(\"cannot parse metadata\", reason);\ndiff --git a/ydb/core/tx/columnshard/columnshard_impl.h b/ydb/core/tx/columnshard/columnshard_impl.h\nindex eda7afe5e587..ce3f16b9899e 100644\n--- a/ydb/core/tx/columnshard/columnshard_impl.h\n+++ b/ydb/core/tx/columnshard/columnshard_impl.h\n@@ -359,7 +359,8 @@ class TColumnShard: public TActor<TColumnShard>, public NTabletFlatExecutor::TTa\n         InsertTable /* \"insert_table\" */,\n         OverloadMetadata /* \"overload_metadata\" */,\n         Disk /* \"disk\" */,\n-        None /* \"none\" */\n+        None /* \"none\" */,\n+        OverloadCompaction /* \"overload_compaction\" */\n     };\n \n     // For syslocks\ndiff --git a/ydb/core/tx/columnshard/common/limits.h b/ydb/core/tx/columnshard/common/limits.h\nindex ca019a7510f6..e3869f26727f 100644\n--- a/ydb/core/tx/columnshard/common/limits.h\n+++ b/ydb/core/tx/columnshard/common/limits.h\n@@ -10,7 +10,6 @@ class TGlobalLimits {\n     static constexpr inline ui64 GeneralCompactionMemoryLimit = 3ULL << 30;\n     static constexpr inline ui64 ScanMemoryLimit = 3ULL << 30;\n \n-    static constexpr inline ui64 DefaultBlobsMemoryIntervalLimit = ScanMemoryLimit;\n     static constexpr inline ui64 DefaultReadSequentiallyBufferSize = ((ui64)8) << 20;\n };\n }\n\\ No newline at end of file\ndiff --git a/ydb/core/tx/columnshard/common/snapshot.cpp b/ydb/core/tx/columnshard/common/snapshot.cpp\nindex e0e873488985..5fcd337b8c9f 100644\n--- a/ydb/core/tx/columnshard/common/snapshot.cpp\n+++ b/ydb/core/tx/columnshard/common/snapshot.cpp\n@@ -39,6 +39,10 @@ NKikimr::NOlap::TSnapshot TSnapshot::MaxForPlanStep(const ui64 planStep) noexcep\n     return TSnapshot(planStep, ::Max<ui64>());\n }\n \n+NKikimr::NOlap::TSnapshot TSnapshot::MaxForPlanStep(const TPositiveIncreasingControlInteger planStep) noexcept {\n+    return MaxForPlanStep(planStep.Val());\n+}\n+\n NKikimr::NOlap::TSnapshot TSnapshot::MaxForPlanInstant(const TInstant planInstant) noexcept {\n     return TSnapshot(planInstant.MilliSeconds(), ::Max<ui64>());\n }\ndiff --git a/ydb/core/tx/columnshard/common/snapshot.h b/ydb/core/tx/columnshard/common/snapshot.h\nindex 7f04203eea8a..4f9e3841f791 100644\n--- a/ydb/core/tx/columnshard/common/snapshot.h\n+++ b/ydb/core/tx/columnshard/common/snapshot.h\n@@ -1,6 +1,6 @@\n #pragma once\n #include <ydb/library/conclusion/status.h>\n-\n+#include <ydb/library/accessor/positive_integer.h>\n #include <util/stream/output.h>\n #include <util/string/cast.h>\n #include <util/datetime/base.h>\n@@ -26,6 +26,11 @@ class TSnapshot {\n         , TxId(txId) {\n     }\n \n+    constexpr TSnapshot(const TPositiveIncreasingControlInteger planStep, const ui64 txId) noexcept\n+        : PlanStep(planStep.Val())\n+        , TxId(txId) {\n+    }\n+\n     NJson::TJsonValue SerializeToJson() const;\n \n     constexpr TInstant GetPlanInstant() const noexcept {\n@@ -60,6 +65,8 @@ class TSnapshot {\n \n     static TSnapshot MaxForPlanStep(const ui64 planStep) noexcept;\n \n+    static TSnapshot MaxForPlanStep(const TPositiveIncreasingControlInteger planStep) noexcept;\n+\n     constexpr bool operator==(const TSnapshot&) const noexcept = default;\n \n     constexpr auto operator<=>(const TSnapshot&) const noexcept = default;\ndiff --git a/ydb/core/tx/columnshard/counters/blobs_manager.h b/ydb/core/tx/columnshard/counters/blobs_manager.h\nindex 8490ff38814e..cae14e75f869 100644\n--- a/ydb/core/tx/columnshard/counters/blobs_manager.h\n+++ b/ydb/core/tx/columnshard/counters/blobs_manager.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include \"common/owner.h\"\n+#include <ydb/library/signals/owner.h>\n \n #include <ydb/core/base/logoblob.h>\n #include <ydb/core/tx/columnshard/blobs_action/abstract/blob_set.h>\ndiff --git a/ydb/core/tx/columnshard/counters/columnshard.cpp b/ydb/core/tx/columnshard/counters/columnshard.cpp\nindex 67c569e1313b..78a3c9785904 100644\n--- a/ydb/core/tx/columnshard/counters/columnshard.cpp\n+++ b/ydb/core/tx/columnshard/counters/columnshard.cpp\n@@ -32,6 +32,8 @@ TCSCounters::TCSCounters()\n     OverloadInsertTableCount = TBase::GetDeriviative(\"Overload/InsertTable/Count\");\n     OverloadMetadataBytes = TBase::GetDeriviative(\"Overload/Metadata/Bytes\");\n     OverloadMetadataCount = TBase::GetDeriviative(\"Overload/Metadata/Count\");\n+    OverloadCompactionBytes = TBase::GetDeriviative(\"Overload/Compaction/Bytes\");\n+    OverloadCompactionCount = TBase::GetDeriviative(\"Overload/Compaction/Count\");\n     OverloadShardTxBytes = TBase::GetDeriviative(\"Overload/Shard/Tx/Bytes\");\n     OverloadShardTxCount = TBase::GetDeriviative(\"Overload/Shard/Tx/Count\");\n     OverloadShardWritesBytes = TBase::GetDeriviative(\"Overload/Shard/Writes/Bytes\");\ndiff --git a/ydb/core/tx/columnshard/counters/columnshard.h b/ydb/core/tx/columnshard/counters/columnshard.h\nindex 97789bc144ca..974bc1433bf2 100644\n--- a/ydb/core/tx/columnshard/counters/columnshard.h\n+++ b/ydb/core/tx/columnshard/counters/columnshard.h\n@@ -2,7 +2,7 @@\n #include \"initialization.h\"\n #include \"tx_progress.h\"\n \n-#include \"common/owner.h\"\n+#include <ydb/library/signals/owner.h>\n \n #include <ydb/core/tx/columnshard/counters/tablet_counters.h>\n #include <ydb/core/tx/data_events/common/signals_flow.h>\n@@ -88,6 +88,8 @@ class TCSCounters: public TCommonCountersOwner {\n     NMonitoring::TDynamicCounters::TCounterPtr OverloadInsertTableCount;\n     NMonitoring::TDynamicCounters::TCounterPtr OverloadMetadataBytes;\n     NMonitoring::TDynamicCounters::TCounterPtr OverloadMetadataCount;\n+    NMonitoring::TDynamicCounters::TCounterPtr OverloadCompactionBytes;\n+    NMonitoring::TDynamicCounters::TCounterPtr OverloadCompactionCount;\n     NMonitoring::TDynamicCounters::TCounterPtr OverloadShardTxBytes;\n     NMonitoring::TDynamicCounters::TCounterPtr OverloadShardTxCount;\n     NMonitoring::TDynamicCounters::TCounterPtr OverloadShardWritesBytes;\n@@ -188,6 +190,11 @@ class TCSCounters: public TCommonCountersOwner {\n         OverloadMetadataCount->Add(1);\n     }\n \n+    void OnWriteOverloadCompaction(const ui64 size) const {\n+        OverloadCompactionBytes->Add(size);\n+        OverloadCompactionCount->Add(1);\n+    }\n+\n     void OnWriteOverloadShardTx(const ui64 size) const {\n         OverloadShardTxBytes->Add(size);\n         OverloadShardTxCount->Add(1);\ndiff --git a/ydb/core/tx/columnshard/counters/common_data.h b/ydb/core/tx/columnshard/counters/common_data.h\nindex 6c92a4fed41e..f087d2e32d1b 100644\n--- a/ydb/core/tx/columnshard/counters/common_data.h\n+++ b/ydb/core/tx/columnshard/counters/common_data.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include \"common/owner.h\"\n+#include <ydb/library/signals/owner.h>\n \n #include <ydb/library/actors/core/log.h>\n \ndiff --git a/ydb/core/tx/columnshard/counters/counters_manager.h b/ydb/core/tx/columnshard/counters/counters_manager.h\nindex 7b287c12fbf4..2f6b2c4ad86a 100644\n--- a/ydb/core/tx/columnshard/counters/counters_manager.h\n+++ b/ydb/core/tx/columnshard/counters/counters_manager.h\n@@ -65,6 +65,10 @@ class TCountersManager {\n         CSCounters.OnWriteOverloadMetadata(size);\n     }\n \n+    void OnWriteOverloadCompaction(const ui64 size) const {\n+        CSCounters.OnWriteOverloadCompaction(size);\n+    }\n+\n     void OnWriteOverloadShardTx(const ui64 size) const {\n         TabletCounters->IncCounter(COUNTER_WRITE_OVERLOAD);\n         CSCounters.OnWriteOverloadShardTx(size);\ndiff --git a/ydb/core/tx/columnshard/counters/engine_logs.h b/ydb/core/tx/columnshard/counters/engine_logs.h\nindex 7461981363b6..9c7a4aefb2a8 100644\n--- a/ydb/core/tx/columnshard/counters/engine_logs.h\n+++ b/ydb/core/tx/columnshard/counters/engine_logs.h\n@@ -1,8 +1,8 @@\n #pragma once\n \n #include \"common_data.h\"\n-#include \"common/owner.h\"\n-#include \"common/histogram.h\"\n+#include <ydb/library/signals/owner.h>\n+#include <ydb/library/signals/histogram.h>\n #include <ydb/core/tx/columnshard/common/portion.h>\n #include <library/cpp/monlib/dynamic_counters/counters.h>\n #include <util/string/builder.h>\ndiff --git a/ydb/core/tx/columnshard/counters/indexation.h b/ydb/core/tx/columnshard/counters/indexation.h\nindex f527a219ff43..5fc395e92f48 100644\n--- a/ydb/core/tx/columnshard/counters/indexation.h\n+++ b/ydb/core/tx/columnshard/counters/indexation.h\n@@ -2,7 +2,7 @@\n #include \"splitter.h\"\n #include \"sub_columns.h\"\n \n-#include \"common/owner.h\"\n+#include <ydb/library/signals/owner.h>\n \n #include <library/cpp/monlib/dynamic_counters/counters.h>\n \ndiff --git a/ydb/core/tx/columnshard/counters/initialization.h b/ydb/core/tx/columnshard/counters/initialization.h\nindex 2a6b432d6135..009c0a79637e 100644\n--- a/ydb/core/tx/columnshard/counters/initialization.h\n+++ b/ydb/core/tx/columnshard/counters/initialization.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include \"common/owner.h\"\n+#include <ydb/library/signals/owner.h>\n \n #include <library/cpp/monlib/dynamic_counters/counters.h>\n \ndiff --git a/ydb/core/tx/columnshard/counters/insert_table.h b/ydb/core/tx/columnshard/counters/insert_table.h\nindex 0c20660d609e..32432acc164f 100644\n--- a/ydb/core/tx/columnshard/counters/insert_table.h\n+++ b/ydb/core/tx/columnshard/counters/insert_table.h\n@@ -1,7 +1,7 @@\n #pragma once\n #include \"common_data.h\"\n-#include \"common/client.h\"\n-#include \"common/agent.h\"\n+#include <ydb/library/signals/client.h>\n+#include <ydb/library/signals/agent.h>\n \n namespace NKikimr::NColumnShard {\n \ndiff --git a/ydb/core/tx/columnshard/counters/portions.h b/ydb/core/tx/columnshard/counters/portions.h\nindex 72915d255b06..cfc06459a521 100644\n--- a/ydb/core/tx/columnshard/counters/portions.h\n+++ b/ydb/core/tx/columnshard/counters/portions.h\n@@ -1,7 +1,7 @@\n #pragma once\n-#include \"common/agent.h\"\n-#include \"common/client.h\"\n-#include \"common/owner.h\"\n+#include <ydb/library/signals/agent.h>\n+#include <ydb/library/signals/client.h>\n+#include <ydb/library/signals/owner.h>\n \n #include <ydb/library/actors/core/log.h>\n \ndiff --git a/ydb/core/tx/columnshard/counters/req_tracer.h b/ydb/core/tx/columnshard/counters/req_tracer.h\nindex f70cd02e4840..e8c6b109f0a0 100644\n--- a/ydb/core/tx/columnshard/counters/req_tracer.h\n+++ b/ydb/core/tx/columnshard/counters/req_tracer.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include \"common/owner.h\"\n+#include <ydb/library/signals/owner.h>\n #include <ydb/core/tx/columnshard/common/snapshot.h>\n \n namespace NKikimr::NColumnShard {\ndiff --git a/ydb/core/tx/columnshard/counters/scan.cpp b/ydb/core/tx/columnshard/counters/scan.cpp\nindex 36b3c6abae87..144a2b25588e 100644\n--- a/ydb/core/tx/columnshard/counters/scan.cpp\n+++ b/ydb/core/tx/columnshard/counters/scan.cpp\n@@ -24,7 +24,8 @@ TScanCounters::TScanCounters(const TString& module)\n     , LinearScanIntervals(TBase::GetDeriviative(\"LinearScanIntervals\"))\n     , LogScanRecords(TBase::GetDeriviative(\"LogScanRecords\"))\n     , LogScanIntervals(TBase::GetDeriviative(\"LogScanIntervals\"))\n-    , NotIndexBlobs(TBase::GetDeriviative(\"Indexes/NoData/Count\"))\n+    , NoIndexBlobs(TBase::GetDeriviative(\"Indexes/NoData/Blobs/Count\"))\n+    , NoIndex(TBase::GetDeriviative(\"Indexes/NoData/Index/Count\"))\n     , RecordsAcceptedByIndex(TBase::GetDeriviative(\"Indexes/Accepted/Records\"))\n     , RecordsDeniedByIndex(TBase::GetDeriviative(\"Indexes/Denied/Records\"))\n     , RecordsAcceptedByHeader(TBase::GetDeriviative(\"Headers/Accepted/Records\"))\ndiff --git a/ydb/core/tx/columnshard/counters/scan.h b/ydb/core/tx/columnshard/counters/scan.h\nindex 78047490d3eb..9c5313f240fd 100644\n--- a/ydb/core/tx/columnshard/counters/scan.h\n+++ b/ydb/core/tx/columnshard/counters/scan.h\n@@ -1,8 +1,8 @@\n #pragma once\n #include \"sub_columns.h\"\n \n-#include \"common/histogram.h\"\n-#include \"common/owner.h\"\n+#include <ydb/library/signals/histogram.h>\n+#include <ydb/library/signals/owner.h>\n \n #include <ydb/core/protos/table_stats.pb.h>\n #include <ydb/core/tx/columnshard/resource_subscriber/counters.h>\n@@ -149,7 +149,8 @@ class TScanCounters: public TCommonCountersOwner {\n     NMonitoring::THistogramPtr HistogramIntervalMemoryRequiredOnFail;\n     NMonitoring::THistogramPtr HistogramIntervalMemoryReduceSize;\n     NMonitoring::THistogramPtr HistogramIntervalMemoryRequiredAfterReduce;\n-    NMonitoring::TDynamicCounters::TCounterPtr NotIndexBlobs;\n+    NMonitoring::TDynamicCounters::TCounterPtr NoIndexBlobs;\n+    NMonitoring::TDynamicCounters::TCounterPtr NoIndex;\n     NMonitoring::TDynamicCounters::TCounterPtr RecordsAcceptedByIndex;\n     NMonitoring::TDynamicCounters::TCounterPtr RecordsDeniedByIndex;\n     NMonitoring::TDynamicCounters::TCounterPtr RecordsAcceptedByHeader;\n@@ -162,8 +163,11 @@ class TScanCounters: public TCommonCountersOwner {\n         return SubColumnCounters;\n     }\n \n-    void OnNotIndexBlobs() const {\n-        NotIndexBlobs->Add(1);\n+    void OnNoIndexBlobs(const ui32 recordsCount) const {\n+        NoIndexBlobs->Add(recordsCount);\n+    }\n+    void OnNoIndex(const ui32 recordsCount) const {\n+        NoIndex->Add(recordsCount);\n     }\n     void OnAcceptedByIndex(const ui32 recordsCount) const {\n         RecordsAcceptedByIndex->Add(recordsCount);\ndiff --git a/ydb/core/tx/columnshard/counters/splitter.h b/ydb/core/tx/columnshard/counters/splitter.h\nindex cbde8265a2f7..efe23b850f21 100644\n--- a/ydb/core/tx/columnshard/counters/splitter.h\n+++ b/ydb/core/tx/columnshard/counters/splitter.h\n@@ -1,6 +1,6 @@\n #pragma once\n #include <library/cpp/monlib/dynamic_counters/counters.h>\n-#include \"common/owner.h\"\n+#include <ydb/library/signals/owner.h>\n \n namespace NKikimr::NColumnShard {\n \ndiff --git a/ydb/core/tx/columnshard/counters/sub_columns.h b/ydb/core/tx/columnshard/counters/sub_columns.h\nindex 36d4aeb2b0a3..66fcfea61a2a 100644\n--- a/ydb/core/tx/columnshard/counters/sub_columns.h\n+++ b/ydb/core/tx/columnshard/counters/sub_columns.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include \"common/owner.h\"\n+#include <ydb/library/signals/owner.h>\n \n #include <library/cpp/monlib/dynamic_counters/counters.h>\n \ndiff --git a/ydb/core/tx/columnshard/counters/tx_progress.h b/ydb/core/tx/columnshard/counters/tx_progress.h\nindex 24319a3ab748..24cbd4ffed10 100644\n--- a/ydb/core/tx/columnshard/counters/tx_progress.h\n+++ b/ydb/core/tx/columnshard/counters/tx_progress.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include \"common/owner.h\"\n+#include <ydb/library/signals/owner.h>\n \n #include <library/cpp/monlib/dynamic_counters/counters.h>\n #include <util/generic/hash.h>\ndiff --git a/ydb/core/tx/columnshard/counters/ya.make b/ydb/core/tx/columnshard/counters/ya.make\nindex 12efb4545046..f27b507d885b 100644\n--- a/ydb/core/tx/columnshard/counters/ya.make\n+++ b/ydb/core/tx/columnshard/counters/ya.make\n@@ -21,7 +21,7 @@ SRCS(\n PEERDIR(\n     library/cpp/monlib/dynamic_counters\n     ydb/core/tx/columnshard/counters/aggregation\n-    ydb/core/tx/columnshard/counters/common\n+    ydb/library/signals\n     ydb/core/base\n     ydb/library/actors/core\n )\ndiff --git a/ydb/core/tx/columnshard/data_accessor/request.h b/ydb/core/tx/columnshard/data_accessor/request.h\nindex 70d1a16eaba0..34876fd9cc35 100644\n--- a/ydb/core/tx/columnshard/data_accessor/request.h\n+++ b/ydb/core/tx/columnshard/data_accessor/request.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>\n+#include <ydb/library/signals/object_counter.h>\n #include <ydb/core/tx/columnshard/engines/portions/data_accessor.h>\n #include <ydb/core/tx/columnshard/engines/portions/portion_info.h>\n #include <ydb/core/tx/columnshard/resource_subscriber/task.h>\ndiff --git a/ydb/core/tx/columnshard/engines/changes/abstract/ya.make b/ydb/core/tx/columnshard/engines/changes/abstract/ya.make\nindex 78095066a094..27b111dc5682 100644\n--- a/ydb/core/tx/columnshard/engines/changes/abstract/ya.make\n+++ b/ydb/core/tx/columnshard/engines/changes/abstract/ya.make\n@@ -10,7 +10,7 @@ SRCS(\n )\n \n PEERDIR(\n-    ydb/core/tx/columnshard/counters/common\n+    ydb/library/signals\n     ydb/core/tx/columnshard/engines/changes/counters\n     ydb/core/tablet_flat\n     yql/essentials/core/expr_nodes\ndiff --git a/ydb/core/tx/columnshard/engines/changes/compaction/sub_columns/ya.make b/ydb/core/tx/columnshard/engines/changes/compaction/sub_columns/ya.make\nindex f18a5c199024..4f85dd7575d0 100644\n--- a/ydb/core/tx/columnshard/engines/changes/compaction/sub_columns/ya.make\n+++ b/ydb/core/tx/columnshard/engines/changes/compaction/sub_columns/ya.make\n@@ -9,6 +9,7 @@ SRCS(\n \n PEERDIR(\n     ydb/core/tx/columnshard/engines/changes/compaction/common\n+    ydb/core/formats/arrow/accessor/sub_columns\n )\n \n END()\ndiff --git a/ydb/core/tx/columnshard/engines/changes/counters/changes.h b/ydb/core/tx/columnshard/engines/changes/counters/changes.h\nindex 2b2f301ae63b..377444fc5f88 100644\n--- a/ydb/core/tx/columnshard/engines/changes/counters/changes.h\n+++ b/ydb/core/tx/columnshard/engines/changes/counters/changes.h\n@@ -1,7 +1,7 @@\n #pragma once\n \n #include <ydb/core/tx/columnshard/blobs_action/counters/storage.h>\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n \n #include <ydb/library/actors/core/log.h>\n \ndiff --git a/ydb/core/tx/columnshard/engines/changes/counters/general.h b/ydb/core/tx/columnshard/engines/changes/counters/general.h\nindex 98deee42a6af..e4fff50744ab 100644\n--- a/ydb/core/tx/columnshard/engines/changes/counters/general.h\n+++ b/ydb/core/tx/columnshard/engines/changes/counters/general.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n #include <ydb/core/tx/columnshard/counters/portions.h>\n \n #include <ydb/library/actors/core/log.h>\ndiff --git a/ydb/core/tx/columnshard/engines/changes/counters/ya.make b/ydb/core/tx/columnshard/engines/changes/counters/ya.make\nindex b557eaee1e58..3b1dc197d21b 100644\n--- a/ydb/core/tx/columnshard/engines/changes/counters/ya.make\n+++ b/ydb/core/tx/columnshard/engines/changes/counters/ya.make\n@@ -10,7 +10,7 @@ PEERDIR(\n     ydb/library/actors/core\n     ydb/core/tablet_flat\n     ydb/core/tx/columnshard/blobs_action/counters\n-    ydb/core/tx/columnshard/counters/common\n+    ydb/library/signals\n )\n \n GENERATE_ENUM_SERIALIZATION(changes.h)\ndiff --git a/ydb/core/tx/columnshard/engines/portions/data_accessor.cpp b/ydb/core/tx/columnshard/engines/portions/data_accessor.cpp\nindex 3d936b1686bc..7c3394f914ef 100644\n--- a/ydb/core/tx/columnshard/engines/portions/data_accessor.cpp\n+++ b/ydb/core/tx/columnshard/engines/portions/data_accessor.cpp\n@@ -766,10 +766,10 @@ TConclusion<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> TPortionDataAcces\n     return builder.Finish();\n }\n \n-std::shared_ptr<NArrow::NAccessor::TDeserializeChunkedArray> TPortionDataAccessor::TPreparedColumn::AssembleForSeqAccess() const {\n+std::shared_ptr<NArrow::NAccessor::IChunkedArray> TPortionDataAccessor::TPreparedColumn::AssembleForSeqAccess() const {\n     Y_ABORT_UNLESS(!Blobs.empty());\n \n-    std::vector<NArrow::NAccessor::TDeserializeChunkedArray::TChunk> chunks;\n+    std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> chunks;\n     chunks.reserve(Blobs.size());\n     ui64 recordsCount = 0;\n     for (auto& blob : Blobs) {\n@@ -781,20 +781,22 @@ std::shared_ptr<NArrow::NAccessor::TDeserializeChunkedArray> TPortionDataAccesso\n         }\n     }\n \n-    return std::make_shared<NArrow::NAccessor::TDeserializeChunkedArray>(recordsCount, Loader, std::move(chunks));\n+    if (chunks.size() == 1) {\n+        return chunks.front();\n+    } else {\n+        return std::make_shared<NArrow::NAccessor::TCompositeChunkedArray>(std::move(chunks), recordsCount, Loader->GetResultField()->type());\n+    }\n }\n \n-NArrow::NAccessor::TDeserializeChunkedArray::TChunk TPortionDataAccessor::TAssembleBlobInfo::BuildDeserializeChunk(\n+std::shared_ptr<NArrow::NAccessor::IChunkedArray> TPortionDataAccessor::TAssembleBlobInfo::BuildDeserializeChunk(\n     const std::shared_ptr<TColumnLoader>& loader) const {\n     if (DefaultRowsCount) {\n         AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"build_trivial\");\n         Y_ABORT_UNLESS(!Data);\n-        auto col = std::make_shared<NArrow::NAccessor::TTrivialArray>(\n-            NArrow::TThreadSimpleArraysCache::Get(loader->GetField()->type(), DefaultValue, DefaultRowsCount));\n-        return NArrow::NAccessor::TDeserializeChunkedArray::TChunk(col);\n+        return std::make_shared<NArrow::NAccessor::TSparsedArray>(DefaultValue, loader->GetField()->type(), DefaultRowsCount);\n     } else {\n         AFL_VERIFY(ExpectedRowsCount);\n-        return NArrow::NAccessor::TDeserializeChunkedArray::TChunk(*ExpectedRowsCount, Data);\n+        return std::make_shared<NArrow::NAccessor::TDeserializeChunkedArray>(*ExpectedRowsCount, loader, Data);\n     }\n }\n \ndiff --git a/ydb/core/tx/columnshard/engines/portions/data_accessor.h b/ydb/core/tx/columnshard/engines/portions/data_accessor.h\nindex b9e440dbc86e..7a1418e66fe8 100644\n--- a/ydb/core/tx/columnshard/engines/portions/data_accessor.h\n+++ b/ydb/core/tx/columnshard/engines/portions/data_accessor.h\n@@ -319,7 +319,7 @@ class TPortionDataAccessor {\n         }\n \n         TConclusion<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> BuildRecordBatch(const TColumnLoader& loader) const;\n-        NArrow::NAccessor::TDeserializeChunkedArray::TChunk BuildDeserializeChunk(const std::shared_ptr<TColumnLoader>& loader) const;\n+        std::shared_ptr<NArrow::NAccessor::IChunkedArray> BuildDeserializeChunk(const std::shared_ptr<TColumnLoader>& loader) const;\n     };\n \n     class TPreparedColumn {\n@@ -346,7 +346,7 @@ class TPortionDataAccessor {\n             AFL_VERIFY(Loader);\n         }\n \n-        std::shared_ptr<NArrow::NAccessor::TDeserializeChunkedArray> AssembleForSeqAccess() const;\n+        std::shared_ptr<NArrow::NAccessor::IChunkedArray> AssembleForSeqAccess() const;\n         TConclusion<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> AssembleAccessor() const;\n     };\n \ndiff --git a/ydb/core/tx/columnshard/engines/portions/meta.h b/ydb/core/tx/columnshard/engines/portions/meta.h\nindex 579c80eb4bc7..a91b29dd08e4 100644\n--- a/ydb/core/tx/columnshard/engines/portions/meta.h\n+++ b/ydb/core/tx/columnshard/engines/portions/meta.h\n@@ -65,7 +65,7 @@ class TPortionMetaBase {\n class TPortionMeta: public TPortionMetaBase {\n private:\n     using TBase = TPortionMetaBase;\n-    NArrow::TFirstLastSpecialKeys ReplaceKeyEdges;   // first and last PK rows\n+    NArrow::TFirstLastSpecialKeys ReplaceKeyEdges;\n     YDB_READONLY_DEF(TString, TierName);\n     YDB_READONLY(ui32, DeletionsCount, 0);\n     YDB_READONLY(ui32, CompactionLevel, 0);\ndiff --git a/ydb/core/tx/columnshard/engines/predicate/container.cpp b/ydb/core/tx/columnshard/engines/predicate/container.cpp\nindex 780a3390befa..0c0cf5baf79c 100644\n--- a/ydb/core/tx/columnshard/engines/predicate/container.cpp\n+++ b/ydb/core/tx/columnshard/engines/predicate/container.cpp\n@@ -179,4 +179,36 @@ TConclusion<TPredicateContainer> TPredicateContainer::BuildPredicateTo(\n     }\n }\n \n+NArrow::TColumnFilter TPredicateContainer::BuildFilter(const std::shared_ptr<NArrow::TGeneralContainer>& data) const {\n+    if (!Object) {\n+        auto result = NArrow::TColumnFilter::BuildAllowFilter();\n+        result.Add(true, data->GetRecordsCount());\n+        return result;\n+    }\n+    if (!data->GetRecordsCount()) {\n+        return NArrow::TColumnFilter::BuildAllowFilter();\n+    }\n+    auto sortingFields = Object->Batch->schema()->field_names();\n+    auto position = NArrow::NMerger::TRWSortableBatchPosition(data, 0, sortingFields, {}, false);\n+    const auto border = NArrow::NMerger::TSortableBatchPosition(Object->Batch, 0, sortingFields, {}, false);\n+    const bool needUppedBound = CompareType == NArrow::ECompareType::LESS_OR_EQUAL || CompareType == NArrow::ECompareType::GREATER;\n+    const auto findBound = position.FindBound(position, 0, data->GetRecordsCount() - 1, border, needUppedBound);\n+    const ui64 rowsBeforeBound = findBound ? findBound->GetPosition() : data->GetRecordsCount();\n+\n+    auto filter = NArrow::TColumnFilter::BuildAllowFilter();\n+    switch (CompareType) {\n+        case NArrow::ECompareType::LESS:\n+        case NArrow::ECompareType::LESS_OR_EQUAL:\n+            filter.Add(true, rowsBeforeBound);\n+            filter.Add(false, data->GetRecordsCount() - rowsBeforeBound);\n+            break;\n+        case NArrow::ECompareType::GREATER:\n+        case NArrow::ECompareType::GREATER_OR_EQUAL:\n+            filter.Add(false, rowsBeforeBound);\n+            filter.Add(true, data->GetRecordsCount() - rowsBeforeBound);\n+            break;\n+    }\n+    return filter;\n }\n+\n+}   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/predicate/container.h b/ydb/core/tx/columnshard/engines/predicate/container.h\nindex bb30aebc59a0..78dcb041447a 100644\n--- a/ydb/core/tx/columnshard/engines/predicate/container.h\n+++ b/ydb/core/tx/columnshard/engines/predicate/container.h\n@@ -1,7 +1,10 @@\n #pragma once\n #include \"predicate.h\"\n \n+#include <ydb/core/formats/arrow/accessor/abstract/accessor.h>\n #include <ydb/core/formats/arrow/arrow_filter.h>\n+#include <ydb/core/formats/arrow/common/container.h>\n+#include <ydb/core/formats/arrow/reader/position.h>\n \n #include <ydb/library/accessor/accessor.h>\n #include <ydb/library/conclusion/result.h>\n@@ -115,12 +118,7 @@ class TPredicateContainer {\n     static TConclusion<TPredicateContainer> BuildPredicateTo(\n         std::shared_ptr<NOlap::TPredicate> object, const std::shared_ptr<arrow::Schema>& pkSchema);\n \n-    NKikimr::NArrow::TColumnFilter BuildFilter(const arrow::Datum& data) const {\n-        if (!Object) {\n-            return NArrow::TColumnFilter::BuildAllowFilter();\n-        }\n-        return NArrow::TColumnFilter::MakePredicateFilter(data, Object->Batch, CompareType);\n-    }\n+    NArrow::TColumnFilter BuildFilter(const std::shared_ptr<NArrow::TGeneralContainer>& data) const;\n };\n \n }   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/engines/predicate/filter.cpp b/ydb/core/tx/columnshard/engines/predicate/filter.cpp\nindex 1dc7b77bff5b..002988f9aadd 100644\n--- a/ydb/core/tx/columnshard/engines/predicate/filter.cpp\n+++ b/ydb/core/tx/columnshard/engines/predicate/filter.cpp\n@@ -7,13 +7,14 @@\n \n namespace NKikimr::NOlap {\n \n-NKikimr::NArrow::TColumnFilter TPKRangesFilter::BuildFilter(const arrow::Datum& data) const {\n+NKikimr::NArrow::TColumnFilter TPKRangesFilter::BuildFilter(const std::shared_ptr<NArrow::TGeneralContainer>& data) const {\n     if (SortedRanges.empty()) {\n         return NArrow::TColumnFilter::BuildAllowFilter();\n     }\n-    NArrow::TColumnFilter result = SortedRanges.front().BuildFilter(data);\n-    for (ui32 i = 1; i < SortedRanges.size(); ++i) {\n-        result = result.Or(SortedRanges[i].BuildFilter(data));\n+\n+    auto result = NArrow::TColumnFilter::BuildDenyFilter();\n+    for (const auto& range : SortedRanges) {\n+        result = result.Or(range.BuildFilter(data));\n     }\n     return result;\n }\n@@ -36,16 +37,9 @@ TConclusionStatus TPKRangesFilter::Add(\n         return toContainerConclusion;\n     }\n     if (SortedRanges.size() && !FakeRanges) {\n-        if (ReverseFlag) {\n-            if (fromContainerConclusion->CrossRanges(SortedRanges.front().GetPredicateTo())) {\n-                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"add_range_filter\")(\"problem\", \"not sorted sequence\");\n-                return TConclusionStatus::Fail(\"not sorted sequence\");\n-            }\n-        } else {\n-            if (fromContainerConclusion->CrossRanges(SortedRanges.back().GetPredicateTo())) {\n-                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"add_range_filter\")(\"problem\", \"not sorted sequence\");\n-                return TConclusionStatus::Fail(\"not sorted sequence\");\n-            }\n+        if (fromContainerConclusion->CrossRanges(SortedRanges.back().GetPredicateTo())) {\n+            AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"add_range_filter\")(\"problem\", \"not sorted sequence\");\n+            return TConclusionStatus::Fail(\"not sorted sequence\");\n         }\n     }\n     auto pkRangeFilterConclusion = TPKRangeFilter::Build(fromContainerConclusion.DetachResult(), toContainerConclusion.DetachResult());\n@@ -56,11 +50,7 @@ TConclusionStatus TPKRangesFilter::Add(\n         FakeRanges = false;\n         SortedRanges.clear();\n     }\n-    if (ReverseFlag) {\n-        SortedRanges.emplace_front(pkRangeFilterConclusion.DetachResult());\n-    } else {\n-        SortedRanges.emplace_back(pkRangeFilterConclusion.DetachResult());\n-    }\n+    SortedRanges.emplace_back(pkRangeFilterConclusion.DetachResult());\n     return TConclusionStatus::Success();\n }\n \n@@ -112,8 +102,7 @@ TPKRangeFilter::EUsageClass TPKRangesFilter::GetUsageClass(const NArrow::TReplac\n     return TPKRangeFilter::EUsageClass::NoUsage;\n }\n \n-TPKRangesFilter::TPKRangesFilter(const bool reverse)\n-    : ReverseFlag(reverse) {\n+TPKRangesFilter::TPKRangesFilter() {\n     auto range = TPKRangeFilter::Build(TPredicateContainer::BuildNullPredicateFrom(), TPredicateContainer::BuildNullPredicateTo());\n     Y_ABORT_UNLESS(range);\n     SortedRanges.emplace_back(*range);\n@@ -148,8 +137,8 @@ std::shared_ptr<arrow::RecordBatch> TPKRangesFilter::SerializeToRecordBatch(cons\n }\n \n std::shared_ptr<NKikimr::NOlap::TPKRangesFilter> TPKRangesFilter::BuildFromRecordBatchLines(\n-    const std::shared_ptr<arrow::RecordBatch>& batch, const bool reverse) {\n-    std::shared_ptr<TPKRangesFilter> result = std::make_shared<TPKRangesFilter>(reverse);\n+    const std::shared_ptr<arrow::RecordBatch>& batch) {\n+    std::shared_ptr<TPKRangesFilter> result = std::make_shared<TPKRangesFilter>();\n     for (ui32 i = 0; i < batch->num_rows(); ++i) {\n         auto batchRow = batch->Slice(i, 1);\n         auto pFrom = std::make_shared<NOlap::TPredicate>(NKernels::EOperation::GreaterEqual, batchRow);\n@@ -160,8 +149,8 @@ std::shared_ptr<NKikimr::NOlap::TPKRangesFilter> TPKRangesFilter::BuildFromRecor\n }\n \n std::shared_ptr<NKikimr::NOlap::TPKRangesFilter> TPKRangesFilter::BuildFromRecordBatchFull(\n-    const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& pkSchema, const bool reverse) {\n-    std::shared_ptr<TPKRangesFilter> result = std::make_shared<TPKRangesFilter>(reverse);\n+    const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& pkSchema) {\n+    std::shared_ptr<TPKRangesFilter> result = std::make_shared<TPKRangesFilter>();\n     auto pkBatch = NArrow::TColumnOperator().Adapt(batch, pkSchema).DetachResult();\n     auto c = batch->GetColumnByName(\".ydb_operation_type\");\n     AFL_VERIFY(c);\n@@ -201,9 +190,9 @@ std::shared_ptr<NKikimr::NOlap::TPKRangesFilter> TPKRangesFilter::BuildFromRecor\n }\n \n std::shared_ptr<NKikimr::NOlap::TPKRangesFilter> TPKRangesFilter::BuildFromString(\n-    const TString& data, const std::shared_ptr<arrow::Schema>& pkSchema, const bool reverse) {\n+    const TString& data, const std::shared_ptr<arrow::Schema>& pkSchema) {\n     auto batch = NArrow::TStatusValidator::GetValid(NArrow::NSerialization::TNativeSerializer().Deserialize(data));\n-    return BuildFromRecordBatchFull(batch, pkSchema, reverse);\n+    return BuildFromRecordBatchFull(batch, pkSchema);\n }\n \n TString TPKRangesFilter::SerializeToString(const std::shared_ptr<arrow::Schema>& pkSchema) const {\ndiff --git a/ydb/core/tx/columnshard/engines/predicate/filter.h b/ydb/core/tx/columnshard/engines/predicate/filter.h\nindex b020320280ef..0241cf20fe5b 100644\n--- a/ydb/core/tx/columnshard/engines/predicate/filter.h\n+++ b/ydb/core/tx/columnshard/engines/predicate/filter.h\n@@ -1,8 +1,8 @@\n #pragma once\n #include \"range.h\"\n \n-#include <ydb/core/protos/tx_datashard.pb.h>\n #include <ydb/core/protos/kqp.pb.h>\n+#include <ydb/core/protos/tx_datashard.pb.h>\n \n #include <deque>\n \n@@ -12,10 +12,9 @@ class TPKRangesFilter {\n private:\n     bool FakeRanges = true;\n     std::deque<TPKRangeFilter> SortedRanges;\n-    bool ReverseFlag = false;\n \n public:\n-    TPKRangesFilter(const bool reverse);\n+    TPKRangesFilter();\n \n     std::optional<ui32> GetFilteredCountLimit(const std::shared_ptr<arrow::Schema>& pkSchema) {\n         ui32 result = 0;\n@@ -38,10 +37,6 @@ class TPKRangesFilter {\n         return SortedRanges.empty() || FakeRanges;\n     }\n \n-    bool IsReverse() const {\n-        return ReverseFlag;\n-    }\n-\n     const TPKRangeFilter& Front() const {\n         Y_ABORT_UNLESS(Size());\n         return SortedRanges.front();\n@@ -69,7 +64,7 @@ class TPKRangesFilter {\n     TPKRangeFilter::EUsageClass GetUsageClass(const NArrow::TReplaceKey& start, const NArrow::TReplaceKey& end) const;\n     bool CheckPoint(const NArrow::TReplaceKey& point) const;\n \n-    NArrow::TColumnFilter BuildFilter(const arrow::Datum& data) const;\n+    NArrow::TColumnFilter BuildFilter(const std::shared_ptr<NArrow::TGeneralContainer>& data) const;\n \n     std::set<std::string> GetColumnNames() const {\n         std::set<std::string> result;\n@@ -85,20 +80,19 @@ class TPKRangesFilter {\n \n     std::set<ui32> GetColumnIds(const TIndexInfo& indexInfo) const;\n \n-    static std::shared_ptr<TPKRangesFilter> BuildFromRecordBatchLines(const std::shared_ptr<arrow::RecordBatch>& batch, const bool reverse);\n+    static std::shared_ptr<TPKRangesFilter> BuildFromRecordBatchLines(const std::shared_ptr<arrow::RecordBatch>& batch);\n \n     static std::shared_ptr<TPKRangesFilter> BuildFromRecordBatchFull(\n-        const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& pkSchema, const bool reverse);\n-    static std::shared_ptr<TPKRangesFilter> BuildFromString(\n-        const TString& data, const std::shared_ptr<arrow::Schema>& pkSchema, const bool reverse);\n+        const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& pkSchema);\n+    static std::shared_ptr<TPKRangesFilter> BuildFromString(const TString& data, const std::shared_ptr<arrow::Schema>& pkSchema);\n \n     template <class TProto>\n-    static TConclusion<TPKRangesFilter> BuildFromProto(const TProto& proto, const bool reverse, const std::vector<TNameTypeInfo>& ydbPk) {\n-        TPKRangesFilter result(reverse);\n+    static TConclusion<TPKRangesFilter> BuildFromProto(const TProto& proto, const std::vector<TNameTypeInfo>& ydbPk) {\n+        TPKRangesFilter result;\n         for (auto& protoRange : proto.GetRanges()) {\n             auto fromPredicate = std::make_shared<TPredicate>();\n             auto toPredicate = std::make_shared<TPredicate>();\n-            std::tie(*fromPredicate, *toPredicate) = TPredicate::DeserializePredicatesRange(TSerializedTableRange{protoRange}, ydbPk);\n+            std::tie(*fromPredicate, *toPredicate) = TPredicate::DeserializePredicatesRange(TSerializedTableRange{ protoRange }, ydbPk);\n             auto status = result.Add(fromPredicate, toPredicate, NArrow::TStatusValidator::GetValid(NArrow::MakeArrowSchema(ydbPk)));\n             if (status.IsFail()) {\n                 return status;\n@@ -114,6 +108,8 @@ class ICursorEntity {\n     virtual ui64 DoGetEntityRecordsCount() const = 0;\n \n public:\n+    virtual ~ICursorEntity() = default;\n+\n     ui64 GetEntityId() const {\n         return DoGetEntityId();\n     }\n@@ -124,8 +120,10 @@ class ICursorEntity {\n \n class IScanCursor {\n private:\n+    YDB_ACCESSOR_DEF(std::optional<ui64>, TabletId);\n+\n     virtual const std::shared_ptr<arrow::RecordBatch>& DoGetPKCursor() const = 0;\n-    virtual bool DoCheckEntityIsBorder(const std::shared_ptr<ICursorEntity>& entity, bool& usage) const = 0;\n+    virtual bool DoCheckEntityIsBorder(const ICursorEntity& entity, bool& usage) const = 0;\n     virtual bool DoCheckSourceIntervalUsage(const ui64 sourceId, const ui32 indexStart, const ui32 recordsCount) const = 0;\n     virtual TConclusionStatus DoDeserializeFromProto(const NKikimrKqp::TEvKqpScanCursor& proto) = 0;\n     virtual void DoSerializeToProto(NKikimrKqp::TEvKqpScanCursor& proto) const = 0;\n@@ -144,17 +142,23 @@ class IScanCursor {\n         return DoCheckSourceIntervalUsage(sourceId, indexStart, recordsCount);\n     }\n \n-    bool CheckEntityIsBorder(const std::shared_ptr<ICursorEntity>& entity, bool& usage) const {\n+    bool CheckEntityIsBorder(const ICursorEntity& entity, bool& usage) const {\n         AFL_VERIFY(IsInitialized());\n         return DoCheckEntityIsBorder(entity, usage);\n     }\n \n     TConclusionStatus DeserializeFromProto(const NKikimrKqp::TEvKqpScanCursor& proto) {\n+        if (proto.HasTabletId()) {\n+            TabletId = proto.GetTabletId();\n+        }\n         return DoDeserializeFromProto(proto);\n     }\n \n     NKikimrKqp::TEvKqpScanCursor SerializeToProto() const {\n         NKikimrKqp::TEvKqpScanCursor result;\n+        if (TabletId) {\n+            result.SetTabletId(*TabletId);\n+        }\n         DoSerializeToProto(result);\n         return result;\n     }\n@@ -172,7 +176,6 @@ class TSimpleScanCursor: public IScanCursor {\n     }\n \n     virtual const std::shared_ptr<arrow::RecordBatch>& DoGetPKCursor() const override {\n-        AFL_VERIFY(!!PrimaryKey);\n         return PrimaryKey;\n     }\n \n@@ -180,18 +183,18 @@ class TSimpleScanCursor: public IScanCursor {\n         return !!SourceId;\n     }\n \n-    virtual bool DoCheckEntityIsBorder(const std::shared_ptr<ICursorEntity>& entity, bool& usage) const override {\n-        if (SourceId != entity->GetEntityId()) {\n+    virtual bool DoCheckEntityIsBorder(const ICursorEntity& entity, bool& usage) const override {\n+        if (SourceId != entity.GetEntityId()) {\n             return false;\n         }\n-        AFL_VERIFY(RecordIndex <= entity->GetEntityRecordsCount());\n-        usage = RecordIndex < entity->GetEntityRecordsCount();\n+        AFL_VERIFY(RecordIndex <= entity.GetEntityRecordsCount());\n+        usage = RecordIndex < entity.GetEntityRecordsCount();\n         return true;\n     }\n \n     virtual TConclusionStatus DoDeserializeFromProto(const NKikimrKqp::TEvKqpScanCursor& proto) override {\n         if (!proto.HasColumnShardSimple()) {\n-            return TConclusionStatus::Success();\n+            return TConclusionStatus::Fail(\"absent sorted cursor data\");\n         }\n         if (!proto.GetColumnShardSimple().HasSourceId()) {\n             return TConclusionStatus::Fail(\"incorrect source id for cursor initialization\");\n@@ -223,6 +226,68 @@ class TSimpleScanCursor: public IScanCursor {\n     }\n };\n \n+class TNotSortedSimpleScanCursor: public TSimpleScanCursor {\n+private:\n+    YDB_READONLY(ui64, SourceId, 0);\n+    YDB_READONLY(ui32, RecordIndex, 0);\n+\n+    virtual void DoSerializeToProto(NKikimrKqp::TEvKqpScanCursor& proto) const override {\n+        auto& data = *proto.MutableColumnShardNotSortedSimple();\n+        data.SetSourceId(SourceId);\n+        data.SetStartRecordIndex(RecordIndex);\n+    }\n+\n+    virtual const std::shared_ptr<arrow::RecordBatch>& DoGetPKCursor() const override {\n+        return Default<std::shared_ptr<arrow::RecordBatch>>();\n+    }\n+\n+    virtual bool IsInitialized() const override {\n+        return !!SourceId;\n+    }\n+\n+    virtual bool DoCheckEntityIsBorder(const ICursorEntity& entity, bool& usage) const override {\n+        if (SourceId != entity.GetEntityId()) {\n+            return false;\n+        }\n+        AFL_VERIFY(RecordIndex <= entity.GetEntityRecordsCount())(\"index\", RecordIndex)(\"count\", entity.GetEntityRecordsCount());\n+        usage = RecordIndex < entity.GetEntityRecordsCount();\n+        return true;\n+    }\n+\n+    virtual TConclusionStatus DoDeserializeFromProto(const NKikimrKqp::TEvKqpScanCursor& proto) override {\n+        if (!proto.HasColumnShardNotSortedSimple()) {\n+            return TConclusionStatus::Fail(\"absent unsorted cursor data\");\n+        }\n+        auto& data = proto.GetColumnShardNotSortedSimple();\n+        if (!data.HasSourceId()) {\n+            return TConclusionStatus::Fail(\"incorrect source id for cursor initialization\");\n+        }\n+        SourceId = data.GetSourceId();\n+        if (!data.HasStartRecordIndex()) {\n+            return TConclusionStatus::Fail(\"incorrect record index for cursor initialization\");\n+        }\n+        RecordIndex = data.GetStartRecordIndex();\n+        return TConclusionStatus::Success();\n+    }\n+\n+    virtual bool DoCheckSourceIntervalUsage(const ui64 sourceId, const ui32 indexStart, const ui32 recordsCount) const override {\n+        AFL_VERIFY(sourceId == SourceId);\n+        if (indexStart >= RecordIndex) {\n+            return true;\n+        }\n+        AFL_VERIFY(indexStart + recordsCount <= RecordIndex);\n+        return false;\n+    }\n+\n+public:\n+    TNotSortedSimpleScanCursor() = default;\n+\n+    TNotSortedSimpleScanCursor(const ui64 portionId, const ui32 recordIndex)\n+        : SourceId(portionId)\n+        , RecordIndex(recordIndex) {\n+    }\n+};\n+\n class TPlainScanCursor: public IScanCursor {\n private:\n     YDB_READONLY_DEF(std::shared_ptr<arrow::RecordBatch>, PrimaryKey);\n@@ -244,7 +309,7 @@ class TPlainScanCursor: public IScanCursor {\n         return TConclusionStatus::Success();\n     }\n \n-    virtual bool DoCheckEntityIsBorder(const std::shared_ptr<ICursorEntity>& /*entity*/, bool& usage) const override {\n+    virtual bool DoCheckEntityIsBorder(const ICursorEntity& /*entity*/, bool& usage) const override {\n         usage = true;\n         return true;\n     }\ndiff --git a/ydb/core/tx/columnshard/engines/predicate/range.cpp b/ydb/core/tx/columnshard/engines/predicate/range.cpp\nindex b00ed126d279..f7516e32d690 100644\n--- a/ydb/core/tx/columnshard/engines/predicate/range.cpp\n+++ b/ydb/core/tx/columnshard/engines/predicate/range.cpp\n@@ -34,8 +34,8 @@ std::set<std::string> TPKRangeFilter::GetColumnNames() const {\n     return result;\n }\n \n-NKikimr::NArrow::TColumnFilter TPKRangeFilter::BuildFilter(const arrow::Datum& data) const {\n-    NArrow::TColumnFilter result = PredicateTo.BuildFilter(data);\n+NArrow::TColumnFilter TPKRangeFilter::BuildFilter(const std::shared_ptr<NArrow::TGeneralContainer>& data) const {\n+    auto result = PredicateTo.BuildFilter(data);\n     return result.And(PredicateFrom.BuildFilter(data));\n }\n \ndiff --git a/ydb/core/tx/columnshard/engines/predicate/range.h b/ydb/core/tx/columnshard/engines/predicate/range.h\nindex fab63a7b9bca..91e7d58c4a77 100644\n--- a/ydb/core/tx/columnshard/engines/predicate/range.h\n+++ b/ydb/core/tx/columnshard/engines/predicate/range.h\n@@ -36,7 +36,7 @@ class TPKRangeFilter {\n \n     static TConclusion<TPKRangeFilter> Build(TPredicateContainer&& from, TPredicateContainer&& to);\n \n-    NArrow::TColumnFilter BuildFilter(const arrow::Datum& data) const;\n+    NArrow::TColumnFilter BuildFilter(const std::shared_ptr<NArrow::TGeneralContainer>& data) const;\n \n     bool IsUsed(const TPortionInfo& info) const;\n     bool CheckPoint(const NArrow::TReplaceKey& point) const;\ndiff --git a/ydb/core/tx/columnshard/engines/reader/abstract/abstract.h b/ydb/core/tx/columnshard/engines/reader/abstract/abstract.h\nindex 37ba57b89985..6968fd1be79f 100644\n--- a/ydb/core/tx/columnshard/engines/reader/abstract/abstract.h\n+++ b/ydb/core/tx/columnshard/engines/reader/abstract/abstract.h\n@@ -7,7 +7,7 @@ namespace NKikimr::NOlap::NReader {\n \n class TScanIteratorBase {\n protected:\n-    virtual void DoOnSentDataFromInterval(const ui32 /*intervalIdx*/) const {\n+    virtual void DoOnSentDataFromInterval(const TPartialSourceAddress& /*intervalAddress*/) {\n \n     }\n public:\n@@ -21,9 +21,9 @@ class TScanIteratorBase {\n \n     virtual const TReadStats& GetStats() const;\n \n-    void OnSentDataFromInterval(const std::optional<ui32> intervalIdx) const {\n-        if (intervalIdx) {\n-            DoOnSentDataFromInterval(*intervalIdx);\n+    void OnSentDataFromInterval(const std::optional<TPartialSourceAddress>& intervalAddress) {\n+        if (intervalAddress) {\n+            DoOnSentDataFromInterval(*intervalAddress);\n         }\n     }\n \ndiff --git a/ydb/core/tx/columnshard/engines/reader/abstract/constructor.cpp b/ydb/core/tx/columnshard/engines/reader/abstract/constructor.cpp\nindex aaaf940f8d2c..f28536de3046 100644\n--- a/ydb/core/tx/columnshard/engines/reader/abstract/constructor.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/abstract/constructor.cpp\n@@ -6,7 +6,7 @@\n \n namespace NKikimr::NOlap::NReader {\n \n-NKikimr::TConclusionStatus IScannerConstructor::ParseProgram(const TVersionedIndex* vIndex, const NKikimrSchemeOp::EOlapProgramType programType,\n+TConclusionStatus IScannerConstructor::ParseProgram(const TVersionedIndex* vIndex, const NKikimrSchemeOp::EOlapProgramType programType,\n     const TString& serializedProgram, TReadDescription& read, const NArrow::NSSA::IColumnResolver& columnResolver) const {\n     std::set<TString> namesChecker;\n     if (serializedProgram.empty()) {\n@@ -32,7 +32,7 @@ NKikimr::TConclusionStatus IScannerConstructor::ParseProgram(const TVersionedInd\n     }\n }\n \n-NKikimr::TConclusion<std::shared_ptr<TReadMetadataBase>> IScannerConstructor::BuildReadMetadata(\n+TConclusion<std::shared_ptr<TReadMetadataBase>> IScannerConstructor::BuildReadMetadata(\n     const NColumnShard::TColumnShard* self, const TReadDescription& read) const {\n     TConclusion<std::shared_ptr<TReadMetadataBase>> result = DoBuildReadMetadata(self, read);\n     if (result.IsFail()) {\n@@ -46,7 +46,7 @@ NKikimr::TConclusion<std::shared_ptr<TReadMetadataBase>> IScannerConstructor::Bu\n     }\n }\n \n-NKikimr::TConclusion<std::shared_ptr<NKikimr::NOlap::IScanCursor>> IScannerConstructor::BuildCursorFromProto(\n+TConclusion<std::shared_ptr<NKikimr::NOlap::IScanCursor>> IScannerConstructor::BuildCursorFromProto(\n     const NKikimrKqp::TEvKqpScanCursor& proto) const {\n     auto result = DoBuildCursor();\n     if (!result) {\ndiff --git a/ydb/core/tx/columnshard/engines/reader/abstract/constructor.h b/ydb/core/tx/columnshard/engines/reader/abstract/constructor.h\nindex 3ad1e86821a2..02e2e74b063e 100644\n--- a/ydb/core/tx/columnshard/engines/reader/abstract/constructor.h\n+++ b/ydb/core/tx/columnshard/engines/reader/abstract/constructor.h\n@@ -14,13 +14,13 @@ class TScannerConstructorContext {\n private:\n     YDB_READONLY(TSnapshot, Snapshot, TSnapshot::Zero());\n     YDB_READONLY(ui32, ItemsLimit, 0);\n-    YDB_READONLY(bool, Reverse, false);\n+    YDB_READONLY(TReadMetadataBase::ESorting, Sorting, TReadMetadataBase::ESorting::NONE);\n \n public:\n-    TScannerConstructorContext(const TSnapshot& snapshot, const ui32 itemsLimit, const bool reverse)\n+    TScannerConstructorContext(const TSnapshot& snapshot, const ui32 itemsLimit, const TReadMetadataBase::ESorting sorting)\n         : Snapshot(snapshot)\n         , ItemsLimit(itemsLimit)\n-        , Reverse(reverse) {\n+        , Sorting(sorting) {\n     }\n };\n \n@@ -28,7 +28,7 @@ class IScannerConstructor {\n protected:\n     const TSnapshot Snapshot;\n     const ui64 ItemsLimit;\n-    const bool IsReverse;\n+    const TReadMetadataBase::ESorting Sorting;\n     TConclusionStatus ParseProgram(const TVersionedIndex* vIndex, const NKikimrSchemeOp::EOlapProgramType programType,\n         const TString& serializedProgram, TReadDescription& read, const NArrow::NSSA::IColumnResolver& columnResolver) const;\n \n@@ -44,7 +44,7 @@ class IScannerConstructor {\n     IScannerConstructor(const TScannerConstructorContext& context)\n         : Snapshot(context.GetSnapshot())\n         , ItemsLimit(context.GetItemsLimit())\n-        , IsReverse(context.GetReverse()) {\n+        , Sorting(context.GetSorting()) {\n     }\n \n     TConclusion<std::shared_ptr<IScanCursor>> BuildCursorFromProto(const NKikimrKqp::TEvKqpScanCursor& proto) const;\ndiff --git a/ydb/core/tx/columnshard/engines/reader/abstract/read_context.h b/ydb/core/tx/columnshard/engines/reader/abstract/read_context.h\nindex 22bb1ce13920..c9a63b0bf53f 100644\n--- a/ydb/core/tx/columnshard/engines/reader/abstract/read_context.h\n+++ b/ydb/core/tx/columnshard/engines/reader/abstract/read_context.h\n@@ -13,6 +13,7 @@\n namespace NKikimr::NOlap::NReader {\n \n class TPartialReadResult;\n+class TPartialSourceAddress;\n \n class TComputeShardingPolicy {\n private:\n@@ -170,7 +171,7 @@ class IDataReader {\n         Started = true;\n         return DoStart();\n     }\n-    virtual void OnSentDataFromInterval(const ui32 intervalIdx) const = 0;\n+    virtual void OnSentDataFromInterval(const TPartialSourceAddress& address) = 0;\n \n     const TReadContext& GetContext() const {\n         return *Context;\ndiff --git a/ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.h b/ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.h\nindex ab0ded4d32bf..aac729f0a4aa 100644\n--- a/ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.h\n+++ b/ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.h\n@@ -1,9 +1,9 @@\n #pragma once\n+#include <ydb/core/tx/columnshard/common/path_id.h>\n #include <ydb/core/tx/columnshard/engines/column_engine.h>\n #include <ydb/core/tx/columnshard/engines/insert_table/insert_table.h>\n #include <ydb/core/tx/columnshard/engines/reader/common/description.h>\n #include <ydb/core/tx/columnshard/engines/scheme/versions/versioned_index.h>\n-#include <ydb/core/tx/columnshard/common/path_id.h>\n \n namespace NKikimr::NOlap {\n class TPortionInfo;\n@@ -33,11 +33,7 @@ class TDataStorageAccessor {\n // Holds all metadata that is needed to perform read/scan\n class TReadMetadataBase {\n public:\n-    enum class ESorting {\n-        NONE = 0 /* \"not_sorted\" */,\n-        ASC /* \"ascending\" */,\n-        DESC /* \"descending\" */,\n-    };\n+    using ESorting = ERequestSorting;\n \n private:\n     YDB_ACCESSOR_DEF(TString, ScanIdentifier);\n@@ -50,6 +46,7 @@ class TReadMetadataBase {\n     TSnapshot RequestSnapshot;\n     std::optional<TGranuleShardingInfo> RequestShardingInfo;\n     std::shared_ptr<IScanCursor> ScanCursor;\n+    const ui64 TabletId;\n     virtual void DoOnReadFinished(NColumnShard::TColumnShard& /*owner*/) const {\n     }\n     virtual void DoOnBeforeStartReading(NColumnShard::TColumnShard& /*owner*/) const {\n@@ -65,7 +62,11 @@ class TReadMetadataBase {\n public:\n     using TConstPtr = std::shared_ptr<const TReadMetadataBase>;\n \n-    void SetRequestedLimit(const ui64 value) { \n+    ui64 GetTabletId() const {\n+        return TabletId;\n+    }\n+\n+    void SetRequestedLimit(const ui64 value) {\n         AFL_VERIFY(!RequestedLimit);\n         if (value == 0 || value >= Max<i64>()) {\n             return;\n@@ -125,7 +126,6 @@ class TReadMetadataBase {\n \n     void SetPKRangesFilter(const std::shared_ptr<TPKRangesFilter>& value) {\n         AFL_VERIFY(value);\n-        Y_ABORT_UNLESS(IsSorted() && value->IsReverse() == IsDescSorted());\n         Y_ABORT_UNLESS(!PKRangesFilter);\n         PKRangesFilter = value;\n         if (ResultIndexSchema) {\n@@ -177,20 +177,23 @@ class TReadMetadataBase {\n     }\n \n     TReadMetadataBase(const std::shared_ptr<TVersionedIndex> index, const ESorting sorting, const TProgramContainer& ssaProgram,\n-        const std::shared_ptr<ISnapshotSchema>& schema, const TSnapshot& requestSnapshot, const std::shared_ptr<IScanCursor>& scanCursor)\n+        const std::shared_ptr<ISnapshotSchema>& schema, const TSnapshot& requestSnapshot, const std::shared_ptr<IScanCursor>& scanCursor,\n+        const ui64 tabletId)\n         : Sorting(sorting)\n         , Program(ssaProgram)\n         , IndexVersionsPointer(index)\n         , RequestSnapshot(requestSnapshot)\n         , ScanCursor(scanCursor)\n-        , ResultIndexSchema(schema)\n-    {\n+        , TabletId(tabletId)\n+        , ResultIndexSchema(schema) {\n+        AFL_VERIFY(!ScanCursor || !ScanCursor->GetTabletId() || (*ScanCursor->GetTabletId() == TabletId))(\"cursor\", ScanCursor->GetTabletId())(\n+                                                                \"tablet_id\", TabletId);\n     }\n     virtual ~TReadMetadataBase() = default;\n \n     virtual TString DebugString() const {\n         return TStringBuilder() << \" predicate{\" << (PKRangesFilter ? PKRangesFilter->DebugString() : \"no_initialized\") << \"}\"\n-            << \" \" << Sorting << \" sorted\";\n+                                << \" \" << Sorting << \" sorted\";\n     }\n \n     std::set<ui32> GetProcessingColumnIds() const {\ndiff --git a/ydb/core/tx/columnshard/engines/reader/actor/actor.cpp b/ydb/core/tx/columnshard/engines/reader/actor/actor.cpp\nindex f788ea433ab5..f847b6d177e0 100644\n--- a/ydb/core/tx/columnshard/engines/reader/actor/actor.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/actor/actor.cpp\n@@ -7,8 +7,8 @@\n #include <yql/essentials/core/issue/yql_issue.h>\r\n \r\n namespace NKikimr::NOlap::NReader {\r\n-constexpr TDuration SCAN_HARD_TIMEOUT = TDuration::Minutes(10);\r\n-constexpr TDuration SCAN_HARD_TIMEOUT_GAP = TDuration::Seconds(5);\r\n+constexpr TDuration SCAN_HARD_TIMEOUT = TDuration::Minutes(60);\r\n+constexpr TDuration COMPUTE_HARD_TIMEOUT = TDuration::Minutes(10);\r\n \r\n void TColumnShardScan::PassAway() {\r\n     Send(ResourceSubscribeActorId, new TEvents::TEvPoisonPill);\r\n@@ -34,7 +34,7 @@ TColumnShardScan::TColumnShardScan(const TActorId& columnShardActorId, const TAc\n     , DataFormat(dataFormat)\r\n     , TabletId(tabletId)\r\n     , ReadMetadataRange(readMetadataRange)\r\n-    , Timeout(timeout ? timeout + SCAN_HARD_TIMEOUT_GAP : SCAN_HARD_TIMEOUT)\r\n+    , Timeout(timeout ? timeout : COMPUTE_HARD_TIMEOUT)\r\n     , ScanCountersPool(scanCountersPool, TValidator::CheckNotNull(ReadMetadataRange)->GetProgram().GetGraphOptional())\r\n     , Stats(NTracing::TTraceClient::GetLocalClient(\"SHARD\", ::ToString(TabletId) /*, \"SCAN_TXID:\" + ::ToString(TxId)*/))\r\n     , ComputeShardingPolicy(computeShardingPolicy) {\r\n@@ -65,7 +65,7 @@ void TColumnShardScan::Bootstrap(const TActorContext& ctx) {\n         ScheduleWakeup(TMonotonic::Now() + Timeout / 5);\r\n \r\n         // propagate self actor id // TODO: FlagSubscribeOnSession ?\r\n-        Send(ScanComputeActorId, new NKqp::TEvKqpCompute::TEvScanInitActor(ScanId, ctx.SelfID, ScanGen, TabletId),\r\n+        Send(ScanComputeActorId, new NKqp::TEvKqpCompute::TEvScanInitActor(ScanId, ctx.SelfID, ScanGen, TabletId, true),\r\n             IEventHandle::FlagTrackDelivery);\r\n \r\n         Become(&TColumnShardScan::StateScan);\r\n@@ -93,6 +93,7 @@ void TColumnShardScan::HandleScan(NColumnShard::TEvPrivate::TEvTaskProcessedResu\n \r\n void TColumnShardScan::HandleScan(NKqp::TEvKqpCompute::TEvScanDataAck::TPtr& ev) {\r\n     auto g = Stats->MakeGuard(\"ack\");\r\n+\r\n     AFL_VERIFY(!AckReceivedInstant);\r\n     AckReceivedInstant = TMonotonic::Now();\r\n \r\n@@ -111,6 +112,12 @@ void TColumnShardScan::HandleScan(NKqp::TEvKqpCompute::TEvScanDataAck::TPtr& ev)\n     ContinueProcessing();\r\n }\r\n \r\n+void TColumnShardScan::HandleScan(NKqp::TEvKqpCompute::TEvScanPing::TPtr&) {\r\n+    if (!AckReceivedInstant) {\r\n+        LastResultInstant = TMonotonic::Now();\r\n+    }\r\n+}\r\n+\r\n void TColumnShardScan::HandleScan(NActors::TEvents::TEvPoison::TPtr& /*ev*/) noexcept {\r\n     PassAway();\r\n }\r\n@@ -165,10 +172,7 @@ void TColumnShardScan::HandleScan(TEvents::TEvWakeup::TPtr& /*ev*/) {\n                 << \" txId: \" << TxId << \" scanId: \" << ScanId << \" gen: \" << ScanGen << \" tablet: \" << TabletId);\r\n \r\n     CheckHanging(true);\r\n-    if (!!AckReceivedInstant && TMonotonic::Now() >= GetDeadline() + Timeout * 0.5) {\r\n-        SendScanError(\"ColumnShard scanner timeout: HAS_ACK=1\");\r\n-        Finish(NColumnShard::TScanCounters::EStatusFinish::Deadline);\r\n-    } else if (!AckReceivedInstant && TMonotonic::Now() >= GetDeadline()) {\r\n+    if (!AckReceivedInstant && TMonotonic::Now() >= GetComputeDeadline()) {\r\n         SendScanError(\"ColumnShard scanner timeout: HAS_ACK=0\");\r\n         Finish(NColumnShard::TScanCounters::EStatusFinish::Deadline);\r\n     } else {\r\n@@ -245,21 +249,23 @@ bool TColumnShardScan::ProduceResults() noexcept {\n         ACFL_DEBUG(\"stage\", \"data_format\")(\"batch_size\", NArrow::GetTableDataSize(Result->ArrowBatch))(\"num_rows\", numRows)(\r\n             \"batch_columns\", JoinSeq(\",\", batch->schema()->field_names()));\r\n     }\r\n-    if (CurrentLastReadKey) {\r\n+    if (CurrentLastReadKey && result.GetScanCursor()->GetPKCursor() && CurrentLastReadKey->GetPKCursor()) {\r\n         auto pNew = NArrow::TReplaceKey::FromBatch(result.GetScanCursor()->GetPKCursor(), 0);\r\n         auto pOld = NArrow::TReplaceKey::FromBatch(CurrentLastReadKey->GetPKCursor(), 0);\r\n-        if (!ReadMetadataRange->IsDescSorted()) {\r\n+        if (ReadMetadataRange->IsAscSorted()) {\r\n             AFL_VERIFY(!(pNew < pOld))(\"old\", pOld.DebugJson().GetStringRobust())(\"new\", pNew.DebugJson().GetStringRobust());\r\n-        } else {\r\n+        } else if (ReadMetadataRange->IsDescSorted()) {\r\n             AFL_VERIFY(!(pOld < pNew))(\"old\", pOld.DebugJson().GetStringRobust())(\"new\", pNew.DebugJson().GetStringRobust());\r\n         }\r\n     }\r\n     CurrentLastReadKey = result.GetScanCursor();\r\n \r\n-    Result->LastKey = ConvertLastKey(CurrentLastReadKey->GetPKCursor());\r\n+    if (CurrentLastReadKey->GetPKCursor()) {\r\n+        Result->LastKey = ConvertLastKey(CurrentLastReadKey->GetPKCursor());\r\n+    }\r\n     Result->LastCursorProto = CurrentLastReadKey->SerializeToProto();\r\n     SendResult(false, false);\r\n-    ScanIterator->OnSentDataFromInterval(result.GetNotFinishedIntervalIdx());\r\n+    ScanIterator->OnSentDataFromInterval(result.GetNotFinishedInterval());\r\n     ACFL_DEBUG(\"stage\", \"finished\")(\"iterator\", ScanIterator->DebugString());\r\n     return true;\r\n }\r\n@@ -353,8 +359,6 @@ bool TColumnShardScan::SendResult(bool pageFault, bool lastBatch) {\n     if (ScanIterator) {\r\n         Result->AvailablePacks = ScanIterator->GetAvailableResultsCount();\r\n     }\r\n-    TDuration totalElapsedTime = TDuration::Seconds(GetElapsedTicksAsSeconds());\r\n-    LastReportedElapsedTime = totalElapsedTime;\r\n \r\n     PageFaults = 0;\r\n \r\n@@ -425,11 +429,14 @@ void TColumnShardScan::ScheduleWakeup(const TMonotonic deadline) {\n     }\r\n }\r\n \r\n-TMonotonic TColumnShardScan::GetDeadline() const {\r\n-    AFL_VERIFY(StartInstant);\r\n-    if (LastResultInstant) {\r\n-        return *LastResultInstant + Timeout;\r\n-    }\r\n-    return *StartInstant + Timeout;\r\n+TMonotonic TColumnShardScan::GetScanDeadline() const {\r\n+    AFL_VERIFY(!!AckReceivedInstant);\r\n+    return *AckReceivedInstant + SCAN_HARD_TIMEOUT;\r\n }\r\n+\r\n+TMonotonic TColumnShardScan::GetComputeDeadline() const {\r\n+    AFL_VERIFY(!AckReceivedInstant);\r\n+    return (LastResultInstant ? *LastResultInstant : *StartInstant) + Timeout;\r\n+}\r\n+\r\n }   // namespace NKikimr::NOlap::NReader\r\ndiff --git a/ydb/core/tx/columnshard/engines/reader/actor/actor.h b/ydb/core/tx/columnshard/engines/reader/actor/actor.h\nindex de4f0a2502aa..09c5f4279aba 100644\n--- a/ydb/core/tx/columnshard/engines/reader/actor/actor.h\n+++ b/ydb/core/tx/columnshard/engines/reader/actor/actor.h\n@@ -46,6 +46,7 @@ class TColumnShardScan: public TActorBootstrapped<TColumnShardScan>,\n             \"TabletId\", TabletId)(\"ScanId\", ScanId)(\"TxId\", TxId)(\"ScanGen\", ScanGen)(\"task_identifier\", ReadMetadataRange->GetScanIdentifier()));\n         switch (ev->GetTypeRewrite()) {\n             hFunc(NKqp::TEvKqpCompute::TEvScanDataAck, HandleScan);\n+            hFunc(NKqp::TEvKqpCompute::TEvScanPing, HandleScan);\n             hFunc(NKqp::TEvKqp::TEvAbortExecution, HandleScan);\n             hFunc(NActors::TEvents::TEvPoison, HandleScan);\n             hFunc(TEvents::TEvUndelivered, HandleScan);\n@@ -60,6 +61,8 @@ class TColumnShardScan: public TActorBootstrapped<TColumnShardScan>,\n \n     void HandleScan(NKqp::TEvKqpCompute::TEvScanDataAck::TPtr& ev);\n \n+    void HandleScan(NKqp::TEvKqpCompute::TEvScanPing::TPtr& ev);\n+\n     // Returns true if it was able to produce new batch\n     bool ProduceResults() noexcept;\n \n@@ -109,7 +112,9 @@ class TColumnShardScan: public TActorBootstrapped<TColumnShardScan>,\n \n     void ScheduleWakeup(const TMonotonic deadline);\n \n-    TMonotonic GetDeadline() const;\n+    TMonotonic GetScanDeadline() const;\n+\n+    TMonotonic GetComputeDeadline() const;\n \n private:\n     const TActorId ColumnShardActorId;\n@@ -186,7 +191,6 @@ class TColumnShardScan: public TActorBootstrapped<TColumnShardScan>,\n     ui64 PacksSum = 0;\n     ui64 Bytes = 0;\n     ui32 PageFaults = 0;\n-    TDuration LastReportedElapsedTime;\n };\n \n }   // namespace NKikimr::NOlap::NReader\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common/conveyor_task.cpp b/ydb/core/tx/columnshard/engines/reader/common/conveyor_task.cpp\nindex ac778b00a6c7..1bcd853bec32 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common/conveyor_task.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/common/conveyor_task.cpp\n@@ -4,7 +4,7 @@\n \n namespace NKikimr::NOlap::NReader {\n \n-NKikimr::TConclusionStatus IDataTasksProcessor::ITask::DoExecute(const std::shared_ptr<NConveyor::ITask>& taskPtr) {\n+void IDataTasksProcessor::ITask::DoExecute(const std::shared_ptr<NConveyor::ITask>& taskPtr) {\n     auto result = DoExecuteImpl();\n     if (result.IsFail()) {\n         NActors::TActivationContext::AsActorContext().Send(OwnerId, new NColumnShard::TEvPrivate::TEvTaskProcessedResult(result));\n@@ -12,7 +12,6 @@ NKikimr::TConclusionStatus IDataTasksProcessor::ITask::DoExecute(const std::shar\n         NActors::TActivationContext::AsActorContext().Send(\n             OwnerId, new NColumnShard::TEvPrivate::TEvTaskProcessedResult(static_pointer_cast<IDataTasksProcessor::ITask>(taskPtr)));\n     }\n-    return result;\n }\n \n void IDataTasksProcessor::ITask::DoOnCannotExecute(const TString& reason) {\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common/conveyor_task.h b/ydb/core/tx/columnshard/engines/reader/common/conveyor_task.h\nindex 0342577c2554..504bb41b6488 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common/conveyor_task.h\n+++ b/ydb/core/tx/columnshard/engines/reader/common/conveyor_task.h\n@@ -28,7 +28,7 @@ class IDataTasksProcessor {\n         virtual TConclusionStatus DoExecuteImpl() = 0;\n \n     protected:\n-        virtual TConclusionStatus DoExecute(const std::shared_ptr<NConveyor::ITask>& taskPtr) override final;\n+        virtual void DoExecute(const std::shared_ptr<NConveyor::ITask>& taskPtr) override final;\n         virtual void DoOnCannotExecute(const TString& reason) override;\n \n     public:\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common/description.h b/ydb/core/tx/columnshard/engines/reader/common/description.h\nindex a08291316ec8..0572c4e8fc40 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common/description.h\n+++ b/ydb/core/tx/columnshard/engines/reader/common/description.h\n@@ -1,12 +1,18 @@\n #pragma once\n-#include <ydb/core/tx/columnshard/common/snapshot.h>\n #include <ydb/core/tx/columnshard/common/path_id.h>\n+#include <ydb/core/tx/columnshard/common/snapshot.h>\n #include <ydb/core/tx/columnshard/engines/predicate/filter.h>\n #include <ydb/core/tx/program/program.h>\n \n #include <ydb/library/yql/dq/actors/protos/dq_stats.pb.h>\n namespace NKikimr::NOlap::NReader {\n \n+enum class ERequestSorting {\n+    NONE = 0 /* \"not_sorted\" */,\n+    ASC /* \"ascending\" */,\n+    DESC /* \"descending\" */,\n+};\n+\n // Describes read/scan request\n struct TReadDescription {\n private:\n@@ -14,6 +20,8 @@ struct TReadDescription {\n     TProgramContainer Program;\n     std::shared_ptr<IScanCursor> ScanCursor;\n     YDB_ACCESSOR_DEF(TString, ScanIdentifier);\n+    YDB_ACCESSOR(ERequestSorting, Sorting, ERequestSorting::NONE);\n+    YDB_READONLY(ui64, TabletId, 0);\n \n public:\n     // Table\n@@ -40,9 +48,11 @@ struct TReadDescription {\n         ScanCursor = cursor;\n     }\n \n-    TReadDescription(const TSnapshot& snapshot, const bool isReverse)\n+    TReadDescription(const ui64 tabletId, const TSnapshot& snapshot, const ERequestSorting sorting)\n         : Snapshot(snapshot)\n-        , PKRangesFilter(std::make_shared<NOlap::TPKRangesFilter>(isReverse)) {\n+        , Sorting(sorting)\n+        , TabletId(tabletId)\n+        , PKRangesFilter(std::make_shared<NOlap::TPKRangesFilter>()) {\n     }\n \n     void SetProgram(TProgramContainer&& value) {\n@@ -58,4 +68,4 @@ struct TReadDescription {\n     }\n };\n \n-}\n+}   // namespace NKikimr::NOlap::NReader\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common/result.cpp b/ydb/core/tx/columnshard/engines/reader/common/result.cpp\nindex 92f55f3dfc77..38805a998232 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common/result.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/common/result.cpp\n@@ -55,12 +55,12 @@ std::vector<std::shared_ptr<TPartialReadResult>> TPartialReadResult::SplitResult\n TPartialReadResult::TPartialReadResult(const std::vector<std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>>& resourceGuards,\n     const std::shared_ptr<NGroupedMemoryManager::TGroupGuard>& gGuard, const NArrow::TShardedRecordBatch& batch,\n     const std::shared_ptr<IScanCursor>& scanCursor, const std::shared_ptr<TReadContext>& context,\n-    const std::optional<ui32> notFinishedIntervalIdx)\n+    const std::optional<TPartialSourceAddress> notFinishedInterval)\n     : ResourceGuards(resourceGuards)\n     , GroupGuard(gGuard)\n     , ResultBatch(batch)\n     , ScanCursor(scanCursor)\n-    , NotFinishedIntervalIdx(notFinishedIntervalIdx)\n+    , NotFinishedInterval(notFinishedInterval)\n     , Guard(TValidator::CheckNotNull(context)->GetCounters().GetResultsForReplyGuard()) {\n     Y_ABORT_UNLESS(ResultBatch.GetRecordsCount());\n     Y_ABORT_UNLESS(ScanCursor);\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common/result.h b/ydb/core/tx/columnshard/engines/reader/common/result.h\nindex f4e7d7d4b1ee..6fff2c86083c 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common/result.h\n+++ b/ydb/core/tx/columnshard/engines/reader/common/result.h\n@@ -12,6 +12,22 @@ namespace NKikimr::NOlap::NReader {\n \n class TReadContext;\n \n+class TPartialSourceAddress {\n+private:\n+    YDB_READONLY(ui32, SourceId, 0);\n+    YDB_READONLY(ui32, SourceIdx, 0);\n+    YDB_READONLY(ui32, SyncPointIndex, 0);\n+\n+public:\n+    TPartialSourceAddress(const ui32 sourceId, const ui32 sourceIdx, const ui32 syncPointIndex)\n+        : SourceId(sourceId)\n+        , SourceIdx(sourceIdx)\n+        , SyncPointIndex(syncPointIndex)\n+    {\n+    \n+    }\n+};\n+\n // Represents a batch of rows produced by ASC or DESC scan with applied filters and partial aggregation\n class TPartialReadResult: public TNonCopyable {\n private:\n@@ -22,7 +38,7 @@ class TPartialReadResult: public TNonCopyable {\n     // This 1-row batch contains the last key that was read while producing the ResultBatch.\n     // NOTE: it might be different from the Key of last row in ResulBatch in case of filtering/aggregation/limit\n     std::shared_ptr<IScanCursor> ScanCursor;\n-    YDB_READONLY_DEF(std::optional<ui32>, NotFinishedIntervalIdx);\n+    YDB_READONLY_DEF(std::optional<TPartialSourceAddress>, NotFinishedInterval);\n     const NColumnShard::TCounterGuard Guard;\n \n public:\n@@ -61,11 +77,11 @@ class TPartialReadResult: public TNonCopyable {\n     explicit TPartialReadResult(const std::vector<std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>>& resourceGuards,\n         const std::shared_ptr<NGroupedMemoryManager::TGroupGuard>& gGuard, const NArrow::TShardedRecordBatch& batch,\n         const std::shared_ptr<IScanCursor>& scanCursor, const std::shared_ptr<TReadContext>& context,\n-        const std::optional<ui32> notFinishedIntervalIdx);\n+        const std::optional<TPartialSourceAddress> notFinishedInterval);\n \n     explicit TPartialReadResult(const NArrow::TShardedRecordBatch& batch, const std::shared_ptr<IScanCursor>& scanCursor,\n-        const std::shared_ptr<TReadContext>& context, const std::optional<ui32> notFinishedIntervalIdx)\n-        : TPartialReadResult({}, nullptr, batch, scanCursor, context, notFinishedIntervalIdx) {\n+        const std::shared_ptr<TReadContext>& context, const std::optional<TPartialSourceAddress> notFinishedInterval)\n+        : TPartialReadResult({}, nullptr, batch, scanCursor, context, notFinishedInterval) {\n     }\n };\n \ndiff --git a/ydb/core/tx/columnshard/engines/reader/common/ya.make b/ydb/core/tx/columnshard/engines/reader/common/ya.make\nindex 8c7beb01bd69..d2b891818ea7 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common/ya.make\n+++ b/ydb/core/tx/columnshard/engines/reader/common/ya.make\n@@ -13,4 +13,6 @@ PEERDIR(\n     ydb/core/formats/arrow/reader\n )\n \n+GENERATE_ENUM_SERIALIZATION(description.h)\n+\n END()\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/constructor/read_metadata.cpp b/ydb/core/tx/columnshard/engines/reader/common_reader/constructor/read_metadata.cpp\nindex e3cf7231287a..a42de044970c 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common_reader/constructor/read_metadata.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/constructor/read_metadata.cpp\n@@ -43,8 +43,8 @@ TConclusionStatus TReadMetadata::Init(\n }\n \n TReadMetadata::TReadMetadata(const std::shared_ptr<TVersionedIndex>& schemaIndex, const TReadDescription& read)\n-    : TBase(schemaIndex, read.PKRangesFilter->IsReverse() ? TReadMetadataBase::ESorting::DESC : TReadMetadataBase::ESorting::ASC,\n-          read.GetProgram(), schemaIndex->GetSchemaVerified(read.GetSnapshot()), read.GetSnapshot(), read.GetScanCursorOptional())\n+    : TBase(schemaIndex, read.GetSorting(), read.GetProgram(), schemaIndex->GetSchemaVerified(read.GetSnapshot()), read.GetSnapshot(),\n+          read.GetScanCursorOptional(), read.GetTabletId())\n     , PathId(read.PathId)\n     , ReadStats(std::make_shared<TReadStats>()) {\n }\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/columns_set.h b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/columns_set.h\nindex a21652522430..4a14d95727f2 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/columns_set.h\n+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/columns_set.h\n@@ -14,13 +14,6 @@ enum class EMemType {\n     RawSequential\n };\n \n-enum class EStageFeaturesIndexes {\n-    Accessors = 0,\n-    Filter = 1,\n-    Fetching = 2,\n-    Merge = 3\n-};\n-\n class TIndexesSet {\n private:\n     YDB_READONLY_DEF(std::vector<ui32>, IndexIds);\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/constructor.cpp b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/constructor.cpp\nindex 800ef6841e73..6d4027801631 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/constructor.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/constructor.cpp\n@@ -10,7 +10,7 @@ void TBlobsFetcherTask::DoOnDataReady(const std::shared_ptr<NResourceBroker::NSu\n     FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, Source->AddEvent(\"fbf\"));\n     Source->MutableStageData().AddBlobs(Source->DecodeBlobAddresses(ExtractBlobsData()));\n     AFL_VERIFY(Step.Next());\n-    auto task = std::make_shared<TStepAction>(Source, std::move(Step), Context->GetCommonContext()->GetScanActorId());\n+    auto task = std::make_shared<TStepAction>(Source, std::move(Step), Context->GetCommonContext()->GetScanActorId(), false);\n     NConveyor::TScanServiceOperator::SendTaskToExecute(task, Context->GetCommonContext()->GetConveyorProcessId());\n }\n \n@@ -54,7 +54,7 @@ void TColumnsFetcherTask::DoOnDataReady(const std::shared_ptr<NResourceBroker::N\n         for (auto&& i : DataFetchers) {\n             Source->MutableStageData().AddFetcher(i.second);\n         }\n-        auto task = std::make_shared<TStepAction>(Source, std::move(Cursor), Source->GetContext()->GetCommonContext()->GetScanActorId());\n+        auto task = std::make_shared<TStepAction>(Source, std::move(Cursor), Source->GetContext()->GetCommonContext()->GetScanActorId(), false);\n         NConveyor::TScanServiceOperator::SendTaskToExecute(task, Source->GetContext()->GetCommonContext()->GetConveyorProcessId());\n     } else {\n         FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, Source->AddEvent(\"cf_next\"));\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/default_fetching.h b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/default_fetching.h\nindex ab886429a77e..4a0cc71cb5f3 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/default_fetching.h\n+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/default_fetching.h\n@@ -6,6 +6,15 @@ namespace NKikimr::NOlap::NReader::NCommon {\n class TDefaultFetchLogic: public IKernelFetchLogic {\n private:\n     using TBase = IKernelFetchLogic;\n+    std::optional<bool> IsEmptyChunks;\n+\n+    std::shared_ptr<NArrow::NAccessor::TColumnLoader> GetColumnLoader(const std::shared_ptr<NCommon::IDataSource>& source) const {\n+        if (auto loader = source->GetSourceSchema()->GetColumnLoaderOptional(GetEntityId())) {\n+            return loader;\n+        }\n+        AFL_VERIFY(IsEmptyChunks && *IsEmptyChunks);\n+        return source->GetContext()->GetReadMetadata()->GetResultSchema()->GetColumnLoaderVerified(GetEntityId());\n+    }\n \n     class TChunkRestoreInfo {\n     private:\n@@ -36,6 +45,7 @@ class TDefaultFetchLogic: public IKernelFetchLogic {\n \n         void SetBlobData(const TString& data) {\n             AFL_VERIFY(!Data);\n+            BlobRange.reset();\n             Data.emplace(data);\n         }\n     };\n@@ -49,8 +59,7 @@ class TDefaultFetchLogic: public IKernelFetchLogic {\n             chunks.emplace_back(i.ExtractDataVerified());\n         }\n \n-        TPortionDataAccessor::TPreparedColumn column(\n-            std::move(chunks), context.GetSource()->GetSourceSchema()->GetColumnLoaderVerified(GetEntityId()));\n+        TPortionDataAccessor::TPreparedColumn column(std::move(chunks), GetColumnLoader(context.GetSource()));\n         context.GetAccessors().AddVerified(GetEntityId(), column.AssembleAccessor().DetachResult(), true);\n     }\n \n@@ -70,9 +79,10 @@ class TDefaultFetchLogic: public IKernelFetchLogic {\n     virtual void DoStart(TReadActionsCollection& nextRead, TFetchingResultContext& context) override {\n         auto source = context.GetSource();\n         auto columnChunks = source->GetStageData().GetPortionAccessor().GetColumnChunksPointers(GetEntityId());\n+        IsEmptyChunks.emplace(columnChunks.empty());\n         if (columnChunks.empty()) {\n-            ColumnChunks.emplace_back(source->GetRecordsCount(), TPortionDataAccessor::TAssembleBlobInfo(source->GetRecordsCount(),\n-                                                                     source->GetSourceSchema()->GetExternalDefaultValueVerified(GetEntityId())));\n+            ColumnChunks.emplace_back(source->GetRecordsCount(),\n+                TPortionDataAccessor::TAssembleBlobInfo(source->GetRecordsCount(), GetColumnLoader(context.GetSource())->GetDefaultValue()));\n             return;\n         }\n         StorageId = source->GetColumnStorageId(GetEntityId());\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.cpp b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.cpp\nindex 51bfe780e313..3559e599b051 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.cpp\n@@ -48,25 +48,28 @@ bool TAllocateMemoryStep::TFetchingStepAllocation::DoOnAllocated(std::shared_ptr\n         guard->Release();\n         return false;\n     }\n-    if (StageIndex == EStageFeaturesIndexes::Accessors) {\n+    if (StageIndex == NArrow::NSSA::IMemoryCalculationPolicy::EStage::Accessors) {\n         data->MutableStageData().SetAccessorsGuard(std::move(guard));\n     } else {\n         data->RegisterAllocationGuard(std::move(guard));\n     }\n-    Step.Next();\n+    if (NeedNextStep) {\n+        Step.Next();\n+    }\n     FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, data->AddEvent(\"fmalloc\"));\n-    auto task = std::make_shared<TStepAction>(data, std::move(Step), data->GetContext()->GetCommonContext()->GetScanActorId());\n+    auto task = std::make_shared<TStepAction>(data, std::move(Step), data->GetContext()->GetCommonContext()->GetScanActorId(), false);\n     NConveyor::TScanServiceOperator::SendTaskToExecute(task, data->GetContext()->GetCommonContext()->GetConveyorProcessId());\n     return true;\n }\n \n-TAllocateMemoryStep::TFetchingStepAllocation::TFetchingStepAllocation(\n-    const std::shared_ptr<IDataSource>& source, const ui64 mem, const TFetchingScriptCursor& step, const EStageFeaturesIndexes stageIndex)\n+TAllocateMemoryStep::TFetchingStepAllocation::TFetchingStepAllocation(const std::shared_ptr<IDataSource>& source, const ui64 mem,\n+    const TFetchingScriptCursor& step, const NArrow::NSSA::IMemoryCalculationPolicy::EStage stageIndex, const bool needNextStep)\n     : TBase(mem)\n     , Source(source)\n     , Step(step)\n     , TasksGuard(source->GetContext()->GetCommonContext()->GetCounters().GetResourcesAllocationTasksGuard())\n-    , StageIndex(stageIndex) {\n+    , StageIndex(stageIndex)\n+    , NeedNextStep(needNextStep) {\n }\n \n void TAllocateMemoryStep::TFetchingStepAllocation::DoOnAllocationImpossible(const TString& errorMessage) {\n@@ -75,6 +78,8 @@ void TAllocateMemoryStep::TFetchingStepAllocation::DoOnAllocationImpossible(cons\n         FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, sourcePtr->AddEvent(\"fail_malloc\"));\n         sourcePtr->GetContext()->GetCommonContext()->AbortWithError(\n             \"cannot allocate memory for step \" + Step.GetName() + \": '\" + errorMessage + \"'\");\n+    } else {\n+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"allocation_impossible\")(\"error\", errorMessage);\n     }\n }\n \ndiff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.h b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.h\nindex 0123678d75c9..3b8abd40ea48 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.h\n+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.h\n@@ -21,25 +21,10 @@ class TAllocateMemoryStep: public IFetchingStep {\n     };\n     std::vector<TColumnsPack> Packs;\n     THashMap<ui32, THashSet<EMemType>> Control;\n-    const EStageFeaturesIndexes StageIndex;\n+    const NArrow::NSSA::IMemoryCalculationPolicy::EStage StageIndex;\n     const std::optional<ui64> PredefinedSize;\n \n protected:\n-    class TFetchingStepAllocation: public NGroupedMemoryManager::IAllocation {\n-    private:\n-        using TBase = NGroupedMemoryManager::IAllocation;\n-        std::weak_ptr<IDataSource> Source;\n-        TFetchingScriptCursor Step;\n-        NColumnShard::TCounterGuard TasksGuard;\n-        const EStageFeaturesIndexes StageIndex;\n-        virtual bool DoOnAllocated(std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>&& guard,\n-            const std::shared_ptr<NGroupedMemoryManager::IAllocation>& allocation) override;\n-        virtual void DoOnAllocationImpossible(const TString& errorMessage) override;\n-\n-    public:\n-        TFetchingStepAllocation(const std::shared_ptr<IDataSource>& source, const ui64 mem, const TFetchingScriptCursor& step,\n-            const EStageFeaturesIndexes stageIndex);\n-    };\n     virtual TConclusion<bool> DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step) const override;\n     virtual ui64 GetProcessingDataSize(const std::shared_ptr<IDataSource>& source) const override;\n     virtual TString DoDebugString() const override {\n@@ -53,6 +38,22 @@ class TAllocateMemoryStep: public IFetchingStep {\n     }\n \n public:\n+    class TFetchingStepAllocation: public NGroupedMemoryManager::IAllocation {\n+    private:\n+        using TBase = NGroupedMemoryManager::IAllocation;\n+        std::weak_ptr<IDataSource> Source;\n+        TFetchingScriptCursor Step;\n+        NColumnShard::TCounterGuard TasksGuard;\n+        const NArrow::NSSA::IMemoryCalculationPolicy::EStage StageIndex;\n+        const bool NeedNextStep;\n+        virtual bool DoOnAllocated(std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>&& guard,\n+            const std::shared_ptr<NGroupedMemoryManager::IAllocation>& allocation) override;\n+        virtual void DoOnAllocationImpossible(const TString& errorMessage) override;\n+\n+    public:\n+        TFetchingStepAllocation(const std::shared_ptr<IDataSource>& source, const ui64 mem, const TFetchingScriptCursor& step,\n+            const NArrow::NSSA::IMemoryCalculationPolicy::EStage stageIndex, const bool needNextStep = true);\n+    };\n     void AddAllocation(const TColumnsSetIds& ids, const EMemType memType) {\n         if (!ids.GetColumnsCount()) {\n             return;\n@@ -62,17 +63,17 @@ class TAllocateMemoryStep: public IFetchingStep {\n         }\n         Packs.emplace_back(ids, memType);\n     }\n-    EStageFeaturesIndexes GetStage() const {\n+    NArrow::NSSA::IMemoryCalculationPolicy::EStage GetStage() const {\n         return StageIndex;\n     }\n \n-    TAllocateMemoryStep(const TColumnsSetIds& columns, const EMemType memType, const EStageFeaturesIndexes stageIndex)\n+    TAllocateMemoryStep(const TColumnsSetIds& columns, const EMemType memType, const NArrow::NSSA::IMemoryCalculationPolicy::EStage stageIndex)\n         : TBase(\"ALLOCATE_MEMORY::\" + ::ToString(stageIndex))\n         , StageIndex(stageIndex) {\n         AddAllocation(columns, memType);\n     }\n \n-    TAllocateMemoryStep(const ui64 memSize, const EStageFeaturesIndexes stageIndex)\n+    TAllocateMemoryStep(const ui64 memSize, const NArrow::NSSA::IMemoryCalculationPolicy::EStage stageIndex)\n         : TBase(\"ALLOCATE_MEMORY::\" + ::ToString(stageIndex))\n         , StageIndex(stageIndex)\n         , PredefinedSize(memSize) {\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetched_data.h b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetched_data.h\nindex 6551b39c271d..e80f376d7913 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetched_data.h\n+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetched_data.h\n@@ -149,8 +149,8 @@ class TFetchedData {\n         }\n     }\n \n-    bool IsEmptyFiltered() const {\n-        return Table->IsEmptyFiltered();\n+    bool IsEmptyWithData() const {\n+        return Table->HasDataAndResultIsEmpty();\n     }\n \n     void Clear() {\n@@ -177,12 +177,35 @@ class TFetchedData {\n     }\n };\n \n+class TSourceChunkToReply {\n+private:\n+    YDB_READONLY(ui32, StartIndex, 0);\n+    YDB_READONLY(ui32, RecordsCount, 0);\n+    std::shared_ptr<arrow::Table> Table;\n+\n+public:\n+    const std::shared_ptr<arrow::Table>& GetTable() const {\n+        AFL_VERIFY(Table);\n+        return Table;\n+    }\n+\n+    bool HasData() const {\n+        return !!Table && Table->num_rows();\n+    }\n+\n+    TSourceChunkToReply(const ui32 startIndex, const ui32 recordsCount, const std::shared_ptr<arrow::Table>& table)\n+        : StartIndex(startIndex)\n+        , RecordsCount(recordsCount)\n+        , Table(table) {\n+    }\n+};\n+\n class TFetchedResult {\n private:\n     YDB_READONLY_DEF(std::shared_ptr<NArrow::TGeneralContainer>, Batch);\n     YDB_READONLY_DEF(std::shared_ptr<NArrow::TColumnFilter>, NotAppliedFilter);\n     std::optional<std::deque<TPortionDataAccessor::TReadPage>> PagesToResult;\n-    std::optional<std::shared_ptr<arrow::Table>> ChunkToReply;\n+    std::optional<TSourceChunkToReply> ChunkToReply;\n \n     TFetchedResult() = default;\n \n@@ -225,7 +248,7 @@ class TFetchedResult {\n         AFL_VERIFY(page.GetIndexStart() == indexStart)(\"real\", page.GetIndexStart())(\"expected\", indexStart);\n         AFL_VERIFY(page.GetRecordsCount() == recordsCount)(\"real\", page.GetRecordsCount())(\"expected\", recordsCount);\n         AFL_VERIFY(!ChunkToReply);\n-        ChunkToReply = std::move(table);\n+        ChunkToReply = TSourceChunkToReply(indexStart, recordsCount, std::move(table));\n     }\n \n     bool IsFinished() const {\n@@ -236,7 +259,7 @@ class TFetchedResult {\n         return !!ChunkToReply;\n     }\n \n-    std::shared_ptr<arrow::Table> ExtractResultChunk() {\n+    std::optional<TSourceChunkToReply> ExtractResultChunk() {\n         AFL_VERIFY(!!ChunkToReply);\n         auto result = std::move(*ChunkToReply);\n         ChunkToReply.reset();\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetching.cpp b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetching.cpp\nindex dfb83d035a4c..b9a686530b9b 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetching.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetching.cpp\n@@ -15,6 +15,7 @@ namespace NKikimr::NOlap::NReader::NCommon {\n bool TStepAction::DoApply(IDataReader& owner) const {\n     if (FinishedFlag) {\n         AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"apply\");\n+        Source->StartSyncSection();\n         Source->OnSourceFetchingFinishedSafe(owner, Source);\n     }\n     return true;\n@@ -26,7 +27,7 @@ TConclusionStatus TStepAction::DoExecuteImpl() {\n         return TConclusionStatus::Success();\n     }\n     auto executeResult = Cursor.Execute(Source);\n-    if (!executeResult) {\n+    if (executeResult.IsFail()) {\n         return executeResult;\n     }\n     if (*executeResult) {\n@@ -35,11 +36,17 @@ TConclusionStatus TStepAction::DoExecuteImpl() {\n     return TConclusionStatus::Success();\n }\n \n-TStepAction::TStepAction(const std::shared_ptr<IDataSource>& source, TFetchingScriptCursor&& cursor, const NActors::TActorId& ownerActorId)\n+TStepAction::TStepAction(const std::shared_ptr<IDataSource>& source, TFetchingScriptCursor&& cursor, const NActors::TActorId& ownerActorId,\n+    const bool changeSyncSection)\n     : TBase(ownerActorId)\n     , Source(source)\n     , Cursor(std::move(cursor))\n     , CountersGuard(Source->GetContext()->GetCommonContext()->GetCounters().GetAssembleTasksGuard()) {\n+    if (changeSyncSection) {\n+        Source->StartAsyncSection();\n+    } else {\n+        Source->CheckAsyncSection();\n+    }\n }\n \n TConclusion<bool> TFetchingScriptCursor::Execute(const std::shared_ptr<IDataSource>& source) {\n@@ -48,14 +55,16 @@ TConclusion<bool> TFetchingScriptCursor::Execute(const std::shared_ptr<IDataSour\n     Script->OnExecute();\n     AFL_VERIFY(!Script->IsFinished(CurrentStepIdx));\n     while (!Script->IsFinished(CurrentStepIdx)) {\n-        if (source->HasStageData() && source->GetStageData().IsEmptyFiltered()) {\n+        if (source->HasStageData() && source->GetStageData().IsEmptyWithData()) {\n             source->OnEmptyStageData(source);\n             break;\n+        } else if (source->HasStageResult() && source->GetStageResult().IsEmpty()) {\n+            break;\n         }\n         auto step = Script->GetStep(CurrentStepIdx);\n         TMemoryProfileGuard mGuard(\"SCAN_PROFILE::FETCHING::\" + step->GetName() + \"::\" + Script->GetBranchName(),\n             IS_DEBUG_LOG_ENABLED(NKikimrServices::TX_COLUMNSHARD_SCAN_MEMORY));\n-        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"scan_step\", step->DebugString())(\"scan_step_idx\", CurrentStepIdx);\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"scan_step\", step->DebugString())(\"scan_step_idx\", CurrentStepIdx)(\"source_id\", source->GetSourceId());\n \n         const TMonotonic startInstant = TMonotonic::Now();\n         const TConclusion<bool> resultStep = step->ExecuteInplace(source, *this);\n@@ -105,7 +114,8 @@ TString TFetchingScript::ProfileDebugString() const {\n     return sb;\n }\n \n-void TFetchingScriptBuilder::AddAllocation(const std::set<ui32>& entityIds, const EStageFeaturesIndexes stage, const EMemType mType) {\n+void TFetchingScriptBuilder::AddAllocation(\n+    const std::set<ui32>& entityIds, const NArrow::NSSA::IMemoryCalculationPolicy::EStage stage, const EMemType mType) {\n     if (Steps.size() == 0) {\n         AddStep(std::make_shared<TAllocateMemoryStep>(entityIds, mType, stage));\n     } else {\n@@ -148,7 +158,7 @@ TFetchingScriptBuilder::TFetchingScriptBuilder(const TSpecialReadContext& contex\n     : TFetchingScriptBuilder(context.GetReadMetadata()->GetResultSchema(), context.GetMergeColumns()) {\n }\n \n-void TFetchingScriptBuilder::AddFetchingStep(const TColumnsSetIds& columns, const EStageFeaturesIndexes stage) {\n+void TFetchingScriptBuilder::AddFetchingStep(const TColumnsSetIds& columns, const NArrow::NSSA::IMemoryCalculationPolicy::EStage stage) {\n     auto actualColumns = columns - AddedFetchingColumns;\n     AddedFetchingColumns += columns;\n     if (actualColumns.IsEmpty()) {\n@@ -166,7 +176,7 @@ void TFetchingScriptBuilder::AddFetchingStep(const TColumnsSetIds& columns, cons\n }\n \n void TFetchingScriptBuilder::AddAssembleStep(\n-    const TColumnsSetIds& columns, const TString& purposeId, const EStageFeaturesIndexes stage, const bool sequential) {\n+    const TColumnsSetIds& columns, const TString& purposeId, const NArrow::NSSA::IMemoryCalculationPolicy::EStage stage, const bool sequential) {\n     auto actualColumns = columns - AddedAssembleColumns;\n     AddedAssembleColumns += columns;\n     if (actualColumns.IsEmpty()) {\n@@ -182,7 +192,7 @@ void TFetchingScriptBuilder::AddAssembleStep(\n             *actualSet = *actualSet - *cross;\n         }\n         if (!actualSet->IsEmpty()) {\n-            AddAllocation(notSequentialColumnIds, stage, EMemType::RawSequential);\n+            AddAllocation(actualSet->GetColumnIds(), stage, EMemType::RawSequential);\n             AddStep(std::make_shared<TOptionalAssemblerStep>(actualSet, purposeId));\n         }\n     } else {\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetching.h b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetching.h\nindex 952c3cda3a3f..e8ca12f666d9 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetching.h\n+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetching.h\n@@ -1,7 +1,7 @@\n #pragma once\n #include \"columns_set.h\"\n \n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n #include <ydb/core/tx/columnshard/counters/scan.h>\n #include <ydb/core/tx/columnshard/engines/reader/common/conveyor_task.h>\n \n@@ -253,7 +253,7 @@ class TFetchingScriptBuilder {\n     }\n \n private:\n-    void AddAllocation(const std::set<ui32>& entityIds, const EStageFeaturesIndexes stage, const EMemType mType);\n+    void AddAllocation(const std::set<ui32>& entityIds, const NArrow::NSSA::IMemoryCalculationPolicy::EStage stage, const EMemType mType);\n \n     template <class T, typename... Args>\n     std::shared_ptr<T> InsertStep(const ui32 index, Args... args) {\n@@ -275,8 +275,9 @@ class TFetchingScriptBuilder {\n         Steps.emplace_back(step);\n     }\n \n-    void AddFetchingStep(const TColumnsSetIds& columns, const EStageFeaturesIndexes stage);\n-    void AddAssembleStep(const TColumnsSetIds& columns, const TString& purposeId, const EStageFeaturesIndexes stage, const bool sequential);\n+    void AddFetchingStep(const TColumnsSetIds& columns, const NArrow::NSSA::IMemoryCalculationPolicy::EStage stage);\n+    void AddAssembleStep(const TColumnsSetIds& columns, const TString& purposeId, const NArrow::NSSA::IMemoryCalculationPolicy::EStage stage,\n+        const bool sequential);\n \n     static TFetchingScriptBuilder MakeForTests(ISnapshotSchema::TPtr schema, std::shared_ptr<TColumnsSetIds> guaranteeNotOptional = nullptr) {\n         return TFetchingScriptBuilder(schema, guaranteeNotOptional ? guaranteeNotOptional : std::make_shared<TColumnsSetIds>());\n@@ -331,10 +332,11 @@ class TStepAction: public IDataTasksProcessor::ITask {\n     }\n \n     template <class T>\n-    TStepAction(const std::shared_ptr<T>& source, TFetchingScriptCursor&& cursor, const NActors::TActorId& ownerActorId)\n-        : TStepAction(std::static_pointer_cast<IDataSource>(source), std::move(cursor), ownerActorId) {\n+    TStepAction(const std::shared_ptr<T>& source, TFetchingScriptCursor&& cursor, const NActors::TActorId& ownerActorId, const bool changeSyncSection)\n+        : TStepAction(std::static_pointer_cast<IDataSource>(source), std::move(cursor), ownerActorId, changeSyncSection) {\n     }\n-    TStepAction(const std::shared_ptr<IDataSource>& source, TFetchingScriptCursor&& cursor, const NActors::TActorId& ownerActorId);\n+    TStepAction(const std::shared_ptr<IDataSource>& source, TFetchingScriptCursor&& cursor, const NActors::TActorId& ownerActorId,\n+        const bool changeSyncSection);\n };\n \n class TProgramStep: public IFetchingStep {\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/iterator.cpp b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/iterator.cpp\nindex 093daee5a6b3..21a7e016baf1 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/iterator.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/iterator.cpp\n@@ -9,7 +9,6 @@ TColumnShardScanIterator::TColumnShardScanIterator(const std::shared_ptr<TReadCo\n     , ReadMetadata(context->GetReadMetadataPtrVerifiedAs<TReadMetadata>())\n     , ReadyResults(context->GetCounters()) {\n     IndexedData = ReadMetadata->BuildReader(Context);\n-    Y_ABORT_UNLESS(Context->GetReadMetadata()->IsSorted());\n }\n \n TConclusion<std::shared_ptr<TPartialReadResult>> TColumnShardScanIterator::GetBatch() {\n@@ -25,8 +24,8 @@ TConclusion<bool> TColumnShardScanIterator::ReadNextInterval() {\n     return IndexedData->ReadNextInterval();\n }\n \n-void TColumnShardScanIterator::DoOnSentDataFromInterval(const ui32 intervalIdx) const {\n-    return IndexedData->OnSentDataFromInterval(intervalIdx);\n+void TColumnShardScanIterator::DoOnSentDataFromInterval(const TPartialSourceAddress& address) {\n+    return IndexedData->OnSentDataFromInterval(address);\n }\n \n TColumnShardScanIterator::~TColumnShardScanIterator() {\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/iterator.h b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/iterator.h\nindex cd570090aa7d..f525af31b9cd 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/iterator.h\n+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/iterator.h\n@@ -55,7 +55,7 @@ class TReadyResults {\n \n class TColumnShardScanIterator: public TScanIteratorBase {\n private:\n-    virtual void DoOnSentDataFromInterval(const ui32 intervalIdx) const override;\n+    virtual void DoOnSentDataFromInterval(const TPartialSourceAddress& address) override;\n \n protected:\n     ui64 ItemsRead = 0;\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/source.h b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/source.h\nindex 466250fa20b9..afdc0b4e36f1 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/source.h\n+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/source.h\n@@ -114,8 +114,9 @@ class TExecutionContext {\n     }\n };\n \n-class IDataSource: public ICursorEntity, public NArrow::NSSA::IDataSource, public NColumnShard::TMonitoringObjectsCounter<IDataSource> {\n+class IDataSource: public ICursorEntity, public NArrow::NSSA::IDataSource {\n private:\n+    TAtomic SyncSectionFlag = 1;\n     YDB_READONLY(ui64, SourceId, 0);\n     YDB_READONLY(ui32, SourceIdx, 0);\n     YDB_READONLY(TSnapshot, RecordSnapshotMin, TSnapshot::Zero());\n@@ -153,20 +154,37 @@ class IDataSource: public ICursorEntity, public NArrow::NSSA::IDataSource, publi\n         const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const TColumnsSetIds& columns) = 0;\n     virtual void DoAssembleColumns(const std::shared_ptr<TColumnsSet>& columns, const bool sequential) = 0;\n \n-    NEvLog::TLogsThread Events;\n+    std::optional<NEvLog::TLogsThread> Events;\n+    std::unique_ptr<TFetchedData> StageData;\n \n protected:\n     std::vector<std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>> ResourceGuards;\n-    std::unique_ptr<TFetchedData> StageData;\n     std::unique_ptr<TFetchedResult> StageResult;\n \n public:\n+    void StartAsyncSection() {\n+        AFL_VERIFY(AtomicCas(&SyncSectionFlag, 0, 1));\n+    }\n+\n+    void CheckAsyncSection() {\n+        AFL_VERIFY(AtomicGet(SyncSectionFlag) == 0);\n+    }\n+\n+    void StartSyncSection() {\n+        AFL_VERIFY(AtomicCas(&SyncSectionFlag, 1, 0));\n+    }\n+\n+    bool IsSyncSection() const {\n+        return AtomicGet(SyncSectionFlag) == 1;\n+    }\n+\n     void AddEvent(const TString& evDescription) {\n-        Events.AddEvent(evDescription);\n+        AFL_VERIFY(!!Events);\n+        Events->AddEvent(evDescription);\n     }\n \n     TString GetEventsReport() const {\n-        return Events.DebugString();\n+        return Events ? Events->DebugString() : Default<TString>();\n     }\n \n     TExecutionContext& MutableExecutionContext() {\n@@ -212,6 +230,7 @@ class IDataSource: public ICursorEntity, public NArrow::NSSA::IDataSource, publi\n         , RecordsCount(recordsCount)\n         , ShardingVersionOptional(shardingVersion)\n         , HasDeletions(hasDeletions) {\n+        FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, Events.emplace(NEvLog::TLogsThread()));\n         FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, AddEvent(\"c\"));\n     }\n \n@@ -272,6 +291,10 @@ class IDataSource: public ICursorEntity, public NArrow::NSSA::IDataSource, publi\n         return DoStartFetchingColumns(sourcePtr, step, columns);\n     }\n \n+    void ResetSourceFinishedFlag() {\n+        AFL_VERIFY(AtomicCas(&SourceFinishedSafeFlag, 0, 1));\n+    }\n+\n     void OnSourceFetchingFinishedSafe(IDataReader& owner, const std::shared_ptr<IDataSource>& sourcePtr) {\n         AFL_VERIFY(AtomicCas(&SourceFinishedSafeFlag, 1, 0));\n         AFL_VERIFY(sourcePtr);\n@@ -315,8 +338,20 @@ class IDataSource: public ICursorEntity, public NArrow::NSSA::IDataSource, publi\n         return false;\n     }\n \n-    bool HasStageData() const {\n-        return !!StageData;\n+    void InitStageData(std::unique_ptr<TFetchedData>&& data) {\n+        AFL_VERIFY(!StageData);\n+        StageData = std::move(data);\n+    }\n+\n+    std::unique_ptr<TFetchedData> ExtractStageData() {\n+        AFL_VERIFY(StageData);\n+        auto result = std::move(StageData);\n+        StageData.reset();\n+        return std::move(result);\n+    }\n+\n+    void ClearStageData() {\n+        StageData.reset();\n     }\n \n     const TFetchedData& GetStageData() const {\n@@ -324,6 +359,10 @@ class IDataSource: public ICursorEntity, public NArrow::NSSA::IDataSource, publi\n         return *StageData;\n     }\n \n+    bool HasStageData() const {\n+        return !!StageData;\n+    }\n+\n     TFetchedData& MutableStageData() {\n         AFL_VERIFY(StageData);\n         return *StageData;\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/sub_columns_fetching.h b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/sub_columns_fetching.h\nindex a7ff2592f096..57cb35904c8d 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/sub_columns_fetching.h\n+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/sub_columns_fetching.h\n@@ -76,12 +76,10 @@ class TColumnChunkRestoreInfo {\n                 PartialArray->GetHeader().GetField(i.second.GetColumnIdx()), nullptr, 0);\n             source->GetContext()->GetCommonContext()->GetCounters().GetSubColumns()->GetColumnCounters().OnRead(\n                 i.second.GetBlobDataVerified().size());\n-            std::vector<NArrow::NAccessor::TDeserializeChunkedArray::TChunk> chunks = { NArrow::NAccessor::TDeserializeChunkedArray::TChunk(\n-                GetRecordsCount(), i.second.GetBlobDataVerified()) };\n             const std::shared_ptr<NArrow::NAccessor::IChunkedArray> arrOriginal =\n-                deserialize\n-                    ? columnLoader->ApplyVerified(i.second.GetBlobDataVerified(), GetRecordsCount())\n-                    : std::make_shared<NArrow::NAccessor::TDeserializeChunkedArray>(GetRecordsCount(), columnLoader, std::move(chunks), true);\n+                deserialize ? columnLoader->ApplyVerified(i.second.GetBlobDataVerified(), GetRecordsCount())\n+                            : std::make_shared<NArrow::NAccessor::TDeserializeChunkedArray>(\n+                                  GetRecordsCount(), columnLoader, i.second.GetBlobDataVerified(), true);\n             if (applyFilter) {\n                 PartialArray->AddColumn(i.first, applyFilter->Apply(arrOriginal));\n             } else {\ndiff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/ya.make b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/ya.make\nindex 1f3ed011557d..6dd94c3943c8 100644\n--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/ya.make\n+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/ya.make\n@@ -15,6 +15,7 @@ SRCS(\n \n PEERDIR(\n     ydb/core/tx/columnshard/engines/scheme\n+    ydb/core/formats/arrow/accessor/sub_columns\n     yql/essentials/minikql\n     ydb/core/util/evlog\n )\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/constructor.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/constructor.cpp\nindex d3654d881f57..ee01720c604c 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/constructor.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/constructor.cpp\n@@ -35,7 +35,11 @@ NKikimr::TConclusion<std::shared_ptr<TReadMetadataBase>> TIndexScannerConstructo\n \n     TDataStorageAccessor dataAccessor(insertTable, index);\n     AFL_VERIFY(read.PathId);\n-    auto readMetadata = std::make_shared<TReadMetadata>(index->CopyVersionedIndexPtr(), read);\n+    auto readCopy = read;\n+    if (readCopy.GetSorting() == ERequestSorting::NONE) {\n+        readCopy.SetSorting(ERequestSorting::ASC);\n+    }\n+    auto readMetadata = std::make_shared<TReadMetadata>(index->CopyVersionedIndexPtr(), readCopy);\n \n     auto initResult = readMetadata->Init(self, read, dataAccessor);\n     if (!initResult) {\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.cpp\nindex ae2deb2810ea..2636db28693e 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.cpp\n@@ -30,7 +30,7 @@ std::shared_ptr<TFetchingScript> TSpecialReadContext::DoGetColumnsFetchingPlan(c\n         if (!AskAccumulatorsScript) {\n             NCommon::TFetchingScriptBuilder acc(*this);\n             if (ui64 size = source->PredictAccessorsMemory()) {\n-                acc.AddStep(std::make_shared<NCommon::TAllocateMemoryStep>(size, EStageFeaturesIndexes::Accessors));\n+                acc.AddStep(std::make_shared<NCommon::TAllocateMemoryStep>(size, NArrow::NSSA::IMemoryCalculationPolicy::EStage::Accessors));\n             }\n             acc.AddStep(std::make_shared<TPortionAccessorFetchingStep>());\n             acc.AddStep(std::make_shared<TDetectInMem>(*GetFFColumns()));\n@@ -90,25 +90,25 @@ std::shared_ptr<TFetchingScript> TSpecialReadContext::BuildColumnsFetchingPlan(c\n     bool hasFilterSharding = false;\n     if (needFilterSharding && !GetShardingColumns()->IsEmpty()) {\n         hasFilterSharding = true;\n-        acc.AddFetchingStep(*GetShardingColumns(), EStageFeaturesIndexes::Filter);\n+        acc.AddFetchingStep(*GetShardingColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);\n         if (!exclusiveSource) {\n-            acc.AddFetchingStep(*GetPKColumns(), EStageFeaturesIndexes::Filter);\n-            acc.AddFetchingStep(*GetSpecColumns(), EStageFeaturesIndexes::Filter);\n+            acc.AddFetchingStep(*GetPKColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);\n+            acc.AddFetchingStep(*GetSpecColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);\n         }\n-        acc.AddAssembleStep(acc.GetAddedFetchingColumns(), \"SPEC_SHARDING\", EStageFeaturesIndexes::Filter, false);\n+        acc.AddAssembleStep(acc.GetAddedFetchingColumns(), \"SPEC_SHARDING\", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);\n         acc.AddStep(std::make_shared<TShardingFilter>());\n     }\n     if (!GetEFColumns()->GetColumnsCount() && !partialUsageByPredicate) {\n         acc.SetBranchName(\"simple\");\n-        acc.AddFetchingStep(*GetFFColumns(), EStageFeaturesIndexes::Fetching);\n+        acc.AddFetchingStep(*GetFFColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching);\n         if (needFilterDeletion) {\n-            acc.AddFetchingStep(*GetDeletionColumns(), EStageFeaturesIndexes::Fetching);\n+            acc.AddFetchingStep(*GetDeletionColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching);\n         }\n         if (needSnapshots) {\n-            acc.AddFetchingStep(*GetSpecColumns(), EStageFeaturesIndexes::Fetching);\n+            acc.AddFetchingStep(*GetSpecColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching);\n         }\n         if (!exclusiveSource) {\n-            acc.AddFetchingStep(*GetMergeColumns(), EStageFeaturesIndexes::Fetching);\n+            acc.AddFetchingStep(*GetMergeColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching);\n         } else {\n             if (acc.GetAddedFetchingColumns().GetColumnsCount() == 1 && GetSpecColumns()->Contains(acc.GetAddedFetchingColumns()) && !hasFilterSharding) {\n                 return nullptr;\n@@ -116,76 +116,77 @@ std::shared_ptr<TFetchingScript> TSpecialReadContext::BuildColumnsFetchingPlan(c\n         }\n         if (acc.GetAddedFetchingColumns().GetColumnsCount() || hasFilterSharding || needFilterDeletion) {\n             if (needSnapshots) {\n-                acc.AddAssembleStep(*GetSpecColumns(), \"SPEC\", EStageFeaturesIndexes::Fetching, false);\n+                acc.AddAssembleStep(*GetSpecColumns(), \"SPEC\", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching, false);\n             }\n             if (!exclusiveSource) {\n-                acc.AddAssembleStep(*GetMergeColumns(), \"LAST_PK\", EStageFeaturesIndexes::Fetching, false);\n+                acc.AddAssembleStep(*GetMergeColumns(), \"LAST_PK\", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching, false);\n             }\n             if (needSnapshots) {\n                 acc.AddStep(std::make_shared<TSnapshotFilter>());\n             }\n             if (needFilterDeletion) {\n-                acc.AddAssembleStep(*GetDeletionColumns(), \"SPEC_DELETION\", EStageFeaturesIndexes::Fetching, false);\n+                acc.AddAssembleStep(*GetDeletionColumns(), \"SPEC_DELETION\", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching, false);\n                 acc.AddStep(std::make_shared<TDeletionFilter>());\n             }\n-            acc.AddAssembleStep(acc.GetAddedFetchingColumns().GetColumnIds(), \"LAST\", EStageFeaturesIndexes::Fetching, !exclusiveSource);\n+            acc.AddAssembleStep(acc.GetAddedFetchingColumns().GetColumnIds(), \"LAST\", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching,\n+                !exclusiveSource);\n         } else {\n             return nullptr;\n         }\n     } else if (exclusiveSource) {\n         acc.SetBranchName(\"exclusive\");\n-        acc.AddFetchingStep(*GetEFColumns(), EStageFeaturesIndexes::Filter);\n+        acc.AddFetchingStep(*GetEFColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);\n         if (needFilterDeletion) {\n-            acc.AddFetchingStep(*GetDeletionColumns(), EStageFeaturesIndexes::Filter);\n+            acc.AddFetchingStep(*GetDeletionColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);\n         }\n         if (needSnapshots || GetFFColumns()->Cross(*GetSpecColumns())) {\n-            acc.AddFetchingStep(*GetSpecColumns(), EStageFeaturesIndexes::Filter);\n+            acc.AddFetchingStep(*GetSpecColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);\n         }\n         if (partialUsageByPredicate) {\n-            acc.AddFetchingStep(*GetPredicateColumns(), EStageFeaturesIndexes::Filter);\n+            acc.AddFetchingStep(*GetPredicateColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);\n         }\n \n         AFL_VERIFY(acc.GetAddedFetchingColumns().GetColumnsCount());\n \n         if (needFilterDeletion) {\n-            acc.AddAssembleStep(*GetDeletionColumns(), \"SPEC_DELETION\", EStageFeaturesIndexes::Filter, false);\n+            acc.AddAssembleStep(*GetDeletionColumns(), \"SPEC_DELETION\", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);\n             acc.AddStep(std::make_shared<TDeletionFilter>());\n         }\n         if (partialUsageByPredicate) {\n-            acc.AddAssembleStep(*GetPredicateColumns(), \"PREDICATE\", EStageFeaturesIndexes::Filter, false);\n+            acc.AddAssembleStep(*GetPredicateColumns(), \"PREDICATE\", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);\n             acc.AddStep(std::make_shared<TPredicateFilter>());\n         }\n         if (needSnapshots || GetFFColumns()->Cross(*GetSpecColumns())) {\n-            acc.AddAssembleStep(*GetSpecColumns(), \"SPEC\", EStageFeaturesIndexes::Filter, false);\n+            acc.AddAssembleStep(*GetSpecColumns(), \"SPEC\", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);\n             acc.AddStep(std::make_shared<TSnapshotFilter>());\n         } else if (GetProgramInputColumns()->Cross(*GetSpecColumns())) {\n             acc.AddStep(std::make_shared<TBuildFakeSpec>());\n         }\n-        acc.AddFetchingStep(*GetFFColumns(), EStageFeaturesIndexes::Fetching);\n-        acc.AddAssembleStep(*GetFFColumns(), \"LAST\", EStageFeaturesIndexes::Fetching, !exclusiveSource);\n+        acc.AddFetchingStep(*GetFFColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching);\n+        acc.AddAssembleStep(*GetFFColumns(), \"LAST\", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching, !exclusiveSource);\n     } else {\n         acc.SetBranchName(\"merge\");\n-        acc.AddFetchingStep(*GetMergeColumns(), EStageFeaturesIndexes::Filter);\n-        acc.AddFetchingStep(*GetEFColumns(), EStageFeaturesIndexes::Filter);\n+        acc.AddFetchingStep(*GetMergeColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);\n+        acc.AddFetchingStep(*GetEFColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);\n         if (needFilterDeletion) {\n-            acc.AddFetchingStep(*GetDeletionColumns(), EStageFeaturesIndexes::Filter);\n+            acc.AddFetchingStep(*GetDeletionColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);\n         }\n         AFL_VERIFY(acc.GetAddedFetchingColumns().GetColumnsCount());\n \n-        acc.AddAssembleStep(*GetSpecColumns(), \"SPEC\", EStageFeaturesIndexes::Filter, false);\n-        acc.AddAssembleStep(*GetPKColumns(), \"PK\", EStageFeaturesIndexes::Filter, false);\n+        acc.AddAssembleStep(*GetSpecColumns(), \"SPEC\", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);\n+        acc.AddAssembleStep(*GetPKColumns(), \"PK\", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);\n         if (needSnapshots) {\n             acc.AddStep(std::make_shared<TSnapshotFilter>());\n         }\n         if (needFilterDeletion) {\n-            acc.AddAssembleStep(*GetDeletionColumns(), \"SPEC_DELETION\", EStageFeaturesIndexes::Filter, false);\n+            acc.AddAssembleStep(*GetDeletionColumns(), \"SPEC_DELETION\", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);\n             acc.AddStep(std::make_shared<TDeletionFilter>());\n         }\n         if (partialUsageByPredicate) {\n             acc.AddStep(std::make_shared<TPredicateFilter>());\n         }\n-        acc.AddFetchingStep(*GetFFColumns(), EStageFeaturesIndexes::Fetching);\n-        acc.AddAssembleStep(*GetFFColumns(), \"LAST\", EStageFeaturesIndexes::Fetching, !exclusiveSource);\n+        acc.AddFetchingStep(*GetFFColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching);\n+        acc.AddAssembleStep(*GetFFColumns(), \"LAST\", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching, !exclusiveSource);\n     }\n     acc.AddStep(std::make_shared<NCommon::TBuildStageResultStep>());\n     return std::move(acc).Build();\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.h\nindex 4d35be2eca8f..9500e54a3cf1 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.h\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.h\n@@ -13,7 +13,6 @@ namespace NKikimr::NOlap::NReader::NPlain {\n \n class IDataSource;\n using TColumnsSet = NCommon::TColumnsSet;\n-using EStageFeaturesIndexes = NCommon::EStageFeaturesIndexes;\n using TColumnsSetIds = NCommon::TColumnsSetIds;\n using EMemType = NCommon::EMemType;\n using TFetchingScript = NCommon::TFetchingScript;\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.cpp\nindex 3c74c4fd25f3..97ddcb1968d0 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.cpp\n@@ -14,9 +14,10 @@ namespace NKikimr::NOlap::NReader::NPlain {\n \n TConclusion<bool> TPredicateFilter::DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& /*step*/) const {\n     auto filter = source->GetContext()->GetReadMetadata()->GetPKRangesFilter().BuildFilter(\n-        source->GetStageData().GetTable()->ToTable(source->GetContext()->GetReadMetadata()->GetPKRangesFilter().GetColumnIds(\n-                                                       source->GetContext()->GetReadMetadata()->GetResultSchema()->GetIndexInfo()),\n-            source->GetContext()->GetCommonContext()->GetResolver(), true));\n+        source->GetStageData().GetTable()->ToGeneralContainer(source->GetContext()->GetCommonContext()->GetResolver(),\n+            source->GetContext()->GetReadMetadata()->GetPKRangesFilter().GetColumnIds(\n+                source->GetContext()->GetReadMetadata()->GetResultSchema()->GetIndexInfo()),\n+            true));\n     source->MutableStageData().AddFilter(filter);\n     return true;\n }\n@@ -34,7 +35,8 @@ TConclusion<bool> TSnapshotFilter::DoExecuteInplace(const std::shared_ptr<IDataS\n }\n \n TConclusion<bool> TDeletionFilter::DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& /*step*/) const {\n-    auto collection = source->GetStageData().GetTable()->SelectOptional(std::vector<ui32>({ (ui32)IIndexInfo::ESpecialColumn::DELETE_FLAG }), false);\n+    auto collection =\n+        source->GetStageData().GetTable()->SelectOptional(std::vector<ui32>({ (ui32)IIndexInfo::ESpecialColumn::DELETE_FLAG }), false);\n     if (!collection) {\n         return true;\n     }\n@@ -86,7 +88,7 @@ TConclusion<bool> TDetectInMem::DoExecuteInplace(const std::shared_ptr<IDataSour\n     auto plan = source->GetContext()->GetColumnsFetchingPlan(source);\n     source->InitFetchingPlan(plan);\n     TFetchingScriptCursor cursor(plan, 0);\n-    auto task = std::make_shared<TStepAction>(source, std::move(cursor), source->GetContext()->GetCommonContext()->GetScanActorId());\n+    auto task = std::make_shared<TStepAction>(source, std::move(cursor), source->GetContext()->GetCommonContext()->GetScanActorId(), false);\n     NConveyor::TScanServiceOperator::SendTaskToExecute(task);\n     return false;\n }\n@@ -94,9 +96,16 @@ TConclusion<bool> TDetectInMem::DoExecuteInplace(const std::shared_ptr<IDataSour\n TConclusion<bool> TBuildFakeSpec::DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& /*step*/) const {\n     std::vector<std::shared_ptr<arrow::Array>> columns;\n     for (auto&& f : IIndexInfo::ArrowSchemaSnapshot()->fields()) {\n-        source->MutableStageData().GetTable()->AddVerified(IIndexInfo::GetColumnIdVerified(f->name()),\n-            std::make_shared<NArrow::NAccessor::TTrivialArray>(\n-                NArrow::TThreadSimpleArraysCache::GetConst(f->type(), NArrow::DefaultScalar(f->type()), source->GetRecordsCount())), true);\n+        if (source->MutableStageData().GetTable()->HasColumn(IIndexInfo::GetColumnIdVerified(f->name()))) {\n+            auto arr = source->MutableStageData().GetTable()->GetArrayVerified(IIndexInfo::GetColumnIdVerified(f->name()));\n+            AFL_WARN(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"spec_column_exists\")(\"column_name\", f->name())(\n+                \"col\", NArrow::DebugJson(arr, 2, 2).GetStringRobust());\n+        } else {\n+            source->MutableStageData().GetTable()->AddVerified(IIndexInfo::GetColumnIdVerified(f->name()),\n+                std::make_shared<NArrow::NAccessor::TTrivialArray>(\n+                    NArrow::TThreadSimpleArraysCache::GetConst(f->type(), NArrow::DefaultScalar(f->type()), source->GetRecordsCount())),\n+                true);\n+        }\n     }\n     return true;\n }\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.h\nindex 1e3fa3a98b5a..b2fcbe88b7e9 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.h\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.h\n@@ -14,7 +14,6 @@ namespace NKikimr::NOlap::NReader::NPlain {\n \n using TColumnsSet = NCommon::TColumnsSet;\n using TIndexesSet = NCommon::TIndexesSet;\n-using EStageFeaturesIndexes = NCommon::EStageFeaturesIndexes;\n using TColumnsSetIds = NCommon::TColumnsSetIds;\n using EMemType = NCommon::EMemType;\n using TFetchingScriptCursor = NCommon::TFetchingScriptCursor;\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/interval.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/interval.cpp\nindex 7f44376f3ad9..a431b81077f4 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/interval.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/interval.cpp\n@@ -20,7 +20,7 @@ void TFetchingInterval::ConstructResult() {\n         auto task = std::make_shared<TStartMergeTask>(MergingContext, Context, std::move(Sources));\n         task->SetPriority(NConveyor::ITask::EPriority::High);\n         NGroupedMemoryManager::TScanMemoryLimiterOperator::SendToAllocation(Context->GetProcessMemoryControlId(),\n-            Context->GetCommonContext()->GetScanId(), GetIntervalId(), { task }, (ui32)EStageFeaturesIndexes::Merge);\n+            Context->GetCommonContext()->GetScanId(), GetIntervalId(), { task }, (ui32)NArrow::NSSA::IMemoryCalculationPolicy::EStage::Merge);\n     }\n }\n \n@@ -83,7 +83,7 @@ void TFetchingInterval::OnPartSendingComplete() {\n     auto task = std::make_shared<TContinueMergeTask>(MergingContext, Context, std::move(Merger));\n     task->SetPriority(NConveyor::ITask::EPriority::High);\n     NGroupedMemoryManager::TScanMemoryLimiterOperator::SendToAllocation(Context->GetProcessMemoryControlId(),\n-        Context->GetCommonContext()->GetScanId(), GetIntervalId(), { task }, (ui32)EStageFeaturesIndexes::Merge);\n+        Context->GetCommonContext()->GetScanId(), GetIntervalId(), { task }, (ui32)NArrow::NSSA::IMemoryCalculationPolicy::EStage::Merge);\n }\n \n }   // namespace NKikimr::NOlap::NReader::NPlain\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/merge.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/merge.cpp\nindex 1432002370ea..9c351d4f7845 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/merge.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/merge.cpp\n@@ -142,7 +142,7 @@ TConclusionStatus TStartMergeTask::DoExecuteImpl() {\n         }\n     }\n     Merger->PutControlPoint(MergingContext->GetFinish(), false);\n-    Merger->SkipToLowerBound(MergingContext->GetStart(), MergingContext->GetIncludeStart());\n+    Merger->SkipToBound(MergingContext->GetStart(), MergingContext->GetIncludeStart());\n     const ui32 originalSourcesCount = Sources.size();\n     Sources.clear();\n \ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/plain_read_data.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/plain_read_data.h\nindex 960f49541bc6..2b2f5e250fd7 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/plain_read_data.h\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/plain_read_data.h\n@@ -45,8 +45,8 @@ class TPlainReadData: public IDataReader, TNonCopyable, NColumnShard::TMonitorin\n     }\n \n public:\n-    virtual void OnSentDataFromInterval(const ui32 intervalIdx) const override {\n-        Scanner->OnSentDataFromInterval(intervalIdx);\n+    virtual void OnSentDataFromInterval(const TPartialSourceAddress& address) override {\n+        Scanner->OnSentDataFromInterval(address);\n     }\n \n     template <class T>\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.cpp\nindex b0e489fa74ea..076dd63d495d 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.cpp\n@@ -21,10 +21,10 @@ void TScanHead::OnIntervalResult(std::shared_ptr<NGroupedMemoryManager::TAllocat\n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"interval_result_received\")(\"interval_idx\", intervalIdx)(\n         \"intervalId\", itInterval->second->GetIntervalId());\n     if (newBatch && newBatch->GetRecordsCount()) {\n-        std::optional<ui32> callbackIdxSubscriver;\n+        std::optional<TPartialSourceAddress> callbackIdxSubscriver;\n         std::shared_ptr<NGroupedMemoryManager::TGroupGuard> gGuard;\n         if (itInterval->second->HasMerger()) {\n-            callbackIdxSubscriver = intervalIdx;\n+            callbackIdxSubscriver = TPartialSourceAddress(itInterval->second->GetIntervalId(), intervalIdx, 0);\n         } else {\n             gGuard = itInterval->second->GetGroupGuard();\n         }\n@@ -203,4 +203,13 @@ void TScanHead::Abort() {\n     Y_ABORT_UNLESS(IsFinished());\n }\n \n+void TScanHead::OnSentDataFromInterval(const TPartialSourceAddress& address) const {\n+    if (Context->IsAborted()) {\n+        return;\n+    }\n+    auto it = FetchingIntervals.find(address.GetSourceIdx());\n+    AFL_VERIFY(it != FetchingIntervals.end())(\"interval_idx\", address.GetSourceIdx())(\"count\", FetchingIntervals.size());\n+    it->second->OnPartSendingComplete();\n+}\n+\n }   // namespace NKikimr::NOlap::NReader::NPlain\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.h\nindex 09649e788147..23888d410815 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.h\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.h\n@@ -84,14 +84,7 @@ class TScanHead {\n     void DrainSources();\n     [[nodiscard]] TConclusionStatus DetectSourcesFeatureInContextIntervalScan(const THashMap<ui32, std::shared_ptr<IDataSource>>& intervalSources, const bool isExclusiveInterval) const;\n public:\n-    void OnSentDataFromInterval(const ui32 intervalIdx) const {\n-        if (Context->IsAborted()) {\n-            return;\n-        }\n-        auto it = FetchingIntervals.find(intervalIdx);\n-        AFL_VERIFY(it != FetchingIntervals.end())(\"interval_idx\", intervalIdx)(\"count\", FetchingIntervals.size());\n-        it->second->OnPartSendingComplete();\n-    }\n+    void OnSentDataFromInterval(const TPartialSourceAddress& address) const;\n \n     bool IsReverse() const;\n     void Abort();\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.cpp\nindex 1c3945298734..9f74bc79c656 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.cpp\n@@ -28,7 +28,7 @@ void IDataSource::RegisterInterval(TFetchingInterval& interval, const std::share\n     if (AtomicCas(&SourceStartedFlag, 1, 0)) {\n         SetMemoryGroupId(interval.GetIntervalId());\n         AFL_VERIFY(FetchingPlan);\n-        StageData = std::make_unique<TFetchedData>(GetExclusiveIntervalOnly(), GetRecordsCount());\n+        InitStageData(std::make_unique<TFetchedData>(GetExclusiveIntervalOnly(), GetRecordsCount()));\n         AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"InitFetchingPlan\", FetchingPlan->DebugString())(\"source_idx\", GetSourceIdx());\n         NActors::TLogContextGuard logGuard(NActors::TLogContextBuilder::Build()(\"source\", GetSourceIdx())(\"method\", \"InitFetchingPlan\"));\n         if (GetContext()->IsAborted()) {\n@@ -36,7 +36,7 @@ void IDataSource::RegisterInterval(TFetchingInterval& interval, const std::share\n             return;\n         }\n         TFetchingScriptCursor cursor(FetchingPlan, 0);\n-        auto task = std::make_shared<TStepAction>(sourcePtr, std::move(cursor), GetContext()->GetCommonContext()->GetScanActorId());\n+        auto task = std::make_shared<TStepAction>(sourcePtr, std::move(cursor), GetContext()->GetCommonContext()->GetScanActorId(), true);\n         NConveyor::TScanServiceOperator::SendTaskToExecute(task);\n     }\n }\n@@ -64,15 +64,15 @@ void IDataSource::DoOnEmptyStageData(const std::shared_ptr<NCommon::IDataSource>\n         StageResult = TFetchedResult::BuildEmpty();\n     } else {\n         StageResult = std::make_unique<TFetchedResult>(\n-            std::move(StageData), GetContext()->GetMergeColumns()->GetColumnIds(), *GetContext()->GetCommonContext()->GetResolver());\n+            ExtractStageData(), GetContext()->GetMergeColumns()->GetColumnIds(), *GetContext()->GetCommonContext()->GetResolver());\n     }\n-    StageData.reset();\n+    ClearStageData();\n }\n \n void IDataSource::DoBuildStageResult(const std::shared_ptr<NCommon::IDataSource>& /*sourcePtr*/) {\n     TMemoryProfileGuard mpg(\"SCAN_PROFILE::STAGE_RESULT\", IS_DEBUG_LOG_ENABLED(NKikimrServices::TX_COLUMNSHARD_SCAN_MEMORY));\n-    StageResult = std::make_unique<TFetchedResult>(std::move(StageData), *GetContext()->GetCommonContext()->GetResolver());\n-    StageData.reset();\n+    StageResult = std::make_unique<TFetchedResult>(ExtractStageData(), *GetContext()->GetCommonContext()->GetResolver());\n+    ClearStageData();\n }\n \n void TPortionDataSource::NeedFetchColumns(const std::set<ui32>& columnIds, TBlobsAction& blobsAction,\n@@ -111,15 +111,15 @@ bool TPortionDataSource::DoStartFetchingColumns(\n     const std::shared_ptr<NCommon::IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const TColumnsSetIds& columns) {\n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", step.GetName());\n     AFL_VERIFY(columns.GetColumnsCount());\n-    AFL_VERIFY(!StageData->GetAppliedFilter() || !StageData->GetAppliedFilter()->IsTotalDenyFilter());\n+    AFL_VERIFY(!GetStageData().GetAppliedFilter() || !GetStageData().GetAppliedFilter()->IsTotalDenyFilter());\n     auto& columnIds = columns.GetColumnIds();\n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", step.GetName())(\"fetching_info\", step.DebugString());\n \n     TBlobsAction action(GetContext()->GetCommonContext()->GetStoragesManager(), NBlobOperations::EConsumer::SCAN);\n     {\n         THashMap<TChunkAddress, TPortionDataAccessor::TAssembleBlobInfo> nullBlocks;\n-        NeedFetchColumns(columnIds, action, nullBlocks, StageData->GetAppliedFilter());\n-        StageData->AddDefaults(std::move(nullBlocks));\n+        NeedFetchColumns(columnIds, action, nullBlocks, GetStageData().GetAppliedFilter());\n+        MutableStageData().AddDefaults(std::move(nullBlocks));\n     }\n \n     auto readActions = action.GetReadingActions();\n@@ -170,7 +170,7 @@ class TPortionAccessorFetchingSubscriber: public IDataAccessorRequestsSubscriber\n         AFL_VERIFY(result.GetPortions().size() == 1)(\"count\", result.GetPortions().size());\n         Source->MutableStageData().SetPortionAccessor(std::move(result.ExtractPortionsVector().front()));\n         AFL_VERIFY(Step.Next());\n-        auto task = std::make_shared<TStepAction>(Source, std::move(Step), Source->GetContext()->GetCommonContext()->GetScanActorId());\n+        auto task = std::make_shared<TStepAction>(Source, std::move(Step), Source->GetContext()->GetCommonContext()->GetScanActorId(), false);\n         NConveyor::TScanServiceOperator::SendTaskToExecute(task);\n     }\n \n@@ -184,7 +184,7 @@ class TPortionAccessorFetchingSubscriber: public IDataAccessorRequestsSubscriber\n }   // namespace\n \n bool TPortionDataSource::DoStartFetchingAccessor(const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step) {\n-    AFL_VERIFY(!StageData->HasPortionAccessor());\n+    AFL_VERIFY(!GetStageData().HasPortionAccessor());\n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", step.GetName())(\"fetching_info\", step.DebugString());\n \n     std::shared_ptr<TDataAccessorsRequest> request = std::make_shared<TDataAccessorsRequest>(\"PLAIN::\" + step.GetName());\n@@ -219,7 +219,8 @@ void TCommittedDataSource::DoAssembleColumns(const std::shared_ptr<TColumnsSet>&\n     const ISnapshotSchema::TPtr batchSchema =\n         GetContext()->GetReadMetadata()->GetIndexVersions().GetSchemaVerified(GetCommitted().GetSchemaVersion());\n     const ISnapshotSchema::TPtr resultSchema = GetContext()->GetReadMetadata()->GetResultSchema();\n-    if (!GetStageData().GetTable()->HasAccessors()) {\n+    if (!AssembledFlag) {\n+        AssembledFlag = true;\n         AFL_VERIFY(GetStageData().GetBlobs().size() == 1);\n         auto bData = MutableStageData().ExtractBlob(GetStageData().GetBlobs().begin()->first);\n         auto schema = GetContext()->GetReadMetadata()->GetBlobSchema(CommittedBlob.GetSchemaVersion());\ndiff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.h\nindex e43e8d75cd86..69cce115dfd2 100644\n--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.h\n+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.h\n@@ -239,7 +239,7 @@ class TPortionDataSource: public IDataSource {\n     }\n \n     virtual bool NeedAccessorsFetching() const override {\n-        return !StageData || !StageData->HasPortionAccessor();\n+        return !HasStageData() || !GetStageData().HasPortionAccessor();\n     }\n \n     virtual bool DoAddTxConflict() override {\n@@ -308,6 +308,7 @@ class TCommittedDataSource: public IDataSource {\n     using TBase = IDataSource;\n     TCommittedBlob CommittedBlob;\n     bool ReadStarted = false;\n+    bool AssembledFlag = false;\n \n     virtual void DoAbort() override {\n     }\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/constructor/constructor.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/constructor/constructor.cpp\nindex 07b1a7653b12..0363e2385c33 100644\n--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/constructor/constructor.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/constructor/constructor.cpp\n@@ -43,4 +43,14 @@ NKikimr::TConclusion<std::shared_ptr<TReadMetadataBase>> TIndexScannerConstructo\n     return static_pointer_cast<TReadMetadataBase>(readMetadata);\n }\n \n+std::shared_ptr<NKikimr::NOlap::IScanCursor> TIndexScannerConstructor::DoBuildCursor() const {\n+    switch (Sorting) {\n+        case ERequestSorting::ASC:\n+        case ERequestSorting::DESC:\n+            return std::make_shared<TSimpleScanCursor>();\n+        case ERequestSorting::NONE:\n+            return std::make_shared<TNotSortedSimpleScanCursor>();\n+    }\n+}\n+\n }   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/constructor/constructor.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/constructor/constructor.h\nindex 76596f8dd94e..7f52b721565a 100644\n--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/constructor/constructor.h\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/constructor/constructor.h\n@@ -13,9 +13,7 @@ class TIndexScannerConstructor: public IScannerConstructor {\n     using TBase = IScannerConstructor;\n     static const inline TFactory::TRegistrator<TIndexScannerConstructor> Registrator =\n         TFactory::TRegistrator<TIndexScannerConstructor>(GetClassNameStatic());\n-    virtual std::shared_ptr<IScanCursor> DoBuildCursor() const override {\n-        return std::make_shared<TSimpleScanCursor>();\n-    }\n+    virtual std::shared_ptr<IScanCursor> DoBuildCursor() const override;\n \n protected:\n     virtual TConclusion<std::shared_ptr<TReadMetadataBase>> DoBuildReadMetadata(const NColumnShard::TColumnShard* self, const TReadDescription& read) const override;\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/abstract.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/abstract.cpp\nnew file mode 100644\nindex 000000000000..d40f3ee3b2a5\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/abstract.cpp\n@@ -0,0 +1,14 @@\n+#include \"abstract.h\"\n+\n+#include <ydb/core/tx/columnshard/engines/predicate/filter.h>\n+\n+namespace NKikimr::NOlap::NReader::NSimple {\n+\n+ISourcesCollection::ISourcesCollection(const std::shared_ptr<TSpecialReadContext>& context)\n+    : Context(context) {\n+    if (HasAppData() && AppDataVerified().ColumnShardConfig.HasMaxInFlightIntervalsOnRequest()) {\n+        MaxInFlight = AppDataVerified().ColumnShardConfig.GetMaxInFlightIntervalsOnRequest();\n+    }\n+}\n+\n+}   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/abstract.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/abstract.h\nnew file mode 100644\nindex 000000000000..6f9eb00eff23\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/abstract.h\n@@ -0,0 +1,81 @@\n+#pragma once\n+#include <ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.h>\n+#include <ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.h>\n+\n+#include <ydb/library/accessor/positive_integer.h>\n+\n+namespace NKikimr::NOlap::NReader::NSimple {\n+\n+class ISourcesCollection {\n+private:\n+    virtual bool DoIsFinished() const = 0;\n+    virtual std::shared_ptr<IDataSource> DoExtractNext() = 0;\n+    virtual bool DoCheckInFlightLimits() const = 0;\n+    virtual void DoOnSourceFinished(const std::shared_ptr<IDataSource>& source) = 0;\n+    virtual void DoClear() = 0;\n+    virtual void DoAbort() = 0;\n+\n+    TPositiveControlInteger SourcesInFlightCount;\n+    YDB_READONLY(ui64, MaxInFlight, 1024);\n+\n+    virtual TString DoDebugString() const {\n+        return \"\";\n+    }\n+    virtual std::shared_ptr<IScanCursor> DoBuildCursor(const std::shared_ptr<IDataSource>& source, const ui32 readyRecords) const = 0;\n+    virtual bool DoHasData() const = 0;\n+\n+protected:\n+    const std::shared_ptr<TSpecialReadContext> Context;\n+\n+public:\n+    bool HasData() const {\n+        return DoHasData();\n+    }\n+\n+    std::shared_ptr<IScanCursor> BuildCursor(const std::shared_ptr<IDataSource>& source, const ui32 readyRecords, const ui64 tabletId) const {\n+        AFL_VERIFY(source);\n+        AFL_VERIFY(readyRecords <= source->GetRecordsCount())(\"count\", source->GetRecordsCount())(\"ready\", readyRecords);\n+        auto result = DoBuildCursor(source, readyRecords);\n+        AFL_VERIFY(result);\n+        result->SetTabletId(tabletId);\n+        AFL_VERIFY(tabletId);\n+        return result;\n+    }\n+\n+    TString DebugString() const {\n+        return DoDebugString();\n+    }\n+\n+    virtual ~ISourcesCollection() = default;\n+\n+    std::shared_ptr<IDataSource> ExtractNext() {\n+        SourcesInFlightCount.Inc();\n+        return DoExtractNext();\n+    }\n+\n+    bool IsFinished() const {\n+        return DoIsFinished();\n+    }\n+\n+    void OnSourceFinished(const std::shared_ptr<IDataSource>& source) {\n+        AFL_VERIFY(source);\n+        SourcesInFlightCount.Dec();\n+        DoOnSourceFinished(source);\n+    }\n+\n+    bool CheckInFlightLimits() const {\n+        return DoCheckInFlightLimits();\n+    }\n+\n+    void Clear() {\n+        DoClear();\n+    }\n+\n+    void Abort() {\n+        DoAbort();\n+    }\n+\n+    ISourcesCollection(const std::shared_ptr<TSpecialReadContext>& context);\n+};\n+\n+}   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/full_scan_sorted.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/full_scan_sorted.cpp\nnew file mode 100644\nindex 000000000000..a24f1158b65f\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/full_scan_sorted.cpp\n@@ -0,0 +1,5 @@\n+#include \"full_scan_sorted.h\"\n+\n+namespace NKikimr::NOlap::NReader::NSimple {\n+\n+}   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/full_scan_sorted.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/full_scan_sorted.h\nnew file mode 100644\nindex 000000000000..9fe6771159ca\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/full_scan_sorted.h\n@@ -0,0 +1,65 @@\n+#pragma once\n+#include \"abstract.h\"\n+\n+#include <ydb/library/accessor/positive_integer.h>\n+\n+namespace NKikimr::NOlap::NReader::NSimple {\n+\n+class TSortedFullScanCollection: public ISourcesCollection {\n+private:\n+    using TBase = ISourcesCollection;\n+    std::deque<TSourceConstructor> HeapSources;\n+    TPositiveControlInteger InFlightCount;\n+    ui32 SourceIdx = 0;\n+    virtual void DoClear() override {\n+        HeapSources.clear();\n+    }\n+    virtual bool DoHasData() const override {\n+        return HeapSources.size();\n+    }\n+    virtual void DoAbort() override {\n+        HeapSources.clear();\n+    }\n+    virtual bool DoIsFinished() const override {\n+        return HeapSources.empty();\n+    }\n+    virtual std::shared_ptr<IScanCursor> DoBuildCursor(const std::shared_ptr<IDataSource>& source, const ui32 readyRecords) const override {\n+        return std::make_shared<TSimpleScanCursor>(source->GetStartPKRecordBatch(), source->GetSourceId(), readyRecords);\n+    }\n+    virtual std::shared_ptr<IDataSource> DoExtractNext() override {\n+        AFL_VERIFY(HeapSources.size());\n+        auto result = HeapSources.front().Construct(SourceIdx++, Context);\n+        std::pop_heap(HeapSources.begin(), HeapSources.end());\n+        HeapSources.pop_back();\n+        InFlightCount.Inc();\n+        return result;\n+    }\n+    virtual bool DoCheckInFlightLimits() const override {\n+        return InFlightCount < GetMaxInFlight();\n+    }\n+    virtual void DoOnSourceFinished(const std::shared_ptr<IDataSource>& /*source*/) override {\n+        InFlightCount.Dec();\n+    }\n+\n+public:\n+    TSortedFullScanCollection(const std::shared_ptr<TSpecialReadContext>& context, std::deque<TSourceConstructor>&& sources,\n+        const std::shared_ptr<IScanCursor>& cursor)\n+        : TBase(context) {\n+        if (cursor && cursor->IsInitialized()) {\n+            for (auto&& i : sources) {\n+                bool usage = false;\n+                if (!context->GetCommonContext()->GetScanCursor()->CheckEntityIsBorder(i, usage)) {\n+                    continue;\n+                }\n+                if (usage) {\n+                    i.SetIsStartedByCursor();\n+                }\n+                break;\n+            }\n+        }\n+        HeapSources = std::move(sources);\n+        std::make_heap(HeapSources.begin(), HeapSources.end());\n+    }\n+};\n+\n+}   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/limit_sorted.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/limit_sorted.cpp\nnew file mode 100644\nindex 000000000000..33b2c050e534\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/limit_sorted.cpp\n@@ -0,0 +1,51 @@\n+#include \"limit_sorted.h\"\n+\n+namespace NKikimr::NOlap::NReader::NSimple {\n+\n+std::shared_ptr<IDataSource> TScanWithLimitCollection::DoExtractNext() {\n+    AFL_VERIFY(HeapSources.size());\n+    std::pop_heap(HeapSources.begin(), HeapSources.end());\n+    auto result = NextSource ? NextSource : HeapSources.back().Construct(SourceIdxCurrent++, Context);\n+    AFL_VERIFY(FetchingInFlightSources.emplace(result->GetSourceId()).second);\n+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"DoExtractNext\")(\"source_id\", result->GetSourceId());\n+    HeapSources.pop_back();\n+    if (HeapSources.size()) {\n+        NextSource = HeapSources.front().Construct(SourceIdxCurrent++, Context);\n+    } else {\n+        NextSource = nullptr;\n+    }\n+    return result;\n+}\n+\n+void TScanWithLimitCollection::DoOnSourceFinished(const std::shared_ptr<IDataSource>& source) {\n+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"DoOnSourceFinished\")(\"source_id\", source->GetSourceId())(\"limit\", Limit)(\n+        \"max\", GetMaxInFlight())(\"in_flight_limit\", InFlightLimit)(\"count\", FetchingInFlightSources.size());\n+    if (!source->GetResultRecordsCount() && InFlightLimit < GetMaxInFlight()) {\n+        InFlightLimit = 2 * InFlightLimit;\n+    }\n+    AFL_VERIFY(Cleared || Aborted || FetchingInFlightSources.erase(source->GetSourceId()))(\"source_id\", source->GetSourceId());\n+}\n+\n+TScanWithLimitCollection::TScanWithLimitCollection(\n+    const std::shared_ptr<TSpecialReadContext>& context, std::deque<TSourceConstructor>&& sources, const std::shared_ptr<IScanCursor>& cursor)\n+    : TBase(context)\n+    , Limit((ui64)Context->GetCommonContext()->GetReadMetadata()->GetLimitRobust()) {\n+    HeapSources = std::move(sources);\n+    std::make_heap(HeapSources.begin(), HeapSources.end());\n+    if (cursor && cursor->IsInitialized()) {\n+        while (HeapSources.size()) {\n+            bool usage = false;\n+            if (!context->GetCommonContext()->GetScanCursor()->CheckEntityIsBorder(HeapSources.front(), usage)) {\n+                std::pop_heap(HeapSources.begin(), HeapSources.end());\n+                HeapSources.pop_back();\n+                continue;\n+            }\n+            if (usage) {\n+                HeapSources.front().SetIsStartedByCursor();\n+            }\n+            break;\n+        }\n+    }\n+}\n+\n+}   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/limit_sorted.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/limit_sorted.h\nnew file mode 100644\nindex 000000000000..e04b1059645b\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/limit_sorted.h\n@@ -0,0 +1,79 @@\n+#pragma once\n+#include \"abstract.h\"\n+\n+#include <ydb/library/accessor/positive_integer.h>\n+\n+namespace NKikimr::NOlap::NReader::NSimple {\n+\n+class TScanWithLimitCollection: public ISourcesCollection {\n+private:\n+    using TBase = ISourcesCollection;\n+    class TFinishedDataSource {\n+    private:\n+        YDB_READONLY(ui32, RecordsCount, 0);\n+        YDB_READONLY(ui32, SourceId, 0);\n+        YDB_READONLY(ui32, SourceIdx, 0);\n+\n+    public:\n+        TFinishedDataSource(const std::shared_ptr<IDataSource>& source)\n+            : RecordsCount(source->GetResultRecordsCount())\n+            , SourceId(source->GetSourceId())\n+            , SourceIdx(source->GetSourceIdx()) {\n+        }\n+\n+        TFinishedDataSource(const std::shared_ptr<IDataSource>& source, const ui32 partSize)\n+            : RecordsCount(partSize)\n+            , SourceId(source->GetSourceId())\n+            , SourceIdx(source->GetSourceIdx()) {\n+            AFL_VERIFY(partSize < source->GetResultRecordsCount());\n+        }\n+    };\n+\n+    virtual bool DoHasData() const override {\n+        return HeapSources.size();\n+    }\n+    ui32 SourceIdxCurrent = 0;\n+    std::shared_ptr<IDataSource> NextSource;\n+    std::deque<TSourceConstructor> HeapSources;\n+    ui64 Limit = 0;\n+    ui64 InFlightLimit = 1;\n+    std::set<ui32> FetchingInFlightSources;\n+    bool Aborted = false;\n+    bool Cleared = false;\n+\n+    void DrainToLimit();\n+\n+    virtual std::shared_ptr<IScanCursor> DoBuildCursor(const std::shared_ptr<IDataSource>& source, const ui32 readyRecords) const override {\n+        return std::make_shared<TSimpleScanCursor>(nullptr, source->GetSourceId(), readyRecords);\n+    }\n+    virtual void DoClear() override {\n+        Cleared = true;\n+        HeapSources.clear();\n+        FetchingInFlightSources.clear();\n+    }\n+    virtual void DoAbort() override {\n+        Aborted = true;\n+        HeapSources.clear();\n+        FetchingInFlightSources.clear();\n+    }\n+    virtual bool DoIsFinished() const override {\n+        return HeapSources.empty() && FetchingInFlightSources.empty();\n+    }\n+    virtual std::shared_ptr<IDataSource> DoExtractNext() override;\n+    virtual bool DoCheckInFlightLimits() const override {\n+        return FetchingInFlightSources.size() < InFlightLimit;\n+    }\n+\n+    virtual void DoOnSourceFinished(const std::shared_ptr<IDataSource>& source) override;\n+    ui32 GetInFlightIntervalsCount(const TCompareKeyForScanSequence& from, const TCompareKeyForScanSequence& to) const;\n+\n+public:\n+    const std::shared_ptr<IDataSource>& GetNextSource() const {\n+        return NextSource;\n+    }\n+\n+    TScanWithLimitCollection(const std::shared_ptr<TSpecialReadContext>& context, std::deque<TSourceConstructor>&& sources,\n+        const std::shared_ptr<IScanCursor>& cursor);\n+};\n+\n+}   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/not_sorted.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/not_sorted.cpp\nnew file mode 100644\nindex 000000000000..8962f0263340\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/not_sorted.cpp\n@@ -0,0 +1,10 @@\n+#include \"not_sorted.h\"\n+\n+namespace NKikimr::NOlap::NReader::NSimple {\n+\n+    std::shared_ptr<NKikimr::NOlap::IScanCursor> TNotSortedCollection::DoBuildCursor(\n+    const std::shared_ptr<IDataSource>& source, const ui32 readyRecords) const {\n+    return std::make_shared<TNotSortedSimpleScanCursor>(source->GetSourceId(), readyRecords);\n+}\n+\n+}   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/not_sorted.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/not_sorted.h\nnew file mode 100644\nindex 000000000000..45b855d9db0e\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/not_sorted.h\n@@ -0,0 +1,78 @@\n+#pragma once\n+#include \"abstract.h\"\n+\n+namespace NKikimr::NOlap::NReader::NSimple {\n+\n+class TNotSortedCollection: public ISourcesCollection {\n+private:\n+    using TBase = ISourcesCollection;\n+    std::optional<ui32> Limit;\n+    ui32 InFlightLimit = 1;\n+    std::deque<TSourceConstructor> Sources;\n+    TPositiveControlInteger InFlightCount;\n+    ui32 FetchedCount = 0;\n+    ui32 SourceIdx = 0;\n+    virtual bool DoHasData() const override {\n+        return Sources.size();\n+    }\n+    virtual void DoClear() override {\n+        Sources.clear();\n+    }\n+    virtual void DoAbort() override {\n+        Sources.clear();\n+    }\n+\n+    virtual std::shared_ptr<IScanCursor> DoBuildCursor(const std::shared_ptr<IDataSource>& source, const ui32 readyRecords) const override;\n+    virtual bool DoIsFinished() const override {\n+        return Sources.empty();\n+    }\n+    virtual std::shared_ptr<IDataSource> DoExtractNext() override {\n+        AFL_VERIFY(Sources.size());\n+        auto result = Sources.front().Construct(SourceIdx++, Context);\n+        Sources.pop_front();\n+        InFlightCount.Inc();\n+        return result;\n+    }\n+    virtual bool DoCheckInFlightLimits() const override {\n+        return InFlightCount < InFlightLimit;\n+    }\n+    virtual void DoOnSourceFinished(const std::shared_ptr<IDataSource>& source) override {\n+        if (!source->GetResultRecordsCount() && InFlightLimit * 2 < GetMaxInFlight()) {\n+            InFlightLimit *= 2;\n+        }\n+        FetchedCount += source->GetResultRecordsCount();\n+        if (Limit && *Limit <= FetchedCount && Sources.size()) {\n+            AFL_NOTICE(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"limit_exhausted\")(\"limit\", Limit)(\"fetched\", FetchedCount);\n+            Sources.clear();\n+        }\n+        InFlightCount.Dec();\n+    }\n+\n+public:\n+    TNotSortedCollection(const std::shared_ptr<TSpecialReadContext>& context, std::deque<TSourceConstructor>&& sources,\n+        const std::shared_ptr<IScanCursor>& cursor, const std::optional<ui32> limit)\n+        : TBase(context)\n+        , Limit(limit) {\n+        if (Limit) {\n+            InFlightLimit = 1;\n+        } else {\n+            InFlightLimit = GetMaxInFlight();\n+        }\n+        if (cursor && cursor->IsInitialized()) {\n+            while (sources.size()) {\n+                bool usage = false;\n+                if (!context->GetCommonContext()->GetScanCursor()->CheckEntityIsBorder(sources.front(), usage)) {\n+                    sources.pop_front();\n+                    continue;\n+                }\n+                if (usage) {\n+                    sources.front().SetIsStartedByCursor();\n+                }\n+                break;\n+            }\n+        }\n+        Sources = std::move(sources);\n+    }\n+};\n+\n+}   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/ya.make b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/ya.make\nnew file mode 100644\nindex 000000000000..640e7bbbe839\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/ya.make\n@@ -0,0 +1,14 @@\n+LIBRARY()\n+\n+SRCS(\n+    abstract.cpp\n+    not_sorted.cpp\n+    full_scan_sorted.cpp\n+    limit_sorted.cpp\n+)\n+\n+PEERDIR(\n+    ydb/core/formats/arrow\n+)\n+\n+END()\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.cpp\nindex edd0fc45092a..59f3601bf55e 100644\n--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.cpp\n@@ -11,11 +11,11 @@ std::shared_ptr<TFetchingScript> TSpecialReadContext::DoGetColumnsFetchingPlan(c\n     const bool needSnapshots = GetReadMetadata()->GetRequestSnapshot() < source->GetRecordSnapshotMax();\n     const bool dontNeedColumns = !needSnapshots && GetFFColumns()->GetColumnIds().size() == 1 &&\n                                  GetFFColumns()->GetColumnIds().contains(NOlap::NPortion::TSpecialColumns::SPEC_COL_PLAN_STEP_INDEX);\n-    if (!dontNeedColumns && !source->GetStageData().HasPortionAccessor()) {\n+    if (!dontNeedColumns && !source->HasStageData()) {\n         if (!AskAccumulatorsScript) {\n             NCommon::TFetchingScriptBuilder acc(*this);\n-            acc.AddStep(std::make_shared<NCommon::TAllocateMemoryStep>\n-                (source->PredictAccessorsSize(GetFFColumns()->GetColumnIds()), EStageFeaturesIndexes::Accessors));\n+            acc.AddStep(std::make_shared<NCommon::TAllocateMemoryStep>(\n+                source->PredictAccessorsSize(GetFFColumns()->GetColumnIds()), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Accessors));\n             acc.AddStep(std::make_shared<TPortionAccessorFetchingStep>());\n             acc.AddStep(std::make_shared<TDetectInMem>(*GetFFColumns()));\n             AskAccumulatorsScript = std::move(acc).Build();\n@@ -64,31 +64,31 @@ std::shared_ptr<TFetchingScript> TSpecialReadContext::BuildColumnsFetchingPlan(c\n     NCommon::TFetchingScriptBuilder acc(*this);\n     if (needFilterSharding && !GetShardingColumns()->IsEmpty()) {\n         const TColumnsSetIds columnsFetch = *GetShardingColumns();\n-        acc.AddFetchingStep(columnsFetch, EStageFeaturesIndexes::Filter);\n-        acc.AddAssembleStep(columnsFetch, \"SPEC_SHARDING\", EStageFeaturesIndexes::Filter, false);\n+        acc.AddFetchingStep(columnsFetch, NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);\n+        acc.AddAssembleStep(columnsFetch, \"SPEC_SHARDING\", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);\n         acc.AddStep(std::make_shared<TShardingFilter>());\n     }\n     {\n         acc.SetBranchName(\"exclusive\");\n         if (needFilterDeletion) {\n-            acc.AddFetchingStep(*GetDeletionColumns(), EStageFeaturesIndexes::Filter);\n+            acc.AddFetchingStep(*GetDeletionColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);\n         }\n         if (partialUsageByPredicate) {\n-            acc.AddFetchingStep(*GetPredicateColumns(), EStageFeaturesIndexes::Filter);\n+            acc.AddFetchingStep(*GetPredicateColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);\n         }\n         if (needSnapshots || GetFFColumns()->Cross(*GetSpecColumns())) {\n-            acc.AddFetchingStep(*GetSpecColumns(), EStageFeaturesIndexes::Filter);\n+            acc.AddFetchingStep(*GetSpecColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);\n         }\n         if (needFilterDeletion) {\n-            acc.AddAssembleStep(*GetDeletionColumns(), \"SPEC_DELETION\", EStageFeaturesIndexes::Filter, false);\n+            acc.AddAssembleStep(*GetDeletionColumns(), \"SPEC_DELETION\", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);\n             acc.AddStep(std::make_shared<TDeletionFilter>());\n         }\n         if (partialUsageByPredicate) {\n-            acc.AddAssembleStep(*GetPredicateColumns(), \"PREDICATE\", EStageFeaturesIndexes::Filter, false);\n+            acc.AddAssembleStep(*GetPredicateColumns(), \"PREDICATE\", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);\n             acc.AddStep(std::make_shared<TPredicateFilter>());\n         }\n         if (needSnapshots || GetFFColumns()->Cross(*GetSpecColumns())) {\n-            acc.AddAssembleStep(*GetSpecColumns(), \"SPEC\", EStageFeaturesIndexes::Filter, false);\n+            acc.AddAssembleStep(*GetSpecColumns(), \"SPEC\", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);\n             acc.AddStep(std::make_shared<TSnapshotFilter>());\n         }\n         const auto& chainProgram = GetReadMetadata()->GetProgram().GetChainVerified();\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.h\nindex f4e3d0ab36c3..c1859a3062d7 100644\n--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.h\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.h\n@@ -12,7 +12,6 @@ namespace NKikimr::NOlap::NReader::NSimple {\n \n class IDataSource;\n using TColumnsSet = NCommon::TColumnsSet;\n-using EStageFeaturesIndexes = NCommon::EStageFeaturesIndexes;\n using TColumnsSetIds = NCommon::TColumnsSetIds;\n using EMemType = NCommon::EMemType;\n using TFetchingScript = NCommon::TFetchingScript;\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/fetching.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/fetching.cpp\nindex bd787e135ff3..7d82fa672338 100644\n--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/fetching.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/fetching.cpp\n@@ -22,9 +22,10 @@ ui64 IFetchingStep::GetProcessingDataSize(const std::shared_ptr<NCommon::IDataSo\n \n TConclusion<bool> TPredicateFilter::DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& /*step*/) const {\n     auto filter = source->GetContext()->GetReadMetadata()->GetPKRangesFilter().BuildFilter(\n-        source->GetStageData().GetTable()->ToTable(source->GetContext()->GetReadMetadata()->GetPKRangesFilter().GetColumnIds(\n-                                                       source->GetContext()->GetReadMetadata()->GetResultSchema()->GetIndexInfo()),\n-            source->GetContext()->GetCommonContext()->GetResolver(), true));\n+        source->GetStageData().GetTable()->ToGeneralContainer(source->GetContext()->GetCommonContext()->GetResolver(),\n+            source->GetContext()->GetReadMetadata()->GetPKRangesFilter().GetColumnIds(\n+                source->GetContext()->GetReadMetadata()->GetResultSchema()->GetIndexInfo()),\n+            true));\n     source->MutableStageData().AddFilter(filter);\n     return true;\n }\n@@ -99,7 +100,7 @@ TConclusion<bool> TDetectInMem::DoExecuteInplace(const std::shared_ptr<IDataSour\n     source->InitFetchingPlan(plan);\n     TFetchingScriptCursor cursor(plan, 0);\n     FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, source->AddEvent(\"sdmem\"));\n-    auto task = std::make_shared<TStepAction>(source, std::move(cursor), source->GetContext()->GetCommonContext()->GetScanActorId());\n+    auto task = std::make_shared<TStepAction>(source, std::move(cursor), source->GetContext()->GetCommonContext()->GetScanActorId(), false);\n     NConveyor::TScanServiceOperator::SendTaskToExecute(task);\n     return false;\n }\n@@ -108,25 +109,19 @@ namespace {\n class TApplySourceResult: public IDataTasksProcessor::ITask {\n private:\n     using TBase = IDataTasksProcessor::ITask;\n-    YDB_READONLY_DEF(std::shared_ptr<arrow::Table>, Result);\n     YDB_READONLY_DEF(std::shared_ptr<IDataSource>, Source);\n-    YDB_READONLY(ui32, StartIndex, 0);\n-    YDB_READONLY(ui32, OriginalRecordsCount, 0);\n     NColumnShard::TCounterGuard Guard;\n     TFetchingScriptCursor Step;\n \n public:\n-    TString GetTaskClassIdentifier() const override {\n+    virtual TString GetTaskClassIdentifier() const override {\n         return \"TApplySourceResult\";\n     }\n \n-    TApplySourceResult(const std::shared_ptr<IDataSource>& source, std::shared_ptr<arrow::Table>&& result, const ui32 startIndex,\n-        const ui32 originalRecordsCount, const TFetchingScriptCursor& step)\n+    TApplySourceResult(\n+        const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step)\n         : TBase(NActors::TActorId())\n-        , Result(result)\n         , Source(source)\n-        , StartIndex(startIndex)\n-        , OriginalRecordsCount(originalRecordsCount)\n         , Guard(source->GetContext()->GetCommonContext()->GetCounters().GetResultsForSourceGuard())\n         , Step(step) {\n     }\n@@ -137,9 +132,9 @@ class TApplySourceResult: public IDataTasksProcessor::ITask {\n     }\n     virtual bool DoApply(IDataReader& indexedDataRead) const override {\n         auto* plainReader = static_cast<TPlainReadData*>(&indexedDataRead);\n-        auto resultCopy = Result;\n         Source->SetCursor(Step);\n-        plainReader->MutableScanner().OnSourceReady(Source, std::move(resultCopy), StartIndex, OriginalRecordsCount, *plainReader);\n+        Source->StartSyncSection();\n+        plainReader->MutableScanner().GetResultSyncPoint()->OnSourcePrepared(Source, *plainReader);\n         return true;\n     }\n };\n@@ -155,40 +150,55 @@ TConclusion<bool> TBuildResultStep::DoExecuteInplace(const std::shared_ptr<IData\n         AFL_VERIFY(StartIndex == 0);\n         AFL_VERIFY(RecordsCount == source->GetRecordsCount())(\"records_count\", RecordsCount)(\"source\", source->GetRecordsCount());\n     }\n+    contextTableConstruct.SetFilter(source->GetStageResult().GetNotAppliedFilter());\n     std::shared_ptr<arrow::Table> resultBatch;\n     if (!source->GetStageResult().IsEmpty()) {\n         resultBatch = source->GetStageResult().GetBatch()->BuildTableVerified(contextTableConstruct);\n-        if (auto filter = source->GetStageResult().GetNotAppliedFilter()) {\n-            AFL_VERIFY(filter->Apply(resultBatch, NArrow::TColumnFilter::TApplyContext(StartIndex, RecordsCount).SetTrySlices(true)));\n+        if (!resultBatch->num_rows()) {\n+            resultBatch = nullptr;\n         }\n     }\n-\n+    const ui32 recordsCount = resultBatch ? resultBatch->num_rows() : 0;\n+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"TBuildResultStep\")(\"source_id\", source->GetSourceId())(\"count\", recordsCount);\n+    context->GetCommonContext()->GetCounters().OnSourceFinished(source->GetRecordsCount(), source->GetUsedRawBytes(), recordsCount);\n+    source->MutableResultRecordsCount() += recordsCount;\n+    if (!resultBatch || !resultBatch->num_rows()) {\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"empty_source\", source->DebugJson().GetStringRobust());\n+    }\n+    source->MutableStageResult().SetResultChunk(std::move(resultBatch), StartIndex, RecordsCount);\n     NActors::TActivationContext::AsActorContext().Send(context->GetCommonContext()->GetScanActorId(),\n-        new NColumnShard::TEvPrivate::TEvTaskProcessedResult(\n-            std::make_shared<TApplySourceResult>(source, std::move(resultBatch), StartIndex, RecordsCount, step)));\n+        new NColumnShard::TEvPrivate::TEvTaskProcessedResult(std::make_shared<TApplySourceResult>(source, step)));\n     return false;\n }\n \n TConclusion<bool> TPrepareResultStep::DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& /*step*/) const {\n-    NCommon::TFetchingScriptBuilder acc(*source->GetContext());\n+    const auto context = source->GetContext();\n+    NCommon::TFetchingScriptBuilder acc(*context);\n     if (source->IsSourceInMemory()) {\n         AFL_VERIFY(source->GetStageResult().GetPagesToResultVerified().size() == 1);\n     }\n+    AFL_VERIFY(!source->GetStageResult().IsEmpty());\n     for (auto&& i : source->GetStageResult().GetPagesToResultVerified()) {\n-        if (source->GetIsStartedByCursor() && !source->GetContext()->GetCommonContext()->GetScanCursor()->CheckSourceIntervalUsage(\n+        if (source->GetIsStartedByCursor() && !context->GetCommonContext()->GetScanCursor()->CheckSourceIntervalUsage(\n                                                   source->GetSourceId(), i.GetIndexStart(), i.GetRecordsCount())) {\n+            AFL_WARN(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"TPrepareResultStep_ResultStep_SKIP_CURSOR\")(\"source_id\", source->GetSourceId());\n             continue;\n+        } else {\n+            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"TPrepareResultStep_ResultStep\")(\"source_id\", source->GetSourceId());\n         }\n         acc.AddStep(std::make_shared<TBuildResultStep>(i.GetIndexStart(), i.GetRecordsCount()));\n     }\n     auto plan = std::move(acc).Build();\n     AFL_VERIFY(!plan->IsFinished(0));\n     source->InitFetchingPlan(plan);\n-\n-    TFetchingScriptCursor cursor(plan, 0);\n-    auto task = std::make_shared<TStepAction>(source, std::move(cursor), source->GetContext()->GetCommonContext()->GetScanActorId());\n-    NConveyor::TScanServiceOperator::SendTaskToExecute(task);\n-    return false;\n+    if (source->NeedFullAnswer()) {\n+        TFetchingScriptCursor cursor(plan, 0);\n+        auto task = std::make_shared<TStepAction>(source, std::move(cursor), context->GetCommonContext()->GetScanActorId(), false);\n+        NConveyor::TScanServiceOperator::SendTaskToExecute(task);\n+        return false;\n+    } else {\n+        return true;\n+    }\n }\n \n }   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/fetching.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/fetching.h\nindex 0a62e6c0a593..d1dcc822b035 100644\n--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/fetching.h\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/fetching.h\n@@ -15,7 +15,6 @@ namespace NKikimr::NOlap::NReader::NSimple {\n class IDataSource;\n using TColumnsSet = NCommon::TColumnsSet;\n using TIndexesSet = NCommon::TIndexesSet;\n-using EStageFeaturesIndexes = NCommon::EStageFeaturesIndexes;\n using TColumnsSetIds = NCommon::TColumnsSetIds;\n using EMemType = NCommon::EMemType;\n using TFetchingScriptCursor = NCommon::TFetchingScriptCursor;\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.cpp\nindex 485956208185..898c6f92c5db 100644\n--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.cpp\n@@ -8,7 +8,7 @@ TPlainReadData::TPlainReadData(const std::shared_ptr<TReadContext>& context)\n     : TBase(context)\n     , SpecialReadContext(std::make_shared<TSpecialReadContext>(context)) {\n     ui32 sourceIdx = 0;\n-    std::deque<std::shared_ptr<IDataSource>> sources;\n+    std::deque<TSourceConstructor> sources;\n     const auto& portions = GetReadMetadata()->SelectInfo->Portions;\n     ui64 compactedPortionsBytes = 0;\n     ui64 insertedPortionsBytes = 0;\n@@ -19,9 +19,8 @@ TPlainReadData::TPlainReadData(const std::shared_ptr<TReadContext>& context)\n             insertedPortionsBytes += i->GetTotalBlobBytes();\n         }\n \n-        sources.emplace_back(std::make_shared<TPortionDataSource>(sourceIdx++, i, SpecialReadContext));\n+        sources.emplace_back(TSourceConstructor(sourceIdx++, i, context));\n     }\n-    std::sort(sources.begin(), sources.end(), IDataSource::TCompareStartForScanSequence());\n     Scanner = std::make_shared<TScanHead>(std::move(sources), SpecialReadContext);\n \n     auto& stats = GetReadMetadata()->ReadStats;\n@@ -58,4 +57,11 @@ void TPlainReadData::OnIntervalResult(const std::shared_ptr<TPartialReadResult>&\n     PartialResults.emplace_back(result);\n }\n \n+void TPlainReadData::OnSentDataFromInterval(const TPartialSourceAddress& sourceAddress) {\n+    if (!SpecialReadContext->IsActive()) {\n+        return;\n+    }\n+    Scanner->GetSyncPoint(sourceAddress.GetSyncPointIndex())->Continue(sourceAddress, *this);\n+}\n+\n }   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.h\nindex adfe861d6319..19c8e14acedf 100644\n--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.h\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.h\n@@ -60,12 +60,7 @@ class TPlainReadData: public IDataReader, TNonCopyable, NColumnShard::TMonitorin\n     TScanHead& MutableScanner() {\n         return *Scanner;\n     }\n-    virtual void OnSentDataFromInterval(const ui32 sourceIdx) const override {\n-        if (!SpecialReadContext->IsActive()) {\n-            return;\n-        }\n-        Scanner->ContinueSource(sourceIdx);\n-    }\n+    virtual void OnSentDataFromInterval(const TPartialSourceAddress& sourceAddress) override;\n \n     void OnIntervalResult(const std::shared_ptr<TPartialReadResult>& result);\n \ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/scanner.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/scanner.cpp\nindex fd0bbde7b3ea..94602e987849 100644\n--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/scanner.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/scanner.cpp\n@@ -1,6 +1,12 @@\n #include \"plain_read_data.h\"\n #include \"scanner.h\"\n \n+#include \"collections/full_scan_sorted.h\"\n+#include \"collections/limit_sorted.h\"\n+#include \"collections/not_sorted.h\"\n+#include \"sync_points/limit.h\"\n+#include \"sync_points/result.h\"\n+\n #include <ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.h>\n #include <ydb/core/tx/columnshard/engines/reader/common/result.h>\n \n@@ -8,158 +14,39 @@\n \n namespace NKikimr::NOlap::NReader::NSimple {\n \n-void TScanHead::OnSourceReady(const std::shared_ptr<IDataSource>& source, std::shared_ptr<arrow::Table>&& tableExt, const ui32 startIndex,\n-    const ui32 recordsCount, TPlainReadData& reader) {\n-    FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, source->AddEvent(\"f\"));\n-    AFL_DEBUG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG)(\"event_log\", source->GetEventsReport())(\"count\", FetchingSources.size());\n-    source->MutableResultRecordsCount() += tableExt ? tableExt->num_rows() : 0;\n-    if (!tableExt || !tableExt->num_rows()) {\n-        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"empty_source\", source->DebugJson().GetStringRobust());\n-    }\n-    Context->GetCommonContext()->GetCounters().OnSourceFinished(\n-        source->GetRecordsCount(), source->GetUsedRawBytes(), tableExt ? tableExt->num_rows() : 0);\n-\n-    source->MutableStageResult().SetResultChunk(std::move(tableExt), startIndex, recordsCount);\n-    if (source->GetStageResult().IsFinished()) {\n-        SourcesInFlightCount.Dec();\n-    }\n-    while (FetchingSources.size()) {\n-        auto frontSource = FetchingSources.front();\n-        if (!frontSource->HasStageResult()) {\n-            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"skip_no_result\")(\"source_id\", frontSource->GetSourceId())(\n-                \"source_idx\", frontSource->GetSourceIdx());\n-            break;\n-        }\n-        if (!frontSource->GetStageResult().HasResultChunk()) {\n-            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"skip_no_result_chunk\")(\"source_id\", frontSource->GetSourceId())(\n-                \"source_idx\", frontSource->GetSourceIdx());\n-            break;\n-        }\n-        auto table = frontSource->MutableStageResult().ExtractResultChunk();\n-        const bool isFinished = frontSource->GetStageResult().IsFinished();\n-        std::optional<ui32> sourceIdxToContinue;\n-        if (!isFinished) {\n-            sourceIdxToContinue = frontSource->GetSourceIdx();\n-        }\n-        if (table && table->num_rows()) {\n-            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"has_result\")(\"source_id\", frontSource->GetSourceId())(\n-                \"source_idx\", frontSource->GetSourceIdx())(\"table\", table->num_rows());\n-            auto cursor =\n-                std::make_shared<TSimpleScanCursor>(frontSource->GetStartPKRecordBatch(), frontSource->GetSourceId(), startIndex + recordsCount);\n-            reader.OnIntervalResult(std::make_shared<TPartialReadResult>(frontSource->GetResourceGuards(), frontSource->GetGroupGuard(), table,\n-                cursor, Context->GetCommonContext(), sourceIdxToContinue));\n-        } else if (sourceIdxToContinue) {\n-            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"continue_source\")(\"source_id\", frontSource->GetSourceId())(\n-                \"source_idx\", frontSource->GetSourceIdx());\n-            ContinueSource(*sourceIdxToContinue);\n-            break;\n-        }\n-        if (!isFinished) {\n-            break;\n-        }\n-        AFL_VERIFY(FetchingSourcesByIdx.erase(frontSource->GetSourceIdx()));\n-        FetchingSources.pop_front();\n-        frontSource->ClearResult();\n-        if (Context->GetCommonContext()->GetReadMetadata()->HasLimit()) {\n-            AFL_VERIFY(FetchingInFlightSources.erase(TCompareKeyForScanSequence::FromFinish(frontSource)));\n-            AFL_VERIFY(FinishedSources.emplace(TCompareKeyForScanSequence::FromFinish(frontSource), frontSource).second);\n-            while (FinishedSources.size() &&\n-                   (SortedSources.empty() || FinishedSources.begin()->second->GetFinish() < SortedSources.front()->GetStart())) {\n-                auto finishedSource = FinishedSources.begin()->second;\n-                if (!finishedSource->GetResultRecordsCount() && InFlightLimit < MaxInFlight) {\n-                    InFlightLimit = 2 * InFlightLimit;\n-                }\n-                FetchedCount += finishedSource->GetResultRecordsCount();\n-                FinishedSources.erase(FinishedSources.begin());\n-                if (Context->IsActive()) {\n-                    --IntervalsInFlightCount;\n-                }\n-                AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"source_finished\")(\"source_id\", finishedSource->GetSourceId())(\n-                    \"source_idx\", finishedSource->GetSourceIdx())(\"limit\", Context->GetCommonContext()->GetReadMetadata()->GetLimitRobust())(\n-                    \"fetched\", finishedSource->GetResultRecordsCount());\n-                if (FetchedCount > (ui64)Context->GetCommonContext()->GetReadMetadata()->GetLimitRobust() && SortedSources.size()) {\n-                    AFL_NOTICE(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"limit_exhausted\")(\n-                        \"limit\", Context->GetCommonContext()->GetReadMetadata()->GetLimitRobust())(\"fetched\", FetchedCount);\n-                    SortedSources.clear();\n-                    IntervalsInFlightCount = GetInFlightIntervalsCount();\n-                }\n-            }\n-        }\n-    }\n-}\n-\n TConclusionStatus TScanHead::Start() {\n-    for (auto&& i : SortedSources) {\n-        i->InitFetchingPlan(Context->GetColumnsFetchingPlan(i));\n-    }\n     return TConclusionStatus::Success();\n }\n \n-TScanHead::TScanHead(std::deque<std::shared_ptr<IDataSource>>&& sources, const std::shared_ptr<TSpecialReadContext>& context)\n+TScanHead::TScanHead(std::deque<TSourceConstructor>&& sources, const std::shared_ptr<TSpecialReadContext>& context)\n     : Context(context) {\n-    if (HasAppData() && AppDataVerified().ColumnShardConfig.HasMaxInFlightIntervalsOnRequest()) {\n-        MaxInFlight = AppDataVerified().ColumnShardConfig.GetMaxInFlightIntervalsOnRequest();\n-    }\n-    if (Context->GetReadMetadata()->HasLimit()) {\n-        InFlightLimit = 1;\n+    if (Context->GetReadMetadata()->IsSorted()) {\n+        if (Context->GetReadMetadata()->HasLimit()) {\n+            auto collection =\n+                std::make_shared<TScanWithLimitCollection>(Context, std::move(sources), context->GetCommonContext()->GetScanCursor());\n+            SourcesCollection = collection;\n+            SyncPoints.emplace_back(std::make_shared<TSyncPointLimitControl>(\n+                (ui64)Context->GetCommonContext()->GetReadMetadata()->GetLimitRobust(), SyncPoints.size(), context, collection));\n+        } else {\n+            SourcesCollection =\n+                std::make_shared<TSortedFullScanCollection>(Context, std::move(sources), context->GetCommonContext()->GetScanCursor());\n+        }\n     } else {\n-        InFlightLimit = MaxInFlight;\n+        SourcesCollection = std::make_shared<TNotSortedCollection>(\n+            Context, std::move(sources), context->GetCommonContext()->GetScanCursor(), Context->GetReadMetadata()->GetLimitRobustOptional());\n     }\n-    bool started = !context->GetCommonContext()->GetScanCursor()->IsInitialized();\n-    for (auto&& i : sources) {\n-        if (!started) {\n-            bool usage = false;\n-            if (!context->GetCommonContext()->GetScanCursor()->CheckEntityIsBorder(i, usage)) {\n-                continue;\n-            }\n-            started = true;\n-            if (!usage) {\n-                continue;\n-            }\n-            i->SetIsStartedByCursor();\n-        }\n-        SortedSources.emplace_back(i);\n+    SyncPoints.emplace_back(std::make_shared<TSyncPointResult>(SyncPoints.size(), context, SourcesCollection));\n+    for (ui32 i = 0; i + 1 < SyncPoints.size(); ++i) {\n+        SyncPoints[i]->SetNext(SyncPoints[i + 1]);\n     }\n }\n \n TConclusion<bool> TScanHead::BuildNextInterval() {\n-    if (!Context->IsActive()) {\n-        return false;\n-    }\n-    if (SortedSources.size() == 0) {\n-        return false;\n-    }\n     bool changed = false;\n-    if (!Context->GetCommonContext()->GetReadMetadata()->HasLimit()) {\n-        while (SortedSources.size() && SourcesInFlightCount.Val() < InFlightLimit && Context->IsActive()) {\n-            FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, SortedSources.front()->AddEvent(\"f\"));\n-            SortedSources.front()->StartProcessing(SortedSources.front());\n-            FetchingSources.emplace_back(SortedSources.front());\n-            SourcesInFlightCount.Inc();\n-            AFL_VERIFY(FetchingSourcesByIdx.emplace(SortedSources.front()->GetSourceIdx(), SortedSources.front()).second);\n-            SortedSources.pop_front();\n-            changed = true;\n-        }\n-    } else {\n-        if (InFlightLimit <= IntervalsInFlightCount) {\n-            return false;\n-        }\n-        ui32 inFlightCountLocal = GetInFlightIntervalsCount();\n-        AFL_VERIFY(IntervalsInFlightCount == inFlightCountLocal)(\"count_global\", IntervalsInFlightCount)(\"count_local\", inFlightCountLocal);\n-        while (SortedSources.size() && inFlightCountLocal < InFlightLimit && Context->IsActive()) {\n-            FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, SortedSources.front()->AddEvent(\"f\"));\n-            SortedSources.front()->StartProcessing(SortedSources.front());\n-            FetchingSources.emplace_back(SortedSources.front());\n-            SourcesInFlightCount.Inc();\n-            AFL_VERIFY(FetchingSourcesByIdx.emplace(SortedSources.front()->GetSourceIdx(), SortedSources.front()).second);\n-            AFL_VERIFY(FetchingInFlightSources.emplace(TCompareKeyForScanSequence::FromFinish(SortedSources.front()), SortedSources.front()).second);\n-            SortedSources.pop_front();\n-            const ui32 inFlightCountLocalNew = GetInFlightIntervalsCount();\n-            AFL_VERIFY(inFlightCountLocal <= inFlightCountLocalNew);\n-            inFlightCountLocal = inFlightCountLocalNew;\n-            changed = true;\n-        }\n-        IntervalsInFlightCount = inFlightCountLocal;\n+    while (SourcesCollection->HasData() && SourcesCollection->CheckInFlightLimits()) {\n+        auto source = SourcesCollection->ExtractNext();\n+        SyncPoints.front()->AddSource(source);\n+        changed = true;\n     }\n     return changed;\n }\n@@ -174,35 +61,15 @@ bool TScanHead::IsReverse() const {\n \n void TScanHead::Abort() {\n     AFL_VERIFY(!Context->IsActive());\n-    for (auto&& i : FetchingSources) {\n+    for (auto&& i : SyncPoints) {\n         i->Abort();\n     }\n-    for (auto&& i : SortedSources) {\n-        i->Abort();\n-    }\n-    FetchingSources.clear();\n-    SortedSources.clear();\n+    SourcesCollection->Abort();\n     Y_ABORT_UNLESS(IsFinished());\n }\n \n TScanHead::~TScanHead() {\n-    AFL_VERIFY(!IntervalsInFlightCount || !Context->IsActive());\n-}\n-\n-ui32 TScanHead::GetInFlightIntervalsCount() const {\n-    if (SortedSources.empty()) {\n-        return FetchingInFlightSources.size() + FinishedSources.size();\n-    }\n-    ui32 inFlightCountLocal = 0;\n-    auto itUpperFinished = FinishedSources.upper_bound(TCompareKeyForScanSequence::BorderStart(SortedSources.front()));\n-    for (auto&& it = FinishedSources.begin(); it != itUpperFinished; ++it) {\n-        ++inFlightCountLocal;\n-    }\n-    auto itUpperFetching = FetchingInFlightSources.upper_bound(TCompareKeyForScanSequence::BorderStart(SortedSources.front()));\n-    for (auto&& it = FetchingInFlightSources.begin(); it != itUpperFetching; ++it) {\n-        ++inFlightCountLocal;\n-    }\n-    return inFlightCountLocal;\n+    AFL_VERIFY(IsFinished() || !Context->IsActive());\n }\n \n }   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/scanner.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/scanner.h\nindex 02315e54957f..c505433c14b7 100644\n--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/scanner.h\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/scanner.h\n@@ -1,5 +1,9 @@\n #pragma once\n #include \"source.h\"\n+\n+#include \"collections/abstract.h\"\n+#include \"sync_points/abstract.h\"\n+\n #include <ydb/core/formats/arrow/reader/position.h>\n #include <ydb/core/tx/columnshard/common/limits.h>\n #include <ydb/core/tx/columnshard/engines/reader/abstract/read_context.h>\n@@ -9,77 +13,62 @@ namespace NKikimr::NOlap::NReader::NSimple {\n \n class TPlainReadData;\n \n-class TDataSourceEndpoint {\n+class TScanHead {\n private:\n-    YDB_READONLY_DEF(std::vector<std::shared_ptr<IDataSource>>, StartSources);\n-    YDB_READONLY_DEF(std::vector<std::shared_ptr<IDataSource>>, FinishSources);\n+    std::shared_ptr<TSpecialReadContext> Context;\n+    std::shared_ptr<ISourcesCollection> SourcesCollection;\n+    std::vector<std::shared_ptr<ISyncPoint>> SyncPoints;\n+\n public:\n-    void AddStart(std::shared_ptr<IDataSource> source) {\n-        StartSources.emplace_back(source);\n+    const std::shared_ptr<ISyncPoint>& GetResultSyncPoint() const {\n+        return SyncPoints.back();\n     }\n-    void AddFinish(std::shared_ptr<IDataSource> source) {\n-        FinishSources.emplace_back(source);\n+\n+    const std::shared_ptr<ISyncPoint>& GetSyncPoint(const ui32 index) const {\n+        AFL_VERIFY(index < SyncPoints.size());\n+        return SyncPoints[index];\n     }\n-};\n \n-class TScanHead {\n-private:\n-    using TCompareKeyForScanSequence = TPortionDataSource::TCompareKeyForScanSequence;\n+    ISourcesCollection& MutableSourcesCollection() const {\n+        return *SourcesCollection;\n+    }\n \n-    std::shared_ptr<TSpecialReadContext> Context;\n-    THashMap<ui64, std::shared_ptr<IDataSource>> FetchingSourcesByIdx;\n-    std::deque<std::shared_ptr<IDataSource>> SortedSources;\n-    std::deque<std::shared_ptr<IDataSource>> FetchingSources;\n-    std::map<TCompareKeyForScanSequence, std::shared_ptr<IDataSource>> FinishedSources;\n-    std::map<TCompareKeyForScanSequence, std::shared_ptr<IDataSource>> FetchingInFlightSources;\n-    TPositiveControlInteger IntervalsInFlightCount;\n-    ui64 FetchedCount = 0;\n-    ui64 InFlightLimit = 1;\n-    ui64 MaxInFlight = 256;\n-    TPositiveControlInteger SourcesInFlightCount;\n-\n-    ui32 GetInFlightIntervalsCount() const;\n+    const ISourcesCollection& GetSourcesCollection() const {\n+        return *SourcesCollection;\n+    }\n \n-public:\n     ~TScanHead();\n \n-    void ContinueSource(const ui32 sourceIdx) const {\n-        auto it = FetchingSourcesByIdx.find(sourceIdx);\n-        AFL_VERIFY(it != FetchingSourcesByIdx.end())(\"source_idx\", sourceIdx)(\"count\", FetchingSourcesByIdx.size());\n-        it->second->ContinueCursor(it->second);\n-    }\n-\n     bool IsReverse() const;\n     void Abort();\n \n     bool IsFinished() const {\n-        return FetchingSources.empty() && SortedSources.empty();\n+        for (auto&& i : SyncPoints) {\n+            if (!i->IsFinished()) {\n+                return false;\n+            }\n+        }\n+        return SourcesCollection->IsFinished();\n     }\n \n     const TReadContext& GetContext() const;\n \n     TString DebugString() const {\n         TStringBuilder sb;\n-        sb << \"S:\";\n-        for (auto&& i : SortedSources) {\n-            sb << i->GetSourceId() << \";\";\n-        }\n-        sb << \"F:\";\n-        for (auto&& i : FetchingSources) {\n-            sb << i->GetSourceId() << \";\";\n+        sb << \"S:{\" << SourcesCollection->DebugString() << \"};\";\n+        sb << \"SP:[\";\n+        for (auto&& i : SyncPoints) {\n+            sb << \"{\" << i->DebugString() << \"};\";\n         }\n+        sb << \"]\";\n         return sb;\n     }\n \n-    void OnSourceReady(const std::shared_ptr<IDataSource>& source, std::shared_ptr<arrow::Table>&& table, const ui32 startIndex,\n-        const ui32 recordsCount, TPlainReadData& reader);\n-\n     TConclusionStatus Start();\n \n-    TScanHead(std::deque<std::shared_ptr<IDataSource>>&& sources, const std::shared_ptr<TSpecialReadContext>& context);\n+    TScanHead(std::deque<TSourceConstructor>&& sources, const std::shared_ptr<TSpecialReadContext>& context);\n \n     [[nodiscard]] TConclusion<bool> BuildNextInterval();\n-\n };\n \n-}\n+}   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.cpp\nindex 589b8e8632dc..e075573a6ea8 100644\n--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.cpp\n@@ -8,6 +8,7 @@\n #include <ydb/core/tx/columnshard/engines/portions/data_accessor.h>\n #include <ydb/core/tx/columnshard/engines/reader/common_reader/iterator/constructor.h>\n #include <ydb/core/tx/columnshard/engines/reader/common_reader/iterator/default_fetching.h>\n+#include <ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.h>\n #include <ydb/core/tx/columnshard/engines/reader/common_reader/iterator/sub_columns_fetching.h>\n #include <ydb/core/tx/columnshard/engines/storage/indexes/portions/meta.h>\n #include <ydb/core/tx/columnshard/engines/storage/indexes/skip_index/meta.h>\n@@ -26,39 +27,47 @@ void IDataSource::InitFetchingPlan(const std::shared_ptr<TFetchingScript>& fetch\n }\n \n void IDataSource::StartProcessing(const std::shared_ptr<IDataSource>& sourcePtr) {\n-    AFL_VERIFY(!ProcessingStarted);\n     AFL_VERIFY(FetchingPlan);\n-    ProcessingStarted = true;\n-    SourceGroupGuard = NGroupedMemoryManager::TScanMemoryLimiterOperator::BuildGroupGuard(\n-        GetContext()->GetProcessMemoryControlId(), GetContext()->GetCommonContext()->GetScanId());\n-    SetMemoryGroupId(SourceGroupGuard->GetGroupId());\n-    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"InitFetchingPlan\", FetchingPlan->DebugString())(\"source_idx\", GetSourceIdx());\n-    //    NActors::TLogContextGuard logGuard(NActors::TLogContextBuilder::Build()(\"source\", SourceIdx)(\"method\", \"InitFetchingPlan\"));\n+    if (!ProcessingStarted) {\n+        InitStageData(std::make_unique<TFetchedData>(\n+            GetContext()->GetReadMetadata()->GetProgram().GetChainVerified()->HasAggregations(), sourcePtr->GetRecordsCount()));\n+        ProcessingStarted = true;\n+        SourceGroupGuard = NGroupedMemoryManager::TScanMemoryLimiterOperator::BuildGroupGuard(\n+            GetContext()->GetProcessMemoryControlId(), GetContext()->GetCommonContext()->GetScanId());\n+        SetMemoryGroupId(SourceGroupGuard->GetGroupId());\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"InitFetchingPlan\", FetchingPlan->DebugString())(\"source_idx\", GetSourceIdx());\n+        //    NActors::TLogContextGuard logGuard(NActors::TLogContextBuilder::Build()(\"source\", SourceIdx)(\"method\", \"InitFetchingPlan\"));\n+    }\n     TFetchingScriptCursor cursor(FetchingPlan, 0);\n-    auto task = std::make_shared<TStepAction>(sourcePtr, std::move(cursor), GetContext()->GetCommonContext()->GetScanActorId());\n+    auto task = std::make_shared<TStepAction>(sourcePtr, std::move(cursor), GetContext()->GetCommonContext()->GetScanActorId(), true);\n     NConveyor::TScanServiceOperator::SendTaskToExecute(task);\n }\n \n void IDataSource::ContinueCursor(const std::shared_ptr<IDataSource>& sourcePtr) {\n-    AFL_VERIFY(!!ScriptCursor);\n+    AFL_VERIFY(!!ScriptCursor)(\"source_id\", GetSourceId());\n     if (ScriptCursor->Next()) {\n-        auto task = std::make_shared<TStepAction>(sourcePtr, std::move(*ScriptCursor), GetContext()->GetCommonContext()->GetScanActorId());\n-        NConveyor::TScanServiceOperator::SendTaskToExecute(task);\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"source_id\", GetSourceId())(\"event\", \"ContinueCursor\");\n+        auto cursor = std::move(*ScriptCursor);\n         ScriptCursor.reset();\n+        auto task = std::make_shared<TStepAction>(sourcePtr, std::move(cursor), GetContext()->GetCommonContext()->GetScanActorId(), true);\n+        NConveyor::TScanServiceOperator::SendTaskToExecute(task);\n+    } else {\n+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"source_id\", GetSourceId())(\"event\", \"CannotContinueCursor\");\n     }\n }\n \n void IDataSource::DoOnSourceFetchingFinishedSafe(IDataReader& owner, const std::shared_ptr<NCommon::IDataSource>& sourcePtr) {\n     auto* plainReader = static_cast<TPlainReadData*>(&owner);\n-    plainReader->MutableScanner().OnSourceReady(std::static_pointer_cast<IDataSource>(sourcePtr), nullptr, 0, GetRecordsCount(), *plainReader);\n+    auto sourceSimple = std::static_pointer_cast<IDataSource>(sourcePtr);\n+    plainReader->MutableScanner().GetSyncPoint(sourceSimple->GetPurposeSyncPointIndex())->OnSourcePrepared(sourceSimple, *plainReader);\n }\n \n void IDataSource::DoOnEmptyStageData(const std::shared_ptr<NCommon::IDataSource>& /*sourcePtr*/) {\n     TMemoryProfileGuard mpg(\"SCAN_PROFILE::STAGE_RESULT_EMPTY\", IS_DEBUG_LOG_ENABLED(NKikimrServices::TX_COLUMNSHARD_SCAN_MEMORY));\n     ResourceGuards.clear();\n     StageResult = TFetchedResult::BuildEmpty();\n-    StageResult->SetPages({ TPortionDataAccessor::TReadPage(0, GetRecordsCount(), 0) });\n-    StageData.reset();\n+    StageResult->SetPages({});\n+    ClearStageData();\n }\n \n void IDataSource::DoBuildStageResult(const std::shared_ptr<NCommon::IDataSource>& /*sourcePtr*/) {\n@@ -67,15 +76,20 @@ void IDataSource::DoBuildStageResult(const std::shared_ptr<NCommon::IDataSource>\n \n void IDataSource::Finalize(const std::optional<ui64> memoryLimit) {\n     TMemoryProfileGuard mpg(\"SCAN_PROFILE::STAGE_RESULT\", IS_DEBUG_LOG_ENABLED(NKikimrServices::TX_COLUMNSHARD_SCAN_MEMORY));\n+    AFL_VERIFY(!GetStageData().IsEmptyWithData());\n     if (memoryLimit && !IsSourceInMemory()) {\n-        const auto accessor = StageData->GetPortionAccessor();\n-        StageResult = std::make_unique<TFetchedResult>(std::move(StageData), *GetContext()->GetCommonContext()->GetResolver());\n+        const auto accessor = GetStageData().GetPortionAccessor();\n+        StageResult = std::make_unique<TFetchedResult>(ExtractStageData(), *GetContext()->GetCommonContext()->GetResolver());\n         StageResult->SetPages(accessor.BuildReadPages(*memoryLimit, GetContext()->GetProgramInputColumns()->GetColumnIds()));\n     } else {\n-        StageResult = std::make_unique<TFetchedResult>(std::move(StageData), *GetContext()->GetCommonContext()->GetResolver());\n+        StageResult = std::make_unique<TFetchedResult>(ExtractStageData(), *GetContext()->GetCommonContext()->GetResolver());\n         StageResult->SetPages({ TPortionDataAccessor::TReadPage(0, GetRecordsCount(), 0) });\n     }\n-    StageData.reset();\n+    if (StageResult->IsEmpty()) {\n+        StageResult = TFetchedResult::BuildEmpty();\n+        StageResult->SetPages({});\n+    }\n+    ClearStageData();\n }\n \n void TPortionDataSource::NeedFetchColumns(const std::set<ui32>& columnIds, TBlobsAction& blobsAction,\n@@ -114,15 +128,15 @@ bool TPortionDataSource::DoStartFetchingColumns(\n     const std::shared_ptr<NCommon::IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const TColumnsSetIds& columns) {\n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", step.GetName());\n     AFL_VERIFY(columns.GetColumnsCount());\n-    AFL_VERIFY(!StageData->GetAppliedFilter() || !StageData->GetAppliedFilter()->IsTotalDenyFilter());\n+    AFL_VERIFY(!GetStageData().GetAppliedFilter() || !GetStageData().GetAppliedFilter()->IsTotalDenyFilter());\n     auto& columnIds = columns.GetColumnIds();\n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", step.GetName())(\"fetching_info\", step.DebugString());\n \n     TBlobsAction action(GetContext()->GetCommonContext()->GetStoragesManager(), NBlobOperations::EConsumer::SCAN);\n     {\n         THashMap<TChunkAddress, TPortionDataAccessor::TAssembleBlobInfo> nullBlocks;\n-        NeedFetchColumns(columnIds, action, nullBlocks, StageData->GetAppliedFilter());\n-        StageData->AddDefaults(std::move(nullBlocks));\n+        NeedFetchColumns(columnIds, action, nullBlocks, GetStageData().GetAppliedFilter());\n+        MutableStageData().AddDefaults(std::move(nullBlocks));\n     }\n \n     auto readActions = action.GetReadingActions();\n@@ -137,7 +151,7 @@ bool TPortionDataSource::DoStartFetchingColumns(\n }\n \n std::shared_ptr<NIndexes::TSkipIndex> TPortionDataSource::SelectOptimalIndex(\n-    const std::vector<std::shared_ptr<NIndexes::TSkipIndex>>& indexes, const NArrow::NSSA::EIndexCheckOperation /*op*/) const {\n+    const std::vector<std::shared_ptr<NIndexes::TSkipIndex>>& indexes, const NArrow::NSSA::TIndexCheckOperation& /*op*/) const {\n     if (indexes.size() == 0) {\n         return nullptr;\n     }\n@@ -217,6 +231,7 @@ TConclusion<NArrow::TColumnFilter> TPortionDataSource::DoCheckIndex(\n     auto meta = MutableStageData().GetRemapDataToIndex(fetchContext);\n     if (!meta) {\n         NYDBTest::TControllers::GetColumnShardController()->OnIndexSelectProcessed({});\n+        GetContext()->GetCommonContext()->GetCounters().OnNoIndex(GetRecordsCount());\n         return NArrow::TColumnFilter::BuildAllowFilter();\n     }\n     AFL_VERIFY(meta->IsSkipIndex());\n@@ -232,6 +247,7 @@ TConclusion<NArrow::TColumnFilter> TPortionDataSource::DoCheckIndex(\n     const std::optional<ui64> cat = meta->CalcCategory(fetchContext.GetSubColumnName());\n     const NIndexes::TIndexColumnChunked* infoPointer = GetStageData().GetIndexes()->GetIndexDataOptional(meta->GetIndexId());\n     if (!infoPointer) {\n+        GetContext()->GetCommonContext()->GetCounters().OnNoIndexBlobs(GetRecordsCount());\n         return filter;\n     }\n     const auto info = *infoPointer;\n@@ -370,7 +386,7 @@ class TPortionAccessorFetchingSubscriber: public IDataAccessorRequestsSubscriber\n         Source->MutableStageData().SetPortionAccessor(std::move(result.ExtractPortionsVector().front()));\n         Source->InitUsedRawBytes();\n         AFL_VERIFY(Step.Next());\n-        auto task = std::make_shared<TStepAction>(Source, std::move(Step), Source->GetContext()->GetCommonContext()->GetScanActorId());\n+        auto task = std::make_shared<TStepAction>(Source, std::move(Step), Source->GetContext()->GetCommonContext()->GetScanActorId(), false);\n         NConveyor::TScanServiceOperator::SendTaskToExecute(task);\n     }\n \n@@ -384,8 +400,16 @@ class TPortionAccessorFetchingSubscriber: public IDataAccessorRequestsSubscriber\n \n }   // namespace\n \n+TCompareKeyForScanSequence TCompareKeyForScanSequence::FromStart(const std::shared_ptr<IDataSource>& src) {\n+    return TCompareKeyForScanSequence(src->GetStart(), src->GetSourceId());\n+}\n+\n+TCompareKeyForScanSequence TCompareKeyForScanSequence::FromFinish(const std::shared_ptr<IDataSource>& src) {\n+    return TCompareKeyForScanSequence(src->GetFinish(), src->GetSourceId());\n+}\n+\n bool TPortionDataSource::DoStartFetchingAccessor(const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step) {\n-    AFL_VERIFY(!StageData->HasPortionAccessor());\n+    AFL_VERIFY(!GetStageData().HasPortionAccessor());\n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", step.GetName())(\"fetching_info\", step.DebugString());\n \n     std::shared_ptr<TDataAccessorsRequest> request = std::make_shared<TDataAccessorsRequest>(\"SIMPLE::\" + step.GetName());\n@@ -405,4 +429,49 @@ TPortionDataSource::TPortionDataSource(\n     , Schema(GetContext()->GetReadMetadata()->GetLoadSchemaVerified(*portion)) {\n }\n \n+TConclusion<bool> TPortionDataSource::DoStartReserveMemory(const NArrow::NSSA::TProcessorContext& context,\n+    const THashMap<ui32, IDataSource::TDataAddress>& columns, const THashMap<ui32, IDataSource::TFetchIndexContext>& /*indexes*/,\n+    const THashMap<ui32, IDataSource::TFetchHeaderContext>& /*headers*/, const std::shared_ptr<NArrow::NSSA::IMemoryCalculationPolicy>& policy) {\n+    class TEntitySize {\n+    private:\n+        YDB_READONLY(ui64, BlobsSize, 0);\n+        YDB_READONLY(ui64, RawSize, 0);\n+\n+    public:\n+        void Add(const TEntitySize& item) {\n+            Add(item.BlobsSize, item.RawSize);\n+        }\n+\n+        void Add(const ui64 blob, const ui64 raw) {\n+            BlobsSize += blob;\n+            RawSize += raw;\n+        }\n+    };\n+\n+    THashMap<ui32, TEntitySize> sizeByColumn;\n+    for (auto&& [_, info] : columns) {\n+        auto chunks = GetStageData().GetPortionAccessor().GetColumnChunksPointers(info.GetColumnId());\n+        auto& sizes = sizeByColumn[info.GetColumnId()];\n+        for (auto&& i : chunks) {\n+            sizes.Add(i->GetBlobRange().GetSize(), i->GetMeta().GetRawBytes());\n+        }\n+    }\n+    TEntitySize result;\n+    for (auto&& i : sizeByColumn) {\n+        result.Add(i.second);\n+    }\n+\n+    auto source = context.GetDataSourceVerifiedAs<NCommon::IDataSource>();\n+\n+    const ui64 sizeToReserve = policy->GetReserveMemorySize(\n+        result.GetBlobsSize(), result.GetRawSize(), GetContext()->GetReadMetadata()->GetLimitRobustOptional(), GetRecordsCount());\n+\n+    auto allocation = std::make_shared<NCommon::TAllocateMemoryStep::TFetchingStepAllocation>(\n+        source, sizeToReserve, GetExecutionContext().GetCursorStep(), policy->GetStage(), false);\n+    FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, AddEvent(\"mr\"));\n+    NGroupedMemoryManager::TScanMemoryLimiterOperator::SendToAllocation(GetContext()->GetProcessMemoryControlId(),\n+        GetContext()->GetCommonContext()->GetScanId(), GetMemoryGroupId(), { allocation }, (ui32)policy->GetStage());\n+    return true;\n+}\n+\n }   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.h\nindex 2c58a5d3933e..de0d8faa3b54 100644\n--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.h\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.h\n@@ -6,8 +6,8 @@\n #include <ydb/core/formats/arrow/reader/position.h>\n #include <ydb/core/tx/columnshard/blob.h>\n #include <ydb/core/tx/columnshard/blobs_action/abstract/action.h>\n-#include <ydb/core/tx/columnshard/common/snapshot.h>\n #include <ydb/core/tx/columnshard/common/path_id.h>\n+#include <ydb/core/tx/columnshard/common/snapshot.h>\n #include <ydb/core/tx/columnshard/engines/portions/portion_info.h>\n #include <ydb/core/tx/columnshard/engines/predicate/range.h>\n #include <ydb/core/tx/columnshard/engines/reader/common_reader/iterator/columns_set.h>\n@@ -47,18 +47,27 @@ class TPortionPage {\n \n class TReplaceKeyAdapter {\n private:\n-    const bool Reverse = false;\n-    const NArrow::TReplaceKey Value;\n+    bool Reverse = false;\n+    NArrow::TComparablePosition Value;\n \n public:\n+    const NArrow::TComparablePosition& GetValue() const {\n+        return Value;\n+    }\n+\n     TReplaceKeyAdapter(const NArrow::TReplaceKey& rk, const bool reverse)\n         : Reverse(reverse)\n         , Value(rk) {\n     }\n \n+    TReplaceKeyAdapter(const NArrow::TComparablePosition& pos, const bool reverse)\n+        : Reverse(reverse)\n+        , Value(pos) {\n+    }\n+\n     std::partial_ordering Compare(const TReplaceKeyAdapter& item) const {\n         AFL_VERIFY(Reverse == item.Reverse);\n-        const std::partial_ordering result = Value.CompareNotNull(item.Value);\n+        const std::partial_ordering result = Value.Compare(item.Value);\n         if (result == std::partial_ordering::equivalent) {\n             return std::partial_ordering::equivalent;\n         } else if (result == std::partial_ordering::less) {\n@@ -72,18 +81,7 @@ class TReplaceKeyAdapter {\n     }\n \n     bool operator<(const TReplaceKeyAdapter& item) const {\n-        AFL_VERIFY(Reverse == item.Reverse);\n-        const std::partial_ordering result = Value.CompareNotNull(item.Value);\n-        if (result == std::partial_ordering::equivalent) {\n-            return false;\n-        } else if (result == std::partial_ordering::less) {\n-            return !Reverse;\n-        } else if (result == std::partial_ordering::greater) {\n-            return Reverse;\n-        } else {\n-            AFL_VERIFY(false);\n-            return false;\n-        }\n+        return Compare(item) == std::partial_ordering::less;\n     }\n \n     TString DebugString() const {\n@@ -91,6 +89,38 @@ class TReplaceKeyAdapter {\n     }\n };\n \n+class TCompareKeyForScanSequence {\n+private:\n+    TReplaceKeyAdapter Key;\n+    YDB_READONLY(ui32, SourceId, 0);\n+\n+public:\n+    const TReplaceKeyAdapter GetKey() const {\n+        return Key;\n+    }\n+\n+    explicit TCompareKeyForScanSequence(const TReplaceKeyAdapter& key, const ui32 sourceId)\n+        : Key(key)\n+        , SourceId(sourceId) {\n+    }\n+\n+    static TCompareKeyForScanSequence FromStart(const std::shared_ptr<IDataSource>& src);\n+    static TCompareKeyForScanSequence FromFinish(const std::shared_ptr<IDataSource>& src);\n+\n+    static TCompareKeyForScanSequence BorderStart(const TReplaceKeyAdapter& key) {\n+        return TCompareKeyForScanSequence(key, 0);\n+    }\n+\n+    bool operator<(const TCompareKeyForScanSequence& item) const {\n+        const std::partial_ordering compareResult = Key.Compare(item.Key);\n+        if (compareResult == std::partial_ordering::equivalent) {\n+            return SourceId < item.SourceId;\n+        } else {\n+            return compareResult == std::partial_ordering::less;\n+        }\n+    };\n+};\n+\n class IDataSource: public NCommon::IDataSource {\n private:\n     using TBase = NCommon::IDataSource;\n@@ -112,6 +142,8 @@ class IDataSource: public NCommon::IDataSource {\n     virtual void DoOnEmptyStageData(const std::shared_ptr<NCommon::IDataSource>& /*sourcePtr*/) override;\n \n     void Finalize(const std::optional<ui64> memoryLimit);\n+    bool NeedFullAnswerFlag = true;\n+    std::optional<ui32> PurposeSyncPointIndex;\n \n protected:\n     std::optional<ui64> UsedRawBytes;\n@@ -123,6 +155,33 @@ class IDataSource: public NCommon::IDataSource {\n     virtual bool DoStartFetchingAccessor(const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step) = 0;\n \n public:\n+    bool NeedFullAnswer() const {\n+        return NeedFullAnswerFlag;\n+    }\n+\n+    void SetNeedFullAnswer(const bool value) {\n+        NeedFullAnswerFlag = value;\n+    }\n+\n+    ui32 GetPurposeSyncPointIndex() const {\n+        AFL_VERIFY(PurposeSyncPointIndex);\n+        return *PurposeSyncPointIndex;\n+    }\n+\n+    void ResetPurposeSyncPointIndex() {\n+        AFL_VERIFY(PurposeSyncPointIndex);\n+        PurposeSyncPointIndex.reset();\n+    }\n+\n+    void SetPurposeSyncPointIndex(const ui32 value) {\n+        if (!PurposeSyncPointIndex) {\n+            AFL_VERIFY(value == 0);\n+        } else {\n+            AFL_VERIFY(*PurposeSyncPointIndex < value);\n+        }\n+        PurposeSyncPointIndex = value;\n+    }\n+\n     virtual void InitUsedRawBytes() = 0;\n \n     ui64 GetUsedRawBytes() const {\n@@ -157,7 +216,7 @@ class IDataSource: public NCommon::IDataSource {\n     }\n \n     virtual void ClearResult() {\n-        StageData.reset();\n+        ClearStageData();\n         StageResult.reset();\n         ResourceGuards.clear();\n         SourceGroupGuard = nullptr;\n@@ -174,6 +233,7 @@ class IDataSource: public NCommon::IDataSource {\n \n     void ContinueCursor(const std::shared_ptr<IDataSource>& sourcePtr);\n \n+    template <bool Reverse>\n     class TCompareStartForScanSequence {\n     public:\n         bool operator()(const std::shared_ptr<IDataSource>& l, const std::shared_ptr<IDataSource>& r) const {\n@@ -181,40 +241,7 @@ class IDataSource: public NCommon::IDataSource {\n             if (compareResult == std::partial_ordering::equivalent) {\n                 return l->GetSourceId() < r->GetSourceId();\n             } else {\n-                return compareResult == std::partial_ordering::less;\n-            }\n-        };\n-    };\n-\n-    class TCompareKeyForScanSequence {\n-    private:\n-        const TReplaceKeyAdapter Key;\n-        const ui32 SourceId;\n-\n-    public:\n-        TCompareKeyForScanSequence(const TReplaceKeyAdapter& key, const ui32 sourceId)\n-            : Key(key)\n-            , SourceId(sourceId) {\n-        }\n-\n-        static TCompareKeyForScanSequence FromStart(const std::shared_ptr<IDataSource>& src) {\n-            return TCompareKeyForScanSequence(src->GetStart(), src->GetSourceId());\n-        }\n-\n-        static TCompareKeyForScanSequence FromFinish(const std::shared_ptr<IDataSource>& src) {\n-            return TCompareKeyForScanSequence(src->GetFinish(), src->GetSourceId());\n-        }\n-\n-        static TCompareKeyForScanSequence BorderStart(const std::shared_ptr<IDataSource>& src) {\n-            return TCompareKeyForScanSequence(src->GetStart(), 0);\n-        }\n-\n-        bool operator<(const TCompareKeyForScanSequence& item) const {\n-            const std::partial_ordering compareResult = Key.Compare(item.Key);\n-            if (compareResult == std::partial_ordering::equivalent) {\n-                return SourceId < item.SourceId;\n-            } else {\n-                return compareResult == std::partial_ordering::less;\n+                return Reverse ? compareResult == std::partial_ordering::greater : compareResult == std::partial_ordering::less;\n             }\n         };\n     };\n@@ -232,6 +259,9 @@ class IDataSource: public NCommon::IDataSource {\n     virtual bool HasIndexes(const std::set<ui32>& indexIds) const = 0;\n \n     void InitFetchingPlan(const std::shared_ptr<TFetchingScript>& fetching);\n+    bool HasFetchingPlan() const {\n+        return !!FetchingPlan;\n+    }\n \n     virtual ui64 GetIndexRawBytes(const std::set<ui32>& indexIds) const = 0;\n \n@@ -264,12 +294,11 @@ class IDataSource: public NCommon::IDataSource {\n         : TBase(sourceId, sourceIdx, context, recordSnapshotMin, recordSnapshotMax, recordsCount, shardingVersion, hasDeletions)\n         , Start(context->GetReadMetadata()->IsDescSorted() ? finish : start, context->GetReadMetadata()->IsDescSorted())\n         , Finish(context->GetReadMetadata()->IsDescSorted() ? start : finish, context->GetReadMetadata()->IsDescSorted()) {\n-        StageData = std::make_unique<TFetchedData>(true, recordsCount);\n         UsageClass = GetContext()->GetReadMetadata()->GetPKRangesFilter().GetUsageClass(start, finish);\n         AFL_VERIFY(UsageClass != TPKRangeFilter::EUsageClass::NoUsage);\n         AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"portions_for_merge\")(\"start\", Start.DebugString())(\n             \"finish\", Finish.DebugString());\n-        Y_ABORT_UNLESS(Start.Compare(Finish) != std::partial_ordering::greater);\n+        AFL_VERIFY_DEBUG(Start.Compare(Finish) != std::partial_ordering::greater);\n     }\n \n     virtual ~IDataSource() = default;\n@@ -286,7 +315,7 @@ class TPortionDataSource: public IDataSource {\n \n     virtual void InitUsedRawBytes() override {\n         AFL_VERIFY(!UsedRawBytes);\n-        UsedRawBytes = StageData->GetPortionAccessor().GetColumnRawBytes(GetContext()->GetAllUsageColumns()->GetColumnIds(), false);\n+        UsedRawBytes = GetStageData().GetPortionAccessor().GetColumnRawBytes(GetContext()->GetAllUsageColumns()->GetColumnIds(), false);\n     }\n \n     virtual bool DoStartFetchingColumns(\n@@ -294,11 +323,14 @@ class TPortionDataSource: public IDataSource {\n     virtual void DoAssembleColumns(const std::shared_ptr<TColumnsSet>& columns, const bool sequential) override;\n \n     std::shared_ptr<NIndexes::TSkipIndex> SelectOptimalIndex(\n-        const std::vector<std::shared_ptr<NIndexes::TSkipIndex>>& indexes, const NArrow::NSSA::EIndexCheckOperation op) const;\n+        const std::vector<std::shared_ptr<NIndexes::TSkipIndex>>& indexes, const NArrow::NSSA::TIndexCheckOperation& op) const;\n \n     virtual TConclusion<bool> DoStartFetchImpl(\n         const NArrow::NSSA::TProcessorContext& context, const std::vector<std::shared_ptr<NCommon::IKernelFetchLogic>>& fetchersExt) override;\n \n+    virtual TConclusion<bool> DoStartReserveMemory(const NArrow::NSSA::TProcessorContext& context,\n+        const THashMap<ui32, IDataSource::TDataAddress>& columns, const THashMap<ui32, IDataSource::TFetchIndexContext>& indexes,\n+        const THashMap<ui32, IDataSource::TFetchHeaderContext>& headers, const std::shared_ptr<NArrow::NSSA::IMemoryCalculationPolicy>& policy) override;\n     virtual TConclusion<std::vector<std::shared_ptr<NArrow::NSSA::IFetchLogic>>> DoStartFetchIndex(\n         const NArrow::NSSA::TProcessorContext& context, const TFetchIndexContext& fetchContext) override;\n     virtual TConclusion<NArrow::TColumnFilter> DoCheckIndex(const NArrow::NSSA::TProcessorContext& context,\n@@ -437,4 +469,56 @@ class TPortionDataSource: public IDataSource {\n     TPortionDataSource(const ui32 sourceIdx, const std::shared_ptr<TPortionInfo>& portion, const std::shared_ptr<TSpecialReadContext>& context);\n };\n \n+class TSourceConstructor: public ICursorEntity {\n+private:\n+    TCompareKeyForScanSequence Start;\n+    YDB_READONLY(ui32, SourceId, 0);\n+    YDB_READONLY(ui32, PortionIdx, 0);\n+    ui32 RecordsCount = 0;\n+    bool IsStartedByCursorFlag = false;\n+\n+    virtual ui64 DoGetEntityId() const override {\n+        return SourceId;\n+    }\n+    virtual ui64 DoGetEntityRecordsCount() const override {\n+        return RecordsCount;\n+    }\n+\n+public:\n+    void SetIsStartedByCursor() {\n+        IsStartedByCursorFlag = true;\n+    }\n+    bool GetIsStartedByCursor() const {\n+        return IsStartedByCursorFlag;\n+    }\n+\n+    const TCompareKeyForScanSequence& GetStart() const {\n+        return Start;\n+    }\n+\n+    TSourceConstructor(const ui32 portionIdx, const std::shared_ptr<TPortionInfo>& portion, const std::shared_ptr<TReadContext>& context)\n+        : Start(TReplaceKeyAdapter(context->GetReadMetadata()->IsDescSorted() ? portion->IndexKeyEnd() : portion->IndexKeyStart(),\n+                    context->GetReadMetadata()->IsDescSorted()),\n+              portion->GetPortionId())\n+        , SourceId(portion->GetPortionId())\n+        , PortionIdx(portionIdx)\n+        , RecordsCount(portion->GetRecordsCount()) {\n+    }\n+\n+    bool operator<(const TSourceConstructor& item) const {\n+        return item.Start < Start;\n+    }\n+\n+    std::shared_ptr<TPortionDataSource> Construct(const ui32 sourceIdx, const std::shared_ptr<TSpecialReadContext>& context) const {\n+        const auto& portions = context->GetReadMetadata()->SelectInfo->Portions;\n+        AFL_VERIFY(sourceIdx < portions.size());\n+        auto result = std::make_shared<TPortionDataSource>(sourceIdx, portions[PortionIdx], context);\n+        if (IsStartedByCursorFlag) {\n+            result->SetIsStartedByCursor();\n+        }\n+        FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, result->AddEvent(\"s\"));\n+        return result;\n+    }\n+};\n+\n }   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/abstract.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/abstract.cpp\nnew file mode 100644\nindex 000000000000..9d840e46432c\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/abstract.cpp\n@@ -0,0 +1,93 @@\n+#include \"abstract.h\"\n+\n+#include <ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.h>\n+\n+#include <util/string/builder.h>\n+\n+namespace NKikimr::NOlap::NReader::NSimple {\n+\n+void ISyncPoint::OnSourcePrepared(const std::shared_ptr<IDataSource>& sourceInput, TPlainReadData& reader) {\n+    const NActors::TLogContextGuard gLogging = NActors::TLogContextBuilder::Build()(\"sync_point\", GetPointName())(\"aborted\", AbortFlag);\n+    if (AbortFlag) {\n+        FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, sourceInput->AddEvent(\"a\" + GetShortPointName()));\n+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"sync_point_aborted\")(\"source_id\", sourceInput->GetSourceId());\n+        return;\n+    } else {\n+        FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, sourceInput->AddEvent(\"f\" + GetShortPointName()));\n+    }\n+    AFL_DEBUG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG)(\"event_log\", sourceInput->GetEventsReport())(\"count\", SourcesSequentially.size())(\n+        \"source_id\", sourceInput->GetSourceId());\n+    AFL_VERIFY(sourceInput->IsSyncSection())(\"source_id\", sourceInput->GetSourceId());\n+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"OnSourcePrepared\")(\"source_id\", sourceInput->GetSourceId());\n+    while (SourcesSequentially.size() && IsSourcePrepared(SourcesSequentially.front())) {\n+        auto source = SourcesSequentially.front();\n+        switch (OnSourceReady(source, reader)) {\n+            case ESourceAction::Finish: {\n+                AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"finish_source\")(\"source_id\", source->GetSourceId());\n+                reader.GetScanner().MutableSourcesCollection().OnSourceFinished(source);\n+                SourcesSequentially.pop_front();\n+                break;\n+            }\n+            case ESourceAction::ProvideNext: {\n+                AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"provide_source\")(\"source_id\", source->GetSourceId());\n+                if (Next) {\n+                    source->ResetSourceFinishedFlag();\n+                    Next->AddSource(source);\n+                } else {\n+                    reader.GetScanner().MutableSourcesCollection().OnSourceFinished(source);\n+                }\n+                SourcesSequentially.pop_front();\n+                break;\n+            }\n+            case ESourceAction::Wait: {\n+                AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"wait_source\")(\"source_id\", source->GetSourceId());\n+                return;\n+            }\n+        }\n+    }\n+}\n+\n+TString ISyncPoint::DebugString() const {\n+    TStringBuilder sb;\n+    sb << \"{\";\n+    for (auto&& i : SourcesSequentially) {\n+        sb << i->GetSourceId() << \",\";\n+    }\n+    sb << \"}\";\n+    return sb;\n+}\n+\n+void ISyncPoint::Continue(const TPartialSourceAddress& continueAddress, TPlainReadData& /*reader*/) {\n+    AFL_VERIFY(PointIndex == continueAddress.GetSyncPointIndex());\n+    AFL_VERIFY(SourcesSequentially.size() && SourcesSequentially.front()->GetSourceId() == continueAddress.GetSourceId())(\"first_source_id\",\n+                                                                                           SourcesSequentially.front()->GetSourceId())(\n+                                                                                           \"continue_source_id\", continueAddress.GetSourceId());\n+    const NActors::TLogContextGuard gLogging = NActors::TLogContextBuilder::Build()(\"sync_point\", GetPointName())(\"event\", \"continue_source\");\n+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"source_id\", SourcesSequentially.front()->GetSourceId());\n+    SourcesSequentially.front()->ContinueCursor(SourcesSequentially.front());\n+}\n+\n+void ISyncPoint::AddSource(const std::shared_ptr<IDataSource>& source) {\n+    const NActors::TLogContextGuard gLogging = NActors::TLogContextBuilder::Build()(\"sync_point\", GetPointName())(\"event\", \"add_source\");\n+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"source_id\", source->GetSourceId());\n+    AFL_VERIFY(!AbortFlag);\n+    source->SetPurposeSyncPointIndex(GetPointIndex());\n+    if (Next) {\n+        source->SetNeedFullAnswer(false);\n+    }\n+    AFL_VERIFY(!!source);\n+    if (!LastSourceIdx) {\n+        LastSourceIdx = source->GetSourceIdx();\n+    } else {\n+        AFL_VERIFY(*LastSourceIdx < source->GetSourceIdx());\n+    }\n+    LastSourceIdx = source->GetSourceIdx();\n+    SourcesSequentially.emplace_back(source);\n+    if (!source->HasFetchingPlan()) {\n+        source->InitFetchingPlan(Context->GetColumnsFetchingPlan(source));\n+    }\n+    OnAddSource(source);\n+    source->StartProcessing(source);\n+}\n+\n+}   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/abstract.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/abstract.h\nnew file mode 100644\nindex 000000000000..5ef3e4ede21a\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/abstract.h\n@@ -0,0 +1,83 @@\n+#pragma once\n+#include <ydb/core/tx/columnshard/engines/reader/common/result.h>\n+#include <ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.h>\n+#include <ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.h>\n+\n+#include <ydb/library/accessor/accessor.h>\n+\n+namespace NKikimr::NOlap::NReader::NSimple {\n+\n+class TPlainReadData;\n+class ISourcesCollection;\n+\n+class ISyncPoint {\n+public:\n+    enum class ESourceAction {\n+        Finish,\n+        ProvideNext,\n+        Wait\n+    };\n+\n+private:\n+    YDB_READONLY(ui32, PointIndex, 0);\n+    YDB_READONLY_DEF(TString, PointName);\n+    std::optional<ui32> LastSourceIdx;\n+    virtual void OnAddSource(const std::shared_ptr<IDataSource>& /*source*/) {\n+    }\n+    virtual bool IsSourcePrepared(const std::shared_ptr<IDataSource>& source) const = 0;\n+    virtual ESourceAction OnSourceReady(const std::shared_ptr<IDataSource>& source, TPlainReadData& reader) = 0;\n+    virtual void DoAbort() = 0;\n+    bool AbortFlag = false;\n+\n+protected:\n+    const std::shared_ptr<TSpecialReadContext> Context;\n+    const std::shared_ptr<ISourcesCollection> Collection;\n+    std::shared_ptr<ISyncPoint> Next;\n+    std::deque<std::shared_ptr<IDataSource>> SourcesSequentially;\n+\n+public:\n+    virtual ~ISyncPoint() = default;\n+\n+    void Continue(const TPartialSourceAddress& continueAddress, TPlainReadData& reader);\n+\n+    TString DebugString() const;\n+\n+    void Abort() {\n+        SourcesSequentially.clear();\n+        if (!AbortFlag) {\n+            AbortFlag = true;\n+            DoAbort();\n+        }\n+    }\n+\n+    bool IsFinished() const {\n+        return SourcesSequentially.empty();\n+    }\n+\n+    void SetNext(const std::shared_ptr<ISyncPoint>& next) {\n+        AFL_VERIFY(!Next);\n+        Next = next;\n+    }\n+\n+    TString GetShortPointName() const {\n+        if (PointName.size() < 2) {\n+            return PointName;\n+        } else {\n+            return PointName.substr(0, 2);\n+        }\n+    }\n+\n+    ISyncPoint(const ui32 pointIndex, const TString& pointName, const std::shared_ptr<TSpecialReadContext>& context,\n+        const std::shared_ptr<ISourcesCollection>& collection)\n+        : PointIndex(pointIndex)\n+        , PointName(pointName)\n+        , Context(context)\n+        , Collection(collection) {\n+    }\n+\n+    void AddSource(const std::shared_ptr<IDataSource>& source);\n+\n+    void OnSourcePrepared(const std::shared_ptr<IDataSource>& sourceInput, TPlainReadData& reader);\n+};\n+\n+}   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/limit.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/limit.cpp\nnew file mode 100644\nindex 000000000000..ef6b890ea39d\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/limit.cpp\n@@ -0,0 +1,96 @@\n+#include \"limit.h\"\n+\n+#include <ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/limit_sorted.h>\n+\n+namespace NKikimr::NOlap::NReader::NSimple {\n+\n+TSyncPointLimitControl::TSyncPointLimitControl(const ui32 limit, const ui32 pointIndex, const std::shared_ptr<TSpecialReadContext>& context,\n+    const std::shared_ptr<TScanWithLimitCollection>& collection)\n+    : TBase(pointIndex, \"SYNC_LIMIT\", context, collection)\n+    , Limit(limit)\n+    , Collection(collection) {\n+    AFL_VERIFY(Collection);\n+}\n+\n+bool TSyncPointLimitControl::DrainToLimit() {\n+    std::optional<TSourceIterator> nextInHeap;\n+    if (Collection->GetNextSource()) {\n+        nextInHeap = TSourceIterator(Collection->GetNextSource());\n+    }\n+    if (Iterators.empty() || (nextInHeap && Iterators.front() < *nextInHeap)) {\n+        return false;\n+    }\n+\n+    while (Iterators.size()) {\n+        if (!Iterators.front().IsFilled()) {\n+            return false;\n+        }\n+        std::pop_heap(Iterators.begin(), Iterators.end());\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"LimitIteratorNext\")(\"source_id\", Iterators.back().GetSourceId())(\n+            \"fetched\", FetchedCount)(\"limit\", Limit)(\"iterators\", Iterators.size());\n+        if (!Iterators.back().Next()) {\n+            Iterators.pop_back();\n+        } else {\n+            std::push_heap(Iterators.begin(), Iterators.end());\n+            if (++FetchedCount >= Limit) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+ISyncPoint::ESourceAction TSyncPointLimitControl::OnSourceReady(const std::shared_ptr<IDataSource>& source, TPlainReadData& /*reader*/) {\n+    if (FetchedCount >= Limit) {\n+        return ESourceAction::Finish;\n+    }\n+    const auto& rk = *source->GetSourceSchema()->GetIndexInfo().GetReplaceKey();\n+    const auto& g = source->GetStageResult().GetBatch();\n+    AFL_VERIFY(Iterators.size());\n+    AFL_VERIFY(Iterators.front().GetSourceId() == source->GetSourceId())(\"front\", Iterators.front().DebugString())(\n+                                                    \"source\", source->GetStart().DebugString())(\"source_id\", source->GetSourceId());\n+    std::pop_heap(Iterators.begin(), Iterators.end());\n+    if (!g || !g->GetRecordsCount()) {\n+        Iterators.pop_back();\n+    } else {\n+        std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> arrs;\n+        for (auto&& i : rk.fields()) {\n+            auto acc = g->GetAccessorByNameOptional(i->name());\n+            if (!acc) {\n+                break;\n+            }\n+            arrs.emplace_back(acc);\n+        }\n+        AFL_VERIFY(arrs.size());\n+        if (!PKPrefixSize) {\n+            PKPrefixSize = arrs.size();\n+        } else {\n+            AFL_VERIFY(*PKPrefixSize == arrs.size())(\"prefix\", PKPrefixSize)(\"arr\", arrs.size());\n+        }\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"DoOnSourceCheckLimitFillIterator\")(\"source_id\", source->GetSourceId())(\n+            \"fetched\", FetchedCount)(\"limit\", Limit);\n+        Iterators.back() = TSourceIterator(arrs, source->GetStageResult().GetNotAppliedFilter(), source);\n+        AFL_VERIFY(Iterators.back().IsFilled());\n+        std::push_heap(Iterators.begin(), Iterators.end());\n+    }\n+    if (DrainToLimit()) {\n+        Collection->Clear();\n+    }\n+    if (source->GetStageResult().IsEmpty()) {\n+        return ESourceAction::Finish;\n+    } else {\n+        return ESourceAction::ProvideNext;\n+    }\n+}\n+\n+TString TSyncPointLimitControl::TSourceIterator::DebugString() const {\n+    TStringBuilder sb;\n+    sb << \"{\";\n+    sb << \"id=\" << Source->GetSourceId() << \";\";\n+    sb << \"f=\" << IsFilled() << \";\";\n+    sb << \"record=\" << SortableRecord->DebugJson() << \";\";\n+    sb << \"start=\" << Source->GetStart().DebugString() << \";\";\n+    return sb;\n+}\n+\n+}   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/limit.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/limit.h\nnew file mode 100644\nindex 000000000000..47ef3894275b\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/limit.h\n@@ -0,0 +1,142 @@\n+#pragma once\n+#include \"abstract.h\"\n+\n+namespace NKikimr::NOlap::NReader::NSimple {\n+\n+class TScanWithLimitCollection;\n+\n+class TSyncPointLimitControl: public ISyncPoint {\n+private:\n+    using TBase = ISyncPoint;\n+\n+    const ui32 Limit;\n+    std::shared_ptr<TScanWithLimitCollection> Collection;\n+    ui32 FetchedCount = 0;\n+    std::optional<ui32> PKPrefixSize;\n+\n+    virtual bool IsSourcePrepared(const std::shared_ptr<IDataSource>& source) const override {\n+        if (source->IsSyncSection() && source->HasStageResult()) {\n+            AFL_VERIFY(!source->GetStageResult().HasResultChunk());\n+            return true;\n+        }\n+        return false;\n+    }\n+    class TSourceIterator {\n+    private:\n+        std::shared_ptr<IDataSource> Source;\n+        bool Reverse;\n+        int Delta = 0;\n+        i64 Start = 0;\n+        i64 Finish = 0;\n+        std::shared_ptr<NArrow::NMerger::TRWSortableBatchPosition> SortableRecord;\n+        std::shared_ptr<NArrow::TColumnFilter> Filter;\n+        std::shared_ptr<NArrow::TColumnFilter::TIterator> FilterIterator;\n+        bool IsValidFlag = true;\n+\n+        bool ShiftWithFilter() const {\n+            AFL_VERIFY(IsValidFlag);\n+            while (!FilterIterator->GetCurrentAcceptance()) {\n+                if (!FilterIterator->Next(1)) {\n+                    AFL_VERIFY(!SortableRecord->NextPosition(Delta));\n+                    return false;\n+                } else {\n+                    AFL_VERIFY(SortableRecord->NextPosition(Delta));\n+                }\n+            }\n+            return true;\n+        }\n+\n+    public:\n+        TString DebugString() const;\n+\n+        const std::shared_ptr<IDataSource>& GetSource() const {\n+            AFL_VERIFY(Source);\n+            return Source;\n+        }\n+\n+        TSourceIterator(const std::shared_ptr<IDataSource>& source)\n+            : Source(source)\n+            , Reverse(Source->GetContext()->GetReadMetadata()->IsDescSorted())\n+            , Delta(Reverse ? -1 : 1) {\n+            AFL_VERIFY(Source);\n+            auto arr = Source->GetStart().GetValue().GetArrays();\n+            auto batch =\n+                arrow::RecordBatch::Make(Source->GetSourceSchema()->GetIndexInfo().GetReplaceKey(), arr.front()->length(), std::move(arr));\n+            SortableRecord =\n+                std::make_shared<NArrow::NMerger::TRWSortableBatchPosition>(batch, Source->GetStart().GetValue().GetMonoPosition(), Reverse);\n+        }\n+\n+        TSourceIterator(const std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>>& arrs,\n+            const std::shared_ptr<NArrow::TColumnFilter>& filter, const std::shared_ptr<IDataSource>& source)\n+            : Source(source)\n+            , Reverse(Source->GetContext()->GetReadMetadata()->IsDescSorted())\n+            , Delta(Reverse ? -1 : 1)\n+            , Start(Reverse ? (arrs.front()->GetRecordsCount() - 1) : 0)\n+            , Finish(Reverse ? 0 : (arrs.front()->GetRecordsCount() - 1))\n+            , Filter(filter ? filter : std::make_shared<NArrow::TColumnFilter>(NArrow::TColumnFilter::BuildAllowFilter())) {\n+            AFL_VERIFY(arrs.size());\n+            AFL_VERIFY(arrs.front()->GetRecordsCount());\n+            FilterIterator = std::make_shared<NArrow::TColumnFilter::TIterator>(Filter->GetIterator(Reverse, arrs.front()->GetRecordsCount()));\n+            auto prefixSchema = Source->GetSourceSchema()->GetIndexInfo().GetReplaceKeyPrefix(arrs.size());\n+            auto copyArrs = arrs;\n+            auto batch = std::make_shared<NArrow::TGeneralContainer>(prefixSchema->fields(), std::move(copyArrs));\n+            SortableRecord = std::make_shared<NArrow::NMerger::TRWSortableBatchPosition>(batch, Start, Reverse);\n+            IsValidFlag = ShiftWithFilter();\n+        }\n+\n+        ui64 GetSourceId() const {\n+            AFL_VERIFY(Source);\n+            return Source->GetSourceId();\n+        }\n+\n+        bool IsFilled() const {\n+            return !!Filter;\n+        }\n+\n+        bool IsValid() const {\n+            return IsValidFlag;\n+        }\n+\n+        bool Next() {\n+            AFL_VERIFY(IsValidFlag);\n+            AFL_VERIFY(!!SortableRecord);\n+            AFL_VERIFY(!!Filter);\n+            IsValidFlag = SortableRecord->NextPosition(Delta);\n+            AFL_VERIFY(FilterIterator->Next(1) == IsValidFlag);\n+            if (IsValidFlag) {\n+                IsValidFlag = ShiftWithFilter();\n+            }\n+            return IsValidFlag;\n+        }\n+\n+        bool operator<(const TSourceIterator& item) const {\n+            const auto cmp = SortableRecord->ComparePartial(*item.SortableRecord);\n+            if (cmp == std::partial_ordering::equivalent) {\n+                return item.Source->GetSourceId() < Source->GetSourceId();\n+            }\n+            return cmp == std::partial_ordering::greater;\n+        }\n+    };\n+\n+    std::vector<TSourceIterator> Iterators;\n+\n+    virtual void OnAddSource(const std::shared_ptr<IDataSource>& source) override {\n+        AFL_VERIFY(FetchedCount < Limit);\n+        Iterators.emplace_back(TSourceIterator(source));\n+        std::push_heap(Iterators.begin(), Iterators.end());\n+    }\n+\n+    virtual void DoAbort() override {\n+        Iterators.clear();\n+    }\n+\n+    virtual ESourceAction OnSourceReady(const std::shared_ptr<IDataSource>& source, TPlainReadData& reader) override;\n+\n+    bool DrainToLimit();\n+\n+public:\n+    TSyncPointLimitControl(const ui32 limit, const ui32 pointIndex, const std::shared_ptr<TSpecialReadContext>& context,\n+        const std::shared_ptr<TScanWithLimitCollection>& collection);\n+};\n+\n+}   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/result.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/result.cpp\nnew file mode 100644\nindex 000000000000..d848cd6f7a69\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/result.cpp\n@@ -0,0 +1,36 @@\n+#include \"result.h\"\n+\n+#include <ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.h>\n+\n+namespace NKikimr::NOlap::NReader::NSimple {\n+\n+ISyncPoint::ESourceAction TSyncPointResult::OnSourceReady(const std::shared_ptr<IDataSource>& source, TPlainReadData& reader) {\n+    if (source->GetStageResult().IsEmpty()) {\n+        return ESourceAction::Finish;\n+    }\n+    auto resultChunk = source->MutableStageResult().ExtractResultChunk();\n+    const bool isFinished = source->GetStageResult().IsFinished();\n+    if (resultChunk && resultChunk->HasData()) {\n+        std::optional<TPartialSourceAddress> partialSourceAddress;\n+        if (!isFinished) {\n+            partialSourceAddress = TPartialSourceAddress(source->GetSourceId(), source->GetSourceIdx(), GetPointIndex());\n+        }\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"has_result\")(\"source_id\", source->GetSourceId())(\n+            \"source_idx\", source->GetSourceIdx())(\"table\", resultChunk->GetTable()->num_rows())(\"is_finished\", isFinished);\n+        auto cursor = Collection->BuildCursor(source, resultChunk->GetStartIndex() + resultChunk->GetRecordsCount(),\n+            Context->GetCommonContext()->GetReadMetadata()->GetTabletId());\n+        reader.OnIntervalResult(std::make_shared<TPartialReadResult>(source->GetResourceGuards(), source->GetGroupGuard(),\n+            resultChunk->GetTable(), cursor, Context->GetCommonContext(), partialSourceAddress));\n+    } else if (!isFinished) {\n+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)(\"event\", \"continue_source\")(\"source_id\", source->GetSourceId())(\n+            \"source_idx\", source->GetSourceIdx());\n+        source->ContinueCursor(source);\n+    }\n+    if (!isFinished) {\n+        return ESourceAction::Wait;\n+    }\n+    source->ClearResult();\n+    return ESourceAction::ProvideNext;\n+}\n+\n+}   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/result.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/result.h\nnew file mode 100644\nindex 000000000000..8df2879d938b\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/result.h\n@@ -0,0 +1,25 @@\n+#pragma once\n+#include \"abstract.h\"\n+\n+namespace NKikimr::NOlap::NReader::NSimple {\n+\n+class TSyncPointResult: public ISyncPoint {\n+private:\n+    using TBase = ISyncPoint;\n+    virtual void DoAbort() override {\n+    }\n+\n+    virtual ESourceAction OnSourceReady(const std::shared_ptr<IDataSource>& source, TPlainReadData& reader) override;\n+    virtual bool IsSourcePrepared(const std::shared_ptr<IDataSource>& source) const override {\n+        return source->IsSyncSection() && source->HasStageResult() &&\n+               (source->GetStageResult().HasResultChunk() || source->GetStageResult().IsEmpty());\n+    }\n+\n+public:\n+    TSyncPointResult(\n+        const ui32 pointIndex, const std::shared_ptr<TSpecialReadContext>& context, const std::shared_ptr<ISourcesCollection>& collection)\n+        : TBase(pointIndex, \"RESULT\", context, collection) {\n+    }\n+};\n+\n+}   // namespace NKikimr::NOlap::NReader::NSimple\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/ya.make b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/ya.make\nnew file mode 100644\nindex 000000000000..58d66933ef7b\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/ya.make\n@@ -0,0 +1,13 @@\n+LIBRARY()\n+\n+SRCS(\n+    abstract.cpp\n+    result.cpp\n+    limit.cpp\n+)\n+\n+PEERDIR(\n+    ydb/core/formats/arrow\n+)\n+\n+END()\ndiff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/ya.make b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/ya.make\nindex 45fef368d323..baff60941f27 100644\n--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/ya.make\n+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/ya.make\n@@ -14,6 +14,8 @@ PEERDIR(\n     ydb/core/formats/arrow\n     ydb/core/tx/columnshard/blobs_action\n     ydb/core/tx/columnshard/engines/reader/common_reader/iterator\n+    ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections\n+    ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points\n     ydb/core/tx/conveyor/usage\n     ydb/core/tx/limiter/grouped_memory/usage\n )\ndiff --git a/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/iterator.cpp b/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/iterator.cpp\nindex abbfad5c92f6..26e1ebdb0950 100644\n--- a/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/iterator.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/iterator.cpp\n@@ -44,8 +44,9 @@ TConclusion<std::shared_ptr<TPartialReadResult>> TStatsIteratorBase::GetBatch()\n         auto lastKey = keyBatch->Slice(keyBatch->num_rows() - 1, 1);\n \n         {\n-            NArrow::TColumnFilter filter = ReadMetadata->GetPKRangesFilter().BuildFilter(originalBatch);\n-            AFL_VERIFY(filter.Apply(originalBatch));\n+            NArrow::TColumnFilter filter =\n+                ReadMetadata->GetPKRangesFilter().BuildFilter(std::make_shared<NArrow::TGeneralContainer>(originalBatch));\n+            filter.Apply(originalBatch);\n         }\n \n         // Leave only requested columns\ndiff --git a/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/metadata.h b/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/metadata.h\nindex 7a9ee6bd36b5..63eff2dc866c 100644\n--- a/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/metadata.h\n+++ b/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/metadata.h\n@@ -11,15 +11,13 @@ struct TReadStatsMetadata: public TReadMetadataBase {\n public:\n     using TConstPtr = std::shared_ptr<const TReadStatsMetadata>;\n \n-    const ui64 TabletId;\n     std::vector<ui32> ReadColumnIds;\n     std::vector<ui32> ResultColumnIds;\n     std::deque<TGranuleMetaView> IndexGranules;\n \n     explicit TReadStatsMetadata(const std::shared_ptr<TVersionedIndex>& info, ui64 tabletId, const ESorting sorting,\n         const TProgramContainer& ssaProgram, const std::shared_ptr<ISnapshotSchema>& schema, const TSnapshot& requestSnapshot)\n-        : TBase(info, sorting, ssaProgram, schema, requestSnapshot, nullptr)\n-        , TabletId(tabletId) {\n+        : TBase(info, sorting, ssaProgram, schema, requestSnapshot, nullptr, tabletId) {\n     }\n };\n \ndiff --git a/ydb/core/tx/columnshard/engines/reader/sys_view/chunks/chunks.cpp b/ydb/core/tx/columnshard/engines/reader/sys_view/chunks/chunks.cpp\nindex 1df5bfeae1d1..664a4ac881cc 100644\n--- a/ydb/core/tx/columnshard/engines/reader/sys_view/chunks/chunks.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/sys_view/chunks/chunks.cpp\n@@ -37,7 +37,7 @@ void TStatsIterator::AppendStats(\n         for (auto&& r : records) {\n             NArrow::Append<arrow::UInt64Type>(*builders[0], portion.GetPathId().GetRawValue());\n             NArrow::Append<arrow::StringType>(*builders[1], prodView);\n-            NArrow::Append<arrow::UInt64Type>(*builders[2], ReadMetadata->TabletId);\n+            NArrow::Append<arrow::UInt64Type>(*builders[2], ReadMetadata->GetTabletId());\n             NArrow::Append<arrow::UInt64Type>(*builders[3], r->GetMeta().GetRecordsCount());\n             NArrow::Append<arrow::UInt64Type>(*builders[4], r->GetMeta().GetRawBytes());\n             NArrow::Append<arrow::UInt64Type>(*builders[5], portion.GetPortionId());\n@@ -94,7 +94,7 @@ void TStatsIterator::AppendStats(\n         for (auto&& r : indexes) {\n             NArrow::Append<arrow::UInt64Type>(*builders[0], portion.GetPathId().GetRawValue());\n             NArrow::Append<arrow::StringType>(*builders[1], prodView);\n-            NArrow::Append<arrow::UInt64Type>(*builders[2], ReadMetadata->TabletId);\n+            NArrow::Append<arrow::UInt64Type>(*builders[2], ReadMetadata->GetTabletId());\n             NArrow::Append<arrow::UInt64Type>(*builders[3], r->GetRecordsCount());\n             NArrow::Append<arrow::UInt64Type>(*builders[4], r->GetRawBytes());\n             NArrow::Append<arrow::UInt64Type>(*builders[5], portion.GetPortionId());\n@@ -131,8 +131,7 @@ std::vector<std::pair<TString, NKikimr::NScheme::TTypeInfo>> TReadStatsMetadata:\n std::shared_ptr<NAbstract::TReadStatsMetadata> TConstructor::BuildMetadata(\n     const NColumnShard::TColumnShard* self, const TReadDescription& read) const {\n     auto* index = self->GetIndexOptional();\n-    return std::make_shared<TReadStatsMetadata>(index ? index->CopyVersionedIndexPtr() : nullptr, self->TabletID(),\n-        IsReverse ? TReadMetadataBase::ESorting::DESC : TReadMetadataBase::ESorting::ASC, read.GetProgram(),\n+    return std::make_shared<TReadStatsMetadata>(index ? index->CopyVersionedIndexPtr() : nullptr, self->TabletID(), Sorting, read.GetProgram(),\n         index ? index->GetVersionedIndex().GetLastSchema() : nullptr, read.GetSnapshot());\n }\n \ndiff --git a/ydb/core/tx/columnshard/engines/reader/sys_view/granules/granules.cpp b/ydb/core/tx/columnshard/engines/reader/sys_view/granules/granules.cpp\nindex 62d911c5f8f7..b714821d7c9f 100644\n--- a/ydb/core/tx/columnshard/engines/reader/sys_view/granules/granules.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/sys_view/granules/granules.cpp\n@@ -1,14 +1,16 @@\n #include \"granules.h\"\n+\n #include <ydb/core/formats/arrow/switch/switch_type.h>\n #include <ydb/core/tx/columnshard/blobs_action/common/const.h>\n #include <ydb/core/tx/columnshard/engines/reader/abstract/read_context.h>\n+\n #include <util/system/hostname.h>\n \n namespace NKikimr::NOlap::NReader::NSysView::NGranules {\n \n bool TStatsIterator::AppendStats(const std::vector<std::unique_ptr<arrow::ArrayBuilder>>& builders, NAbstract::TGranuleMetaView& granule) const {\n     NArrow::Append<arrow::UInt64Type>(*builders[0], granule.GetPathId().GetRawValue());\n-    NArrow::Append<arrow::UInt64Type>(*builders[1], ReadMetadata->TabletId);\n+    NArrow::Append<arrow::UInt64Type>(*builders[1], ReadMetadata->GetTabletId());\n     NArrow::Append<arrow::UInt64Type>(*builders[2], granule.GetPortions().size());\n     NArrow::Append<arrow::StringType>(*builders[3], HostNameField);\n     NArrow::Append<arrow::UInt64Type>(*builders[4], NActors::TActivationContext::AsActorContext().SelfID.NodeId());\n@@ -23,11 +25,11 @@ std::vector<std::pair<TString, NKikimr::NScheme::TTypeInfo>> TReadStatsMetadata:\n     return GetColumns(TStatsIterator::StatsSchema, TStatsIterator::StatsSchema.KeyColumns);\n }\n \n-std::shared_ptr<NAbstract::TReadStatsMetadata> TConstructor::BuildMetadata(const NColumnShard::TColumnShard* self, const TReadDescription& read) const {\n+std::shared_ptr<NAbstract::TReadStatsMetadata> TConstructor::BuildMetadata(\n+    const NColumnShard::TColumnShard* self, const TReadDescription& read) const {\n     auto* index = self->GetIndexOptional();\n-    return std::make_shared<TReadStatsMetadata>(index ? index->CopyVersionedIndexPtr() : nullptr, self->TabletID(),\n-        IsReverse ? TReadMetadataBase::ESorting::DESC : TReadMetadataBase::ESorting::ASC,\n-        read.GetProgram(), index ? index->GetVersionedIndex().GetLastSchema() : nullptr, read.GetSnapshot());\n+    return std::make_shared<TReadStatsMetadata>(index ? index->CopyVersionedIndexPtr() : nullptr, self->TabletID(), Sorting, read.GetProgram(),\n+        index ? index->GetVersionedIndex().GetLastSchema() : nullptr, read.GetSnapshot());\n }\n \n-}\n+}   // namespace NKikimr::NOlap::NReader::NSysView::NGranules\ndiff --git a/ydb/core/tx/columnshard/engines/reader/sys_view/optimizer/optimizer.cpp b/ydb/core/tx/columnshard/engines/reader/sys_view/optimizer/optimizer.cpp\nindex 813362a71329..c43e82b690fd 100644\n--- a/ydb/core/tx/columnshard/engines/reader/sys_view/optimizer/optimizer.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/sys_view/optimizer/optimizer.cpp\n@@ -1,7 +1,9 @@\n #include \"optimizer.h\"\n+\n #include <ydb/core/formats/arrow/switch/switch_type.h>\n #include <ydb/core/tx/columnshard/blobs_action/common/const.h>\n #include <ydb/core/tx/columnshard/engines/reader/abstract/read_context.h>\n+\n #include <util/system/hostname.h>\n \n namespace NKikimr::NOlap::NReader::NSysView::NOptimizer {\n@@ -9,7 +11,7 @@ namespace NKikimr::NOlap::NReader::NSysView::NOptimizer {\n bool TStatsIterator::AppendStats(const std::vector<std::unique_ptr<arrow::ArrayBuilder>>& builders, NAbstract::TGranuleMetaView& granule) const {\n     for (auto&& i : granule.GetOptimizerTasks()) {\n         NArrow::Append<arrow::UInt64Type>(*builders[0], granule.GetPathId().GetRawValue());\n-        NArrow::Append<arrow::UInt64Type>(*builders[1], ReadMetadata->TabletId);\n+        NArrow::Append<arrow::UInt64Type>(*builders[1], ReadMetadata->GetTabletId());\n         NArrow::Append<arrow::UInt64Type>(*builders[2], i.GetTaskId());\n         NArrow::Append<arrow::StringType>(*builders[3], HostNameField);\n         NArrow::Append<arrow::UInt64Type>(*builders[4], NActors::TActivationContext::AsActorContext().SelfID.NodeId());\n@@ -30,11 +32,11 @@ std::vector<std::pair<TString, NKikimr::NScheme::TTypeInfo>> TReadStatsMetadata:\n     return GetColumns(TStatsIterator::StatsSchema, TStatsIterator::StatsSchema.KeyColumns);\n }\n \n-std::shared_ptr<NAbstract::TReadStatsMetadata> TConstructor::BuildMetadata(const NColumnShard::TColumnShard* self, const TReadDescription& read) const {\n+std::shared_ptr<NAbstract::TReadStatsMetadata> TConstructor::BuildMetadata(\n+    const NColumnShard::TColumnShard* self, const TReadDescription& read) const {\n     auto* index = self->GetIndexOptional();\n-    return std::make_shared<TReadStatsMetadata>(index ? index->CopyVersionedIndexPtr() : nullptr, self->TabletID(),\n-        IsReverse ? TReadMetadataBase::ESorting::DESC : TReadMetadataBase::ESorting::ASC,\n-        read.GetProgram(), index ? index->GetVersionedIndex().GetLastSchema() : nullptr, read.GetSnapshot());\n+    return std::make_shared<TReadStatsMetadata>(index ? index->CopyVersionedIndexPtr() : nullptr, self->TabletID(), Sorting, read.GetProgram(),\n+        index ? index->GetVersionedIndex().GetLastSchema() : nullptr, read.GetSnapshot());\n }\n \n-}\n+}   // namespace NKikimr::NOlap::NReader::NSysView::NOptimizer\ndiff --git a/ydb/core/tx/columnshard/engines/reader/sys_view/portions/portions.cpp b/ydb/core/tx/columnshard/engines/reader/sys_view/portions/portions.cpp\nindex 3e58ce3a82e7..ae0e9bf3e29f 100644\n--- a/ydb/core/tx/columnshard/engines/reader/sys_view/portions/portions.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/sys_view/portions/portions.cpp\n@@ -1,4 +1,5 @@\n #include \"portions.h\"\n+\n #include <ydb/core/formats/arrow/switch/switch_type.h>\n #include <ydb/core/tx/columnshard/blobs_action/common/const.h>\n #include <ydb/core/tx/columnshard/engines/reader/abstract/read_context.h>\n@@ -9,7 +10,7 @@ void TStatsIterator::AppendStats(const std::vector<std::unique_ptr<arrow::ArrayB\n     NArrow::Append<arrow::UInt64Type>(*builders[0], portion.GetPathId().GetRawValue());\n     const std::string prod = ::ToString(portion.GetMeta().Produced);\n     NArrow::Append<arrow::StringType>(*builders[1], prod);\n-    NArrow::Append<arrow::UInt64Type>(*builders[2], ReadMetadata->TabletId);\n+    NArrow::Append<arrow::UInt64Type>(*builders[2], ReadMetadata->GetTabletId());\n     NArrow::Append<arrow::UInt64Type>(*builders[3], portion.GetRecordsCount());\n     NArrow::Append<arrow::UInt64Type>(*builders[4], portion.GetColumnRawBytes());\n     NArrow::Append<arrow::UInt64Type>(*builders[5], portion.GetIndexRawBytes());\n@@ -60,11 +61,11 @@ std::vector<std::pair<TString, NKikimr::NScheme::TTypeInfo>> TReadStatsMetadata:\n     return GetColumns(TStatsIterator::StatsSchema, TStatsIterator::StatsSchema.KeyColumns);\n }\n \n-std::shared_ptr<NAbstract::TReadStatsMetadata> TConstructor::BuildMetadata(const NColumnShard::TColumnShard* self, const TReadDescription& read) const {\n+std::shared_ptr<NAbstract::TReadStatsMetadata> TConstructor::BuildMetadata(\n+    const NColumnShard::TColumnShard* self, const TReadDescription& read) const {\n     auto* index = self->GetIndexOptional();\n-    return std::make_shared<TReadStatsMetadata>(index ? index->CopyVersionedIndexPtr() : nullptr, self->TabletID(),\n-        IsReverse ? TReadMetadataBase::ESorting::DESC : TReadMetadataBase::ESorting::ASC,\n-        read.GetProgram(), index ? index->GetVersionedIndex().GetLastSchema() : nullptr, read.GetSnapshot());\n+    return std::make_shared<TReadStatsMetadata>(index ? index->CopyVersionedIndexPtr() : nullptr, self->TabletID(), Sorting, read.GetProgram(),\n+        index ? index->GetVersionedIndex().GetLastSchema() : nullptr, read.GetSnapshot());\n }\n \n-}\n+}   // namespace NKikimr::NOlap::NReader::NSysView::NPortions\ndiff --git a/ydb/core/tx/columnshard/engines/reader/transaction/tx_internal_scan.cpp b/ydb/core/tx/columnshard/engines/reader/transaction/tx_internal_scan.cpp\nindex 76a66c25b475..519cba47c90a 100644\n--- a/ydb/core/tx/columnshard/engines/reader/transaction/tx_internal_scan.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/transaction/tx_internal_scan.cpp\n@@ -38,9 +38,13 @@ void TTxInternalScan::Complete(const TActorContext& ctx) {\n     const NActors::TLogContextGuard gLogging =\n         NActors::TLogContextBuilder::Build()(\"tablet\", Self->TabletID())(\"snapshot\", snapshot.DebugString())(\"task_id\", request.TaskIdentifier);\n     TReadMetadataPtr readMetadataRange;\n-    TScannerConstructorContext context(snapshot, 0, request.GetReverse());\n+    const TReadMetadataBase::ESorting sorting = [&]() {\n+        return request.GetReverse() ? TReadMetadataBase::ESorting::DESC : TReadMetadataBase::ESorting::ASC;\n+    }();\n+\n+    TScannerConstructorContext context(snapshot, 0, sorting);\n     {\n-        TReadDescription read(snapshot, request.GetReverse());\n+        TReadDescription read(Self->TabletID(), snapshot, sorting);\n         read.SetScanIdentifier(request.TaskIdentifier);\n         read.PathId = request.GetPathId();\n         read.LockId = LockId;\ndiff --git a/ydb/core/tx/columnshard/engines/reader/transaction/tx_scan.cpp b/ydb/core/tx/columnshard/engines/reader/transaction/tx_scan.cpp\nindex 3ab63b339ce8..bcca02549984 100644\n--- a/ydb/core/tx/columnshard/engines/reader/transaction/tx_scan.cpp\n+++ b/ydb/core/tx/columnshard/engines/reader/transaction/tx_scan.cpp\n@@ -38,7 +38,16 @@ void TTxScan::Complete(const TActorContext& ctx) {\n     if (snapshot.IsZero()) {\n         snapshot = Self->GetLastTxSnapshot();\n     }\n-    TScannerConstructorContext context(snapshot, request.HasItemsLimit() ? request.GetItemsLimit() : 0, request.GetReverse());\n+    const TReadMetadataBase::ESorting sorting =\n+        [&]() {\n+            if (request.HasReverse()) {\n+                return request.GetReverse() ? TReadMetadataBase::ESorting::DESC : TReadMetadataBase::ESorting::ASC;\n+            } else {\n+                return TReadMetadataBase::ESorting::NONE;\n+            }\n+    }();\n+\n+    TScannerConstructorContext context(snapshot, request.HasItemsLimit() ? request.GetItemsLimit() : 0, sorting);\n     const auto scanId = request.GetScanId();\n     const ui64 txId = request.GetTxId();\n     const ui32 scanGen = request.GetGeneration();\n@@ -55,7 +64,7 @@ void TTxScan::Complete(const TActorContext& ctx) {\n     {\n         LOG_S_DEBUG(\"TTxScan prepare txId: \" << txId << \" scanId: \" << scanId << \" at tablet \" << Self->TabletID());\n \n-        TReadDescription read(snapshot, request.GetReverse());\n+        TReadDescription read(Self->TabletID(), snapshot, sorting);\n         read.TxId = txId;\n         if (request.HasLockTxId()) {\n             read.LockId = request.GetLockTxId();\n@@ -95,7 +104,7 @@ void TTxScan::Complete(const TActorContext& ctx) {\n         if (!scannerConstructor) {\n             return SendError(\"cannot build scanner\", AppDataVerified().ColumnShardConfig.GetReaderClassName(), ctx);\n         }\n-        {\n+        if (request.HasScanCursor()) {\n             auto cursorConclusion = scannerConstructor->BuildCursorFromProto(request.GetScanCursor());\n             if (cursorConclusion.IsFail()) {\n                 return SendError(\"cannot build scanner cursor\", cursorConclusion.GetErrorMessage(), ctx);\n@@ -110,28 +119,23 @@ void TTxScan::Complete(const TActorContext& ctx) {\n         if (!parseResult) {\n             return SendError(\"cannot parse program\", parseResult.GetErrorMessage(), ctx);\n         }\n-\n-        if (!request.RangesSize()) {\n+        {\n+            if (request.RangesSize()) {\n+                auto ydbKey = scannerConstructor->GetPrimaryKeyScheme(Self);\n+                {\n+                    auto filterConclusion = NOlap::TPKRangesFilter::BuildFromProto(request, ydbKey);\n+                    if (filterConclusion.IsFail()) {\n+                        return SendError(\"cannot build ranges filter\", filterConclusion.GetErrorMessage(), ctx);\n+                    }\n+                    read.PKRangesFilter = std::make_shared<NOlap::TPKRangesFilter>(filterConclusion.DetachResult());\n+                }\n+            }\n             auto newRange = scannerConstructor->BuildReadMetadata(Self, read);\n             if (newRange.IsSuccess()) {\n                 readMetadataRange = TValidator::CheckNotNull(newRange.DetachResult());\n             } else {\n                 return SendError(\"cannot build metadata withno ranges\", newRange.GetErrorMessage(), ctx);\n             }\n-        } else {\n-            auto ydbKey = scannerConstructor->GetPrimaryKeyScheme(Self);\n-            {\n-                auto filterConclusion = NOlap::TPKRangesFilter::BuildFromProto(request, request.GetReverse(), ydbKey);\n-                if (filterConclusion.IsFail()) {\n-                    return SendError(\"cannot build ranges filter\", filterConclusion.GetErrorMessage(), ctx);\n-                }\n-                read.PKRangesFilter = std::make_shared<NOlap::TPKRangesFilter>(filterConclusion.DetachResult());\n-            }\n-            auto newRange = scannerConstructor->BuildReadMetadata(Self, read);\n-            if (!newRange) {\n-                return SendError(\"cannot build metadata\", newRange.GetErrorMessage(), ctx);\n-            }\n-            readMetadataRange = TValidator::CheckNotNull(newRange.DetachResult());\n         }\n     }\n     AFL_VERIFY(readMetadataRange);\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/index_info.cpp b/ydb/core/tx/columnshard/engines/scheme/index_info.cpp\nindex b49760873c23..12b1a1b9c6f7 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/index_info.cpp\n+++ b/ydb/core/tx/columnshard/engines/scheme/index_info.cpp\n@@ -667,7 +667,7 @@ ui32 TIndexInfo::GetColumnIndexVerified(const ui32 id) const {\n }\n \n std::vector<std::shared_ptr<NIndexes::TSkipIndex>> TIndexInfo::FindSkipIndexes(\n-    const NIndexes::NRequest::TOriginalDataAddress& originalDataAddress, const NArrow::NSSA::EIndexCheckOperation op) const {\n+    const NIndexes::NRequest::TOriginalDataAddress& originalDataAddress, const NArrow::NSSA::TIndexCheckOperation& op) const {\n     std::vector<std::shared_ptr<NIndexes::TSkipIndex>> result;\n     for (auto&& [_, i] : Indexes) {\n         if (!i->IsSkipIndex()) {\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/index_info.h b/ydb/core/tx/columnshard/engines/scheme/index_info.h\nindex bb45f1e45a0b..7fc0cce69a22 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/index_info.h\n+++ b/ydb/core/tx/columnshard/engines/scheme/index_info.h\n@@ -174,6 +174,11 @@ struct TIndexInfo: public IIndexInfo {\n         return ColumnFeatures[colIndex]->GetIsNullable();\n     }\n \n+    const TColumnFeatures& GetColumnFeaturesVerifiedByIndex(const ui32 colIndex) const {\n+        AFL_VERIFY(colIndex < ColumnFeatures.size());\n+        return *ColumnFeatures[colIndex];\n+    }\n+\n     bool IsNullableVerified(const ui32 colId) const {\n         return GetColumnFeaturesVerified(colId).GetIsNullable();\n     }\n@@ -330,7 +335,7 @@ struct TIndexInfo: public IIndexInfo {\n     }\n \n     std::vector<std::shared_ptr<NIndexes::TSkipIndex>> FindSkipIndexes(\n-        const NIndexes::NRequest::TOriginalDataAddress& originalDataAddress, const NArrow::NSSA::EIndexCheckOperation op) const;\n+        const NIndexes::NRequest::TOriginalDataAddress& originalDataAddress, const NArrow::NSSA::TIndexCheckOperation& op) const;\n     std::shared_ptr<NIndexes::NMax::TIndexMeta> GetIndexMetaMax(const ui32 columnId) const;\n     std::shared_ptr<NIndexes::NCountMinSketch::TIndexMeta> GetIndexMetaCountMinSketch(const std::set<ui32>& columnIds) const;\n \n@@ -377,6 +382,16 @@ struct TIndexInfo: public IIndexInfo {\n         return PKColumnIds[0];\n     }\n \n+    std::shared_ptr<arrow::Schema> GetReplaceKeyPrefix(const ui32 size) const {\n+        AFL_VERIFY(size);\n+        AFL_VERIFY(size <= (ui32)PrimaryKey->num_fields());\n+        if (size == (ui32)PrimaryKey->num_fields()) {\n+            return PrimaryKey;\n+        } else {\n+            std::vector<std::shared_ptr<arrow::Field>> fields(PrimaryKey->fields().begin(), PrimaryKey->fields().begin() + size);\n+            return std::make_shared<arrow::Schema>(std::move(fields));\n+        }\n+    }\n     const std::shared_ptr<arrow::Schema>& GetReplaceKey() const {\n         return PrimaryKey;\n     }\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/collection.cpp b/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/collection.cpp\nindex 07a765aacb9a..12b6d788a38e 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/collection.cpp\n+++ b/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/collection.cpp\n@@ -6,7 +6,7 @@\n namespace NKikimr::NOlap::NIndexes {\n \n std::shared_ptr<IIndexMeta> TIndexesCollection::FindIndexFor(\n-    const NRequest::TOriginalDataAddress& address, const NArrow::NSSA::EIndexCheckOperation op) const {\n+    const NRequest::TOriginalDataAddress& address, const NArrow::NSSA::TIndexCheckOperation& op) const {\n     auto it = IndexByOriginalData.find(address);\n     if (it == IndexByOriginalData.end()) {\n         return nullptr;\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/collection.h b/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/collection.h\nindex 5b6a88985f6a..1fc9c5adc2ce 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/collection.h\n+++ b/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/collection.h\n@@ -181,7 +181,7 @@ class TIndexesCollection {\n         }\n     }\n \n-    std::shared_ptr<IIndexMeta> FindIndexFor(const NRequest::TOriginalDataAddress& address, const NArrow::NSSA::EIndexCheckOperation op) const;\n+    std::shared_ptr<IIndexMeta> FindIndexFor(const NRequest::TOriginalDataAddress& address, const NArrow::NSSA::TIndexCheckOperation& op) const;\n };\n \n }   // namespace NKikimr::NOlap::NIndexes\ndiff --git a/ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.cpp b/ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.cpp\nindex b93bb5d1cbf1..833ea12ff37d 100644\n--- a/ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.cpp\n+++ b/ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.cpp\n@@ -101,8 +101,17 @@ TConclusion<NArrow::TContainerWithIndexes<arrow::RecordBatch>> ISnapshotSchema::\n         if (targetIdx == -1) {\n             return TConclusionStatus::Success();\n         }\n-        const auto hasNull = NArrow::HasNulls(incomingBatch->column(incomingIdx));\n-        const std::optional<i32> pkFieldIdx = GetIndexInfo().GetPKColumnIndexByIndexVerified(targetIdx);\n+        const auto& incomingColumn = incomingBatch->column(incomingIdx);\n+        const auto hasNull = NArrow::HasNulls(incomingColumn);\n+        const TColumnFeatures& features = GetIndexInfo().GetColumnFeaturesVerifiedByIndex(targetIdx);\n+        const std::optional<i32> pkFieldIdx = features.GetPKColumnIndex();\n+        if (!features.GetDataAccessorConstructor()->HasInternalConversion() || !!pkFieldIdx) {\n+            if (!features.GetArrowField()->type()->Equals(incomingColumn->type())) {\n+                return TConclusionStatus::Fail(\n+                    \"not equal type for column: \" + features.GetColumnName() + \": \" + features.GetArrowField()->type()->ToString()\n+                    + \" vs \" + incomingColumn->type()->ToString());\n+            }\n+        }\n         if (pkFieldIdx && hasNull && !AppData()->ColumnShardConfig.GetAllowNullableColumnsInPK()) {\n             return TConclusionStatus::Fail(\"null data for pk column is impossible for '\" + dstSchema.field(targetIdx)->name() + \"'\");\n         }\n@@ -130,7 +139,7 @@ TConclusion<NArrow::TContainerWithIndexes<arrow::RecordBatch>> ISnapshotSchema::\n     const auto nameResolver = [&](const std::string& fieldName) -> i32 {\n         return GetIndexInfo().GetColumnIndexOptional(fieldName).value_or(-1);\n     };\n-    auto batchConclusion = NArrow::TColumnOperator().SkipIfAbsent().ErrorOnDifferentFieldTypes().AdaptIncomingToDestinationExt(\n+    auto batchConclusion = NArrow::TColumnOperator().SkipIfAbsent().IgnoreOnDifferentFieldTypes().AdaptIncomingToDestinationExt(\n         incomingBatch, dstSchema, pred, nameResolver);\n     if (batchConclusion.IsFail()) {\n         return batchConclusion;\n@@ -331,6 +340,7 @@ TConclusion<TWritePortionInfoWithBlobsResult> ISnapshotSchema::PrepareForWrite(c\n             TConclusion<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> arrToWrite =\n                 loader->GetAccessorConstructor()->Construct(accessor, loader->BuildAccessorContext(accessor->GetRecordsCount()));\n             if (arrToWrite.IsFail()) {\n+                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"cannot build accessor\")(\"reason\", arrToWrite.GetErrorMessage());\n                 return arrToWrite;\n             }\n \ndiff --git a/ydb/core/tx/columnshard/engines/storage/actualizer/counters/counters.h b/ydb/core/tx/columnshard/engines/storage/actualizer/counters/counters.h\nindex e803df700f7b..1452f7bb342c 100644\n--- a/ydb/core/tx/columnshard/engines/storage/actualizer/counters/counters.h\n+++ b/ydb/core/tx/columnshard/engines/storage/actualizer/counters/counters.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n #include <ydb/core/tx/columnshard/engines/portions/portion_info.h>\n \n namespace NKikimr::NOlap::NActualizer {\ndiff --git a/ydb/core/tx/columnshard/engines/storage/actualizer/counters/ya.make b/ydb/core/tx/columnshard/engines/storage/actualizer/counters/ya.make\nindex d73b370747be..81a1e3cdd937 100644\n--- a/ydb/core/tx/columnshard/engines/storage/actualizer/counters/ya.make\n+++ b/ydb/core/tx/columnshard/engines/storage/actualizer/counters/ya.make\n@@ -7,7 +7,7 @@ SRCS(\n PEERDIR(\n     ydb/library/actors/core\n     ydb/core/tx/columnshard/engines/portions\n-    ydb/core/tx/columnshard/counters/common\n+    ydb/library/signals\n )\n \n END()\ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/abstract.h b/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/abstract.h\nindex 923bd35a8478..208daf711ac7 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/abstract.h\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/abstract.h\n@@ -50,7 +50,7 @@ class IBitsStorageConstructor {\n     virtual TConclusion<std::shared_ptr<IBitsStorage>> DoBuild(const TString& data) const = 0;\n \n public:\n-    static std::shared_ptr<IBitsStorageConstructor> GetDefault();;\n+    static std::shared_ptr<IBitsStorageConstructor> GetDefault();\n \n     virtual ~IBitsStorageConstructor() = default;\n \ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/bitset.h b/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/bitset.h\nindex 4674af24374b..63b7e6abfc62 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/bitset.h\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/bitset.h\n@@ -30,6 +30,9 @@ class TBitSetStorage: public IBitsStorage {\n     }\n \n     bool TestHash(const ui64 hash) const {\n+        if (!Bits.Size()) {\n+            return false;\n+        }\n         return Bits.Get(hash % Bits.Size());\n     }\n \ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/string.cpp b/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/string.cpp\nindex c2a4b2a451d0..54e52e803445 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/string.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/string.cpp\n@@ -7,6 +7,9 @@\n namespace NKikimr::NOlap::NIndexes {\n \n bool TFixStringBitsStorage::DoGet(const ui32 idx) const {\n+    if (!Data.size()) {\n+        return false;\n+    }\n     AFL_VERIFY(idx < Data.size() * 8);\n     const ui8 start = (*(ui8*)&Data[idx / 8]);\n     return start & (1 << (idx % 8));\ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.cpp b/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.cpp\nindex 6a2bc50a2dfa..2ba8811ff4ad 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.cpp\n@@ -63,10 +63,10 @@ TString TBloomIndexMeta::DoBuildIndexImpl(TChunkedBatchReader& reader, const ui3\n     return GetBitsStorageConstructor()->Build(std::move(filterBits))->SerializeToString();\n }\n \n-bool TBloomIndexMeta::DoCheckValueImpl(\n-    const IBitsStorage& data, const std::optional<ui64> category, const std::shared_ptr<arrow::Scalar>& value, const EOperation op) const {\n+bool TBloomIndexMeta::DoCheckValueImpl(const IBitsStorage& data, const std::optional<ui64> category, const std::shared_ptr<arrow::Scalar>& value,\n+    const NArrow::NSSA::TIndexCheckOperation& op) const {\n     std::set<ui64> hashes;\n-    AFL_VERIFY(op == EOperation::Equals)(\"op\", op);\n+    AFL_VERIFY(op.GetOperation() == EOperation::Equals)(\"op\", op.DebugString());\n     const ui32 bitsCount = data.GetBitsCount();\n     if (!!category) {\n         for (ui64 hashSeed = 0; hashSeed < HashesCount; ++hashSeed) {\n@@ -88,8 +88,8 @@ bool TBloomIndexMeta::DoCheckValueImpl(\n \n std::optional<ui64> TBloomIndexMeta::DoCalcCategory(const TString& subColumnName) const {\n     ui64 result;\n-    const NRequest::TOriginalDataAddress addr(Max<ui32>(), subColumnName);\n-    AFL_VERIFY(GetDataExtractor()->CheckForIndex(addr, result));\n+    const NRequest::TOriginalDataAddress addr(GetColumnId(), subColumnName);\n+    AFL_VERIFY(GetDataExtractor()->CheckForIndex(addr, &result));\n     if (subColumnName) {\n         return result;\n     } else {\ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.h b/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.h\nindex 2be01b8d7942..bdb39bb44508 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.h\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.h\n@@ -20,8 +20,8 @@ class TBloomIndexMeta: public TSkipBitmapIndex {\n \n     virtual std::optional<ui64> DoCalcCategory(const TString& subColumnName) const override;\n \n-    virtual bool DoIsAppropriateFor(const TString& /*subColumnName*/, const EOperation op) const override {\n-        return op == EOperation::Equals;\n+    virtual bool DoIsAppropriateFor(const NArrow::NSSA::TIndexCheckOperation& op) const override {\n+        return op.GetOperation() == EOperation::Equals && op.GetCaseSensitive();\n     }\n \n protected:\n@@ -32,7 +32,7 @@ class TBloomIndexMeta: public TSkipBitmapIndex {\n     virtual void DoSerializeToProto(NKikimrSchemeOp::TOlapIndexDescription& proto) const override;\n \n     virtual bool DoCheckValueImpl(const IBitsStorage& data, const std::optional<ui64> category, const std::shared_ptr<arrow::Scalar>& value,\n-        const EOperation op) const override;\n+        const NArrow::NSSA::TIndexCheckOperation& op) const override;\n \n public:\n     TBloomIndexMeta() = default;\ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/constructor.cpp b/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/constructor.cpp\nindex b73e9195feab..60131226f065 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/constructor.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/constructor.cpp\n@@ -16,7 +16,7 @@ std::shared_ptr<IIndexMeta> TIndexConstructor::DoCreateIndexMeta(\n     }\n     const ui32 columnId = columnInfo->GetId();\n     return std::make_shared<TIndexMeta>(indexId, indexName, GetStorageId().value_or(NBlobOperations::TGlobal::DefaultStorageId), columnId,\n-        GetDataExtractor(), HashesCount, FilterSizeBytes, NGrammSize, RecordsCount, TBase::GetBitsStorageConstructor());\n+        GetDataExtractor(), HashesCount, FilterSizeBytes, NGrammSize, RecordsCount, TBase::GetBitsStorageConstructor(), CaseSensitive);\n }\n \n TConclusionStatus TIndexConstructor::DoDeserializeFromJson(const NJson::TJsonValue& jsonInfo) {\n@@ -61,7 +61,15 @@ TConclusionStatus TIndexConstructor::DoDeserializeFromJson(const NJson::TJsonVal\n         return TConclusionStatus::Fail(\n             \"hashes_count have to be in bloom ngramm filter in interval \" + TConstants::GetHashesCountIntervalString());\n     }\n+\n+    if (jsonInfo.Has(\"case_sensitive\")) {\n+        if (!jsonInfo[\"case_sensitive\"].IsBoolean()) {\n+            return TConclusionStatus::Fail(\"case_sensitive have to be in bloom filter features as boolean field\");\n+        }\n+        CaseSensitive = jsonInfo[\"case_sensitive\"].GetBoolean();\n+    }\n     return TConclusionStatus::Success();\n+\n }\n \n NKikimr::TConclusionStatus TIndexConstructor::DoDeserializeFromProto(const NKikimrSchemeOp::TOlapIndexRequested& proto) {\n@@ -77,6 +85,9 @@ NKikimr::TConclusionStatus TIndexConstructor::DoDeserializeFromProto(const NKiki\n             return conclusion;\n         }\n     }\n+    if (bFilter.HasCaseSensitive()) {\n+        CaseSensitive = bFilter.GetCaseSensitive();\n+    }\n     RecordsCount = bFilter.GetRecordsCount();\n     if (!TConstants::CheckRecordsCount(RecordsCount)) {\n         return TConclusionStatus::Fail(\"RecordsCount have to be in \" + TConstants::GetRecordsCountIntervalString());\n@@ -107,6 +118,7 @@ void TIndexConstructor::DoSerializeToProto(NKikimrSchemeOp::TOlapIndexRequested&\n     auto* filterProto = proto.MutableBloomNGrammFilter();\n     TBase::SerializeToProtoBitsStorageOnly(*filterProto);\n     filterProto->SetColumnName(GetColumnName());\n+    filterProto->SetCaseSensitive(CaseSensitive);\n     filterProto->SetRecordsCount(RecordsCount);\n     filterProto->SetNGrammSize(NGrammSize);\n     filterProto->SetFilterSizeBytes(FilterSizeBytes);\ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/constructor.h b/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/constructor.h\nindex 375de80ebd78..343984c0a993 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/constructor.h\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/constructor.h\n@@ -19,6 +19,7 @@ class TIndexConstructor: public TSkipBitmapIndexConstructor {\n     ui32 FilterSizeBytes = 512;\n     ui32 HashesCount = 2;\n     ui32 RecordsCount = 10000;\n+    bool CaseSensitive = true;\n     static inline auto Registrator = TFactory::TRegistrator<TIndexConstructor>(GetClassNameStatic());\n \n protected:\ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/meta.cpp b/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/meta.cpp\nindex c0dabbc4ba5a..e13c1086c548 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/meta.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/meta.cpp\n@@ -10,12 +10,14 @@\n #include <contrib/libs/apache/arrow/cpp/src/arrow/array/builder_primitive.h>\n #include <library/cpp/deprecated/atomic/atomic.h>\n #include <util/generic/bitmap.h>\n+#include <util/string/ascii.h>\n \n namespace NKikimr::NOlap::NIndexes::NBloomNGramm {\n \n class TNGrammBuilder {\n private:\n     const ui32 HashesCount;\n+    const bool CaseSensitive;\n \n     template <ui32 CharsRemained>\n     class THashesBuilder {\n@@ -133,17 +135,29 @@ class TNGrammBuilder {\n             AFL_VERIFY(false);\n         }\n     };\n+    TBuffer LowerStringBuffer;\n \n public:\n-    TNGrammBuilder(const ui32 hashesCount)\n-        : HashesCount(hashesCount) {\n+    TNGrammBuilder(const ui32 hashesCount, const bool caseSensitive)\n+        : HashesCount(hashesCount)\n+        , CaseSensitive(caseSensitive) {\n     }\n \n     template <class TAction>\n     void BuildNGramms(\n         const char* data, const ui32 dataSize, const std::optional<NRequest::TLikePart::EOperation> op, const ui32 nGrammSize, TAction& pred) {\n-        THashesSelector<TConstants::MaxHashesCount, TConstants::MaxNGrammSize>::BuildHashes(\n-            (const ui8*)data, dataSize, HashesCount, nGrammSize, op, pred);\n+        if (CaseSensitive) {\n+            THashesSelector<TConstants::MaxHashesCount, TConstants::MaxNGrammSize>::BuildHashes(\n+                (const ui8*)data, dataSize, HashesCount, nGrammSize, op, pred);\n+        } else {\n+            LowerStringBuffer.Clear();\n+            LowerStringBuffer.Resize(dataSize);\n+            for (ui32 i = 0; i < dataSize; ++i) {\n+                LowerStringBuffer.Data()[i] = AsciiToLower(data[i]);\n+            }\n+            THashesSelector<TConstants::MaxHashesCount, TConstants::MaxNGrammSize>::BuildHashes(\n+                (const ui8*)LowerStringBuffer.Data(), dataSize, HashesCount, nGrammSize, op, pred);\n+        }\n     }\n \n     template <class TFiller>\n@@ -172,7 +186,12 @@ class TNGrammBuilder {\n \n     template <class TFiller>\n     void FillNGrammHashes(const ui32 nGrammSize, const NRequest::TLikePart::EOperation op, const TString& userReq, TFiller& fillData) {\n-        BuildNGramms(userReq.data(), userReq.size(), op, nGrammSize, fillData);\n+        if (CaseSensitive) {\n+            BuildNGramms(userReq.data(), userReq.size(), op, nGrammSize, fillData);\n+        } else {\n+            const TString lowerString = to_lower(userReq);\n+            BuildNGramms(lowerString.data(), lowerString.size(), op, nGrammSize, fillData);\n+        }\n     }\n };\n \n@@ -259,7 +278,7 @@ class TBitmapDetector<0> {\n \n TString TIndexMeta::DoBuildIndexImpl(TChunkedBatchReader& reader, const ui32 recordsCount) const {\n     AFL_VERIFY(reader.GetColumnsCount() == 1)(\"count\", reader.GetColumnsCount());\n-    TNGrammBuilder builder(HashesCount);\n+    TNGrammBuilder builder(HashesCount, CaseSensitive);\n \n     ui32 size = FilterSizeBytes * 8;\n     if ((size & (size - 1)) == 0) {\n@@ -311,8 +330,8 @@ TString TIndexMeta::DoBuildIndexImpl(TChunkedBatchReader& reader, const ui32 rec\n     return GetBitsStorageConstructor()->Build(inserter.ExtractBits())->SerializeToString();\n }\n \n-bool TIndexMeta::DoCheckValueImpl(\n-    const IBitsStorage& data, const std::optional<ui64> category, const std::shared_ptr<arrow::Scalar>& value, const EOperation op) const {\n+bool TIndexMeta::DoCheckValueImpl(const IBitsStorage& data, const std::optional<ui64> category, const std::shared_ptr<arrow::Scalar>& value,\n+    const NArrow::NSSA::TIndexCheckOperation& op) const {\n     AFL_VERIFY(!category);\n     AFL_VERIFY(value->type->id() == arrow::utf8()->id() || value->type->id() == arrow::binary()->id())(\"id\", value->type->ToString());\n     bool result = true;\n@@ -322,10 +341,11 @@ bool TIndexMeta::DoCheckValueImpl(\n             result = false;\n         }\n     };\n-    TNGrammBuilder builder(HashesCount);\n+    TNGrammBuilder builder(HashesCount, CaseSensitive);\n+    AFL_VERIFY(!CaseSensitive || op.GetCaseSensitive());\n \n     NRequest::TLikePart::EOperation opLike;\n-    switch (op) {\n+    switch (op.GetOperation()) {\n         case TSkipIndex::EOperation::Equals:\n             opLike = NRequest::TLikePart::EOperation::Equals;\n             break;\ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/meta.h b/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/meta.h\nindex d1326c3da469..31f29d1e7a5f 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/meta.h\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/meta.h\n@@ -13,6 +13,7 @@ class TIndexMeta: public TSkipBitmapIndex {\n private:\n     using TBase = TSkipBitmapIndex;\n     std::shared_ptr<arrow::Schema> ResultSchema;\n+    bool CaseSensitive = true;\n     ui32 NGrammSize = 3;\n     ui32 FilterSizeBytes = 512;\n     ui32 RecordsCount = 10000;\n@@ -28,16 +29,13 @@ class TIndexMeta: public TSkipBitmapIndex {\n         AFL_VERIFY(TConstants::CheckRecordsCount(RecordsCount));\n     }\n \n-    virtual bool DoIsAppropriateFor(const TString& subColumnName, const EOperation op) const override {\n-        if (!!subColumnName) {\n-            return false;\n-        }\n-        switch (op) {\n+    virtual bool DoIsAppropriateFor(const NArrow::NSSA::TIndexCheckOperation& op) const override {\n+        switch (op.GetOperation()) {\n             case EOperation::Equals:\n             case EOperation::StartsWith:\n             case EOperation::EndsWith:\n             case EOperation::Contains:\n-                return true;\n+                return !CaseSensitive || op.GetCaseSensitive();\n         }\n \n         return false;\n@@ -50,12 +48,6 @@ class TIndexMeta: public TSkipBitmapIndex {\n             return TConclusionStatus::Fail(\n                 \"cannot read meta as appropriate class: \" + GetClassName() + \". Meta said that class name is \" + newMeta.GetClassName());\n         }\n-        if (HashesCount != bMeta->HashesCount) {\n-            return TConclusionStatus::Fail(\"cannot modify hashes count\");\n-        }\n-        if (NGrammSize != bMeta->NGrammSize) {\n-            return TConclusionStatus::Fail(\"cannot modify ngramm size\");\n-        }\n         return TBase::CheckSameColumnsForModification(newMeta);\n     }\n     virtual TString DoBuildIndexImpl(TChunkedBatchReader& reader, const ui32 recordsCount) const override;\n@@ -80,6 +72,9 @@ class TIndexMeta: public TSkipBitmapIndex {\n         if (!MutableDataExtractor().DeserializeFromProto(bFilter.GetDataExtractor())) {\n             return false;\n         }\n+        if (bFilter.HasCaseSensitive()) {\n+            CaseSensitive = bFilter.GetCaseSensitive();\n+        }\n         HashesCount = bFilter.GetHashesCount();\n         if (!TConstants::CheckHashesCount(HashesCount)) {\n             return false;\n@@ -111,18 +106,20 @@ class TIndexMeta: public TSkipBitmapIndex {\n         filterProto->SetFilterSizeBytes(FilterSizeBytes);\n         filterProto->SetHashesCount(HashesCount);\n         filterProto->SetColumnId(GetColumnId());\n+        filterProto->SetCaseSensitive(CaseSensitive);\n         *filterProto->MutableDataExtractor() = GetDataExtractor().SerializeToProto();\n     }\n \n     virtual bool DoCheckValueImpl(const IBitsStorage& data, const std::optional<ui64> category, const std::shared_ptr<arrow::Scalar>& value,\n-        const EOperation op) const override;\n+        const NArrow::NSSA::TIndexCheckOperation& op) const override;\n \n public:\n     TIndexMeta() = default;\n     TIndexMeta(const ui32 indexId, const TString& indexName, const TString& storageId, const ui32 columnId,\n         const TReadDataExtractorContainer& dataExtractor, const ui32 hashesCount, const ui32 filterSizeBytes, const ui32 nGrammSize,\n-        const ui32 recordsCount, const std::shared_ptr<IBitsStorageConstructor>& bitsStorageConstructor)\n+        const ui32 recordsCount, const std::shared_ptr<IBitsStorageConstructor>& bitsStorageConstructor, const bool caseSensitive)\n         : TBase(indexId, indexName, columnId, storageId, dataExtractor, bitsStorageConstructor)\n+        , CaseSensitive(caseSensitive)\n         , NGrammSize(nGrammSize)\n         , FilterSizeBytes(filterSizeBytes)\n         , RecordsCount(recordsCount)\ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/categories_bloom/meta.cpp b/ydb/core/tx/columnshard/engines/storage/indexes/categories_bloom/meta.cpp\nindex 813605c1ec05..6ce01b442d55 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/categories_bloom/meta.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/categories_bloom/meta.cpp\n@@ -166,11 +166,15 @@ TConclusion<std::shared_ptr<IIndexHeader>> TIndexMeta::DoBuildHeader(const TChun\n     return std::make_shared<TCompositeBloomHeader>(std::move(proto), IIndexHeader::ReadHeaderSize(data.GetDataVerified(), true).DetachResult());\n }\n \n-bool TIndexMeta::DoCheckValueImpl(\n-    const IBitsStorage& data, const std::optional<ui64> category, const std::shared_ptr<arrow::Scalar>& value, const EOperation op) const {\n+bool TIndexMeta::DoCheckValueImpl(const IBitsStorage& data, const std::optional<ui64> category, const std::shared_ptr<arrow::Scalar>& value,\n+    const NArrow::NSSA::TIndexCheckOperation& op) const {\n     AFL_VERIFY(!!category);\n-    AFL_VERIFY(op == EOperation::Equals)(\"op\", op);\n+    AFL_VERIFY(op.GetOperation() == EOperation::Equals)(\"op\", op.DebugString());\n+    AFL_VERIFY(op.GetCaseSensitive());\n     const ui32 bitsCount = data.GetBitsCount();\n+    if (!bitsCount) {\n+        return false;\n+    }\n     for (ui64 hashSeed = 0; hashSeed < HashesCount; ++hashSeed) {\n         const ui64 hash = NArrow::NHash::TXX64::CalcForScalar(value, hashSeed);\n         if (!data.Get(hash % bitsCount)) {\n@@ -182,8 +186,8 @@ bool TIndexMeta::DoCheckValueImpl(\n \n std::optional<ui64> TIndexMeta::DoCalcCategory(const TString& subColumnName) const {\n     ui64 result;\n-    const NRequest::TOriginalDataAddress addr(Max<ui32>(), subColumnName);\n-    AFL_VERIFY(GetDataExtractor()->CheckForIndex(addr, result));\n+    const NRequest::TOriginalDataAddress addr(GetColumnId(), subColumnName);\n+    AFL_VERIFY(GetDataExtractor()->CheckForIndex(addr, &result));\n     return result;\n }\n \ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/categories_bloom/meta.h b/ydb/core/tx/columnshard/engines/storage/indexes/categories_bloom/meta.h\nindex 6f7a2396971c..decf03fb7920 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/categories_bloom/meta.h\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/categories_bloom/meta.h\n@@ -21,15 +21,15 @@ class TIndexMeta: public TSkipBitmapIndex {\n     }\n \n     virtual bool DoCheckValueImpl(const IBitsStorage& data, const std::optional<ui64> category, const std::shared_ptr<arrow::Scalar>& value,\n-        const EOperation op) const override;\n+        const NArrow::NSSA::TIndexCheckOperation& op) const override;\n \n     virtual TConclusion<std::shared_ptr<IIndexHeader>> DoBuildHeader(const TChunkOriginalData& data) const override;\n \n-    virtual bool DoIsAppropriateFor(const TString& subColumnName, const EOperation op) const override {\n-        if (!subColumnName) {\n+    virtual bool DoIsAppropriateFor(const NArrow::NSSA::TIndexCheckOperation& op) const override {\n+        if (!op.GetCaseSensitive()) {\n             return false;\n         }\n-        if (op != EOperation::Equals) {\n+        if (op.GetOperation() != EOperation::Equals) {\n             return false;\n         }\n         return true;\ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/abstract.h b/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/abstract.h\nindex 82fda999716d..ebdb32051afa 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/abstract.h\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/abstract.h\n@@ -23,7 +23,7 @@ class IReadDataExtractor {\n \n     virtual void DoSerializeToProto(TProto& proto) const = 0;\n     virtual bool DoDeserializeFromProto(const TProto& proto) = 0;\n-    virtual bool DoCheckForIndex(const NRequest::TOriginalDataAddress& dataSource, ui64& baseHash) const = 0;\n+    virtual bool DoCheckForIndex(const NRequest::TOriginalDataAddress& dataSource, ui64* baseHash) const = 0;\n     virtual THashMap<ui64, ui32> DoGetIndexHitsCount(const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& dataArray) const = 0;\n \n public:\n@@ -34,8 +34,10 @@ class IReadDataExtractor {\n         return DoGetIndexHitsCount(dataArray);\n     }\n \n-    bool CheckForIndex(const NRequest::TOriginalDataAddress& dataSource, ui64& baseHash) const {\n-        baseHash = 0;\n+    bool CheckForIndex(const NRequest::TOriginalDataAddress& dataSource, ui64* baseHash) const {\n+        if (baseHash) {\n+            *baseHash = 0;\n+        }\n         return DoCheckForIndex(dataSource, baseHash);\n     }\n \ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/default.cpp b/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/default.cpp\nindex 2da8da4da2ae..9a38a9580ea2 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/default.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/default.cpp\n@@ -37,7 +37,7 @@ void TDefaultDataExtractor::DoVisitAll(const std::shared_ptr<NArrow::NAccessor::\n     }\n }\n \n-bool TDefaultDataExtractor::DoCheckForIndex(const NRequest::TOriginalDataAddress& request, ui64& hashBase) const {\n+bool TDefaultDataExtractor::DoCheckForIndex(const NRequest::TOriginalDataAddress& request, ui64* hashBase) const {\n     if (request.GetSubColumnName()) {\n         std::string_view sv = [&]() {\n             if (request.GetSubColumnName().StartsWith(\"$.\")) {\n@@ -46,10 +46,9 @@ bool TDefaultDataExtractor::DoCheckForIndex(const NRequest::TOriginalDataAddress\n                 return std::string_view(request.GetSubColumnName().data(), request.GetSubColumnName().size());\n             }\n         }();\n-        if (sv.starts_with(\"\\\"\") && sv.ends_with(\"\\\"\")) {\n-            sv = std::string_view(sv.data() + 1, sv.size() - 2);\n+        if (hashBase) {\n+            *hashBase = NRequest::TOriginalDataAddress::CalcSubColumnHash(sv);\n         }\n-        hashBase = NRequest::TOriginalDataAddress::CalcSubColumnHash(sv);\n     }\n     return true;\n }\ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/default.h b/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/default.h\nindex 64f534edf594..47de05f3f942 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/default.h\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/default.h\n@@ -27,7 +27,7 @@ class TDefaultDataExtractor: public IReadDataExtractor {\n     virtual void DoVisitAll(const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& dataArray, const TChunkVisitor& chunkVisitor,\n         const TRecordVisitor& recordVisitor) const override;\n \n-    virtual bool DoCheckForIndex(const NRequest::TOriginalDataAddress& request, ui64& hashBase) const override;\n+    virtual bool DoCheckForIndex(const NRequest::TOriginalDataAddress& request, ui64* hashBase) const override;\n     virtual THashMap<ui64, ui32> DoGetIndexHitsCount(const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& dataArray) const override;\n \n public:\ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/sub_column.h b/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/sub_column.h\nindex f7e9e6daa697..6479afc78927 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/sub_column.h\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/sub_column.h\n@@ -45,7 +45,7 @@ class TSubColumnDataExtractor: public IReadDataExtractor {\n     virtual void DoVisitAll(const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& dataArray, const TChunkVisitor& chunkVisitor,\n         const TRecordVisitor& recordVisitor) const override;\n \n-    virtual bool DoCheckForIndex(const NRequest::TOriginalDataAddress& request, ui64& /*hashBase*/) const override {\n+    virtual bool DoCheckForIndex(const NRequest::TOriginalDataAddress& request, ui64* /*hashBase*/) const override {\n         return request.GetSubColumnName() == SubColumnName;\n     }\n \ndiff --git a/ydb/core/tx/columnshard/engines/storage/indexes/skip_index/meta.h b/ydb/core/tx/columnshard/engines/storage/indexes/skip_index/meta.h\nindex eb63fe0d6b38..329419088768 100644\n--- a/ydb/core/tx/columnshard/engines/storage/indexes/skip_index/meta.h\n+++ b/ydb/core/tx/columnshard/engines/storage/indexes/skip_index/meta.h\n@@ -13,15 +13,16 @@ class TSkipIndex: public TIndexByColumns {\n     using TBase = TIndexByColumns;\n \n public:\n-    using EOperation = NArrow::NSSA::EIndexCheckOperation;\n+    using EOperation = NArrow::NSSA::TIndexCheckOperation::EOperation;\n \n private:\n-    virtual bool DoIsAppropriateFor(const TString& subColumnName, const EOperation op) const = 0;\n-    virtual bool DoCheckValue(\n-        const TString& data, const std::optional<ui64> cat, const std::shared_ptr<arrow::Scalar>& value, const EOperation op) const = 0;\n+    virtual bool DoIsAppropriateFor(const NArrow::NSSA::TIndexCheckOperation& op) const = 0;\n+    virtual bool DoCheckValue(const TString& data, const std::optional<ui64> cat, const std::shared_ptr<arrow::Scalar>& value,\n+        const NArrow::NSSA::TIndexCheckOperation& op) const = 0;\n \n public:\n-    bool CheckValue(const TString& data, const std::optional<ui64> cat, const std::shared_ptr<arrow::Scalar>& value, const EOperation op) const {\n+    bool CheckValue(const TString& data, const std::optional<ui64> cat, const std::shared_ptr<arrow::Scalar>& value,\n+        const NArrow::NSSA::TIndexCheckOperation& op) const {\n         return DoCheckValue(data, cat, value, op);\n     }\n \n@@ -29,11 +30,14 @@ class TSkipIndex: public TIndexByColumns {\n         return true;\n     }\n \n-    bool IsAppropriateFor(const NRequest::TOriginalDataAddress& addr, const EOperation op) const {\n+    bool IsAppropriateFor(const NRequest::TOriginalDataAddress& addr, const NArrow::NSSA::TIndexCheckOperation& op) const {\n         if (GetColumnId() != addr.GetColumnId()) {\n             return false;\n         }\n-        return DoIsAppropriateFor(addr.GetSubColumnName(), op);\n+        if (!GetDataExtractor()->CheckForIndex(addr, nullptr)) {\n+            return false;\n+        }\n+        return DoIsAppropriateFor(op);\n     }\n     using TBase::TBase;\n };\n@@ -42,11 +46,14 @@ class TSkipBitmapIndex: public TSkipIndex {\n private:\n     std::shared_ptr<IBitsStorageConstructor> BitsStorageConstructor;\n     using TBase = TSkipIndex;\n-    virtual bool DoCheckValueImpl(\n-        const IBitsStorage& data, const std::optional<ui64> cat, const std::shared_ptr<arrow::Scalar>& value, const EOperation op) const = 0;\n+    virtual bool DoCheckValueImpl(const IBitsStorage& data, const std::optional<ui64> cat, const std::shared_ptr<arrow::Scalar>& value,\n+        const NArrow::NSSA::TIndexCheckOperation& op) const = 0;\n \n     virtual bool DoCheckValue(const TString& data, const std::optional<ui64> cat, const std::shared_ptr<arrow::Scalar>& value,\n-        const EOperation op) const override final {\n+        const NArrow::NSSA::TIndexCheckOperation& op) const override final {\n+        if (data.empty()) {\n+            return false;\n+        }\n         auto storageConclusion = BitsStorageConstructor->Build(data);\n         return DoCheckValueImpl(*storageConclusion.GetResult(), cat, value, op);\n     }\ndiff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/abstract/optimizer.h b/ydb/core/tx/columnshard/engines/storage/optimizer/abstract/optimizer.h\nindex 633e3a519e53..20c68212068e 100644\n--- a/ydb/core/tx/columnshard/engines/storage/optimizer/abstract/optimizer.h\n+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/abstract/optimizer.h\n@@ -84,6 +84,10 @@ class IOptimizerPlanner {\n     const TInternalPathId PathId;\n     YDB_READONLY(TInstant, ActualizationInstant, TInstant::Zero());\n \n+    virtual bool DoIsOverloaded() const {\n+        return false;\n+    }\n+\n protected:\n     virtual void DoModifyPortions(const THashMap<ui64, std::shared_ptr<TPortionInfo>>& add,\n         const THashMap<ui64, std::shared_ptr<TPortionInfo>>& remove) = 0;\n@@ -107,7 +111,9 @@ class IOptimizerPlanner {\n     IOptimizerPlanner(const TInternalPathId pathId)\n         : PathId(pathId) {\n     }\n-\n+    bool IsOverloaded() const {\n+        return DoIsOverloaded();\n+    }\n     TConclusionStatus CheckWriteData() const {\n         return DoCheckWriteData();\n     }\ndiff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/constructor/zero_level.cpp b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/constructor/zero_level.cpp\nindex 18c383861af4..5d612baa6604 100644\n--- a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/constructor/zero_level.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/constructor/zero_level.cpp\n@@ -33,6 +33,13 @@ TConclusionStatus TZeroLevelConstructor::DoDeserializeFromJson(const NJson::TJso\n         }\n         ExpectedBlobsSize = jsonValue.GetUInteger();\n     }\n+    if (json.Has(\"portions_count_limit\")) {\n+        const auto& jsonValue = json[\"portions_count_limit\"];\n+        if (!jsonValue.IsUInteger()) {\n+            return TConclusionStatus::Fail(\"incorrect portions_count_limit value (have to be unsigned int)\");\n+        }\n+        PortionsCountLimit = jsonValue.GetUInteger();\n+    }\n     return TConclusionStatus::Success();\n }\n \n@@ -49,6 +56,9 @@ bool TZeroLevelConstructor::DoDeserializeFromProto(const NKikimrSchemeOp::TCompa\n     if (proto.GetZeroLevel().HasPortionsCountAvailable()) {\n         PortionsCountAvailable = proto.GetZeroLevel().GetPortionsCountAvailable();\n     }\n+    if (proto.GetZeroLevel().HasPortionsCountLimit()) {\n+        PortionsCountLimit = proto.GetZeroLevel().GetPortionsCountLimit();\n+    }\n     return true;\n }\n \n@@ -62,12 +72,15 @@ void TZeroLevelConstructor::DoSerializeToProto(NKikimrSchemeOp::TCompactionLevel\n     if (PortionsCountAvailable) {\n         proto.MutableZeroLevel()->SetPortionsCountAvailable(*PortionsCountAvailable);\n     }\n+    if (PortionsCountLimit) {\n+        proto.MutableZeroLevel()->SetPortionsCountLimit(*PortionsCountLimit);\n+    }\n }\n \n std::shared_ptr<NKikimr::NOlap::NStorageOptimizer::NLCBuckets::IPortionsLevel> TZeroLevelConstructor::DoBuildLevel(\n     const std::shared_ptr<IPortionsLevel>& nextLevel, const ui32 indexLevel, const TLevelCounters& counters) const {\n     return std::make_shared<TZeroLevelPortions>(indexLevel, nextLevel, counters, PortionsLiveDuration.value_or(TDuration::Max()),\n-        ExpectedBlobsSize.value_or((ui64)1 << 20), PortionsCountAvailable.value_or(10));\n+        ExpectedBlobsSize.value_or((ui64)1 << 20), PortionsCountAvailable.value_or(10), PortionsCountLimit);\n }\n \n }   // namespace NKikimr::NOlap::NStorageOptimizer::NLCBuckets\ndiff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/constructor/zero_level.h b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/constructor/zero_level.h\nindex 0ebce6554aeb..9b838c1beccb 100644\n--- a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/constructor/zero_level.h\n+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/constructor/zero_level.h\n@@ -13,6 +13,7 @@ class TZeroLevelConstructor: public ILevelConstructor {\n     std::optional<TDuration> PortionsLiveDuration;\n     std::optional<ui64> ExpectedBlobsSize;\n     std::optional<ui64> PortionsCountAvailable;\n+    std::optional<ui64> PortionsCountLimit;\n \n     virtual std::shared_ptr<IPortionsLevel> DoBuildLevel(\n         const std::shared_ptr<IPortionsLevel>& nextLevel, const ui32 indexLevel, const TLevelCounters& counters) const override;\ndiff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/abstract.h b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/abstract.h\nindex a43ab27668b0..2233e71122a7 100644\n--- a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/abstract.h\n+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/abstract.h\n@@ -295,6 +295,10 @@ class IPortionsLevel {\n     mutable std::optional<TInstant> PredOptimization = TInstant::Now();\n \n public:\n+    virtual bool IsOverloaded() const {\n+        return false;\n+    }\n+\n     bool HasData() const {\n         return PortionsInfo.GetCount();\n     }\ndiff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/optimizer.cpp b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/optimizer.cpp\nindex fcc5ce4a58d7..b20d6c1a0fde 100644\n--- a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/optimizer.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/optimizer.cpp\n@@ -30,11 +30,11 @@ TOptimizerPlanner::TOptimizerPlanner(const TInternalPathId pathId, const std::sh\n             nextLevel = Levels.back();\n         }\n     } else {\n-        Levels.emplace_back(std::make_shared<TZeroLevelPortions>(2, nullptr, Counters->GetLevelCounters(2), TDuration::Max(), 1 << 20, 10));\n+        Levels.emplace_back(std::make_shared<TZeroLevelPortions>(2, nullptr, Counters->GetLevelCounters(2), TDuration::Max(), 1 << 20, 10, std::nullopt));\n         Levels.emplace_back(\n-            std::make_shared<TZeroLevelPortions>(1, Levels.back(), Counters->GetLevelCounters(1), TDuration::Max(), 1 << 20, 10));\n-        Levels.emplace_back(\n-            std::make_shared<TZeroLevelPortions>(0, Levels.back(), Counters->GetLevelCounters(0), TDuration::Seconds(180), 1 << 20, 10));\n+            std::make_shared<TZeroLevelPortions>(1, Levels.back(), Counters->GetLevelCounters(1), TDuration::Max(), 1 << 20, 10, std::nullopt));\n+        Levels.emplace_back(std::make_shared<TZeroLevelPortions>(\n+            0, Levels.back(), Counters->GetLevelCounters(0), TDuration::Seconds(180), 1 << 20, 10, std::nullopt));\n     }\n     std::reverse(Levels.begin(), Levels.end());\n     RefreshWeights();\ndiff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/optimizer.h b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/optimizer.h\nindex 6d0071b99dce..e34f678f896a 100644\n--- a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/optimizer.h\n+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/optimizer.h\n@@ -17,6 +17,15 @@ class TOptimizerPlanner: public IOptimizerPlanner {\n     std::map<ui64, std::shared_ptr<IPortionsLevel>, std::greater<ui64>> LevelsByWeight;\n     const std::shared_ptr<IStoragesManager> StoragesManager;\n     const std::shared_ptr<arrow::Schema> PrimaryKeysSchema;\n+    virtual bool DoIsOverloaded() const override {\n+        for (auto&& i : Levels) {\n+            if (i->IsOverloaded()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     virtual std::vector<TTaskDescription> DoGetTasksDescription() const override {\n         std::vector<TTaskDescription> result;\n         for (auto&& i : Levels) {\ndiff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/zero_level.cpp b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/zero_level.cpp\nindex 60e99b9a3d06..d79bc6c40e40 100644\n--- a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/zero_level.cpp\n+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/zero_level.cpp\n@@ -68,4 +68,18 @@ TInstant TZeroLevelPortions::DoGetWeightExpirationInstant() const {\n     return *PredOptimization + DurationToDrop;\n }\n \n+TZeroLevelPortions::TZeroLevelPortions(const ui32 levelIdx, const std::shared_ptr<IPortionsLevel>& nextLevel,\n+    const TLevelCounters& levelCounters, const TDuration durationToDrop, const ui64 expectedBlobsSize, const ui64 portionsCountAvailable,\n+    const std::optional<ui64> portionsCountLimit)\n+    : TBase(levelIdx, nextLevel)\n+    , LevelCounters(levelCounters)\n+    , DurationToDrop(durationToDrop)\n+    , ExpectedBlobsSize(expectedBlobsSize)\n+    , PortionsCountAvailable(portionsCountAvailable)\n+    , PortionsCountLimit(portionsCountLimit) {\n+    if (DurationToDrop != TDuration::Max() && PredOptimization) {\n+        *PredOptimization -= TDuration::Seconds(RandomNumber<ui32>(DurationToDrop.Seconds()));\n+    }\n+}\n+\n }   // namespace NKikimr::NOlap::NStorageOptimizer::NLCBuckets\ndiff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/zero_level.h b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/zero_level.h\nindex e4cbd13259da..6ec690182e5b 100644\n--- a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/zero_level.h\n+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/zero_level.h\n@@ -11,6 +11,7 @@ class TZeroLevelPortions: public IPortionsLevel {\n     const TDuration DurationToDrop;\n     const ui64 ExpectedBlobsSize;\n     const ui64 PortionsCountAvailable;\n+    const std::optional<ui64> PortionsCountLimit;\n     class TOrderedPortion {\n     private:\n         YDB_READONLY_DEF(TPortionInfo::TConstPtr, Portion);\n@@ -39,6 +40,13 @@ class TZeroLevelPortions: public IPortionsLevel {\n     };\n     std::set<TOrderedPortion> Portions;\n \n+    virtual bool IsOverloaded() const override {\n+        if (!PortionsCountLimit) {\n+            return false;\n+        }\n+        return Portions.size() > *PortionsCountLimit;\n+    }\n+\n     virtual NArrow::NMerger::TIntervalPositions DoGetBucketPositions(const std::shared_ptr<arrow::Schema>& /*pkSchema*/) const override {\n         return NArrow::NMerger::TIntervalPositions();\n     }\n@@ -95,13 +103,7 @@ class TZeroLevelPortions: public IPortionsLevel {\n \n public:\n     TZeroLevelPortions(const ui32 levelIdx, const std::shared_ptr<IPortionsLevel>& nextLevel, const TLevelCounters& levelCounters,\n-        const TDuration durationToDrop, const ui64 expectedBlobsSize, const ui64 portionsCountAvailable)\n-        : TBase(levelIdx, nextLevel)\n-        , LevelCounters(levelCounters)\n-        , DurationToDrop(durationToDrop)\n-        , ExpectedBlobsSize(expectedBlobsSize)\n-        , PortionsCountAvailable(portionsCountAvailable) {\n-    }\n+        const TDuration durationToDrop, const ui64 expectedBlobsSize, const ui64 portionsCountAvailable, const std::optional<ui64> portionsCountLimit);\n };\n \n }   // namespace NKikimr::NOlap::NStorageOptimizer::NLCBuckets\ndiff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/counters/counters.h b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/counters/counters.h\nindex 0f04067f8ef4..8a309059eecf 100644\n--- a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/counters/counters.h\n+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/counters/counters.h\n@@ -1,6 +1,6 @@\n #pragma once\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n-#include <ydb/core/tx/columnshard/counters/common/agent.h>\n+#include <ydb/library/signals/owner.h>\n+#include <ydb/library/signals/agent.h>\n #include <ydb/core/tx/columnshard/engines/portions/portion_info.h>\n \n namespace NKikimr::NOlap::NStorageOptimizer::NSBuckets {\ndiff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/counters/ya.make b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/counters/ya.make\nindex 7f45975900a7..762de70f968d 100644\n--- a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/counters/ya.make\n+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/counters/ya.make\n@@ -5,7 +5,7 @@ SRCS(\n )\n \n PEERDIR(\n-    ydb/core/tx/columnshard/counters/common\n+    ydb/library/signals\n     ydb/core/tx/columnshard/engines/portions\n )\n \ndiff --git a/ydb/core/tx/columnshard/engines/ut/ut_logs_engine.cpp b/ydb/core/tx/columnshard/engines/ut/ut_logs_engine.cpp\nindex 017d43015c86..c8b4dc2dc6b4 100644\n--- a/ydb/core/tx/columnshard/engines/ut/ut_logs_engine.cpp\n+++ b/ydb/core/tx/columnshard/engines/ut/ut_logs_engine.cpp\n@@ -570,28 +570,28 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n         {   // select from snap before insert\n             ui64 planStep = 1;\n             ui64 txId = 0;\n-            auto selectInfo = engine.Select(paths[0], TSnapshot(planStep, txId), NOlap::TPKRangesFilter(false), false);\n+            auto selectInfo = engine.Select(paths[0], TSnapshot(planStep, txId), NOlap::TPKRangesFilter(), false);\n             UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 0);\n         }\n \n         {   // select from snap between insert (greater txId)\n             ui64 planStep = 1;\n             ui64 txId = 2;\n-            auto selectInfo = engine.Select(paths[0], TSnapshot(planStep, txId), NOlap::TPKRangesFilter(false), false);\n+            auto selectInfo = engine.Select(paths[0], TSnapshot(planStep, txId), NOlap::TPKRangesFilter(), false);\n             UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 0);\n         }\n \n         {   // select from snap after insert (greater planStep)\n             ui64 planStep = 2;\n             ui64 txId = 1;\n-            auto selectInfo = engine.Select(paths[0], TSnapshot(planStep, txId), NOlap::TPKRangesFilter(false), false);\n+            auto selectInfo = engine.Select(paths[0], TSnapshot(planStep, txId), NOlap::TPKRangesFilter(), false);\n             UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 1);\n         }\n \n         {   // select another pathId\n             ui64 planStep = 2;\n             ui64 txId = 1;\n-            auto selectInfo = engine.Select(paths[1], TSnapshot(planStep, txId), NOlap::TPKRangesFilter(false), false);\n+            auto selectInfo = engine.Select(paths[1], TSnapshot(planStep, txId), NOlap::TPKRangesFilter(), false);\n             UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 0);\n         }\n     }\n@@ -661,7 +661,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n \n         {   // full scan\n             ui64 txId = 1;\n-            auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(false), false);\n+            auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(), false);\n             UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 20);\n         }\n \n@@ -673,7 +673,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n             if (key[0].GetType() == TTypeInfo(NTypeIds::Utf8)) {\n                 gt10k = MakeStrPredicate(\"10000\", NKikimr::NKernels::EOperation::Greater);\n             }\n-            NOlap::TPKRangesFilter pkFilter(false);\n+            NOlap::TPKRangesFilter pkFilter;\n             Y_ABORT_UNLESS(pkFilter.Add(gt10k, nullptr, indexInfo.GetReplaceKey()));\n             auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), pkFilter, false);\n             UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 10);\n@@ -685,7 +685,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n             if (key[0].GetType() == TTypeInfo(NTypeIds::Utf8)) {\n                 lt10k = MakeStrPredicate(\"08999\", NKikimr::NKernels::EOperation::Less);\n             }\n-            NOlap::TPKRangesFilter pkFilter(false);\n+            NOlap::TPKRangesFilter pkFilter;\n             Y_ABORT_UNLESS(pkFilter.Add(nullptr, lt10k, indexInfo.GetReplaceKey()));\n             auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), pkFilter, false);\n             UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 9);\n@@ -845,7 +845,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n \n             {   // full scan\n                 ui64 txId = 1;\n-                auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(false), false);\n+                auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(), false);\n                 UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 20);\n             }\n \n@@ -854,7 +854,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n \n             {   // full scan\n                 ui64 txId = 1;\n-                auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(false), false);\n+                auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(), false);\n                 UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 20);\n             }\n \n@@ -870,7 +870,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n \n             {   // full scan\n                 ui64 txId = 1;\n-                auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(false), false);\n+                auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(), false);\n                 UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 10);\n             }\n         }\n@@ -886,7 +886,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {\n \n             {   // full scan\n                 ui64 txId = 1;\n-                auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(false), false);\n+                auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(), false);\n                 UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 10);\n             }\n         }\ndiff --git a/ydb/core/tx/columnshard/engines/ut/ut_script.cpp b/ydb/core/tx/columnshard/engines/ut/ut_script.cpp\nindex a50388e8bfb9..1ee5dd5091fa 100644\n--- a/ydb/core/tx/columnshard/engines/ut/ut_script.cpp\n+++ b/ydb/core/tx/columnshard/engines/ut/ut_script.cpp\n@@ -26,26 +26,26 @@ Y_UNIT_TEST_SUITE(TestScript) {\n                 { 1, NTable::TColumn(\"c1\", 0, NScheme::TTypeInfo(NScheme::NTypeIds::Int32), \"\") },\n                 { 2, NTable::TColumn(\"c2\", 0, NScheme::TTypeInfo(NScheme::NTypeIds::Int32), \"\") } }));\n \n-        acc.AddFetchingStep(std::vector<ui32>({ 0 }), NCommon::EStageFeaturesIndexes::Filter);\n-        acc.AddFetchingStep(std::vector<ui32>({ 0 }), NCommon::EStageFeaturesIndexes::Filter);\n-        acc.AddAssembleStep(std::vector<ui32>({ 0 }), \"\", NCommon::EStageFeaturesIndexes::Filter, false);\n+        acc.AddFetchingStep(std::vector<ui32>({ 0 }), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);\n+        acc.AddFetchingStep(std::vector<ui32>({ 0 }), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);\n+        acc.AddAssembleStep(std::vector<ui32>({ 0 }), \"\", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);\n         acc.AddStep(std::make_shared<NSimple::TDeletionFilter>());\n-        acc.AddFetchingStep(std::vector<ui32>({ 0, 1 }), NCommon::EStageFeaturesIndexes::Filter);\n-        acc.AddFetchingStep(std::vector<ui32>({ 1, 2 }), NCommon::EStageFeaturesIndexes::Fetching);\n-        acc.AddFetchingStep(std::vector<ui32>({ 0 }), NCommon::EStageFeaturesIndexes::Fetching);\n-        acc.AddAssembleStep(std::vector<ui32>({ 0, 1, 2 }), \"\", NCommon::EStageFeaturesIndexes::Fetching, false);\n+        acc.AddFetchingStep(std::vector<ui32>({ 0, 1 }), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);\n+        acc.AddFetchingStep(std::vector<ui32>({ 1, 2 }), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching);\n+        acc.AddFetchingStep(std::vector<ui32>({ 0 }), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching);\n+        acc.AddAssembleStep(std::vector<ui32>({ 0, 1, 2 }), \"\", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching, false);\n         acc.AddStep(std::make_shared<NSimple::TDeletionFilter>());\n-        acc.AddFetchingStep(std::vector<ui32>({ 0 }), NCommon::EStageFeaturesIndexes::Merge);\n+        acc.AddFetchingStep(std::vector<ui32>({ 0 }), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Merge);\n \n         auto script = std::move(acc).Build();\n         UNIT_ASSERT_STRINGS_EQUAL(script->DebugString(),\n             \"{branch:UNDEFINED;steps:[\"\n-            \"{name=ALLOCATE_MEMORY::Filter;details={stage=Filter;column_ids=[Blob:0,Raw:0];};};\"\n+            \"{name=ALLOCATE_MEMORY::FILTER;details={stage=FILTER;column_ids=[Blob:0,Raw:0];};};\"\n             \"{name=FETCHING_COLUMNS;details={columns=0;};};\"\n             \"{name=ASSEMBLER;details={columns=(column_ids=0;column_names=c0;);;};};\"\n             \"{name=DELETION;details={};};\"\n-            \"{name=ALLOCATE_MEMORY::Filter;details={stage=Filter;column_ids=[Blob:1];};};\"\n-            \"{name=ALLOCATE_MEMORY::Fetching;details={stage=Fetching;column_ids=[Blob:2,Raw:1,Raw:2];};};\"\n+            \"{name=ALLOCATE_MEMORY::FILTER;details={stage=FILTER;column_ids=[Blob:1];};};\"\n+            \"{name=ALLOCATE_MEMORY::FETCHING;details={stage=FETCHING;column_ids=[Blob:2,Raw:1,Raw:2];};};\"\n             \"{name=FETCHING_COLUMNS;details={columns=1,2;};};\"\n             \"{name=ASSEMBLER;details={columns=(column_ids=1,2;column_names=c1,c2;);;};};\"\n             \"{name=DELETION;details={};};]}\");\ndiff --git a/ydb/core/tx/columnshard/engines/writer/buffer/actor2.cpp b/ydb/core/tx/columnshard/engines/writer/buffer/actor2.cpp\nindex faff75816478..dfa57b5bee89 100644\n--- a/ydb/core/tx/columnshard/engines/writer/buffer/actor2.cpp\n+++ b/ydb/core/tx/columnshard/engines/writer/buffer/actor2.cpp\n@@ -71,7 +71,7 @@ void TWriteAggregation::Flush(const ui64 tabletId) {\n         Context.GetWritingCounters()->OnAggregationWrite(Units.size(), SumSize);\n         std::shared_ptr<NConveyor::ITask> task =\n             std::make_shared<TBuildPackSlicesTask>(std::move(Units), Context, PathId, tabletId, ModificationType);\n-        NConveyor::TInsertServiceOperator::AsyncTaskToExecute(task);\n+        NConveyor::TInsertServiceOperator::SendTaskToExecute(task);\n         Units.clear();\n         SumSize = 0;\n     }\ndiff --git a/ydb/core/tx/columnshard/engines/writer/indexed_blob_constructor.h b/ydb/core/tx/columnshard/engines/writer/indexed_blob_constructor.h\nindex 8765968a0a00..1fcff6975285 100644\n--- a/ydb/core/tx/columnshard/engines/writer/indexed_blob_constructor.h\n+++ b/ydb/core/tx/columnshard/engines/writer/indexed_blob_constructor.h\n@@ -7,7 +7,7 @@\n #include <ydb/core/tx/columnshard/blobs_action/abstract/write.h>\n #include <ydb/core/tx/columnshard/blobs_action/counters/storage.h>\n #include <ydb/core/tx/columnshard/columnshard.h>\n-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>\n+#include <ydb/library/signals/object_counter.h>\n #include <ydb/core/tx/columnshard/engines/insert_table/user_data.h>\n #include <ydb/core/tx/columnshard/engines/portions/portion_info.h>\n #include <ydb/core/tx/data_events/write_data.h>\ndiff --git a/ydb/core/tx/columnshard/normalizer/portion/chunks.cpp b/ydb/core/tx/columnshard/normalizer/portion/chunks.cpp\nindex 7cfdfcd21308..1d7e9656cd43 100644\n--- a/ydb/core/tx/columnshard/normalizer/portion/chunks.cpp\n+++ b/ydb/core/tx/columnshard/normalizer/portion/chunks.cpp\n@@ -52,7 +52,7 @@ class TRowsAndBytesChangesTask: public NConveyor::ITask {\n     TNormalizationContext NormContext;\n \n protected:\n-    virtual TConclusionStatus DoExecute(const std::shared_ptr<NConveyor::ITask>& /*taskPtr*/) override {\n+    virtual void DoExecute(const std::shared_ptr<NConveyor::ITask>& /*taskPtr*/) override {\n         for (auto&& chunkInfo : Chunks) {\n             const auto& blobRange = chunkInfo.GetBlobRange();\n \n@@ -73,7 +73,6 @@ class TRowsAndBytesChangesTask: public NConveyor::ITask {\n         auto changes = std::make_shared<TChunksNormalizer::TNormalizerResult>(std::move(Chunks));\n         TActorContext::AsActorContext().Send(\n             NormContext.GetShardActor(), std::make_unique<NColumnShard::TEvPrivate::TEvNormalizerResult>(changes));\n-        return TConclusionStatus::Success();\n     }\n \n public:\ndiff --git a/ydb/core/tx/columnshard/operations/batch_builder/builder.cpp b/ydb/core/tx/columnshard/operations/batch_builder/builder.cpp\nindex cf9746640459..7f886c8be62e 100644\n--- a/ydb/core/tx/columnshard/operations/batch_builder/builder.cpp\n+++ b/ydb/core/tx/columnshard/operations/batch_builder/builder.cpp\n@@ -21,19 +21,19 @@ void TBuildBatchesTask::ReplyError(const TString& message, const NColumnShard::T\n     TActorContext::AsActorContext().Send(Context.GetTabletActorId(), result.release());\n }\n \n-TConclusionStatus TBuildBatchesTask::DoExecute(const std::shared_ptr<ITask>& /*taskPtr*/) {\n+void TBuildBatchesTask::DoExecute(const std::shared_ptr<ITask>& /*taskPtr*/) {\n     const NActors::TLogContextGuard lGuard = NActors::TLogContextBuilder::Build()(\"scope\", \"TBuildBatchesTask::DoExecute\");\n     if (!Context.IsActive()) {\n         AFL_WARN(NKikimrServices::TX_COLUMNSHARD_WRITE)(\"event\", \"abort_external\");\n         ReplyError(\"writing aborted\", NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Internal);\n-        return TConclusionStatus::Fail(\"writing aborted\");\n+        return;\n     }\n     TConclusion<std::shared_ptr<arrow::RecordBatch>> batchConclusion = WriteData.GetData()->ExtractBatch();\n     if (batchConclusion.IsFail()) {\n         AFL_WARN(NKikimrServices::TX_COLUMNSHARD_WRITE)(\"event\", \"abort_on_extract\")(\"reason\", batchConclusion.GetErrorMessage());\n         ReplyError(\"cannot extract incoming batch: \" + batchConclusion.GetErrorMessage(),\n             NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Internal);\n-        return TConclusionStatus::Fail(\"cannot extract incoming batch: \" + batchConclusion.GetErrorMessage());\n+        return;\n     }\n     Context.GetWritingCounters()->OnIncomingData(NArrow::GetBatchDataSize(*batchConclusion));\n \n@@ -43,7 +43,7 @@ TConclusionStatus TBuildBatchesTask::DoExecute(const std::shared_ptr<ITask>& /*t\n         AFL_WARN(NKikimrServices::TX_COLUMNSHARD_WRITE)(\"event\", \"abort_on_prepare\")(\"reason\", preparedConclusion.GetErrorMessage());\n         ReplyError(\"cannot prepare incoming batch: \" + preparedConclusion.GetErrorMessage(),\n             NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Request);\n-        return TConclusionStatus::Fail(\"cannot prepare incoming batch: \" + preparedConclusion.GetErrorMessage());\n+        return;\n     }\n     auto batch = preparedConclusion.DetachResult();\n     std::shared_ptr<IMerger> merger;\n@@ -54,13 +54,13 @@ TConclusionStatus TBuildBatchesTask::DoExecute(const std::shared_ptr<ITask>& /*t\n                 if (!WriteData.GetWritePortions() || !Context.GetNoTxWrite()) {\n                     std::shared_ptr<NConveyor::ITask> task =\n                         std::make_shared<NOlap::TBuildSlicesTask>(std::move(WriteData), batch.GetContainer(), Context);\n-                    NConveyor::TInsertServiceOperator::AsyncTaskToExecute(task);\n+                    NConveyor::TInsertServiceOperator::SendTaskToExecute(task);\n                 } else {\n                     NActors::TActivationContext::ActorSystem()->Send(Context.GetBufferizationPortionsActorId(),\n                         new NWritingPortions::TEvAddInsertedDataToBuffer(\n                             std::make_shared<NEvWrite::TWriteData>(WriteData), batch, std::make_shared<TWritingContext>(Context)));\n                 }\n-                return TConclusionStatus::Success();\n+                return;\n             } else {\n                 auto insertionConclusion = Context.GetActualSchema()->CheckColumnsDefault(defaultFields);\n                 auto conclusion = Context.GetActualSchema()->BuildDefaultBatch(Context.GetActualSchema()->GetIndexInfo().ArrowSchema(), 1, true);\n@@ -86,20 +86,18 @@ TConclusionStatus TBuildBatchesTask::DoExecute(const std::shared_ptr<ITask>& /*t\n             if (!WriteData.GetWritePortions() || !Context.GetNoTxWrite()) {\n                 std::shared_ptr<NConveyor::ITask> task =\n                     std::make_shared<NOlap::TBuildSlicesTask>(std::move(WriteData), batch.GetContainer(), Context);\n-                NConveyor::TInsertServiceOperator::AsyncTaskToExecute(task);\n+                NConveyor::TInsertServiceOperator::SendTaskToExecute(task);\n             } else {\n                 NActors::TActivationContext::ActorSystem()->Send(Context.GetBufferizationPortionsActorId(),\n                     new NWritingPortions::TEvAddInsertedDataToBuffer(\n                                        std::make_shared<NEvWrite::TWriteData>(WriteData), batch, std::make_shared<TWritingContext>(Context)));\n             }\n-            return TConclusionStatus::Success();\n+            return;\n         }\n     }\n     std::shared_ptr<NDataReader::IRestoreTask> task =\n         std::make_shared<NOlap::TModificationRestoreTask>(std::move(WriteData), merger, ActualSnapshot, batch, Context);\n     NActors::TActivationContext::AsActorContext().Register(new NDataReader::TActor(task));\n-\n-    return TConclusionStatus::Success();\n }\n \n }   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/operations/batch_builder/builder.h b/ydb/core/tx/columnshard/operations/batch_builder/builder.h\nindex 1ec9b1ae551f..50e156542972 100644\n--- a/ydb/core/tx/columnshard/operations/batch_builder/builder.h\n+++ b/ydb/core/tx/columnshard/operations/batch_builder/builder.h\n@@ -17,7 +17,7 @@ class TBuildBatchesTask: public NConveyor::ITask, public NColumnShard::TMonitori\n     void ReplyError(const TString& message, const NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass errorClass);\n \n protected:\n-    virtual TConclusionStatus DoExecute(const std::shared_ptr<ITask>& taskPtr) override;\n+    virtual void DoExecute(const std::shared_ptr<ITask>& taskPtr) override;\n \n public:\n     virtual TString GetTaskClassIdentifier() const override {\ndiff --git a/ydb/core/tx/columnshard/operations/batch_builder/merger.h b/ydb/core/tx/columnshard/operations/batch_builder/merger.h\nindex f1d8fcddfa84..148af13daf6f 100644\n--- a/ydb/core/tx/columnshard/operations/batch_builder/merger.h\n+++ b/ydb/core/tx/columnshard/operations/batch_builder/merger.h\n@@ -67,7 +67,7 @@ class TReplaceMerger: public IMerger {\n \n     virtual NArrow::TContainerWithIndexes<arrow::RecordBatch> BuildResultBatch() override {\n         auto result = IncomingData;\n-        AFL_VERIFY(Filter.Apply(result.MutableContainer()));\n+        Filter.Apply(result.MutableContainer());\n         return result;\n     }\n };\ndiff --git a/ydb/core/tx/columnshard/operations/batch_builder/restore.cpp b/ydb/core/tx/columnshard/operations/batch_builder/restore.cpp\nindex 3d6d8e03ed40..4854fc010fe7 100644\n--- a/ydb/core/tx/columnshard/operations/batch_builder/restore.cpp\n+++ b/ydb/core/tx/columnshard/operations/batch_builder/restore.cpp\n@@ -13,7 +13,7 @@ std::unique_ptr<TEvColumnShard::TEvInternalScan> TModificationRestoreTask::DoBui\n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_RESTORE)(\"event\", \"restore_start\")(\"count\", IncomingData.HasContainer() ? IncomingData->num_rows() : 0)(\n         \"task_id\", WriteData.GetWriteMeta().GetId());\n     auto pkData = NArrow::TColumnOperator().VerifyIfAbsent().Extract(IncomingData.GetContainer(), Context.GetActualSchema()->GetPKColumnNames());\n-    request->RangesFilter = TPKRangesFilter::BuildFromRecordBatchLines(pkData, false);\n+    request->RangesFilter = TPKRangesFilter::BuildFromRecordBatchLines(pkData);\n     for (auto&& i : Context.GetActualSchema()->GetIndexInfo().GetColumnIds(false)) {\n         request->AddColumn(i);\n     }\n@@ -49,7 +49,7 @@ NKikimr::TConclusionStatus TModificationRestoreTask::DoOnFinished() {\n     if (!WriteData.GetWritePortions() || !Context.GetNoTxWrite()) {\n         std::shared_ptr<NConveyor::ITask> task =\n             std::make_shared<NOlap::TBuildSlicesTask>(std::move(WriteData), batchResult.GetContainer(), Context);\n-        NConveyor::TInsertServiceOperator::AsyncTaskToExecute(task);\n+        NConveyor::TInsertServiceOperator::SendTaskToExecute(task);\n     } else {\n         NActors::TActivationContext::ActorSystem()->Send(\n             Context.GetBufferizationPortionsActorId(), new NWritingPortions::TEvAddInsertedDataToBuffer(\ndiff --git a/ydb/core/tx/columnshard/operations/events.h b/ydb/core/tx/columnshard/operations/events.h\nindex 30328c0bfc49..bf0ac210c627 100644\n--- a/ydb/core/tx/columnshard/operations/events.h\n+++ b/ydb/core/tx/columnshard/operations/events.h\n@@ -29,10 +29,36 @@ class TWriteResult {\n     std::shared_ptr<NEvWrite::TWriteMeta> WriteMeta;\n     YDB_READONLY(ui64, DataSize, 0);\n     YDB_READONLY(bool, NoDataToWrite, false);\n+    TString ErrorMessage;\n+    std::optional<bool> IsInternalErrorFlag;\n     std::shared_ptr<arrow::RecordBatch> PKBatch;\n     ui32 RecordsCount;\n \n public:\n+    TWriteResult& SetErrorMessage(const TString& value, const bool isInternal) {\n+        AFL_VERIFY(!ErrorMessage);\n+        IsInternalErrorFlag = isInternal;\n+        ErrorMessage = value;\n+        return *this;\n+    }\n+\n+    bool IsInternalError() const {\n+        AFL_VERIFY_DEBUG(!!IsInternalErrorFlag);\n+        if (!IsInternalErrorFlag) {\n+            return true;\n+        }\n+        return *IsInternalErrorFlag;\n+    }\n+\n+    const TString& GetErrorMessage() const {\n+        static TString undefinedMessage = \"UNKNOWN_WRITE_RESULT_MESSAGE\";\n+        AFL_VERIFY_DEBUG(!!ErrorMessage);\n+        if (!ErrorMessage) {\n+            return undefinedMessage;\n+        }\n+        return ErrorMessage;\n+    }\n+\n     const std::shared_ptr<arrow::RecordBatch>& GetPKBatchVerified() const {\n         AFL_VERIFY(PKBatch);\n         return PKBatch;\n@@ -91,11 +117,16 @@ namespace NKikimr::NColumnShard::NPrivateEvents::NWrite {\n class TEvWritePortionResult: public TEventLocal<TEvWritePortionResult, TEvPrivate::EvWritePortionResult> {\n private:\n     YDB_READONLY_DEF(NKikimrProto::EReplyStatus, WriteStatus);\n-    YDB_READONLY_DEF(std::shared_ptr<NOlap::IBlobsWritingAction>, WriteAction);\n+    std::optional<std::shared_ptr<NOlap::IBlobsWritingAction>> WriteAction;\n     bool Detached = false;\n     TInsertedPortions InsertedData;\n \n public:\n+    const std::shared_ptr<NOlap::IBlobsWritingAction>& GetWriteAction() const {\n+        AFL_VERIFY(!!WriteAction);\n+        return *WriteAction;\n+    }\n+\n     const TInsertedPortions& DetachInsertedData() {\n         AFL_VERIFY(!Detached);\n         Detached = true;\ndiff --git a/ydb/core/tx/columnshard/operations/slice_builder/builder.cpp b/ydb/core/tx/columnshard/operations/slice_builder/builder.cpp\nindex 866720bb1a65..fb79e54284b4 100644\n--- a/ydb/core/tx/columnshard/operations/slice_builder/builder.cpp\n+++ b/ydb/core/tx/columnshard/operations/slice_builder/builder.cpp\n@@ -99,19 +99,19 @@ class TPortionWriteController: public NColumnShard::IWriteController,\n     }\n };\n \n-TConclusionStatus TBuildSlicesTask::DoExecute(const std::shared_ptr<ITask>& /*taskPtr*/) {\n+void TBuildSlicesTask::DoExecute(const std::shared_ptr<ITask>& /*taskPtr*/) {\n     const NActors::TLogContextGuard g = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD_WRITE)(\"tablet_id\", TabletId)(\n         \"parent_id\", Context.GetTabletActorId())(\"write_id\", WriteData.GetWriteMeta().GetWriteId())(\n         \"table_id\", WriteData.GetWriteMeta().GetTableId());\n     if (!Context.IsActive()) {\n         AFL_WARN(NKikimrServices::TX_COLUMNSHARD_WRITE)(\"event\", \"abort_execution\");\n         ReplyError(\"execution aborted\", NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Internal);\n-        return TConclusionStatus::Fail(\"execution aborted\");\n+        return;\n     }\n     if (!OriginalBatch) {\n         AFL_WARN(NKikimrServices::TX_COLUMNSHARD_WRITE)(\"event\", \"ev_write_bad_data\");\n         ReplyError(\"no data in batch\", NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Internal);\n-        return TConclusionStatus::Fail(\"no data in batch\");\n+        return;\n     }\n     if (WriteData.GetWritePortions()) {\n         if (OriginalBatch->num_rows() == 0) {\n@@ -136,7 +136,7 @@ TConclusionStatus TBuildSlicesTask::DoExecute(const std::shared_ptr<ITask>& /*ta\n                         WriteData.GetWriteMeta().GetModificationType(), Context.GetStoragesManager(), Context.GetSplitterCounters());\n                 if (portionConclusion.IsFail()) {\n                     ReplyError(portionConclusion.GetErrorMessage(), NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Request);\n-                    return portionConclusion;\n+                    return;\n                 }\n                 portions.emplace_back(portionConclusion.DetachResult());\n             }\n@@ -157,7 +157,7 @@ TConclusionStatus TBuildSlicesTask::DoExecute(const std::shared_ptr<ITask>& /*ta\n                 \"problem\", subsetConclusion.GetErrorMessage());\n             ReplyError(\"unadaptable schema: \" + subsetConclusion.GetErrorMessage(),\n                 NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Internal);\n-            return TConclusionStatus::Fail(\"cannot reorder schema: \" + subsetConclusion.GetErrorMessage());\n+            return;\n         }\n         NArrow::TSchemaSubset subset = subsetConclusion.DetachResult();\n \n@@ -186,9 +186,8 @@ TConclusionStatus TBuildSlicesTask::DoExecute(const std::shared_ptr<ITask>& /*ta\n             TActorContext::AsActorContext().Send(Context.GetBufferizationInsertionActorId(), result.release());\n         } else {\n             ReplyError(\"Cannot slice input to batches\", NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Internal);\n-            return TConclusionStatus::Fail(\"Cannot slice input to batches\");\n+            return;\n         }\n     }\n-    return TConclusionStatus::Success();\n }\n }   // namespace NKikimr::NOlap\ndiff --git a/ydb/core/tx/columnshard/operations/slice_builder/builder.h b/ydb/core/tx/columnshard/operations/slice_builder/builder.h\nindex 0efd53378e3f..5d6bb4159777 100644\n--- a/ydb/core/tx/columnshard/operations/slice_builder/builder.h\n+++ b/ydb/core/tx/columnshard/operations/slice_builder/builder.h\n@@ -18,7 +18,7 @@ class TBuildSlicesTask: public NConveyor::ITask, public NColumnShard::TMonitorin\n     void ReplyError(const TString& message, const NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass errorClass);\n \n protected:\n-    virtual TConclusionStatus DoExecute(const std::shared_ptr<ITask>& taskPtr) override;\n+    virtual void DoExecute(const std::shared_ptr<ITask>& taskPtr) override;\n \n public:\n     virtual TString GetTaskClassIdentifier() const override {\ndiff --git a/ydb/core/tx/columnshard/operations/slice_builder/pack_builder.cpp b/ydb/core/tx/columnshard/operations/slice_builder/pack_builder.cpp\nindex 6ab38d7cbc21..9b9b0e351b5b 100644\n--- a/ydb/core/tx/columnshard/operations/slice_builder/pack_builder.cpp\n+++ b/ydb/core/tx/columnshard/operations/slice_builder/pack_builder.cpp\n@@ -44,6 +44,11 @@ class TPortionWriteController: public NColumnShard::IWriteController,\n         for (auto&& i : Portions) {\n             portions.emplace_back(i.ExtractPortion());\n         }\n+        if (putResult->GetPutStatus() != NKikimrProto::OK) {\n+            for (auto&& i : WriteResults) {\n+                i.SetErrorMessage(\"cannot put blobs: \" + ::ToString(putResult->GetPutStatus()), true);\n+            }\n+        }\n         NColumnShard::TInsertedPortions pack(std::move(WriteResults), std::move(portions));\n         auto result =\n             std::make_unique<NColumnShard::NPrivateEvents::NWrite::TEvWritePortionResult>(putResult->GetPutStatus(), Action, std::move(pack));\n@@ -89,13 +94,18 @@ class TSliceToMerge {\n         SequentialWriteId.emplace_back(data->GetWriteMeta().GetWriteId());\n     }\n \n-    [[nodiscard]] TConclusionStatus Finalize(const NOlap::TWritingContext& context, std::vector<TPortionWriteController::TInsertPortion>& result) {\n+    [[nodiscard]] TConclusionStatus Finalize(\n+        const NOlap::TWritingContext& context, std::vector<TPortionWriteController::TInsertPortion>& result) {\n         if (Batches.size() == 0) {\n             return TConclusionStatus::Success();\n         }\n         if (Batches.size() == 1) {\n-            auto portionConclusion = context.GetActualSchema()->PrepareForWrite(context.GetActualSchema(), PathId, Batches.front().GetContainer(),\n-                ModificationType, context.GetStoragesManager(), context.GetSplitterCounters());\n+            auto portionConclusion = context.GetActualSchema()->PrepareForWrite(context.GetActualSchema(), PathId,\n+                Batches.front().GetContainer(), ModificationType, context.GetStoragesManager(), context.GetSplitterCounters());\n+            if (portionConclusion.IsFail()) {\n+                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"cannot prepare for write\")(\"reason\", portionConclusion.GetErrorMessage());\n+                return portionConclusion;\n+            }\n             result.emplace_back(portionConclusion.DetachResult());\n         } else {\n             ui32 idx = 0;\n@@ -119,12 +129,16 @@ class TSliceToMerge {\n                         if (itBatchIndexes == i.GetColumnIndexes().end() || *itAllIndexes < *itBatchIndexes) {\n                             auto defaultColumn = indexInfo.BuildDefaultColumn(*itAllIndexes, i->num_rows(), false);\n                             if (defaultColumn.IsFail()) {\n+                                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"cannot build default column\")(\n+                                    \"reason\", defaultColumn.GetErrorMessage());\n                                 return defaultColumn;\n                             }\n-                            gContainer->AddField(context.GetActualSchema()->GetFieldByIndexVerified(*itAllIndexes), defaultColumn.DetachResult()).Validate();\n+                            gContainer->AddField(context.GetActualSchema()->GetFieldByIndexVerified(*itAllIndexes), defaultColumn.DetachResult())\n+                                .Validate();\n                         } else {\n                             AFL_VERIFY(*itAllIndexes == *itBatchIndexes);\n-                            gContainer->AddField(context.GetActualSchema()->GetFieldByIndexVerified(*itAllIndexes),\n+                            gContainer\n+                                ->AddField(context.GetActualSchema()->GetFieldByIndexVerified(*itAllIndexes),\n                                     i->column(itBatchIndexes - i.GetColumnIndexes().begin()))\n                                 .Validate();\n                             ++itBatchIndexes;\n@@ -152,19 +166,19 @@ class TSliceToMerge {\n             stream.DrainAll(rbBuilder);\n             auto portionConclusion = context.GetActualSchema()->PrepareForWrite(context.GetActualSchema(), PathId, rbBuilder.Finalize(),\n                 ModificationType, context.GetStoragesManager(), context.GetSplitterCounters());\n+            if (portionConclusion.IsFail()) {\n+                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"cannot prepare for write\")(\"reason\", portionConclusion.GetErrorMessage());\n+                return portionConclusion;\n+            }\n             result.emplace_back(portionConclusion.DetachResult());\n         }\n         return TConclusionStatus::Success();\n     }\n };\n \n-TConclusionStatus TBuildPackSlicesTask::DoExecute(const std::shared_ptr<ITask>& /*taskPtr*/) {\n+void TBuildPackSlicesTask::DoExecute(const std::shared_ptr<ITask>& /*taskPtr*/) {\n     const NActors::TLogContextGuard g = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD_WRITE)(\"tablet_id\", TabletId)(\n         \"parent_id\", Context.GetTabletActorId())(\"path_id\", PathId);\n-    if (!Context.IsActive()) {\n-        AFL_WARN(NKikimrServices::TX_COLUMNSHARD_WRITE)(\"event\", \"abort_execution\");\n-        return TConclusionStatus::Fail(\"execution aborted\");\n-    }\n     NArrow::NMerger::TIntervalPositions splitPositions;\n     for (auto&& unit : WriteUnits) {\n         splitPositions.Merge(unit.GetData()->GetData()->GetSeparationPoints());\n@@ -192,18 +206,39 @@ TConclusionStatus TBuildPackSlicesTask::DoExecute(const std::shared_ptr<ITask>&\n         }\n     }\n     std::vector<TPortionWriteController::TInsertPortion> portionsToWrite;\n-    for (auto&& i : slicesToMerge) {\n-        i.Finalize(Context, portionsToWrite).Validate();\n+    TString cancelWritingReason;\n+    if (!Context.IsActive()) {\n+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD_WRITE)(\"event\", \"abort_execution\");\n+        cancelWritingReason = \"execution aborted\";\n+    } else {\n+        for (auto&& i : slicesToMerge) {\n+            auto conclusion = i.Finalize(Context, portionsToWrite);\n+            if (conclusion.IsFail()) {\n+                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"cannot build slice\")(\"reason\", conclusion.GetErrorMessage());\n+                cancelWritingReason = conclusion.GetErrorMessage();\n+                break;\n+            }\n+        }\n     }\n-    auto actions = WriteUnits.front().GetData()->GetBlobsAction();\n-    auto writeController =\n-        std::make_shared<TPortionWriteController>(Context.GetTabletActorId(), actions, std::move(writeResults), std::move(portionsToWrite));\n-    if (actions->NeedDraftTransaction()) {\n-        TActorContext::AsActorContext().Send(\n-            Context.GetTabletActorId(), std::make_unique<NColumnShard::TEvPrivate::TEvWriteDraft>(writeController));\n+    if (!cancelWritingReason) {\n+        auto actions = WriteUnits.front().GetData()->GetBlobsAction();\n+        auto writeController =\n+            std::make_shared<TPortionWriteController>(Context.GetTabletActorId(), actions, std::move(writeResults), std::move(portionsToWrite));\n+        if (actions->NeedDraftTransaction()) {\n+            TActorContext::AsActorContext().Send(\n+                Context.GetTabletActorId(), std::make_unique<NColumnShard::TEvPrivate::TEvWriteDraft>(writeController));\n+        } else {\n+            TActorContext::AsActorContext().Register(NColumnShard::CreateWriteActor(TabletId, writeController, TInstant::Max()));\n+        }\n     } else {\n-        TActorContext::AsActorContext().Register(NColumnShard::CreateWriteActor(TabletId, writeController, TInstant::Max()));\n+        for (auto&& i : writeResults) {\n+            i.SetErrorMessage(cancelWritingReason, false);\n+        }\n+        NColumnShard::TInsertedPortions pack(std::move(writeResults), std::vector<NColumnShard::TInsertedPortion>());\n+        auto result =\n+            std::make_unique<NColumnShard::NPrivateEvents::NWrite::TEvWritePortionResult>(NKikimrProto::EReplyStatus::ERROR, nullptr, std::move(pack));\n+        TActorContext::AsActorContext().Send(Context.GetTabletActorId(), result.release());\n+    \n     }\n-    return TConclusionStatus::Success();\n }\n }   // namespace NKikimr::NOlap::NWritingPortions\ndiff --git a/ydb/core/tx/columnshard/operations/slice_builder/pack_builder.h b/ydb/core/tx/columnshard/operations/slice_builder/pack_builder.h\nindex f8f46e35ba6d..cbcc954630db 100644\n--- a/ydb/core/tx/columnshard/operations/slice_builder/pack_builder.h\n+++ b/ydb/core/tx/columnshard/operations/slice_builder/pack_builder.h\n@@ -1,7 +1,7 @@\n #pragma once\n #include <ydb/core/formats/arrow/size_calcer.h>\n #include <ydb/core/tx/columnshard/columnshard_private_events.h>\n-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>\n+#include <ydb/library/signals/object_counter.h>\n #include <ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.h>\n #include <ydb/core/tx/columnshard/operations/common/context.h>\n #include <ydb/core/tx/columnshard/common/path_id.h>\n@@ -35,7 +35,7 @@ class TBuildPackSlicesTask: public NConveyor::ITask, public NColumnShard::TMonit\n     std::optional<std::vector<NArrow::TSerializedBatch>> BuildSlices();\n \n protected:\n-    virtual TConclusionStatus DoExecute(const std::shared_ptr<ITask>& taskPtr) override;\n+    virtual void DoExecute(const std::shared_ptr<ITask>& taskPtr) override;\n \n public:\n     virtual TString GetTaskClassIdentifier() const override {\ndiff --git a/ydb/core/tx/columnshard/operations/write.cpp b/ydb/core/tx/columnshard/operations/write.cpp\nindex d739caf6aedc..b7d184b9c07c 100644\n--- a/ydb/core/tx/columnshard/operations/write.cpp\n+++ b/ydb/core/tx/columnshard/operations/write.cpp\n@@ -38,7 +38,7 @@ void TWriteOperation::Start(\n     NEvWrite::TWriteData writeData(writeMeta, data, owner.TablesManager.GetPrimaryIndex()->GetReplaceKey(),\n         owner.StoragesManager->GetInsertOperator()->StartWritingAction(NOlap::NBlobOperations::EConsumer::WRITING_OPERATOR), WritePortions);\n     std::shared_ptr<NConveyor::ITask> task = std::make_shared<NOlap::TBuildBatchesTask>(std::move(writeData), context);\n-    NConveyor::TInsertServiceOperator::AsyncTaskToExecute(task);\n+    NConveyor::TInsertServiceOperator::SendTaskToExecute(task);\n \n     Status = EOperationStatus::Started;\n }\ndiff --git a/ydb/core/tx/columnshard/operations/write.h b/ydb/core/tx/columnshard/operations/write.h\nindex 735a8aa93b0d..97800d78dc8a 100644\n--- a/ydb/core/tx/columnshard/operations/write.h\n+++ b/ydb/core/tx/columnshard/operations/write.h\n@@ -5,7 +5,7 @@\n #include <ydb/core/protos/tx_columnshard.pb.h>\n #include <ydb/core/tablet_flat/flat_cxx_database.h>\n #include <ydb/core/tx/columnshard/common/snapshot.h>\n-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>\n+#include <ydb/library/signals/object_counter.h>\n #include <ydb/core/tx/columnshard/engines/defs.h>\n #include <ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.h>\n #include <ydb/core/tx/columnshard/common/path_id.h>\ndiff --git a/ydb/core/tx/columnshard/resource_subscriber/counters.h b/ydb/core/tx/columnshard/resource_subscriber/counters.h\nindex 230222f8ffa3..5495f9cf2327 100644\n--- a/ydb/core/tx/columnshard/resource_subscriber/counters.h\n+++ b/ydb/core/tx/columnshard/resource_subscriber/counters.h\n@@ -1,6 +1,6 @@\n #pragma once\n #include <library/cpp/monlib/dynamic_counters/counters.h>\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n #include <util/generic/hash.h>\n \n namespace NKikimr::NOlap::NResourceBroker::NSubscribe {\ndiff --git a/ydb/core/tx/columnshard/resource_subscriber/task.h b/ydb/core/tx/columnshard/resource_subscriber/task.h\nindex 46a1ebebd32c..a065c8946691 100644\n--- a/ydb/core/tx/columnshard/resource_subscriber/task.h\n+++ b/ydb/core/tx/columnshard/resource_subscriber/task.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>\n+#include <ydb/library/signals/object_counter.h>\n #include \"counters.h\"\n \n namespace NKikimr::NOlap::NResourceBroker::NSubscribe {\ndiff --git a/ydb/core/tx/columnshard/resources/memory.h b/ydb/core/tx/columnshard/resources/memory.h\nindex 3f0683d38dec..388caf15a6ae 100644\n--- a/ydb/core/tx/columnshard/resources/memory.h\n+++ b/ydb/core/tx/columnshard/resources/memory.h\n@@ -1,6 +1,6 @@\n #pragma once\n-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/object_counter.h>\n+#include <ydb/library/signals/owner.h>\n #include <ydb/library/services/services.pb.h>\n #include <ydb/library/actors/core/log.h>\n #include <util/system/mutex.h>\ndiff --git a/ydb/core/tx/columnshard/tablet/write_queue.cpp b/ydb/core/tx/columnshard/tablet/write_queue.cpp\nindex 41291f1d6f08..75726189c77e 100644\n--- a/ydb/core/tx/columnshard/tablet/write_queue.cpp\n+++ b/ydb/core/tx/columnshard/tablet/write_queue.cpp\n@@ -7,12 +7,6 @@\n namespace NKikimr::NColumnShard {\n \n bool TWriteTask::Execute(TColumnShard* owner, const TActorContext& /* ctx */) {\n-    auto overloadStatus = owner->CheckOverloadedWait(PathId);\n-    if (overloadStatus != TColumnShard::EOverloadStatus::None) {\n-        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_WRITE)(\"event\", \"wait_overload\")(\"status\", overloadStatus);\n-        return false;\n-    }\n-\n     owner->Counters.GetCSCounters().WritingCounters->OnWritingTaskDequeue(TMonotonic::Now() - Created);\n     owner->OperationsManager->RegisterLock(LockId, owner->Generation());\n     auto writeOperation = owner->OperationsManager->RegisterOperation(\n@@ -37,21 +31,39 @@ bool TWriteTasksQueue::Drain(const bool onWakeup, const TActorContext& ctx) {\n     if (onWakeup) {\n         WriteTasksOverloadCheckerScheduled = false;\n     }\n-    while (WriteTasks.size() && WriteTasks.front().Execute(Owner, ctx)) {\n-        WriteTasks.pop_front();\n+    std::vector<TInternalPathId> toRemove;\n+    ui32 countTasks = 0;\n+    for (auto&& i : WriteTasks) {\n+        auto overloadStatus = Owner->CheckOverloadedWait(i.first);\n+        if (overloadStatus != TColumnShard::EOverloadStatus::None) {\n+            countTasks += i.second.size();\n+            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_WRITE)(\"event\", \"wait_overload\")(\"status\", overloadStatus)(\"path_id\", i.first)(\n+                \"size\", i.second.size());\n+            continue;\n+        }\n+        for (auto&& t : i.second) {\n+            t.Execute(Owner, ctx);\n+        }\n+        toRemove.emplace_back(i.first);\n     }\n-    if (WriteTasks.size() && !WriteTasksOverloadCheckerScheduled) {\n+\n+    for (auto&& i : toRemove) {\n+        AFL_VERIFY(WriteTasks.erase(i));\n+    }\n+\n+    if (countTasks && !WriteTasksOverloadCheckerScheduled) {\n         Owner->Schedule(TDuration::MilliSeconds(300), new NActors::TEvents::TEvWakeup(1));\n         WriteTasksOverloadCheckerScheduled = true;\n-        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"queue_on_write\")(\"size\", WriteTasks.size());\n+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)(\"event\", \"queue_on_write\")(\"size\", countTasks);\n     }\n-    Owner->Counters.GetCSCounters().WritingCounters->QueueWaitSize->Add((i64)WriteTasks.size() - PredWriteTasksSize);\n-    PredWriteTasksSize = (i64)WriteTasks.size();\n-    return !WriteTasks.size();\n+    Owner->Counters.GetCSCounters().WritingCounters->QueueWaitSize->Add((i64)countTasks - PredWriteTasksSize);\n+    PredWriteTasksSize = (i64)countTasks;\n+    return !countTasks;\n }\n \n void TWriteTasksQueue::Enqueue(TWriteTask&& task) {\n-    WriteTasks.emplace_back(std::move(task));\n+    const TInternalPathId pathId = task.GetPathId();\n+    WriteTasks[pathId].emplace_back(std::move(task));\n }\n \n TWriteTasksQueue::~TWriteTasksQueue() {\ndiff --git a/ydb/core/tx/columnshard/tablet/write_queue.h b/ydb/core/tx/columnshard/tablet/write_queue.h\nindex 4e0c63363b1d..aba35e5a6a20 100644\n--- a/ydb/core/tx/columnshard/tablet/write_queue.h\n+++ b/ydb/core/tx/columnshard/tablet/write_queue.h\n@@ -35,6 +35,10 @@ class TWriteTask: TMoveOnly {\n         , Behaviour(behaviour) {\n     }\n \n+    const TInternalPathId& GetPathId() const {\n+        return PathId;\n+    }\n+\n     const TMonotonic& GetCreatedMonotonic() const {\n         return Created;\n     }\n@@ -45,7 +49,7 @@ class TWriteTask: TMoveOnly {\n class TWriteTasksQueue {\n private:\n     bool WriteTasksOverloadCheckerScheduled = false;\n-    std::deque<TWriteTask> WriteTasks;\n+    THashMap<TInternalPathId, std::deque<TWriteTask>> WriteTasks;\n     i64 PredWriteTasksSize = 0;\n     TColumnShard* Owner;\n \ndiff --git a/ydb/core/tx/columnshard/transactions/locks/read_start.cpp b/ydb/core/tx/columnshard/transactions/locks/read_start.cpp\nindex 963c47b068a9..5165e8f194d7 100644\n--- a/ydb/core/tx/columnshard/transactions/locks/read_start.cpp\n+++ b/ydb/core/tx/columnshard/transactions/locks/read_start.cpp\n@@ -17,7 +17,7 @@ bool TEvReadStart::DoDeserializeFromProto(const NKikimrColumnShardTxProto::TEven\n         AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"error\", \"cannot_parse_TEvReadStart\")(\"reason\", \"cannot_parse_schema\");\n         return false;\n     }\n-    Filter = TPKRangesFilter::BuildFromString(proto.GetRead().GetFilter(), Schema, false);\n+    Filter = TPKRangesFilter::BuildFromString(proto.GetRead().GetFilter(), Schema);\n     if (!Filter) {\n         AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)(\"error\", \"cannot_parse_TEvReadStart\")(\"reason\", \"cannot_parse_filter\");\n         return false;\ndiff --git a/ydb/core/tx/columnshard/transactions/tx_controller.cpp b/ydb/core/tx/columnshard/transactions/tx_controller.cpp\nindex 1e36aedd39ef..c423e8915e3a 100644\n--- a/ydb/core/tx/columnshard/transactions/tx_controller.cpp\n+++ b/ydb/core/tx/columnshard/transactions/tx_controller.cpp\n@@ -71,6 +71,7 @@ bool TTxController::Load(NTabletFlatExecutor::TTransactionContext& txc) {\n             ++countNoDeadline;\n         }\n         txInfo.PlanStep = rowset.GetValueOrDefault<Schema::TxInfo::PlanStep>(0);\n+        AFL_INFO(NKikimrServices::TX_COLUMNSHARD_TX)(\"event\", \"Load\")(\"tx_id\", txInfo.TxId)(\"plan_step\", txInfo.PlanStep);\n         txInfo.Source = rowset.GetValue<Schema::TxInfo::Source>();\n         txInfo.Cookie = rowset.GetValue<Schema::TxInfo::Cookie>();\n         txInfo.DeserializeSeqNoFromString(rowset.GetValue<Schema::TxInfo::SeqNo>());\n@@ -97,6 +98,8 @@ std::shared_ptr<TTxController::ITransactionOperator> TTxController::UpdateTxSour\n     op->ResetStatusOnUpdate();\n     auto& txInfo = op->MutableTxInfo();\n     txInfo.Source = tx.Source;\n+    txInfo.MinStep = tx.MinStep;\n+    txInfo.MaxStep = tx.MaxStep;\n     txInfo.Cookie = tx.Cookie;\n     txInfo.SeqNo = tx.SeqNo;\n \n@@ -111,7 +114,7 @@ TTxController::TTxInfo TTxController::RegisterTx(const std::shared_ptr<TTxContro\n     auto& txInfo = txOperator->GetTxInfo();\n     AFL_VERIFY(txInfo.MaxStep == Max<ui64>());\n     AFL_VERIFY(Operators.emplace(txInfo.TxId, txOperator).second);\n-\n+    AFL_INFO(NKikimrServices::TX_COLUMNSHARD_TX)(\"event\", \"RegisterTx\")(\"tx_id\", txInfo.TxId)(\"plan_step\", txInfo.PlanStep);\n     Schema::SaveTxInfo(db, txInfo, txBody);\n     Counters.OnRegisterTx(txOperator->GetOpType());\n     return txInfo;\n@@ -126,7 +129,7 @@ TTxController::TTxInfo TTxController::RegisterTxWithDeadline(const std::shared_p\n     txInfo.MaxStep = txInfo.MinStep + MaxCommitTxDelay.MilliSeconds();\n \n     AFL_VERIFY(Operators.emplace(txOperator->GetTxId(), txOperator).second);\n-\n+    AFL_INFO(NKikimrServices::TX_COLUMNSHARD_TX)(\"event\", \"RegisterTxWithDeadline\")(\"tx_id\", txInfo.TxId)(\"plan_step\", txInfo.PlanStep);\n     Schema::SaveTxInfo(db, txInfo, txBody);\n     DeadlineQueue.emplace(txInfo.MaxStep, txOperator->GetTxId());\n     Counters.OnRegisterTx(txOperator->GetOpType());\n@@ -295,6 +298,8 @@ TTxController::EPlanResult TTxController::PlanTx(const ui64 planStep, const ui64\n             DeadlineQueue.erase(TPlanQueueItem(txInfo.MaxStep, txId));\n         }\n         return EPlanResult::Planned;\n+    } else {\n+        AFL_INFO(NKikimrServices::TX_COLUMNSHARD_TX)(\"event\", \"skip_plan_tx_plan_step_is_not_zero\")(\"tx_id\", txId)(\"plan_step\", txInfo.PlanStep)(\"schemeshard_plan_step\", planStep);\n     }\n     return EPlanResult::AlreadyPlanned;\n }\ndiff --git a/ydb/core/tx/columnshard/transactions/tx_controller.h b/ydb/core/tx/columnshard/transactions/tx_controller.h\nindex 664b32bde0b9..af7a497b47a9 100644\n--- a/ydb/core/tx/columnshard/transactions/tx_controller.h\n+++ b/ydb/core/tx/columnshard/transactions/tx_controller.h\n@@ -50,7 +50,7 @@ struct TFullTxInfo: public TBasicTxInfo {\n \n public:\n     static TFullTxInfo BuildFake(const NKikimrTxColumnShard::ETransactionKind kind) {\n-        return TFullTxInfo(kind, 0, NActors::TActorId(), 0, {});\n+        return TFullTxInfo(kind, 0, NActors::TActorId(), 0, 0, {});\n     }\n \n     bool operator==(const TFullTxInfo& item) const = default;\n@@ -86,9 +86,10 @@ struct TFullTxInfo: public TBasicTxInfo {\n         : TBasicTxInfo(txKind, txId) {\n     }\n \n-    TFullTxInfo(const NKikimrTxColumnShard::ETransactionKind& txKind, const ui64 txId, const TActorId& source, const ui64 cookie,\n-        const std::optional<TMessageSeqNo>& seqNo)\n+    TFullTxInfo(const NKikimrTxColumnShard::ETransactionKind& txKind, const ui64 txId, const TActorId& source, const ui64 minAllowedPlanStep, \n+        const ui64 cookie, const std::optional<TMessageSeqNo>& seqNo)\n         : TBasicTxInfo(txKind, txId)\n+        , MinStep(minAllowedPlanStep)\n         , Source(source)\n         , Cookie(cookie)\n         , SeqNo(seqNo) {\n@@ -414,7 +415,6 @@ class TTxController {\n \n     THashMap<ui64, ITransactionOperator::TPtr> Operators;\n private:\n-    ui64 GetAllowedStep() const;\n     bool AbortTx(const TPlanQueueItem planQueueItem, NTabletFlatExecutor::TTransactionContext& txc);\n \n     TTxInfo RegisterTx(const std::shared_ptr<TTxController::ITransactionOperator>& txOperator, const TString& txBody,\n@@ -426,6 +426,8 @@ class TTxController {\n public:\n     TTxController(TColumnShard& owner);\n \n+    ui64 GetAllowedStep() const;\n+\n     ITransactionOperator::TPtr GetTxOperatorOptional(const ui64 txId) const {\n         auto it = Operators.find(txId);\n         if (it == Operators.end()) {\ndiff --git a/ydb/core/tx/columnshard/ut_rw/ut_backup.cpp b/ydb/core/tx/columnshard/ut_rw/ut_backup.cpp\nindex 8ca1b5a87245..f0a8aeda7a64 100644\n--- a/ydb/core/tx/columnshard/ut_rw/ut_backup.cpp\n+++ b/ydb/core/tx/columnshard/ut_rw/ut_backup.cpp\n@@ -17,7 +17,7 @@ using namespace NTxUT;\n \n Y_UNIT_TEST_SUITE(Backup) {\n \n-    bool ProposeTx(TTestBasicRuntime& runtime, TActorId& sender, NKikimrTxColumnShard::ETransactionKind txKind, const TString& txBody, const ui64 txId) {\n+    [[nodiscard]] TPlanStep ProposeTx(TTestBasicRuntime& runtime, TActorId& sender, NKikimrTxColumnShard::ETransactionKind txKind, const TString& txBody, const ui64 txId) {\n         auto event = std::make_unique<TEvColumnShard::TEvProposeTransaction>(\n             txKind, sender, txId, txBody);\n \n@@ -26,7 +26,8 @@ Y_UNIT_TEST_SUITE(Backup) {\n         const auto& res = ev->Get()->Record;\n         UNIT_ASSERT_EQUAL(res.GetTxId(), txId);\n         UNIT_ASSERT_EQUAL(res.GetTxKind(), txKind);\n-        return (res.GetStatus() == NKikimrTxColumnShard::PREPARED);\n+        UNIT_ASSERT_EQUAL(res.GetStatus(),  NKikimrTxColumnShard::PREPARED);\n+        return TPlanStep{res.GetMinStep()};\n     }\n \n     void PlanTx(TTestBasicRuntime& runtime, TActorId& sender, NKikimrTxColumnShard::ETransactionKind txKind, NOlap::TSnapshot snap, bool waitResult = true) {\n@@ -67,10 +68,8 @@ Y_UNIT_TEST_SUITE(Backup) {\n                                                                     NArrow::NTest::TTestColumn(\"field\", TTypeInfo(NTypeIds::Utf8) )\n                                                                 };\n         auto csControllerGuard = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<NOlap::TWaitCompactionController>();\n-        PrepareTablet(runtime, tableId, schema, 2);\n+        auto planStep = PrepareTablet(runtime, tableId, schema, 2);\n         ui64 txId = 111;\n-        ui64 planStep = 1000000000; // greater then delays\n-\n         ui64 writeId = 1;\n \n         TActorId sender = runtime.AllocateEdgeActor();\n@@ -78,8 +77,8 @@ Y_UNIT_TEST_SUITE(Backup) {\n         {\n             std::vector<ui64> writeIds;\n             UNIT_ASSERT(WriteData(runtime, sender, writeId++, tableId, MakeTestBlob({0, 100}, schema), schema, true, &writeIds));\n-            ProposeCommit(runtime, sender, ++txId, writeIds);\n-            PlanCommit(runtime, sender, ++planStep, txId);\n+            planStep = ProposeCommit(runtime, sender, ++txId, writeIds);\n+            PlanCommit(runtime, sender, planStep, txId);\n         }\n \n         TestWaitCondition(runtime, \"insert compacted\",\n@@ -87,13 +86,13 @@ Y_UNIT_TEST_SUITE(Backup) {\n             ++writeId;\n             std::vector<ui64> writeIds;\n             WriteData(runtime, sender, writeId, tableId, MakeTestBlob({writeId * 100, (writeId + 1) * 100}, schema), schema, true, &writeIds);\n-            ProposeCommit(runtime, sender, ++txId, writeIds);\n-            PlanCommit(runtime, sender, ++planStep, txId);\n+            planStep = ProposeCommit(runtime, sender, ++txId, writeIds);\n+            PlanCommit(runtime, sender, planStep, txId);\n             return true;\n         }, TDuration::Seconds(1000));\n \n         NKikimrTxColumnShard::TBackupTxBody txBody;\n-        NOlap::TSnapshot backupSnapshot(planStep, txId);\n+        NOlap::TSnapshot backupSnapshot(planStep.Val(), txId);\n         txBody.MutableBackupTask()->SetTableName(\"abcde\");\n         txBody.MutableBackupTask()->SetTableId(tableId);\n         txBody.MutableBackupTask()->SetSnapshotStep(backupSnapshot.GetPlanStep());\n@@ -101,9 +100,9 @@ Y_UNIT_TEST_SUITE(Backup) {\n         txBody.MutableBackupTask()->MutableS3Settings()->SetEndpoint(\"fake.fake\");\n         txBody.MutableBackupTask()->MutableS3Settings()->SetSecretKey(\"fakeSecret\");\n         AFL_VERIFY(csControllerGuard->GetFinishedExportsCount() == 0);\n-        UNIT_ASSERT(ProposeTx(runtime, sender, NKikimrTxColumnShard::TX_KIND_BACKUP, txBody.SerializeAsString(), ++txId));\n+        planStep = ProposeTx(runtime, sender, NKikimrTxColumnShard::TX_KIND_BACKUP, txBody.SerializeAsString(), ++txId);\n         AFL_VERIFY(csControllerGuard->GetFinishedExportsCount() == 1);\n-        PlanTx(runtime, sender, NKikimrTxColumnShard::TX_KIND_BACKUP, NOlap::TSnapshot(++planStep, txId), false);\n+        PlanTx(runtime, sender, NKikimrTxColumnShard::TX_KIND_BACKUP, NOlap::TSnapshot(planStep, txId), false);\n         TestWaitCondition(runtime, \"export\",\n             []() {return Singleton<NKikimr::NWrappers::NExternalStorage::TFakeExternalStorage>()->GetSize(); });\n     }\ndiff --git a/ydb/core/tx/columnshard/ut_rw/ut_columnshard_read_write.cpp b/ydb/core/tx/columnshard/ut_rw/ut_columnshard_read_write.cpp\nindex f0441b79b15f..9d3ee177a7b0 100644\n--- a/ydb/core/tx/columnshard/ut_rw/ut_columnshard_read_write.cpp\n+++ b/ydb/core/tx/columnshard/ut_rw/ut_columnshard_read_write.cpp\n@@ -10,6 +10,7 @@\n #include <ydb/core/tx/columnshard/hooks/testing/controller.h>\n #include <ydb/core/tx/columnshard/operations/write_data.h>\n #include <ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h>\n+#include <ydb/core/tx/columnshard/test_helper/test_combinator.h>\n #include <ydb/core/tx/columnshard/test_helper/controllers.h>\n #include <ydb/core/tx/columnshard/test_helper/shard_reader.h>\n #include <ydb/core/tx/columnshard/test_helper/shard_writer.h>\n@@ -354,7 +355,7 @@ void TestWrite(const TestTableDescription& table) {\n     ui64 writeId = 0;\n     ui64 tableId = 1;\n \n-    SetupSchema(runtime, sender, tableId, table);\n+    Y_UNUSED(SetupSchema(runtime, sender, tableId, table));\n \n     const auto& ydbSchema = table.Schema;\n \n@@ -434,11 +435,12 @@ void TestWrite(const TestTableDescription& table) {\n     UNIT_ASSERT(ok);\n }\n \n-void TestWriteOverload(const TestTableDescription& table) {\n+void TestWriteOverload(const TestTableDescription& table, bool WritePortionsOnInsert) {\n     TTestBasicRuntime runtime;\n     TTester::Setup(runtime);\n+    runtime.GetAppData().FeatureFlags.SetEnableWritePortionsOnInsert(WritePortionsOnInsert);\n     auto csDefaultControllerGuard = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<TDefaultTestsController>();\n-\n+    csDefaultControllerGuard->SetOverrideBlobSplitSettings(std::nullopt);\n     TActorId sender = runtime.AllocateEdgeActor();\n     CreateTestBootstrapper(runtime, CreateTestTabletInfo(TTestTxConfig::TxTablet0, TTabletTypes::ColumnShard), &CreateColumnShard);\n \n@@ -450,7 +452,7 @@ void TestWriteOverload(const TestTableDescription& table) {\n     ui64 writeId = 0;\n     ui64 tableId = 1;\n \n-    SetupSchema(runtime, sender, tableId, table);\n+    Y_UNUSED(SetupSchema(runtime, sender, tableId, table));\n \n     TString testBlob = MakeTestBlob({ 0, 100 * 1000 }, table.Schema);\n     UNIT_ASSERT(testBlob.size() > NOlap::TCompactionLimits::MAX_BLOB_SIZE / 2);\n@@ -462,26 +464,31 @@ void TestWriteOverload(const TestTableDescription& table) {\n     TDeque<TAutoPtr<IEventHandle>> capturedWrites;\n \n     auto captureEvents = [&](TTestActorRuntimeBase&, TAutoPtr<IEventHandle>& ev) {\n-        if (auto* msg = TryGetPrivateEvent<NColumnShard::TEvPrivate::TEvWriteBlobsResult>(ev)) {\n-            Cerr << \"CATCH TEvWrite, status \" << msg->GetPutResult().GetPutStatus() << Endl;\n-            if (toCatch && msg->GetPutResult().GetPutStatus() != NKikimrProto::UNKNOWN) {\n-                capturedWrites.push_back(ev.Release());\n+        if (toCatch) {\n+            TAutoPtr<IEventHandle> eventToCapture;\n+            if (WritePortionsOnInsert) {\n+                if (auto* msg = TryGetPrivateEvent<NColumnShard::NPrivateEvents::NWrite::TEvWritePortionResult>(ev)) {\n+                    Cerr << \"CATCH TEvWritePortionResult, status \" << msg->GetWriteStatus() << Endl;\n+                    if (msg->GetWriteStatus() != NKikimrProto::EReplyStatus::UNKNOWN) {\n+                        eventToCapture = ev.Release();\n+                    }\n+                }\n+             } else {\n+                if (auto* msg = TryGetPrivateEvent<NColumnShard::TEvPrivate::TEvWriteBlobsResult>(ev)) {\n+                    Cerr << \"CATCH TEvWrite, status \" << msg->GetPutResult().GetPutStatus() << Endl;\n+                    if (msg->GetPutResult().GetPutStatus() != NKikimrProto::UNKNOWN) {\n+                        eventToCapture = ev.Release();\n+                    }\n+                }\n+            }\n+            if (eventToCapture) {\n                 --toCatch;\n+                capturedWrites.push_back(std::move(eventToCapture));\n                 return true;\n-            } else {\n-                return false;\n             }\n         }\n         return false;\n     };\n-\n-    auto resendOneCaptured = [&]() {\n-        UNIT_ASSERT(capturedWrites.size());\n-        Cerr << \"RESEND TEvWrite\" << Endl;\n-        runtime.Send(capturedWrites.front().Release());\n-        capturedWrites.pop_front();\n-    };\n-\n     runtime.SetEventFilter(captureEvents);\n \n     const ui32 toSend = toCatch + 1;\n@@ -492,7 +499,8 @@ void TestWriteOverload(const TestTableDescription& table) {\n     UNIT_ASSERT_VALUES_EQUAL(WaitWriteResult(runtime, TTestTxConfig::TxTablet0), (ui32)NKikimrDataEvents::TEvWriteResult::STATUS_OVERLOADED);\n \n     while (capturedWrites.size()) {\n-        resendOneCaptured();\n+        runtime.Send(capturedWrites.front().Release());\n+        capturedWrites.pop_front();\n         UNIT_ASSERT_VALUES_EQUAL(WaitWriteResult(runtime, TTestTxConfig::TxTablet0), (ui32)NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED);\n     }\n \n@@ -518,7 +526,7 @@ void TestWriteReadDup(const TestTableDescription& table = {}) {\n     ui64 tableId = 1;\n \n     auto ydbSchema = table.Schema;\n-    SetupSchema(runtime, sender, tableId);\n+    auto planStep = SetupSchema(runtime, sender, tableId);\n \n     constexpr ui32 numRows = 10;\n     std::pair<ui64, ui64> portion = { 10, 10 + numRows };\n@@ -526,21 +534,20 @@ void TestWriteReadDup(const TestTableDescription& table = {}) {\n     TAutoPtr<IEventHandle> handle;\n \n     ui64 txId = 0;\n-    ui64 initPlanStep = 100;\n-    for (ui64 planStep = initPlanStep; planStep < initPlanStep + 50; ++planStep) {\n+    for (auto count = 0; count != 50; ++count) {\n         TSet<ui64> txIds;\n         for (ui32 i = 0; i <= 5; ++i) {\n             std::vector<ui64> writeIds;\n             ++txId;\n             UNIT_ASSERT(\n                 WriteData(runtime, sender, ++writeId, tableId, testData, ydbSchema, true, &writeIds, NEvWrite::EModificationType::Upsert, txId));\n-            ProposeCommit(runtime, sender, txId, writeIds, txId);\n+            planStep = ProposeCommit(runtime, sender, txId, writeIds, txId);\n             txIds.insert(txId);\n         }\n         PlanCommit(runtime, sender, planStep, txIds);\n \n         // read\n-        if (planStep != initPlanStep) {\n+        if (count != 0) {\n             TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep - 1, Max<ui64>()));\n             reader.SetReplyColumnIds(table.GetColumnIds({ \"timestamp\" }));\n             auto rb = reader.ReadAll();\n@@ -579,13 +586,14 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n     };\n \n     auto proposeCommit = [&](TTestBasicRuntime& runtime, TActorId& sender, ui64 txId, const std::vector<ui64>& writeIds) {\n-        ProposeCommit(runtime, sender, txId, writeIds);\n+        const auto result = ProposeCommit(runtime, sender, txId, writeIds);\n         if (reboots) {\n             RebootTablet(runtime, TTestTxConfig::TxTablet0, sender);\n         }\n+        return result;\n     };\n \n-    auto planCommit = [&](TTestBasicRuntime& runtime, TActorId& sender, ui64 planStep, ui64 txId) {\n+    auto planCommit = [&](TTestBasicRuntime& runtime, TActorId& sender, TPlanStep planStep, ui64 txId) {\n         PlanCommit(runtime, sender, planStep, txId);\n         if (reboots) {\n             RebootTablet(runtime, TTestTxConfig::TxTablet0, sender);\n@@ -597,7 +605,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n     ui64 writeId = 0;\n     ui64 tableId = 1;\n \n-    SetupSchema(runtime, sender, tableId, table, codec);\n+    auto planStep = SetupSchema(runtime, sender, tableId, table, codec);\n \n     const std::vector<NArrow::NTest::TTestColumn>& ydbSchema = table.Schema;\n     const std::vector<NArrow::NTest::TTestColumn>& testYdbPk = table.Pk;\n@@ -627,10 +635,10 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n     }\n     // commit 1: ins:0, cmt:1, idx:0\n \n-    ui64 planStep = 21;\n     ui64 txId = 100;\n-    proposeCommit(runtime, sender, txId, intWriteIds);\n+    planStep = proposeCommit(runtime, sender, txId, intWriteIds);\n     planCommit(runtime, sender, planStep, txId);\n+    const auto firstWritePlanStep = planStep;\n \n     // read 2 (committed, old snapshot)\n     {\n@@ -700,9 +708,8 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n \n     // commit 2 (init indexation): ins:0, cmt:0, idx:1\n \n-    planStep = 22;\n     ++txId;\n-    proposeCommit(runtime, sender, txId, intWriteIds);\n+    planStep = proposeCommit(runtime, sender, txId, intWriteIds);\n     planCommit(runtime, sender, planStep, txId);\n \n     // write 3: ins:1, cmt:0, idx:1\n@@ -721,10 +728,10 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n         UNIT_ASSERT(reader.IsCorrectlyFinished());\n     }\n \n-    // read 7, planstep 21 (part of index)\n+    // read 7, first write snapshot\n     {\n         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"TEST_STEP\", 7);\n-        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(21, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(firstWritePlanStep, txId));\n         reader.SetReplyColumnIds(TTestSchema::ExtractIds(ydbSchema));\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(rb);\n@@ -738,10 +745,10 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n         UNIT_ASSERT(DataNotHas({ rb }, portion[2]));\n     }\n \n-    // read 8, planstep 22 (full index)\n+    // read 8 (full index)\n     {\n         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"TEST_STEP\", 8);\n-        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(22, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n         reader.SetReplyColumnIds(TTestSchema::ExtractIds(ydbSchema));\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(rb);\n@@ -757,9 +764,8 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n \n     // commit 3: ins:0, cmt:1, idx:1\n \n-    planStep = 23;\n     ++txId;\n-    proposeCommit(runtime, sender, txId, intWriteIds);\n+    planStep = proposeCommit(runtime, sender, txId, intWriteIds);\n     planCommit(runtime, sender, planStep, txId);\n \n     // write 4: ins:1, cmt:1, idx:1\n@@ -771,7 +777,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n     // read 9 (committed, indexed)\n     {\n         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"TEST_STEP\", 9);\n-        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(23, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n         reader.SetReplyColumnIds(TTestSchema::ExtractIds(ydbSchema));\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(rb);\n@@ -788,15 +794,14 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n \n     // commit 4: ins:0, cmt:2, idx:1 (with duplicates in PK)\n \n-    planStep = 24;\n     ++txId;\n-    proposeCommit(runtime, sender, txId, intWriteIds);\n+    planStep = proposeCommit(runtime, sender, txId, intWriteIds);\n     planCommit(runtime, sender, planStep, txId);\n \n     // read 10\n     {\n         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"TEST_STEP\", 10);\n-        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(24, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n         reader.SetReplyColumnIds(TTestSchema::ExtractIds(ydbSchema));\n         auto rb = reader.ReadAll();\n         UNIT_ASSERT(rb);\n@@ -841,7 +846,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n     // read 11 (range predicate: closed interval)\n     {\n         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"TEST_STEP\", 11);\n-        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(24, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n         reader.SetReplyColumnIds(TTestSchema::ExtractIds(ydbSchema));\n         reader.AddRange(MakeTestRange({ 10, 42 }, true, true, testYdbPk));\n         auto rb = reader.ReadAll();\n@@ -858,7 +863,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString\n     // read 12 (range predicate: open interval)\n     {\n         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)(\"TEST_STEP\", 11);\n-        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(24, txId));\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n         reader.SetReplyColumnIds(TTestSchema::ExtractIds(ydbSchema));\n         reader.AddRange(MakeTestRange({ 10, 42 }, false, false, testYdbPk));\n         auto rb = reader.ReadAll();\n@@ -896,13 +901,14 @@ void TestCompactionInGranuleImpl(bool reboots, const TestTableDescription& table\n     };\n \n     auto proposeCommit = [&](TTestBasicRuntime& runtime, TActorId& sender, ui64 txId, const std::vector<ui64>& writeIds) {\n-        ProposeCommit(runtime, sender, txId, writeIds);\n+        auto result = ProposeCommit(runtime, sender, txId, writeIds);\n         if (reboots) {\n             RebootTablet(runtime, TTestTxConfig::TxTablet0, sender);\n         }\n+        return result;\n     };\n \n-    auto planCommit = [&](TTestBasicRuntime& runtime, TActorId& sender, ui64 planStep, ui64 txId) {\n+    auto planCommit = [&](TTestBasicRuntime& runtime, TActorId& sender, TPlanStep planStep, ui64 txId) {\n         PlanCommit(runtime, sender, planStep, txId);\n         if (reboots) {\n             RebootTablet(runtime, TTestTxConfig::TxTablet0, sender);\n@@ -913,10 +919,9 @@ void TestCompactionInGranuleImpl(bool reboots, const TestTableDescription& table\n \n     ui64 writeId = 0;\n     ui64 tableId = 1;\n-    ui64 planStep = 100;\n     ui64 txId = 100;\n \n-    SetupSchema(runtime, sender, tableId, table);\n+    auto planStep = SetupSchema(runtime, sender, tableId, table);\n     TAutoPtr<IEventHandle> handle;\n     const auto& ydbSchema = table.Schema;\n     const auto& ydbPk = table.Pk;\n@@ -935,7 +940,7 @@ void TestCompactionInGranuleImpl(bool reboots, const TestTableDescription& table\n \n     // inserts triggered by count\n     ui32 pos = triggerPortionSize;\n-    for (ui32 i = 0; i < 1; ++i, ++planStep, ++txId) {\n+    for (ui32 i = 0; i < 1; ++i, ++txId) {\n         std::vector<ui64> ids;\n         ids.reserve(numWrites);\n         for (ui32 w = 0; w < numWrites; ++w, ++writeId, pos += portionSize) {\n@@ -949,7 +954,7 @@ void TestCompactionInGranuleImpl(bool reboots, const TestTableDescription& table\n             RebootTablet(runtime, TTestTxConfig::TxTablet0, sender);\n         }\n \n-        proposeCommit(runtime, sender, txId, ids);\n+        planStep = proposeCommit(runtime, sender, txId, ids);\n         planCommit(runtime, sender, planStep, txId);\n     }\n     std::pair<ui64, ui64> smallWrites = { triggerPortionSize, pos };\n@@ -958,16 +963,15 @@ void TestCompactionInGranuleImpl(bool reboots, const TestTableDescription& table\n     NOlap::TCompactionLimits engineLimits;\n     ui32 numTxs = engineLimits.GranuleSizeForOverloadPrevent / triggerData.size() + 1;\n \n-    for (ui32 i = 0; i < numTxs; ++i, ++writeId, ++planStep, ++txId) {\n+    for (ui32 i = 0; i < numTxs; ++i, ++writeId, ++txId) {\n         std::vector<ui64> writeIds;\n         UNIT_ASSERT(write(runtime, sender, writeId, tableId, triggerData, ydbSchema, writeIds));\n \n-        proposeCommit(runtime, sender, txId, writeIds);\n+        planStep = proposeCommit(runtime, sender, txId, writeIds);\n         planCommit(runtime, sender, planStep, txId);\n     }\n \n     // TODO: Move tablet's time to the future with mediator timecast instead\n-    --planStep;\n     --txId;\n \n     for (ui32 i = 0; i < 2; ++i) {\n@@ -1169,17 +1173,15 @@ void TestReadWithProgram(const TestTableDescription& table = {}) {\n \n     ui64 writeId = 0;\n     ui64 tableId = 1;\n-    ui64 planStep = 100;\n     ui64 txId = 100;\n \n-    SetupSchema(runtime, sender, tableId, table);\n+    auto planStep = SetupSchema(runtime, sender, tableId, table);\n \n     {   // write some data\n         std::vector<ui64> writeIds;\n         bool ok = WriteData(runtime, sender, writeId, tableId, MakeTestBlob({ 0, 100 }, table.Schema), table.Schema, true, &writeIds);\n         UNIT_ASSERT(ok);\n-\n-        ProposeCommit(runtime, sender, txId, writeIds);\n+        planStep = ProposeCommit(runtime, sender, txId, writeIds);\n         PlanCommit(runtime, sender, planStep, txId);\n     }\n \n@@ -1253,17 +1255,16 @@ void TestReadWithProgramLike(const TestTableDescription& table = {}) {\n \n     ui64 writeId = 0;\n     ui64 tableId = 1;\n-    ui64 planStep = 100;\n     ui64 txId = 100;\n \n-    SetupSchema(runtime, sender, tableId, table);\n+    auto planStep = SetupSchema(runtime, sender, tableId, table);\n \n     {   // write some data\n         std::vector<ui64> writeIds;\n         bool ok = WriteData(runtime, sender, writeId, tableId, MakeTestBlob({ 0, 100 }, table.Schema), table.Schema, true, &writeIds);\n         UNIT_ASSERT(ok);\n \n-        ProposeCommit(runtime, sender, txId, writeIds);\n+        planStep = ProposeCommit(runtime, sender, txId, writeIds);\n         PlanCommit(runtime, sender, planStep, txId);\n     }\n \n@@ -1317,17 +1318,16 @@ void TestSomePrograms(const TestTableDescription& table) {\n \n     ui64 writeId = 0;\n     ui64 tableId = 1;\n-    ui64 planStep = 100;\n     ui64 txId = 100;\n \n-    SetupSchema(runtime, sender, tableId, table);\n+    auto planStep = SetupSchema(runtime, sender, tableId, table);\n \n     {   // write some data\n         std::vector<ui64> writeIds;\n         bool ok = WriteData(runtime, sender, writeId, tableId, MakeTestBlob({ 0, 100 }, table.Schema), table.Schema, true, &writeIds);\n         UNIT_ASSERT(ok);\n \n-        ProposeCommit(runtime, sender, txId, writeIds);\n+        planStep = ProposeCommit(runtime, sender, txId, writeIds);\n         PlanCommit(runtime, sender, planStep, txId);\n     }\n \n@@ -1354,6 +1354,83 @@ void TestSomePrograms(const TestTableDescription& table) {\n     }\n }\n \n+void TestReadWithProgramNoProjection(const TestTableDescription& table = {}) {\n+    TTestBasicRuntime runtime;\n+    TTester::Setup(runtime);\n+    auto csDefaultControllerGuard = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<TDefaultTestsController>();\n+\n+    TActorId sender = runtime.AllocateEdgeActor();\n+    CreateTestBootstrapper(runtime, CreateTestTabletInfo(TTestTxConfig::TxTablet0, TTabletTypes::ColumnShard), &CreateColumnShard);\n+\n+    TDispatchOptions options;\n+    options.FinalEvents.push_back(TDispatchOptions::TFinalEventCondition(TEvTablet::EvBoot));\n+    runtime.DispatchEvents(options);\n+\n+    ui64 writeId = 0;\n+    ui64 tableId = 1;\n+    ui64 txId = 100;\n+\n+    auto planStep = SetupSchema(runtime, sender, tableId, table);\n+\n+    {   // write some data\n+        std::vector<ui64> writeIds;\n+        bool ok = WriteData(runtime, sender, writeId, tableId, MakeTestBlob({ 0, 100 }, table.Schema), table.Schema, true, &writeIds);\n+        UNIT_ASSERT(ok);\n+        planStep = ProposeCommit(runtime, sender, txId, writeIds);\n+        PlanCommit(runtime, sender, planStep, txId);\n+    }\n+\n+    std::vector<TString> programs;\n+    programs.push_back(\"XXXYYYZZZ\");\n+    {\n+        NKikimrSSA::TProgram ssa = MakeSelect(TAssignment::FUNC_CMP_EQUAL);\n+        TString serialized;\n+        UNIT_ASSERT(ssa.SerializeToString(&serialized));\n+\n+        NKikimrSSA::TOlapProgram program;\n+        program.SetProgram(serialized);\n+\n+        programs.push_back(\"\");\n+        UNIT_ASSERT(program.SerializeToString(&programs.back()));\n+\n+        //remove projections\n+        auto* commands = ssa.MutableCommand();\n+        for(int i = commands->size() - 1; i >= 0; --i) {\n+            if ((*commands)[i].HasProjection()) {\n+                commands->DeleteSubrange(i, 1);\n+            }\n+        }\n+\n+        UNIT_ASSERT(ssa.SerializeToString(&serialized));\n+        program.SetProgram(serialized);\n+        programs.push_back(\"\");\n+        UNIT_ASSERT(program.SerializeToString(&programs.back()));\n+    }\n+\n+    ui32 i = 0;\n+    for (auto& programText : programs) {\n+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));\n+        reader.SetProgram(programText);\n+        auto rb = reader.ReadAll();\n+        switch(i) {\n+            case 0:\n+            UNIT_ASSERT(reader.IsError());\n+            break;\n+\n+            case 1:\n+            UNIT_ASSERT(!reader.IsError());\n+            break;\n+\n+            case 2:\n+            UNIT_ASSERT(reader.IsError());\n+            UNIT_ASSERT(reader.GetErrors().back().Getmessage().Contains(\"program has no projections\"));\n+            break;\n+        }\n+        UNIT_ASSERT(reader.IsFinished());\n+        ++i;\n+    }\n+}\n+\n struct TReadAggregateResult {\n     ui32 NumRows = 1;\n \n@@ -1379,19 +1456,18 @@ void TestReadAggregate(const std::vector<NArrow::NTest::TTestColumn>& ydbSchema,\n \n     ui64 writeId = 0;\n     ui64 tableId = 1;\n-    ui64 planStep = 100;\n     ui64 txId = 100;\n \n     auto pk = NArrow::NTest::TTestColumn::CropSchema(ydbSchema, 4);\n     TestTableDescription table{ .Schema = ydbSchema, .Pk = pk };\n-    SetupSchema(runtime, sender, tableId, table);\n+    auto planStep = SetupSchema(runtime, sender, tableId, table);\n \n     {   // write some data\n         std::vector<ui64> writeIds;\n         bool ok = WriteData(runtime, sender, writeId, tableId, testDataBlob, table.Schema, true, &writeIds);\n         UNIT_ASSERT(ok);\n \n-        ProposeCommit(runtime, sender, txId, writeIds);\n+        planStep = ProposeCommit(runtime, sender, txId, writeIds);\n         PlanCommit(runtime, sender, planStep, txId);\n     }\n \n@@ -1496,7 +1572,8 @@ Y_UNIT_TEST_SUITE(EvWrite) {\n         const std::vector<NArrow::NTest::TTestColumn> schema = { NArrow::NTest::TTestColumn(\"key\", TTypeInfo(NTypeIds::Uint64)),\n             NArrow::NTest::TTestColumn(\"field\", TTypeInfo(NTypeIds::Utf8)) };\n         const std::vector<ui32> columnsIds = { 1, 2 };\n-        PrepareTablet(runtime, tableId, schema);\n+        auto planStep = PrepareTablet(runtime, tableId, schema);\n+        const auto schemaPlanStep = planStep;\n         const ui64 txId = 111;\n \n         NConstruction::IArrayBuilder::TPtr keyColumn =\n@@ -1508,21 +1585,19 @@ Y_UNIT_TEST_SUITE(EvWrite) {\n \n         NTxUT::TShardWriter writer(runtime, TTestTxConfig::TxTablet0, tableId, 222);\n         AFL_VERIFY(writer.Write(batch, {1, 2}, txId) == NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED);\n-        AFL_VERIFY(writer.StartCommit(txId) == NKikimrDataEvents::TEvWriteResult::STATUS_PREPARED);\n+        planStep = writer.StartCommit(txId);\n \n         {\n             NTxUT::TShardWriter writer(runtime, TTestTxConfig::TxTablet0, tableId, 444);\n-            AFL_VERIFY(writer.StartCommit(444) == NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST);\n+            writer.StartCommitFail(444);\n         }\n-\n         {\n-            auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(10, txId), schema);\n+            auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(schemaPlanStep, txId), schema);\n             UNIT_ASSERT_VALUES_EQUAL(readResult->num_rows(), 0);\n-\n-            PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(11, txId));\n+            PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(planStep, txId));\n         }\n \n-        auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot::MaxForPlanStep(11), schema);\n+        auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot::MaxForPlanStep(planStep), schema);\n         UNIT_ASSERT_VALUES_EQUAL(readResult->num_rows(), 2048);\n     }\n \n@@ -1537,7 +1612,7 @@ Y_UNIT_TEST_SUITE(EvWrite) {\n         const std::vector<NArrow::NTest::TTestColumn> schema = { NArrow::NTest::TTestColumn(\"key\", TTypeInfo(NTypeIds::Uint64)),\n             NArrow::NTest::TTestColumn(\"field\", TTypeInfo(NTypeIds::Utf8)) };\n         const std::vector<ui32> columnsIds = { 1, 2 };\n-        PrepareTablet(runtime, tableId, schema);\n+        auto planStep = PrepareTablet(runtime, tableId, schema);\n         const ui64 txId = 111;\n \n         NConstruction::IArrayBuilder::TPtr keyColumn =\n@@ -1550,9 +1625,9 @@ Y_UNIT_TEST_SUITE(EvWrite) {\n         AFL_VERIFY(writer.Write(batch, {1, 2}, txId) == NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED);\n         AFL_VERIFY(writer.Abort(txId) == NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED);\n \n-        PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(10, txId + 1), false);\n+        PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(planStep, txId + 1), false);\n \n-        auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot::MaxForPlanStep(10), schema);\n+        auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot::MaxForPlanStep(planStep), schema);\n         UNIT_ASSERT_VALUES_EQUAL(readResult->num_rows(), 0);\n     }\n \n@@ -1566,7 +1641,7 @@ Y_UNIT_TEST_SUITE(EvWrite) {\n         const ui64 tableId = 1;\n         const std::vector<NArrow::NTest::TTestColumn> schema = { NArrow::NTest::TTestColumn(\"key\", TTypeInfo(NTypeIds::Uint64)),\n             NArrow::NTest::TTestColumn(\"field\", TTypeInfo(NTypeIds::Utf8)) };\n-        PrepareTablet(runtime, tableId, schema);\n+        auto planStep = PrepareTablet(runtime, tableId, schema);\n         const ui64 txId = 111;\n \n         NConstruction::IArrayBuilder::TPtr keyColumn =\n@@ -1580,11 +1655,11 @@ Y_UNIT_TEST_SUITE(EvWrite) {\n \n         NTxUT::TShardWriter writer(runtime, TTestTxConfig::TxTablet0, tableId, 222);\n         AFL_VERIFY(writer.Write(batch, {1, 2}, txId) == NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED);\n-        AFL_VERIFY(writer.StartCommit(txId) == NKikimrDataEvents::TEvWriteResult::STATUS_PREPARED);\n+        planStep = writer.StartCommit(txId);\n \n-        PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(11, txId));\n+        PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(planStep, txId));\n \n-        auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot::MaxForPlanStep(11), schema);\n+        auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot::MaxForPlanStep(planStep), schema);\n         UNIT_ASSERT_VALUES_EQUAL(readResult->num_rows(), 2048);\n     }\n \n@@ -1599,7 +1674,7 @@ Y_UNIT_TEST_SUITE(EvWrite) {\n         const std::vector<NArrow::NTest::TTestColumn> schema = { NArrow::NTest::TTestColumn(\"key\", TTypeInfo(NTypeIds::Uint64)),\n             NArrow::NTest::TTestColumn(\"field\", TTypeInfo(NTypeIds::Utf8)) };\n         const std::vector<ui32> columnIds = { 1, 2 };\n-        PrepareTablet(runtime, tableId, schema);\n+        auto planStep = PrepareTablet(runtime, tableId, schema);\n         const ui64 txId = 111;\n \n         NTxUT::TShardWriter writer(runtime, TTestTxConfig::TxTablet0, tableId, 222);\n@@ -1612,7 +1687,7 @@ Y_UNIT_TEST_SUITE(EvWrite) {\n             auto batch = NConstruction::TRecordBatchConstructor({ keyColumn, column }).BuildBatch(2048);\n             AFL_VERIFY(writer.Write(batch, columnIds, txId) == NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED);\n             {\n-                auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(10, txId), schema);\n+                auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(planStep, txId), schema);\n                 UNIT_ASSERT_VALUES_EQUAL(readResult->num_rows(), 0);\n             }\n         }\n@@ -1626,16 +1701,16 @@ Y_UNIT_TEST_SUITE(EvWrite) {\n             AFL_VERIFY(writer.Write(batch, columnIds, txId) == NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED);\n \n             {\n-                auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(10, txId), schema);\n+                auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(planStep, txId), schema);\n                 UNIT_ASSERT_VALUES_EQUAL(readResult->num_rows(), 0);\n             }\n         }\n         {\n-            AFL_VERIFY(writer.StartCommit(txId) == NKikimrDataEvents::TEvWriteResult::STATUS_PREPARED);\n-            PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(11, txId));\n+            planStep = writer.StartCommit(txId);\n+            PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(planStep, txId));\n         }\n \n-        auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(11, txId), schema);\n+        auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(planStep, txId), schema);\n         UNIT_ASSERT_VALUES_EQUAL(readResult->num_rows(), 2 * 2048);\n     }\n }\n@@ -1665,15 +1740,10 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n         TestWrite(table);\n     }\n \n-    Y_UNIT_TEST(WriteOverload) {\n+    Y_UNIT_TEST_QUATRO(WriteOverload, InStore, WithWritePortionsOnInsert) {\n         TestTableDescription table;\n-        TestWriteOverload(table);\n-    }\n-\n-    Y_UNIT_TEST(WriteStandaloneOverload) {\n-        TestTableDescription table;\n-        table.InStore = false;\n-        TestWriteOverload(table);\n+        table.InStore = InStore;\n+        TestWriteOverload(table, WithWritePortionsOnInsert);\n     }\n \n     Y_UNIT_TEST(WriteReadDuplicate) {\n@@ -1699,7 +1769,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n         ui64 tableId = 1;\n \n         auto ydbSchema = table.Schema;\n-        SetupSchema(runtime, sender, tableId);\n+        auto planStep = SetupSchema(runtime, sender, tableId);\n \n         constexpr ui32 numRows = 10;\n         std::pair<ui64, ui64> portion = { 10, 10 + numRows };\n@@ -1707,13 +1777,12 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n         TAutoPtr<IEventHandle> handle;\n \n         ui64 txId = 0;\n-        ui64 planStep = 100;\n         {\n             TSet<ui64> txIds;\n             std::vector<ui64> writeIds;\n             UNIT_ASSERT(\n                 WriteData(runtime, sender, ++writeId, tableId, testData, ydbSchema, true, &writeIds, NEvWrite::EModificationType::Update));\n-            ProposeCommit(runtime, sender, ++txId, writeIds);\n+            planStep = ProposeCommit(runtime, sender, ++txId, writeIds);\n             txIds.insert(txId);\n             PlanCommit(runtime, sender, planStep, txIds);\n \n@@ -1722,14 +1791,13 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n             auto rb = reader.ReadAll();\n             UNIT_ASSERT(reader.IsCorrectlyFinished());\n             UNIT_ASSERT(!rb || rb->num_rows() == 0);\n-            ++planStep;\n         }\n         {\n             TSet<ui64> txIds;\n             std::vector<ui64> writeIds;\n             UNIT_ASSERT(\n                 WriteData(runtime, sender, ++writeId, tableId, testData, ydbSchema, true, &writeIds, NEvWrite::EModificationType::Insert));\n-            ProposeCommit(runtime, sender, ++txId, writeIds);\n+            planStep = ProposeCommit(runtime, sender, ++txId, writeIds);\n             txIds.insert(txId);\n             PlanCommit(runtime, sender, planStep, txIds);\n \n@@ -1739,14 +1807,13 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n             UNIT_ASSERT(reader.IsCorrectlyFinished());\n             UNIT_ASSERT(CheckOrdered(rb));\n             UNIT_ASSERT(DataHas({ rb }, portion, true));\n-            ++planStep;\n         }\n         {\n             TSet<ui64> txIds;\n             std::vector<ui64> writeIds;\n             UNIT_ASSERT(\n                 WriteData(runtime, sender, ++writeId, tableId, testData, ydbSchema, true, &writeIds, NEvWrite::EModificationType::Upsert));\n-            ProposeCommit(runtime, sender, ++txId, writeIds);\n+            planStep = ProposeCommit(runtime, sender, ++txId, writeIds);\n             txIds.insert(txId);\n             PlanCommit(runtime, sender, planStep, txIds);\n \n@@ -1756,14 +1823,13 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n             UNIT_ASSERT(reader.IsCorrectlyFinished());\n             UNIT_ASSERT(CheckOrdered(rb));\n             UNIT_ASSERT(DataHas({ rb }, portion, true));\n-            ++planStep;\n         }\n         {\n             TSet<ui64> txIds;\n             std::vector<ui64> writeIds;\n             UNIT_ASSERT(\n                 WriteData(runtime, sender, ++writeId, tableId, testData, ydbSchema, true, &writeIds, NEvWrite::EModificationType::Update));\n-            ProposeCommit(runtime, sender, ++txId, writeIds);\n+            planStep = ProposeCommit(runtime, sender, ++txId, writeIds);\n             txIds.insert(txId);\n             PlanCommit(runtime, sender, planStep, txIds);\n \n@@ -1773,7 +1839,6 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n             UNIT_ASSERT(reader.IsCorrectlyFinished());\n             UNIT_ASSERT(CheckOrdered(rb));\n             UNIT_ASSERT(DataHas({ rb }, portion, true));\n-            ++planStep;\n         }\n         {\n             TSet<ui64> txIds;\n@@ -1786,7 +1851,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n             std::vector<ui64> writeIds;\n             UNIT_ASSERT(\n                 WriteData(runtime, sender, ++writeId, tableId, testData, ydbSchema, true, &writeIds, NEvWrite::EModificationType::Delete));\n-            ProposeCommit(runtime, sender, ++txId, writeIds);\n+            auto planStep = ProposeCommit(runtime, sender, ++txId, writeIds);\n             txIds.insert(txId);\n             PlanCommit(runtime, sender, planStep, txIds);\n \n@@ -1795,7 +1860,6 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n             auto rb = reader.ReadAll();\n             UNIT_ASSERT(reader.IsCorrectlyFinished());\n             AFL_VERIFY(!rb || rb->num_rows() == 0)(\"count\", rb->num_rows());\n-            ++planStep;\n         }\n     }\n \n@@ -1933,6 +1997,10 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n         TestSomePrograms(table);\n     }\n \n+    Y_UNIT_TEST(ReadWithProgramNoProjection) {\n+        TestReadWithProgramNoProjection();\n+    }\n+\n     Y_UNIT_TEST(ReadAggregate) {\n         auto schema = TTestSchema::YdbAllTypesSchema();\n         auto testBlob = MakeTestBlob({ 0, 100 }, schema);\n@@ -1990,13 +2058,13 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n     class TTabletReadPredicateTest {\n     private:\n         TTestBasicRuntime& Runtime;\n-        const ui64 PlanStep;\n+        const TPlanStep PlanStep;\n         const ui64 TxId;\n         const std::vector<NArrow::NTest::TTestColumn> YdbPk;\n \n     public:\n         TTabletReadPredicateTest(\n-            TTestBasicRuntime& runtime, const ui64 planStep, const ui64 txId, const std::vector<NArrow::NTest::TTestColumn>& ydbPk)\n+            TTestBasicRuntime& runtime, const TPlanStep planStep, const ui64 txId, const std::vector<NArrow::NTest::TTestColumn>& ydbPk)\n             : Runtime(runtime)\n             , PlanStep(planStep)\n             , TxId(txId)\n@@ -2126,10 +2194,9 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n         runtime.DispatchEvents(options);\n \n         const ui64 tableId = 1;\n-        ui64 planStep = 100;\n         ui64 txId = 100;\n \n-        SetupSchema(runtime, sender, tableId, table, \"lz4\");\n+        auto planStep = SetupSchema(runtime, sender, tableId, table, \"lz4\");\n         TAutoPtr<IEventHandle> handle;\n \n         bool isStrPk0 = table.Pk[0].GetType() == TTypeInfo(NTypeIds::String) || table.Pk[0].GetType() == TTypeInfo(NTypeIds::Utf8);\n@@ -2142,7 +2209,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n         const ui32 numWrites = 23;\n         {\n             ui64 writeId = 0;\n-            for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++planStep, ++txId) {\n+            for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++txId) {\n                 ui64 start = i * (triggerPortionSize - overlapSize);\n                 std::pair<ui64, ui64> triggerPortion = { start, start + triggerPortionSize };\n                 TString triggerData = MakeTestBlob(triggerPortion, table.Schema, testBlobOptions);\n@@ -2152,13 +2219,12 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n                 std::vector<ui64> writeIds;\n                 UNIT_ASSERT(WriteData(runtime, sender, writeId, tableId, triggerData, table.Schema, true, &writeIds));\n \n-                ProposeCommit(runtime, sender, txId, writeIds);\n+                planStep = ProposeCommit(runtime, sender, txId, writeIds);\n                 PlanCommit(runtime, sender, planStep, txId);\n             }\n         }\n \n         // TODO: Move tablet's time to the future with mediator timecast instead\n-        --planStep;\n         --txId;\n \n         const ui32 fullNumRows = numWrites * (triggerPortionSize - overlapSize) + overlapSize;\n@@ -2368,11 +2434,10 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n \n         ui64 writeId = 0;\n         ui64 tableId = 1;\n-        ui64 planStep = 1000000;\n         ui64 txId = 100;\n \n         auto ydbSchema = TTestSchema::YdbSchema();\n-        SetupSchema(runtime, sender, tableId);\n+        auto planStep = SetupSchema(runtime, sender, tableId);\n         TAutoPtr<IEventHandle> handle;\n \n         // Write some test data to advance the time\n@@ -2383,7 +2448,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n             std::vector<ui64> writeIds;\n             UNIT_ASSERT(WriteData(runtime, sender, writeId, tableId, triggerData, ydbSchema, true, &writeIds));\n \n-            ProposeCommit(runtime, sender, txId, writeIds);\n+            planStep = ProposeCommit(runtime, sender, txId, writeIds);\n             PlanCommit(runtime, sender, planStep, txId);\n         }\n \n@@ -2397,7 +2462,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n                 request->Record.SetScanId(1);\n                 request->Record.SetLocalPathId(tableId);\n                 request->Record.SetTablePath(\"test_olap_table\");\n-                request->Record.MutableSnapshot()->SetStep(planStep - staleness.MilliSeconds());\n+                request->Record.MutableSnapshot()->SetStep(planStep.Val() - staleness.MilliSeconds());\n                 request->Record.MutableSnapshot()->SetTxId(Max<ui64>());\n \n                 ForwardToTablet(runtime, TTestTxConfig::TxTablet0, sender, request.release());\n@@ -2410,7 +2475,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n             // Cerr << response << Endl;\n             UNIT_ASSERT_VALUES_EQUAL(response.GetStatus(), Ydb::StatusIds::BAD_REQUEST);\n             UNIT_ASSERT_VALUES_EQUAL(response.IssuesSize(), 1);\n-            UNIT_ASSERT_STRING_CONTAINS(response.GetIssues(0).message(), \"Snapshot too old: {640000:max}\");\n+            UNIT_ASSERT_STRING_CONTAINS(response.GetIssues(0).message(), TStringBuilder() << \"Snapshot too old: {\" << planStep - staleness.MilliSeconds() << \":max}\");\n         }\n \n         // Try to read snapshot that is too old\n@@ -2444,7 +2509,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n         ui64 tableId = 1;\n \n         auto ydbSchema = TTestSchema::YdbSchema();\n-        SetupSchema(runtime, sender, tableId);\n+        auto planStep = SetupSchema(runtime, sender, tableId);\n         TAutoPtr<IEventHandle> handle;\n \n         bool blockReadFinished = true;\n@@ -2538,17 +2603,6 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n         };\n         runtime.SetEventFilter(captureEvents);\n \n-        // Disable GC batching so that deleted blobs get collected without a delay\n-        {\n-            TAtomic unusedPrev;\n-            runtime.GetAppData().Icb->SetValue(\"ColumnShardControls.BlobCountToTriggerGC\", 1, unusedPrev);\n-        }\n-\n-        {\n-            TAtomic unusedPrev;\n-            runtime.GetAppData().Icb->SetValue(\"ColumnShardControls.MaxPortionsInGranule\", 10, unusedPrev);\n-        }\n-\n         // Write different keys: grow on compaction\n \n         static const ui32 triggerPortionSize = 75 * 1000;\n@@ -2557,16 +2611,15 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n         UNIT_ASSERT(triggerData.size() > NColumnShard::TLimits::MIN_BYTES_TO_INSERT);\n         UNIT_ASSERT(triggerData.size() < NColumnShard::TLimits::GetMaxBlobSize());\n \n-        ui64 planStep = 5000000;\n         ui64 txId = 1000;\n \n         // Overwrite the same data multiple times to produce multiple portions at different timestamps\n         ui32 numWrites = 14;\n-        for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++planStep, ++txId) {\n+        for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++txId) {\n             std::vector<ui64> writeIds;\n             UNIT_ASSERT(WriteData(runtime, sender, writeId, tableId, triggerData, ydbSchema, true, &writeIds));\n \n-            ProposeCommit(runtime, sender, txId, writeIds);\n+            planStep = ProposeCommit(runtime, sender, txId, writeIds);\n             PlanCommit(runtime, sender, planStep, txId);\n         }\n \n@@ -2577,14 +2630,12 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n             std::vector<ui64> writeIds;\n             UNIT_ASSERT(WriteData(runtime, sender, writeId, tableId, smallData, ydbSchema, true, &writeIds));\n \n-            ProposeCommit(runtime, sender, txId, writeIds);\n+            planStep = ProposeCommit(runtime, sender, txId, writeIds);\n             PlanCommit(runtime, sender, planStep, txId);\n             ++writeId;\n-            ++planStep;\n             ++txId;\n         }\n \n-        --planStep;\n         --txId;\n         Cerr << compactionsHappened << Endl;\n         //        UNIT_ASSERT_GE(compactionsHappened, 3); // we catch it three times per action\n@@ -2607,14 +2658,12 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n         // read request is in progress and keeps the portions\n \n         // Advance the time in order to trigger GC\n-        TDuration delay = TDuration::Minutes(6);\n-        planStep += delay.MilliSeconds();\n         numWrites = 10;\n-        for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++planStep, ++txId) {\n+        for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++txId) {\n             std::vector<ui64> writeIds;\n             UNIT_ASSERT(WriteData(runtime, sender, writeId, tableId, triggerData, ydbSchema, true, &writeIds));\n \n-            ProposeCommit(runtime, sender, txId, writeIds);\n+            planStep = ProposeCommit(runtime, sender, txId, writeIds);\n             PlanCommit(runtime, sender, planStep, txId);\n         }\n         {\n@@ -2632,7 +2681,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n         // Check that GC happened but it didn't collect some old portions\n         UNIT_ASSERT_GT(compactionsHappened, previousCompactionsHappened);\n         UNIT_ASSERT_EQUAL(cleanupsHappened, 0);\n-        UNIT_ASSERT_GT_C(oldPortions.size(), deletedPortions.size(), \"Some old portions must not be deleted because the are in use by read\");\n+        UNIT_ASSERT_GT_C(oldPortions.size(), deletedPortions.size(), \"Some old portions must not be deleted because they are in use by read\");\n         UNIT_ASSERT_GT_C(delayedBlobs.size(), 0, \"Read request is expected to have at least one committed blob, which deletion must be delayed\");\n         previousCompactionsHappened = compactionsHappened;\n         previousCleanupsHappened = cleanupsHappened;\n@@ -2646,17 +2695,17 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n         }\n \n         // Advance the time and trigger some more cleanups withno compactions\n+        csDefaultControllerGuard->SetOverrideUsedSnapshotLivetime(csDefaultControllerGuard->GetMaxReadStalenessInMem() - TDuration::MilliSeconds(1));\n         csDefaultControllerGuard->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Compaction);\n         {\n             auto read = std::make_unique<NColumnShard::TEvPrivate::TEvPingSnapshotsUsage>();\n             ForwardToTablet(runtime, TTestTxConfig::TxTablet0, sender, read.release());\n         }\n-        planStep += (2 * delay).MilliSeconds();\n-        for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++planStep, ++txId) {\n+        for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++txId) {\n             std::vector<ui64> writeIds;\n             UNIT_ASSERT(WriteData(runtime, sender, writeId, tableId, triggerData, ydbSchema, true, &writeIds));\n \n-            ProposeCommit(runtime, sender, txId, writeIds);\n+            planStep = ProposeCommit(runtime, sender, txId, writeIds);\n             PlanCommit(runtime, sender, planStep, txId);\n         }\n         UNIT_ASSERT_EQUAL(cleanupsHappened, 0);\n@@ -2666,16 +2715,17 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {\n             auto read = std::make_unique<NColumnShard::TEvPrivate::TEvPingSnapshotsUsage>();\n             ForwardToTablet(runtime, TTestTxConfig::TxTablet0, sender, read.release());\n         }\n-        for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++planStep, ++txId) {\n+        for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++txId) {\n             std::vector<ui64> writeIds;\n             UNIT_ASSERT(WriteData(runtime, sender, writeId, tableId, triggerData, ydbSchema, true, &writeIds));\n \n-            ProposeCommit(runtime, sender, txId, writeIds);\n+            planStep = ProposeCommit(runtime, sender, txId, writeIds);\n             PlanCommit(runtime, sender, planStep, txId);\n         }\n         AFL_VERIFY(csDefaultControllerGuard->GetRequestTracingSnapshotsSave().Val() == 1);\n         AFL_VERIFY(csDefaultControllerGuard->GetRequestTracingSnapshotsRemove().Val() == 1);\n-\n+        csDefaultControllerGuard->SetOverrideMaxReadStaleness(TDuration::Zero());\n+        csDefaultControllerGuard->WaitCleaning(TDuration::Seconds(20), &runtime);\n         Cerr << \"Compactions happened: \" << csDefaultControllerGuard->GetCompactionStartedCounter().Val() << Endl;\n         Cerr << \"Indexations happened: \" << csDefaultControllerGuard->GetInsertStartedCounter().Val() << Endl;\n         Cerr << \"Cleanups happened: \" << csDefaultControllerGuard->GetCleaningStartedCounter().Val() << Endl;\ndiff --git a/ydb/core/tx/columnshard/ut_rw/ut_normalizer.cpp b/ydb/core/tx/columnshard/ut_rw/ut_normalizer.cpp\nindex 305778a5d0e3..731c578deea9 100644\n--- a/ydb/core/tx/columnshard/ut_rw/ut_normalizer.cpp\n+++ b/ydb/core/tx/columnshard/ut_rw/ut_normalizer.cpp\n@@ -259,7 +259,7 @@ Y_UNIT_TEST_SUITE(Normalizers) {\n         const std::vector<NArrow::NTest::TTestColumn> schema = { NArrow::NTest::TTestColumn(\"key1\", TTypeInfo(NTypeIds::Uint64)),\n             NArrow::NTest::TTestColumn(\"key2\", TTypeInfo(NTypeIds::Uint64)), NArrow::NTest::TTestColumn(\"field\", TTypeInfo(NTypeIds::Utf8)) };\n         const std::vector<ui32> columnsIds = { 1, 2, 3 };\n-        PrepareTablet(runtime, tableId, schema, 2);\n+        auto planStep = PrepareTablet(runtime, tableId, schema, 2);\n         const ui64 txId = 111;\n \n         NConstruction::IArrayBuilder::TPtr key1Column =\n@@ -272,17 +272,17 @@ Y_UNIT_TEST_SUITE(Normalizers) {\n         auto batch = NConstruction::TRecordBatchConstructor({ key1Column, key2Column, column }).BuildBatch(20048);\n         NTxUT::TShardWriter writer(runtime, TTestTxConfig::TxTablet0, tableId, 222);\n         AFL_VERIFY(writer.Write(batch, {1, 2, 3}, txId) == NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED);\n-        AFL_VERIFY(writer.StartCommit(txId) == NKikimrDataEvents::TEvWriteResult::STATUS_PREPARED);\n-        PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(11, txId));\n+        planStep = writer.StartCommit(txId);\n+        PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(planStep, txId));\n \n         {\n-            auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(11, txId), schema);\n+            auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(planStep, txId), schema);\n             UNIT_ASSERT_VALUES_EQUAL(readResult->num_rows(), 20048);\n         }\n         RebootTablet(runtime, TTestTxConfig::TxTablet0, writer.GetSender());\n \n         {\n-            auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(11, txId), schema);\n+            auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(planStep, txId), schema);\n             UNIT_ASSERT_VALUES_EQUAL(readResult->num_rows(), checker.RecordsCountAfterReboot(20048));\n         }\n     }\ndiff --git a/ydb/core/tx/columnshard/ut_schema/ut_columnshard_schema.cpp b/ydb/core/tx/columnshard/ut_schema/ut_columnshard_schema.cpp\nindex 663e8557de71..439e58fe36d1 100644\n--- a/ydb/core/tx/columnshard/ut_schema/ut_columnshard_schema.cpp\n+++ b/ydb/core/tx/columnshard/ut_schema/ut_columnshard_schema.cpp\n@@ -6,6 +6,7 @@\n #include <ydb/core/tx/tx_proxy/proxy.h>\n #include <ydb/core/tx/schemeshard/schemeshard.h>\n #include <ydb/core/tx/columnshard/test_helper/shard_reader.h>\n+#include <ydb/core/tx/columnshard/test_helper/test_combinator.h>\n #include <ydb/core/tx/columnshard/hooks/abstract/abstract.h>\n #include <ydb/core/tx/columnshard/hooks/testing/controller.h>\n #include <ydb/core/tx/columnshard/blobs_reader/actor.h>\n@@ -20,6 +21,7 @@\n #include <library/cpp/deprecated/atomic/atomic.h>\n #include <library/cpp/testing/hook/hook.h>\n \n+\n namespace NKikimr {\n \n using namespace NTxUT;\n@@ -168,23 +170,20 @@ static constexpr ui32 PORTION_ROWS = 80 * 1000;\n \n // ts[0] = 1600000000; // date -u --date='@1600000000' Sun Sep 13 12:26:40 UTC 2020\n // ts[1] = 1620000000; // date -u --date='@1620000000' Mon May  3 00:00:00 UTC 2021\n-void TestTtl(bool reboots, bool internal, TTestSchema::TTableSpecials spec = {},\n-             const std::vector<NArrow::NTest::TTestColumn>& ydbSchema = testYdbSchema)\n+void TestTtl(bool reboots, bool internal, bool useFirstPkColumnForTtl, NScheme::TTypeId ttlColumnTypeId)\n {\n     auto csControllerGuard = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<NOlap::TWaitCompactionController>();\n     csControllerGuard->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Compaction);\n     csControllerGuard->SetOverrideTasksActualizationLag(TDuration::Zero());\n     std::vector<ui64> ts = { 1600000000, 1620000000 };\n \n-    ui32 ttlIncSeconds = 1;\n-    for (auto& c : ydbSchema) {\n-        if (c.GetName() == spec.TtlColumn) {\n-            if (c.GetType().GetTypeId() == NTypeIds::Date) {\n-                ttlIncSeconds = TDuration::Days(1).Seconds();\n-            }\n-            break;\n-        }\n-    }\n+    auto ydbSchema = TTestSchema::YdbSchema();\n+    const auto ttlColumnNameIdx = useFirstPkColumnForTtl ? 0 : 8;\n+    const auto ttlColumnName = ydbSchema[ttlColumnNameIdx].GetName();\n+    UNIT_ASSERT(ttlColumnName == (useFirstPkColumnForTtl ? \"timestamp\" : \"saved_at\")); //to detect default schema changes\n+    ydbSchema[ttlColumnNameIdx].SetType(ttlColumnTypeId);\n+    const auto ttlIncSeconds = ttlColumnTypeId == NTypeIds::Date ? TDuration::Days(1).Seconds() : 1;\n+    TTestSchema::TTableSpecials specs;\n \n     TTestBasicRuntime runtime;\n     TTester::Setup(runtime);\n@@ -203,7 +202,6 @@ void TestTtl(bool reboots, bool internal, TTestSchema::TTableSpecials spec = {},\n \n     ui64 writeId = 0;\n     ui64 tableId = 1;\n-    ui64 planStep = 1000000000; // greater then delays\n     ui64 txId = 100;\n \n     UNIT_ASSERT(ts.size() == 2);\n@@ -214,15 +212,11 @@ void TestTtl(bool reboots, bool internal, TTestSchema::TTableSpecials spec = {},\n     } else {\n         ttlSec -= ts[0] + ttlIncSeconds;\n     }\n-    if (spec.HasTiers()) {\n-        spec.Tiers[0].EvictAfter = TDuration::Seconds(ttlSec);\n-    } else {\n-        UNIT_ASSERT(!spec.TtlColumn.empty());\n-        spec.EvictAfter = TDuration::Seconds(ttlSec);\n-    }\n-    SetupSchema(runtime, sender,\n-                              TTestSchema::CreateInitShardTxBody(tableId, ydbSchema, testYdbPk, spec, \"/Root/olapStore\"),\n-                              NOlap::TSnapshot(++planStep, ++txId));\n+    TTestSchema::TTableSpecials spec;\n+    spec.TtlColumn = ttlColumnName;\n+    spec.EvictAfter = TDuration::Seconds(ttlSec);\n+    auto planStep = SetupSchema(runtime, sender,\n+        TTestSchema::CreateInitShardTxBody(tableId, ydbSchema, testYdbPk, spec, \"/Root/olapStore\"), ++txId);\n     if (spec.HasTiers()) {\n         csControllerGuard->OverrideTierConfigs(runtime, sender, TTestSchema::BuildSnapshot(spec));\n     }\n@@ -234,8 +228,8 @@ void TestTtl(bool reboots, bool internal, TTestSchema::TTableSpecials spec = {},\n     for (auto& data : blobs) {\n         std::vector<ui64> writeIds;\n         UNIT_ASSERT(WriteData(runtime, sender, ++writeId, tableId, data, ydbSchema, true, &writeIds));\n-        ProposeCommit(runtime, sender, ++txId, writeIds);\n-        PlanCommit(runtime, sender, ++planStep, txId);\n+        planStep = ProposeCommit(runtime, sender, ++txId, writeIds);\n+        PlanCommit(runtime, sender, planStep, txId);\n     }\n \n     // TODO: write into path 2 (no ttl)\n@@ -270,9 +264,8 @@ void TestTtl(bool reboots, bool internal, TTestSchema::TTableSpecials spec = {},\n     } else {\n         spec.EvictAfter = TDuration::Seconds(ttlSec);\n     }\n-    SetupSchema(runtime, sender,\n-                         TTestSchema::AlterTableTxBody(tableId, 2, spec),\n-                         NOlap::TSnapshot(++planStep, ++txId));\n+    planStep = SetupSchema(runtime, sender,\n+                         TTestSchema::AlterTableTxBody(tableId, 2, spec), ++txId);\n     if (spec.HasTiers()) {\n         csControllerGuard->OverrideTierConfigs(runtime, sender, TTestSchema::BuildSnapshot(spec));\n     }\n@@ -294,10 +287,8 @@ void TestTtl(bool reboots, bool internal, TTestSchema::TTableSpecials spec = {},\n \n     // Disable TTL\n     lastTtlFinishedCount = csControllerGuard->GetTTLFinishedCounter().Val();\n-    auto ok = ProposeSchemaTx(runtime, sender,\n-                         TTestSchema::AlterTableTxBody(tableId, 3, TTestSchema::TTableSpecials()),\n-                         NOlap::TSnapshot(++planStep, ++txId));\n-    UNIT_ASSERT(ok);\n+    planStep = SetupSchema(runtime, sender,\n+                         TTestSchema::AlterTableTxBody(tableId, 3, TTestSchema::TTableSpecials()), ++txId);\n     if (spec.HasTiers()) {\n         csControllerGuard->OverrideTierConfigs(runtime, sender, TTestSchema::BuildSnapshot(TTestSchema::TTableSpecials()));\n     }\n@@ -306,8 +297,8 @@ void TestTtl(bool reboots, bool internal, TTestSchema::TTableSpecials spec = {},\n \n     std::vector<ui64> writeIds;\n     UNIT_ASSERT(WriteData(runtime, sender, ++writeId, tableId, blobs[0], ydbSchema, true, &writeIds));\n-    ProposeCommit(runtime, sender, ++txId, writeIds);\n-    PlanCommit(runtime, sender, ++planStep, txId);\n+    planStep  = ProposeCommit(runtime, sender, ++txId, writeIds);\n+    PlanCommit(runtime, sender, planStep, txId);\n \n     ForwardToTablet(runtime, TTestTxConfig::TxTablet0, sender, new TEvPrivate::TEvPeriodicWakeup(true));\n \n@@ -535,24 +526,14 @@ std::vector<std::pair<ui32, ui64>> TestTiers(bool reboots, const std::vector<TSt\n         runtime.GetAppData().Icb->SetValue(\"BlobCache.MaxCacheDataSize\", 0, unused);\n     }\n \n-    // Disable GC batching so that deleted blobs get collected without a delay\n-    {\n-        TAtomic unused;\n-        runtime.GetAppData().Icb->SetValue(\"ColumnShardControls.BlobCountToTriggerGC\", 1, unused);\n-    }\n-\n-    //\n-\n     ui64 writeId = 0;\n     ui64 tableId = 1;\n-    ui64 planStep = 1000000000; // greater then delays\n     ui64 txId = 100;\n //    const TDuration exportTimeout = TDuration::Seconds(40);\n \n     UNIT_ASSERT(specs.size() > 0);\n-    SetupSchema(runtime, sender,\n-            TTestSchema::CreateInitShardTxBody(tableId, testYdbSchema, testYdbPk, specs[0], \"/Root/olapStore\"),\n-            NOlap::TSnapshot(++planStep, ++txId));\n+    auto planStep = SetupSchema(runtime, sender,\n+            TTestSchema::CreateInitShardTxBody(tableId, testYdbSchema, testYdbPk, specs[0], \"/Root/olapStore\"), ++txId);\n     if (specs[0].Tiers.size()) {\n         csControllerGuard->OverrideTierConfigs(runtime, sender, TTestSchema::BuildSnapshot(specs[0]));\n     }\n@@ -560,8 +541,8 @@ std::vector<std::pair<ui32, ui64>> TestTiers(bool reboots, const std::vector<TSt\n     for (auto& data : blobs) {\n         std::vector<ui64> writeIds;\n         UNIT_ASSERT(WriteData(runtime, sender, ++writeId, tableId, data, testYdbSchema, true, &writeIds));\n-        ProposeCommit(runtime, sender, ++txId, writeIds);\n-        PlanCommit(runtime, sender, ++planStep, txId);\n+        planStep = ProposeCommit(runtime, sender, ++txId, writeIds);\n+        PlanCommit(runtime, sender, planStep, txId);\n     }\n \n     if (reboots) {\n@@ -602,9 +583,7 @@ std::vector<std::pair<ui32, ui64>> TestTiers(bool reboots, const std::vector<TSt\n         }\n         if (i) {\n             const ui32 version = 2 * i + 1;\n-            SetupSchema(runtime, sender,\n-                TTestSchema::AlterTableTxBody(tableId, version, specs[i]),\n-                NOlap::TSnapshot(++planStep, ++txId));\n+            planStep = SetupSchema(runtime, sender, TTestSchema::AlterTableTxBody(tableId, version, specs[i]), ++txId);\n         }\n         if (specs[i].HasTiers() || reboots) {\n             csControllerGuard->OverrideTierConfigs(runtime, sender, TTestSchema::BuildSnapshot(specs[i]));\n@@ -939,13 +918,10 @@ void TestDrop(bool reboots) {\n \n     ui64 writeId = 0;\n     ui64 tableId = 1;\n-    ui64 planStep = 1000000000; // greater then delays\n     ui64 txId = 100;\n \n-    SetupSchema(runtime, sender, TTestSchema::CreateTableTxBody(tableId, testYdbSchema, testYdbPk),\n-                              NOlap::TSnapshot(++planStep, ++txId));\n-    //\n-\n+    auto planStep = SetupSchema(runtime, sender,\n+        TTestSchema::CreateTableTxBody(tableId, testYdbSchema, testYdbPk), ++txId);\n     TString data1 = MakeTestBlob({0, PORTION_ROWS}, testYdbSchema);\n     UNIT_ASSERT(data1.size() > NColumnShard::TLimits::MIN_BYTES_TO_INSERT);\n     UNIT_ASSERT(data1.size() < 7 * 1024 * 1024);\n@@ -956,21 +932,21 @@ void TestDrop(bool reboots) {\n     // Write into index\n     std::vector<ui64> writeIds;\n     UNIT_ASSERT(WriteData(runtime, sender, ++writeId, tableId, data1, testYdbSchema, true, &writeIds));\n-    ProposeCommit(runtime, sender, ++txId, writeIds);\n-    PlanCommit(runtime, sender, ++planStep, txId);\n+    planStep = ProposeCommit(runtime, sender, ++txId, writeIds);\n+    PlanCommit(runtime, sender, planStep, txId);\n \n     // Write into InsertTable\n     writeIds.clear();\n     UNIT_ASSERT(WriteData(runtime, sender, ++writeId, tableId, data2, testYdbSchema, true, &writeIds));\n-    ProposeCommit(runtime, sender, ++txId, writeIds);\n-    PlanCommit(runtime, sender, ++planStep, txId);\n+    planStep = ProposeCommit(runtime, sender, ++txId, writeIds);\n+    PlanCommit(runtime, sender, planStep, txId);\n \n     if (reboots) {\n         RebootTablet(runtime, TTestTxConfig::TxTablet0, sender);\n     }\n \n     // Drop table\n-    SetupSchema(runtime, sender, TTestSchema::DropTableTxBody(tableId, 2), NOlap::TSnapshot(++planStep, ++txId));\n+    planStep = SetupSchema(runtime, sender, TTestSchema::DropTableTxBody(tableId, 2), ++txId);\n \n     if (reboots) {\n         RebootTablet(runtime, TTestTxConfig::TxTablet0, sender);\n@@ -978,7 +954,6 @@ void TestDrop(bool reboots) {\n \n     TAutoPtr<IEventHandle> handle;\n     {\n-        --planStep;\n         TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));\n         reader.SetReplyColumnIds(TTestSchema::GetColumnIds(TTestSchema::YdbSchema(), { TTestSchema::DefaultTtlColumn }));\n         auto rb = reader.ReadAll();\n@@ -1004,32 +979,29 @@ void TestDropWriteRace() {\n     //\n \n     ui64 tableId = 1;\n-    ui64 planStep = 1000000000; // greater then delays\n     ui64 txId = 100;\n     ui32 writeId = 0;\n \n     NLongTxService::TLongTxId longTxId;\n     UNIT_ASSERT(longTxId.ParseString(\"ydb://long-tx/01ezvvxjdk2hd4vdgjs68knvp8?node_id=1\"));\n \n-    SetupSchema(runtime, sender, TTestSchema::CreateTableTxBody(tableId, testYdbSchema, testYdbPk),\n-                              NOlap::TSnapshot(++planStep, ++txId));\n+    auto planStep = SetupSchema(runtime, sender,\n+        TTestSchema::CreateTableTxBody(tableId, testYdbSchema, testYdbPk), ++txId);\n     TString data = MakeTestBlob({0, 100}, testYdbSchema);\n     UNIT_ASSERT(data.size() < NColumnShard::TLimits::MIN_BYTES_TO_INSERT);\n \n     // Write into InsertTable\n     ++txId;\n     AFL_VERIFY(WriteData(runtime, sender, ++writeId, tableId, data, testYdbSchema));\n-    ProposeCommit(runtime, sender, txId, { writeId });\n-    auto commitTxId = txId;\n+    planStep = ProposeCommit(runtime, sender, txId, { writeId });\n+    const auto commitTxId = txId;\n \n     // Drop table\n-    auto ok = ProposeSchemaTx(runtime, sender, TTestSchema::DropTableTxBody(tableId, 2), NOlap::TSnapshot(++planStep, ++txId));\n-    if (ok) {\n-        PlanSchemaTx(runtime, sender, NOlap::TSnapshot(planStep, txId));\n-    }\n+    planStep = ProposeSchemaTx(runtime, sender, TTestSchema::DropTableTxBody(tableId, 2), ++txId);\n+    PlanSchemaTx(runtime, sender, NOlap::TSnapshot(planStep, txId));\n \n     // Plan commit\n-    PlanCommit(runtime, sender, ++planStep, commitTxId);\n+    PlanCommit(runtime, sender, planStep + 1, commitTxId);\n }\n \n void TestCompaction(std::optional<ui32> numWrites = {}) {\n@@ -1049,11 +1021,10 @@ void TestCompaction(std::optional<ui32> numWrites = {}) {\n     // Create table\n     ui64 writeId = 0;\n     ui64 tableId = 1;\n-    ui64 planStep = 100;\n     ui64 txId = 100;\n \n-    SetupSchema(runtime, sender, TTestSchema::CreateTableTxBody(tableId, testYdbSchema, testYdbPk),\n-                              NOlap::TSnapshot(++planStep, ++txId));\n+    auto planStep = SetupSchema(runtime, sender,\n+        TTestSchema::CreateTableTxBody(tableId, testYdbSchema, testYdbPk), ++txId);\n     // Set tiering\n \n     ui64 ts = 1620000000;\n@@ -1069,8 +1040,8 @@ void TestCompaction(std::optional<ui32> numWrites = {}) {\n     spec.Tiers.back().EvictAfter = allow;\n     spec.Tiers.back().S3 = TTestSchema::TStorageTier::FakeS3();\n \n-    SetupSchema(runtime, sender, TTestSchema::AlterTableTxBody(tableId, 1, spec),\n-                            NOlap::TSnapshot(++planStep, ++txId));\n+    planStep = SetupSchema(runtime, sender, TTestSchema::AlterTableTxBody(tableId, 1, spec),\n+                           ++txId);\n     csControllerGuard->OverrideTierConfigs(runtime, sender, TTestSchema::BuildSnapshot(spec));\n \n     // Writes\n@@ -1084,13 +1055,12 @@ void TestCompaction(std::optional<ui32> numWrites = {}) {\n         numWrites = NOlap::TCompactionLimits().GranuleOverloadSize / triggerData.size();\n     }\n \n-    ++planStep;\n     ++txId;\n-    for (ui32 i = 0; i < *numWrites; ++i, ++writeId, ++planStep, ++txId) {\n+    for (ui32 i = 0; i < *numWrites; ++i, ++writeId, ++txId) {\n         std::vector<ui64> writeIds;\n         UNIT_ASSERT(WriteData(runtime, sender, writeId, tableId, triggerData, testYdbSchema, true, &writeIds));\n \n-        ProposeCommit(runtime, sender, txId, writeIds);\n+        planStep = ProposeCommit(runtime, sender, txId, writeIds);\n         PlanCommit(runtime, sender, planStep, txId);\n \n     }\n@@ -1141,7 +1111,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestSchema) {\n         auto schema = TTestSchema::YdbSchema(NArrow::NTest::TTestColumn(\"k0\", TTypeInfo(NTypeIds::Timestamp)));\n         auto pk = NArrow::NTest::TTestColumn::CropSchema(schema, 4);\n \n-        ui64 planStep = 1000;\n+        TPlanStep planStep;\n         ui64 txId = 100;\n         ui64 generation = 0;\n \n@@ -1149,7 +1119,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestSchema) {\n             schema[0].SetType(TTypeInfo(ydbType));\n             pk[0].SetType(TTypeInfo(ydbType));\n             auto txBody = TTestSchema::CreateTableTxBody(tableId++, schema, pk, {}, ++generation);\n-            SetupSchema(runtime, sender, txBody, NOlap::TSnapshot(planStep++, txId++));\n+            planStep = SetupSchema(runtime, sender, txBody, txId++);\n         }\n \n         // TODO: support float types\n@@ -1162,7 +1132,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestSchema) {\n             schema[0].SetType(TTypeInfo(ydbType));\n             pk[0].SetType(TTypeInfo(ydbType));\n             auto txBody = TTestSchema::CreateTableTxBody(tableId++, schema, pk, {}, ++generation);\n-            SetupSchema(runtime, sender, txBody, NOlap::TSnapshot(planStep++, txId++), false);\n+            ProposeSchemaTxFail(runtime, sender, txBody, txId++);\n         }\n \n         std::vector<TTypeId> strTypes = {\n@@ -1174,7 +1144,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestSchema) {\n             schema[0].SetType(TTypeInfo(ydbType));\n             pk[0].SetType(TTypeInfo(ydbType));\n             auto txBody = TTestSchema::CreateTableTxBody(tableId++, schema, pk, {}, ++generation);\n-            SetupSchema(runtime, sender, txBody, NOlap::TSnapshot(planStep++, txId++));\n+            planStep = SetupSchema(runtime, sender, txBody, txId++);\n         }\n \n         std::vector<TTypeId> xsonTypes = {\n@@ -1187,83 +1157,18 @@ Y_UNIT_TEST_SUITE(TColumnShardTestSchema) {\n             schema[0].SetType(TTypeInfo(ydbType));\n             pk[0].SetType(TTypeInfo(ydbType));\n             auto txBody = TTestSchema::CreateTableTxBody(tableId++, schema, pk, {}, ++generation);\n-            SetupSchema(runtime, sender, txBody, NOlap::TSnapshot(planStep++, txId++), false);\n+            ProposeSchemaTxFail(runtime, sender, txBody, txId++);\n         }\n     }\n \n-    Y_UNIT_TEST(ExternalTTL) {\n-        TestTtl(false, false); // over NTypeIds::Timestamp ttl column\n-    }\n-\n-    Y_UNIT_TEST(ExternalTTL_Types) {\n-        auto ydbSchema = testYdbSchema;\n-        for (auto typeId : {NTypeIds::Datetime, NTypeIds::Date, NTypeIds::Uint32, NTypeIds::Uint64}) {\n-            UNIT_ASSERT_EQUAL(ydbSchema[8].GetName(), \"saved_at\");\n-            ydbSchema[8].SetType(TTypeInfo(typeId));\n-\n-            TTestSchema::TTableSpecials specs;\n-            specs.SetTtlColumn(\"saved_at\");\n-\n-            TestTtl(false, false, specs, ydbSchema);\n+    Y_UNIT_TEST_OCTO(TTL, Reboot, Internal, FirstPkColumn) {\n+        for (auto typeId : {NTypeIds::Timestamp, NTypeIds::Datetime, NTypeIds::Date, NTypeIds::Uint32, NTypeIds::Uint64}) {\n+            TestTtl(Reboot, Internal, FirstPkColumn, typeId);\n         }\n     }\n \n-    Y_UNIT_TEST(RebootExternalTTL) {\n-        NColumnShard::gAllowLogBatchingDefaultValue = false;\n-        TestTtl(true, false);\n-    }\n-\n-    Y_UNIT_TEST(InternalTTL) {\n-        TestTtl(false, true); // over NTypeIds::Timestamp ttl column\n-    }\n-\n-    Y_UNIT_TEST(InternalTTL_Types) {\n-        auto ydbSchema = testYdbSchema;\n-        for (auto typeId : {NTypeIds::Datetime, NTypeIds::Date, NTypeIds::Uint32, NTypeIds::Uint64}) {\n-            UNIT_ASSERT_EQUAL(ydbSchema[8].GetName(), \"saved_at\");\n-            ydbSchema[8].SetType(TTypeInfo(typeId));\n-\n-            TTestSchema::TTableSpecials specs;\n-            specs.SetTtlColumn(\"saved_at\");\n \n-            TestTtl(false, true, specs, ydbSchema);\n-        }\n-    }\n \n-    Y_UNIT_TEST(RebootInternalTTL) {\n-        NColumnShard::gAllowLogBatchingDefaultValue = false;\n-        TestTtl(true, true);\n-    }\n-\n-    Y_UNIT_TEST(OneTier) {\n-        TTestSchema::TTableSpecials specs;\n-        specs.SetTtlColumn(\"timestamp\");\n-//        specs.Tiers.emplace_back(TTestSchema::TStorageTier(\"default\").SetTtlColumn(\"timestamp\"));\n-        TestTtl(false, true, specs);\n-    }\n-\n-    Y_UNIT_TEST(RebootOneTier) {\n-        NColumnShard::gAllowLogBatchingDefaultValue = false;\n-        TTestSchema::TTableSpecials specs;\n-        specs.SetTtlColumn(\"timestamp\");\n-//        specs.Tiers.emplace_back(TTestSchema::TStorageTier(\"default\").SetTtlColumn(\"timestamp\"));\n-        TestTtl(true, true, specs);\n-    }\n-\n-    Y_UNIT_TEST(OneTierExternalTtl) {\n-        TTestSchema::TTableSpecials specs;\n-        specs.SetTtlColumn(\"timestamp\");\n-//        specs.Tiers.emplace_back(TTestSchema::TStorageTier(\"default\").SetTtlColumn(\"timestamp\"));\n-        TestTtl(false, false, specs);\n-    }\n-\n-    Y_UNIT_TEST(RebootOneTierExternalTtl) {\n-        NColumnShard::gAllowLogBatchingDefaultValue = false;\n-        TTestSchema::TTableSpecials specs;\n-        specs.SetTtlColumn(\"timestamp\");\n-//        specs.Tiers.emplace_back(TTestSchema::TStorageTier(\"default\").SetTtlColumn(\"timestamp\"));\n-        TestTtl(true, false, specs);\n-    }\n \n     // TODO: EnableOneTierAfterTtl, EnableTtlAfterOneTier\n \ndiff --git a/ydb/core/tx/conveyor/service/service.cpp b/ydb/core/tx/conveyor/service/service.cpp\nindex 295745c4e603..3f93fed0dc19 100644\n--- a/ydb/core/tx/conveyor/service/service.cpp\n+++ b/ydb/core/tx/conveyor/service/service.cpp\n@@ -36,9 +36,10 @@ void TDistributor::HandleMain(TEvInternal::TEvTaskProcessedResult::TPtr& evExt)\n         (\"queue\", ProcessesOrdered.size())(\"workers\", Workers.size())(\"count\", ev->GetProcessIds().size())(\"d\", ev->GetInstants().back() - ev->GetInstants().front());\n     for (ui32 idx = 0; idx < ev->GetProcessIds().size(); ++idx) {\n         AddCPUTime(ev->GetProcessIds()[idx], ev->GetInstants()[idx + 1] - std::max(LastAddProcessInstant, ev->GetInstants()[idx]));\n+        Counters.TaskExecuteHistogram->Collect((ev->GetInstants()[idx + 1] - ev->GetInstants()[idx]).MicroSeconds());\n     }\n     const TDuration dExecution = ev->GetInstants().back() - ev->GetInstants().front();\n-    Counters.ExecuteHistogram->Collect(dExecution.MicroSeconds());\n+    Counters.PackExecuteHistogram->Collect(dExecution.MicroSeconds());\n     Counters.ExecuteDuration->Add(dExecution.MicroSeconds());\n \n     const TMonotonic now = TMonotonic::Now();\ndiff --git a/ydb/core/tx/conveyor/service/service.h b/ydb/core/tx/conveyor/service/service.h\nindex e42ae5ec0056..b3af6ea71d5a 100644\n--- a/ydb/core/tx/conveyor/service/service.h\n+++ b/ydb/core/tx/conveyor/service/service.h\n@@ -2,7 +2,7 @@\n #include \"worker.h\"\n #include <ydb/core/tx/conveyor/usage/config.h>\n #include <ydb/core/tx/conveyor/usage/events.h>\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n #include <ydb/library/accessor/positive_integer.h>\n #include <ydb/library/actors/core/actor_bootstrapped.h>\n #include <ydb/library/actors/core/log.h>\n@@ -35,7 +35,8 @@ class TCounters: public NColumnShard::TCommonCountersOwner {\n \n     const ::NMonitoring::THistogramPtr WaitingHistogram;\n     const ::NMonitoring::THistogramPtr PackHistogram;\n-    const ::NMonitoring::THistogramPtr ExecuteHistogram;\n+    const ::NMonitoring::THistogramPtr PackExecuteHistogram;\n+    const ::NMonitoring::THistogramPtr TaskExecuteHistogram;\n     const ::NMonitoring::THistogramPtr SendBackHistogram;\n     const ::NMonitoring::THistogramPtr SendFwdHistogram;\n     const ::NMonitoring::THistogramPtr ReceiveTaskHistogram;\n@@ -58,7 +59,8 @@ class TCounters: public NColumnShard::TCommonCountersOwner {\n         , UseWorkerRate(TBase::GetDeriviative(\"UseWorker\"))\n         , WaitingHistogram(TBase::GetHistogram(\"Waiting/Duration/Us\", NMonitoring::ExponentialHistogram(25, 2, 50)))\n         , PackHistogram(TBase::GetHistogram(\"ExecutionPack/Count\", NMonitoring::LinearHistogram(25, 1, 1)))\n-        , ExecuteHistogram(TBase::GetHistogram(\"Execute/Duration/Us\", NMonitoring::ExponentialHistogram(25, 2, 50)))\n+        , PackExecuteHistogram(TBase::GetHistogram(\"PackExecute/Duration/Us\", NMonitoring::ExponentialHistogram(25, 2, 50)))\n+        , TaskExecuteHistogram(TBase::GetHistogram(\"TaskExecute/Duration/Us\", NMonitoring::ExponentialHistogram(25, 2, 50)))\n         , SendBackHistogram(TBase::GetHistogram(\"SendBack/Duration/Us\", NMonitoring::ExponentialHistogram(25, 2, 50)))\n         , SendFwdHistogram(TBase::GetHistogram(\"SendForward/Duration/Us\", NMonitoring::ExponentialHistogram(25, 2, 50)))\n         , ReceiveTaskHistogram(TBase::GetHistogram(\"ReceiveTask/Duration/Us\", NMonitoring::ExponentialHistogram(25, 2, 50)))\ndiff --git a/ydb/core/tx/conveyor/service/worker.cpp b/ydb/core/tx/conveyor/service/worker.cpp\nindex 6450725f15f3..a9e68d7b9359 100644\n--- a/ydb/core/tx/conveyor/service/worker.cpp\n+++ b/ydb/core/tx/conveyor/service/worker.cpp\n@@ -8,7 +8,7 @@ void TWorker::ExecuteTask(std::vector<TWorkerTask>&& workerTasks) {\n     std::vector<ui64> processes;\n     instants.emplace_back(TMonotonic::Now());\n     for (auto&& t : workerTasks) {\n-        Y_UNUSED(t.GetTask()->Execute(t.GetTaskSignals(), t.GetTask()));\n+        t.GetTask()->Execute(t.GetTaskSignals(), t.GetTask());\n         instants.emplace_back(TMonotonic::Now());\n         processes.emplace_back(t.GetProcessId());\n     }\ndiff --git a/ydb/core/tx/conveyor/usage/abstract.cpp b/ydb/core/tx/conveyor/usage/abstract.cpp\nindex 55c19e7bba87..2c670d5a0227 100644\n--- a/ydb/core/tx/conveyor/usage/abstract.cpp\n+++ b/ydb/core/tx/conveyor/usage/abstract.cpp\n@@ -8,30 +8,22 @@\n #include <util/string/builder.h>\n \n namespace NKikimr::NConveyor {\n-TConclusionStatus ITask::Execute(std::shared_ptr<TTaskSignals> signals, const std::shared_ptr<ITask>& taskPtr) {\n+void ITask::Execute(std::shared_ptr<TTaskSignals> signals, const std::shared_ptr<ITask>& taskPtr) {\n     AFL_VERIFY(!ExecutedFlag);\n     ExecutedFlag = true;\n     const TMonotonic start = TMonotonic::Now();\n     try {\n-        TConclusionStatus result = DoExecute(taskPtr);\n-        if (result.IsFail()) {\n-            if (signals) {\n-                signals->Fails->Add(1);\n-                signals->FailsDuration->Add((TMonotonic::Now() - start).MicroSeconds());\n-            }\n-        } else {\n-            if (signals) {\n-                signals->Success->Add(1);\n-                signals->SuccessDuration->Add((TMonotonic::Now() - start).MicroSeconds());\n-            }\n+        DoExecute(taskPtr);\n+        if (signals) {\n+            signals->Success->Add(1);\n+            signals->SuccessDuration->Add((TMonotonic::Now() - start).MicroSeconds());\n         }\n-        return result;\n     } catch (...) {\n         if (signals) {\n             signals->Fails->Add(1);\n             signals->FailsDuration->Add((TMonotonic::Now() - start).MicroSeconds());\n         }\n-        return TConclusionStatus::Fail(\"exception: \" + CurrentExceptionMessage());\n+        AFL_ERROR(NKikimrServices::TX_CONVEYOR)(\"event\", \"exception_on_execute\")(\"message\", CurrentExceptionMessage());\n     }\n }\n \ndiff --git a/ydb/core/tx/conveyor/usage/abstract.h b/ydb/core/tx/conveyor/usage/abstract.h\nindex d66e203274bb..909136d42639 100644\n--- a/ydb/core/tx/conveyor/usage/abstract.h\n+++ b/ydb/core/tx/conveyor/usage/abstract.h\n@@ -1,6 +1,6 @@\n #pragma once\n #include <memory>\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n \n #include <ydb/library/accessor/accessor.h>\n #include <ydb/library/actors/core/actorid.h>\n@@ -65,7 +65,7 @@ class ITask {\n     YDB_ACCESSOR(EPriority, Priority, EPriority::Normal);\n     bool ExecutedFlag = false;\n protected:\n-    virtual TConclusionStatus DoExecute(const std::shared_ptr<ITask>& taskPtr) = 0;\n+    virtual void DoExecute(const std::shared_ptr<ITask>& taskPtr) = 0;\n     virtual void DoOnCannotExecute(const TString& reason);\n public:\n     using TPtr = std::shared_ptr<ITask>;\n@@ -76,7 +76,7 @@ class ITask {\n     void OnCannotExecute(const TString& reason) {\n         return DoOnCannotExecute(reason);\n     }\n-    TConclusionStatus Execute(std::shared_ptr<TTaskSignals> signals, const std::shared_ptr<ITask>& taskPtr);\n+    void Execute(std::shared_ptr<TTaskSignals> signals, const std::shared_ptr<ITask>& taskPtr);\n };\n \n }\ndiff --git a/ydb/core/tx/data_events/common/error_codes.cpp b/ydb/core/tx/data_events/common/error_codes.cpp\nindex 2c86d4b52152..06cc5703d0f3 100644\n--- a/ydb/core/tx/data_events/common/error_codes.cpp\n+++ b/ydb/core/tx/data_events/common/error_codes.cpp\n@@ -13,6 +13,8 @@ TConclusion<NErrorCodes::TOperator::TYdbStatusInfo> TOperator::GetStatusInfo(\n             return TYdbStatusInfo(Ydb::StatusIds::ABORTED, NYql::TIssuesIds::KIKIMR_OPERATION_ABORTED, \"Request aborted\");\n         case NKikimrDataEvents::TEvWriteResult::STATUS_DISK_SPACE_EXHAUSTED:\n             return TYdbStatusInfo(Ydb::StatusIds::INTERNAL_ERROR, NYql::TIssuesIds::KIKIMR_DISK_SPACE_EXHAUSTED, \"Disk space exhausted\");\n+        case NKikimrDataEvents::TEvWriteResult::STATUS_OUT_OF_SPACE:\n+            return TYdbStatusInfo(Ydb::StatusIds::OVERLOADED, NYql::TIssuesIds::KIKIMR_OVERLOADED, \"Out of space\");\n         case NKikimrDataEvents::TEvWriteResult::STATUS_INTERNAL_ERROR:\n             return TYdbStatusInfo(Ydb::StatusIds::INTERNAL_ERROR, NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR, \"Request aborted\");\n         case NKikimrDataEvents::TEvWriteResult::STATUS_OVERLOADED:\n@@ -29,8 +31,8 @@ TConclusion<NErrorCodes::TOperator::TYdbStatusInfo> TOperator::GetStatusInfo(\n         case NKikimrDataEvents::TEvWriteResult::STATUS_WRONG_SHARD_STATE:\n             return TYdbStatusInfo(Ydb::StatusIds::PRECONDITION_FAILED, NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED, \"Wrong shard state\");\n         case NKikimrDataEvents::TEvWriteResult::STATUS_CONSTRAINT_VIOLATION:\n-            return TYdbStatusInfo(Ydb::StatusIds::PRECONDITION_FAILED, NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED, \"Constraint violated\");\n+            return TYdbStatusInfo(Ydb::StatusIds::PRECONDITION_FAILED, NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, \"Constraint violated\");\n     }\n }\n \n-}\n\\ No newline at end of file\n+}\ndiff --git a/ydb/core/tx/data_events/common/signals_flow.cpp b/ydb/core/tx/data_events/common/signals_flow.cpp\nindex cbe1839dcd4f..d043c9c4a98c 100644\n--- a/ydb/core/tx/data_events/common/signals_flow.cpp\n+++ b/ydb/core/tx/data_events/common/signals_flow.cpp\n@@ -18,7 +18,7 @@ TWriteFlowCounters::TWriteFlowCounters()\n         for (auto&& to : GetEnumAllValues<EWriteStage>()) {\n             auto subTo = sub.CreateSubGroup(\"stage_to\", ::ToString(to));\n             CountByStageMoving.back().emplace_back(subTo.GetDeriviative(\"Transfers/Count\"));\n-            CountByStageDuration.back().emplace_back(subTo.GetDeriviative(\"Transfers/Count\"));\n+            CountByStageDuration.back().emplace_back(subTo.GetDeriviative(\"Transfers/Duration/Ms\"));\n         }\n     }\n }\ndiff --git a/ydb/core/tx/data_events/common/signals_flow.h b/ydb/core/tx/data_events/common/signals_flow.h\nindex 4cd74a3c5f3a..fcf6b9426819 100644\n--- a/ydb/core/tx/data_events/common/signals_flow.h\n+++ b/ydb/core/tx/data_events/common/signals_flow.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n \n namespace NKikimr::NEvWrite {\n \n@@ -13,7 +13,8 @@ enum class EWriteStage {\n     BuildSlicesPack,\n     Result,\n     Finished,\n-    Aborted\n+    Aborted,\n+    Replied\n };\n \n class TWriteFlowCounters: public NColumnShard::TCommonCountersOwner {\ndiff --git a/ydb/core/tx/data_events/events.h b/ydb/core/tx/data_events/events.h\nindex 87279ec784f0..eeff29d2bf77 100644\n--- a/ydb/core/tx/data_events/events.h\n+++ b/ydb/core/tx/data_events/events.h\n@@ -2,14 +2,18 @@\n \n #include <library/cpp/lwtrace/shuttle.h>\n \n-#include <ydb/core/scheme/scheme_tabledefs.h>\n-#include <ydb/core/protos/data_events.pb.h>\n #include <ydb/core/base/events.h>\n+#include <ydb/core/protos/data_events.pb.h>\n+#include <ydb/core/scheme/scheme_tabledefs.h>\n+#include <ydb/core/tx/data_events/common/error_codes.h>\n #include <ydb/public/api/protos/ydb_issue_message.pb.h>\n \n #include <ydb/library/accessor/accessor.h>\n #include <ydb/library/actors/core/event_pb.h>\n #include <ydb/library/actors/core/log.h>\n+#include <yql/essentials/core/issue/yql_issue.h>\n+\n+#include <yql/essentials/public/issue/yql_issue_message.h>\n \n namespace NKikimr::NEvents {\n \n@@ -100,8 +104,11 @@ struct TDataEvents {\n             result->Record.SetOrigin(origin);\n             result->Record.SetTxId(txId);\n             result->Record.SetStatus(status);\n-            auto issue = result->Record.AddIssues();\n-            issue->set_message(errorMsg);\n+            NYql::TIssue issue(errorMsg);\n+            if (const auto statusConclusion = NKikimr::NEvWrite::NErrorCodes::TOperator::GetStatusInfo(status); statusConclusion.IsSuccess()) {\n+                NYql::SetIssueCode(statusConclusion->GetIssueCode(), issue);\n+            }\n+            NYql::IssueToMessage(issue, result->Record.AddIssues());\n             return result;\n         }\n \ndiff --git a/ydb/core/tx/data_events/shard_writer.cpp b/ydb/core/tx/data_events/shard_writer.cpp\nindex d4d38101e6be..1ce27af0d670 100644\n--- a/ydb/core/tx/data_events/shard_writer.cpp\n+++ b/ydb/core/tx/data_events/shard_writer.cpp\n@@ -29,12 +29,10 @@ namespace NKikimr::NEvWrite {\n     void TWritersController::OnFail(const Ydb::StatusIds::StatusCode code, const TString& message) {\n         Counters->OnCSFailed(code);\n         FailsCount.Inc();\n-        if (!Code) {\n-            TGuard<TMutex> g(Mutex);\n-            if (!Code) {\n-                Issues.AddIssue(message);\n-                Code = code;\n-            }\n+        if (AtomicCas(&HasCodeFail, 1, 0)) {\n+            AFL_VERIFY(!Code);\n+            Issues.AddIssue(message);\n+            Code = code;\n         }\n         if (!WritesCount.Dec()) {\n             SendReply();\ndiff --git a/ydb/core/tx/data_events/shard_writer.h b/ydb/core/tx/data_events/shard_writer.h\nindex b3c53d3d36d7..595d61e7c5e2 100644\n--- a/ydb/core/tx/data_events/shard_writer.h\n+++ b/ydb/core/tx/data_events/shard_writer.h\n@@ -6,7 +6,7 @@\n #include \"common/modification_type.h\"\n \n #include <ydb/core/base/tablet_pipecache.h>\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n #include <ydb/core/tx/long_tx_service/public/events.h>\n \n #include <ydb/library/accessor/accessor.h>\n@@ -105,9 +105,11 @@ class TWritersController {\n     TAtomicCounter WritesCount = 0;\n     TAtomicCounter WritesIndex = 0;\n     TAtomicCounter FailsCount = 0;\n-    TMutex Mutex;\n+\n+    TAtomic HasCodeFail = 0;\n     NYql::TIssues Issues;\n     std::optional<Ydb::StatusIds::StatusCode> Code;\n+\n     NActors::TActorIdentity LongTxActorId;\n     std::vector<TWriteIdForShard> WriteIds;\n     const TMonotonic StartInstant = TMonotonic::Now();\ndiff --git a/ydb/core/tx/data_events/write_data.cpp b/ydb/core/tx/data_events/write_data.cpp\nindex 4e05aeccea73..f3779a1cb5af 100644\n--- a/ydb/core/tx/data_events/write_data.cpp\n+++ b/ydb/core/tx/data_events/write_data.cpp\n@@ -21,10 +21,13 @@ TWriteData::TWriteData(const std::shared_ptr<TWriteMeta>& writeMeta, IDataContai\n }\n \n void TWriteMeta::OnStage(const EWriteStage stage) const {\n-    AFL_VERIFY(CurrentStage != EWriteStage::Finished && CurrentStage != EWriteStage::Aborted);\n+    if (stage == CurrentStage) {\n+        return;\n+    }\n     AFL_VERIFY((ui32)stage > (ui32)CurrentStage)(\"from\", CurrentStage)(\"to\", stage);\n     const TMonotonic nextStageInstant = TMonotonic::Now();\n     Counters->OnStageMove(CurrentStage, stage, nextStageInstant - LastStageInstant);\n+    CurrentStage = stage;\n     LastStageInstant = nextStageInstant;\n     if (stage == EWriteStage::Finished) {\n         Counters->OnWriteFinished(nextStageInstant - WriteStartInstant);\ndiff --git a/ydb/core/tx/data_events/write_data.h b/ydb/core/tx/data_events/write_data.h\nindex 56407661b1ce..33af6e744eb1 100644\n--- a/ydb/core/tx/data_events/write_data.h\n+++ b/ydb/core/tx/data_events/write_data.h\n@@ -4,7 +4,7 @@\n \n #include <ydb/core/formats/arrow/arrow_helpers.h>\n #include <ydb/core/formats/arrow/reader/position.h>\n-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>\n+#include <ydb/library/signals/object_counter.h>\n #include <ydb/core/tx/long_tx_service/public/types.h>\n \n #include <ydb/library/accessor/accessor.h>\n@@ -58,8 +58,8 @@ class TWriteMeta: public NColumnShard::TMonitoringObjectsCounter<TWriteMeta>, TN\n     void OnStage(const EWriteStage stage) const;\n \n     ~TWriteMeta() {\n-        if (CurrentStage != EWriteStage::Finished && CurrentStage != EWriteStage::Aborted) {\n-            Counters->OnWriteAborted(TMonotonic::Now() - WriteStartInstant);\n+        if (CurrentStage != EWriteStage::Replied) {\n+            OnStage(EWriteStage::Aborted);\n         }\n     }\n \ndiff --git a/ydb/core/tx/datashard/check_write_unit.cpp b/ydb/core/tx/datashard/check_write_unit.cpp\nindex 303d136b4ff9..6cf2b2b02938 100644\n--- a/ydb/core/tx/datashard/check_write_unit.cpp\n+++ b/ydb/core/tx/datashard/check_write_unit.cpp\n@@ -65,7 +65,7 @@ EExecutionStatus TCheckWriteUnit::Execute(TOperation::TPtr op,\n \n         DataShard.IncCounter(COUNTER_WRITE_OUT_OF_SPACE);\n \n-        writeOp->SetError(NKikimrDataEvents::TEvWriteResult::STATUS_OVERLOADED, err);\n+        writeOp->SetError(NKikimrDataEvents::TEvWriteResult::STATUS_OUT_OF_SPACE, err);\n         op->Abort(EExecutionUnitKind::FinishProposeWrite);\n \n         DataShard.SetOverloadSubscribed(writeOp->GetWriteTx()->GetOverloadSubscribe(), writeOp->GetRecipient(), op->GetTarget(), ERejectReasons::YellowChannels, writeOp->GetWriteResult()->Record);\n@@ -115,7 +115,7 @@ EExecutionStatus TCheckWriteUnit::Execute(TOperation::TPtr op,\n         if (!Pipeline.AssignPlanInterval(op)) {\n             TString err = TStringBuilder() << \"Can't propose tx \" << op->GetTxId() << \" at blocked shard \" << DataShard.TabletID();\n \n-            writeOp->SetError(NKikimrDataEvents::TEvWriteResult::STATUS_INTERNAL_ERROR, err);\n+            writeOp->SetError(NKikimrDataEvents::TEvWriteResult::STATUS_OVERLOADED, err);\n             op->Abort(EExecutionUnitKind::FinishProposeWrite);\n \n             LOG_NOTICE_S(ctx, NKikimrServices::TX_DATASHARD, err);\ndiff --git a/ydb/core/tx/datashard/datashard.h b/ydb/core/tx/datashard/datashard.h\nindex 37143a514cf2..1f2b0973d245 100644\n--- a/ydb/core/tx/datashard/datashard.h\n+++ b/ydb/core/tx/datashard/datashard.h\n@@ -349,6 +349,9 @@ namespace TEvDataShard {\n         EvForceDataCleanup,\n         EvForceDataCleanupResult,\n \n+        EvPrefixKMeansRequest,\n+        EvPrefixKMeansResponse,\n+\n         EvEnd\n     };\n \n@@ -1514,6 +1517,18 @@ namespace TEvDataShard {\n                           TEvDataShard::EvLocalKMeansResponse> {\n     };\n \n+    struct TEvPrefixKMeansRequest\n+        : public TEventPB<TEvPrefixKMeansRequest,\n+                          NKikimrTxDataShard::TEvPrefixKMeansRequest,\n+                          TEvDataShard::EvPrefixKMeansRequest> {\n+    };\n+\n+    struct TEvPrefixKMeansResponse\n+        : public TEventPB<TEvPrefixKMeansResponse,\n+                          NKikimrTxDataShard::TEvPrefixKMeansResponse,\n+                          TEvDataShard::EvPrefixKMeansResponse> {\n+    };\n+\n     struct TEvKqpScan\n         : public TEventPB<TEvKqpScan,\n                           NKikimrTxDataShard::TEvKqpScan,\ndiff --git a/ydb/core/tx/datashard/datashard__read_iterator.cpp b/ydb/core/tx/datashard/datashard__read_iterator.cpp\nindex 263caa364af0..a85007280560 100644\n--- a/ydb/core/tx/datashard/datashard__read_iterator.cpp\n+++ b/ydb/core/tx/datashard/datashard__read_iterator.cpp\n@@ -2326,7 +2326,7 @@ class TDataShard::TReadOperation : public TOperation, public IReadOperation {\n             sysLocks.BreakSetLocks();\n         }\n \n-        auto locks = sysLocks.ApplyLocks();\n+        auto [locks, _] = sysLocks.ApplyLocks();\n \n         for (auto& lock : locks) {\n             NKikimrDataEvents::TLock* addLock;\n@@ -2958,7 +2958,7 @@ class TDataShard::TTxReadContinue : public NTabletFlatExecutor::TTransactionBase\n                 state.Lock = nullptr;\n             } else {\n                 // Lock valid, apply conflict changes\n-                auto locks = sysLocks.ApplyLocks();\n+                auto [locks, _] = sysLocks.ApplyLocks();\n                 Y_ABORT_UNLESS(locks.empty(), \"ApplyLocks acquired unexpected locks\");\n             }\n         }\ndiff --git a/ydb/core/tx/datashard/datashard_impl.h b/ydb/core/tx/datashard/datashard_impl.h\nindex c36c6331bb1f..3381708b9a0a 100644\n--- a/ydb/core/tx/datashard/datashard_impl.h\n+++ b/ydb/core/tx/datashard/datashard_impl.h\n@@ -250,6 +250,7 @@ class TDataShard\n     class TTxHandleSafeBuildIndexScan;\n     class TTxHandleSafeSampleKScan;\n     class TTxHandleSafeLocalKMeansScan;\n+    class TTxHandleSafePrefixKMeansScan;\n     class TTxHandleSafeReshuffleKMeansScan;\n     class TTxHandleSafeStatisticsScan;\n \n@@ -1335,6 +1336,8 @@ class TDataShard\n     void HandleSafe(TEvDataShard::TEvReshuffleKMeansRequest::TPtr& ev, const TActorContext& ctx);\n     void Handle(TEvDataShard::TEvLocalKMeansRequest::TPtr& ev, const TActorContext& ctx);\n     void HandleSafe(TEvDataShard::TEvLocalKMeansRequest::TPtr& ev, const TActorContext& ctx);\n+    void Handle(TEvDataShard::TEvPrefixKMeansRequest::TPtr& ev, const TActorContext& ctx);\n+    void HandleSafe(TEvDataShard::TEvPrefixKMeansRequest::TPtr& ev, const TActorContext& ctx);\n     void Handle(TEvDataShard::TEvCdcStreamScanRequest::TPtr& ev, const TActorContext& ctx);\n     void Handle(TEvPrivate::TEvCdcStreamScanRegistered::TPtr& ev, const TActorContext& ctx);\n     void Handle(TEvPrivate::TEvCdcStreamScanProgress::TPtr& ev, const TActorContext& ctx);\n@@ -3197,6 +3200,7 @@ class TDataShard\n             HFunc(TEvDataShard::TEvSampleKRequest, Handle);\n             HFunc(TEvDataShard::TEvReshuffleKMeansRequest, Handle);\n             HFunc(TEvDataShard::TEvLocalKMeansRequest, Handle);\n+            HFunc(TEvDataShard::TEvPrefixKMeansRequest, Handle);\n             HFunc(TEvDataShard::TEvCdcStreamScanRequest, Handle);\n             HFunc(TEvPrivate::TEvCdcStreamScanRegistered, Handle);\n             HFunc(TEvPrivate::TEvCdcStreamScanProgress, Handle);\ndiff --git a/ydb/core/tx/datashard/datashard_integrity_trails.h b/ydb/core/tx/datashard/datashard_integrity_trails.h\nindex de0a65569af4..0883b7f8d92c 100644\n--- a/ydb/core/tx/datashard/datashard_integrity_trails.h\n+++ b/ydb/core/tx/datashard/datashard_integrity_trails.h\n@@ -126,6 +126,32 @@ inline void LogIntegrityTrailsKeys(const NActors::TActorContext& ctx, const ui64\n     }\n }\n \n+inline void LogIntegrityTrailsLocks(const TActorContext& ctx, const ui64 tabletId, const ui64 txId, const TVector<ui64>& locks) {\n+    if (locks.empty()) {\n+        return;\n+    }\n+\n+    auto logFn = [&]() {\n+        TStringStream ss;\n+\n+        LogKeyValue(\"Component\", \"DataShard\", ss);\n+        LogKeyValue(\"Type\", \"Locks\", ss);\n+        LogKeyValue(\"TabletId\", ToString(tabletId), ss);\n+        LogKeyValue(\"PhyTxId\", ToString(txId), ss);\n+\n+        ss << \"BreakLocks: [\";\n+        for (const auto& lock : locks) {\n+            ss << lock << \" \";\n+        }\n+        ss << \"]\";\n+\n+        return ss.Str();\n+    };\n+\n+    LOG_INFO_S(ctx, NKikimrServices::DATA_INTEGRITY, logFn());\n+\n+}\n+\n template <typename TxResult>\n inline void LogIntegrityTrailsFinish(const NActors::TActorContext& ctx, const ui64 tabletId, const ui64 txId, const typename TxResult::EStatus status) {\n     auto logFn = [&]() {\ndiff --git a/ydb/core/tx/datashard/datashard_ut_change_exchange.cpp b/ydb/core/tx/datashard/datashard_ut_change_exchange.cpp\nindex 9981bd2ce3fe..7580867e814f 100644\n--- a/ydb/core/tx/datashard/datashard_ut_change_exchange.cpp\n+++ b/ydb/core/tx/datashard/datashard_ut_change_exchange.cpp\n@@ -2434,6 +2434,14 @@ Y_UNIT_TEST_SUITE(Cdc) {\n                     }\n                 }\n                 return TTestActorRuntime::EEventAction::PROCESS;\n+            \n+            case NKikimr::NEvents::TDataEvents::EvWriteResult:\n+                if (auto* msg = ev->Get<NKikimr::NEvents::TDataEvents::TEvWriteResult>()) {\n+                    if (msg->GetStatus() == NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED) {\n+                        txCompleted = true;\n+                    }\n+                }\n+                return TTestActorRuntime::EEventAction::PROCESS;\n \n             case TEvChangeExchange::EvSplitAck:\n                 splitAcked = true;\ndiff --git a/ydb/core/tx/datashard/datashard_ut_kqp_errors.cpp b/ydb/core/tx/datashard/datashard_ut_kqp_errors.cpp\nindex 58bda03fd2ab..9094c940a6a6 100644\n--- a/ydb/core/tx/datashard/datashard_ut_kqp_errors.cpp\n+++ b/ydb/core/tx/datashard/datashard_ut_kqp_errors.cpp\n@@ -16,12 +16,12 @@ using namespace NKikimrTxDataShard;\n \n namespace {\n \n-bool HasIssue(const TIssues& issues, ui32 code, TStringBuf message, std::function<bool(const TIssue& issue)> predicate = {}) {\n+bool HasIssueImpl(const TIssues& issues, ui32 code, TStringBuf message, std::function<bool(const TIssue& issue)> predicate, bool contains) {\n     bool hasIssue = false;\n \n     for (auto& issue : issues) {\n         WalkThroughIssues(issue, false, [&] (const TIssue& issue, int) {\n-            if (!hasIssue && issue.GetCode() == code && (!message || message == issue.GetMessage())) {\n+            if (!hasIssue && issue.GetCode() == code && (!message || message == issue.GetMessage() || (contains && issue.GetMessage().Contains(message)))) {\n                 hasIssue = !predicate || predicate(issue);\n             }\n         });\n@@ -30,14 +30,25 @@ bool HasIssue(const TIssues& issues, ui32 code, TStringBuf message, std::functio\n     return hasIssue;\n }\n \n+bool HasIssue(const TIssues& issues, ui32 code, TStringBuf message, std::function<bool(const TIssue& issue)> predicate = {}) {\n+    return HasIssueImpl(issues, code, message, predicate, false);\n+}\n+\n+bool HasIssueContains(const TIssues& issues, ui32 code, TStringBuf message, std::function<bool(const TIssue& issue)> predicate = {}) {\n+    return HasIssueImpl(issues, code, message, predicate, true);\n+}\n+\n } // anonymous namespace\n \n class TLocalFixture {\n public:\n-    TLocalFixture(bool enableResourcePools = true) {\n+    TLocalFixture(bool enableResourcePools = true, std::optional<bool> enableOltpSink = std::nullopt) {\n         TPortManager pm;\n         NKikimrConfig::TAppConfig app;\n         app.MutableFeatureFlags()->SetEnableResourcePools(enableResourcePools);\n+        if (enableOltpSink) {\n+            app.MutableTableServiceConfig()->SetEnableOltpSink(*enableOltpSink);\n+        }\n         TServerSettings serverSettings(pm.GetPort(2134));\n         serverSettings.SetDomainName(\"Root\")\n             .SetNodeCount(2)\n@@ -112,7 +123,7 @@ Y_UNIT_TEST(ResolveTableError) {\n }\n \n Y_UNIT_TEST(ProposeError) {\n-    TLocalFixture fixture;\n+    TLocalFixture fixture(true, false);\n     THashSet<TActorId> knownExecuters;\n \n     using TMod = std::function<void(NKikimrTxDataShard::TEvProposeTransactionResult&)>;\n@@ -227,6 +238,107 @@ Y_UNIT_TEST(ProposeError) {\n             \"Error executing transaction: transaction failed.\");\n }\n \n+Y_UNIT_TEST(ProposeErrorEvWrite) {\n+    TLocalFixture fixture(true, true);\n+    THashSet<TActorId> knownExecuters;\n+\n+    using TMod = std::function<void(NKikimrDataEvents::TEvWriteResult&)>;\n+\n+    auto test = [&](auto proposeStatus, auto ydbStatus, auto issue, auto issueMessage, TMod mod = {}) {\n+        auto client = fixture.Runtime->AllocateEdgeActor();\n+\n+        bool done = false;\n+        auto mitm = [&](TAutoPtr<IEventHandle> &ev) {\n+            if (!done && ev->GetTypeRewrite() == NKikimr::NEvents::TDataEvents::TEvWriteResult::EventType &&\n+                !knownExecuters.contains(ev->Recipient))\n+            {\n+                auto event = ev.Get()->Get<NKikimr::NEvents::TDataEvents::TEvWriteResult>();\n+                event->Record.SetStatus(proposeStatus);\n+                if (mod) {\n+                    mod(event->Record);\n+                }\n+                knownExecuters.insert(ev->Recipient);\n+                done = true;\n+            }\n+            return TTestActorRuntime::EEventAction::PROCESS;\n+        };\n+        fixture.Runtime->SetObserverFunc(mitm);\n+\n+        SendRequest(*fixture.Runtime, client, MakeSQLRequest(Q_(\"upsert into `/Root/table-1` (key, value) values (5, 5);\")));\n+\n+        auto ev = fixture.Runtime->GrabEdgeEventRethrow<NKqp::TEvKqp::TEvQueryResponse>(client);\n+        auto& record = ev->Get()->Record;\n+        UNIT_ASSERT_VALUES_EQUAL_C(record.GetYdbStatus(), ydbStatus, record.DebugString());\n+\n+        // Cerr << record.DebugString() << Endl;\n+\n+        TIssues issues;\n+        IssuesFromMessage(record.GetResponse().GetQueryIssues(), issues);\n+        UNIT_ASSERT_C(HasIssueContains(issues, issue, issueMessage), \"issue not found, issue: \" << (int) issue\n+            << \", message: \" << issueMessage << \", response: \" << record.GetResponse().DebugString());\n+    };\n+\n+    test(NKikimrDataEvents::TEvWriteResult::STATUS_OVERLOADED,                    // propose error\n+         Ydb::StatusIds::OVERLOADED,                                 // ydb status\n+         NYql::TIssuesIds::KIKIMR_OVERLOADED,                        // issue status\n+         \"Kikimr cluster or one of its subsystems is overloaded.\");  // main issue message (more detailed info can be in subissues)\n+\n+    test(NKikimrDataEvents::TEvWriteResult::STATUS_UNSPECIFIED,\n+         Ydb::StatusIds::STATUS_CODE_UNSPECIFIED,\n+         NYql::TIssuesIds::DEFAULT_ERROR,\n+         \"Unspecified error.\");\n+\n+    test(NKikimrDataEvents::TEvWriteResult::STATUS_ABORTED,\n+         Ydb::StatusIds::ABORTED,\n+         NYql::TIssuesIds::KIKIMR_OPERATION_ABORTED,\n+         \"Operation aborted.\");\n+\n+    test(NKikimrDataEvents::TEvWriteResult::STATUS_INTERNAL_ERROR,\n+         Ydb::StatusIds::INTERNAL_ERROR,\n+         NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,\n+         \"Internal error while executing transaction.\");\n+\n+    test(NKikimrDataEvents::TEvWriteResult::STATUS_CANCELLED,\n+         Ydb::StatusIds::CANCELLED,\n+         NYql::TIssuesIds::KIKIMR_OPERATION_CANCELLED,\n+         \"Operation cancelled.\");\n+\n+    test(NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST,\n+         Ydb::StatusIds::BAD_REQUEST,\n+         NYql::TIssuesIds::KIKIMR_BAD_REQUEST,\n+         \"Bad request.\");\n+\n+    test(NKikimrDataEvents::TEvWriteResult::STATUS_SCHEME_CHANGED,\n+         Ydb::StatusIds::ABORTED,\n+         NYql::TIssuesIds::KIKIMR_SCHEME_MISMATCH,\n+         \"Scheme changed.\");\n+\n+    test(NKikimrDataEvents::TEvWriteResult::STATUS_LOCKS_BROKEN,\n+         Ydb::StatusIds::ABORTED,\n+         NYql::TIssuesIds::KIKIMR_LOCKS_INVALIDATED,\n+         \"Transaction locks invalidated.\");\n+    \n+    test(NKikimrDataEvents::TEvWriteResult::STATUS_DISK_SPACE_EXHAUSTED,\n+         Ydb::StatusIds::UNAVAILABLE,\n+         NYql::TIssuesIds::KIKIMR_DISK_SPACE_EXHAUSTED,\n+         \"Disk space exhausted.\");\n+\n+    test(NKikimrDataEvents::TEvWriteResult::STATUS_WRONG_SHARD_STATE,\n+         Ydb::StatusIds::UNAVAILABLE,\n+         NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,\n+         \"Wrong shard state.\");\n+\n+    test(NKikimrDataEvents::TEvWriteResult::STATUS_CONSTRAINT_VIOLATION,\n+         Ydb::StatusIds::PRECONDITION_FAILED,\n+         NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION,\n+         \"Constraint violated.\");\n+    \n+    test(NKikimrDataEvents::TEvWriteResult::STATUS_OUT_OF_SPACE,\n+         Ydb::StatusIds::OVERLOADED,\n+         NYql::TIssuesIds::KIKIMR_OVERLOADED,\n+         \"out of space.\");\n+}\n+\n void TestProposeResultLost(TTestActorRuntime& runtime, TActorId client, const TString& query,\n                            std::function<void(const NKikimrKqp::TEvQueryResponse& resp)> fn)\n {\n@@ -236,7 +348,8 @@ void TestProposeResultLost(TTestActorRuntime& runtime, TActorId client, const TS\n     auto prev = runtime.SetObserverFunc([&](TAutoPtr<IEventHandle>& ev) {\n         if (ev->GetTypeRewrite() == TEvPipeCache::TEvForward::EventType) {\n             auto* fe = ev.Get()->Get<TEvPipeCache::TEvForward>();\n-            if (fe->Ev->Type() == TEvDataShard::TEvProposeTransaction::EventType) {\n+            if (fe->Ev->Type() == TEvDataShard::TEvProposeTransaction::EventType\n+                || fe->Ev->Type() == NKikimr::NEvents::TDataEvents::TEvWrite::EventType) {\n                 executer = ev->Sender;\n                 // Cerr << \"-- executer: \" << executer << Endl;\n                 return TTestActorRuntime::EEventAction::PROCESS;\n@@ -256,6 +369,19 @@ void TestProposeResultLost(TTestActorRuntime& runtime, TActorId client, const TS\n             }\n         }\n \n+        if (ev->GetTypeRewrite() == NKikimr::NEvents::TDataEvents::TEvWriteResult::EventType) {\n+            auto* msg = ev.Get()->Get<NKikimr::NEvents::TDataEvents::TEvWriteResult>();\n+            if (msg->Record.GetStatus() == NKikimrDataEvents::TEvWriteResult::STATUS_PREPARED) {\n+                if (ev->Sender.NodeId() == executer.NodeId()) {\n+                    ++droppedEvents;\n+                    // Cerr << \"-- send undelivery to \" << ev->Recipient << \", executer: \" << executer << Endl;\n+                    runtime.Send(new IEventHandle(executer, ev->Sender,\n+                        new TEvPipeCache::TEvDeliveryProblem(msg->Record.GetOrigin(), /* NotDelivered */ false)));\n+                    return TTestActorRuntime::EEventAction::DROP;\n+                }\n+            }\n+        }\n+\n         return TTestActorRuntime::EEventAction::PROCESS;\n     });\n     SendRequest(runtime, client, MakeSQLRequest(query));\n@@ -270,8 +396,8 @@ void TestProposeResultLost(TTestActorRuntime& runtime, TActorId client, const TS\n     runtime.SetObserverFunc(prev);\n }\n \n-Y_UNIT_TEST(ProposeResultLost_RwTx) {\n-    TLocalFixture fixture;\n+Y_UNIT_TEST_TWIN(ProposeResultLost_RwTx, UseSink) {\n+    TLocalFixture fixture(true, UseSink);\n     TestProposeResultLost(*fixture.Runtime, fixture.Client,\n         Q_(R\"(\n             upsert into `/Root/table-1` (key, value) VALUES\n@@ -283,7 +409,7 @@ Y_UNIT_TEST(ProposeResultLost_RwTx) {\n             TIssues issues;\n             IssuesFromMessage(record.GetResponse().GetQueryIssues(), issues);\n             UNIT_ASSERT_C(\n-                HasIssue(issues, NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,\n+                HasIssueContains(issues, NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,\n                     \"Kikimr cluster or one of its subsystems was unavailable.\"),\n                 record.GetResponse().DebugString());\n         });\ndiff --git a/ydb/core/tx/datashard/datashard_ut_locks.cpp b/ydb/core/tx/datashard/datashard_ut_locks.cpp\nindex 60f3ed8b03d9..e512e223e6dd 100644\n--- a/ydb/core/tx/datashard/datashard_ut_locks.cpp\n+++ b/ydb/core/tx/datashard/datashard_ut_locks.cpp\n@@ -201,7 +201,7 @@ namespace NTest {\n         }\n \n         TVector<TSysLocks::TLock> ApplyTxLocks() {\n-            auto locks = Locks.ApplyLocks();\n+            auto [locks, _] = Locks.ApplyLocks();\n             Locks.ResetUpdate();\n             return locks;\n         }\ndiff --git a/ydb/core/tx/datashard/datashard_ut_order.cpp b/ydb/core/tx/datashard/datashard_ut_order.cpp\nindex 1ff5e1f32f25..25f943ebf894 100644\n--- a/ydb/core/tx/datashard/datashard_ut_order.cpp\n+++ b/ydb/core/tx/datashard/datashard_ut_order.cpp\n@@ -1352,6 +1352,7 @@ Y_UNIT_TEST(TestOutOfOrderLockLost) {\n Y_UNIT_TEST_TWIN(TestOutOfOrderReadOnlyAllowed, EvWrite) {\n     TPortManager pm;\n     NKikimrConfig::TAppConfig app;\n+    app.MutableTableServiceConfig()->SetEnableOltpSink(EvWrite);\n     TServerSettings serverSettings(pm.GetPort(2134));\n     serverSettings.SetDomainName(\"Root\")\n         .SetUseRealThreads(false)\n@@ -1372,9 +1373,6 @@ Y_UNIT_TEST_TWIN(TestOutOfOrderReadOnlyAllowed, EvWrite) {\n     auto [shards2, tableId2] = CreateShardedTable(server, sender, \"/Root\", \"table-2\", 1);\n \n     {\n-        auto rows = EvWrite ? TEvWriteRows{{tableId1, {1, 1}}, {tableId2, {2, 1}}} : TEvWriteRows{};\n-        auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(runtime, rows);\n-\n         ExecSQL(server, sender, Q_(\"UPSERT INTO `/Root/table-1` (key, value) VALUES (1, 1);\"));\n         ExecSQL(server, sender, Q_(\"UPSERT INTO `/Root/table-2` (key, value) VALUES (2, 1);\"));\n     }\n@@ -1405,16 +1403,11 @@ Y_UNIT_TEST_TWIN(TestOutOfOrderReadOnlyAllowed, EvWrite) {\n     };\n     auto prevObserverFunc = runtime.SetObserverFunc(captureRS);\n \n-    auto rows = EvWrite ? TEvWriteRows{{tableId1, {3, 2}}, {tableId2, {4, 2}}} : TEvWriteRows{};\n-    auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(runtime, rows);\n-\n     // Send a commit request, it would block on readset exchange\n     auto f2 = SendRequest(runtime, MakeSimpleRequestRPC(Q_(R\"(\n         UPSERT INTO `/Root/table-1` (key, value) VALUES (3, 2);\n         UPSERT INTO `/Root/table-2` (key, value) VALUES (4, 2))\"), sessionId, txId, true));\n \n-    evWriteObservers = TTestActorRuntimeBase::TEventObserverHolderPair{};\n-\n     // Wait until we captured both readsets\n     const size_t expectedReadSets = usesVolatileTxs ? 4 : 2;\n     {\n@@ -1464,6 +1457,7 @@ Y_UNIT_TEST_TWIN(TestOutOfOrderReadOnlyAllowed, EvWrite) {\n Y_UNIT_TEST_TWIN(TestOutOfOrderNonConflictingWrites, EvWrite) {\n     TPortManager pm;\n     NKikimrConfig::TAppConfig app;\n+    app.MutableTableServiceConfig()->SetEnableOltpSink(EvWrite);\n     TServerSettings serverSettings(pm.GetPort(2134));\n     serverSettings.SetDomainName(\"Root\")\n         .SetAppConfig(app)\n@@ -1484,9 +1478,6 @@ Y_UNIT_TEST_TWIN(TestOutOfOrderNonConflictingWrites, EvWrite) {\n     auto [shards2, tableId2] = CreateShardedTable(server, sender, \"/Root\", \"table-2\", 1);\n \n     {\n-        auto rows = EvWrite ? TEvWriteRows{{tableId1, {1, 1}}, {tableId2, {2, 1}}} : TEvWriteRows{};\n-        auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(runtime, rows);\n-\n         ExecSQL(server, sender, Q_(\"UPSERT INTO `/Root/table-1` (key, value) VALUES (1, 1);\"));\n         ExecSQL(server, sender, Q_(\"UPSERT INTO `/Root/table-2` (key, value) VALUES (2, 1);\"));\n     }\n@@ -1518,16 +1509,11 @@ Y_UNIT_TEST_TWIN(TestOutOfOrderNonConflictingWrites, EvWrite) {\n     };\n     auto prevObserverFunc = runtime.SetObserverFunc(captureRS);\n \n-    auto rows = EvWrite ? TEvWriteRows{{tableId1, {3, 2}}, {tableId2, {4, 2}}} : TEvWriteRows{};\n-    auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(runtime, rows);\n-\n     // Send a commit request, it would block on readset exchange\n     auto f2 = SendRequest(runtime, MakeSimpleRequestRPC(Q_(R\"(\n         UPSERT INTO `/Root/table-1` (key, value) VALUES (3, 2);\n         UPSERT INTO `/Root/table-2` (key, value) VALUES (4, 2))\"), sessionId, txId, true));\n \n-    evWriteObservers = TTestActorRuntimeBase::TEventObserverHolderPair{};\n-\n     // Wait until we captured both readsets\n     const size_t expectedReadSets = usesVolatileTxs ? 4 : 2;\n     if (readSets.size() < expectedReadSets) {\n@@ -1542,9 +1528,6 @@ Y_UNIT_TEST_TWIN(TestOutOfOrderNonConflictingWrites, EvWrite) {\n \n     // Now send non-conflicting upsert to both tables\n     {\n-        auto rows1 = EvWrite ? TEvWriteRows{{tableId1, {5, 3}}, {tableId2, {6, 3}}} : TEvWriteRows{};\n-        auto evWriteObservers1 = ReplaceEvProposeTransactionWithEvWrite(runtime, rows1);\n-\n         blockReadSets = false;  // needed for volatile transactions\n         auto result = KqpSimpleExec(runtime, Q_(R\"(\n             UPSERT INTO `/Root/table-1` (key, value) VALUES (5, 3);\n@@ -1555,9 +1538,6 @@ Y_UNIT_TEST_TWIN(TestOutOfOrderNonConflictingWrites, EvWrite) {\n \n     // Check that immediate non-conflicting upsert is working too\n     {\n-        auto rows1 = EvWrite ? TEvWriteRows{{tableId1, {7, 4}}} : TEvWriteRows{};\n-        auto evWriteObservers1 = ReplaceEvProposeTransactionWithEvWrite(runtime, rows1);\n-\n         auto result = KqpSimpleExec(runtime, Q_(\"UPSERT INTO `/Root/table-1` (key, value) VALUES (7, 4)\"));\n         UNIT_ASSERT_VALUES_EQUAL(result, \"<empty>\");\n     }\n@@ -2040,11 +2020,14 @@ Y_UNIT_TEST(TestPlannedTimeoutSplit) {\n     }\n }\n \n-Y_UNIT_TEST(TestPlannedHalfOverloadedSplit) {\n+Y_UNIT_TEST_TWIN(TestPlannedHalfOverloadedSplit, UseSink) {\n     TPortManager pm;\n     TServerSettings serverSettings(pm.GetPort(2134));\n+    NKikimrConfig::TAppConfig app;\n+    app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n     serverSettings.SetDomainName(\"Root\")\n-        .SetUseRealThreads(false);\n+        .SetUseRealThreads(false)\n+        .SetAppConfig(app);\n \n     Tests::TServer::TPtr server = new TServer(serverSettings);\n     auto &runtime = *server->GetRuntime();\n@@ -2075,7 +2058,8 @@ Y_UNIT_TEST(TestPlannedHalfOverloadedSplit) {\n     TVector<THolder<IEventHandle>> txProposeResults;\n     auto captureMessages = [&](TAutoPtr<IEventHandle> &event) -> auto {\n         switch (event->GetTypeRewrite()) {\n-            case TEvDataShard::EvProposeTransaction: {\n+            case TEvDataShard::EvProposeTransaction:\n+            case NKikimr::NEvents::TDataEvents::EvWrite: {\n                 Cerr << \"---- observed EvProposeTransactionResult ----\" << Endl;\n                 if (txProposes.size() == 0) {\n                     // Capture the first propose\n@@ -2084,7 +2068,8 @@ Y_UNIT_TEST(TestPlannedHalfOverloadedSplit) {\n                 }\n                 break;\n             }\n-            case TEvDataShard::EvProposeTransactionResult: {\n+            case TEvDataShard::EvProposeTransactionResult:\n+            case NKikimr::NEvents::TDataEvents::EvWriteResult: {\n                 Cerr << \"---- observed EvProposeTransactionResult ----\" << Endl;\n                 if (txProposes.size() > 0) {\n                     // Capture all propose results\n@@ -2472,11 +2457,14 @@ Y_UNIT_TEST(TestReadTableSingleShardImmediate) {\n     UNIT_ASSERT_VALUES_EQUAL(seenPlanSteps, 0u);\n }\n \n-Y_UNIT_TEST(TestImmediateQueueThenSplit) {\n+Y_UNIT_TEST_TWIN(TestImmediateQueueThenSplit, UseSink) {\n     TPortManager pm;\n     TServerSettings serverSettings(pm.GetPort(2134));\n+    NKikimrConfig::TAppConfig app;\n+    app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n     serverSettings.SetDomainName(\"Root\")\n-        .SetUseRealThreads(false);\n+        .SetUseRealThreads(false)\n+        .SetAppConfig(app);\n \n     Tests::TServer::TPtr server = new TServer(serverSettings);\n     auto &runtime = *server->GetRuntime();\n@@ -2519,6 +2507,7 @@ Y_UNIT_TEST(TestImmediateQueueThenSplit) {\n                 }\n                 break;\n             case TEvDataShard::EvProposeTransaction:\n+            case NKikimr::NEvents::TDataEvents::EvWrite:\n                 if (capturePropose) {\n                     Cerr << \"---- capture EvProposeTransaction ----\" << Endl;\n                     eventsPropose.emplace_back(event.Release());\n@@ -2640,10 +2629,11 @@ Y_UNIT_TEST(TestImmediateQueueThenSplit) {\n         << failures << \" failures\");\n }\n \n-void TestLateKqpQueryAfterColumnDrop(bool dataQuery, const TString& query) {\n+void TestLateKqpQueryAfterColumnDrop(bool dataQuery, bool useSink, const TString& query) {\n     TPortManager pm;\n     NKikimrConfig::TAppConfig app;\n     app.MutableTableServiceConfig()->SetEnableKqpScanQuerySourceRead(false);\n+    app.MutableTableServiceConfig()->SetEnableOltpSink(useSink);\n     TServerSettings serverSettings(pm.GetPort(2134));\n     serverSettings.SetDomainName(\"Root\")\n         .SetUseRealThreads(false)\n@@ -2691,6 +2681,15 @@ void TestLateKqpQueryAfterColumnDrop(bool dataQuery, const TString& query) {\n                 break;\n             }\n \n+            case NKikimr::NEvents::TDataEvents::EvWrite: {\n+                if (capturePropose) {\n+                    Cerr << \"---- capture EvWrite ----\" << Endl;\n+                    eventsPropose.emplace_back(ev.Release());\n+                    return TTestActorRuntime::EEventAction::DROP;\n+                }\n+                break;\n+            }\n+\n             case TEvDataShard::EvKqpScan: {\n                 if (capturePropose) {\n                     Cerr << \"---- capture EvKqpScan ----\" << Endl;\n@@ -2755,8 +2754,8 @@ void TestLateKqpQueryAfterColumnDrop(bool dataQuery, const TString& query) {\n     }\n }\n \n-Y_UNIT_TEST(TestLateKqpScanAfterColumnDrop) {\n-    TestLateKqpQueryAfterColumnDrop(false, \"SELECT SUM(value2) FROM `/Root/table-1`\");\n+Y_UNIT_TEST_TWIN(TestLateKqpScanAfterColumnDrop, UseSink) {\n+    TestLateKqpQueryAfterColumnDrop(false, UseSink, \"SELECT SUM(value2) FROM `/Root/table-1`\");\n }\n \n Y_UNIT_TEST(TestSecondaryClearanceAfterShardRestartRace) {\n@@ -2963,6 +2962,7 @@ Y_UNIT_TEST(TestShardRestartNoUndeterminedImmediate) {\n Y_UNIT_TEST_TWIN(TestShardRestartPlannedCommitShouldSucceed, EvWrite) {\n     TPortManager pm;\n     NKikimrConfig::TAppConfig app;\n+    app.MutableTableServiceConfig()->SetEnableOltpSink(EvWrite);\n     TServerSettings serverSettings(pm.GetPort(2134));\n     serverSettings.SetDomainName(\"Root\")\n         .SetUseRealThreads(false)\n@@ -2983,9 +2983,6 @@ Y_UNIT_TEST_TWIN(TestShardRestartPlannedCommitShouldSucceed, EvWrite) {\n     auto [shards2, tableId2] = CreateShardedTable(server, sender, \"/Root\", \"table-2\", 1);\n \n     {\n-        auto rows = EvWrite ? TEvWriteRows{{tableId1, {1, 1}}, {tableId2, {2, 1}}} : TEvWriteRows{};\n-        auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(runtime, rows);\n-\n         Cerr << \"===== UPSERT initial rows\" << Endl;\n \n         ExecSQL(server, sender, Q_(\"UPSERT INTO `/Root/table-1` (key, value) VALUES (1, 1)\"));\n@@ -3035,9 +3032,6 @@ Y_UNIT_TEST_TWIN(TestShardRestartPlannedCommitShouldSucceed, EvWrite) {\n     };\n     auto prevObserverFunc = runtime.SetObserverFunc(captureRS);\n \n-    auto rows = EvWrite ? TEvWriteRows{{tableId1, {3, 2}}, {tableId2, {4, 2}}} : TEvWriteRows{};\n-    auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(runtime, rows);\n-\n     Cerr << \"===== UPSERT and commit\" << Endl;\n \n     // Send a commit request, it would block on readset exchange\n@@ -3063,8 +3057,6 @@ Y_UNIT_TEST_TWIN(TestShardRestartPlannedCommitShouldSucceed, EvWrite) {\n         UNIT_ASSERT_VALUES_EQUAL(response.operation().status(), Ydb::StatusIds::SUCCESS);\n     }\n \n-    evWriteObservers = TTestActorRuntimeBase::TEventObserverHolderPair{};\n-\n     // Select key 3 and verify its value was updated\n     {\n         Cerr << \"===== Last SELECT\" << Endl;\n@@ -3284,10 +3276,13 @@ Y_UNIT_TEST(TestShardSnapshotReadNoEarlyReply) {\n }\n \n Y_UNIT_TEST_TWIN(TestSnapshotReadAfterBrokenLock, EvWrite) {\n+    NKikimrConfig::TAppConfig app;\n+    app.MutableTableServiceConfig()->SetEnableOltpSink(EvWrite);\n     TPortManager pm;\n     TServerSettings serverSettings(pm.GetPort(2134));\n     serverSettings.SetDomainName(\"Root\")\n-        .SetUseRealThreads(false);\n+        .SetUseRealThreads(false)\n+        .SetAppConfig(app);\n \n     Tests::TServer::TPtr server = new TServer(serverSettings);\n     auto &runtime = *server->GetRuntime();\n@@ -3298,9 +3293,6 @@ Y_UNIT_TEST_TWIN(TestSnapshotReadAfterBrokenLock, EvWrite) {\n     CreateShardedTable(server, sender, \"/Root\", \"table-1\", 1);\n     CreateShardedTable(server, sender, \"/Root\", \"table-2\", 1);\n \n-    auto rows = EvWrite ? TEvWriteRows{{{1, 1}}, {{2, 2}}, {{3, 3}}, {{5, 5}}} : TEvWriteRows{};\n-    auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(runtime, rows);\n-\n     ExecSQL(server, sender, Q_(\"UPSERT INTO `/Root/table-1` (key, value) VALUES (1, 1)\"));\n     ExecSQL(server, sender, Q_(\"UPSERT INTO `/Root/table-2` (key, value) VALUES (2, 2)\"));\n \ndiff --git a/ydb/core/tx/datashard/datashard_ut_prefix_kmeans.cpp b/ydb/core/tx/datashard/datashard_ut_prefix_kmeans.cpp\nnew file mode 100644\nindex 000000000000..b163e3b7c69a\n--- /dev/null\n+++ b/ydb/core/tx/datashard/datashard_ut_prefix_kmeans.cpp\n@@ -0,0 +1,565 @@\n+#include <ydb/core/base/table_index.h>\n+#include <ydb/core/testlib/test_client.h>\n+#include <ydb/core/tx/datashard/ut_common/datashard_ut_common.h>\n+#include <ydb/core/tx/schemeshard/schemeshard.h>\n+#include <ydb/core/tx/tx_proxy/proxy.h>\n+#include <ydb/core/tx/tx_proxy/upload_rows.h>\n+#include <ydb/core/protos/index_builder.pb.h>\n+\n+#include <yql/essentials/public/issue/yql_issue_message.h>\n+\n+#include <library/cpp/testing/unittest/registar.h>\n+\n+namespace NKikimr {\n+using namespace Tests;\n+using Ydb::Table::VectorIndexSettings;\n+using namespace NTableIndex::NTableVectorKmeansTreeIndex;\n+\n+static std::atomic<ui64> sId = 1;\n+static constexpr const char* kMainTable = \"/Root/table-main\";\n+static constexpr const char* kLevelTable = \"/Root/table-level\";\n+static constexpr const char* kPostingTable = \"/Root/table-posting\";\n+static constexpr const char* kPrefixTable = \"/Root/table-prefix\";\n+\n+Y_UNIT_TEST_SUITE (TTxDataShardPrefixKMeansScan) {\n+    static void DoBadRequest(Tests::TServer::TPtr server, TActorId sender,\n+                             std::unique_ptr<TEvDataShard::TEvPrefixKMeansRequest> & ev, size_t dims = 2,\n+                             VectorIndexSettings::VectorType type = VectorIndexSettings::VECTOR_TYPE_FLOAT,\n+                             VectorIndexSettings::Metric metric = VectorIndexSettings::DISTANCE_COSINE)\n+    {\n+        auto id = sId.fetch_add(1, std::memory_order_relaxed);\n+        auto& runtime = *server->GetRuntime();\n+        auto datashards = GetTableShards(server, sender, kMainTable);\n+        TTableId tableId = ResolveTableId(server, sender, kMainTable);\n+\n+        TStringBuilder data;\n+        TString err;\n+        UNIT_ASSERT(datashards.size() == 1);\n+\n+        for (auto tid : datashards) {\n+            auto& rec = ev->Record;\n+            rec.SetId(1);\n+\n+            rec.SetSeqNoGeneration(id);\n+            rec.SetSeqNoRound(1);\n+\n+            if (!rec.HasTabletId()) {\n+                rec.SetTabletId(tid);\n+            }\n+            if (!rec.HasPathId()) {\n+                tableId.PathId.ToProto(rec.MutablePathId());\n+            }\n+\n+            VectorIndexSettings settings;\n+            settings.set_vector_dimension(dims);\n+            settings.set_vector_type(type);\n+            settings.set_metric(metric);\n+            *rec.MutableSettings() = settings;\n+\n+            if (!rec.HasK()) {\n+                rec.SetK(2);\n+            }\n+            rec.SetSeed(1337);\n+\n+            rec.SetUpload(NKikimrTxDataShard::TEvLocalKMeansRequest::UPLOAD_BUILD_TO_POSTING);\n+\n+            rec.SetNeedsRounds(3);\n+\n+            rec.SetChild(1);\n+\n+            if (rec.HasEmbeddingColumn()) {\n+                rec.ClearEmbeddingColumn();\n+            } else {\n+                rec.SetEmbeddingColumn(\"embedding\");\n+            }\n+\n+            rec.SetLevelName(kLevelTable);\n+            rec.SetPostingName(kPostingTable);\n+\n+            runtime.SendToPipe(tid, sender, ev.release(), 0, GetPipeConfigWithRetries());\n+\n+            TAutoPtr<IEventHandle> handle;\n+            auto reply = runtime.GrabEdgeEventRethrow<TEvDataShard::TEvPrefixKMeansResponse>(handle);\n+            UNIT_ASSERT_VALUES_EQUAL(reply->Record.GetStatus(), NKikimrIndexBuilder::EBuildStatus::BAD_REQUEST);\n+        }\n+    }\n+\n+    static std::tuple<TString, TString> DoPrefixKMeans(\n+        Tests::TServer::TPtr server, TActorId sender, NTableIndex::TClusterId parent, ui64 seed, ui64 k,\n+        NKikimrTxDataShard::TEvLocalKMeansRequest::EState upload, VectorIndexSettings::VectorType type,\n+        VectorIndexSettings::Metric metric)\n+    {\n+        auto id = sId.fetch_add(1, std::memory_order_relaxed);\n+        auto& runtime = *server->GetRuntime();\n+        auto datashards = GetTableShards(server, sender, kMainTable);\n+        TTableId tableId = ResolveTableId(server, sender, kMainTable);\n+\n+        TString err;\n+\n+        for (auto tid : datashards) {\n+            auto ev1 = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();\n+            auto ev2 = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();\n+            auto fill = [&](std::unique_ptr<TEvDataShard::TEvPrefixKMeansRequest>& ev) {\n+                auto& rec = ev->Record;\n+                rec.SetId(1);\n+\n+                rec.SetSeqNoGeneration(id);\n+                rec.SetSeqNoRound(1);\n+\n+                rec.SetTabletId(tid);\n+                tableId.PathId.ToProto(rec.MutablePathId());\n+\n+                VectorIndexSettings settings;\n+                settings.set_vector_dimension(2);\n+                settings.set_vector_type(type);\n+                settings.set_metric(metric);\n+                *rec.MutableSettings() = settings;\n+\n+                rec.SetK(k);\n+                rec.SetSeed(seed);\n+\n+                rec.SetUpload(upload);\n+\n+                rec.SetNeedsRounds(300);\n+\n+                rec.SetChild(parent);\n+\n+                rec.SetEmbeddingColumn(\"embedding\");\n+                rec.AddDataColumns(\"data\");\n+                rec.SetPrefixColumns(1);\n+\n+                rec.SetLevelName(kLevelTable);\n+                rec.SetPostingName(kPostingTable);\n+                rec.SetPrefixName(kPrefixTable);\n+            };\n+            fill(ev1);\n+            fill(ev2);\n+\n+            runtime.SendToPipe(tid, sender, ev1.release(), 0, GetPipeConfigWithRetries());\n+            runtime.SendToPipe(tid, sender, ev2.release(), 0, GetPipeConfigWithRetries());\n+\n+            TAutoPtr<IEventHandle> handle;\n+            auto reply = runtime.GrabEdgeEventRethrow<TEvDataShard::TEvPrefixKMeansResponse>(handle);\n+\n+            NYql::TIssues issues;\n+            NYql::IssuesFromMessage(reply->Record.GetIssues(), issues);\n+            UNIT_ASSERT_EQUAL_C(reply->Record.GetStatus(), NKikimrIndexBuilder::EBuildStatus::DONE,\n+                                issues.ToOneLineString());\n+        }\n+\n+        auto level = ReadShardedTable(server, kLevelTable);\n+        auto posting = ReadShardedTable(server, kPostingTable);\n+        return {std::move(level), std::move(posting)};\n+    }\n+\n+    static void DropTable(Tests::TServer::TPtr server, TActorId sender, const char* name)\n+    {\n+        ui64 txId = AsyncDropTable(server, sender, \"/Root\", name);\n+        WaitTxNotification(server, sender, txId);\n+    }\n+\n+    static void CreateLevelTable(Tests::TServer::TPtr server, TActorId sender, TShardedTableOptions options)\n+    {\n+        options.AllowSystemColumnNames(true);\n+        options.Columns({\n+            {ParentColumn, NTableIndex::ClusterIdTypeName, true, true},\n+            {IdColumn, NTableIndex::ClusterIdTypeName, true, true},\n+            {CentroidColumn, \"String\", false, true},\n+        });\n+        CreateShardedTable(server, sender, \"/Root\", \"table-level\", options);\n+    }\n+\n+    static void CreatePostingTable(Tests::TServer::TPtr server, TActorId sender, TShardedTableOptions options)\n+    {\n+        options.AllowSystemColumnNames(true);\n+        options.Columns({\n+            {ParentColumn, NTableIndex::ClusterIdTypeName, true, true},\n+            {\"key\", \"Uint32\", true, true},\n+            {\"data\", \"String\", false, false},\n+        });\n+        CreateShardedTable(server, sender, \"/Root\", \"table-posting\", options);\n+    }\n+\n+    static void CreateBuildTable(Tests::TServer::TPtr server, TActorId sender, TShardedTableOptions options,\n+                                 const char* name)\n+    {\n+        options.AllowSystemColumnNames(true);\n+        options.Columns({\n+            {ParentColumn, NTableIndex::ClusterIdTypeName, true, true},\n+            {\"key\", \"Uint32\", true, true},\n+            {\"embedding\", \"String\", false, false},\n+            {\"data\", \"String\", false, false},\n+        });\n+        CreateShardedTable(server, sender, \"/Root\", name, options);\n+    }\n+\n+    static void CreateBuildPrefixTable(Tests::TServer::TPtr server, TActorId sender, TShardedTableOptions options,\n+                                       const char* name)\n+    {\n+        options.Columns({\n+            {\"user\", \"String\", true, true},\n+            {\"key\", \"Uint32\", true, true},\n+            {\"embedding\", \"String\", false, false},\n+            {\"data\", \"String\", false, false},\n+        });\n+        CreateShardedTable(server, sender, \"/Root\", name, options);\n+    }\n+\n+    Y_UNIT_TEST (BadRequest) {\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings.SetDomainName(\"Root\");\n+\n+        Tests::TServer::TPtr server = new TServer(serverSettings);\n+        auto& runtime = *server->GetRuntime();\n+        auto sender = runtime.AllocateEdgeActor();\n+\n+        runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_DEBUG);\n+\n+        InitRoot(server, sender);\n+\n+        CreateShardedTable(server, sender, \"/Root\", \"table-main\", 1);\n+\n+        {\n+            auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();\n+            auto& rec = ev->Record;\n+\n+            rec.SetK(0);\n+            DoBadRequest(server, sender, ev);\n+        }\n+        {\n+            auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();\n+            auto& rec = ev->Record;\n+\n+            rec.SetK(1);\n+            DoBadRequest(server, sender, ev);\n+        }\n+        {\n+            auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();\n+            auto& rec = ev->Record;\n+\n+            rec.SetEmbeddingColumn(\"some\");\n+            DoBadRequest(server, sender, ev);\n+        }\n+        {\n+            auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();\n+            auto& rec = ev->Record;\n+\n+            rec.SetTabletId(0);\n+            DoBadRequest(server, sender, ev);\n+        }\n+        {\n+            auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();\n+            auto& rec = ev->Record;\n+\n+            TPathId(0, 0).ToProto(rec.MutablePathId());\n+            DoBadRequest(server, sender, ev);\n+        }\n+        {\n+            auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();\n+\n+            DoBadRequest(server, sender, ev, 0);\n+        }\n+        {\n+            auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();\n+\n+            // TODO(mbkkt) bit vector not supported for now\n+            DoBadRequest(server, sender, ev, 2, VectorIndexSettings::VECTOR_TYPE_BIT);\n+        }\n+        {\n+            auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();\n+\n+            DoBadRequest(server, sender, ev, 2, VectorIndexSettings::VECTOR_TYPE_UNSPECIFIED);\n+        }\n+        {\n+            auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();\n+\n+            DoBadRequest(server, sender, ev, 2, VectorIndexSettings::VECTOR_TYPE_FLOAT,\n+                         VectorIndexSettings::METRIC_UNSPECIFIED);\n+        }\n+        // TODO(mbkkt) For now all build_index, sample_k, build_columns, local_kmeans, prefix_kmeans doesn't really check this\n+        // {\n+        //     auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();\n+        //     auto snapshotCopy = snapshot;\n+        //     snapshotCopy.Step++;\n+        //     DoBadRequest(server, sender, ev);\n+        // }\n+        // {\n+        //     auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();\n+        //     auto snapshotCopy = snapshot;\n+        //     snapshotCopy.TxId++;\n+        //     DoBadRequest(server, sender, ev);\n+        // }\n+    }\n+\n+    Y_UNIT_TEST (BuildToPosting) {\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings.SetDomainName(\"Root\");\n+\n+        Tests::TServer::TPtr server = new TServer(serverSettings);\n+        auto& runtime = *server->GetRuntime();\n+        auto sender = runtime.AllocateEdgeActor();\n+\n+        runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_DEBUG);\n+        runtime.SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_DEBUG);\n+\n+        InitRoot(server, sender);\n+\n+        TShardedTableOptions options;\n+        options.EnableOutOfOrder(true); // TODO(mbkkt) what is it?\n+        options.Shards(1);\n+\n+        CreateBuildPrefixTable(server, sender, options, \"table-main\");\n+        // Upsert some initial values\n+        ExecSQL(server, sender,\n+                R\"(\n+        UPSERT INTO `/Root/table-main`\n+            (user, key, embedding, data)\n+        VALUES )\"\n+                \"(\\\"user-1\\\", 11, \\\"\\x30\\x30\\3\\\", \\\"1-one\\\"),\"\n+                \"(\\\"user-1\\\", 12, \\\"\\x31\\x31\\3\\\", \\\"1-two\\\"),\"\n+                \"(\\\"user-1\\\", 13, \\\"\\x32\\x32\\3\\\", \\\"1-three\\\"),\"\n+                \"(\\\"user-1\\\", 14, \\\"\\x65\\x65\\3\\\", \\\"1-four\\\"),\"\n+                \"(\\\"user-1\\\", 15, \\\"\\x75\\x75\\3\\\", \\\"1-five\\\"),\"\n+\n+                \"(\\\"user-2\\\", 21, \\\"\\x30\\x30\\3\\\", \\\"2-one\\\"),\"\n+                \"(\\\"user-2\\\", 22, \\\"\\x31\\x31\\3\\\", \\\"2-two\\\"),\"\n+                \"(\\\"user-2\\\", 23, \\\"\\x32\\x32\\3\\\", \\\"2-three\\\"),\"\n+                \"(\\\"user-2\\\", 24, \\\"\\x65\\x65\\3\\\", \\\"2-four\\\"),\"\n+                \"(\\\"user-2\\\", 25, \\\"\\x75\\x75\\3\\\", \\\"2-five\\\");\");\n+\n+        auto create = [&] {\n+            CreateLevelTable(server, sender, options);\n+            CreatePostingTable(server, sender, options);\n+        };\n+        create();\n+        auto recreate = [&] {\n+            DropTable(server, sender, \"table-level\");\n+            DropTable(server, sender, \"table-posting\");\n+            create();\n+        };\n+\n+        ui64 seed, k;\n+        k = 2;\n+\n+        seed = 0;\n+        for (auto distance : {VectorIndexSettings::DISTANCE_MANHATTAN, VectorIndexSettings::DISTANCE_EUCLIDEAN}) {\n+            auto [level, posting] = DoPrefixKMeans(server, sender, 40, seed, k,\n+                                                  NKikimrTxDataShard::TEvLocalKMeansRequest::UPLOAD_BUILD_TO_POSTING,\n+                                                  VectorIndexSettings::VECTOR_TYPE_UINT8, distance);\n+            UNIT_ASSERT_VALUES_EQUAL(level, \n+                \"__ydb_parent = 40, __ydb_id = 41, __ydb_centroid = mm\\3\\n\"\n+                \"__ydb_parent = 40, __ydb_id = 42, __ydb_centroid = 11\\3\\n\"\n+\n+                \"__ydb_parent = 43, __ydb_id = 44, __ydb_centroid = 11\\3\\n\"\n+                \"__ydb_parent = 43, __ydb_id = 45, __ydb_centroid = mm\\3\\n\"\n+            );\n+            UNIT_ASSERT_VALUES_EQUAL(posting, \n+                \"__ydb_parent = 41, key = 14, data = 1-four\\n\"\n+                \"__ydb_parent = 41, key = 15, data = 1-five\\n\"\n+                \"__ydb_parent = 42, key = 11, data = 1-one\\n\"\n+                \"__ydb_parent = 42, key = 12, data = 1-two\\n\"\n+                \"__ydb_parent = 42, key = 13, data = 1-three\\n\"\n+\n+                \"__ydb_parent = 44, key = 21, data = 2-one\\n\"\n+                \"__ydb_parent = 44, key = 22, data = 2-two\\n\"\n+                \"__ydb_parent = 44, key = 23, data = 2-three\\n\"\n+                \"__ydb_parent = 45, key = 24, data = 2-four\\n\"\n+                \"__ydb_parent = 45, key = 25, data = 2-five\\n\"\n+            );\n+            recreate();\n+        }\n+\n+        seed = 111;\n+        for (auto distance : {VectorIndexSettings::DISTANCE_MANHATTAN, VectorIndexSettings::DISTANCE_EUCLIDEAN}) {\n+            auto [level, posting] = DoPrefixKMeans(server, sender, 40, seed, k,\n+                                                  NKikimrTxDataShard::TEvLocalKMeansRequest::UPLOAD_BUILD_TO_POSTING,\n+                                                  VectorIndexSettings::VECTOR_TYPE_UINT8, distance);\n+            UNIT_ASSERT_VALUES_EQUAL(level, \n+                \"__ydb_parent = 40, __ydb_id = 41, __ydb_centroid = 11\\3\\n\"\n+                \"__ydb_parent = 40, __ydb_id = 42, __ydb_centroid = mm\\3\\n\"\n+\n+                \"__ydb_parent = 43, __ydb_id = 44, __ydb_centroid = 11\\3\\n\"\n+                \"__ydb_parent = 43, __ydb_id = 45, __ydb_centroid = mm\\3\\n\"\n+            );\n+            UNIT_ASSERT_VALUES_EQUAL(posting, \n+                \"__ydb_parent = 41, key = 11, data = 1-one\\n\"\n+                \"__ydb_parent = 41, key = 12, data = 1-two\\n\"\n+                \"__ydb_parent = 41, key = 13, data = 1-three\\n\"\n+                \"__ydb_parent = 42, key = 14, data = 1-four\\n\"\n+                \"__ydb_parent = 42, key = 15, data = 1-five\\n\"\n+\n+                \"__ydb_parent = 44, key = 21, data = 2-one\\n\"\n+                \"__ydb_parent = 44, key = 22, data = 2-two\\n\"\n+                \"__ydb_parent = 44, key = 23, data = 2-three\\n\"\n+                \"__ydb_parent = 45, key = 24, data = 2-four\\n\"\n+                \"__ydb_parent = 45, key = 25, data = 2-five\\n\"\n+            );\n+            recreate();\n+        }\n+        seed = 32;\n+        for (auto similarity : {VectorIndexSettings::SIMILARITY_INNER_PRODUCT, VectorIndexSettings::SIMILARITY_COSINE,\n+                                VectorIndexSettings::DISTANCE_COSINE})\n+        {\n+            auto [level, posting] = DoPrefixKMeans(server, sender, 40, seed, k,\n+                                                  NKikimrTxDataShard::TEvLocalKMeansRequest::UPLOAD_BUILD_TO_POSTING,\n+                                                  VectorIndexSettings::VECTOR_TYPE_UINT8, similarity);\n+            UNIT_ASSERT_VALUES_EQUAL(level, \n+                \"__ydb_parent = 40, __ydb_id = 41, __ydb_centroid = II\\3\\n\"\n+\n+                \"__ydb_parent = 43, __ydb_id = 44, __ydb_centroid = II\\3\\n\"\n+            );\n+            UNIT_ASSERT_VALUES_EQUAL(posting, \n+                \"__ydb_parent = 41, key = 11, data = 1-one\\n\"\n+                \"__ydb_parent = 41, key = 12, data = 1-two\\n\"\n+                \"__ydb_parent = 41, key = 13, data = 1-three\\n\"\n+                \"__ydb_parent = 41, key = 14, data = 1-four\\n\"\n+                \"__ydb_parent = 41, key = 15, data = 1-five\\n\"\n+\n+                \"__ydb_parent = 44, key = 21, data = 2-one\\n\"\n+                \"__ydb_parent = 44, key = 22, data = 2-two\\n\"\n+                \"__ydb_parent = 44, key = 23, data = 2-three\\n\"\n+                \"__ydb_parent = 44, key = 24, data = 2-four\\n\"\n+                \"__ydb_parent = 44, key = 25, data = 2-five\\n\"\n+            );\n+            recreate();\n+        }\n+    }\n+\n+    Y_UNIT_TEST (BuildToBuild) {\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings.SetDomainName(\"Root\");\n+\n+        Tests::TServer::TPtr server = new TServer(serverSettings);\n+        auto& runtime = *server->GetRuntime();\n+        auto sender = runtime.AllocateEdgeActor();\n+\n+        runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_DEBUG);\n+\n+        InitRoot(server, sender);\n+\n+        TShardedTableOptions options;\n+        options.EnableOutOfOrder(true); // TODO(mbkkt) what is it?\n+        options.Shards(1);\n+\n+        CreateBuildPrefixTable(server, sender, options, \"table-main\");\n+        // Upsert some initial values\n+        ExecSQL(server, sender,\n+                R\"(\n+        UPSERT INTO `/Root/table-main`\n+            (user, key, embedding, data)\n+        VALUES )\"\n+                \"(\\\"user-1\\\", 11, \\\"\\x30\\x30\\3\\\", \\\"1-one\\\"),\"\n+                \"(\\\"user-1\\\", 12, \\\"\\x31\\x31\\3\\\", \\\"1-two\\\"),\"\n+                \"(\\\"user-1\\\", 13, \\\"\\x32\\x32\\3\\\", \\\"1-three\\\"),\"\n+                \"(\\\"user-1\\\", 14, \\\"\\x65\\x65\\3\\\", \\\"1-four\\\"),\"\n+                \"(\\\"user-1\\\", 15, \\\"\\x75\\x75\\3\\\", \\\"1-five\\\"),\"\n+\n+                \"(\\\"user-2\\\", 21, \\\"\\x30\\x30\\3\\\", \\\"2-one\\\"),\"\n+                \"(\\\"user-2\\\", 22, \\\"\\x31\\x31\\3\\\", \\\"2-two\\\"),\"\n+                \"(\\\"user-2\\\", 23, \\\"\\x32\\x32\\3\\\", \\\"2-three\\\"),\"\n+                \"(\\\"user-2\\\", 24, \\\"\\x65\\x65\\3\\\", \\\"2-four\\\"),\"\n+                \"(\\\"user-2\\\", 25, \\\"\\x75\\x75\\3\\\", \\\"2-five\\\");\");\n+\n+        auto create = [&] {\n+            CreateLevelTable(server, sender, options);\n+            CreateBuildTable(server, sender, options, \"table-posting\");\n+        };\n+        create();\n+        auto recreate = [&] {\n+            DropTable(server, sender, \"table-level\");\n+            DropTable(server, sender, \"table-posting\");\n+            create();\n+        };\n+\n+        ui64 seed, k;\n+        k = 2;\n+\n+        seed = 0;\n+        for (auto distance : {VectorIndexSettings::DISTANCE_MANHATTAN, VectorIndexSettings::DISTANCE_EUCLIDEAN}) {\n+            auto [level, posting] = DoPrefixKMeans(server, sender, 40, seed, k,\n+                                                  NKikimrTxDataShard::TEvLocalKMeansRequest::UPLOAD_BUILD_TO_BUILD,\n+                                                  VectorIndexSettings::VECTOR_TYPE_UINT8, distance);\n+            UNIT_ASSERT_VALUES_EQUAL(level, \n+                \"__ydb_parent = 40, __ydb_id = 41, __ydb_centroid = mm\\3\\n\"\n+                \"__ydb_parent = 40, __ydb_id = 42, __ydb_centroid = 11\\3\\n\"\n+\n+                \"__ydb_parent = 43, __ydb_id = 44, __ydb_centroid = 11\\3\\n\"\n+                \"__ydb_parent = 43, __ydb_id = 45, __ydb_centroid = mm\\3\\n\"\n+            );\n+            UNIT_ASSERT_VALUES_EQUAL(posting, \n+                \"__ydb_parent = 41, key = 14, embedding = \\x65\\x65\\3, data = 1-four\\n\"\n+                \"__ydb_parent = 41, key = 15, embedding = \\x75\\x75\\3, data = 1-five\\n\"\n+                \"__ydb_parent = 42, key = 11, embedding = \\x30\\x30\\3, data = 1-one\\n\"\n+                \"__ydb_parent = 42, key = 12, embedding = \\x31\\x31\\3, data = 1-two\\n\"\n+                \"__ydb_parent = 42, key = 13, embedding = \\x32\\x32\\3, data = 1-three\\n\"\n+\n+                \"__ydb_parent = 44, key = 21, embedding = \\x30\\x30\\3, data = 2-one\\n\"\n+                \"__ydb_parent = 44, key = 22, embedding = \\x31\\x31\\3, data = 2-two\\n\"\n+                \"__ydb_parent = 44, key = 23, embedding = \\x32\\x32\\3, data = 2-three\\n\"\n+                \"__ydb_parent = 45, key = 24, embedding = \\x65\\x65\\3, data = 2-four\\n\"\n+                \"__ydb_parent = 45, key = 25, embedding = \\x75\\x75\\3, data = 2-five\\n\"\n+            );\n+            recreate();\n+        }\n+\n+        seed = 111;\n+        for (auto distance : {VectorIndexSettings::DISTANCE_MANHATTAN, VectorIndexSettings::DISTANCE_EUCLIDEAN}) {\n+            auto [level, posting] = DoPrefixKMeans(server, sender, 40, seed, k,\n+                                                  NKikimrTxDataShard::TEvLocalKMeansRequest::UPLOAD_BUILD_TO_BUILD,\n+                                                  VectorIndexSettings::VECTOR_TYPE_UINT8, distance);\n+            UNIT_ASSERT_VALUES_EQUAL(level, \n+                \"__ydb_parent = 40, __ydb_id = 41, __ydb_centroid = 11\\3\\n\"\n+                \"__ydb_parent = 40, __ydb_id = 42, __ydb_centroid = mm\\3\\n\"\n+\n+                \"__ydb_parent = 43, __ydb_id = 44, __ydb_centroid = 11\\3\\n\"\n+                \"__ydb_parent = 43, __ydb_id = 45, __ydb_centroid = mm\\3\\n\"\n+            );\n+            UNIT_ASSERT_VALUES_EQUAL(posting, \n+                \"__ydb_parent = 41, key = 11, embedding = \\x30\\x30\\3, data = 1-one\\n\"\n+                \"__ydb_parent = 41, key = 12, embedding = \\x31\\x31\\3, data = 1-two\\n\"\n+                \"__ydb_parent = 41, key = 13, embedding = \\x32\\x32\\3, data = 1-three\\n\"\n+                \"__ydb_parent = 42, key = 14, embedding = \\x65\\x65\\3, data = 1-four\\n\"\n+                \"__ydb_parent = 42, key = 15, embedding = \\x75\\x75\\3, data = 1-five\\n\"\n+\n+                \"__ydb_parent = 44, key = 21, embedding = \\x30\\x30\\3, data = 2-one\\n\"\n+                \"__ydb_parent = 44, key = 22, embedding = \\x31\\x31\\3, data = 2-two\\n\"\n+                \"__ydb_parent = 44, key = 23, embedding = \\x32\\x32\\3, data = 2-three\\n\"\n+                \"__ydb_parent = 45, key = 24, embedding = \\x65\\x65\\3, data = 2-four\\n\"\n+                \"__ydb_parent = 45, key = 25, embedding = \\x75\\x75\\3, data = 2-five\\n\"\n+            );\n+            recreate();\n+        }\n+        seed = 32;\n+        for (auto similarity : {VectorIndexSettings::SIMILARITY_INNER_PRODUCT, VectorIndexSettings::SIMILARITY_COSINE,\n+                                VectorIndexSettings::DISTANCE_COSINE})\n+        {\n+            auto [level, posting] = DoPrefixKMeans(server, sender, 40, seed, k,\n+                                                  NKikimrTxDataShard::TEvLocalKMeansRequest::UPLOAD_BUILD_TO_BUILD,\n+                                                  VectorIndexSettings::VECTOR_TYPE_UINT8, similarity);\n+            UNIT_ASSERT_VALUES_EQUAL(level, \n+                \"__ydb_parent = 40, __ydb_id = 41, __ydb_centroid = II\\3\\n\"\n+\n+                \"__ydb_parent = 43, __ydb_id = 44, __ydb_centroid = II\\3\\n\"\n+            );\n+            UNIT_ASSERT_VALUES_EQUAL(posting, \n+                \"__ydb_parent = 41, key = 11, embedding = \\x30\\x30\\3, data = 1-one\\n\"\n+                \"__ydb_parent = 41, key = 12, embedding = \\x31\\x31\\3, data = 1-two\\n\"\n+                \"__ydb_parent = 41, key = 13, embedding = \\x32\\x32\\3, data = 1-three\\n\"\n+                \"__ydb_parent = 41, key = 14, embedding = \\x65\\x65\\3, data = 1-four\\n\"\n+                \"__ydb_parent = 41, key = 15, embedding = \\x75\\x75\\3, data = 1-five\\n\"\n+\n+                \"__ydb_parent = 44, key = 21, embedding = \\x30\\x30\\3, data = 2-one\\n\"\n+                \"__ydb_parent = 44, key = 22, embedding = \\x31\\x31\\3, data = 2-two\\n\"\n+                \"__ydb_parent = 44, key = 23, embedding = \\x32\\x32\\3, data = 2-three\\n\"\n+                \"__ydb_parent = 44, key = 24, embedding = \\x65\\x65\\3, data = 2-four\\n\"\n+                \"__ydb_parent = 44, key = 25, embedding = \\x75\\x75\\3, data = 2-five\\n\"\n+            );\n+            recreate();\n+        }\n+    }\n+}\n+\n+}\ndiff --git a/ydb/core/tx/datashard/datashard_ut_read_iterator.cpp b/ydb/core/tx/datashard/datashard_ut_read_iterator.cpp\nindex 252e414d895d..2eb7e5bf5ef1 100644\n--- a/ydb/core/tx/datashard/datashard_ut_read_iterator.cpp\n+++ b/ydb/core/tx/datashard/datashard_ut_read_iterator.cpp\n@@ -2570,16 +2570,19 @@ Y_UNIT_TEST_SUITE(DataShardReadIterator) {\n         });\n     }\n \n-    Y_UNIT_TEST(ShouldReadFromHeadWithConflict) {\n+    Y_UNIT_TEST_TWIN(ShouldReadFromHeadWithConflict, UseSink) {\n         // Similar to ShouldReadFromHead, but there is conflicting hanged operation.\n         // We will read all at once thus should not block\n \n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n             // Blocked volatile transactions block reads, disable\n-            .SetEnableDataShardVolatileTransactions(false);\n+            .SetEnableDataShardVolatileTransactions(false)\n+            .SetAppConfig(app);\n \n         const ui64 shardCount = 1;\n         TTestHelper helper(serverSettings, shardCount);\n@@ -2624,7 +2627,7 @@ Y_UNIT_TEST_SUITE(DataShardReadIterator) {\n         }\n     }\n \n-    Y_UNIT_TEST(ShouldReadFromHeadToMvccWithConflict) {\n+    Y_UNIT_TEST_TWIN(ShouldReadFromHeadToMvccWithConflict, UseSink) {\n         // Similar to ShouldProperlyOrderConflictingTransactionsMvcc, but we read HEAD\n         //\n         // In this test HEAD read waits conflicting transaction: first time we read from HEAD and\n@@ -2632,8 +2635,11 @@ Y_UNIT_TEST_SUITE(DataShardReadIterator) {\n \n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n-            .SetUseRealThreads(false);\n+            .SetUseRealThreads(false)\n+            .SetAppConfig(app);\n \n         const ui64 shardCount = 1;\n         TTestHelper helper(serverSettings, shardCount);\n@@ -2714,7 +2720,7 @@ Y_UNIT_TEST_SUITE(DataShardReadIterator) {\n         }\n     }\n \n-    Y_UNIT_TEST(ShouldProperlyOrderConflictingTransactionsMvcc) {\n+    Y_UNIT_TEST_TWIN(ShouldProperlyOrderConflictingTransactionsMvcc, UseSink) {\n         // 1. Start read-write multishard transaction: readset will be blocked\n         // to hang transaction. Write is the key we want to read.\n         // 2a. Check that we can read prior blocked step.\n@@ -2727,8 +2733,11 @@ Y_UNIT_TEST_SUITE(DataShardReadIterator) {\n \n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n-            .SetUseRealThreads(false);\n+            .SetUseRealThreads(false)\n+            .SetAppConfig(app);\n \n         const ui64 shardCount = 1;\n         TTestHelper helper(serverSettings, shardCount);\n@@ -3705,7 +3714,16 @@ Y_UNIT_TEST_SUITE(DataShardReadIterator) {\n         // 2. tx2: upsert into range2 > range1 range and commit.\n         // 3. tx1: read range2 -> lock should be broken\n \n-        TTestHelper helper;\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(EvWrite);\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings\n+            .SetDomainName(\"Root\")\n+            .SetUseRealThreads(false)\n+            .SetAppConfig(app);\n+\n+        TTestHelper helper(serverSettings);\n \n         auto readVersion = CreateVolatileSnapshot(\n             helper.Server,\n@@ -3724,9 +3742,6 @@ Y_UNIT_TEST_SUITE(DataShardReadIterator) {\n         UNIT_ASSERT_VALUES_EQUAL(readResult1->Record.TxLocksSize(), 1);\n         UNIT_ASSERT_VALUES_EQUAL(readResult1->Record.BrokenTxLocksSize(), 0);\n \n-        auto rows = EvWrite ? TEvWriteRows{{{300, 0, 0, 3000}}} : TEvWriteRows{};\n-        auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(*helper.Server->GetRuntime(), rows);\n-\n         // write new data above snapshot\n         ExecSQL(helper.Server, helper.Sender, R\"(\n             SELECT * FROM `/Root/table-1` WHERE key1 == 300;\ndiff --git a/ydb/core/tx/datashard/datashard_ut_replication.cpp b/ydb/core/tx/datashard/datashard_ut_replication.cpp\nindex 2334ad48bd01..76dc29c026b2 100644\n--- a/ydb/core/tx/datashard/datashard_ut_replication.cpp\n+++ b/ydb/core/tx/datashard/datashard_ut_replication.cpp\n@@ -228,11 +228,14 @@ Y_UNIT_TEST_SUITE(DataShardReplication) {\n         DoSplitMergeChanges(true);\n     }\n \n-    Y_UNIT_TEST(ReplicatedTable) {\n+    Y_UNIT_TEST_TWIN(ReplicatedTable, UseSink) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n-            .SetUseRealThreads(false);\n+            .SetUseRealThreads(false)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -244,8 +247,13 @@ Y_UNIT_TEST_SUITE(DataShardReplication) {\n         CreateShardedTable(server, sender, \"/Root\", \"table-1\", TShardedTableOptions().Replicated(true));\n \n         ExecSQL(server, sender, \"SELECT * FROM `/Root/table-1`\");\n-        ExecSQL(server, sender, \"INSERT INTO `/Root/table-1` (key, value) VALUES (1, 10);\", true,\n-            Ydb::StatusIds::GENERIC_ERROR);\n+        if (UseSink) {\n+            ExecSQL(server, sender, \"INSERT INTO `/Root/table-1` (key, value) VALUES (1, 10);\", true,\n+                Ydb::StatusIds::BAD_REQUEST);\n+        } else {\n+            ExecSQL(server, sender, \"INSERT INTO `/Root/table-1` (key, value) VALUES (1, 10);\", true,\n+                Ydb::StatusIds::GENERIC_ERROR);\n+        }\n \n         WaitTxNotification(server, sender, AsyncAlterDropReplicationConfig(server, \"/Root\", \"table-1\"));\n         ExecSQL(server, sender, \"INSERT INTO `/Root/table-1` (key, value) VALUES (1, 10);\");\ndiff --git a/ydb/core/tx/datashard/datashard_ut_rs.cpp b/ydb/core/tx/datashard/datashard_ut_rs.cpp\nindex b15784d66c22..e7d0c3765ee7 100644\n--- a/ydb/core/tx/datashard/datashard_ut_rs.cpp\n+++ b/ydb/core/tx/datashard/datashard_ut_rs.cpp\n@@ -63,13 +63,16 @@ struct IsReadSet {\n };\n \n Y_UNIT_TEST_SUITE(TDataShardRSTest) {\n-    Y_UNIT_TEST(TestCleanupInRS) {\n+    Y_UNIT_TEST_TWIN(TestCleanupInRS, UseSink) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n             // Volatile transactions avoid storing readsets in InReadSets table\n-            .SetEnableDataShardVolatileTransactions(false);\n+            .SetEnableDataShardVolatileTransactions(false)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\ndiff --git a/ydb/core/tx/datashard/datashard_ut_snapshot.cpp b/ydb/core/tx/datashard/datashard_ut_snapshot.cpp\nindex 1b3a3454569b..011487a1973b 100644\n--- a/ydb/core/tx/datashard/datashard_ut_snapshot.cpp\n+++ b/ydb/core/tx/datashard/datashard_ut_snapshot.cpp\n@@ -1278,6 +1278,56 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n                     }\n                     break;\n                 }\n+                case NKikimr::NEvents::TDataEvents::TEvWrite::EventType: {\n+                    auto& record = ev->Get<NKikimr::NEvents::TDataEvents::TEvWrite>()->Record;\n+                    Cerr << \"TEvWrite:\" << Endl;\n+                    Cerr << record.DebugString() << Endl;\n+                    if (InjectClearTasks) {\n+                        record.ClearOperations();\n+                    }\n+                    if (InjectLocks) {\n+                        auto* protoLocks = record.MutableLocks();\n+                        protoLocks->SetOp(InjectLocks->Op);\n+                        protoLocks->ClearLocks();\n+                        TSet<ui64> shards;\n+                        for (auto& lock : InjectLocks->Locks) {\n+                            auto* protoLock = protoLocks->AddLocks();\n+                            protoLock->SetLockId(lock.LockId);\n+                            protoLock->SetDataShard(lock.DataShard);\n+                            protoLock->SetGeneration(lock.Generation);\n+                            protoLock->SetCounter(lock.Counter);\n+                            protoLock->SetSchemeShard(lock.SchemeShard);\n+                            protoLock->SetPathId(lock.PathId);\n+                            shards.insert(lock.DataShard);\n+                        }\n+                        protoLocks->ClearSendingShards();\n+                        for (ui64 shard : shards) {\n+                            protoLocks->AddSendingShards(shard);\n+                            protoLocks->AddReceivingShards(shard);\n+                        }\n+                        Cerr << \"TEvWrite: injected Locks\" << Endl;\n+                    }\n+                    Last = {};\n+                    if (record.GetLockTxId()) {\n+                        Last.LockId = record.GetLockTxId();\n+                        Last.LockNodeId = record.GetLockNodeId();\n+                    } else if (Inject.LockId) {\n+                        record.SetLockTxId(Inject.LockId);\n+                        if (Inject.LockNodeId) {\n+                            record.SetLockNodeId(Inject.LockNodeId);\n+                        }\n+                        Cerr << \"TEvWrite: injected LockId\" << Endl;\n+                    }\n+                    if (record.HasMvccSnapshot()) {\n+                        Last.MvccSnapshot.Step = record.GetMvccSnapshot().GetStep();\n+                        Last.MvccSnapshot.TxId = record.GetMvccSnapshot().GetTxId();\n+                    } else if (Inject.MvccSnapshot) {\n+                        record.MutableMvccSnapshot()->SetStep(Inject.MvccSnapshot.Step);\n+                        record.MutableMvccSnapshot()->SetTxId(Inject.MvccSnapshot.TxId);\n+                        Cerr << \"TEvWrite: injected MvccSnapshot\" << Endl;\n+                    }\n+                    break;\n+                }\n                 case TEvDataShard::TEvProposeTransactionResult::EventType: {\n                     auto& record = ev->Get<TEvDataShard::TEvProposeTransactionResult>()->Record;\n                     Cerr << \"TEvProposeTransactionResult:\" << Endl;\n@@ -1294,6 +1344,22 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n                     }\n                     break;\n                 }\n+                case NKikimr::NEvents::TDataEvents::TEvWriteResult::EventType: {\n+                    auto& record = ev->Get<NKikimr::NEvents::TDataEvents::TEvWriteResult>()->Record;\n+                    Cerr << \"TEvWriteResult:\" << Endl;\n+                    Cerr << record.DebugString() << Endl;\n+                    LastLocks.clear();\n+                    for (auto& protoLock : record.GetTxLocks()) {\n+                        auto& lock = LastLocks.emplace_back();\n+                        lock.LockId = protoLock.GetLockId();\n+                        lock.DataShard = protoLock.GetDataShard();\n+                        lock.Generation = protoLock.GetGeneration();\n+                        lock.Counter = protoLock.GetCounter();\n+                        lock.SchemeShard = protoLock.GetSchemeShard();\n+                        lock.PathId = protoLock.GetPathId();\n+                    }\n+                    break;\n+                }\n                 case TEvTxProcessing::TEvReadSet::EventType: {\n                     if (BlockReadSets) {\n                         Cerr << \"... blocked TEvReadSet\" << Endl;\n@@ -1337,15 +1403,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n         TVector<THolder<IEventHandle>> BlockedApplyRecords;\n     };\n \n-    Y_UNIT_TEST(MvccSnapshotLockedWrites) {\n+    Y_UNIT_TEST_TWIN(MvccSnapshotLockedWrites, UseSink) {\n         TPortManager pm;\n         TServerSettings::TControls controls;\n         controls.MutableDataShardControls()->SetEnableLockedWrites(1);\n \n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetControls(controls);\n+            .SetControls(controls)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -1429,15 +1498,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n             \"{ items { uint32_value: 3 } items { uint32_value: 3 } }\");\n     }\n \n-    Y_UNIT_TEST(MvccSnapshotLockedWritesRestart) {\n+    Y_UNIT_TEST_TWIN(MvccSnapshotLockedWritesRestart, UseSink) {\n         TPortManager pm;\n         TServerSettings::TControls controls;\n         controls.MutableDataShardControls()->SetEnableLockedWrites(1);\n \n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetControls(controls);\n+            .SetControls(controls)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -1528,15 +1600,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n             \"{ items { uint32_value: 3 } items { uint32_value: 3 } }\");\n     }\n \n-    Y_UNIT_TEST(MvccSnapshotLockedWritesWithoutConflicts) {\n+    Y_UNIT_TEST_TWIN(MvccSnapshotLockedWritesWithoutConflicts, UseSink) {\n         TPortManager pm;\n         TServerSettings::TControls controls;\n         controls.MutableDataShardControls()->SetEnableLockedWrites(1);\n \n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetControls(controls);\n+            .SetControls(controls)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -1655,15 +1730,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n             \"ERROR: ABORTED\");\n     }\n \n-    Y_UNIT_TEST(MvccSnapshotLockedWritesWithConflicts) {\n+    Y_UNIT_TEST_TWIN(MvccSnapshotLockedWritesWithConflicts, UseSink) {\n         TPortManager pm;\n         TServerSettings::TControls controls;\n         controls.MutableDataShardControls()->SetEnableLockedWrites(1);\n \n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetControls(controls);\n+            .SetControls(controls)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -1818,15 +1896,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n         return builder;\n     }\n \n-    Y_UNIT_TEST(MvccSnapshotReadLockedWrites) {\n+    Y_UNIT_TEST_TWIN(MvccSnapshotReadLockedWrites, UseSink) {\n         TPortManager pm;\n         TServerSettings::TControls controls;\n         controls.MutableDataShardControls()->SetEnableLockedWrites(1);\n \n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetControls(controls);\n+            .SetControls(controls)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -2118,15 +2199,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n         observer.Inject = {};\n     }\n \n-    Y_UNIT_TEST(LockedWriteBulkUpsertConflict) {\n+    Y_UNIT_TEST_TWIN(LockedWriteBulkUpsertConflict, UseSink) {\n         TPortManager pm;\n         TServerSettings::TControls controls;\n         controls.MutableDataShardControls()->SetEnableLockedWrites(1);\n \n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetControls(controls);\n+            .SetControls(controls)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -2214,15 +2298,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n         observer.InjectLocks.reset();\n     }\n \n-    Y_UNIT_TEST(LockedWriteReuseAfterCommit) {\n+    Y_UNIT_TEST_TWIN(LockedWriteReuseAfterCommit, UseSink) {\n         TPortManager pm;\n         TServerSettings::TControls controls;\n         controls.MutableDataShardControls()->SetEnableLockedWrites(1);\n \n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetControls(controls);\n+            .SetControls(controls)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -2297,15 +2384,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n         observer.Inject = {};\n     }\n \n-    Y_UNIT_TEST(LockedWriteDistributedCommitSuccess) {\n+    Y_UNIT_TEST_TWIN(LockedWriteDistributedCommitSuccess, UseSink) {\n         TPortManager pm;\n         TServerSettings::TControls controls;\n         controls.MutableDataShardControls()->SetEnableLockedWrites(1);\n \n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetControls(controls);\n+            .SetControls(controls)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -2402,15 +2492,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n \n     }\n \n-    Y_UNIT_TEST(LockedWriteDistributedCommitAborted) {\n+    Y_UNIT_TEST_TWIN(LockedWriteDistributedCommitAborted, UseSink) {\n         TPortManager pm;\n         TServerSettings::TControls controls;\n         controls.MutableDataShardControls()->SetEnableLockedWrites(1);\n \n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetControls(controls);\n+            .SetControls(controls)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -2512,15 +2605,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n             \"{ items { uint32_value: 20 } items { uint32_value: 22 } }\");\n     }\n \n-    Y_UNIT_TEST(LockedWriteDistributedCommitFreeze) {\n+    Y_UNIT_TEST_TWIN(LockedWriteDistributedCommitFreeze, UseSink) {\n         TPortManager pm;\n         TServerSettings::TControls controls;\n         controls.MutableDataShardControls()->SetEnableLockedWrites(1);\n \n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetControls(controls);\n+            .SetControls(controls)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -2637,15 +2733,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n         }\n     }\n \n-    Y_UNIT_TEST(LockedWriteDistributedCommitCrossConflict) {\n+    Y_UNIT_TEST_TWIN(LockedWriteDistributedCommitCrossConflict, UseSink) {\n         TPortManager pm;\n         TServerSettings::TControls controls;\n         controls.MutableDataShardControls()->SetEnableLockedWrites(1);\n \n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetControls(controls);\n+            .SetControls(controls)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -2817,15 +2916,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n             \"{ items { uint32_value: 30 } items { uint32_value: 21 } }\");\n     }\n \n-    Y_UNIT_TEST(LockedWriteCleanupOnSplit) {\n+    Y_UNIT_TEST_TWIN(LockedWriteCleanupOnSplit, UseSink) {\n         TPortManager pm;\n         TServerSettings::TControls controls;\n         controls.MutableDataShardControls()->SetEnableLockedWrites(1);\n \n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetControls(controls);\n+            .SetControls(controls)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -2912,15 +3014,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n         }\n     }\n \n-    Y_UNIT_TEST(LockedWriteCleanupOnCopyTable) {\n+    Y_UNIT_TEST_TWIN(LockedWriteCleanupOnCopyTable, UseSink) {\n         TPortManager pm;\n         TServerSettings::TControls controls;\n         controls.MutableDataShardControls()->SetEnableLockedWrites(1);\n \n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetControls(controls);\n+            .SetControls(controls)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -3032,15 +3137,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n             \"{ items { uint32_value: 1 } items { uint32_value: 1 } }\");\n     }\n \n-    Y_UNIT_TEST_TWIN(LockedWriteWithAsyncIndex, WithRestart) {\n+    Y_UNIT_TEST_QUAD(LockedWriteWithAsyncIndex, WithRestart, UseSink) {\n         TPortManager pm;\n         TServerSettings::TControls controls;\n         controls.MutableDataShardControls()->SetEnableLockedWrites(1);\n \n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetControls(controls);\n+            .SetControls(controls)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -3165,16 +3273,19 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n         observer.InjectLocks.reset();\n     }\n \n-    Y_UNIT_TEST(LockedWritesLimitedPerKey) {\n+    Y_UNIT_TEST_TWIN(LockedWritesLimitedPerKey, UseSink) {\n         TPortManager pm;\n         TServerSettings::TControls controls;\n         controls.MutableDataShardControls()->SetEnableLockedWrites(1);\n         controls.MutableDataShardControls()->SetMaxLockedWritesPerKey(2);\n \n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetControls(controls);\n+            .SetControls(controls)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -3244,7 +3355,7 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n             KqpSimpleExec(runtime, Q_(R\"(\n                 UPSERT INTO `/Root/table-1` (key, value) VALUES (2, 23)\n                 )\")),\n-            \"ERROR: GENERIC_ERROR\");\n+            UseSink ? \"ERROR: INTERNAL_ERROR\" : \"ERROR: GENERIC_ERROR\");\n         observer.Inject = {};\n \n         // Abort tx 234, this would allow adding one more change to key 2\n@@ -3358,15 +3469,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n             \"ERROR: WrongRequest\\n\");\n     }\n \n-    Y_UNIT_TEST(LockedWriteWithAsyncIndexAndVolatileCommit) {\n+    Y_UNIT_TEST_TWIN(LockedWriteWithAsyncIndexAndVolatileCommit, UseSink) {\n         TPortManager pm;\n         TServerSettings::TControls controls;\n         controls.MutableDataShardControls()->SetEnableLockedWrites(1);\n \n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetControls(controls);\n+            .SetControls(controls)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -3492,15 +3606,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n             \"{ items { uint32_value: 20 } items { uint32_value: 210 } }\");\n     }\n \n-    Y_UNIT_TEST(LockedWriteWithPendingVolatileCommit) {\n+    Y_UNIT_TEST_TWIN(LockedWriteWithPendingVolatileCommit, UseSink) {\n         TServerSettings::TControls controls;\n         controls.MutableDataShardControls()->SetEnableLockedWrites(1);\n \n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetControls(controls);\n+            .SetControls(controls)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -5084,19 +5201,25 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n             \"{ items { int32_value: 2 } items { int32_value: 20 } }\");\n     }\n \n-    Y_UNIT_TEST(UncommittedChangesRenameTable) {\n+    Y_UNIT_TEST_TWIN(UncommittedChangesRenameTable, UseSink) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n             .SetDomainPlanResolution(100)\n-            .SetEnableDataShardVolatileTransactions(true);\n+            .SetEnableDataShardVolatileTransactions(true)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n         auto sender = runtime.AllocateEdgeActor();\n \n         runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_TRACE);\n+        runtime.SetLogPriority(NKikimrServices::KQP_COMPUTE, NLog::PRI_DEBUG);\n+        runtime.SetLogPriority(NKikimrServices::KQP_EXECUTER, NLog::PRI_DEBUG);\n+        runtime.SetLogPriority(NKikimrServices::KQP_SESSION, NLog::PRI_DEBUG);\n \n         InitRoot(server, sender);\n \n@@ -5444,12 +5567,15 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n             \"{ items { uint32_value: 6 } items { uint32_value: 66 } }\");\n     }\n \n-    Y_UNIT_TEST(ShardRestartLockNotBrokenByUncommittedBeforeRead) {\n+    Y_UNIT_TEST_TWIN(ShardRestartLockNotBrokenByUncommittedBeforeRead, UseSink) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetDomainPlanResolution(100);\n+            .SetDomainPlanResolution(100)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -5513,12 +5639,15 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n             \"{ items { uint32_value: 6 } items { uint32_value: 66 } }\");\n     }\n \n-    Y_UNIT_TEST(ShardRestartLockBrokenByUncommittedBeforeRead) {\n+    Y_UNIT_TEST_TWIN(ShardRestartLockBrokenByUncommittedBeforeRead, UseSink) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetDomainPlanResolution(100);\n+            .SetDomainPlanResolution(100)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -5582,12 +5711,15 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n     }\n \n \n-    Y_UNIT_TEST(ShardRestartLockNotBrokenByUncommittedAfterRead) {\n+    Y_UNIT_TEST_TWIN(ShardRestartLockNotBrokenByUncommittedAfterRead, UseSink) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetDomainPlanResolution(100);\n+            .SetDomainPlanResolution(100)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -5651,12 +5783,15 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n             \"{ items { uint32_value: 6 } items { uint32_value: 66 } }\");\n     }\n \n-    Y_UNIT_TEST(ShardRestartLockBrokenByUncommittedAfterRead) {\n+    Y_UNIT_TEST_TWIN(ShardRestartLockBrokenByUncommittedAfterRead, UseSink) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetDomainPlanResolution(100);\n+            .SetDomainPlanResolution(100)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -5735,9 +5870,6 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {\n         TBlockEvents<TEvMediatorTimecast::TEvGranularUpdate> blockGranularUpdate(runtime);\n \n         runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_TRACE);\n-        runtime.SetLogPriority(NKikimrServices::TX_PROXY, NLog::PRI_DEBUG);\n-        runtime.SetLogPriority(NKikimrServices::KQP_EXECUTER, NLog::PRI_TRACE);\n-        runtime.SetLogPriority(NKikimrServices::KQP_SESSION, NLog::PRI_TRACE);\n \n         InitRoot(server, sender);\n \ndiff --git a/ydb/core/tx/datashard/datashard_ut_trace.cpp b/ydb/core/tx/datashard/datashard_ut_trace.cpp\nindex 5b593c5b7fc4..0f7ac5d09bc2 100644\n--- a/ydb/core/tx/datashard/datashard_ut_trace.cpp\n+++ b/ydb/core/tx/datashard/datashard_ut_trace.cpp\n@@ -48,11 +48,16 @@ Y_UNIT_TEST_SUITE(TDataShardTrace) {\n         UNIT_ASSERT(tablets.size() == 2);\n     }\n \n-    std::tuple<TTestActorRuntime&, Tests::TServer::TPtr, TActorId> TestCreateServer() {\n+    std::tuple<TTestActorRuntime&, Tests::TServer::TPtr, TActorId> TestCreateServer(std::optional<bool> useSink = std::nullopt) {\n         TPortManager pm;\n+        NKikimrConfig::TAppConfig appConfig;\n+        if (useSink) {\n+            appConfig.MutableTableServiceConfig()->SetEnableOltpSink(*useSink);\n+        }\n         TServerSettings serverSettings(pm.GetPort(2134));\n         serverSettings.SetDomainName(\"Root\")\n-            .SetUseRealThreads(false);\n+            .SetUseRealThreads(false)\n+            .SetAppConfig(appConfig);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -203,8 +208,8 @@ Y_UNIT_TEST_SUITE(TDataShardTrace) {\n         UNIT_ASSERT_VALUES_EQUAL(count, unitSpans.size());\n     }\n \n-    Y_UNIT_TEST(TestTraceDistributedUpsert) {\n-        auto [runtime, server, sender] = TestCreateServer();\n+    Y_UNIT_TEST_TWIN(TestTraceDistributedUpsert, UseSink) {\n+        auto [runtime, server, sender] = TestCreateServer(UseSink);\n \n         CreateShardedTable(server, sender, \"/Root\", \"table-1\", 1, false);\n \n@@ -231,54 +236,108 @@ Y_UNIT_TEST_SUITE(TDataShardTrace) {\n \n         TFakeWilsonUploader::Trace &trace = uploader->Traces.begin()->second;\n \n-        auto deSpan = trace.Root.BFSFindOne(\"DataExecuter\");\n-        UNIT_ASSERT(deSpan);\n+        Cerr << \"Trace: \" << trace.ToString() << Endl;\n+\n+        if (!UseSink) {\n+            auto deSpan = trace.Root.BFSFindOne(\"DataExecuter\");\n+            UNIT_ASSERT(deSpan);\n+            auto dsTxSpans = deSpan->get().FindAll(\"Datashard.Transaction\");\n+            UNIT_ASSERT_VALUES_EQUAL(2, dsTxSpans.size()); // Two shards, each executes a user transaction.\n \n-        auto dsTxSpans = deSpan->get().FindAll(\"Datashard.Transaction\");\n-        UNIT_ASSERT_VALUES_EQUAL(2, dsTxSpans.size()); // Two shards, each executes a user transaction.\n+            for (auto dsTxSpan : dsTxSpans) {\n+                auto tabletTxs = dsTxSpan.get().FindAll(\"Tablet.Transaction\");\n+                UNIT_ASSERT_VALUES_EQUAL(2, tabletTxs.size()); // Each shard executes a proposal tablet tx and a progress tablet tx.\n \n-        for (auto dsTxSpan : dsTxSpans) {\n-            auto tabletTxs = dsTxSpan.get().FindAll(\"Tablet.Transaction\");\n-            UNIT_ASSERT_VALUES_EQUAL(2, tabletTxs.size()); // Each shard executes a proposal tablet tx and a progress tablet tx.\n+                auto propose = tabletTxs[0];\n+                // Note: when volatile transactions are enabled propose doesn't persist anything\n+                if (!usesVolatileTxs) {\n+                    CheckTxHasWriteLog(propose);\n+                }\n+                CheckTxHasDatashardUnits(propose, 3);\n \n-            auto propose = tabletTxs[0];\n-            // Note: when volatile transactions are enabled propose doesn't persist anything\n-            if (!usesVolatileTxs) {\n-                CheckTxHasWriteLog(propose);\n+                auto progress = tabletTxs[1];\n+                CheckTxHasWriteLog(progress);\n+                CheckTxHasDatashardUnits(progress, usesVolatileTxs ? 6 : 11);\n             }\n-            CheckTxHasDatashardUnits(propose, 3);\n \n-            auto progress = tabletTxs[1];\n-            CheckTxHasWriteLog(progress);\n-            CheckTxHasDatashardUnits(progress, usesVolatileTxs ? 6 : 11);\n-        }\n+            std::string canon = ExpectedSpan(\"Session.query.QUERY_ACTION_EXECUTE\",\n+                ExpectedSpan(\"CompileService\", \"CompileActor\"),\n+                \"LiteralExecuter\",\n+                ExpectedSpan(\"DataExecuter\",\n+                    \"WaitForTableResolve\",\n+                    \"RunTasks\",\n+                    Repeat(\n+                        ExpectedSpan(\"Datashard.Transaction\",\n+                            ExpectedSpan(\"Tablet.Transaction\",\n+                                ExpectedSpan(\"Tablet.Transaction.Execute\",\n+                                    Repeat(\"Datashard.Unit\", 3)),\n+                                Conditional(!usesVolatileTxs,\n+                                    ExpectedSpan(\"Tablet.WriteLog\", \"Tablet.WriteLog.LogEntry\")),\n+                                \"Tablet.Transaction.Complete\"),\n+                            Conditional(usesVolatileTxs, \"Datashard.SendWithConfirmedReadOnlyLease\"),\n+                            ExpectedSpan(\"Tablet.Transaction\",\n+                                ExpectedSpan(\"Tablet.Transaction.Execute\",\n+                                    Repeat(\"Datashard.Unit\", usesVolatileTxs ? 6 : 11)),\n+                                ExpectedSpan(\"Tablet.WriteLog\",\n+                                    \"Tablet.WriteLog.LogEntry\"),\n+                                \"Tablet.Transaction.Complete\"),\n+                            \"Datashard.SendResult\"),\n+                        2)))\n+                .ToString();\n+\n+            UNIT_ASSERT_VALUES_EQUAL(trace.ToString(), canon);\n+        } else {\n+            auto commitSpan = trace.Root.BFSFindOne(\"Commit\");\n+            UNIT_ASSERT(commitSpan);\n+            auto dsTxSpans = commitSpan->get().FindAll(\"Datashard.WriteTransaction\");\n+            UNIT_ASSERT_VALUES_EQUAL(2, dsTxSpans.size()); // Two shards, each executes a user transaction.\n+\n+            for (auto dsTxSpan : dsTxSpans) {\n+                auto tabletTxs = dsTxSpan.get().FindAll(\"Tablet.Transaction\");\n+                UNIT_ASSERT_VALUES_EQUAL(2, tabletTxs.size()); // Each shard executes a proposal tablet tx and a progress tablet tx.\n+\n+                auto propose = tabletTxs[0];\n+                // Note: when volatile transactions are enabled propose doesn't persist anything\n+                if (!usesVolatileTxs) {\n+                    CheckTxHasWriteLog(propose);\n+                }\n+                CheckTxHasDatashardUnits(propose, 3);\n \n-        std::string canon = ExpectedSpan(\"Session.query.QUERY_ACTION_EXECUTE\",\n-            ExpectedSpan(\"CompileService\", \"CompileActor\"),\n-            \"LiteralExecuter\",\n-            ExpectedSpan(\"DataExecuter\",\n-                \"WaitForTableResolve\",\n-                \"RunTasks\",\n-                Repeat(\n-                    ExpectedSpan(\"Datashard.Transaction\",\n-                        ExpectedSpan(\"Tablet.Transaction\",\n-                            ExpectedSpan(\"Tablet.Transaction.Execute\",\n-                                Repeat(\"Datashard.Unit\", 3)),\n-                            Conditional(!usesVolatileTxs,\n-                                ExpectedSpan(\"Tablet.WriteLog\", \"Tablet.WriteLog.LogEntry\")),\n-                            \"Tablet.Transaction.Complete\"),\n-                        Conditional(usesVolatileTxs, \"Datashard.SendWithConfirmedReadOnlyLease\"),\n-                        ExpectedSpan(\"Tablet.Transaction\",\n-                            ExpectedSpan(\"Tablet.Transaction.Execute\",\n-                                Repeat(\"Datashard.Unit\", usesVolatileTxs ? 6 : 11)),\n-                            ExpectedSpan(\"Tablet.WriteLog\",\n-                                \"Tablet.WriteLog.LogEntry\"),\n-                            \"Tablet.Transaction.Complete\"),\n-                        \"Datashard.SendResult\"),\n-                    2)))\n-            .ToString();\n+                auto progress = tabletTxs[1];\n+                CheckTxHasWriteLog(progress);\n+                CheckTxHasDatashardUnits(progress, usesVolatileTxs ? 6 : 11);\n+            }\n \n-        UNIT_ASSERT_VALUES_EQUAL(trace.ToString(), canon);\n+            std::string canon = ExpectedSpan(\"Session.query.QUERY_ACTION_EXECUTE\",\n+                ExpectedSpan(\"CompileService\", \"CompileActor\"),\n+                ExpectedSpan(\"DataExecuter\",\n+                    \"WaitForTableResolve\",\n+                    ExpectedSpan(\"ComputeActor\",\n+                        Repeat((\"ForwardWriteActor\"), 1)),\n+                    \"RunTasks\",\n+                    ExpectedSpan(\n+                        \"Commit\",\n+                        Repeat(\n+                            ExpectedSpan(\"Datashard.WriteTransaction\",\n+                                ExpectedSpan(\"Tablet.Transaction\",\n+                                    ExpectedSpan(\"Tablet.Transaction.Execute\",\n+                                        Repeat(\"Datashard.Unit\", 3)),\n+                                    Conditional(!usesVolatileTxs,\n+                                        ExpectedSpan(\"Tablet.WriteLog\", \"Tablet.WriteLog.LogEntry\")),\n+                                    \"Tablet.Transaction.Complete\"),\n+                                Conditional(usesVolatileTxs, \"Datashard.SendWithConfirmedReadOnlyLease\"),\n+                                ExpectedSpan(\"Tablet.Transaction\",\n+                                    ExpectedSpan(\"Tablet.Transaction.Execute\",\n+                                        Repeat(\"Datashard.Unit\", usesVolatileTxs ? 6 : 11)),\n+                                    ExpectedSpan(\"Tablet.WriteLog\",\n+                                        \"Tablet.WriteLog.LogEntry\"),\n+                                    \"Tablet.Transaction.Complete\"),\n+                                \"Datashard.SendWriteResult\"),\n+                            2))))\n+                .ToString();\n+\n+            UNIT_ASSERT_VALUES_EQUAL(trace.ToString(), canon);\n+        }\n     }\n \n     Y_UNIT_TEST(TestTraceDistributedSelect) {\ndiff --git a/ydb/core/tx/datashard/datashard_ut_volatile.cpp b/ydb/core/tx/datashard/datashard_ut_volatile.cpp\nindex dfc079377292..0af89d12d665 100644\n--- a/ydb/core/tx/datashard/datashard_ut_volatile.cpp\n+++ b/ydb/core/tx/datashard/datashard_ut_volatile.cpp\n@@ -141,12 +141,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n             \"{ items { uint32_value: 10 } items { uint32_value: 10 } }\");\n     }\n \n-    Y_UNIT_TEST(DistributedWriteShardRestartBeforePlan) {\n+    Y_UNIT_TEST_TWIN(DistributedWriteShardRestartBeforePlan, UseSink) {\n+        NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetDomainPlanResolution(1000);\n+            .SetDomainPlanResolution(1000)\n+            .SetAppConfig(appConfig);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -220,12 +223,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n             \"{ items { uint32_value: 10 } items { uint32_value: 10 } }\");\n     }\n \n-    Y_UNIT_TEST(DistributedWriteShardRestartAfterExpectation) {\n+    Y_UNIT_TEST_TWIN(DistributedWriteShardRestartAfterExpectation, UseSink) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetDomainPlanResolution(1000);\n+            .SetDomainPlanResolution(1000)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -384,9 +390,10 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n             \"{ items { uint32_value: 10 } items { uint32_value: 10 } }\");\n     }\n \n-    Y_UNIT_TEST(DistributedWriteLaterSnapshotBlockedThenCommit) {\n+    Y_UNIT_TEST_TWIN(DistributedWriteLaterSnapshotBlockedThenCommit, UseSink) {\n         TPortManager pm;\n         NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         TServerSettings serverSettings(pm.GetPort(2134));\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n@@ -2195,14 +2202,17 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n             \"{ items { uint32_value: 4 } items { uint32_value: 40 } }\");\n     }\n \n-    Y_UNIT_TEST(TwoAppendsMustBeVolatile) {\n+    Y_UNIT_TEST_TWIN(TwoAppendsMustBeVolatile, UseSink) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetNodeCount(2)\n             .SetUseRealThreads(false)\n             .SetDomainPlanResolution(100)\n-            .SetEnableDataShardVolatileTransactions(true);\n+            .SetEnableDataShardVolatileTransactions(true)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -2229,6 +2239,12 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n                 ++volatileTxs;\n             }\n         });\n+        auto proposeObserverEvWrite = runtime.AddObserver<NKikimr::NEvents::TDataEvents::TEvWrite>([&](NKikimr::NEvents::TDataEvents::TEvWrite::TPtr& ev) {\n+            auto* msg = ev->Get();\n+            if (msg->Record.GetTxMode() == NKikimrDataEvents::TEvWrite::MODE_VOLATILE_PREPARE) {\n+                ++volatileTxs;\n+            }\n+        });\n \n         // This simulates a jepsen transaction that appends two values at different shards\n         TString sessionId, txId;\n@@ -2265,13 +2281,16 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n     }\n \n     // Regression test for KIKIMR-21156\n-    Y_UNIT_TEST(VolatileCommitOnBlobStorageFailure) {\n+    Y_UNIT_TEST_TWIN(VolatileCommitOnBlobStorageFailure, UseSink) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n             .SetDomainPlanResolution(1000)\n-            .SetEnableDataShardVolatileTransactions(true);\n+            .SetEnableDataShardVolatileTransactions(true)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -2509,10 +2528,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n                 [this](auto& ev) {\n                     this->OnEvent(ev);\n                 }))\n+            , ObserverEvWrite(runtime.AddObserver<NKikimr::NEvents::TDataEvents::TEvWrite>(\n+                [this](auto& ev) {\n+                    this->OnEvent(ev);\n+                }))\n         {}\n \n         void Remove() {\n             Observer.Remove();\n+            ObserverEvWrite.Remove();\n         }\n \n     private:\n@@ -2577,12 +2601,45 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n             ++Modified;\n         }\n \n+        void OnEvent(NKikimr::NEvents::TDataEvents::TEvWrite::TPtr& ev) {\n+            auto* msg = ev->Get();\n+\n+            if (msg->Record.GetTxMode() != NKikimrDataEvents::TEvWrite::MODE_VOLATILE_PREPARE) {\n+                Cerr << \"... skipping TEvWrite with TxMode=\" << NKikimrDataEvents::TEvWrite_ETxMode_Name(msg->Record.GetTxMode())\n+                    << \"(expected \" << NKikimrDataEvents::TEvWrite_ETxMode_Name(NKikimrDataEvents::TEvWrite::MODE_VOLATILE_PREPARE) << \")\"<< Endl;\n+                return;\n+            }\n+\n+            if (!msg->Record.HasLocks()) {\n+                Cerr << \"... skipping TEvWrite without locks\" << Endl;\n+                return;\n+            }\n+\n+            auto* kqpLocks = msg->Record.MutableLocks();\n+            const auto& sendingShards = kqpLocks->GetSendingShards();\n+            const auto& receivingShards = kqpLocks->GetReceivingShards();\n+\n+            if (std::find(sendingShards.begin(), sendingShards.end(), ArbiterShard) == sendingShards.end()) {\n+                Cerr << \"... skipping TEvWrite without \" << ArbiterShard << \" in sending shards\" << Endl;\n+                return;\n+            }\n+\n+            if (std::find(receivingShards.begin(), receivingShards.end(), ArbiterShard) == receivingShards.end()) {\n+                Cerr << \"... skipping TEvWrite without \" << ArbiterShard << \" in receiving shards\" << Endl;\n+                return;\n+            }\n+\n+            kqpLocks->SetArbiterShard(ArbiterShard);\n+            ++Modified;\n+        }\n+\n     public:\n         size_t Modified = 0;\n \n     private:\n         const ui64 ArbiterShard;\n         TTestActorRuntime::TEventObserverHolder Observer;\n+        TTestActorRuntime::TEventObserverHolder ObserverEvWrite;\n     };\n \n     class TForceBrokenLock {\n@@ -2595,6 +2652,10 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n                 [this](auto& ev) {\n                     this->OnEvent(ev);\n                 }))\n+            , ObserverEvWrite(runtime.AddObserver<NKikimr::NEvents::TDataEvents::TEvWrite>(\n+                [this](auto& ev) {\n+                    this->OnEvent(ev);\n+                }))\n         {}\n \n     private:\n@@ -2659,6 +2720,38 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n             ++Modified;\n         }\n \n+        void OnEvent(NKikimr::NEvents::TDataEvents::TEvWrite::TPtr& ev) {\n+            if (ev->GetRecipientRewrite() != ShardActor) {\n+                return;\n+            }\n+\n+            auto* msg = ev->Get();\n+\n+            if (msg->Record.GetTxMode() != NKikimrDataEvents::TEvWrite::MODE_VOLATILE_PREPARE) {\n+                Cerr << \"... skipping TEvWrite with TxMode=\" << NKikimrDataEvents::TEvWrite_ETxMode_Name(msg->Record.GetTxMode())\n+                    << \"(expected \" << NKikimrDataEvents::TEvWrite_ETxMode_Name(NKikimrDataEvents::TEvWrite::MODE_VOLATILE_PREPARE) << \")\"<< Endl;\n+                return;\n+            }\n+\n+            if (!msg->Record.HasLocks()) {\n+                Cerr << \"... skipping TEvWrite without locks\" << Endl;\n+                return;\n+            }\n+\n+            auto* kqpLocks = msg->Record.MutableLocks();\n+\n+            // We use a lock that should have never existed to simulate a broken lock\n+            auto* kqpLock = kqpLocks->AddLocks();\n+            kqpLock->SetLockId(msg->Record.GetTxId());\n+            kqpLock->SetDataShard(Shard);\n+            kqpLock->SetGeneration(1);\n+            kqpLock->SetCounter(1);\n+            kqpLock->SetSchemeShard(TableId.PathId.OwnerId);\n+            kqpLock->SetPathId(TableId.PathId.LocalPathId);\n+\n+            ++Modified;\n+        }\n+\n     public:\n         size_t Modified = 0;\n \n@@ -2667,6 +2760,7 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n         const ui64 Shard;\n         const TActorId ShardActor;\n         TTestActorRuntime::TEventObserverHolder Observer;\n+        TTestActorRuntime::TEventObserverHolder ObserverEvWrite;\n     };\n \n     class TBlockReadSets : public std::vector<TEvTxProcessing::TEvReadSet::TPtr> {\n@@ -2723,12 +2817,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n         TTestActorRuntime::TEventObserverHolder Observer;\n     };\n \n-    Y_UNIT_TEST(UpsertNoLocksArbiter) {\n+    Y_UNIT_TEST_TWIN(UpsertNoLocksArbiter, UseSink) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetEnableDataShardVolatileTransactions(true);\n+            .SetEnableDataShardVolatileTransactions(true)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -2778,12 +2875,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n             \"{ items { int32_value: 31 } items { int32_value: 311 } }\");\n     }\n \n-    Y_UNIT_TEST(UpsertBrokenLockArbiter) {\n+    Y_UNIT_TEST_TWIN(UpsertBrokenLockArbiter, UseSink) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetEnableDataShardVolatileTransactions(true);\n+            .SetEnableDataShardVolatileTransactions(true)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -2844,12 +2944,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n             \"\");\n     }\n \n-    Y_UNIT_TEST(UpsertNoLocksArbiterRestart) {\n+    Y_UNIT_TEST_TWIN(UpsertNoLocksArbiterRestart, UseSink) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetEnableDataShardVolatileTransactions(true);\n+            .SetEnableDataShardVolatileTransactions(true)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -2916,12 +3019,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n             \"ERROR: UNDETERMINED\");\n     }\n \n-    Y_UNIT_TEST(UpsertBrokenLockArbiterRestart) {\n+    Y_UNIT_TEST_TWIN(UpsertBrokenLockArbiterRestart, UseSink) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetEnableDataShardVolatileTransactions(true);\n+            .SetEnableDataShardVolatileTransactions(true)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -2989,12 +3095,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n             \"ERROR: ABORTED\");\n     }\n \n-    Y_UNIT_TEST(UpsertDependenciesShardsRestart) {\n+    Y_UNIT_TEST_TWIN(UpsertDependenciesShardsRestart, UseSink) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetEnableDataShardVolatileTransactions(true);\n+            .SetEnableDataShardVolatileTransactions(true)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -3079,12 +3188,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n         Cerr << \"... split finished\" << Endl;\n     }\n \n-    Y_UNIT_TEST(DistributedUpsertRestartBeforePrepare) {\n+    Y_UNIT_TEST_TWIN(DistributedUpsertRestartBeforePrepare, UseSink) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetEnableDataShardVolatileTransactions(true);\n+            .SetEnableDataShardVolatileTransactions(true)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -3116,6 +3228,7 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n             \"<empty>\");\n \n         TBlockEvents<TEvDataShard::TEvProposeTransaction> blockedPrepare(runtime);\n+        TBlockEvents<NKikimr::NEvents::TDataEvents::TEvWrite> blockedEvWrite(runtime);\n \n         Cerr << \"========= Starting upsert 1 =========\" << Endl;\n         auto upsertFuture1 = KqpSimpleSend(runtime, R\"(\n@@ -3123,10 +3236,11 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n             VALUES (2, 2), (12, 12);\n             )\");\n \n-        runtime.WaitFor(\"prepare requests\", [&]{ return blockedPrepare.size() >= 2; });\n-        UNIT_ASSERT_VALUES_EQUAL(blockedPrepare.size(), 2u);\n+        runtime.WaitFor(\"prepare requests\", [&]{ return blockedPrepare.size() + blockedEvWrite.size() >= 2; });\n+        UNIT_ASSERT_VALUES_EQUAL(blockedPrepare.size() + blockedEvWrite.size(), 2u);\n \n         blockedPrepare.Stop();\n+        blockedEvWrite.Stop();\n \n         Cerr << \"========= Restarting shard 1 =========\" << Endl;\n         GracefulRestartTablet(runtime, shards.at(0), sender);\n@@ -3136,12 +3250,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n             \"ERROR: UNAVAILABLE\");\n     }\n \n-    Y_UNIT_TEST(DistributedUpsertRestartAfterPrepare) {\n+    Y_UNIT_TEST_TWIN(DistributedUpsertRestartAfterPrepare, UseSink) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetEnableDataShardVolatileTransactions(true);\n+            .SetEnableDataShardVolatileTransactions(true)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -3173,6 +3290,7 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n             \"<empty>\");\n \n         TBlockEvents<TEvDataShard::TEvProposeTransactionResult> blockedPrepare(runtime);\n+        TBlockEvents<NKikimr::NEvents::TDataEvents::TEvWriteResult> blockedEvWrite(runtime);\n \n         Cerr << \"========= Starting upsert 1 =========\" << Endl;\n         auto upsertFuture1 = KqpSimpleSend(runtime, R\"(\n@@ -3180,16 +3298,22 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n             VALUES (2, 2), (12, 12);\n             )\");\n \n-        runtime.WaitFor(\"prepare results\", [&]{ return blockedPrepare.size() >= 2; });\n-        UNIT_ASSERT_VALUES_EQUAL(blockedPrepare.size(), 2u);\n+        runtime.WaitFor(\"prepare results\", [&]{ return blockedPrepare.size() + blockedEvWrite.size() >= 2; });\n+        UNIT_ASSERT_VALUES_EQUAL(blockedPrepare.size() + blockedEvWrite.size(), 2u);\n \n         for (auto& ev : blockedPrepare) {\n             auto* msg = ev->Get();\n             UNIT_ASSERT_VALUES_EQUAL(msg->Record.GetStatus(), NKikimrTxDataShard::TEvProposeTransactionResult::PREPARED);\n         }\n \n+        for (auto& ev : blockedEvWrite) {\n+            auto* msg = ev->Get();\n+            UNIT_ASSERT_VALUES_EQUAL(msg->Record.GetStatus(), NKikimrDataEvents::TEvWriteResult::STATUS_PREPARED);\n+        }\n+\n         // Unblock prepare results and restart the first shard\n         blockedPrepare.Stop().Unblock();\n+        blockedEvWrite.Stop().Unblock();\n \n         Cerr << \"========= Restarting shard 1 =========\" << Endl;\n         GracefulRestartTablet(runtime, shards.at(0), sender);\n@@ -3280,12 +3404,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n     }\n \n     // Regression test for KIKIMR-22506\n-    Y_UNIT_TEST(NotCachingAbortingDeletes) {\n+    Y_UNIT_TEST_TWIN(NotCachingAbortingDeletes, UseSink) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n         serverSettings.SetDomainName(\"Root\")\n             .SetUseRealThreads(false)\n-            .SetEnableDataShardVolatileTransactions(true);\n+            .SetEnableDataShardVolatileTransactions(true)\n+            .SetAppConfig(app);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -3383,6 +3510,14 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n                 }\n                 return true;\n             });\n+        TBlockEvents<NKikimr::NEvents::TDataEvents::TEvWriteResult> blockedEvWriteResults(runtime,\n+            [&](const auto& ev) {\n+                auto* msg = ev->Get();\n+                if (msg->Record.GetStatus() == NKikimrDataEvents::TEvWriteResult::STATUS_PREPARED) {\n+                    return false;\n+                }\n+                return true;\n+            });\n \n         size_t otherReadSets = 0;\n         TBlockEvents<TEvTxProcessing::TEvReadSet> blockedReadSets(runtime,\n@@ -3425,8 +3560,9 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n         Cerr << \"========= Unblocking commits and checking results =========\" << Endl;\n         blockedCommits.Stop().Unblock();\n \n-        runtime.WaitFor(\"both results\", [&]{ return blockedResults.size() >= 2; });\n+        runtime.WaitFor(\"both results\", [&]{ return blockedResults.size() + blockedEvWriteResults.size() >= 2; });\n         blockedResults.Stop().Unblock();\n+        blockedEvWriteResults.Stop().Unblock();\n \n         UNIT_ASSERT_VALUES_EQUAL(\n             FormatResult(runtime.WaitFuture(std::move(commitFuture))),\ndiff --git a/ydb/core/tx/datashard/datashard_ut_write.cpp b/ydb/core/tx/datashard/datashard_ut_write.cpp\nindex 8d2254d68a4b..8852ff8438dc 100644\n--- a/ydb/core/tx/datashard/datashard_ut_write.cpp\n+++ b/ydb/core/tx/datashard/datashard_ut_write.cpp\n@@ -40,14 +40,20 @@ Y_UNIT_TEST_SUITE(DataShardWrite) {\n     }\n \n     Y_UNIT_TEST_TWIN(ExecSQLUpsertImmediate, EvWrite) {\n-        auto [runtime, server, sender] = TestCreateServer();\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(EvWrite);\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings\n+            .SetDomainName(\"Root\")\n+            .SetUseRealThreads(false)\n+            .SetAppConfig(app);\n+\n+        auto [runtime, server, sender] = TestCreateServer(serverSettings);\n \n         TShardedTableOptions opts;\n         auto [shards, tableId] = CreateShardedTable(server, sender, \"/Root\", \"table-1\", opts);\n \n-        auto rows = EvWrite ? TEvWriteRows{{{0, 1}}, {{2, 3}}, {{4, 5}}} : TEvWriteRows{};\n-        auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(runtime, rows);\n-\n         Cout << \"========= Send immediate write =========\\n\";\n         {\n             ExecSQL(server, sender, Q_(\"UPSERT INTO `/Root/table-1` (key, value) VALUES (0, 1);\"));\n@@ -63,7 +69,16 @@ Y_UNIT_TEST_SUITE(DataShardWrite) {\n     }\n \n     Y_UNIT_TEST_QUAD(ExecSQLUpsertPrepared, EvWrite, Volatile) {\n-        auto [runtime, server, sender] = TestCreateServer();\n+        NKikimrConfig::TAppConfig app;\n+        app.MutableTableServiceConfig()->SetEnableOltpSink(EvWrite);\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings\n+            .SetDomainName(\"Root\")\n+            .SetUseRealThreads(false)\n+            .SetAppConfig(app);\n+\n+        auto [runtime, server, sender] = TestCreateServer(serverSettings);\n \n         runtime.GetAppData().FeatureFlags.SetEnableDataShardVolatileTransactions(Volatile);\n \n@@ -71,9 +86,6 @@ Y_UNIT_TEST_SUITE(DataShardWrite) {\n         auto [shards1, tableId1] = CreateShardedTable(server, sender, \"/Root\", \"table-1\", opts);\n         auto [shards2, tableId2] = CreateShardedTable(server, sender, \"/Root\", \"table-2\", opts);\n \n-        auto rows = EvWrite ? TEvWriteRows{{tableId1, {0, 1}}, {tableId2, {2, 3}}} : TEvWriteRows{};\n-        auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(runtime, rows);\n-\n         Cout << \"========= Send distributed write =========\\n\";\n         {\n             ExecSQL(server, sender, Q_(\ndiff --git a/ydb/core/tx/datashard/execute_data_tx_unit.cpp b/ydb/core/tx/datashard/execute_data_tx_unit.cpp\nindex 5d45d8820254..310bf3c539b8 100644\n--- a/ydb/core/tx/datashard/execute_data_tx_unit.cpp\n+++ b/ydb/core/tx/datashard/execute_data_tx_unit.cpp\n@@ -346,7 +346,7 @@ void TExecuteDataTxUnit::ExecuteDataTx(TOperation::TPtr op,\n }\n \n void TExecuteDataTxUnit::AddLocksToResult(TOperation::TPtr op, const TActorContext& ctx) {\n-    auto locks = DataShard.SysLocksTable().ApplyLocks();\n+    auto [locks, _] = DataShard.SysLocksTable().ApplyLocks();\n     for (const auto& lock : locks) {\n         if (lock.IsError()) {\n             LOG_NOTICE_S(TActivationContext::AsActorContext(), NKikimrServices::TX_DATASHARD,\ndiff --git a/ydb/core/tx/datashard/execute_kqp_data_tx_unit.cpp b/ydb/core/tx/datashard/execute_kqp_data_tx_unit.cpp\nindex 8c667b4266b7..7e989238ab3c 100644\n--- a/ydb/core/tx/datashard/execute_kqp_data_tx_unit.cpp\n+++ b/ydb/core/tx/datashard/execute_kqp_data_tx_unit.cpp\n@@ -1,4 +1,5 @@\n #include \"datashard_impl.h\"\n+#include \"datashard_integrity_trails.h\"\n #include \"datashard_kqp.h\"\n #include \"datashard_pipeline.h\"\n #include \"execution_unit_ctors.h\"\n@@ -214,7 +215,8 @@ EExecutionStatus TExecuteKqpDataTxUnit::Execute(TOperation::TPtr op, TTransactio\n             }\n \n             KqpEraseLocks(tabletId, kqpLocks, sysLocks);\n-            sysLocks.ApplyLocks();\n+            auto [_, locksBrokenByTx] = sysLocks.ApplyLocks();\n+            NDataIntegrity::LogIntegrityTrailsLocks(ctx, tabletId, txId, locksBrokenByTx);\n             DataShard.SubscribeNewLocks(ctx);\n             if (locksDb.HasChanges()) {\n                 op->SetWaitCompletionFlag(true);\n@@ -469,7 +471,8 @@ EExecutionStatus TExecuteKqpDataTxUnit::Execute(TOperation::TPtr op, TTransactio\n }\n \n void TExecuteKqpDataTxUnit::AddLocksToResult(TOperation::TPtr op, const TActorContext& ctx) {\n-    auto locks = DataShard.SysLocksTable().ApplyLocks();\n+    auto [locks, locksBrokenByTx] = DataShard.SysLocksTable().ApplyLocks();\n+    NDataIntegrity::LogIntegrityTrailsLocks(ctx, DataShard.TabletID(), op->GetTxId(), locksBrokenByTx);\n     LOG_T(\"add locks to result: \" << locks.size());\n     for (const auto& lock : locks) {\n         if (lock.IsError()) {\ndiff --git a/ydb/core/tx/datashard/execute_write_unit.cpp b/ydb/core/tx/datashard/execute_write_unit.cpp\nindex e6b7c43f2aa2..afa4a61724df 100644\n--- a/ydb/core/tx/datashard/execute_write_unit.cpp\n+++ b/ydb/core/tx/datashard/execute_write_unit.cpp\n@@ -4,6 +4,7 @@\n #include \"datashard_locks_db.h\"\n #include \"datashard_user_db.h\"\n #include \"datashard_kqp.h\"\n+#include \"datashard_integrity_trails.h\"\n \n #include <ydb/core/engine/mkql_engine_flat_host.h>\n \n@@ -41,7 +42,8 @@ class TExecuteWriteUnit : public TExecutionUnit {\n     void AddLocksToResult(TWriteOperation* writeOp, const TActorContext& ctx) {\n         NEvents::TDataEvents::TEvWriteResult& writeResult = *writeOp->GetWriteResult();\n \n-        auto locks = DataShard.SysLocksTable().ApplyLocks();\n+        auto [locks, locksBrokenByTx] = DataShard.SysLocksTable().ApplyLocks();\n+        NDataIntegrity::LogIntegrityTrailsLocks(ctx, DataShard.TabletID(), writeOp->GetTxId(), locksBrokenByTx);\n         LOG_TRACE_S(ctx, NKikimrServices::TX_DATASHARD, \"add locks to result: \" << locks.size());\n         for (const auto& lock : locks) {\n             if (lock.IsError()) {\n@@ -95,8 +97,8 @@ class TExecuteWriteUnit : public TExecutionUnit {\n         if (CheckForVolatileReadDependencies(userDb, writeOp, txc, ctx)) \n             return EExecutionStatus::Continue;\n         \n-        LOG_TRACE_S(ctx, NKikimrServices::TX_DATASHARD, \"Operation \" << writeOp << \" at \" << DataShard.TabletID() << \" aborting because an duplicate key\");\n-        writeOp.SetError(NKikimrDataEvents::TEvWriteResult::STATUS_CONSTRAINT_VIOLATION, \"Operation is aborting because an duplicate key\");\n+        LOG_TRACE_S(ctx, NKikimrServices::TX_DATASHARD, \"Operation \" << writeOp << \" at \" << DataShard.TabletID() << \" aborting. Duplicate keys have been found.\");\n+        writeOp.SetError(NKikimrDataEvents::TEvWriteResult::STATUS_CONSTRAINT_VIOLATION, \"Duplicate keys have been found.\");\n         ResetChanges(userDb, writeOp, txc);\n         return EExecutionStatus::Executed;\n     }\n@@ -344,7 +346,8 @@ class TExecuteWriteUnit : public TExecutionUnit {\n                 }\n \n                 KqpEraseLocks(tabletId, kqpLocks, sysLocks);\n-                sysLocks.ApplyLocks();\n+                auto [_, locksBrokenByTx] = sysLocks.ApplyLocks();\n+                NDataIntegrity::LogIntegrityTrailsLocks(ctx, tabletId, txId, locksBrokenByTx);\n                 DataShard.SubscribeNewLocks(ctx);\n                 if (locksDb.HasChanges()) {\n                     op->SetWaitCompletionFlag(true);\ndiff --git a/ydb/core/tx/datashard/kmeans_helper.cpp b/ydb/core/tx/datashard/kmeans_helper.cpp\nindex 080771c20f28..3a74b92c74aa 100644\n--- a/ydb/core/tx/datashard/kmeans_helper.cpp\n+++ b/ydb/core/tx/datashard/kmeans_helper.cpp\n@@ -47,21 +47,23 @@ void AddRowMain2Posting(TBufferData& buffer, NTableIndex::TClusterId parent, TAr\n                   TSerializedCellVec::Serialize((*row).Slice(dataPos)));\n }\n \n-void AddRowBuild2Build(TBufferData& buffer, NTableIndex::TClusterId parent, TArrayRef<const TCell> key, const NTable::TRowState& row) {\n+void AddRowBuild2Build(TBufferData& buffer, NTableIndex::TClusterId parent, TArrayRef<const TCell> key, const NTable::TRowState& row,\n+                       ui32 prefixColumns)\n+{\n     std::array<TCell, 1> cells;\n     cells[0] = TCell::Make(parent);\n     auto pk = TSerializedCellVec::Serialize(cells);\n-    TSerializedCellVec::UnsafeAppendCells(key.Slice(1), pk);\n+    TSerializedCellVec::UnsafeAppendCells(key.Slice(prefixColumns), pk);\n     buffer.AddRow(TSerializedCellVec{key}, TSerializedCellVec{std::move(pk)}, TSerializedCellVec::Serialize(*row));\n }\n \n void AddRowBuild2Posting(TBufferData& buffer, NTableIndex::TClusterId parent, TArrayRef<const TCell> key, const NTable::TRowState& row,\n-                         ui32 dataPos)\n+                         ui32 dataPos, ui32 prefixColumns)\n {\n     std::array<TCell, 1> cells;\n     cells[0] = TCell::Make(parent);\n     auto pk = TSerializedCellVec::Serialize(cells);\n-    TSerializedCellVec::UnsafeAppendCells(key.Slice(1), pk);\n+    TSerializedCellVec::UnsafeAppendCells(key.Slice(prefixColumns), pk);\n     buffer.AddRow(TSerializedCellVec{key}, TSerializedCellVec{std::move(pk)},\n                   TSerializedCellVec::Serialize((*row).Slice(dataPos)));\n }\n@@ -88,12 +90,13 @@ TTags MakeUploadTags(const TUserTable& table, const TProtoStringType& embedding,\n \n std::shared_ptr<NTxProxy::TUploadTypes>\n MakeUploadTypes(const TUserTable& table, NKikimrTxDataShard::TEvLocalKMeansRequest::EState uploadState,\n-                const TProtoStringType& embedding, const google::protobuf::RepeatedPtrField<TProtoStringType>& data)\n+                const TProtoStringType& embedding, const google::protobuf::RepeatedPtrField<TProtoStringType>& data,\n+                ui32 prefixColumns)\n {\n     auto types = GetAllTypes(table);\n \n     auto uploadTypes = std::make_shared<NTxProxy::TUploadTypes>();\n-    uploadTypes->reserve(1 + 1 + std::min(table.KeyColumnTypes.size() + data.size(), types.size()));\n+    uploadTypes->reserve(1 + 1 + std::min((table.KeyColumnTypes.size() - prefixColumns) + data.size(), types.size()));\n \n     Ydb::Type type;\n     type.set_type_id(NTableIndex::ClusterIdType);\n@@ -107,7 +110,7 @@ MakeUploadTypes(const TUserTable& table, NKikimrTxDataShard::TEvLocalKMeansReque\n             types.erase(it);\n         }\n     };\n-    for (const auto& column : table.KeyColumnIds) {\n+    for (const auto& column : table.KeyColumnIds | std::views::drop(prefixColumns)) {\n         addType(table.Columns.at(column).Name);\n     }\n     switch (uploadState) {\ndiff --git a/ydb/core/tx/datashard/kmeans_helper.h b/ydb/core/tx/datashard/kmeans_helper.h\nindex 42449519b4d5..92ea345ccdde 100644\n--- a/ydb/core/tx/datashard/kmeans_helper.h\n+++ b/ydb/core/tx/datashard/kmeans_helper.h\n@@ -206,10 +206,11 @@ void AddRowMain2Build(TBufferData& buffer, NTableIndex::TClusterId parent, TArra\n void AddRowMain2Posting(TBufferData& buffer, NTableIndex::TClusterId parent, TArrayRef<const TCell> key, const NTable::TRowState& row,\n                         ui32 dataPos);\n \n-void AddRowBuild2Build(TBufferData& buffer, NTableIndex::TClusterId parent, TArrayRef<const TCell> key, const NTable::TRowState& row);\n+void AddRowBuild2Build(TBufferData& buffer, NTableIndex::TClusterId parent, TArrayRef<const TCell> key, const NTable::TRowState& row,\n+                       ui32 prefixColumns = 1);\n \n void AddRowBuild2Posting(TBufferData& buffer, NTableIndex::TClusterId parent, TArrayRef<const TCell> key, const NTable::TRowState& row,\n-                         ui32 dataPos);\n+                         ui32 dataPos, ui32 prefixColumns = 1);\n \n TTags MakeUploadTags(const TUserTable& table, const TProtoStringType& embedding,\n                      const google::protobuf::RepeatedPtrField<TProtoStringType>& data, ui32& embeddingPos,\n@@ -217,7 +218,8 @@ TTags MakeUploadTags(const TUserTable& table, const TProtoStringType& embedding,\n \n std::shared_ptr<NTxProxy::TUploadTypes>\n MakeUploadTypes(const TUserTable& table, NKikimrTxDataShard::TEvLocalKMeansRequest::EState uploadState,\n-                const TProtoStringType& embedding, const google::protobuf::RepeatedPtrField<TProtoStringType>& data);\n+                const TProtoStringType& embedding, const google::protobuf::RepeatedPtrField<TProtoStringType>& data,\n+                ui32 prefixColumns = 0);\n \n void MakeScan(auto& record, const auto& createScan, const auto& badRequest)\n {\ndiff --git a/ydb/core/tx/datashard/prefix_kmeans.cpp b/ydb/core/tx/datashard/prefix_kmeans.cpp\nnew file mode 100644\nindex 000000000000..053ca5ed7325\n--- /dev/null\n+++ b/ydb/core/tx/datashard/prefix_kmeans.cpp\n@@ -0,0 +1,716 @@\n+#include \"datashard_impl.h\"\n+#include \"kmeans_helper.h\"\n+#include \"scan_common.h\"\n+#include \"upload_stats.h\"\n+#include \"buffer_data.h\"\n+\n+#include <ydb/core/base/appdata.h>\n+#include <ydb/core/base/counters.h>\n+#include <ydb/core/kqp/common/kqp_types.h>\n+#include <ydb/core/scheme/scheme_tablecell.h>\n+\n+#include <ydb/core/tx/tx_proxy/proxy.h>\n+#include <ydb/core/tx/tx_proxy/upload_rows.h>\n+\n+#include <ydb/core/ydb_convert/table_description.h>\n+#include <ydb/core/ydb_convert/ydb_convert.h>\n+#include <yql/essentials/public/issue/yql_issue_message.h>\n+\n+#include <util/generic/algorithm.h>\n+#include <util/string/builder.h>\n+\n+namespace NKikimr::NDataShard {\n+using namespace NKMeans;\n+\n+// This scan needed to run kmeans reshuffle which is part of global kmeans run.\n+static constexpr double MinVectorsNeedsReassigned = 0.01;\n+\n+class TPrefixKMeansScanBase: public TActor<TPrefixKMeansScanBase>, public NTable::IScan {\n+protected:\n+    using EState = NKikimrTxDataShard::TEvLocalKMeansRequest;\n+\n+    NTableIndex::TClusterId Parent = 0;\n+    NTableIndex::TClusterId Child = 0;\n+\n+    ui32 Round = 0;\n+    const ui32 MaxRounds = 0;\n+\n+    const ui32 InitK = 0;\n+    ui32 K = 0;\n+\n+    EState::EState State;\n+    const EState::EState UploadState;\n+\n+    IDriver* Driver = nullptr;\n+\n+    TLead Lead;\n+\n+    ui64 BuildId = 0;\n+\n+    ui64 ReadRows = 0;\n+    ui64 ReadBytes = 0;\n+\n+    // Sample\n+    ui64 MaxProbability = std::numeric_limits<ui64>::max();\n+    TReallyFastRng32 Rng;\n+\n+    struct TProbability {\n+        ui64 P = 0;\n+        ui64 I = 0;\n+\n+        bool operator==(const TProbability&) const noexcept = default;\n+        auto operator<=>(const TProbability&) const noexcept = default;\n+    };\n+\n+    std::vector<TProbability> MaxRows;\n+    std::vector<TString> Clusters;\n+    std::vector<ui64> ClusterSizes;\n+\n+    // Upload\n+    std::shared_ptr<NTxProxy::TUploadTypes> InitTargetTypes;\n+    std::shared_ptr<NTxProxy::TUploadTypes> InitNextTypes;\n+\n+    std::shared_ptr<NTxProxy::TUploadTypes> TargetTypes;\n+    std::shared_ptr<NTxProxy::TUploadTypes> NextTypes;\n+\n+    const TString TargetTable;\n+    const TString NextTable;\n+    TString CurrTable;\n+\n+    TBufferData ReadBuf;\n+    TBufferData WriteBuf;\n+\n+    NTable::TPos EmbeddingPos = 0;\n+    NTable::TPos DataPos = 1;\n+\n+    ui32 RetryCount = 0;\n+\n+    TActorId Uploader;\n+    TUploadLimits Limits;\n+\n+    NTable::TTag KMeansScan;\n+    TTags UploadScan;\n+\n+    TUploadStatus UploadStatus;\n+\n+    ui64 UploadRows = 0;\n+    ui64 UploadBytes = 0;\n+\n+    // Response\n+    TActorId ResponseActorId;\n+    TAutoPtr<TEvDataShard::TEvPrefixKMeansResponse> Response;\n+\n+    ui32 PrefixColulmns;\n+    TSerializedCellVec Key;\n+    bool HasNextKey = false;\n+\n+public:\n+    static constexpr NKikimrServices::TActivity::EType ActorActivityType()\n+    {\n+        return NKikimrServices::TActivity::LOCAL_KMEANS_SCAN_ACTOR;\n+    }\n+\n+    TPrefixKMeansScanBase(const TUserTable& table, TLead&& lead,\n+                          const NKikimrTxDataShard::TEvPrefixKMeansRequest& request,\n+                          const TActorId& responseActorId,\n+                          TAutoPtr<TEvDataShard::TEvPrefixKMeansResponse>&& response)\n+        : TActor{&TThis::StateWork}\n+        , Parent{request.GetChild()}\n+        , Child{Parent + 1}\n+        , MaxRounds{request.GetNeedsRounds()}\n+        , InitK{request.GetK()}\n+        , K{request.GetK()}\n+        , State{EState::SAMPLE}\n+        , UploadState{request.GetUpload()}\n+        , Lead{std::move(lead)}\n+        , BuildId{request.GetId()}\n+        , Rng{request.GetSeed()}\n+        , TargetTable{request.GetLevelName()}\n+        , NextTable{request.GetPostingName()}\n+        , ResponseActorId{responseActorId}\n+        , Response{std::move(response)}\n+        , PrefixColulmns{request.GetPrefixColumns()}\n+    {\n+        const auto& embedding = request.GetEmbeddingColumn();\n+        const auto& data = request.GetDataColumns();\n+        // scan tags\n+        UploadScan = MakeUploadTags(table, embedding, data, EmbeddingPos, DataPos, KMeansScan);\n+        // upload types\n+        if (Ydb::Type type; State <= EState::KMEANS) {\n+            TargetTypes = std::make_shared<NTxProxy::TUploadTypes>(3);\n+            type.set_type_id(NTableIndex::ClusterIdType);\n+            (*TargetTypes)[0] = {NTableIndex::NTableVectorKmeansTreeIndex::ParentColumn, type};\n+            (*TargetTypes)[1] = {NTableIndex::NTableVectorKmeansTreeIndex::IdColumn, type};\n+            type.set_type_id(Ydb::Type::STRING);\n+            (*TargetTypes)[2] = {NTableIndex::NTableVectorKmeansTreeIndex::CentroidColumn, type};\n+        }\n+        NextTypes = MakeUploadTypes(table, UploadState, embedding, data, PrefixColulmns);\n+\n+        InitTargetTypes = TargetTypes;\n+        InitNextTypes = NextTypes;\n+        CurrTable = TargetTable;\n+    }\n+\n+    TInitialState Prepare(IDriver* driver, TIntrusiveConstPtr<TScheme>) noexcept final\n+    {\n+        TActivationContext::AsActorContext().RegisterWithSameMailbox(this);\n+        LOG_D(\"Prepare \" << Debug());\n+\n+        Driver = driver;\n+        return {EScan::Feed, {}};\n+    }\n+\n+    TAutoPtr<IDestructable> Finish(EAbort abort) noexcept final\n+    {\n+        LOG_D(\"Finish \" << Debug());\n+\n+        if (Uploader) {\n+            Send(Uploader, new TEvents::TEvPoison);\n+            Uploader = {};\n+        }\n+\n+        auto& record = Response->Record;\n+        record.SetReadRows(ReadRows);\n+        record.SetReadBytes(ReadBytes);\n+        record.SetUploadRows(UploadRows);\n+        record.SetUploadBytes(UploadBytes);\n+        if (abort != EAbort::None) {\n+            record.SetStatus(NKikimrIndexBuilder::EBuildStatus::ABORTED);\n+        } else if (UploadStatus.IsSuccess()) {\n+            record.SetStatus(NKikimrIndexBuilder::EBuildStatus::DONE);\n+        } else {\n+            record.SetStatus(NKikimrIndexBuilder::EBuildStatus::BUILD_ERROR);\n+        }\n+        NYql::IssuesToMessage(UploadStatus.Issues, record.MutableIssues());\n+        Send(ResponseActorId, Response.Release());\n+\n+        Driver = nullptr;\n+        this->PassAway();\n+        return nullptr;\n+    }\n+\n+    void Describe(IOutputStream& out) const noexcept final\n+    {\n+        out << Debug();\n+    }\n+\n+    TString Debug() const\n+    {\n+        return TStringBuilder() << \" TPrefixKMeansScan Id: \" << BuildId << \" Parent: \" << Parent << \" Child: \" << Child\n+            << \" CurrTable: \" << CurrTable << \" K: \" << K << \" Clusters: \" << Clusters.size()\n+            << \" State: \" << State << \" Round: \" << Round << \" / \" << MaxRounds\n+            << \" ReadBuf size: \" << ReadBuf.Size() << \" WriteBuf size: \" << WriteBuf.Size() << \" \";\n+    }\n+\n+    EScan PageFault() noexcept final\n+    {\n+        LOG_T(\"PageFault \" << Debug());\n+\n+        if (!ReadBuf.IsEmpty() && WriteBuf.IsEmpty()) {\n+            ReadBuf.FlushTo(WriteBuf);\n+            Upload(false);\n+        }\n+\n+        return EScan::Feed;\n+    }\n+\n+protected:\n+    STFUNC(StateWork)\n+    {\n+        switch (ev->GetTypeRewrite()) {\n+            HFunc(TEvTxUserProxy::TEvUploadRowsResponse, Handle);\n+            CFunc(TEvents::TSystem::Wakeup, HandleWakeup);\n+            default:\n+                LOG_E(\"TPrefixKMeansScan: StateWork unexpected event type: \" << ev->GetTypeRewrite() << \" event: \"\n+                                                                            << ev->ToString() << \" \" << Debug());\n+        }\n+    }\n+\n+    void HandleWakeup(const NActors::TActorContext& /*ctx*/)\n+    {\n+        LOG_T(\"Retry upload \" << Debug());\n+\n+        if (!WriteBuf.IsEmpty()) {\n+            Upload(true);\n+        }\n+    }\n+\n+    void Handle(TEvTxUserProxy::TEvUploadRowsResponse::TPtr& ev, const TActorContext& ctx)\n+    {\n+        LOG_D(\"Handle TEvUploadRowsResponse \" << Debug()\n+            << \" Uploader: \" << Uploader.ToString() << \" ev->Sender: \" << ev->Sender.ToString());\n+\n+        if (Uploader) {\n+            Y_VERIFY_S(Uploader == ev->Sender, \"Mismatch Uploader: \" << Uploader.ToString() << \" ev->Sender: \"\n+                                                                     << ev->Sender.ToString() << Debug());\n+        } else {\n+            Y_ABORT_UNLESS(Driver == nullptr);\n+            return;\n+        }\n+\n+        UploadStatus.StatusCode = ev->Get()->Status;\n+        UploadStatus.Issues = ev->Get()->Issues;\n+        if (UploadStatus.IsSuccess()) {\n+            UploadRows += WriteBuf.GetRows();\n+            UploadBytes += WriteBuf.GetBytes();\n+            WriteBuf.Clear();\n+            if (!ReadBuf.IsEmpty() && ReadBuf.IsReachLimits(Limits)) {\n+                ReadBuf.FlushTo(WriteBuf);\n+                Upload(false);\n+            }\n+\n+            Driver->Touch(EScan::Feed);\n+            return;\n+        }\n+\n+        if (RetryCount < Limits.MaxUploadRowsRetryCount && UploadStatus.IsRetriable()) {\n+            LOG_N(\"Got retriable error, \" << Debug() << UploadStatus.ToString());\n+\n+            ctx.Schedule(Limits.GetTimeoutBackouff(RetryCount), new TEvents::TEvWakeup());\n+            return;\n+        }\n+\n+        LOG_N(\"Got error, abort scan, \" << Debug() << UploadStatus.ToString());\n+\n+        Driver->Touch(EScan::Final);\n+    }\n+\n+    EScan FeedUpload()\n+    {\n+        if (!ReadBuf.IsReachLimits(Limits)) {\n+            return EScan::Feed;\n+        }\n+        if (!WriteBuf.IsEmpty()) {\n+            return EScan::Sleep;\n+        }\n+        ReadBuf.FlushTo(WriteBuf);\n+        Upload(false);\n+        return EScan::Feed;\n+    }\n+\n+    ui64 GetProbability()\n+    {\n+        return Rng.GenRand64();\n+    }\n+\n+    void Upload(bool isRetry)\n+    {\n+        if (isRetry) {\n+            ++RetryCount;\n+        } else {\n+            RetryCount = 0;\n+            if (State != EState::KMEANS && NextTypes) {\n+                TargetTypes = std::exchange(NextTypes, {});\n+                CurrTable = NextTable;\n+            }\n+        }\n+\n+        auto actor = NTxProxy::CreateUploadRowsInternal(\n+            this->SelfId(), CurrTable, TargetTypes, WriteBuf.GetRowsData(),\n+            NTxProxy::EUploadRowsMode::WriteToTableShadow, true /*writeToPrivateTable*/);\n+\n+        Uploader = this->Register(actor);\n+    }\n+\n+    void UploadSample()\n+    {\n+        Y_ASSERT(ReadBuf.IsEmpty());\n+        Y_ASSERT(WriteBuf.IsEmpty());\n+        std::array<TCell, 2> pk;\n+        std::array<TCell, 1> data;\n+        for (NTable::TPos pos = 0; const auto& row : Clusters) {\n+            pk[0] = TCell::Make(Parent);\n+            pk[1] = TCell::Make(Child + pos);\n+            data[0] = TCell{row};\n+            WriteBuf.AddRow({}, TSerializedCellVec{pk}, TSerializedCellVec::Serialize(data));\n+            ++pos;\n+        }\n+        Upload(false);\n+    }\n+};\n+\n+template <typename TMetric>\n+class TPrefixKMeansScan final: public TPrefixKMeansScanBase, private TCalculation<TMetric> {\n+    // KMeans\n+    using TEmbedding = std::vector<typename TMetric::TSum>;\n+\n+    struct TAggregatedCluster {\n+        TEmbedding Cluster;\n+        ui64 Size = 0;\n+    };\n+    std::vector<TAggregatedCluster> AggregatedClusters;\n+\n+\n+    bool MoveToNextKey() {\n+        if (!HasNextKey) {\n+            if (UploadStatus.IsNone()) {\n+                UploadStatus.StatusCode = Ydb::StatusIds::SUCCESS;\n+            }\n+            return false;\n+        }\n+        Parent = Child + K;\n+        Child = Parent + 1;\n+        Round = 0;\n+        K = InitK;\n+        State = EState::SAMPLE;\n+        // TODO(mbkkt) Upper or Lower doesn't matter here, because we seek to (prefix, inf)\n+        // so we can choose Lower if it's faster.\n+        // Exact seek with Lower also possible but needs to rewrite some code in Feed\n+        Lead.To(Key.GetCells().subspan(0, PrefixColulmns), NTable::ESeek::Upper);\n+        Key = {};\n+        MaxProbability = std::numeric_limits<ui64>::max();\n+        MaxRows.clear();\n+        Clusters.clear();\n+        ClusterSizes.clear();\n+        TargetTypes = InitTargetTypes;\n+        NextTypes = InitNextTypes;\n+        CurrTable = TargetTable;\n+        HasNextKey = false;\n+        AggregatedClusters.clear();\n+        return true;\n+    }\n+\n+public:\n+    TPrefixKMeansScan(const TUserTable& table, TLead&& lead, NKikimrTxDataShard::TEvPrefixKMeansRequest& request,\n+                      const TActorId& responseActorId, TAutoPtr<TEvDataShard::TEvPrefixKMeansResponse>&& response)\n+        : TPrefixKMeansScanBase{table, std::move(lead), request, responseActorId, std::move(response)}\n+    {\n+        this->Dimensions = request.GetSettings().vector_dimension();\n+        LOG_D(\"Create \" << Debug());\n+    }\n+\n+    EScan Seek(TLead& lead, ui64 seq) noexcept final\n+    {\n+        LOG_D(\"Seek \" << Debug());\n+        ui64 zeroSeq = 0;\n+        while (true) {\n+            if (State == UploadState) {\n+                if (!WriteBuf.IsEmpty()) {\n+                    return EScan::Sleep;\n+                }\n+                if (!ReadBuf.IsEmpty()) {\n+                    ReadBuf.FlushTo(WriteBuf);\n+                    Upload(false);\n+                    return EScan::Sleep;\n+                }\n+                if (MoveToNextKey()) {\n+                    zeroSeq = seq;\n+                    continue;\n+                }\n+                return EScan::Final;\n+            }\n+\n+            lead = Lead;\n+            if (State == EState::SAMPLE) {\n+                lead.SetTags({&KMeansScan, 1});\n+                if (seq == zeroSeq && !HasNextKey) {\n+                    return EScan::Feed;\n+                }\n+                State = EState::KMEANS;\n+                if (!InitAggregatedClusters()) {\n+                    // We don't need to do anything,\n+                    // because this datashard doesn't have valid embeddings for this parent\n+                    if (MoveToNextKey()) {\n+                        zeroSeq = seq;\n+                        continue;\n+                    }\n+                    return EScan::Final;\n+                }\n+                ++Round;\n+                return EScan::Feed;\n+            }\n+\n+            Y_ASSERT(State == EState::KMEANS);\n+            if (RecomputeClusters()) {\n+                lead.SetTags(UploadScan);\n+\n+                UploadSample();\n+                State = UploadState;\n+            } else {\n+                lead.SetTags({&KMeansScan, 1});\n+                ++Round;\n+            }\n+            return EScan::Feed;\n+        }\n+    }\n+\n+    EScan Feed(TArrayRef<const TCell> key, const TRow& row) noexcept final\n+    {\n+        LOG_T(\"Feed \" << Debug());\n+        if (!Key) {\n+            Key = TSerializedCellVec{key};\n+        } else if (!TCellVectorsEquals{}(Key.GetCells().subspan(0, PrefixColulmns), key.subspan(0, PrefixColulmns))) {\n+            HasNextKey = true;\n+            return EScan::Reset;\n+        }\n+        ++ReadRows;\n+        ReadBytes += CountBytes(key, row);\n+        switch (State) {\n+            case EState::SAMPLE:\n+                return FeedSample(row);\n+            case EState::KMEANS:\n+                return FeedKMeans(row);\n+            case EState::UPLOAD_BUILD_TO_BUILD:\n+                return FeedUploadBuild2Build(key, row);\n+            case EState::UPLOAD_BUILD_TO_POSTING:\n+                return FeedUploadBuild2Posting(key, row);\n+            default:\n+                Y_ASSERT(false);\n+                return EScan::Final;\n+        }\n+    }\n+\n+private:\n+    bool InitAggregatedClusters()\n+    {\n+        if (Clusters.size() == 0) {\n+            return false;\n+        }\n+        if (Clusters.size() < K) {\n+            // if this datashard have smaller than K count of valid embeddings for this parent\n+            // lets make single centroid for it\n+            K = 1;\n+            Clusters.resize(K);\n+        }\n+        Y_ASSERT(Clusters.size() == K);\n+        ClusterSizes.resize(K, 0);\n+        AggregatedClusters.resize(K);\n+        for (auto& aggregate : AggregatedClusters) {\n+            aggregate.Cluster.resize(this->Dimensions, 0);\n+        }\n+        return true;\n+    }\n+\n+    void AggregateToCluster(ui32 pos, const char* embedding)\n+    {\n+        if (pos >= K) {\n+            return;\n+        }\n+        auto& aggregate = AggregatedClusters[pos];\n+        auto* coords = aggregate.Cluster.data();\n+        for (auto coord : this->GetCoords(embedding)) {\n+            *coords++ += coord;\n+        }\n+        ++aggregate.Size;\n+    }\n+\n+    bool RecomputeClusters()\n+    {\n+        Y_ASSERT(K >= 1);\n+        ui64 vectorCount = 0;\n+        ui64 reassignedCount = 0;\n+        for (size_t i = 0; auto& aggregate : AggregatedClusters) {\n+            vectorCount += aggregate.Size;\n+\n+            auto& clusterSize = ClusterSizes[i];\n+            reassignedCount += clusterSize < aggregate.Size ? aggregate.Size - clusterSize : 0;\n+            clusterSize = aggregate.Size;\n+\n+            if (aggregate.Size != 0) {\n+                this->Fill(Clusters[i], aggregate.Cluster.data(), aggregate.Size);\n+                Y_ASSERT(aggregate.Size == 0);\n+            }\n+            ++i;\n+        }\n+        Y_ASSERT(vectorCount >= K);\n+        Y_ASSERT(reassignedCount <= vectorCount);\n+        if (K == 1) {\n+            return true;\n+        }\n+\n+        bool last = Round >= MaxRounds;\n+        if (!last && Round > 1) {\n+            const auto changes = static_cast<double>(reassignedCount) / static_cast<double>(vectorCount);\n+            last = changes < MinVectorsNeedsReassigned;\n+        }\n+        if (!last) {\n+            return false;\n+        }\n+\n+        size_t w = 0;\n+        for (size_t r = 0; r < ClusterSizes.size(); ++r) {\n+            if (ClusterSizes[r] != 0) {\n+                ClusterSizes[w] = ClusterSizes[r];\n+                Clusters[w] = std::move(Clusters[r]);\n+                ++w;\n+            }\n+        }\n+        ClusterSizes.erase(ClusterSizes.begin() + w, ClusterSizes.end());\n+        Clusters.erase(Clusters.begin() + w, Clusters.end());\n+        return true;\n+    }\n+\n+    EScan FeedSample(const TRow& row) noexcept\n+    {\n+        Y_ASSERT(row.Size() == 1);\n+        const auto embedding = row.Get(0).AsRef();\n+        if (!this->IsExpectedSize(embedding)) {\n+            return EScan::Feed;\n+        }\n+\n+        const auto probability = GetProbability();\n+        if (Clusters.size() < K) {\n+            MaxRows.push_back({probability, Clusters.size()});\n+            Clusters.emplace_back(embedding.data(), embedding.size());\n+            if (Clusters.size() == K) {\n+                std::make_heap(MaxRows.begin(), MaxRows.end());\n+                MaxProbability = MaxRows.front().P;\n+            }\n+        } else if (probability < MaxProbability) {\n+            // TODO(mbkkt) use tournament tree to make less compare and swaps\n+            std::pop_heap(MaxRows.begin(), MaxRows.end());\n+            Clusters[MaxRows.back().I].assign(embedding.data(), embedding.size());\n+            MaxRows.back().P = probability;\n+            std::push_heap(MaxRows.begin(), MaxRows.end());\n+            MaxProbability = MaxRows.front().P;\n+        }\n+        return MaxProbability != 0 ? EScan::Feed : EScan::Reset;\n+    }\n+\n+    EScan FeedKMeans(const TRow& row) noexcept\n+    {\n+        Y_ASSERT(row.Size() == 1);\n+        const ui32 pos = FeedEmbedding(*this, Clusters, row, 0);\n+        AggregateToCluster(pos, row.Get(0).Data());\n+        return EScan::Feed;\n+    }\n+\n+    EScan FeedUploadBuild2Build(TArrayRef<const TCell> key, const TRow& row) noexcept\n+    {\n+        const ui32 pos = FeedEmbedding(*this, Clusters, row, EmbeddingPos);\n+        if (pos > K) {\n+            return EScan::Feed;\n+        }\n+        AddRowBuild2Build(ReadBuf, Child + pos, key, row, PrefixColulmns);\n+        return FeedUpload();\n+    }\n+\n+    EScan FeedUploadBuild2Posting(TArrayRef<const TCell> key, const TRow& row) noexcept\n+    {\n+        const ui32 pos = FeedEmbedding(*this, Clusters, row, EmbeddingPos);\n+        if (pos > K) {\n+            return EScan::Feed;\n+        }\n+        AddRowBuild2Posting(ReadBuf, Child + pos, key, row, DataPos, PrefixColulmns);\n+        return FeedUpload();\n+    }\n+};\n+\n+class TDataShard::TTxHandleSafePrefixKMeansScan final: public NTabletFlatExecutor::TTransactionBase<TDataShard> {\n+public:\n+    TTxHandleSafePrefixKMeansScan(TDataShard* self, TEvDataShard::TEvPrefixKMeansRequest::TPtr&& ev)\n+        : TTransactionBase(self)\n+        , Ev(std::move(ev))\n+    {\n+    }\n+\n+    bool Execute(TTransactionContext&, const TActorContext& ctx) final\n+    {\n+        Self->HandleSafe(Ev, ctx);\n+        return true;\n+    }\n+\n+    void Complete(const TActorContext&) final\n+    {\n+    }\n+\n+private:\n+    TEvDataShard::TEvPrefixKMeansRequest::TPtr Ev;\n+};\n+\n+void TDataShard::Handle(TEvDataShard::TEvPrefixKMeansRequest::TPtr& ev, const TActorContext&)\n+{\n+    Execute(new TTxHandleSafePrefixKMeansScan(this, std::move(ev)));\n+}\n+\n+void TDataShard::HandleSafe(TEvDataShard::TEvPrefixKMeansRequest::TPtr& ev, const TActorContext& ctx)\n+{\n+    auto& record = ev->Get()->Record;\n+    TRowVersion rowVersion = GetMvccTxVersion(EMvccTxMode::ReadOnly);\n+\n+    // Note: it's very unlikely that we have volatile txs before this snapshot\n+    if (VolatileTxManager.HasVolatileTxsAtSnapshot(rowVersion)) {\n+        VolatileTxManager.AttachWaitingSnapshotEvent(rowVersion, std::unique_ptr<IEventHandle>(ev.Release()));\n+        return;\n+    }\n+    const ui64 id = record.GetId();\n+\n+    auto response = MakeHolder<TEvDataShard::TEvPrefixKMeansResponse>();\n+    response->Record.SetId(id);\n+    response->Record.SetTabletId(TabletID());\n+\n+    TScanRecord::TSeqNo seqNo = {record.GetSeqNoGeneration(), record.GetSeqNoRound()};\n+    response->Record.SetRequestSeqNoGeneration(seqNo.Generation);\n+    response->Record.SetRequestSeqNoRound(seqNo.Round);\n+\n+    auto badRequest = [&](const TString& error) {\n+        response->Record.SetStatus(NKikimrIndexBuilder::EBuildStatus::BAD_REQUEST);\n+        auto issue = response->Record.AddIssues();\n+        issue->set_severity(NYql::TSeverityIds::S_ERROR);\n+        issue->set_message(error);\n+        ctx.Send(ev->Sender, std::move(response));\n+        response.Reset();\n+    };\n+\n+    if (const ui64 shardId = record.GetTabletId(); shardId != TabletID()) {\n+        badRequest(TStringBuilder() << \"Wrong shard \" << shardId << \" this is \" << TabletID());\n+        return;\n+    }\n+\n+    const auto pathId = TPathId::FromProto(record.GetPathId());\n+    const auto* userTableIt = GetUserTables().FindPtr(pathId.LocalPathId);\n+    if (!userTableIt) {\n+        badRequest(TStringBuilder() << \"Unknown table id: \" << pathId.LocalPathId);\n+        return;\n+    }\n+    Y_ABORT_UNLESS(*userTableIt);\n+    const auto& userTable = **userTableIt;\n+\n+    if (const auto* recCard = ScanManager.Get(id)) {\n+        if (recCard->SeqNo == seqNo) {\n+            // do no start one more scan\n+            return;\n+        }\n+\n+        for (auto scanId : recCard->ScanIds) {\n+            CancelScan(userTable.LocalTid, scanId);\n+        }\n+        ScanManager.Drop(id);\n+    }\n+\n+    const auto range = userTable.GetTableRange();\n+    if (range.IsEmptyRange(userTable.KeyColumnTypes)) {\n+        badRequest(TStringBuilder() << \" requested range doesn't intersect with table range\");\n+        return;\n+    }\n+\n+    if (!IsStateActive()) {\n+        badRequest(TStringBuilder() << \"Shard \" << TabletID() << \" is not ready for requests\");\n+        return;\n+    }\n+\n+    if (record.GetK() < 2) {\n+        badRequest(\"Should be requested partition on at least two rows\");\n+        return;\n+    }\n+\n+    TAutoPtr<NTable::IScan> scan;\n+    auto createScan = [&]<typename T> {\n+        scan = new TPrefixKMeansScan<T>{\n+            userTable, CreateLeadFrom(range), record, ev->Sender, std::move(response),\n+        };\n+    };\n+    MakeScan(record, createScan, badRequest);\n+    if (!scan) {\n+        Y_ASSERT(!response);\n+        return;\n+    }\n+\n+    TScanOptions scanOpts;\n+    scanOpts.SetSnapshotRowVersion(rowVersion);\n+    scanOpts.SetResourceBroker(\"build_index\", 10); // TODO(mbkkt) Should be different group?\n+    const auto scanId = QueueScan(userTable.LocalTid, std::move(scan), 0, scanOpts);\n+    ScanManager.Set(id, seqNo).push_back(scanId);\n+}\n+\n+}\ndiff --git a/ydb/core/tx/datashard/ut_common/datashard_ut_common.cpp b/ydb/core/tx/datashard/ut_common/datashard_ut_common.cpp\nindex 6e19f17694b3..8dff10e43014 100644\n--- a/ydb/core/tx/datashard/ut_common/datashard_ut_common.cpp\n+++ b/ydb/core/tx/datashard/ut_common/datashard_ut_common.cpp\n@@ -2257,114 +2257,6 @@ NKikimrDataEvents::TEvWriteResult Update(TTestActorRuntime& runtime, TActorId se\n     return Write(runtime, sender, shardId, std::move(request), expectedStatus);\n }\n \n-TTestActorRuntimeBase::TEventObserverHolderPair ReplaceEvProposeTransactionWithEvWrite(TTestActorRuntime& runtime, TEvWriteRows& rows) {\n-    if (rows.empty())\n-        return {};\n-\n-    auto requestObserver = runtime.AddObserver([&rows](TAutoPtr<IEventHandle>& event) {\n-        if (event->GetTypeRewrite() != TEvDataShard::EvProposeTransaction)\n-            return;\n-\n-        const auto& record = event->Get<TEvDataShard::TEvProposeTransaction>()->Record;\n-\n-        if (record.GetTxKind() != NKikimrTxDataShard::TX_KIND_DATA)\n-            return;\n-\n-        // Parse original TEvProposeTransaction\n-        const ui64 txId = record.GetTxId();\n-        const TString& txBody = record.GetTxBody();\n-        NKikimrTxDataShard::TDataTransaction tx;\n-        Y_VERIFY(tx.ParseFromArray(txBody.data(), txBody.size()));\n-\n-        // Construct new EvWrite\n-        TVector<TCell> cells;\n-        TTableId tableId;\n-        ui16 colCount = 0;\n-        for (const auto& task : tx.GetKqpTransaction().GetTasks()) {\n-            NKikimrTxDataShard::TKqpTransaction::TDataTaskMeta meta;\n-            Y_VERIFY(task.GetMeta().UnpackTo(&meta));\n-            if (!meta.HasWrites())\n-                continue;\n-\n-            const auto& tableMeta = meta.GetTable();\n-            TTableId tableIdProto(tableMeta.GetTableId().GetOwnerId(), tableMeta.GetTableId().GetTableId(), tableMeta.GetSchemaVersion());\n-            Y_VERIFY_S(tableId == TTableId{} || tableId == tableIdProto, \"Only writes to one table is supported now\");\n-            tableId = tableIdProto;\n-            const auto& writes = meta.GetWrites();\n-            Y_VERIFY_S(colCount == 0 || colCount == writes.GetColumns().size(), \"Only equal column count is supported now.\");\n-            colCount = writes.GetColumns().size();\n-\n-            const auto& row = rows.ProcessRow(tableId, txId);\n-            Y_VERIFY(row.Cells.size() == colCount);\n-            std::copy(row.Cells.begin(), row.Cells.end(), std::back_inserter(cells));\n-        }\n-\n-        Cerr << \"TEvProposeTransaction \" << txId << \" is observed and will be replaced with EvWrite: \" << record.ShortDebugString() << Endl;\n-\n-        auto txMode = NKikimr::NDataShard::NEvWrite::TConvertor::GetTxMode(record.GetFlags());\n-\n-        auto evWrite = std::make_unique<NKikimr::NEvents::TDataEvents::TEvWrite>(txId, txMode);\n-\n-        if (!cells.empty()) {\n-            TSerializedCellMatrix matrix(cells, cells.size() / colCount, colCount);\n-            TString blobData = matrix.ReleaseBuffer();\n-\n-            UNIT_ASSERT(blobData.size() < 8_MB);\n-\n-            std::vector<ui32> columnIds(colCount);\n-            std::iota(columnIds.begin(), columnIds.end(), 1);\n-\n-            ui64 payloadIndex = NKikimr::NEvWrite::TPayloadWriter<NKikimr::NEvents::TDataEvents::TEvWrite>(*evWrite).AddDataToPayload(std::move(blobData));\n-            evWrite->AddOperation(NKikimrDataEvents::TEvWrite::TOperation::OPERATION_UPSERT, tableId, columnIds, payloadIndex, NKikimrDataEvents::FORMAT_CELLVEC);\n-        }\n-\n-        // Copy locks\n-        if (tx.HasLockTxId())\n-            evWrite->Record.SetLockTxId(tx.GetLockTxId());\n-        if (tx.HasLockNodeId())\n-            evWrite->Record.SetLockNodeId(tx.GetLockNodeId());\n-        if (tx.GetKqpTransaction().HasLocks())\n-            evWrite->Record.MutableLocks()->CopyFrom(tx.GetKqpTransaction().GetLocks());\n-\n-        if (record.HasMvccSnapshot()) {\n-            *evWrite->Record.MutableMvccSnapshot() = record.GetMvccSnapshot();\n-        }\n-\n-        // Replace event\n-        auto handle = new IEventHandle(event->Recipient, event->Sender, evWrite.release(), 0, event->Cookie);\n-        handle->Rewrite(handle->GetTypeRewrite(), event->GetRecipientRewrite());\n-        event.Reset(handle);\n-    });\n-\n-    auto responseObserver = runtime.AddObserver([](TAutoPtr<IEventHandle>& event) {\n-        if (event->GetTypeRewrite() != NEvents::TDataEvents::EvWriteResult)\n-            return;\n-\n-        const auto& record = event->Get<NEvents::TDataEvents::TEvWriteResult>()->Record;\n-        ui64 txId = record.GetTxId();\n-\n-        Cerr << \"EvWriteResult \" << txId << \" is observed and will be replaced with EvProposeTransactionResult: \" << record.ShortDebugString() << Endl;\n-\n-        // Construct new EvProposeTransactionResult\n-        ui64 origin = record.GetOrigin();\n-        auto status = NKikimr::NDataShard::NEvWrite::TConvertor::GetStatus(record.GetStatus());\n-\n-        auto evResult = std::make_unique<TEvDataShard::TEvProposeTransactionResult>(NKikimrTxDataShard::TX_KIND_DATA, origin, txId, status);\n-\n-        if (status == NKikimrTxDataShard::TEvProposeTransactionResult::PREPARED) {\n-            evResult->SetPrepared(record.GetMinStep(), record.GetMaxStep(), {});\n-            evResult->Record.MutableDomainCoordinators()->CopyFrom(record.GetDomainCoordinators());\n-        }\n-\n-        // Replace event\n-        auto handle = new IEventHandle(event->Recipient, event->Sender, evResult.release(), 0, event->Cookie);\n-        handle->Rewrite(handle->GetTypeRewrite(), event->GetRecipientRewrite());\n-        event.Reset(handle);\n-    });\n-\n-    return {std::move(requestObserver), std::move(responseObserver)};\n-}\n-\n NKikimrDataEvents::TEvWriteResult WaitForWriteCompleted(TTestActorRuntime& runtime, TActorId sender, NKikimrDataEvents::TEvWriteResult::EStatus expectedStatus)\n {\n     auto ev = runtime.GrabEdgeEventRethrow<NEvents::TDataEvents::TEvWriteResult>(sender);\ndiff --git a/ydb/core/tx/datashard/ut_common/datashard_ut_common.h b/ydb/core/tx/datashard/ut_common/datashard_ut_common.h\nindex 2c42040fdcaa..3381b4dae7ca 100644\n--- a/ydb/core/tx/datashard/ut_common/datashard_ut_common.h\n+++ b/ydb/core/tx/datashard/ut_common/datashard_ut_common.h\n@@ -836,8 +836,6 @@ class TEvWriteRows : public std::vector<TEvWriteRow> {\n     }\n };\n \n-TTestActorRuntimeBase::TEventObserverHolderPair ReplaceEvProposeTransactionWithEvWrite(TTestActorRuntime& runtime, TEvWriteRows& rows);\n-\n void UploadRows(TTestActorRuntime& runtime, const TString& tablePath, const TVector<std::pair<TString, Ydb::Type_PrimitiveTypeId>>& types, const TVector<TCell>& keys, const TVector<TCell>& values);\n \n struct TSendProposeToCoordinatorOptions {\n@@ -862,6 +860,11 @@ struct IsTxResultComplete {\n             if (status == NKikimrTxDataShard::TEvProposeTransactionResult::COMPLETE)\n                 return true;\n         }\n+        if (ev.GetTypeRewrite() == NKikimr::NEvents::TDataEvents::EvWriteResult) {\n+            auto status = ev.Get<NKikimr::NEvents::TDataEvents::TEvWriteResult>()->GetStatus();\n+            if (status == NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED)\n+                return true;\n+        }\n         return false;\n     }\n };\ndiff --git a/ydb/core/tx/datashard/ut_prefix_kmeans/ya.make b/ydb/core/tx/datashard/ut_prefix_kmeans/ya.make\nnew file mode 100644\nindex 000000000000..8c1a7869e441\n--- /dev/null\n+++ b/ydb/core/tx/datashard/ut_prefix_kmeans/ya.make\n@@ -0,0 +1,33 @@\n+UNITTEST_FOR(ydb/core/tx/datashard)\n+\n+FORK_SUBTESTS()\n+\n+SPLIT_FACTOR(1)\n+\n+IF (SANITIZER_TYPE == \"thread\" OR WITH_VALGRIND)\n+    SIZE(LARGE)\n+    TAG(ya:fat)\n+ELSE()\n+    SIZE(MEDIUM)\n+ENDIF()\n+\n+PEERDIR(\n+    ydb/core/tx/datashard/ut_common\n+    library/cpp/getopt\n+    library/cpp/regex/pcre\n+    library/cpp/svnversion\n+    ydb/core/kqp/ut/common\n+    ydb/core/testlib/default\n+    ydb/core/tx\n+    yql/essentials/public/udf/service/exception_policy\n+    ydb/public/lib/yson_value\n+    ydb/public/sdk/cpp/src/client/result\n+)\n+\n+YQL_LAST_ABI_VERSION()\n+\n+SRCS(\n+    datashard_ut_prefix_kmeans.cpp\n+)\n+\n+END()\ndiff --git a/ydb/core/tx/datashard/ya.make b/ydb/core/tx/datashard/ya.make\nindex 82fee3c74e78..4c7087836059 100644\n--- a/ydb/core/tx/datashard/ya.make\n+++ b/ydb/core/tx/datashard/ya.make\n@@ -181,6 +181,7 @@ SRCS(\n     operation.cpp\n     operation.h\n     plan_queue_unit.cpp\n+    prefix_kmeans.cpp\n     prepare_data_tx_in_rs_unit.cpp\n     prepare_distributed_erase_tx_in_rs_unit.cpp\n     prepare_kqp_data_tx_in_rs_unit.cpp\n@@ -326,6 +327,7 @@ RECURSE_FOR_TESTS(\n     ut_minstep\n     ut_object_storage_listing\n     ut_order\n+    ut_prefix_kmeans\n     ut_range_ops\n     ut_read_iterator\n     ut_read_table\ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/allocation.h b/ydb/core/tx/limiter/grouped_memory/service/allocation.h\nindex 678a4f97f859..a96377258984 100644\n--- a/ydb/core/tx/limiter/grouped_memory/service/allocation.h\n+++ b/ydb/core/tx/limiter/grouped_memory/service/allocation.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>\n+#include <ydb/library/signals/object_counter.h>\n #include <ydb/core/tx/limiter/grouped_memory/usage/abstract.h>\n \n namespace NKikimr::NOlap::NGroupedMemoryManager {\ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/counters.h b/ydb/core/tx/limiter/grouped_memory/service/counters.h\nindex 1d55b7b17f4a..2e75604b5792 100644\n--- a/ydb/core/tx/limiter/grouped_memory/service/counters.h\n+++ b/ydb/core/tx/limiter/grouped_memory/service/counters.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n \n namespace NKikimr::NOlap::NGroupedMemoryManager {\n \ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/group.h b/ydb/core/tx/limiter/grouped_memory/service/group.h\nindex 1c988081b02e..d97bf79012e8 100644\n--- a/ydb/core/tx/limiter/grouped_memory/service/group.h\n+++ b/ydb/core/tx/limiter/grouped_memory/service/group.h\n@@ -1,7 +1,7 @@\n #pragma once\n #include \"allocation.h\"\n \n-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>\n+#include <ydb/library/signals/object_counter.h>\n \n namespace NKikimr::NOlap::NGroupedMemoryManager {\n \ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/process.h b/ydb/core/tx/limiter/grouped_memory/service/process.h\nindex 3a53ff542750..a7631dd390ef 100644\n--- a/ydb/core/tx/limiter/grouped_memory/service/process.h\n+++ b/ydb/core/tx/limiter/grouped_memory/service/process.h\n@@ -2,7 +2,7 @@\n #include \"group.h\"\n #include \"ids.h\"\n \n-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>\n+#include <ydb/library/signals/object_counter.h>\n \n #include <ydb/library/accessor/validator.h>\n \ndiff --git a/ydb/core/tx/limiter/grouped_memory/service/ya.make b/ydb/core/tx/limiter/grouped_memory/service/ya.make\nindex d67332688426..7611cc6b7cb9 100644\n--- a/ydb/core/tx/limiter/grouped_memory/service/ya.make\n+++ b/ydb/core/tx/limiter/grouped_memory/service/ya.make\n@@ -12,7 +12,7 @@ SRCS(\n \n PEERDIR(\n     ydb/core/protos\n-    ydb/core/tx/columnshard/counters/common\n+    ydb/library/signals\n )\n \n GENERATE_ENUM_SERIALIZATION(allocation.h)\ndiff --git a/ydb/core/tx/limiter/service/service.h b/ydb/core/tx/limiter/service/service.h\nindex 32e9c45faca5..dd7fd10f3d49 100644\n--- a/ydb/core/tx/limiter/service/service.h\n+++ b/ydb/core/tx/limiter/service/service.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n #include <ydb/core/tx/limiter/usage/abstract.h>\n #include <ydb/core/tx/limiter/usage/config.h>\n #include <ydb/core/tx/limiter/usage/events.h>\ndiff --git a/ydb/core/tx/limiter/usage/abstract.h b/ydb/core/tx/limiter/usage/abstract.h\nindex ff3e460a771c..3a4b45983b5b 100644\n--- a/ydb/core/tx/limiter/usage/abstract.h\n+++ b/ydb/core/tx/limiter/usage/abstract.h\n@@ -1,6 +1,6 @@\n #pragma once\n #include <memory>\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n \n namespace NKikimr::NLimiter {\n class IResourceRequest {\ndiff --git a/ydb/core/tx/locks/locks.cpp b/ydb/core/tx/locks/locks.cpp\nindex 8b2b6ef03b5d..6162f8443245 100644\n--- a/ydb/core/tx/locks/locks.cpp\n+++ b/ydb/core/tx/locks/locks.cpp\n@@ -973,7 +973,7 @@ TLocksUpdate::~TLocksUpdate() {\n \n // TSysLocks\n \n-TVector<TSysLocks::TLock> TSysLocks::ApplyLocks() {\n+std::pair<TVector<TSysLocks::TLock>, TVector<ui64>> TSysLocks::ApplyLocks() {\n     Y_ABORT_UNLESS(Update);\n \n     TMicrosecTimerCounter measureApplyLocks(*Self, COUNTER_APPLY_LOCKS_USEC);\n@@ -988,8 +988,14 @@ TVector<TSysLocks::TLock> TSysLocks::ApplyLocks() {\n     Locker.RemoveBrokenRanges();\n \n     Update->FlattenBreakLocks();\n+\n+    TVector<ui64> brokenLocks;\n+    brokenLocks.reserve(Update->BreakLocks.Size());\n     if (Update->BreakLocks) {\n         Locker.BreakLocks(Update->BreakLocks, breakVersion);\n+        for (const auto& lock : Update->BreakLocks) {\n+            brokenLocks.push_back(lock.GetLockId());\n+        }\n     }\n \n     Locker.SaveBrokenPersistentLocks(Db);\n@@ -1019,7 +1025,7 @@ TVector<TSysLocks::TLock> TSysLocks::ApplyLocks() {\n         // Adding read/write conflicts implies locking\n         Y_ABORT_UNLESS(!Update->ReadConflictLocks);\n         Y_ABORT_UNLESS(!Update->WriteConflictLocks);\n-        return TVector<TLock>();\n+        return {TVector<TLock>(), brokenLocks};\n     }\n \n     TLockInfo::TPtr lock;\n@@ -1093,7 +1099,7 @@ TVector<TSysLocks::TLock> TSysLocks::ApplyLocks() {\n         out.emplace_back(MakeLock(Update->LockTxId, lock ? lock->GetGeneration() : Self->Generation(), counter,\n             table.GetTableId(), Update->Lock && Update->Lock->IsWriteLock()));\n     }\n-    return out;\n+    return {out, brokenLocks};\n }\n \n void TSysLocks::UpdateCounters() {\ndiff --git a/ydb/core/tx/locks/locks.h b/ydb/core/tx/locks/locks.h\nindex 76c486123aa0..042c079e5f10 100644\n--- a/ydb/core/tx/locks/locks.h\n+++ b/ydb/core/tx/locks/locks.h\n@@ -878,7 +878,7 @@ class TSysLocks {\n         Locker.RemoveSchema(tableId, db);\n     }\n \n-    TVector<TLock> ApplyLocks();\n+    std::pair<TVector<TLock>, TVector<ui64>> ApplyLocks();\n     ui64 ExtractLockTxId(const TArrayRef<const TCell>& syslockKey) const;\n     TLock GetLock(const TArrayRef<const TCell>& syslockKey) const;\n     void EraseLock(ui64 lockId);\ndiff --git a/ydb/core/tx/priorities/service/counters.h b/ydb/core/tx/priorities/service/counters.h\nindex 7eb2202d9556..660b84a40429 100644\n--- a/ydb/core/tx/priorities/service/counters.h\n+++ b/ydb/core/tx/priorities/service/counters.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n \n #include <library/cpp/monlib/dynamic_counters/counters.h>\n \ndiff --git a/ydb/core/tx/program/builder.cpp b/ydb/core/tx/program/builder.cpp\nindex 31a5d1be32f5..144a1b2bfe8c 100644\n--- a/ydb/core/tx/program/builder.cpp\n+++ b/ydb/core/tx/program/builder.cpp\n@@ -17,8 +17,17 @@\n \n namespace NKikimr::NArrow::NSSA {\n \n-TConclusion<std::shared_ptr<IStepFunction>> TProgramBuilder::MakeFunction(\n-    const TColumnInfo& name, const NKikimrSSA::TProgram::TAssignment::TFunction& func, std::vector<TColumnChainInfo>& arguments) const {\n+TConclusion<std::shared_ptr<IStepFunction>> TProgramBuilder::MakeFunction(const TColumnInfo& name,\n+    const NKikimrSSA::TProgram::TAssignment::TFunction& func, std::shared_ptr<NArrow::NSSA::IKernelLogic>& kernelLogic,\n+    std::vector<TColumnChainInfo>& arguments) const {\n+    if (func.GetKernelName()) {\n+        kernelLogic.reset(IKernelLogic::TFactory::Construct(func.GetKernelName()));\n+    } else if (func.HasYqlOperationId()) {\n+        kernelLogic = std::make_shared<TSimpleKernelLogic>(func.GetYqlOperationId());\n+    } else {\n+        kernelLogic = std::make_shared<TSimpleKernelLogic>();\n+    }\n+\n     using TId = NKikimrSSA::TProgram::TAssignment;\n \n     arguments.clear();\n@@ -27,6 +36,15 @@ TConclusion<std::shared_ptr<IStepFunction>> TProgramBuilder::MakeFunction(\n     }\n \n     if (func.GetFunctionType() == NKikimrSSA::TProgram::EFunctionType::TProgram_EFunctionType_YQL_KERNEL) {\n+        if (func.GetYqlOperationId() == (ui32)NYql::TKernelRequestBuilder::EBinaryOp::Equals) {\n+            kernelLogic = std::make_shared<TLogicEquals>(false);\n+        } else if (func.GetYqlOperationId() == (ui32)NYql::TKernelRequestBuilder::EBinaryOp::StringContains) {\n+            kernelLogic = std::make_shared<TLogicMatchString>(TIndexCheckOperation::EOperation::Contains, true, false);\n+        } else if (func.GetYqlOperationId() == (ui32)NYql::TKernelRequestBuilder::EBinaryOp::StartsWith) {\n+            kernelLogic = std::make_shared<TLogicMatchString>(TIndexCheckOperation::EOperation::StartsWith, true, false);\n+        } else if (func.GetYqlOperationId() == (ui32)NYql::TKernelRequestBuilder::EBinaryOp::EndsWith) {\n+            kernelLogic = std::make_shared<TLogicMatchString>(TIndexCheckOperation::EOperation::EndsWith, true, false);\n+        }\n         auto kernelFunction = KernelsRegistry.GetFunction(func.GetKernelIdx());\n         if (!kernelFunction) {\n             return TConclusionStatus::Fail(\n@@ -59,6 +77,7 @@ TConclusion<std::shared_ptr<IStepFunction>> TProgramBuilder::MakeFunction(\n \n     switch (func.GetId()) {\n         case TId::FUNC_CMP_EQUAL:\n+            kernelLogic = std::make_shared<TLogicEquals>(true);\n             return std::make_shared<TSimpleFunction>(EOperation::Equal);\n         case TId::FUNC_CMP_NOT_EQUAL:\n             return std::make_shared<TSimpleFunction>(EOperation::NotEqual);\n@@ -76,6 +95,7 @@ TConclusion<std::shared_ptr<IStepFunction>> TProgramBuilder::MakeFunction(\n             return std::make_shared<TSimpleFunction>(EOperation::BinaryLength);\n         case TId::FUNC_STR_MATCH: {\n             if (auto opts = mkLikeOptions(false)) {\n+                kernelLogic = std::make_shared<TLogicMatchString>(TIndexCheckOperation::EOperation::Contains, true, true);\n                 return std::make_shared<TSimpleFunction>(EOperation::MatchSubstring, opts);\n             }\n             break;\n@@ -88,30 +108,35 @@ TConclusion<std::shared_ptr<IStepFunction>> TProgramBuilder::MakeFunction(\n         }\n         case TId::FUNC_STR_STARTS_WITH: {\n             if (auto opts = mkLikeOptions(false)) {\n+                kernelLogic = std::make_shared<TLogicMatchString>(TIndexCheckOperation::EOperation::StartsWith, true, true);\n                 return std::make_shared<TSimpleFunction>(EOperation::StartsWith, opts);\n             }\n             break;\n         }\n         case TId::FUNC_STR_ENDS_WITH: {\n             if (auto opts = mkLikeOptions(false)) {\n+                kernelLogic = std::make_shared<TLogicMatchString>(TIndexCheckOperation::EOperation::EndsWith, true, true);\n                 return std::make_shared<TSimpleFunction>(EOperation::EndsWith, opts);\n             }\n             break;\n         }\n         case TId::FUNC_STR_MATCH_IGNORE_CASE: {\n             if (auto opts = mkLikeOptions(true)) {\n+                kernelLogic = std::make_shared<TLogicMatchString>(TIndexCheckOperation::EOperation::Contains, false, true);\n                 return std::make_shared<TSimpleFunction>(EOperation::MatchSubstring, opts);\n             }\n             break;\n         }\n         case TId::FUNC_STR_STARTS_WITH_IGNORE_CASE: {\n             if (auto opts = mkLikeOptions(true)) {\n+                kernelLogic = std::make_shared<TLogicMatchString>(TIndexCheckOperation::EOperation::StartsWith, false, true);\n                 return std::make_shared<TSimpleFunction>(EOperation::StartsWith, opts);\n             }\n             break;\n         }\n         case TId::FUNC_STR_ENDS_WITH_IGNORE_CASE: {\n             if (auto opts = mkLikeOptions(true)) {\n+                kernelLogic = std::make_shared<TLogicMatchString>(TIndexCheckOperation::EOperation::EndsWith, false, true);\n                 return std::make_shared<TSimpleFunction>(EOperation::EndsWith, opts);\n             }\n             break;\n@@ -276,18 +301,14 @@ TConclusionStatus TProgramBuilder::ReadAssign(\n     switch (assign.GetExpressionCase()) {\n         case TId::kFunction: {\n             std::shared_ptr<IKernelLogic> kernelLogic;\n-            if (assign.GetFunction().GetKernelName()) {\n-                kernelLogic.reset(IKernelLogic::TFactory::Construct(assign.GetFunction().GetKernelName()));\n-            }\n-\n             std::vector<TColumnChainInfo> arguments;\n-            auto function = MakeFunction(columnName, assign.GetFunction(), arguments);\n+            auto function = MakeFunction(columnName, assign.GetFunction(), kernelLogic, arguments);\n             if (function.IsFail()) {\n                 return function;\n             }\n \n-            if (assign.GetFunction().HasYqlOperationId() && assign.GetFunction().GetYqlOperationId() ==\n-                (ui32)NYql::TKernelRequestBuilder::EBinaryOp::And) {\n+            if (assign.GetFunction().HasYqlOperationId() &&\n+                assign.GetFunction().GetYqlOperationId() == (ui32)NYql::TKernelRequestBuilder::EBinaryOp::And) {\n                 auto processor =\n                     std::make_shared<TStreamLogicProcessor>(std::move(arguments), columnName.GetColumnId(), NKernels::EOperation::And);\n                 Builder.Add(processor);\n@@ -301,9 +322,6 @@ TConclusionStatus TProgramBuilder::ReadAssign(\n                 if (processor.IsFail()) {\n                     return processor;\n                 }\n-                if (assign.GetFunction().HasYqlOperationId()) {\n-                    processor.GetResult()->SetYqlOperationId(assign.GetFunction().GetYqlOperationId());\n-                }\n                 Builder.Add(processor.DetachResult());\n             }\n             break;\n@@ -399,7 +417,7 @@ TConclusionStatus TProgramBuilder::ReadGroupBy(const NKikimrSSA::TProgram::TGrou\n             }\n             auto aggrType = GetAggregationType(agg.GetFunction());\n             auto argColumnIds = extractColumnIds(agg.GetFunction().GetArguments());\n-            auto status = TCalculationProcessor::Build(std::move(argColumnIds), columnName.GetColumnId(), func.DetachResult(), nullptr);\n+            auto status = TCalculationProcessor::Build(std::move(argColumnIds), columnName.GetColumnId(), func.DetachResult(), std::make_shared<TSimpleKernelLogic>());\n             if (status.IsFail()) {\n                 return status;\n             }\ndiff --git a/ydb/core/tx/program/builder.h b/ydb/core/tx/program/builder.h\nindex 94d679300874..5e7b0fcb17dd 100644\n--- a/ydb/core/tx/program/builder.h\n+++ b/ydb/core/tx/program/builder.h\n@@ -7,6 +7,7 @@\n #include <ydb/core/formats/arrow/program/functions.h>\n #include <ydb/core/formats/arrow/program/graph_execute.h>\n #include <ydb/core/formats/arrow/program/graph_optimization.h>\n+#include <ydb/core/formats/arrow/program/kernel_logic.h>\n \n #include <ydb/library/formats/arrow/protos/ssa.pb.h>\n \n@@ -37,8 +38,9 @@ class TProgramBuilder {\n     TColumnInfo GetColumnInfo(const NKikimrSSA::TProgram::TColumn& column) const;\n \n     std::string GenerateName(const NKikimrSSA::TProgram::TColumn& column) const;\n-    [[nodiscard]] TConclusion<std::shared_ptr<IStepFunction>> MakeFunction(\n-        const TColumnInfo& name, const NKikimrSSA::TProgram::TAssignment::TFunction& func, std::vector<TColumnChainInfo>& arguments) const;\n+    [[nodiscard]] TConclusion<std::shared_ptr<IStepFunction>> MakeFunction(const TColumnInfo& name,\n+        const NKikimrSSA::TProgram::TAssignment::TFunction& func, std::shared_ptr<IKernelLogic>& kernelLogic,\n+        std::vector<TColumnChainInfo>& arguments) const;\n     [[nodiscard]] TConclusion<std::shared_ptr<TConstProcessor>> MakeConstant(\n         const TColumnInfo& name, const NKikimrSSA::TProgram::TConstant& constant) const;\n     [[nodiscard]] TConclusion<std::shared_ptr<TConstProcessor>> MaterializeParameter(const TColumnInfo& name,\ndiff --git a/ydb/core/tx/program/program.cpp b/ydb/core/tx/program/program.cpp\nindex 19eaf54a7d1d..bd08ca83b361 100644\n--- a/ydb/core/tx/program/program.cpp\n+++ b/ydb/core/tx/program/program.cpp\n@@ -94,8 +94,8 @@ TConclusionStatus TProgramContainer::ParseProgram(const NArrow::NSSA::IColumnRes\n     using TId = NKikimrSSA::TProgram::TCommand;\n \n     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)(\"parse_proto_program\", program.DebugString());\n-//    Cerr << program.DebugString() << Endl;\n     NArrow::NSSA::TProgramBuilder programBuilder(columnResolver, KernelsRegistry);\n+    bool hasProjection = false;\n     for (auto& cmd : program.GetCommand()) {\n         switch (cmd.GetLineCase()) {\n             case TId::kAssign: {\n@@ -117,6 +117,7 @@ TConclusionStatus TProgramContainer::ParseProgram(const NArrow::NSSA::IColumnRes\n                 if (status.IsFail()) {\n                     return status;\n                 }\n+                hasProjection = true;\n                 break;\n             }\n             case TId::kGroupBy: {\n@@ -130,6 +131,9 @@ TConclusionStatus TProgramContainer::ParseProgram(const NArrow::NSSA::IColumnRes\n                 return TConclusionStatus::Fail(\"incorrect SSA line case\");\n         }\n     }\n+    if (!hasProjection) {\n+        return TConclusionStatus::Fail(\"program has no projections\");\n+    }\n     auto programStatus = programBuilder.Finish();\n     if (programStatus.IsFail()) {\n         return programStatus;\ndiff --git a/ydb/core/tx/schemeshard/olap/column_families/schema.cpp b/ydb/core/tx/schemeshard/olap/column_families/schema.cpp\nindex 957788be869a..7453de281940 100644\n--- a/ydb/core/tx/schemeshard/olap/column_families/schema.cpp\n+++ b/ydb/core/tx/schemeshard/olap/column_families/schema.cpp\n@@ -87,7 +87,7 @@ void TOlapColumnFamiliesDescription::Serialize(NKikimrSchemeOp::TColumnTableSche\n     }\n }\n \n-bool TOlapColumnFamiliesDescription::Validate(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const {\n+bool TOlapColumnFamiliesDescription::ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const {\n     ui32 lastColumnFamilyId = 0;\n     THashSet<ui32> usedColumnFamilies;\n     for (const auto& familyProto : opSchema.GetColumnFamilies()) {\ndiff --git a/ydb/core/tx/schemeshard/olap/column_families/schema.h b/ydb/core/tx/schemeshard/olap/column_families/schema.h\nindex 046321f8a2e9..2fd6736d8231 100644\n--- a/ydb/core/tx/schemeshard/olap/column_families/schema.h\n+++ b/ydb/core/tx/schemeshard/olap/column_families/schema.h\n@@ -39,6 +39,6 @@ class TOlapColumnFamiliesDescription {\n \n     bool Parse(const NKikimrSchemeOp::TColumnTableSchema& tableSchema);\n     void Serialize(NKikimrSchemeOp::TColumnTableSchema& tableSchema) const;\n-    bool Validate(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;\n+    bool ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;\n };\n }\ndiff --git a/ydb/core/tx/schemeshard/olap/columns/schema.cpp b/ydb/core/tx/schemeshard/olap/columns/schema.cpp\nindex f533a3476bf9..3ff56dbbdbaf 100644\n--- a/ydb/core/tx/schemeshard/olap/columns/schema.cpp\n+++ b/ydb/core/tx/schemeshard/olap/columns/schema.cpp\n@@ -165,7 +165,7 @@ void TOlapColumnsDescription::Serialize(NKikimrSchemeOp::TColumnTableSchema& tab\n     }\n }\n \n-bool TOlapColumnsDescription::Validate(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const {\n+bool TOlapColumnsDescription::ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const {\n     const NScheme::TTypeRegistry* typeRegistry = AppData()->TypeRegistry;\n \n     ui32 lastColumnId = 0;\ndiff --git a/ydb/core/tx/schemeshard/olap/columns/schema.h b/ydb/core/tx/schemeshard/olap/columns/schema.h\nindex c8604d55e997..c4c8d88998c4 100644\n--- a/ydb/core/tx/schemeshard/olap/columns/schema.h\n+++ b/ydb/core/tx/schemeshard/olap/columns/schema.h\n@@ -58,6 +58,6 @@ class TOlapColumnsDescription {\n \n     void Parse(const NKikimrSchemeOp::TColumnTableSchema& tableSchema);\n     void Serialize(NKikimrSchemeOp::TColumnTableSchema& tableSchema) const;\n-    bool Validate(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;\n+    bool ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;\n };\n }\ndiff --git a/ydb/core/tx/schemeshard/olap/indexes/schema.cpp b/ydb/core/tx/schemeshard/olap/indexes/schema.cpp\nindex 8b00178a459c..a0fe974394e0 100644\n--- a/ydb/core/tx/schemeshard/olap/indexes/schema.cpp\n+++ b/ydb/core/tx/schemeshard/olap/indexes/schema.cpp\n@@ -83,7 +83,10 @@ void TOlapIndexesDescription::Serialize(NKikimrSchemeOp::TColumnTableSchema& tab\n     }\n }\n \n-bool TOlapIndexesDescription::Validate(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const {\n+bool TOlapIndexesDescription::ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const {\n+    if (opSchema.GetIndexes().size() == 0) {\n+        return true;\n+    }\n     THashSet<ui32> usedIndexes;\n     ui32 lastIdx = 0;\n     for (const auto& proto : opSchema.GetIndexes()) {\ndiff --git a/ydb/core/tx/schemeshard/olap/indexes/schema.h b/ydb/core/tx/schemeshard/olap/indexes/schema.h\nindex 630016fe96a5..66a79eeed588 100644\n--- a/ydb/core/tx/schemeshard/olap/indexes/schema.h\n+++ b/ydb/core/tx/schemeshard/olap/indexes/schema.h\n@@ -77,6 +77,6 @@ class TOlapIndexesDescription {\n \n     void Parse(const NKikimrSchemeOp::TColumnTableSchema& tableSchema);\n     void Serialize(NKikimrSchemeOp::TColumnTableSchema& tableSchema) const;\n-    bool Validate(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;\n+    bool ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;\n };\n }\ndiff --git a/ydb/core/tx/schemeshard/olap/operations/create_table.cpp b/ydb/core/tx/schemeshard/olap/operations/create_table.cpp\nindex 7e5211821d3b..01403b255aa2 100644\n--- a/ydb/core/tx/schemeshard/olap/operations/create_table.cpp\n+++ b/ydb/core/tx/schemeshard/olap/operations/create_table.cpp\n@@ -99,7 +99,7 @@ class TTableConstructorBase {\n \n class TOlapPresetConstructor : public TTableConstructorBase {\n     ui32 PresetId = 0;\n-    TString PresetName = \"default\";\n+    TString PresetName = TOlapStoreInfo::DefaultPresetName;\n     const TOlapStoreInfo& StoreInfo;\n     mutable bool NeedUpdateObject = false;\n public:\n@@ -118,27 +118,16 @@ class TOlapPresetConstructor : public TTableConstructorBase {\n             return false;\n         }\n \n-        if (description.HasSchemaPresetId()) {\n-            PresetId = description.GetSchemaPresetId();\n-            if (!StoreInfo.SchemaPresets.contains(PresetId)) {\n-                errors.AddError(Sprintf(\"Specified schema preset %\" PRIu32 \" does not exist in tablestore\", PresetId));\n-                return false;\n-            }\n-            PresetName = StoreInfo.SchemaPresets.at(PresetId).GetName();\n-        } else {\n-            if (description.HasSchemaPresetName()) {\n-                PresetName = description.GetSchemaPresetName();\n-            }\n-            if (!StoreInfo.SchemaPresetByName.contains(PresetName)) {\n-                errors.AddError(Sprintf(\"Specified schema preset '%s' does not exist in tablestore\", PresetName.c_str()));\n-                return false;\n-            }\n-            PresetId = StoreInfo.SchemaPresetByName.at(PresetName);\n-            Y_ABORT_UNLESS(StoreInfo.SchemaPresets.contains(PresetId));\n+        auto* preset = StoreInfo.GetPresetOptional(description);\n+        if (!preset) {\n+            errors.AddError(\"preset not found in tables store\");\n+            return false;\n         }\n+        PresetId = preset->GetId();\n+        PresetName = preset->GetName();\n \n         if (description.HasSchema()) {\n-            if (!GetSchema().Validate(description.GetSchema(), errors)) {\n+            if (!GetSchema().ValidateForStore(description.GetSchema(), errors)) {\n                 return false;\n             }\n         }\ndiff --git a/ydb/core/tx/schemeshard/olap/options/schema.cpp b/ydb/core/tx/schemeshard/olap/options/schema.cpp\nindex 59f9df521f34..033ef33ccd0d 100644\n--- a/ydb/core/tx/schemeshard/olap/options/schema.cpp\n+++ b/ydb/core/tx/schemeshard/olap/options/schema.cpp\n@@ -42,7 +42,10 @@ void TOlapOptionsDescription::Serialize(NKikimrSchemeOp::TColumnTableSchema& tab\n     }\n }\n \n-bool TOlapOptionsDescription::Validate(const NKikimrSchemeOp::TColumnTableSchema& /*opSchema*/, IErrorCollector& /*errors*/) const {\n+bool TOlapOptionsDescription::ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& /*errors*/) const {\n+    if (!opSchema.HasOptions()) {\n+        return true;\n+    }\n     return true;\n }\n \ndiff --git a/ydb/core/tx/schemeshard/olap/options/schema.h b/ydb/core/tx/schemeshard/olap/options/schema.h\nindex 070bd16437e7..575152a271d2 100644\n--- a/ydb/core/tx/schemeshard/olap/options/schema.h\n+++ b/ydb/core/tx/schemeshard/olap/options/schema.h\n@@ -16,6 +16,6 @@ class TOlapOptionsDescription {\n \n     void Parse(const NKikimrSchemeOp::TColumnTableSchema& tableSchema);\n     void Serialize(NKikimrSchemeOp::TColumnTableSchema& tableSchema) const;\n-    bool Validate(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;\n+    bool ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;\n };\n }\ndiff --git a/ydb/core/tx/schemeshard/olap/schema/schema.cpp b/ydb/core/tx/schemeshard/olap/schema/schema.cpp\nindex 82e2a499bdd9..03428f46e551 100644\n--- a/ydb/core/tx/schemeshard/olap/schema/schema.cpp\n+++ b/ydb/core/tx/schemeshard/olap/schema/schema.cpp\n@@ -71,16 +71,20 @@ void TOlapSchema::Serialize(NKikimrSchemeOp::TColumnTableSchema& tableSchemaExt)\n     std::swap(resultLocal, tableSchemaExt);\n }\n \n-bool TOlapSchema::Validate(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const {\n-    if (!Columns.Validate(opSchema, errors)) {\n+bool TOlapSchema::ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const {\n+    if (!Columns.ValidateForStore(opSchema, errors)) {\n         return false;\n     }\n \n-    if (!Indexes.Validate(opSchema, errors)) {\n+    if (!Indexes.ValidateForStore(opSchema, errors)) {\n         return false;\n     }\n \n-    if (!Options.Validate(opSchema, errors)) {\n+    if (!Options.ValidateForStore(opSchema, errors)) {\n+        return false;\n+    }\n+\n+    if (!ColumnFamilies.ValidateForStore(opSchema, errors)) {\n         return false;\n     }\n     return true;\ndiff --git a/ydb/core/tx/schemeshard/olap/schema/schema.h b/ydb/core/tx/schemeshard/olap/schema/schema.h\nindex 9e950b36c99e..3086ff883fa2 100644\n--- a/ydb/core/tx/schemeshard/olap/schema/schema.h\n+++ b/ydb/core/tx/schemeshard/olap/schema/schema.h\n@@ -30,7 +30,7 @@ namespace NKikimr::NSchemeShard {\n \n         void ParseFromLocalDB(const NKikimrSchemeOp::TColumnTableSchema& tableSchema);\n         void Serialize(NKikimrSchemeOp::TColumnTableSchema& tableSchema) const;\n-        bool Validate(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;\n+        bool ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;\n         bool ValidateTtlSettings(const NKikimrSchemeOp::TColumnDataLifeCycle& ttlSettings, const TOperationContext& context, IErrorCollector& errors) const;\n     };\n \ndiff --git a/ydb/core/tx/schemeshard/olap/store/store.h b/ydb/core/tx/schemeshard/olap/store/store.h\nindex 84ae9148573c..b5719f3aed91 100644\n--- a/ydb/core/tx/schemeshard/olap/store/store.h\n+++ b/ydb/core/tx/schemeshard/olap/store/store.h\n@@ -17,6 +17,8 @@ struct TOlapStoreInfo {\n     NKikimrSchemeOp::TColumnStoreDescription Description;\n     ui64 AlterVersion = 0;\n public:\n+    static const inline TString DefaultPresetName = \"default\";\n+\n     using TPtr = std::shared_ptr<TOlapStoreInfo>;\n \n     class TLayoutInfo {\n@@ -99,6 +101,41 @@ struct TOlapStoreInfo {\n             shardInfoProto->SetLocalId(idx.GetLocalId().GetValue());\n         }\n     }\n+\n+    const TOlapStoreSchemaPreset* GetPresetOptional(const ui32 presetId) const {\n+        auto it = SchemaPresets.find(presetId);\n+        if (it == SchemaPresets.end()) {\n+            return nullptr;\n+        }\n+        return &it->second;\n+    }\n+\n+    const TOlapStoreSchemaPreset& GetPresetVerified(const ui32 presetId) const {\n+        auto* result = GetPresetOptional(presetId);\n+        AFL_VERIFY(result);\n+        return *result;\n+    }\n+\n+    const TOlapStoreSchemaPreset* GetPresetOptional(const TString& presetName) const {\n+        auto it = SchemaPresetByName.find(presetName);\n+        if (it == SchemaPresetByName.end()) {\n+            return nullptr;\n+        }\n+        return &GetPresetVerified(it->second);\n+    }\n+\n+    const TOlapStoreSchemaPreset* GetPresetOptional(const NKikimrSchemeOp::TColumnTableDescription& description) const {\n+        if (description.HasSchemaPresetId()) {\n+            return GetPresetOptional(description.GetSchemaPresetId());\n+        } else {\n+            if (description.HasSchemaPresetName()) {\n+                return GetPresetOptional(description.GetSchemaPresetName());\n+            } else {\n+                return GetPresetOptional(DefaultPresetName);\n+            }\n+        }\n+    }\n+\n     void SerializeDescription(NKikimrSchemeOp::TColumnStoreDescription& descriptionProto) const;\n     void ParseFromLocalDB(const NKikimrSchemeOp::TColumnStoreDescription& descriptionProto);\n     bool ParseFromRequest(const NKikimrSchemeOp::TColumnStoreDescription& descriptionProto, IErrorCollector& errors);\ndiff --git a/ydb/core/tx/schemeshard/schemeshard__operation_modify_acl.cpp b/ydb/core/tx/schemeshard/schemeshard__operation_modify_acl.cpp\nindex f54c004cf5f9..b021c7d656c7 100644\n--- a/ydb/core/tx/schemeshard/schemeshard__operation_modify_acl.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard__operation_modify_acl.cpp\n@@ -54,7 +54,7 @@ class TModifyACL: public TSubOperationBase {\n         }\n \n         TString errStr;\n-        if (!context.SS->CheckApplyIf(Transaction, errStr)) {\n+        if (!context.SS->CheckApplyIf(Transaction, errStr, path->PathType)) {\n             result->SetError(NKikimrScheme::StatusPreconditionFailed, errStr);\n             return result;\n         }\ndiff --git a/ydb/core/tx/schemeshard/schemeshard_build_index.cpp b/ydb/core/tx/schemeshard/schemeshard_build_index.cpp\nindex 90a93627e866..9071b11c5b72 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_build_index.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard_build_index.cpp\n@@ -40,6 +40,10 @@ void TSchemeShard::Handle(TEvDataShard::TEvLocalKMeansResponse::TPtr& ev, const\n     Execute(CreateTxReply(ev), ctx);\n }\n \n+void TSchemeShard::Handle(TEvDataShard::TEvPrefixKMeansResponse::TPtr& ev, const TActorContext& ctx) {\n+    Execute(CreateTxReply(ev), ctx);\n+}\n+\n void TSchemeShard::Handle(TEvIndexBuilder::TEvUploadSampleKResponse::TPtr& ev, const TActorContext& ctx) {\n     Execute(CreateTxReply(ev), ctx);\n }\ndiff --git a/ydb/core/tx/schemeshard/schemeshard_build_index__create.cpp b/ydb/core/tx/schemeshard/schemeshard_build_index__create.cpp\nindex 98c75f6de42b..5c5e08eff44b 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_build_index__create.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard_build_index__create.cpp\n@@ -224,13 +224,15 @@ class TSchemeShard::TIndexBuilder::TTxCreate: public TSchemeShard::TIndexBuilder\n             explain = \"unsupported index type to build\";\n             return false;\n         case Ydb::Table::TableIndex::TypeCase::kGlobalVectorKmeansTreeIndex: {\n-            buildInfo.BuildKind = TIndexBuildInfo::EBuildKind::BuildVectorIndex;\n+            buildInfo.BuildKind = index.index_columns().size() == 1\n+                ? TIndexBuildInfo::EBuildKind::BuildVectorIndex\n+                : TIndexBuildInfo::EBuildKind::BuildPrefixedVectorIndex;\n             buildInfo.IndexType = NKikimrSchemeOp::EIndexType::EIndexTypeGlobalVectorKmeansTree;\n             NKikimrSchemeOp::TVectorIndexKmeansTreeDescription vectorIndexKmeansTreeDescription;\n             *vectorIndexKmeansTreeDescription.MutableSettings() = index.global_vector_kmeans_tree_index().vector_settings();\n             buildInfo.SpecializedIndexDescription = vectorIndexKmeansTreeDescription;\n             buildInfo.KMeans.K = std::max<ui32>(2, vectorIndexKmeansTreeDescription.GetSettings().clusters());\n-            buildInfo.KMeans.Levels = std::max<ui32>(1, vectorIndexKmeansTreeDescription.GetSettings().levels());\n+            buildInfo.KMeans.Levels = buildInfo.IsBuildPrefixedVectorIndex() + std::max<ui32>(1, vectorIndexKmeansTreeDescription.GetSettings().levels());\n             break;\n         }\n         case Ydb::Table::TableIndex::TypeCase::TYPE_NOT_SET:\ndiff --git a/ydb/core/tx/schemeshard/schemeshard_build_index__progress.cpp b/ydb/core/tx/schemeshard/schemeshard_build_index__progress.cpp\nindex e124b34d69cc..df3e83bc1b80 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_build_index__progress.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard_build_index__progress.cpp\n@@ -21,6 +21,9 @@\n namespace NKikimr {\n namespace NSchemeShard {\n \n+// TODO(mbkkt) get table rows count (but even better to have unique prefixes count)\n+static constexpr ui64 TableSize = 1'000;\n+\n static constexpr const char* Name(TIndexBuildInfo::EState state) noexcept {\n     switch (state) {\n     case TIndexBuildInfo::EState::Invalid:\n@@ -64,7 +67,7 @@ static constexpr const char* Name(TIndexBuildInfo::EState state) noexcept {\n static std::tuple<NTableIndex::TClusterId, NTableIndex::TClusterId, NTableIndex::TClusterId> ComputeKMeansBoundaries(const NSchemeShard::TTableInfo& tableInfo, const TIndexBuildInfo& buildInfo) {\n     const auto& kmeans = buildInfo.KMeans;\n     Y_ASSERT(kmeans.K != 0);\n-    const auto count = TIndexBuildInfo::TKMeans::BinPow(kmeans.K, kmeans.Level);\n+    const auto count = kmeans.ChildCount();\n     NTableIndex::TClusterId step = 1;\n     auto parts = count;\n     auto shards = tableInfo.GetShard2PartitionIdx().size();\n@@ -321,10 +324,14 @@ THolder<TEvSchemeShard::TEvModifySchemeTransaction> CreateBuildPropose(\n         buildInfo.SerializeToProto(ss, modifyScheme.MutableInitiateIndexBuild());\n         const auto& indexDesc = modifyScheme.GetInitiateIndexBuild().GetIndex();\n         const auto& baseTableColumns = NTableIndex::ExtractInfo(tableInfo);\n-        const auto& indexKeys = NTableIndex::ExtractInfo(indexDesc);\n+        auto indexKeys = NTableIndex::ExtractInfo(indexDesc);\n+        if (buildInfo.IsBuildPrefixedVectorIndex() && buildInfo.KMeans.Level != 1) {\n+            Y_ASSERT(indexKeys.KeyColumns.size() >= 2);\n+            indexKeys.KeyColumns.erase(indexKeys.KeyColumns.begin(), indexKeys.KeyColumns.end() - 1);\n+        }\n         implTableColumns = CalcTableImplDescription(buildInfo.IndexType, baseTableColumns, indexKeys);\n-        Y_ABORT_UNLESS(indexKeys.KeyColumns.size() == 1);\n-        implTableColumns.Columns.emplace(indexKeys.KeyColumns[0]);\n+        Y_ABORT_UNLESS(indexKeys.KeyColumns.size() >= 1);\n+        implTableColumns.Columns.emplace(indexKeys.KeyColumns.back());\n         modifyScheme.ClearInitiateIndexBuild();\n     }\n \n@@ -337,26 +344,38 @@ THolder<TEvSchemeShard::TEvModifySchemeTransaction> CreateBuildPropose(\n     modifyScheme.SetOperationType(NKikimrSchemeOp::ESchemeOpInitiateBuildIndexImplTable);\n     auto& op = *modifyScheme.MutableCreateTable();\n     std::string_view suffix = buildInfo.KMeans.Level % 2 != 0 ? BuildSuffix0 : BuildSuffix1;\n+    auto resetPartitionsSettings = [&] {\n+        auto& config = *op.MutablePartitionConfig();\n+        config.SetShadowData(false);\n+\n+        auto& policy = *config.MutablePartitioningPolicy();\n+        policy.SetSizeToSplit(0); // disable auto split/merge\n+        policy.ClearFastSplitSettings();\n+        policy.ClearSplitByLoadSettings();\n+\n+        op.ClearSplitBoundary();\n+        return &policy;\n+    };\n+    if (buildInfo.IsBuildPrefixedVectorIndex() && buildInfo.KMeans.Level == 1) {\n+        op.SetName(TString::Join(PostingTable, suffix));\n+        NTableIndex::FillIndexTableColumns(tableInfo->Columns, implTableColumns.Keys, implTableColumns.Columns, op);\n+        auto& policy = *resetPartitionsSettings();\n+        const auto shards = tableInfo->GetShard2PartitionIdx().size();\n+        policy.SetMinPartitionsCount(shards);\n+        policy.SetMaxPartitionsCount(shards);\n+        return propose;\n+    }\n     op = CalcVectorKmeansTreePostingImplTableDesc({}, tableInfo, tableInfo->PartitionConfig(), implTableColumns, {}, suffix);\n-\n     const auto [count, parts, step] = ComputeKMeansBoundaries(*tableInfo, buildInfo);\n \n-    auto& config = *op.MutablePartitionConfig();\n-    config.SetShadowData(false);\n-\n-    auto& policy = *config.MutablePartitioningPolicy();\n-    policy.SetSizeToSplit(0); // disable auto split/merge\n-    policy.ClearFastSplitSettings();\n-    policy.ClearSplitByLoadSettings();\n-\n-    op.ClearSplitBoundary();\n+    auto& policy = *resetPartitionsSettings();\n     static constexpr std::string_view LogPrefix = \"Create build table boundaries for \";\n     LOG_D(buildInfo.Id << \" table \" << suffix\n         << \", count: \" << count << \", parts: \" << parts << \", step: \" << step\n         << \", kmeans: \" << buildInfo.KMeansTreeToDebugStr());\n     if (parts > 1) {\n-        const auto parentFrom = buildInfo.KMeans.ParentEnd + 1;\n-        for (auto i = parentFrom + step, e = parentFrom + count; i < e; i += step) {\n+        const auto from = buildInfo.KMeans.ChildBegin;\n+        for (auto i = from + step, e = from + count; i < e; i += step) {\n             LOG_D(buildInfo.Id << \" table \" << suffix << \" value: \" << i);\n             auto cell = TCell::Make(i);\n             op.AddSplitBoundary()->SetSerializedKeyPrefix(TSerializedCellVec::Serialize({&cell, 1}));\n@@ -491,14 +510,16 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n \n     TDeque<std::tuple<TTabletId, ui64, THolder<IEventBase>>> ToTabletSend;\n \n-    template <typename Record>\n+    template <bool WithSnapshot = true, typename Record>\n     TTabletId CommonFillRecord(Record& record, TShardIdx shardIdx, TIndexBuildInfo& buildInfo) {\n         TTabletId shardId = Self->ShardInfos.at(shardIdx).TabletID;\n         record.SetTabletId(ui64(shardId));\n-        if (buildInfo.SnapshotTxId) {\n-            Y_ASSERT(buildInfo.SnapshotStep);\n-            record.SetSnapshotTxId(ui64(buildInfo.SnapshotTxId));\n-            record.SetSnapshotStep(ui64(buildInfo.SnapshotStep));\n+        if constexpr (WithSnapshot) {\n+            if (buildInfo.SnapshotTxId) {\n+                Y_ASSERT(buildInfo.SnapshotStep);\n+                record.SetSnapshotTxId(ui64(buildInfo.SnapshotTxId));\n+                record.SetSnapshotStep(ui64(buildInfo.SnapshotStep));\n+            }\n         }\n \n         auto& shardStatus = buildInfo.Shards.at(shardIdx);\n@@ -521,7 +542,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n         auto ev = MakeHolder<TEvDataShard::TEvSampleKRequest>();\n         ev->Record.SetId(ui64(BuildId));\n \n-        if (buildInfo.KMeans.Parent == 0) {\n+        if (buildInfo.KMeans.Level == 1) {\n             buildInfo.TablePathId.ToProto(ev->Record.MutablePathId());\n         } else {\n             auto path = TPath::Init(buildInfo.TablePathId, Self).Dive(buildInfo.IndexName);\n@@ -537,7 +558,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n             range.Serialize(*ev->Record.MutableKeyRange());\n         }\n \n-        ev->Record.AddColumns(buildInfo.IndexColumns[0]);\n+        ev->Record.AddColumns(buildInfo.IndexColumns.back());\n \n         auto shardId = CommonFillRecord(ev->Record, shardIdx, buildInfo);\n         ev->Record.SetSeed(ui64(shardId));\n@@ -552,7 +573,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n         ev->Record.SetId(ui64(BuildId));\n \n         auto path = TPath::Init(buildInfo.TablePathId, Self).Dive(buildInfo.IndexName);\n-        if (buildInfo.KMeans.Parent == 0) {\n+        if (buildInfo.KMeans.Level == 1) {\n             buildInfo.TablePathId.ToProto(ev->Record.MutablePathId());\n         } else {\n             path.Dive(buildInfo.KMeans.ReadFrom())->PathId.ToProto(ev->Record.MutablePathId());\n@@ -563,7 +584,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n             buildInfo.SpecializedIndexDescription).GetSettings().settings();\n         ev->Record.SetUpload(buildInfo.KMeans.GetUpload());\n         ev->Record.SetParent(buildInfo.KMeans.Parent);\n-        ev->Record.SetChild(buildInfo.KMeans.ChildBegin);\n+        ev->Record.SetChild(buildInfo.KMeans.Child);\n \n         auto& clusters = *ev->Record.MutableClusters();\n         clusters.Reserve(buildInfo.Sample.Rows.size());\n@@ -573,7 +594,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n \n         ev->Record.SetPostingName(path.Dive(buildInfo.KMeans.WriteTo()).PathString());\n \n-        ev->Record.SetEmbeddingColumn(buildInfo.IndexColumns[0]);\n+        ev->Record.SetEmbeddingColumn(buildInfo.IndexColumns.back());\n         *ev->Record.MutableDataColumns() = {\n             buildInfo.DataColumns.begin(), buildInfo.DataColumns.end()\n         };\n@@ -596,7 +617,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n         ev->Record.SetId(ui64(BuildId));\n \n         auto path = TPath::Init(buildInfo.TablePathId, Self).Dive(buildInfo.IndexName);\n-        if (buildInfo.KMeans.Parent == 0) {\n+        if (buildInfo.KMeans.Level == 1) {\n             buildInfo.TablePathId.ToProto(ev->Record.MutablePathId());\n         } else {\n             path.Dive(buildInfo.KMeans.ReadFrom())->PathId.ToProto(ev->Record.MutablePathId());\n@@ -614,12 +635,11 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n         if (buildInfo.KMeans.State != TIndexBuildInfo::TKMeans::MultiLocal) {\n             ev->Record.SetParentFrom(buildInfo.KMeans.Parent);\n             ev->Record.SetParentTo(buildInfo.KMeans.Parent);\n-            ev->Record.SetChild(buildInfo.KMeans.ChildBegin);\n+            ev->Record.SetChild(buildInfo.KMeans.Child);\n         } else {\n             const auto& range = buildInfo.Shards.at(shardIdx).Range;\n             const auto [parentFrom, parentTo] = buildInfo.KMeans.RangeToBorders(range);\n-            // child begin for parent from = (last child begin + K) - (last parent - parent from + 1) * K\n-            const auto childBegin = buildInfo.KMeans.ChildBegin - (buildInfo.KMeans.ParentEnd - parentFrom) * buildInfo.KMeans.K;\n+            const auto childBegin = buildInfo.KMeans.ChildBegin + (parentFrom - buildInfo.KMeans.ParentBegin) * buildInfo.KMeans.K;\n             LOG_D(\"shard \" << shardIdx << \", parent range { From: \" << parentFrom << \", To: \" << parentTo << \" }, child begin \" << childBegin);\n             ev->Record.SetParentFrom(parentFrom);\n             ev->Record.SetParentTo(parentTo);\n@@ -630,7 +650,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n         path.Rise().Dive(NTableIndex::NTableVectorKmeansTreeIndex::LevelTable);\n         ev->Record.SetLevelName(path.PathString());\n \n-        ev->Record.SetEmbeddingColumn(buildInfo.IndexColumns[0]);\n+        ev->Record.SetEmbeddingColumn(buildInfo.IndexColumns.back());\n         *ev->Record.MutableDataColumns() = {\n             buildInfo.DataColumns.begin(), buildInfo.DataColumns.end()\n         };\n@@ -642,6 +662,46 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n         ToTabletSend.emplace_back(shardId, ui64(BuildId), std::move(ev));\n     }\n \n+    void SendPrefixKMeansRequest(TShardIdx shardIdx, TIndexBuildInfo& buildInfo) {\n+        Y_ASSERT(buildInfo.IsBuildPrefixedVectorIndex());\n+        Y_ASSERT(buildInfo.KMeans.Parent == buildInfo.KMeans.ParentEnd());\n+        Y_ASSERT(buildInfo.KMeans.Level == 2);\n+\n+        auto ev = MakeHolder<TEvDataShard::TEvPrefixKMeansRequest>();\n+        ev->Record.SetId(ui64(BuildId));\n+\n+        auto path = TPath::Init(buildInfo.TablePathId, Self).Dive(buildInfo.IndexName);\n+        path.Dive(buildInfo.KMeans.ReadFrom())->PathId.ToProto(ev->Record.MutablePathId());\n+        path.Rise();\n+        *ev->Record.MutableSettings() = std::get<NKikimrSchemeOp::TVectorIndexKmeansTreeDescription>(\n+            buildInfo.SpecializedIndexDescription).GetSettings().settings();\n+        ev->Record.SetK(buildInfo.KMeans.K);\n+        ev->Record.SetUpload(buildInfo.KMeans.GetUpload());\n+\n+        ev->Record.SetNeedsRounds(3); // TODO(mbkkt) should be configurable\n+\n+        const auto shardIndex = buildInfo.Shards.at(shardIdx).Index;\n+        ev->Record.SetChild(buildInfo.KMeans.ChildBegin + (1 + TableSize) * shardIndex);\n+\n+        ev->Record.SetPostingName(path.Dive(buildInfo.KMeans.WriteTo()).PathString());\n+        path.Rise().Dive(NTableIndex::NTableVectorKmeansTreeIndex::LevelTable);\n+        ev->Record.SetLevelName(path.PathString());\n+        path.Rise().Dive(NTableIndex::NTableVectorKmeansTreeIndex::PrefixTable);\n+        ev->Record.SetPrefixName(path.PathString());\n+\n+        ev->Record.SetPrefixColumns(buildInfo.IndexColumns.size() - 1);\n+        ev->Record.SetEmbeddingColumn(buildInfo.IndexColumns.back());\n+        *ev->Record.MutableDataColumns() = {\n+            buildInfo.DataColumns.begin(), buildInfo.DataColumns.end()\n+        };\n+\n+        auto shardId = CommonFillRecord<false>(ev->Record, shardIdx, buildInfo);\n+        ev->Record.SetSeed(ui64(shardId));\n+        LOG_D(\"TTxBuildProgress: TEvPrefixKMeansRequest: \" << ev->Record.ShortDebugString());\n+\n+        ToTabletSend.emplace_back(shardId, ui64(BuildId), std::move(ev));\n+    }\n+\n     void SendBuildIndexRequest(TShardIdx shardIdx, TIndexBuildInfo& buildInfo) {\n         auto ev = MakeHolder<TEvDataShard::TEvBuildIndexCreateRequest>();\n         ev->Record.SetBuildIndexId(ui64(BuildId));\n@@ -649,9 +709,12 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n         ev->Record.SetOwnerId(buildInfo.TablePathId.OwnerId);\n         ev->Record.SetPathId(buildInfo.TablePathId.LocalPathId);\n \n-        if (buildInfo.IsBuildSecondaryIndex()) {\n+        if (buildInfo.IsBuildColumns()) {\n+            buildInfo.SerializeToProto(Self, ev->Record.MutableColumnBuildSettings());\n+        } else {\n             if (buildInfo.TargetName.empty()) {\n-                TPath implTable = TPath::Init(buildInfo.TablePathId, Self).Dive(buildInfo.IndexName).Dive(NTableIndex::ImplTable);\n+                TPath implTable = TPath::Init(buildInfo.TablePathId, Self).Dive(buildInfo.IndexName).Dive(\n+                    buildInfo.IsBuildPrefixedVectorIndex() ? buildInfo.KMeans.WriteTo() : NTableIndex::ImplTable);\n                 buildInfo.TargetName = implTable.PathString();\n \n                 const auto& implTableInfo = Self->Tables.at(implTable.Base()->PathId);\n@@ -662,6 +725,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n                     buildInfo.FillIndexColumns.emplace_back(x);\n                     implTableColumns.Columns.erase(x);\n                 }\n+                // TODO(mbkkt) why order doesn't matter?\n                 buildInfo.FillDataColumns.clear();\n                 buildInfo.FillDataColumns.reserve(implTableColumns.Columns.size());\n                 for (const auto& x: implTableColumns.Columns) {\n@@ -676,8 +740,6 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n                 buildInfo.FillDataColumns.begin(),\n                 buildInfo.FillDataColumns.end()\n             };\n-        } else if (buildInfo.IsBuildColumns()) {\n-            buildInfo.SerializeToProto(Self, ev->Record.MutableColumnBuildSettings());\n         }\n \n         ev->Record.SetTargetName(buildInfo.TargetName);\n@@ -701,7 +763,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n         Y_ASSERT(buildInfo.Sample.Rows.size() <= buildInfo.KMeans.K);\n         auto actor = new TUploadSampleK(path.PathString(),\n             buildInfo.Limits, Self->SelfId(), ui64(BuildId),\n-            buildInfo.Sample.Rows, buildInfo.KMeans.Parent, buildInfo.KMeans.ChildBegin);\n+            buildInfo.Sample.Rows, buildInfo.KMeans.Parent, buildInfo.KMeans.Child);\n \n         TActivationContext::AsActorContext().MakeFor(Self->SelfId()).Register(actor);\n         buildInfo.Sample.State = TIndexBuildInfo::TSample::EState::Upload;\n@@ -758,6 +820,14 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n                buildInfo.DoneShards.size() == buildInfo.Shards.size();\n     }\n \n+    bool FillPrefixKMeans(TIndexBuildInfo& buildInfo) {\n+        if (buildInfo.DoneShards.empty() && buildInfo.ToUploadShards.empty() && buildInfo.InProgressShards.empty()) {\n+            AddAllShards(buildInfo);\n+        }\n+        return SendToShards(buildInfo, [&](TShardIdx shardIdx) { SendPrefixKMeansRequest(shardIdx, buildInfo); }) &&\n+               buildInfo.DoneShards.size() == buildInfo.Shards.size();\n+    }\n+\n     bool InitSingleKMeans(TIndexBuildInfo& buildInfo) {\n         if (!buildInfo.DoneShards.empty() || !buildInfo.InProgressShards.empty() || !buildInfo.ToUploadShards.empty()) {\n             return false;\n@@ -866,6 +936,47 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n     }\n \n     bool FillVectorIndex(TTransactionContext& txc, TIndexBuildInfo& buildInfo) {\n+        if (buildInfo.IsBuildPrefixedVectorIndex() && buildInfo.KMeans.Level == 1) {\n+            LOG_D(\"FillIndex::Prefixed::Level1::Start \" << buildInfo.KMeansTreeToDebugStr());\n+            if (!FillTable(buildInfo)) {\n+                return false;\n+            }\n+            const ui64 doneShards = buildInfo.DoneShards.size();\n+\n+            ClearDoneShards(txc, buildInfo);\n+            Y_ABORT_UNLESS(buildInfo.KMeans.PrefixTableDone(TableSize, doneShards));\n+            PersistKMeansState(txc, buildInfo);\n+            NIceDb::TNiceDb db{txc.DB};\n+            Self->PersistBuildIndexUploadReset(db, buildInfo);\n+            LOG_D(\"FillIndex::Prefixed::Level1::Done \" << buildInfo.KMeansTreeToDebugStr());\n+            ChangeState(BuildId, TIndexBuildInfo::EState::CreateBuild);\n+            Progress(BuildId);\n+            return false;\n+        }\n+\n+        if (buildInfo.IsBuildPrefixedVectorIndex() && buildInfo.KMeans.Level == 2) {\n+            LOG_D(\"FillIndex::Prefixed::Level2::Start \" << buildInfo.KMeansTreeToDebugStr());\n+            if (!FillPrefixKMeans(buildInfo)) {\n+                return false;\n+            }\n+\n+            ClearDoneShards(txc, buildInfo);\n+            Y_ASSERT(buildInfo.KMeans.State == TIndexBuildInfo::TKMeans::MultiLocal);\n+            const bool needsAnotherLevel = buildInfo.KMeans.NextLevel();\n+            buildInfo.KMeans.State = TIndexBuildInfo::TKMeans::MultiLocal;\n+            buildInfo.KMeans.Parent = buildInfo.KMeans.ParentEnd();\n+            PersistKMeansState(txc, buildInfo);\n+            NIceDb::TNiceDb db{txc.DB};\n+            Self->PersistBuildIndexUploadReset(db, buildInfo);\n+            LOG_D(\"FillIndex::Prefixed::Level2::Done \" << buildInfo.KMeansTreeToDebugStr());\n+            if (!needsAnotherLevel) {\n+                return true;\n+            }\n+            ChangeState(BuildId, TIndexBuildInfo::EState::DropBuild);\n+            Progress(BuildId);\n+            return false;\n+        }\n+\n         if (buildInfo.Sample.State == TIndexBuildInfo::TSample::EState::Upload) {\n             return false;\n         }\n@@ -932,9 +1043,9 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n     }\n \n     bool FillIndex(TTransactionContext& txc, TIndexBuildInfo& buildInfo) {\n-        // About Parent == 0, for now build index impl tables don't need snapshot,\n+        // About Level == 1, for now build index impl tables don't need snapshot,\n         // because they're used only by build index\n-        if (buildInfo.KMeans.Parent == 0 && !buildInfo.SnapshotTxId) {\n+        if (buildInfo.KMeans.Level == 1 && !buildInfo.SnapshotTxId) {\n             Y_ABORT_UNLESS(!buildInfo.SnapshotStep);\n             Y_ABORT_UNLESS(Self->TablesWithSnapshots.contains(buildInfo.TablePathId));\n             Y_ABORT_UNLESS(Self->TablesWithSnapshots.at(buildInfo.TablePathId) == buildInfo.InitiateTxId);\n@@ -1012,11 +1123,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n             } else if (!buildInfo.InitiateTxDone) {\n                 Send(Self->SelfId(), MakeHolder<TEvSchemeShard::TEvNotifyTxCompletion>(ui64(buildInfo.InitiateTxId)));\n             } else {\n-                if (buildInfo.IsBuildVectorIndex() && buildInfo.IndexColumns.size() != 1) {\n-                    // TODO(mbkkt) in this state every prefixed vector index is empty\n-                    // So we need some new code to fill it\n-                    ChangeState(BuildId, TIndexBuildInfo::EState::Applying);\n-                } else if (buildInfo.IsBuildVectorIndex() && buildInfo.KMeans.NeedsAnotherLevel()) {\n+                if (buildInfo.IsBuildVectorIndex() && buildInfo.KMeans.NeedsAnotherLevel()) {\n                     ChangeState(BuildId, TIndexBuildInfo::EState::CreateBuild);\n                 } else {\n                     ChangeState(BuildId, TIndexBuildInfo::EState::Filling);\n@@ -1200,7 +1307,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n         Y_ASSERT(buildInfo.DoneShards.empty());\n \n         TTableInfo::TPtr table;\n-        if (buildInfo.KMeans.Parent == 0) {\n+        if (buildInfo.KMeans.Level == 1) {\n             table = Self->Tables.at(buildInfo.TablePathId);\n         } else {\n             auto path = TPath::Init(buildInfo.TablePathId, Self).Dive(buildInfo.IndexName);\n@@ -1218,7 +1325,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n             shardRange.To = bound;\n             LOG_D(\"shard \" << x.ShardIdx << \" range \" << buildInfo.KMeans.RangeToDebugStr(shardRange));\n             buildInfo.AddParent(shardRange, x.ShardIdx);\n-            auto [it, emplaced] = buildInfo.Shards.emplace(x.ShardIdx, TIndexBuildInfo::TShardStatus{std::move(shardRange), \"\"});\n+            auto [it, emplaced] = buildInfo.Shards.emplace(x.ShardIdx, TIndexBuildInfo::TShardStatus{std::move(shardRange), \"\", buildInfo.Shards.size()});\n             Y_ASSERT(emplaced);\n             shardRange.From = std::move(bound);\n \n@@ -1763,6 +1870,131 @@ struct TSchemeShard::TIndexBuilder::TTxReplyReshuffleKMeans: public TSchemeShard\n     }\n };\n \n+struct TSchemeShard::TIndexBuilder::TTxReplyPrefixKMeans: public TSchemeShard::TIndexBuilder::TTxReply {\n+private:\n+    TEvDataShard::TEvPrefixKMeansResponse::TPtr Prefix;\n+\n+public:\n+    explicit TTxReplyPrefixKMeans(TSelf* self, TEvDataShard::TEvPrefixKMeansResponse::TPtr& prefix)\n+        : TTxReply(self)\n+        , Prefix(prefix)\n+    {\n+    }\n+\n+    bool DoExecute(TTransactionContext& txc, const TActorContext& ctx) override {\n+        auto& record = Prefix->Get()->Record;\n+\n+        LOG_I(\"TTxReply : TEvPrefixKMeansResponse, id# \" << record.GetId());\n+\n+        const auto buildId = TIndexBuildId(record.GetId());\n+        const auto* buildInfoPtr = Self->IndexBuilds.FindPtr(buildId);\n+        if (!buildInfoPtr) {\n+            return true;\n+        }\n+        auto& buildInfo = *buildInfoPtr->Get();\n+        LOG_D(\"TTxReply : TEvPrefixKMeansResponse\"\n+              << \", TIndexBuildInfo: \" << buildInfo\n+              << \", record: \" << record.ShortDebugString());\n+\n+        TTabletId shardId = TTabletId(record.GetTabletId());\n+        if (!Self->TabletIdToShardIdx.contains(shardId)) {\n+            return true;\n+        }\n+\n+        TShardIdx shardIdx = Self->TabletIdToShardIdx.at(shardId);\n+        if (!buildInfo.Shards.contains(shardIdx)) {\n+            return true;\n+        }\n+\n+        switch (const auto state = buildInfo.State; state) {\n+        case TIndexBuildInfo::EState::Filling:\n+        {\n+            TIndexBuildInfo::TShardStatus& shardStatus = buildInfo.Shards.at(shardIdx);\n+\n+            auto actualSeqNo = std::pair<ui64, ui64>(Self->Generation(), shardStatus.SeqNoRound);\n+            auto recordSeqNo = std::pair<ui64, ui64>(record.GetRequestSeqNoGeneration(), record.GetRequestSeqNoRound());\n+\n+            if (actualSeqNo != recordSeqNo) {\n+                LOG_D(\"TTxReply : TEvPrefixKMeansResponse\"\n+                      << \" ignore progress message by seqNo\"\n+                      << \", TIndexBuildInfo: \" << buildInfo\n+                      << \", actual seqNo for the shard \" << shardId << \" (\" << shardIdx << \") is: \"  << Self->Generation() << \":\" <<  shardStatus.SeqNoRound\n+                      << \", record: \" << record.ShortDebugString());\n+                Y_ABORT_UNLESS(actualSeqNo > recordSeqNo);\n+                return true;\n+            }\n+\n+            TBillingStats stats{record.GetUploadRows(), record.GetUploadBytes(), record.GetReadRows(), record.GetReadBytes()};\n+            shardStatus.Processed += stats;\n+            buildInfo.Processed += stats;\n+\n+            NYql::TIssues issues;\n+            NYql::IssuesFromMessage(record.GetIssues(), issues);\n+            shardStatus.DebugMessage = issues.ToString();\n+\n+            NIceDb::TNiceDb db(txc.DB);\n+            shardStatus.Status = record.GetStatus();\n+\n+            switch (shardStatus.Status) {\n+            case  NKikimrIndexBuilder::EBuildStatus::DONE:\n+                if (buildInfo.InProgressShards.erase(shardIdx)) {\n+                    buildInfo.DoneShards.emplace_back(shardIdx);\n+                }\n+                break;\n+            case  NKikimrIndexBuilder::EBuildStatus::ABORTED:\n+                // datashard gracefully rebooted, reschedule shard\n+                if (buildInfo.InProgressShards.erase(shardIdx)) {\n+                    buildInfo.ToUploadShards.emplace_front(shardIdx);\n+                }\n+                break;\n+            case  NKikimrIndexBuilder::EBuildStatus::BUILD_ERROR:\n+            case  NKikimrIndexBuilder::EBuildStatus::BAD_REQUEST:\n+                buildInfo.Issue += TStringBuilder()\n+                    << \"One of the shards report \"<< shardStatus.Status\n+                    << \" at Filling stage, process has to be canceled\"\n+                    << \", shardId: \" << shardId\n+                    << \", shardIdx: \" << shardIdx;\n+                Self->PersistBuildIndexIssue(db, buildInfo);\n+                ChangeState(buildInfo.Id, TIndexBuildInfo::EState::Rejection_Applying);\n+\n+                Progress(buildId);\n+                return true;\n+            case  NKikimrIndexBuilder::EBuildStatus::INVALID:\n+            case  NKikimrIndexBuilder::EBuildStatus::ACCEPTED:\n+            case  NKikimrIndexBuilder::EBuildStatus::IN_PROGRESS:\n+                Y_ABORT(\"Unreachable\");\n+            }\n+            Self->PersistBuildIndexUploadProgress(db, buildId, shardIdx, shardStatus);\n+            Self->IndexBuildPipes.Close(buildId, shardId, ctx);\n+            Progress(buildId);\n+            break;\n+        }\n+        case TIndexBuildInfo::EState::AlterMainTable:\n+        case TIndexBuildInfo::EState::Invalid:\n+        case TIndexBuildInfo::EState::Locking:\n+        case TIndexBuildInfo::EState::GatheringStatistics:\n+        case TIndexBuildInfo::EState::Initiating:\n+        case TIndexBuildInfo::EState::DropBuild:\n+        case TIndexBuildInfo::EState::CreateBuild:\n+        case TIndexBuildInfo::EState::Applying:\n+        case TIndexBuildInfo::EState::Unlocking:\n+        case TIndexBuildInfo::EState::Done:\n+            Y_FAIL_S(\"Unreachable \" << Name(state));\n+        case TIndexBuildInfo::EState::Cancellation_Applying:\n+        case TIndexBuildInfo::EState::Cancellation_Unlocking:\n+        case TIndexBuildInfo::EState::Cancelled:\n+        case TIndexBuildInfo::EState::Rejection_Applying:\n+        case TIndexBuildInfo::EState::Rejection_Unlocking:\n+        case TIndexBuildInfo::EState::Rejected:\n+            LOG_D(\"TTxReply : TEvPrefixKMeansResponse\"\n+                  << \" superfluous message \" << record.ShortDebugString());\n+            break;\n+        }\n+\n+        return true;\n+    }\n+};\n+\n struct TSchemeShard::TIndexBuilder::TTxReplyUpload: public TSchemeShard::TIndexBuilder::TTxReply  {\n private:\n     TEvIndexBuilder::TEvUploadSampleKResponse::TPtr Upload;\n@@ -2398,6 +2630,10 @@ ITransaction* TSchemeShard::CreateTxReply(TEvDataShard::TEvLocalKMeansResponse::\n     return new TIndexBuilder::TTxReplyLocalKMeans(this, local);\n }\n \n+ITransaction* TSchemeShard::CreateTxReply(TEvDataShard::TEvPrefixKMeansResponse::TPtr& prefix) {\n+    return new TIndexBuilder::TTxReplyPrefixKMeans(this, prefix);\n+}\n+\n ITransaction* TSchemeShard::CreateTxReply(TEvIndexBuilder::TEvUploadSampleKResponse::TPtr& upload) {\n     return new TIndexBuilder::TTxReplyUpload(this, upload);\n }\ndiff --git a/ydb/core/tx/schemeshard/schemeshard_impl.cpp b/ydb/core/tx/schemeshard/schemeshard_impl.cpp\nindex 6cd469fdee8b..d2a74329d106 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_impl.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard_impl.cpp\n@@ -1256,120 +1256,158 @@ TString TSchemeShard::PathToString(TPathElement::TPtr item) {\n     return path.PathString();\n }\n \n-bool TSchemeShard::CheckApplyIf(const NKikimrSchemeOp::TModifyScheme &scheme, TString &errStr) {\n+bool TSchemeShard::CheckApplyIf(const NKikimrSchemeOp::TModifyScheme& scheme, TString& errStr, std::optional<TPathElement::EPathType> pathType) {\n     const auto& conditions = scheme.GetApplyIf();\n \n-    for(const auto& item: conditions) {\n-        if (!item.HasPathId()) {\n-            continue;\n-        }\n-        TLocalPathId localPathId = item.GetPathId();\n-        const auto pathId = TPathId(TabletID(), localPathId);\n+    for (const auto& item: conditions) {\n+        if (item.HasPathId()) {\n+            TLocalPathId localPathId = item.GetPathId();\n+            const auto pathId = TPathId(TabletID(), localPathId);\n \n-        if (!PathsById.contains(pathId)) {\n-            errStr = TStringBuilder()\n-                << \"fail user constraint: ApplyIf section:\"\n-                << \" no path with id \" << pathId;\n-            return false;\n-        }\n-        const TPathElement::TPtr pathEl = PathsById.at(pathId);\n+            if (!PathsById.contains(pathId)) {\n+                errStr = TStringBuilder()\n+                    << \"fail user constraint: ApplyIf section:\"\n+                    << \" no path with id \" << pathId;\n+                return false;\n+            }\n+            const TPathElement::TPtr pathEl = PathsById.at(pathId);\n \n-        if (pathEl->Dropped()) {\n-            errStr = TStringBuilder()\n-                << \"fail user constraint: ApplyIf section:\"\n-                << \" path with id \" << pathId << \" has been dropped\";\n-            return false;\n-        }\n+            if (pathEl->Dropped()) {\n+                errStr = TStringBuilder()\n+                    << \"fail user constraint: ApplyIf section:\"\n+                    << \" path with id \" << pathId << \" has been dropped\";\n+                return false;\n+            }\n \n-        if (item.HasPathVersion()) {\n-            const auto requiredVersion = item.GetPathVersion();\n-            arc_ui64 actualVersion;\n-            auto path = TPath::Init(pathId, this);\n-            auto pathVersion = GetPathVersion(path);\n-\n-            if (item.HasCheckEntityVersion() && item.GetCheckEntityVersion()) {\n-                switch(path.Base()->PathType) {\n-                    case NKikimrSchemeOp::EPathTypePersQueueGroup:\n-                        actualVersion = pathVersion.GetPQVersion();\n-                        break;\n-                    case NKikimrSchemeOp::EPathType::EPathTypeSubDomain:\n-                    case NKikimrSchemeOp::EPathType::EPathTypeExtSubDomain:\n-                        actualVersion = pathVersion.GetSubDomainVersion();\n-                        break;\n-                    case NKikimrSchemeOp::EPathTypeTable:\n-                        actualVersion = pathVersion.GetTableSchemaVersion();\n-                        break;\n-                    case NKikimrSchemeOp::EPathType::EPathTypeBlockStoreVolume:\n-                        actualVersion = pathVersion.GetBSVVersion();\n-                        break;\n-                    case NKikimrSchemeOp::EPathType::EPathTypeFileStore:\n-                        actualVersion = pathVersion.GetFileStoreVersion();\n-                        break;\n-                    case NKikimrSchemeOp::EPathType::EPathTypeKesus:\n-                        actualVersion = pathVersion.GetKesusVersion();\n-                        break;\n-                    case NKikimrSchemeOp::EPathType::EPathTypeRtmrVolume:\n-                        actualVersion = pathVersion.GetRTMRVersion();\n-                        break;\n-                    case NKikimrSchemeOp::EPathType::EPathTypeSolomonVolume:\n-                        actualVersion = pathVersion.GetSolomonVersion();\n-                        break;\n-                    case NKikimrSchemeOp::EPathType::EPathTypeTableIndex:\n-                        actualVersion = pathVersion.GetTableIndexVersion();\n-                        break;\n-                    case NKikimrSchemeOp::EPathType::EPathTypeColumnStore:\n-                        actualVersion = pathVersion.GetColumnStoreVersion();\n-                        break;\n-                    case NKikimrSchemeOp::EPathType::EPathTypeColumnTable:\n-                        actualVersion = pathVersion.GetColumnTableVersion();\n-                        break;\n-                    case NKikimrSchemeOp::EPathType::EPathTypeCdcStream:\n-                        actualVersion = pathVersion.GetCdcStreamVersion();\n-                        break;\n-                    case NKikimrSchemeOp::EPathType::EPathTypeSequence:\n-                        actualVersion = pathVersion.GetSequenceVersion();\n-                        break;\n-                    case NKikimrSchemeOp::EPathType::EPathTypeReplication:\n-                    case NKikimrSchemeOp::EPathType::EPathTypeTransfer:\n-                        actualVersion = pathVersion.GetReplicationVersion();\n-                        break;\n-                    case NKikimrSchemeOp::EPathType::EPathTypeExternalTable:\n-                        actualVersion = pathVersion.GetExternalTableVersion();\n-                        break;\n-                    case NKikimrSchemeOp::EPathType::EPathTypeExternalDataSource:\n-                        actualVersion = pathVersion.GetExternalDataSourceVersion();\n-                        break;\n-                    case NKikimrSchemeOp::EPathType::EPathTypeView:\n-                        actualVersion = pathVersion.GetViewVersion();\n-                        break;\n-                    default:\n-                        actualVersion = pathVersion.GetGeneralVersion();\n-                        break;\n+            if (item.HasPathVersion()) {\n+                const auto requiredVersion = item.GetPathVersion();\n+                arc_ui64 actualVersion;\n+                auto path = TPath::Init(pathId, this);\n+                auto pathVersion = GetPathVersion(path);\n+\n+                if (item.HasCheckEntityVersion() && item.GetCheckEntityVersion()) {\n+                    switch(path.Base()->PathType) {\n+                        case NKikimrSchemeOp::EPathTypePersQueueGroup:\n+                            actualVersion = pathVersion.GetPQVersion();\n+                            break;\n+                        case NKikimrSchemeOp::EPathType::EPathTypeSubDomain:\n+                        case NKikimrSchemeOp::EPathType::EPathTypeExtSubDomain:\n+                            actualVersion = pathVersion.GetSubDomainVersion();\n+                            break;\n+                        case NKikimrSchemeOp::EPathTypeTable:\n+                            actualVersion = pathVersion.GetTableSchemaVersion();\n+                            break;\n+                        case NKikimrSchemeOp::EPathType::EPathTypeBlockStoreVolume:\n+                            actualVersion = pathVersion.GetBSVVersion();\n+                            break;\n+                        case NKikimrSchemeOp::EPathType::EPathTypeFileStore:\n+                            actualVersion = pathVersion.GetFileStoreVersion();\n+                            break;\n+                        case NKikimrSchemeOp::EPathType::EPathTypeKesus:\n+                            actualVersion = pathVersion.GetKesusVersion();\n+                            break;\n+                        case NKikimrSchemeOp::EPathType::EPathTypeRtmrVolume:\n+                            actualVersion = pathVersion.GetRTMRVersion();\n+                            break;\n+                        case NKikimrSchemeOp::EPathType::EPathTypeSolomonVolume:\n+                            actualVersion = pathVersion.GetSolomonVersion();\n+                            break;\n+                        case NKikimrSchemeOp::EPathType::EPathTypeTableIndex:\n+                            actualVersion = pathVersion.GetTableIndexVersion();\n+                            break;\n+                        case NKikimrSchemeOp::EPathType::EPathTypeColumnStore:\n+                            actualVersion = pathVersion.GetColumnStoreVersion();\n+                            break;\n+                        case NKikimrSchemeOp::EPathType::EPathTypeColumnTable:\n+                            actualVersion = pathVersion.GetColumnTableVersion();\n+                            break;\n+                        case NKikimrSchemeOp::EPathType::EPathTypeCdcStream:\n+                            actualVersion = pathVersion.GetCdcStreamVersion();\n+                            break;\n+                        case NKikimrSchemeOp::EPathType::EPathTypeSequence:\n+                            actualVersion = pathVersion.GetSequenceVersion();\n+                            break;\n+                        case NKikimrSchemeOp::EPathType::EPathTypeReplication:\n+                        case NKikimrSchemeOp::EPathType::EPathTypeTransfer:\n+                            actualVersion = pathVersion.GetReplicationVersion();\n+                            break;\n+                        case NKikimrSchemeOp::EPathType::EPathTypeExternalTable:\n+                            actualVersion = pathVersion.GetExternalTableVersion();\n+                            break;\n+                        case NKikimrSchemeOp::EPathType::EPathTypeExternalDataSource:\n+                            actualVersion = pathVersion.GetExternalDataSourceVersion();\n+                            break;\n+                        case NKikimrSchemeOp::EPathType::EPathTypeView:\n+                            actualVersion = pathVersion.GetViewVersion();\n+                            break;\n+                        default:\n+                            actualVersion = pathVersion.GetGeneralVersion();\n+                            break;\n+                    }\n+                } else {\n+                    actualVersion = pathVersion.GetGeneralVersion();\n+                }\n+\n+                if (requiredVersion != actualVersion) {\n+                    errStr = TStringBuilder()\n+                        << \"fail user constraint in ApplyIf section:\"\n+                        //FIXME: revert to misspelled text as there is dependency on it in the nbs code.\n+                        // Dependency on text should be replaced by introducing special error code.\n+                        << \" path version mistmach, path with id \" << pathEl->PathId\n+                        << \" has actual version \" << actualVersion\n+                        << \" but version \" << requiredVersion << \" was required\";\n+                    return false;\n                 }\n-            } else {\n-                actualVersion = pathVersion.GetGeneralVersion();\n             }\n \n-            if (requiredVersion != actualVersion) {\n-                errStr = TStringBuilder()\n-                    << \"fail user constraint in ApplyIf section:\"\n-                    //FIXME: revert to misspelled text as there is dependency on it in the nbs code.\n-                    // Dependency on text should be replaced by introducing special error code.\n-                    << \" path version mistmach, path with id \" << pathEl->PathId\n-                    << \" has actual version \" << actualVersion\n-                    << \" but version \" << requiredVersion << \" was required\";\n-                return false;\n+            if (item.HasLockedTxId()) {\n+                const auto lockOwnerTxId = TTxId(item.GetLockedTxId());\n+    \n+                TString lockErr = \"fail user constraint in ApplyIf section:\";\n+                if (!CheckLocks(pathId, lockOwnerTxId, lockErr)) {\n+                    errStr = lockErr;\n+                    return false;\n+                }\n             }\n         }\n \n-        if (item.HasLockedTxId()) {\n-            const auto lockOwnerTxId = TTxId(item.GetLockedTxId());\n+        if (AppData()->FeatureFlags.GetEnableAlterDatabase()) {\n+            if (!item.GetPathTypes().empty()) {\n+                if (!pathType.has_value()) {\n+                    errStr = TStringBuilder()\n+                        << \"fail in ApplyIf section:\"\n+                        << \" argument `pathType` is undefined,\"\n+                        << \" but ApplyIf has non-empty field `PathTypes.`\";\n \n-            TString lockErr = \"fail user constraint in ApplyIf section:\";\n-            if (!CheckLocks(pathId, lockOwnerTxId, lockErr)) {\n-                errStr = lockErr;\n-                return false;\n+                    return false;\n+                }\n+\n+                const auto& pathTypes = item.GetPathTypes();\n+                bool allowed = (std::find(pathTypes.begin(), pathTypes.end(), pathType) != pathTypes.end());\n+                if (!allowed) {\n+                    auto enumToString = [](TPathElement::EPathType type) {\n+                        return NKikimrSchemeOp::EPathType_Name(type);\n+                    };\n+\n+                    errStr = TStringBuilder()\n+                        << \"fail in ApplyIf section:\"\n+                        << \" wrong Path type.\"\n+                        << \" Expected types: \";\n+\n+                        for (int i = 0; i < pathTypes.size(); i++) {\n+                            errStr += enumToString(static_cast<TPathElement::EPathType>(pathTypes[i]) ) + \",;\"[i + 1 == pathTypes.size()] + \" \";\n+                        }\n+\n+                        errStr += TStringBuilder() << \"But actual Path type is \" << enumToString(pathType.value());\n+                    return false;\n+                }\n             }\n+        } else if (!item.GetPathTypes().empty()) {\n+            errStr = TStringBuilder()\n+                << \"fail in ApplyIf section:\"\n+                << \" Check Path Type is not supported\";\n+\n+            return false;\n         }\n     }\n \n@@ -4911,6 +4949,7 @@ void TSchemeShard::StateWork(STFUNC_SIG) {\n         HFuncTraced(TEvDataShard::TEvSampleKResponse, Handle);\n         HFuncTraced(TEvDataShard::TEvReshuffleKMeansResponse, Handle);\n         HFuncTraced(TEvDataShard::TEvLocalKMeansResponse, Handle);\n+        HFuncTraced(TEvDataShard::TEvPrefixKMeansResponse, Handle);\n         HFuncTraced(TEvIndexBuilder::TEvUploadSampleKResponse, Handle);\n         // } // NIndexBuilder\n \ndiff --git a/ydb/core/tx/schemeshard/schemeshard_impl.h b/ydb/core/tx/schemeshard/schemeshard_impl.h\nindex f4bf218201ac..925fa69c31d4 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_impl.h\n+++ b/ydb/core/tx/schemeshard/schemeshard_impl.h\n@@ -603,7 +603,7 @@ class TSchemeShard\n     TTabletId SelectCoordinator(TTxId txId, TPathId pathId) const;\n     TTabletId SelectCoordinator(TTxId txId, TPathElement::TPtr pathEl) const;\n \n-    bool CheckApplyIf(const NKikimrSchemeOp::TModifyScheme& scheme, TString& errStr);\n+    bool CheckApplyIf(const NKikimrSchemeOp::TModifyScheme& scheme, TString& errStr, std::optional<TPathElement::EPathType> pathType = {});\n     bool CheckLocks(const TPathId pathId, const TTxId lockTxId, TString& errStr) const;\n     bool CheckLocks(const TPathId pathId, const NKikimrSchemeOp::TModifyScheme& scheme, TString& errStr) const;\n     bool CheckInFlightLimit(TTxState::ETxType txType, TString& errStr) const;\n@@ -1426,6 +1426,7 @@ class TSchemeShard\n         struct TTxReplySampleK;\n         struct TTxReplyReshuffleKMeans;\n         struct TTxReplyLocalKMeans;\n+        struct TTxReplyPrefixKMeans;\n         struct TTxReplyUpload;\n \n         struct TTxPipeReset;\n@@ -1445,6 +1446,7 @@ class TSchemeShard\n     NTabletFlatExecutor::ITransaction* CreateTxReply(TEvDataShard::TEvSampleKResponse::TPtr& sampleK);\n     NTabletFlatExecutor::ITransaction* CreateTxReply(TEvDataShard::TEvReshuffleKMeansResponse::TPtr& reshuffle);\n     NTabletFlatExecutor::ITransaction* CreateTxReply(TEvDataShard::TEvLocalKMeansResponse::TPtr& local);\n+    NTabletFlatExecutor::ITransaction* CreateTxReply(TEvDataShard::TEvPrefixKMeansResponse::TPtr& prefix);\n     NTabletFlatExecutor::ITransaction* CreateTxReply(TEvIndexBuilder::TEvUploadSampleKResponse::TPtr& upload);\n     NTabletFlatExecutor::ITransaction* CreatePipeRetry(TIndexBuildId indexBuildId, TTabletId tabletId);\n     NTabletFlatExecutor::ITransaction* CreateTxBilling(TEvPrivate::TEvIndexBuildingMakeABill::TPtr& ev);\n@@ -1459,6 +1461,7 @@ class TSchemeShard\n     void Handle(TEvDataShard::TEvSampleKResponse::TPtr& ev, const TActorContext& ctx);\n     void Handle(TEvDataShard::TEvReshuffleKMeansResponse::TPtr& ev, const TActorContext& ctx);\n     void Handle(TEvDataShard::TEvLocalKMeansResponse::TPtr& ev, const TActorContext& ctx);\n+    void Handle(TEvDataShard::TEvPrefixKMeansResponse::TPtr& ev, const TActorContext& ctx);\n     void Handle(TEvIndexBuilder::TEvUploadSampleKResponse::TPtr& ev, const TActorContext& ctx);\n \n     void Handle(TEvPrivate::TEvIndexBuildingMakeABill::TPtr& ev, const TActorContext& ctx);\ndiff --git a/ydb/core/tx/schemeshard/schemeshard_info_types.cpp b/ydb/core/tx/schemeshard/schemeshard_info_types.cpp\nindex ddd148f18bb3..1de46a0f63db 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_info_types.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard_info_types.cpp\n@@ -2164,9 +2164,10 @@ void TImportInfo::AddNotifySubscriber(const TActorId &actorId) {\n     Subscribers.insert(actorId);\n }\n \n-TIndexBuildInfo::TShardStatus::TShardStatus(TSerializedTableRange range, TString lastKeyAck)\n+TIndexBuildInfo::TShardStatus::TShardStatus(TSerializedTableRange range, TString lastKeyAck, size_t shardsCount)\n     : Range(std::move(range))\n     , LastKeyAck(std::move(lastKeyAck))\n+    , Index(shardsCount)\n {}\n \n void TIndexBuildInfo::SerializeToProto(TSchemeShard* ss, NKikimrSchemeOp::TIndexBuildConfig* result) const {\n@@ -2208,7 +2209,6 @@ void TIndexBuildInfo::SerializeToProto([[maybe_unused]] TSchemeShard* ss, NKikim\n \n void TIndexBuildInfo::AddParent(const TSerializedTableRange& range, TShardIdx shard) {\n     if (KMeans.Parent == 0) {\n-        Y_ASSERT(KMeans.ParentEnd == 0);\n         // For Parent == 0 only single kmeans needed, so there is only two options:\n         // 1. It fits entirely in the single shard => local kmeans for single shard\n         // 2. It doesn't fit entirely in the single shard => global kmeans for all shards\ndiff --git a/ydb/core/tx/schemeshard/schemeshard_info_types.h b/ydb/core/tx/schemeshard/schemeshard_info_types.h\nindex 6d52d76f207f..1f59bffd68db 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_info_types.h\n+++ b/ydb/core/tx/schemeshard/schemeshard_info_types.h\n@@ -3047,6 +3047,7 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {\n         BuildKindUnspecified = 0,\n         BuildSecondaryIndex = 10,\n         BuildVectorIndex = 11,\n+        BuildPrefixedVectorIndex = 12,\n         BuildColumns = 20,\n     };\n \n@@ -3092,42 +3093,46 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {\n \n         EState State = Sample;\n \n-        NTableIndex::TClusterId Parent = 0;\n-        NTableIndex::TClusterId ParentEnd = 0;  // included\n+        NTableIndex::TClusterId ParentBegin = 0;  // included\n+        NTableIndex::TClusterId Parent = ParentBegin;\n \n         NTableIndex::TClusterId ChildBegin = 1;  // included\n+        NTableIndex::TClusterId Child = ChildBegin;\n+\n+        ui64 ParentEnd() const noexcept {  // included\n+            return ChildBegin - 1;\n+        }\n+        ui64 ChildEnd() const noexcept {  // included\n+            return ChildBegin + ChildCount() - 1;\n+        }\n+\n+        ui64 ParentCount() const noexcept {\n+            return ParentEnd() - ParentBegin + 1;\n+        }\n+        ui64 ChildCount() const noexcept {\n+            return ParentCount() * K;\n+        }\n \n         TString ToStr() const {\n             return TStringBuilder()\n                 << \"{ K = \" << K\n                 << \", Level = \" << Level << \" / \" << Levels\n-                << \", Parent = \" << Parent << \" / \" << ParentEnd\n-                << \", State = \" << State << \" }\";\n-        }\n-\n-        static NTableIndex::TClusterId BinPow(NTableIndex::TClusterId k, ui32 l) {\n-            NTableIndex::TClusterId r = 1;\n-            while (l != 0) {\n-                if (l % 2 != 0) {\n-                    r *= k;\n-                }\n-                k *= k;\n-                l /= 2;\n-            }\n-            return r;\n+                << \", Parent = [\" << ParentBegin << \"..\" << Parent << \"..\" << ParentEnd()\n+                << \"], Child = [\" << ChildBegin << \"..\" << Child << \"..\" << ChildEnd()\n+                << \"], State = \" << State << \" }\";\n         }\n \n-        bool NeedsAnotherLevel() const {\n+        bool NeedsAnotherLevel() const noexcept {\n             return Level < Levels;\n         }\n-        bool NeedsAnotherParent() const {\n-            return Parent < ParentEnd;\n+        bool NeedsAnotherParent() const noexcept {\n+            return Parent < ParentEnd();\n         }\n-        bool NeedsAnotherState() const {\n+        bool NeedsAnotherState() const noexcept {\n             return State == Sample /*|| State == Recompute*/;\n         }\n \n-        bool NextState() {\n+        bool NextState() noexcept {\n             if (!NeedsAnotherState()) {\n                 return false;\n             }\n@@ -3135,25 +3140,32 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {\n             return true;\n         }\n \n-        bool NextParent() {\n+        bool NextParent() noexcept {\n             if (!NeedsAnotherParent()) {\n                 return false;\n             }\n-            ChildBegin += K;\n             State = Sample;\n             ++Parent;\n+            Child += K;\n             return true;\n         }\n \n-        bool NextLevel() {\n+        bool NextLevel() noexcept {\n             if (!NeedsAnotherLevel()) {\n                 return false;\n             }\n-            ChildBegin += K;\n             State = Sample;\n-            ++Parent;\n-            ParentEnd += BinPow(K, Level);\n-            ++Level;\n+            NextLevel(ChildCount());\n+            return true;\n+        }\n+\n+        bool PrefixTableDone(ui64 tableSize, ui64 shards) {\n+            if (!NeedsAnotherLevel()) {\n+                return false;\n+            }\n+            State = MultiLocal;\n+            NextLevel((1 + tableSize) * shards);\n+            Parent = ParentEnd();\n             return true;\n         }\n \n@@ -3169,7 +3181,7 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {\n         }\n \n         NKikimrTxDataShard::TEvLocalKMeansRequest::EState GetUpload() const {\n-            if (Parent == 0) {\n+            if (Level == 1) {\n                 if (NeedsAnotherLevel()) {\n                     return NKikimrTxDataShard::TEvLocalKMeansRequest::UPLOAD_MAIN_TO_BUILD;\n                 } else {\n@@ -3193,7 +3205,7 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {\n             return name;\n         }\n         TString ReadFrom() const {\n-            Y_ASSERT(Parent != 0);\n+            Y_ASSERT(Level > 1);\n             using namespace NTableIndex::NTableVectorKmeansTreeIndex;\n             TString name = PostingTable;\n             name += Level % 2 != 0 ? BuildSuffix1 : BuildSuffix0;\n@@ -3201,11 +3213,8 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {\n         }\n \n         std::pair<NTableIndex::TClusterId, NTableIndex::TClusterId> RangeToBorders(const TSerializedTableRange& range) const {\n-            Y_ASSERT(ParentEnd != 0);\n-            const NTableIndex::TClusterId maxParent = ParentEnd;\n-            const NTableIndex::TClusterId levelSize = TKMeans::BinPow(K, Level - 1);\n-            Y_ASSERT(levelSize <= maxParent);\n-            const NTableIndex::TClusterId minParent = maxParent - levelSize + 1;\n+            const NTableIndex::TClusterId minParent = ParentBegin;\n+            const NTableIndex::TClusterId maxParent = ParentEnd();\n             const NTableIndex::TClusterId parentFrom = [&, from = range.From.GetCells()] {\n                 if (!from.empty()) {\n                     if (!from[0].IsNull()) {\n@@ -3222,9 +3231,9 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {\n                 }\n                 return maxParent;\n             }();\n-            Y_VERIFY_DEBUG_S(minParent <= parentFrom, \"minParent(\" << minParent << \") > parentFrom(\" << parentFrom << \")\");\n-            Y_VERIFY_DEBUG_S(parentFrom <= parentTo, \"parentFrom(\" << parentFrom << \") > parentTo(\" << parentTo << \")\");\n-            Y_VERIFY_DEBUG_S(parentTo <= maxParent, \"parentTo(\" << parentTo << \") > maxParent(\" << maxParent << \")\");\n+            Y_VERIFY_DEBUG_S(minParent <= parentFrom, \"minParent(\" << minParent << \") > parentFrom(\" << parentFrom << \") \" << ToStr());\n+            Y_VERIFY_DEBUG_S(parentFrom <= parentTo, \"parentFrom(\" << parentFrom << \") > parentTo(\" << parentTo << \") \" << ToStr());\n+            Y_VERIFY_DEBUG_S(parentTo <= maxParent, \"parentTo(\" << parentTo << \") > maxParent(\" << maxParent << \") \" << ToStr());\n             return {parentFrom, parentTo};\n         }\n \n@@ -3249,6 +3258,15 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {\n             };\n             return TStringBuilder{} << \"{ From: \" << toStr(range.From) << \", To: \" << toStr(range.To) << \" }\";\n         }\n+\n+    private:\n+        void NextLevel(ui64 childCount) noexcept {\n+            ParentBegin = ChildBegin;\n+            Parent = ParentBegin;\n+            ChildBegin = ParentBegin + childCount;\n+            Child = ChildBegin;\n+            ++Level;\n+        }\n     };\n     TKMeans KMeans;\n \n@@ -3288,6 +3306,7 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {\n         TSerializedTableRange Range;\n         TString LastKeyAck;\n         ui64 SeqNoRound = 0;\n+        size_t Index = 0;  // size of Shards map before this element was added\n \n         NKikimrIndexBuilder::EBuildStatus Status = NKikimrIndexBuilder::EBuildStatus::INVALID;\n \n@@ -3296,7 +3315,7 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {\n \n         TBillingStats Processed;\n \n-        TShardStatus(TSerializedTableRange range, TString lastKeyAck);\n+        TShardStatus(TSerializedTableRange range, TString lastKeyAck, size_t shardsCount);\n \n         TString ToString(TShardIdx shardIdx = InvalidShardIdx) const {\n             TStringBuilder result;\n@@ -3485,6 +3504,12 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {\n         indexInfo->IndexName = row.template GetValue<Schema::IndexBuild::IndexName>();\n         indexInfo->IndexType = row.template GetValue<Schema::IndexBuild::IndexType>();\n \n+        // note: please note that here we specify BuildSecondaryIndex as operation default,\n+        // because previosly this table was dedicated for build secondary index operations only.\n+        indexInfo->BuildKind = TIndexBuildInfo::EBuildKind(\n+            row.template GetValueOrDefault<Schema::IndexBuild::BuildKind>(\n+                ui32(TIndexBuildInfo::EBuildKind::BuildSecondaryIndex)));\n+\n         // Restore the operation details: ImplTableDescriptions and SpecializedIndexDescription.\n         if (row.template HaveValue<Schema::IndexBuild::CreationConfig>()) {\n             NKikimrSchemeOp::TIndexCreationConfig creationConfig;\n@@ -3500,7 +3525,7 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {\n                 case NKikimrSchemeOp::TIndexCreationConfig::kVectorIndexKmeansTreeDescription: {\n                     auto& desc = *creationConfig.MutableVectorIndexKmeansTreeDescription();\n                     indexInfo->KMeans.K = std::max<ui32>(2, desc.settings().clusters());\n-                    indexInfo->KMeans.Levels = std::max<ui32>(1, desc.settings().levels());\n+                    indexInfo->KMeans.Levels = indexInfo->IsBuildPrefixedVectorIndex() + std::max<ui32>(1, desc.settings().levels());\n                     indexInfo->SpecializedIndexDescription =std::move(desc);\n                 } break;\n                 case NKikimrSchemeOp::TIndexCreationConfig::SPECIALIZEDINDEXDESCRIPTION_NOT_SET:\n@@ -3566,19 +3591,12 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {\n             row.template GetValueOrDefault<Schema::IndexBuild::UnlockTxDone>(\n                 indexInfo->UnlockTxDone);\n \n-        // note: please note that here we specify BuildSecondaryIndex as operation default,\n-        // because previosly this table was dedicated for build secondary index operations only.\n-        indexInfo->BuildKind = TIndexBuildInfo::EBuildKind(\n-            row.template GetValueOrDefault<Schema::IndexBuild::BuildKind>(\n-                ui32(TIndexBuildInfo::EBuildKind::BuildSecondaryIndex)));\n-\n         indexInfo->AlterMainTableTxId =\n             row.template GetValueOrDefault<Schema::IndexBuild::AlterMainTableTxId>(\n                 indexInfo->AlterMainTableTxId);\n         indexInfo->AlterMainTableTxStatus =\n-            row\n-                .template GetValueOrDefault<Schema::IndexBuild::AlterMainTableTxStatus>(\n-                    indexInfo->AlterMainTableTxStatus);\n+            row.template GetValueOrDefault<Schema::IndexBuild::AlterMainTableTxStatus>(\n+                indexInfo->AlterMainTableTxStatus);\n         indexInfo->AlterMainTableTxDone =\n             row.template GetValueOrDefault<Schema::IndexBuild::AlterMainTableTxDone>(\n                 indexInfo->AlterMainTableTxDone);\n@@ -3623,7 +3641,7 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {\n             \"AddShardStatus id# \" << Id << \" shard \" << shardIdx << \" range \" << KMeans.RangeToDebugStr(bound));\n         AddParent(bound, shardIdx);\n         Shards.emplace(\n-            shardIdx, TIndexBuildInfo::TShardStatus(std::move(bound), std::move(lastKeyAck)));\n+            shardIdx, TIndexBuildInfo::TShardStatus(std::move(bound), std::move(lastKeyAck), Shards.size()));\n         TIndexBuildInfo::TShardStatus &shardStatus = Shards.at(shardIdx);\n \n         shardStatus.Status =\n@@ -3661,8 +3679,12 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {\n         return BuildKind == EBuildKind::BuildSecondaryIndex;\n     }\n \n+    bool IsBuildPrefixedVectorIndex() const {\n+        return BuildKind == EBuildKind::BuildPrefixedVectorIndex;\n+    }\n+\n     bool IsBuildVectorIndex() const {\n-        return BuildKind == EBuildKind::BuildVectorIndex;\n+        return BuildKind == EBuildKind::BuildVectorIndex || IsBuildPrefixedVectorIndex();\n     }\n \n     bool IsBuildIndex() const {\n@@ -3701,16 +3723,8 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {\n                 && toUpload == 0 && inProgress == 0) {\n                 return 100.f;\n             }\n-            auto percent = static_cast<float>(KMeans.Level - 1) / KMeans.Levels;\n-            auto multiply = 1.f / KMeans.Levels;\n-            if (KMeans.State == TKMeans::MultiLocal) {\n-                percent += (multiply * (total - inProgress - toUpload)) / total;\n-            } else {\n-                const auto parentSize = KMeans.BinPow(KMeans.K, KMeans.Level - 1);\n-                const auto parentFrom = KMeans.ParentEnd - parentSize + 1;\n-                percent += (multiply * (KMeans.Parent - parentFrom)) / parentSize;\n-            }\n-            return 100.f * percent;\n+            // TODO(mbkkt) more detailed progress?\n+            return (100.f * (KMeans.Level - 1)) / KMeans.Levels;\n         }\n         if (Shards) {\n             return (100.f * done) / total;\ndiff --git a/ydb/core/tx/schemeshard/schemeshard_path.cpp b/ydb/core/tx/schemeshard/schemeshard_path.cpp\nindex d01f285c0f8f..01bae14754e7 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_path.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard_path.cpp\n@@ -578,6 +578,19 @@ const TPath::TChecker& TPath::TChecker::IsDirectory(EStatus status) const {\n         << \" (\" << BasicPathInfo(Path.Base()) << \")\");\n }\n \n+const TPath::TChecker& TPath::TChecker::IsRtmrVolume(EStatus status) const {\n+    if (Failed) {\n+        return *this;\n+    }\n+\n+    if (Path.Base()->IsRtmrVolume()) {\n+        return *this;\n+    }\n+\n+    return Fail(status, TStringBuilder() << \"path is not a run time map-reduce volume\"\n+        << \" (\" << BasicPathInfo(Path.Base()) << \")\");\n+}\n+\n const TPath::TChecker& TPath::TChecker::IsTheSameDomain(const TPath& another, EStatus status) const {\n     if (Failed) {\n         return *this;\ndiff --git a/ydb/core/tx/schemeshard/schemeshard_path.h b/ydb/core/tx/schemeshard/schemeshard_path.h\nindex 4e017c51b05a..4e167ac23dc3 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_path.h\n+++ b/ydb/core/tx/schemeshard/schemeshard_path.h\n@@ -78,6 +78,7 @@ class TPath {\n         const TChecker& IsCdcStream(EStatus status = EStatus::StatusNameConflict) const;\n         const TChecker& IsLikeDirectory(EStatus status = EStatus::StatusPathIsNotDirectory) const;\n         const TChecker& IsDirectory(EStatus status = EStatus::StatusPathIsNotDirectory) const;\n+        const TChecker& IsRtmrVolume(EStatus status = EStatus::StatusNameConflict) const;\n         const TChecker& IsTheSameDomain(const TPath& another, EStatus status = EStatus::StatusInvalidParameter) const;\n         const TChecker& FailOnWrongType(const TSet<TPathElement::EPathType>& expectedTypes) const;\n         const TChecker& FailOnWrongType(TPathElement::EPathType expectedType) const;\ndiff --git a/ydb/core/tx/schemeshard/schemeshard_path_describer.cpp b/ydb/core/tx/schemeshard/schemeshard_path_describer.cpp\nindex 9a266bd00694..819471cac026 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_path_describer.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard_path_describer.cpp\n@@ -1398,12 +1398,6 @@ void TSchemeShard::DescribeTableIndex(const TPathId& pathId, const TString& name\n     const auto* indexPathPtr = PathsById.FindPtr(pathId);\n     Y_ABORT_UNLESS(indexPathPtr);\n     const auto& indexPath = *indexPathPtr->Get();\n-    if (const auto size = indexPath.GetChildren().size(); indexInfo->Type == NKikimrSchemeOp::EIndexType::EIndexTypeGlobalVectorKmeansTree) {\n-        // For vector index we have 2 impl tables and 2 build impl tables\n-        Y_VERIFY_S(2 <= size && size <= 4, size);\n-    } else {\n-        Y_VERIFY_S(size == 1, size);\n-    }\n \n     ui64 dataSize = 0;\n     for (const auto& indexImplTablePathId : indexPath.GetChildren()) {\ndiff --git a/ydb/core/tx/schemeshard/schemeshard_utils.cpp b/ydb/core/tx/schemeshard/schemeshard_utils.cpp\nindex 3d3b99bc7af6..ec70a4fe58b4 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_utils.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard_utils.cpp\n@@ -317,6 +317,14 @@ auto CalcVectorKmeansTreePrefixImplTableDescImpl(\n \n }\n \n+void FillIndexTableColumns(\n+    const THashMap<ui32, NSchemeShard::TTableInfo::TColumn>& baseTableColumns,\n+    std::span<const TString> keys,\n+    const THashSet<TString>& columns,\n+    NKikimrSchemeOp::TTableDescription& implTableDesc) {\n+    FillIndexImplTableColumns(baseTableColumns, keys, columns, implTableDesc);\n+}\n+\n NKikimrSchemeOp::TTableDescription CalcImplTableDesc(\n     const NSchemeShard::TTableInfo::TPtr& baseTableInfo,\n     const TTableColumns& implTableColumns,\ndiff --git a/ydb/core/tx/schemeshard/schemeshard_utils.h b/ydb/core/tx/schemeshard/schemeshard_utils.h\nindex aac12855b5db..0557a4ecab04 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_utils.h\n+++ b/ydb/core/tx/schemeshard/schemeshard_utils.h\n@@ -96,6 +96,12 @@ TTableColumns ExtractInfo(const NSchemeShard::TTableInfo::TPtr& tableInfo);\n TTableColumns ExtractInfo(const NKikimrSchemeOp::TTableDescription& tableDesc);\n TIndexColumns ExtractInfo(const NKikimrSchemeOp::TIndexCreationConfig& indexDesc);\n \n+void FillIndexTableColumns(\n+    const THashMap<ui32, NSchemeShard::TTableInfo::TColumn>& baseTableColumns,\n+    std::span<const TString> keys,\n+    const THashSet<TString>& columns,\n+    NKikimrSchemeOp::TTableDescription& implTableDesc);\n+\n using TColumnTypes = THashMap<TString, NScheme::TTypeInfo>;\n \n bool ExtractTypes(const NSchemeShard::TTableInfo::TPtr& baseTableInfo, TColumnTypes& columnsTypes, TString& explain);\ndiff --git a/ydb/core/tx/schemeshard/ut_base/ut_base.cpp b/ydb/core/tx/schemeshard/ut_base/ut_base.cpp\nindex f71e0e5d8b2e..57569ae1cb6a 100644\n--- a/ydb/core/tx/schemeshard/ut_base/ut_base.cpp\n+++ b/ydb/core/tx/schemeshard/ut_base/ut_base.cpp\n@@ -11784,4 +11784,83 @@ Y_UNIT_TEST_SUITE(TSchemeShardTest) {\n             });\n         }\n     }\n+\n+    Y_UNIT_TEST(NewOwnerOnDatabase) {\n+        TTestBasicRuntime runtime;\n+        TTestEnv env(runtime);\n+        runtime.GetAppData().FeatureFlags.SetEnableAlterDatabase(true);\n+\n+        ui64 txId = 100;\n+\n+        TString newOwner = \"user1\";\n+\n+        TApplyIfUnit applyIfUnit;\n+        applyIfUnit.PathTypes = {NKikimrSchemeOp::EPathTypeSubDomain, NKikimrSchemeOp::EPathTypeExtSubDomain};\n+        TApplyIf applyIf = {applyIfUnit};\n+\n+        auto checkOwner = [=] (const NKikimrScheme::TEvDescribeSchemeResult& record) {\n+            const auto& self = record.GetPathDescription().GetSelf();\n+            UNIT_ASSERT_EQUAL(self.GetOwner(), newOwner);\n+        };\n+\n+        {\n+            TestCreateSubDomain(runtime, ++txId, \"/MyRoot\", R\"(\n+                Name: \"Subdomain\"\n+            )\");\n+\n+            {\n+                TestModifyACL(runtime, ++txId, \"/MyRoot\", \"Subdomain\", TString(), newOwner, NKikimrScheme::StatusSuccess, applyIf);\n+                TestDescribeResult(DescribePath(runtime, \"/MyRoot/Subdomain\"), {checkOwner});\n+            }\n+        }\n+\n+        {\n+            TestCreateExtSubDomain(runtime, ++txId,  \"/MyRoot\", R\"(\n+                Name: \"Extsubdomain\"\n+            )\");\n+\n+            {\n+                TestModifyACL(runtime, ++txId, \"/MyRoot\", \"Extsubdomain\", TString(), newOwner, NKikimrScheme::StatusSuccess, applyIf);\n+                TestDescribeResult(DescribePath(runtime, \"/MyRoot/Extsubdomain\"), {checkOwner});\n+            }\n+        }\n+\n+        { // last case didnt create external subdomain\n+            TestCreateExtSubDomain(runtime, ++txId,  \"/MyRoot\", R\"(\n+                Name: \"Extsubdomain2\"\n+            )\");\n+\n+            TestAlterExtSubDomain(runtime, ++txId, \"/MyRoot\", R\"(\n+                Name: \"Extsubdomain2\"\n+                PlanResolution: 50\n+                Coordinators: 1\n+                Mediators: 1\n+                TimeCastBucketsPerMediator: 2\n+                ExternalSchemeShard: true\n+                StoragePools {\n+                    Name: \"/dc-1/users/tenant-1:hdd\"\n+                    Kind: \"hdd\"\n+                }\n+            )\");\n+\n+            {\n+                TestModifyACL(runtime, ++txId, \"/MyRoot\", \"Extsubdomain2\", TString(), newOwner, NKikimrScheme::StatusSuccess, applyIf);\n+                TestDescribeResult(DescribePath(runtime, \"/MyRoot/Extsubdomain2\"), {checkOwner});\n+            }\n+        }\n+\n+        {\n+            TestCreateTable(runtime, txId, \"/MyRoot\", R\"(\n+                Name: \"Table\"\n+                Columns { Name: \"key\"   Type: \"Uint64\" }\n+                Columns { Name: \"value\" Type: \"Utf8\" }\n+                KeyColumnNames: [\"key\"]\n+            )\");\n+\n+            {\n+                TestModifyACL(runtime, ++txId, \"/MyRoot\", \"Table\", TString(), newOwner, NKikimrScheme::StatusPreconditionFailed, applyIf);\n+                TestModifyACL(runtime, ++txId, \"/MyRoot\", \"Table\", TString(), newOwner, NKikimrScheme::StatusSuccess);\n+            }\n+        }\n+    }\n }\ndiff --git a/ydb/core/tx/schemeshard/ut_helpers/helpers.cpp b/ydb/core/tx/schemeshard/ut_helpers/helpers.cpp\nindex 0e10fedcdea5..3936cb23652c 100644\n--- a/ydb/core/tx/schemeshard/ut_helpers/helpers.cpp\n+++ b/ydb/core/tx/schemeshard/ut_helpers/helpers.cpp\n@@ -187,19 +187,33 @@ namespace NSchemeShardUT_Private {\n     }\n \n     void SetApplyIf(NKikimrSchemeOp::TModifyScheme& transaction, const TApplyIf& applyIf) {\n-        for (auto& pathVersion: applyIf) {\n+        for (const auto& applyIfUnit: applyIf) {\n             auto condition = transaction.AddApplyIf();\n-            condition->SetPathId(pathVersion.PathId.LocalPathId);\n-            condition->SetPathVersion(pathVersion.Version);\n+\n+            if (applyIfUnit.PathId != TPathId()) {\n+                condition->SetPathId(applyIfUnit.PathId.LocalPathId);\n+                condition->SetPathVersion(applyIfUnit.Version);\n+            }\n+\n+            for (auto pathType : applyIfUnit.PathTypes) {\n+                condition->AddPathTypes(pathType);\n+            }\n         }\n     }\n \n-    TEvSchemeShard::TEvModifySchemeTransaction* CreateModifyACLRequest(ui64 txId, ui64 schemeshard, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner) {\n+    TEvSchemeShard::TEvModifySchemeTransaction* CreateModifyACLRequest(\n+        ui64 txId, ui64 schemeshard,\n+        TString parentPath, TString name, \n+        const TString& diffAcl, const TString& newOwner, const TApplyIf& applyIf\n+    )\n+    {\n         auto evTx = new TEvSchemeShard::TEvModifySchemeTransaction(txId, schemeshard);\n         auto transaction = evTx->Record.AddTransaction();\n         transaction->SetWorkingDir(parentPath);\n         transaction->SetOperationType(NKikimrSchemeOp::EOperationType::ESchemeOpModifyACL);\n \n+        SetApplyIf(*transaction, applyIf);\n+\n         auto op = transaction->MutableModifyACL();\n         op->SetName(name);\n         if (diffAcl) {\n@@ -212,25 +226,47 @@ namespace NSchemeShardUT_Private {\n         return evTx;\n     }\n \n-    void AsyncModifyACL(TTestActorRuntime& runtime, ui64 schemeShardId, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner) {\n-        AsyncSend(runtime, schemeShardId, CreateModifyACLRequest(txId, schemeShardId, parentPath, name, diffAcl, newOwner));\n+    void AsyncModifyACL(\n+        TTestActorRuntime& runtime,\n+        ui64 schemeShardId, ui64 txId,\n+        TString parentPath, TString name,\n+        const TString& diffAcl, const TString& newOwner, const TApplyIf& applyIf\n+    )\n+    {\n+        AsyncSend(runtime, schemeShardId, CreateModifyACLRequest(txId, schemeShardId, parentPath, name, diffAcl, newOwner, applyIf));\n     }\n \n-    void AsyncModifyACL(TTestActorRuntime& runtime, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner) {\n-        return AsyncModifyACL(runtime, TTestTxConfig::SchemeShard, txId, parentPath, name, diffAcl, newOwner);\n+    void AsyncModifyACL(\n+        TTestActorRuntime& runtime,\n+        ui64 txId, TString parentPath, TString name,\n+        const TString& diffAcl, const TString& newOwner, const TApplyIf& applyIf\n+    )\n+    {\n+        return AsyncModifyACL(runtime, TTestTxConfig::SchemeShard, txId, parentPath, name, diffAcl, newOwner, applyIf);\n     }\n \n-    void TestModifyACL(TTestActorRuntime& runtime, ui64 schemeShardId, ui64 txId, TString parentPath, TString name,\n-                       const TString& diffAcl, const TString& newOwner,\n-                       TEvSchemeShard::EStatus expectedResult) {\n-        AsyncModifyACL(runtime, schemeShardId, txId, parentPath, name, diffAcl, newOwner);\n+    void TestModifyACL(\n+        TTestActorRuntime& runtime,\n+        ui64 schemeShardId, ui64 txId,\n+        TString parentPath, TString name,\n+        const TString& diffAcl, const TString& newOwner,\n+        TEvSchemeShard::EStatus expectedResult,\n+        const TApplyIf& applyIf\n+    )\n+    {\n+        AsyncModifyACL(runtime, schemeShardId, txId, parentPath, name, diffAcl, newOwner, applyIf);\n         TestModificationResult(runtime, txId, expectedResult);\n     }\n \n-    void TestModifyACL(TTestActorRuntime& runtime, ui64 txId, TString parentPath, TString name,\n-                       const TString& diffAcl, const TString& newOwner,\n-                       TEvSchemeShard::EStatus expectedResult) {\n-        TestModifyACL(runtime, TTestTxConfig::SchemeShard, txId, parentPath, name, diffAcl, newOwner, expectedResult);\n+    void TestModifyACL(\n+        TTestActorRuntime& runtime,\n+        ui64 txId, TString parentPath, TString name,\n+        const TString& diffAcl, const TString& newOwner,\n+        TEvSchemeShard::EStatus expectedResult,\n+        const TApplyIf& applyIf\n+    )\n+    {\n+        TestModifyACL(runtime, TTestTxConfig::SchemeShard, txId, parentPath, name, diffAcl, newOwner, expectedResult, applyIf);\n     }\n \n \ndiff --git a/ydb/core/tx/schemeshard/ut_helpers/helpers.h b/ydb/core/tx/schemeshard/ut_helpers/helpers.h\nindex bcca433cc1cc..f44b17ca7a7c 100644\n--- a/ydb/core/tx/schemeshard/ut_helpers/helpers.h\n+++ b/ydb/core/tx/schemeshard/ut_helpers/helpers.h\n@@ -326,11 +326,11 @@ namespace NSchemeShardUT_Private {\n                                const TVector<TExpectedResult>& expectedResults = {NKikimrScheme::StatusAccepted});\n \n     // modify acl\n-    TEvTx* CreateModifyACLRequest(ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner);\n-    void AsyncModifyACL(TTestActorRuntime& runtime, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner);\n-    void AsyncModifyACL(TTestActorRuntime& runtime, ui64 schemeShard, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner);\n-    void TestModifyACL(TTestActorRuntime& runtime, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner, TEvSchemeShard::EStatus expectedResult = NKikimrScheme::StatusSuccess);\n-    void TestModifyACL(TTestActorRuntime& runtime, ui64 schemeShard, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner, TEvSchemeShard::EStatus expectedResult = NKikimrScheme::StatusSuccess);\n+    TEvTx* CreateModifyACLRequest(ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner, const TApplyIf& applyIf = {});\n+    void AsyncModifyACL(TTestActorRuntime& runtime, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner, const TApplyIf& applyIf = {});\n+    void AsyncModifyACL(TTestActorRuntime& runtime, ui64 schemeShard, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner, const TApplyIf& applyIf = {});\n+    void TestModifyACL(TTestActorRuntime& runtime, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner, TEvSchemeShard::EStatus expectedResult = NKikimrScheme::StatusSuccess, const TApplyIf& applyIf = {});\n+    void TestModifyACL(TTestActorRuntime& runtime, ui64 schemeShard, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner, TEvSchemeShard::EStatus expectedResult = NKikimrScheme::StatusSuccess, const TApplyIf& applyIf = {});\n \n     // upgrade subdomain\n     TEvTx* UpgradeSubDomainRequest(ui64 txId, const TString& parentPath, const TString& name);\ndiff --git a/ydb/core/tx/schemeshard/ut_helpers/ls_checks.h b/ydb/core/tx/schemeshard/ut_helpers/ls_checks.h\nindex eb42a9ef8f60..e41ad8b5e6b9 100644\n--- a/ydb/core/tx/schemeshard/ut_helpers/ls_checks.h\n+++ b/ydb/core/tx/schemeshard/ut_helpers/ls_checks.h\n@@ -23,7 +23,24 @@ struct TPathVersion {\n     TPathId PathId = TPathId();\n     ui64 Version = Max<ui64>();\n };\n-using TApplyIf = TVector<TPathVersion>;\n+\n+struct TApplyIfUnit : TPathVersion {\n+    std::vector<NKikimrSchemeOp::EPathType> PathTypes;\n+\n+    TApplyIfUnit() {}\n+\n+    TApplyIfUnit(const TPathVersion& pathVersion) {\n+        PathId = pathVersion.PathId;\n+        Version = pathVersion.Version;\n+    }\n+\n+    TApplyIfUnit(TPathVersion&& pathVersion) {\n+        PathId = std::move(pathVersion.PathId);\n+        Version = std::move(pathVersion.Version);\n+    }\n+};\n+\n+using TApplyIf = TVector<TApplyIfUnit>;\n \n using TUserAttrs = TVector<std::pair<TString, TString>>;\n \ndiff --git a/ydb/core/tx/schemeshard/ut_olap/ut_olap.cpp b/ydb/core/tx/schemeshard/ut_olap/ut_olap.cpp\nindex 527c067c0d7d..a4e65b233a48 100644\n--- a/ydb/core/tx/schemeshard/ut_olap/ut_olap.cpp\n+++ b/ydb/core/tx/schemeshard/ut_olap/ut_olap.cpp\n@@ -887,12 +887,12 @@ Y_UNIT_TEST_SUITE(TOlap) {\n \n         ui64 pathId = 0;\n         ui64 shardId = 0;\n-        ui64 planStep = 0;\n+        NTxUT::TPlanStep planStep;\n         auto checkFn = [&](const NKikimrScheme::TEvDescribeSchemeResult& record) {\n             auto& self = record.GetPathDescription().GetSelf();\n             pathId = self.GetPathId();\n             txId = self.GetCreateTxId() + 1;\n-            planStep = self.GetCreateStep();\n+            planStep =  NTxUT::TPlanStep{self.GetCreateStep()};\n             auto& sharding = record.GetPathDescription().GetColumnTableDescription().GetSharding();\n             UNIT_ASSERT_VALUES_EQUAL(sharding.ColumnShardsSize(), 1);\n             shardId = sharding.GetColumnShards()[0];\n@@ -902,7 +902,7 @@ Y_UNIT_TEST_SUITE(TOlap) {\n         TestLsPathId(runtime, 3, checkFn);\n         UNIT_ASSERT(shardId);\n         UNIT_ASSERT(pathId);\n-        UNIT_ASSERT(planStep);\n+        UNIT_ASSERT(planStep.Val());\n         {\n             auto description = DescribePrivatePath(runtime, TTestTxConfig::SchemeShard, \"/MyRoot/OlapStore/ColumnTable\", true, true);\n             Cerr << description.DebugString() << Endl;\n@@ -927,11 +927,11 @@ Y_UNIT_TEST_SUITE(TOlap) {\n                 std::vector<ui64> writeIds;\n                 ++txId;\n                 NTxUT::WriteData(runtime, sender, shardId, ++writeId, pathId, data, defaultYdbSchema, &writeIds, NEvWrite::EModificationType::Upsert, txId);\n-                NTxUT::ProposeCommit(runtime, sender, shardId, txId, writeIds, txId);\n+                planStep = NTxUT::ProposeCommit(runtime, sender, shardId, txId, writeIds, txId);\n                 txIds.insert(txId);\n             }\n \n-            NTxUT::PlanCommit(runtime, sender, shardId, ++planStep, txIds);\n+            NTxUT::PlanCommit(runtime, sender, shardId, planStep, txIds);\n \n             // emulate timeout\n             runtime.UpdateCurrentTime(TInstant::Now());\n@@ -940,8 +940,8 @@ Y_UNIT_TEST_SUITE(TOlap) {\n             std::vector<ui64> writeIds;\n             ++txId;\n             NTxUT::WriteData(runtime, sender, shardId, ++writeId, pathId, data, defaultYdbSchema, &writeIds, NEvWrite::EModificationType::Upsert, txId);\n-            NTxUT::ProposeCommit(runtime, sender, shardId, txId, writeIds, txId);\n-            NTxUT::PlanCommit(runtime, sender, shardId, ++planStep, { txId });\n+            planStep = NTxUT::ProposeCommit(runtime, sender, shardId, txId, writeIds, txId);\n+            NTxUT::PlanCommit(runtime, sender, shardId, planStep, { txId });\n         }\n         csController->WaitIndexation(TDuration::Seconds(5));\n         {\n@@ -1066,12 +1066,12 @@ Y_UNIT_TEST_SUITE(TOlap) {\n \n         ui64 pathId = 0;\n         ui64 shardId = 0;\n-        ui64 planStep = 0;\n+        NTxUT::TPlanStep planStep;\n         auto checkFn = [&](const NKikimrScheme::TEvDescribeSchemeResult& record) {\n             auto& self = record.GetPathDescription().GetSelf();\n             pathId = self.GetPathId();\n             txId = self.GetCreateTxId() + 1;\n-            planStep = self.GetCreateStep();\n+            planStep = NTxUT::TPlanStep{self.GetCreateStep()};\n             auto& sharding = record.GetPathDescription().GetColumnTableDescription().GetSharding();\n             UNIT_ASSERT_VALUES_EQUAL(sharding.ColumnShardsSize(), 1);\n             shardId = sharding.GetColumnShards()[0];\n@@ -1081,7 +1081,7 @@ Y_UNIT_TEST_SUITE(TOlap) {\n         TestLsPathId(runtime, 4, checkFn);\n         UNIT_ASSERT(shardId);\n         UNIT_ASSERT(pathId);\n-        UNIT_ASSERT(planStep);\n+        UNIT_ASSERT(planStep.Val());\n         {\n             auto description = DescribePrivatePath(runtime, TTestTxConfig::SchemeShard, \"/MyRoot/SomeDatabase/OlapStore/ColumnTable\", true, true);\n             Cerr << description.DebugString() << Endl;\n@@ -1106,11 +1106,11 @@ Y_UNIT_TEST_SUITE(TOlap) {\n                 std::vector<ui64> writeIds;\n                 ++txId;\n                 NTxUT::WriteData(runtime, sender, shardId, ++writeId, pathId, data, defaultYdbSchema, &writeIds, NEvWrite::EModificationType::Upsert, txId);\n-                NTxUT::ProposeCommit(runtime, sender, shardId, txId, writeIds, txId);\n+                planStep = NTxUT::ProposeCommit(runtime, sender, shardId, txId, writeIds, txId);\n                 txIds.insert(txId);\n             }\n \n-            NTxUT::PlanCommit(runtime, sender, shardId, ++planStep, txIds);\n+            NTxUT::PlanCommit(runtime, sender, shardId, planStep, txIds);\n \n             WaitTableStats(runtime, shardId);\n             CheckQuotaExceedance(runtime, TTestTxConfig::SchemeShard, \"/MyRoot/SomeDatabase\", true, DEBUG_HINT);\n@@ -1155,9 +1155,9 @@ Y_UNIT_TEST_SUITE(TOlap) {\n         ++txId;\n         bool delResult = NTxUT::WriteData(runtime, sender, shardId, ++writeId, pathId, data, defaultYdbSchema, &writeIds, NEvWrite::EModificationType::Delete, txId);\n         Y_UNUSED(delResult);\n-        NTxUT::ProposeCommit(runtime, sender, shardId, txId, writeIds, txId);\n+        planStep = NTxUT::ProposeCommit(runtime, sender, shardId, txId, writeIds, txId);\n         txIds.insert(txId);\n-        NTxUT::PlanCommit(runtime, sender, shardId, ++planStep, txIds);\n+        NTxUT::PlanCommit(runtime, sender, shardId, planStep, txIds);\n \n         csController->EnableBackground(NKikimr::NYDBTest::ICSController::EBackground::Compaction);\n         csController->WaitCompactions(TDuration::Seconds(60));\ndiff --git a/ydb/core/tx/sharding/sharding.cpp b/ydb/core/tx/sharding/sharding.cpp\nindex d95970482917..b8bef2a4108e 100644\n--- a/ydb/core/tx/sharding/sharding.cpp\n+++ b/ydb/core/tx/sharding/sharding.cpp\n@@ -241,13 +241,13 @@ NKikimrSchemeOp::TColumnTableSharding IShardingBase::SerializeToProto() const {\n     return result;\n }\n \n-THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> IShardingBase::SplitByShardsToArrowBatches(const std::shared_ptr<arrow::RecordBatch>& batch) {\n+THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> IShardingBase::SplitByShardsToArrowBatches(const std::shared_ptr<arrow::RecordBatch>& batch, arrow::MemoryPool* memoryPool) {\n     THashMap<ui64, std::vector<ui32>> sharding = MakeSharding(batch);\n     THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> chunks;\n     if (sharding.size() == 1) {\n         AFL_VERIFY(chunks.emplace(sharding.begin()->first, batch).second);\n     } else {\n-        chunks = NArrow::ShardingSplit(batch, sharding);\n+        chunks = NArrow::ShardingSplit(batch, sharding, memoryPool);\n     }\n     AFL_VERIFY(chunks.size() == sharding.size());\n     return chunks;\ndiff --git a/ydb/core/tx/sharding/sharding.h b/ydb/core/tx/sharding/sharding.h\nindex 4e0ba237a8b3..30c8a99ac175 100644\n--- a/ydb/core/tx/sharding/sharding.h\n+++ b/ydb/core/tx/sharding/sharding.h\n@@ -310,7 +310,7 @@ class IShardingBase {\n \n     virtual THashMap<ui64, std::vector<ui32>> MakeSharding(const std::shared_ptr<arrow::RecordBatch>& batch) const = 0;\n \n-    THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> SplitByShardsToArrowBatches(const std::shared_ptr<arrow::RecordBatch>& batch);\n+    THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> SplitByShardsToArrowBatches(const std::shared_ptr<arrow::RecordBatch>& batch, arrow::MemoryPool* memoryPool = arrow::default_memory_pool());\n     TConclusion<THashMap<ui64, std::vector<NArrow::TSerializedBatch>>> SplitByShards(const std::shared_ptr<arrow::RecordBatch>& batch, const ui64 chunkBytesLimit);\n \n     virtual TString DebugString() const;\ndiff --git a/ydb/core/tx/tx_proxy/rpc_long_tx.cpp b/ydb/core/tx/tx_proxy/rpc_long_tx.cpp\nindex 435dd536bec6..24f0d1a8bae6 100644\n--- a/ydb/core/tx/tx_proxy/rpc_long_tx.cpp\n+++ b/ydb/core/tx/tx_proxy/rpc_long_tx.cpp\n@@ -2,7 +2,7 @@\n \n #include <ydb/core/formats/arrow/size_calcer.h>\n #include <ydb/core/tx/columnshard/columnshard.h>\n-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>\n+#include <ydb/library/signals/object_counter.h>\n #include <ydb/core/tx/data_events/shard_writer.h>\n #include <ydb/core/tx/long_tx_service/public/events.h>\n #include <ydb/core/tx/schemeshard/schemeshard.h>\ndiff --git a/ydb/core/tx/tx_proxy/upload_rows.cpp b/ydb/core/tx/tx_proxy/upload_rows.cpp\nindex 5bf5d915eea1..c7e542f7e987 100644\n--- a/ydb/core/tx/tx_proxy/upload_rows.cpp\n+++ b/ydb/core/tx/tx_proxy/upload_rows.cpp\n@@ -70,8 +70,7 @@ class TUploadRowsInternal : public TUploadRowsBase<NKikimrServices::TActivity::U\n         return false;\n     }\n \n-    TVector<std::pair<TString, Ydb::Type>> GetRequestColumns(TString& errorMessage) const override {\n-        Y_UNUSED(errorMessage);\n+    TConclusion<TVector<std::pair<TString, Ydb::Type>>> GetRequestColumns() const override {\n         return *ColumnTypes;\n     }\n \ndiff --git a/ydb/core/tx/tx_proxy/upload_rows_common_impl.h b/ydb/core/tx/tx_proxy/upload_rows_common_impl.h\nindex 171ac8690ec7..e7c98d3ac5d5 100644\n--- a/ydb/core/tx/tx_proxy/upload_rows_common_impl.h\n+++ b/ydb/core/tx/tx_proxy/upload_rows_common_impl.h\n@@ -17,10 +17,11 @@\n #include <ydb/core/tx/datashard/datashard.h>\n #include <ydb/core/tx/scheme_cache/scheme_cache.h>\n #include <ydb/core/tx/tx_proxy/upload_rows_counters.h>\n+#include <ydb/core/formats/arrow/accessor/abstract/constructor.h>\n #include <ydb/core/formats/arrow/size_calcer.h>\n \n #include <library/cpp/monlib/dynamic_counters/counters.h>\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n \n #include <ydb/public/api/protos/ydb_status_codes.pb.h>\n #include <ydb/public/api/protos/ydb_value.pb.h>\n@@ -302,7 +303,7 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit\n     virtual const TString& GetTable() = 0;\n     virtual const TVector<std::pair<TSerializedCellVec, TString>>& GetRows() const = 0;\n     virtual bool CheckAccess(TString& errorMessage) = 0;\n-    virtual TVector<std::pair<TString, Ydb::Type>> GetRequestColumns(TString& errorMessage) const = 0;\n+    virtual TConclusion<TVector<std::pair<TString, Ydb::Type>>> GetRequestColumns() const = 0;\n     virtual bool ExtractRows(TString& errorMessage) = 0;\n     virtual bool ExtractBatch(TString& errorMessage) = 0;\n     virtual void RaiseIssue(const NYql::TIssue& issue) = 0;\n@@ -343,7 +344,7 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit\n     }\n \n     TStringBuilder LogPrefix() {\n-        return TStringBuilder() << \"Bulk upsert to table '\" << GetTable() << \"'\";\n+        return TStringBuilder() << \"Bulk upsert to table '\" << GetTable() << \"' \";\n     }\n \n     static bool SameDstType(NScheme::TTypeInfo type1, NScheme::TTypeInfo type2, bool allowConvert) {\n@@ -366,9 +367,10 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit\n         return ok;\n     }\n \n-    bool BuildSchema(const NActors::TActorContext& ctx, TString& errorMessage, bool makeYqbSchema) {\n+    [[nodiscard]] TConclusionStatus BuildSchema(const NActors::TActorContext& ctx, bool makeYqbSchema) {\n         Y_UNUSED(ctx);\n         Y_ABORT_UNLESS(ResolveNamesResult);\n+        AFL_VERIFY(ResolveNamesResult->ResultSet.size() == 1);\n \n         auto& entry = ResolveNamesResult->ResultSet.front();\n \n@@ -377,6 +379,7 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit\n         THashSet<TString> keyColumnsLeft;\n         THashSet<TString> notNullColumnsLeft = entry.NotNullColumns;\n         SrcColumns.reserve(entry.Columns.size());\n+        THashSet<TString> HasInternalConversion;\n \n         for (const auto& [_, colInfo] : entry.Columns) {\n             ui32 id = colInfo.Id;\n@@ -396,87 +399,95 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit\n             }\n         }\n \n+        if (entry.ColumnTableInfo) {\n+            for (const auto& colInfo : entry.ColumnTableInfo->Description.GetSchema().GetColumns()) {\n+                auto& name = colInfo.GetName();\n+                NArrow::NAccessor::TConstructorContainer accessor;\n+                if (colInfo.HasDataAccessorConstructor()) {\n+                    if (!accessor.DeserializeFromProto(colInfo.GetDataAccessorConstructor())) {\n+                        return TConclusionStatus::Fail(\"cannot parse accessor for column: \" + name);\n+                    }\n+                    if (accessor->HasInternalConversion()) {\n+                        HasInternalConversion.emplace(name);\n+                    }\n+                }\n+            }\n+        }\n+\n         KeyColumnPositions.resize(KeyColumnTypes.size());\n         KeyColumnNames.resize(KeyColumnTypes.size());\n \n-        auto reqColumns = GetRequestColumns(errorMessage);\n-        if (!errorMessage.empty()) {\n-            return false;\n-        } else if (reqColumns.empty()) {\n+        auto reqColumns = GetRequestColumns();\n+        if (reqColumns.IsFail()) {\n+            return reqColumns;\n+        } else if (reqColumns->empty()) {\n             for (auto& [name, typeInfo] : SrcColumns) {\n                 Ydb::Type ydbType;\n                 ProtoFromTypeInfo(typeInfo, ydbType);\n-                reqColumns.emplace_back(name, std::move(ydbType));\n+                reqColumns->emplace_back(name, std::move(ydbType));\n             }\n         }\n \n-        for (size_t pos = 0; pos < reqColumns.size(); ++pos) {\n-            auto& name = reqColumns[pos].first;\n+        for (size_t pos = 0; pos < reqColumns->size(); ++pos) {\n+            auto& name = (*reqColumns)[pos].first;\n             const auto* cp = columnByName.FindPtr(name);\n             if (!cp) {\n-                errorMessage = Sprintf(\"Unknown column: %s\", name.c_str());\n-                return false;\n+                return TConclusionStatus::Fail(Sprintf(\"Unknown column: %s\", name.c_str()));\n             }\n             i32 pgTypeMod = -1;            \n-            ui32 colId = *cp;\n+            const ui32 colId = *cp;\n             auto& ci = *entry.Columns.FindPtr(colId);\n \n             TString columnTypeName = NScheme::TypeName(ci.PType, ci.PTypeMod);\n \n-            const Ydb::Type& typeInProto = reqColumns[pos].second;\n+            const Ydb::Type& typeInProto = (*reqColumns)[pos].second;\n             \n             TString parseProtoError;\n             NScheme::TTypeInfoMod inTypeInfoMod;\n             if (!NScheme::TypeInfoFromProto(typeInProto, inTypeInfoMod, parseProtoError)){\n-                errorMessage = Sprintf(\"Type parse error for column %s: %s\",\n-                    name.c_str(), parseProtoError.c_str());\n-                return false;\n+                return TConclusionStatus::Fail(Sprintf(\"Type parse error for column %s: %s\",\n+                    name.c_str(), parseProtoError.c_str()));\n             }\n \n             const NScheme::TTypeInfo& typeInRequest = inTypeInfoMod.TypeInfo;\n \n             TString inTypeName = NScheme::TypeName(typeInRequest, typeInRequest.GetPgTypeMod(ci.PTypeMod));\n \n-            if (typeInProto.has_type_id()) {\n-                bool sourceIsArrow = GetSourceType() != EUploadSource::ProtoValues;\n+                if (typeInProto.has_type_id()) {\n+                    bool sourceIsArrow = GetSourceType() != EUploadSource::ProtoValues;\n                 bool ok = SameOrConvertableDstType(typeInRequest, ci.PType, sourceIsArrow); // TODO\n-                if (!ok) {\n-                    errorMessage = Sprintf(\"Type mismatch, got type %s for column %s, but expected %s\",\n-                        inTypeName.c_str(), name.c_str(), columnTypeName.c_str());\n-                    return false;\n-                }\n-                if (NArrow::TArrowToYdbConverter::NeedInplaceConversion(typeInRequest, ci.PType)) {\n-                    ColumnsToConvertInplace[name] = ci.PType;\n-                }\n-            } else if (typeInProto.has_decimal_type()) {\n-                if (typeInRequest != ci.PType) {\n-                    errorMessage = Sprintf(\"Type mismatch, got type %s for column %s, but expected %s\",\n-                        inTypeName.c_str(), name.c_str(), columnTypeName.c_str());\n-                    return false;\n-                }\n-            } else if (typeInProto.has_pg_type()) {\n-                bool ok = SameDstType(typeInRequest, ci.PType, false);\n-                if (!ok) {\n-                    errorMessage = Sprintf(\"Type mismatch, got type %s for column %s, but expected %s\",\n-                        inTypeName.c_str(), name.c_str(), columnTypeName.c_str());\n-                    return false;\n-                }\n-                if (!ci.PTypeMod.empty() && NPg::TypeDescNeedsCoercion(typeInRequest.GetPgTypeDesc())) {\n-                    if (inTypeInfoMod.TypeMod != ci.PTypeMod) {\n-                        errorMessage = Sprintf(\"Typemod mismatch, got type %s for column %s, type mod %s, but expected %s\",\n-                            inTypeName.c_str(), name.c_str(), inTypeInfoMod.TypeMod.c_str(), ci.PTypeMod.c_str());\n-                        return false;\n+                    if (!ok) {\n+                    return TConclusionStatus::Fail(Sprintf(\"Type mismatch, got type %s for column %s, but expected %s\",\n+                        inTypeName.c_str(), name.c_str(), columnTypeName.c_str()));\n                     }\n+                    if (NArrow::TArrowToYdbConverter::NeedInplaceConversion(typeInRequest, ci.PType)) {\n+                        ColumnsToConvertInplace[name] = ci.PType;\n+                    }\n+                } else if (typeInProto.has_decimal_type()) {\n+                    if (typeInRequest != ci.PType) {\n+                    return TConclusionStatus::Fail(Sprintf(\"Type mismatch, got type %s for column %s, but expected %s\",\n+                        inTypeName.c_str(), name.c_str(), columnTypeName.c_str()));\n+                    }\n+                } else if (typeInProto.has_pg_type()) {\n+                    bool ok = SameDstType(typeInRequest, ci.PType, false);\n+                    if (!ok) {\n+                    return TConclusionStatus::Fail(Sprintf(\"Type mismatch, got type %s for column %s, but expected %s\",\n+                        inTypeName.c_str(), name.c_str(), columnTypeName.c_str()));\n+                    }\n+                    if (!ci.PTypeMod.empty() && NPg::TypeDescNeedsCoercion(typeInRequest.GetPgTypeDesc())) {\n+                        if (inTypeInfoMod.TypeMod != ci.PTypeMod) {\n+                            return TConclusionStatus::Fail(Sprintf(\"Typemod mismatch, got type %s for column %s, type mod %s, but expected %s\",\n+                                inTypeName.c_str(), name.c_str(), inTypeInfoMod.TypeMod.c_str(), ci.PTypeMod.c_str()));\n+                        }\n \n-                    const auto result = NPg::BinaryTypeModFromTextTypeMod(inTypeInfoMod.TypeMod, typeInRequest.GetPgTypeDesc());\n-                    if (result.Error) {\n-                        errorMessage = Sprintf(\"Invalid typemod %s, got type %s for column %s, error %s\",\n-                           inTypeInfoMod.TypeMod.c_str(), inTypeName.c_str(), name.c_str(), result.Error->c_str());\n-                        return false;\n+                        const auto result = NPg::BinaryTypeModFromTextTypeMod(inTypeInfoMod.TypeMod, typeInRequest.GetPgTypeDesc());\n+                        if (result.Error) {\n+                            return TConclusionStatus::Fail(Sprintf(\"Invalid typemod %s, got type %s for column %s, error %s\",\n+                                inTypeInfoMod.TypeMod.c_str(), inTypeName.c_str(), name.c_str(), result.Error->c_str()));\n+                        }\n+                        pgTypeMod = result.Typmod;\n                     }\n-                    pgTypeMod = result.Typmod;\n                 }\n-            }\n \n             bool notNull = entry.NotNullColumns.contains(ci.Name);\n             if (notNull) {\n@@ -524,8 +535,7 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit\n             }\n \n             if (!allowUpdate) {\n-                errorMessage = \"Only async-indexed tables are supported by BulkUpsert\";\n-                return false;\n+                return TConclusionStatus::Fail(\"Only async-indexed tables are supported by BulkUpsert\");\n             }\n         }\n \n@@ -546,6 +556,9 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit\n             }\n \n             for (const auto& [colName, colType] : YdbSchema) {\n+                if (HasInternalConversion.contains(colName)) {\n+                    continue;\n+                }\n                 if (NArrow::TArrowToYdbConverter::NeedDataConversion(colType)) {\n                     ColumnsToConvert[colName] = colType;\n                 }\n@@ -553,8 +566,7 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit\n         }\n \n         if (!keyColumnsLeft.empty()) {\n-            errorMessage = Sprintf(\"Missing key columns: %s\", JoinSeq(\", \", keyColumnsLeft).c_str());\n-            return false;\n+            return TConclusionStatus::Fail(Sprintf(\"Missing key columns: %s\", JoinSeq(\", \", keyColumnsLeft).c_str()));\n         }\n \n         if (!notNullColumnsLeft.empty() && UpsertIfExists) {\n@@ -564,11 +576,10 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit\n         }\n \n         if (!notNullColumnsLeft.empty()) {\n-            errorMessage = Sprintf(\"Missing not null columns: %s\", JoinSeq(\", \", notNullColumnsLeft).c_str());\n-            return false;\n+            return TConclusionStatus::Fail(Sprintf(\"Missing not null columns: %s\", JoinSeq(\", \", notNullColumnsLeft).c_str()));\n         }\n \n-        return true;\n+        return TConclusionStatus::Success();\n     }\n \n     void ResolveTable(const TString& table, const NActors::TActorContext& ctx) {\n@@ -615,7 +626,7 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit\n         }\n \n         TableKind = entry.Kind;\n-        bool isColumnTable = (TableKind == NSchemeCache::TSchemeCacheNavigate::KindColumnTable);\n+        const bool isColumnTable = (TableKind == NSchemeCache::TSchemeCacheNavigate::KindColumnTable);\n \n         if (entry.TableId.IsSystemView()) {\n             return ReplyWithError(Ydb::StatusIds::SCHEME_ERROR, \"is not supported. Table is a system view\", ctx);\n@@ -631,11 +642,14 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit\n         ResolveNamesResult.reset(ev->Get()->Request.Release());\n \n         bool makeYdbSchema = isColumnTable || (GetSourceType() != EUploadSource::ProtoValues);\n-        TString errorMessage;\n-        if (!BuildSchema(ctx, errorMessage, makeYdbSchema)) {\n-            return ReplyWithError(Ydb::StatusIds::SCHEME_ERROR, errorMessage, ctx);\n+        {\n+            auto conclusion = BuildSchema(ctx, makeYdbSchema);\n+            if (conclusion.IsFail()) {\n+                return ReplyWithError(Ydb::StatusIds::SCHEME_ERROR, conclusion.GetErrorMessage(), ctx);\n+            }\n         }\n \n+        TString errorMessage;\n         switch (GetSourceType()) {\n             case EUploadSource::ProtoValues:\n             {\ndiff --git a/ydb/core/tx/tx_proxy/upload_rows_counters.h b/ydb/core/tx/tx_proxy/upload_rows_counters.h\nindex 4839e76da172..f48292b896c1 100644\n--- a/ydb/core/tx/tx_proxy/upload_rows_counters.h\n+++ b/ydb/core/tx/tx_proxy/upload_rows_counters.h\n@@ -1,7 +1,7 @@\n #pragma once\n \n #include <ydb/library/actors/core/log.h>\n-#include <ydb/core/tx/columnshard/counters/common/owner.h>\n+#include <ydb/library/signals/owner.h>\n #include <ydb/core/tx/scheme_cache/scheme_cache.h>\n \n #include <ydb/public/api/protos/ydb_status_codes.pb.h>\ndiff --git a/ydb/core/ydb_convert/table_description.cpp b/ydb/core/ydb_convert/table_description.cpp\nindex afe68309c8a2..94041248b9af 100644\n--- a/ydb/core/ydb_convert/table_description.cpp\n+++ b/ydb/core/ydb_convert/table_description.cpp\n@@ -740,6 +740,18 @@ bool FillColumnDescriptionImpl(TColumnTable& out, const google::protobuf::Repeat\n         if (!column.Getfamily().empty()) {\n             columnDesc->SetColumnFamilyName(column.Getfamily());\n         }\n+\n+        if (column.has_from_literal()) {\n+            status = Ydb::StatusIds::BAD_REQUEST;\n+            error = TStringBuilder() << \"Default values are not supported in column tables\";\n+            return false;\n+        }\n+\n+        if (column.has_from_sequence()) {\n+            status = Ydb::StatusIds::BAD_REQUEST;\n+            error = TStringBuilder() << \"Default sequences are not supported in column tables\";\n+            return false;\n+        }\n     }\n \n     return true;\ndiff --git a/ydb/docs/en/core/yql/reference/_includes/permissions_list.md b/ydb/docs/en/core/yql/reference/_includes/permissions_list.md\nindex 4c3a108b2d86..edbbe713739a 100644\n--- a/ydb/docs/en/core/yql/reference/_includes/permissions_list.md\n+++ b/ydb/docs/en/core/yql/reference/_includes/permissions_list.md\n@@ -12,8 +12,8 @@ The possible names of rights are listed in the table below.\n | `ydb.database.drop`                   | `DROP`              | The right to delete databases in the cluster                                                        |\n | **Elementary rights for database objects** |                |                                                                                                      |\n | `ydb.granular.select_row`             | `SELECT ROW`        | The right to read rows from a table (select), read messages from topics                             |\n-| `ydb.granular.update_row`             | `UPDATE ROW`        | The right to update rows in a table (insert, update, erase), write messages to topics               |\n-| `ydb.granular.erase_row`              | `ERASE ROW`         | The right to delete rows from a table                                                               |\n+| `ydb.granular.update_row`             | `UPDATE ROW`        | The right to update rows in a table (insert, update, upsert, replace), write messages to topics     |\n+| `ydb.granular.erase_row`              | `ERASE ROW`         | The right to delete rows from a table (delete)                                                      |\n | `ydb.granular.create_directory`       | `CREATE DIRECTORY`  | The right to create and delete directories, including existing and nested ones                      |\n | `ydb.granular.create_table`           | `CREATE TABLE`      | The right to create tables (including index, external, columnar), views, sequences                  |\n | `ydb.granular.create_queue`           | `CREATE QUEUE`      | The right to create topics                                                                          |\ndiff --git a/ydb/docs/ru/core/yql/reference/_includes/permissions_list.md b/ydb/docs/ru/core/yql/reference/_includes/permissions_list.md\nindex 08ceae13ba4c..6fc055287861 100644\n--- a/ydb/docs/ru/core/yql/reference/_includes/permissions_list.md\n+++ b/ydb/docs/ru/core/yql/reference/_includes/permissions_list.md\n@@ -11,8 +11,8 @@\n `ydb.database.drop` | `DROP` | \u041f\u0440\u0430\u0432\u043e \u0443\u0434\u0430\u043b\u044f\u0442\u044c \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445 \u0432 \u043a\u043b\u0430\u0441\u0442\u0435\u0440\u0435\n \u042d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u0440\u043d\u044b\u0435 \u043f\u0440\u0430\u0432\u0430 \u043d\u0430 \u043e\u0431\u044a\u0435\u043a\u0442\u044b \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445\n `ydb.granular.select_row` | `SELECT ROW` | \u041f\u0440\u0430\u0432\u043e \u0447\u0438\u0442\u0430\u0442\u044c \u0441\u0442\u0440\u043e\u043a\u0438 \u0438\u0437 \u0442\u0430\u0431\u043b\u0438\u0446\u044b (select), \u0447\u0438\u0442\u0430\u0442\u044c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u0438\u0437 \u0442\u043e\u043f\u0438\u043a\u043e\u0432\n-`ydb.granular.update_row` | `UPDATE ROW` | \u041f\u0440\u0430\u0432\u043e \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u0442\u044c \u0441\u0442\u0440\u043e\u043a\u0438 \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 (insert, update, insert, erase), \u043f\u0438\u0441\u0430\u0442\u044c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u0432 \u0442\u043e\u043f\u0438\u043a\u0438\n-`ydb.granular.erase_row` | `ERASE ROW` | \u041f\u0440\u0430\u0432\u043e \u0443\u0434\u0430\u043b\u044f\u0442\u044c \u0441\u0442\u0440\u043e\u043a\u0438 \u0438\u0437 \u0442\u0430\u0431\u043b\u0438\u0446\u044b\n+`ydb.granular.update_row` | `UPDATE ROW` | \u041f\u0440\u0430\u0432\u043e \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u0442\u044c \u0441\u0442\u0440\u043e\u043a\u0438 \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 (insert, update, upsert, replace), \u043f\u0438\u0441\u0430\u0442\u044c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u0432 \u0442\u043e\u043f\u0438\u043a\u0438\n+`ydb.granular.erase_row` | `ERASE ROW` | \u041f\u0440\u0430\u0432\u043e \u0443\u0434\u0430\u043b\u044f\u0442\u044c \u0441\u0442\u0440\u043e\u043a\u0438 \u0438\u0437 \u0442\u0430\u0431\u043b\u0438\u0446\u044b (delete)\n `ydb.granular.create_directory` | `CREATE DIRECTORY` | \u041f\u0440\u0430\u0432\u043e \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0442\u044c \u0438 \u0443\u0434\u0430\u043b\u044f\u0442\u044c \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438, \u0432 \u0442\u043e\u043c \u0447\u0438\u0441\u043b\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0435 \u0438 \u0432\u043b\u043e\u0436\u0435\u043d\u043d\u044b\u0435\n `ydb.granular.create_table` | `CREATE TABLE` | \u041f\u0440\u0430\u0432\u043e \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0442\u044c \u0442\u0430\u0431\u043b\u0438\u0446\u044b (\u0432 \u0442\u043e\u043c \u0447\u0438\u0441\u043b\u0435 \u0438\u043d\u0434\u0435\u043a\u0441\u043d\u044b\u0435, \u0432\u043d\u0435\u0448\u043d\u0438\u0435, \u043a\u043e\u043b\u043e\u043d\u043e\u0447\u043d\u044b\u0435), \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u044f, \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438\n `ydb.granular.create_queue` | `CREATE QUEUE` | \u041f\u0440\u0430\u0432\u043e \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0442\u044c \u0442\u043e\u043f\u0438\u043a\u0438\ndiff --git a/ydb/library/accessor/positive_integer.cpp b/ydb/library/accessor/positive_integer.cpp\nindex dce6a9c33af3..65f5a01bc609 100644\n--- a/ydb/library/accessor/positive_integer.cpp\n+++ b/ydb/library/accessor/positive_integer.cpp\n@@ -34,10 +34,25 @@ ui64 TPositiveControlInteger::Val() const {\n     return Value.Val();\n }\n \n+TPositiveIncreasingControlInteger&TPositiveIncreasingControlInteger::operator=(const TPositiveIncreasingControlInteger& v) {\n+    if (&v != this) {\n+        AFL_VERIFY(Value < v.Value);\n+        Value = v.Value;\n+    }\n+    return *this;\n }\n \n+} //namespace NKikimr\n+\n template<>\n void Out<NKikimr::TPositiveControlInteger>(IOutputStream& o,\n     typename TTypeTraits<NKikimr::TPositiveControlInteger>::TFuncParam x) {\n     o << x.Val();\n }\n+\n+\n+template<>\n+void Out<NKikimr::TPositiveIncreasingControlInteger>(IOutputStream& o,\n+    typename TTypeTraits<NKikimr::TPositiveIncreasingControlInteger>::TFuncParam x) {\n+    o << x.Val();\n+}\ndiff --git a/ydb/library/accessor/positive_integer.h b/ydb/library/accessor/positive_integer.h\nindex 3df6e2a6e4b6..266d49453e73 100644\n--- a/ydb/library/accessor/positive_integer.h\n+++ b/ydb/library/accessor/positive_integer.h\n@@ -1,4 +1,5 @@\n #pragma once\n+#include <ydb/library/actors/core/log.h>\n #include <util/system/types.h>\n #include <util/stream/output.h>\n #include <util/generic/typetraits.h>\n@@ -40,4 +41,26 @@ class TPositiveControlInteger {\n     }\n };\n \n+class TPositiveIncreasingControlInteger {\n+    private:\n+        ui64 Value = 0;\n+    public:\n+        constexpr TPositiveIncreasingControlInteger() = default;\n+        explicit constexpr TPositiveIncreasingControlInteger(const ui64 value)\n+            : Value(value) {\n+        }\n+        TPositiveIncreasingControlInteger(const TPositiveIncreasingControlInteger&) = default;\n+        TPositiveIncreasingControlInteger& operator=(const TPositiveIncreasingControlInteger& v);\n+\n+        TPositiveIncreasingControlInteger operator+(ui64 v) const {\n+            return TPositiveIncreasingControlInteger(Value + v);\n+        }\n+        TPositiveIncreasingControlInteger operator-(const ui64 v) const {\n+            AFL_VERIFY(v <= Value);\n+            return TPositiveIncreasingControlInteger(Value - v);\n+        }\n+        ui64 Val() const {\n+            return Value;\n+        }\n+    };\n }\ndiff --git a/ydb/library/conclusion/generic/string_status.h b/ydb/library/conclusion/generic/string_status.h\nindex 81541395d055..c485bcc7e757 100644\n--- a/ydb/library/conclusion/generic/string_status.h\n+++ b/ydb/library/conclusion/generic/string_status.h\n@@ -44,6 +44,7 @@ class TConclusionStatusImpl: public TConclusionStatusGenericImpl<TConclusionStat\n     }\n \n     [[nodiscard]] TString GetErrorMessage() const {\n+        Y_ABORT_UNLESS(TBase::IsFail());\n         return TBase::GetErrorDescription();\n     }\n };\ndiff --git a/ydb/library/formats/arrow/arrow_helpers.cpp b/ydb/library/formats/arrow/arrow_helpers.cpp\nindex a5efddc2f6a2..2a2c8cd0ce1c 100644\n--- a/ydb/library/formats/arrow/arrow_helpers.cpp\n+++ b/ydb/library/formats/arrow/arrow_helpers.cpp\n@@ -83,20 +83,26 @@ bool IsTrivial(const arrow::UInt64Array& permutation, const ui64 originalLength)\n }\n \n std::shared_ptr<arrow::RecordBatch> Reorder(\n-    const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::UInt64Array>& permutation, const bool canRemove) {\n+        const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::UInt64Array>& permutation,\n+        const bool canRemove, arrow::MemoryPool* memoryPool) {\n     Y_ABORT_UNLESS(permutation->length() == batch->num_rows() || canRemove);\n \n-    auto res = IsTrivial(*permutation, batch->num_rows()) ? batch : arrow::compute::Take(batch, permutation);\n+    arrow::compute::ExecContext ctx(memoryPool);\n+    auto res = IsTrivial(*permutation, batch->num_rows())\n+        ? batch\n+        : arrow::compute::Take(batch, permutation, arrow::compute::TakeOptions::Defaults(), &ctx);\n     Y_ABORT_UNLESS(res.ok());\n     return (*res).record_batch();\n }\n \n THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> ShardingSplit(\n-    const std::shared_ptr<arrow::RecordBatch>& batch, const THashMap<ui64, std::vector<ui32>>& shardRows) {\n+        const std::shared_ptr<arrow::RecordBatch>& batch,\n+        const THashMap<ui64, std::vector<ui32>>& shardRows,\n+        arrow::MemoryPool* memoryPool) {\n     AFL_VERIFY(batch);\n     std::shared_ptr<arrow::UInt64Array> permutation;\n     {\n-        arrow::UInt64Builder builder;\n+        arrow::UInt64Builder builder(memoryPool);\n         Y_VERIFY_OK(builder.Reserve(batch->num_rows()));\n \n         for (auto&& [shardId, rowIdxs] : shardRows) {\n@@ -742,7 +748,7 @@ std::vector<std::shared_ptr<arrow::RecordBatch>> SliceToRecordBatches(const std:\n                 positions.emplace_back(pos);\n                 pos += arr->length();\n             }\n-            AFL_VERIFY(pos == t->num_rows());\n+            AFL_VERIFY(pos == t->num_rows())(\"pos\", pos)(\"length\", t->num_rows());\n         }\n         positions.emplace_back(t->num_rows());\n     }\ndiff --git a/ydb/library/formats/arrow/arrow_helpers.h b/ydb/library/formats/arrow/arrow_helpers.h\nindex faa630a0904d..e2ece344d9fa 100644\n--- a/ydb/library/formats/arrow/arrow_helpers.h\n+++ b/ydb/library/formats/arrow/arrow_helpers.h\n@@ -53,7 +53,7 @@ std::vector<std::shared_ptr<arrow::RecordBatch>> ShardingSplit(\n std::vector<std::shared_ptr<arrow::RecordBatch>> ShardingSplit(\n     const std::shared_ptr<arrow::RecordBatch>& batch, const std::vector<std::vector<ui32>>& shardRows, const ui32 numShards);\n THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> ShardingSplit(\n-    const std::shared_ptr<arrow::RecordBatch>& batch, const THashMap<ui64, std::vector<ui32>>& shardRows);\n+    const std::shared_ptr<arrow::RecordBatch>& batch, const THashMap<ui64, std::vector<ui32>>& shardRows, arrow::MemoryPool* memoryPool);\n \n std::unique_ptr<arrow::ArrayBuilder> MakeBuilder(\n     const std::shared_ptr<arrow::Field>& field, const ui32 reserveItems = 0, const ui32 reserveSize = 0);\n@@ -110,7 +110,10 @@ TString DebugString(std::shared_ptr<arrow::Array> array, const ui32 position);\n NJson::TJsonValue DebugJson(std::shared_ptr<arrow::RecordBatch> array, const ui32 position);\n \n std::shared_ptr<arrow::RecordBatch> Reorder(\n-    const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::UInt64Array>& permutation, const bool canRemove);\n+    const std::shared_ptr<arrow::RecordBatch>& batch,\n+    const std::shared_ptr<arrow::UInt64Array>& permutation,\n+    const bool canRemove,\n+    arrow::MemoryPool* pool = arrow::default_memory_pool());\n \n // Deep-copies all internal arrow::buffers - and makes sure that new buffers don't have any parents.\n std::shared_ptr<arrow::Table> DeepCopy(const std::shared_ptr<arrow::Table>& table, arrow::MemoryPool* pool = arrow::default_memory_pool());\ndiff --git a/ydb/library/formats/arrow/protos/accessor.proto b/ydb/library/formats/arrow/protos/accessor.proto\nindex b9edfe1be126..7cb298cf6978 100644\n--- a/ydb/library/formats/arrow/protos/accessor.proto\n+++ b/ydb/library/formats/arrow/protos/accessor.proto\n@@ -1,5 +1,23 @@\n package NKikimrArrowAccessorProto;\n \n+message TDataExtractor {\n+    optional string ClassName = 1;\n+\n+    message TJsonScanner {\n+        optional bool FirstLevelOnly = 1 [default = false];\n+        optional bool ForceSIMDJsonParsing = 2 [default = false];\n+    }\n+\n+    message TSIMDJsonScanner {\n+        optional bool FirstLevelOnly = 1 [default = false];\n+    }\n+\n+    oneof Implementation {\n+        TJsonScanner JsonScanner = 20;\n+        TSIMDJsonScanner SIMDJsonScanner = 21;\n+    }\n+}\n+\n message TRequestedConstructor {\n     optional string ClassName = 1;\n \n@@ -15,6 +33,7 @@ message TRequestedConstructor {\n             optional uint32 ColumnsLimit = 2 [default = 1024];\n             optional uint32 ChunkMemoryLimit = 3 [default = 50000000];\n             optional double OthersAllowedFraction = 4 [default = 0.05];\n+            optional TDataExtractor DataExtractor = 5;\n         }\n         optional TSettings Settings = 1;\n     }\n@@ -41,6 +60,7 @@ message TConstructor {\n             optional uint32 ColumnsLimit = 2 [default = 1024];\n             optional uint32 ChunkMemoryLimit = 3 [default = 50000000];\n             optional double OthersAllowedFraction = 4 [default = 0.05];\n+            optional TDataExtractor DataExtractor = 5;\n         }\n         optional TSettings Settings = 1;\n     }\ndiff --git a/ydb/library/formats/arrow/replace_key.h b/ydb/library/formats/arrow/replace_key.h\nindex a0e3a26b27e5..c4fe75d21d0e 100644\n--- a/ydb/library/formats/arrow/replace_key.h\n+++ b/ydb/library/formats/arrow/replace_key.h\n@@ -8,7 +8,6 @@\n \n #include <contrib/libs/apache/arrow/cpp/src/arrow/api.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/compute/api_vector.h>\n-\n #include <util/string/builder.h>\n #include <util/string/join.h>\n \n@@ -18,7 +17,7 @@ namespace NKikimr::NArrow {\n \n using TArrayVec = std::vector<std::shared_ptr<arrow::Array>>;\n \n-template<typename TArrayVecPtr>\n+template <typename TArrayVecPtr>\n class TReplaceKeyTemplate {\n public:\n     static constexpr bool IsOwning = std::is_same_v<TArrayVecPtr, std::shared_ptr<TArrayVec>>;\n@@ -64,21 +63,20 @@ class TReplaceKeyTemplate {\n \n     TReplaceKeyTemplate(TArrayVecPtr columns, const ui64 position)\n         : Columns(columns)\n-        , Position(position)\n-    {\n+        , Position(position) {\n         Y_ABORT_UNLESS(Size() > 0 && Position < (ui64)Column(0).length());\n     }\n \n-    template<typename T = TArrayVecPtr> requires IsOwning\n+    template <typename T = TArrayVecPtr>\n+        requires IsOwning\n     TReplaceKeyTemplate(TArrayVec&& columns, const ui64 position)\n         : Columns(std::make_shared<TArrayVec>(std::move(columns)))\n-        , Position(position)\n-    {\n+        , Position(position) {\n         Y_ABORT_UNLESS(Size() > 0 && Position < (ui64)Column(0).length());\n     }\n \n-    template<typename T>\n-    bool operator == (const TReplaceKeyTemplate<T>& key) const {\n+    template <typename T>\n+    bool operator==(const TReplaceKeyTemplate<T>& key) const {\n         Y_ABORT_UNLESS(Size() == key.Size());\n \n         for (ui32 i = 0; i < Size(); ++i) {\n@@ -90,8 +88,8 @@ class TReplaceKeyTemplate {\n         return true;\n     }\n \n-    template<typename T>\n-    std::partial_ordering operator <=> (const TReplaceKeyTemplate<T>& key) const {\n+    template <typename T>\n+    std::partial_ordering operator<=>(const TReplaceKeyTemplate<T>& key) const {\n         Y_ABORT_UNLESS(Size() == key.Size());\n \n         for (ui32 i = 0; i < Size(); ++i) {\n@@ -103,7 +101,7 @@ class TReplaceKeyTemplate {\n         return std::partial_ordering::equivalent;\n     }\n \n-    template<typename T>\n+    template <typename T>\n     std::partial_ordering CompareNotNull(const TReplaceKeyTemplate<T>& key) const {\n         Y_ABORT_UNLESS(Size() == key.Size());\n \n@@ -116,7 +114,7 @@ class TReplaceKeyTemplate {\n         return std::partial_ordering::equivalent;\n     }\n \n-    template<typename T>\n+    template <typename T>\n     std::partial_ordering ComparePartNotNull(const TReplaceKeyTemplate<T>& key, const ui32 size) const {\n         Y_ABORT_UNLESS(size <= key.Size());\n         Y_ABORT_UNLESS(size <= Size());\n@@ -130,13 +128,13 @@ class TReplaceKeyTemplate {\n         return std::partial_ordering::equivalent;\n     }\n \n-    template<typename T>\n+    template <typename T>\n     std::partial_ordering CompareColumnValueNotNull(int column, const TReplaceKeyTemplate<T>& key, int keyColumn) const {\n         Y_DEBUG_ABORT_UNLESS(Column(column).type_id() == key.Column(keyColumn).type_id());\n         return TComparator::TypedCompare<true>(Column(column), Position, key.Column(keyColumn), key.Position);\n     }\n \n-    template<typename T>\n+    template <typename T>\n     std::partial_ordering CompareColumnValue(int column, const TReplaceKeyTemplate<T>& key, int keyColumn) const {\n         Y_DEBUG_ABORT_UNLESS(Column(column).type_id() == key.Column(keyColumn).type_id());\n         return TComparator::TypedCompare<false>(Column(column), Position, key.Column(keyColumn), key.Position);\n@@ -172,23 +170,26 @@ class TReplaceKeyTemplate {\n         }\n     }\n \n-    template<typename T = TArrayVecPtr> requires IsOwning\n+    template <typename T = TArrayVecPtr>\n+        requires IsOwning\n     std::shared_ptr<arrow::RecordBatch> RestoreBatch(const std::shared_ptr<arrow::Schema>& schema) const {\n         AFL_VERIFY(Size() && Size() == (ui32)schema->num_fields())(\"columns\", DebugString())(\"schema\", JoinSeq(\",\", schema->field_names()));\n         const auto& columns = *Columns;\n         return arrow::RecordBatch::Make(schema, columns[0]->length(), columns);\n     }\n \n-    template<typename T = TArrayVecPtr> requires IsOwning\n+    template <typename T = TArrayVecPtr>\n+        requires IsOwning\n     std::shared_ptr<arrow::RecordBatch> ToBatch(const std::shared_ptr<arrow::Schema>& schema) const {\n         auto batch = RestoreBatch(schema);\n         Y_ABORT_UNLESS(Position < (ui64)batch->num_rows());\n         return batch->Slice(Position, 1);\n     }\n \n-    template<typename T = TArrayVecPtr> requires IsOwning\n-    static TReplaceKeyTemplate<TArrayVecPtr> FromBatch(const std::shared_ptr<arrow::RecordBatch>& batch,\n-                                                       const std::shared_ptr<arrow::Schema>& key, int row) {\n+    template <typename T = TArrayVecPtr>\n+        requires IsOwning\n+    static TReplaceKeyTemplate<TArrayVecPtr> FromBatch(\n+        const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& key, int row) {\n         Y_ABORT_UNLESS(key->num_fields() <= batch->num_columns());\n \n         TArrayVec columns;\n@@ -204,7 +205,8 @@ class TReplaceKeyTemplate {\n         return TReplaceKeyTemplate<TArrayVecPtr>(std::move(columns), row);\n     }\n \n-    template<typename T = TArrayVecPtr> requires IsOwning\n+    template <typename T = TArrayVecPtr>\n+        requires IsOwning\n     static TReplaceKeyTemplate<TArrayVecPtr> FromBatch(const std::shared_ptr<arrow::RecordBatch>& batch, int row) {\n         auto columns = std::make_shared<TArrayVec>(batch->columns());\n         return TReplaceKeyTemplate<TArrayVecPtr>(columns, row);\n@@ -226,24 +228,153 @@ class TReplaceKeyTemplate {\n         return *res;\n     }\n \n+    const TArrayVecPtr& GetColumns() const {\n+        return Columns;\n+    }\n+\n private:\n     TArrayVecPtr Columns = nullptr;\n     ui64 Position = 0;\n-\n };\n \n using TReplaceKey = TReplaceKeyTemplate<std::shared_ptr<TArrayVec>>;\n \n+class TComparablePosition {\n+private:\n+    std::vector<std::shared_ptr<arrow::Array>> Arrays;\n+    std::vector<ui32> Positions;\n+\n+public:\n+    ui32 GetMonoPosition() const {\n+        std::optional<ui32> result;\n+        for (auto&& i : Positions) {\n+            if (!result) {\n+                result = i;\n+            } else {\n+                AFL_VERIFY(*result == i);\n+            }\n+        }\n+        AFL_VERIFY(result);\n+        return *result;\n+    }\n+\n+    const std::vector<std::shared_ptr<arrow::Array>>& GetArrays() const {\n+        return Arrays;\n+    }\n+\n+    TComparablePosition(const TReplaceKey& key)\n+        : Arrays(*key.GetColumns())\n+        , Positions(Arrays.size(), key.GetPosition()) {\n+    }\n+\n+    TComparablePosition(const std::shared_ptr<arrow::Table>& table, const ui32 position) {\n+        AFL_VERIFY(position < table->num_rows());\n+        for (auto&& col : table->columns()) {\n+            ui32 pos = 0;\n+            bool found = false;\n+            for (auto&& chunk : col->chunks()) {\n+                if (position < pos + chunk->length()) {\n+                    AFL_VERIFY(pos <= position);\n+                    Arrays.emplace_back(chunk);\n+                    Positions.emplace_back(position - pos);\n+                    found = true;\n+                    break;\n+                }\n+                pos += chunk->length();\n+            }\n+            AFL_VERIFY(found);\n+        }\n+    }\n+\n+    TComparablePosition(const std::vector<std::shared_ptr<arrow::ChunkedArray>>& tableColumns, const ui32 position) {\n+        for (auto&& col : tableColumns) {\n+            ui32 pos = 0;\n+            bool found = false;\n+            for (auto&& chunk : col->chunks()) {\n+                if (position < pos + chunk->length()) {\n+                    AFL_VERIFY(pos <= position);\n+                    Arrays.emplace_back(chunk);\n+                    Positions.emplace_back(position - pos);\n+                    found = true;\n+                    break;\n+                }\n+                pos += chunk->length();\n+            }\n+            AFL_VERIFY(found);\n+        }\n+    }\n+\n+    TComparablePosition(const std::shared_ptr<arrow::RecordBatch>& rb, const ui32 position) {\n+        AFL_VERIFY(position < rb->num_rows());\n+        for (auto&& col : rb->columns()) {\n+            Arrays.emplace_back(col);\n+            Positions.emplace_back(position);\n+        }\n+    }\n+\n+    TString DebugString() const {\n+        TStringBuilder sb;\n+        for (ui32 i = 0; i < Arrays.size(); ++i) {\n+            auto res = Arrays[i]->GetScalar(Positions[i]);\n+            if (!res.ok()) {\n+                sb << res.status().ToString() << \";\";\n+            } else {\n+                sb << (*res)->ToString() << \";\";\n+            }\n+        }\n+        return sb;\n+    }\n+\n+    template <bool NotNull = false>\n+    std::partial_ordering Compare(const TComparablePosition& pos) const {\n+        AFL_VERIFY(pos.Positions.size() == Positions.size());\n+        for (ui32 i = 0; i < Positions.size(); ++i) {\n+            AFL_VERIFY(Arrays[i]->type()->id() == pos.Arrays[i]->type()->id());\n+            const std::partial_ordering cmpResult =\n+                TComparator::TypedCompare<NotNull>(*Arrays[i], Positions[i], *pos.Arrays[i], pos.Positions[i]);\n+            if (cmpResult != std::partial_ordering::equivalent) {\n+                return cmpResult;\n+            }\n+        }\n+        return std::partial_ordering::equivalent;\n+    }\n+\n+    template <bool NotNull = false>\n+    std::partial_ordering ComparePartial(const TComparablePosition& pos) const {\n+        for (ui32 i = 0; i < std::min<ui32>(Positions.size(), pos.Positions.size()); ++i) {\n+            AFL_VERIFY(Arrays[i]->type()->id() == pos.Arrays[i]->type()->id());\n+            const std::partial_ordering cmpResult =\n+                TComparator::TypedCompare<NotNull>(*Arrays[i], Positions[i], *pos.Arrays[i], pos.Positions[i]);\n+            if (cmpResult != std::partial_ordering::equivalent) {\n+                return cmpResult;\n+            }\n+        }\n+        if (Positions.size() < pos.Positions.size()) {\n+            return std::partial_ordering::less;\n+        } else if (pos.Positions.size() < Positions.size()) {\n+            return std::partial_ordering::greater;\n+        }\n+        return std::partial_ordering::equivalent;\n+    }\n+\n+    bool operator==(const TComparablePosition& pos) const {\n+        return Compare(pos) == std::partial_ordering::equivalent;\n+    }\n+\n+    bool operator<(const TComparablePosition& pos) const {\n+        return Compare(pos) == std::partial_ordering::less;\n+    }\n+};\n+\n class TReplaceKeyInterval {\n private:\n     NArrow::TReplaceKey Start;\n     NArrow::TReplaceKey Finish;\n+\n public:\n     TReplaceKeyInterval(const NArrow::TReplaceKey& start, const NArrow::TReplaceKey& finish)\n         : Start(start)\n-        , Finish(finish)\n-    {\n-\n+        , Finish(finish) {\n     }\n \n     const NArrow::TReplaceKey& GetStart() const {\n@@ -264,10 +395,10 @@ using TRawReplaceKey = TReplaceKeyTemplate<const TArrayVec*>;\n class TStoreReplaceKey: public TReplaceKey {\n private:\n     using TBase = TReplaceKey;\n+\n public:\n     TStoreReplaceKey(const TReplaceKey& baseKey)\n-        : TBase(baseKey)\n-    {\n+        : TBase(baseKey) {\n         TBase::ShrinkToFit();\n     }\n };\n@@ -289,12 +420,14 @@ static bool IsSelfSorted(const std::shared_ptr<arrow::RecordBatch>& batch) {\n         TRawReplaceKey current(&columns, i);\n         if constexpr (desc) {\n             if (prev < current) {\n-                AFL_DEBUG(NKikimrServices::ARROW_HELPER)(\"event\", \"prev < current\")(\"current\", current.DebugString())(\"prev\", prev.DebugString());\n+                AFL_DEBUG(NKikimrServices::ARROW_HELPER)(\"event\", \"prev < current\")(\"current\", current.DebugString())(\n+                    \"prev\", prev.DebugString());\n                 return false;\n             }\n         } else {\n             if (current < prev) {\n-                AFL_DEBUG(NKikimrServices::ARROW_HELPER)(\"event\", \"current < prev\")(\"current\", current.DebugString())(\"prev\", prev.DebugString());\n+                AFL_DEBUG(NKikimrServices::ARROW_HELPER)(\"event\", \"current < prev\")(\"current\", current.DebugString())(\n+                    \"prev\", prev.DebugString());\n                 return false;\n             }\n         }\n@@ -308,5 +441,4 @@ static bool IsSelfSorted(const std::shared_ptr<arrow::RecordBatch>& batch) {\n     return true;\n }\n \n-}\n-\n+}   // namespace NKikimr::NArrow\ndiff --git a/ydb/library/formats/arrow/simple_arrays_cache.h b/ydb/library/formats/arrow/simple_arrays_cache.h\nindex 2d307171658f..a15c8430c87c 100644\n--- a/ydb/library/formats/arrow/simple_arrays_cache.h\n+++ b/ydb/library/formats/arrow/simple_arrays_cache.h\n@@ -1,38 +1,69 @@\n #pragma once\n #include \"size_calcer.h\"\n \n-#include <util/generic/hash.h>\n+#include <ydb/library/actors/core/log.h>\n \n #include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_base.h>\n-#include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n #include <contrib/libs/apache/arrow/cpp/src/arrow/scalar.h>\n-#include <ydb/library/actors/core/log.h>\n+#include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>\n+#include <library/cpp/cache/cache.h>\n+#include <util/generic/hash.h>\n \n namespace NKikimr::NArrow {\n \n class TThreadSimpleArraysCache {\n private:\n-    THashMap<TString, std::shared_ptr<arrow::Array>> Arrays;\n-    const ui64 MaxOneArrayMemorySize = 10 * 1024 * 1024;\n+    class TCachedArrayData {\n+    private:\n+        YDB_READONLY_DEF(std::shared_ptr<arrow::Array>, Array);\n+        YDB_READONLY(ui64, Size, 0);\n+\n+    public:\n+        TCachedArrayData() = default;\n+        TCachedArrayData(const std::shared_ptr<arrow::Array>& array)\n+            : Array(array)\n+            , Size(NArrow::GetArrayDataSize(array)) {\n+        }\n+    };\n+\n+    struct TCachedSizeProvider {\n+        size_t operator()(const TCachedArrayData& data) {\n+            return data.GetSize();\n+        }\n+    };\n+\n+    TLRUCache<TString, TCachedArrayData, TNoopDelete, TCachedSizeProvider> Arrays;\n+    static const ui64 MaxOneArrayMemorySize = 1 * 1024 * 1024;\n+    static const ui64 MaxSumMemorySize = 50 * 1024 * 1024;\n \n     template <class TInitializeActor>\n     std::shared_ptr<arrow::Array> InitializePosition(const TString& key, const ui32 recordsCountExt, const TInitializeActor actor) {\n-        const ui32 recordsCount = (recordsCountExt < 1024) ? 1024 : recordsCountExt;\n-        auto it = Arrays.find(key);\n-        if (it == Arrays.end() || it->second->length() < recordsCount) {\n-            auto arrNew = actor(recordsCount);\n-            if (NArrow::GetArrayMemorySize(arrNew->data()) < MaxOneArrayMemorySize) {\n-                if (it == Arrays.end()) {\n-                    it = Arrays.emplace(key, arrNew).first;\n+        TCachedArrayData currentValue;\n+        std::shared_ptr<arrow::Array> result;\n+        {\n+            auto it = Arrays.Find(key);\n+            if (it == Arrays.End() || it->GetArray()->length() < recordsCountExt) {\n+                result = actor(recordsCountExt);\n+                TCachedArrayData cache(result);\n+                if (cache.GetSize() < MaxOneArrayMemorySize) {\n+                    AFL_INFO(NKikimrServices::ARROW_HELPER)(\"event\", \"insert_to_cache\")(\"key\", key)(\"records\", recordsCountExt)(\n+                        \"size\", cache.GetSize());\n+                    if (it != Arrays.End()) {\n+                        Arrays.Erase(it);\n+                    }\n+                    AFL_VERIFY(Arrays.Insert(key, result));\n                 } else {\n-                    it->second = arrNew;\n+                    AFL_INFO(NKikimrServices::ARROW_HELPER)(\"event\", \"too_big_to_add\")(\"key\", key)(\"records\", recordsCountExt)(\n+                        \"size\", cache.GetSize());\n                 }\n             } else {\n-                AFL_VERIFY(recordsCountExt == recordsCount)(\"ext\", recordsCountExt)(\"count\", recordsCount);\n-                return arrNew;\n+                result = it->GetArray();\n             }\n         }\n-        return it->second->Slice(0, recordsCountExt);\n+        AFL_VERIFY(result);\n+        AFL_VERIFY(recordsCountExt <= result->length())(\"result\", result->length())(\"ext\", recordsCountExt);\n+        AFL_INFO(NKikimrServices::ARROW_HELPER)(\"event\", \"slice_from_cache\")(\"key\", key)(\"records\", recordsCountExt)(\"count\", result->length());\n+        return result->Slice(0, recordsCountExt);\n     }\n \n     std::shared_ptr<arrow::Array> GetNullImpl(const std::shared_ptr<arrow::DataType>& type, const ui32 recordsCount);\n@@ -40,6 +71,10 @@ class TThreadSimpleArraysCache {\n         const std::shared_ptr<arrow::DataType>& type, const std::shared_ptr<arrow::Scalar>& scalar, const ui32 recordsCount);\n \n public:\n+    TThreadSimpleArraysCache()\n+        : Arrays(MaxSumMemorySize) {\n+    }\n+\n     static std::shared_ptr<arrow::Array> GetNull(const std::shared_ptr<arrow::DataType>& type, const ui32 recordsCount);\n     static std::shared_ptr<arrow::Array> GetConst(\n         const std::shared_ptr<arrow::DataType>& type, const std::shared_ptr<arrow::Scalar>& scalar, const ui32 recordsCount);\ndiff --git a/ydb/library/signal_backtrace/signal_backtrace.cpp b/ydb/library/signal_backtrace/signal_backtrace.cpp\nnew file mode 100644\nindex 000000000000..1a07ddde6e7e\n--- /dev/null\n+++ b/ydb/library/signal_backtrace/signal_backtrace.cpp\n@@ -0,0 +1,234 @@\n+#include \"signal_backtrace.h\"\n+\n+#include <ydb/library/yverify_stream/yverify_stream.h>\n+\n+#include <library/cpp/dwarf_backtrace/backtrace.h>\n+#include <library/cpp/logger/log.h>\n+\n+#include <util/generic/scope.h>\n+#include <util/string/builder.h>\n+\n+#include <sys/wait.h>\n+\n+using namespace NKikimr;\n+\n+namespace {\n+\n+    using TSignalHandlerFn = std::function<void(int, siginfo_t*, void*)>;\n+\n+    void SetSignalHandler(int signal, TSignalHandlerFn&& newHandler, struct sigaction* oldAction) {\n+        static std::array<TSignalHandlerFn, NSIG> signalHandlers;\n+\n+        Y_VERIFY_S(signal > 0 && signal < NSIG, \"Unsupported signal: \" << signal);\n+        signalHandlers[signal] = std::move(newHandler);\n+\n+        struct sigaction action;\n+        memset(&action, 0, sizeof(action));\n+        action.sa_flags = SA_SIGINFO | SA_RESTART;\n+        if (signal == SIGCHLD) {\n+            action.sa_flags |= SA_NOCLDSTOP; // always receive SIGCHLD only on process termination.\n+        }\n+        action.sa_sigaction = [](int sig, siginfo_t* info, void* ucontext) {\n+            signalHandlers[sig](sig, info, ucontext);\n+        };\n+        sigaction(signal, &action, oldAction);\n+    }\n+\n+} // namespace\n+\n+class TTraceCollector::TPipeConnection {\n+public:\n+    TPipeConnection() {\n+        TPipe::Pipe(ReadPipe, WritePipe);\n+    }\n+\n+    ~TPipeConnection() {\n+        ReadPipe.Close();\n+        WritePipe.Close();\n+    }\n+\n+    size_t Write(const void* buffer, size_t size) const {\n+        return WritePipe.Write(buffer, size);\n+    }\n+\n+    size_t Read(void* buffer, size_t size) const {\n+        return ReadPipe.Read(buffer, size);\n+    }\n+\n+    void CloseRead() {\n+        ReadPipe.Close();\n+    }\n+    void CloseWrite() {\n+        WritePipe.Close();\n+    }\n+\n+private:\n+    TPipe ReadPipe;\n+    TPipe WritePipe;\n+};\n+\n+class TTraceCollector::TStackTrace {\n+public:\n+    TStackTrace() : Size(BackTrace(Backtrace.data(), Backtrace.size())) {}\n+\n+    inline const void* const* Get() const {\n+        return Backtrace.data();\n+    }\n+\n+    inline size_t GetSize() const {\n+        return Size;\n+    }\n+\n+private:\n+    static_assert(PIPE_BUF >= 512);\n+\n+    // The constant 60 is used because PIPE_BUF >= 512 and\n+    // sizeof(TStackTrace) = Backtrace.size() * 8 + 8 should be <= 512\n+    std::array<void*, 60> Backtrace;\n+    const size_t Size;\n+};\n+\n+// static\n+const THashSet<int> TTraceCollector::DEFAULT_SIGNALS = {SIGABRT, SIGBUS, SIGILL, SIGSEGV};\n+\n+TTraceCollector::TTraceCollector(const THashSet<int>& signalHandlers, IOutputStream& out)\n+    : Out(out)\n+    , HandledSignals(signalHandlers)\n+    , Connection(MakeHolder<TPipeConnection>())\n+{\n+    static_assert(sizeof(TStackTrace) <= PIPE_BUF, \"Reading and writing TStackTrace to the pipe should be atomic\");\n+\n+    CollectorPid = fork();\n+\n+    if (CollectorPid < 0) {\n+        Out << \"Failed to fork process: \" << strerror(-CollectorPid) << Endl;\n+    } else if (CollectorPid == 0) {\n+        // TODO: place to setup custom logging facility for the trace collector in the future\n+        // Trace collector process\n+        RunChildMain();\n+    } else {\n+        // Main process\n+        Connection->CloseRead();\n+        SetSignalHandlers();\n+\n+        Out << \"Trace collector pid: \" << CollectorPid << Endl;\n+    }\n+}\n+\n+TTraceCollector::~TTraceCollector() {\n+    Connection->CloseWrite();\n+    if (CollectorPid != -1) {\n+        waitpid(CollectorPid, nullptr, 0);\n+        RestoreSignalHandlers();\n+    }\n+}\n+\n+void TTraceCollector::SetSignalHandlers() {\n+    // Send the stacktrace when the handled signal is received\n+    for (const auto signal: HandledSignals) {\n+        // SIGCHLD cannot be caught because it has a special handler\n+        Y_VERIFY_S(signal != SIGCHLD, \"Trace collector doesn't support signal SIGCHLD\");\n+        Y_VERIFY_S(signal < NSIG, \"Signal number is too big\");\n+\n+        SetSignalHandler(signal, [&](int sig, siginfo_t*, void*) {\n+            // TODO: it's a dubious place for log - make sure that in case of heap corruption we don't make things worse\n+            Out << \"Received signal \" << sig << Endl;\n+\n+            static_assert(PIPE_BUF >= 512);\n+            static_assert(sizeof(TStackTrace) <= PIPE_BUF, \"Only write to pipe the chunk of size PIPE_BUF is atomic\");\n+\n+            TStackTrace stackTrace;\n+            size_t written = Connection->Write(&stackTrace, sizeof(stackTrace));\n+            Y_VERIFY_S(sizeof(stackTrace) == written, \"Write to pipe is not atomic!\");\n+\n+            waitpid(CollectorPid, nullptr, 0);\n+            CollectorPid = -1;\n+\n+            RestoreSignalHandlers();\n+            raise(sig);\n+        }, &OldActions[signal]);\n+    }\n+\n+    // Special handler to log the shutdown of the trace collector process\n+    SetSignalHandler(SIGCHLD, [&](int sig, siginfo_t* info, void* ucontext) {\n+        if (info->si_pid == CollectorPid) {\n+            switch(info->si_code) {\n+                case CLD_EXITED:\n+                    if (info->si_status == 0) {\n+                        Out << \"The trace collector has finished work normally\" << Endl;\n+                    } else {\n+                        Out << \"The trace collector has finished work with exit_code=\" << info->si_status << Endl;\n+                    }\n+                    break;\n+                case CLD_KILLED:\n+                    Out << \"The trace collector was killed by signal=\" << info->si_status << Endl;\n+                    break;\n+                case CLD_DUMPED:\n+                    Out << \"The trace collector terminated abnormally by signal=\" << info->si_status << Endl;\n+                    break;\n+                default: [[unlikely]]\n+                    Out << \"Unexpected si_code: \" << info->si_code << Endl;\n+                    ;\n+            }\n+\n+            RestoreSignalHandlers();\n+        } else {\n+            const auto& oldHandler = OldActions[sig].sa_handler;\n+            if (oldHandler == SIG_DFL || oldHandler == SIG_IGN) {\n+                // TODO: we should raise signal again in case of SIG_DFL\n+                return;\n+            } else {\n+                // Call previous signal handler\n+                OldActions[sig].sa_sigaction(sig, info, ucontext);\n+            }\n+        }\n+    },\n+    &OldActions[SIGCHLD]);\n+}\n+\n+void TTraceCollector::RestoreSignalHandlers() {\n+    for (auto sig: HandledSignals) {\n+        sigaction(sig, &OldActions[sig], nullptr);\n+    }\n+}\n+\n+void TTraceCollector::RunChildMain() {\n+    Out << \"The trace collector is running\" << Endl;\n+\n+    Connection->CloseWrite();\n+    try {\n+        TStackTrace trace;\n+        size_t read = Connection->Read(&trace, sizeof(trace));\n+\n+        if (read != 0) {\n+            Y_VERIFY_S(sizeof(TStackTrace) == read, \"Read from pipe is not atomic\");\n+            {\n+                TStringStream backtrace;\n+                backtrace << \"Backtrace:\\n\" << Symbolize(trace) << Endl;\n+                Out << backtrace.Str();\n+            }\n+        }\n+    } catch (const std::exception& error) {\n+        Y_FAIL_S(\"Error while the trace collector is running: \" << error.what());\n+    }\n+\n+    Connection->CloseRead();\n+    std::exit(0);\n+}\n+\n+TString TTraceCollector::Symbolize(const TStackTrace& stackTrace) const {\n+    TStringStream trace;\n+\n+    auto error = NDwarf::ResolveBacktrace({stackTrace.Get() + 1, stackTrace.GetSize() - 1}, [&trace](const NDwarf::TLineInfo& info) {\n+        trace << \"#\" << info.Index << \" \" << info.FunctionName << \" at \" << info.FileName << ':' << info.Line << ':' << info.Col << '\\n';\n+        return NDwarf::EResolving::Continue;\n+    });\n+\n+    if (error) {\n+        trace << \"Failed to resolve backtrace\\n\";\n+    } else {\n+        trace << '\\n';\n+    }\n+\n+    return trace.Str();\n+}\ndiff --git a/ydb/library/signal_backtrace/signal_backtrace.h b/ydb/library/signal_backtrace/signal_backtrace.h\nnew file mode 100644\nindex 000000000000..76835c8960c4\n--- /dev/null\n+++ b/ydb/library/signal_backtrace/signal_backtrace.h\n@@ -0,0 +1,38 @@\n+#pragma once\n+\n+#include <util/generic/hash_set.h>\n+#include <util/stream/buffer.h>\n+#include <util/system/pipe.h>\n+\n+#include <array>\n+\n+namespace NKikimr {\n+\n+class TTraceCollector : public TSingletonTraits<TTraceCollector> {\n+    class TPipeConnection;\n+    class TStackTrace;\n+\n+public:\n+    static const THashSet<int> DEFAULT_SIGNALS;\n+\n+    explicit TTraceCollector(const THashSet<int>& signalHandlers, IOutputStream& out = Cerr);\n+    ~TTraceCollector();\n+\n+private:\n+    // Main process routines\n+    void SetSignalHandlers();\n+    void RestoreSignalHandlers();\n+\n+    // Forked process routines\n+    void RunChildMain();\n+    TString Symbolize(const TStackTrace& stackTrace) const;\n+\n+private:\n+    IOutputStream& Out;\n+    const THashSet<int> HandledSignals;\n+    THolder<TPipeConnection> Connection;\n+    pid_t CollectorPid;\n+    std::array<struct sigaction, NSIG> OldActions;\n+};\n+\n+} // namespace NKikimr\ndiff --git a/ydb/library/signal_backtrace/ya.make b/ydb/library/signal_backtrace/ya.make\nnew file mode 100644\nindex 000000000000..9f896e039a3f\n--- /dev/null\n+++ b/ydb/library/signal_backtrace/ya.make\n@@ -0,0 +1,11 @@\n+LIBRARY()\n+\n+PEERDIR(\n+    library/cpp/dwarf_backtrace\n+)\n+\n+SRCS(\n+    signal_backtrace.cpp\n+)\n+\n+END()\ndiff --git a/ydb/core/tx/columnshard/counters/common/agent.cpp b/ydb/library/signals/agent.cpp\nsimilarity index 100%\nrename from ydb/core/tx/columnshard/counters/common/agent.cpp\nrename to ydb/library/signals/agent.cpp\ndiff --git a/ydb/core/tx/columnshard/counters/common/agent.h b/ydb/library/signals/agent.h\nsimilarity index 100%\nrename from ydb/core/tx/columnshard/counters/common/agent.h\nrename to ydb/library/signals/agent.h\ndiff --git a/ydb/core/tx/columnshard/counters/common/client.cpp b/ydb/library/signals/client.cpp\nsimilarity index 100%\nrename from ydb/core/tx/columnshard/counters/common/client.cpp\nrename to ydb/library/signals/client.cpp\ndiff --git a/ydb/core/tx/columnshard/counters/common/client.h b/ydb/library/signals/client.h\nsimilarity index 100%\nrename from ydb/core/tx/columnshard/counters/common/client.h\nrename to ydb/library/signals/client.h\ndiff --git a/ydb/core/tx/columnshard/counters/common/histogram.cpp b/ydb/library/signals/histogram.cpp\nsimilarity index 100%\nrename from ydb/core/tx/columnshard/counters/common/histogram.cpp\nrename to ydb/library/signals/histogram.cpp\ndiff --git a/ydb/core/tx/columnshard/counters/common/histogram.h b/ydb/library/signals/histogram.h\nsimilarity index 100%\nrename from ydb/core/tx/columnshard/counters/common/histogram.h\nrename to ydb/library/signals/histogram.h\ndiff --git a/ydb/core/tx/columnshard/counters/common/object_counter.cpp b/ydb/library/signals/object_counter.cpp\nsimilarity index 100%\nrename from ydb/core/tx/columnshard/counters/common/object_counter.cpp\nrename to ydb/library/signals/object_counter.cpp\ndiff --git a/ydb/core/tx/columnshard/counters/common/object_counter.h b/ydb/library/signals/object_counter.h\nsimilarity index 100%\nrename from ydb/core/tx/columnshard/counters/common/object_counter.h\nrename to ydb/library/signals/object_counter.h\ndiff --git a/ydb/core/tx/columnshard/counters/common/owner.cpp b/ydb/library/signals/owner.cpp\nsimilarity index 100%\nrename from ydb/core/tx/columnshard/counters/common/owner.cpp\nrename to ydb/library/signals/owner.cpp\ndiff --git a/ydb/core/tx/columnshard/counters/common/owner.h b/ydb/library/signals/owner.h\nsimilarity index 100%\nrename from ydb/core/tx/columnshard/counters/common/owner.h\nrename to ydb/library/signals/owner.h\ndiff --git a/ydb/core/tx/columnshard/counters/common/private.cpp b/ydb/library/signals/private.cpp\nsimilarity index 100%\nrename from ydb/core/tx/columnshard/counters/common/private.cpp\nrename to ydb/library/signals/private.cpp\ndiff --git a/ydb/core/tx/columnshard/counters/common/private.h b/ydb/library/signals/private.h\nsimilarity index 100%\nrename from ydb/core/tx/columnshard/counters/common/private.h\nrename to ydb/library/signals/private.h\ndiff --git a/ydb/core/tx/columnshard/counters/common/ya.make b/ydb/library/signals/ya.make\nsimilarity index 100%\nrename from ydb/core/tx/columnshard/counters/common/ya.make\nrename to ydb/library/signals/ya.make\ndiff --git a/ydb/library/wilson_ids/wilson.h b/ydb/library/wilson_ids/wilson.h\nindex e768c21024c7..27c22d11053e 100644\n--- a/ydb/library/wilson_ids/wilson.h\n+++ b/ydb/library/wilson_ids/wilson.h\n@@ -82,14 +82,11 @@ namespace NKikimr {\n                 LookupActor = TComponentTracingLevels::TQueryProcessor::Basic,\n                     LookupActorShardsResolve = TComponentTracingLevels::TQueryProcessor::Detailed,\n \n-                TableWriteActor = TComponentTracingLevels::TQueryProcessor::Basic,\n-                    TableWriteActorTableNavigate = TComponentTracingLevels::TQueryProcessor::Detailed,\n-\n-                DirectWriteActor = TComponentTracingLevels::TQueryProcessor::Basic,\n                 ForwardWriteActor = TComponentTracingLevels::TQueryProcessor::Basic,\n-\n+                DirectWriteActor = TComponentTracingLevels::TQueryProcessor::Basic,\n                 BufferWriteActor = TComponentTracingLevels::TQueryProcessor::Basic,\n-                    BufferWriteActorState = TComponentTracingLevels::TQueryProcessor::Basic,\n+                    BufferWriteActorState = TComponentTracingLevels::TQueryProcessor::Detailed,\n+                    TableWriteActor = TComponentTracingLevels::TQueryProcessor::Detailed,\n \n             BulkUpsertActor = TComponentTracingLevels::TQueryProcessor::TopLevel,\n         };\ndiff --git a/ydb/library/ya.make b/ydb/library/ya.make\nindex 20e9b7445853..21f5dcc51358 100644\n--- a/ydb/library/ya.make\n+++ b/ydb/library/ya.make\n@@ -28,6 +28,8 @@ RECURSE(\n     query_actor\n     schlab\n     security\n+    signal_backtrace\n+    signals\n     table_creator\n     testlib\n     time_series_vec\ndiff --git a/ydb/library/yql/dq/actors/compute/dq_compute_actor_impl.h b/ydb/library/yql/dq/actors/compute/dq_compute_actor_impl.h\nindex 28e44c1e983a..db0b3bf61784 100644\n--- a/ydb/library/yql/dq/actors/compute/dq_compute_actor_impl.h\n+++ b/ydb/library/yql/dq/actors/compute/dq_compute_actor_impl.h\n@@ -653,8 +653,11 @@ class TDqComputeActorBase : public NActors::TActorBootstrapped<TDerived>\n         Terminate(State == NDqProto::COMPUTE_STATE_FINISHED, NDqProto::EComputeState_Name(State));\n     }\n \n-    void InternalError(TIssuesIds::EIssueCode issueCode, const TString& message) {\n-        InternalError(NYql::NDqProto::StatusIds::PRECONDITION_FAILED, issueCode, message);\n+    void ErrorFromIssue(TIssuesIds::EIssueCode issueCode, const TString& message) {\n+        TIssue issue(message);\n+        SetIssueCode(issueCode, issue);\n+        const auto statusCode = GetDqStatus(issue).GetOrElse(NYql::NDqProto::StatusIds::PRECONDITION_FAILED);\n+        InternalError(statusCode, std::move(issue));\n     }\n \n     void InternalError(NYql::NDqProto::StatusIds::StatusCode statusCode, TIssuesIds::EIssueCode issueCode, const TString& message) {\ndiff --git a/ydb/library/yql/dq/actors/dq.cpp b/ydb/library/yql/dq/actors/dq.cpp\nindex 793d1f0c7f90..b7bdff74db0d 100644\n--- a/ydb/library/yql/dq/actors/dq.cpp\n+++ b/ydb/library/yql/dq/actors/dq.cpp\n@@ -1,5 +1,7 @@\n #include \"dq.h\"\n \n+#include <yql/essentials/core/issue/yql_issue.h>\n+\n namespace NYql::NDq {\n \n Ydb::StatusIds::StatusCode DqStatusToYdbStatus(NYql::NDqProto::StatusIds::StatusCode statusCode) {\n@@ -16,6 +18,8 @@ Ydb::StatusIds::StatusCode DqStatusToYdbStatus(NYql::NDqProto::StatusIds::Status\n         return Ydb::StatusIds::ABORTED;\n     case NYql::NDqProto::StatusIds::UNAVAILABLE:\n         return Ydb::StatusIds::UNAVAILABLE;\n+    case NYql::NDqProto::StatusIds::UNDETERMINED:\n+        return Ydb::StatusIds::UNDETERMINED;\n     case NYql::NDqProto::StatusIds::BAD_REQUEST:\n         return Ydb::StatusIds::BAD_REQUEST;\n     case NYql::NDqProto::StatusIds::PRECONDITION_FAILED:\n@@ -58,6 +62,8 @@ NYql::NDqProto::StatusIds::StatusCode YdbStatusToDqStatus(Ydb::StatusIds::Status\n         return NYql::NDqProto::StatusIds::ABORTED;\n     case Ydb::StatusIds::UNAVAILABLE:\n         return NYql::NDqProto::StatusIds::UNAVAILABLE;\n+    case Ydb::StatusIds::UNDETERMINED:\n+        return NYql::NDqProto::StatusIds::UNDETERMINED;\n     case Ydb::StatusIds::OVERLOADED:\n         return NYql::NDqProto::StatusIds::OVERLOADED;\n     case Ydb::StatusIds::TIMEOUT:\n@@ -80,4 +86,58 @@ NYql::NDqProto::StatusIds::StatusCode YdbStatusToDqStatus(Ydb::StatusIds::Status\n     }\n }\n \n+TMaybe<NYql::NDqProto::StatusIds::StatusCode> GetDqStatus(const TIssue& issue) {\n+    if (issue.GetSeverity() == TSeverityIds::S_FATAL) {\n+        return NYql::NDqProto::StatusIds::INTERNAL_ERROR;\n+    }\n+\n+    switch (issue.GetCode()) {\n+        case NYql::TIssuesIds::KIKIMR_LOCKS_INVALIDATED:\n+        case NYql::TIssuesIds::KIKIMR_LOCKS_ACQUIRE_FAILURE:\n+        case NYql::TIssuesIds::KIKIMR_OPERATION_ABORTED:\n+        case NYql::TIssuesIds::KIKIMR_SCHEME_MISMATCH:\n+            return NYql::NDqProto::StatusIds::ABORTED;\n+\n+        case NYql::TIssuesIds::KIKIMR_SCHEME_ERROR:\n+            return NYql::NDqProto::StatusIds::SCHEME_ERROR;\n+\n+        case NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE:\n+            return NYql::NDqProto::StatusIds::UNAVAILABLE;\n+\n+        case NYql::TIssuesIds::KIKIMR_OVERLOADED:\n+        case NYql::TIssuesIds::KIKIMR_MULTIPLE_SCHEME_MODIFICATIONS:\n+            return NYql::NDqProto::StatusIds::OVERLOADED;\n+\n+        case NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION:\n+        case NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED:\n+            return NYql::NDqProto::StatusIds::PRECONDITION_FAILED;\n+\n+        case NYql::TIssuesIds::KIKIMR_BAD_REQUEST:\n+        case NYql::TIssuesIds::KIKIMR_BAD_COLUMN_TYPE:\n+        case NYql::TIssuesIds::KIKIMR_NO_COLUMN_DEFAULT_VALUE:\n+            return NYql::NDqProto::StatusIds::BAD_REQUEST;\n+\n+        case NYql::TIssuesIds::KIKIMR_ACCESS_DENIED:\n+            return NYql::NDqProto::StatusIds::UNAUTHORIZED;\n+\n+        case NYql::TIssuesIds::KIKIMR_TIMEOUT:\n+            return NYql::NDqProto::StatusIds::TIMEOUT;\n+\n+        case NYql::TIssuesIds::KIKIMR_OPERATION_CANCELLED:\n+            return NYql::NDqProto::StatusIds::CANCELLED;\n+\n+        case NYql::TIssuesIds::KIKIMR_RESULT_UNAVAILABLE:\n+        case NYql::TIssuesIds::KIKIMR_OPERATION_STATE_UNKNOWN:\n+            return NYql::NDqProto::StatusIds::UNDETERMINED;\n+\n+        case NYql::TIssuesIds::KIKIMR_UNSUPPORTED:\n+            return NYql::NDqProto::StatusIds::UNSUPPORTED;\n+\n+        default:\n+            break;\n+    }\n+\n+    return Nothing();\n+}\n+\n } // namespace NYql::NDq\ndiff --git a/ydb/library/yql/dq/actors/dq.h b/ydb/library/yql/dq/actors/dq.h\nindex 09e44c2fb2b0..f7dbce057c20 100644\n--- a/ydb/library/yql/dq/actors/dq.h\n+++ b/ydb/library/yql/dq/actors/dq.h\n@@ -18,6 +18,7 @@ enum class EStatusCompatibilityLevel {\n \n Ydb::StatusIds::StatusCode DqStatusToYdbStatus(NYql::NDqProto::StatusIds::StatusCode statusCode);\n NYql::NDqProto::StatusIds::StatusCode YdbStatusToDqStatus(Ydb::StatusIds::StatusCode statusCode, EStatusCompatibilityLevel compatibility = EStatusCompatibilityLevel::Basic);\n+TMaybe<NYql::NDqProto::StatusIds::StatusCode> GetDqStatus(const TIssue& issue);\n \n struct TEvDq {\n \ndiff --git a/ydb/library/yql/dq/runtime/dq_tasks_runner.cpp b/ydb/library/yql/dq/runtime/dq_tasks_runner.cpp\nindex ef941b5741ca..e21821436e2e 100644\n--- a/ydb/library/yql/dq/runtime/dq_tasks_runner.cpp\n+++ b/ydb/library/yql/dq/runtime/dq_tasks_runner.cpp\n@@ -594,18 +594,22 @@ class TDqTaskRunner : public IDqTaskRunner {\n                 }\n             }\n \n-            auto entryNode = AllocatedHolder->ProgramParsed.CompGraph->GetEntryPoint(i, true);\n-            if (transform) {\n-                transform->TransformInput = DqBuildInputValue(inputDesc, transform->TransformInputType, std::move(inputs), holderFactory, {}, Stats->StartTs, InputConsumed, PgBuilder_.get());\n-                inputs.clear();\n-                inputs.emplace_back(transform->TransformOutput);\n-                entryNode->SetValue(AllocatedHolder->ProgramParsed.CompGraph->GetContext(),\n-                    CreateInputUnionValue(transform->TransformOutput->GetInputType(), std::move(inputs), holderFactory,\n-                        {inputStats, transform->TransformOutputType}, Stats->StartTs, InputConsumed));\n+            auto entryNode = AllocatedHolder->ProgramParsed.CompGraph->GetEntryPoint(i, false);\n+            if (entryNode) {\n+                if (transform) {\n+                    transform->TransformInput = DqBuildInputValue(inputDesc, transform->TransformInputType, std::move(inputs), holderFactory, {}, Stats->StartTs, InputConsumed, PgBuilder_.get());\n+                    inputs.clear();\n+                    inputs.emplace_back(transform->TransformOutput);\n+                    entryNode->SetValue(AllocatedHolder->ProgramParsed.CompGraph->GetContext(),\n+                        CreateInputUnionValue(transform->TransformOutput->GetInputType(), std::move(inputs), holderFactory,\n+                            {inputStats, transform->TransformOutputType}, Stats->StartTs, InputConsumed));\n+                } else {\n+                    entryNode->SetValue(AllocatedHolder->ProgramParsed.CompGraph->GetContext(),\n+                        DqBuildInputValue(inputDesc, entry->InputItemTypes[i], std::move(inputs), holderFactory,\n+                            {inputStats, entry->InputItemTypes[i]}, Stats->StartTs, InputConsumed, PgBuilder_.get()));\n+                }\n             } else {\n-                entryNode->SetValue(AllocatedHolder->ProgramParsed.CompGraph->GetContext(),\n-                    DqBuildInputValue(inputDesc, entry->InputItemTypes[i], std::move(inputs), holderFactory,\n-                        {inputStats, entry->InputItemTypes[i]}, Stats->StartTs, InputConsumed, PgBuilder_.get()));\n+                // In some cases we don't need input. For example, for joining EmptyIterator with table.\n             }\n         }\n \ndiff --git a/ydb/services/persqueue_v1/ut/topic_service_ut.cpp b/ydb/services/persqueue_v1/ut/topic_service_ut.cpp\nindex 4df8f2fc7556..8409f81fc184 100644\n--- a/ydb/services/persqueue_v1/ut/topic_service_ut.cpp\n+++ b/ydb/services/persqueue_v1/ut/topic_service_ut.cpp\n@@ -412,7 +412,11 @@ Y_UNIT_TEST_F(MultiplePartitionsAndNoGapsInTheOffsets, TUpdateOffsetsInTransacti\n     auto result = tx->Commit().ExtractValueSync();\n     Cerr << \">>> CommitTx >>>\" << Endl;\n     UNIT_ASSERT_EQUAL(result.IsTransportError(), false);\n-    UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::ABORTED);\n+    if (server->ServerSettings.AppConfig->GetTableServiceConfig().GetEnableOltpSink()) {\n+        UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::BAD_REQUEST);\n+    } else {\n+        UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::ABORTED);\n+    }\n }\n \n }\ndiff --git a/ydb/services/ydb/backup_ut/ydb_backup_ut.cpp b/ydb/services/ydb/backup_ut/ydb_backup_ut.cpp\nindex d35f6f8f9680..5e9774c5dee5 100644\n--- a/ydb/services/ydb/backup_ut/ydb_backup_ut.cpp\n+++ b/ydb/services/ydb/backup_ut/ydb_backup_ut.cpp\n@@ -235,7 +235,7 @@ auto CreateMinPartitionsChecker(ui32 expectedMinPartitions, const TString& debug\n     };\n }\n \n-auto CreateHasIndexChecker(const TString& indexName, EIndexType indexType) {\n+auto CreateHasIndexChecker(const TString& indexName, EIndexType indexType, bool prefix) {\n     return [=](const TTableDescription& tableDescription) {\n         for (const auto& indexDesc : tableDescription.GetIndexDescriptions()) {\n             if (indexDesc.GetIndexName() != indexName) {\n@@ -244,13 +244,16 @@ auto CreateHasIndexChecker(const TString& indexName, EIndexType indexType) {\n             if (indexDesc.GetIndexType() != indexType) {\n                 continue;\n             }\n-            if (indexDesc.GetIndexColumns().size() != 1) {\n+            if (indexDesc.GetIndexColumns().size() != (prefix ? 2 : 1)) {\n                 continue;\n             }\n             if (indexDesc.GetDataColumns().size() != 0) {\n                 continue;\n             }\n-            if (indexDesc.GetIndexColumns()[0] != \"Value\") {\n+            if (prefix && indexDesc.GetIndexColumns().front() != \"Group\") {\n+                continue;\n+            }\n+            if (indexDesc.GetIndexColumns().back() != \"Value\") {\n                 continue;\n             }\n             if (indexType != NYdb::NTable::EIndexType::GlobalVectorKMeansTree) {\n@@ -587,23 +590,37 @@ NYdb::NTable::EIndexType ConvertIndexTypeToAPI(NKikimrSchemeOp::EIndexType index\n }\n \n void TestRestoreTableWithIndex(\n-    const char* table, const char* index, NKikimrSchemeOp::EIndexType indexType, TSession& session,\n+    const char* table, const char* index, NKikimrSchemeOp::EIndexType indexType, bool prefix, TSession& session,\n     TBackupFunction&& backup, TRestoreFunction&& restore\n ) {\n     TString query;\n     if (indexType == NKikimrSchemeOp::EIndexTypeGlobalVectorKmeansTree) {\n-        query = Sprintf(R\"(CREATE TABLE `%s` (\n-            Key Uint32,\n-            Value String,\n-            PRIMARY KEY (Key),\n-            INDEX %s GLOBAL USING vector_kmeans_tree\n-                ON (Value)\n-                WITH (similarity=inner_product, vector_type=float, vector_dimension=768, levels=2, clusters=80)\n-        );)\", table, index);\n+        if (prefix) {\n+            query = Sprintf(R\"(CREATE TABLE `%s` (\n+                Key Uint32,\n+                Group Uint32,\n+                Value String,\n+                PRIMARY KEY (Key),\n+                INDEX %s GLOBAL USING vector_kmeans_tree\n+                    ON (Group, Value)\n+                    WITH (similarity=inner_product, vector_type=float, vector_dimension=768, levels=2, clusters=80)\n+            );)\", table, index);\n+        } else {\n+            query = Sprintf(R\"(CREATE TABLE `%s` (\n+                Key Uint32,\n+                Group Uint32,\n+                Value String,\n+                PRIMARY KEY (Key),\n+                INDEX %s GLOBAL USING vector_kmeans_tree\n+                    ON (Value)\n+                    WITH (similarity=inner_product, vector_type=float, vector_dimension=768, levels=2, clusters=80)\n+            );)\", table, index);\n+        }\n     } else {\n         query = Sprintf(R\"(\n             CREATE TABLE `%s` (\n                 Key Uint32,\n+                Group Uint32,\n                 Value Uint32,\n                 PRIMARY KEY (Key),\n                 INDEX %s %s ON (Value)\n@@ -622,7 +639,7 @@ void TestRestoreTableWithIndex(\n \n     restore();\n \n-    CheckTableDescription(session, table, CreateHasIndexChecker(index, ConvertIndexTypeToAPI(indexType)));\n+    CheckTableDescription(session, table, CreateHasIndexChecker(index, ConvertIndexTypeToAPI(indexType), prefix));\n }\n \n void TestRestoreDirectory(const char* directory, TSchemeClient& client, TBackupFunction&& backup, TRestoreFunction&& restore) {\n@@ -1487,7 +1504,7 @@ Y_UNIT_TEST_SUITE(BackupRestore) {\n         );\n     }\n \n-    void TestTableWithIndexBackupRestore(NKikimrSchemeOp::EIndexType indexType = NKikimrSchemeOp::EIndexTypeGlobal) {\n+    void TestTableWithIndexBackupRestore(NKikimrSchemeOp::EIndexType indexType = NKikimrSchemeOp::EIndexTypeGlobal, bool prefix = false) {\n         NKikimrConfig::TAppConfig appConfig;\n         appConfig.MutableFeatureFlags()->SetEnableVectorIndex(true);\n         TKikimrWithGrpcAndRootSchema server{std::move(appConfig)};\n@@ -1504,6 +1521,7 @@ Y_UNIT_TEST_SUITE(BackupRestore) {\n             table,\n             index,\n             indexType,\n+            prefix,\n             session,\n             CreateBackupLambda(driver, pathToBackup),\n             CreateRestoreLambda(driver, pathToBackup)\n@@ -1830,6 +1848,10 @@ Y_UNIT_TEST_SUITE(BackupRestore) {\n                 UNIT_FAIL(\"Client backup/restore were not implemented for this index type\");\n         }\n     }\n+\n+    Y_UNIT_TEST(PrefixedVectorIndex) {\n+        TestTableWithIndexBackupRestore(NKikimrSchemeOp::EIndexTypeGlobalVectorKmeansTree, true);\n+    }\n }\n \n Y_UNIT_TEST_SUITE(BackupRestoreS3) {\n@@ -2217,7 +2239,7 @@ Y_UNIT_TEST_SUITE(BackupRestoreS3) {\n         );\n     }\n \n-    void TestTableWithIndexBackupRestore(NKikimrSchemeOp::EIndexType indexType = NKikimrSchemeOp::EIndexTypeGlobal) {\n+    void TestTableWithIndexBackupRestore(NKikimrSchemeOp::EIndexType indexType = NKikimrSchemeOp::EIndexTypeGlobal, bool prefix = false) {\n         TS3TestEnv testEnv;\n         constexpr const char* table = \"/Root/table\";\n         constexpr const char* index = \"value_idx\";\n@@ -2226,6 +2248,7 @@ Y_UNIT_TEST_SUITE(BackupRestoreS3) {\n             table,\n             index,\n             indexType,\n+            prefix,\n             testEnv.GetTableSession(),\n             CreateBackupLambda(testEnv.GetDriver(), testEnv.GetS3Port()),\n             CreateRestoreLambda(testEnv.GetDriver(), testEnv.GetS3Port(), { \"table\" })\n@@ -2345,4 +2368,8 @@ Y_UNIT_TEST_SUITE(BackupRestoreS3) {\n                 UNIT_FAIL(\"S3 backup/restore were not implemented for this index type\");\n         }\n     }\n+\n+    Y_UNIT_TEST(PrefixedVectorIndex) {\n+        TestTableWithIndexBackupRestore(NKikimrSchemeOp::EIndexTypeGlobalVectorKmeansTree, true);\n+    }\n }\ndiff --git a/ydb/services/ydb/ydb_common_ut.h b/ydb/services/ydb/ydb_common_ut.h\nindex 5a0083485514..aad0d679a1fa 100644\n--- a/ydb/services/ydb/ydb_common_ut.h\n+++ b/ydb/services/ydb/ydb_common_ut.h\n@@ -139,10 +139,12 @@ class TBasicKikimrWithGrpcAndRootSchema {\n \n         //Server_->GetRuntime()->SetLogPriority(NKikimrServices::TX_PROXY_SCHEME_CACHE, NActors::NLog::PRI_DEBUG);\n         //Server_->GetRuntime()->SetLogPriority(NKikimrServices::SCHEME_BOARD_REPLICA, NActors::NLog::PRI_DEBUG);\n-        Server_->GetRuntime()->SetLogPriority(NKikimrServices::FLAT_TX_SCHEMESHARD, NActors::NLog::PRI_INFO);\n+        //Server_->GetRuntime()->SetLogPriority(NKikimrServices::FLAT_TX_SCHEMESHARD, NActors::NLog::PRI_INFO);\n         //Server_->GetRuntime()->SetLogPriority(NKikimrServices::TX_PROXY, NActors::NLog::PRI_DEBUG);\n         //Server_->GetRuntime()->SetLogPriority(NKikimrServices::TX_OLAPSHARD, NActors::NLog::PRI_DEBUG);\n         //Server_->GetRuntime()->SetLogPriority(NKikimrServices::TX_COLUMNSHARD, NActors::NLog::PRI_DEBUG);\n+        //Server_->GetRuntime()->SetLogPriority(NKikimrServices::KQP_SESSION, NActors::NLog::PRI_DEBUG);\n+        //Server_->GetRuntime()->SetLogPriority(NKikimrServices::KQP_EXECUTER, NActors::NLog::PRI_DEBUG);\n         if (enableYq) {\n             Server_->GetRuntime()->SetLogPriority(NKikimrServices::YQL_PROXY, NActors::NLog::PRI_DEBUG);\n             Server_->GetRuntime()->SetLogPriority(NKikimrServices::KQP_COMPUTE, NActors::NLog::PRI_DEBUG);\ndiff --git a/ydb/services/ydb/ydb_table_ut.cpp b/ydb/services/ydb/ydb_table_ut.cpp\nindex 68e90446d36e..f5bbaeb1712f 100644\n--- a/ydb/services/ydb/ydb_table_ut.cpp\n+++ b/ydb/services/ydb/ydb_table_ut.cpp\n@@ -2841,168 +2841,181 @@ R\"___(<main>: Error: Transaction not found: , code: 2015\n \n \n     Y_UNIT_TEST(QueryStats) {\n-        TKikimrWithGrpcAndRootSchema server;\n+        for (bool useSink : {false, true}) {\n+            NKikimrConfig::TAppConfig appConfig;\n+            appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);\n+            TKikimrWithGrpcAndRootSchema server(appConfig);\n \n-        NYdb::TDriver driver(TDriverConfig().SetEndpoint(TStringBuilder() << \"localhost:\" << server.GetPort()));\n-        NYdb::NTable::TTableClient client(driver);\n+            NYdb::TDriver driver(TDriverConfig().SetEndpoint(TStringBuilder() << \"localhost:\" << server.GetPort()));\n+            NYdb::NTable::TTableClient client(driver);\n \n-        auto sessionResult = client.CreateSession().ExtractValueSync();\n-        UNIT_ASSERT_VALUES_EQUAL(sessionResult.GetStatus(), EStatus::SUCCESS);\n-        auto session = sessionResult.GetSession();\n+            auto sessionResult = client.CreateSession().ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL(sessionResult.GetStatus(), EStatus::SUCCESS);\n+            auto session = sessionResult.GetSession();\n \n-        const ui32 SHARD_COUNT = 4;\n+            const ui32 SHARD_COUNT = 4;\n \n-        {\n-            auto tableBuilder = client.GetTableBuilder();\n-            tableBuilder\n-                .AddNullableColumn(\"Key\", EPrimitiveType::Uint32)\n-                .AddNullableColumn(\"Value\", EPrimitiveType::Utf8);\n-            tableBuilder.SetPrimaryKeyColumn(\"Key\");\n+            {\n+                auto tableBuilder = client.GetTableBuilder();\n+                tableBuilder\n+                    .AddNullableColumn(\"Key\", EPrimitiveType::Uint32)\n+                    .AddNullableColumn(\"Value\", EPrimitiveType::Utf8);\n+                tableBuilder.SetPrimaryKeyColumn(\"Key\");\n \n-            auto tableSettings = NYdb::NTable::TCreateTableSettings().PartitioningPolicy(\n-                NYdb::NTable::TPartitioningPolicy().UniformPartitions(SHARD_COUNT));\n+                auto tableSettings = NYdb::NTable::TCreateTableSettings().PartitioningPolicy(\n+                    NYdb::NTable::TPartitioningPolicy().UniformPartitions(SHARD_COUNT));\n \n-            auto result = session.CreateTable(\"/Root/Foo\", tableBuilder.Build(), tableSettings).ExtractValueSync();\n-            UNIT_ASSERT_EQUAL(result.IsTransportError(), false);\n-            UNIT_ASSERT_EQUAL(result.GetStatus(), EStatus::SUCCESS);\n-        }\n-\n-        for (bool returnStats : {false, true}) {\n-            NYdb::NTable::TExecDataQuerySettings execSettings;\n-            if (returnStats) {\n-                execSettings.CollectQueryStats(ECollectQueryStatsMode::Profile);\n+                auto result = session.CreateTable(\"/Root/Foo\", tableBuilder.Build(), tableSettings).ExtractValueSync();\n+                UNIT_ASSERT_EQUAL(result.IsTransportError(), false);\n+                UNIT_ASSERT_EQUAL(result.GetStatus(), EStatus::SUCCESS);\n             }\n-            {\n-                auto query = \"UPSERT INTO `/Root/Foo` (Key, Value) VALUES (0, 'aa');\";\n-                auto result = session.ExecuteDataQuery(\n-                            query,\n-                            TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();\n \n-                if (!returnStats) {\n-                    UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);\n-                } else {\n-                    // Cerr << \"\\nQUERY: \" << query << \"\\nSTATS:\\n\" << result.GetStats()->ToString() << Endl;\n-                    auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n-                    if (stats.query_phases().size() == 1) {\n-                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n-                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/Foo\");\n-                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 1);\n-                        UNIT_ASSERT(stats.query_phases(0).table_access(0).updates().bytes() > 1);\n-                        UNIT_ASSERT(stats.query_phases(0).cpu_time_us() > 0);\n-                        UNIT_ASSERT(stats.total_duration_us() > 0);\n+            for (bool returnStats : {false, true}) {\n+                NYdb::NTable::TExecDataQuerySettings execSettings;\n+                if (returnStats) {\n+                    execSettings.CollectQueryStats(ECollectQueryStatsMode::Profile);\n+                }\n+                {\n+                    auto query = \"UPSERT INTO `/Root/Foo` (Key, Value) VALUES (0, 'aa');\";\n+                    auto result = session.ExecuteDataQuery(\n+                                query,\n+                                TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();\n+\n+                    if (!returnStats) {\n+                        UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);\n                     } else {\n-                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n-                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n-                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/Foo\");\n-                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);\n-                        UNIT_ASSERT(stats.query_phases(1).table_access(0).updates().bytes() > 1);\n-                        UNIT_ASSERT(stats.query_phases(1).cpu_time_us() > 0);\n-                        UNIT_ASSERT(stats.total_duration_us() > 0);\n+                        // Cerr << \"\\nQUERY: \" << query << \"\\nSTATS:\\n\" << result.GetStats()->ToString() << Endl;\n+                        auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n+                        if (stats.query_phases().size() == 1) {\n+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/Foo\");\n+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 1);\n+                            UNIT_ASSERT(stats.query_phases(0).table_access(0).updates().bytes() > 1);\n+                            UNIT_ASSERT(stats.query_phases(0).cpu_time_us() > 0);\n+                            UNIT_ASSERT(stats.total_duration_us() > 0);\n+                        } else {\n+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/Foo\");\n+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);\n+                            UNIT_ASSERT(stats.query_phases(1).table_access(0).updates().bytes() > 1);\n+                            UNIT_ASSERT(stats.query_phases(1).cpu_time_us() > 0);\n+                            UNIT_ASSERT(stats.total_duration_us() > 0);\n+                        }\n                     }\n                 }\n-            }\n \n-            {\n-                auto query = \"UPSERT INTO `/Root/Foo` (Key, Value) VALUES (1, Utf8('bb')), (0xffffffff, Utf8('cc'));\";\n-                auto result = session.ExecuteDataQuery(\n-                            query,\n-                            TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();\n+                {\n+                    auto query = \"UPSERT INTO `/Root/Foo` (Key, Value) VALUES (1, Utf8('bb')), (0xffffffff, Utf8('cc'));\";\n+                    auto result = session.ExecuteDataQuery(\n+                                query,\n+                                TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();\n \n-                if (!returnStats) {\n-                    UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);\n-                } else {\n-                    // Cerr << \"\\nQUERY: \" << query << \"\\nSTATS:\\n\" << result.GetStats()->ToString() << Endl;\n-                    auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);\n-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);\n-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), \"/Root/Foo\");\n-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 2);\n-                    UNIT_ASSERT(stats.query_phases(1).table_access(0).updates().bytes() > 1);\n-                    UNIT_ASSERT(stats.query_phases(1).cpu_time_us() > 0);\n-                    UNIT_ASSERT(stats.total_duration_us() > 0);\n+                    if (!returnStats) {\n+                        UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);\n+                    } else {\n+                        // Cerr << \"\\nQUERY: \" << query << \"\\nSTATS:\\n\" << result.GetStats()->ToString() << Endl;\n+                        auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), useSink ? 1 : 2);\n+                        const auto idx = stats.query_phases().size() - 1;\n+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access().size(), 1);\n+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).name(), \"/Root/Foo\");\n+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).updates().rows(), 2);\n+                        UNIT_ASSERT(stats.query_phases(idx).table_access(0).updates().bytes() > 1);\n+                        UNIT_ASSERT(stats.query_phases(idx).cpu_time_us() > 0);\n+                        UNIT_ASSERT(stats.total_duration_us() > 0);\n+                    }\n                 }\n-            }\n \n-            {\n-                auto query = \"SELECT * FROM `/Root/Foo`;\";\n-                auto result = session.ExecuteDataQuery(\n-                            query,\n-                            TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();\n+                {\n+                    auto query = \"SELECT * FROM `/Root/Foo`;\";\n+                    auto result = session.ExecuteDataQuery(\n+                                query,\n+                                TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();\n \n-                if (!returnStats) {\n-                    UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);\n-                } else {\n-                    // Cerr << \"\\nQUERY: \" << query << \"\\nSTATS:\\n\" << result.GetStats()->ToString() << Endl;\n-                    auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);\n-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/Foo\");\n-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 3);\n-                    UNIT_ASSERT(stats.query_phases(0).table_access(0).reads().bytes() > 3);\n-                    UNIT_ASSERT(stats.query_phases(0).cpu_time_us() > 0);\n-                    UNIT_ASSERT(stats.total_duration_us() > 0);\n+                    if (!returnStats) {\n+                        UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);\n+                    } else {\n+                        // Cerr << \"\\nQUERY: \" << query << \"\\nSTATS:\\n\" << result.GetStats()->ToString() << Endl;\n+                        auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);\n+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/Foo\");\n+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 3);\n+                        UNIT_ASSERT(stats.query_phases(0).table_access(0).reads().bytes() > 3);\n+                        UNIT_ASSERT(stats.query_phases(0).cpu_time_us() > 0);\n+                        UNIT_ASSERT(stats.total_duration_us() > 0);\n+                    }\n                 }\n-            }\n \n-            {\n-                auto query = \"SELECT * FROM `/Root/Foo` WHERE Key == 1;\";\n-                auto result = session.ExecuteDataQuery(\n-                            query,\n-                            TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();\n+                {\n+                    auto query = \"SELECT * FROM `/Root/Foo` WHERE Key == 1;\";\n+                    auto result = session.ExecuteDataQuery(\n+                                query,\n+                                TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();\n \n-                if (!returnStats) {\n-                    UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);\n-                } else {\n-                    // Cerr << \"\\nQUERY: \" << query << \"\\nSTATS:\\n\" << result.GetStats()->ToString() << Endl;\n-                    auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);\n-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/Foo\");\n-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 1);\n-                    UNIT_ASSERT(stats.query_phases(0).table_access(0).reads().bytes() > 1);\n-                    UNIT_ASSERT(stats.query_phases(0).cpu_time_us() > 0);\n-                    UNIT_ASSERT(stats.total_duration_us() > 0);\n+                    if (!returnStats) {\n+                        UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);\n+                    } else {\n+                        // Cerr << \"\\nQUERY: \" << query << \"\\nSTATS:\\n\" << result.GetStats()->ToString() << Endl;\n+                        auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);\n+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);\n+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), \"/Root/Foo\");\n+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 1);\n+                        UNIT_ASSERT(stats.query_phases(0).table_access(0).reads().bytes() > 1);\n+                        UNIT_ASSERT(stats.query_phases(0).cpu_time_us() > 0);\n+                        UNIT_ASSERT(stats.total_duration_us() > 0);\n+                    }\n                 }\n-            }\n \n-            {\n-                auto query = \"DELETE FROM `/Root/Foo` WHERE Key > 0;\";\n-                auto result = session.ExecuteDataQuery(\n-                            query,\n-                            TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();\n-\n-                if (!returnStats) {\n-                    UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);\n-                } else {\n-                    // Cerr << \"\\nQUERY: \" << query << \"\\nSTATS:\\n\" << result.GetStats()->ToString() << Endl;\n-                    auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n+                {\n+                    auto query = \"DELETE FROM `/Root/Foo` WHERE Key > 0;\";\n+                    auto result = session.ExecuteDataQuery(\n+                                query,\n+                                TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();\n \n-                    int idx = 0;\n-                    if (stats.query_phases().size() == 2) {\n-                        idx = 0;\n+                    if (!returnStats) {\n+                        UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);\n                     } else {\n-                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 3);\n-                        UNIT_ASSERT(stats.query_phases(0).table_access().empty());\n-                        idx = 1;\n+                        // Cerr << \"\\nQUERY: \" << query << \"\\nSTATS:\\n\" << result.GetStats()->ToString() << Endl;\n+                        auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());\n+\n+                        int idx = 0;\n+                        if (useSink) {\n+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);\n+                            idx = 0;\n+                        } else if (stats.query_phases().size() == 2) {\n+                            idx = 0;\n+                        } else {\n+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 3);\n+                            UNIT_ASSERT(stats.query_phases(0).table_access().empty());\n+                            idx = 1;\n+                        }\n+\n+                        // 1st phase: find matching rows\n+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access().size(), 1);\n+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).name(), \"/Root/Foo\");\n+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).reads().rows(), 2);\n+                        if (useSink) {\n+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).deletes().rows(), 2);\n+                        }\n+                        UNIT_ASSERT(stats.query_phases(idx).cpu_time_us() > 0);\n+                        // 2nd phase: delete found rows\n+                        if (!useSink) {\n+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx + 1).table_access().size(), 1);\n+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx + 1).table_access(0).name(), \"/Root/Foo\");\n+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx + 1).table_access(0).deletes().rows(), 2);\n+                            UNIT_ASSERT(stats.query_phases(idx + 1).cpu_time_us() > 0);\n+                        }\n+                        UNIT_ASSERT(stats.total_duration_us() > 0);\n                     }\n-\n-                    // 1st phase: find matching rows\n-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access().size(), 1);\n-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).name(), \"/Root/Foo\");\n-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).reads().rows(), 2);\n-                    UNIT_ASSERT(stats.query_phases(idx).cpu_time_us() > 0);\n-                    // 2nd phase: delete found rows\n-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx + 1).table_access().size(), 1);\n-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx + 1).table_access(0).name(), \"/Root/Foo\");\n-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx + 1).table_access(0).deletes().rows(), 2);\n-                    UNIT_ASSERT(stats.query_phases(idx + 1).cpu_time_us() > 0);\n-                    UNIT_ASSERT(stats.total_duration_us() > 0);\n                 }\n             }\n-        }\n \n-        sessionResult = client.CreateSession().ExtractValueSync();\n-        UNIT_ASSERT_VALUES_EQUAL(sessionResult.GetStatus(), EStatus::SUCCESS);\n+            sessionResult = client.CreateSession().ExtractValueSync();\n+            UNIT_ASSERT_VALUES_EQUAL(sessionResult.GetStatus(), EStatus::SUCCESS);\n+        }\n     }\n \n     Y_UNIT_TEST(CopyTables) {\ndiff --git a/ydb/services/ydb/ydb_ut.cpp b/ydb/services/ydb/ydb_ut.cpp\nindex 3b17744f0a4d..b6bfd312b4b4 100644\n--- a/ydb/services/ydb/ydb_ut.cpp\n+++ b/ydb/services/ydb/ydb_ut.cpp\n@@ -5703,8 +5703,10 @@ Y_UNIT_TEST_SUITE(TYqlDateTimeTests) {\n #endif\n \n Y_UNIT_TEST_SUITE(LocalityOperation) {\n-Y_UNIT_TEST(LocksFromAnotherTenants) {\n-    TKikimrWithGrpcAndRootSchema server;\n+Y_UNIT_TEST_TWIN(LocksFromAnotherTenants, UseSink) {\n+    NKikimrConfig::TAppConfig appConfig;\n+    appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);\n+    TKikimrWithGrpcAndRootSchema server(appConfig);\n     //server.Server_->SetupLogging(\n \n     auto connection = NYdb::TDriver(\ndiff --git a/yql/essentials/types/binary_json/read.cpp b/yql/essentials/types/binary_json/read.cpp\nindex 0786e59853ac..d50f8b82d8cc 100644\n--- a/yql/essentials/types/binary_json/read.cpp\n+++ b/yql/essentials/types/binary_json/read.cpp\n@@ -330,9 +330,7 @@ TString SerializeToJson(const TBinaryJson& binaryJson) {\n     return SerializeToJson(TStringBuf(binaryJson.Data(), binaryJson.Size()));\n }\n \n-TString SerializeToJson(TStringBuf binaryJson) {\n-    auto reader = TBinaryJsonReader::Make(binaryJson);\n-\n+TString SerializeToJson(const TContainerCursor& cursor) {\n     TJsonWriterConfig config;\n     config.DoubleNDigits = 16;\n     config.FloatNDigits = 8;\n@@ -340,11 +338,16 @@ TString SerializeToJson(TStringBuf binaryJson) {\n \n     TStringStream output;\n     TJsonWriter writer(&output, config);\n-    ReadContainerToJson(reader->GetRootCursor(), writer);\n+    ReadContainerToJson(cursor, writer);\n     writer.Flush();\n     return output.Str();\n }\n \n+TString SerializeToJson(TStringBuf binaryJson) {\n+    auto reader = TBinaryJsonReader::Make(binaryJson);\n+    return SerializeToJson(reader->GetRootCursor());\n+}\n+\n namespace {\n \n struct TPODReader {\ndiff --git a/yql/essentials/types/binary_json/read.h b/yql/essentials/types/binary_json/read.h\nindex c9b2c1cbf0bb..a0fdf931bf1d 100644\n--- a/yql/essentials/types/binary_json/read.h\n+++ b/yql/essentials/types/binary_json/read.h\n@@ -177,6 +177,8 @@ NUdf::TUnboxedValue ReadToJsonDom(TStringBuf binaryJson, const NUdf::IValueBuild\n /**\n  * @brief Serializes whole BinaryJson into textual JSON\n  */\n+TString SerializeToJson(const TContainerCursor& cursor);\n+\n TString SerializeToJson(const TBinaryJson& binaryJson);\n \n TString SerializeToJson(TStringBuf binaryJson);\n",
  "test_patch": "diff --git a/ydb/core/tx/columnshard/hooks/testing/ro_controller.h b/ydb/core/tx/columnshard/hooks/testing/ro_controller.h\nindex cc7354f52b21..1487ad560507 100644\n--- a/ydb/core/tx/columnshard/hooks/testing/ro_controller.h\n+++ b/ydb/core/tx/columnshard/hooks/testing/ro_controller.h\n@@ -4,6 +4,7 @@\n #include <ydb/core/tx/columnshard/common/tablet_id.h>\n #include <ydb/core/tx/columnshard/engines/writer/write_controller.h>\n #include <ydb/core/tx/columnshard/hooks/abstract/abstract.h>\n+#include <ydb/core/testlib/basics/runtime.h>\n #include <util/string/join.h>\n \n namespace NKikimr::NYDBTest::NColumnShard {\n@@ -108,7 +109,7 @@ class TReadOnlyController: public ICSController {\n         }\n     }\n \n-    void WaitCleaning(const TDuration d) const {\n+    void WaitCleaning(const TDuration d, NActors::TTestBasicRuntime* testRuntime = nullptr) const {\n         TInstant start = TInstant::Now();\n         ui32 countStart = GetCleaningStartedCounter().Val();\n         while (Now() - start < d) {\n@@ -117,7 +118,11 @@ class TReadOnlyController: public ICSController {\n                 start = TInstant::Now();\n             }\n             Cerr << \"WAIT_CLEANING: \" << GetCleaningStartedCounter().Val() << Endl;\n-            Sleep(TDuration::Seconds(1));\n+            if (testRuntime) {\n+                testRuntime->SimulateSleep(TDuration::Seconds(1));\n+            } else {\n+                Sleep(TDuration::Seconds(1));\n+            }\n         }\n     }\n \ndiff --git a/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.cpp b/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.cpp\nindex 833a430a4feb..9e2b466469a7 100644\n--- a/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.cpp\n+++ b/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.cpp\n@@ -54,16 +54,34 @@ void RefreshTiering(TTestBasicRuntime& runtime, const TActorId& sender) {\n     ForwardToTablet(runtime, TTestTxConfig::TxTablet0, sender, event.release());\n }\n \n-bool ProposeSchemaTx(TTestBasicRuntime& runtime, TActorId& sender, const TString& txBody, NOlap::TSnapshot snap) {\n+namespace {\n+std::optional<TPlanStep> ProposeSchemaTxOptional(TTestBasicRuntime& runtime, TActorId& sender, const TString& txBody, const ui64 txId) {\n     auto event = std::make_unique<TEvColumnShard::TEvProposeTransaction>(\n-        NKikimrTxColumnShard::TX_KIND_SCHEMA, 0, sender, snap.GetTxId(), txBody, 0, 0);\n-\n+        NKikimrTxColumnShard::TX_KIND_SCHEMA, 0, sender, txId, txBody, 0, 0);\n+    const auto now = runtime.GetTimeProvider()->Now();\n     ForwardToTablet(runtime, TTestTxConfig::TxTablet0, sender, event.release());\n     auto ev = runtime.GrabEdgeEvent<TEvColumnShard::TEvProposeTransactionResult>(sender);\n     const auto& res = ev->Get()->Record;\n-    UNIT_ASSERT_EQUAL(res.GetTxId(), snap.GetTxId());\n+    UNIT_ASSERT_EQUAL(res.GetTxId(), txId);\n     UNIT_ASSERT_EQUAL(res.GetTxKind(), NKikimrTxColumnShard::TX_KIND_SCHEMA);\n-    return (res.GetStatus() == NKikimrTxColumnShard::PREPARED);\n+    if (res.GetStatus() == NKikimrTxColumnShard::PREPARED) {\n+        UNIT_ASSERT_LE(now.MilliSeconds(), res.GetMinStep());\n+        UNIT_ASSERT_EQUAL(res.GetMaxStep(), std::numeric_limits<ui64>::max());\n+        return {TPlanStep(res.GetMinStep())};\n+    }\n+    return std::nullopt;\n+}\n+} //namespace\n+\n+void ProposeSchemaTxFail(TTestBasicRuntime& runtime, TActorId& sender, const TString& txBody, const ui64 txId) {\n+    const auto result = ProposeSchemaTxOptional(runtime, sender, txBody, txId);\n+    AFL_VERIFY(!result);\n+}\n+\n+TPlanStep ProposeSchemaTx(TTestBasicRuntime& runtime, TActorId& sender, const TString& txBody, const ui64 txId) {\n+    const auto result = ProposeSchemaTxOptional(runtime, sender, txBody, txId);\n+    AFL_VERIFY(result);\n+    return *result;\n }\n \n void PlanSchemaTx(TTestBasicRuntime& runtime, const TActorId& sender, NOlap::TSnapshot snap) {\n@@ -208,7 +226,7 @@ void ScanIndexStats(TTestBasicRuntime& runtime, TActorId& sender, const std::vec\n }\n \n template<class Checker>\n-void ProposeCommitCheck(TTestBasicRuntime& runtime, TActorId& sender, ui64 shardId, ui64 txId, const std::vector<ui64>& /* writeIds */, const ui64 lockId, Checker&& checker) {\n+TPlanStep ProposeCommitCheck(TTestBasicRuntime& runtime, TActorId& sender, ui64 shardId, ui64 txId, const std::vector<ui64>& /* writeIds */, const ui64 lockId, Checker&& checker) {\n     auto write = std::make_unique<NEvents::TDataEvents::TEvWrite>(txId, NKikimrDataEvents::TEvWrite::MODE_PREPARE);\n     auto* lock = write->Record.MutableLocks()->AddLocks();\n     lock->SetLockId(lockId);\n@@ -221,31 +239,37 @@ void ProposeCommitCheck(TTestBasicRuntime& runtime, TActorId& sender, ui64 shard\n \n     auto& res = event->Record;\n     checker(res);\n+    return TPlanStep(res.GetMinStep());\n }\n \n-void ProposeCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 shardId, ui64 txId, const std::vector<ui64>& writeIds, const ui64 lockId) {\n-    ProposeCommitCheck(runtime, sender, shardId, txId, writeIds, lockId, [&](auto& res) {\n+TPlanStep ProposeCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 shardId, ui64 txId, const std::vector<ui64>& writeIds, const ui64 lockId) {\n+    const auto now = runtime.GetTimeProvider()->Now();\n+    return ProposeCommitCheck(runtime, sender, shardId, txId, writeIds, lockId, [&](auto& res) {\n         AFL_VERIFY(res.GetTxId() == txId)(\"tx_id\", txId)(\"res\", res.GetTxId());\n         UNIT_ASSERT_EQUAL(res.GetStatus(), NKikimrDataEvents::TEvWriteResult::STATUS_PREPARED);\n+        UNIT_ASSERT_LE(now.MilliSeconds(), res.GetMinStep());\n+        UNIT_ASSERT_UNEQUAL(res.GetMaxStep(), std::numeric_limits<ui64>::max());\n+        UNIT_ASSERT_LE(res.GetMinStep(), res.GetMaxStep());\n     });\n }\n \n void ProposeCommitFail(TTestBasicRuntime& runtime, TActorId& sender, ui64 shardId, ui64 txId, const std::vector<ui64>& writeIds, const ui64 lockId) {\n-    ProposeCommitCheck(runtime, sender, shardId, txId, writeIds, lockId, [&](auto& res) {\n+    const auto result = ProposeCommitCheck(runtime, sender, shardId, txId, writeIds, lockId, [&](auto& res) {\n         UNIT_ASSERT_UNEQUAL(res.GetStatus(), NKikimrDataEvents::TEvWriteResult::STATUS_PREPARED);\n     });\n+    Y_UNUSED(result);\n }\n \n-void ProposeCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 txId, const std::vector<ui64>& writeIds, const ui64 lockId) {\n-    ProposeCommit(runtime, sender, TTestTxConfig::TxTablet0, txId, writeIds, lockId);\n+TPlanStep ProposeCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 txId, const std::vector<ui64>& writeIds, const ui64 lockId) {\n+    return ProposeCommit(runtime, sender, TTestTxConfig::TxTablet0, txId, writeIds, lockId);\n }\n \n \n-void ProposeCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 txId, const std::vector<ui64>& writeIds) {\n-    ProposeCommit(runtime, sender, TTestTxConfig::TxTablet0, txId, writeIds);\n+TPlanStep ProposeCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 txId, const std::vector<ui64>& writeIds) {\n+    return ProposeCommit(runtime, sender, TTestTxConfig::TxTablet0, txId, writeIds);\n }\n \n-void PlanCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 planStep, const TSet<ui64>& txIds) {\n+void PlanCommit(TTestBasicRuntime& runtime, TActorId& sender, TPlanStep planStep, const TSet<ui64>& txIds) {\n     PlanCommit(runtime, sender, TTestTxConfig::TxTablet0, planStep, txIds);\n }\n \n@@ -254,8 +278,8 @@ void Wakeup(TTestBasicRuntime& runtime, const TActorId& sender, const ui64 shard\n     ForwardToTablet(runtime, shardId, sender, wakeup.release());\n }\n \n-void PlanCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 shardId, ui64 planStep, const TSet<ui64>& txIds) {\n-    auto plan = std::make_unique<TEvTxProcessing::TEvPlanStep>(planStep, 0, shardId);\n+void PlanCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 shardId, TPlanStep planStep, const TSet<ui64>& txIds) {\n+    auto plan = std::make_unique<TEvTxProcessing::TEvPlanStep>(planStep.Val(), 0, shardId);\n     for (ui64 txId : txIds) {\n         auto tx = plan->Record.AddTransactions();\n         tx->SetTxId(txId);\n@@ -466,7 +490,7 @@ namespace NKikimr::NColumnShard {\n         return NOlap::TIndexInfo::BuildDefault(NOlap::TTestStoragesManager::GetInstance(), columns, pkIds);\n     }\n \n-    void SetupSchema(TTestBasicRuntime& runtime, TActorId& sender, const TString& txBody, const NOlap::TSnapshot& snapshot, bool succeed) {\n+    NTxUT::TPlanStep SetupSchema(TTestBasicRuntime& runtime, TActorId& sender, const TString& txBody, const ui64 txId) {\n \n         auto controller = NYDBTest::TControllers::GetControllerAs<NYDBTest::NColumnShard::TController>();\n         while (controller && !controller->IsActiveTablet(TTestTxConfig::TxTablet0)) {\n@@ -474,17 +498,15 @@ namespace NKikimr::NColumnShard {\n         }\n \n         using namespace NTxUT;\n-        bool ok = ProposeSchemaTx(runtime, sender, txBody, snapshot);\n-        UNIT_ASSERT_VALUES_EQUAL(ok, succeed);\n-        if (succeed) {\n-            PlanSchemaTx(runtime, sender, snapshot);\n-        }\n+        const auto planStep = ProposeSchemaTx(runtime, sender, txBody, txId);\n+        PlanSchemaTx(runtime, sender, NOlap::TSnapshot(planStep, txId));\n+        return planStep;\n     }\n \n-    void SetupSchema(TTestBasicRuntime& runtime, TActorId& sender, ui64 pathId,\n+    NTxUT::TPlanStep SetupSchema(TTestBasicRuntime& runtime, TActorId& sender, ui64 pathId,\n                  const TestTableDescription& table, TString codec) {\n         using namespace NTxUT;\n-        NOlap::TSnapshot snapshot(10, 10);\n+        const ui64 txId = 10;\n         TString txBody;\n         auto specials = TTestSchema::TTableSpecials().WithCodec(codec);\n         if (table.InStore) {\n@@ -492,11 +514,11 @@ namespace NKikimr::NColumnShard {\n         } else {\n             txBody = TTestSchema::CreateStandaloneTableTxBody(pathId, table.Schema, table.Pk, specials);\n         }\n-        SetupSchema(runtime, sender, txBody, snapshot, true);\n+        return SetupSchema(runtime, sender, txBody, txId);\n     }\n \n \n-    void PrepareTablet(TTestBasicRuntime& runtime, const ui64 tableId, const std::vector<NArrow::NTest::TTestColumn>& schema, const ui32 keySize) {\n+    NTxUT::TPlanStep PrepareTablet(TTestBasicRuntime& runtime, const ui64 tableId, const std::vector<NArrow::NTest::TTestColumn>& schema, const ui32 keySize) {\n         using namespace NTxUT;\n         CreateTestBootstrapper(runtime, CreateTestTabletInfo(TTestTxConfig::TxTablet0, TTabletTypes::ColumnShard), &CreateColumnShard);\n \n@@ -512,10 +534,10 @@ namespace NKikimr::NColumnShard {\n             tableDescription.Pk.push_back(schema[i]);\n         }\n         TActorId sender = runtime.AllocateEdgeActor();\n-        SetupSchema(runtime, sender, tableId, tableDescription);\n+        return SetupSchema(runtime, sender, tableId, tableDescription);\n     }\n \n-    void PrepareTablet(TTestBasicRuntime& runtime, const TString& schemaTxBody, bool succeed) {\n+    NTxUT::TPlanStep PrepareTablet(TTestBasicRuntime& runtime, const TString& schemaTxBody) {\n         using namespace NTxUT;\n         CreateTestBootstrapper(runtime, CreateTestTabletInfo(TTestTxConfig::TxTablet0, TTabletTypes::ColumnShard), &CreateColumnShard);\n \n@@ -524,7 +546,7 @@ namespace NKikimr::NColumnShard {\n         runtime.DispatchEvents(options);\n \n         TActorId sender = runtime.AllocateEdgeActor();\n-        SetupSchema(runtime, sender, schemaTxBody, NOlap::TSnapshot(1000, 100), succeed);\n+        return SetupSchema(runtime, sender, schemaTxBody, 100);\n     }\n \n      std::shared_ptr<arrow::RecordBatch> ReadAllAsBatch(TTestBasicRuntime& runtime, const ui64 tableId, const NOlap::TSnapshot& snapshot, const std::vector<NArrow::NTest::TTestColumn>& schema) {\ndiff --git a/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h b/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h\nindex a844f3f80114..f433bf54be3f 100644\n--- a/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h\n+++ b/ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h\n@@ -25,6 +25,8 @@ struct TIndexInfo;\n \n namespace NKikimr::NTxUT {\n \n+using TPlanStep = TPositiveIncreasingControlInteger;\n+\n // Private events of different actors reuse the same ES_PRIVATE range\n // So in order to capture the right private event we need to check its type via dynamic_cast\n template <class TPrivateEvent>\n@@ -395,7 +397,8 @@ struct TTestSchema {\n \n void RefreshTiering(TTestBasicRuntime& runtime, const TActorId& sender);\n \n-bool ProposeSchemaTx(TTestBasicRuntime& runtime, TActorId& sender, const TString& txBody, NOlap::TSnapshot snap);\n+void ProposeSchemaTxFail(TTestBasicRuntime& runtime, TActorId& sender, const TString& txBody, const ui64 txId);\n+[[nodiscard]] TPlanStep ProposeSchemaTx(TTestBasicRuntime& runtime, TActorId& sender, const TString& txBody, const ui64 txId);\n void PlanSchemaTx(TTestBasicRuntime& runtime, const TActorId& sender, NOlap::TSnapshot snap);\n \n void PlanWriteTx(TTestBasicRuntime& runtime, const TActorId& sender, NOlap::TSnapshot snap, bool waitResult = true);\n@@ -418,14 +421,14 @@ void ScanIndexStats(TTestBasicRuntime& runtime, TActorId& sender, const std::vec\n \n void ProposeCommitFail(\n      TTestBasicRuntime& runtime, TActorId& sender, ui64 shardId, ui64 txId, const std::vector<ui64>& writeIds, const ui64 lockId = 1);\n-void ProposeCommit(\n+[[nodiscard]] TPlanStep ProposeCommit(\n     TTestBasicRuntime& runtime, TActorId& sender, ui64 shardId, ui64 txId, const std::vector<ui64>& writeIds, const ui64 lockId = 1);\n-void ProposeCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 txId, const std::vector<ui64>& writeIds, const ui64 lockId = 1);\n+[[nodiscard]] TPlanStep ProposeCommit(TTestBasicRuntime& runtime, TActorId& sender, const ui64 txId, const std::vector<ui64>& writeIds, const ui64 lockId = 1);\n \n-void PlanCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 shardId, ui64 planStep, const TSet<ui64>& txIds);\n-void PlanCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 planStep, const TSet<ui64>& txIds);\n+void PlanCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 shardId, TPlanStep planStep, const TSet<ui64>& txIds);\n+void PlanCommit(TTestBasicRuntime& runtime, TActorId& sender, TPlanStep planStep, const TSet<ui64>& txIds);\n \n-inline void PlanCommit(TTestBasicRuntime& runtime, TActorId& sender, ui64 planStep, ui64 txId) {\n+inline void PlanCommit(TTestBasicRuntime& runtime, TActorId& sender, TPlanStep planStep, ui64 txId) {\n     TSet<ui64> ids;\n     ids.insert(txId);\n     PlanCommit(runtime, sender, planStep, ids);\n@@ -557,12 +560,11 @@ struct TestTableDescription {\n     }\n };\n \n-void SetupSchema(TTestBasicRuntime& runtime, TActorId& sender, ui64 pathId, const TestTableDescription& table = {}, TString codec = \"none\");\n-void SetupSchema(TTestBasicRuntime& runtime, TActorId& sender, const TString& txBody, const NOlap::TSnapshot& snapshot, bool succeed = true);\n+[[nodiscard]] NTxUT::TPlanStep SetupSchema(TTestBasicRuntime& runtime, TActorId& sender, ui64 pathId, const TestTableDescription& table = {}, TString codec = \"none\");\n+[[nodiscard]] NTxUT::TPlanStep SetupSchema(TTestBasicRuntime& runtime, TActorId& sender, const TString& txBody, const ui64 txId);\n \n-void PrepareTablet(\n+[[nodiscard]] NTxUT::TPlanStep PrepareTablet(\n     TTestBasicRuntime& runtime, const ui64 tableId, const std::vector<NArrow::NTest::TTestColumn>& schema, const ui32 keySize = 1);\n-void PrepareTablet(TTestBasicRuntime& runtime, const TString& schemaTxBody, bool succeed);\n \n std::shared_ptr<arrow::RecordBatch> ReadAllAsBatch(\n     TTestBasicRuntime& runtime, const ui64 tableId, const NOlap::TSnapshot& snapshot, const std::vector<NArrow::NTest::TTestColumn>& schema);\ndiff --git a/ydb/core/tx/columnshard/test_helper/shard_reader.h b/ydb/core/tx/columnshard/test_helper/shard_reader.h\nindex ebef456bbee5..8f1d3afb1c8f 100644\n--- a/ydb/core/tx/columnshard/test_helper/shard_reader.h\n+++ b/ydb/core/tx/columnshard/test_helper/shard_reader.h\n@@ -35,6 +35,8 @@ class TShardReader {\n     std::vector<std::shared_ptr<arrow::RecordBatch>> ResultBatches;\n     YDB_READONLY(ui32, IterationsCount, 0);\n \n+    std::vector<Ydb::Issue::IssueMessage> Errors;\n+\n public:\n     ui64 GetReadStat(const TString& paramName) const {\n         AFL_VERIFY(IsCorrectlyFinished());\n@@ -92,6 +94,10 @@ class TShardReader {\n         return IsFinished() && *Finished == -1;\n     }\n \n+    const std::vector<Ydb::Issue::IssueMessage>& GetErrors() const {\n+        return Errors;\n+    }\n+\n     bool InitializeScanner() {\n         AFL_VERIFY(!ScanActorId);\n         const TActorId sender = Runtime.AllocateEdgeActor();\n@@ -104,6 +110,9 @@ class TShardReader {\n             ScanActorId = ActorIdFromProto(msg.GetScanActorId());\n             return true;\n         } else if (auto* evError = std::get<1>(event)) {\n+            for (auto issue : evError->Record.GetIssues()) {\n+                Errors.emplace_back(issue);\n+            }\n             Finished = -1;\n         } else {\n             AFL_VERIFY(false);\n@@ -136,6 +145,9 @@ class TShardReader {\n                 Finished = 1;\n             }\n         } else if (auto* evError = std::get<1>(event)) {\n+            for (auto issue : evError->Record.GetIssues()) {\n+                Errors.emplace_back(issue);\n+            }\n             Finished = -1;\n         } else {\n             AFL_VERIFY(false);\ndiff --git a/ydb/core/tx/columnshard/test_helper/shard_writer.cpp b/ydb/core/tx/columnshard/test_helper/shard_writer.cpp\nindex 92e262d2f776..b1e61360b66f 100644\n--- a/ydb/core/tx/columnshard/test_helper/shard_writer.cpp\n+++ b/ydb/core/tx/columnshard/test_helper/shard_writer.cpp\n@@ -8,7 +8,7 @@\n \n namespace NKikimr::NTxUT {\n \n-NKikimrDataEvents::TEvWriteResult::EStatus TShardWriter::StartCommit(const ui64 txId) {\n+NKikimrDataEvents::TEvWriteResult TShardWriter::StartCommitImpl(const ui64 txId) {\n     auto evCommit = std::make_unique<NKikimr::NEvents::TDataEvents::TEvWrite>(txId, NKikimrDataEvents::TEvWrite::MODE_IMMEDIATE);\n     evCommit->Record.MutableLocks()->SetOp(NKikimrDataEvents::TKqpLocks::Commit);\n     auto* lock = evCommit->Record.MutableLocks()->AddLocks();\n@@ -18,8 +18,23 @@ NKikimrDataEvents::TEvWriteResult::EStatus TShardWriter::StartCommit(const ui64\n     TAutoPtr<NActors::IEventHandle> handle;\n     auto event = Runtime.GrabEdgeEvent<NKikimr::NEvents::TDataEvents::TEvWriteResult>(handle);\n     AFL_VERIFY(event);\n+    AFL_VERIFY(event->Record.GetTxId() == txId);\n+    return event->Record;\n+}\n \n-    return event->Record.GetStatus();\n+void TShardWriter::StartCommitFail(const ui64 txId) {\n+    auto event = StartCommitImpl(txId);\n+    AFL_VERIFY(event.GetStatus() == NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST);\n+}\n+\n+TPlanStep TShardWriter::StartCommit(const ui64 txId) {\n+    const auto now = Runtime.GetTimeProvider()->Now();\n+    auto event = StartCommitImpl(txId);\n+    AFL_VERIFY(event.GetStatus() == NKikimrDataEvents::TEvWriteResult::STATUS_PREPARED);\n+    AFL_VERIFY(now.MilliSeconds() <= event.GetMinStep());\n+    AFL_VERIFY(event.GetMinStep() <= event.GetMaxStep());\n+    AFL_VERIFY(event.GetMaxStep() < Max<ui64>());\n+    return TPlanStep{event.GetMinStep()};\n }\n \n NKikimrDataEvents::TEvWriteResult::EStatus TShardWriter::Abort(const ui64 txId) {\ndiff --git a/ydb/core/tx/columnshard/test_helper/shard_writer.h b/ydb/core/tx/columnshard/test_helper/shard_writer.h\nindex b43e9749a69b..584a443df480 100644\n--- a/ydb/core/tx/columnshard/test_helper/shard_writer.h\n+++ b/ydb/core/tx/columnshard/test_helper/shard_writer.h\n@@ -1,6 +1,7 @@\n #pragma once\n-#include <ydb/core/protos/data_events.pb.h>\n+#include <ydb/core/tx/data_events/events.h>\n #include <ydb/core/testlib/basics/runtime.h>\n+#include <ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h>\n \n #include <ydb/library/accessor/accessor.h>\n \n@@ -19,6 +20,9 @@ class TShardWriter {\n     YDB_ACCESSOR(ui64, LockNodeId, 1);\n     const TActorId Sender;\n \n+private:\n+    [[nodiscard]] NKikimrDataEvents::TEvWriteResult StartCommitImpl(const ui64 txId);\n+\n public:\n     TShardWriter(TTestBasicRuntime& runtime, const ui64 tabletId, const ui64 pathId, const ui64 lockId)\n         : Runtime(runtime)\n@@ -32,8 +36,8 @@ class TShardWriter {\n     const TActorId& GetSender() const {\n         return Sender;\n     }\n-\n-    [[nodiscard]] NKikimrDataEvents::TEvWriteResult::EStatus StartCommit(const ui64 txId);\n+    void StartCommitFail(const ui64 txId);\n+    [[nodiscard]] NTxUT::TPlanStep StartCommit(const ui64 txId);\n     [[nodiscard]] NKikimrDataEvents::TEvWriteResult::EStatus Abort(const ui64 txId);\n \n     [[nodiscard]] NKikimrDataEvents::TEvWriteResult::EStatus Write(\ndiff --git a/ydb/core/tx/columnshard/test_helper/test_combinator.h b/ydb/core/tx/columnshard/test_helper/test_combinator.h\nnew file mode 100644\nindex 000000000000..d98519465e44\n--- /dev/null\n+++ b/ydb/core/tx/columnshard/test_helper/test_combinator.h\n@@ -0,0 +1,80 @@\n+#pragma once\n+\n+\n+#define Y_UNIT_TEST_COMBINATOR_1(BaseName, Flag1)                                                                                  \\\n+    template<bool> void BaseName(NUnitTest::TTestContext&);                                                                        \\\n+    struct TTestRegistration##BaseName {                                                                                           \\\n+        TTestRegistration##BaseName() {                                                                                            \\\n+            TCurrentTest::AddTest(#BaseName \"-\" #Flag1, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<false>), false); \\\n+            TCurrentTest::AddTest(#BaseName \"+\" #Flag1, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<true>), false);  \\\n+        }                                                                                                                          \\\n+    };                                                                                                                             \\\n+    static TTestRegistration##BaseName testRegistration##BaseName;                                                                 \\\n+    template<bool Flag1>                                                                                                           \\\n+    void BaseName(NUnitTest::TTestContext&)\n+\n+#define Y_UNIT_TEST_COMBINATOR_2(BaseName, Flag1, Flag2)                                                                                             \\\n+    template<bool, bool> void BaseName(NUnitTest::TTestContext&);                                                                                    \\\n+    struct TTestRegistration##BaseName {                                                                                                             \\\n+        TTestRegistration##BaseName() {                                                                                                              \\\n+            TCurrentTest::AddTest(#BaseName \"-\" #Flag1 \"-\" #Flag2, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<false, false>), false); \\\n+            TCurrentTest::AddTest(#BaseName \"+\" #Flag1 \"-\" #Flag2, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<true,  false>), false); \\\n+            TCurrentTest::AddTest(#BaseName \"-\" #Flag1 \"+\" #Flag2, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<false, true>),  false); \\\n+            TCurrentTest::AddTest(#BaseName \"+\" #Flag1 \"+\" #Flag2, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<true,  true>),  false); \\\n+        }                                                                                                                                            \\\n+    };                                                                                                                                               \\\n+    static TTestRegistration##BaseName testRegistration##BaseName;                                                                                   \\\n+    template<bool Flag1, bool Flag2>                                                                                                                 \\\n+    void BaseName(NUnitTest::TTestContext&)\n+\n+\n+#define Y_UNIT_TEST_COMBINATOR_3(BaseName, Flag1, Flag2, Flag3)                                                                                                        \\\n+    template<bool, bool, bool> void BaseName(NUnitTest::TTestContext&);                                                                                                \\\n+    struct TTestRegistration##BaseName {                                                                                                                               \\\n+        TTestRegistration##BaseName() {                                                                                                                                \\\n+            TCurrentTest::AddTest(#BaseName \"-\" #Flag1 \"-\" #Flag2 \"-\" #Flag3, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<false, false, false>), false); \\\n+            TCurrentTest::AddTest(#BaseName \"+\" #Flag1 \"-\" #Flag2 \"-\" #Flag3, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<true,  false, false>), false); \\\n+            TCurrentTest::AddTest(#BaseName \"-\" #Flag1 \"+\" #Flag2 \"-\" #Flag3, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<false, true,  false>), false); \\\n+            TCurrentTest::AddTest(#BaseName \"+\" #Flag1 \"+\" #Flag2 \"-\" #Flag3, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<true,  true,  false>), false); \\\n+            TCurrentTest::AddTest(#BaseName \"-\" #Flag1 \"-\" #Flag2 \"+\" #Flag3, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<false, false, true>),  false); \\\n+            TCurrentTest::AddTest(#BaseName \"+\" #Flag1 \"-\" #Flag2 \"+\" #Flag3, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<true,  false, true>),  false); \\\n+            TCurrentTest::AddTest(#BaseName \"-\" #Flag1 \"+\" #Flag2 \"+\" #Flag3, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<false, true,  true>),  false); \\\n+            TCurrentTest::AddTest(#BaseName \"+\" #Flag1 \"+\" #Flag2 \"+\" #Flag3, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<true,  true,  true>),  false); \\\n+        }                                                                                                                                                              \\\n+    };                                                                                                                                                                 \\\n+    static TTestRegistration##BaseName testRegistration##BaseName;                                                                                                     \\\n+    template<bool Flag1, bool Flag2, bool Flag3>                                                                                                                       \\\n+    void BaseName(NUnitTest::TTestContext&)\n+\n+#define Y_UNIT_TEST_COMBINATOR_4(BaseName, Flag1, Flag2, Flag3, Flag4)                                                                                                                   \\\n+    template<bool, bool, bool, bool> void BaseName(NUnitTest::TTestContext&);                                                                                                            \\\n+    struct TTestRegistration##BaseName {                                                                                                                                                 \\\n+        TTestRegistration##BaseName() {                                                                                                                                                  \\\n+            TCurrentTest::AddTest(#BaseName \"-\" #Flag1 \"-\" #Flag2 \"-\" #Flag3 \"-\" #Flag4, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<false, false, false, false>), false); \\\n+            TCurrentTest::AddTest(#BaseName \"+\" #Flag1 \"-\" #Flag2 \"-\" #Flag3 \"-\" #Flag4, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<true,  false, false, false>), false); \\\n+            TCurrentTest::AddTest(#BaseName \"-\" #Flag1 \"+\" #Flag2 \"-\" #Flag3 \"-\" #Flag4, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<false, true,  false, false>), false); \\\n+            TCurrentTest::AddTest(#BaseName \"+\" #Flag1 \"+\" #Flag2 \"-\" #Flag3 \"-\" #Flag4, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<true,  true,  false, false>), false); \\\n+            TCurrentTest::AddTest(#BaseName \"-\" #Flag1 \"-\" #Flag2 \"+\" #Flag3 \"-\" #Flag4, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<false, false, true,  false>), false); \\\n+            TCurrentTest::AddTest(#BaseName \"+\" #Flag1 \"-\" #Flag2 \"+\" #Flag3 \"-\" #Flag4, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<true,  false, true,  false>), false); \\\n+            TCurrentTest::AddTest(#BaseName \"-\" #Flag1 \"+\" #Flag2 \"+\" #Flag3 \"-\" #Flag4, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<false, true,  true,  false>), false); \\\n+            TCurrentTest::AddTest(#BaseName \"+\" #Flag1 \"+\" #Flag2 \"+\" #Flag3 \"-\" #Flag4, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<true,  true,  true,  false>), false); \\\n+            TCurrentTest::AddTest(#BaseName \"-\" #Flag1 \"-\" #Flag2 \"-\" #Flag3 \"+\" #Flag4, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<false, false, false, true>),  false); \\\n+            TCurrentTest::AddTest(#BaseName \"+\" #Flag1 \"-\" #Flag2 \"-\" #Flag3 \"+\" #Flag4, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<true,  false, false, true>),  false); \\\n+            TCurrentTest::AddTest(#BaseName \"-\" #Flag1 \"+\" #Flag2 \"-\" #Flag3 \"+\" #Flag4, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<false, true,  false, true>),  false); \\\n+            TCurrentTest::AddTest(#BaseName \"+\" #Flag1 \"+\" #Flag2 \"-\" #Flag3 \"+\" #Flag4, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<true,  true,  false, true>),  false); \\\n+            TCurrentTest::AddTest(#BaseName \"-\" #Flag1 \"-\" #Flag2 \"+\" #Flag3 \"+\" #Flag4, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<false, false, true,  true>),  false); \\\n+            TCurrentTest::AddTest(#BaseName \"+\" #Flag1 \"-\" #Flag2 \"+\" #Flag3 \"+\" #Flag4, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<true,  false, true,  true>),  false); \\\n+            TCurrentTest::AddTest(#BaseName \"-\" #Flag1 \"+\" #Flag2 \"+\" #Flag3 \"+\" #Flag4, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<false, true,  true,  true>),  false); \\\n+            TCurrentTest::AddTest(#BaseName \"+\" #Flag1 \"+\" #Flag2 \"+\" #Flag3 \"+\" #Flag4, static_cast<void (*)(NUnitTest::TTestContext&)>(&BaseName<true,  true,  true,  true>),  false); \\\n+        }                                                                                                                                                                                \\\n+    };                                                                                                                                                                                   \\\n+    static TTestRegistration##BaseName testRegistration##BaseName;                                                                                                                       \\\n+    template<bool Flag1, bool Flag2, bool Flag3, bool Flag4>                                                                                                                             \\\n+    void BaseName(NUnitTest::TTestContext&)\n+\n+\n+#define Y_UNIT_TEST_DUO Y_UNIT_TEST_COMBINATOR_1\n+#define Y_UNIT_TEST_QUATRO Y_UNIT_TEST_COMBINATOR_2\n+#define Y_UNIT_TEST_OCTO Y_UNIT_TEST_COMBINATOR_3\n+#define Y_UNIT_TEST_SEDECIM Y_UNIT_TEST_COMBINATOR_4\n+\ndiff --git a/ydb/tests/functional/api/test_insert.py b/ydb/tests/functional/api/test_insert.py\nindex 4e5a1f93a72c..ad28e4b87bf9 100644\n--- a/ydb/tests/functional/api/test_insert.py\n+++ b/ydb/tests/functional/api/test_insert.py\n@@ -191,7 +191,7 @@ def callee():\n                         callee,\n                         raises(\n                             ydb.PreconditionFailed,\n-                            \"Conflict with existing key.\"\n+                            \"(Duplicate keys have been found.)|(Conflict with existing key.)\"\n                         )\n                     )\n \ndiff --git a/ydb/tests/functional/api/test_isolation.py b/ydb/tests/functional/api/test_isolation.py\nindex 3954115349fd..3b398881a1a9 100644\n--- a/ydb/tests/functional/api/test_isolation.py\n+++ b/ydb/tests/functional/api/test_isolation.py\n@@ -651,6 +651,9 @@ def test_anti_dependency_cycles_g2_two_edges(self):\n         def callee():\n             t1.execute('{} update {} set value = 0 where id = 1;'.format(prefix, table_name))\n \n+            # Sinks allow UPDATE statement to be delayed, so we do commit here to execute update.\n+            t1.commit()\n+\n         assert_that(\n             callee,\n             raises(\ndiff --git a/ydb/tests/functional/api/ya.make b/ydb/tests/functional/api/ya.make\nindex 5060311299de..9ab14133538b 100644\n--- a/ydb/tests/functional/api/ya.make\n+++ b/ydb/tests/functional/api/ya.make\n@@ -4,6 +4,7 @@ FORK_TEST_FILES()\n SIZE(MEDIUM)\n \n ENV(YDB_DRIVER_BINARY=\"ydb/apps/ydbd/ydbd\")\n+ENV(YDB_HARD_MEMORY_LIMIT_BYTES=\"8000000000\")\n \n TEST_SRCS(\n     test_session_pool.py\ndiff --git a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_dynumber_insert_from_table.sql-plan_/dynumber_insert_from_table.sql.plan b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_dynumber_insert_from_table.sql-plan_/dynumber_insert_from_table.sql.plan\nindex c1ec7180d970..e78bb7600be4 100644\n--- a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_dynumber_insert_from_table.sql-plan_/dynumber_insert_from_table.sql.plan\n+++ b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_dynumber_insert_from_table.sql-plan_/dynumber_insert_from_table.sql.plan\n@@ -21,21 +21,13 @@\n         },\n         {\n             \"name\": \"/local/base_dynumber_insert_from_table_sql_plan/ResultTableDyNumber\",\n-            \"reads\": [\n-                {\n-                    \"lookup_by\": [\n-                        \"Key\"\n-                    ],\n-                    \"type\": \"Lookup\"\n-                }\n-            ],\n             \"writes\": [\n                 {\n                     \"columns\": [\n                         \"Key\",\n                         \"Value\"\n                     ],\n-                    \"type\": \"MultiUpsert\"\n+                    \"type\": \"MultiInsert\"\n                 }\n             ]\n         }\ndiff --git a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_dynumber_insert_literal.sql-plan_/dynumber_insert_literal.sql.plan b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_dynumber_insert_literal.sql-plan_/dynumber_insert_literal.sql.plan\nindex 2360a2fc1bee..db6d72b7f43e 100644\n--- a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_dynumber_insert_literal.sql-plan_/dynumber_insert_literal.sql.plan\n+++ b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_dynumber_insert_literal.sql-plan_/dynumber_insert_literal.sql.plan\n@@ -6,21 +6,13 @@\n     \"tables\": [\n         {\n             \"name\": \"/local/base_dynumber_insert_literal_sql_plan/ResultLiteralDyNumber\",\n-            \"reads\": [\n-                {\n-                    \"lookup_by\": [\n-                        \"Key\"\n-                    ],\n-                    \"type\": \"Lookup\"\n-                }\n-            ],\n             \"writes\": [\n                 {\n                     \"columns\": [\n                         \"Key\",\n                         \"Value\"\n                     ],\n-                    \"type\": \"MultiUpsert\"\n+                    \"type\": \"MultiInsert\"\n                 }\n             ]\n         }\ndiff --git a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_dynumber_insert_params.sql-plan_/dynumber_insert_params.sql.plan b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_dynumber_insert_params.sql-plan_/dynumber_insert_params.sql.plan\nindex 7fdad896072b..23abca39d642 100644\n--- a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_dynumber_insert_params.sql-plan_/dynumber_insert_params.sql.plan\n+++ b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_dynumber_insert_params.sql-plan_/dynumber_insert_params.sql.plan\n@@ -6,21 +6,13 @@\n     \"tables\": [\n         {\n             \"name\": \"/local/base_dynumber_insert_params_sql_plan/ResultParamsDyNumber\",\n-            \"reads\": [\n-                {\n-                    \"lookup_by\": [\n-                        \"Key\"\n-                    ],\n-                    \"type\": \"Lookup\"\n-                }\n-            ],\n             \"writes\": [\n                 {\n                     \"columns\": [\n                         \"Key\",\n                         \"Value\"\n                     ],\n-                    \"type\": \"MultiUpsert\"\n+                    \"type\": \"MultiInsert\"\n                 }\n             ]\n         }\ndiff --git a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_explain.script-script_/explain.script.plan b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_explain.script-script_/explain.script.plan\nindex c57e7aca54b5..0faa53fd98e5 100644\n--- a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_explain.script-script_/explain.script.plan\n+++ b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_explain.script-script_/explain.script.plan\n@@ -519,27 +519,23 @@\n                 \"PlanNodeType\": \"Query\",\n                 \"Plans\": [\n                     {\n-                        \"Node Type\": \"Effect\",\n+                        \"Node Type\": \"Sink\",\n                         \"PlanNodeId\": 2,\n                         \"Plans\": [\n                             {\n-                                \"CTE Name\": \"precompute_0_0\",\n-                                \"Node Type\": \"Upsert-ConstantExpr\",\n+                                \"Node Type\": \"ConstantExpr-Sink\",\n                                 \"Operators\": [\n                                     {\n-                                        \"Inputs\": [\n-                                            {\n-                                                \"InternalOperatorId\": 1\n-                                            }\n-                                        ],\n-                                        \"Name\": \"Upsert\",\n-                                        \"Path\": \"/local/base_explain_script_script/ScriptingTest\",\n-                                        \"Table\": \"base_explain_script_script/ScriptingTest\"\n+                                        \"Inputs\": [],\n+                                        \"Iterator\": \"[{Key: 3,Value: \\\"Three\\\"},{Key: 4,Value: \\\"Four\\\"}]\",\n+                                        \"Name\": \"Iterator\"\n                                     },\n                                     {\n                                         \"Inputs\": [],\n-                                        \"Iterator\": \"precompute_0_0\",\n-                                        \"Name\": \"Iterator\"\n+                                        \"Name\": \"Replace\",\n+                                        \"Path\": \"/local/base_explain_script_script/ScriptingTest\",\n+                                        \"SinkType\": \"KqpTableSink\",\n+                                        \"Table\": \"base_explain_script_script/ScriptingTest\"\n                                     }\n                                 ],\n                                 \"PlanNodeId\": 1,\n@@ -563,7 +559,7 @@\n                                 \"Key\",\n                                 \"Value\"\n                             ],\n-                            \"type\": \"MultiUpsert\"\n+                            \"type\": \"MultiReplace\"\n                         }\n                     ]\n                 }\n@@ -575,27 +571,23 @@\n                 \"PlanNodeType\": \"Query\",\n                 \"Plans\": [\n                     {\n-                        \"Node Type\": \"Effect\",\n+                        \"Node Type\": \"Sink\",\n                         \"PlanNodeId\": 2,\n                         \"Plans\": [\n                             {\n-                                \"CTE Name\": \"precompute_0_0\",\n-                                \"Node Type\": \"Upsert-ConstantExpr\",\n+                                \"Node Type\": \"ConstantExpr-Sink\",\n                                 \"Operators\": [\n                                     {\n-                                        \"Inputs\": [\n-                                            {\n-                                                \"InternalOperatorId\": 1\n-                                            }\n-                                        ],\n-                                        \"Name\": \"Upsert\",\n-                                        \"Path\": \"/local/base_explain_script_script/ScriptingTest\",\n-                                        \"Table\": \"base_explain_script_script/ScriptingTest\"\n+                                        \"Inputs\": [],\n+                                        \"Iterator\": \"[{Key: 1,Value: \\\"One\\\"},{Key: 2,Value: \\\"Two\\\"}]\",\n+                                        \"Name\": \"Iterator\"\n                                     },\n                                     {\n                                         \"Inputs\": [],\n-                                        \"Iterator\": \"precompute_0_0\",\n-                                        \"Name\": \"Iterator\"\n+                                        \"Name\": \"Replace\",\n+                                        \"Path\": \"/local/base_explain_script_script/ScriptingTest\",\n+                                        \"SinkType\": \"KqpTableSink\",\n+                                        \"Table\": \"base_explain_script_script/ScriptingTest\"\n                                     }\n                                 ],\n                                 \"PlanNodeId\": 1,\n@@ -619,7 +611,7 @@\n                                 \"Key\",\n                                 \"Value\"\n                             ],\n-                            \"type\": \"MultiUpsert\"\n+                            \"type\": \"MultiReplace\"\n                         }\n                     ]\n                 }\ndiff --git a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_join_group_by_lookup.script-script_/join_group_by_lookup.script.plan b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_join_group_by_lookup.script-script_/join_group_by_lookup.script.plan\nindex b0bfc9915f5c..fa973cd0756c 100644\n--- a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_join_group_by_lookup.script-script_/join_group_by_lookup.script.plan\n+++ b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_join_group_by_lookup.script-script_/join_group_by_lookup.script.plan\n@@ -294,27 +294,23 @@\n                 \"PlanNodeType\": \"Query\",\n                 \"Plans\": [\n                     {\n-                        \"Node Type\": \"Effect\",\n+                        \"Node Type\": \"Sink\",\n                         \"PlanNodeId\": 2,\n                         \"Plans\": [\n                             {\n-                                \"CTE Name\": \"precompute_0_0\",\n-                                \"Node Type\": \"Upsert-ConstantExpr\",\n+                                \"Node Type\": \"ConstantExpr-Sink\",\n                                 \"Operators\": [\n                                     {\n-                                        \"Inputs\": [\n-                                            {\n-                                                \"InternalOperatorId\": 1\n-                                            }\n-                                        ],\n-                                        \"Name\": \"Upsert\",\n-                                        \"Path\": \"/local/base_join_group_by_lookup_script_script/Temp\",\n-                                        \"Table\": \"base_join_group_by_lookup_script_script/Temp\"\n+                                        \"Inputs\": [],\n+                                        \"Iterator\": \"[{Group: 1,Value: \\\"One\\\"},{Group: 3,Value: \\\"Three\\\"}]\",\n+                                        \"Name\": \"Iterator\"\n                                     },\n                                     {\n                                         \"Inputs\": [],\n-                                        \"Iterator\": \"precompute_0_0\",\n-                                        \"Name\": \"Iterator\"\n+                                        \"Name\": \"Replace\",\n+                                        \"Path\": \"/local/base_join_group_by_lookup_script_script/Temp\",\n+                                        \"SinkType\": \"KqpTableSink\",\n+                                        \"Table\": \"base_join_group_by_lookup_script_script/Temp\"\n                                     }\n                                 ],\n                                 \"PlanNodeId\": 1,\n@@ -338,7 +334,7 @@\n                                 \"Group\",\n                                 \"Value\"\n                             ],\n-                            \"type\": \"MultiUpsert\"\n+                            \"type\": \"MultiReplace\"\n                         }\n                     ]\n                 }\ndiff --git a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_json_insert_from_table.sql-plan_/json_insert_from_table.sql.plan b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_json_insert_from_table.sql-plan_/json_insert_from_table.sql.plan\nindex a38f5dd1ff77..3422943b64c2 100644\n--- a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_json_insert_from_table.sql-plan_/json_insert_from_table.sql.plan\n+++ b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_json_insert_from_table.sql-plan_/json_insert_from_table.sql.plan\n@@ -21,21 +21,13 @@\n         },\n         {\n             \"name\": \"/local/base_json_insert_from_table_sql_plan/ResultTableJD\",\n-            \"reads\": [\n-                {\n-                    \"lookup_by\": [\n-                        \"Key\"\n-                    ],\n-                    \"type\": \"Lookup\"\n-                }\n-            ],\n             \"writes\": [\n                 {\n                     \"columns\": [\n                         \"Key\",\n                         \"Value\"\n                     ],\n-                    \"type\": \"MultiUpsert\"\n+                    \"type\": \"MultiInsert\"\n                 }\n             ]\n         }\ndiff --git a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_json_insert_literal.sql-plan_/json_insert_literal.sql.plan b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_json_insert_literal.sql-plan_/json_insert_literal.sql.plan\nindex 1324aa83b6c6..e2b336b31c87 100644\n--- a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_json_insert_literal.sql-plan_/json_insert_literal.sql.plan\n+++ b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_json_insert_literal.sql-plan_/json_insert_literal.sql.plan\n@@ -6,21 +6,13 @@\n     \"tables\": [\n         {\n             \"name\": \"/local/base_json_insert_literal_sql_plan/ResultLiteralJD\",\n-            \"reads\": [\n-                {\n-                    \"lookup_by\": [\n-                        \"Key\"\n-                    ],\n-                    \"type\": \"Lookup\"\n-                }\n-            ],\n             \"writes\": [\n                 {\n                     \"columns\": [\n                         \"Key\",\n                         \"Value\"\n                     ],\n-                    \"type\": \"MultiUpsert\"\n+                    \"type\": \"MultiInsert\"\n                 }\n             ]\n         }\ndiff --git a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_json_insert_params.sql-plan_/json_insert_params.sql.plan b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_json_insert_params.sql-plan_/json_insert_params.sql.plan\nindex 12d03175a1f8..802cd64665dc 100644\n--- a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_json_insert_params.sql-plan_/json_insert_params.sql.plan\n+++ b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_json_insert_params.sql-plan_/json_insert_params.sql.plan\n@@ -6,21 +6,13 @@\n     \"tables\": [\n         {\n             \"name\": \"/local/base_json_insert_params_sql_plan/ResultParamsJD\",\n-            \"reads\": [\n-                {\n-                    \"lookup_by\": [\n-                        \"Key\"\n-                    ],\n-                    \"type\": \"Lookup\"\n-                }\n-            ],\n             \"writes\": [\n                 {\n                     \"columns\": [\n                         \"Key\",\n                         \"Value\"\n                     ],\n-                    \"type\": \"MultiUpsert\"\n+                    \"type\": \"MultiInsert\"\n                 }\n             ]\n         }\ndiff --git a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_simple_ct.script-script_/simple_ct.script.plan b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_simple_ct.script-script_/simple_ct.script.plan\nindex a3f28f505fd8..10512bcaaa79 100644\n--- a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_simple_ct.script-script_/simple_ct.script.plan\n+++ b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_simple_ct.script-script_/simple_ct.script.plan\n@@ -10,27 +10,23 @@\n                 \"PlanNodeType\": \"Query\",\n                 \"Plans\": [\n                     {\n-                        \"Node Type\": \"Effect\",\n+                        \"Node Type\": \"Sink\",\n                         \"PlanNodeId\": 2,\n                         \"Plans\": [\n                             {\n-                                \"CTE Name\": \"precompute_0_0\",\n-                                \"Node Type\": \"Upsert-ConstantExpr\",\n+                                \"Node Type\": \"ConstantExpr-Sink\",\n                                 \"Operators\": [\n                                     {\n-                                        \"Inputs\": [\n-                                            {\n-                                                \"InternalOperatorId\": 1\n-                                            }\n-                                        ],\n-                                        \"Name\": \"Upsert\",\n-                                        \"Path\": \"/local/base_simple_ct_script_script/Questions\",\n-                                        \"Table\": \"base_simple_ct_script_script/Questions\"\n+                                        \"Inputs\": [],\n+                                        \"Iterator\": \"[{idx: 1,text: \\\"to do or not to do\\\"}]\",\n+                                        \"Name\": \"Iterator\"\n                                     },\n                                     {\n                                         \"Inputs\": [],\n-                                        \"Iterator\": \"precompute_0_0\",\n-                                        \"Name\": \"Iterator\"\n+                                        \"Name\": \"Upsert\",\n+                                        \"Path\": \"/local/base_simple_ct_script_script/Questions\",\n+                                        \"SinkType\": \"KqpTableSink\",\n+                                        \"Table\": \"base_simple_ct_script_script/Questions\"\n                                     }\n                                 ],\n                                 \"PlanNodeId\": 1,\ndiff --git a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_table_types.script-script_/table_types.script.plan b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_table_types.script-script_/table_types.script.plan\nindex c09de3f8757c..4f05136f0ad5 100644\n--- a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_table_types.script-script_/table_types.script.plan\n+++ b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_table_types.script-script_/table_types.script.plan\n@@ -135,27 +135,23 @@\n                 \"PlanNodeType\": \"Query\",\n                 \"Plans\": [\n                     {\n-                        \"Node Type\": \"Effect\",\n+                        \"Node Type\": \"Sink\",\n                         \"PlanNodeId\": 2,\n                         \"Plans\": [\n                             {\n-                                \"CTE Name\": \"precompute_0_0\",\n-                                \"Node Type\": \"Upsert-ConstantExpr\",\n+                                \"Node Type\": \"ConstantExpr-Sink\",\n                                 \"Operators\": [\n                                     {\n-                                        \"Inputs\": [\n-                                            {\n-                                                \"InternalOperatorId\": 1\n-                                            }\n-                                        ],\n-                                        \"Name\": \"Upsert\",\n-                                        \"Path\": \"/local/base_table_types_script_script/TableTypes\",\n-                                        \"Table\": \"base_table_types_script_script/TableTypes\"\n+                                        \"Inputs\": [],\n+                                        \"Iterator\": \"[{Key: \\\"Key\\\",Value01: \\\"true\\\",Value02: 1,Value03: -1,Value04: 2,Value05: -2,Value06: 3,Value07: \\\"4.5\\\",Value08: Minus,Value09: \\\"3.14\\\",Value10: DyNumber,Value21: \\\"\\\\u041F\\\\u0440\\\\u0438\\\\u0432\\\\u0435\\\\u0442\\\",Value22: \\\"{\\\\\\\"name\\\\\\\": \\\\\\\"George\\\\\\\", \\\\\\\"age\\\\\\\": 23}\\\",Value23: JsonDocument,Value24: \\\"{a=1; b=2}\\\",Value31: Apply,Value32: Apply,Value33: Apply,Value34: Apply}]\",\n+                                        \"Name\": \"Iterator\"\n                                     },\n                                     {\n                                         \"Inputs\": [],\n-                                        \"Iterator\": \"precompute_0_0\",\n-                                        \"Name\": \"Iterator\"\n+                                        \"Name\": \"Replace\",\n+                                        \"Path\": \"/local/base_table_types_script_script/TableTypes\",\n+                                        \"SinkType\": \"KqpTableSink\",\n+                                        \"Table\": \"base_table_types_script_script/TableTypes\"\n                                     }\n                                 ],\n                                 \"PlanNodeId\": 1,\n@@ -196,7 +192,7 @@\n                                 \"Value33\",\n                                 \"Value34\"\n                             ],\n-                            \"type\": \"MultiUpsert\"\n+                            \"type\": \"MultiReplace\"\n                         }\n                     ]\n                 }\ndiff --git a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_insert.sql-plan_/write_insert.sql.plan b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_insert.sql-plan_/write_insert.sql.plan\nindex d9b00b71fdfc..f6a5f6b88beb 100644\n--- a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_insert.sql-plan_/write_insert.sql.plan\n+++ b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_insert.sql-plan_/write_insert.sql.plan\n@@ -6,15 +6,6 @@\n     \"tables\": [\n         {\n             \"name\": \"/local/base_write_insert_sql_plan/Input\",\n-            \"reads\": [\n-                {\n-                    \"lookup_by\": [\n-                        \"key\",\n-                        \"subkey\"\n-                    ],\n-                    \"type\": \"Lookup\"\n-                }\n-            ],\n             \"writes\": [\n                 {\n                     \"columns\": [\n@@ -22,7 +13,7 @@\n                         \"subkey\",\n                         \"value\"\n                     ],\n-                    \"type\": \"MultiUpsert\"\n+                    \"type\": \"MultiInsert\"\n                 }\n             ]\n         },\n@@ -41,13 +32,6 @@\n                         \"Name (-\\u221e, +\\u221e)\"\n                     ],\n                     \"type\": \"Scan\"\n-                },\n-                {\n-                    \"lookup_by\": [\n-                        \"Group\",\n-                        \"Name\"\n-                    ],\n-                    \"type\": \"Lookup\"\n                 }\n             ],\n             \"writes\": [\n@@ -57,7 +41,7 @@\n                         \"Group\",\n                         \"Name\"\n                     ],\n-                    \"type\": \"MultiUpsert\"\n+                    \"type\": \"MultiInsert\"\n                 }\n             ]\n         }\ndiff --git a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_insert_revert.sql-plan_/write_insert_revert.sql.plan b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_insert_revert.sql-plan_/write_insert_revert.sql.plan\nindex 586f7e00d290..3b4d0c4d679c 100644\n--- a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_insert_revert.sql-plan_/write_insert_revert.sql.plan\n+++ b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_insert_revert.sql-plan_/write_insert_revert.sql.plan\n@@ -22,7 +22,7 @@\n                         \"subkey\",\n                         \"value\"\n                     ],\n-                    \"type\": \"MultiUpsert\"\n+                    \"type\": \"MultiInsert\"\n                 }\n             ]\n         },\n@@ -44,7 +44,7 @@\n                         \"Group\",\n                         \"Name\"\n                     ],\n-                    \"type\": \"MultiUpsert\"\n+                    \"type\": \"MultiInsert\"\n                 }\n             ]\n         }\ndiff --git a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_multi_usage.script-script_/write_multi_usage.script.plan b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_multi_usage.script-script_/write_multi_usage.script.plan\nindex 8c8f361d05b9..d47da6224a7e 100644\n--- a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_multi_usage.script-script_/write_multi_usage.script.plan\n+++ b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_multi_usage.script-script_/write_multi_usage.script.plan\n@@ -65,6 +65,7 @@\n                                                                     \"Name (-\\u221e, +\\u221e)\"\n                                                                 ],\n                                                                 \"ReadRangesPointPrefixLen\": \"0\",\n+                                                                \"Reverse\": false,\n                                                                 \"Scan\": \"Sequential\",\n                                                                 \"Table\": \"base_write_multi_usage_script_script/Temp\"\n                                                             }\n@@ -144,6 +145,7 @@\n                                                                     \"Name (-\\u221e, +\\u221e)\"\n                                                                 ],\n                                                                 \"ReadRangesPointPrefixLen\": \"0\",\n+                                                                \"Reverse\": false,\n                                                                 \"Scan\": \"Sequential\",\n                                                                 \"Table\": \"base_write_multi_usage_script_script/Input1\"\n                                                             }\n@@ -214,98 +216,30 @@\n                 \"PlanNodeType\": \"Query\",\n                 \"Plans\": [\n                     {\n-                        \"Node Type\": \"Effect\",\n-                        \"PlanNodeId\": 12,\n+                        \"Node Type\": \"Sink\",\n+                        \"PlanNodeId\": 7,\n                         \"Plans\": [\n                             {\n-                                \"CTE Name\": \"precompute_0_1\",\n-                                \"Node Type\": \"Upsert-ConstantExpr\",\n+                                \"Node Type\": \"Stage-Sink\",\n                                 \"Operators\": [\n                                     {\n-                                        \"Inputs\": [\n-                                            {\n-                                                \"InternalOperatorId\": 1\n-                                            }\n-                                        ],\n+                                        \"Inputs\": [],\n                                         \"Name\": \"Upsert\",\n                                         \"Path\": \"/local/base_write_multi_usage_script_script/Temp\",\n+                                        \"SinkType\": \"KqpTableSink\",\n                                         \"Table\": \"base_write_multi_usage_script_script/Temp\"\n-                                    },\n-                                    {\n-                                        \"Inputs\": [],\n-                                        \"Iterator\": \"precompute_0_1\",\n-                                        \"Name\": \"Iterator\"\n                                     }\n                                 ],\n-                                \"PlanNodeId\": 11,\n-                                \"Tables\": [\n-                                    \"base_write_multi_usage_script_script/Temp\"\n-                                ]\n-                            }\n-                        ]\n-                    },\n-                    {\n-                        \"Node Type\": \"Effect\",\n-                        \"PlanNodeId\": 10,\n-                        \"Plans\": [\n-                            {\n-                                \"CTE Name\": \"precompute_0_0\",\n-                                \"Node Type\": \"Delete-ConstantExpr\",\n-                                \"Operators\": [\n-                                    {\n-                                        \"Inputs\": [\n-                                            {\n-                                                \"InternalOperatorId\": 1\n-                                            }\n-                                        ],\n-                                        \"Name\": \"Delete\",\n-                                        \"Path\": \"/local/base_write_multi_usage_script_script/Input1\",\n-                                        \"Table\": \"base_write_multi_usage_script_script/Input1\"\n-                                    },\n-                                    {\n-                                        \"Inputs\": [],\n-                                        \"Iterator\": \"precompute_0_0\",\n-                                        \"Name\": \"Iterator\"\n-                                    }\n-                                ],\n-                                \"PlanNodeId\": 9,\n-                                \"Tables\": [\n-                                    \"base_write_multi_usage_script_script/Input1\"\n-                                ]\n-                            }\n-                        ]\n-                    },\n-                    {\n-                        \"Node Type\": \"Precompute_0_0\",\n-                        \"Parent Relationship\": \"InitPlan\",\n-                        \"PlanNodeId\": 7,\n-                        \"PlanNodeType\": \"Materialize\",\n-                        \"Plans\": [\n-                            {\n-                                \"Node Type\": \"Stage\",\n-                                \"PlanNodeId\": 6\n-                            }\n-                        ],\n-                        \"Subplan Name\": \"CTE precompute_0_0\"\n-                    },\n-                    {\n-                        \"Node Type\": \"Precompute_0_1\",\n-                        \"Parent Relationship\": \"InitPlan\",\n-                        \"PlanNodeId\": 5,\n-                        \"PlanNodeType\": \"Materialize\",\n-                        \"Plans\": [\n-                            {\n-                                \"Node Type\": \"Collect\",\n-                                \"PlanNodeId\": 4,\n+                                \"PlanNodeId\": 6,\n                                 \"Plans\": [\n                                     {\n                                         \"Node Type\": \"UnionAll\",\n-                                        \"PlanNodeId\": 3,\n+                                        \"PlanNodeId\": 5,\n                                         \"PlanNodeType\": \"Connection\",\n                                         \"Plans\": [\n                                             {\n                                                 \"Node Type\": \"Stage\",\n-                                                \"PlanNodeId\": 2,\n+                                                \"PlanNodeId\": 4,\n                                                 \"Plans\": [\n                                                     {\n                                                         \"Node Type\": \"TableRangeScan\",\n@@ -325,7 +259,7 @@\n                                                                 \"Table\": \"base_write_multi_usage_script_script/Input1\"\n                                                             }\n                                                         ],\n-                                                        \"PlanNodeId\": 1,\n+                                                        \"PlanNodeId\": 3,\n                                                         \"Tables\": [\n                                                             \"base_write_multi_usage_script_script/Input1\"\n                                                         ]\n@@ -334,10 +268,39 @@\n                                             }\n                                         ]\n                                     }\n+                                ],\n+                                \"Tables\": [\n+                                    \"base_write_multi_usage_script_script/Temp\"\n+                                ]\n+                            }\n+                        ]\n+                    },\n+                    {\n+                        \"Node Type\": \"Sink\",\n+                        \"PlanNodeId\": 2,\n+                        \"Plans\": [\n+                            {\n+                                \"Node Type\": \"ConstantExpr-Sink\",\n+                                \"Operators\": [\n+                                    {\n+                                        \"Inputs\": [],\n+                                        \"Iterator\": \"[{Group: 1,Name: ToString}]\",\n+                                        \"Name\": \"Iterator\"\n+                                    },\n+                                    {\n+                                        \"Inputs\": [],\n+                                        \"Name\": \"Delete\",\n+                                        \"Path\": \"/local/base_write_multi_usage_script_script/Input1\",\n+                                        \"SinkType\": \"KqpTableSink\",\n+                                        \"Table\": \"base_write_multi_usage_script_script/Input1\"\n+                                    }\n+                                ],\n+                                \"PlanNodeId\": 1,\n+                                \"Tables\": [\n+                                    \"base_write_multi_usage_script_script/Input1\"\n                                 ]\n                             }\n-                        ],\n-                        \"Subplan Name\": \"CTE precompute_0_1\"\n+                        ]\n                     }\n                 ],\n                 \"Stats\": {\ndiff --git a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_multi_usage_key.script-script_/write_multi_usage_key.script.plan b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_multi_usage_key.script-script_/write_multi_usage_key.script.plan\nindex 2f5f92230673..073b8bb49d0b 100644\n--- a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_multi_usage_key.script-script_/write_multi_usage_key.script.plan\n+++ b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_multi_usage_key.script-script_/write_multi_usage_key.script.plan\n@@ -104,44 +104,20 @@\n                 \"PlanNodeType\": \"Query\",\n                 \"Plans\": [\n                     {\n-                        \"Node Type\": \"Effect\",\n-                        \"PlanNodeId\": 8,\n+                        \"Node Type\": \"Sink\",\n+                        \"PlanNodeId\": 5,\n                         \"Plans\": [\n                             {\n-                                \"CTE Name\": \"precompute_0_0\",\n-                                \"Node Type\": \"Upsert-ConstantExpr\",\n+                                \"Node Type\": \"Stage-Sink\",\n                                 \"Operators\": [\n                                     {\n-                                        \"Inputs\": [\n-                                            {\n-                                                \"InternalOperatorId\": 1\n-                                            }\n-                                        ],\n+                                        \"Inputs\": [],\n                                         \"Name\": \"Upsert\",\n                                         \"Path\": \"/local/base_write_multi_usage_key_script_script/Temp\",\n+                                        \"SinkType\": \"KqpTableSink\",\n                                         \"Table\": \"base_write_multi_usage_key_script_script/Temp\"\n-                                    },\n-                                    {\n-                                        \"Inputs\": [],\n-                                        \"Iterator\": \"precompute_0_0\",\n-                                        \"Name\": \"Iterator\"\n                                     }\n                                 ],\n-                                \"PlanNodeId\": 7,\n-                                \"Tables\": [\n-                                    \"base_write_multi_usage_key_script_script/Temp\"\n-                                ]\n-                            }\n-                        ]\n-                    },\n-                    {\n-                        \"Node Type\": \"Precompute_0\",\n-                        \"Parent Relationship\": \"InitPlan\",\n-                        \"PlanNodeId\": 5,\n-                        \"PlanNodeType\": \"Materialize\",\n-                        \"Plans\": [\n-                            {\n-                                \"Node Type\": \"Collect\",\n                                 \"PlanNodeId\": 4,\n                                 \"Plans\": [\n                                     {\n@@ -193,10 +169,12 @@\n                                             }\n                                         ]\n                                     }\n+                                ],\n+                                \"Tables\": [\n+                                    \"base_write_multi_usage_key_script_script/Temp\"\n                                 ]\n                             }\n-                        ],\n-                        \"Subplan Name\": \"CTE precompute_0_0\"\n+                        ]\n                     }\n                 ],\n                 \"Stats\": {\ndiff --git a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_multi_write.sql-plan_/write_multi_write.sql.plan b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_multi_write.sql-plan_/write_multi_write.sql.plan\nindex 841dfdec96d8..c95d86b6795b 100644\n--- a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_multi_write.sql-plan_/write_multi_write.sql.plan\n+++ b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_multi_write.sql-plan_/write_multi_write.sql.plan\n@@ -9,7 +9,6 @@\n             \"writes\": [\n                 {\n                     \"columns\": [\n-                        \"Amount\",\n                         \"Comment\",\n                         \"Group\",\n                         \"Name\"\n@@ -17,18 +16,19 @@\n                     \"type\": \"MultiUpsert\"\n                 },\n                 {\n-                    \"columns\": [\n-                        \"Comment\",\n-                        \"Group\",\n-                        \"Name\"\n-                    ],\n-                    \"type\": \"MultiUpsert\"\n+                    \"type\": \"MultiErase\"\n                 },\n                 {\n                     \"type\": \"MultiErase\"\n                 },\n                 {\n-                    \"type\": \"MultiErase\"\n+                    \"columns\": [\n+                        \"Amount\",\n+                        \"Comment\",\n+                        \"Group\",\n+                        \"Name\"\n+                    ],\n+                    \"type\": \"MultiReplace\"\n                 }\n             ]\n         }\ndiff --git a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_replace.sql-plan_/write_replace.sql.plan b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_replace.sql-plan_/write_replace.sql.plan\nindex cd2b46dbe89c..5c028acd1cb8 100644\n--- a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_replace.sql-plan_/write_replace.sql.plan\n+++ b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_replace.sql-plan_/write_replace.sql.plan\n@@ -26,7 +26,7 @@\n                         \"subkey\",\n                         \"value\"\n                     ],\n-                    \"type\": \"MultiUpsert\"\n+                    \"type\": \"MultiReplace\"\n                 }\n             ]\n         },\n@@ -40,7 +40,7 @@\n                         \"Group\",\n                         \"Name\"\n                     ],\n-                    \"type\": \"MultiUpsert\"\n+                    \"type\": \"MultiReplace\"\n                 },\n                 {\n                     \"columns\": [\n@@ -49,7 +49,7 @@\n                         \"Group\",\n                         \"Name\"\n                     ],\n-                    \"type\": \"MultiUpsert\"\n+                    \"type\": \"MultiReplace\"\n                 }\n             ]\n         }\ndiff --git a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_update.sql-plan_/write_update.sql.plan b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_update.sql-plan_/write_update.sql.plan\nindex ce96e820d33b..257d7e1c1634 100644\n--- a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_update.sql-plan_/write_update.sql.plan\n+++ b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_update.sql-plan_/write_update.sql.plan\n@@ -26,8 +26,8 @@\n                 {\n                     \"columns\": [\n                         \"Amount\",\n-                        \"Name\",\n-                        \"Group\"\n+                        \"Group\",\n+                        \"Name\"\n                     ],\n                     \"type\": \"MultiUpsert\"\n                 }\ndiff --git a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_update_on.sql-plan_/write_update_on.sql.plan b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_update_on.sql-plan_/write_update_on.sql.plan\nindex 9574e68bdd9a..06b591ec55f5 100644\n--- a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_update_on.sql-plan_/write_update_on.sql.plan\n+++ b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_update_on.sql-plan_/write_update_on.sql.plan\n@@ -6,19 +6,6 @@\n     \"tables\": [\n         {\n             \"name\": \"/local/base_write_update_on_sql_plan/Input\",\n-            \"reads\": [\n-                {\n-                    \"columns\": [\n-                        \"key\",\n-                        \"subkey\"\n-                    ],\n-                    \"lookup_by\": [\n-                        \"key\",\n-                        \"subkey\"\n-                    ],\n-                    \"type\": \"Lookup\"\n-                }\n-            ],\n             \"writes\": [\n                 {\n                     \"columns\": [\n@@ -26,7 +13,7 @@\n                         \"subkey\",\n                         \"value\"\n                     ],\n-                    \"type\": \"MultiUpsert\"\n+                    \"type\": \"MultiUpdate\"\n                 }\n             ]\n         },\n@@ -46,17 +33,6 @@\n                         \"Name (-\\u221e, +\\u221e)\"\n                     ],\n                     \"type\": \"Scan\"\n-                },\n-                {\n-                    \"columns\": [\n-                        \"Group\",\n-                        \"Name\"\n-                    ],\n-                    \"lookup_by\": [\n-                        \"Group\",\n-                        \"Name\"\n-                    ],\n-                    \"type\": \"Lookup\"\n                 }\n             ],\n             \"writes\": [\n@@ -66,7 +42,7 @@\n                         \"Group\",\n                         \"Name\"\n                     ],\n-                    \"type\": \"MultiUpsert\"\n+                    \"type\": \"MultiUpdate\"\n                 }\n             ]\n         }\ndiff --git a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_write_group_by.script-script_/write_write_group_by.script.plan b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_write_group_by.script-script_/write_write_group_by.script.plan\nindex 34538f0c81ef..64e854f08dad 100644\n--- a/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_write_group_by.script-script_/write_write_group_by.script.plan\n+++ b/ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_write_group_by.script-script_/write_write_group_by.script.plan\n@@ -106,44 +106,20 @@\n                 \"PlanNodeType\": \"Query\",\n                 \"Plans\": [\n                     {\n-                        \"Node Type\": \"Effect\",\n-                        \"PlanNodeId\": 10,\n+                        \"Node Type\": \"Sink\",\n+                        \"PlanNodeId\": 7,\n                         \"Plans\": [\n                             {\n-                                \"CTE Name\": \"precompute_0_0\",\n-                                \"Node Type\": \"Upsert-ConstantExpr\",\n+                                \"Node Type\": \"Stage-Sink\",\n                                 \"Operators\": [\n                                     {\n-                                        \"Inputs\": [\n-                                            {\n-                                                \"InternalOperatorId\": 1\n-                                            }\n-                                        ],\n+                                        \"Inputs\": [],\n                                         \"Name\": \"Upsert\",\n                                         \"Path\": \"/local/base_write_write_group_by_script_script/Temp\",\n+                                        \"SinkType\": \"KqpTableSink\",\n                                         \"Table\": \"base_write_write_group_by_script_script/Temp\"\n-                                    },\n-                                    {\n-                                        \"Inputs\": [],\n-                                        \"Iterator\": \"precompute_0_0\",\n-                                        \"Name\": \"Iterator\"\n                                     }\n                                 ],\n-                                \"PlanNodeId\": 9,\n-                                \"Tables\": [\n-                                    \"base_write_write_group_by_script_script/Temp\"\n-                                ]\n-                            }\n-                        ]\n-                    },\n-                    {\n-                        \"Node Type\": \"Precompute_0\",\n-                        \"Parent Relationship\": \"InitPlan\",\n-                        \"PlanNodeId\": 7,\n-                        \"PlanNodeType\": \"Materialize\",\n-                        \"Plans\": [\n-                            {\n-                                \"Node Type\": \"Collect\",\n                                 \"PlanNodeId\": 6,\n                                 \"Plans\": [\n                                     {\n@@ -224,10 +200,12 @@\n                                             }\n                                         ]\n                                     }\n+                                ],\n+                                \"Tables\": [\n+                                    \"base_write_write_group_by_script_script/Temp\"\n                                 ]\n                             }\n-                        ],\n-                        \"Subplan Name\": \"CTE precompute_0_0\"\n+                        ]\n                     }\n                 ],\n                 \"Stats\": {\ndiff --git a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-0 b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-0\nindex 2626baeb227f..55e2200cc82c 100644\n--- a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-0\n+++ b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-0\n@@ -79,7 +79,9 @@\n                                                         \"Inputs\": [],\n                                                         \"Name\": \"TableFullScan\",\n                                                         \"Path\": \"/local/clickbench/plans/column/hits\",\n-                                                        \"ReadColumns\": null,\n+                                                        \"ReadColumns\": [\n+                                                            \"CounterID\"\n+                                                        ],\n                                                         \"ReadRanges\": [\n                                                             \"CounterID (-\\u221e, +\\u221e)\",\n                                                             \"EventDate (-\\u221e, +\\u221e)\",\n@@ -141,6 +143,9 @@\n                     \"name\": \"/local/clickbench/plans/column/hits\",\n                     \"reads\": [\n                         {\n+                            \"columns\": [\n+                                \"CounterID\"\n+                            ],\n                             \"scan_by\": [\n                                 \"CounterID (-\\u221e, +\\u221e)\",\n                                 \"EventDate (-\\u221e, +\\u221e)\",\ndiff --git a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-40 b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-40\nindex a87ce4a6ce60..600be0f4a4ce 100644\n--- a/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-40\n+++ b/ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-40\n@@ -107,7 +107,7 @@\n                                                                                             }\n                                                                                         ],\n                                                                                         \"Name\": \"Filter\",\n-                                                                                        \"Predicate\": \"IsRefresh == 0 AND TraficSourceID == -1 OR TraficSourceID == 6 AND RefererHash == 3594120000172545465\",\n+                                                                                        \"Predicate\": \"IsRefresh == 0 AND RefererHash == 3594120000172545465 AND TraficSourceID == -1 OR TraficSourceID == 6\",\n                                                                                         \"Pushdown\": \"True\"\n                                                                                     },\n                                                                                     {\n@@ -169,7 +169,7 @@\n                                                                                                             \"Id\": 108\n                                                                                                         },\n                                                                                                         \"Constant\": {\n-                                                                                                            \"Int32\": -1\n+                                                                                                            \"Int64\": 3594120000172545465\n                                                                                                         }\n                                                                                                     }\n                                                                                                 },\n@@ -181,7 +181,7 @@\n                                                                                                         \"Function\": {\n                                                                                                             \"Arguments\": [\n                                                                                                                 {\n-                                                                                                                    \"Id\": 38\n+                                                                                                                    \"Id\": 103\n                                                                                                                 },\n                                                                                                                 {\n                                                                                                                     \"Id\": 108\n@@ -199,7 +199,7 @@\n                                                                                                             \"Id\": 110\n                                                                                                         },\n                                                                                                         \"Constant\": {\n-                                                                                                            \"Int32\": 6\n+                                                                                                            \"Int32\": -1\n                                                                                                         }\n                                                                                                     }\n                                                                                                 },\n@@ -228,28 +228,28 @@\n                                                                                                         \"Column\": {\n                                                                                                             \"Id\": 112\n                                                                                                         },\n+                                                                                                        \"Constant\": {\n+                                                                                                            \"Int32\": 6\n+                                                                                                        }\n+                                                                                                    }\n+                                                                                                },\n+                                                                                                {\n+                                                                                                    \"Assign\": {\n+                                                                                                        \"Column\": {\n+                                                                                                            \"Id\": 113\n+                                                                                                        },\n                                                                                                         \"Function\": {\n                                                                                                             \"Arguments\": [\n                                                                                                                 {\n-                                                                                                                    \"Id\": 109\n+                                                                                                                    \"Id\": 38\n                                                                                                                 },\n                                                                                                                 {\n-                                                                                                                    \"Id\": 111\n+                                                                                                                    \"Id\": 112\n                                                                                                                 }\n                                                                                                             ],\n                                                                                                             \"FunctionType\": 2,\n                                                                                                             \"KernelIdx\": 3,\n-                                                                                                            \"YqlOperationId\": 1\n-                                                                                                        }\n-                                                                                                    }\n-                                                                                                },\n-                                                                                                {\n-                                                                                                    \"Assign\": {\n-                                                                                                        \"Column\": {\n-                                                                                                            \"Id\": 113\n-                                                                                                        },\n-                                                                                                        \"Constant\": {\n-                                                                                                            \"Int64\": 3594120000172545465\n+                                                                                                            \"YqlOperationId\": 11\n                                                                                                         }\n                                                                                                     }\n                                                                                                 },\n@@ -261,7 +261,7 @@\n                                                                                                         \"Function\": {\n                                                                                                             \"Arguments\": [\n                                                                                                                 {\n-                                                                                                                    \"Id\": 103\n+                                                                                                                    \"Id\": 111\n                                                                                                                 },\n                                                                                                                 {\n                                                                                                                     \"Id\": 113\n@@ -269,7 +269,7 @@\n                                                                                                             ],\n                                                                                                             \"FunctionType\": 2,\n                                                                                                             \"KernelIdx\": 4,\n-                                                                                                            \"YqlOperationId\": 11\n+                                                                                                            \"YqlOperationId\": 1\n                                                                                                         }\n                                                                                                     }\n                                                                                                 },\n@@ -281,7 +281,7 @@\n                                                                                                         \"Function\": {\n                                                                                                             \"Arguments\": [\n                                                                                                                 {\n-                                                                                                                    \"Id\": 112\n+                                                                                                                    \"Id\": 109\n                                                                                                                 },\n                                                                                                                 {\n                                                                                                                     \"Id\": 114\ndiff --git a/ydb/tests/functional/compatibility/test_stress.py b/ydb/tests/functional/compatibility/test_stress.py\nnew file mode 100644\nindex 000000000000..a6e6ca250004\n--- /dev/null\n+++ b/ydb/tests/functional/compatibility/test_stress.py\n@@ -0,0 +1,365 @@\n+# -*- coding: utf-8 -*-\n+import os\n+\n+import pytest\n+\n+import yatest\n+\n+from ydb.tests.library.harness.kikimr_runner import KiKiMR\n+from ydb.tests.library.harness.kikimr_config import KikimrConfigGenerator\n+from ydb.tests.library.harness.param_constants import kikimr_driver_path\n+from ydb.tests.library.common.types import Erasure\n+from ydb.tests.stress.simple_queue.workload import Workload\n+\n+last_stable_binary_path = yatest.common.binary_path(\"ydb/tests/library/compatibility/ydbd-last-stable\")\n+current_binary_path = kikimr_driver_path()\n+\n+all_binary_combinations = [\n+    [last_stable_binary_path],\n+    [current_binary_path],\n+    [last_stable_binary_path, current_binary_path],\n+]\n+all_binary_combinations_ids = [\"last_stable\", \"current\", \"mixed\"]\n+\n+\n+class TestStress(object):\n+    @pytest.fixture(autouse=True, params=all_binary_combinations, ids=all_binary_combinations_ids)\n+    def setup(self, request):\n+        binary_paths = request.param\n+        self.config = KikimrConfigGenerator(\n+            erasure=Erasure.MIRROR_3_DC,\n+            binary_paths=binary_paths,\n+            # uncomment for 64 datetime in tpc-h/tpc-ds\n+            # extra_feature_flags={\"enable_table_datetime64\": True},\n+        )\n+\n+        self.cluster = KiKiMR(self.config)\n+        self.cluster.start()\n+        self.endpoint = \"%s:%s\" % (self.cluster.nodes[1].host, self.cluster.nodes[1].port)\n+        output_path = yatest.common.test_output_path()\n+        self.output_f = open(os.path.join(output_path, \"out.log\"), \"w\")\n+        yield\n+        self.cluster.stop()\n+\n+    def get_command_prefix_log(self, subcmds: list[str], path: str) -> list[str]:\n+        return (\n+            [\n+                yatest.common.binary_path(os.getenv(\"YDB_CLI_BINARY\")),\n+                \"--verbose\",\n+                \"--endpoint\",\n+                \"grpc://localhost:%d\" % self.cluster.nodes[1].grpc_port,\n+                \"--database=/Root\",\n+                \"workload\",\n+                \"log\",\n+            ]\n+            + subcmds\n+            + [\"--path\", path]\n+        )\n+\n+    def set_auto_partitioning_size_mb(self, path, size_mb):\n+        yatest.common.execute(\n+            [\n+                yatest.common.binary_path(os.getenv(\"YDB_CLI_BINARY\")),\n+                \"--verbose\",\n+                \"--endpoint\",\n+                \"grpc://localhost:%d\" % self.cluster.nodes[1].grpc_port,\n+                \"--database=/Root\",\n+                \"sql\", \"-s\",\n+                \"ALTER TABLE `{}` SET (AUTO_PARTITIONING_PARTITION_SIZE_MB={})\".format(path, size_mb),\n+            ],\n+            stdout=self.output_f,\n+            stderr=self.output_f,\n+        )\n+\n+    @pytest.mark.parametrize(\"store_type\", [\"row\"])\n+    def test_log(self, store_type):\n+        timeout_scale = 60\n+\n+        upload_commands = [\n+            # bulk upsert workload\n+            self.get_command_prefix_log(subcmds=[\"run\", \"bulk_upsert\"], path=store_type)\n+            + [\"--seconds\", str(timeout_scale), \"--threads\", \"10\", \"--rows\", \"2000\"],\n+            # upsert workload\n+            self.get_command_prefix_log(subcmds=[\"run\", \"upsert\"], path=store_type)\n+            + [\"--seconds\", str(timeout_scale), \"--threads\", \"10\"],\n+            # insert workload\n+            self.get_command_prefix_log(subcmds=[\"run\", \"insert\"], path=store_type)\n+            + [\"--seconds\", str(timeout_scale), \"--threads\", \"10\"],\n+        ]\n+        # init\n+        yatest.common.execute(\n+            self.get_command_prefix_log(subcmds=[\"init\"], path=store_type)\n+            + [\n+                \"--store\",\n+                store_type,\n+                \"--min-partitions\",\n+                \"100\",\n+                \"--partition-size\",\n+                \"10\",\n+                \"--auto-partition\",\n+                \"0\",\n+                \"--ttl\",\n+                \"10\",\n+            ],\n+            stdout=self.output_f,\n+            stderr=self.output_f,\n+        )\n+\n+        yatest.common.execute(\n+            self.get_command_prefix_log(subcmds=[\"import\", \"--bulk-size\", \"1000\", \"-t\", \"1\", \"generator\"], path=store_type),\n+            stdout=self.output_f,\n+            stderr=self.output_f,\n+            wait=True,\n+        )\n+        select = yatest.common.execute(\n+            self.get_command_prefix_log(subcmds=[\"run\", \"select\"], path=store_type)\n+            + [\n+                \"--client-timeout\",\n+                \"10000\",\n+                \"--threads\",\n+                \"10\",\n+                \"--seconds\",\n+                str(timeout_scale * len(upload_commands)),\n+            ],\n+            wait=False,\n+            stdout=self.output_f,\n+            stderr=self.output_f,\n+        )\n+\n+        for i, command in enumerate(upload_commands):\n+            yatest.common.execute(\n+                command,\n+                wait=True,\n+                stdout=self.output_f,\n+                stderr=self.output_f,\n+            )\n+\n+        select.wait()\n+\n+    @pytest.mark.skip(reason=\"Too huge logs\")\n+    @pytest.mark.parametrize(\"mode\", [\"row\"])\n+    def test_simple_queue(self, mode: str):\n+        with Workload(f\"grpc://localhost:{self.cluster.nodes[1].grpc_port}\", \"/Root\", 180, mode) as workload:\n+            for handle in workload.loop():\n+                handle()\n+\n+    @pytest.mark.parametrize(\"store_type\", [\"row\"])\n+    def test_kv(self, store_type):\n+        init_command_prefix = [\n+            yatest.common.binary_path(os.getenv(\"YDB_CLI_BINARY\")),\n+            \"--verbose\",\n+            \"--endpoint\",\n+            \"grpc://localhost:%d\" % self.cluster.nodes[1].grpc_port,\n+            \"--database=/Root\",\n+            \"workload\",\n+            \"kv\",\n+            \"init\",\n+            \"--min-partitions\",\n+            \"10\",\n+            \"--partition-size\",\n+            \"10\",\n+            \"--auto-partition\",\n+            \"0\",\n+            \"--init-upserts\",\n+            \"0\",\n+            \"--cols\",\n+            \"5\",\n+            \"--int-cols\",\n+            \"2\",\n+            \"--key-cols\",\n+            \"3\",\n+        ]\n+\n+        run_command_prefix = [\n+            yatest.common.binary_path(os.getenv(\"YDB_CLI_BINARY\")),\n+            \"--verbose\",\n+            \"--endpoint\",\n+            \"grpc://localhost:%d\" % self.cluster.nodes[1].grpc_port,\n+            \"--database=/Root\",\n+            \"workload\",\n+            \"kv\",\n+            \"run\",\n+            \"mixed\",\n+            \"--seconds\",\n+            \"180\",\n+            \"--threads\",\n+            \"10\",\n+            \"--cols\",\n+            \"5\",\n+            \"--len\",\n+            \"200\",\n+            \"--int-cols\",\n+            \"2\",\n+            \"--key-cols\",\n+            \"3\",\n+        ]\n+\n+        init_command = init_command_prefix\n+        init_command.extend(\n+            [\n+                \"--path\",\n+                store_type,\n+                \"--store\",\n+                store_type,\n+            ]\n+        )\n+        run_command = run_command_prefix\n+        run_command.extend(\n+            [\n+                \"--path\",\n+                store_type,\n+            ]\n+        )\n+        yatest.common.execute(init_command, wait=True, stdout=self.output_f, stderr=self.output_f)\n+        yatest.common.execute(run_command, wait=True, stdout=self.output_f, stderr=self.output_f)\n+\n+    @pytest.mark.parametrize(\"store_type\", [\"row\"])\n+    def test_tpch1(self, store_type):\n+        init_command = [\n+            yatest.common.binary_path(os.getenv(\"YDB_CLI_BINARY\")),\n+            \"--verbose\",\n+            \"--endpoint\",\n+            \"grpc://localhost:%d\" % self.cluster.nodes[1].grpc_port,\n+            \"--database=/Root\",\n+            \"workload\",\n+            \"tpch\",\n+            \"-p\",\n+            \"tpch\",\n+            \"init\",\n+            \"--store={}\".format(store_type),\n+            \"--datetime\",  # use 32 bit dates instead of 64 (not supported in 24-4)\n+        ]\n+        import_command = [\n+            yatest.common.binary_path(os.getenv(\"YDB_CLI_BINARY\")),\n+            \"--verbose\",\n+            \"--endpoint\",\n+            \"grpc://localhost:%d\" % self.cluster.nodes[1].grpc_port,\n+            \"--database=/Root\",\n+            \"workload\",\n+            \"tpch\",\n+            \"-p\",\n+            \"tpch\",\n+            \"import\",\n+            \"generator\",\n+            \"--scale=1\",\n+        ]\n+        run_command = [\n+            yatest.common.binary_path(os.getenv(\"YDB_CLI_BINARY\")),\n+            \"--verbose\",\n+            \"--endpoint\",\n+            \"grpc://localhost:%d\" % self.cluster.nodes[1].grpc_port,\n+            \"--database=/Root\",\n+            \"workload\",\n+            \"tpch\",\n+            \"-p\",\n+            \"tpch\",\n+            \"run\",\n+            \"--scale=1\",\n+            \"--exclude\",\n+            # not working for row tables\n+            \"17\",\n+            \"--check-canonical\",\n+        ]\n+\n+        yatest.common.execute(init_command, wait=True, stdout=self.output_f, stderr=self.output_f)\n+\n+        # make tables distributed across nodes\n+        tables = [\n+            \"lineitem\",\n+            \"nation\",\n+            \"orders\",\n+            \"part\",\n+            \"partsupp\",\n+            \"region\",\n+            \"supplier\",\n+        ]\n+        for table in tables:\n+            self.set_auto_partitioning_size_mb(\"tpch/{}\".format(table), 25)\n+\n+        yatest.common.execute(import_command, wait=True, stdout=self.output_f, stderr=self.output_f)\n+        yatest.common.execute(run_command, wait=True, stdout=self.output_f, stderr=self.output_f)\n+\n+    @pytest.mark.skip(reason=\"Not stabilized yet\")\n+    @pytest.mark.parametrize(\"store_type\", [\"row\"])\n+    def test_tpcds1(self, store_type):\n+        init_command = [\n+            yatest.common.binary_path(os.getenv(\"YDB_CLI_BINARY\")),\n+            \"--verbose\",\n+            \"--endpoint\",\n+            \"grpc://localhost:%d\" % self.cluster.nodes[1].grpc_port,\n+            \"--database=/Root\",\n+            \"workload\",\n+            \"tpcds\",\n+            \"-p\",\n+            \"tpcds\",\n+\n+            \"init\",\n+            \"--store={}\".format(store_type),\n+            \"--datetime\",  # use 32 bit dates instead of 64 (not supported in 24-4)\n+        ]\n+        import_command = [\n+            yatest.common.binary_path(os.getenv(\"YDB_CLI_BINARY\")),\n+            \"--verbose\",\n+            \"--endpoint\",\n+            \"grpc://localhost:%d\" % self.cluster.nodes[1].grpc_port,\n+            \"--database=/Root\",\n+            \"workload\",\n+            \"tpcds\",\n+            \"-p\",\n+            \"tpcds\",\n+            \"import\",\n+            \"generator\",\n+            \"--scale=1\",\n+        ]\n+        run_command = [\n+            yatest.common.binary_path(os.getenv(\"YDB_CLI_BINARY\")),\n+            \"--verbose\",\n+            \"--endpoint\",\n+            \"grpc://localhost:%d\" % self.cluster.nodes[1].grpc_port,\n+            \"--database=/Root\",\n+            \"workload\",\n+            \"tpcds\",\n+            \"-p\",\n+            \"tpcds\",\n+            \"run\",\n+            \"--scale=1\",\n+            \"--check-canonical\",\n+            \"--exclude\",\n+            # not working for row tables\n+            \"5,7,14,18,22,23,24,26,27,31,33,39,46,51,54,56,58,60,61,64,66,67,68,72,75,77,78,79,80,93\",\n+        ]\n+\n+        yatest.common.execute(init_command, wait=True, stdout=self.output_f, stderr=self.output_f)\n+\n+        # make table distributed across nodes\n+        tables = [\n+            \"call_center\",\n+            \"catalog_page\",\n+            \"catalog_returns\",\n+            \"catalog_sales\",\n+            \"customer\",\n+            \"customer_demographics\",\n+            \"date_dim\",\n+            \"household_demographics\",\n+            \"income_band\",\n+            \"inventory\",\n+            \"item\",\n+            \"promotion\",\n+            \"reason\",\n+            \"ship_mode\",\n+            \"store\",\n+            \"store_returns\",\n+            \"store_sales\",\n+            \"time_dim\",\n+            \"warehouse\",\n+            \"web_page\",\n+            \"web_returns\",\n+            \"web_sales\",\n+            \"web_site\",\n+        ]\n+\n+        for table in tables:\n+            self.set_auto_partitioning_size_mb(\"tpcds/{}\".format(table), 25)\n+\n+        yatest.common.execute(import_command, wait=True, stdout=self.output_f, stderr=self.output_f)\n+        yatest.common.execute(run_command, wait=True, stdout=self.output_f, stderr=self.output_f)\ndiff --git a/ydb/tests/functional/compatibility/ya.make b/ydb/tests/functional/compatibility/ya.make\nindex 0c9096aa3a5d..637be3ea2e58 100644\n--- a/ydb/tests/functional/compatibility/ya.make\n+++ b/ydb/tests/functional/compatibility/ya.make\n@@ -1,21 +1,27 @@\n PY3TEST()\n ENV(YDB_DRIVER_BINARY=\"ydb/apps/ydbd/ydbd\")\n+ENV(YDB_CLI_BINARY=\"ydb/apps/ydb/ydb\")\n \n TEST_SRCS(\n     test_followers.py\n     test_compatibility.py\n+    test_stress.py\n )\n \n SIZE(LARGE)\n+REQUIREMENTS(cpu:all)\n+REQUIREMENTS(ram:all)\n INCLUDE(${ARCADIA_ROOT}/ydb/tests/large.inc)\n \n DEPENDS(\n+    ydb/apps/ydb\n     ydb/apps/ydbd\n     ydb/tests/library/compatibility\n )\n \n PEERDIR(\n     ydb/tests/library\n+    ydb/tests/stress/simple_queue/workload\n )\n \n END()\ndiff --git a/ydb/tests/olap/ya.make b/ydb/tests/olap/ya.make\nindex 1689defbcf07..ceba4f136e81 100644\n--- a/ydb/tests/olap/ya.make\n+++ b/ydb/tests/olap/ya.make\n@@ -5,6 +5,7 @@ PY3TEST()\n \n     TEST_SRCS(\n         test_quota_exhaustion.py\n+        zip_bomb.py\n     )\n \n     IF (SANITIZER_TYPE OR WITH_VALGRIND)\ndiff --git a/ydb/tests/olap/zip_bomb.py b/ydb/tests/olap/zip_bomb.py\nnew file mode 100644\nindex 000000000000..a124c3a7ab9e\n--- /dev/null\n+++ b/ydb/tests/olap/zip_bomb.py\n@@ -0,0 +1,125 @@\n+import sys\n+import time\n+\n+import ydb\n+from threading import Thread\n+from ydb.tests.library.harness.kikimr_config import KikimrConfigGenerator\n+from ydb.tests.library.harness.kikimr_runner import KiKiMR\n+from ydb.tests.library.harness.util import LogLevels\n+\n+ROWS_CHUNK_SIZE = 100000\n+ROWS_CHUNKS_COUNT = 2\n+\n+\n+class TestZipBomb(object):\n+    @classmethod\n+    def setup_class(cls):\n+        cls.cluster = KiKiMR(KikimrConfigGenerator(\n+            column_shard_config={},\n+            additional_log_configs={'MEMORY_CONTROLLER': LogLevels.INFO, \"TX_COLUMNSHARD\": LogLevels.DEBUG},\n+            extra_feature_flags={'enable_write_portions_on_insert': True},\n+            static_pdisk_size=10 * 1024 * 1024,\n+            dynamic_pdisk_size=5 * 1024 * 1024\n+        ))\n+        cls.cluster.start()\n+\n+    @classmethod\n+    def teardown_class(cls):\n+        cls.cluster.stop()\n+\n+    def make_session(self):\n+        driver = ydb.Driver(endpoint=f'grpc://localhost:{self.cluster.nodes[1].grpc_port}', database=self.database_name)\n+        session = ydb.QuerySessionPool(driver)\n+        driver.wait(5, fail_fast=True)\n+        return session\n+\n+    def create_test_str_table(self, session, table):\n+        return session.execute_with_retries(f\"\"\"\n+                CREATE TABLE `{table}` (\n+                    k Int32 NOT NULL,\n+                    v1 String,\n+                    v2 String,\n+                    v3 String,\n+                    v4 String,\n+                    v5 String,\n+                    PRIMARY KEY (k)\n+                ) WITH (STORE = COLUMN, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT=1)\n+            \"\"\")\n+\n+    def upsert_test_str_chunk(self, session, table, chunk_id, retries=10):\n+        long_string = 'x' * 5000\n+        return session.execute_with_retries(f\"\"\"\n+                $n = {ROWS_CHUNK_SIZE};\n+                $values_list = ListReplicate(42ul, $n);\n+                $value = '{long_string}';\n+                $rows_list = ListFoldMap($values_list, {chunk_id * ROWS_CHUNK_SIZE}, ($val, $i)->((<|k:$i, v1:$value||'1', v2:$value||'2', v3:$value||'3', v4:$value||'4', v5:$value||'5'|>, $i + 1)));\n+\n+                UPSERT INTO `{table}`\n+                SELECT * FROM AS_TABLE($rows_list);\n+            \"\"\", None, ydb.retries.RetrySettings(max_retries=retries))\n+\n+    def upsert_str(self, session, table):\n+        for i in range(ROWS_CHUNKS_COUNT):\n+            res = self.upsert_test_str_chunk(session, table, i, retries=0)\n+            print(f\"upsert #{i} ok, result:\", res, file=sys.stderr)\n+\n+    def select(self, table, session):\n+        result = session.execute_with_retries(\"\"\"\n+            SELECT\n+                MAX(v1),\n+                MAX(v2),\n+                MAX(v3),\n+                MAX(v4),\n+                MAX(v5)\n+            FROM huge\n+        \"\"\")\n+        print(result[0].rows, file=sys.stderr)\n+\n+    def get_rss(self, pid):\n+        with open(f\"/proc/{pid}/status\", \"r\") as f:\n+            for line in f:\n+                if line.startswith(\"RssAnon:\"):\n+                    return int(line.split()[1])\n+\n+    def watch_rss(self, pid, rss):\n+        maxrss = 0\n+        try:\n+            while rss[1] == 0:\n+                rss_kb = self.get_rss(pid)\n+                if rss_kb > maxrss:\n+                    maxrss = rss_kb\n+                time.sleep(1)\n+        except FileNotFoundError:\n+            return\n+        rss[0] = maxrss\n+\n+    def test(self):\n+        \"\"\"As per https://github.com/ydb-platform/ydb/issues/13529\"\"\"\n+        pid = self.cluster.nodes[1].pid\n+        maxrss = [0, 0]\n+        watch_thread = Thread(target=self.watch_rss, args=[pid, maxrss])\n+        watch_thread.start()\n+        print('Pid {}'.format(pid), file=sys.stderr)\n+        self.database_name = '/Root'\n+        session = self.make_session()\n+\n+        # Overflow the database\n+        self.create_test_str_table(session, 'huge')\n+        self.upsert_str(session, 'huge')\n+        rss = self.get_rss(pid)\n+        print('Rss after upsert {}'.format(rss), file=sys.stderr)\n+        threads = []\n+        for c in range(20):\n+            thread = Thread(target=self.select, args=['huge', session])\n+            threads.append(thread)\n+\n+        for thread in threads:\n+            thread.start()\n+\n+        for thread in threads:\n+            thread.join()\n+\n+        maxrss[1] = 1\n+        watch_thread.join()\n+        print('Max rss {}', format(maxrss[0]), file=sys.stderr)\n+        assert maxrss[0] < 12 * 1024 * 1024, \"Too high memory consumption\"\n",
  "problem_statement": "when shard replies \"MaxTxInFly was exceeded\" KQP returns Unavailable\nInternalError: UNAVAILABLE DEFAULT_ERROR: { <main>: Error: Too many retries for shard <> subissue: { <main>: Error: Request 0 rejected, MaxTxInFly was exceeded\n",
  "hints_text": "",
  "created_at": "2025-04-19T16:53:51Z",
  "modified_files": [
    ".github/config/muted_ya.txt",
    "ydb/core/driver_lib/run/run.cpp",
    "ydb/core/driver_lib/run/ya.make",
    "ydb/core/formats/arrow/accessor/abstract/accessor.cpp",
    "ydb/core/formats/arrow/accessor/abstract/accessor.h",
    "b/ydb/core/formats/arrow/accessor/abstract/common.cpp",
    "b/ydb/core/formats/arrow/accessor/abstract/common.h",
    "ydb/core/formats/arrow/accessor/abstract/constructor.h",
    "ydb/core/formats/arrow/accessor/abstract/ya.make",
    "ydb/core/formats/arrow/accessor/composite/accessor.cpp",
    "ydb/core/formats/arrow/accessor/composite/accessor.h",
    "ydb/core/formats/arrow/accessor/composite_serial/accessor.cpp",
    "ydb/core/formats/arrow/accessor/composite_serial/accessor.h",
    "ydb/core/formats/arrow/accessor/plain/accessor.cpp",
    "ydb/core/formats/arrow/accessor/plain/accessor.h",
    "ydb/core/formats/arrow/accessor/plain/constructor.cpp",
    "ydb/core/formats/arrow/accessor/sparsed/accessor.cpp",
    "ydb/core/formats/arrow/accessor/sparsed/accessor.h",
    "ydb/core/formats/arrow/accessor/sparsed/constructor.cpp",
    "ydb/core/formats/arrow/accessor/sub_columns/accessor.cpp",
    "ydb/core/formats/arrow/accessor/sub_columns/accessor.h",
    "ydb/core/formats/arrow/accessor/sub_columns/columns_storage.cpp",
    "ydb/core/formats/arrow/accessor/sub_columns/columns_storage.h",
    "ydb/core/formats/arrow/accessor/sub_columns/constructor.cpp",
    "ydb/core/formats/arrow/accessor/sub_columns/constructor.h",
    "ydb/core/formats/arrow/accessor/sub_columns/data_extractor.cpp",
    "ydb/core/formats/arrow/accessor/sub_columns/data_extractor.h",
    "ydb/core/formats/arrow/accessor/sub_columns/direct_builder.cpp",
    "ydb/core/formats/arrow/accessor/sub_columns/direct_builder.h",
    "ydb/core/formats/arrow/accessor/sub_columns/iterators.h",
    "b/ydb/core/formats/arrow/accessor/sub_columns/json_extractors.cpp",
    "b/ydb/core/formats/arrow/accessor/sub_columns/json_extractors.h",
    "ydb/core/formats/arrow/accessor/sub_columns/others_storage.cpp",
    "ydb/core/formats/arrow/accessor/sub_columns/others_storage.h",
    "ydb/core/formats/arrow/accessor/sub_columns/request.cpp",
    "ydb/core/formats/arrow/accessor/sub_columns/settings.h",
    "b/ydb/core/formats/arrow/accessor/sub_columns/signals.cpp",
    "b/ydb/core/formats/arrow/accessor/sub_columns/signals.h",
    "ydb/core/formats/arrow/accessor/sub_columns/ut/ut_sub_columns.cpp",
    "ydb/core/formats/arrow/accessor/sub_columns/ya.make",
    "ydb/core/formats/arrow/arrow_batch_builder.cpp",
    "ydb/core/formats/arrow/arrow_batch_builder.h",
    "ydb/core/formats/arrow/arrow_filter.cpp",
    "ydb/core/formats/arrow/arrow_filter.h",
    "ydb/core/formats/arrow/arrow_helpers.h",
    "ydb/core/formats/arrow/common/container.cpp",
    "ydb/core/formats/arrow/common/container.h",
    "ydb/core/formats/arrow/program/abstract.h",
    "ydb/core/formats/arrow/program/assign_internal.cpp",
    "ydb/core/formats/arrow/program/assign_internal.h",
    "ydb/core/formats/arrow/program/collection.cpp",
    "ydb/core/formats/arrow/program/collection.h",
    "ydb/core/formats/arrow/program/execution.h",
    "ydb/core/formats/arrow/program/filter.cpp",
    "ydb/core/formats/arrow/program/graph_execute.cpp",
    "ydb/core/formats/arrow/program/graph_optimization.cpp",
    "ydb/core/formats/arrow/program/graph_optimization.h",
    "ydb/core/formats/arrow/program/header.cpp",
    "ydb/core/formats/arrow/program/index.cpp",
    "ydb/core/formats/arrow/program/index.h",
    "ydb/core/formats/arrow/program/kernel_logic.cpp",
    "ydb/core/formats/arrow/program/kernel_logic.h",
    "ydb/core/formats/arrow/program/original.h",
    "ydb/core/formats/arrow/program/projection.cpp",
    "b/ydb/core/formats/arrow/program/reserve.cpp",
    "b/ydb/core/formats/arrow/program/reserve.h",
    "ydb/core/formats/arrow/program/stream_logic.cpp",
    "ydb/core/formats/arrow/program/stream_logic.h",
    "ydb/core/formats/arrow/program/ya.make",
    "ydb/core/formats/arrow/reader/merger.cpp",
    "ydb/core/formats/arrow/reader/merger.h",
    "ydb/core/formats/arrow/reader/position.cpp",
    "ydb/core/formats/arrow/reader/position.h",
    "ydb/core/formats/arrow/ssa_runtime_version.h",
    "ydb/core/formats/arrow/ut/ut_arrow.cpp",
    "ydb/core/formats/arrow/ut/ut_column_filter.cpp",
    "ydb/core/formats/arrow/ut/ut_program_step.cpp",
    "b/ydb/core/formats/arrow/ut/ut_reader.cpp",
    "ydb/core/formats/arrow/ut/ya.make",
    "ydb/core/grpc_services/rpc_load_rows.cpp",
    "ydb/core/kqp/common/buffer/buffer.h",
    "ydb/core/kqp/common/buffer/events.h",
    "ydb/core/kqp/common/kqp_data_integrity_trails.h",
    "ydb/core/kqp/common/kqp_tx.cpp",
    "ydb/core/kqp/common/kqp_tx.h",
    "ydb/core/kqp/common/kqp_tx_manager.cpp",
    "ydb/core/kqp/common/kqp_tx_manager.h",
    "ydb/core/kqp/common/kqp_yql.cpp",
    "ydb/core/kqp/common/kqp_yql.h",
    "ydb/core/kqp/common/simple/kqp_event_ids.h",
    "ydb/core/kqp/compute_actor/kqp_compute_actor_factory.cpp",
    "ydb/core/kqp/compute_actor/kqp_compute_events.h",
    "ydb/core/kqp/compute_actor/kqp_pure_compute_actor.cpp",
    "ydb/core/kqp/compute_actor/kqp_scan_compute_manager.cpp",
    "ydb/core/kqp/compute_actor/kqp_scan_compute_manager.h",
    "ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.cpp",
    "ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.h",
    "ydb/core/kqp/executer_actor/kqp_data_executer.cpp",
    "ydb/core/kqp/executer_actor/kqp_executer_impl.h",
    "ydb/core/kqp/executer_actor/kqp_executer_stats.cpp",
    "ydb/core/kqp/executer_actor/kqp_partition_helper.cpp",
    "ydb/core/kqp/executer_actor/kqp_partition_helper.h",
    "ydb/core/kqp/executer_actor/kqp_planner.cpp",
    "ydb/core/kqp/executer_actor/kqp_tasks_graph.cpp",
    "ydb/core/kqp/executer_actor/kqp_tasks_graph.h",
    "ydb/core/kqp/expr_nodes/kqp_expr_nodes.json",
    "ydb/core/kqp/gateway/kqp_ic_gateway.cpp",
    "ydb/core/kqp/host/kqp_gateway_proxy.cpp",
    "ydb/core/kqp/host/kqp_runner.cpp",
    "ydb/core/kqp/host/kqp_type_ann.cpp",
    "ydb/core/kqp/node_service/kqp_node_service.cpp",
    "ydb/core/kqp/opt/kqp_opt_kql.cpp",
    "ydb/core/kqp/opt/kqp_query_plan.cpp",
    "ydb/core/kqp/opt/kqp_query_plan.h",
    "ydb/core/kqp/opt/logical/kqp_opt_log_extract.cpp",
    "ydb/core/kqp/opt/logical/kqp_opt_log_indexes.cpp",
    "ydb/core/kqp/opt/physical/kqp_opt_phy.cpp",
    "ydb/core/kqp/opt/physical/kqp_opt_phy_limit.cpp",
    "ydb/core/kqp/opt/physical/kqp_opt_phy_olap_agg.cpp",
    "ydb/core/kqp/opt/physical/kqp_opt_phy_olap_filter.cpp",
    "ydb/core/kqp/opt/physical/kqp_opt_phy_rules.h",
    "ydb/core/kqp/opt/physical/kqp_opt_phy_sort.cpp",
    "ydb/core/kqp/opt/physical/predicate_collector.cpp",
    "ydb/core/kqp/opt/physical/predicate_collector.h",
    "ydb/core/kqp/provider/yql_kikimr_datasink.cpp",
    "ydb/core/kqp/provider/yql_kikimr_datasource.cpp",
    "ydb/core/kqp/provider/yql_kikimr_exec.cpp",
    "ydb/core/kqp/provider/yql_kikimr_expr_nodes.json",
    "ydb/core/kqp/provider/yql_kikimr_gateway.h",
    "ydb/core/kqp/provider/yql_kikimr_opt_build.cpp",
    "ydb/core/kqp/provider/yql_kikimr_provider.cpp",
    "ydb/core/kqp/provider/yql_kikimr_provider.h",
    "ydb/core/kqp/provider/yql_kikimr_provider_impl.h",
    "ydb/core/kqp/provider/yql_kikimr_settings.cpp",
    "ydb/core/kqp/provider/yql_kikimr_settings.h",
    "ydb/core/kqp/provider/yql_kikimr_type_ann.cpp",
    "ydb/core/kqp/query_compiler/kqp_mkql_compiler.cpp",
    "ydb/core/kqp/query_compiler/kqp_olap_compiler.cpp",
    "ydb/core/kqp/query_compiler/kqp_query_compiler.cpp",
    "ydb/core/kqp/query_data/kqp_query_data.cpp",
    "ydb/core/kqp/runtime/kqp_read_actor.cpp",
    "ydb/core/kqp/runtime/kqp_stream_lookup_actor.cpp",
    "ydb/core/kqp/runtime/kqp_write_actor.cpp",
    "ydb/core/kqp/runtime/kqp_write_actor_settings.h",
    "ydb/core/kqp/runtime/kqp_write_table.cpp",
    "ydb/core/kqp/runtime/kqp_write_table.h",
    "ydb/core/kqp/session_actor/kqp_query_state.h",
    "ydb/core/kqp/session_actor/kqp_session_actor.cpp",
    "ydb/core/kqp/ut/common/kqp_ut_common.cpp",
    "ydb/core/kqp/ut/common/kqp_ut_common.h",
    "ydb/core/kqp/ut/data_integrity/kqp_data_integrity_trails_ut.cpp",
    "ydb/core/kqp/ut/effects/kqp_effects_ut.cpp",
    "ydb/core/kqp/ut/effects/kqp_immediate_effects_ut.cpp",
    "ydb/core/kqp/ut/effects/kqp_inplace_update_ut.cpp",
    "ydb/core/kqp/ut/effects/kqp_write_ut.cpp",
    "ydb/core/kqp/ut/indexes/kqp_indexes_multishard_ut.cpp",
    "ydb/core/kqp/ut/indexes/kqp_indexes_ut.cpp",
    "ydb/core/kqp/ut/olap/aggregations_ut.cpp",
    "ydb/core/kqp/ut/olap/blobs_sharing_ut.cpp",
    "ydb/core/kqp/ut/olap/helpers/get_value.cpp",
    "ydb/core/kqp/ut/olap/indexes_ut.cpp",
    "ydb/core/kqp/ut/olap/json_ut.cpp",
    "ydb/core/kqp/ut/olap/kqp_olap_ut.cpp",
    "ydb/core/kqp/ut/opt/kqp_ne_ut.cpp",
    "ydb/core/kqp/ut/opt/kqp_not_null_ut.cpp",
    "ydb/core/kqp/ut/opt/kqp_ranges_ut.cpp",
    "ydb/core/kqp/ut/perf/kqp_query_perf_ut.cpp",
    "ydb/core/kqp/ut/pg/pg_catalog_ut.cpp",
    "ydb/core/kqp/ut/query/kqp_explain_ut.cpp",
    "ydb/core/kqp/ut/query/kqp_limits_ut.cpp",
    "ydb/core/kqp/ut/query/kqp_params_ut.cpp",
    "ydb/core/kqp/ut/query/kqp_query_ut.cpp",
    "ydb/core/kqp/ut/query/kqp_stats_ut.cpp",
    "ydb/core/kqp/ut/scheme/kqp_acl_ut.cpp",
    "ydb/core/kqp/ut/scheme/kqp_scheme_ut.cpp",
    "ydb/core/kqp/ut/service/kqp_qs_queries_ut.cpp",
    "ydb/core/kqp/ut/tx/kqp_locks_ut.cpp",
    "ydb/core/kqp/ut/tx/kqp_sink_tx_ut.cpp",
    "ydb/core/kqp/ut/tx/kqp_tx_ut.cpp",
    "ydb/core/kqp/ut/yql/kqp_yql_ut.cpp",
    "ydb/core/protos/data_events.proto",
    "ydb/core/protos/feature_flags.proto",
    "ydb/core/protos/flat_scheme_op.proto",
    "ydb/core/protos/index_builder.proto",
    "ydb/core/protos/kqp.proto",
    "ydb/core/protos/table_service_config.proto",
    "ydb/core/protos/tx_datashard.proto",
    "ydb/core/scheme/scheme_tablecell.cpp",
    "ydb/core/scheme/scheme_tablecell.h",
    "ydb/core/tx/columnshard/blob_cache.cpp",
    "ydb/core/tx/columnshard/blob_cache.h",
    "ydb/core/tx/columnshard/blobs_action/counters/read.h",
    "ydb/core/tx/columnshard/blobs_action/counters/remove_declare.h",
    "ydb/core/tx/columnshard/blobs_action/counters/remove_gc.h",
    "ydb/core/tx/columnshard/blobs_action/counters/storage.h",
    "ydb/core/tx/columnshard/blobs_action/counters/write.h",
    "ydb/core/tx/columnshard/blobs_action/tier/adapter.cpp",
    "ydb/core/tx/columnshard/blobs_action/transaction/tx_blobs_written.cpp",
    "ydb/core/tx/columnshard/blobs_action/transaction/tx_blobs_written.h",
    "ydb/core/tx/columnshard/blobs_reader/actor.cpp",
    "ydb/core/tx/columnshard/blobs_reader/read_coordinator.cpp",
    "ydb/core/tx/columnshard/blobs_reader/task.h",
    "ydb/core/tx/columnshard/columnshard__propose_transaction.cpp",
    "ydb/core/tx/columnshard/columnshard__write.cpp",
    "ydb/core/tx/columnshard/columnshard_impl.cpp",
    "ydb/core/tx/columnshard/columnshard_impl.h",
    "ydb/core/tx/columnshard/common/limits.h",
    "ydb/core/tx/columnshard/common/snapshot.cpp",
    "ydb/core/tx/columnshard/common/snapshot.h",
    "ydb/core/tx/columnshard/counters/blobs_manager.h",
    "ydb/core/tx/columnshard/counters/columnshard.cpp",
    "ydb/core/tx/columnshard/counters/columnshard.h",
    "ydb/core/tx/columnshard/counters/common_data.h",
    "ydb/core/tx/columnshard/counters/counters_manager.h",
    "ydb/core/tx/columnshard/counters/engine_logs.h",
    "ydb/core/tx/columnshard/counters/indexation.h",
    "ydb/core/tx/columnshard/counters/initialization.h",
    "ydb/core/tx/columnshard/counters/insert_table.h",
    "ydb/core/tx/columnshard/counters/portions.h",
    "ydb/core/tx/columnshard/counters/req_tracer.h",
    "ydb/core/tx/columnshard/counters/scan.cpp",
    "ydb/core/tx/columnshard/counters/scan.h",
    "ydb/core/tx/columnshard/counters/splitter.h",
    "ydb/core/tx/columnshard/counters/sub_columns.h",
    "ydb/core/tx/columnshard/counters/tx_progress.h",
    "ydb/core/tx/columnshard/counters/ya.make",
    "ydb/core/tx/columnshard/data_accessor/request.h",
    "ydb/core/tx/columnshard/engines/changes/abstract/ya.make",
    "ydb/core/tx/columnshard/engines/changes/compaction/sub_columns/ya.make",
    "ydb/core/tx/columnshard/engines/changes/counters/changes.h",
    "ydb/core/tx/columnshard/engines/changes/counters/general.h",
    "ydb/core/tx/columnshard/engines/changes/counters/ya.make",
    "ydb/core/tx/columnshard/engines/portions/data_accessor.cpp",
    "ydb/core/tx/columnshard/engines/portions/data_accessor.h",
    "ydb/core/tx/columnshard/engines/portions/meta.h",
    "ydb/core/tx/columnshard/engines/predicate/container.cpp",
    "ydb/core/tx/columnshard/engines/predicate/container.h",
    "ydb/core/tx/columnshard/engines/predicate/filter.cpp",
    "ydb/core/tx/columnshard/engines/predicate/filter.h",
    "ydb/core/tx/columnshard/engines/predicate/range.cpp",
    "ydb/core/tx/columnshard/engines/predicate/range.h",
    "ydb/core/tx/columnshard/engines/reader/abstract/abstract.h",
    "ydb/core/tx/columnshard/engines/reader/abstract/constructor.cpp",
    "ydb/core/tx/columnshard/engines/reader/abstract/constructor.h",
    "ydb/core/tx/columnshard/engines/reader/abstract/read_context.h",
    "ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.h",
    "ydb/core/tx/columnshard/engines/reader/actor/actor.cpp",
    "ydb/core/tx/columnshard/engines/reader/actor/actor.h",
    "ydb/core/tx/columnshard/engines/reader/common/conveyor_task.cpp",
    "ydb/core/tx/columnshard/engines/reader/common/conveyor_task.h",
    "ydb/core/tx/columnshard/engines/reader/common/description.h",
    "ydb/core/tx/columnshard/engines/reader/common/result.cpp",
    "ydb/core/tx/columnshard/engines/reader/common/result.h",
    "ydb/core/tx/columnshard/engines/reader/common/ya.make",
    "ydb/core/tx/columnshard/engines/reader/common_reader/constructor/read_metadata.cpp",
    "ydb/core/tx/columnshard/engines/reader/common_reader/iterator/columns_set.h",
    "ydb/core/tx/columnshard/engines/reader/common_reader/iterator/constructor.cpp",
    "ydb/core/tx/columnshard/engines/reader/common_reader/iterator/default_fetching.h",
    "ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.cpp",
    "ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.h",
    "ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetched_data.h",
    "ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetching.cpp",
    "ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetching.h",
    "ydb/core/tx/columnshard/engines/reader/common_reader/iterator/iterator.cpp",
    "ydb/core/tx/columnshard/engines/reader/common_reader/iterator/iterator.h",
    "ydb/core/tx/columnshard/engines/reader/common_reader/iterator/source.h",
    "ydb/core/tx/columnshard/engines/reader/common_reader/iterator/sub_columns_fetching.h",
    "ydb/core/tx/columnshard/engines/reader/common_reader/iterator/ya.make",
    "ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/constructor.cpp",
    "ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.cpp",
    "ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.h",
    "ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.cpp",
    "ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.h",
    "ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/interval.cpp",
    "ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/merge.cpp",
    "ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/plain_read_data.h",
    "ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.cpp",
    "ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.h",
    "ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.cpp",
    "ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.h",
    "ydb/core/tx/columnshard/engines/reader/simple_reader/constructor/constructor.cpp",
    "ydb/core/tx/columnshard/engines/reader/simple_reader/constructor/constructor.h",
    "b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/abstract.cpp",
    "b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/abstract.h",
    "b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/full_scan_sorted.cpp",
    "b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/full_scan_sorted.h",
    "b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/limit_sorted.cpp",
    "b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/limit_sorted.h",
    "b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/not_sorted.cpp",
    "b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/not_sorted.h",
    "b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/ya.make",
    "ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.cpp",
    "ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.h",
    "ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/fetching.cpp",
    "ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/fetching.h",
    "ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.cpp",
    "ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.h",
    "ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/scanner.cpp",
    "ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/scanner.h",
    "ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.cpp",
    "ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.h",
    "b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/abstract.cpp",
    "b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/abstract.h",
    "b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/limit.cpp",
    "b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/limit.h",
    "b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/result.cpp",
    "b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/result.h",
    "b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/ya.make",
    "ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/ya.make",
    "ydb/core/tx/columnshard/engines/reader/sys_view/abstract/iterator.cpp",
    "ydb/core/tx/columnshard/engines/reader/sys_view/abstract/metadata.h",
    "ydb/core/tx/columnshard/engines/reader/sys_view/chunks/chunks.cpp",
    "ydb/core/tx/columnshard/engines/reader/sys_view/granules/granules.cpp",
    "ydb/core/tx/columnshard/engines/reader/sys_view/optimizer/optimizer.cpp",
    "ydb/core/tx/columnshard/engines/reader/sys_view/portions/portions.cpp",
    "ydb/core/tx/columnshard/engines/reader/transaction/tx_internal_scan.cpp",
    "ydb/core/tx/columnshard/engines/reader/transaction/tx_scan.cpp",
    "ydb/core/tx/columnshard/engines/scheme/index_info.cpp",
    "ydb/core/tx/columnshard/engines/scheme/index_info.h",
    "ydb/core/tx/columnshard/engines/scheme/indexes/abstract/collection.cpp",
    "ydb/core/tx/columnshard/engines/scheme/indexes/abstract/collection.h",
    "ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.cpp",
    "ydb/core/tx/columnshard/engines/storage/actualizer/counters/counters.h",
    "ydb/core/tx/columnshard/engines/storage/actualizer/counters/ya.make",
    "ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/abstract.h",
    "ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/bitset.h",
    "ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/string.cpp",
    "ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.cpp",
    "ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.h",
    "ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/constructor.cpp",
    "ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/constructor.h",
    "ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/meta.cpp",
    "ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/meta.h",
    "ydb/core/tx/columnshard/engines/storage/indexes/categories_bloom/meta.cpp",
    "ydb/core/tx/columnshard/engines/storage/indexes/categories_bloom/meta.h",
    "ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/abstract.h",
    "ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/default.cpp",
    "ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/default.h",
    "ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/sub_column.h",
    "ydb/core/tx/columnshard/engines/storage/indexes/skip_index/meta.h",
    "ydb/core/tx/columnshard/engines/storage/optimizer/abstract/optimizer.h",
    "ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/constructor/zero_level.cpp",
    "ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/constructor/zero_level.h",
    "ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/abstract.h",
    "ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/optimizer.cpp",
    "ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/optimizer.h",
    "ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/zero_level.cpp",
    "ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/zero_level.h",
    "ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/counters/counters.h",
    "ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/counters/ya.make",
    "ydb/core/tx/columnshard/engines/ut/ut_logs_engine.cpp",
    "ydb/core/tx/columnshard/engines/ut/ut_script.cpp",
    "ydb/core/tx/columnshard/engines/writer/buffer/actor2.cpp",
    "ydb/core/tx/columnshard/engines/writer/indexed_blob_constructor.h",
    "ydb/core/tx/columnshard/normalizer/portion/chunks.cpp",
    "ydb/core/tx/columnshard/operations/batch_builder/builder.cpp",
    "ydb/core/tx/columnshard/operations/batch_builder/builder.h",
    "ydb/core/tx/columnshard/operations/batch_builder/merger.h",
    "ydb/core/tx/columnshard/operations/batch_builder/restore.cpp",
    "ydb/core/tx/columnshard/operations/events.h",
    "ydb/core/tx/columnshard/operations/slice_builder/builder.cpp",
    "ydb/core/tx/columnshard/operations/slice_builder/builder.h",
    "ydb/core/tx/columnshard/operations/slice_builder/pack_builder.cpp",
    "ydb/core/tx/columnshard/operations/slice_builder/pack_builder.h",
    "ydb/core/tx/columnshard/operations/write.cpp",
    "ydb/core/tx/columnshard/operations/write.h",
    "ydb/core/tx/columnshard/resource_subscriber/counters.h",
    "ydb/core/tx/columnshard/resource_subscriber/task.h",
    "ydb/core/tx/columnshard/resources/memory.h",
    "ydb/core/tx/columnshard/tablet/write_queue.cpp",
    "ydb/core/tx/columnshard/tablet/write_queue.h",
    "ydb/core/tx/columnshard/transactions/locks/read_start.cpp",
    "ydb/core/tx/columnshard/transactions/tx_controller.cpp",
    "ydb/core/tx/columnshard/transactions/tx_controller.h",
    "ydb/core/tx/columnshard/ut_rw/ut_backup.cpp",
    "ydb/core/tx/columnshard/ut_rw/ut_columnshard_read_write.cpp",
    "ydb/core/tx/columnshard/ut_rw/ut_normalizer.cpp",
    "ydb/core/tx/columnshard/ut_schema/ut_columnshard_schema.cpp",
    "ydb/core/tx/conveyor/service/service.cpp",
    "ydb/core/tx/conveyor/service/service.h",
    "ydb/core/tx/conveyor/service/worker.cpp",
    "ydb/core/tx/conveyor/usage/abstract.cpp",
    "ydb/core/tx/conveyor/usage/abstract.h",
    "ydb/core/tx/data_events/common/error_codes.cpp",
    "ydb/core/tx/data_events/common/signals_flow.cpp",
    "ydb/core/tx/data_events/common/signals_flow.h",
    "ydb/core/tx/data_events/events.h",
    "ydb/core/tx/data_events/shard_writer.cpp",
    "ydb/core/tx/data_events/shard_writer.h",
    "ydb/core/tx/data_events/write_data.cpp",
    "ydb/core/tx/data_events/write_data.h",
    "ydb/core/tx/datashard/check_write_unit.cpp",
    "ydb/core/tx/datashard/datashard.h",
    "ydb/core/tx/datashard/datashard__read_iterator.cpp",
    "ydb/core/tx/datashard/datashard_impl.h",
    "ydb/core/tx/datashard/datashard_integrity_trails.h",
    "ydb/core/tx/datashard/datashard_ut_change_exchange.cpp",
    "ydb/core/tx/datashard/datashard_ut_kqp_errors.cpp",
    "ydb/core/tx/datashard/datashard_ut_locks.cpp",
    "ydb/core/tx/datashard/datashard_ut_order.cpp",
    "b/ydb/core/tx/datashard/datashard_ut_prefix_kmeans.cpp",
    "ydb/core/tx/datashard/datashard_ut_read_iterator.cpp",
    "ydb/core/tx/datashard/datashard_ut_replication.cpp",
    "ydb/core/tx/datashard/datashard_ut_rs.cpp",
    "ydb/core/tx/datashard/datashard_ut_snapshot.cpp",
    "ydb/core/tx/datashard/datashard_ut_trace.cpp",
    "ydb/core/tx/datashard/datashard_ut_volatile.cpp",
    "ydb/core/tx/datashard/datashard_ut_write.cpp",
    "ydb/core/tx/datashard/execute_data_tx_unit.cpp",
    "ydb/core/tx/datashard/execute_kqp_data_tx_unit.cpp",
    "ydb/core/tx/datashard/execute_write_unit.cpp",
    "ydb/core/tx/datashard/kmeans_helper.cpp",
    "ydb/core/tx/datashard/kmeans_helper.h",
    "b/ydb/core/tx/datashard/prefix_kmeans.cpp",
    "ydb/core/tx/datashard/ut_common/datashard_ut_common.cpp",
    "ydb/core/tx/datashard/ut_common/datashard_ut_common.h",
    "b/ydb/core/tx/datashard/ut_prefix_kmeans/ya.make",
    "ydb/core/tx/datashard/ya.make",
    "ydb/core/tx/limiter/grouped_memory/service/allocation.h",
    "ydb/core/tx/limiter/grouped_memory/service/counters.h",
    "ydb/core/tx/limiter/grouped_memory/service/group.h",
    "ydb/core/tx/limiter/grouped_memory/service/process.h",
    "ydb/core/tx/limiter/grouped_memory/service/ya.make",
    "ydb/core/tx/limiter/service/service.h",
    "ydb/core/tx/limiter/usage/abstract.h",
    "ydb/core/tx/locks/locks.cpp",
    "ydb/core/tx/locks/locks.h",
    "ydb/core/tx/priorities/service/counters.h",
    "ydb/core/tx/program/builder.cpp",
    "ydb/core/tx/program/builder.h",
    "ydb/core/tx/program/program.cpp",
    "ydb/core/tx/schemeshard/olap/column_families/schema.cpp",
    "ydb/core/tx/schemeshard/olap/column_families/schema.h",
    "ydb/core/tx/schemeshard/olap/columns/schema.cpp",
    "ydb/core/tx/schemeshard/olap/columns/schema.h",
    "ydb/core/tx/schemeshard/olap/indexes/schema.cpp",
    "ydb/core/tx/schemeshard/olap/indexes/schema.h",
    "ydb/core/tx/schemeshard/olap/operations/create_table.cpp",
    "ydb/core/tx/schemeshard/olap/options/schema.cpp",
    "ydb/core/tx/schemeshard/olap/options/schema.h",
    "ydb/core/tx/schemeshard/olap/schema/schema.cpp",
    "ydb/core/tx/schemeshard/olap/schema/schema.h",
    "ydb/core/tx/schemeshard/olap/store/store.h",
    "ydb/core/tx/schemeshard/schemeshard__operation_modify_acl.cpp",
    "ydb/core/tx/schemeshard/schemeshard_build_index.cpp",
    "ydb/core/tx/schemeshard/schemeshard_build_index__create.cpp",
    "ydb/core/tx/schemeshard/schemeshard_build_index__progress.cpp",
    "ydb/core/tx/schemeshard/schemeshard_impl.cpp",
    "ydb/core/tx/schemeshard/schemeshard_impl.h",
    "ydb/core/tx/schemeshard/schemeshard_info_types.cpp",
    "ydb/core/tx/schemeshard/schemeshard_info_types.h",
    "ydb/core/tx/schemeshard/schemeshard_path.cpp",
    "ydb/core/tx/schemeshard/schemeshard_path.h",
    "ydb/core/tx/schemeshard/schemeshard_path_describer.cpp",
    "ydb/core/tx/schemeshard/schemeshard_utils.cpp",
    "ydb/core/tx/schemeshard/schemeshard_utils.h",
    "ydb/core/tx/schemeshard/ut_base/ut_base.cpp",
    "ydb/core/tx/schemeshard/ut_helpers/helpers.cpp",
    "ydb/core/tx/schemeshard/ut_helpers/helpers.h",
    "ydb/core/tx/schemeshard/ut_helpers/ls_checks.h",
    "ydb/core/tx/schemeshard/ut_olap/ut_olap.cpp",
    "ydb/core/tx/sharding/sharding.cpp",
    "ydb/core/tx/sharding/sharding.h",
    "ydb/core/tx/tx_proxy/rpc_long_tx.cpp",
    "ydb/core/tx/tx_proxy/upload_rows.cpp",
    "ydb/core/tx/tx_proxy/upload_rows_common_impl.h",
    "ydb/core/tx/tx_proxy/upload_rows_counters.h",
    "ydb/core/ydb_convert/table_description.cpp",
    "ydb/docs/en/core/yql/reference/_includes/permissions_list.md",
    "ydb/docs/ru/core/yql/reference/_includes/permissions_list.md",
    "ydb/library/accessor/positive_integer.cpp",
    "ydb/library/accessor/positive_integer.h",
    "ydb/library/conclusion/generic/string_status.h",
    "ydb/library/formats/arrow/arrow_helpers.cpp",
    "ydb/library/formats/arrow/arrow_helpers.h",
    "ydb/library/formats/arrow/protos/accessor.proto",
    "ydb/library/formats/arrow/replace_key.h",
    "ydb/library/formats/arrow/simple_arrays_cache.h",
    "b/ydb/library/signal_backtrace/signal_backtrace.cpp",
    "b/ydb/library/signal_backtrace/signal_backtrace.h",
    "b/ydb/library/signal_backtrace/ya.make",
    "ydb/library/wilson_ids/wilson.h",
    "ydb/library/ya.make",
    "ydb/library/yql/dq/actors/compute/dq_compute_actor_impl.h",
    "ydb/library/yql/dq/actors/dq.cpp",
    "ydb/library/yql/dq/actors/dq.h",
    "ydb/library/yql/dq/runtime/dq_tasks_runner.cpp",
    "ydb/services/persqueue_v1/ut/topic_service_ut.cpp",
    "ydb/services/ydb/backup_ut/ydb_backup_ut.cpp",
    "ydb/services/ydb/ydb_common_ut.h",
    "ydb/services/ydb/ydb_table_ut.cpp",
    "ydb/services/ydb/ydb_ut.cpp",
    "yql/essentials/types/binary_json/read.cpp",
    "yql/essentials/types/binary_json/read.h"
  ],
  "modified_test_files": [
    "ydb/core/tx/columnshard/hooks/testing/ro_controller.h",
    "ydb/core/tx/columnshard/test_helper/columnshard_ut_common.cpp",
    "ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h",
    "ydb/core/tx/columnshard/test_helper/shard_reader.h",
    "ydb/core/tx/columnshard/test_helper/shard_writer.cpp",
    "ydb/core/tx/columnshard/test_helper/shard_writer.h",
    "b/ydb/core/tx/columnshard/test_helper/test_combinator.h",
    "ydb/tests/functional/api/test_insert.py",
    "ydb/tests/functional/api/test_isolation.py",
    "ydb/tests/functional/api/ya.make",
    "ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_dynumber_insert_from_table.sql-plan_/dynumber_insert_from_table.sql.plan",
    "ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_dynumber_insert_literal.sql-plan_/dynumber_insert_literal.sql.plan",
    "ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_dynumber_insert_params.sql-plan_/dynumber_insert_params.sql.plan",
    "ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_explain.script-script_/explain.script.plan",
    "ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_join_group_by_lookup.script-script_/join_group_by_lookup.script.plan",
    "ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_json_insert_from_table.sql-plan_/json_insert_from_table.sql.plan",
    "ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_json_insert_literal.sql-plan_/json_insert_literal.sql.plan",
    "ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_json_insert_params.sql-plan_/json_insert_params.sql.plan",
    "ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_simple_ct.script-script_/simple_ct.script.plan",
    "ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_table_types.script-script_/table_types.script.plan",
    "ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_insert.sql-plan_/write_insert.sql.plan",
    "ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_insert_revert.sql-plan_/write_insert_revert.sql.plan",
    "ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_multi_usage.script-script_/write_multi_usage.script.plan",
    "ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_multi_usage_key.script-script_/write_multi_usage_key.script.plan",
    "ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_multi_write.sql-plan_/write_multi_write.sql.plan",
    "ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_replace.sql-plan_/write_replace.sql.plan",
    "ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_update.sql-plan_/write_update.sql.plan",
    "ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_update_on.sql-plan_/write_update_on.sql.plan",
    "ydb/tests/functional/canonical/canondata/test_sql.TestCanonicalFolder1.test_case_write_write_group_by.script-script_/write_write_group_by.script.plan",
    "ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-0",
    "ydb/tests/functional/clickbench/canondata/test.test_plans_column_/queries-original-plan-column-40",
    "b/ydb/tests/functional/compatibility/test_stress.py",
    "ydb/tests/functional/compatibility/ya.make",
    "ydb/tests/olap/ya.make",
    "b/ydb/tests/olap/zip_bomb.py"
  ]
}