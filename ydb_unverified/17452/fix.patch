diff --git a/.github/config/muted_ya.txt b/.github/config/muted_ya.txt
index 32c1efeb9123..8c1ac1272637 100644
--- a/.github/config/muted_ya.txt
+++ b/.github/config/muted_ya.txt
@@ -20,25 +20,6 @@ ydb/core/keyvalue/ut_trace TKeyValueTracingTest.WriteSmall
 ydb/core/kqp/ut/cost KqpCost.OlapWriteRow
 ydb/core/kqp/ut/olap KqpDecimalColumnShard.TestAggregation
 ydb/core/kqp/ut/olap KqpDecimalColumnShard.TestFilterCompare
-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.BlobsSharingSplit1_1
-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.BlobsSharingSplit1_1_clean
-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.BlobsSharingSplit1_1_clean_with_restarts
-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.BlobsSharingSplit1_3_1
-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.BlobsSharingSplit1_3_2_1_clean
-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.BlobsSharingSplit3_1
-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.ChangeSchemaAndSplit
-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.HugeSchemeHistory
-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.MultipleMerge
-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.MultipleMergesWithRestartsAfterWait
-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.MultipleMergesWithRestartsWhenWait
-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.MultipleSchemaVersions
-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.MultipleSplits
-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.MultipleSplitsThenMerges
-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.MultipleSplitsWithRestartsAfterWait
-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.MultipleSplitsWithRestartsWhenWait
-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.TableReshardingConsistency64
-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.TableReshardingModuloN
-ydb/core/kqp/ut/olap KqpOlapBlobsSharing.UpsertWhileSplitTest
 ydb/core/kqp/ut/olap KqpOlapJson.BloomIndexesVariants
 ydb/core/kqp/ut/olap KqpOlapSysView.StatsSysViewBytesDictActualization
 ydb/core/kqp/ut/olap KqpOlapSysView.StatsSysViewBytesDictStatActualization
@@ -47,6 +28,9 @@ ydb/core/kqp/ut/olap [*/*] chunk chunk
 ydb/core/kqp/ut/query KqpAnalyze.AnalyzeTable+ColumnStore
 ydb/core/kqp/ut/query KqpAnalyze.AnalyzeTable-ColumnStore
 ydb/core/kqp/ut/query KqpStats.SysViewClientLost
+ydb/core/kqp/ut/query KqpLimits.OutOfSpaceYQLUpsertFail+useSink
+ydb/core/kqp/ut/query KqpLimits.QSReplySizeEnsureMemoryLimits+useSink
+ydb/core/kqp/ut/query KqpStats.SysViewClientLost
 ydb/core/kqp/ut/scheme KqpOlapScheme.TenThousandColumns
 ydb/core/kqp/ut/scheme KqpScheme.AlterAsyncReplication
 ydb/core/kqp/ut/scheme [*/*] chunk chunk
@@ -163,6 +147,13 @@ ydb/tests/functional/tpc/large test_tpcds.py.TestTpcdsS1.test_tpcds[36]
 ydb/tests/functional/tpc/large test_tpcds.py.TestTpcdsS1.test_tpcds[67]
 ydb/tests/functional/tpc/large test_tpcds.py.TestTpcdsS1.test_tpcds[86]
 ydb/tests/functional/tpc/large test_tpcds.py.TestTpcdsS1.test_tpcds[9]
+ydb/tests/functional/tpc/large test_tpch_spilling.py.TestTpchSpillingS10.test_tpch[7]
+ydb/tests/olap sole chunk chunk
+ydb/tests/olap test_quota_exhaustion.py.TestYdbWorkload.test_delete
+ydb/tests/olap/data_quotas test_quota_exhaustion.py.TestYdbWorkload.test_duplicates
+ydb/tests/olap/column_family/compression alter_compression.py.TestAlterCompression.test_all_supported_compression
+ydb/tests/olap/column_family/compression sole chunk chunk
+ydb/tests/olap/oom overlapping_portions.py.TestOverlappingPortions.test
 ydb/tests/olap/scenario sole chunk chunk
 ydb/tests/olap/scenario test_alter_compression.py.TestAlterCompression.test[alter_compression]
 ydb/tests/olap/scenario test_alter_tiering.py.TestAlterTiering.test[many_tables]
@@ -172,6 +163,7 @@ ydb/tests/olap/ttl_tiering data_migration_when_alter_ttl.py.TestDataMigrationWhe
 ydb/tests/olap/ttl_tiering sole chunk chunk
 ydb/tests/olap/ttl_tiering ttl_delete_s3.py.TestDeleteS3Ttl.test_data_unchanged_after_ttl_change
 ydb/tests/olap/ttl_tiering ttl_delete_s3.py.TestDeleteS3Ttl.test_ttl_delete
+ydb/tests/olap/ttl_tiering ttl_delete_s3.py.TestDeleteS3Ttl.test_delete_s3_tiering
 ydb/tests/olap/ttl_tiering ttl_unavailable_s3.py.TestUnavailableS3.test
 ydb/tests/olap/ttl_tiering ttl_delete_s3.py.TestDeleteS3Ttl.test_delete_s3_tiering
 ydb/tests/olap/ttl_tiering unstable_connection.py.TestUnstableConnection.test
diff --git a/ydb/core/driver_lib/run/run.cpp b/ydb/core/driver_lib/run/run.cpp
index 30b9e40eb53c..4dfdb3a4e4a2 100644
--- a/ydb/core/driver_lib/run/run.cpp
+++ b/ydb/core/driver_lib/run/run.cpp
@@ -149,6 +149,7 @@
 #include <ydb/library/actors/util/memory_track.h>
 #include <ydb/library/actors/prof/tag.h>
 #include <ydb/library/security/ydb_credentials_provider_factory.h>
+#include <ydb/library/signal_backtrace/signal_backtrace.h>
 #include <yql/essentials/minikql/invoke_builtins/mkql_builtins.h>
 
 #include <util/charset/wide.h>
@@ -1939,6 +1940,10 @@ void TKikimrRunner::SetSignalHandlers() {
     signal(SIGINT, &TKikimrRunner::OnTerminate);
     signal(SIGTERM, &TKikimrRunner::OnTerminate);
 
+    if (IsTrue(GetEnv("YDB_ENABLE_SIGNAL_BACKTRACE"))) {
+        Singleton<TTraceCollector>(TTraceCollector::DEFAULT_SIGNALS);
+    }
+
 #if !defined(_win_)
     SetAsyncSignalHandler(SIGHUP, [](int) {
         TLogBackend::ReopenAllBackends();
diff --git a/ydb/core/driver_lib/run/ya.make b/ydb/core/driver_lib/run/ya.make
index 3be3072c6751..c1027bcef99f 100644
--- a/ydb/core/driver_lib/run/ya.make
+++ b/ydb/core/driver_lib/run/ya.make
@@ -138,6 +138,7 @@ PEERDIR(
     ydb/library/grpc/server/actors
     ydb/library/pdisk_io
     ydb/library/security
+    ydb/library/signal_backtrace
     ydb/library/yql/providers/pq/cm_client
     ydb/library/yql/providers/s3/actors
     ydb/public/lib/base
diff --git a/ydb/core/formats/arrow/accessor/abstract/accessor.cpp b/ydb/core/formats/arrow/accessor/abstract/accessor.cpp
index b1221c1bf8b6..152bae082d2e 100644
--- a/ydb/core/formats/arrow/accessor/abstract/accessor.cpp
+++ b/ydb/core/formats/arrow/accessor/abstract/accessor.cpp
@@ -24,26 +24,7 @@ std::shared_ptr<arrow::Array> IChunkedArray::TReader::CopyRecord(const ui64 reco
 }
 
 std::shared_ptr<arrow::ChunkedArray> IChunkedArray::Slice(const ui32 offset, const ui32 count) const {
-    AFL_VERIFY(offset + count <= (ui64)GetRecordsCount())("offset", offset)("count", count)("length", GetRecordsCount());
-    ui32 currentOffset = offset;
-    ui32 countLeast = count;
-    std::vector<std::shared_ptr<arrow::Array>> chunks;
-    auto address = GetChunkSlow(offset);
-    while (countLeast) {
-        address = GetChunk(address.GetAddress(), currentOffset);
-        const ui64 internalPos = address.GetAddress().GetLocalIndex(currentOffset);
-        if (internalPos + countLeast <= (ui64)address.GetArray()->length()) {
-            chunks.emplace_back(address.GetArray()->Slice(internalPos, countLeast));
-            break;
-        } else {
-            const ui32 deltaCount = address.GetArray()->length() - internalPos;
-            chunks.emplace_back(address.GetArray()->Slice(internalPos, deltaCount));
-            AFL_VERIFY(countLeast >= deltaCount);
-            countLeast -= deltaCount;
-            currentOffset += deltaCount;
-        }
-    }
-    return std::make_shared<arrow::ChunkedArray>(chunks, DataType);
+    return GetChunkedArray(TColumnConstructionContext().SetStartIndex(offset).SetRecordsCount(count));
 }
 
 IChunkedArray::TFullDataAddress IChunkedArray::GetChunk(const std::optional<TAddressChain>& chunkCurrent, const ui64 position) const {
@@ -62,10 +43,10 @@ IChunkedArray::TFullDataAddress IChunkedArray::GetChunk(const std::optional<TAdd
         return TFullDataAddress(localAddress.GetArray(), std::move(addressChain));
     } else {
         auto chunkedArrayAddress = GetArray(chunkCurrent, position, nullptr);
-        if (chunkCurrent) {
-            AFL_VERIFY(chunkCurrent->GetSize() == 1 + chunkedArrayAddress.GetAddress().GetSize())("current", chunkCurrent->GetSize())(
-                                                      "chunked", chunkedArrayAddress.GetAddress().GetSize());
-        }
+        //        if (chunkCurrent) {
+        //            AFL_VERIFY(chunkCurrent->GetSize() == chunkedArrayAddress.GetAddress().GetSize())("current", chunkCurrent->GetSize())(
+        //                                                      "chunked", chunkedArrayAddress.GetAddress().GetSize());
+        //        }
         auto localAddress = chunkedArrayAddress.GetArray()->GetLocalData(address, chunkedArrayAddress.GetAddress().GetLocalIndex(position));
         auto fullAddress = std::move(chunkedArrayAddress.MutableAddress());
         fullAddress.Add(localAddress.GetAddress());
@@ -112,7 +93,7 @@ std::shared_ptr<IChunkedArray> IChunkedArray::DoApplyFilter(const TColumnFilter&
     auto schema = std::make_shared<arrow::Schema>(fields);
     auto table = arrow::Table::Make(schema, { arr }, GetRecordsCount());
     AFL_VERIFY(table->num_columns() == 1);
-    AFL_VERIFY(filter.Apply(table));
+    filter.Apply(table);
     if (table->column(0)->num_chunks() == 1) {
         return std::make_shared<TTrivialArray>(table->column(0)->chunk(0));
     } else {
@@ -121,8 +102,8 @@ std::shared_ptr<IChunkedArray> IChunkedArray::DoApplyFilter(const TColumnFilter&
 }
 
 std::shared_ptr<IChunkedArray> IChunkedArray::ApplyFilter(const TColumnFilter& filter, const std::shared_ptr<IChunkedArray>& selfPtr) const {
-    AFL_VERIFY(selfPtr);
     if (filter.IsTotalAllowFilter()) {
+        AFL_VERIFY(selfPtr);
         return selfPtr;
     }
     if (filter.IsTotalDenyFilter()) {
@@ -134,7 +115,7 @@ std::shared_ptr<IChunkedArray> IChunkedArray::ApplyFilter(const TColumnFilter& f
     return result;
 }
 
-std::shared_ptr<arrow::ChunkedArray> IChunkedArray::GetChunkedArray() const {
+std::shared_ptr<arrow::ChunkedArray> IChunkedArray::GetChunkedArrayTrivial() const {
     std::vector<std::shared_ptr<arrow::Array>> chunks;
     std::optional<TFullDataAddress> address;
     for (ui32 position = 0; position < GetRecordsCount();) {
@@ -145,6 +126,23 @@ std::shared_ptr<arrow::ChunkedArray> IChunkedArray::GetChunkedArray() const {
     return std::make_shared<arrow::ChunkedArray>(chunks, GetDataType());
 }
 
+std::shared_ptr<arrow::ChunkedArray> IChunkedArray::GetChunkedArray(const TColumnConstructionContext& context) const {
+    if (context.GetStartIndex() || context.GetRecordsCount()) {
+        const ui32 start = context.GetStartIndex().value_or(0);
+        const ui32 count = context.GetRecordsCount().value_or(GetRecordsCount() - start);
+        auto slice = ISlice(start, count);
+        if (context.GetFilter() && !context.GetFilter()->IsTotalAllowFilter()) {
+            return slice->ApplyFilter(context.GetFilter()->Slice(start, count), slice)->GetChunkedArrayTrivial();
+        } else {
+            return slice->GetChunkedArrayTrivial();
+        }
+    } else if (context.GetFilter() && !context.GetFilter()->IsTotalAllowFilter()) {
+        return ApplyFilter(*context.GetFilter(), nullptr)->GetChunkedArrayTrivial();
+    } else {
+        return GetChunkedArrayTrivial();
+    }
+}
+
 TString IChunkedArray::TReader::DebugString(const ui32 position) const {
     auto address = GetReadChunk(position);
     return NArrow::DebugString(address.GetArray(), address.GetPosition());
diff --git a/ydb/core/formats/arrow/accessor/abstract/accessor.h b/ydb/core/formats/arrow/accessor/abstract/accessor.h
index 1bcd5989ebd4..09b5cea3e051 100644
--- a/ydb/core/formats/arrow/accessor/abstract/accessor.h
+++ b/ydb/core/formats/arrow/accessor/abstract/accessor.h
@@ -1,5 +1,7 @@
 #pragma once
 
+#include "common.h"
+
 #include <ydb/library/accessor/accessor.h>
 #include <ydb/library/accessor/validator.h>
 #include <ydb/library/formats/arrow/splitter/similar_packer.h>
@@ -264,6 +266,8 @@ class IChunkedArray {
     virtual void DoVisitValues(const TValuesSimpleVisitor& visitor) const = 0;
 
 protected:
+    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArrayTrivial() const;
+
     std::shared_ptr<arrow::Schema> GetArraySchema() const {
         const arrow::FieldVector fields = { std::make_shared<arrow::Field>("val", GetDataType()) };
         return std::make_shared<arrow::Schema>(fields);
@@ -344,7 +348,6 @@ class IChunkedArray {
     }
 
     virtual void Reallocate() {
-
     }
 
     void VisitValues(const TValuesSimpleVisitor& visitor) const {
@@ -444,7 +447,8 @@ class IChunkedArray {
         return *result;
     }
 
-    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArray() const;
+    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArray(
+        const TColumnConstructionContext& context = Default<TColumnConstructionContext>()) const;
     virtual ~IChunkedArray() = default;
 
     std::shared_ptr<arrow::ChunkedArray> Slice(const ui32 offset, const ui32 count) const;
diff --git a/ydb/core/formats/arrow/accessor/abstract/common.cpp b/ydb/core/formats/arrow/accessor/abstract/common.cpp
new file mode 100644
index 000000000000..04fc014e1ee0
--- /dev/null
+++ b/ydb/core/formats/arrow/accessor/abstract/common.cpp
@@ -0,0 +1,31 @@
+#include "common.h"
+
+#include <ydb/core/formats/arrow/arrow_filter.h>
+
+namespace NKikimr::NArrow::NAccessor {
+
+TColumnConstructionContext& TColumnConstructionContext::SetFilter(const std::shared_ptr<TColumnFilter>& val) {
+    if (!val || val->IsTotalAllowFilter()) {
+        Filter = nullptr;
+    } else {
+        Filter = val;
+    }
+    return *this;
+}
+
+std::optional<TColumnConstructionContext> TColumnConstructionContext::Slice(const ui32 offset, const ui32 count) const {
+    std::optional<TColumnConstructionContext> result;
+    const ui32 start = std::max<ui32>(offset, StartIndex.value_or(0));
+    const ui32 finish = std::min<ui32>(offset + count, StartIndex.value_or(0) + RecordsCount.value_or(offset + count));
+    if (finish <= start) {
+        result = std::nullopt;
+    } else {
+        result = TColumnConstructionContext().SetStartIndex(start - offset).SetRecordsCount(finish - start, count);
+    }
+    if (result && Filter) {
+        result->SetFilter(std::make_shared<TColumnFilter>(Filter->Slice(offset, count)));
+    }
+    return result;
+}
+
+}   // namespace NKikimr::NArrow::NAccessor
diff --git a/ydb/core/formats/arrow/accessor/abstract/common.h b/ydb/core/formats/arrow/accessor/abstract/common.h
new file mode 100644
index 000000000000..95a8409451d5
--- /dev/null
+++ b/ydb/core/formats/arrow/accessor/abstract/common.h
@@ -0,0 +1,47 @@
+#pragma once
+#include <ydb/library/accessor/accessor.h>
+
+#include <util/system/types.h>
+
+#include <memory>
+#include <optional>
+
+namespace NKikimr::NArrow {
+class TColumnFilter;
+}
+
+namespace NKikimr::NArrow::NAccessor {
+
+class TColumnConstructionContext {
+private:
+    YDB_READONLY_DEF(std::optional<ui32>, StartIndex);
+    YDB_ACCESSOR_DEF(std::optional<ui32>, RecordsCount);
+    YDB_READONLY_DEF(std::shared_ptr<TColumnFilter>, Filter);
+
+public:
+    TColumnConstructionContext& SetRecordsCount(const ui32 recordsCount, const ui32 defValue) {
+        if (recordsCount == defValue) {
+            RecordsCount.reset();
+        } else {
+            RecordsCount = recordsCount;
+        }
+        return *this;
+    }
+
+    TColumnConstructionContext& SetStartIndex(const ui32 startIndex) {
+        if (startIndex) {
+            StartIndex = startIndex;
+        } else {
+            StartIndex.reset();
+        }
+        return *this;
+    }
+
+    TColumnConstructionContext& SetFilter(const std::shared_ptr<TColumnFilter>& val);
+
+    std::optional<TColumnConstructionContext> Slice(const ui32 offset, const ui32 count) const;
+
+    TColumnConstructionContext() = default;
+};
+
+}   // namespace NKikimr::NArrow::NAccessor
diff --git a/ydb/core/formats/arrow/accessor/abstract/constructor.h b/ydb/core/formats/arrow/accessor/abstract/constructor.h
index 4dd908a82299..56b981e08edd 100644
--- a/ydb/core/formats/arrow/accessor/abstract/constructor.h
+++ b/ydb/core/formats/arrow/accessor/abstract/constructor.h
@@ -33,6 +33,10 @@ class IConstructor {
         const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& originalArray, const TChunkConstructionData& externalInfo) const = 0;
 
 public:
+    virtual bool HasInternalConversion() const {
+        return false;
+    }
+
     IConstructor(const IChunkedArray::EType type)
         : Type(type) {
     }
diff --git a/ydb/core/formats/arrow/accessor/abstract/ya.make b/ydb/core/formats/arrow/accessor/abstract/ya.make
index 6b239c4ad15d..2940495d2a5c 100644
--- a/ydb/core/formats/arrow/accessor/abstract/ya.make
+++ b/ydb/core/formats/arrow/accessor/abstract/ya.make
@@ -10,6 +10,7 @@ PEERDIR(
 )
 
 SRCS(
+    common.cpp
     constructor.cpp
     request.cpp
     accessor.cpp
diff --git a/ydb/core/formats/arrow/accessor/composite/accessor.cpp b/ydb/core/formats/arrow/accessor/composite/accessor.cpp
index 7afe8199c9fc..eef73d9970d2 100644
--- a/ydb/core/formats/arrow/accessor/composite/accessor.cpp
+++ b/ydb/core/formats/arrow/accessor/composite/accessor.cpp
@@ -110,4 +110,24 @@ std::optional<bool> TCompositeChunkedArray::DoCheckOneValueAccessor(std::shared_
     return true;
 }
 
+std::shared_ptr<arrow::ChunkedArray> TCompositeChunkedArray::GetChunkedArray(const TColumnConstructionContext& context) const {
+    ui32 pos = 0;
+    std::vector<std::shared_ptr<arrow::Array>> chunks;
+    for (auto&& i : Chunks) {
+        auto sliceCtx = context.Slice(pos, i->GetRecordsCount());
+        if (!sliceCtx) {
+            if (chunks.size()) {
+                break;
+            } else {
+                pos += i->GetRecordsCount();
+                continue;
+            }
+        }
+        std::shared_ptr<arrow::ChunkedArray> arr = i->GetChunkedArray(*sliceCtx);
+        chunks.insert(chunks.end(), arr->chunks().begin(), arr->chunks().end());
+        pos += i->GetRecordsCount();
+    }
+    return std::make_shared<arrow::ChunkedArray>(std::move(chunks));
+}
+
 }   // namespace NKikimr::NArrow::NAccessor
diff --git a/ydb/core/formats/arrow/accessor/composite/accessor.h b/ydb/core/formats/arrow/accessor/composite/accessor.h
index 558b4046b3e1..dfce2c8d1f4d 100644
--- a/ydb/core/formats/arrow/accessor/composite/accessor.h
+++ b/ydb/core/formats/arrow/accessor/composite/accessor.h
@@ -22,6 +22,8 @@ class TCompositeChunkedArray: public ICompositeChunkedArray {
 private:
     YDB_READONLY_DEF(std::vector<std::shared_ptr<IChunkedArray>>, Chunks);
 
+    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArray(const TColumnConstructionContext& context) const override;
+
     virtual void DoVisitValues(const TValuesSimpleVisitor& visitor) const override {
         for (auto&& i : Chunks) {
             i->VisitValues(visitor);
diff --git a/ydb/core/formats/arrow/accessor/composite_serial/accessor.cpp b/ydb/core/formats/arrow/accessor/composite_serial/accessor.cpp
index 7bd74612008a..bcebf9136f2a 100644
--- a/ydb/core/formats/arrow/accessor/composite_serial/accessor.cpp
+++ b/ydb/core/formats/arrow/accessor/composite_serial/accessor.cpp
@@ -2,62 +2,26 @@
 
 #include <ydb/core/formats/arrow/accessor/sparsed/constructor.h>
 
+#include <ydb/library/actors/core/log.h>
 #include <ydb/library/actors/prof/tag.h>
 
 namespace NKikimr::NArrow::NAccessor {
 
-namespace {
-class TSerializedChunkAccessor {
-private:
-    const std::vector<TDeserializeChunkedArray::TChunk>& Chunks;
-    const std::shared_ptr<TColumnLoader>& Loader;
-    std::optional<IChunkedArray::TLocalChunkedArrayAddress>& Result;
-
-public:
-    TSerializedChunkAccessor(const std::vector<TDeserializeChunkedArray::TChunk>& chunks, const std::shared_ptr<TColumnLoader>& loader,
-        std::optional<IChunkedArray::TLocalChunkedArrayAddress>& result)
-        : Chunks(chunks)
-        , Loader(loader)
-        , Result(result) {
-    }
-    ui64 GetChunksCount() const {
-        return Chunks.size();
-    }
-    ui64 GetChunkLength(const ui32 idx) const {
-        return Chunks[idx].GetRecordsCount();
-    }
-    void OnArray(const ui32 chunkIdx, const ui32 startPosition) const {
-        Result = IChunkedArray::TLocalChunkedArrayAddress(Chunks[chunkIdx].GetArrayVerified(Loader), startPosition, chunkIdx);
-    }
-};
-
-}   // namespace
-
-std::shared_ptr<IChunkedArray> TDeserializeChunkedArray::TChunk::GetArrayVerified(const std::shared_ptr<TColumnLoader>& loader) const {
+IChunkedArray::TLocalChunkedArrayAddress TDeserializeChunkedArray::DoGetLocalChunkedArray(
+    const std::optional<TCommonChunkAddress>& /*chunkCurrent*/, const ui64 /*position*/) const {
     if (PredefinedArray) {
-        return PredefinedArray;
+        return TLocalChunkedArrayAddress(PredefinedArray, 0, 0);
+    }
+    if (Counter.Inc() > 1) {
+        AFL_WARN(NKikimrServices::ARROW_HELPER)("event", "many_deserializations")("counter", Counter.Val())("size", Data.size())(
+            "buffer", DataBuffer.size());
     }
     if (!!Data) {
-        return loader->ApplyVerified(Data, RecordsCount);
+        return TLocalChunkedArrayAddress(Loader->ApplyVerified(Data, GetRecordsCount()), 0, 0);
     } else {
         AFL_VERIFY(!!DataBuffer);
-        return loader->ApplyVerified(TString(DataBuffer.data(), DataBuffer.size()), RecordsCount);
+        return TLocalChunkedArrayAddress(Loader->ApplyVerified(TString(DataBuffer.data(), DataBuffer.size()), GetRecordsCount()), 0, 0);
     }
 }
 
-IChunkedArray::TLocalDataAddress TDeserializeChunkedArray::DoGetLocalData(
-    const std::optional<TCommonChunkAddress>& /*chunkCurrent*/, const ui64 /*position*/) const {
-    AFL_VERIFY(false);
-    return IChunkedArray::TLocalDataAddress(nullptr, 0, 0);
-}
-
-IChunkedArray::TLocalChunkedArrayAddress TDeserializeChunkedArray::DoGetLocalChunkedArray(
-    const std::optional<TCommonChunkAddress>& chunkCurrent, const ui64 position) const {
-    std::optional<IChunkedArray::TLocalChunkedArrayAddress> result;
-    TSerializedChunkAccessor accessor(Chunks, Loader, result);
-    SelectChunk(chunkCurrent, position, accessor);
-    AFL_VERIFY(result);
-    return *result;
-}
-
 }   // namespace NKikimr::NArrow::NAccessor
diff --git a/ydb/core/formats/arrow/accessor/composite_serial/accessor.h b/ydb/core/formats/arrow/accessor/composite_serial/accessor.h
index 1eb6459a4b41..81c9828fb4a3 100644
--- a/ydb/core/formats/arrow/accessor/composite_serial/accessor.h
+++ b/ydb/core/formats/arrow/accessor/composite_serial/accessor.h
@@ -5,50 +5,23 @@
 
 namespace NKikimr::NArrow::NAccessor {
 
-class TDeserializeChunkedArray: public ICompositeChunkedArray {
+class TDeserializeChunkedArray: public IChunkedArray {
 private:
-    using TBase = ICompositeChunkedArray;
-
-public:
-    class TChunk {
-    private:
-        YDB_READONLY(ui32, RecordsCount, 0);
-        std::shared_ptr<IChunkedArray> PredefinedArray;
-        const TString Data;
-        const TStringBuf DataBuffer;
-
-    public:
-        TChunk(const std::shared_ptr<IChunkedArray>& predefinedArray)
-            : PredefinedArray(predefinedArray) {
-            AFL_VERIFY(PredefinedArray);
-            RecordsCount = PredefinedArray->GetRecordsCount();
-        }
-
-        TChunk(const ui32 recordsCount, const TString& data)
-            : RecordsCount(recordsCount)
-            , Data(data) {
-        }
-
-        TChunk(const ui32 recordsCount, const TStringBuf dataBuffer)
-            : RecordsCount(recordsCount)
-            , DataBuffer(dataBuffer) {
-        }
-
-        std::shared_ptr<IChunkedArray> GetArrayVerified(const std::shared_ptr<TColumnLoader>& loader) const;
-    };
-
-private:
-    std::shared_ptr<TColumnLoader> Loader;
-    std::vector<TChunk> Chunks;
-    const bool ForLazyInitialization = false;
+    using TBase = IChunkedArray;
+    const std::shared_ptr<TColumnLoader> Loader;
+    std::shared_ptr<IChunkedArray> PredefinedArray;
+    const TString Data;
+    const TStringBuf DataBuffer;
+    const bool ForLazyInitialization;
+    mutable TAtomicCounter Counter = 0;
 
+protected:
+    virtual std::shared_ptr<IChunkedArray> DoISlice(const ui32 offset, const ui32 count) const override {
+        return GetLocalChunkedArray(std::nullopt, 0).GetArray()->ISlice(offset, count);
+    }
     virtual void DoVisitValues(const TValuesSimpleVisitor& visitor) const override {
-        for (auto&& i : Chunks) {
-            i.GetArrayVerified(Loader)->VisitValues(visitor);
-        }
+        return GetLocalChunkedArray(std::nullopt, 0).GetArray()->VisitValues(visitor);
     }
-
-protected:
     virtual ui32 DoGetNullsCount() const override {
         AFL_VERIFY(false);
         return 0;
@@ -60,7 +33,10 @@ class TDeserializeChunkedArray: public ICompositeChunkedArray {
 
     virtual TLocalChunkedArrayAddress DoGetLocalChunkedArray(
         const std::optional<TCommonChunkAddress>& chunkCurrent, const ui64 position) const override;
-    virtual TLocalDataAddress DoGetLocalData(const std::optional<TCommonChunkAddress>& chunkCurrent, const ui64 position) const override;
+    virtual TLocalDataAddress DoGetLocalData(const std::optional<TCommonChunkAddress>& /*chunkCurrent*/, const ui64 /*position*/) const override {
+        AFL_VERIFY(false);
+        return TLocalDataAddress(nullptr, 0, 0);
+    }
 
     virtual std::shared_ptr<arrow::Scalar> DoGetScalar(const ui32 /*index*/) const override {
         AFL_VERIFY(false)("problem", "cannot use method");
@@ -73,21 +49,39 @@ class TDeserializeChunkedArray: public ICompositeChunkedArray {
         AFL_VERIFY(false);
         return nullptr;
     }
-    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArray() const override {
+    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArrayTrivial() const override {
         if (!ForLazyInitialization) {
             AFL_VERIFY(false);
             return nullptr;
         } else {
-            return TBase::GetChunkedArray();
+            return TBase::GetChunkedArrayTrivial();
         }
     }
 
 public:
-    TDeserializeChunkedArray(const ui64 recordsCount, const std::shared_ptr<TColumnLoader>& loader, std::vector<TChunk>&& chunks,
+    TDeserializeChunkedArray(const ui64 recordsCount, const std::shared_ptr<TColumnLoader>& loader, const TString& data,
+        const bool forLazyInitialization = false)
+        : TBase(recordsCount, NArrow::NAccessor::IChunkedArray::EType::SerializedChunkedArray, loader->GetField()->type())
+        , Loader(loader)
+        , Data(data)
+        , ForLazyInitialization(forLazyInitialization) {
+        AFL_VERIFY(Loader);
+    }
+
+    TDeserializeChunkedArray(
+        const ui64 recordsCount, const std::shared_ptr<TColumnLoader>& loader, const TStringBuf data, const bool forLazyInitialization = false)
+        : TBase(recordsCount, NArrow::NAccessor::IChunkedArray::EType::SerializedChunkedArray, loader->GetField()->type())
+        , Loader(loader)
+        , DataBuffer(data)
+        , ForLazyInitialization(forLazyInitialization) {
+        AFL_VERIFY(Loader);
+    }
+
+    TDeserializeChunkedArray(const ui64 recordsCount, const std::shared_ptr<TColumnLoader>& loader, const std::shared_ptr<IChunkedArray>& data,
         const bool forLazyInitialization = false)
         : TBase(recordsCount, NArrow::NAccessor::IChunkedArray::EType::SerializedChunkedArray, loader->GetField()->type())
         , Loader(loader)
-        , Chunks(std::move(chunks))
+        , PredefinedArray(data)
         , ForLazyInitialization(forLazyInitialization) {
         AFL_VERIFY(Loader);
     }
diff --git a/ydb/core/formats/arrow/accessor/plain/accessor.cpp b/ydb/core/formats/arrow/accessor/plain/accessor.cpp
index 4d217a596c39..5967eb45786a 100644
--- a/ydb/core/formats/arrow/accessor/plain/accessor.cpp
+++ b/ydb/core/formats/arrow/accessor/plain/accessor.cpp
@@ -31,16 +31,25 @@ void TTrivialArray::Reallocate() {
 }
 
 std::shared_ptr<arrow::Array> TTrivialArray::BuildArrayFromOptionalScalar(
-    const std::shared_ptr<arrow::Scalar>& scalar, const std::shared_ptr<arrow::DataType>& type) {
+    const std::shared_ptr<arrow::Scalar>& scalar, const std::shared_ptr<arrow::DataType>& typePtr) {
     if (scalar) {
-        AFL_VERIFY(scalar->type->id() == type->id());
+        AFL_VERIFY(scalar->type->id() == typePtr->id());
         auto builder = NArrow::MakeBuilder(scalar->type, 1);
         TStatusValidator::Validate(builder->AppendScalar(*scalar));
         return NArrow::FinishBuilder(std::move(builder));
     } else {
-        auto builder = NArrow::MakeBuilder(type, 1);
-        TStatusValidator::Validate(builder->AppendNull());
-        return NArrow::FinishBuilder(std::move(builder));
+        std::shared_ptr<arrow::Array> result;
+        NArrow::SwitchType(typePtr->id(), [&](const auto& /*type*/) {
+            static const std::shared_ptr<arrow::Array> arrResult = [&]() {
+                auto builder = NArrow::MakeBuilder(typePtr, 1);
+                TStatusValidator::Validate(builder->AppendNull());
+                return NArrow::FinishBuilder(std::move(builder));
+            }();
+            result = arrResult;
+            return true;
+        });
+        AFL_VERIFY(result);
+        return result;
     }
 }
 
diff --git a/ydb/core/formats/arrow/accessor/plain/accessor.h b/ydb/core/formats/arrow/accessor/plain/accessor.h
index 3b9cbad85e39..d05d72f3d266 100644
--- a/ydb/core/formats/arrow/accessor/plain/accessor.h
+++ b/ydb/core/formats/arrow/accessor/plain/accessor.h
@@ -41,7 +41,7 @@ class TTrivialArray: public IChunkedArray {
 
     virtual void Reallocate() override;
 
-    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArray() const override {
+    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArrayTrivial() const override {
         return std::make_shared<arrow::ChunkedArray>(Array);
     }
 
@@ -93,6 +93,16 @@ class TTrivialArray: public IChunkedArray {
             AFL_VERIFY(NArrow::Append<TArrowDataType>(*Builder, arrow::util::string_view(value.data(), value.size())));
         }
 
+        void AddNull(const ui32 recordIndex) {
+            if (LastRecordIndex) {
+                AFL_VERIFY(*LastRecordIndex < recordIndex)("last", LastRecordIndex)("index", recordIndex);
+                TStatusValidator::Validate(Builder->AppendNulls(recordIndex - *LastRecordIndex));
+            } else {
+                TStatusValidator::Validate(Builder->AppendNulls(recordIndex + 1));
+            }
+            LastRecordIndex = recordIndex;
+        }
+
         std::shared_ptr<IChunkedArray> Finish(const ui32 recordsCount) {
             if (LastRecordIndex) {
                 AFL_VERIFY(*LastRecordIndex < recordsCount)("last", LastRecordIndex)("count", recordsCount);
@@ -120,6 +130,10 @@ class TTrivialChunkedArray: public IChunkedArray {
         }
     }
 
+    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArrayTrivial() const override {
+        return Array;
+    }
+
 protected:
     virtual ui32 DoGetValueRawBytes() const override;
     virtual ui32 DoGetNullsCount() const override {
@@ -139,10 +153,6 @@ class TTrivialChunkedArray: public IChunkedArray {
     virtual std::shared_ptr<arrow::Scalar> DoGetMaxScalar() const override;
 
 public:
-    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArray() const override {
-        return Array;
-    }
-
     TTrivialChunkedArray(const std::shared_ptr<arrow::ChunkedArray>& data)
         : TBase(data->length(), EType::ChunkedArray, data->type())
         , Array(data) {
diff --git a/ydb/core/formats/arrow/accessor/plain/constructor.cpp b/ydb/core/formats/arrow/accessor/plain/constructor.cpp
index 757b4c129885..1f34cb796254 100644
--- a/ydb/core/formats/arrow/accessor/plain/constructor.cpp
+++ b/ydb/core/formats/arrow/accessor/plain/constructor.cpp
@@ -56,6 +56,10 @@ TString TConstructor::DoSerializeToString(const std::shared_ptr<IChunkedArray>&
 
 TConclusion<std::shared_ptr<IChunkedArray>> TConstructor::DoConstruct(
     const std::shared_ptr<IChunkedArray>& originalArray, const TChunkConstructionData& externalInfo) const {
+    if (!originalArray->GetDataType()->Equals(externalInfo.GetColumnType())) {
+        return TConclusionStatus::Fail("plain accessor cannot convert types for transfer: " + originalArray->GetDataType()->ToString() + " to " +
+                                       externalInfo.GetColumnType()->ToString());
+    }
     auto schema = std::make_shared<arrow::Schema>(arrow::FieldVector({ std::make_shared<arrow::Field>("val", externalInfo.GetColumnType()) }));
     auto chunked = originalArray->GetChunkedArray();
     auto table = arrow::Table::Make(schema, { chunked }, originalArray->GetRecordsCount());
diff --git a/ydb/core/formats/arrow/accessor/sparsed/accessor.cpp b/ydb/core/formats/arrow/accessor/sparsed/accessor.cpp
index c60df733ba73..75786aa95a85 100644
--- a/ydb/core/formats/arrow/accessor/sparsed/accessor.cpp
+++ b/ydb/core/formats/arrow/accessor/sparsed/accessor.cpp
@@ -110,8 +110,13 @@ IChunkedArray::TLocalDataAddress TSparsedArrayChunk::GetChunk(
     AFL_VERIFY(it != RemapExternalToInternal.begin());
     --it;
     if (it->GetIsDefault()) {
-        return IChunkedArray::TLocalDataAddress(
-            NArrow::TThreadSimpleArraysCache::Get(ColValue->type(), DefaultValue, it->GetSize()), it->GetStartExt(), 0);
+        std::shared_ptr<arrow::Array> arr;
+        if (!DefaultValue) {
+            arr = NArrow::TThreadSimpleArraysCache::Get(ColValue->type(), DefaultValue, it->GetSize());
+        } else {
+            arr = NArrow::TStatusValidator::GetValid(arrow::MakeArrayFromScalar(*DefaultValue, it->GetSize()));
+        }
+        return IChunkedArray::TLocalDataAddress(arr, it->GetStartExt(), 0);
     } else {
         return IChunkedArray::TLocalDataAddress(ColValue->Slice(it->GetStartInt(), it->GetSize()), it->GetStartExt(), 0);
     }
@@ -217,8 +222,8 @@ TSparsedArrayChunk TSparsedArrayChunk::ApplyFilter(const TColumnFilter& filter)
     ui32 filteredCount = 0;
     bool currentAcceptance = filter.GetStartValue();
     TColumnFilter filterNew = TColumnFilter::BuildAllowFilter();
-    auto indexesBuilder = NArrow::MakeBuilder(arrow::uint32());
-    auto valuesBuilder = NArrow::MakeBuilder(ColValue->type());
+    auto indexesBuilder = NArrow::MakeBuilder(arrow::uint32(), filter.GetFilteredCountVerified());
+    auto valuesBuilder = NArrow::MakeBuilder(ColValue->type(), filter.GetFilteredCountVerified());
     for (auto it = filter.GetFilter().begin(); it != filter.GetFilter().end(); ++it) {
         for (; recordIndex < UI32ColIndex->length(); ++recordIndex) {
             if (UI32ColIndex->Value(recordIndex) < filterIntervalStart) {
diff --git a/ydb/core/formats/arrow/accessor/sparsed/accessor.h b/ydb/core/formats/arrow/accessor/sparsed/accessor.h
index d125fba0733e..42eafb46dea4 100644
--- a/ydb/core/formats/arrow/accessor/sparsed/accessor.h
+++ b/ydb/core/formats/arrow/accessor/sparsed/accessor.h
@@ -58,6 +58,11 @@ class TSparsedArrayChunk {
         : TSparsedArrayChunk(original) {
         AFL_VERIFY(!original.GetNotDefaultRecordsCount());
         RecordsCount = recordsCount;
+        AFL_VERIFY(RemapExternalToInternal.size() == 1);
+        AFL_VERIFY(RemapExternalToInternal[0].GetStartExt() == 0);
+        AFL_VERIFY(RemapExternalToInternal[0].GetStartInt() == 0);
+        AFL_VERIFY(RemapExternalToInternal[0].GetIsDefault());
+        RemapExternalToInternal[0] = TInternalChunkInfo(0, 0, recordsCount, true);
     }
 
 public:
@@ -170,10 +175,19 @@ class TSparsedArray: public IChunkedArray {
 
     static ui32 GetLastIndex(const std::shared_ptr<arrow::RecordBatch>& batch);
 
-    static std::shared_ptr<arrow::Schema> BuildSchema(const std::shared_ptr<arrow::DataType>& type) {
-        std::vector<std::shared_ptr<arrow::Field>> fields = { std::make_shared<arrow::Field>("index", arrow::uint32()),
-            std::make_shared<arrow::Field>("value", type) };
-        return std::make_shared<arrow::Schema>(fields);
+    static std::shared_ptr<arrow::Schema> BuildSchema(const std::shared_ptr<arrow::DataType>& typePtr) {
+        std::shared_ptr<arrow::Schema> result;
+        NArrow::SwitchType(typePtr->id(), [&](const auto& /*type*/) {
+            static const std::shared_ptr<arrow::Schema> schemaResult = [&]() {
+                std::vector<std::shared_ptr<arrow::Field>> fields = { std::make_shared<arrow::Field>("index", arrow::uint32()),
+                    std::make_shared<arrow::Field>("value", typePtr) };
+                return std::make_shared<arrow::Schema>(fields);
+            }();
+            result = schemaResult;
+            return true;
+        });
+        AFL_VERIFY(result);
+        return result;
     }
 
     static TSparsedArrayChunk MakeDefaultChunk(
@@ -224,7 +238,7 @@ class TSparsedArray: public IChunkedArray {
         std::unique_ptr<arrow::ArrayBuilder> ValueBuilder;
         ui32 RecordsCount = 0;
         const std::shared_ptr<arrow::Scalar> DefaultValue;
-
+        std::optional<ui32> LastRecordIndex;
     public:
         TSparsedBuilder(const std::shared_ptr<arrow::Scalar>& defaultValue, const ui32 reserveItems, const ui32 reserveData)
             : DefaultValue(defaultValue) {
@@ -233,11 +247,26 @@ class TSparsedArray: public IChunkedArray {
         }
 
         void AddRecord(const ui32 recordIndex, const std::string_view value) {
+            if (!!LastRecordIndex) {
+                AFL_VERIFY(*LastRecordIndex < recordIndex);
+            }
+            LastRecordIndex = recordIndex;
             AFL_VERIFY(NArrow::Append<arrow::UInt32Type>(*IndexBuilder, recordIndex));
             AFL_VERIFY(NArrow::Append<TDataType>(*ValueBuilder, arrow::util::string_view(value.data(), value.size())));
             ++RecordsCount;
         }
 
+        void AddNull(const ui32 recordIndex) {
+            if (!!LastRecordIndex) {
+                AFL_VERIFY(*LastRecordIndex < recordIndex);
+            }
+            LastRecordIndex = recordIndex;
+            if (!!DefaultValue && DefaultValue->type->id() != arrow::null()->id()) {
+                AFL_VERIFY(NArrow::Append<arrow::UInt32Type>(*IndexBuilder, recordIndex));
+                TStatusValidator::Validate(ValueBuilder->AppendNull());
+            }
+        }
+
         std::shared_ptr<IChunkedArray> Finish(const ui32 recordsCount) {
             TSparsedArray::TBuilder builder(DefaultValue, arrow::TypeTraits<TDataType>::type_singleton());
             std::vector<std::unique_ptr<arrow::ArrayBuilder>> builders;
diff --git a/ydb/core/formats/arrow/accessor/sparsed/constructor.cpp b/ydb/core/formats/arrow/accessor/sparsed/constructor.cpp
index 3d4a3574afd5..ab7d309fc7e5 100644
--- a/ydb/core/formats/arrow/accessor/sparsed/constructor.cpp
+++ b/ydb/core/formats/arrow/accessor/sparsed/constructor.cpp
@@ -42,7 +42,10 @@ TString TConstructor::DoSerializeToString(const std::shared_ptr<IChunkedArray>&
 
 TConclusion<std::shared_ptr<IChunkedArray>> TConstructor::DoConstruct(
     const std::shared_ptr<IChunkedArray>& originalArray, const TChunkConstructionData& externalInfo) const {
-    AFL_VERIFY(originalArray);
+    if (!externalInfo.GetColumnType()->Equals(originalArray->GetDataType())) {
+        return TConclusionStatus::Fail("sparsed accessor cannot convert types for transfer: " + originalArray->GetDataType()->ToString() + " to " +
+                                       externalInfo.GetColumnType()->ToString());
+    }
     return TSparsedArray::Make(*originalArray, externalInfo.GetDefaultValue());
 }
 
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/accessor.cpp b/ydb/core/formats/arrow/accessor/sub_columns/accessor.cpp
index 327cf5bb279f..f33a04785e61 100644
--- a/ydb/core/formats/arrow/accessor/sub_columns/accessor.cpp
+++ b/ydb/core/formats/arrow/accessor/sub_columns/accessor.cpp
@@ -1,4 +1,6 @@
 #include "accessor.h"
+#include "direct_builder.h"
+#include "signals.h"
 
 #include <ydb/core/formats/arrow/accessor/composite_serial/accessor.h>
 #include <ydb/core/formats/arrow/accessor/plain/constructor.h>
@@ -14,9 +16,8 @@
 
 namespace NKikimr::NArrow::NAccessor {
 
-TConclusion<std::shared_ptr<TSubColumnsArray>> TSubColumnsArray::Make(const std::shared_ptr<IChunkedArray>& sourceArray,
-    const std::shared_ptr<NSubColumns::IDataAdapter>& adapter, const NSubColumns::TSettings& settings) {
-    AFL_VERIFY(adapter);
+TConclusion<std::shared_ptr<TSubColumnsArray>> TSubColumnsArray::Make(
+    const std::shared_ptr<IChunkedArray>& sourceArray, const NSubColumns::TSettings& settings) {
     AFL_VERIFY(sourceArray);
     NSubColumns::TDataBuilder builder(sourceArray->GetDataType(), settings);
     IChunkedArray::TReader reader(sourceArray);
@@ -24,7 +25,7 @@ TConclusion<std::shared_ptr<TSubColumnsArray>> TSubColumnsArray::Make(const std:
     for (ui32 i = 0; i < reader.GetRecordsCount();) {
         auto address = reader.GetReadChunk(i);
         storage.emplace_back(address.GetArray());
-        auto conclusion = adapter->AddDataToBuilders(address.GetArray(), builder);
+        auto conclusion = settings.GetDataExtractor()->AddDataToBuilders(address.GetArray(), builder);
         if (conclusion.IsFail()) {
             return conclusion;
         }
@@ -67,19 +68,26 @@ TString TSubColumnsArray::SerializeToString(const TChunkConstructionData& extern
         proto.SetOtherStatsSize(0);
     }
     ui32 columnIdx = 0;
+    TMonotonic pred = TMonotonic::Now();
     for (auto&& i : ColumnsData.GetRecords()->GetColumns()) {
         TChunkConstructionData cData(GetRecordsCount(), nullptr, arrow::utf8(), externalInfo.GetDefaultSerializer());
-        blobRanges.emplace_back(
-            ColumnsData.GetStats().GetAccessorConstructor(columnIdx).SerializeToString(i, cData));
+        blobRanges.emplace_back(ColumnsData.GetStats().GetAccessorConstructor(columnIdx).SerializeToString(i, cData));
         auto* cInfo = proto.AddKeyColumns();
         cInfo->SetSize(blobRanges.back().size());
+        TMonotonic next = TMonotonic::Now();
+        NSubColumns::TSignals::GetColumnSignals().OnBlobSize(ColumnsData.GetStats().GetColumnSize(columnIdx), blobRanges.back().size(), next - pred);
+        pred = next;
         ++columnIdx;
     }
 
     if (OthersData.GetRecords()->GetRecordsCount()) {
+        TMonotonic pred = TMonotonic::Now();
         for (auto&& i : OthersData.GetRecords()->GetColumns()) {
             TChunkConstructionData cData(i->GetRecordsCount(), nullptr, i->GetDataType(), externalInfo.GetDefaultSerializer());
             blobRanges.emplace_back(NPlain::TConstructor().SerializeToString(i, cData));
+            TMonotonic next = TMonotonic::Now();
+            NSubColumns::TSignals::GetOtherSignals().OnBlobSize(i->GetRawSizeVerified(), blobRanges.back().size(), next - pred);
+            pred = next;
             auto* cInfo = proto.AddOtherColumns();
             cInfo->SetSize(blobRanges.back().size());
         }
@@ -105,42 +113,160 @@ TString TSubColumnsArray::SerializeToString(const TChunkConstructionData& extern
     return result;
 }
 
-IChunkedArray::TLocalDataAddress TSubColumnsArray::DoGetLocalData(
-    const std::optional<TCommonChunkAddress>& /*chunkCurrent*/, const ui64 /*position*/) const {
+class TJsonRestorer {
+private:
+    NJson::TJsonValue Result;
+
+public:
+    bool IsNull() const {
+        return !Result.IsDefined();
+    }
+
+    TConclusion<NBinaryJson::TBinaryJson> Finish() {
+        auto str = Result.GetStringRobust();
+        auto bJson = NBinaryJson::SerializeToBinaryJson(Result.GetStringRobust());
+        if (const TString* val = std::get_if<TString>(&bJson)) {
+            return TConclusionStatus::Fail(*val);
+        } else if (const NBinaryJson::TBinaryJson* val = std::get_if<NBinaryJson::TBinaryJson>(&bJson)) {
+            return std::move(*val);
+        } else {
+            return TConclusionStatus::Fail("undefined case for binary json construction");
+        }
+    }
+
+    void SetValueByPath(const TString& path, const TString& valueStr) {
+        ui32 start = 0;
+        bool enqueue = false;
+        bool wasEnqueue = false;
+        NJson::TJsonValue* current = &Result;
+        for (ui32 i = 0; i < path.size(); ++i) {
+            if (path[i] == '\\') {
+                ++i;
+                continue;
+            }
+            if (path[i] == '\'' || path[i] == '\"') {
+                wasEnqueue = true;
+                enqueue = !enqueue;
+                continue;
+            }
+            if (enqueue) {
+                continue;
+            }
+            if (path[i] == '.') {
+                if (wasEnqueue) {
+                    AFL_VERIFY(i > start + 2);
+                    TStringBuf key(path.data() + start + 1, (i - 1) - start - 1);
+                    NJson::TJsonValue* currentNext = nullptr;
+                    if (current->GetValuePointer(key, &currentNext)) {
+                        current = currentNext;
+                    } else {
+                        current = &current->InsertValue(key, NJson::JSON_MAP);
+                    }
+                } else {
+                    AFL_VERIFY(i > start);
+                    TStringBuf key(path.data() + start, i - start);
+                    NJson::TJsonValue* currentNext = nullptr;
+                    if (current->GetValuePointer(key, &currentNext)) {
+                        current = currentNext;
+                    } else {
+                        ui32 keyIndex;
+                        if (key.StartsWith("[") && key.EndsWith("]") && TryFromString<ui32>(key.data() + 1, key.size() - 2, keyIndex)) {
+                            AFL_VERIFY(!current->IsDefined() || current->IsArray() || (current->IsMap() && current->GetMapSafe().empty()));
+                            current->SetType(NJson::JSON_ARRAY);
+                            if (current->GetArraySafe().size() <= keyIndex) {
+                                current->GetArraySafe().resize(keyIndex + 1);
+                            }
+                            current = &current->GetArraySafe()[keyIndex];
+                        } else {
+                            AFL_VERIFY(!current->IsArray())("current_type", current->GetType())("current", current->GetStringRobust());
+                            current = &current->InsertValue(key, NJson::JSON_MAP);
+                        }
+                    }
+                }
+                wasEnqueue = false;
+                start = i + 1;
+            }
+        }
+        if (wasEnqueue) {
+            AFL_VERIFY(path.size() > start + 2)("path", path)("start", start);
+            TStringBuf key(path.data() + start + 1, (path.size() - 1) - start - 1);
+            current->InsertValue(key, valueStr);
+        } else {
+            AFL_VERIFY(path.size() > start);
+            TStringBuf key(path.data() + start, (path.size()) - start);
+            ui32 keyIndex;
+            if (key.StartsWith("[") && key.EndsWith("]") && TryFromString<ui32>(key.data() + 1, key.size() - 2, keyIndex)) {
+                AFL_VERIFY(!current->IsDefined() || current->IsArray() || (current->IsMap() && current->GetMapSafe().empty()));
+                current->SetType(NJson::JSON_ARRAY);
+
+                if (current->GetArraySafe().size() <= keyIndex) {
+                    current->GetArraySafe().resize(keyIndex + 1);
+                }
+                current->GetArraySafe()[keyIndex] = valueStr;
+            } else {
+                AFL_VERIFY(!current->IsArray())("key", key)("current", current->GetStringRobust())("full", Result.GetStringRobust())(
+                    "current_type", current->GetType());
+                current->InsertValue(key, valueStr);
+            }
+        }
+    }
+};
+
+std::shared_ptr<arrow::Array> TSubColumnsArray::BuildBJsonArray(const TColumnConstructionContext& context) const {
     auto it = BuildUnorderedIterator();
     auto builder = NArrow::MakeBuilder(GetDataType());
-    for (ui32 recordIndex = 0; recordIndex < GetRecordsCount(); ++recordIndex) {
-        NJson::TJsonValue value;
+    const ui32 start = context.GetStartIndex().value_or(0);
+    const ui32 finish = start + context.GetRecordsCount().value_or(GetRecordsCount() - start);
+    std::optional<std::vector<bool>> simpleFilter;
+    if (context.GetFilter()) {
+        simpleFilter = context.GetFilter()->BuildSimpleFilter();
+    }
+    for (ui32 recordIndex = start; recordIndex < finish; ++recordIndex) {
+        if (simpleFilter && !(*simpleFilter)[recordIndex]) {
+            continue;
+        }
+        it.SkipRecordTo(recordIndex);
+        TJsonRestorer value;
         auto onStartRecord = [&](const ui32 index) {
             AFL_VERIFY(recordIndex == index)("count", recordIndex)("index", index);
         };
         auto onFinishRecord = [&]() {
-            auto str = value.GetStringRobust();
-            //            NArrow::Append<arrow::BinaryType>(*builder, arrow::util::string_view(str.data(), str.size()));
-            //
-            auto bJson = NBinaryJson::SerializeToBinaryJson(value.GetStringRobust());
-            if (const TString* val = std::get_if<TString>(&bJson)) {
-                AFL_VERIFY(false)("error", *val);
-            } else if (const NBinaryJson::TBinaryJson* val = std::get_if<NBinaryJson::TBinaryJson>(&bJson)) {
-                if (value.IsNull() || !value.IsDefined()) {
-                    TStatusValidator::Validate(builder->AppendNull());
-                } else {
-                    NArrow::Append<arrow::BinaryType>(*builder, arrow::util::string_view(val->data(), val->size()));
-                }
+            if (value.IsNull()) {
+                TStatusValidator::Validate(builder->AppendNull());
             } else {
-                AFL_VERIFY(false);
+                const TConclusion<NBinaryJson::TBinaryJson> bJson = value.Finish();
+                NArrow::Append<arrow::BinaryType>(*builder, arrow::util::string_view(bJson->data(), bJson->size()));
             }
         };
+
+        const auto addValueToJson = [&](const TString& path, const TString& valueStr) {
+            value.SetValueByPath(path, valueStr);
+        };
+
         auto onRecordKV = [&](const ui32 index, const std::string_view valueView, const bool isColumn) {
             if (isColumn) {
-                value.InsertValue(ColumnsData.GetStats().GetColumnNameString(index), TString(valueView.data(), valueView.size()));
+                addValueToJson(ColumnsData.GetStats().GetColumnNameString(index), TString(valueView.data(), valueView.size()));
             } else {
-                value.InsertValue(OthersData.GetStats().GetColumnNameString(index), TString(valueView.data(), valueView.size()));
+                addValueToJson(OthersData.GetStats().GetColumnNameString(index), TString(valueView.data(), valueView.size()));
             }
         };
         it.ReadRecord(recordIndex, onStartRecord, onRecordKV, onFinishRecord);
     }
-    return TLocalDataAddress(NArrow::FinishBuilder(std::move(builder)), 0, 0);
+    return NArrow::FinishBuilder(std::move(builder));
+}
+
+std::shared_ptr<arrow::ChunkedArray> TSubColumnsArray::GetChunkedArray(const TColumnConstructionContext& context) const {
+    auto chunk = BuildBJsonArray(context);
+    if (chunk->length()) {
+        return std::make_shared<arrow::ChunkedArray>(chunk);
+    } else {
+        return std::make_shared<arrow::ChunkedArray>(arrow::ArrayVector(), GetDataType());
+    }
+}
+
+IChunkedArray::TLocalDataAddress TSubColumnsArray::DoGetLocalData(
+    const std::optional<TCommonChunkAddress>& /*chunkCurrent*/, const ui64 /*position*/) const {
+    return TLocalDataAddress(BuildBJsonArray(TColumnConstructionContext()), 0, 0);
 }
 
 }   // namespace NKikimr::NArrow::NAccessor
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/accessor.h b/ydb/core/formats/arrow/accessor/sub_columns/accessor.h
index c1abe025199a..2fd9f60329f3 100644
--- a/ydb/core/formats/arrow/accessor/sub_columns/accessor.h
+++ b/ydb/core/formats/arrow/accessor/sub_columns/accessor.h
@@ -62,7 +62,11 @@ class TSubColumnsArray: public IChunkedArray {
             ColumnsData.Slice(offset, count), OthersData.Slice(offset, count, Settings), GetDataType(), count, Settings);
     }
 
+    std::shared_ptr<arrow::Array> BuildBJsonArray(const TColumnConstructionContext& context) const;
+
 public:
+    virtual std::shared_ptr<arrow::ChunkedArray> GetChunkedArray(
+        const TColumnConstructionContext& context = Default<TColumnConstructionContext>()) const override;
     virtual void DoVisitValues(const std::function<void(std::shared_ptr<arrow::Array>)>& /*visitor*/) const override {
         AFL_VERIFY(false);
     }
@@ -97,8 +101,8 @@ class TSubColumnsArray: public IChunkedArray {
     TSubColumnsArray(NSubColumns::TColumnsData&& columns, NSubColumns::TOthersData&& others, const std::shared_ptr<arrow::DataType>& type,
         const ui32 recordsCount, const NSubColumns::TSettings& settings);
 
-    static TConclusion<std::shared_ptr<TSubColumnsArray>> Make(const std::shared_ptr<IChunkedArray>& sourceArray,
-        const std::shared_ptr<NSubColumns::IDataAdapter>& adapter, const NSubColumns::TSettings& settings);
+    static TConclusion<std::shared_ptr<TSubColumnsArray>> Make(
+        const std::shared_ptr<IChunkedArray>& sourceArray, const NSubColumns::TSettings& settings);
 
     TSubColumnsArray(const std::shared_ptr<arrow::DataType>& type, const ui32 recordsCount, const NSubColumns::TSettings& settings);
 
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/columns_storage.cpp b/ydb/core/formats/arrow/accessor/sub_columns/columns_storage.cpp
index 86838382a29d..219353a866af 100644
--- a/ydb/core/formats/arrow/accessor/sub_columns/columns_storage.cpp
+++ b/ydb/core/formats/arrow/accessor/sub_columns/columns_storage.cpp
@@ -31,7 +31,7 @@ TColumnsData TColumnsData::ApplyFilter(const TColumnFilter& filter) const {
         return *this;
     }
     auto records = Records;
-    AFL_VERIFY(filter.Apply(records));
+    filter.Apply(records);
     if (records->GetRecordsCount()) {
         TDictStats::TBuilder builder;
         ui32 idx = 0;
@@ -53,4 +53,33 @@ TColumnsData TColumnsData::ApplyFilter(const TColumnFilter& filter) const {
     }
 }
 
+void TColumnsData::TIterator::InitArrays() {
+    while (CurrentIndex < GlobalChunkedArray->GetRecordsCount()) {
+        if (!FullArrayAddress || !FullArrayAddress->GetAddress().Contains(CurrentIndex)) {
+            FullArrayAddress = GlobalChunkedArray->GetArray(FullArrayAddress, CurrentIndex, GlobalChunkedArray);
+            ChunkAddress = std::nullopt;
+        }
+        const ui32 localIndex = FullArrayAddress->GetAddress().GetLocalIndex(CurrentIndex);
+        ChunkAddress = FullArrayAddress->GetArray()->GetChunk(ChunkAddress, localIndex);
+        AFL_VERIFY(ChunkAddress->GetArray()->type()->id() == arrow::utf8()->id());
+        CurrentArrayData = static_cast<const arrow::StringArray*>(ChunkAddress->GetArray().get());
+        if (FullArrayAddress->GetArray()->GetType() == IChunkedArray::EType::Array) {
+            if (CurrentArrayData->IsNull(localIndex)) {
+                Next();
+            }
+            break;
+        } else if (FullArrayAddress->GetArray()->GetType() == IChunkedArray::EType::SparsedArray) {
+            if (CurrentArrayData->IsNull(localIndex) &&
+                std::static_pointer_cast<TSparsedArray>(FullArrayAddress->GetArray())->GetDefaultValue() == nullptr) {
+                CurrentIndex = ChunkAddress->GetAddress().GetGlobalFinishPosition();
+            } else {
+                break;
+            }
+        } else {
+            AFL_VERIFY(false)("type", FullArrayAddress->GetArray()->GetType());
+        }
+    }
+    AFL_VERIFY(CurrentIndex <= GlobalChunkedArray->GetRecordsCount())("index", CurrentIndex)("count", GlobalChunkedArray->GetRecordsCount());
+}
+
 }   // namespace NKikimr::NArrow::NAccessor::NSubColumns
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/columns_storage.h b/ydb/core/formats/arrow/accessor/sub_columns/columns_storage.h
index 4fdbaf8c848e..9c7f4ac609e3 100644
--- a/ydb/core/formats/arrow/accessor/sub_columns/columns_storage.h
+++ b/ydb/core/formats/arrow/accessor/sub_columns/columns_storage.h
@@ -29,7 +29,7 @@ class TColumnsData {
     NJson::TJsonValue DebugJson() const {
         NJson::TJsonValue result = NJson::JSON_MAP;
         result.InsertValue("stats", Stats.DebugJson());
-        result.InsertValue("records", Records->DebugJson(true));
+        result.InsertValue("records", Records->DebugJson());
         return result;
     }
 
@@ -54,34 +54,7 @@ class TColumnsData {
         std::optional<IChunkedArray::TFullDataAddress> ChunkAddress;
         ui32 CurrentIndex = 0;
 
-        void InitArrays() {
-            while (CurrentIndex < GlobalChunkedArray->GetRecordsCount()) {
-                if (!FullArrayAddress || !FullArrayAddress->GetAddress().Contains(CurrentIndex)) {
-                    FullArrayAddress = GlobalChunkedArray->GetArray(FullArrayAddress, CurrentIndex, GlobalChunkedArray);
-                    ChunkAddress = std::nullopt;
-                }
-                const ui32 localIndex = FullArrayAddress->GetAddress().GetLocalIndex(CurrentIndex);
-                ChunkAddress = FullArrayAddress->GetArray()->GetChunk(ChunkAddress, localIndex);
-                AFL_VERIFY(ChunkAddress->GetArray()->type()->id() == arrow::utf8()->id());
-                CurrentArrayData = static_cast<const arrow::StringArray*>(ChunkAddress->GetArray().get());
-                if (FullArrayAddress->GetArray()->GetType() == IChunkedArray::EType::Array) {
-                    if (CurrentArrayData->IsNull(localIndex)) {
-                        Next();
-                    }
-                    break;
-                } else if (FullArrayAddress->GetArray()->GetType() == IChunkedArray::EType::SparsedArray) {
-                    if (CurrentArrayData->IsNull(localIndex) &&
-                        std::static_pointer_cast<TSparsedArray>(FullArrayAddress->GetArray())->GetDefaultValue() == nullptr) {
-                        CurrentIndex += ChunkAddress->GetArray()->length();
-                    } else {
-                        break;
-                    }
-                } else {
-                    AFL_VERIFY(false)("type", FullArrayAddress->GetArray()->GetType());
-                }
-            }
-            AFL_VERIFY(CurrentIndex <= GlobalChunkedArray->GetRecordsCount());
-        }
+        void InitArrays();
 
     public:
         TIterator(const ui32 keyIndex, const std::shared_ptr<IChunkedArray>& chunkedArray)
@@ -111,6 +84,23 @@ class TColumnsData {
             return CurrentIndex < GlobalChunkedArray->GetRecordsCount();
         }
 
+        bool SkipRecordTo(const ui32 recordIndex) {
+            if (recordIndex <= CurrentIndex) {
+                return true;
+            }
+            AFL_VERIFY(IsValid());
+            AFL_VERIFY(ChunkAddress->GetAddress().Contains(CurrentIndex));
+            CurrentIndex = recordIndex;
+            for (; CurrentIndex < ChunkAddress->GetAddress().GetGlobalFinishPosition(); ++CurrentIndex) {
+                if (CurrentArrayData->IsNull(CurrentIndex - ChunkAddress->GetAddress().GetGlobalStartPosition())) {
+                    continue;
+                }
+                return true;
+            }
+            InitArrays();
+            return IsValid();
+        }
+
         bool Next() {
             AFL_VERIFY(IsValid());
             AFL_VERIFY(ChunkAddress->GetAddress().Contains(CurrentIndex));
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/constructor.cpp b/ydb/core/formats/arrow/accessor/sub_columns/constructor.cpp
index 73e4cbe8ce0a..900049f303b5 100644
--- a/ydb/core/formats/arrow/accessor/sub_columns/constructor.cpp
+++ b/ydb/core/formats/arrow/accessor/sub_columns/constructor.cpp
@@ -27,13 +27,13 @@ TConclusion<std::shared_ptr<IChunkedArray>> TConstructor::DoDeserializeFromStrin
         auto schema = headerConclusion->GetColumnStats().BuildColumnsSchema();
         AFL_VERIFY(headerConclusion->GetColumnStats().GetColumnsCount() == (ui32)proto.GetKeyColumns().size())(
                                                                              "schema", headerConclusion->GetColumnStats().GetColumnsCount())(
-                                                  "proto", proto.GetKeyColumns().size());
+                                                                             "proto", proto.GetKeyColumns().size());
         for (ui32 i = 0; i < (ui32)proto.GetKeyColumns().size(); ++i) {
             std::shared_ptr<TColumnLoader> columnLoader = std::make_shared<TColumnLoader>(
                 externalInfo.GetDefaultSerializer(), headerConclusion->GetColumnStats().GetAccessorConstructor(i), schema->field(i), nullptr, 0);
-            std::vector<TDeserializeChunkedArray::TChunk> chunks = { TDeserializeChunkedArray::TChunk(
-                externalInfo.GetRecordsCount(), TStringBuf(originalData.data() + currentIndex, proto.GetKeyColumns(i).GetSize())) };
-            columns.emplace_back(std::make_shared<TDeserializeChunkedArray>(externalInfo.GetRecordsCount(), columnLoader, std::move(chunks), true));
+            std::shared_ptr<IChunkedArray> chunk = std::make_shared<TDeserializeChunkedArray>(externalInfo.GetRecordsCount(), columnLoader,
+                TStringBuf(originalData.data() + currentIndex, proto.GetKeyColumns(i).GetSize()), true);
+            columns.emplace_back(chunk);
             currentIndex += proto.GetKeyColumns(i).GetSize();
         }
         columnKeysContainer = std::make_shared<TGeneralContainer>(schema, std::move(columns));
@@ -67,7 +67,11 @@ bool TConstructor::DoDeserializeFromProto(const NKikimrArrowAccessorProto::TCons
 
 TConclusion<std::shared_ptr<IChunkedArray>> TConstructor::DoConstruct(
     const std::shared_ptr<IChunkedArray>& originalData, const TChunkConstructionData& /*externalInfo*/) const {
-    return NAccessor::TSubColumnsArray::Make(originalData, DataExtractor, Settings).DetachResult();
+    auto conclusion = NAccessor::TSubColumnsArray::Make(originalData, Settings);
+    if (conclusion.IsFail()) {
+        return conclusion;
+    }
+    return conclusion.DetachResult();
 }
 
 TString TConstructor::DoSerializeToString(const std::shared_ptr<IChunkedArray>& columnData, const TChunkConstructionData& externalInfo) const {
@@ -89,10 +93,8 @@ TConclusion<std::shared_ptr<TGeneralContainer>> TConstructor::BuildOthersContain
             columns.emplace_back(columnLoader->ApplyVerified(
                 TString(data.data() + currentIndex, proto.GetOtherColumns(i).GetSize()), proto.GetOtherRecordsCount()));
         } else {
-            std::vector<TDeserializeChunkedArray::TChunk> chunks = { TDeserializeChunkedArray::TChunk(
-                proto.GetOtherRecordsCount(), TStringBuf(data.data() + currentIndex, proto.GetOtherColumns(i).GetSize())) };
-            columns.emplace_back(
-                std::make_shared<TDeserializeChunkedArray>(proto.GetOtherRecordsCount(), columnLoader, std::move(chunks), true));
+            columns.emplace_back(std::make_shared<TDeserializeChunkedArray>(
+                proto.GetOtherRecordsCount(), columnLoader, TStringBuf(data.data() + currentIndex, proto.GetOtherColumns(i).GetSize()), true));
         }
         currentIndex += proto.GetOtherColumns(i).GetSize();
     }
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/constructor.h b/ydb/core/formats/arrow/accessor/sub_columns/constructor.h
index c9ef9bd1a352..dca602a38b7b 100644
--- a/ydb/core/formats/arrow/accessor/sub_columns/constructor.h
+++ b/ydb/core/formats/arrow/accessor/sub_columns/constructor.h
@@ -10,7 +10,6 @@ namespace NKikimr::NArrow::NAccessor::NSubColumns {
 class TConstructor: public IConstructor {
 private:
     using TBase = IConstructor;
-    std::shared_ptr<IDataAdapter> DataExtractor = std::make_shared<TFirstLevelSchemaData>();
     TSettings Settings;
 
 public:
@@ -43,6 +42,10 @@ class TConstructor: public IConstructor {
         : TBase(IChunkedArray::EType::SubColumnsArray) {
     }
 
+    virtual bool HasInternalConversion() const override {
+        return Settings.GetDataExtractor()->HasInternalConversion();
+    }
+
     static TConclusion<std::shared_ptr<TGeneralContainer>> BuildOthersContainer(
         const TStringBuf data, const NKikimrArrowAccessorProto::TSubColumnsAccessor& proto, const TChunkConstructionData& externalInfo, const bool deserialize);
 
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/data_extractor.cpp b/ydb/core/formats/arrow/accessor/sub_columns/data_extractor.cpp
index 7fe91d74686a..0bbf7abb273b 100644
--- a/ydb/core/formats/arrow/accessor/sub_columns/data_extractor.cpp
+++ b/ydb/core/formats/arrow/accessor/sub_columns/data_extractor.cpp
@@ -1,4 +1,6 @@
 #include "data_extractor.h"
+#include "direct_builder.h"
+#include "json_extractors.h"
 
 #include <util/string/split.h>
 #include <util/string/vector.h>
@@ -8,53 +10,103 @@
 
 namespace NKikimr::NArrow::NAccessor::NSubColumns {
 
-TConclusionStatus TFirstLevelSchemaData::DoAddDataToBuilders(
-    const std::shared_ptr<arrow::Array>& sourceArray, TDataBuilder& dataBuilder) const noexcept {
-    if (sourceArray->type()->id() != arrow::binary()->id()) {
-        return TConclusionStatus::Fail("incorrect base type for subcolumns schema usage");
+class TSimdBuffers: public TDataBuilder::IBuffers {
+private:
+    std::vector<simdjson::padded_string> PaddedStrings;
+    std::vector<TString> Strings;
+
+public:
+    TSimdBuffers(std::vector<simdjson::padded_string>&& paddedStrings, std::vector<TString>&& strings)
+        : PaddedStrings(std::move(paddedStrings))
+        , Strings(std::move(strings)) {
     }
+};
 
-    auto arr = std::static_pointer_cast<arrow::StringArray>(sourceArray);
+TConclusionStatus TJsonScanExtractor::DoAddDataToBuilders(const std::shared_ptr<arrow::Array>& sourceArray, TDataBuilder& dataBuilder) const {
+    auto arr = std::static_pointer_cast<arrow::BinaryArray>(sourceArray);
+    std::optional<bool> isBinaryJson;
+    if (arr->type()->id() == arrow::utf8()->id()) {
+        isBinaryJson = false;
+    }
+    if (!arr->length()) {
+        return TConclusionStatus::Success();
+    }
+    simdjson::ondemand::parser simdParser;
+    std::vector<simdjson::padded_string> paddedStrings;
+    std::vector<TString> forceSIMDStrings;
+    ui32 sumBuf = 0;
+    ui32 paddedBorder = 0;
+    for (i32 i = arr->length() - 1; i >= 1; --i) {
+        sumBuf += arr->GetView(i).size();
+        if (sumBuf > simdjson::SIMDJSON_PADDING) {
+            paddedBorder = i;
+            break;
+        }
+    }
     for (ui32 i = 0; i < arr->length(); ++i) {
         const auto view = arr->GetView(i);
         if (view.size() && !arr->IsNull(i)) {
-            //        NBinaryJson::TBinaryJson bJson(view.data(), view.size());
-            //        auto bJson = NBinaryJson::SerializeToBinaryJson(TStringBuf(view.data(), view.size()));
-            //        const NBinaryJson::TBinaryJson* bJsonParsed = std::get_if<NBinaryJson::TBinaryJson>(&bJson);
-            //        AFL_VERIFY(bJsonParsed)("error", *std::get_if<TString>(&bJson))("json", TStringBuf(view.data(), view.size()));
-            //        const NBinaryJson::TBinaryJson* bJsonParsed = &bJson;
-            auto reader = NBinaryJson::TBinaryJsonReader::Make(TStringBuf(view.data(), view.size()));
-            auto cursor = reader->GetRootCursor();
-            if (cursor.GetType() == NBinaryJson::EContainerType::Object) {
-                auto it = cursor.GetObjectIterator();
-                while (it.HasNext()) {
-                    auto [key, value] = it.Next();
-                    if (key.GetType() != NBinaryJson::EEntryType::String) {
-                        continue;
-                    }
-                    if (value.GetType() == NBinaryJson::EEntryType::String) {
-                        dataBuilder.AddKV(key.GetString(), value.GetString());
-                    } else if (value.GetType() == NBinaryJson::EEntryType::Number) {
-                        dataBuilder.AddKVOwn(key.GetString(), ::ToString(value.GetNumber()));
-                    } else if (value.GetType() == NBinaryJson::EEntryType::BoolFalse) {
-                        dataBuilder.AddKVOwn(key.GetString(), "0");
-                    } else if (value.GetType() == NBinaryJson::EEntryType::BoolTrue) {
-                        dataBuilder.AddKVOwn(key.GetString(), "1");
-                    } else {
-                        continue;
+            TStringBuf sbJson(view.data(), view.size());
+            if (!isBinaryJson) {
+                isBinaryJson = NBinaryJson::IsValidBinaryJson(sbJson);
+            }
+            TString json;
+            if (*isBinaryJson && ForceSIMDJsonParsing) {
+                json = NBinaryJson::SerializeToJson(sbJson);
+                forceSIMDStrings.emplace_back(json);
+                sbJson = TStringBuf(json.data(), json.size());
+            }
+            if (!json && *isBinaryJson) {
+                auto reader = NBinaryJson::TBinaryJsonReader::Make(sbJson);
+                auto cursor = reader->GetRootCursor();
+                std::deque<std::unique_ptr<IJsonObjectExtractor>> iterators;
+                if (cursor.GetType() == NBinaryJson::EContainerType::Object) {
+                    iterators.push_back(std::make_unique<TKVExtractor>(cursor.GetObjectIterator(), TStringBuf(), FirstLevelOnly));
+                } else if (cursor.GetType() == NBinaryJson::EContainerType::Array) {
+                    iterators.push_back(std::make_unique<TArrayExtractor>(cursor.GetArrayIterator(), TStringBuf(), FirstLevelOnly));
+                }
+                while (iterators.size()) {
+                    const auto conclusion = iterators.front()->Fill(dataBuilder, iterators);
+                    if (conclusion.IsFail()) {
+                        return conclusion;
                     }
+                    iterators.pop_front();
                 }
             } else {
-            //    return TConclusionStatus::Fail("incorrect json data: " + ::ToString((int)cursor.GetType()));
+                std::deque<std::unique_ptr<IJsonObjectExtractor>> iterators;
+                simdjson::simdjson_result<simdjson::ondemand::document> doc;
+                if (i < paddedBorder) {
+                    doc = simdParser.iterate(
+                        simdjson::padded_string_view(sbJson.data(), sbJson.size(), sbJson.size() + simdjson::SIMDJSON_PADDING));
+                } else {
+                    paddedStrings.emplace_back(simdjson::padded_string(sbJson.data(), sbJson.size()));
+                    doc = simdParser.iterate(paddedStrings.back());
+                }
+                auto conclusion = TSIMDExtractor(doc, FirstLevelOnly).Fill(dataBuilder, iterators);
+                if (conclusion.IsFail()) {
+                    return conclusion;
+                }
             }
         }
         dataBuilder.StartNextRecord();
     }
+    if (paddedStrings.size()) {
+        dataBuilder.StoreBuffer(std::make_shared<TSimdBuffers>(std::move(paddedStrings), std::move(forceSIMDStrings)));
+    }
     return TConclusionStatus::Success();
 }
 
 TConclusionStatus IDataAdapter::AddDataToBuilders(const std::shared_ptr<arrow::Array>& sourceArray, TDataBuilder& dataBuilder) const noexcept {
-    return DoAddDataToBuilders(sourceArray, dataBuilder);
+    try {
+        return DoAddDataToBuilders(sourceArray, dataBuilder);
+    } catch (...) {
+        return TConclusionStatus::Fail("exception on data extraction: " + CurrentExceptionMessage());
+    }
+}
+
+TDataAdapterContainer TDataAdapterContainer::GetDefault() {
+    static TDataAdapterContainer result(std::make_shared<NSubColumns::TJsonScanExtractor>());
+    return result;
 }
 
 }   // namespace NKikimr::NArrow::NAccessor::NSubColumns
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/data_extractor.h b/ydb/core/formats/arrow/accessor/sub_columns/data_extractor.h
index 631728c7ac00..aff5f957ada6 100644
--- a/ydb/core/formats/arrow/accessor/sub_columns/data_extractor.h
+++ b/ydb/core/formats/arrow/accessor/sub_columns/data_extractor.h
@@ -1,30 +1,121 @@
 #pragma once
-#include "direct_builder.h"
 
 #include <ydb/core/formats/arrow/accessor/abstract/accessor.h>
 #include <ydb/core/formats/arrow/arrow_helpers.h>
 
+#include <ydb/library/formats/arrow/protos/accessor.pb.h>
+#include <ydb/services/bg_tasks/abstract/interface.h>
+#include <ydb/services/metadata/abstract/request_features.h>
+
 #include <contrib/libs/apache/arrow/cpp/src/arrow/array/builder_base.h>
+#include <library/cpp/object_factory/object_factory.h>
 
 namespace NKikimr::NArrow::NAccessor::NSubColumns {
 
+class TDataBuilder;
+
 class IDataAdapter {
+public:
+    using TProto = NKikimrArrowAccessorProto::TDataExtractor;
+    using TFactory = NObjectFactory::TObjectFactory<IDataAdapter, TString>;
+
 private:
     virtual TConclusionStatus DoAddDataToBuilders(
-        const std::shared_ptr<arrow::Array>& sourceArray, TDataBuilder& dataBuilder) const noexcept = 0;
+        const std::shared_ptr<arrow::Array>& sourceArray, TDataBuilder& dataBuilder) const = 0;
+    virtual bool DoDeserializeFromProto(const TProto& proto) = 0;
+    virtual void DoSerializeToProto(TProto& proto) const = 0;
+    virtual NJson::TJsonValue DoDebugJson() const {
+        return NJson::JSON_MAP;
+    }
+    virtual TConclusionStatus DoDeserializeFromRequest(NYql::TFeaturesExtractor& features) = 0;
 
 public:
+    virtual bool HasInternalConversion() const = 0;
+    virtual TString GetClassName() const = 0;
+    bool DeserializeFromProto(const TProto& proto) {
+        return DoDeserializeFromProto(proto);
+    }
+
+    TConclusionStatus DeserializeFromRequest(NYql::TFeaturesExtractor& features) {
+        return DoDeserializeFromRequest(features);
+    }
+
+    NJson::TJsonValue DebugJson() const {
+        NJson::TJsonValue result = NJson::JSON_MAP;
+        result.InsertValue("class_name", GetClassName());
+        result.InsertValue("details", DoDebugJson());
+        return result;
+    }
+    void SerializeToProto(TProto& proto) const {
+        DoSerializeToProto(proto);
+    }
+
     virtual ~IDataAdapter() = default;
 
-    [[nodiscard]] TConclusionStatus AddDataToBuilders(const std::shared_ptr<arrow::Array>& sourceArray, TDataBuilder& dataBuilder) const noexcept;
+    [[nodiscard]] TConclusionStatus AddDataToBuilders(
+        const std::shared_ptr<arrow::Array>& sourceArray, TDataBuilder& dataBuilder) const noexcept;
 };
 
-class TFirstLevelSchemaData: public IDataAdapter {
+class TJsonScanExtractor: public IDataAdapter {
+public:
+    static TString GetClassNameStatic() {
+        return "JSON_SCANNER";
+    }
+
 private:
+    virtual bool HasInternalConversion() const override {
+        return true;
+    }
+
+    bool FirstLevelOnly = false;
+    bool ForceSIMDJsonParsing = false;
+    virtual TConclusionStatus DoDeserializeFromRequest(NYql::TFeaturesExtractor& features) override {
+        if (auto scanFlag = features.Extract<bool>("SCAN_FIRST_LEVEL_ONLY")) {
+            FirstLevelOnly = *scanFlag;
+        }
+        if (auto scanFlag = features.Extract<bool>("FORCE_SIMD_PARSING")) {
+            ForceSIMDJsonParsing = *scanFlag;
+        }
+        return TConclusionStatus::Success();
+    }
+
     virtual TConclusionStatus DoAddDataToBuilders(
-        const std::shared_ptr<arrow::Array>& sourceArray, TDataBuilder& dataBuilder) const noexcept override;
+        const std::shared_ptr<arrow::Array>& sourceArray, TDataBuilder& dataBuilder) const override;
+    virtual bool DoDeserializeFromProto(const TProto& proto) override {
+        if (!proto.HasJsonScanner() && !proto.HasSIMDJsonScanner()) {
+            return true;
+        }
+        FirstLevelOnly = proto.GetJsonScanner().GetFirstLevelOnly() || proto.GetSIMDJsonScanner().GetFirstLevelOnly();
+        ForceSIMDJsonParsing = proto.GetJsonScanner().GetForceSIMDJsonParsing();
+        return true;
+    }
+    virtual void DoSerializeToProto(TProto& proto) const override {
+        proto.MutableJsonScanner()->SetFirstLevelOnly(FirstLevelOnly);
+        proto.MutableJsonScanner()->SetForceSIMDJsonParsing(ForceSIMDJsonParsing);
+    }
+    virtual TString GetClassName() const override {
+        return GetClassNameStatic();
+    }
+
+    static const inline auto Registrator = TFactory::TRegistrator<TJsonScanExtractor>(GetClassNameStatic());
+    static const inline auto Registrator1 = TFactory::TRegistrator<TJsonScanExtractor>("BINARY_JSON_SCANNER");
+    static const inline auto Registrator2 = TFactory::TRegistrator<TJsonScanExtractor>("SIMD_JSON_SCANNER");
 
 public:
+    TJsonScanExtractor() = default;
+    TJsonScanExtractor(const bool firstLevelOnly)
+        : FirstLevelOnly(firstLevelOnly) {
+    }
+};
+
+class TDataAdapterContainer: public NBackgroundTasks::TInterfaceProtoContainer<IDataAdapter> {
+private:
+    using TBase = NBackgroundTasks::TInterfaceProtoContainer<IDataAdapter>;
+
+public:
+    static TDataAdapterContainer GetDefault();
+
+    using TBase::TBase;
 };
 
 }   // namespace NKikimr::NArrow::NAccessor::NSubColumns
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/direct_builder.cpp b/ydb/core/formats/arrow/accessor/sub_columns/direct_builder.cpp
index e5126a64dcf6..5b858f8787a5 100644
--- a/ydb/core/formats/arrow/accessor/sub_columns/direct_builder.cpp
+++ b/ydb/core/formats/arrow/accessor/sub_columns/direct_builder.cpp
@@ -5,6 +5,13 @@
 #include <ydb/core/formats/arrow/accessor/plain/accessor.h>
 #include <ydb/core/formats/arrow/accessor/sparsed/accessor.h>
 
+#include <contrib/libs/simdjson/include/simdjson/dom/array-inl.h>
+#include <contrib/libs/simdjson/include/simdjson/dom/document-inl.h>
+#include <contrib/libs/simdjson/include/simdjson/dom/element-inl.h>
+#include <contrib/libs/simdjson/include/simdjson/dom/object-inl.h>
+#include <contrib/libs/simdjson/include/simdjson/dom/parser-inl.h>
+#include <contrib/libs/simdjson/include/simdjson/ondemand.h>
+
 namespace NKikimr::NArrow::NAccessor::NSubColumns {
 
 void TColumnElements::BuildSparsedAccessor(const ui32 recordsCount) {
@@ -37,7 +44,7 @@ std::shared_ptr<TSubColumnsArray> TDataBuilder::Finish() {
     TSettings::TColumnsDistributor distributor = Settings.BuildDistributor(sumSize, CurrentRecordIndex);
     for (auto rIt = elementsBySize.rbegin(); rIt != elementsBySize.rend(); ++rIt) {
         for (auto&& i : rIt->second) {
-            switch (distributor.TakeAndDetect(rIt->first, i->GetRecordIndexes().size())) { 
+            switch (distributor.TakeAndDetect(rIt->first, i->GetRecordIndexes().size())) {
                 case TSettings::TColumnsDistributor::EColumnType::Separated:
                     columnElements.emplace_back(i);
                     break;
@@ -97,7 +104,7 @@ TOthersData TDataBuilder::MergeOthers(const std::vector<TColumnElements*>& other
     auto othersBuilder = TOthersData::MakeMergedBuilder();
     while (heap.size()) {
         std::pop_heap(heap.begin(), heap.end());
-        othersBuilder->Add(heap.back().GetRecordIndex(), heap.back().GetKeyIndex(), heap.back().GetValue());
+        othersBuilder->AddImpl(heap.back().GetRecordIndex(), heap.back().GetKeyIndex(), heap.back().GetValuePointer());
         if (!heap.back().Next()) {
             heap.pop_back();
         } else {
@@ -107,4 +114,44 @@ TOthersData TDataBuilder::MergeOthers(const std::vector<TColumnElements*>& other
     return othersBuilder->Finish(TOthersData::TFinishContext(BuildStats(otherKeys, Settings, recordsCount)));
 }
 
+std::string BuildString(const TStringBuf currentPrefix, const TStringBuf key) {
+    if (key.find(".") != std::string::npos) {
+        if (currentPrefix.size()) {
+            return Sprintf("%.*s.\"%.*s\"", currentPrefix.size(), currentPrefix.data(), key.size(), key.data());
+        } else {
+            return Sprintf("\"%.*s\"", key.size(), key.data());
+        }
+    } else {
+        if (currentPrefix.size()) {
+            return Sprintf("%.*s.%.*s", currentPrefix.size(), currentPrefix.data(), key.size(), key.data());
+        } else {
+            return std::string(key.data(), key.size());
+        }
+    }
+}
+
+TStringBuf TDataBuilder::AddKeyOwn(const TStringBuf currentPrefix, std::string&& key) {
+    auto it = StorageHash.find(TStorageAddress(currentPrefix, TStringBuf(key.data(), key.size())));
+    if (it == StorageHash.end()) {
+        Storage.emplace_back(std::move(key));
+        TStringBuf sbKey(Storage.back().data(), Storage.back().size());
+        it = StorageHash.emplace(TStorageAddress(currentPrefix, sbKey), BuildString(currentPrefix, sbKey)).first;
+    }
+    return TStringBuf(it->second.data(), it->second.size());
+}
+
+TStringBuf TDataBuilder::AddKey(const TStringBuf currentPrefix, const TStringBuf key) {
+    TStorageAddress keyAddress(currentPrefix, key);
+    auto it = StorageHash.find(keyAddress);
+    if (it == StorageHash.end()) {
+        it = StorageHash.emplace(keyAddress, BuildString(currentPrefix, key)).first;
+    }
+    return TStringBuf(it->second.data(), it->second.size());
+}
+
+TDataBuilder::TDataBuilder(const std::shared_ptr<arrow::DataType>& type, const TSettings& settings)
+    : Type(type)
+    , Settings(settings) {
+}
+
 }   // namespace NKikimr::NArrow::NAccessor::NSubColumns
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/direct_builder.h b/ydb/core/formats/arrow/accessor/sub_columns/direct_builder.h
index 5e7365b271c4..59a1d9ea93da 100644
--- a/ydb/core/formats/arrow/accessor/sub_columns/direct_builder.h
+++ b/ydb/core/formats/arrow/accessor/sub_columns/direct_builder.h
@@ -7,6 +7,8 @@
 #include <ydb/core/formats/arrow/arrow_helpers.h>
 
 #include <contrib/libs/apache/arrow/cpp/src/arrow/array/builder_base.h>
+#include <contrib/libs/xxhash/xxhash.h>
+#include <util/string/join.h>
 
 namespace NKikimr::NArrow::NAccessor {
 class TSubColumnsArray;
@@ -18,7 +20,6 @@ class TColumnElements {
 private:
     YDB_READONLY_DEF(TStringBuf, KeyName);
     YDB_READONLY_DEF(std::deque<TStringBuf>, Values);
-    std::vector<TString> ValuesStorage;
     YDB_READONLY_DEF(std::vector<ui32>, RecordIndexes);
     YDB_READONLY(ui32, DataSize, 0);
     std::shared_ptr<IChunkedArray> Accessor;
@@ -38,34 +39,82 @@ class TColumnElements {
 
     void AddData(const TStringBuf sb, const ui32 index) {
         Values.emplace_back(sb);
+        AFL_VERIFY(RecordIndexes.empty() || RecordIndexes.back() < index);
         RecordIndexes.emplace_back(index);
         DataSize += sb.size();
     }
-
-    void AddDataToOwn(const TString& value, const ui32 index) {
-        ValuesStorage.emplace_back(value);
-        AddData(TStringBuf(value.data(), value.size()), index);
-    }
 };
 
 class TDataBuilder {
+public:
+    class IBuffers {
+    public:
+        virtual ~IBuffers() = default;
+    };
+
 private:
+    class TStorageAddress {
+    private:
+        const TStringBuf Prefix;
+        const TStringBuf Key;
+        const size_t Hash;
+
+    public:
+        TStorageAddress(const TStringBuf prefix, const TStringBuf key)
+            : Prefix(prefix)
+            , Key(key)
+            , Hash(XXH3_64bits(Prefix.data(), Prefix.size()) ^ XXH3_64bits(Key.data(), Key.size())) {
+        }
+
+        operator size_t() const {
+            return Hash;
+        }
+
+        bool operator==(const TStorageAddress& item) const {
+            return Hash == item.Hash && Prefix == item.Prefix && Key == item.Key;
+        }
+    };
+
     ui32 CurrentRecordIndex = 0;
     THashMap<TStringBuf, TColumnElements> Elements;
-    std::deque<TString> Storage;
+    THashMap<TStorageAddress, std::string> StorageHash;
+    std::deque<std::string> Storage;
+    std::deque<TString> StorageStrings;
     const std::shared_ptr<arrow::DataType> Type;
     const TSettings Settings;
+    std::vector<std::shared_ptr<IBuffers>> Buffers;
 
 public:
-    TDataBuilder(const std::shared_ptr<arrow::DataType>& type, const TSettings& settings)
-        : Type(type)
-        , Settings(settings) {
+    TDataBuilder(const std::shared_ptr<arrow::DataType>& type, const TSettings& settings);
+
+    void StoreBuffer(const std::shared_ptr<IBuffers>& data) {
+        Buffers.emplace_back(data);
     }
 
     void StartNextRecord() {
         ++CurrentRecordIndex;
     }
 
+    TStringBuf AddKeyOwn(const TStringBuf currentPrefix, std::string&& key);
+    TStringBuf AddKey(const TStringBuf currentPrefix, const TStringBuf key);
+
+    void AddKVNull(const TStringBuf key) {
+        auto itElements = Elements.find(key);
+        if (itElements == Elements.end()) {
+            itElements = Elements.emplace(key, key).first;
+        }
+        itElements->second.AddData(GetNullString(), CurrentRecordIndex);
+    }
+
+    static const TString& GetNullString() {
+        const static TString nullString = "NULL";
+        return nullString;
+    }
+
+    static std::string_view GetNullStringView() {
+        return std::string_view(GetNullString().data(), GetNullString().size());
+    }
+
     void AddKV(const TStringBuf key, const TStringBuf value) {
         auto itElements = Elements.find(key);
         if (itElements == Elements.end()) {
@@ -74,13 +123,22 @@ class TDataBuilder {
         itElements->second.AddData(value, CurrentRecordIndex);
     }
 
-    void AddKVOwn(const TStringBuf key, const TString& value) {
-        Storage.emplace_back(value);
+    void AddKVOwn(const TStringBuf key, std::string&& value) {
+        Storage.emplace_back(std::move(value));
         auto itElements = Elements.find(key);
         if (itElements == Elements.end()) {
             itElements = Elements.emplace(key, key).first;
         }
-        itElements->second.AddData(value, CurrentRecordIndex);
+        itElements->second.AddData(Storage.back(), CurrentRecordIndex);
+    }
+
+    void AddKVOwn(const TStringBuf key, TString&& value) {
+        StorageStrings.emplace_back(std::move(value));
+        auto itElements = Elements.find(key);
+        if (itElements == Elements.end()) {
+            itElements = Elements.emplace(key, key).first;
+        }
+        itElements->second.AddData(StorageStrings.back(), CurrentRecordIndex);
     }
 
     class THeapElements {
@@ -108,8 +166,8 @@ class TDataBuilder {
             return KeyIndex;
         }
 
-        TStringBuf GetValue() const {
-            return Elements->GetValues()[Index];
+        const TStringBuf* GetValuePointer() const {
+            return &Elements->GetValues()[Index];
         }
 
         bool operator<(const THeapElements& item) const {
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/iterators.h b/ydb/core/formats/arrow/accessor/sub_columns/iterators.h
index bf642e0e330f..52c6453155c0 100644
--- a/ydb/core/formats/arrow/accessor/sub_columns/iterators.h
+++ b/ydb/core/formats/arrow/accessor/sub_columns/iterators.h
@@ -76,6 +76,38 @@ class TGeneralIterator {
     bool IsColumnKey() const {
         return IsColumnKeyFlag;
     }
+
+    bool SkipRecordTo(const ui32 recordIndex) {
+        struct TVisitor {
+        private:
+            TGeneralIterator& Owner;
+            const ui32 RecordIndex;
+        public:
+            TVisitor(TGeneralIterator& owner, const ui32 recordIndex)
+                : Owner(owner)
+                , RecordIndex(recordIndex)
+            {
+            }
+            bool operator()(TOthersData::TIterator& iterator) {
+                if (iterator.SkipRecordTo(RecordIndex)) {
+                    Owner.InitFromIterator(iterator);
+                } else {
+                    Owner.IsValidFlag = false;
+                }
+                return Owner.IsValidFlag;
+            }
+            bool operator()(TColumnsData::TIterator& iterator) {
+                if (iterator.SkipRecordTo(RecordIndex)) {
+                    Owner.InitFromIterator(iterator);
+                } else {
+                    Owner.IsValidFlag = false;
+                }
+                return Owner.IsValidFlag;
+            }
+        };
+        return std::visit(TVisitor(*this, recordIndex), Iterator);
+    }
+
     bool Next() {
         struct TVisitor {
         private:
@@ -182,6 +214,18 @@ class TReadIteratorUnorderedKeys {
         }
         finishRecordActor();
     }
+
+    void SkipRecordTo(const ui32 recordIndex) {
+        for (ui32 iIter = 0; iIter < SortedIterators.size();) {
+            if (!SortedIterators[iIter]->SkipRecordTo(recordIndex)) {
+                std::swap(SortedIterators[iIter], SortedIterators[SortedIterators.size() - 1]);
+                SortedIterators.pop_back();
+            } else {
+                AFL_VERIFY(recordIndex <= SortedIterators[iIter]->GetRecordIndex());
+                ++iIter;
+            }
+        }
+    }
 };
 
 class TReadIteratorOrderedKeys {
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/json_extractors.cpp b/ydb/core/formats/arrow/accessor/sub_columns/json_extractors.cpp
new file mode 100644
index 000000000000..3483ae1369b0
--- /dev/null
+++ b/ydb/core/formats/arrow/accessor/sub_columns/json_extractors.cpp
@@ -0,0 +1,79 @@
+#include "json_extractors.h"
+
+#include <util/string/split.h>
+#include <util/string/vector.h>
+#include <yql/essentials/types/binary_json/format.h>
+#include <yql/essentials/types/binary_json/read.h>
+#include <yql/essentials/types/binary_json/write.h>
+
+#include <math.h>
+
+namespace NKikimr::NArrow::NAccessor::NSubColumns {
+
+TConclusionStatus TArrayExtractor::DoFill(TDataBuilder& dataBuilder, std::deque<std::unique_ptr<IJsonObjectExtractor>>& iterators) {
+    ui32 idx = 0;
+    while (Iterator.HasNext()) {
+        auto value = Iterator.Next();
+        const TStringBuf key = dataBuilder.AddKeyOwn(GetPrefix(), "[" + std::to_string(idx++) + "]");
+        auto conclusion = AddDataToBuilder(dataBuilder, iterators, key, value);
+        if (conclusion.IsFail()) {
+            return conclusion;
+        }
+    }
+    return TConclusionStatus::Success();
+}
+
+TConclusionStatus TKVExtractor::DoFill(TDataBuilder& dataBuilder, std::deque<std::unique_ptr<IJsonObjectExtractor>>& iterators) {
+    while (Iterator.HasNext()) {
+        auto [jsonKey, value] = Iterator.Next();
+        if (jsonKey.GetType() != NBinaryJson::EEntryType::String) {
+            continue;
+        }
+        const TStringBuf key = dataBuilder.AddKey(GetPrefix(), jsonKey.GetString());
+        auto conclusion = AddDataToBuilder(dataBuilder, iterators, key, value);
+        if (conclusion.IsFail()) {
+            return conclusion;
+        }
+    }
+    return TConclusionStatus::Success();
+}
+
+TConclusionStatus IJsonObjectExtractor::AddDataToBuilder(TDataBuilder& dataBuilder,
+    std::deque<std::unique_ptr<IJsonObjectExtractor>>& iterators, const TStringBuf key, NBinaryJson::TEntryCursor& value) const {
+    if (value.GetType() == NBinaryJson::EEntryType::String) {
+        dataBuilder.AddKV(key, value.GetString());
+    } else if (value.GetType() == NBinaryJson::EEntryType::Number) {
+        const double val = value.GetNumber();
+        double integer;
+        if (modf(val, &integer)) {
+            dataBuilder.AddKVOwn(key, std::to_string(val));
+        } else {
+            dataBuilder.AddKVOwn(key, std::to_string((i64)integer));
+        }
+    } else if (value.GetType() == NBinaryJson::EEntryType::BoolFalse) {
+        static const TString zeroString = "0";
+        dataBuilder.AddKV(key, TStringBuf(zeroString.data(), zeroString.size()));
+    } else if (value.GetType() == NBinaryJson::EEntryType::BoolTrue) {
+        static const TString oneString = "1";
+        dataBuilder.AddKV(key, TStringBuf(oneString.data(), oneString.size()));
+    } else if (value.GetType() == NBinaryJson::EEntryType::Container) {
+        auto container = value.GetContainer();
+        if (FirstLevelOnly) {
+            dataBuilder.AddKVOwn(key, NBinaryJson::SerializeToJson(container));
+        } else if (container.GetType() == NBinaryJson::EContainerType::Array) {
+            iterators.emplace_back(std::make_unique<TArrayExtractor>(container.GetArrayIterator(), key));
+        } else if (container.GetType() == NBinaryJson::EContainerType::Object) {
+            iterators.emplace_back(std::make_unique<TKVExtractor>(container.GetObjectIterator(), key));
+        } else {
+            return TConclusionStatus::Fail("unexpected top value scalar in container iterator");
+        }
+
+    } else if (value.GetType() == NBinaryJson::EEntryType::Null) {
+        dataBuilder.AddKVNull(key);
+    } else {
+        return TConclusionStatus::Fail("unexpected json value type: " + ::ToString((int)value.GetType()));
+    }
+    return TConclusionStatus::Success();
+}
+
+}   // namespace NKikimr::NArrow::NAccessor::NSubColumns
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/json_extractors.h b/ydb/core/formats/arrow/accessor/sub_columns/json_extractors.h
new file mode 100644
index 000000000000..c0e61456c15c
--- /dev/null
+++ b/ydb/core/formats/arrow/accessor/sub_columns/json_extractors.h
@@ -0,0 +1,188 @@
+#pragma once
+#include "direct_builder.h"
+
+#include <contrib/libs/apache/arrow/cpp/src/arrow/array/builder_base.h>
+#include <contrib/libs/simdjson/include/simdjson/dom/array-inl.h>
+#include <contrib/libs/simdjson/include/simdjson/dom/document-inl.h>
+#include <contrib/libs/simdjson/include/simdjson/dom/element-inl.h>
+#include <contrib/libs/simdjson/include/simdjson/dom/object-inl.h>
+#include <contrib/libs/simdjson/include/simdjson/dom/parser-inl.h>
+#include <contrib/libs/simdjson/include/simdjson/ondemand.h>
+#include <yql/essentials/types/binary_json/read.h>
+
+namespace NKikimr::NArrow::NAccessor::NSubColumns {
+
+class IJsonObjectExtractor {
+private:
+    const TStringBuf Prefix;
+    virtual TConclusionStatus DoFill(TDataBuilder& dataBuilder, std::deque<std::unique_ptr<IJsonObjectExtractor>>& iterators) = 0;
+
+protected:
+    const bool FirstLevelOnly = false;
+    TStringBuf GetPrefix() const {
+        return Prefix;
+    }
+
+    [[nodiscard]] TConclusionStatus AddDataToBuilder(TDataBuilder& dataBuilder, std::deque<std::unique_ptr<IJsonObjectExtractor>>& iterators,
+        const TStringBuf key, NBinaryJson::TEntryCursor& value) const;
+
+public:
+    virtual ~IJsonObjectExtractor() = default;
+
+    IJsonObjectExtractor(const TStringBuf prefix, const bool firstLevelOnly)
+        : Prefix(prefix)
+        , FirstLevelOnly(firstLevelOnly) {
+    }
+
+    [[nodiscard]] TConclusionStatus Fill(TDataBuilder& dataBuilder, std::deque<std::unique_ptr<IJsonObjectExtractor>>& iterators) {
+        return DoFill(dataBuilder, iterators);
+    }
+};
+
+class TKVExtractor: public IJsonObjectExtractor {
+private:
+    using TBase = IJsonObjectExtractor;
+    NBinaryJson::TObjectIterator Iterator;
+    virtual TConclusionStatus DoFill(TDataBuilder& dataBuilder, std::deque<std::unique_ptr<IJsonObjectExtractor>>& iterators) override;
+
+public:
+    TKVExtractor(const NBinaryJson::TObjectIterator& iterator, const TStringBuf prefix, const bool firstLevelOnly = false)
+        : TBase(prefix, firstLevelOnly)
+        , Iterator(iterator) {
+    }
+};
+
+class TArrayExtractor: public IJsonObjectExtractor {
+private:
+    using TBase = IJsonObjectExtractor;
+    NBinaryJson::TArrayIterator Iterator;
+    virtual TConclusionStatus DoFill(TDataBuilder& dataBuilder, std::deque<std::unique_ptr<IJsonObjectExtractor>>& iterators) override;
+
+public:
+    TArrayExtractor(const NBinaryJson::TArrayIterator& iterator, const TStringBuf prefix, const bool firstLevelOnly = false)
+        : TBase(prefix, firstLevelOnly)
+        , Iterator(iterator) {
+    }
+};
+
+class TSIMDExtractor: public IJsonObjectExtractor {
+private:
+    using TBase = IJsonObjectExtractor;
+    simdjson::simdjson_result<simdjson::ondemand::document>& Document;
+
+#define RETURN_IF_NOT_SUCCESS(expr)                                                                        \
+    if (const auto& status = expr; Y_UNLIKELY(status != simdjson::SUCCESS)) {                              \
+        return TConclusionStatus::Fail("json parsing error: " + TString(simdjson::error_message(status))); \
+    }
+
+    TConclusion<std::string_view> PrintObject(simdjson::ondemand::value& value) const {
+        switch (value.type()) {
+            case simdjson::ondemand::json_type::string: {
+                auto sv = (std::string_view)value.raw_json_token();
+                AFL_VERIFY(sv.size() >= 2);
+                return std::string_view(sv.data() + 1, sv.size() - 2);
+            }
+            case simdjson::ondemand::json_type::null: {
+                return TDataBuilder::GetNullStringView();
+            }
+            case simdjson::ondemand::json_type::number:
+            case simdjson::ondemand::json_type::boolean: {
+                return (std::string_view)value.raw_json_token();
+            }
+            case simdjson::ondemand::json_type::object: {
+                simdjson::ondemand::object v;
+                RETURN_IF_NOT_SUCCESS(value.get(v));
+                return v.raw_json();
+            }
+            case simdjson::ondemand::json_type::array: {
+                simdjson::ondemand::array v;
+                RETURN_IF_NOT_SUCCESS(value.get(v));
+                return v.raw_json();
+            }
+        }
+    }
+
+    template <typename TOnDemandValue>
+        requires std::is_same_v<TOnDemandValue, simdjson::ondemand::value> || std::is_same_v<TOnDemandValue, simdjson::ondemand::document>
+    [[nodiscard]] TConclusionStatus ProcessValue(TDataBuilder& dataBuilder, TOnDemandValue& value, const TStringBuf currentKey) {
+        switch (value.type()) {
+            case simdjson::ondemand::json_type::string: {
+                auto sv = (std::string_view)value.raw_json_token();
+                AFL_VERIFY(sv.size() >= 2);
+                dataBuilder.AddKV(currentKey, TStringBuf(sv.data() + 1, sv.size() - 2));
+                break;
+            }
+            case simdjson::ondemand::json_type::null: {
+                dataBuilder.AddKVNull(currentKey);
+                break;
+            }
+            case simdjson::ondemand::json_type::number:
+            case simdjson::ondemand::json_type::boolean: {
+                dataBuilder.AddKV(currentKey, (std::string_view)value.raw_json_token());
+                break;
+            }
+            case simdjson::ondemand::json_type::array: {
+                simdjson::ondemand::array v;
+                RETURN_IF_NOT_SUCCESS(value.get(v));
+                ui32 idx = 0;
+                for (auto item : v) {
+                    RETURN_IF_NOT_SUCCESS(item.error());
+                    const TStringBuf sbKey = dataBuilder.AddKeyOwn(currentKey, "[" + std::to_string(idx++) + "]");
+                    if (FirstLevelOnly) {
+                        auto conclusion = PrintObject(item.value_unsafe());
+                        if (conclusion.IsFail()) {
+                            return conclusion;
+                        }
+                        dataBuilder.AddKV(sbKey, conclusion.DetachResult());
+                    } else {
+                        auto conclusion =
+                            ProcessValue(dataBuilder, item.value_unsafe(), sbKey);
+                        if (conclusion.IsFail()) {
+                            return conclusion;
+                        }
+                    }
+                }
+                break;
+            }
+            case simdjson::ondemand::json_type::object: {
+                simdjson::ondemand::object v;
+                RETURN_IF_NOT_SUCCESS(value.get(v));
+                for (auto item : v) {
+                    RETURN_IF_NOT_SUCCESS(item.error());
+                    auto& keyValue = item.value_unsafe();
+                    const auto key = keyValue.escaped_key();
+                    const auto sbKey = dataBuilder.AddKey(currentKey, key);
+                    if (FirstLevelOnly) {
+                        auto conclusion = PrintObject(keyValue.value());
+                        if (conclusion.IsFail()) {
+                            return conclusion;
+                        }
+                        dataBuilder.AddKV(sbKey, conclusion.DetachResult());
+                    } else {
+                        auto conclusion = ProcessValue(dataBuilder, keyValue.value(), sbKey);
+                        if (conclusion.IsFail()) {
+                            return conclusion;
+                        }
+                    }
+                }
+                break;
+            }
+        }
+
+        return TConclusionStatus::Success();
+    }
+
+    virtual TConclusionStatus DoFill(TDataBuilder& dataBuilder, std::deque<std::unique_ptr<IJsonObjectExtractor>>& /*iterators*/) override {
+        RETURN_IF_NOT_SUCCESS(Document.error());
+        return ProcessValue(dataBuilder, Document.value_unsafe(), TStringBuf());
+    }
+
+public:
+#undef RETURN_IF_NOT_SUCCESS
+    TSIMDExtractor(simdjson::simdjson_result<simdjson::ondemand::document>& document, const bool firstLevelOnly = false)
+        : TBase(TStringBuf(), firstLevelOnly)
+        , Document(document) {
+    }
+};
+
+}   // namespace NKikimr::NArrow::NAccessor::NSubColumns
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/others_storage.cpp b/ydb/core/formats/arrow/accessor/sub_columns/others_storage.cpp
index 58d1877d6496..36c8a7fe3edc 100644
--- a/ydb/core/formats/arrow/accessor/sub_columns/others_storage.cpp
+++ b/ydb/core/formats/arrow/accessor/sub_columns/others_storage.cpp
@@ -21,12 +21,14 @@ TOthersData::TBuilderWithStats::TBuilderWithStats() {
     Values = static_cast<arrow::StringBuilder*>(Builders[2].get());
 }
 
-void TOthersData::TBuilderWithStats::Add(const ui32 recordIndex, const ui32 keyIndex, const std::string_view value) {
+void TOthersData::TBuilderWithStats::AddImpl(const ui32 recordIndex, const ui32 keyIndex, const std::string_view* value) {
     AFL_VERIFY(Builders.size());
     if (StatsByKeyIndex.size() <= keyIndex) {
         StatsByKeyIndex.resize((keyIndex + 1) * 2);
     }
-    StatsByKeyIndex[keyIndex].AddValue(value);
+    if (value) {
+        StatsByKeyIndex[keyIndex].AddValue(*value);
+    }
     if (!LastRecordIndex) {
         LastRecordIndex = recordIndex;
         LastKeyIndex = keyIndex;
@@ -35,7 +37,11 @@ void TOthersData::TBuilderWithStats::Add(const ui32 recordIndex, const ui32 keyI
     }
     TStatusValidator::Validate(RecordIndex->Append(recordIndex));
     RTKeyIndexes.emplace_back(keyIndex);
-    TStatusValidator::Validate(Values->Append(value.data(), value.size()));
+    if (value) {
+        TStatusValidator::Validate(Values->Append(value->data(), value->size()));
+    } else {
+        TStatusValidator::Validate(Values->AppendNull());
+    }
     ++RecordsCount;
 }
 
@@ -247,7 +253,7 @@ std::shared_ptr<IChunkedArray> TOthersData::GetPathAccessor(const std::string_vi
         filter.Add(it.GetKeyIndex() == *idx);
     }
     auto recordsFiltered = Records;
-    AFL_VERIFY(filter.Apply(recordsFiltered));
+    filter.Apply(recordsFiltered);
     auto table = recordsFiltered->BuildTableVerified(std::set<std::string>({ "record_idx", "value" }));
 
     TSparsedArray::TBuilder builder(nullptr, arrow::utf8());
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/others_storage.h b/ydb/core/formats/arrow/accessor/sub_columns/others_storage.h
index 84ba8071f1e0..8917d6de63ec 100644
--- a/ydb/core/formats/arrow/accessor/sub_columns/others_storage.h
+++ b/ydb/core/formats/arrow/accessor/sub_columns/others_storage.h
@@ -73,6 +73,22 @@ class TOthersData {
             CurrentIndex = 0;
         }
 
+        bool SkipRecordTo(const ui32 recordIndex) {
+            AFL_VERIFY(IsValid());
+            if (recordIndex <= RecordIndex->Value(CurrentIndex)) {
+                return true;
+            }
+            auto idx = NArrow::FindUpperOrEqualPosition(*RecordIndex, recordIndex, CurrentIndex);
+            if (!idx) {
+                CurrentIndex = RecordIndex->length();
+                return false;
+            } else {
+                CurrentIndex = *idx;
+                AFL_VERIFY(recordIndex <= RecordIndex->Value(CurrentIndex));
+                return CurrentIndex < RecordsCount;
+            }
+        }
+
         std::optional<ui32> FindPosition(const ui32 findRecordIndex) const {
             return NArrow::FindUpperOrEqualPosition(*RecordIndex, findRecordIndex);
         }
@@ -173,11 +189,16 @@ class TOthersData {
         std::optional<ui32> LastKeyIndex;
         ui32 RecordsCount = 0;
         YDB_READONLY_DEF(std::vector<TDictStats::TRTStatsValue>, StatsByKeyIndex);
-
     public:
         TBuilderWithStats();
 
-        void Add(const ui32 recordIndex, const ui32 keyIndex, const std::string_view value);
+        void AddImpl(const ui32 recordIndex, const ui32 keyIndex, const std::string_view* value);
+        void Add(const ui32 recordIndex, const ui32 keyIndex, const std::string_view value) {
+            return AddImpl(recordIndex, keyIndex, &value);
+        }
+        void AddNull(const ui32 recordIndex, const ui32 keyIndex) {
+            return AddImpl(recordIndex, keyIndex, nullptr);
+        }
 
         TOthersData Finish(const TFinishContext& finishContext);
     };
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/request.cpp b/ydb/core/formats/arrow/accessor/sub_columns/request.cpp
index 82315e89737c..e0483ec58e6e 100644
--- a/ydb/core/formats/arrow/accessor/sub_columns/request.cpp
+++ b/ydb/core/formats/arrow/accessor/sub_columns/request.cpp
@@ -1,5 +1,6 @@
-#include "request.h"
 #include "constructor.h"
+#include "data_extractor.h"
+#include "request.h"
 
 namespace NKikimr::NArrow::NAccessor::NSubColumns {
 
@@ -20,6 +21,20 @@ TConclusionStatus TRequestedConstuctor::DoDeserializeFromRequest(NYql::TFeatures
     if (auto kff = features.Extract<ui32>("SPARSED_DETECTOR_KFF")) {
         Settings.SetSparsedDetectorKff(*kff);
     }
+    THolder<IDataAdapter> extractor;
+    if (auto dataExtractorClassName = features.Extract<TString>("DATA_EXTRACTOR_CLASS_NAME")) {
+        extractor = IDataAdapter::TFactory::MakeHolder(*dataExtractorClassName);
+        if (!extractor) {
+            return TConclusionStatus::Fail("incorrect data extractor class name");
+        }
+    } else {
+        extractor = MakeHolder<TJsonScanExtractor>(false);
+    }
+    auto parseConclusion = extractor->DeserializeFromRequest(features);
+    if (parseConclusion.IsFail()) {
+        return parseConclusion;
+    }
+    Settings.SetDataExtractor(std::shared_ptr<IDataAdapter>(extractor.Release()));
     if (auto memLimit = features.Extract<ui32>("MEM_LIMIT_CHUNK")) {
         Settings.SetChunkMemoryLimit(*memLimit);
     }
@@ -36,4 +51,4 @@ NKikimr::TConclusion<TConstructorContainer> TRequestedConstuctor::DoBuildConstru
     return std::make_shared<TConstructor>(Settings);
 }
 
-}
+}   // namespace NKikimr::NArrow::NAccessor::NSubColumns
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/settings.h b/ydb/core/formats/arrow/accessor/sub_columns/settings.h
index 45dda39ae0c4..0a6c38d5cb68 100644
--- a/ydb/core/formats/arrow/accessor/sub_columns/settings.h
+++ b/ydb/core/formats/arrow/accessor/sub_columns/settings.h
@@ -1,4 +1,6 @@
 #pragma once
+#include "data_extractor.h"
+
 #include <ydb/core/formats/arrow/accessor/abstract/accessor.h>
 #include <ydb/core/formats/arrow/arrow_helpers.h>
 
@@ -14,6 +16,7 @@ class TSettings {
     YDB_ACCESSOR(ui32, ColumnsLimit, 1024);
     YDB_ACCESSOR(ui32, ChunkMemoryLimit, 50 * 1024 * 1024);
     YDB_READONLY(double, OthersAllowedFraction, 0.05);
+    YDB_ACCESSOR_DEF(TDataAdapterContainer, DataExtractor);
 
 public:
     class TColumnsDistributor {
@@ -45,11 +48,14 @@ class TSettings {
     }
 
     TSettings() = default;
-    TSettings(const ui32 sparsedDetectorKff, const ui32 columnsLimit, const ui32 chunkMemoryLimit, const double othersAllowedFraction)
+    TSettings(const ui32 sparsedDetectorKff, const ui32 columnsLimit, const ui32 chunkMemoryLimit, const double othersAllowedFraction,
+        const TDataAdapterContainer& dataExtractor)
         : SparsedDetectorKff(sparsedDetectorKff)
         , ColumnsLimit(columnsLimit)
         , ChunkMemoryLimit(chunkMemoryLimit)
-        , OthersAllowedFraction(othersAllowedFraction) {
+        , OthersAllowedFraction(othersAllowedFraction)
+        , DataExtractor(dataExtractor) {
+        AFL_VERIFY(!!DataExtractor);
         AFL_VERIFY(OthersAllowedFraction >= 0 && OthersAllowedFraction <= 1)("others_fraction", OthersAllowedFraction);
     }
 
@@ -65,6 +71,7 @@ class TSettings {
         result.InsertValue("columns_limit", ColumnsLimit);
         result.InsertValue("memory_limit", ChunkMemoryLimit);
         result.InsertValue("others_allowed_fraction", OthersAllowedFraction);
+        result.InsertValue("data_extractor", DataExtractor->DebugJson());
         return result;
     }
 
@@ -79,6 +86,7 @@ class TSettings {
         result.SetColumnsLimit(ColumnsLimit);
         result.SetChunkMemoryLimit(ChunkMemoryLimit);
         result.SetOthersAllowedFraction(OthersAllowedFraction);
+        DataExtractor.SerializeToProto(*result.MutableDataExtractor());
     }
 
     template <class TProto>
@@ -87,6 +95,11 @@ class TSettings {
         ColumnsLimit = proto.GetColumnsLimit();
         ChunkMemoryLimit = proto.GetChunkMemoryLimit();
         OthersAllowedFraction = proto.GetOthersAllowedFraction();
+        if (!proto.HasDataExtractor()) {
+            AFL_VERIFY(DataExtractor.Initialize(TJsonScanExtractor::GetClassNameStatic()));
+        } else if (!DataExtractor.DeserializeFromProto(proto.GetDataExtractor())) {
+            return false;
+        }
         return true;
     }
 
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/signals.cpp b/ydb/core/formats/arrow/accessor/sub_columns/signals.cpp
new file mode 100644
index 000000000000..b8e60c8c8793
--- /dev/null
+++ b/ydb/core/formats/arrow/accessor/sub_columns/signals.cpp
@@ -0,0 +1,5 @@
+#include "signals.h"
+
+namespace NKikimr::NArrow::NAccessor ::NSubColumns{
+
+}   // namespace NKikimr::NArrow::NAccessor
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/signals.h b/ydb/core/formats/arrow/accessor/sub_columns/signals.h
new file mode 100644
index 000000000000..51c27b05af3d
--- /dev/null
+++ b/ydb/core/formats/arrow/accessor/sub_columns/signals.h
@@ -0,0 +1,73 @@
+#pragma once
+#include <ydb/library/signals/owner.h>
+
+#include <library/cpp/monlib/dynamic_counters/counters.h>
+
+namespace NKikimr::NArrow::NAccessor::NSubColumns {
+
+class TCategorySignals: public NColumnShard::TCommonCountersOwner {
+private:
+    using TBase = NColumnShard::TCommonCountersOwner;
+
+    NMonitoring::THistogramPtr HistogramRawDataSizeBytes;
+    NMonitoring::THistogramPtr HistogramRawDataSizeCount;
+    NMonitoring::THistogramPtr HistogramRawDataSizeDuration;
+
+    NMonitoring::THistogramPtr HistogramBlobDataSizeBytes;
+    NMonitoring::THistogramPtr HistogramBlobDataSizeCount;
+    NMonitoring::THistogramPtr HistogramBlobDataSizeDuration;
+
+public:
+    TCategorySignals(NColumnShard::TCommonCountersOwner& owner, const TString& categoryName)
+        : TBase(owner, "category", categoryName)
+        , HistogramRawDataSizeBytes(TBase::GetHistogram("RawData/BySize/Bytes", NMonitoring::ExponentialHistogram(15, 2, 100)))
+        , HistogramRawDataSizeCount(TBase::GetHistogram("RawData/BySize/Count", NMonitoring::ExponentialHistogram(15, 2, 100)))
+        , HistogramRawDataSizeDuration(TBase::GetHistogram("RawData/BySize/Duration/Us", NMonitoring::ExponentialHistogram(15, 2, 100)))
+        , HistogramBlobDataSizeBytes(TBase::GetHistogram("BlobData/BySize/Bytes", NMonitoring::ExponentialHistogram(15, 2, 100)))
+        , HistogramBlobDataSizeCount(TBase::GetHistogram("BlobData/BySize/Count", NMonitoring::ExponentialHistogram(15, 2, 100)))
+        , HistogramBlobDataSizeDuration(TBase::GetHistogram("BlobData/BySize/Duration/Us", NMonitoring::ExponentialHistogram(15, 2, 100))) {
+    }
+
+    void OnBlobSize(const i64 rawDataSize, const i64 blobDataSize, const TDuration d) const {
+        HistogramBlobDataSizeBytes->Collect(blobDataSize, blobDataSize);
+        HistogramBlobDataSizeCount->Collect(blobDataSize);
+        HistogramBlobDataSizeDuration->Collect(blobDataSize, d.MicroSeconds());
+
+        HistogramRawDataSizeBytes->Collect(rawDataSize, rawDataSize);
+        HistogramRawDataSizeCount->Collect(rawDataSize);
+        HistogramRawDataSizeDuration->Collect(rawDataSize, d.MicroSeconds());
+    }
+};
+
+class TSignalsImpl: public NColumnShard::TCommonCountersOwner {
+private:
+    using TBase = NColumnShard::TCommonCountersOwner;
+
+    TCategorySignals ColumnSignals;
+    TCategorySignals OtherSignals;
+
+public:
+    TSignalsImpl()
+        : TBase("sub_columns")
+        , ColumnSignals(*this, "columns")
+        , OtherSignals(*this, "other") {
+    }
+
+    const TCategorySignals& GetColumnSignals() const {
+        return ColumnSignals;
+    }
+    const TCategorySignals& GetOtherSignals() const {
+        return OtherSignals;
+    }
+};
+
+class TSignals {
+public:
+    static const TCategorySignals& GetColumnSignals() {
+        return Singleton<TSignalsImpl>()->GetColumnSignals();
+    }
+    static const TCategorySignals& GetOtherSignals() {
+        return Singleton<TSignalsImpl>()->GetOtherSignals();
+    }
+};
+}   // namespace NKikimr::NArrow::NAccessor::NSubColumns
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/ut/ut_sub_columns.cpp b/ydb/core/formats/arrow/accessor/sub_columns/ut/ut_sub_columns.cpp
index 40513d522380..edeef71ee950 100644
--- a/ydb/core/formats/arrow/accessor/sub_columns/ut/ut_sub_columns.cpp
+++ b/ydb/core/formats/arrow/accessor/sub_columns/ut/ut_sub_columns.cpp
@@ -49,7 +49,7 @@ Y_UNIT_TEST_SUITE(SubColumnsArrayAccessor) {
 
     Y_UNIT_TEST(SlicesDef) {
         for (ui32 colsCount = 0; colsCount < 5; ++colsCount) {
-            NSubColumns::TSettings settings(4, colsCount, 0, 0);
+            NSubColumns::TSettings settings(4, colsCount, 0, 0, NKikimr::NArrow::NAccessor::NSubColumns::TDataAdapterContainer::GetDefault());
 
             const std::vector<TString> jsons = {
                 R"({"a" : 1, "b" : 1, "c" : "111"})",
@@ -71,7 +71,7 @@ Y_UNIT_TEST_SUITE(SubColumnsArrayAccessor) {
                 ++idx;
             }
             auto bJsonArr = arrBuilder.Finish(jsons.size());
-            auto arrData = TSubColumnsArray::Make(bJsonArr, std::make_shared<NSubColumns::TFirstLevelSchemaData>(), settings).DetachResult();
+            auto arrData = TSubColumnsArray::Make(bJsonArr, settings).DetachResult();
             Cerr << arrData->DebugJson() << Endl;
             AFL_VERIFY(PrintBinaryJsons(arrData->GetChunkedArray()) == R"([[{"a":"1","b":"1","c":"111"},null,{"a1":"2","b":"2","c":"222"},{"a":"3","b":"3","c":"333"},null,{"a":"5","b1":"5"}]])")(
                     "string", PrintBinaryJsons(arrData->GetChunkedArray()));
@@ -141,7 +141,7 @@ Y_UNIT_TEST_SUITE(SubColumnsArrayAccessor) {
 
     Y_UNIT_TEST(FiltersDef) {
         for (ui32 colsCount = 0; colsCount < 5; ++colsCount) {
-            NSubColumns::TSettings settings(4, colsCount, 0, 0);
+            NSubColumns::TSettings settings(4, colsCount, 0, 0, NKikimr::NArrow::NAccessor::NSubColumns::TDataAdapterContainer::GetDefault());
 
             const std::vector<TString> jsons = {
                 R"({"a" : 1, "b" : 1, "c" : "111"})",
@@ -163,7 +163,7 @@ Y_UNIT_TEST_SUITE(SubColumnsArrayAccessor) {
                 ++idx;
             }
             auto bJsonArr = arrBuilder.Finish(jsons.size());
-            auto arrData = TSubColumnsArray::Make(bJsonArr, std::make_shared<NSubColumns::TFirstLevelSchemaData>(), settings).DetachResult();
+            auto arrData = TSubColumnsArray::Make(bJsonArr, settings).DetachResult();
             Cerr << arrData->DebugJson() << Endl;
             AFL_VERIFY(PrintBinaryJsons(arrData->GetChunkedArray()) == R"([[{"a":"1","b":"1","c":"111"},null,{"a1":"2","b":"2","c":"222"},{"a":"3","b":"3","c":"333"},null,{"a":"5","b1":"5"}]])")(
                     "string", PrintBinaryJsons(arrData->GetChunkedArray()));
diff --git a/ydb/core/formats/arrow/accessor/sub_columns/ya.make b/ydb/core/formats/arrow/accessor/sub_columns/ya.make
index 9b2f1d220205..13a710f8f96a 100644
--- a/ydb/core/formats/arrow/accessor/sub_columns/ya.make
+++ b/ydb/core/formats/arrow/accessor/sub_columns/ya.make
@@ -7,6 +7,7 @@ PEERDIR(
     ydb/core/formats/arrow/accessor/composite_serial
     ydb/core/formats/arrow/save_load
     ydb/core/formats/arrow/common
+    ydb/library/signals
     ydb/library/formats/arrow
     ydb/library/formats/arrow/protos
     yql/essentials/types/binary_json
@@ -18,6 +19,7 @@ SRCS(
     header.cpp
     partial.cpp
     data_extractor.cpp
+    json_extractors.cpp
     accessor.cpp
     direct_builder.cpp
     settings.cpp
@@ -25,10 +27,15 @@ SRCS(
     others_storage.cpp
     columns_storage.cpp
     iterators.cpp
+    signals.cpp
 )
 
 YQL_LAST_ABI_VERSION()
 
+CFLAGS(
+    -Wno-assume
+)
+
 END()
 
 RECURSE_FOR_TESTS(
diff --git a/ydb/core/formats/arrow/arrow_batch_builder.cpp b/ydb/core/formats/arrow/arrow_batch_builder.cpp
index ebd955833c8e..7db800ffd816 100644
--- a/ydb/core/formats/arrow/arrow_batch_builder.cpp
+++ b/ydb/core/formats/arrow/arrow_batch_builder.cpp
@@ -183,9 +183,13 @@ bool TRecordBatchReader::DeserializeFromStrings(const TString& schemaString, con
     return true;
 }
 
-TArrowBatchBuilder::TArrowBatchBuilder(arrow::Compression::type codec, const std::set<std::string>& notNullColumns)
+TArrowBatchBuilder::TArrowBatchBuilder(
+        arrow::Compression::type codec,
+        const std::set<std::string>& notNullColumns,
+        arrow::MemoryPool* memoryPool)
     : WriteOptions(arrow::ipc::IpcWriteOptions::Defaults())
     , NotNullColumns(notNullColumns)
+    , MemoryPool(memoryPool)
 {
     Y_ABORT_UNLESS(arrow::util::Codec::IsAvailable(codec));
     auto resCodec = arrow::util::Codec::Create(codec);
@@ -201,7 +205,7 @@ arrow::Status TArrowBatchBuilder::Start(const std::vector<std::pair<TString, NSc
     if (!schema.ok()) {
         return arrow::Status::FromArgs(schema.status().code(), "Cannot make arrow schema: ", schema.status().ToString());
     }
-    auto status = arrow::RecordBatchBuilder::Make(*schema, arrow::default_memory_pool(), RowsToReserve, &BatchBuilder);
+    auto status = arrow::RecordBatchBuilder::Make(*schema, MemoryPool, RowsToReserve, &BatchBuilder);
     NumRows = NumBytes = 0;
     if (!status.ok()) {
         return arrow::Status::FromArgs(schema.status().code(), "Cannot make arrow builder: ", status.ToString());
diff --git a/ydb/core/formats/arrow/arrow_batch_builder.h b/ydb/core/formats/arrow/arrow_batch_builder.h
index cacf7fd7882f..042d1bf35555 100644
--- a/ydb/core/formats/arrow/arrow_batch_builder.h
+++ b/ydb/core/formats/arrow/arrow_batch_builder.h
@@ -149,7 +149,10 @@ class TArrowBatchBuilder : public NKikimr::IBlockBuilder {
 
     /// @note compression is disabled by default KIKIMR-11690
     // Allowed codecs: UNCOMPRESSED, LZ4_FRAME, ZSTD
-    TArrowBatchBuilder(arrow::Compression::type codec = arrow::Compression::UNCOMPRESSED, const std::set<std::string>& notNullColumns = {});
+    TArrowBatchBuilder(
+        arrow::Compression::type codec = arrow::Compression::UNCOMPRESSED,
+        const std::set<std::string>& notNullColumns = {},
+        arrow::MemoryPool* memoryPool = arrow::default_memory_pool());
     ~TArrowBatchBuilder() = default;
 
     bool Start(const std::vector<std::pair<TString, NScheme::TTypeInfo>>& columns,
@@ -197,6 +200,7 @@ class TArrowBatchBuilder : public NKikimr::IBlockBuilder {
     std::shared_ptr<arrow::RecordBatch> Batch;
     size_t RowsToReserve{DEFAULT_ROWS_TO_RESERVE};
     const std::set<std::string> NotNullColumns;
+    arrow::MemoryPool* MemoryPool;
 
 protected:
     size_t NumRows{0};
diff --git a/ydb/core/formats/arrow/arrow_filter.cpp b/ydb/core/formats/arrow/arrow_filter.cpp
index d0e127dc91e8..7be4883bea85 100644
--- a/ydb/core/formats/arrow/arrow_filter.cpp
+++ b/ydb/core/formats/arrow/arrow_filter.cpp
@@ -16,127 +16,6 @@ namespace NKikimr::NArrow {
 
 #define Y_VERIFY_OK(status) Y_ABORT_UNLESS(status.ok(), "%s", status.ToString().c_str())
 
-namespace {
-enum class ECompareResult : i8 {
-    LESS = -1,
-    BORDER = 0,
-    GREATER = 1
-};
-
-template <typename TArray>
-inline auto GetValue(const std::shared_ptr<TArray>& array, int pos) {
-    return array->GetView(pos);
-}
-
-template <typename T>
-inline void UpdateCompare(const T& value, const T& border, ECompareResult& res) {
-    if (res == ECompareResult::BORDER) {
-        if constexpr (std::is_same_v<T, arrow::util::string_view>) {
-            size_t minSize = (value.size() < border.size()) ? value.size() : border.size();
-            int cmp = memcmp(value.data(), border.data(), minSize);
-            if (cmp < 0) {
-                res = ECompareResult::LESS;
-            } else if (cmp > 0) {
-                res = ECompareResult::GREATER;
-            } else {
-                UpdateCompare(value.size(), border.size(), res);
-            }
-        } else {
-            if (value < border) {
-                res = ECompareResult::LESS;
-            } else if (value > border) {
-                res = ECompareResult::GREATER;
-            }
-        }
-    }
-}
-
-template <typename TArray, typename T>
-bool CompareImpl(const std::shared_ptr<arrow::Array>& column, const T& border, std::vector<NArrow::ECompareResult>& rowsCmp) {
-    bool hasBorder = false;
-    ECompareResult* res = &rowsCmp[0];
-    auto array = std::static_pointer_cast<TArray>(column);
-
-    for (int i = 0; i < array->length(); ++i, ++res) {
-        UpdateCompare(GetValue(array, i), border, *res);
-        hasBorder = hasBorder || (*res == ECompareResult::BORDER);
-    }
-    return !hasBorder;
-}
-
-template <typename TArray, typename T>
-bool CompareImpl(const std::shared_ptr<arrow::ChunkedArray>& column, const T& border, std::vector<NArrow::ECompareResult>& rowsCmp) {
-    bool hasBorder = false;
-    ECompareResult* res = &rowsCmp[0];
-
-    for (auto& chunk : column->chunks()) {
-        auto array = std::static_pointer_cast<TArray>(chunk);
-
-        for (int i = 0; i < chunk->length(); ++i, ++res) {
-            UpdateCompare(GetValue(array, i), border, *res);
-            hasBorder = hasBorder || (*res == ECompareResult::BORDER);
-        }
-    }
-    return !hasBorder;
-}
-
-/// @return true in case we have no borders in compare: no need for future keys, allow early exit
-template <typename TArray>
-bool Compare(const arrow::Datum& column, const std::shared_ptr<arrow::Array>& borderArray, std::vector<NArrow::ECompareResult>& rowsCmp) {
-    auto border = GetValue(std::static_pointer_cast<TArray>(borderArray), 0);
-
-    switch (column.kind()) {
-        case arrow::Datum::ARRAY:
-            return CompareImpl<TArray>(column.make_array(), border, rowsCmp);
-        case arrow::Datum::CHUNKED_ARRAY:
-            return CompareImpl<TArray>(column.chunked_array(), border, rowsCmp);
-        default:
-            break;
-    }
-    Y_ABORT_UNLESS(false);
-    return false;
-}
-
-bool SwitchCompare(const arrow::Datum& column, const std::shared_ptr<arrow::Array>& border, std::vector<NArrow::ECompareResult>& rowsCmp) {
-    Y_ABORT_UNLESS(border->length() == 1);
-
-    // first time it's empty
-    if (rowsCmp.empty()) {
-        rowsCmp.resize(column.length(), ECompareResult::BORDER);
-    }
-
-    return SwitchArrayType(column, [&](const auto& type) -> bool {
-        using TWrap = std::decay_t<decltype(type)>;
-        using TArray = typename arrow::TypeTraits<typename TWrap::T>::ArrayType;
-        return Compare<TArray>(column, border, rowsCmp);
-    });
-}
-
-template <typename T>
-void CompositeCompare(std::shared_ptr<T> some, std::shared_ptr<arrow::RecordBatch> borderBatch, std::vector<NArrow::ECompareResult>& rowsCmp) {
-    AFL_VERIFY(some);
-    AFL_VERIFY(borderBatch);
-    auto key = borderBatch->schema()->fields();
-    AFL_VERIFY(key.size());
-
-    for (size_t i = 0; i < key.size(); ++i) {
-        auto& field = key[i];
-        auto typeId = field->type()->id();
-        auto column = some->GetColumnByName(field->name());
-        std::shared_ptr<arrow::Array> border = borderBatch->GetColumnByName(field->name());
-        AFL_VERIFY(column)("schema1", some->schema()->ToString())("schema2", borderBatch->schema()->ToString())("f", field->name());
-        AFL_VERIFY(border)("schema1", some->schema()->ToString())("schema2", borderBatch->schema()->ToString())("f", field->name());
-        AFL_VERIFY(some->schema()->GetFieldByName(field->name())->type()->id() == typeId)("schema1", some->schema()->ToString())(
-            "schema2", borderBatch->schema()->ToString())("f", field->name());
-
-        if (SwitchCompare(column, border, rowsCmp)) {
-            break;   // early exit in case we have all rows compared: no borders, can omit key tail
-        }
-    }
-}
-
-}   // namespace
-
 TColumnFilter::TSlicesIterator::TSlicesIterator(const TColumnFilter& owner, const std::optional<ui32> start, const std::optional<ui32> count)
     : Owner(owner)
     , StartIndex(start)
@@ -307,65 +186,10 @@ ui32 TColumnFilter::CrossSize(const ui32 s1, const ui32 f1, const ui32 s2, const
     return f - s;
 }
 
-NKikimr::NArrow::TColumnFilter TColumnFilter::MakePredicateFilter(
-    const arrow::Datum& datum, const arrow::Datum& border, ECompareType compareType) {
-    std::vector<ECompareResult> cmps;
-
-    switch (datum.kind()) {
-        case arrow::Datum::ARRAY:
-            Y_ABORT_UNLESS(border.kind() == arrow::Datum::ARRAY);
-            SwitchCompare(datum, border.make_array(), cmps);
-            break;
-        case arrow::Datum::CHUNKED_ARRAY:
-            Y_ABORT_UNLESS(border.kind() == arrow::Datum::ARRAY);
-            SwitchCompare(datum, border.make_array(), cmps);
-            break;
-        case arrow::Datum::RECORD_BATCH:
-            Y_ABORT_UNLESS(border.kind() == arrow::Datum::RECORD_BATCH);
-            CompositeCompare(datum.record_batch(), border.record_batch(), cmps);
-            break;
-        case arrow::Datum::TABLE:
-            Y_ABORT_UNLESS(border.kind() == arrow::Datum::RECORD_BATCH);
-            CompositeCompare(datum.table(), border.record_batch(), cmps);
-            break;
-        default:
-            Y_ABORT_UNLESS(false);
-            break;
-    }
-
-    std::vector<bool> bits;
-    bits.reserve(cmps.size());
-
-    switch (compareType) {
-        case ECompareType::LESS:
-            for (size_t i = 0; i < cmps.size(); ++i) {
-                bits.emplace_back(cmps[i] < ECompareResult::BORDER);
-            }
-            break;
-        case ECompareType::LESS_OR_EQUAL:
-            for (size_t i = 0; i < cmps.size(); ++i) {
-                bits.emplace_back(cmps[i] <= ECompareResult::BORDER);
-            }
-            break;
-        case ECompareType::GREATER:
-            for (size_t i = 0; i < cmps.size(); ++i) {
-                bits.emplace_back(cmps[i] > ECompareResult::BORDER);
-            }
-            break;
-        case ECompareType::GREATER_OR_EQUAL:
-            for (size_t i = 0; i < cmps.size(); ++i) {
-                bits.emplace_back(cmps[i] >= ECompareResult::BORDER);
-            }
-            break;
-    }
-
-    return NArrow::TColumnFilter(std::move(bits));
-}
-
 template <class TData>
-bool ApplyImpl(const TColumnFilter& filter, std::shared_ptr<TData>& batch, const TColumnFilter::TApplyContext& context) {
+void ApplyImpl(const TColumnFilter& filter, std::shared_ptr<TData>& batch, const TColumnFilter::TApplyContext& context) {
     if (!batch || !batch->num_rows()) {
-        return false;
+        return;
     }
     if (!filter.IsEmpty()) {
         if (context.HasSlice()) {
@@ -380,10 +204,10 @@ bool ApplyImpl(const TColumnFilter& filter, std::shared_ptr<TData>& batch, const
     }
     if (filter.IsTotalDenyFilter()) {
         batch = NAdapter::TDataBuilderPolicy<TData>::GetEmptySame(batch);
-        return true;
+        return;
     }
     if (filter.IsTotalAllowFilter()) {
-        return true;
+        return;
     }
     if (context.GetTrySlices() && filter.GetFilter().size() * 10 < filter.GetRecordsCountVerified() &&
         filter.GetRecordsCountVerified() < filter.GetFilteredCountVerified() * 50) {
@@ -394,18 +218,17 @@ bool ApplyImpl(const TColumnFilter& filter, std::shared_ptr<TData>& batch, const
     } else {
         batch = NAdapter::TDataBuilderPolicy<TData>::ApplyArrowFilter(batch, filter);
     }
-    return batch->num_rows();
 }
 
-bool TColumnFilter::Apply(std::shared_ptr<TGeneralContainer>& batch, const TApplyContext& context) const {
+void TColumnFilter::Apply(std::shared_ptr<TGeneralContainer>& batch, const TApplyContext& context) const {
     return ApplyImpl(*this, batch, context);
 }
 
-bool TColumnFilter::Apply(std::shared_ptr<arrow::Table>& batch, const TApplyContext& context) const {
+void TColumnFilter::Apply(std::shared_ptr<arrow::Table>& batch, const TApplyContext& context) const {
     return ApplyImpl(*this, batch, context);
 }
 
-bool TColumnFilter::Apply(std::shared_ptr<arrow::RecordBatch>& batch, const TApplyContext& context) const {
+void TColumnFilter::Apply(std::shared_ptr<arrow::RecordBatch>& batch, const TApplyContext& context) const {
     return ApplyImpl(*this, batch, context);
 }
 
@@ -785,25 +608,24 @@ TString TColumnFilter::DebugString() const {
     return sb;
 }
 
-TColumnFilter TColumnFilter::Cut(const ui32 filteredRecordsCount, const ui32 limit, const bool reverse) const {
+TColumnFilter TColumnFilter::Cut(const ui32 totalRecordsCount, const ui32 limit, const bool reverse) const {
     if (IsTotalDenyFilter()) {
         return TColumnFilter::BuildDenyFilter();
     }
     TColumnFilter result = TColumnFilter::BuildAllowFilter();
     if (IsTotalAllowFilter()) {
-        if (filteredRecordsCount <= limit) {
+        if (totalRecordsCount <= limit) {
             return result;
         }
         if (reverse) {
-            result.Add(false, filteredRecordsCount - limit);
+            result.Add(false, totalRecordsCount - limit);
             result.Add(true, limit);
         } else {
             result.Add(true, limit);
-            result.Add(false, filteredRecordsCount - limit);
+            result.Add(false, totalRecordsCount - limit);
         }
     } else {
-        AFL_VERIFY_DEBUG(GetFilteredCountVerified() == filteredRecordsCount)
-        ("filter", GetFilteredCountVerified())("total", GetRecordsCountVerified())("ext", filteredRecordsCount);
+        AFL_VERIFY(GetRecordsCountVerified() == totalRecordsCount)("total", GetRecordsCountVerified())("ext", totalRecordsCount);
         ui32 cutCount = 0;
         bool currentValue = reverse ? LastValue : GetStartValue();
         const auto scan = [&](auto begin, auto end) {
diff --git a/ydb/core/formats/arrow/arrow_filter.h b/ydb/core/formats/arrow/arrow_filter.h
index c93b086080ca..9a135f5961ae 100644
--- a/ydb/core/formats/arrow/arrow_filter.h
+++ b/ydb/core/formats/arrow/arrow_filter.h
@@ -86,7 +86,7 @@ class TColumnFilter {
         bool Next();
     };
 
-    TColumnFilter Cut(const ui32 filteredRecordsCount, const ui32 limit, const bool reverse) const;
+    TColumnFilter Cut(const ui32 totalRecordsCount, const ui32 limit, const bool reverse) const;
 
     TSlicesIterator BuildSlicesIterator(const std::optional<ui32> startIndex, const std::optional<ui32> count) const {
         return TSlicesIterator(*this, startIndex, count);
@@ -266,9 +266,6 @@ class TColumnFilter {
     TColumnFilter And(const TColumnFilter& extFilter) const Y_WARN_UNUSED_RESULT;
     TColumnFilter Or(const TColumnFilter& extFilter) const Y_WARN_UNUSED_RESULT;
 
-    // It makes a filter using composite predicate
-    static TColumnFilter MakePredicateFilter(const arrow::Datum& datum, const arrow::Datum& border, ECompareType compareType);
-
     class TApplyContext {
     private:
         YDB_READONLY_DEF(std::optional<ui32>, StartPos);
@@ -289,9 +286,9 @@ class TColumnFilter {
         TApplyContext& Slice(const ui32 start, const ui32 count);
     };
 
-    [[nodiscard]] bool Apply(std::shared_ptr<TGeneralContainer>& batch, const TApplyContext& context = Default<TApplyContext>()) const;
-    [[nodiscard]] bool Apply(std::shared_ptr<arrow::Table>& batch, const TApplyContext& context = Default<TApplyContext>()) const;
-    [[nodiscard]] bool Apply(std::shared_ptr<arrow::RecordBatch>& batch, const TApplyContext& context = Default<TApplyContext>()) const;
+    void Apply(std::shared_ptr<TGeneralContainer>& batch, const TApplyContext& context = Default<TApplyContext>()) const;
+    void Apply(std::shared_ptr<arrow::Table>& batch, const TApplyContext& context = Default<TApplyContext>()) const;
+    void Apply(std::shared_ptr<arrow::RecordBatch>& batch, const TApplyContext& context = Default<TApplyContext>()) const;
     void Apply(const ui32 expectedRecordsCount, std::vector<arrow::Datum*>& datums) const;
     [[nodiscard]] std::shared_ptr<NAccessor::IChunkedArray> Apply(
         const std::shared_ptr<NAccessor::IChunkedArray>& source, const TApplyContext& context = Default<TApplyContext>()) const;
diff --git a/ydb/core/formats/arrow/arrow_helpers.h b/ydb/core/formats/arrow/arrow_helpers.h
index f9bc678d6278..893c78af0ef7 100644
--- a/ydb/core/formats/arrow/arrow_helpers.h
+++ b/ydb/core/formats/arrow/arrow_helpers.h
@@ -12,18 +12,18 @@
 namespace NKikimr::NArrow {
 
 template <class TArray, class TValue>
-std::optional<ui32> FindUpperOrEqualPosition(const TArray& arr, const TValue val) {
+std::optional<ui32> FindUpperOrEqualPosition(const TArray& arr, const TValue val, const ui32 startIndex = 0) {
     if (!arr.length()) {
         return std::nullopt;
     }
-    TValue left = arr.Value(0);
+    TValue left = arr.Value(startIndex);
     TValue right = arr.Value(arr.length() - 1);
     if (val < left) {
-        return 0;
+        return startIndex;
     } else if (right < val) {
         return std::nullopt;
     } else if (val == left) {
-        return 0;
+        return startIndex;
     }
     ui32 idxLeft = 0;
     ui32 idxRight = arr.length() - 1;
@@ -40,6 +40,9 @@ std::optional<ui32> FindUpperOrEqualPosition(const TArray& arr, const TValue val
             idxRight = idxMiddle;
         }
     }
+    while (idxRight && arr.Value(idxRight) == arr.Value(idxRight - 1)) {
+        --idxRight;
+    }
     return idxRight;
 }
 arrow::Result<std::shared_ptr<arrow::DataType>> GetArrowType(NScheme::TTypeInfo typeInfo);
diff --git a/ydb/core/formats/arrow/common/container.cpp b/ydb/core/formats/arrow/common/container.cpp
index 8d7ff97342b1..fa382e9ede3f 100644
--- a/ydb/core/formats/arrow/common/container.cpp
+++ b/ydb/core/formats/arrow/common/container.cpp
@@ -155,23 +155,24 @@ std::shared_ptr<NKikimr::NArrow::TGeneralContainer> TGeneralContainer::BuildEmpt
 std::shared_ptr<arrow::Table> TGeneralContainer::BuildTableOptional(const TTableConstructionContext& context) const {
     std::vector<std::shared_ptr<arrow::ChunkedArray>> columns;
     std::vector<std::shared_ptr<arrow::Field>> fields;
+    std::optional<ui32> count;
     for (i32 i = 0; i < Schema->num_fields(); ++i) {
         if (context.GetColumnNames() && !context.GetColumnNames()->contains(Schema->field(i)->name())) {
             continue;
         }
-        if (context.GetRecordsCount() || context.GetStartIndex()) {
-            columns.emplace_back(Columns[i]->Slice(context.GetStartIndex().value_or(0),
-                context.GetRecordsCount().value_or(GetRecordsCount() - context.GetStartIndex().value_or(0))));
+        columns.emplace_back(Columns[i]->GetChunkedArray(context));
+        if (!count) {
+            count = columns.back()->length();
         } else {
-            columns.emplace_back(Columns[i]->GetChunkedArray());
+            AFL_VERIFY(*count == columns.back()->length())("count", count)("local", columns.back()->length());
         }
         fields.emplace_back(Schema->field(i));
     }
     if (fields.empty()) {
         return nullptr;
     }
-    AFL_VERIFY(RecordsCount);
-    return arrow::Table::Make(std::make_shared<arrow::Schema>(fields), columns, context.GetRecordsCount().value_or(*RecordsCount));
+    AFL_VERIFY(count);
+    return arrow::Table::Make(std::make_shared<arrow::Schema>(fields), columns, *count);
 }
 
 std::shared_ptr<arrow::Table> TGeneralContainer::BuildTableVerified(const TTableConstructionContext& context) const {
diff --git a/ydb/core/formats/arrow/common/container.h b/ydb/core/formats/arrow/common/container.h
index 0f78e2492527..28f9247e767e 100644
--- a/ydb/core/formats/arrow/common/container.h
+++ b/ydb/core/formats/arrow/common/container.h
@@ -86,11 +86,9 @@ class TGeneralContainer {
         return Columns[idx];
     }
 
-    class TTableConstructionContext {
+    class TTableConstructionContext: public NAccessor::TColumnConstructionContext {
     private:
         YDB_ACCESSOR_DEF(std::optional<std::set<std::string>>, ColumnNames);
-        YDB_ACCESSOR_DEF(std::optional<ui32>, StartIndex);
-        YDB_ACCESSOR_DEF(std::optional<ui32>, RecordsCount);
 
     public:
         TTableConstructionContext() = default;
diff --git a/ydb/core/formats/arrow/program/abstract.h b/ydb/core/formats/arrow/program/abstract.h
index 01724d31aeca..32e73482e962 100644
--- a/ydb/core/formats/arrow/program/abstract.h
+++ b/ydb/core/formats/arrow/program/abstract.h
@@ -13,6 +13,85 @@ class TAccessorsCollection;
 
 namespace NKikimr::NArrow::NSSA {
 
+class IMemoryCalculationPolicy {
+public:
+    enum class EStage {
+        Accessors = 0 /* "ACCESSORS" */,
+        Filter = 1 /* "FILTER" */,
+        Fetching = 2 /* "FETCHING" */,
+        Merge = 3 /* "MERGE" */
+    };
+
+    virtual ~IMemoryCalculationPolicy() = default;
+
+    virtual EStage GetStage() const = 0;
+    virtual ui64 GetReserveMemorySize(
+        const ui64 blobsSize, const ui64 rawSize, const std::optional<ui32> limit, const ui32 recordsCount) const = 0;
+};
+
+class TFilterCalculationPolicy: public IMemoryCalculationPolicy {
+public:
+    virtual EStage GetStage() const override {
+        return EStage::Filter;
+    }
+    virtual ui64 GetReserveMemorySize(
+        const ui64 blobsSize, const ui64 /*rawSize*/, const std::optional<ui32> /*limit*/, const ui32 /*recordsCount*/) const override {
+        return blobsSize;
+    }
+};
+
+class TFetchingCalculationPolicy: public IMemoryCalculationPolicy {
+public:
+    virtual EStage GetStage() const override {
+        return EStage::Fetching;
+    }
+    virtual ui64 GetReserveMemorySize(const ui64 blobsSize, const ui64 rawSize, const std::optional<ui32> limit, const ui32 recordsCount) const override {
+        if (limit) {
+            return std::max<ui64>(blobsSize, rawSize * (1.0 * *limit) / recordsCount);
+        } else {
+            return std::max<ui64>(blobsSize, rawSize);
+        }
+    }
+};
+
+class TIndexCheckOperation {
+public:
+    enum class EOperation : ui32 {
+        Equals,
+        StartsWith,
+        EndsWith,
+        Contains
+    };
+
+private:
+    const EOperation Operation;
+    YDB_READONLY(bool, CaseSensitive, true);
+
+public:
+    TString GetSignalId() const {
+        return TStringBuilder() << Operation << "::" << (CaseSensitive ? 1 : 0);
+    }
+
+    TString DebugString() const {
+        return TStringBuilder() << "{" << Operation << "," << CaseSensitive << "}";
+    }
+
+    EOperation GetOperation() const {
+        return Operation;
+    }
+
+    TIndexCheckOperation(const EOperation op, const bool caseSensitive)
+        : Operation(op)
+        , CaseSensitive(caseSensitive) {
+    }
+
+    explicit operator size_t() const {
+        return (size_t)Operation;
+    }
+
+    bool operator==(const TIndexCheckOperation& op) const = default;
+};
+
 using IChunkedArray = NAccessor::IChunkedArray;
 using TAccessorsCollection = NAccessor::TAccessorsCollection;
 
@@ -176,7 +255,8 @@ enum class EProcessorType {
     AssembleOriginalData,
     CheckIndexData,
     CheckHeaderData,
-    StreamLogic
+    StreamLogic,
+    ReserveMemory
 };
 
 class TFetchingInfo {
@@ -265,6 +345,13 @@ class IResourceProcessor {
         Input.emplace_back(TColumnChainInfo(resourceId));
     }
 
+    void AddOutput(const ui32 resourceId) {
+        for (auto&& i : Output) {
+            AFL_VERIFY(i.GetColumnId() != resourceId);
+        }
+        Output.emplace_back(TColumnChainInfo(resourceId));
+    }
+
     void RemoveInput(const ui32 resourceId) {
         for (ui32 idx = 0; idx < Input.size(); ++idx) {
             if (Input[idx].GetColumnId() == resourceId) {
diff --git a/ydb/core/formats/arrow/program/assign_internal.cpp b/ydb/core/formats/arrow/program/assign_internal.cpp
index a1432806e6c1..3493c8fc4394 100644
--- a/ydb/core/formats/arrow/program/assign_internal.cpp
+++ b/ydb/core/formats/arrow/program/assign_internal.cpp
@@ -40,40 +40,16 @@ TConclusion<std::shared_ptr<TCalculationProcessor>> TCalculationProcessor::Build
 
 NJson::TJsonValue TCalculationProcessor::DoDebugJson() const {
     NJson::TJsonValue result = NJson::JSON_MAP;
-    if (!!YqlOperationId) {
-        result.InsertValue("yql_op", ::ToString((NYql::TKernelRequestBuilder::EBinaryOp)*YqlOperationId));
-    }
-    if (!!KernelLogic) {
-        result.InsertValue("kernel", KernelLogic->GetClassName());
-    }
+    result.InsertValue("kernel", KernelLogic->DebugJson());
     return result;
 }
 
 ui64 TCalculationProcessor::DoGetWeight() const {
-    if (KernelLogic) {
-        return 0;
-    }
-    if (!YqlOperationId) {
-        return 10;
-    } else if ((NYql::TKernelRequestBuilder::EBinaryOp)*YqlOperationId == NYql::TKernelRequestBuilder::EBinaryOp::StartsWith ||
-               (NYql::TKernelRequestBuilder::EBinaryOp)*YqlOperationId == NYql::TKernelRequestBuilder::EBinaryOp::EndsWith) {
-        return 7;
-    } else if ((NYql::TKernelRequestBuilder::EBinaryOp)*YqlOperationId == NYql::TKernelRequestBuilder::EBinaryOp::StringContains) {
-        return 10;
-    } else if ((NYql::TKernelRequestBuilder::EBinaryOp)*YqlOperationId == NYql::TKernelRequestBuilder::EBinaryOp::Equals) {
-        return 5;
-    }
-    return 0;
+    return (ui64)KernelLogic->GetWeight();
 }
 
 TString TCalculationProcessor::DoGetSignalCategoryName() const {
-    if (KernelLogic) {
-        return ::ToString(GetProcessorType()) + "::" + KernelLogic->GetClassName();
-    } else if (YqlOperationId) {
-        return ::ToString(GetProcessorType()) + "::" + ::ToString((NYql::TKernelRequestBuilder::EBinaryOp)*YqlOperationId);
-    } else {
-        return ::ToString(GetProcessorType());
-    }
+    return ::ToString(GetProcessorType()) + "::" + KernelLogic->SignalDescription();
 }
 
 }   // namespace NKikimr::NArrow::NSSA
diff --git a/ydb/core/formats/arrow/program/assign_internal.h b/ydb/core/formats/arrow/program/assign_internal.h
index fb67c3c7de6c..213a7299b06a 100644
--- a/ydb/core/formats/arrow/program/assign_internal.h
+++ b/ydb/core/formats/arrow/program/assign_internal.h
@@ -11,7 +11,6 @@ class TCalculationProcessor: public IResourceProcessor {
 private:
     using TBase = IResourceProcessor;
 
-    YDB_ACCESSOR_DEF(std::optional<ui32>, YqlOperationId);
     YDB_ACCESSOR_DEF(std::shared_ptr<IKernelLogic>, KernelLogic);
 
     std::shared_ptr<IStepFunction> Function;
@@ -27,6 +26,7 @@ class TCalculationProcessor: public IResourceProcessor {
         : TBase(std::move(input), std::move(output), EProcessorType::Calculation)
         , KernelLogic(kernelLogic)
         , Function(function) {
+        AFL_VERIFY(KernelLogic);
     }
 
     virtual bool IsAggregation() const override {
@@ -37,7 +37,7 @@ class TCalculationProcessor: public IResourceProcessor {
 
 public:
     static TConclusion<std::shared_ptr<TCalculationProcessor>> Build(std::vector<TColumnChainInfo>&& input, const TColumnChainInfo& output, 
-        const std::shared_ptr<IStepFunction>& function, const std::shared_ptr<IKernelLogic>& kernelLogic = nullptr);
+        const std::shared_ptr<IStepFunction>& function, const std::shared_ptr<IKernelLogic>& kernelLogic);
 };
 
 }   // namespace NKikimr::NArrow::NSSA
diff --git a/ydb/core/formats/arrow/program/collection.cpp b/ydb/core/formats/arrow/program/collection.cpp
index 194fd984b59c..728a7a169345 100644
--- a/ydb/core/formats/arrow/program/collection.cpp
+++ b/ydb/core/formats/arrow/program/collection.cpp
@@ -9,6 +9,11 @@
 
 namespace NKikimr::NArrow::NAccessor {
 
+void TAccessorsCollection::Upsert(const ui32 columnId, const std::shared_ptr<IChunkedArray>& data, const bool withFilter) {
+    Remove(columnId, true);
+    AddVerified(columnId, data, withFilter);
+}
+
 void TAccessorsCollection::AddVerified(const ui32 columnId, const arrow::Datum& data, const bool withFilter) {
     AddVerified(columnId, TAccessorCollectedContainer(data), withFilter);
 }
diff --git a/ydb/core/formats/arrow/program/collection.h b/ydb/core/formats/arrow/program/collection.h
index 046f7a4c51d9..5d1f6a5b2996 100644
--- a/ydb/core/formats/arrow/program/collection.h
+++ b/ydb/core/formats/arrow/program/collection.h
@@ -43,6 +43,7 @@ class TAccessorsCollection {
     std::shared_ptr<TColumnFilter> Filter = std::make_shared<TColumnFilter>(TColumnFilter::BuildAllowFilter());
     bool UseFilter = true;
     std::optional<ui32> RecordsCountActual;
+    const std::optional<ui32> RecordsCountOriginal;
     THashSet<i64> Markers;
 
 public:
@@ -58,12 +59,19 @@ class TAccessorsCollection {
         AFL_VERIFY(Markers.erase(marker));
     }
 
-    bool IsEmptyFiltered() const {
+    bool IsEmptyFilter() const {
         return Filter->IsTotalDenyFilter();
     }
 
-    bool HasAccessors() const {
-        return Accessors.size();
+    bool HasData() const {
+        return Accessors.size() || !!RecordsCountActual;
+    }
+
+    bool HasDataAndResultIsEmpty() const {
+        if (!HasData()) {
+            return false;
+        }
+        return !GetRecordsCountActualVerified() || IsEmptyFilter();
     }
 
     std::optional<ui32> GetRecordsCountActualOptional() const {
@@ -75,9 +83,21 @@ class TAccessorsCollection {
         return *RecordsCountActual;
     }
 
+    ui32 GetRecordsCountRobustVerified() const {
+        if (UseFilter) {
+            AFL_VERIFY(!!RecordsCountActual);
+            return *RecordsCountActual;
+        } else {
+            AFL_VERIFY(!!RecordsCountOriginal);
+            return *RecordsCountOriginal;
+        }
+    }
+
     TAccessorsCollection() = default;
     TAccessorsCollection(const ui32 baseRecordsCount)
-        : RecordsCountActual(baseRecordsCount) {
+        : RecordsCountActual(baseRecordsCount)
+        , RecordsCountOriginal(baseRecordsCount)
+    {
     }
 
     std::optional<TAccessorsCollection> SelectOptional(const std::vector<ui32>& indexes, const bool withFilters) const;
@@ -149,6 +169,7 @@ class TAccessorsCollection {
     void AddVerified(const ui32 columnId, const arrow::Datum& data, const bool withFilter);
     void AddVerified(const ui32 columnId, const std::shared_ptr<IChunkedArray>& data, const bool withFilter);
     void AddVerified(const ui32 columnId, const TAccessorCollectedContainer& data, const bool withFilter);
+    void Upsert(const ui32 columnId, const std::shared_ptr<IChunkedArray>& data, const bool withFilter);
 
     void AddConstantVerified(const ui32 columnId, const std::shared_ptr<arrow::Scalar>& scalar) {
         AFL_VERIFY(columnId);
@@ -359,15 +380,14 @@ class TAccessorsCollection {
     }
 
     void CutFilter(const ui32 recordsCount, const ui32 limit, const bool reverse) {
-        const ui32 recordsCountImpl = Filter->GetFilteredCount().value_or(recordsCount);
-        if (recordsCountImpl < limit) {
+        if (recordsCount < limit) {
             return;
         }
         if (UseFilter) {
-            auto filter = NArrow::TColumnFilter::BuildAllowFilter().Cut(recordsCountImpl, limit, reverse);
+            auto filter = NArrow::TColumnFilter::BuildAllowFilter().Cut(recordsCount, limit, reverse);
             AddFilter(filter);
         } else {
-            *Filter = Filter->Cut(recordsCountImpl, limit, reverse);
+            *Filter = Filter->Cut(recordsCount, limit, reverse);
         }
     }
 
diff --git a/ydb/core/formats/arrow/program/execution.h b/ydb/core/formats/arrow/program/execution.h
index 348dea253feb..48b454f052a2 100644
--- a/ydb/core/formats/arrow/program/execution.h
+++ b/ydb/core/formats/arrow/program/execution.h
@@ -10,13 +10,6 @@
 
 namespace NKikimr::NArrow::NSSA {
 
-enum class EIndexCheckOperation {
-    Equals,
-    StartsWith,
-    EndsWith,
-    Contains
-};
-
 class TProcessorContext;
 
 class IFetchLogic {
@@ -153,15 +146,15 @@ class IDataSource {
 
     class TFetchIndexContext {
     public:
-        using EOperation = EIndexCheckOperation;
+        using TOperation = TIndexCheckOperation;
 
         class TOperationsBySubColumn {
         private:
             std::optional<bool> FullColumnOperations;
-            THashMap<TString, THashSet<EOperation>> Data;
+            THashMap<TString, THashSet<TOperation>> Data;
 
         public:
-            const THashMap<TString, THashSet<EOperation>>& GetData() const {
+            const THashMap<TString, THashSet<TOperation>>& GetData() const {
                 return Data;
             }
 
@@ -170,7 +163,7 @@ class IDataSource {
                 return !*FullColumnOperations;
             }
 
-            TOperationsBySubColumn& Add(const TString& subColumn, const EOperation operation, const bool strict = true) {
+            TOperationsBySubColumn& Add(const TString& subColumn, const TOperation operation, const bool strict = true) {
                 if (FullColumnOperations) {
                     AFL_VERIFY(*FullColumnOperations == !subColumn);
                 } else {
@@ -196,7 +189,7 @@ class IDataSource {
             for (auto&& i : OperationsBySubColumn.GetData()) {
                 auto& subColumnJson = result.InsertValue(i.first, NJson::JSON_ARRAY);
                 for (auto&& op : i.second) {
-                    subColumnJson.AppendValue(::ToString(op));
+                    subColumnJson.AppendValue(op.DebugString());
                 }
             }
             return result;
@@ -231,15 +224,19 @@ class IDataSource {
     private:
         YDB_READONLY(ui32, ColumnId, 0);
         YDB_READONLY_DEF(TString, SubColumnName);
-        YDB_READONLY(EIndexCheckOperation, Operation, EIndexCheckOperation::Equals);
+        TIndexCheckOperation Operation;
 
     public:
-        TCheckIndexContext(const ui32 columnId, const TString& subColumnName, const EIndexCheckOperation operation)
+        TCheckIndexContext(const ui32 columnId, const TString& subColumnName, const TIndexCheckOperation& operation)
             : ColumnId(columnId)
             , SubColumnName(subColumnName)
             , Operation(operation) {
         }
 
+        const TIndexCheckOperation& GetOperation() const {
+            return Operation;
+        }
+
         bool operator==(const TCheckIndexContext& item) const {
             return std::tie(ColumnId, SubColumnName, Operation) == std::tie(item.ColumnId, item.SubColumnName, item.Operation);
         }
@@ -279,9 +276,23 @@ class IDataSource {
     virtual TConclusion<bool> DoStartFetch(
         const NArrow::NSSA::TProcessorContext& context, const std::vector<std::shared_ptr<NArrow::NSSA::IFetchLogic>>& fetchers) = 0;
 
+    virtual TConclusion<bool> DoStartReserveMemory(const NArrow::NSSA::TProcessorContext& /*context*/,
+        const THashMap<ui32, IDataSource::TDataAddress>& /*columns*/, const THashMap<ui32, IDataSource::TFetchIndexContext>& /*indexes*/,
+        const THashMap<ui32, IDataSource::TFetchHeaderContext>& /*headers*/,
+        const std::shared_ptr<NArrow::NSSA::IMemoryCalculationPolicy>& /*policy*/) {
+        return false;
+    }
+
 public:
     virtual ~IDataSource() = default;
 
+    TConclusion<bool> StartReserveMemory(const NArrow::NSSA::TProcessorContext& context,
+        const THashMap<ui32, IDataSource::TDataAddress>& columns, const THashMap<ui32, IDataSource::TFetchIndexContext>& indexes,
+        const THashMap<ui32, IDataSource::TFetchHeaderContext>& headers, const std::shared_ptr<NArrow::NSSA::IMemoryCalculationPolicy>& policy) {
+        AFL_VERIFY(policy);
+        return DoStartReserveMemory(context, columns, indexes, headers, policy);
+    }
+
     TConclusion<bool> StartFetch(
         const NArrow::NSSA::TProcessorContext& context, const std::vector<std::shared_ptr<NArrow::NSSA::IFetchLogic>>& fetchers) {
         return DoStartFetch(context, fetchers);
diff --git a/ydb/core/formats/arrow/program/filter.cpp b/ydb/core/formats/arrow/program/filter.cpp
index 22d40ddbef6c..cd6bc9024047 100644
--- a/ydb/core/formats/arrow/program/filter.cpp
+++ b/ydb/core/formats/arrow/program/filter.cpp
@@ -105,7 +105,7 @@ TConclusion<IResourceProcessor::EExecutionResult> TFilterProcessor::DoExecute(
                                                      "input", inputColumns.front()->GetRecordsCount());
     if (context.GetLimit()) {
         context.GetResources()->AddFilter(
-            filter.Cut(context.GetResources()->GetRecordsCountActualVerified(), *context.GetLimit(), context.GetReverse()));
+            filter.Cut(context.GetResources()->GetRecordsCountRobustVerified(), *context.GetLimit(), context.GetReverse()));
     } else {
         context.GetResources()->AddFilter(filter);
     }
diff --git a/ydb/core/formats/arrow/program/graph_execute.cpp b/ydb/core/formats/arrow/program/graph_execute.cpp
index 0bd1f099f1a8..8628efe74738 100644
--- a/ydb/core/formats/arrow/program/graph_execute.cpp
+++ b/ydb/core/formats/arrow/program/graph_execute.cpp
@@ -3,6 +3,8 @@
 #include "graph_optimization.h"
 #include "visitor.h"
 
+#include <yql/essentials/minikql/mkql_terminator.h>
+
 namespace NKikimr::NArrow::NSSA::NGraph::NExecution {
 
 class TResourceUsageInfo {
@@ -102,7 +104,7 @@ TCompiledGraph::TCompiledGraph(const NOptimization::TGraph& original, const ICol
                 if (i.second->GetProcessor()->GetProcessorType() == EProcessorType::Filter) {
                     AFL_VERIFY(!IsFilterRoot(i.second->GetIdentifier()));
                     FilterRoot.emplace_back(i.second);
-                } else if (i.second->GetProcessor()->GetProcessorType() != EProcessorType::Const) {
+                } else if (i.second->GetProcessor()->GetProcessorType() == EProcessorType::Projection) {
                     AFL_VERIFY(!ResultRoot)("debug", DebugDOT());
                     ResultRoot = i.second;
                 } else {
@@ -122,6 +124,9 @@ TCompiledGraph::TCompiledGraph(const NOptimization::TGraph& original, const ICol
         for (; it->IsValid(); it->Next()) {
             it->MutableCurrentNode().SetSequentialIdx(currentIndex);
             for (auto&& i : it->GetProcessorVerified()->GetInput()) {
+                if (!i.GetColumnId()) {
+                    continue;
+                }
                 if (resolver.HasColumn(i.GetColumnId())) {
                     if (IsFilterRoot(it->GetCurrentGraphNode()->GetIdentifier())) {
                         FilterColumns.emplace(i.GetColumnId());
@@ -131,6 +136,9 @@ TCompiledGraph::TCompiledGraph(const NOptimization::TGraph& original, const ICol
                 usage[i.GetColumnId()].InUsage(currentIndex);
             }
             for (auto&& i : it->GetProcessorVerified()->GetOutput()) {
+                if (!i.GetColumnId()) {
+                    continue;
+                }
                 usage[i.GetColumnId()].Constructed(currentIndex);
             }
             sortedNodes.emplace_back(&it->MutableCurrentNode());
@@ -152,12 +160,13 @@ TCompiledGraph::TCompiledGraph(const NOptimization::TGraph& original, const ICol
         }
     }
     AFL_TRACE(NKikimrServices::SSA_GRAPH_EXECUTION)("graph_constructed", DebugDOT());
-//    Cerr << DebugDOT() << Endl;
+    //    Cerr << DebugDOT() << Endl;
 }
 
 TConclusionStatus TCompiledGraph::Apply(
     const std::shared_ptr<IDataSource>& source, const std::shared_ptr<TAccessorsCollection>& resources) const {
     TProcessorContext context(source, resources, std::nullopt, false);
+    NMiniKQL::TThrowingBindTerminator bind;
     std::shared_ptr<TExecutionVisitor> visitor = std::make_shared<TExecutionVisitor>(context);
     for (auto it = BuildIterator(visitor); it->IsValid();) {
         {
@@ -168,7 +177,7 @@ TConclusionStatus TCompiledGraph::Apply(
                 AFL_VERIFY(*conclusion != IResourceProcessor::EExecutionResult::InBackground);
             }
         }
-        if (resources->IsEmptyFiltered()) {
+        if (resources->HasDataAndResultIsEmpty()) {
             resources->Clear();
             return TConclusionStatus::Success();
         }
diff --git a/ydb/core/formats/arrow/program/graph_optimization.cpp b/ydb/core/formats/arrow/program/graph_optimization.cpp
index a907512237d9..54169173e0ab 100644
--- a/ydb/core/formats/arrow/program/graph_optimization.cpp
+++ b/ydb/core/formats/arrow/program/graph_optimization.cpp
@@ -5,12 +5,15 @@
 #include "header.h"
 #include "index.h"
 #include "original.h"
+#include "reserve.h"
 #include "stream_logic.h"
 
 #include <ydb/library/arrow_kernels/operations.h>
 #include <ydb/library/formats/arrow/switch/switch_type.h>
 
+#include <library/cpp/string_utils/quote/quote.h>
 #include <util/string/builder.h>
+#include <util/string/escape.h>
 #include <yql/essentials/core/arrow_kernels/request/request.h>
 
 namespace NKikimr::NArrow::NSSA::NGraph::NOptimization {
@@ -199,9 +202,12 @@ TConclusion<bool> TGraph::OptimizeMergeFetching(TGraphNode* baseNode) {
         if (!i.second->Is(EProcessorType::FetchOriginalData)) {
             continue;
         }
-        if (i.second->GetProcessorAs<TOriginalColumnDataProcessor>()->GetDataAddresses().size() + 
-            i.second->GetProcessorAs<TOriginalColumnDataProcessor>()->GetIndexContext().size() + 
-            i.second->GetProcessorAs<TOriginalColumnDataProcessor>()->GetHeaderContext().size() > 1) {
+        if (!i.second->AddOptimizerMarker(EOptimizerMarkers::FetchMerged)) {
+            continue;
+        }
+        if (i.second->GetProcessorAs<TOriginalColumnDataProcessor>()->GetDataAddresses().size() +
+                i.second->GetProcessorAs<TOriginalColumnDataProcessor>()->GetIndexContext().size() +
+                i.second->GetProcessorAs<TOriginalColumnDataProcessor>()->GetHeaderContext().size() > 1) {
             continue;
         }
         if (i.second->GetProcessorAs<TOriginalColumnDataProcessor>()->GetDataAddresses().size()) {
@@ -215,28 +221,44 @@ TConclusion<bool> TGraph::OptimizeMergeFetching(TGraphNode* baseNode) {
         }
     }
     bool changed = false;
+    TGraphNode* nodeFetch = nullptr;
     if (dataAddresses.size() > 1) {
         THashSet<ui32> columnIds;
         for (auto&& i : dataAddresses) {
             columnIds.emplace(i->GetProcessorAs<TOriginalColumnDataProcessor>()->GetOutputColumnIdOnce());
         }
-        auto proc =
-            std::make_shared<TOriginalColumnDataProcessor>(std::vector<ui32>(columnIds.begin(), columnIds.end()));
+        auto proc = std::make_shared<TOriginalColumnDataProcessor>(std::vector<ui32>(columnIds.begin(), columnIds.end()));
         for (auto&& i : dataAddresses) {
             for (auto&& addr : i->GetProcessorAs<TOriginalColumnDataProcessor>()->GetDataAddresses()) {
                 proc->Add(addr.second);
             }
         }
-        auto nodeFetch = AddNode(proc);
+        nodeFetch = AddNode(proc).get();
         FetchersMerged.emplace(nodeFetch->GetIdentifier());
         for (auto&& i : dataAddresses) {
-            for (auto&& to: i->GetOutputEdges()) {
-                AddEdge(nodeFetch.get(), to.second, to.first.GetResourceId());
+            for (auto&& to : i->GetOutputEdges()) {
+                AddEdge(nodeFetch, to.second, to.first.GetResourceId());
             }
             RemoveNode(i->GetIdentifier());
         }
         changed = true;
+    } else if (dataAddresses.size() == 1) {
+        nodeFetch = dataAddresses.front();
     }
+    if (nodeFetch) {
+        std::shared_ptr<IMemoryCalculationPolicy> policy;
+        if (baseNode->Is(EProcessorType::Filter)) {
+            policy = std::make_shared<TFilterCalculationPolicy>();
+        } else if (baseNode->Is(EProcessorType::Projection)) {
+            policy = std::make_shared<TFetchingCalculationPolicy>();
+        }
+        auto reserveMemory = std::make_shared<TReserveMemoryProcessor>(*nodeFetch->GetProcessorAs<TOriginalColumnDataProcessor>(), policy);
+        auto nodeReserve = AddNode(reserveMemory);
+        nodeReserve->GetProcessor()->AddOutput(0);
+        nodeFetch->GetProcessor()->AddInput(0);
+        AddEdge(nodeReserve.get(), nodeFetch, 0);
+    }
+
     if (indexes.size() + headers.size() > 1) {
         THashSet<ui32> columnIds;
         for (auto&& i : indexes) {
@@ -245,8 +267,7 @@ TConclusion<bool> TGraph::OptimizeMergeFetching(TGraphNode* baseNode) {
         for (auto&& i : headers) {
             columnIds.emplace(i->GetProcessorAs<TOriginalColumnDataProcessor>()->GetOutputColumnIdOnce());
         }
-        auto proc =
-            std::make_shared<TOriginalColumnDataProcessor>(std::vector<ui32>(columnIds.begin(), columnIds.end()));
+        auto proc = std::make_shared<TOriginalColumnDataProcessor>(std::vector<ui32>(columnIds.begin(), columnIds.end()));
         for (auto&& i : indexes) {
             for (auto&& addr : i->GetProcessorAs<TOriginalColumnDataProcessor>()->GetIndexContext()) {
                 proc->Add(addr.second);
@@ -345,12 +366,6 @@ std::optional<TResourceAddress> TGraph::GetOriginalAddress(TGraphNode* condNode)
             if (path.StartsWith("$.")) {
                 path = path.substr(2);
             }
-            if (path.StartsWith("\"") && path.EndsWith("\"")) {
-                if (path.size() < 2) {
-                    return std::nullopt;
-                }
-                path = path.substr(1, path.size() - 2);
-            }
             if (!path) {
                 return std::nullopt;
             }
@@ -367,11 +382,11 @@ TConclusion<bool> TGraph::OptimizeConditionsForIndexes(TGraphNode* condNode) {
     if (condNode->GetProcessor()->GetProcessorType() != EProcessorType::Calculation) {
         return false;
     }
-    if (condNode->GetProcessor()->GetInput().size() != 2) {
+    auto calc = condNode->GetProcessorAs<TCalculationProcessor>();
+    if (!calc->GetKernelLogic()) {
         return false;
     }
-    auto calc = condNode->GetProcessorAs<TCalculationProcessor>();
-    if (!calc->GetYqlOperationId()) {
+    if (condNode->GetProcessor()->GetInput().size() != 2) {
         return false;
     }
     if (condNode->GetOutputEdges().size() != 1) {
@@ -382,17 +397,7 @@ TConclusion<bool> TGraph::OptimizeConditionsForIndexes(TGraphNode* condNode) {
     if (constNode->GetProcessor()->GetProcessorType() != EProcessorType::Const) {
         return false;
     }
-    if (!!calc->GetKernelLogic()) {
-        if (!calc->GetKernelLogic()->IsBoolInResult()) {
-            return false;
-        }
-    }
-    if (calc->GetYqlOperationId()) {
-        if (!IsBoolResultYqlOperator((NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId())) {
-            return false;
-        }
-    }
-    if (!calc->GetYqlOperationId() && !calc->GetKernelLogic()) {
+    if (!calc->GetKernelLogic()->IsBoolInResult()) {
         return false;
     }
     std::optional<TResourceAddress> dataAddr = GetOriginalAddress(dataNode);
@@ -401,91 +406,44 @@ TConclusion<bool> TGraph::OptimizeConditionsForIndexes(TGraphNode* condNode) {
     }
     auto* dest = condNode->GetOutputEdges().begin()->second;
     const ui32 destResourceId = condNode->GetOutputEdges().begin()->first.GetResourceId();
-    if ((NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId() == NYql::TKernelRequestBuilder::EBinaryOp::Equals ||
-        (NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId() == NYql::TKernelRequestBuilder::EBinaryOp::StartsWith ||
-        (NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId() == NYql::TKernelRequestBuilder::EBinaryOp::EndsWith ||
-        (NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId() == NYql::TKernelRequestBuilder::EBinaryOp::StringContains) {
-        if (!IndexesConstructed.emplace(condNode->GetIdentifier()).second) {
-            return false;
-        }
-        RemoveEdge(condNode, dest, destResourceId);
-
-        const EIndexCheckOperation indexOperation = [&]() {
-            if ((NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId() == NYql::TKernelRequestBuilder::EBinaryOp::Equals) {
-                return EIndexCheckOperation::Equals;
-            }
-            if ((NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId() == NYql::TKernelRequestBuilder::EBinaryOp::StartsWith) {
-                return EIndexCheckOperation::StartsWith;
-            }
-            if ((NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId() == NYql::TKernelRequestBuilder::EBinaryOp::EndsWith) {
-                return EIndexCheckOperation::EndsWith;
-            }
-            if ((NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId() == NYql::TKernelRequestBuilder::EBinaryOp::StringContains) {
-                return EIndexCheckOperation::Contains;
-            }
-            return EIndexCheckOperation::Contains;
-            AFL_VERIFY(false);
-        }();
-
-        const ui32 resourceIdxFetch = BuildNextResourceId();
-        IDataSource::TFetchIndexContext indexContext(dataAddr->GetColumnId(),
-            IDataSource::TFetchIndexContext::TOperationsBySubColumn().Add(dataAddr->GetSubColumnName(), indexOperation));
-        auto indexFetchProc = std::make_shared<TOriginalColumnDataProcessor>(resourceIdxFetch, indexContext);
-        auto indexFetchNode = AddNode(indexFetchProc);
-        RegisterProducer(resourceIdxFetch, indexFetchNode.get());
-
-        const ui32 resourceIdIndexToAnd = BuildNextResourceId();
-        IDataSource::TCheckIndexContext checkIndexContext(dataAddr->GetColumnId(), dataAddr->GetSubColumnName(), indexOperation);
-        auto indexCheckProc = std::make_shared<TIndexCheckerProcessor>(
-            resourceIdxFetch, constNode->GetProcessor()->GetOutputColumnIdOnce(), checkIndexContext, resourceIdIndexToAnd);
-        auto indexProcNode = AddNode(indexCheckProc);
-        RegisterProducer(resourceIdIndexToAnd, indexProcNode.get());
-        AddEdge(indexFetchNode.get(), indexProcNode.get(), resourceIdxFetch);
-        AddEdge(constNode, indexProcNode.get(), constNode->GetProcessor()->GetOutputColumnIdOnce());
-
-        const ui32 resourceIdEqToAnd = BuildNextResourceId();
-        RegisterProducer(resourceIdEqToAnd, condNode);
-        calc->SetOutputResourceIdOnce(resourceIdEqToAnd);
-
-        auto andProcessor = std::make_shared<TStreamLogicProcessor>(TColumnChainInfo::BuildVector({ resourceIdEqToAnd, resourceIdIndexToAnd }),
-            TColumnChainInfo(destResourceId), NKernels::EOperation::And);
-        auto andNode = AddNode(andProcessor);
-        AddEdge(andNode.get(), dest, destResourceId);
-
-        AddEdge(indexProcNode.get(), andNode.get(), resourceIdIndexToAnd);
-        AddEdge(condNode, andNode.get(), resourceIdEqToAnd);
-        ResetProducer(destResourceId, andNode.get());
-        return true;
+    auto indexChecker = calc->GetKernelLogic()->GetIndexCheckerOperation();
+    if (!indexChecker) {
+        return false;
     }
-    return false;
-}
+    if (!IndexesConstructed.emplace(condNode->GetIdentifier()).second) {
+        return false;
+    }
+    RemoveEdge(condNode, dest, destResourceId);
 
-bool TGraph::IsBoolResultYqlOperator(const NYql::TKernelRequestBuilder::EBinaryOp op) const {
-    switch (op) {
-        case NYql::TKernelRequestBuilder::EBinaryOp::And:
-        case NYql::TKernelRequestBuilder::EBinaryOp::Or:
-        case NYql::TKernelRequestBuilder::EBinaryOp::Xor:
-            return true;
-        case NYql::TKernelRequestBuilder::EBinaryOp::Add:
-        case NYql::TKernelRequestBuilder::EBinaryOp::Sub:
-        case NYql::TKernelRequestBuilder::EBinaryOp::Mul:
-        case NYql::TKernelRequestBuilder::EBinaryOp::Div:
-        case NYql::TKernelRequestBuilder::EBinaryOp::Mod:
-        case NYql::TKernelRequestBuilder::EBinaryOp::Coalesce:
-            return false;
+    const ui32 resourceIdxFetch = BuildNextResourceId();
+    IDataSource::TFetchIndexContext indexContext(
+        dataAddr->GetColumnId(), IDataSource::TFetchIndexContext::TOperationsBySubColumn().Add(dataAddr->GetSubColumnName(), *indexChecker));
+    auto indexFetchProc = std::make_shared<TOriginalColumnDataProcessor>(resourceIdxFetch, indexContext);
+    auto indexFetchNode = AddNode(indexFetchProc);
+    RegisterProducer(resourceIdxFetch, indexFetchNode.get());
 
-        case NYql::TKernelRequestBuilder::EBinaryOp::StartsWith:
-        case NYql::TKernelRequestBuilder::EBinaryOp::EndsWith:
-        case NYql::TKernelRequestBuilder::EBinaryOp::StringContains:
+    const ui32 resourceIdIndexToAnd = BuildNextResourceId();
+    IDataSource::TCheckIndexContext checkIndexContext(dataAddr->GetColumnId(), dataAddr->GetSubColumnName(), *indexChecker);
+    auto indexCheckProc = std::make_shared<TIndexCheckerProcessor>(
+        resourceIdxFetch, constNode->GetProcessor()->GetOutputColumnIdOnce(), checkIndexContext, resourceIdIndexToAnd);
+    auto indexProcNode = AddNode(indexCheckProc);
+    RegisterProducer(resourceIdIndexToAnd, indexProcNode.get());
+    AddEdge(indexFetchNode.get(), indexProcNode.get(), resourceIdxFetch);
+    AddEdge(constNode, indexProcNode.get(), constNode->GetProcessor()->GetOutputColumnIdOnce());
 
-        case NYql::TKernelRequestBuilder::EBinaryOp::Equals:
-        case NYql::TKernelRequestBuilder::EBinaryOp::NotEquals:
-        case NYql::TKernelRequestBuilder::EBinaryOp::Less:
-        case NYql::TKernelRequestBuilder::EBinaryOp::LessOrEqual:
-        case NYql::TKernelRequestBuilder::EBinaryOp::Greater:
-        case NYql::TKernelRequestBuilder::EBinaryOp::GreaterOrEqual:
-            return true;
-    }
+    const ui32 resourceIdEqToAnd = BuildNextResourceId();
+    RegisterProducer(resourceIdEqToAnd, condNode);
+    calc->SetOutputResourceIdOnce(resourceIdEqToAnd);
+
+    auto andProcessor = std::make_shared<TStreamLogicProcessor>(
+        TColumnChainInfo::BuildVector({ resourceIdEqToAnd, resourceIdIndexToAnd }), TColumnChainInfo(destResourceId), NKernels::EOperation::And);
+    auto andNode = AddNode(andProcessor);
+    AddEdge(andNode.get(), dest, destResourceId);
+
+    AddEdge(indexProcNode.get(), andNode.get(), resourceIdIndexToAnd);
+    AddEdge(condNode, andNode.get(), resourceIdEqToAnd);
+    ResetProducer(destResourceId, andNode.get());
+    return true;
 }
 
 TConclusion<bool> TGraph::OptimizeConditionsForHeadersCheck(TGraphNode* condNode) {
@@ -501,17 +459,7 @@ TConclusion<bool> TGraph::OptimizeConditionsForHeadersCheck(TGraphNode* condNode
     }
     auto* dest = condNode->GetOutputEdges().begin()->second;
     const ui32 destResourceId = condNode->GetOutputEdges().begin()->first.GetResourceId();
-    if (!!calc->GetKernelLogic()) {
-        if (!calc->GetKernelLogic()->IsBoolInResult()) {
-            return false;
-        }
-    }
-    if (calc->GetYqlOperationId()) {
-        if (!IsBoolResultYqlOperator((NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId())) {
-            return false;
-        }
-    }
-    if (!calc->GetYqlOperationId() && !calc->GetKernelLogic()) {
+    if (!calc->GetKernelLogic() || !calc->GetKernelLogic()->IsBoolInResult()) {
         return false;
     }
     auto* node = GetProducerVerified(condNode->GetProcessor()->GetInput()[0].GetColumnId());
@@ -561,10 +509,11 @@ TConclusion<bool> TGraph::OptimizeFilterWithCoalesce(TGraphNode* cNode) {
         return false;
     }
     const auto calc = cNode->GetProcessorAs<TCalculationProcessor>();
-    if (!calc->GetYqlOperationId()) {
+    if (!calc->GetKernelLogic()->GetYqlOperationId()) {
         return false;
     }
-    if ((NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetYqlOperationId() != NYql::TKernelRequestBuilder::EBinaryOp::Coalesce) {
+    if ((NYql::TKernelRequestBuilder::EBinaryOp)*calc->GetKernelLogic()->GetYqlOperationId() !=
+        NYql::TKernelRequestBuilder::EBinaryOp::Coalesce) {
         return false;
     }
     if (cNode->GetOutputEdges().size() != 1) {
@@ -585,30 +534,14 @@ TConclusion<bool> TGraph::OptimizeFilterWithCoalesce(TGraphNode* cNode) {
 
     auto* nextNode = cNode->GetOutputEdges().begin()->second;
     if (nextNode->GetProcessor()->GetProcessorType() != EProcessorType::Filter) {
-        if (nextNode->GetProcessor()->GetProcessorType() == EProcessorType::Calculation) {
-            const auto outputCalc = nextNode->GetProcessorAs<TCalculationProcessor>();
-            if (!outputCalc->GetYqlOperationId()) {
-                return false;
-            }
-            if ((NYql::TKernelRequestBuilder::EBinaryOp)*outputCalc->GetYqlOperationId() != NYql::TKernelRequestBuilder::EBinaryOp::And) {
-                return false;
-            }
-        } else if (nextNode->GetProcessor()->GetProcessorType() == EProcessorType::StreamLogic) {
-            const auto outputCalc = nextNode->GetProcessorAs<TStreamLogicProcessor>();
-            if (outputCalc->GetOperation() != NKernels::EOperation::And) {
-                return false;
-            }
+        if (nextNode->GetProcessor()->GetProcessorType() != EProcessorType::StreamLogic) {
+            return false;
         }
-        if (nextNode->GetOutputEdges().size() != 1) {
+        const auto outputCalc = nextNode->GetProcessorAs<TStreamLogicProcessor>();
+        if (outputCalc->GetOperation() != NKernels::EOperation::And) {
             return false;
         }
-        if (nextNode->GetOutputEdges().begin()->second->GetProcessor()->GetProcessorType() == EProcessorType::StreamLogic) {
-            const auto outputCalc = nextNode->GetOutputEdges().begin()->second->GetProcessorAs<TStreamLogicProcessor>();
-            if (outputCalc->GetOperation() != NKernels::EOperation::And) {
-                return false;
-            }
-        } else if (nextNode->GetOutputEdges().begin()->second->GetProcessor()->GetProcessorType() == EProcessorType::Filter) {
-        } else {
+        if (nextNode->GetOutputEdges().size() != 1) {
             return false;
         }
     }
@@ -693,16 +626,16 @@ TConclusionStatus TGraph::Collapse() {
                 }
             }
 
-            {
-                auto conclusion = OptimizeConditionsForHeadersCheck(n.get());
-                if (conclusion.IsFail()) {
-                    return conclusion;
-                }
-                if (*conclusion) {
-                    hasChanges = true;
-                    break;
-                }
-            }
+            //            {
+            //                auto conclusion = OptimizeConditionsForHeadersCheck(n.get());
+            //                if (conclusion.IsFail()) {
+            //                    return conclusion;
+            //                }
+            //                if (*conclusion) {
+            //                    hasChanges = true;
+            //                    break;
+            //                }
+            //            }
 
             {
                 auto conclusion = OptimizeConditionsForStream(n.get());
diff --git a/ydb/core/formats/arrow/program/graph_optimization.h b/ydb/core/formats/arrow/program/graph_optimization.h
index 5fcf22495e12..ec5b97a138e2 100644
--- a/ydb/core/formats/arrow/program/graph_optimization.h
+++ b/ydb/core/formats/arrow/program/graph_optimization.h
@@ -47,8 +47,13 @@ class TResourceAddress {
     TString DebugString() const;
 };
 
+enum class EOptimizerMarkers {
+    FetchMerged
+};
+
 class TGraphNode {
 private:
+    std::set<EOptimizerMarkers> OptimizerMarkers;
     YDB_READONLY(i64, Identifier, 0);
     YDB_READONLY_DEF(std::shared_ptr<IResourceProcessor>, Processor);
     class TAddress {
@@ -81,6 +86,15 @@ class TGraphNode {
     std::map<TAddress, TGraphNode*> OutputEdges;
 
 public:
+
+    bool AddOptimizerMarker(const EOptimizerMarkers marker) {
+        return OptimizerMarkers.emplace(marker).second;
+    }
+
+    bool HasOptimizerMarker(const EOptimizerMarkers marker) {
+        return OptimizerMarkers.contains(marker);
+    }
+
     void AddEdgeTo(TGraphNode* to, const ui32 resourceId);
     void AddEdgeFrom(TGraphNode* from, const ui32 resourceId);
     void RemoveEdgeTo(const ui32 identifier, const ui32 resourceId);
@@ -147,7 +161,6 @@ class TGraph {
     std::optional<TResourceAddress> GetOriginalAddress(TGraphNode* condNode) const;
     TConclusion<bool> OptimizeForFetchSubColumns(TGraphNode* condNode);
     TConclusion<bool> OptimizeConditionsForHeadersCheck(TGraphNode* condNode);
-    bool IsBoolResultYqlOperator(const NYql::TKernelRequestBuilder::EBinaryOp op) const;
 
     TConclusion<bool> OptimizeConditionsForStream(TGraphNode* condNode);
     TConclusion<bool> OptimizeConditionsForIndexes(TGraphNode* condNode);
diff --git a/ydb/core/formats/arrow/program/header.cpp b/ydb/core/formats/arrow/program/header.cpp
index d2b9bc0010b2..9d80d38abe69 100644
--- a/ydb/core/formats/arrow/program/header.cpp
+++ b/ydb/core/formats/arrow/program/header.cpp
@@ -17,10 +17,10 @@ TConclusion<IResourceProcessor::EExecutionResult> THeaderCheckerProcessor::DoExe
     }
     if (conclusion->IsTotalDenyFilter()) {
         context.GetResources()->AddVerified(GetOutputColumnIdOnce(),
-            NAccessor::TSparsedArray::BuildFalseArrayUI8(context.GetResources()->GetRecordsCountActualVerified()), false);
+            NAccessor::TSparsedArray::BuildFalseArrayUI8(context.GetResources()->GetRecordsCountRobustVerified()), false);
     } else if (conclusion->IsTotalAllowFilter() || !ApplyToFilterFlag) {
         context.GetResources()->AddVerified(GetOutputColumnIdOnce(),
-            NAccessor::TSparsedArray::BuildTrueArrayUI8(context.GetResources()->GetRecordsCountActualVerified()), false);
+            NAccessor::TSparsedArray::BuildTrueArrayUI8(context.GetResources()->GetRecordsCountRobustVerified()), false);
     } else {
         context.GetResources()->AddFilter(*conclusion);
     }
diff --git a/ydb/core/formats/arrow/program/index.cpp b/ydb/core/formats/arrow/program/index.cpp
index bf955a4106a6..43ab8445caab 100644
--- a/ydb/core/formats/arrow/program/index.cpp
+++ b/ydb/core/formats/arrow/program/index.cpp
@@ -19,10 +19,10 @@ TConclusion<IResourceProcessor::EExecutionResult> TIndexCheckerProcessor::DoExec
     }
     if (conclusion->IsTotalDenyFilter()) {
         context.GetResources()->AddVerified(GetOutputColumnIdOnce(),
-            NAccessor::TSparsedArray::BuildFalseArrayUI8(context.GetResources()->GetRecordsCountActualVerified()), false);
+            NAccessor::TSparsedArray::BuildFalseArrayUI8(context.GetResources()->GetRecordsCountRobustVerified()), false);
     } else if (conclusion->IsTotalAllowFilter() || !ApplyToFilterFlag) {
         context.GetResources()->AddVerified(GetOutputColumnIdOnce(),
-            NAccessor::TSparsedArray::BuildTrueArrayUI8(context.GetResources()->GetRecordsCountActualVerified()), false);
+            NAccessor::TSparsedArray::BuildTrueArrayUI8(context.GetResources()->GetRecordsCountRobustVerified()), false);
     } else {
         context.GetResources()->AddFilter(*conclusion);
     }
diff --git a/ydb/core/formats/arrow/program/index.h b/ydb/core/formats/arrow/program/index.h
index 3a54dd9c5b14..1ff82c80164b 100644
--- a/ydb/core/formats/arrow/program/index.h
+++ b/ydb/core/formats/arrow/program/index.h
@@ -28,7 +28,7 @@ class TIndexCheckerProcessor: public IResourceProcessor {
     bool ApplyToFilterFlag = false;
 
     virtual TString DoGetSignalCategoryName() const override {
-        return ::ToString(GetProcessorType()) + "::" + ::ToString(IndexContext.GetOperation());
+        return ::ToString(GetProcessorType()) + "::" + IndexContext.GetOperation().GetSignalId();
     }
 
 public:
diff --git a/ydb/core/formats/arrow/program/kernel_logic.cpp b/ydb/core/formats/arrow/program/kernel_logic.cpp
index f20d22d9f55f..e0986354e88e 100644
--- a/ydb/core/formats/arrow/program/kernel_logic.cpp
+++ b/ydb/core/formats/arrow/program/kernel_logic.cpp
@@ -5,6 +5,8 @@
 #include <ydb/core/formats/arrow/accessor/sub_columns/accessor.h>
 #include <ydb/core/formats/arrow/accessor/sub_columns/partial.h>
 
+#include <yql/essentials/core/arrow_kernels/request/request.h>
+
 namespace NKikimr::NArrow::NSSA {
 
 TConclusion<bool> TGetJsonPath::DoExecute(const std::vector<TColumnChainInfo>& input, const std::vector<TColumnChainInfo>& output,
@@ -47,37 +49,6 @@ std::shared_ptr<IChunkedArray> TGetJsonPath::ExtractArray(const std::shared_ptr<
     }
 }
 
-std::optional<TFetchingInfo> TGetJsonPath::BuildFetchTask(const ui32 columnId, const NAccessor::IChunkedArray::EType arrType,
-    const std::vector<TColumnChainInfo>& input, const std::shared_ptr<TAccessorsCollection>& resources) const {
-    if (arrType != NAccessor::IChunkedArray::EType::SubColumnsArray) {
-        return TFetchingInfo::BuildFullRestore(false);
-    }
-    AFL_VERIFY(input.size() == 2 && input.front().GetColumnId() == columnId);
-    auto description = BuildDescription(input, resources).DetachResult();
-    const std::vector<TString> subColumns = { TString(description.GetJsonPath().data(), description.GetJsonPath().size()) };
-    if (!description.GetInputAccessor()) {
-        return TFetchingInfo::BuildSubColumnsRestore(subColumns);
-    }
-
-    std::optional<bool> hasSubColumns;
-    return NAccessor::TCompositeChunkedArray::VisitDataOwners<TFetchingInfo>(
-        description.GetInputAccessor(), [&](const std::shared_ptr<NAccessor::IChunkedArray>& arr) {
-            if (arr->GetType() == NAccessor::IChunkedArray::EType::SubColumnsPartialArray) {
-                AFL_VERIFY(!hasSubColumns || *hasSubColumns);
-                hasSubColumns = true;
-                auto scArr = std::static_pointer_cast<NAccessor::TSubColumnsPartialArray>(arr);
-                if (scArr->NeedFetch(description.GetJsonPath())) {
-                    return std::optional<TFetchingInfo>(TFetchingInfo::BuildSubColumnsRestore(subColumns));
-                }
-            } else {
-                AFL_VERIFY(arr->GetType() == NAccessor::IChunkedArray::EType::SubColumnsArray);
-                AFL_VERIFY(!hasSubColumns || !*hasSubColumns);
-                hasSubColumns = false;
-            }
-            return std::optional<TFetchingInfo>();
-        });
-}
-
 NAccessor::TCompositeChunkedArray::TBuilder TGetJsonPath::MakeCompositeBuilder() const {
     return NAccessor::TCompositeChunkedArray::TBuilder(arrow::utf8());
 }
@@ -99,4 +70,52 @@ NAccessor::TCompositeChunkedArray::TBuilder TExistsJsonPath::MakeCompositeBuilde
     return NAccessor::TCompositeChunkedArray::TBuilder(arrow::uint8());
 }
 
+TString TSimpleKernelLogic::SignalDescription() const {
+    if (YqlOperationId) {
+        return ::ToString((NYql::TKernelRequestBuilder::EBinaryOp)*YqlOperationId);
+    } else {
+        return "UNKNOWN";
+    }
+}
+
+bool TSimpleKernelLogic::IsBoolInResult() const {
+    if (YqlOperationId) {
+        switch ((NYql::TKernelRequestBuilder::EBinaryOp)*YqlOperationId) {
+            case NYql::TKernelRequestBuilder::EBinaryOp::And:
+            case NYql::TKernelRequestBuilder::EBinaryOp::Or:
+            case NYql::TKernelRequestBuilder::EBinaryOp::Xor:
+                return true;
+            case NYql::TKernelRequestBuilder::EBinaryOp::Add:
+            case NYql::TKernelRequestBuilder::EBinaryOp::Sub:
+            case NYql::TKernelRequestBuilder::EBinaryOp::Mul:
+            case NYql::TKernelRequestBuilder::EBinaryOp::Div:
+            case NYql::TKernelRequestBuilder::EBinaryOp::Mod:
+            case NYql::TKernelRequestBuilder::EBinaryOp::Coalesce:
+                return false;
+
+            case NYql::TKernelRequestBuilder::EBinaryOp::StartsWith:
+            case NYql::TKernelRequestBuilder::EBinaryOp::EndsWith:
+            case NYql::TKernelRequestBuilder::EBinaryOp::StringContains:
+
+            case NYql::TKernelRequestBuilder::EBinaryOp::Equals:
+            case NYql::TKernelRequestBuilder::EBinaryOp::NotEquals:
+            case NYql::TKernelRequestBuilder::EBinaryOp::Less:
+            case NYql::TKernelRequestBuilder::EBinaryOp::LessOrEqual:
+            case NYql::TKernelRequestBuilder::EBinaryOp::Greater:
+            case NYql::TKernelRequestBuilder::EBinaryOp::GreaterOrEqual:
+                return true;
+        }
+    } else {
+        return false;
+    }
+}
+
+NJson::TJsonValue TSimpleKernelLogic::DoDebugJson() const {
+    if (YqlOperationId) {
+        return ::ToString((NYql::TKernelRequestBuilder::EBinaryOp)*YqlOperationId);
+    } else {
+        return NJson::JSON_NULL;
+    }
+}
+
 }   // namespace NKikimr::NArrow::NSSA
diff --git a/ydb/core/formats/arrow/program/kernel_logic.h b/ydb/core/formats/arrow/program/kernel_logic.h
index c6488f691c57..d65405053c42 100644
--- a/ydb/core/formats/arrow/program/kernel_logic.h
+++ b/ydb/core/formats/arrow/program/kernel_logic.h
@@ -8,21 +8,52 @@
 
 namespace NKikimr::NArrow::NSSA {
 
+enum class ECalculationHardness {
+    JustAccessorUsage = 1,
+    NotSpecified = 3,
+    Equals = 5,
+    StringMatching = 10,
+    Unknown = 8
+};
+
 class IKernelLogic {
 private:
     virtual TConclusion<bool> DoExecute(const std::vector<TColumnChainInfo>& input, const std::vector<TColumnChainInfo>& output,
         const std::shared_ptr<TAccessorsCollection>& resources) const = 0;
 
+    virtual std::optional<TIndexCheckOperation> DoGetIndexCheckerOperation() const = 0;
+    YDB_ACCESSOR_DEF(std::optional<ui32>, YqlOperationId);
+    virtual NJson::TJsonValue DoDebugJson() const {
+        return NJson::JSON_NULL;
+    }
 public:
+    NJson::TJsonValue DebugJson() const {
+        NJson::TJsonValue result = NJson::JSON_MAP;
+        result.InsertValue("class_name", GetClassName());
+        auto details = DoDebugJson();
+        if (details.IsDefined()) {
+            result.InsertValue("details", std::move(details));
+        }
+        return result;
+    }
+
+    IKernelLogic() = default;
+
+    IKernelLogic(const ui32 yqlOperationId)
+        : YqlOperationId(yqlOperationId) {
+    }
+
     virtual ~IKernelLogic() = default;
 
+    virtual TString SignalDescription() const {
+        return GetClassName();
+    }
+    virtual ECalculationHardness GetWeight() const = 0;
+
     using TFactory = NObjectFactory::TObjectFactory<IKernelLogic, TString>;
 
     virtual TString GetClassName() const = 0;
 
-    virtual std::optional<TFetchingInfo> BuildFetchTask(const ui32 columnId, const NAccessor::IChunkedArray::EType arrType,
-        const std::vector<TColumnChainInfo>& input, const std::shared_ptr<TAccessorsCollection>& resources) const = 0;
-
     TConclusion<bool> Execute(const std::vector<TColumnChainInfo>& input, const std::vector<TColumnChainInfo>& output,
         const std::shared_ptr<TAccessorsCollection>& resources) const {
         if (!resources) {
@@ -32,6 +63,119 @@ class IKernelLogic {
     }
 
     virtual bool IsBoolInResult() const = 0;
+    std::optional<TIndexCheckOperation> GetIndexCheckerOperation() const {
+        return DoGetIndexCheckerOperation();
+    }
+};
+
+class TSimpleKernelLogic: public IKernelLogic {
+private:
+    using TBase = IKernelLogic;
+    YDB_READONLY_DEF(std::optional<ui32>, YqlOperationId);
+
+    virtual TConclusion<bool> DoExecute(const std::vector<TColumnChainInfo>& /*input*/, const std::vector<TColumnChainInfo>& /*output*/,
+        const std::shared_ptr<TAccessorsCollection>& /*resources*/) const override {
+        return false;
+    }
+
+    virtual NJson::TJsonValue DoDebugJson() const override;
+    virtual std::optional<TIndexCheckOperation> DoGetIndexCheckerOperation() const override {
+        return std::nullopt;
+    }
+
+public:
+    TSimpleKernelLogic() = default;
+    TSimpleKernelLogic(const ui32 yqlOperationId)
+        : TBase(yqlOperationId)
+        , YqlOperationId(yqlOperationId) {
+    }
+
+    virtual TString SignalDescription() const override;
+
+    virtual ECalculationHardness GetWeight() const override {
+        if (!YqlOperationId) {
+            return ECalculationHardness::Unknown;
+        }
+        return ECalculationHardness::NotSpecified;
+    }
+
+    virtual TString GetClassName() const override {
+        return "SIMPLE";
+    }
+
+    virtual bool IsBoolInResult() const override;
+};
+
+class TLogicMatchString: public IKernelLogic {
+private:
+    using TBase = IKernelLogic;
+    virtual TConclusion<bool> DoExecute(const std::vector<TColumnChainInfo>& /*input*/, const std::vector<TColumnChainInfo>& /*output*/,
+        const std::shared_ptr<TAccessorsCollection>& /*resources*/) const override {
+        return false;
+    }
+    virtual std::optional<TIndexCheckOperation> DoGetIndexCheckerOperation() const override {
+        return TIndexCheckOperation(Operation, CaseSensitive);
+    }
+    virtual ECalculationHardness GetWeight() const override {
+        return ECalculationHardness::StringMatching;
+    }
+
+    const TIndexCheckOperation::EOperation Operation;
+    const bool CaseSensitive;
+    const bool IsSimpleFunction;
+
+    virtual NJson::TJsonValue DoDebugJson() const override {
+        return ::ToString(Operation) + "::" + ::ToString(CaseSensitive) + "::" + ::ToString(IsSimpleFunction);
+    }
+
+public:
+    TLogicMatchString(const TIndexCheckOperation::EOperation operation, const bool caseSensitive, const bool isSimpleFunction)
+        : Operation(operation)
+        , CaseSensitive(caseSensitive)
+        , IsSimpleFunction(isSimpleFunction) {
+    }
+
+    virtual TString SignalDescription() const override {
+        return "MATCH_STRING::" + ::ToString(Operation) + "::" + ::ToString(CaseSensitive);
+    }
+
+    virtual TString GetClassName() const override {
+        return "MATCH_STRING";
+    }
+
+    virtual bool IsBoolInResult() const override {
+        return !IsSimpleFunction;
+    }
+};
+
+class TLogicEquals: public IKernelLogic {
+private:
+    using TBase = IKernelLogic;
+    virtual TConclusion<bool> DoExecute(const std::vector<TColumnChainInfo>& /*input*/, const std::vector<TColumnChainInfo>& /*output*/,
+        const std::shared_ptr<TAccessorsCollection>& /*resources*/) const override {
+        return false;
+    }
+    virtual std::optional<TIndexCheckOperation> DoGetIndexCheckerOperation() const override {
+        return TIndexCheckOperation(TIndexCheckOperation::EOperation::Equals, true);
+    }
+    const bool IsSimpleFunction;
+
+    virtual ECalculationHardness GetWeight() const override {
+        return ECalculationHardness::Equals;
+    }
+
+public:
+    TLogicEquals(const bool isSimpleFunction)
+        : IsSimpleFunction(isSimpleFunction) {
+    }
+
+    virtual TString GetClassName() const override {
+        return "EQUALS";
+    }
+
+    virtual bool IsBoolInResult() const override {
+        return !IsSimpleFunction;
+    }
 };
 
 class TGetJsonPath: public IKernelLogic {
@@ -39,6 +183,13 @@ class TGetJsonPath: public IKernelLogic {
     static TString GetClassNameStatic() {
         return "JsonValue";
     }
+    virtual std::optional<TIndexCheckOperation> DoGetIndexCheckerOperation() const override {
+        return std::nullopt;
+    }
+
+    virtual ECalculationHardness GetWeight() const override {
+        return ECalculationHardness::JustAccessorUsage;
+    }
 
 private:
     virtual bool IsBoolInResult() const override {
@@ -81,9 +232,6 @@ class TGetJsonPath: public IKernelLogic {
             return TConclusionStatus::Fail("incorrect path format: have to be as '$.**...**'");
         }
         svPath = svPath.substr(2);
-        if (svPath.starts_with("\"") && svPath.ends_with("\"") && svPath.size() > 2) {
-            svPath = svPath.substr(1, svPath.size() - 2);
-        }
 
         return TDescription(resources->GetAccessorOptional(input.front().GetColumnId()), svPath);
     }
@@ -94,9 +242,6 @@ class TGetJsonPath: public IKernelLogic {
 
     static const inline TFactory::TRegistrator<TGetJsonPath> Registrator = TFactory::TRegistrator<TGetJsonPath>(GetClassNameStatic());
 
-    virtual std::optional<TFetchingInfo> BuildFetchTask(const ui32 columnId, const NAccessor::IChunkedArray::EType arrType,
-        const std::vector<TColumnChainInfo>& input, const std::shared_ptr<TAccessorsCollection>& resources) const override;
-
     virtual TConclusion<bool> DoExecute(const std::vector<TColumnChainInfo>& input, const std::vector<TColumnChainInfo>& output,
         const std::shared_ptr<TAccessorsCollection>& resources) const override;
 
diff --git a/ydb/core/formats/arrow/program/original.h b/ydb/core/formats/arrow/program/original.h
index 3d3ab3d1fc1a..0ba877b54f73 100644
--- a/ydb/core/formats/arrow/program/original.h
+++ b/ydb/core/formats/arrow/program/original.h
@@ -2,6 +2,7 @@
 #include "abstract.h"
 #include "functions.h"
 #include "kernel_logic.h"
+#include "execution.h"
 
 namespace NKikimr::NArrow::NSSA {
 
diff --git a/ydb/core/formats/arrow/program/projection.cpp b/ydb/core/formats/arrow/program/projection.cpp
index 216cd3103c89..472161f73a9d 100644
--- a/ydb/core/formats/arrow/program/projection.cpp
+++ b/ydb/core/formats/arrow/program/projection.cpp
@@ -8,7 +8,7 @@ TConclusion<IResourceProcessor::EExecutionResult> TProjectionProcessor::DoExecut
     const TProcessorContext& context, const TExecutionNodeContext& /*nodeContext*/) const {
     context.GetResources()->RemainOnly(TColumnChainInfo::ExtractColumnIds(GetInput()), true);
     if (context.GetLimit()) {
-        context.GetResources()->CutFilter(context.GetResources()->GetRecordsCountActualVerified(), *context.GetLimit(), context.GetReverse());
+        context.GetResources()->CutFilter(context.GetResources()->GetRecordsCountRobustVerified(), *context.GetLimit(), context.GetReverse());
     }
     return EExecutionResult::Success;
 }
diff --git a/ydb/core/formats/arrow/program/reserve.cpp b/ydb/core/formats/arrow/program/reserve.cpp
new file mode 100644
index 000000000000..f10c87602003
--- /dev/null
+++ b/ydb/core/formats/arrow/program/reserve.cpp
@@ -0,0 +1,6 @@
+#include "execution.h"
+#include "original.h"
+
+namespace NKikimr::NArrow::NSSA {
+
+}   // namespace NKikimr::NArrow::NSSA
diff --git a/ydb/core/formats/arrow/program/reserve.h b/ydb/core/formats/arrow/program/reserve.h
new file mode 100644
index 000000000000..0ecadb8b3003
--- /dev/null
+++ b/ydb/core/formats/arrow/program/reserve.h
@@ -0,0 +1,74 @@
+#pragma once
+#include "abstract.h"
+#include "original.h"
+
+namespace NKikimr::NArrow::NSSA {
+
+class TReserveMemoryProcessor: public IResourceProcessor {
+private:
+    using TBase = IResourceProcessor;
+
+    THashMap<ui32, IDataSource::TDataAddress> DataAddresses;
+    THashMap<ui32, IDataSource::TFetchIndexContext> IndexContext;
+    THashMap<ui32, IDataSource::TFetchHeaderContext> HeaderContext;
+    std::shared_ptr<IMemoryCalculationPolicy> Policy;
+
+    virtual NJson::TJsonValue DoDebugJson() const override {
+        NJson::TJsonValue result = NJson::JSON_MAP;
+        if (DataAddresses.size()) {
+            auto& arrAddr = result.InsertValue("data", NJson::JSON_ARRAY);
+            for (auto&& i : DataAddresses) {
+                arrAddr.AppendValue(i.second.DebugJson());
+            }
+        }
+        if (IndexContext.size()) {
+            auto& indexesArr = result.InsertValue("indexes", NJson::JSON_ARRAY);
+            for (auto&& i : IndexContext) {
+                indexesArr.AppendValue(i.second.DebugJson());
+            }
+        }
+        if (HeaderContext.size()) {
+            auto& headersArr = result.InsertValue("headers", NJson::JSON_ARRAY);
+            for (auto&& i : HeaderContext) {
+                headersArr.AppendValue(i.second.DebugJson());
+            }
+        }
+        return result;
+    }
+
+    virtual TConclusion<EExecutionResult> DoExecute(const TProcessorContext& context, const TExecutionNodeContext& /*nodeContext*/) const override {
+        auto source = context.GetDataSource().lock();
+        if (!source) {
+            return TConclusionStatus::Fail("source was destroyed before (original fetch start)");
+        }
+        auto conclusion = source->StartReserveMemory(context, DataAddresses, IndexContext, HeaderContext, Policy);
+        if (conclusion.IsFail()) {
+            return conclusion;
+        } else if (conclusion.GetResult()) {
+            return EExecutionResult::InBackground;
+        } else {
+            return EExecutionResult::Success;
+        }
+    }
+
+    virtual bool IsAggregation() const override {
+        return false;
+    }
+
+    virtual ui64 DoGetWeight() const override {
+        return 0;
+    }
+
+public:
+    TReserveMemoryProcessor(const TOriginalColumnDataProcessor& original, const std::shared_ptr<IMemoryCalculationPolicy>& policy)
+        : TBase({}, {}, EProcessorType::ReserveMemory)
+        , DataAddresses(original.GetDataAddresses())
+        , IndexContext(original.GetIndexContext())
+        , HeaderContext(original.GetHeaderContext())
+        , Policy(policy)
+    {
+        AFL_VERIFY(policy);
+    }
+};
+
+}   // namespace NKikimr::NArrow::NSSA
diff --git a/ydb/core/formats/arrow/program/stream_logic.cpp b/ydb/core/formats/arrow/program/stream_logic.cpp
index 58079b6d98a4..6c467d6f984a 100644
--- a/ydb/core/formats/arrow/program/stream_logic.cpp
+++ b/ydb/core/formats/arrow/program/stream_logic.cpp
@@ -29,72 +29,59 @@ TConclusion<bool> TStreamLogicProcessor::OnInputReady(
     const ui32 inputId, const TProcessorContext& context, const TExecutionNodeContext& /*nodeContext*/) const {
     auto accInput = context.GetResources()->GetAccessorVerified(inputId);
 
-    std::shared_ptr<arrow::Scalar> monoValue;
     AFL_VERIFY(!context.GetResources()->HasMarker(FinishMarker));
     const auto accResult = context.GetResources()->GetAccessorOptional(GetOutputColumnIdOnce());
 
-    const auto isMonoValue = accInput->CheckOneValueAccessor(monoValue);
-    if (isMonoValue && *isMonoValue) {
-        const auto isFalseConclusion = ScalarIsFalse(monoValue);
-        if (isFalseConclusion.IsFail()) {
-            return isFalseConclusion;
-        }
-        const auto isTrueConclusion = ScalarIsTrue(monoValue);
-        if (isTrueConclusion.IsFail()) {
-            return isTrueConclusion;
-        }
-        AFL_VERIFY(*isFalseConclusion || *isTrueConclusion);
+    TConclusion<std::optional<bool>> isMonoInput = GetMonoInput(accInput);
+    if (isMonoInput.IsFail()) {
+        return isMonoInput;
+    }
+
+    if (isMonoInput.GetResult()) {
+        const bool monoValue = *isMonoInput.GetResult();
         if (Operation == NKernels::EOperation::And) {
-            if (*isTrueConclusion) {
+            if (monoValue) {
                 if (!accResult) {
                     context.GetResources()->AddVerified(GetOutputColumnIdOnce(),
-                        std::make_shared<NAccessor::TSparsedArray>(
-                            std::make_shared<arrow::UInt8Scalar>(1), arrow::uint8(), context.GetResources()->GetRecordsCountActualVerified()),
-                        false);
+                        NAccessor::TSparsedArray::BuildTrueArrayUI8(context.GetResources()->GetRecordsCountRobustVerified()), false);
                 }
                 return false;
             } else {
-                if (accResult) {
-                    context.GetResources()->Remove(GetOutputColumnIdOnce(), true);
-                }
-                context.GetResources()->AddVerified(GetOutputColumnIdOnce(),
-                    std::make_shared<NAccessor::TSparsedArray>(
-                        std::make_shared<arrow::UInt8Scalar>(0), arrow::uint8(), context.GetResources()->GetRecordsCountActualVerified()),
-                    false);
+                context.GetResources()->Upsert(GetOutputColumnIdOnce(),
+                    NAccessor::TSparsedArray::BuildFalseArrayUI8(context.GetResources()->GetRecordsCountRobustVerified()), false);
                 return true;
             }
         } else if (Operation == NKernels::EOperation::Or) {
-            if (*isFalseConclusion) {
+            if (!monoValue) {
                 if (!accResult) {
                     context.GetResources()->AddVerified(GetOutputColumnIdOnce(),
-                        std::make_shared<NAccessor::TSparsedArray>(
-                            std::make_shared<arrow::UInt8Scalar>(0), arrow::uint8(), context.GetResources()->GetRecordsCountActualVerified()),
-                        false);
+                        NAccessor::TSparsedArray::BuildFalseArrayUI8(context.GetResources()->GetRecordsCountRobustVerified()), false);
                 }
                 return false;
             } else {
-                if (accResult) {
-                    context.GetResources()->Remove(GetOutputColumnIdOnce(), true);
-                }
-                context.GetResources()->AddVerified(GetOutputColumnIdOnce(),
-                    std::make_shared<NAccessor::TSparsedArray>(
-                        std::make_shared<arrow::UInt8Scalar>(1), arrow::uint8(), context.GetResources()->GetRecordsCountActualVerified()),
-                    false);
+                context.GetResources()->Upsert(GetOutputColumnIdOnce(),
+                    NAccessor::TSparsedArray::BuildTrueArrayUI8(context.GetResources()->GetRecordsCountRobustVerified()), false);
                 return true;
             }
         }
     }
 
     if (!accResult) {
+        AFL_VERIFY(accInput->GetDataType()->id() == arrow::uint8()->id())("type", accInput->GetDataType()->ToString());
         context.GetResources()->AddVerified(GetOutputColumnIdOnce(), accInput, false);
     } else {
         auto result = Function->Call(TColumnChainInfo::BuildVector({ GetOutputColumnIdOnce(), inputId }), context.GetResources());
         if (result.IsFail()) {
             return result;
         }
+        auto datum = result.DetachResult();
         context.GetResources()->Remove(GetOutputColumnIdOnce());
-        context.GetResources()->AddVerified(GetOutputColumnIdOnce(), std::move(*result), false);
+        context.GetResources()->AddVerified(GetOutputColumnIdOnce(), datum, false);
+        if (IsFinishDatum(datum)) {
+            return true;
+        }
     }
+
     return false;
 }
 
@@ -162,4 +149,57 @@ NJson::TJsonValue TStreamLogicProcessor::DoDebugJson() const {
     return result;
 }
 
+bool TStreamLogicProcessor::IsFinishDatum(const arrow::Datum& datum) const {
+    const auto arrChecker = [&](const arrow::Array& arr) {
+        AFL_VERIFY(arr.type()->id() == arrow::uint8()->id());
+        const arrow::UInt8Array& ui8Arr = static_cast<const arrow::UInt8Array&>(arr);
+        const ui8* values = ui8Arr.raw_values();
+        if (Operation == NKernels::EOperation::And) {
+            for (ui32 i = 0; i < ui8Arr.length(); ++i) {
+                if (values[i] != 0) {
+                    return false;
+                }
+            }
+        } else if (Operation == NKernels::EOperation::Or) {
+            for (ui32 i = 0; i < ui8Arr.length(); ++i) {
+                if (values[i] == 0) {
+                    return false;
+                }
+            }
+        } else {
+            AFL_VERIFY(false)("op", Operation);
+        }
+        return true;
+    };
+    if (datum.is_array()) {
+        auto arr = datum.make_array();
+        return arrChecker(*arr);
+    } else if (datum.is_arraylike()) {
+        auto arr = datum.chunked_array();
+        AFL_VERIFY(arr->type()->id() == arrow::uint8()->id());
+        for (auto&& chunk : arr->chunks()) {
+            if (!arrChecker(*chunk)) {
+                return false;
+            }
+        }
+        return true;
+    } else {
+        AFL_VERIFY(false)("kind", (ui32)datum.kind());
+        return false;
+    }
+}
+
+TConclusion<std::optional<bool>> TStreamLogicProcessor::GetMonoInput(const std::shared_ptr<IChunkedArray>& inputArray) const {
+    std::shared_ptr<arrow::Scalar> monoValue;
+    const auto isMonoValue = inputArray->CheckOneValueAccessor(monoValue);
+    if (!isMonoValue || !*isMonoValue) {
+        return std::optional<bool>();
+    }
+    const auto isFalseConclusion = ScalarIsFalse(monoValue);
+    if (isFalseConclusion.IsFail()) {
+        return isFalseConclusion;
+    }
+    return !*isFalseConclusion;
+}
+
 }   // namespace NKikimr::NArrow::NSSA
diff --git a/ydb/core/formats/arrow/program/stream_logic.h b/ydb/core/formats/arrow/program/stream_logic.h
index f78619b8cff2..3855cedf546a 100644
--- a/ydb/core/formats/arrow/program/stream_logic.h
+++ b/ydb/core/formats/arrow/program/stream_logic.h
@@ -21,15 +21,16 @@ class TStreamLogicProcessor: public IResourceProcessor {
         return false;
     }
 
+    TConclusion<std::optional<bool>> GetMonoInput(const std::shared_ptr<IChunkedArray>& inputArray) const;
+
+    bool IsFinishDatum(const arrow::Datum& datum) const;
     virtual ui64 DoGetWeight() const override;
 
 public:
     NKernels::EOperation GetOperation() const {
         return Operation;
     }
-
     TConclusion<bool> OnInputReady(const ui32 inputId, const TProcessorContext& context, const TExecutionNodeContext& nodeContext) const;
-
     TStreamLogicProcessor(std::vector<TColumnChainInfo>&& input, const TColumnChainInfo& output, const NKernels::EOperation op);
 };
 
diff --git a/ydb/core/formats/arrow/program/ya.make b/ydb/core/formats/arrow/program/ya.make
index 114660d3251e..720b0f0b3180 100644
--- a/ydb/core/formats/arrow/program/ya.make
+++ b/ydb/core/formats/arrow/program/ya.make
@@ -48,6 +48,7 @@ SRCS(
     assign_internal.cpp
     custom_registry.cpp
     GLOBAL kernel_logic.cpp
+    reserve.cpp
 )
 
 GENERATE_ENUM_SERIALIZATION(abstract.h)
diff --git a/ydb/core/formats/arrow/reader/merger.cpp b/ydb/core/formats/arrow/reader/merger.cpp
index b6c56ba23183..bdf212696b8c 100644
--- a/ydb/core/formats/arrow/reader/merger.cpp
+++ b/ydb/core/formats/arrow/reader/merger.cpp
@@ -105,7 +105,7 @@ std::shared_ptr<arrow::Table> TMergePartialStream::SingleSourceDrain(const TSort
             *lastResultPosition = TCursor(keys, 0, SortSchema->field_names());
         }
         if (SortHeap.Current().GetFilter()) {
-            AFL_VERIFY(SortHeap.Current().GetFilter()->Apply(result, TColumnFilter::TApplyContext(pos.GetPosition() + (include ? 0 : 1), resultSize)));
+            SortHeap.Current().GetFilter()->Apply(result, TColumnFilter::TApplyContext(pos.GetPosition() + (include ? 0 : 1), resultSize));
         }
     } else {
         result = SortHeap.Current().GetKeyColumns().SliceData(startPos, resultSize);
@@ -114,7 +114,7 @@ std::shared_ptr<arrow::Table> TMergePartialStream::SingleSourceDrain(const TSort
             *lastResultPosition = TCursor(keys, keys->num_rows() - 1, SortSchema->field_names());
         }
         if (SortHeap.Current().GetFilter()) {
-            AFL_VERIFY(SortHeap.Current().GetFilter()->Apply(result, TColumnFilter::TApplyContext(startPos, resultSize)));
+            SortHeap.Current().GetFilter()->Apply(result, TColumnFilter::TApplyContext(startPos, resultSize));
         }
     }
     if (!result || !result->num_rows()) {
@@ -214,7 +214,7 @@ std::vector<std::shared_ptr<arrow::RecordBatch>> TMergePartialStream::DrainAllPa
     return result;
 }
 
-void TMergePartialStream::SkipToLowerBound(const TSortableBatchPosition& pos, const bool include) {
+void TMergePartialStream::SkipToBound(const TSortableBatchPosition& pos, const bool lower) {
     if (SortHeap.Empty()) {
         return;
     }
@@ -224,13 +224,13 @@ void TMergePartialStream::SkipToLowerBound(const TSortableBatchPosition& pos, co
         if (cmpResult == std::partial_ordering::greater) {
             break;
         }
-        if (cmpResult == std::partial_ordering::equivalent && include) {
+        if (cmpResult == std::partial_ordering::equivalent && lower) {
             break;
         }
         const TSortableBatchPosition::TFoundPosition skipPos = SortHeap.MutableCurrent().SkipToLower(pos);
         AFL_DEBUG(NKikimrServices::ARROW_HELPER)("pos", pos.DebugJson().GetStringRobust())("heap", SortHeap.Current().GetKeyColumns().DebugJson().GetStringRobust());
         if (skipPos.IsEqual()) {
-            if (!include && !SortHeap.MutableCurrent().Next()) {
+            if (!lower && !SortHeap.MutableCurrent().Next()) {
                 SortHeap.RemoveTop();
             } else {
                 SortHeap.UpdateTop();
diff --git a/ydb/core/formats/arrow/reader/merger.h b/ydb/core/formats/arrow/reader/merger.h
index c30aba0f384f..4950e49bee34 100644
--- a/ydb/core/formats/arrow/reader/merger.h
+++ b/ydb/core/formats/arrow/reader/merger.h
@@ -53,7 +53,7 @@ class TMergePartialStream {
     }
 
     void PutControlPoint(const TSortableBatchPosition& point, const bool deepCopy);
-    void SkipToLowerBound(const TSortableBatchPosition& pos, const bool include);
+    void SkipToBound(const TSortableBatchPosition& pos, const bool lower);
 
     void SetPossibleSameVersion(const bool value) {
         PossibleSameVersionFlag = value;
diff --git a/ydb/core/formats/arrow/reader/position.cpp b/ydb/core/formats/arrow/reader/position.cpp
index e4f4d799a5a1..5476975998e0 100644
--- a/ydb/core/formats/arrow/reader/position.cpp
+++ b/ydb/core/formats/arrow/reader/position.cpp
@@ -18,51 +18,51 @@ NJson::TJsonValue TSortableBatchPosition::DebugJson() const {
     return result;
 }
 
-std::optional<TSortableBatchPosition::TFoundPosition> TSortableBatchPosition::FindPosition(TRWSortableBatchPosition& position,
-    const ui64 posStartExt, const ui64 posFinishExt, const TSortableBatchPosition& forFound, const bool greater) {
+std::optional<TSortableBatchPosition::TFoundPosition> TSortableBatchPosition::FindBound(TRWSortableBatchPosition& position,
+    const ui64 posStartExt, const ui64 posFinishExt, const TSortableBatchPosition& forFound, const bool upper) {
     ui64 posStart = posStartExt;
     ui64 posFinish = posFinishExt;
     auto guard = position.CreateAsymmetricAccessGuard();
+    const auto cond = upper ?
+        [](const std::partial_ordering cmp) {
+            return cmp == std::partial_ordering::greater;
+        } :
+        [](const std::partial_ordering cmp) {
+            return cmp == std::partial_ordering::greater || cmp == std::partial_ordering::equivalent;
+        };
+
     {
         AFL_VERIFY(guard.InitSortingPosition(posStart));
         auto cmp = position.Compare(forFound);
-        if (cmp == std::partial_ordering::greater) {
-            return TFoundPosition::Greater(posStart);
-        } else if (cmp == std::partial_ordering::equivalent) {
-            return TFoundPosition::Equal(posStart);
+        if (cond(cmp)) {
+            return TFoundPosition(posStart, cmp);
         }
     }
     {
         AFL_VERIFY(guard.InitSortingPosition(posFinish));
         auto cmp = position.Compare(forFound);
-        if (cmp == std::partial_ordering::less) {
-            return TFoundPosition::Less(posFinish);
-        } else if (cmp == std::partial_ordering::equivalent) {
-            return TFoundPosition::Equal(posFinish);
+        if (!cond(cmp)) {
+            return std::nullopt;
         }
     }
-    while (posFinish > posStart + 1) {
+    while (posFinish != posStart + 1) {
+        AFL_VERIFY(posFinish > posStart + 1)("finish", posFinish)("start", posStart);
         AFL_VERIFY(guard.InitSortingPosition(0.5 * (posStart + posFinish)));
         const auto comparision = position.Compare(forFound);
-        if (comparision == std::partial_ordering::less) {
-            posStart = position.Position;
-        } else if (comparision == std::partial_ordering::greater) {
+        if (cond(comparision)) {
             posFinish = position.Position;
         } else {
-            return TFoundPosition::Equal(position.Position);
+            posStart = position.Position;
         }
     }
-    AFL_VERIFY(posFinish != posStart);
-    if (greater) {
-        AFL_VERIFY(guard.InitSortingPosition(posFinish));
-        return TFoundPosition::Greater(posFinish);
-    } else {
-        AFL_VERIFY(guard.InitSortingPosition(posStart));
-        return TFoundPosition::Less(posStart);
-    }
+    AFL_VERIFY(posFinish == posStart + 1)("finish", posFinish)("start", posStart);
+    AFL_VERIFY(guard.InitSortingPosition(posFinish));
+    const auto comparision = position.Compare(forFound);
+    AFL_VERIFY(cond(comparision));
+    return TFoundPosition(posFinish, comparision);
 }
 
-std::optional<TSortableBatchPosition::TFoundPosition> TSortableBatchPosition::FindPosition(const std::shared_ptr<arrow::RecordBatch>& batch,
+std::optional<TSortableBatchPosition::TFoundPosition> TSortableBatchPosition::FindBound(const std::shared_ptr<arrow::RecordBatch>& batch,
     const TSortableBatchPosition& forFound, const bool greater, const std::optional<ui32> includedStartPosition) {
     if (!batch || !batch->num_rows()) {
         return {};
@@ -77,12 +77,11 @@ std::optional<TSortableBatchPosition::TFoundPosition> TSortableBatchPosition::Fi
     }
 
     TRWSortableBatchPosition position = forFound.BuildRWPosition(batch, posStart);
-    return FindPosition(position, posStart, posFinish, forFound, greater);
+    return FindBound(position, posStart, posFinish, forFound, greater);
 }
 
 NKikimr::NArrow::NMerger::TRWSortableBatchPosition TSortableBatchPosition::BuildRWPosition(const bool needData, const bool deepCopy) const {
-    return TRWSortableBatchPosition(Position, RecordsCount, ReverseSort,
-        deepCopy ? Sorting->BuildCopy(Position) : Sorting,
+    return TRWSortableBatchPosition(Position, RecordsCount, ReverseSort, deepCopy ? Sorting->BuildCopy(Position) : Sorting,
         (needData && Data) ? (deepCopy ? Data->BuildCopy(Position) : Data) : nullptr);
 }
 
@@ -96,9 +95,15 @@ NKikimr::NArrow::NMerger::TRWSortableBatchPosition TSortableBatchPosition::Build
 }
 
 TSortableBatchPosition::TFoundPosition TRWSortableBatchPosition::SkipToLower(const TSortableBatchPosition& forFound) {
+    AFL_VERIFY(RecordsCount);
     const ui32 posStart = Position;
-    auto pos = FindPosition(*this, posStart, ReverseSort ? 0 : (RecordsCount - 1), forFound, true);
-    AFL_VERIFY(pos)("cursor", DebugJson())("found", forFound.DebugJson());
+    AFL_VERIFY(!ReverseSort)("reason", "unimplemented");
+    auto pos = FindBound(*this, posStart, RecordsCount - 1, forFound, false);
+    if (!pos) {
+        auto guard = CreateAsymmetricAccessGuard();
+        AFL_VERIFY(guard.InitSortingPosition(RecordsCount - 1));
+        return TFoundPosition(RecordsCount - 1, Compare(forFound));
+    }
     if (ReverseSort) {
         AFL_VERIFY(Position <= posStart)("pos", Position)("pos_skip", pos->GetPosition())("reverse", true);
     } else {
@@ -120,6 +125,12 @@ TSortableScanData::TSortableScanData(
     BuildPosition(position);
 }
 
+TSortableScanData::TSortableScanData(const ui64 position, const std::shared_ptr<TGeneralContainer>& batch) {
+    Fields = batch->GetSchema()->GetFields();
+    Columns = batch->GetColumns();
+    BuildPosition(position);
+}
+
 TSortableScanData::TSortableScanData(
     const ui64 position, const std::shared_ptr<arrow::RecordBatch>& batch, const std::vector<std::string>& columns) {
     for (auto&& i : columns) {
@@ -133,8 +144,7 @@ TSortableScanData::TSortableScanData(
     BuildPosition(position);
 }
 
-TSortableScanData::TSortableScanData(
-    const ui64 position, const std::shared_ptr<arrow::RecordBatch>& batch) {
+TSortableScanData::TSortableScanData(const ui64 position, const std::shared_ptr<arrow::RecordBatch>& batch) {
     for (auto&& c : batch->columns()) {
         Columns.emplace_back(std::make_shared<NAccessor::TTrivialArray>(c));
     }
diff --git a/ydb/core/formats/arrow/reader/position.h b/ydb/core/formats/arrow/reader/position.h
index f403dd7fe3af..a902744fe6e8 100644
--- a/ydb/core/formats/arrow/reader/position.h
+++ b/ydb/core/formats/arrow/reader/position.h
@@ -73,11 +73,47 @@ class TSortableScanData {
         return StartPosition <= position && position < FinishPosition;
     }
 
+    std::partial_ordering CompareImpl(const ui64 position, const TSortableScanData& item, const ui64 itemPosition, const ui32 size) const {
+        AFL_VERIFY(size <= PositionAddress.size() && size <= item.PositionAddress.size());
+        AFL_VERIFY(size);
+        if (Contains(position) && item.Contains(itemPosition)) {
+            for (ui32 idx = 0; idx < size; ++idx) {
+                std::partial_ordering cmp = PositionAddress[idx].Compare(position, item.PositionAddress[idx], itemPosition);
+                if (cmp != std::partial_ordering::equivalent) {
+                    return cmp;
+                }
+            }
+        } else {
+            for (ui32 idx = 0; idx < size; ++idx) {
+                std::partial_ordering cmp = std::partial_ordering::equivalent;
+                const bool containsSelf = PositionAddress[idx].GetAddress().Contains(position);
+                const bool containsItem = item.PositionAddress[idx].GetAddress().Contains(itemPosition);
+                if (containsSelf && containsItem) {
+                    cmp = PositionAddress[idx].Compare(position, item.PositionAddress[idx], itemPosition);
+                } else if (containsSelf) {
+                    auto temporaryAddress = item.Columns[idx]->GetChunk(item.PositionAddress[idx].GetAddress(), itemPosition);
+                    cmp = PositionAddress[idx].Compare(position, temporaryAddress, itemPosition);
+                } else if (containsItem) {
+                    auto temporaryAddress = Columns[idx]->GetChunk(PositionAddress[idx].GetAddress(), position);
+                    cmp = temporaryAddress.Compare(position, item.PositionAddress[idx], itemPosition);
+                } else {
+                    AFL_VERIFY(false);
+                }
+                if (cmp != std::partial_ordering::equivalent) {
+                    return cmp;
+                }
+            }
+        }
+
+        return std::partial_ordering::equivalent;
+    }
+
 public:
     TSortableScanData(const ui64 position, const std::shared_ptr<arrow::RecordBatch>& batch);
     TSortableScanData(const ui64 position, const std::shared_ptr<arrow::RecordBatch>& batch, const std::vector<std::string>& columns);
     TSortableScanData(const ui64 position, const std::shared_ptr<arrow::Table>& batch, const std::vector<std::string>& columns);
     TSortableScanData(const ui64 position, const std::shared_ptr<TGeneralContainer>& batch, const std::vector<std::string>& columns);
+    TSortableScanData(const ui64 position, const std::shared_ptr<TGeneralContainer>& batch);
     TSortableScanData(const ui64 position, const ui64 recordsCount, const std::vector<std::shared_ptr<NAccessor::IChunkedArray>>& columns,
         const std::vector<std::shared_ptr<arrow::Field>>& fields)
         : RecordsCount(recordsCount)
@@ -117,36 +153,11 @@ class TSortableScanData {
 
     std::partial_ordering Compare(const ui64 position, const TSortableScanData& item, const ui64 itemPosition) const {
         AFL_VERIFY(PositionAddress.size() == item.PositionAddress.size());
-        if (Contains(position) && item.Contains(itemPosition)) {
-            for (ui32 idx = 0; idx < PositionAddress.size(); ++idx) {
-                std::partial_ordering cmp = PositionAddress[idx].Compare(position, item.PositionAddress[idx], itemPosition);
-                if (cmp != std::partial_ordering::equivalent) {
-                    return cmp;
-                }
-            }
-        } else {
-            for (ui32 idx = 0; idx < PositionAddress.size(); ++idx) {
-                std::partial_ordering cmp = std::partial_ordering::equivalent;
-                const bool containsSelf = PositionAddress[idx].GetAddress().Contains(position);
-                const bool containsItem = item.PositionAddress[idx].GetAddress().Contains(itemPosition);
-                if (containsSelf && containsItem) {
-                    cmp = PositionAddress[idx].Compare(position, item.PositionAddress[idx], itemPosition);
-                } else if (containsSelf) {
-                    auto temporaryAddress = item.Columns[idx]->GetChunk(item.PositionAddress[idx].GetAddress(), itemPosition);
-                    cmp = PositionAddress[idx].Compare(position, temporaryAddress, itemPosition);
-                } else if (containsItem) {
-                    auto temporaryAddress = Columns[idx]->GetChunk(PositionAddress[idx].GetAddress(), position);
-                    cmp = temporaryAddress.Compare(position, item.PositionAddress[idx], itemPosition);
-                } else {
-                    AFL_VERIFY(false);
-                }
-                if (cmp != std::partial_ordering::equivalent) {
-                    return cmp;
-                }
-            }
-        }
+        return CompareImpl(position, item, itemPosition, item.PositionAddress.size());
+    }
 
-        return std::partial_ordering::equivalent;
+    std::partial_ordering ComparePartial(const ui64 position, const TSortableScanData& item, const ui64 itemPosition) const {
+        return CompareImpl(position, item, itemPosition, std::min<ui32>(PositionAddress.size(), item.PositionAddress.size()));
     }
 
     void AppendPositionTo(const std::vector<std::unique_ptr<arrow::ArrayBuilder>>& builders, const ui64 position, ui64* recordSize) const;
@@ -314,15 +325,24 @@ class TSortableBatchPosition {
         static TFoundPosition Equal(const ui32 pos) {
             return TFoundPosition(pos);
         }
+
+        TFoundPosition(const ui32 pos, const std::partial_ordering cmp)
+            : Position(pos) {
+            if (cmp == std::partial_ordering::less) {
+                GreaterIfNotEqual = false;
+            } else if (cmp == std::partial_ordering::greater) {
+                GreaterIfNotEqual = true;
+            }
+        }
     };
 
     [[nodiscard]] bool IsAvailablePosition(const i64 position) const {
         return 0 <= position && position < RecordsCount;
     }
 
-    static std::optional<TFoundPosition> FindPosition(const std::shared_ptr<arrow::RecordBatch>& batch, const TSortableBatchPosition& forFound,
+    static std::optional<TFoundPosition> FindBound(const std::shared_ptr<arrow::RecordBatch>& batch, const TSortableBatchPosition& forFound,
         const bool needGreater, const std::optional<ui32> includedStartPosition);
-    static std::optional<TSortableBatchPosition::TFoundPosition> FindPosition(TRWSortableBatchPosition& position, const ui64 posStart,
+    static std::optional<TSortableBatchPosition::TFoundPosition> FindBound(TRWSortableBatchPosition& position, const ui64 posStart,
         const ui64 posFinish, const TSortableBatchPosition& forFound, const bool greater);
 
     const TSortableScanData& GetData() const {
@@ -405,6 +425,12 @@ class TSortableBatchPosition {
         return ApplyOptionalReverseForCompareResult(directResult);
     }
 
+    std::partial_ordering ComparePartial(const TSortableBatchPosition& item) const {
+        Y_ABORT_UNLESS(item.ReverseSort == ReverseSort);
+        const auto directResult = Sorting->ComparePartial(Position, *item.Sorting, item.GetPosition());
+        return ApplyOptionalReverseForCompareResult(directResult);
+    }
+
     std::partial_ordering Compare(const TSortableScanData& data, const ui64 dataPosition) const {
         return Sorting->Compare(Position, data, dataPosition);
     }
diff --git a/ydb/core/formats/arrow/ssa_runtime_version.h b/ydb/core/formats/arrow/ssa_runtime_version.h
index 500074420fda..5e46ec37cb4f 100644
--- a/ydb/core/formats/arrow/ssa_runtime_version.h
+++ b/ydb/core/formats/arrow/ssa_runtime_version.h
@@ -27,6 +27,9 @@ namespace NKikimr::NSsa {
 // v2 is the version supported by kikimr-23-1. Supports LIKE filter for Utf8 type, COUNT(col), COUNT(*), SUM(), MIN(), MAX(), AVG(), SOME() aggregations.
 // v3 is the version supported by kikimr-23-3. Supports LIKE filter for String type, JSON_VALUE and JSON_EXISTS functions in filters
 // v4 is the version supported by kikimr-24-1. Supports any comparsions and arithmetics on YQL kernels.
+// v5 supports generic ast pushdouwn via KqpOlapApply
 constexpr ui32 RuntimeVersion = SSA_RUNTIME_VERSION;
 
+static_assert(RuntimeVersion >= 4);
+
 }
diff --git a/ydb/core/formats/arrow/ut/ut_arrow.cpp b/ydb/core/formats/arrow/ut/ut_arrow.cpp
index 6f12504187e9..bc46b4f329f7 100644
--- a/ydb/core/formats/arrow/ut/ut_arrow.cpp
+++ b/ydb/core/formats/arrow/ut/ut_arrow.cpp
@@ -480,21 +480,6 @@ std::vector<TDataRow> TestRows() {
     return rows;
 }
 
-bool CheckFilter(const std::vector<bool>& f, size_t count, bool value) {
-    for (size_t i = 0; i < f.size(); ++i) {
-        if (i < count) {
-            if (f[i] != value) {
-                return false;
-            }
-        } else {
-            if (f[i] == value) {
-                return false;
-            }
-        }
-    }
-    return true;
-}
-
 std::shared_ptr<arrow::Table> MakeTable1000() {
     TDataRowTableBuilder builder;
 
@@ -672,38 +657,6 @@ Y_UNIT_TEST_SUITE(ArrowTest) {
         }
     }
 
-    Y_UNIT_TEST(KeyComparison) {
-        auto table = MakeTable1000();
-
-        std::shared_ptr<arrow::RecordBatch> border; // {2, 3, 4}
-        {
-            arrow::ScalarVector scalars{
-                std::make_shared<arrow::Int8Scalar>(2),
-                std::make_shared<arrow::Int16Scalar>(3),
-                std::make_shared<arrow::Int32Scalar>(4),
-            };
-
-            std::vector<std::shared_ptr<arrow::Array>> columns;
-            for (auto scalar : scalars) {
-                auto res = arrow::MakeArrayFromScalar(*scalar, 1);
-                UNIT_ASSERT(res.ok());
-                columns.push_back(*res);
-            }
-
-            border = arrow::RecordBatch::Make(table->schema(), 1, columns);
-        }
-
-        const NArrow::TColumnFilter lt = NArrow::TColumnFilter::MakePredicateFilter(table, border, NArrow::ECompareType::LESS);
-        const NArrow::TColumnFilter le = NArrow::TColumnFilter::MakePredicateFilter(table, border, NArrow::ECompareType::LESS_OR_EQUAL);
-        const NArrow::TColumnFilter gt = NArrow::TColumnFilter::MakePredicateFilter(table, border, NArrow::ECompareType::GREATER);
-        const NArrow::TColumnFilter ge = NArrow::TColumnFilter::MakePredicateFilter(table, border, NArrow::ECompareType::GREATER_OR_EQUAL);
-
-        UNIT_ASSERT(CheckFilter(lt.BuildSimpleFilter(), 234, true));
-        UNIT_ASSERT(CheckFilter(le.BuildSimpleFilter(), 235, true));
-        UNIT_ASSERT(CheckFilter(gt.BuildSimpleFilter(), 235, false));
-        UNIT_ASSERT(CheckFilter(ge.BuildSimpleFilter(), 234, false));
-    }
-
     Y_UNIT_TEST(SortWithCompositeKey) {
         std::shared_ptr<arrow::Table> table = Shuffle(MakeTable1000());
 
diff --git a/ydb/core/formats/arrow/ut/ut_column_filter.cpp b/ydb/core/formats/arrow/ut/ut_column_filter.cpp
index f12fe1898b65..5994e8c45ce6 100644
--- a/ydb/core/formats/arrow/ut/ut_column_filter.cpp
+++ b/ydb/core/formats/arrow/ut/ut_column_filter.cpp
@@ -82,15 +82,15 @@ Y_UNIT_TEST_SUITE(ColumnFilter) {
         {
             auto cut = filter.Cut(100, 10, false);
             AFL_VERIFY(cut.DebugString() == "{1}[10,90]")("val", cut.DebugString());
-            auto cut1 = cut.Cut(10, 3, false);
+            auto cut1 = cut.Cut(100, 3, false);
             AFL_VERIFY(cut1.DebugString() == "{1}[3,97]")("val", cut1.DebugString());
-            auto cut2 = cut.Cut(10, 3, true);
+            auto cut2 = cut.Cut(100, 3, true);
             AFL_VERIFY(cut2.DebugString() == "{0}[7,3,90]")("val", cut2.DebugString());
         }
         {
             auto cut = filter.Cut(100, 10, true);
             AFL_VERIFY(cut.DebugString() == "{0}[90,10]")("val", cut.DebugString());
-            auto cut1 = cut.Cut(10, 0, true);
+            auto cut1 = cut.Cut(100, 0, true);
             AFL_VERIFY(cut1.DebugString() == "{0}[100]")("val", cut1.DebugString());
         }
     }
@@ -108,27 +108,27 @@ Y_UNIT_TEST_SUITE(ColumnFilter) {
         filter.Add(true, 3);
         filter.Add(false, 2);
         {
-            auto cut = filter.Cut(filter.GetFilteredCountVerified(), 10, false);
+            auto cut = filter.Cut(filter.GetRecordsCountVerified(), 10, false);
             AFL_VERIFY(cut.DebugString() == "{1}[4,3,2,1,4,18]")("val", cut.DebugString());
             AFL_VERIFY(cut.GetRecordsCountVerified() == filter.GetRecordsCountVerified());
         }
         {
-            auto cut = filter.Cut(filter.GetFilteredCountVerified(), 1, false);
+            auto cut = filter.Cut(filter.GetRecordsCountVerified(), 1, false);
             AFL_VERIFY(cut.DebugString() == "{1}[1,31]")("val", cut.DebugString());
             AFL_VERIFY(cut.GetRecordsCountVerified() == filter.GetRecordsCountVerified());
         }
         {
-            auto cut = filter.Cut(filter.GetFilteredCountVerified(), 8, false);
+            auto cut = filter.Cut(filter.GetRecordsCountVerified(), 8, false);
             AFL_VERIFY(cut.DebugString() == "{1}[4,3,2,1,2,20]")("val", cut.DebugString());
             AFL_VERIFY(cut.GetRecordsCountVerified() == filter.GetRecordsCountVerified());
         }
         {
-            auto cut = filter.Cut(filter.GetFilteredCountVerified(), 10, true);
+            auto cut = filter.Cut(filter.GetRecordsCountVerified(), 10, true);
             AFL_VERIFY(cut.DebugString() == "{0}[13,1,6,6,1,3,2]")("val", cut.DebugString());
             AFL_VERIFY(cut.GetRecordsCountVerified() == filter.GetRecordsCountVerified());
         }
         {
-            auto cut = filter.Cut(filter.GetFilteredCountVerified(), 1000, true);
+            auto cut = filter.Cut(filter.GetRecordsCountVerified(), 1000, true);
             AFL_VERIFY(cut.DebugString() == "{1}[4,3,2,1,4,6,6,1,3,2]")("val", cut.DebugString());
             AFL_VERIFY(cut.GetRecordsCountVerified() == filter.GetRecordsCountVerified());
         }
diff --git a/ydb/core/formats/arrow/ut/ut_program_step.cpp b/ydb/core/formats/arrow/ut/ut_program_step.cpp
index bea0dcc463af..8f3f403a2af2 100644
--- a/ydb/core/formats/arrow/ut/ut_program_step.cpp
+++ b/ydb/core/formats/arrow/ut/ut_program_step.cpp
@@ -43,8 +43,8 @@ size_t FilterTest(const std::vector<std::shared_ptr<arrow::Array>>& args, const
         std::make_shared<arrow::Field>("y", args.at(1)->type()), std::make_shared<arrow::Field>("z", args.at(2)->type()) });
     TSchemaColumnResolver resolver(schema);
     NOptimization::TGraph::TBuilder builder(resolver);
-    builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1, 2}), TColumnChainInfo(4), std::make_shared<TSimpleFunction>(op1)).DetachResult());
-    builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({4, 3}), TColumnChainInfo(5), std::make_shared<TSimpleFunction>(op2)).DetachResult());
+    builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1, 2}), TColumnChainInfo(4), std::make_shared<TSimpleFunction>(op1), std::make_shared<TSimpleKernelLogic>()).DetachResult());
+    builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({4, 3}), TColumnChainInfo(5), std::make_shared<TSimpleFunction>(op2), std::make_shared<TSimpleKernelLogic>()).DetachResult());
     builder.Add(std::make_shared<TFilterProcessor>(TColumnChainInfo(5)));
     builder.Add(std::make_shared<TProjectionProcessor>(TColumnChainInfo::BuildVector({ 4, 5 })));
     auto chain = builder.Finish().DetachResult();
@@ -74,8 +74,8 @@ size_t FilterTestUnary(std::vector<std::shared_ptr<arrow::Array>> args, const EO
     }
 
     NOptimization::TGraph::TBuilder builder(resolver);
-    builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1}), TColumnChainInfo(4), std::make_shared<TSimpleFunction>(op1)).DetachResult());
-    builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({2, 4}), TColumnChainInfo(5), std::make_shared<TSimpleFunction>(op2)).DetachResult());
+    builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1}), TColumnChainInfo(4), std::make_shared<TSimpleFunction>(op1), std::make_shared<TSimpleKernelLogic>()).DetachResult());
+    builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({2, 4}), TColumnChainInfo(5), std::make_shared<TSimpleFunction>(op2), std::make_shared<TSimpleKernelLogic>()).DetachResult());
     builder.Add(std::make_shared<TFilterProcessor>(TColumnChainInfo(5)));
     builder.Add(std::make_shared<TProjectionProcessor>(TColumnChainInfo::BuildVector({ 4, 5 })));
     auto chain = builder.Finish().DetachResult();
@@ -103,7 +103,7 @@ std::vector<bool> LikeTest(const std::vector<std::string>& data, EOperation op,
 
     NOptimization::TGraph::TBuilder builder(resolver);
     builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1}), TColumnChainInfo(2), 
-        std::make_shared<TSimpleFunction>(op, std::make_shared<arrow::compute::MatchSubstringOptions>(pattern, ignoreCase))).DetachResult());
+        std::make_shared<TSimpleFunction>(op, std::make_shared<arrow::compute::MatchSubstringOptions>(pattern, ignoreCase)), std::make_shared<TSimpleKernelLogic>()).DetachResult());
     builder.Add(std::make_shared<TProjectionProcessor>(TColumnChainInfo::BuildVector({ 2 })));
     auto chain = builder.Finish().DetachResult();
 
@@ -149,7 +149,13 @@ struct TSumData {
     }
 
     static void CheckResult(ETest test, const std::shared_ptr<TAccessorsCollection>& batch, ui32 numKeys, bool nullable) {
-        AFL_VERIFY(batch->GetColumnsCount() == numKeys + 2);
+        if (test == ETest::EMPTY) {
+            UNIT_ASSERT(!batch->HasData());
+            return;
+        } else {
+            AFL_VERIFY(batch->GetColumnsCount() == numKeys + 2);
+        }
+
         auto aggXOriginal = batch->GetArrayVerified(3);
         auto aggYOriginal = batch->GetArrayVerified(4);
         auto colXOriginal = batch->GetArrayVerified(1);
@@ -505,7 +511,7 @@ Y_UNIT_TEST_SUITE(ProgramStep) {
         TSchemaColumnResolver resolver(schema);
         NOptimization::TGraph::TBuilder builder(resolver);
         builder.Add(std::make_shared<TConstProcessor>(std::make_shared<arrow::Int64Scalar>(56), 3));
-        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1, 3}), TColumnChainInfo(4), std::make_shared<TSimpleFunction>(EOperation::Add)).DetachResult());
+        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1, 3}), TColumnChainInfo(4), std::make_shared<TSimpleFunction>(EOperation::Add), std::make_shared<TSimpleKernelLogic>()).DetachResult());
         builder.Add(std::make_shared<TFilterProcessor>(TColumnChainInfo(2)));
         builder.Add(std::make_shared<TProjectionProcessor>(TColumnChainInfo::BuildVector({ 2, 4 })));
         auto chain = builder.Finish().DetachResult();
@@ -533,6 +539,7 @@ Y_UNIT_TEST_SUITE(ProgramStep) {
         std::vector<std::string> data = { "aa", "aaa", "aaaa", "bbbbb" };
         arrow::StringBuilder sb;
         sb.AppendValues(data).ok();
+        using namespace NKikimr::NArrow::NSSA;
 
         auto schema = std::make_shared<arrow::Schema>(
             std::vector{ std::make_shared<arrow::Field>("int", arrow::int64()), std::make_shared<arrow::Field>("string", arrow::utf8()) });
@@ -551,33 +558,33 @@ Y_UNIT_TEST_SUITE(ProgramStep) {
             builder.Add(proc);
         }
         {
-            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({10001}), TColumnChainInfo(1001), std::make_shared<TSimpleFunction>(EOperation::MatchSubstring)).DetachResult();
-            proc->SetYqlOperationId((ui32)NYql::TKernelRequestBuilder::EBinaryOp::StringContains);
+            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({10001}), TColumnChainInfo(1001), std::make_shared<TSimpleFunction>(EOperation::MatchSubstring), 
+                std::make_shared<NKikimr::NArrow::NSSA::TLogicMatchString>(TIndexCheckOperation::EOperation::Contains, true, false)).DetachResult();
             builder.Add(proc);
         }
         {
-            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1001, 4}), TColumnChainInfo(1101), std::make_shared<TSimpleFunction>(EOperation::Add)).DetachResult();
-            proc->SetYqlOperationId((ui32)NYql::TKernelRequestBuilder::EBinaryOp::Coalesce);
+            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1001, 4}), TColumnChainInfo(1101), std::make_shared<TSimpleFunction>(EOperation::Add), 
+                std::make_shared<TSimpleKernelLogic>((ui32)NYql::TKernelRequestBuilder::EBinaryOp::Coalesce)).DetachResult();
             builder.Add(proc);
         }
         {
-            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({2}), TColumnChainInfo(1002), std::make_shared<TSimpleFunction>(EOperation::StartsWith)).DetachResult();
-            proc->SetYqlOperationId((ui32)NYql::TKernelRequestBuilder::EBinaryOp::StartsWith);
+            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({2}), TColumnChainInfo(1002), std::make_shared<TSimpleFunction>(EOperation::StartsWith), std::make_shared<NKikimr::NArrow::NSSA::TLogicMatchString>(
+                NKikimr::NArrow::NSSA::TIndexCheckOperation::EOperation::StartsWith, true, false)).DetachResult();
             builder.Add(proc);
         }
         {
-            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1002, 4}), TColumnChainInfo(1102), std::make_shared<TSimpleFunction>(EOperation::Add)).DetachResult();
-            proc->SetYqlOperationId((ui32)NYql::TKernelRequestBuilder::EBinaryOp::Coalesce);
+            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1002, 4}), TColumnChainInfo(1102), std::make_shared<TSimpleFunction>(EOperation::Add),
+                std::make_shared<TSimpleKernelLogic>((ui32)NYql::TKernelRequestBuilder::EBinaryOp::Coalesce)).DetachResult();
             builder.Add(proc);
         }
         {
-            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1, 3}), TColumnChainInfo(1003), std::make_shared<TSimpleFunction>(EOperation::Equal)).DetachResult();
-            proc->SetYqlOperationId((ui32)NYql::TKernelRequestBuilder::EBinaryOp::Equals);
+            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1, 3}), TColumnChainInfo(1003), std::make_shared<TSimpleFunction>(EOperation::Equal),
+                std::make_shared<TLogicEquals>(false)).DetachResult();
             builder.Add(proc);
         }
         {
-            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1003, 4}), TColumnChainInfo(1103), std::make_shared<TSimpleFunction>(EOperation::Add)).DetachResult();
-            proc->SetYqlOperationId((ui32)NYql::TKernelRequestBuilder::EBinaryOp::Coalesce);
+            auto proc = TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1003, 4}), TColumnChainInfo(1103), std::make_shared<TSimpleFunction>(EOperation::Add),
+                std::make_shared<TSimpleKernelLogic>((ui32)NYql::TKernelRequestBuilder::EBinaryOp::Coalesce)).DetachResult();
             builder.Add(proc);
         }
 
@@ -587,7 +594,7 @@ Y_UNIT_TEST_SUITE(ProgramStep) {
         builder.Add(std::make_shared<TProjectionProcessor>(TColumnChainInfo::BuildVector({ 1, 2 })));
         auto chain = builder.Finish().DetachResult();
         Cerr << chain->DebugDOT() << Endl;
-        AFL_VERIFY(chain->DebugStats() == "[TOTAL:Const:2;Calculation:4;Projection:1;Filter:1;FetchOriginalData:2;AssembleOriginalData:3;CheckIndexData:1;CheckHeaderData:1;StreamLogic:1;];SUB:[FetchOriginalData:1;AssembleOriginalData:1;CheckHeaderData:1;];")("debug", chain->DebugStats());
+        AFL_VERIFY(chain->DebugStats() == "[TOTAL:Const:2;Calculation:4;Projection:1;Filter:1;FetchOriginalData:2;AssembleOriginalData:3;CheckIndexData:1;StreamLogic:1;ReserveMemory:1;];SUB:[AssembleOriginalData:1;];")("debug", chain->DebugStats());
     }
 
     Y_UNIT_TEST(Projection) {
@@ -626,8 +633,8 @@ Y_UNIT_TEST_SUITE(ProgramStep) {
         TSchemaColumnResolver resolver(schema);
         NOptimization::TGraph::TBuilder builder(resolver);
         NAggregation::TWithKeysAggregationProcessor::TBuilder aggrBuilder;
-        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1}), TColumnChainInfo(3), std::make_shared<NAggregation::TAggregateFunction>(EAggregate::Min)).DetachResult());
-        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({2}), TColumnChainInfo(4), std::make_shared<NAggregation::TAggregateFunction>(EAggregate::Max)).DetachResult());
+        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1}), TColumnChainInfo(3), std::make_shared<NAggregation::TAggregateFunction>(EAggregate::Min), std::make_shared<TSimpleKernelLogic>()).DetachResult());
+        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({2}), TColumnChainInfo(4), std::make_shared<NAggregation::TAggregateFunction>(EAggregate::Max), std::make_shared<TSimpleKernelLogic>()).DetachResult());
         builder.Add(std::make_shared<TProjectionProcessor>(TColumnChainInfo::BuildVector({ 3, 4 })));
         auto chain = builder.Finish().DetachResult();
         auto sds = std::make_shared<TSimpleDataSource>();
@@ -655,8 +662,8 @@ Y_UNIT_TEST_SUITE(ProgramStep) {
 
         TSchemaColumnResolver resolver(schema);
         NOptimization::TGraph::TBuilder builder(resolver);
-        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1}), TColumnChainInfo(3), std::make_shared<NAggregation::TAggregateFunction>(EAggregate::Sum)).DetachResult());
-        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({2}), TColumnChainInfo(4), std::make_shared<NAggregation::TAggregateFunction>(EAggregate::Sum)).DetachResult());
+        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({1}), TColumnChainInfo(3), std::make_shared<NAggregation::TAggregateFunction>(EAggregate::Sum), std::make_shared<TSimpleKernelLogic>()).DetachResult());
+        builder.Add(TCalculationProcessor::Build(TColumnChainInfo::BuildVector({2}), TColumnChainInfo(4), std::make_shared<NAggregation::TAggregateFunction>(EAggregate::Sum), std::make_shared<TSimpleKernelLogic>()).DetachResult());
         builder.Add(std::make_shared<TProjectionProcessor>(TColumnChainInfo::BuildVector({ 3, 4 })));
         auto chain = builder.Finish().DetachResult();
 
diff --git a/ydb/core/formats/arrow/ut/ut_reader.cpp b/ydb/core/formats/arrow/ut/ut_reader.cpp
new file mode 100644
index 000000000000..68b1cd2090b8
--- /dev/null
+++ b/ydb/core/formats/arrow/ut/ut_reader.cpp
@@ -0,0 +1,58 @@
+#include <ydb/core/formats/arrow/reader/position.h>
+
+#include <library/cpp/testing/unittest/registar.h>
+
+namespace NKikimr::NArrow {
+
+Y_UNIT_TEST_SUITE(SortableBatchPosition) {
+    Y_UNIT_TEST(FindPosition) {
+        std::shared_ptr<arrow::RecordBatch> data;
+        std::shared_ptr<arrow::Schema> schema =
+            std::make_shared<arrow::Schema>(arrow::Schema({ std::make_shared<arrow::Field>("class", std::make_shared<arrow::StringType>()),
+                std::make_shared<arrow::Field>("name", std::make_shared<arrow::StringType>()) }));
+        {
+            std::unique_ptr<arrow::RecordBatchBuilder> batchBuilder;
+            UNIT_ASSERT(arrow::RecordBatchBuilder::Make(schema, arrow::default_memory_pool(), &batchBuilder).ok());
+
+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(0)->Append("a").ok());
+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(0)->Append("a").ok());
+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(0)->Append("a").ok());
+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(0)->Append("a").ok());
+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(0)->Append("c").ok());
+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(0)->Append("c").ok());
+
+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(1)->Append("a").ok());
+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(1)->Append("a").ok());
+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(1)->Append("c").ok());
+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(1)->Append("c").ok());
+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(1)->Append("a").ok());
+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(1)->Append("c").ok());
+
+            UNIT_ASSERT(batchBuilder->Flush(&data).ok());
+        }
+
+        std::shared_ptr<arrow::RecordBatch> search;
+        {
+            std::unique_ptr<arrow::RecordBatchBuilder> batchBuilder;
+            UNIT_ASSERT(arrow::RecordBatchBuilder::Make(schema, arrow::default_memory_pool(), &batchBuilder).ok());
+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(0)->Append("a").ok());
+            UNIT_ASSERT(batchBuilder->GetFieldAs<arrow::TypeTraits<arrow::StringType>::BuilderType>(1)->Append("c").ok());
+            UNIT_ASSERT(batchBuilder->Flush(&search).ok());
+        }
+
+        NMerger::TSortableBatchPosition searchPosition(search, 0, false);
+        {
+            auto findPosition = NMerger::TSortableBatchPosition::FindBound(data, searchPosition, false, std::nullopt);
+            UNIT_ASSERT(!!findPosition);
+            UNIT_ASSERT_VALUES_EQUAL(findPosition->GetPosition(), 2);
+        }
+
+        {
+            auto findPosition = NMerger::TSortableBatchPosition::FindBound(data, searchPosition, true, std::nullopt);
+            UNIT_ASSERT(!!findPosition);
+            UNIT_ASSERT_VALUES_EQUAL(findPosition->GetPosition(), 4);
+        }
+    }
+}
+
+}   // namespace NKikimr::NArrow
diff --git a/ydb/core/formats/arrow/ut/ya.make b/ydb/core/formats/arrow/ut/ya.make
index 6d82dd0a6d11..f3f2f255017b 100644
--- a/ydb/core/formats/arrow/ut/ya.make
+++ b/ydb/core/formats/arrow/ut/ya.make
@@ -33,6 +33,7 @@ SRCS(
     ut_dictionary.cpp
     ut_column_filter.cpp
     ut_hash.cpp
+    ut_reader.cpp
 )
 
 END()
diff --git a/ydb/core/grpc_services/rpc_load_rows.cpp b/ydb/core/grpc_services/rpc_load_rows.cpp
index ffe6527fed87..108594bb57be 100644
--- a/ydb/core/grpc_services/rpc_load_rows.cpp
+++ b/ydb/core/grpc_services/rpc_load_rows.cpp
@@ -208,9 +208,7 @@ class TUploadRowsRPCPublic : public NTxProxy::TUploadRowsBase<NKikimrServices::T
         return true;
     }
 
-    TVector<std::pair<TString, Ydb::Type>> GetRequestColumns(TString& errorMessage) const override {
-        Y_UNUSED(errorMessage);
-
+    TConclusion<TVector<std::pair<TString, Ydb::Type>>> GetRequestColumns() const override {
         const auto& type = GetProtoRequest(Request.get())->Getrows().Gettype();
         const auto& rowType = type.Getlist_type();
         const auto& rowFields = rowType.Getitem().Getstruct_type().Getmembers();
@@ -398,19 +396,18 @@ class TUploadColumnsRPCPublic : public NTxProxy::TUploadRowsBase<NKikimrServices
         return true;
     }
 
-    TVector<std::pair<TString, Ydb::Type>> GetRequestColumns(TString& errorMessage) const override {
+    TConclusion<TVector<std::pair<TString, Ydb::Type>>> GetRequestColumns() const override {
+        TVector<std::pair<TString, Ydb::Type>> out;
         if (GetSourceType() == EUploadSource::CSV) {
             // TODO: for CSV with header we have to extract columns from data (from first batch in file stream)
-            return {};
+            return out;
         }
 
         auto schema = NArrow::DeserializeSchema(GetSourceSchema());
         if (!schema) {
-            errorMessage = TString("Wrong schema in bulk upsert data");
-            return {};
+            return TConclusionStatus::Fail("Wrong schema in bulk upsert data");
         }
 
-        TVector<std::pair<TString, Ydb::Type>> out;
         out.reserve(schema->num_fields());
 
         for (auto& field : schema->fields()) {
@@ -419,8 +416,7 @@ class TUploadColumnsRPCPublic : public NTxProxy::TUploadRowsBase<NKikimrServices
 
             Ydb::Type ydbType;
             if (!ConvertArrowToYdbPrimitive(*type, ydbType)) {
-                errorMessage = TString("Cannot convert arrow type to ydb one: " + type->ToString());
-                return {};
+                return TConclusionStatus::Fail("Cannot convert arrow type to ydb one: " + type->ToString());
             }
             out.emplace_back(name, std::move(ydbType));
         }
diff --git a/ydb/core/kqp/common/buffer/buffer.h b/ydb/core/kqp/common/buffer/buffer.h
index 226273440269..8025335215e9 100644
--- a/ydb/core/kqp/common/buffer/buffer.h
+++ b/ydb/core/kqp/common/buffer/buffer.h
@@ -12,6 +12,7 @@ struct TKqpBufferWriterSettings {
     NWilson::TTraceId TraceId;
     TIntrusivePtr<TKqpCounters> Counters;
     TIntrusivePtr<NTxProxy::TTxProxyMon> TxProxyMon;
+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;
 };
 
 NActors::IActor* CreateKqpBufferWriterActor(TKqpBufferWriterSettings&& settings);
diff --git a/ydb/core/kqp/common/buffer/events.h b/ydb/core/kqp/common/buffer/events.h
index 3d21caea1c14..b05159518e0d 100644
--- a/ydb/core/kqp/common/buffer/events.h
+++ b/ydb/core/kqp/common/buffer/events.h
@@ -11,9 +11,7 @@ namespace NKqp {
 
 struct TEvKqpBuffer {
 
-struct TEvPrepare : public TEventLocal<TEvPrepare, TKqpBufferWriterEvents::EvPrepare> {
-    TActorId ExecuterActorId;
-};
+// To BufferActor
 
 struct TEvCommit : public TEventLocal<TEvCommit, TKqpBufferWriterEvents::EvCommit> {
     TActorId ExecuterActorId;
@@ -28,6 +26,11 @@ struct TEvFlush : public TEventLocal<TEvFlush, TKqpBufferWriterEvents::EvFlush>
     TActorId ExecuterActorId;
 };
 
+struct TEvTerminate : public TEventLocal<TEvTerminate, TKqpBufferWriterEvents::EvTerminate> {
+};
+
+// From BufferActor
+
 struct TEvResult : public TEventLocal<TEvResult, TKqpBufferWriterEvents::EvResult> {
     TEvResult() = default;
     TEvResult(NYql::NDqProto::TDqTaskStats&& stats) : Stats(std::move(stats)) {}
@@ -42,9 +45,6 @@ struct TEvError : public TEventLocal<TEvError, TKqpBufferWriterEvents::EvError>
     TEvError(NYql::NDqProto::StatusIds::StatusCode statusCode, NYql::TIssues&& issues);
 };
 
-struct TEvTerminate : public TEventLocal<TEvTerminate, TKqpBufferWriterEvents::EvTerminate> {
-};
-
 };
 
 }
diff --git a/ydb/core/kqp/common/kqp_data_integrity_trails.h b/ydb/core/kqp/common/kqp_data_integrity_trails.h
index 71198204a55b..28566a975d53 100644
--- a/ydb/core/kqp/common/kqp_data_integrity_trails.h
+++ b/ydb/core/kqp/common/kqp_data_integrity_trails.h
@@ -6,6 +6,8 @@
 #include <library/cpp/string_utils/base64/base64.h>
 
 #include <ydb/core/data_integrity_trails/data_integrity_trails.h>
+#include <ydb/core/tx/data_events/events.h>
+#include <ydb/core/tx/datashard/datashard.h>
 
 namespace NKikimr {
 namespace NDataIntegrity {
@@ -97,23 +99,110 @@ inline void LogIntegrityTrails(const TString& traceId, NKikimrKqp::EQueryAction
 }
 
 // DataExecuter
-inline void LogIntegrityTrails(const TString& txType, const TString& traceId, ui64 txId, TMaybe<ui64> shardId, const TActorContext& ctx) {
-    auto log = [](const auto& type, const auto& traceId, const auto& txId, const auto& shardId) {
+inline void LogIntegrityTrails(const TString& txType, const TString& txLocksDebugStr, const TString& traceId, ui64 txId, TMaybe<ui64> shardId, const TActorContext& ctx) {
+    auto log = [](const auto& type, const auto& txLocksDebugStr, const auto& traceId, const auto& txId, const auto& shardId) {
         TStringStream ss;
         LogKeyValue("Component", "Executer", ss);
+        LogKeyValue("Type", "Request", ss);
         LogKeyValue("TraceId", traceId, ss);
         LogKeyValue("PhyTxId", ToString(txId), ss);
+        LogKeyValue("Locks", "[" + txLocksDebugStr + "]", ss);
 
         if (shardId) {
             LogKeyValue("ShardId", ToString(*shardId), ss);
         }
 
-        LogKeyValue("Type", type, ss, /*last*/ true);
+        LogKeyValue("TxType", type, ss, /*last*/ true);
+
+        return ss.Str();
+    };
+
+    LOG_INFO_S(ctx, NKikimrServices::DATA_INTEGRITY, log(txType, txLocksDebugStr, traceId, txId, shardId));
+}
+
+inline void LogIntegrityTrails(const TString& state, const TString& traceId, const NEvents::TDataEvents::TEvWriteResult::TPtr& ev, const TActorContext& ctx) {
+    auto log = [](const auto& state, const auto& traceId, const auto& ev) {
+        const auto& record = ev->Get()->Record;
+
+        TStringStream ss;
+        LogKeyValue("Component", "Executer", ss);
+        LogKeyValue("Type", "Response", ss);
+        LogKeyValue("State", state, ss);
+        LogKeyValue("TraceId", traceId, ss);
+        LogKeyValue("PhyTxId", ToString(record.GetTxId()), ss);
+        LogKeyValue("ShardId", ToString(record.GetOrigin()), ss);
+
+        TStringBuilder locksDebugStr;
+        locksDebugStr << "[";
+        for (const auto& lock : record.GetTxLocks()) {
+            locksDebugStr << lock.ShortDebugString() << " ";
+        }
+        locksDebugStr << "]";
+
+        LogKeyValue("Locks", locksDebugStr, ss);
+        LogKeyValue("Status",  NKikimrDataEvents::TEvWriteResult::EStatus_Name(ev->Get()->GetStatus()), ss);
+
+        NYql::TIssues issues;
+        NYql::IssuesFromMessage(record.GetIssues(), issues);
+        LogKeyValue("Issues", issues.ToString(), ss, /*last*/ true);
+
+        return ss.Str();
+    };
+
+    LOG_INFO_S(ctx, NKikimrServices::DATA_INTEGRITY, log(state, traceId, ev));
+}
+
+inline void LogIntegrityTrails(const TString& state, const TString& traceId, const TEvDataShard::TEvProposeTransactionResult::TPtr& ev, const TActorContext& ctx) {
+    auto log = [](const auto& state, const auto& traceId, const auto& ev) {
+        const auto& record = ev->Get()->Record;
+
+        TStringStream ss;
+        LogKeyValue("Component", "Executer", ss);
+        LogKeyValue("Type", "Response", ss);
+        LogKeyValue("State", state, ss);
+        LogKeyValue("TraceId", traceId, ss);
+        LogKeyValue("PhyTxId", ToString(record.GetTxId()), ss);
+        LogKeyValue("ShardId", ToString(record.GetOrigin()), ss);
+
+        TStringBuilder locksDebugStr;
+        locksDebugStr << "[";
+        for (const auto& lock : record.GetTxLocks()) {
+            locksDebugStr << lock.ShortDebugString() << " ";
+        }
+        locksDebugStr << "]";
+
+        LogKeyValue("Locks", locksDebugStr, ss);
+        LogKeyValue("Status",  NKikimrTxDataShard::TEvProposeTransactionResult_EStatus_Name(ev->Get()->GetStatus()), ss);
+        LogKeyValue("Issues", ev->Get()->GetError(), ss, /*last*/ true);
+
+        return ss.Str();
+    };
+
+    LOG_INFO_S(ctx, NKikimrServices::DATA_INTEGRITY, log(state, traceId, ev));
+}
+
+template <typename TActorResultInfo>
+inline void LogIntegrityTrails(const TString& type, const TString& traceId, ui64 txId, const TActorResultInfo& info, const TActorContext& ctx) {
+    auto log = [](const auto& type, const auto& traceId, const auto& txId, const auto& info) {
+        TStringStream ss;
+        LogKeyValue("Component", "Executer", ss);
+        LogKeyValue("Type", type, ss);
+        LogKeyValue("TraceId", traceId, ss);
+        LogKeyValue("PhyTxId", ToString(txId), ss);
+
+        TStringBuilder locksDebugStr;
+        locksDebugStr << "[";
+        for (const auto& lock : info.GetLocks()) {
+            locksDebugStr << lock.ShortDebugString() << " ";
+        }
+        locksDebugStr << "]";
+
+        LogKeyValue("Locks", locksDebugStr, ss);
 
         return ss.Str();
     };
 
-    LOG_INFO_S(ctx, NKikimrServices::DATA_INTEGRITY, log(txType, traceId, txId, shardId));
+    LOG_INFO_S(ctx, NKikimrServices::DATA_INTEGRITY, log(type, traceId, txId, info));
 }
 
 // WriteActor,BufferActor
diff --git a/ydb/core/kqp/common/kqp_tx.cpp b/ydb/core/kqp/common/kqp_tx.cpp
index e9b02b093c37..f6022c112c52 100644
--- a/ydb/core/kqp/common/kqp_tx.cpp
+++ b/ydb/core/kqp/common/kqp_tx.cpp
@@ -335,7 +335,7 @@ bool HasOltpTableWriteInTx(const NKqpProto::TKqpPhyQuery& physicalQuery) {
     return false;
 }
 
-bool HasUncommittedChangesRead(THashSet<NKikimr::TTableId>& modifiedTables, const NKqpProto::TKqpPhyQuery& physicalQuery) {
+bool HasUncommittedChangesRead(THashSet<NKikimr::TTableId>& modifiedTables, const NKqpProto::TKqpPhyQuery& physicalQuery, const bool commit) {
     auto getTable = [](const NKqpProto::TKqpPhyTableId& table) {
         return NKikimr::TTableId(table.GetOwnerId(), table.GetTableId());
     };
@@ -402,6 +402,10 @@ bool HasUncommittedChangesRead(THashSet<NKikimr::TTableId>& modifiedTables, cons
                     NKikimrKqp::TKqpTableSinkSettings settings;
                     YQL_ENSURE(sink.GetInternalSink().GetSettings().UnpackTo(&settings), "Failed to unpack settings");
                     modifiedTables.insert(getTable(settings.GetTable()));
+                    if (settings.GetType() == NKikimrKqp::TKqpTableSinkSettings::MODE_INSERT && !commit) {
+                        // INSERT with sink should be executed immediately, because it returns an error in case of duplicate rows.
+                        return true;
+                    }
                 } else {
                     return true;
                 }
diff --git a/ydb/core/kqp/common/kqp_tx.h b/ydb/core/kqp/common/kqp_tx.h
index d7353de0540a..68a34c7186b0 100644
--- a/ydb/core/kqp/common/kqp_tx.h
+++ b/ydb/core/kqp/common/kqp_tx.h
@@ -160,7 +160,7 @@ class TShardIdToTableInfo {
 };
 using TShardIdToTableInfoPtr = std::shared_ptr<TShardIdToTableInfo>;
 
-bool HasUncommittedChangesRead(THashSet<NKikimr::TTableId>& modifiedTables, const NKqpProto::TKqpPhyQuery& physicalQuery);
+bool HasUncommittedChangesRead(THashSet<NKikimr::TTableId>& modifiedTables, const NKqpProto::TKqpPhyQuery& physicalQuery, const bool commit);
 
 class TKqpTransactionContext : public NYql::TKikimrTransactionContextBase  {
 public:
@@ -316,8 +316,8 @@ class TKqpTransactionContext : public NYql::TKikimrTransactionContextBase  {
         return true;
     }
 
-    void ApplyPhysicalQuery(const NKqpProto::TKqpPhyQuery& phyQuery) {
-        NeedUncommittedChangesFlush = HasUncommittedChangesRead(ModifiedTablesSinceLastFlush, phyQuery);
+    void ApplyPhysicalQuery(const NKqpProto::TKqpPhyQuery& phyQuery, const bool commit) {
+        NeedUncommittedChangesFlush = HasUncommittedChangesRead(ModifiedTablesSinceLastFlush, phyQuery, commit);
         if (NeedUncommittedChangesFlush) {
             ModifiedTablesSinceLastFlush.clear();   
         }
diff --git a/ydb/core/kqp/common/kqp_tx_manager.cpp b/ydb/core/kqp/common/kqp_tx_manager.cpp
index a23ed7d5c7e6..2d973deea186 100644
--- a/ydb/core/kqp/common/kqp_tx_manager.cpp
+++ b/ydb/core/kqp/common/kqp_tx_manager.cpp
@@ -91,7 +91,6 @@ class TKqpTransactionManager : public IKqpTransactionManager {
         auto& shardInfo = ShardsInfo.at(shardId);
         if (auto lockPtr = shardInfo.Locks.FindPtr(lock.GetKey()); lockPtr) {
             if (lock.Proto.GetHasWrites()) {
-                AFL_ENSURE(!ReadOnly);
                 lockPtr->Lock.Proto.SetHasWrites(true);
             }
 
@@ -163,6 +162,14 @@ class TKqpTransactionManager : public IKqpTransactionManager {
         return nullptr;
     }
 
+    void AddParticipantNode(const ui32 nodeId) override {
+        ParticipantNodes.insert(nodeId);
+    }
+
+    const THashSet<ui32>& GetParticipantNodes() const override {
+        return ParticipantNodes;
+    }
+
     void SetTopicOperations(NTopic::TTopicOperations&& topicOperations) override {
         TopicOperations = std::move(topicOperations);
     }
@@ -307,6 +314,10 @@ class TKqpTransactionManager : public IKqpTransactionManager {
         return !dontNeedCommit;
     }
 
+    virtual ui64 GetCoordinator() const override {
+        return Coordinator;
+    }
+
     void StartPrepare() override {
         AFL_ENSURE(!CollectOnly);
         AFL_ENSURE(State == ETransactionState::COLLECTING);
@@ -485,7 +496,8 @@ class TKqpTransactionManager : public IKqpTransactionManager {
 
     void MakeLocksIssue(const TShardInfo& shardInfo) {
         TStringBuilder message;
-        message << "Transaction locks invalidated. Tables: ";
+        message << "Transaction locks invalidated. ";
+        message << (shardInfo.Pathes.size() == 1 ? "Table: " : "Tables: ");
         bool first = true;
         // TODO: add error by pathid
         for (const auto& path : shardInfo.Pathes) {
@@ -502,6 +514,8 @@ class TKqpTransactionManager : public IKqpTransactionManager {
     THashMap<ui64, TShardInfo> ShardsInfo;
     std::unordered_set<TString> TablePathes;
 
+    THashSet<ui32> ParticipantNodes;
+
     THashMap<TTableId, std::shared_ptr<const TVector<TKeyDesc::TPartitionInfo>>> TablePartitioning;
 
     bool AllowVolatile = false;
diff --git a/ydb/core/kqp/common/kqp_tx_manager.h b/ydb/core/kqp/common/kqp_tx_manager.h
index 18ba29d93299..dc11e0b12bec 100644
--- a/ydb/core/kqp/common/kqp_tx_manager.h
+++ b/ydb/core/kqp/common/kqp_tx_manager.h
@@ -71,6 +71,9 @@ class IKqpTransactionManager {
     virtual void BuildTopicTxs(NTopic::TTopicOperationTransactions& txs) = 0;
     virtual bool HasTopics() const = 0;
 
+    virtual void AddParticipantNode(const ui32 nodeId) = 0;
+    virtual const THashSet<ui32>& GetParticipantNodes() const = 0;
+
     virtual bool IsTxPrepared() const = 0;
     virtual bool IsTxFinished() const = 0;
 
@@ -95,6 +98,8 @@ class IKqpTransactionManager {
 
     virtual bool NeedCommit() const = 0;
 
+    virtual ui64 GetCoordinator() const = 0;
+
     virtual void StartPrepare() = 0;
 
     struct TPrepareInfo {
diff --git a/ydb/core/kqp/common/kqp_yql.cpp b/ydb/core/kqp/common/kqp_yql.cpp
index 0ff2491c2a0b..050f527db95b 100644
--- a/ydb/core/kqp/common/kqp_yql.cpp
+++ b/ydb/core/kqp/common/kqp_yql.cpp
@@ -158,10 +158,11 @@ TKqpReadTableSettings ParseInternal(const TCoNameValueTupleList& node) {
             settings.ItemsLimit = tuple.Value().Cast().Ptr();
         } else if (name == TKqpReadTableSettings::ReverseSettingName) {
             YQL_ENSURE(tuple.Ref().ChildrenSize() == 1);
-            settings.Reverse = true;
+            settings.SetSorting(ERequestSorting::DESC);
         } else if (name == TKqpReadTableSettings::SortedSettingName) {
-            YQL_ENSURE(tuple.Ref().ChildrenSize() == 1);
-            settings.Sorted = true;
+            if (settings.GetSorting() == ERequestSorting::NONE) {
+                settings.SetSorting(ERequestSorting::ASC);
+            }
         } else if (name == TKqpReadTableSettings::SequentialSettingName) {
             YQL_ENSURE(tuple.Ref().ChildrenSize() == 2);
             settings.SequentialInFlight = FromString<ui64>(tuple.Value().Cast<TCoAtom>().Value());
@@ -224,7 +225,7 @@ NNodes::TCoNameValueTupleList TKqpReadTableSettings::BuildNode(TExprContext& ctx
                 .Done());
     }
 
-    if (Reverse) {
+    if (IsReverse()) {
         settings.emplace_back(
             Build<TCoNameValueTuple>(ctx, pos)
                 .Name()
@@ -240,7 +241,7 @@ NNodes::TCoNameValueTupleList TKqpReadTableSettings::BuildNode(TExprContext& ctx
                 .Done());
     }
 
-    if (Sorted) {
+    if (IsSorted()) {
         settings.emplace_back(
             Build<TCoNameValueTuple>(ctx, pos)
                 .Name()
diff --git a/ydb/core/kqp/common/kqp_yql.h b/ydb/core/kqp/common/kqp_yql.h
index 2765c35b9335..4372406e1c35 100644
--- a/ydb/core/kqp/common/kqp_yql.h
+++ b/ydb/core/kqp/common/kqp_yql.h
@@ -44,7 +44,7 @@ struct TKqpPhyTxSettings {
 };
 
 constexpr TStringBuf KqpReadRangesSourceName = "KqpReadRangesSource";
-constexpr TStringBuf KqpTableSinkName = "KqpTableSinkName";
+constexpr TStringBuf KqpTableSinkName = "KqpTableSink";
 
 enum class EStreamLookupStrategyType {
     Unspecified,
@@ -72,7 +72,35 @@ struct TKqpStreamLookupSettings {
     static TKqpStreamLookupSettings Parse(const NNodes::TCoNameValueTupleList& node);
 };
 
-struct TKqpReadTableSettings {
+enum class ERequestSorting {
+    NONE = 0,
+    ASC,
+    DESC
+};
+
+template <ERequestSorting DefaultValue = ERequestSorting::NONE>
+class TSortingOperator {
+private:
+    ERequestSorting Sorting = DefaultValue;
+public:
+    void SetSorting(const ERequestSorting sorting) {
+        Sorting = sorting;
+    }
+    ERequestSorting GetSorting() const {
+        return Sorting;
+    }
+
+    bool IsSorted() const {
+        return Sorting != ERequestSorting::NONE;
+    }
+
+    bool IsReverse() const {
+        return Sorting == ERequestSorting::DESC;
+    }
+};
+
+struct TKqpReadTableSettings: public TSortingOperator<ERequestSorting::NONE> {
+public:
     static constexpr TStringBuf SkipNullKeysSettingName = "SkipNullKeys";
     static constexpr TStringBuf ItemsLimitSettingName = "ItemsLimit";
     static constexpr TStringBuf ReverseSettingName = "Reverse";
@@ -84,16 +112,12 @@ struct TKqpReadTableSettings {
 
     TVector<TString> SkipNullKeys;
     TExprNode::TPtr ItemsLimit;
-    bool Reverse = false;
-    bool Sorted = false;
     TMaybe<ui64> SequentialInFlight;
     TMaybe<ui64> TabletId;
     bool ForcePrimary = false;
 
     void AddSkipNullKey(const TString& key);
     void SetItemsLimit(const TExprNode::TPtr& expr) { ItemsLimit = expr; }
-    void SetReverse() { Reverse = true; }
-    void SetSorted() { Sorted = true; }
 
     bool operator == (const TKqpReadTableSettings&) const = default;
 
diff --git a/ydb/core/kqp/common/simple/kqp_event_ids.h b/ydb/core/kqp/common/simple/kqp_event_ids.h
index a54408006423..b9ad1addb195 100644
--- a/ydb/core/kqp/common/simple/kqp_event_ids.h
+++ b/ydb/core/kqp/common/simple/kqp_event_ids.h
@@ -94,6 +94,7 @@ struct TKqpComputeEvents {
         EvScanInitActor,
         EvRemoteScanData,
         EvRemoteScanDataAck,
+        EvScanPing,
     };
 
     static_assert(Unused0 == EventSpaceBegin(TKikimrEvents::ES_KQP) + 200);
diff --git a/ydb/core/kqp/compute_actor/kqp_compute_actor_factory.cpp b/ydb/core/kqp/compute_actor/kqp_compute_actor_factory.cpp
index 46267030ba46..0dff7085bdcd 100644
--- a/ydb/core/kqp/compute_actor/kqp_compute_actor_factory.cpp
+++ b/ydb/core/kqp/compute_actor/kqp_compute_actor_factory.cpp
@@ -86,7 +86,7 @@ class TKqpCaFactory : public IKqpNodeComputeActorFactory {
     std::atomic<ui64> MkqlLightProgramMemoryLimit = 0;
     std::atomic<ui64> MkqlHeavyProgramMemoryLimit = 0;
     std::atomic<ui64> MinChannelBufferSize = 0;
-    std::atomic<ui64> MinMemAllocSize = 8_MB;
+    std::atomic<ui64> MinMemAllocSize = 1_MB;
     std::atomic<ui64> MinMemFreeSize = 32_MB;
 
 public:
diff --git a/ydb/core/kqp/compute_actor/kqp_compute_events.h b/ydb/core/kqp/compute_actor/kqp_compute_events.h
index 4b9d3f292420..cdb0496fe4df 100644
--- a/ydb/core/kqp/compute_actor/kqp_compute_events.h
+++ b/ydb/core/kqp/compute_actor/kqp_compute_events.h
@@ -250,16 +250,22 @@ struct TEvKqpCompute {
         }
     };
 
+    struct TEvScanPing : public NActors::TEventPB<TEvScanPing, NKikimrKqp::TEvScanPing,
+        TKqpComputeEvents::EvScanPing>
+    {
+    };
+
     struct TEvScanInitActor : public NActors::TEventPB<TEvScanInitActor, NKikimrKqp::TEvScanInitActor,
         TKqpComputeEvents::EvScanInitActor>
     {
         TEvScanInitActor() = default;
 
-        TEvScanInitActor(ui64 scanId, const NActors::TActorId& scanActor, ui32 generation, const ui64 tabletId) {
+        TEvScanInitActor(ui64 scanId, const NActors::TActorId& scanActor, ui32 generation, const ui64 tabletId, bool allowPings = false) {
             Record.SetScanId(scanId);
             ActorIdToProto(scanActor, Record.MutableScanActorId());
             Record.SetGeneration(generation);
             Record.SetTabletId(tabletId);
+            Record.SetAllowPings(allowPings);
         }
     };
 
diff --git a/ydb/core/kqp/compute_actor/kqp_pure_compute_actor.cpp b/ydb/core/kqp/compute_actor/kqp_pure_compute_actor.cpp
index 2e019e53797e..4b08dca16f42 100644
--- a/ydb/core/kqp/compute_actor/kqp_pure_compute_actor.cpp
+++ b/ydb/core/kqp/compute_actor/kqp_pure_compute_actor.cpp
@@ -84,7 +84,7 @@ void TKqpComputeActor::DoBootstrap() {
     try {
         PrepareTaskRunner(TKqpTaskRunnerExecutionContext(std::get<ui64>(TxId), RuntimeSettings.UseSpilling, ArrayBufferMinFillPercentage, std::move(wakeupCallback), std::move(errorCallback)));
     } catch (const NMiniKQL::TKqpEnsureFail& e) {
-        InternalError((TIssuesIds::EIssueCode) e.GetCode(), e.GetMessage());
+        ErrorFromIssue((TIssuesIds::EIssueCode) e.GetCode(), e.GetMessage());
         return;
     }
 
@@ -120,7 +120,7 @@ void TKqpComputeActor::DoBootstrap() {
         auto scanActor = NSysView::CreateSystemViewScan(SelfId(), 0, ScanData->TableId, ScanData->TablePath, ranges, columns, UserToken, Database, reverse);
 
         if (!scanActor) {
-            InternalError(TIssuesIds::DEFAULT_ERROR, TStringBuilder()
+            ErrorFromIssue(TIssuesIds::DEFAULT_ERROR, TStringBuilder()
                 << "Failed to create system view scan, table id: " << ScanData->TableId);
             return;
         }
@@ -148,9 +148,9 @@ STFUNC(TKqpComputeActor::StateFunc) {
     } catch (const TMemoryLimitExceededException& e) {
         TBase::OnMemoryLimitExceptionHandler();
     } catch (const NMiniKQL::TKqpEnsureFail& e) {
-        InternalError((TIssuesIds::EIssueCode) e.GetCode(), e.GetMessage());
-    } catch (const yexception& e) {
-        InternalError(TIssuesIds::DEFAULT_ERROR, e.what());
+        ErrorFromIssue((TIssuesIds::EIssueCode) e.GetCode(), e.GetMessage());
+    } catch (const std::exception& e) {
+        ErrorFromIssue(TIssuesIds::DEFAULT_ERROR, e.what());
     }
 
     ReportEventElapsedTime();
diff --git a/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.cpp b/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.cpp
index 7eab5ef78196..1b408cdf6f82 100644
--- a/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.cpp
+++ b/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.cpp
@@ -27,10 +27,9 @@ std::vector<std::unique_ptr<TComputeTaskData>> TShardScannerInfo::OnReceiveData(
         AFL_ENSURE(data.Finished);
         result.emplace_back(std::make_unique<TComputeTaskData>(selfPtr, std::make_unique<TEvScanExchange::TEvSendData>(TabletId, data.LocksInfo)));
     } else if (data.SplittedBatches.size() > 1) {
-        ui32 idx = 0;
         AFL_ENSURE(data.ArrowBatch);
         for (auto&& i : data.SplittedBatches) {
-            result.emplace_back(std::make_unique<TComputeTaskData>(selfPtr, std::make_unique<TEvScanExchange::TEvSendData>(data.ArrowBatch, TabletId, std::move(i), data.LocksInfo), idx++));
+            result.emplace_back(std::make_unique<TComputeTaskData>(selfPtr, std::make_unique<TEvScanExchange::TEvSendData>(data.ArrowBatch, TabletId, std::move(i), data.LocksInfo)));
         }
     } else if (data.ArrowBatch) {
         result.emplace_back(std::make_unique<TComputeTaskData>(selfPtr, std::make_unique<TEvScanExchange::TEvSendData>(data.ArrowBatch, TabletId, data.LocksInfo)));
diff --git a/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.h b/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.h
index 67b7ff64beee..bcc0e28fe4ce 100644
--- a/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.h
+++ b/ydb/core/kqp/compute_actor/kqp_scan_compute_manager.h
@@ -32,6 +32,7 @@ class TShardScannerInfo {
     const ui64 FreeSpace = (ui64)8 << 20;
     bool NeedAck = true;
     bool Finished = false;
+    bool AllowPings = false;
 
     void DoAck() {
         if (Finished) {
@@ -105,10 +106,17 @@ class TShardScannerInfo {
         return !ActorId.has_value();
     }
 
-    void Start(const TActorId& actorId) {
+    void PingIfNeeded() {
+        if (AllowPings && !!ActorId) {
+            NActors::TActivationContext::AsActorContext().Send(*ActorId, new TEvKqpCompute::TEvScanPing());
+        }
+    }
+
+    void Start(const TActorId& actorId, bool allowPings) {
         AFL_DEBUG(NKikimrServices::KQP_COMPUTE)("event", "start_scanner")("actor_id", actorId);
         AFL_ENSURE(!ActorId);
         ActorId = actorId;
+        AllowPings = allowPings;
         DoAck();
     }
 
@@ -284,6 +292,12 @@ class TInFlightShards: public NComputeActor::TScanShardsStatistics {
         }
     }
 
+    void PingAllScanners() {
+        for (auto&& itTablet : ShardScanners) {
+            itTablet.second->PingIfNeeded();
+        }
+    }
+
     std::shared_ptr<TShardState> GetShardStateByActorId(const NActors::TActorId& actorId) const {
         auto it = ShardsByActorId.find(actorId);
         if (it == ShardsByActorId.end()) {
@@ -307,7 +321,7 @@ class TInFlightShards: public NComputeActor::TScanShardsStatistics {
         }
     }
 
-    void RegisterScannerActor(const ui64 tabletId, const ui64 generation, const TActorId& scanActorId) {
+    void RegisterScannerActor(const ui64 tabletId, const ui64 generation, const TActorId& scanActorId, bool allowPings) {
         auto state = GetShardState(tabletId);
         if (!state || generation != state->Generation) {
             AFL_DEBUG(NKikimrServices::KQP_COMPUTE)("event", "register_scanner_actor_dropped")
@@ -326,7 +340,7 @@ class TInFlightShards: public NComputeActor::TScanShardsStatistics {
         state->ResetRetry();
         AFL_ENSURE(ShardsByActorId.emplace(scanActorId, state).second);
 
-        GetShardScannerVerified(tabletId)->Start(scanActorId);
+        GetShardScannerVerified(tabletId)->Start(scanActorId, allowPings);
     }
 
     void StartScanner(TShardState& state) {
diff --git a/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.cpp b/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.cpp
index 0a383b154a6f..45064976e208 100644
--- a/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.cpp
+++ b/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.cpp
@@ -1,10 +1,12 @@
 #include "kqp_scan_fetcher_actor.h"
-#include <ydb/library/wilson_ids/wilson.h>
-#include <ydb/core/kqp/common/kqp_resolve.h>
-#include <ydb/core/tx/datashard/range_ops.h>
+
 #include <ydb/core/actorlib_impl/long_timer.h>
+#include <ydb/core/kqp/common/kqp_resolve.h>
+#include <ydb/core/kqp/common/kqp_yql.h>
 #include <ydb/core/scheme/scheme_types_proto.h>
+#include <ydb/core/tx/datashard/range_ops.h>
 
+#include <ydb/library/wilson_ids/wilson.h>
 #include <ydb/library/yql/dq/actors/compute/dq_compute_actor_impl.h>
 
 namespace NKikimr::NKqp::NScanPrivate {
@@ -15,18 +17,16 @@ using namespace NYql;
 using namespace NYql::NDq;
 using namespace NKikimr::NKqp::NComputeActor;
 
-static constexpr ui64 MAX_SHARD_RETRIES = 5; // retry after: 0, 250, 500, 1000, 2000
+static constexpr ui64 MAX_SHARD_RETRIES = 5;   // retry after: 0, 250, 500, 1000, 2000
 static constexpr ui64 MAX_TOTAL_SHARD_RETRIES = 20;
 static constexpr ui64 MAX_SHARD_RESOLVES = 3;
 
-} // anonymous namespace
-
+}   // anonymous namespace
 
-TKqpScanFetcherActor::TKqpScanFetcherActor(const NKikimrKqp::TKqpSnapshot& snapshot,
-    const TComputeRuntimeSettings& settings, std::vector<NActors::TActorId>&& computeActors,
-    const ui64 txId, const TMaybe<ui64> lockTxId, const ui32 lockNodeId, const TMaybe<NKikimrDataEvents::ELockMode> lockMode,
-    const NKikimrTxDataShard::TKqpTransaction_TScanTaskMeta& meta, const TShardsScanningPolicy& shardsScanningPolicy,
-    TIntrusivePtr<TKqpCounters> counters, NWilson::TTraceId traceId)
+TKqpScanFetcherActor::TKqpScanFetcherActor(const NKikimrKqp::TKqpSnapshot& snapshot, const TComputeRuntimeSettings& settings,
+    std::vector<NActors::TActorId>&& computeActors, const ui64 txId, const TMaybe<ui64> lockTxId, const ui32 lockNodeId,
+    const TMaybe<NKikimrDataEvents::ELockMode> lockMode, const NKikimrTxDataShard::TKqpTransaction_TScanTaskMeta& meta,
+    const TShardsScanningPolicy& shardsScanningPolicy, TIntrusivePtr<TKqpCounters> counters, NWilson::TTraceId traceId)
     : Meta(meta)
     , ScanDataMeta(Meta)
     , RuntimeSettings(settings)
@@ -47,14 +47,15 @@ TKqpScanFetcherActor::TKqpScanFetcherActor(const NKikimrKqp::TKqpSnapshot& snaps
     KeyColumnTypes.reserve(Meta.GetKeyColumnTypes().size());
     for (size_t i = 0; i < Meta.KeyColumnTypesSize(); i++) {
         NScheme::TTypeId typeId = Meta.GetKeyColumnTypes().at(i);
-        NScheme::TTypeInfo typeInfo = NScheme::NTypeIds::IsParametrizedType(typeId) ?
-            NScheme::TypeInfoFromProto(typeId, Meta.GetKeyColumnTypeInfos().at(i)) :
-            NScheme::TTypeInfo(typeId);
+        NScheme::TTypeInfo typeInfo = NScheme::NTypeIds::IsParametrizedType(typeId)
+                                          ? NScheme::TypeInfoFromProto(typeId, Meta.GetKeyColumnTypeInfos().at(i))
+                                          : NScheme::TTypeInfo(typeId);
         KeyColumnTypes.push_back(typeInfo);
     }
 }
 
-TVector<NKikimr::TSerializedTableRange> TKqpScanFetcherActor::BuildSerializedTableRanges(const NKikimrTxDataShard::TKqpTransaction::TScanTaskMeta::TReadOpMeta& readData) {
+TVector<NKikimr::TSerializedTableRange> TKqpScanFetcherActor::BuildSerializedTableRanges(
+    const NKikimrTxDataShard::TKqpTransaction::TScanTaskMeta::TReadOpMeta& readData) {
     TVector<TSerializedTableRange> resultLocal;
     resultLocal.reserve(readData.GetKeyRanges().size());
     for (const auto& range : readData.GetKeyRanges()) {
@@ -82,21 +83,21 @@ void TKqpScanFetcherActor::Bootstrap() {
     AFL_DEBUG(NKikimrServices::KQP_COMPUTE)("event", "bootstrap")("compute", ComputeActorIds.size())("shards", PendingShards.size());
     StartTableScan();
     Become(&TKqpScanFetcherActor::StateFunc);
+    Schedule(TDuration::Seconds(30), new NActors::TEvents::TEvWakeup());
 }
 
 void TKqpScanFetcherActor::HandleExecute(TEvScanExchange::TEvAckData::TPtr& ev) {
     AFL_ENSURE(ev->Get()->GetFreeSpace());
-    AFL_DEBUG(NKikimrServices::KQP_COMPUTE)("event", "AckDataFromCompute")("self_id", SelfId())("scan_id", ScanId)
-        ("packs_to_send", InFlightComputes.GetPacksToSendCount())
-        ("from", ev->Sender)("shards remain", PendingShards.size())
-        ("in flight scans", InFlightShards.GetScansCount())
-        ("in flight shards", InFlightShards.GetShardsCount());
+    AFL_DEBUG(NKikimrServices::KQP_COMPUTE)("event", "AckDataFromCompute")("self_id", SelfId())("scan_id", ScanId)(
+        "packs_to_send", InFlightComputes.GetPacksToSendCount())("from", ev->Sender)("shards remain", PendingShards.size())(
+        "in flight scans", InFlightShards.GetScansCount())("in flight shards", InFlightShards.GetShardsCount());
     InFlightComputes.OnComputeAck(ev->Sender, ev->Get()->GetFreeSpace());
     CheckFinish();
 }
 
 void TKqpScanFetcherActor::HandleExecute(TEvScanExchange::TEvTerminateFromCompute::TPtr& ev) {
-    AFL_DEBUG(NKikimrServices::KQP_COMPUTE)("event", "TEvTerminateFromCompute")("sender", ev->Sender)("info", ev->Get()->GetIssues().ToOneLineString());
+    AFL_DEBUG(NKikimrServices::KQP_COMPUTE)("event", "TEvTerminateFromCompute")("sender", ev->Sender)(
+        "info", ev->Get()->GetIssues().ToOneLineString());
     TStringBuilder sb;
     sb << "Send abort execution from compute actor, message: " << ev->Get()->GetIssues().ToOneLineString();
 
@@ -110,7 +111,7 @@ void TKqpScanFetcherActor::HandleExecute(TEvKqpCompute::TEvScanInitActor::TPtr&
     }
     auto& msg = ev->Get()->Record;
     auto scanActorId = ActorIdFromProto(msg.GetScanActorId());
-    InFlightShards.RegisterScannerActor(msg.GetTabletId(), msg.GetGeneration(), scanActorId);
+    InFlightShards.RegisterScannerActor(msg.GetTabletId(), msg.GetGeneration(), scanActorId, msg.GetAllowPings());
 }
 
 void TKqpScanFetcherActor::HandleExecute(TEvKqpCompute::TEvScanData::TPtr& ev) {
@@ -124,17 +125,13 @@ void TKqpScanFetcherActor::HandleExecute(TEvKqpCompute::TEvScanData::TPtr& ev) {
     AFL_ENSURE(state->State == EShardState::Running)("state", state->State)("actor_id", state->ActorId)("ev_sender", ev->Sender);
 
     AFL_DEBUG(NKikimrServices::KQP_COMPUTE)
-        ("Recv TEvScanData from ShardID=", ev->Sender)
-        ("ScanId", ev->Get()->ScanId)
-        ("Finished", ev->Get()->Finished)
-        ("Lock", [&]() {
+    ("Recv TEvScanData from ShardID=", ev->Sender)("ScanId", ev->Get()->ScanId)("Finished", ev->Get()->Finished)("Lock", [&]() {
         TStringBuilder builder;
         for (const auto& lock : ev->Get()->LocksInfo.Locks) {
             builder << lock.ShortDebugString();
         }
         return builder;
-    }())
-        ("BrokenLocks", [&]() {
+    }())("BrokenLocks", [&]() {
         TStringBuilder builder;
         for (const auto& lock : ev->Get()->LocksInfo.BrokenLocks) {
             builder << lock.ShortDebugString();
@@ -162,10 +159,8 @@ void TKqpScanFetcherActor::HandleExecute(TEvKqpCompute::TEvScanError::TPtr& ev)
     TIssues issues;
     IssuesFromMessage(msg.GetIssues(), issues);
 
-    CA_LOG_W("Got EvScanError scan state: "
-        << ", status: " << Ydb::StatusIds_StatusCode_Name(status)
-        << ", reason: " << issues.ToString()
-        << ", tablet id: " << msg.GetTabletId() << ", actor_id: " << ev->Sender);
+    CA_LOG_W("Got EvScanError scan state: " << ", status: " << Ydb::StatusIds_StatusCode_Name(status) << ", reason: " << issues.ToString()
+                                            << ", tablet id: " << msg.GetTabletId() << ", actor_id: " << ev->Sender);
 
     auto state = InFlightShards.GetShardStateByActorId(ev->Sender);
     if (!state) {
@@ -182,8 +177,8 @@ void TKqpScanFetcherActor::HandleExecute(TEvKqpCompute::TEvScanError::TPtr& ev)
     if (state->State == EShardState::Starting) {
         ++TotalRetries;
         if (TotalRetries >= MAX_TOTAL_SHARD_RETRIES) {
-            CA_LOG_E("TKqpScanFetcherActor: broken tablet for this request " << state->TabletId
-                << ", retries limit exceeded (" << state->TotalRetries << "/" << TotalRetries << ")");
+            CA_LOG_E("TKqpScanFetcherActor: broken tablet for this request " << state->TabletId << ", retries limit exceeded ("
+                                                                             << state->TotalRetries << "/" << TotalRetries << ")");
             SendGlobalFail(NDqProto::COMPUTE_STATE_FAILURE, YdbStatusToDqStatus(status), issues);
             return PassAway();
         }
@@ -203,8 +198,8 @@ void TKqpScanFetcherActor::HandleExecute(TEvKqpCompute::TEvScanError::TPtr& ev)
     }
 
     if (state->State == EShardState::PostRunning || state->State == EShardState::Running) {
-        CA_LOG_E("TKqpScanFetcherActor: broken tablet for this request " << state->TabletId
-            << ", retries limit exceeded (" << state->TotalRetries << "/" << TotalRetries << ")");
+        CA_LOG_E("TKqpScanFetcherActor: broken tablet for this request " << state->TabletId << ", retries limit exceeded ("
+                                                                         << state->TotalRetries << "/" << TotalRetries << ")");
         SendGlobalFail(NDqProto::COMPUTE_STATE_FAILURE, YdbStatusToDqStatus(status), issues);
         return PassAway();
     }
@@ -299,68 +294,82 @@ void TKqpScanFetcherActor::HandleExecute(TEvTxProxySchemeCache::TEvResolveKeySet
     }
 
     const auto& tr = *AppData()->TypeRegistry;
-
-    TVector<TShardState> newShards;
-    newShards.reserve(keyDesc->GetPartitions().size());
-
-    for (ui64 idx = 0, i = 0; idx < keyDesc->GetPartitions().size(); ++idx) {
-        const auto& partition = keyDesc->GetPartitions()[idx];
-
-        TTableRange partitionRange{
-            idx == 0 ? state.Ranges.front().From.GetCells() : keyDesc->GetPartitions()[idx - 1].Range->EndKeyPrefix.GetCells(),
-            idx == 0 ? state.Ranges.front().FromInclusive : !keyDesc->GetPartitions()[idx - 1].Range->IsInclusive,
-            keyDesc->GetPartitions()[idx].Range->EndKeyPrefix.GetCells(),
-            keyDesc->GetPartitions()[idx].Range->IsInclusive
-        };
-
-        CA_LOG_D("Processing resolved ShardId# " << partition.ShardId
-            << ", partition range: " << DebugPrintRange(KeyColumnTypes, partitionRange, tr)
-            << ", i: " << i << ", state ranges: " << state.Ranges.size());
-
-        auto newShard = TShardState(partition.ShardId);
-
-        for (ui64 j = i; j < state.Ranges.size(); ++j) {
-            auto comparison = CompareRanges(partitionRange, state.Ranges[j].ToTableRange(), KeyColumnTypes);
-            CA_LOG_D("Compare range #" << j << " " << DebugPrintRange(KeyColumnTypes, state.Ranges[j].ToTableRange(), tr)
-                << " with partition range " << DebugPrintRange(KeyColumnTypes, partitionRange, tr)
-                << " : " << comparison);
-
-            if (comparison > 0) {
+    if (Meta.HasOlapProgram()) {
+        bool found = false;
+        for (auto&& partition : keyDesc->GetPartitions()) {
+            if (partition.ShardId != state.TabletId) {
                 continue;
-            } else if (comparison == 0) {
-                auto intersection = Intersect(KeyColumnTypes, partitionRange, state.Ranges[j].ToTableRange());
-                CA_LOG_D("Add range to new shardId: " << partition.ShardId
-                    << ", range: " << DebugPrintRange(KeyColumnTypes, intersection, tr));
-
-                newShard.Ranges.emplace_back(TSerializedTableRange(intersection));
-            } else {
-                break;
             }
-            i = j;
+            auto newShard = TShardState(partition.ShardId);
+            AFL_ENSURE(!found);
+            newShard.LastKey = std::move(state.LastKey);
+            newShard.LastCursorProto = std::move(state.LastCursorProto);
+            newShard.Ranges = state.Ranges;
+            PendingShards.emplace_front(std::move(newShard));
+            found = true;
         }
+        AFL_ENSURE(found);
+    } else {
+        TVector<TShardState> newShards;
+        newShards.reserve(keyDesc->GetPartitions().size());
+
+        for (ui64 idx = 0, i = 0; idx < keyDesc->GetPartitions().size(); ++idx) {
+            const auto& partition = keyDesc->GetPartitions()[idx];
+
+            TTableRange partitionRange{ idx == 0 ? state.Ranges.front().From.GetCells()
+                                                 : keyDesc->GetPartitions()[idx - 1].Range->EndKeyPrefix.GetCells(),
+                idx == 0 ? state.Ranges.front().FromInclusive : !keyDesc->GetPartitions()[idx - 1].Range->IsInclusive,
+                keyDesc->GetPartitions()[idx].Range->EndKeyPrefix.GetCells(), keyDesc->GetPartitions()[idx].Range->IsInclusive };
+
+            CA_LOG_D("Processing resolved ShardId# "
+                     << partition.ShardId << ", partition range: " << DebugPrintRange(KeyColumnTypes, partitionRange, tr) << ", i: " << i
+                     << ", state ranges: " << state.Ranges.size());
+
+            auto newShard = TShardState(partition.ShardId);
+
+            for (ui64 j = i; j < state.Ranges.size(); ++j) {
+                auto comparison = CompareRanges(partitionRange, state.Ranges[j].ToTableRange(), KeyColumnTypes);
+                CA_LOG_D("Compare range #" << j << " " << DebugPrintRange(KeyColumnTypes, state.Ranges[j].ToTableRange(), tr)
+                                           << " with partition range " << DebugPrintRange(KeyColumnTypes, partitionRange, tr) << " : "
+                                           << comparison);
+
+                if (comparison > 0) {
+                    continue;
+                } else if (comparison == 0) {
+                    auto intersection = Intersect(KeyColumnTypes, partitionRange, state.Ranges[j].ToTableRange());
+                    CA_LOG_D(
+                        "Add range to new shardId: " << partition.ShardId << ", range: " << DebugPrintRange(KeyColumnTypes, intersection, tr));
+
+                    newShard.Ranges.emplace_back(TSerializedTableRange(intersection));
+                } else {
+                    break;
+                }
+                i = j;
+            }
 
-        if (!newShard.Ranges.empty()) {
-            newShards.emplace_back(std::move(newShard));
+            if (!newShard.Ranges.empty()) {
+                newShards.emplace_back(std::move(newShard));
+            }
         }
-    }
 
-    AFL_ENSURE(!newShards.empty());
+        AFL_ENSURE(!newShards.empty());
 
-    for (int i = newShards.ysize() - 1; i >= 0; --i) {
-        PendingShards.emplace_front(std::move(newShards[i]));
-    }
-
-    if (!state.LastKey.empty()) {
-        PendingShards.front().LastKey = std::move(state.LastKey);
-        while (!PendingShards.empty() && PendingShards.front().GetScanRanges(KeyColumnTypes).empty()) {
-            CA_LOG_D("Nothing to read " << PendingShards.front().ToString(KeyColumnTypes));
-            auto readShard = std::move(PendingShards.front());
-            PendingShards.pop_front();
-            PendingShards.front().LastKey = std::move(readShard.LastKey);
-            PendingShards.front().LastCursorProto = std::move(readShard.LastCursorProto);
+        for (int i = newShards.ysize() - 1; i >= 0; --i) {
+            PendingShards.emplace_front(std::move(newShards[i]));
         }
 
-        AFL_ENSURE(!PendingShards.empty());
+        if (!state.LastKey.empty()) {
+            PendingShards.front().LastKey = std::move(state.LastKey);
+            while (!PendingShards.empty() && PendingShards.front().GetScanRanges(KeyColumnTypes).empty()) {
+                CA_LOG_D("Nothing to read " << PendingShards.front().ToString(KeyColumnTypes));
+                auto readShard = std::move(PendingShards.front());
+                PendingShards.pop_front();
+                PendingShards.front().LastKey = std::move(readShard.LastKey);
+                PendingShards.front().LastCursorProto = std::move(readShard.LastCursorProto);
+            }
+
+            AFL_ENSURE(!PendingShards.empty());
+        }
     }
     StartTableScan();
 }
@@ -374,8 +383,8 @@ void TKqpScanFetcherActor::HandleExecute(TEvents::TEvUndelivered::TPtr& ev) {
             auto info = InFlightShards.GetShardScanner(ev->Cookie);
             if (!!info) {
                 auto state = InFlightShards.GetShardStateVerified(info->GetTabletId());
-                AFL_WARN(NKikimrServices::KQP_COMPUTE)("event", "TEvents::TEvUndelivered")("from_tablet", info->GetTabletId())
-                    ("state", state->State)("details", info->ToString())("node", SelfId().NodeId());
+                AFL_WARN(NKikimrServices::KQP_COMPUTE)("event", "TEvents::TEvUndelivered")("from_tablet", info->GetTabletId())(
+                    "state", state->State)("details", info->ToString())("node", SelfId().NodeId());
                 AFL_ENSURE(state->State == EShardState::Running || state->State == EShardState::Starting)("state", state->State);
                 RetryDeliveryProblem(state);
             }
@@ -390,18 +399,20 @@ void TKqpScanFetcherActor::HandleExecute(TEvInterconnect::TEvNodeDisconnected::T
     CA_LOG_N("Disconnected node " << nodeId);
 
     TrackingNodes.erase(nodeId);
-    SendGlobalFail(NDqProto::StatusIds::UNAVAILABLE, TIssuesIds::DEFAULT_ERROR,
-        TStringBuilder() << "Connection with node " << nodeId << " lost.");
+    SendGlobalFail(
+        NDqProto::StatusIds::UNAVAILABLE, TIssuesIds::DEFAULT_ERROR, TStringBuilder() << "Connection with node " << nodeId << " lost.");
 }
 
-bool TKqpScanFetcherActor::SendGlobalFail(const NYql::NDqProto::StatusIds::StatusCode statusCode, const TIssuesIds::EIssueCode issueCode, const TString& message) const {
+bool TKqpScanFetcherActor::SendGlobalFail(
+    const NYql::NDqProto::StatusIds::StatusCode statusCode, const TIssuesIds::EIssueCode issueCode, const TString& message) const {
     for (auto&& i : ComputeActorIds) {
         Send(i, new TEvScanExchange::TEvTerminateFromFetcher(statusCode, issueCode, message));
     }
     return true;
 }
 
-bool TKqpScanFetcherActor::SendGlobalFail(const NDqProto::EComputeState state, NYql::NDqProto::StatusIds::StatusCode statusCode, const TIssues& issues) const {
+bool TKqpScanFetcherActor::SendGlobalFail(
+    const NDqProto::EComputeState state, NYql::NDqProto::StatusIds::StatusCode statusCode, const TIssues& issues) const {
     for (auto&& i : ComputeActorIds) {
         Send(i, new TEvScanExchange::TEvTerminateFromFetcher(state, statusCode, issues));
     }
@@ -461,7 +472,15 @@ std::unique_ptr<NKikimr::TEvDataShard::TEvKqpScan> TKqpScanFetcherActor::BuildEv
 
     ev->Record.SetGeneration(gen);
 
-    ev->Record.SetReverse(Meta.GetReverse());
+    if (Meta.HasOptionalSorting()) {
+        if (Meta.GetOptionalSorting() == (ui32)ERequestSorting::DESC) {
+            ev->Record.SetReverse(true);
+        } else if (Meta.GetOptionalSorting() == (ui32)ERequestSorting::ASC) {
+            ev->Record.SetReverse(false);
+        }
+    } else {
+        ev->Record.SetReverse(Meta.GetReverse());
+    }
     ev->Record.SetItemsLimit(Meta.GetItemsLimit());
 
     if (Meta.GroupByColumnNamesSize()) {
@@ -476,9 +495,7 @@ std::unique_ptr<NKikimr::TEvDataShard::TEvKqpScan> TKqpScanFetcherActor::BuildEv
         TStringOutput stream(programBytes);
         Meta.GetOlapProgram().SerializeToArcadiaStream(&stream);
         ev->Record.SetOlapProgram(programBytes);
-        ev->Record.SetOlapProgramType(
-            NKikimrSchemeOp::EOlapProgramType::OLAP_PROGRAM_SSA_PROGRAM_WITH_PARAMETERS
-        );
+        ev->Record.SetOlapProgramType(NKikimrSchemeOp::EOlapProgramType::OLAP_PROGRAM_SSA_PROGRAM_WITH_PARAMETERS);
     }
 
     ev->Record.SetDataFormat(Meta.GetDataFormat());
@@ -504,18 +521,15 @@ void TKqpScanFetcherActor::ProcessPendingScanDataItem(TEvKqpCompute::TEvScanData
     state->LastKey = std::move(msg.LastKey);
     state->LastCursorProto = std::move(msg.LastCursorProto);
     const ui64 rowsCount = msg.GetRowsCount();
-    AFL_DEBUG(NKikimrServices::KQP_COMPUTE)("action", "got EvScanData")("rows", rowsCount)("finished", msg.Finished)("exceeded", msg.RequestedBytesLimitReached)
-        ("scan", ScanId)("packs_to_send", InFlightComputes.GetPacksToSendCount())
-        ("from", ev->Sender)("shards remain", PendingShards.size())
-        ("in flight scans", InFlightShards.GetScansCount())
-        ("in flight shards", InFlightShards.GetShardsCount())
-        ("delayed_for_seconds_by_ratelimiter", latency.SecondsFloat())
-        ("tablet_id", state->TabletId)
-        ("locks", msg.LocksInfo.Locks.size())
-        ("broken locks", msg.LocksInfo.BrokenLocks.size());
+    AFL_DEBUG(NKikimrServices::KQP_COMPUTE)("action", "got EvScanData")("rows", rowsCount)("finished", msg.Finished)(
+        "exceeded", msg.RequestedBytesLimitReached)("scan", ScanId)("packs_to_send", InFlightComputes.GetPacksToSendCount())("from", ev->Sender)(
+        "shards remain", PendingShards.size())("in flight scans", InFlightShards.GetScansCount())(
+        "in flight shards", InFlightShards.GetShardsCount())("delayed_for_seconds_by_ratelimiter", latency.SecondsFloat())(
+        "tablet_id", state->TabletId)("locks", msg.LocksInfo.Locks.size())("broken locks", msg.LocksInfo.BrokenLocks.size());
     auto shardScanner = InFlightShards.GetShardScannerVerified(state->TabletId);
     auto tasksForCompute = shardScanner->OnReceiveData(msg, shardScanner);
-    AFL_ENSURE(tasksForCompute.size() == 1 || tasksForCompute.size() == 0 || tasksForCompute.size() == ComputeActorIds.size())("size", tasksForCompute.size())("compute_size", ComputeActorIds.size());
+    AFL_ENSURE(tasksForCompute.size() == 1 || tasksForCompute.size() == 0 || tasksForCompute.size() == ComputeActorIds.size())(
+        "size", tasksForCompute.size())("compute_size", ComputeActorIds.size());
     for (auto&& i : tasksForCompute) {
         const std::optional<ui32> computeShardId = i->GetComputeShardId();
         InFlightComputes.OnReceiveData(computeShardId, std::move(i));
@@ -525,7 +539,8 @@ void TKqpScanFetcherActor::ProcessPendingScanDataItem(TEvKqpCompute::TEvScanData
     InFlightShards.MutableStatistics(state->TabletId).AddPack(rowsCount, 0);
     Stats.AddReadStat(state->TabletId, rowsCount, 0);
 
-    CA_LOG_D("EVLOGKQP:" << IsAggregationRequest << "/" << Meta.GetItemsLimit() << "/" << InFlightShards.GetTotalRowsCount() << "/" << rowsCount);
+    CA_LOG_D(
+        "EVLOGKQP:" << IsAggregationRequest << "/" << Meta.GetItemsLimit() << "/" << InFlightShards.GetTotalRowsCount() << "/" << rowsCount);
     if (msg.Finished) {
         Stats.CompleteShard(state);
         InFlightShards.StopScanner(state->TabletId);
@@ -541,8 +556,9 @@ void TKqpScanFetcherActor::ProcessScanData() {
     PendingScanData.pop_front();
 
     auto state = InFlightShards.GetShardStateByActorId(ev->Sender);
-    if (!state)
+    if (!state) {
         return;
+    }
 
     AFL_ENSURE(state->State == EShardState::Running || state->State == EShardState::PostRunning)("state", state->State);
     ProcessPendingScanDataItem(ev, enqueuedAt);
@@ -565,11 +581,10 @@ void TKqpScanFetcherActor::StartTableScan() {
     }
 
     CA_LOG_D("Scheduled table scans, in flight: " << InFlightShards.GetScansCount() << " shards. "
-        << "pending shards to read: " << PendingShards.size() << ", "
-        << "pending resolve shards: " << PendingResolveShards.size() << ", "
-        << "average read rows: " << Stats.AverageReadRows() << ", "
-        << "average read bytes: " << Stats.AverageReadBytes() << ", ");
-
+                                                  << "pending shards to read: " << PendingShards.size() << ", "
+                                                  << "pending resolve shards: " << PendingResolveShards.size() << ", "
+                                                  << "average read rows: " << Stats.AverageReadRows() << ", "
+                                                  << "average read bytes: " << Stats.AverageReadBytes() << ", ");
 }
 
 void TKqpScanFetcherActor::RetryDeliveryProblem(TShardState::TPtr state) {
@@ -577,8 +592,8 @@ void TKqpScanFetcherActor::RetryDeliveryProblem(TShardState::TPtr state) {
     Counters->ScanQueryShardDisconnect->Inc();
 
     if (state->TotalRetries >= MAX_TOTAL_SHARD_RETRIES) {
-        CA_LOG_E("TKqpScanFetcherActor: broken pipe with tablet " << state->TabletId
-            << ", retries limit exceeded (" << state->TotalRetries << ")");
+        CA_LOG_E(
+            "TKqpScanFetcherActor: broken pipe with tablet " << state->TabletId << ", retries limit exceeded (" << state->TotalRetries << ")");
         SendGlobalFail(NDqProto::StatusIds::UNAVAILABLE, TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,
             TStringBuilder() << "Retries limit with shard " << state->TabletId << " exceeded.");
         return;
@@ -596,10 +611,10 @@ void TKqpScanFetcherActor::RetryDeliveryProblem(TShardState::TPtr state) {
 
     ++TotalRetries;
     auto retryDelay = state->CalcRetryDelay();
-    CA_LOG_W("TKqpScanFetcherActor: broken pipe with tablet " << state->TabletId
-        << ", restarting scan from last received key " << state->PrintLastKey(KeyColumnTypes)
-        << ", attempt #" << state->RetryAttempt << " (total " << state->TotalRetries << ")"
-        << " schedule after " << retryDelay);
+    CA_LOG_W("TKqpScanFetcherActor: broken pipe with tablet " << state->TabletId << ", restarting scan from last received key "
+                                                              << state->PrintLastKey(KeyColumnTypes) << ", attempt #" << state->RetryAttempt
+                                                              << " (total " << state->TotalRetries << ")"
+                                                              << " schedule after " << retryDelay);
 
     state->RetryTimer = CreateLongTimer(TlsActivationContext->AsActorContext(), retryDelay,
         new IEventHandle(SelfId(), SelfId(), new TEvPrivate::TEvRetryShard(state->TabletId, state->Generation)));
@@ -617,9 +632,10 @@ void TKqpScanFetcherActor::ResolveShard(TShardState& state) {
     state.State = EShardState::Resolving;
     state.ResolveAttempt++;
     state.SubscribedOnTablet = false;
+    AFL_ENSURE(state.Ranges.size());
 
-    auto range = TTableRange(state.Ranges.front().From.GetCells(), state.Ranges.front().FromInclusive,
-        state.Ranges.back().To.GetCells(), state.Ranges.back().ToInclusive);
+    auto range = TTableRange(state.Ranges.front().From.GetCells(), state.Ranges.front().FromInclusive, state.Ranges.back().To.GetCells(),
+        state.Ranges.back().ToInclusive);
 
     TVector<TKeyDesc::TColumnOp> columns;
     columns.reserve(ScanDataMeta.GetColumns().size());
@@ -631,12 +647,11 @@ void TKqpScanFetcherActor::ResolveShard(TShardState& state) {
         columns.emplace_back(std::move(op));
     }
 
-    auto keyDesc = MakeHolder<TKeyDesc>(ScanDataMeta.TableId, range, TKeyDesc::ERowOperation::Read,
-        KeyColumnTypes, columns);
+    auto keyDesc = MakeHolder<TKeyDesc>(ScanDataMeta.TableId, range, TKeyDesc::ERowOperation::Read, KeyColumnTypes, columns);
 
     CA_LOG_D("Sending TEvResolveKeySet update for table '" << ScanDataMeta.TablePath << "'"
-        << ", range: " << DebugPrintRange(KeyColumnTypes, range, *AppData()->TypeRegistry)
-        << ", attempt #" << state.ResolveAttempt);
+                                                           << ", range: " << DebugPrintRange(KeyColumnTypes, range, *AppData()->TypeRegistry)
+                                                           << ", attempt #" << state.ResolveAttempt);
 
     auto request = MakeHolder<NSchemeCache::TSchemeCacheRequest>();
     request->ResultSet.emplace_back(std::move(keyDesc));
@@ -668,12 +683,15 @@ void TKqpScanFetcherActor::CheckFinish() {
     if (GetShardsInProgressCount() == 0 && InFlightComputes.GetPacksToSendCount() == 0) {
         SendScanFinished();
         InFlightShards.Stop();
-        CA_LOG_D("EVLOGKQP(max_in_flight:" << MaxInFlight << ")"
-            << Endl << InFlightShards.GetDurationStats()
-            << Endl << InFlightShards.StatisticsToString()
-        );
+        CA_LOG_D("EVLOGKQP(max_in_flight:" << MaxInFlight << ")" << Endl << InFlightShards.GetDurationStats() << Endl
+                                           << InFlightShards.StatisticsToString());
         PassAway();
     }
 }
 
+void TKqpScanFetcherActor::HandleExecute(NActors::TEvents::TEvWakeup::TPtr&) {
+    InFlightShards.PingAllScanners();
+    Schedule(TDuration::Seconds(30), new NActors::TEvents::TEvWakeup());
 }
+
+}   // namespace NKikimr::NKqp::NScanPrivate
diff --git a/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.h b/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.h
index 73ead0a5ef0e..18d6e0500398 100644
--- a/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.h
+++ b/ydb/core/kqp/compute_actor/kqp_scan_fetcher_actor.h
@@ -82,6 +82,7 @@ class TKqpScanFetcherActor: public NActors::TActorBootstrapped<TKqpScanFetcherAc
                 hFunc(TEvInterconnect::TEvNodeDisconnected, HandleExecute);
                 hFunc(TEvScanExchange::TEvTerminateFromCompute, HandleExecute);
                 hFunc(TEvScanExchange::TEvAckData, HandleExecute);
+                hFunc(NActors::TEvents::TEvWakeup, HandleExecute);
                 IgnoreFunc(TEvInterconnect::TEvNodeConnected);
                 IgnoreFunc(TEvTxProxySchemeCache::TEvInvalidateTableResult);
                 default:
@@ -97,6 +98,8 @@ class TKqpScanFetcherActor: public NActors::TActorBootstrapped<TKqpScanFetcherAc
 
     void HandleExecute(TEvScanExchange::TEvTerminateFromCompute::TPtr& ev);
 
+    void HandleExecute(NActors::TEvents::TEvWakeup::TPtr& ev);
+
 private:
 
     void CheckFinish();
diff --git a/ydb/core/kqp/executer_actor/kqp_data_executer.cpp b/ydb/core/kqp/executer_actor/kqp_data_executer.cpp
index 614442fd57a1..238710d6a3a8 100644
--- a/ydb/core/kqp/executer_actor/kqp_data_executer.cpp
+++ b/ydb/core/kqp/executer_actor/kqp_data_executer.cpp
@@ -198,6 +198,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
             if (data.GetData().template Is<NKikimrTxDataShard::TEvKqpInputActorResultInfo>()) {
                 NKikimrTxDataShard::TEvKqpInputActorResultInfo info;
                 YQL_ENSURE(data.GetData().UnpackTo(&info), "Failed to unpack settings");
+                NDataIntegrity::LogIntegrityTrails("InputActorResult", Request.UserTraceId, TxId, info, TlsActivationContext->AsActorContext());
                 for (auto& lock : info.GetLocks()) {
                     if (!TxManager) {
                         Locks.push_back(lock);
@@ -216,6 +217,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
             } else if (data.GetData().template Is<NKikimrKqp::TEvKqpOutputActorResultInfo>()) {
                 NKikimrKqp::TEvKqpOutputActorResultInfo info;
                 YQL_ENSURE(data.GetData().UnpackTo(&info), "Failed to unpack settings");
+                NDataIntegrity::LogIntegrityTrails("OutputActorResult", Request.UserTraceId, TxId, info, TlsActivationContext->AsActorContext());
                 for (auto& lock : info.GetLocks()) {
                     if (!TxManager) {
                         Locks.push_back(lock);
@@ -256,6 +258,10 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
 
         if (TxManager) {
             TxManager->SetHasSnapshot(GetSnapshot().IsValid());
+
+            for (const ui64& shardId : TxManager->GetShards()) {
+                Stats->AffectedShards.insert(shardId);
+            }
         }
 
         if (!BufferActorId || (ReadOnlyTx && Request.LocksOp != ELocksOp::Rollback)) {
@@ -269,7 +275,12 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
             auto event = std::make_unique<NKikimr::NKqp::TEvKqpBuffer::TEvCommit>();
             event->ExecuterActorId = SelfId();
             event->TxId = TxId;
-            Send<ESendingType::Tail>(BufferActorId, event.release(), IEventHandle::FlagTrackDelivery);
+            Send<ESendingType::Tail>(
+                BufferActorId,
+                event.release(),
+                IEventHandle::FlagTrackDelivery,
+                0,
+                ExecuterSpan.GetTraceId());
             return;
         } else if (Request.LocksOp == ELocksOp::Rollback) {
             Become(&TKqpDataExecuter::FinalizeState);
@@ -277,7 +288,12 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
 
             auto event = std::make_unique<NKikimr::NKqp::TEvKqpBuffer::TEvRollback>();
             event->ExecuterActorId = SelfId();
-            Send<ESendingType::Tail>(BufferActorId, event.release(), IEventHandle::FlagTrackDelivery);
+            Send<ESendingType::Tail>(
+                BufferActorId,
+                event.release(),
+                IEventHandle::FlagTrackDelivery,
+                0,
+                ExecuterSpan.GetTraceId());
             MakeResponseAndPassAway();
             return;
         } else if (Request.UseImmediateEffects) {
@@ -286,7 +302,12 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
 
             auto event = std::make_unique<NKikimr::NKqp::TEvKqpBuffer::TEvFlush>();
             event->ExecuterActorId = SelfId();
-            Send<ESendingType::Tail>(BufferActorId, event.release(), IEventHandle::FlagTrackDelivery);
+            Send<ESendingType::Tail>(
+                BufferActorId,
+                event.release(),
+                IEventHandle::FlagTrackDelivery,
+                0,
+                ExecuterSpan.GetTraceId());
             return;
         } else {
             Become(&TKqpDataExecuter::FinalizeState);
@@ -298,7 +319,8 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
     STATEFN(FinalizeState) {
         try {
             switch(ev->GetTypeRewrite()) {
-                hFunc(TEvKqp::TEvAbortExecution, HandleAbortExecution);
+                hFunc(TEvKqp::TEvAbortExecution, HandleFinalize);
+                hFunc(TEvKqpBuffer::TEvError, Handle);
                 hFunc(TEvKqpBuffer::TEvResult, HandleFinalize);
                 hFunc(TEvents::TEvUndelivered, HandleFinalize);
 
@@ -325,6 +347,14 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
         ReportEventElapsedTime();
     }
 
+    void HandleFinalize(TEvKqp::TEvAbortExecution::TPtr& ev) {
+        if (IsCancelAfterAllowed(ev)) {
+            TBase::HandleAbortExecution(ev);
+        } else {
+            LOG_D("Got TEvAbortExecution from : " << ev->Sender << " but cancelation is not alowed");
+        }
+    }
+
     void HandleFinalize(TEvKqpBuffer::TEvResult::TPtr& ev) {
         if (ev->Get()->Stats) {
             if (Stats) {
@@ -335,13 +365,8 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
     }
 
     void HandleFinalize(TEvents::TEvUndelivered::TPtr&) {
-        if (Request.LocksOp == ELocksOp::Commit && !ReadOnlyTx) {
-            auto issue = YqlIssue({}, TIssuesIds::KIKIMR_OPERATION_STATE_UNKNOWN, "Buffer actor isn't available. Operation state unknown.");
-            ReplyErrorAndDie(Ydb::StatusIds::UNDETERMINED, issue);
-        } else {
-            auto issue = YqlIssue({}, TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE, "Buffer actor isn't available.");
-            ReplyErrorAndDie(Ydb::StatusIds::UNAVAILABLE, issue);
-        }
+        auto issue = YqlIssue({}, TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE, "Buffer actor isn't available.");
+        ReplyErrorAndDie(Ydb::StatusIds::UNAVAILABLE, issue);
     }
 
     void MakeResponseAndPassAway() {
@@ -395,6 +420,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
                 hFunc(TEvSaveScriptExternalEffectResponse, HandleResolve);
                 hFunc(TEvDescribeSecretsResponse, HandleResolve);
                 hFunc(TEvKqp::TEvAbortExecution, HandleAbortExecution);
+                hFunc(TEvKqpBuffer::TEvError, Handle);
                 default:
                     UnexpectedEvent("WaitResolveState", ev->GetTypeRewrite());
             }
@@ -446,6 +472,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
                 hFunc(TEvKqpExecuter::TEvStreamDataAck, HandleStreamAck);
                 hFunc(TEvPipeCache::TEvDeliveryProblem, HandlePrepare);
                 hFunc(TEvKqp::TEvAbortExecution, HandlePrepare);
+                hFunc(TEvKqpBuffer::TEvError, Handle);
                 hFunc(TEvents::TEvUndelivered, HandleUndelivered);
                 hFunc(TEvInterconnect::TEvNodeDisconnected, HandleDisconnected);
                 hFunc(TEvKqpNode::TEvStartKqpTasksResponse, HandleStartKqpTasksResponse);
@@ -498,6 +525,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
         TShardState* shardState = ShardStates.FindPtr(shardId);
         YQL_ENSURE(shardState, "Unexpected propose result from unknown tabletId " << shardId);
 
+        NDataIntegrity::LogIntegrityTrails("Prepare", Request.UserTraceId, ev, TlsActivationContext->AsActorContext());
         LOG_D("Got propose result, shard: " << shardId << ", status: "
             << NKikimrTxDataShard::TEvProposeTransactionResult_EStatus_Name(res->GetStatus())
             << ", error: " << res->GetError());
@@ -567,6 +595,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
         NYql::TIssues issues;
         NYql::IssuesFromMessage(res->Record.GetIssues(), issues);
 
+        NDataIntegrity::LogIntegrityTrails("Prepare", Request.UserTraceId, ev, TlsActivationContext->AsActorContext());
         LOG_D("Recv EvWriteResult (prepare) from ShardID=" << shardId
             << ", Status=" << NKikimrDataEvents::TEvWriteResult::EStatus_Name(ev->Get()->GetStatus())
             << ", TxId=" << ev->Get()->Record.GetTxId()
@@ -889,6 +918,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
                         case NKikimrTxDataShard::TError::SCHEME_ERROR:
                             return ReplyErrorAndDie(Ydb::StatusIds::SCHEME_ERROR, YqlIssue({},
                                 TIssuesIds::KIKIMR_SCHEME_MISMATCH, er.GetReason()));
+                        //TODO Split OUT_OF_SPACE and DISK_SPACE_EXHAUSTED cases. The first one is temporary, the second one is permanent.
                         case NKikimrTxDataShard::TError::OUT_OF_SPACE:
                         case NKikimrTxDataShard::TError::DISK_SPACE_EXHAUSTED: {
                             auto issue = YqlIssue({}, TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE);
@@ -1097,7 +1127,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
             transaction.SetFlags(TEvTxProxy::TEvProposeTransaction::FlagVolatile);
         }
 
-        NDataIntegrity::LogIntegrityTrails("PlannedTx", Request.UserTraceId, TxId, {}, TlsActivationContext->AsActorContext());
+        NDataIntegrity::LogIntegrityTrails("PlannedTx", "", Request.UserTraceId, TxId, {}, TlsActivationContext->AsActorContext());
 
         LOG_D("Execute planned transaction, coordinator: " << TxCoordinator << " for " << affectedSet.size() << "shards");
         Send(MakePipePerNodeCacheID(false), new TEvPipeCache::TEvForward(ev.Release(), TxCoordinator, /* subscribe */ true));
@@ -1124,6 +1154,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
                 hFunc(NYql::NDq::TEvDqCompute::TEvChannelData, HandleChannelData);
                 hFunc(TEvKqpExecuter::TEvStreamDataAck, HandleStreamAck);
                 hFunc(TEvKqp::TEvAbortExecution, HandleExecute);
+                hFunc(TEvKqpBuffer::TEvError, Handle);
                 IgnoreFunc(TEvInterconnect::TEvNodeConnected);
                 default:
                     UnexpectedEvent("ExecuteState", ev->GetTypeRewrite());
@@ -1180,6 +1211,11 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
         }
     }
 
+    void Handle(TEvKqpBuffer::TEvError::TPtr& ev) {
+        auto& msg = *ev->Get();
+        TBase::HandleAbortExecution(msg.StatusCode, msg.Issues, false);
+    }
+
     void HandleExecute(TEvColumnShard::TEvProposeTransactionResult::TPtr& ev) {
         TEvColumnShard::TEvProposeTransactionResult* res = ev->Get();
         const ui64 shardId = res->Record.GetOrigin();
@@ -1238,6 +1274,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
         NYql::TIssues issues;
         NYql::IssuesFromMessage(res->Record.GetIssues(), issues);
 
+        NDataIntegrity::LogIntegrityTrails("Execute", Request.UserTraceId, ev, TlsActivationContext->AsActorContext());
         LOG_D("Recv EvWriteResult (execute) from ShardID=" << shardId
             << ", Status=" << NKikimrDataEvents::TEvWriteResult::EStatus_Name(ev->Get()->GetStatus())
             << ", TxId=" << ev->Get()->Record.GetTxId()
@@ -1255,6 +1292,10 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
             Stats->AddDatashardStats(std::move(*res->Record.MutableTxStats()));
         }
 
+        if (TxManager) {
+            TxManager->AddParticipantNode(ev->Sender.NodeId());
+        }
+
         switch (ev->Get()->GetStatus()) {
             case NKikimrDataEvents::TEvWriteResult::STATUS_UNSPECIFIED: {
                 YQL_ENSURE(false);
@@ -1309,6 +1350,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
         TShardState* shardState = ShardStates.FindPtr(shardId);
         YQL_ENSURE(shardState);
 
+        NDataIntegrity::LogIntegrityTrails("Execute", Request.UserTraceId, ev, TlsActivationContext->AsActorContext());
         LOG_D("Got propose result, shard: " << shardId << ", status: "
             << NKikimrTxDataShard::TEvProposeTransactionResult_EStatus_Name(res->GetStatus())
             << ", error: " << res->GetError());
@@ -1712,7 +1754,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
 
     void ExecuteDatashardTransaction(ui64 shardId, NKikimrTxDataShard::TKqpTransaction& kqpTx, const bool isOlap)
     {
-        YQL_ENSURE(!TxManager);
+        YQL_ENSURE(ReadOnlyTx || !TxManager);
         TShardState shardState;
         shardState.State = ImmediateTx ? TShardState::EState::Executing : TShardState::EState::Preparing;
         shardState.DatashardState.ConstructInPlace();
@@ -1799,7 +1841,8 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
                     flags));
             }
 
-            NDataIntegrity::LogIntegrityTrails("DatashardTx", Request.UserTraceId, TxId, shardId, TlsActivationContext->AsActorContext());
+            NDataIntegrity::LogIntegrityTrails("DatashardTx", dataTransaction.GetKqpTransaction().GetLocks().ShortDebugString(), 
+                Request.UserTraceId, TxId, shardId, TlsActivationContext->AsActorContext());
 
             ResponseEv->Orbit.Fork(evData->Orbit);
             ev = std::move(evData);
@@ -1835,7 +1878,8 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
 
         auto traceId = ExecuterSpan.GetTraceId();
 
-        NDataIntegrity::LogIntegrityTrails("EvWriteTx", Request.UserTraceId, TxId, shardId, TlsActivationContext->AsActorContext());
+        NDataIntegrity::LogIntegrityTrails("EvWriteTx", evWriteTransaction->Record.GetLocks().ShortDebugString(), 
+            Request.UserTraceId, TxId, shardId, TlsActivationContext->AsActorContext());
 
         auto shardsToString = [](const auto& shards) {
             TStringBuilder builder;
@@ -1974,9 +2018,12 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
         for (ui32 txIdx = 0; txIdx < Request.Transactions.size(); ++txIdx) {
             auto& tx = Request.Transactions[txIdx];
             auto scheduledTaskCount = ScheduleByCost(tx, ResourcesSnapshot);
+            AFL_ENSURE(tx.Body->StagesSize() < (static_cast<ui64>(1) << PriorityTxShift));
             for (ui32 stageIdx = 0; stageIdx < tx.Body->StagesSize(); ++stageIdx) {
                 auto& stage = tx.Body->GetStages(stageIdx);
-                auto& stageInfo = TasksGraph.GetStageInfo(TStageId(txIdx, stageIdx));
+                const auto stageId = TStageId(txIdx, stageIdx);
+                auto& stageInfo = TasksGraph.GetStageInfo(stageId);
+                AFL_ENSURE(stageInfo.Id == stageId);
 
                 if (stageInfo.Meta.ShardKind == NSchemeCache::TSchemeCacheRequest::KindAsyncIndexTable) {
                     TMaybe<TString> error;
@@ -2279,6 +2326,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da
             switch (ev->GetTypeRewrite()) {
                 hFunc(NLongTxService::TEvLongTxService::TEvAcquireReadSnapshotResult, Handle);
                 hFunc(TEvKqp::TEvAbortExecution, HandleAbortExecution);
+                hFunc(TEvKqpBuffer::TEvError, Handle);
                 default:
                     UnexpectedEvent("WaitSnapshotState", ev->GetTypeRewrite());
             }
diff --git a/ydb/core/kqp/executer_actor/kqp_executer_impl.h b/ydb/core/kqp/executer_actor/kqp_executer_impl.h
index 0c498d0562fc..120c2fa4a11a 100644
--- a/ydb/core/kqp/executer_actor/kqp_executer_impl.h
+++ b/ydb/core/kqp/executer_actor/kqp_executer_impl.h
@@ -70,6 +70,7 @@ using EExecType = TEvKqpExecuter::TEvTxResponse::EExecutionType;
 
 const ui64 MaxTaskSize = 48_MB;
 constexpr ui64 PotentialUnsigned64OverflowLimit = (std::numeric_limits<ui64>::max() >> 1);
+constexpr ui64 PriorityTxShift = 32;
 
 std::pair<TString, TString> SerializeKqpTasksParametersForOlap(const TStageInfo& stageInfo, const TTask& task);
 
@@ -264,6 +265,9 @@ class TKqpExecuterBase : public TActor<TDerived> {
         for (auto& [shardId, nodeId] : ShardIdToNodeId) {
             ShardsOnNode[nodeId].push_back(shardId);
             ParticipantNodes.emplace(nodeId);
+            if (TxManager) {
+                TxManager->AddParticipantNode(nodeId);
+            }
         }
 
         if (IsDebugLogEnabled()) {
@@ -568,7 +572,6 @@ class TKqpExecuterBase : public TActor<TDerived> {
         }
 
         if (BufferActorId && Request.LocksOp == ELocksOp::Rollback) {
-            YQL_ENSURE(Request.Transactions.empty());
             static_cast<TDerived*>(this)->Finalize();
             return;
         }
@@ -762,15 +765,22 @@ class TKqpExecuterBase : public TActor<TDerived> {
     void HandleAbortExecution(TEvKqp::TEvAbortExecution::TPtr& ev) {
         auto& msg = ev->Get()->Record;
         NYql::TIssues issues = ev->Get()->GetIssues();
-        LOG_D("Got EvAbortExecution, status: " << NYql::NDqProto::StatusIds_StatusCode_Name(msg.GetStatusCode())
+        HandleAbortExecution(msg.GetStatusCode(), ev->Get()->GetIssues(), ev->Sender != Target);
+    }
+
+    void HandleAbortExecution(
+            NYql::NDqProto::StatusIds::StatusCode statusCode, 
+            const NYql::TIssues& issues,
+            const bool sessionSender) {
+        LOG_D("Got EvAbortExecution, status: " << NYql::NDqProto::StatusIds_StatusCode_Name(statusCode)
             << ", message: " << issues.ToOneLineString());
-        auto statusCode = NYql::NDq::DqStatusToYdbStatus(msg.GetStatusCode());
-        if (statusCode == Ydb::StatusIds::INTERNAL_ERROR) {
+        auto ydbStatusCode = NYql::NDq::DqStatusToYdbStatus(statusCode);
+        if (ydbStatusCode == Ydb::StatusIds::INTERNAL_ERROR) {
             InternalError(issues);
-        } else if (statusCode == Ydb::StatusIds::TIMEOUT) {
-            TimeoutError(ev->Sender, issues);
+        } else if (ydbStatusCode == Ydb::StatusIds::TIMEOUT) {
+            TimeoutError(sessionSender, issues);
         } else {
-            RuntimeError(NYql::NDq::DqStatusToYdbStatus(msg.GetStatusCode()), issues);
+            RuntimeError(NYql::NDq::DqStatusToYdbStatus(statusCode), issues);
         }
     }
 
@@ -964,7 +974,7 @@ class TKqpExecuterBase : public TActor<TDerived> {
             auto readSettings = ExtractReadSettings(op, stageInfo, HolderFactory(), TypeEnv());
             task.Meta.Reads.ConstructInPlace();
             task.Meta.Reads->emplace_back(std::move(readInfo));
-            task.Meta.ReadInfo.Reverse = readSettings.Reverse;
+            task.Meta.ReadInfo.SetSorting(readSettings.GetSorting());
             task.Meta.Type = TTaskMeta::TTaskType::Compute;
 
             FillSecureParamsFromStage(task.Meta.SecureParams, stage);
@@ -1019,6 +1029,8 @@ class TKqpExecuterBase : public TActor<TDerived> {
                 settings.SetLockMode(*TasksGraph.GetMeta().LockMode);
             }
 
+            settings.SetPriority((task.StageId.TxId << PriorityTxShift) + settings.GetPriority());
+
             output.SinkSettings.ConstructInPlace();
             output.SinkSettings->PackFrom(settings);
         } else {
@@ -1479,18 +1491,17 @@ class TKqpExecuterBase : public TActor<TDerived> {
         }
     }
 
-    void FillReadInfo(TTaskMeta& taskMeta, ui64 itemsLimit, bool reverse, bool sorted) const
+    void FillReadInfo(TTaskMeta& taskMeta, ui64 itemsLimit, const NYql::ERequestSorting sorting) const
     {
         if (taskMeta.Reads && !taskMeta.Reads.GetRef().empty()) {
             // Validate parameters
             YQL_ENSURE(taskMeta.ReadInfo.ItemsLimit == itemsLimit);
-            YQL_ENSURE(taskMeta.ReadInfo.Reverse == reverse);
+            YQL_ENSURE(taskMeta.ReadInfo.GetSorting() == sorting);
             return;
         }
 
         taskMeta.ReadInfo.ItemsLimit = itemsLimit;
-        taskMeta.ReadInfo.Reverse = reverse;
-        taskMeta.ReadInfo.Sorted = sorted;
+        taskMeta.ReadInfo.SetSorting(sorting);
         taskMeta.ReadInfo.ReadType = TTaskMeta::TReadInfo::EReadType::Rows;
     }
 
@@ -1564,7 +1575,7 @@ class TKqpExecuterBase : public TActor<TDerived> {
             readInfo.ShardId = shardId;
         }
 
-        FillReadInfo(meta, readSettings.ItemsLimit, readSettings.Reverse, readSettings.Sorted);
+        FillReadInfo(meta, readSettings.ItemsLimit, readSettings.GetSorting());
         if (op.GetTypeCase() == NKqpProto::TKqpPhyTableOperation::kReadOlapRange) {
             FillOlapReadInfo(meta, readSettings.ResultType, op.GetReadOlapRange());
         }
@@ -1698,7 +1709,7 @@ class TKqpExecuterBase : public TActor<TDerived> {
                 stageInfo.Meta.SkipNullKeys.assign(op.GetReadRange().GetSkipNullKeys().begin(),
                                                    op.GetReadRange().GetSkipNullKeys().end());
                 // not supported for scan queries
-                YQL_ENSURE(!readSettings.Reverse);
+                YQL_ENSURE(!readSettings.IsReverse());
             }
 
             for (auto&& i: partitions) {
@@ -1712,11 +1723,11 @@ class TKqpExecuterBase : public TActor<TDerived> {
                 }
             }
 
-            if (!AppData()->FeatureFlags.GetEnableSeparationComputeActorsFromRead() || (!isOlapScan && readSettings.Sorted)) {
+            if (!AppData()->FeatureFlags.GetEnableSeparationComputeActorsFromRead() || (!isOlapScan && readSettings.IsSorted())) {
                 for (auto&& pair : nodeShards) {
                     auto& shardsInfo = pair.second;
                     for (auto&& shardInfo : shardsInfo) {
-                        auto& task = AssignScanTaskToShard(stageInfo, shardInfo.ShardId, nodeTasks, assignedShardsCount, readSettings.Sorted, isOlapScan);
+                        auto& task = AssignScanTaskToShard(stageInfo, shardInfo.ShardId, nodeTasks, assignedShardsCount, readSettings.IsSorted(), isOlapScan);
                         MergeReadInfoToTaskMeta(task.Meta, shardInfo.ShardId, shardInfo.KeyReadRanges, readSettings,
                             columns, op, /*isPersistentScan*/ true);
                     }
@@ -1725,7 +1736,7 @@ class TKqpExecuterBase : public TActor<TDerived> {
                 for (const auto& pair : nodeTasks) {
                     for (const auto& taskIdx : pair.second) {
                         auto& task = TasksGraph.GetTask(taskIdx);
-                        task.Meta.SetEnableShardsSequentialScan(readSettings.Sorted);
+                        task.Meta.SetEnableShardsSequentialScan(readSettings.IsSorted());
                         PrepareScanMetaForUsage(task.Meta, keyTypes);
                         BuildSinks(stage, task);
                     }
@@ -1877,7 +1888,7 @@ class TKqpExecuterBase : public TActor<TDerived> {
         ReplyErrorAndDie(status, &issues);
     }
 
-    void TimeoutError(TActorId abortSender, NYql::TIssues issues) {
+    void TimeoutError(bool sessionSender, NYql::TIssues issues) {
         if (AlreadyReplied) {
             LOG_E("Timeout when we already replied - not good" << Endl << TBackTrace().PrintToString() << Endl);
             return;
@@ -1901,7 +1912,7 @@ class TKqpExecuterBase : public TActor<TDerived> {
         NYql::IssuesToMessage(issues, ResponseEv->Record.MutableResponse()->MutableIssues());
 
         // TEvAbortExecution can come from either ComputeActor or SessionActor (== Target).
-        if (abortSender != Target) {
+        if (!sessionSender) {
             auto abortEv = MakeHolder<TEvKqp::TEvAbortExecution>(status, issues);
             this->Send(Target, abortEv.Release());
         }
diff --git a/ydb/core/kqp/executer_actor/kqp_executer_stats.cpp b/ydb/core/kqp/executer_actor/kqp_executer_stats.cpp
index 360c39ffde3a..60dae26fb9df 100644
--- a/ydb/core/kqp/executer_actor/kqp_executer_stats.cpp
+++ b/ydb/core/kqp/executer_actor/kqp_executer_stats.cpp
@@ -836,7 +836,10 @@ void TQueryExecutionStats::AddComputeActorStats(ui32 /* nodeId */, NYql::NDqProt
         // TODO(ilezhankin): investigate - for some reason `task.FinishTimeMs` may be large (or small?)
         //      enough to result in an enormous duration - triggering the "long tasks" mode.
 
-        auto taskDuration = TDuration::MilliSeconds(task.GetFinishTimeMs() - task.GetStartTimeMs());
+        auto taskDuration = TDuration::MilliSeconds(
+            task.GetStartTimeMs() != 0 && task.GetFinishTimeMs() >= task.GetStartTimeMs()
+            ? task.GetFinishTimeMs() - task.GetStartTimeMs()
+            : 0);
         auto& longestTaskDuration = LongestTaskDurations[task.GetStageId()];
         if (taskDuration > Max(collectLongTaskStatsTimeout, longestTaskDuration)) {
             CollectStatsByLongTasks = true;
@@ -982,7 +985,10 @@ void TQueryExecutionStats::AddDatashardStats(NYql::NDqProto::TDqComputeActorStat
 
         // checking whether the task is long
 
-        auto taskDuration = TDuration::MilliSeconds(task.GetFinishTimeMs() - task.GetStartTimeMs());
+        auto taskDuration = TDuration::MilliSeconds(
+            task.GetStartTimeMs() != 0 && task.GetFinishTimeMs() >= task.GetStartTimeMs()
+            ? task.GetFinishTimeMs() - task.GetStartTimeMs()
+            : 0);
         auto& longestTaskDuration = LongestTaskDurations[task.GetStageId()];
         if (taskDuration > Max(collectLongTaskStatsTimeout, longestTaskDuration)) {
             CollectStatsByLongTasks = true;
@@ -1045,7 +1051,7 @@ void TQueryExecutionStats::AddBufferStats(NYql::NDqProto::TDqTaskStats&& taskSta
         tableAggr->SetWriteRows(tableAggr->GetWriteRows() + table.GetWriteRows());
         tableAggr->SetWriteBytes(tableAggr->GetWriteBytes() + table.GetWriteBytes());
         tableAggr->SetEraseRows(tableAggr->GetEraseRows() + table.GetEraseRows());
-        tableAggr->SetAffectedPartitions(table.GetAffectedPartitions());
+        tableAggr->SetAffectedPartitions(tableAggr->GetAffectedPartitions() + table.GetAffectedPartitions());
     }
 }
 
diff --git a/ydb/core/kqp/executer_actor/kqp_partition_helper.cpp b/ydb/core/kqp/executer_actor/kqp_partition_helper.cpp
index d7bb8faf2fc9..e0acc8b98b41 100644
--- a/ydb/core/kqp/executer_actor/kqp_partition_helper.cpp
+++ b/ydb/core/kqp/executer_actor/kqp_partition_helper.cpp
@@ -1017,19 +1017,28 @@ TPhysicalShardReadSettings ExtractReadSettings(const NKqpProto::TKqpPhyTableOper
     switch(operation.GetTypeCase()){
         case NKqpProto::TKqpPhyTableOperation::kReadRanges: {
             readSettings.ItemsLimit = ExtractItemsLimit(stageInfo, operation.GetReadRanges().GetItemsLimit(), holderFactory, typeEnv);
-            readSettings.Reverse = operation.GetReadRanges().GetReverse();
+            if (operation.GetReadRanges().GetReverse()) {
+                readSettings.SetSorting(ERequestSorting::DESC);
+            }
             break;
         }
 
         case NKqpProto::TKqpPhyTableOperation::kReadRange: {
             readSettings.ItemsLimit = ExtractItemsLimit(stageInfo, operation.GetReadRange().GetItemsLimit(), holderFactory, typeEnv);
-            readSettings.Reverse = operation.GetReadRange().GetReverse();
+            if (operation.GetReadRange().GetReverse()) {
+                readSettings.SetSorting(ERequestSorting::DESC);
+            }
             break;
         }
 
         case NKqpProto::TKqpPhyTableOperation::kReadOlapRange: {
-            readSettings.Sorted = operation.GetReadOlapRange().GetSorted();
-            readSettings.Reverse = operation.GetReadOlapRange().GetReverse();
+            if (operation.GetReadOlapRange().GetReverse()) {
+                readSettings.SetSorting(ERequestSorting::DESC);
+            } else if (operation.GetReadOlapRange().GetSorted()) {
+                readSettings.SetSorting(ERequestSorting::ASC);
+            } else {
+                readSettings.SetSorting(ERequestSorting::NONE);
+            }
             readSettings.ItemsLimit = ExtractItemsLimit(stageInfo, operation.GetReadOlapRange().GetItemsLimit(), holderFactory, typeEnv);
             NKikimrMiniKQL::TType minikqlProtoResultType;
             ConvertYdbTypeToMiniKQLType(operation.GetReadOlapRange().GetResultType(), minikqlProtoResultType);
diff --git a/ydb/core/kqp/executer_actor/kqp_partition_helper.h b/ydb/core/kqp/executer_actor/kqp_partition_helper.h
index c3d54b17faab..03a1679436e6 100644
--- a/ydb/core/kqp/executer_actor/kqp_partition_helper.h
+++ b/ydb/core/kqp/executer_actor/kqp_partition_helper.h
@@ -2,7 +2,7 @@
 
 #include "kqp_tasks_graph.h"
 
-
+#include <ydb/core/kqp/common/kqp_yql.h>
 #include <yql/essentials/minikql/computation/mkql_computation_node_holders.h>
 
 #include <util/generic/variant.h>
@@ -26,15 +26,12 @@ class TShardInfoWithId: public TShardInfo {
     ui64 ShardId;
     TShardInfoWithId(const ui64 shardId, TShardInfo&& base)
         : TShardInfo(std::move(base))
-        , ShardId(shardId)
-    {
+        , ShardId(shardId) {
 
     }
 };
 
-struct TPhysicalShardReadSettings {
-    bool Sorted = true;
-    bool Reverse = false;
+struct TPhysicalShardReadSettings: public NYql::TSortingOperator<NYql::ERequestSorting::ASC> {
     ui64 ItemsLimit = 0;
     NKikimr::NMiniKQL::TType* ResultType = nullptr;
 };
diff --git a/ydb/core/kqp/executer_actor/kqp_planner.cpp b/ydb/core/kqp/executer_actor/kqp_planner.cpp
index 592a57590add..5e862f5b8116 100644
--- a/ydb/core/kqp/executer_actor/kqp_planner.cpp
+++ b/ydb/core/kqp/executer_actor/kqp_planner.cpp
@@ -105,6 +105,7 @@ TKqpPlanner::TKqpPlanner(TKqpPlanner::TArgs&& args)
     , ArrayBufferMinFillPercentage(args.ArrayBufferMinFillPercentage)
     , VerboseMemoryLimitException(args.VerboseMemoryLimitException)
 {
+    Y_UNUSED(MkqlMemoryLimit);
     if (GUCSettings) {
         SerializedGUCSettings = GUCSettings->SerializeToString();
     }
diff --git a/ydb/core/kqp/executer_actor/kqp_tasks_graph.cpp b/ydb/core/kqp/executer_actor/kqp_tasks_graph.cpp
index 1824280f9adb..8dd771747072 100644
--- a/ydb/core/kqp/executer_actor/kqp_tasks_graph.cpp
+++ b/ydb/core/kqp/executer_actor/kqp_tasks_graph.cpp
@@ -859,7 +859,7 @@ void FillTaskMeta(const TStageInfo& stageInfo, const TTask& task, NYql::NDqProto
                     protoColumn->SetName(column.Name);
                 }
                 protoReadMeta->SetItemsLimit(task.Meta.ReadInfo.ItemsLimit);
-                protoReadMeta->SetReverse(task.Meta.ReadInfo.Reverse);
+                protoReadMeta->SetReverse(task.Meta.ReadInfo.IsReverse());
             }
         }
         if (task.Meta.Writes) {
@@ -930,7 +930,8 @@ void FillTaskMeta(const TStageInfo& stageInfo, const TTask& task, NYql::NDqProto
         YQL_ENSURE(!task.Meta.Writes);
 
         if (!task.Meta.Reads->empty()) {
-            protoTaskMeta.SetReverse(task.Meta.ReadInfo.Reverse);
+            protoTaskMeta.SetReverse(task.Meta.ReadInfo.IsReverse());
+            protoTaskMeta.SetOptionalSorting((ui32)task.Meta.ReadInfo.GetSorting());
             protoTaskMeta.SetItemsLimit(task.Meta.ReadInfo.ItemsLimit);
             if (task.Meta.HasEnableShardsSequentialScan()) {
                 protoTaskMeta.SetEnableShardsSequentialScan(task.Meta.GetEnableShardsSequentialScanUnsafe());
diff --git a/ydb/core/kqp/executer_actor/kqp_tasks_graph.h b/ydb/core/kqp/executer_actor/kqp_tasks_graph.h
index 87be6dfae907..e74ff181b706 100644
--- a/ydb/core/kqp/executer_actor/kqp_tasks_graph.h
+++ b/ydb/core/kqp/executer_actor/kqp_tasks_graph.h
@@ -2,6 +2,7 @@
 
 #include <ydb/core/kqp/common/kqp_resolve.h>
 #include <ydb/core/kqp/common/kqp_user_request_context.h>
+#include <ydb/core/kqp/common/kqp_yql.h>
 #include <ydb/core/kqp/gateway/kqp_gateway.h>
 #include <ydb/core/scheme/scheme_tabledefs.h>
 #include <ydb/core/tx/scheme_cache/scheme_cache.h>
@@ -222,14 +223,13 @@ struct TTaskMeta {
         std::set<TString> ParameterNames;
     };
 
-    struct TReadInfo {
+    struct TReadInfo: public NYql::TSortingOperator<NYql::ERequestSorting::NONE> {
+    public:
         enum class EReadType {
             Rows,
             Blocks
         };
         ui64 ItemsLimit = 0;
-        bool Reverse = false;
-        bool Sorted = false;
         EReadType ReadType = EReadType::Rows;
         TKqpOlapProgram OlapProgram;
         TVector<NScheme::TTypeInfo> ResultColumnsTypes;
diff --git a/ydb/core/kqp/expr_nodes/kqp_expr_nodes.json b/ydb/core/kqp/expr_nodes/kqp_expr_nodes.json
index 3f1efc86bad2..9f2b033f353b 100644
--- a/ydb/core/kqp/expr_nodes/kqp_expr_nodes.json
+++ b/ydb/core/kqp/expr_nodes/kqp_expr_nodes.json
@@ -679,7 +679,8 @@
             "Children": [
                 {"Index": 0, "Name": "Type", "Type": "TExprBase"},
                 {"Index": 1, "Name": "Columns", "Type": "TCoAtomList"},
-                {"Index": 2, "Name": "Lambda", "Type": "TCoLambda"}
+                {"Index": 2, "Name": "Parameters", "Type": "TExprList"},
+                {"Index": 3, "Name": "Lambda", "Type": "TCoLambda"}
             ]
         },
         {
diff --git a/ydb/core/kqp/gateway/kqp_ic_gateway.cpp b/ydb/core/kqp/gateway/kqp_ic_gateway.cpp
index 24e93ab246d9..e785ddbcc1d8 100644
--- a/ydb/core/kqp/gateway/kqp_ic_gateway.cpp
+++ b/ydb/core/kqp/gateway/kqp_ic_gateway.cpp
@@ -722,9 +722,6 @@ namespace {
 }
 
 class TKikimrIcGateway : public IKqpGateway {
-private:
-    using TNavigate = NSchemeCache::TSchemeCacheNavigate;
-
 public:
     TKikimrIcGateway(const TString& cluster, NKikimrKqp::EQueryType queryType, const TString& database, const TString& databaseId, std::shared_ptr<IKqpTableMetadataLoader>&& metadataLoader,
         TActorSystem* actorSystem, ui32 nodeId, TKqpRequestCounters::TPtr counters, const NKikimrConfig::TQueryServiceConfig& queryServiceConfig)
@@ -914,6 +911,48 @@ class TKikimrIcGateway : public IKqpGateway {
         return tablePromise.GetFuture();
     }
 
+    TFuture<TGenericResult> AlterDatabase(const TString& cluster, const NYql::TAlterDatabaseSettings& settings) override {
+        using TRequest = TEvTxUserProxy::TEvProposeTransaction;
+
+        try {
+            if (!CheckCluster(cluster)) {
+                return InvalidCluster<TGenericResult>(cluster);
+            }
+
+            auto alterDatabasePromise = NewPromise<TGenericResult>();
+
+            auto ev = MakeHolder<TRequest>();
+
+            ev->Record.SetDatabaseName(Database);
+            if (UserToken) {
+                ev->Record.SetUserToken(UserToken->GetSerializedToken());
+            }
+
+            const auto& [dirname, basename] = NSchemeHelpers::SplitPathByDirAndBaseNames(settings.DatabasePath);
+
+            NKikimrSchemeOp::TModifyScheme* modifyScheme = ev->Record.MutableTransaction()->MutableModifyScheme();
+            modifyScheme->SetOperationType(NKikimrSchemeOp::ESchemeOpModifyACL);
+            modifyScheme->SetWorkingDir(dirname);
+            modifyScheme->MutableModifyACL()->SetNewOwner(settings.Owner.value());
+            modifyScheme->MutableModifyACL()->SetName(basename);
+
+            auto condition = modifyScheme->AddApplyIf();
+            condition->AddPathTypes(NKikimrSchemeOp::EPathType::EPathTypeSubDomain);
+            condition->AddPathTypes(NKikimrSchemeOp::EPathType::EPathTypeExtSubDomain);
+
+            SendSchemeRequest(ev.Release()).Apply(
+                [alterDatabasePromise](const TFuture<TGenericResult>& future) mutable {
+                    alterDatabasePromise.SetValue(future.GetValue());
+                }
+            );
+
+            return alterDatabasePromise.GetFuture();
+        }
+        catch (yexception& e) {
+            return MakeFuture(ResultFromException<TGenericResult>(e));
+        }
+    }
+
     TFuture<TGenericResult> CreateColumnTable(NYql::TKikimrTableMetadataPtr metadata,
             bool createDir, bool existingOk) override {
         Y_UNUSED(metadata);
@@ -1437,8 +1476,8 @@ class TKikimrIcGateway : public IKqpGateway {
 
             SendSchemeRequest(ev.Release()).Apply(
                 [alterUserPromise](const TFuture<TGenericResult>& future) mutable {
-                alterUserPromise.SetValue(future.GetValue());
-            }
+                    alterUserPromise.SetValue(future.GetValue());
+                }
             );
 
             return alterUserPromise.GetFuture();
diff --git a/ydb/core/kqp/host/kqp_gateway_proxy.cpp b/ydb/core/kqp/host/kqp_gateway_proxy.cpp
index 0e614df185fc..d1f52070882e 100644
--- a/ydb/core/kqp/host/kqp_gateway_proxy.cpp
+++ b/ydb/core/kqp/host/kqp_gateway_proxy.cpp
@@ -439,6 +439,18 @@ bool FillColumnTableSchema(NKikimrSchemeOp::TColumnTableSchema& schema, const T&
         auto columnIt = metadata.Columns.find(name);
         Y_ENSURE(columnIt != metadata.Columns.end());
 
+        if (columnIt->second.IsDefaultFromLiteral()) {
+            code = Ydb::StatusIds::BAD_REQUEST;
+            error = TStringBuilder() << "Default values are not supported in column tables";
+            return false;
+        }
+
+        if (columnIt->second.IsDefaultFromSequence()) {
+            code = Ydb::StatusIds::BAD_REQUEST;
+            error = TStringBuilder() << "Default sequences are not supported in column tables";
+            return false;
+        }
+
         NKikimrSchemeOp::TOlapColumnDescription& columnDesc = *schema.AddColumns();
         columnDesc.SetName(columnIt->second.Name);
         columnDesc.SetType(columnIt->second.Type);
@@ -624,6 +636,38 @@ class TKqpGatewayProxy : public IKikimrGateway {
         return Gateway->LoadTableMetadata(cluster, table, settings);
     }
 
+    TFuture<TGenericResult> AlterDatabase(const TString& cluster, const TAlterDatabaseSettings& settings) override {
+        CHECK_PREPARED_DDL(AlterDatabase);
+
+        if (IsPrepare()) {
+            auto alterDatabasePromise = NewPromise<TGenericResult>();
+
+            const auto& [dirname, basename] = NSchemeHelpers::SplitPathByDirAndBaseNames(settings.DatabasePath);
+
+            NKikimrSchemeOp::TModifyScheme schemeTx;
+            schemeTx.SetOperationType(NKikimrSchemeOp::ESchemeOpModifyACL);
+            schemeTx.SetWorkingDir(dirname);
+            schemeTx.MutableModifyACL()->SetNewOwner(settings.Owner.value());
+            schemeTx.MutableModifyACL()->SetName(basename);
+
+            auto condition = schemeTx.AddApplyIf();
+            condition->AddPathTypes(NKikimrSchemeOp::EPathType::EPathTypeSubDomain);
+            condition->AddPathTypes(NKikimrSchemeOp::EPathType::EPathTypeExtSubDomain);
+
+            auto& phyQuery = *SessionCtx->Query().PreparingQuery->MutablePhysicalQuery();
+            auto& phyTx = *phyQuery.AddTransactions();
+            phyTx.SetType(NKqpProto::TKqpPhyTx::TYPE_SCHEME);
+
+            phyTx.MutableSchemeOperation()->MutableModifyPermissions()->Swap(&schemeTx);
+            TGenericResult result;
+            result.SetSuccess();
+            alterDatabasePromise.SetValue(result);
+            return alterDatabasePromise.GetFuture();
+        } else {
+            return Gateway->AlterDatabase(cluster, settings);
+        }
+    }
+
     TFuture<TGenericResult> CreateTable(TKikimrTableMetadataPtr metadata, bool createDir, bool existingOk, bool replaceIfExists) override {
         Y_UNUSED(replaceIfExists);
         CHECK_PREPARED_DDL(CreateTable);
diff --git a/ydb/core/kqp/host/kqp_runner.cpp b/ydb/core/kqp/host/kqp_runner.cpp
index 81ea7ec9df6c..2c11d6ad2a87 100644
--- a/ydb/core/kqp/host/kqp_runner.cpp
+++ b/ydb/core/kqp/host/kqp_runner.cpp
@@ -23,6 +23,7 @@
 #include <yql/essentials/core/yql_opt_proposed_by_data.h>
 
 #include <ydb/library/yql/providers/dq/common/yql_dq_settings.h>
+#include <ydb/library/yql/providers/dq/opt/dqs_opt.h>
 
 #include <util/generic/is_in.h>
 
@@ -278,7 +279,7 @@ class TKqpRunner : public IKqpRunner {
         auto preparedExplainTransformer = CreateKqpExplainPreparedTransformer(
             Gateway, Cluster, TransformCtx, &funcRegistry, *typesCtx, OptimizeCtx);
 
-        auto physicalOptimizeTransformer = CreateKqpQueryBlocksTransformer(TTransformationPipeline(typesCtx)
+        auto physicalOptimizePipeline = TTransformationPipeline(typesCtx)
             .AddServiceTransformers()
             .Add(Log("PhysicalOptimize"), "LogPhysicalOptimize")
             .AddPreTypeAnnotation()
@@ -294,7 +295,13 @@ class TKqpRunner : public IKqpRunner {
             .Add(CreateKqpStatisticsTransformer(OptimizeCtx, *typesCtx, Config, Pctx), "Statistics")
             .Add(CreateKqpLogOptTransformer(OptimizeCtx, *typesCtx, Config), "LogicalOptimize")
             .Add(CreateLogicalDataProposalsInspector(*typesCtx), "ProvidersLogicalOptimize")
-            .Add(CreateKqpPhyOptTransformer(OptimizeCtx, *typesCtx, Config), "KqpPhysicalOptimize")
+            .Add(CreateKqpPhyOptTransformer(OptimizeCtx, *typesCtx, Config), "KqpPhysicalOptimize");
+
+        if (sessionCtx->Config().UseBlockReader.Get().GetOrElse(false)) {
+            physicalOptimizePipeline.Add(NDqs::CreateDqsRewritePhyBlockReadOnDqIntegrationTransformer(*typesCtx), "ReplaceWideReadsWithBlock");
+        }
+
+        auto physicalOptimizeTransformer = CreateKqpQueryBlocksTransformer(physicalOptimizePipeline
             .Add(CreatePhysicalDataProposalsInspector(*typesCtx), "ProvidersPhysicalOptimize")
             .Add(CreateKqpFinalizingOptTransformer(OptimizeCtx), "FinalizingOptimize")
             .Add(CreateKqpQueryPhasesTransformer(), "QueryPhases")
diff --git a/ydb/core/kqp/host/kqp_type_ann.cpp b/ydb/core/kqp/host/kqp_type_ann.cpp
index d1ea8fa1c562..2c4aed2bcc73 100644
--- a/ydb/core/kqp/host/kqp_type_ann.cpp
+++ b/ydb/core/kqp/host/kqp_type_ann.cpp
@@ -1077,7 +1077,7 @@ TStatus AnnotateOlapFilter(const TExprNode::TPtr& node, TExprContext& ctx) {
 }
 
 TStatus AnnotateOlapApply(const TExprNode::TPtr& node, TExprContext& ctx) {
-    if (!EnsureArgsCount(*node, 3U, ctx)) {
+    if (!EnsureArgsCount(*node, 4U, ctx)) {
         return TStatus::Error;
     }
 
@@ -1097,7 +1097,8 @@ TStatus AnnotateOlapApply(const TExprNode::TPtr& node, TExprContext& ctx) {
     }
 
     const auto structType = argsType->Cast<TStructExprType>();
-    TTypeAnnotationNode::TListType argsTypes(columns->ChildrenSize());
+    std::vector<const NYql::TTypeAnnotationNode*> argsTypes(columns->ChildrenSize());
+
     for (auto i = 0U; i < argsTypes.size(); ++i) {
         if (const auto argType = structType->FindItemType(columns->Child(i)->Content()))
             argsTypes[i] = argType;
@@ -1109,6 +1110,22 @@ TStatus AnnotateOlapApply(const TExprNode::TPtr& node, TExprContext& ctx) {
         }
     }
 
+    TExprList parameters = TExprList(node->Child(TKqpOlapApply::idx_Parameters));
+
+    for(auto expr: parameters) {
+        if (!EnsureArgsCount(*expr.Ptr(), 2U, ctx)) {
+            return TStatus::Error;
+        }
+
+        TCoParameter param = TMaybeNode<TCoParameter>(expr.Ptr()).Cast();
+        const auto& paramType = expr.Ptr()->Child(TCoParameter::idx_Type);
+        if (!EnsureType(*paramType, ctx)) {
+            return TStatus::Error;
+        }
+
+        argsTypes.push_back(paramType->GetTypeAnn()->Cast<TTypeExprType>()->GetType());
+    }
+
     if (!EnsureLambda(node->Tail(), ctx)) {
         return TStatus::Error;
     }
diff --git a/ydb/core/kqp/node_service/kqp_node_service.cpp b/ydb/core/kqp/node_service/kqp_node_service.cpp
index eacc6bdb39d6..77748787004f 100644
--- a/ydb/core/kqp/node_service/kqp_node_service.cpp
+++ b/ydb/core/kqp/node_service/kqp_node_service.cpp
@@ -457,7 +457,6 @@ class TKqpNodeService : public TActorBootstrapped<TKqpNodeService> {
 
         ptr->InFlightMemoryLimitPerActorBytes = settings.GetInFlightMemoryLimitPerActorBytes();
         ptr->MemoryLimitPerMessageBytes = settings.GetMemoryLimitPerMessageBytes();
-        ptr->MaxBatchesPerMessage = settings.GetMaxBatchesPerMessage();
 
         ptr->StartRetryDelay = TDuration::MilliSeconds(settings.GetStartRetryDelayMs());
         ptr->MaxRetryDelay = TDuration::MilliSeconds(settings.GetMaxRetryDelayMs());
diff --git a/ydb/core/kqp/opt/kqp_opt_kql.cpp b/ydb/core/kqp/opt/kqp_opt_kql.cpp
index 1eae92aabd71..be7616830f5a 100644
--- a/ydb/core/kqp/opt/kqp_opt_kql.cpp
+++ b/ydb/core/kqp/opt/kqp_opt_kql.cpp
@@ -217,11 +217,10 @@ TCoAtomList BuildUpsertInputColumns(const TCoAtomList& inputColumns,
 }
 
 std::pair<TExprBase, TCoAtomList> BuildWriteInput(const TKiWriteTable& write, const TKikimrTableDescription& table,
-    const TCoAtomList& inputColumns, const TCoAtomList& autoIncrement, const bool isSink,
+    const TCoAtomList& inputColumns, const TCoAtomList& autoIncrement, const bool /*isSink*/,
     TPositionHandle pos, TExprContext& ctx)
 {
     auto input = write.Input();
-    const bool isWriteReplace = (GetTableOp(write) == TYdbOperation::Replace) && !isSink;
 
     TCoAtomList inputCols = BuildUpsertInputColumns(inputColumns, autoIncrement, pos, ctx);
 
@@ -229,7 +228,9 @@ std::pair<TExprBase, TCoAtomList> BuildWriteInput(const TKiWriteTable& write, co
         input = BuildKqlSequencer(input, table, inputCols, autoIncrement, pos, ctx);
     }
 
+    const bool isWriteReplace = (GetTableOp(write) == TYdbOperation::Replace);
     if (isWriteReplace) {
+        // TODO: don't need it for sinks (can be disabled when secondary indexes are supported inside write actor)
         std::tie(input, inputCols) = CreateRowsToReplace(input, inputCols, table, write.Pos(), ctx);
     }
 
diff --git a/ydb/core/kqp/opt/kqp_query_plan.cpp b/ydb/core/kqp/opt/kqp_query_plan.cpp
index 95cf7bdf1734..c0c859ef0413 100644
--- a/ydb/core/kqp/opt/kqp_query_plan.cpp
+++ b/ydb/core/kqp/opt/kqp_query_plan.cpp
@@ -65,13 +65,12 @@ std::string RemoveForbiddenChars(std::string s) {
     return NYql::IsUtf8(s)? s: "Non-UTF8 string";
 }
 
-struct TTableRead {
+struct TTableRead: public NYql::TSortingOperator<NYql::ERequestSorting::ASC> {
     EPlanTableReadType Type = EPlanTableReadType::Unspecified;
     TVector<TString> LookupBy;
     TVector<TString> ScanBy;
     TVector<TString> Columns;
     TMaybe<TString> Limit;
-    bool Reverse = false;
 };
 
 struct TTableWrite {
@@ -795,7 +794,7 @@ class TxPlanSerializer {
         AddOperator(stagePlanNode, "Source", op);
     }
 
-    void Visit(const TDqSink& sink, TQueryPlanNode& stagePlanNode) {
+    void Visit(const TDqSink& sink, const TDqStageBase& stage, TQueryPlanNode& stagePlanNode) {
         // Federated providers
         TOperator op;
         TCoDataSink dataSink = sink.DataSink().Cast<TCoDataSink>();
@@ -811,7 +810,50 @@ class TxPlanSerializer {
 
         // Common settings that can be overwritten by provider
         op.Properties["SinkType"] = dataSinkCategory;
-        if (auto cluster = TryGetCluster(dataSink)) {
+        if (dataSinkCategory == NYql::KqpTableSinkName) {
+            auto settings = sink.Settings().Cast<TKqpTableSinkSettings>();
+
+            TTableWrite writeInfo;
+            if (settings.Mode().StringValue() == "replace") {
+                op.Properties["Name"] = "Replace";
+                writeInfo.Type = EPlanTableWriteType::MultiReplace;
+            } else if (settings.Mode().StringValue() == "upsert" || settings.Mode().StringValue().empty()) {
+                op.Properties["Name"] = "Upsert";
+                writeInfo.Type = EPlanTableWriteType::MultiUpsert;
+            } else if (settings.Mode().StringValue() == "insert") {
+                op.Properties["Name"] = "Insert";
+                writeInfo.Type = EPlanTableWriteType::MultiInsert;
+            } else if (settings.Mode().StringValue() == "delete") {
+                op.Properties["Name"] = "Delete";
+                writeInfo.Type = EPlanTableWriteType::MultiErase;
+            } else if (settings.Mode().StringValue() == "update") {
+                op.Properties["Name"] = "Update";
+                writeInfo.Type = EPlanTableWriteType::MultiUpdate;
+            } else {
+                YQL_ENSURE(false, "Unsupported sink mode");
+            }
+
+            const auto tablePath = settings.Table().Path().StringValue();
+            const auto& tableData = SerializerCtx.TablesData->GetTable(SerializerCtx.Cluster, tablePath);
+            op.Properties["Table"] = tableData.RelativePath ? *tableData.RelativePath : tablePath;
+            op.Properties["Path"] = tablePath;
+
+            if (writeInfo.Type != EPlanTableWriteType::MultiErase) {
+                const auto& tupleType = stage.Ref().GetTypeAnn()->Cast<TTupleExprType>();
+                YQL_ENSURE(tupleType);
+                YQL_ENSURE(tupleType->GetSize() == 1);
+                const auto& listType = tupleType->GetItems()[0]->Cast<TListExprType>();
+                YQL_ENSURE(listType);
+                const auto& structType = listType->GetItemType()->Cast<TStructExprType>();
+                YQL_ENSURE(structType);
+                for (const auto& item : structType->GetItems()) {
+                    writeInfo.Columns.push_back(TString(item->GetName()));
+                }
+            }
+
+            SerializerCtx.Tables[tablePath].Writes.push_back(writeInfo);
+            stagePlanNode.NodeInfo["Tables"].AppendValue(op.Properties["Table"]);
+        } else if (auto cluster = TryGetCluster(dataSink)) {
             TString dataSource = RemovePathPrefix(std::move(*cluster));
             op.Properties["ExternalDataSource"] = dataSource;
             op.Properties["Name"] = TStringBuilder() << "Write " << dataSource;
@@ -896,7 +938,7 @@ class TxPlanSerializer {
             if (auto outputs = expr.Cast<TDqStageBase>().Outputs()) {
                 for (auto output : outputs.Cast()) {
                     if (auto sink = output.Maybe<TDqSink>()) {
-                        Visit(sink.Cast(), stagePlanNode);
+                        Visit(sink.Cast(), expr.Cast<TDqStageBase>(), stagePlanNode);
                     }
                 }
             }
@@ -1871,9 +1913,11 @@ class TxPlanSerializer {
             readInfo.Limit = limit;
             op.Properties["ReadLimit"] = limit;
         }
-        if (settings.Reverse) {
-            readInfo.Reverse = true;
+        readInfo.SetSorting(settings.GetSorting());
+        if (settings.GetSorting() == ERequestSorting::DESC) {
             op.Properties["Reverse"] = true;
+        } else if (settings.GetSorting() == ERequestSorting::ASC) {
+            op.Properties["Reverse"] = false;
         }
 
         if (settings.SequentialInFlight) {
@@ -1963,7 +2007,7 @@ void WriteCommonTablesInfo(NJsonWriter::TBuf& writer, TMap<TString, TTableInfo>&
                 if (read.Limit) {
                     writer.WriteKey("limit").WriteString(*read.Limit);
                 }
-                if (read.Reverse) {
+                if (read.IsReverse()) {
                     writer.WriteKey("reverse").WriteBool(true);
                 }
 
diff --git a/ydb/core/kqp/opt/kqp_query_plan.h b/ydb/core/kqp/opt/kqp_query_plan.h
index 6facebe4574b..d1ac3f73020d 100644
--- a/ydb/core/kqp/opt/kqp_query_plan.h
+++ b/ydb/core/kqp/opt/kqp_query_plan.h
@@ -27,6 +27,9 @@ enum class EPlanTableWriteType {
     MultiUpsert,
     Erase,
     MultiErase,
+    MultiReplace,
+    MultiInsert,
+    MultiUpdate,
 };
 
 /*
diff --git a/ydb/core/kqp/opt/logical/kqp_opt_log_extract.cpp b/ydb/core/kqp/opt/logical/kqp_opt_log_extract.cpp
index 2507d3b31c86..f9c03d710d1f 100644
--- a/ydb/core/kqp/opt/logical/kqp_opt_log_extract.cpp
+++ b/ydb/core/kqp/opt/logical/kqp_opt_log_extract.cpp
@@ -157,6 +157,10 @@ TExprBase KqpApplyExtractMembersToReadOlapTable(TExprBase node, TExprContext& ct
 
     auto read = node.Cast<TKqpReadOlapTableRangesBase>();
 
+    if (read.Columns().Size() == 1) {
+        return node;
+    }
+
     auto usedColumns = GetUsedColumns(read, read.Columns(), parentsMap, allowMultiUsage, ctx);
     if (!usedColumns) {
         return node;
diff --git a/ydb/core/kqp/opt/logical/kqp_opt_log_indexes.cpp b/ydb/core/kqp/opt/logical/kqp_opt_log_indexes.cpp
index 258012939b0a..bcc70a1d961a 100644
--- a/ydb/core/kqp/opt/logical/kqp_opt_log_indexes.cpp
+++ b/ydb/core/kqp/opt/logical/kqp_opt_log_indexes.cpp
@@ -150,7 +150,7 @@ bool CanUseVectorIndex(const TIndexDescription& indexDesc, const TExprBase& lamb
     // TODO(mbkkt) We need to account top.Count(), but not clear what to if it's value is runtime?
     auto checkMember = [&] (const TExprBase& expr) {
         auto member = expr.Maybe<TCoMember>();
-        return member && member.Cast().Name().Value() == indexDesc.KeyColumns[0];
+        return member && member.Cast().Name().Value() == indexDesc.KeyColumns.back();
     };
     auto checkUdf = [&] (const TExprBase& expr, bool checkMembers) {
         auto apply = expr.Maybe<TCoApply>();
@@ -452,7 +452,7 @@ TExprBase DoRewriteTopSortOverKMeansTree(
             auto apply = newLambda.Body().Cast<TCoApply>();
             for (auto arg : apply.Args()) {
                 auto oldMember = arg.Maybe<TCoMember>();
-                if (oldMember && oldMember.Cast().Name().Value() == indexDesc.KeyColumns[0]) {
+                if (oldMember && oldMember.Cast().Name().Value() == indexDesc.KeyColumns.back()) {
                     auto newMember = Build<TCoMember>(ctx, pos)
                         .Name().Build(NTableIndex::NTableVectorKmeansTreeIndex::CentroidColumn)
                         .Struct(oldMember.Cast().Struct())
diff --git a/ydb/core/kqp/opt/physical/kqp_opt_phy.cpp b/ydb/core/kqp/opt/physical/kqp_opt_phy.cpp
index e52c87424631..b760a26ae8ea 100644
--- a/ydb/core/kqp/opt/physical/kqp_opt_phy.cpp
+++ b/ydb/core/kqp/opt/physical/kqp_opt_phy.cpp
@@ -124,7 +124,10 @@ class TKqpPhysicalOptTransformer : public TOptimizeTransformerBase {
         AddHandler(1, &TCoTake::Match, HNDL(PropagatePrecomuteTake<true>));
         AddHandler(1, &TCoFlatMap::Match, HNDL(PropagatePrecomuteFlatmap<true>));
         AddHandler(1, &TKqpWriteConstraint::Match, HNDL(BuildWriteConstraint<true>));
+        AddHandler(1, &TKqpWriteConstraint::Match, HNDL(BuildWriteConstraint<true>));
+        AddHandler(1, &TKqpReadOlapTableRanges::Match, HNDL(AddColumnForEmptyColumnsOlapRead));
 
+        
         AddHandler(2, &TDqStage::Match, HNDL(RewriteKqpReadTable));
         AddHandler(2, &TDqStage::Match, HNDL(RewriteKqpLookupTable));
         AddHandler(2, &TKqlUpsertRows::Match, HNDL(RewriteReturningUpsert));
@@ -525,6 +528,13 @@ class TKqpPhysicalOptTransformer : public TOptimizeTransformerBase {
         return output;
     }
 
+    TMaybeNode<TExprBase> AddColumnForEmptyColumnsOlapRead(TExprBase node, TExprContext& ctx)
+    {
+        TExprBase output = KqpAddColumnForEmptyColumnsOlapRead(node, ctx, KqpCtx);
+        DumpAppliedRule("AddColumnForEmptyColumnsOlapRead", node.Ptr(), output.Ptr(), ctx);
+        return output;
+    }
+
     TMaybeNode<TExprBase> DropUnordered(TExprBase node, TExprContext& ctx) {
         TExprBase output = node;
         if (node.Maybe<TCoUnorderedBase>().Input().Maybe<TDqCnUnionAll>()) {
diff --git a/ydb/core/kqp/opt/physical/kqp_opt_phy_limit.cpp b/ydb/core/kqp/opt/physical/kqp_opt_phy_limit.cpp
index f89cf425ad02..69ed31b6004a 100644
--- a/ydb/core/kqp/opt/physical/kqp_opt_phy_limit.cpp
+++ b/ydb/core/kqp/opt/physical/kqp_opt_phy_limit.cpp
@@ -122,7 +122,9 @@ TExprBase KqpApplyLimitToOlapReadTable(TExprBase node, TExprContext& ctx, const
         return node; // already set
     }
     if (direction == ESortDirection::Reverse) {
-        settings.SetReverse();
+        settings.SetSorting(ERequestSorting::DESC);
+    } else if (direction == ESortDirection::Forward) {
+        settings.SetSorting(ERequestSorting::ASC);
     }
 
     auto keySelector = topSort.KeySelectorLambda();
diff --git a/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_agg.cpp b/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_agg.cpp
index 592f77fb6e5d..c061e0ac579f 100644
--- a/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_agg.cpp
+++ b/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_agg.cpp
@@ -245,11 +245,6 @@ TExprBase KqpPushDownOlapGroupByKeysImpl(TExprBase node, TExprContext& ctx, bool
 }
 
 TExprBase KqpPushDownOlapGroupByKeys(TExprBase node, TExprContext& ctx, const TKqpOptimizeContext& kqpCtx) {
-    if (NKikimr::NSsa::RuntimeVersion < 2U) {
-        // We introduced aggregate pushdown in v2 of SSA program
-        return node;
-    }
-
     if (!kqpCtx.Config->HasOptEnableOlapPushdown() || !kqpCtx.Config->HasOptEnableOlapProvideComputeSharding()) {
         return node;
     }
@@ -271,11 +266,6 @@ TExprBase KqpPushDownOlapGroupByKeys(TExprBase node, TExprContext& ctx, const TK
 
 TExprBase KqpPushOlapAggregate(TExprBase node, TExprContext& ctx, const TKqpOptimizeContext& kqpCtx)
 {
-    if (NKikimr::NSsa::RuntimeVersion < 2U) {
-        // We introduced aggregate pushdown in v2 of SSA program
-        return node;
-    }
-
     if (!kqpCtx.Config->HasOptEnableOlapPushdown()) {
         return node;
     }
@@ -373,11 +363,6 @@ TExprBase KqpPushOlapAggregate(TExprBase node, TExprContext& ctx, const TKqpOpti
 
 TExprBase KqpPushOlapLength(TExprBase node, TExprContext& ctx, const TKqpOptimizeContext& kqpCtx)
 {
-    if (NKikimr::NSsa::RuntimeVersion < 2U) {
-        // We introduced aggregate pushdown in v2 of SSA program
-        return node;
-    }
-
     if (!kqpCtx.Config->HasOptEnableOlapPushdown()) {
         return node;
     }
diff --git a/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_filter.cpp b/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_filter.cpp
index 13ea4fb1c257..542137581e62 100644
--- a/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_filter.cpp
+++ b/ydb/core/kqp/opt/physical/kqp_opt_phy_olap_filter.cpp
@@ -24,6 +24,32 @@ static const std::unordered_set<std::string> SecondLevelFilters = {
     "ends_with"
 };
 
+static TMaybeNode<TExprBase> CombinePredicatesWithAnd(const TVector<TExprBase>& conjuncts, TExprContext& ctx, TPositionHandle pos, bool useOlapAnd, bool trueForEmpty) {
+    if (conjuncts.empty()) {
+        return trueForEmpty ? TMaybeNode<TExprBase>{MakeBool<true>(pos, ctx)} : TMaybeNode<TExprBase>{};
+    } else if (conjuncts.size() == 1) {
+        return conjuncts[0];
+    } else {
+        if (useOlapAnd) {
+            return Build<TKqpOlapAnd>(ctx, pos)
+                .Add(conjuncts)
+            .Done();
+        } else {
+            return Build<TCoAnd>(ctx, pos)
+                .Add(conjuncts)
+            .Done();
+        }
+    }
+}
+
+static TMaybeNode<TExprBase> CombinePredicatesWithAnd(const TVector<TOLAPPredicateNode>& conjuncts, TExprContext& ctx, TPositionHandle pos, bool useOlapAnd, bool trueForEmpty) {
+    TVector<TExprBase> exprs;
+    for(const auto& c: conjuncts) {
+        exprs.emplace_back(c.ExprNode);
+    }
+    return CombinePredicatesWithAnd(exprs, ctx, pos, useOlapAnd, trueForEmpty);
+}
+
 struct TFilterOpsLevels {
     TFilterOpsLevels(const TMaybeNode<TExprBase>& firstLevel, const TMaybeNode<TExprBase>& secondLevel)
         : FirstLevelOps(firstLevel)
@@ -69,6 +95,23 @@ struct TFilterOpsLevels {
     }
 
 
+    static TFilterOpsLevels Merge(TVector<TFilterOpsLevels> predicates, TExprContext& ctx, TPositionHandle pos) {
+        TVector<TExprBase> predicatesFirstLevel;
+        TVector<TExprBase> predicatesSecondLevel;
+        for (const auto& p: predicates) {
+            if (p.FirstLevelOps.IsValid()) {
+                predicatesFirstLevel.emplace_back(p.FirstLevelOps.Cast());
+            }
+            if (p.SecondLevelOps.IsValid()) {
+                predicatesSecondLevel.emplace_back(p.SecondLevelOps.Cast());
+            }
+        }
+        return {
+            CombinePredicatesWithAnd(predicatesFirstLevel, ctx, pos, true, false),
+            CombinePredicatesWithAnd(predicatesSecondLevel, ctx, pos, true, false),
+        };
+    }
+
     TMaybeNode<TExprBase> FirstLevelOps;
     TMaybeNode<TExprBase> SecondLevelOps;
 };
@@ -139,7 +182,7 @@ std::vector<std::pair<TExprBase, TExprBase>> ExtractComparisonParameters(const T
 TMaybeNode<TExprBase> ComparisonPushdown(const std::vector<std::pair<TExprBase, TExprBase>>& parameters, const TCoCompare& predicate, TExprContext& ctx, TPositionHandle pos);
 
 [[maybe_unused]]
-TMaybeNode<TExprBase> YqlCoalescePushdown(const TCoCoalesce& coalesce, const TExprNode& argument, TExprContext& ctx) {
+TMaybeNode<TExprBase> CoalescePushdown(const TCoCoalesce& coalesce, const TExprNode& argument, TExprContext& ctx) {
     if (const auto params = ExtractBinaryFunctionParameters(coalesce, argument, ctx, coalesce.Pos())) {
         return Build<TKqpOlapFilterBinaryOp>(ctx, coalesce.Pos())
                 .Operator().Value("??", TNodeFlags::Default).Build()
@@ -171,11 +214,6 @@ TMaybeNode<TExprBase> YqlApplyPushdown(const TExprBase& apply, const TExprNode&
         return false;
     });
 
-    // Temporary fix for https://st.yandex-team.ru/KIKIMR-22216
-    if (parameters.size()!=0) {
-        return nullptr;
-    }
-
     const auto members = FindNodes(apply.Ptr(), [&argument] (const TExprNode::TPtr& node) {
         if (const auto maybeMember = TMaybeNode<TCoMember>(node))
             return maybeMember.Cast().Struct().Raw() == &argument;
@@ -188,10 +226,18 @@ TMaybeNode<TExprBase> YqlApplyPushdown(const TExprBase& apply, const TExprNode&
     arguments.reserve(members.size());
     for (const auto& member : members) {
         columns.emplace_back(member->TailPtr());
-        arguments.emplace_back(ctx.NewArgument(member->Pos(), columns.back()->Content()));
+        TString argumentName = "members_" + TString(columns.back()->Content());
+        arguments.emplace_back(ctx.NewArgument(member->Pos(), TStringBuf(argumentName)));
         replacements.emplace(member.Get(), arguments.back());
     }
 
+    for(const auto& pptr : parameters) {
+        TCoParameter parameter = TMaybeNode<TCoParameter>(pptr).Cast();
+        TString argumentName = "parameter_" + TString(parameter.Name().StringValue());
+        arguments.emplace_back(ctx.NewArgument(pptr->Pos(), TStringBuf(argumentName)));
+        replacements.emplace(pptr.Get(), arguments.back());
+    }
+
     // Temporary fix for https://st.yandex-team.ru/KIKIMR-22560
     if (!columns.size()) {
         return nullptr;
@@ -200,13 +246,69 @@ TMaybeNode<TExprBase> YqlApplyPushdown(const TExprBase& apply, const TExprNode&
     return Build<TKqpOlapApply>(ctx, apply.Pos())
         .Type(ExpandType(argument.Pos(), *argument.GetTypeAnn(), ctx))
         .Columns().Add(std::move(columns)).Build()
+        .Parameters().Add(std::move(parameters)).Build()
         .Lambda(ctx.NewLambda(apply.Pos(), ctx.NewArguments(argument.Pos(), std::move(arguments)), ctx.ReplaceNodes(apply.Ptr(), replacements)))
         .Done();
 }
 
+TMaybeNode<TExprBase> JsonExistsPushdown(const TCoJsonExists& jsonExists, TExprContext& ctx, TPositionHandle pos)
+{
+    auto columnName = jsonExists.Json().Cast<TCoMember>().Name();
+    return Build<TKqpOlapJsonExists>(ctx, pos)
+        .Column(columnName)
+        .Path(jsonExists.JsonPath().Cast<TCoUtf8>())
+        .Done();
+}
+TMaybeNode<TExprBase> SimplePredicatePushdown(const TCoCompare& predicate, const TExprNode& argument, TExprContext& ctx, TPositionHandle pos)
+{
+    const auto parameters = ExtractComparisonParameters(predicate, argument, ctx, pos);
+    if (parameters.empty()) {
+        return NullNode;
+    }
+
+    return ComparisonPushdown(parameters, predicate, ctx, pos);
+}
+
+TMaybeNode<TExprBase> SafeCastPredicatePushdown(const TCoFlatMap& inputFlatmap, const TExprNode& argument, TExprContext& ctx, TPositionHandle pos)
+{
+    /*
+     * There are three ways of comparison in following format:
+     *
+     * FlatMap (LeftArgument, FlatMap(RightArgument(), Just(Predicate))
+     *
+     * Examples:
+     * FlatMap (SafeCast(), FlatMap(Member(), Just(Comparison))
+     * FlatMap (Member(), FlatMap(SafeCast(), Just(Comparison))
+     * FlatMap (SafeCast(), FlatMap(SafeCast(), Just(Comparison))
+     */
+    auto left = ConvertComparisonNode(inputFlatmap.Input(), argument, ctx, pos);
+    if (left.empty()) {
+        return NullNode;
+    }
+
+    auto flatmap = inputFlatmap.Lambda().Body().Cast<TCoFlatMap>();
+    auto right = ConvertComparisonNode(flatmap.Input(), argument, ctx, pos);
+    if (right.empty()) {
+        return NullNode;
+    }
+
+    auto predicate = flatmap.Lambda().Body().Cast<TCoJust>().Input().Cast<TCoCompare>();
+
+    std::vector<std::pair<TExprBase, TExprBase>> parameters;
+    if (left.size() != right.size()) {
+        return NullNode;
+    }
+
+    for (ui32 i = 0; i < left.size(); ++i) {
+        parameters.emplace_back(std::move(std::make_pair(left[i], right[i])));
+    }
+
+    return ComparisonPushdown(parameters, predicate, ctx, pos);
+}
+
+
 std::vector<TExprBase> ConvertComparisonNode(const TExprBase& nodeIn, const TExprNode& argument, TExprContext& ctx, TPositionHandle pos)
 {
-    std::vector<TExprBase> out;
     const auto convertNode = [&ctx, &pos, &argument](const TExprBase& node) -> TMaybeNode<TExprBase> {
         if (node.Maybe<TCoNull>()) {
             return node;
@@ -249,6 +351,10 @@ std::vector<TExprBase> ConvertComparisonNode(const TExprBase& nodeIn, const TExp
             return builder.Done();
         }
 
+        if (auto maybeJsonExists = node.Maybe<TCoJsonExists>()) {
+            return JsonExistsPushdown(maybeJsonExists.Cast(), ctx, pos);
+        }
+
         if (const auto maybeJust = node.Maybe<TCoJust>()) {
             if (const auto params = ConvertComparisonNode(maybeJust.Cast().Input(), argument, ctx, pos); 1U == params.size()) {
                 return Build<TKqpOlapFilterUnaryOp>(ctx, node.Pos())
@@ -262,33 +368,31 @@ std::vector<TExprBase> ConvertComparisonNode(const TExprBase& nodeIn, const TExp
             return YqlIfPushdown(maybeIf.Cast(), argument, ctx);
         }
 
-        if constexpr (NKikimr::NSsa::RuntimeVersion >= 4U) {
-            if (const auto maybeArithmetic = node.Maybe<TCoBinaryArithmetic>()) {
-                const auto arithmetic = maybeArithmetic.Cast();
-                if (const auto params = ExtractBinaryFunctionParameters(arithmetic, argument, ctx, pos)) {
-                    return Build<TKqpOlapFilterBinaryOp>(ctx, pos)
-                            .Operator().Value(arithmetic.Ref().Content(), TNodeFlags::Default).Build()
-                            .Left(params->first)
-                            .Right(params->second)
-                            .Done();
-                }
+        if (const auto maybeArithmetic = node.Maybe<TCoBinaryArithmetic>()) {
+            const auto arithmetic = maybeArithmetic.Cast();
+            if (const auto params = ExtractBinaryFunctionParameters(arithmetic, argument, ctx, pos)) {
+                return Build<TKqpOlapFilterBinaryOp>(ctx, pos)
+                        .Operator().Value(arithmetic.Ref().Content(), TNodeFlags::Default).Build()
+                        .Left(params->first)
+                        .Right(params->second)
+                        .Done();
             }
+        }
 
-            if (const auto maybeArithmetic = node.Maybe<TCoUnaryArithmetic>()) {
-                const auto arithmetic = maybeArithmetic.Cast();
-                if (const auto params = ConvertComparisonNode(arithmetic.Arg(), argument, ctx, pos); 1U == params.size()) {
-                    TString oper(arithmetic.Ref().Content());
-                    YQL_ENSURE(oper.to_lower());
-                    return Build<TKqpOlapFilterUnaryOp>(ctx, pos)
-                            .Operator().Value(oper, TNodeFlags::Default).Build()
-                            .Arg(params.front())
-                            .Done();
-                }
+        if (const auto maybeArithmetic = node.Maybe<TCoUnaryArithmetic>()) {
+            const auto arithmetic = maybeArithmetic.Cast();
+            if (const auto params = ConvertComparisonNode(arithmetic.Arg(), argument, ctx, pos); 1U == params.size()) {
+                TString oper(arithmetic.Ref().Content());
+                YQL_ENSURE(oper.to_lower());
+                return Build<TKqpOlapFilterUnaryOp>(ctx, pos)
+                        .Operator().Value(oper, TNodeFlags::Default).Build()
+                        .Arg(params.front())
+                        .Done();
             }
+        }
 
-            if (const auto maybeCoalesce = node.Maybe<TCoCoalesce>()) {
-                return YqlCoalescePushdown(maybeCoalesce.Cast(), argument, ctx);
-            }
+        if (const auto maybeCoalesce = node.Maybe<TCoCoalesce>()) {
+            return CoalescePushdown(maybeCoalesce.Cast(), argument, ctx);
         }
 
         if (const auto maybeCompare = node.Maybe<TCoCompare>()) {
@@ -297,6 +401,11 @@ std::vector<TExprBase> ConvertComparisonNode(const TExprBase& nodeIn, const TExp
             }
         }
 
+        if (const auto maybeFlatmap = node.Maybe<TCoFlatMap>()) {
+            return SafeCastPredicatePushdown(maybeFlatmap.Cast(), argument, ctx, pos);
+        } else if (auto maybePredicate = node.Maybe<TCoCompare>()) {
+            return SimplePredicatePushdown(maybePredicate.Cast(), argument, ctx, pos);
+        }
 
         if constexpr (NKikimr::NSsa::RuntimeVersion >= 5U) {
             return YqlApplyPushdown(node, argument, ctx);
@@ -305,36 +414,27 @@ std::vector<TExprBase> ConvertComparisonNode(const TExprBase& nodeIn, const TExp
         }
     };
 
-    // Columns & values may be single element
-    TMaybeNode<TExprBase> node = convertNode(nodeIn);
+    if (const auto& list = nodeIn.Maybe<TExprList>()) {
+        const auto& tuple = list.Cast();
+        std::vector<TExprBase> out;
 
-    if (node.IsValid()) {
-        out.emplace_back(std::move(node.Cast()));
-        return out;
-    }
+        out.reserve(tuple.Size());
+        for (ui32 i = 0; i < tuple.Size(); ++i) {
+            TMaybeNode<TExprBase> node = convertNode(tuple.Item(i));
 
-    // Or columns and values can be Tuple
-    if (!nodeIn.Maybe<TExprList>()) {
-        // something unusual found, return empty vector
-        return out;
-    }
-
-    auto tuple = nodeIn.Cast<TExprList>();
-
-    out.reserve(tuple.Size());
-
-    for (ui32 i = 0; i < tuple.Size(); ++i) {
-        TMaybeNode<TExprBase> node = convertNode(tuple.Item(i));
+            if (!node.IsValid()) {
+                // Return empty vector
+                return TVector<TExprBase>();
+            }
 
-        if (!node.IsValid()) {
-            // Return empty vector
-            return TVector<TExprBase>();
+            out.emplace_back(node.Cast());
         }
-
-        out.emplace_back(node.Cast());
+        return out;
+    } else if (const auto& node = convertNode(nodeIn); node.IsValid()) {
+        return {node.Cast()};
+    } else {
+        return {};
     }
-
-    return out;
 }
 
 TExprBase BuildOneElementComparison(const std::pair<TExprBase, TExprBase>& parameter, const TCoCompare& predicate,
@@ -375,7 +475,7 @@ TExprBase BuildOneElementComparison(const std::pair<TExprBase, TExprBase>& param
         compareOperator = "gt";
     } else if (predicate.Maybe<TCoCmpGreaterOrEqual>() && !forceStrictComparison) {
         compareOperator = "gte";
-    } else if constexpr (NKikimr::NSsa::RuntimeVersion >= 2U) {
+    } else {
         // We introduced LIKE pushdown in v2 of SSA program
         if (predicate.Maybe<TCoCmpStringContains>()) {
             compareOperator = "string_contains";
@@ -469,16 +569,6 @@ TMaybeNode<TExprBase> ComparisonPushdown(const std::vector<std::pair<TExprBase,
         .Done();
 }
 
-TMaybeNode<TExprBase> SimplePredicatePushdown(const TCoCompare& predicate, const TExprNode& argument, TExprContext& ctx, TPositionHandle pos)
-{
-    const auto parameters = ExtractComparisonParameters(predicate, argument, ctx, pos);
-    if (parameters.empty()) {
-        return NullNode;
-    }
-
-    return ComparisonPushdown(parameters, predicate, ctx, pos);
-}
-
 // TODO: Check how to reduce columns if they are not needed. Unfortunately columnshard need columns list
 // for every column present in program even if it is not used in result set.
 //#define ENABLE_COLUMNS_PRUNING
@@ -511,88 +601,16 @@ template<bool Empty>
 TMaybeNode<TExprBase> ExistsPushdown(const TCoExists& exists, TExprContext& ctx, TPositionHandle pos)
 {
     const auto columnName = exists.Optional().Cast<TCoMember>().Name();
-    if constexpr (NSsa::RuntimeVersion >= 4U) {
-        return Build<TKqpOlapFilterUnaryOp>(ctx, pos)
-                .Operator().Value(Empty ? "empty" : "exists", TNodeFlags::Default).Build()
-                .Arg(columnName)
-                .Done();
-    } else {
-        return Build<TKqpOlapFilterExists>(ctx, pos)
-            .Column(columnName)
+    return Build<TKqpOlapFilterUnaryOp>(ctx, pos)
+            .Operator().Value(Empty ? "empty" : "exists", TNodeFlags::Default).Build()
+            .Arg(columnName)
             .Done();
-    }
-}
-
-TMaybeNode<TExprBase> JsonExistsPushdown(const TCoJsonExists& jsonExists, TExprContext& ctx, TPositionHandle pos)
-{
-    auto columnName = jsonExists.Json().Cast<TCoMember>().Name();
-    return Build<TKqpOlapJsonExists>(ctx, pos)
-        .Column(columnName)
-        .Path(jsonExists.JsonPath().Cast<TCoUtf8>())
-        .Done();
-}
-
-TMaybeNode<TExprBase> SafeCastPredicatePushdown(const TCoFlatMap& inputFlatmap, const TExprNode& argument, TExprContext& ctx, TPositionHandle pos)
-{
-    /*
-     * There are three ways of comparison in following format:
-     *
-     * FlatMap (LeftArgument, FlatMap(RightArgument(), Just(Predicate))
-     *
-     * Examples:
-     * FlatMap (SafeCast(), FlatMap(Member(), Just(Comparison))
-     * FlatMap (Member(), FlatMap(SafeCast(), Just(Comparison))
-     * FlatMap (SafeCast(), FlatMap(SafeCast(), Just(Comparison))
-     */
-    auto left = ConvertComparisonNode(inputFlatmap.Input(), argument, ctx, pos);
-    if (left.empty()) {
-        return NullNode;
-    }
-
-    auto flatmap = inputFlatmap.Lambda().Body().Cast<TCoFlatMap>();
-    auto right = ConvertComparisonNode(flatmap.Input(), argument, ctx, pos);
-    if (right.empty()) {
-        return NullNode;
-    }
-
-    auto predicate = flatmap.Lambda().Body().Cast<TCoJust>().Input().Cast<TCoCompare>();
-
-    std::vector<std::pair<TExprBase, TExprBase>> parameters;
-    if (left.size() != right.size()) {
-        return NullNode;
-    }
-
-    for (ui32 i = 0; i < left.size(); ++i) {
-        parameters.emplace_back(std::move(std::make_pair(left[i], right[i])));
-    }
-
-    return ComparisonPushdown(parameters, predicate, ctx, pos);
-}
-
-TMaybeNode<TExprBase> CoalescePushdown(const TCoCoalesce& coalesce, const TExprNode& argument, TExprContext& ctx, TPositionHandle pos)
-{
-    if constexpr (NSsa::RuntimeVersion >= 4U) {
-        if (const auto node = YqlCoalescePushdown(coalesce, argument, ctx)) {
-            return node;
-        }
-    }
-
-    auto predicate = coalesce.Predicate();
-    if (const auto maybeFlatmap = predicate.Maybe<TCoFlatMap>()) {
-        return SafeCastPredicatePushdown(maybeFlatmap.Cast(), argument, ctx, pos);
-    } else if (auto maybePredicate = predicate.Maybe<TCoCompare>()) {
-        return SimplePredicatePushdown(maybePredicate.Cast(), argument, ctx, pos);
-    } else if (auto maybeJsonExists = predicate.Maybe<TCoJsonExists>()) {
-        return JsonExistsPushdown(maybeJsonExists.Cast(), ctx, pos);
-    }
-
-    return NullNode;
 }
 
 TFilterOpsLevels PredicatePushdown(const TExprBase& predicate, const TExprNode& argument, TExprContext& ctx, TPositionHandle pos)
 {
     if (const auto maybeCoalesce = predicate.Maybe<TCoCoalesce>()) {
-        auto coalescePred = CoalescePushdown(maybeCoalesce.Cast(), argument, ctx, pos);
+        auto coalescePred = CoalescePushdown(maybeCoalesce.Cast(), argument, ctx);
         return TFilterOpsLevels(coalescePred);
     }
 
@@ -617,10 +635,8 @@ TFilterOpsLevels PredicatePushdown(const TExprBase& predicate, const TExprNode&
 
     if (const auto maybeNot = predicate.Maybe<TCoNot>()) {
         const auto notNode = maybeNot.Cast();
-        if constexpr (NSsa::RuntimeVersion >= 4U) {
-            if (const auto maybeExists = notNode.Value().Maybe<TCoExists>()) {
-                return TFilterOpsLevels(ExistsPushdown<true>(maybeExists.Cast(), ctx, pos));
-            }
+        if (const auto maybeExists = notNode.Value().Maybe<TCoExists>()) {
+            return TFilterOpsLevels(ExistsPushdown<true>(maybeExists.Cast(), ctx, pos));
         }
         auto pushedFilters = PredicatePushdown(notNode.Value(), argument, ctx, pos);
         pushedFilters.WrapToNotOp(ctx, pos);
@@ -684,50 +700,22 @@ TFilterOpsLevels PredicatePushdown(const TExprBase& predicate, const TExprNode&
     return YqlApplyPushdown(predicate, argument, ctx);
 }
 
-TOLAPPredicateNode WrapPredicates(const std::vector<TOLAPPredicateNode>& predicates, TExprContext& ctx, TPositionHandle pos) {
-    if (predicates.empty()) {
-        return {};
-    }
-
-    if (const auto predicatesSize = predicates.size(); 1U == predicatesSize) {
-        return predicates.front();
-    } else {
-        TOLAPPredicateNode result;
-        result.Children = predicates;
-        result.CanBePushed = true;
-
-        TVector<NNodes::TExprBase> exprNodes;
-        exprNodes.reserve(predicatesSize);
-        for (const auto& pred : predicates) {
-            exprNodes.emplace_back(pred.ExprNode);
-            result.CanBePushed &= pred.CanBePushed;
-        }
-        result.ExprNode = NNodes::Build<NNodes::TCoAnd>(ctx, pos)
-            .Add(exprNodes)
-            .Done().Ptr();
-        return result;
-    }
-}
-
-void SplitForPartialPushdown(const TOLAPPredicateNode& predicateTree, TOLAPPredicateNode& predicatesToPush, TOLAPPredicateNode& remainingPredicates,
-    TExprContext& ctx, TPositionHandle pos)
+std::pair<TVector<TOLAPPredicateNode>, TVector<TOLAPPredicateNode>> SplitForPartialPushdown(const TOLAPPredicateNode& predicateTree)
 {
     if (predicateTree.CanBePushed) {
-        predicatesToPush = predicateTree;
-        remainingPredicates.ExprNode = MakeBool<true>(pos, ctx);
-        return;
+        return {{predicateTree}, {}};
     }
 
     if (!TCoAnd::Match(predicateTree.ExprNode.Get())) {
         // We can partially pushdown predicates from AND operator only.
         // For OR operator we would need to have several read operators which is not acceptable.
         // TODO: Add support for NOT(op1 OR op2), because it expands to (!op1 AND !op2).
-        remainingPredicates = predicateTree;
-        return;
+        return {{}, {predicateTree}};
     }
 
     bool isFoundNotStrictOp = false;
-    std::vector<TOLAPPredicateNode> pushable, remaining;
+    TVector<TOLAPPredicateNode> pushable;
+    TVector<TOLAPPredicateNode> remaining;
     for (const auto& predicate : predicateTree.Children) {
         if (predicate.CanBePushed && !isFoundNotStrictOp) {
             pushable.emplace_back(predicate);
@@ -738,8 +726,7 @@ void SplitForPartialPushdown(const TOLAPPredicateNode& predicateTree, TOLAPPredi
             remaining.emplace_back(predicate);
         }
     }
-    predicatesToPush = WrapPredicates(pushable, ctx, pos);
-    remainingPredicates = WrapPredicates(remaining, ctx, pos);
+    return {pushable, remaining};
 }
 
 } // anonymous namespace end
@@ -763,6 +750,7 @@ TExprBase KqpPushOlapFilter(TExprBase node, TExprContext& ctx, const TKqpOptimiz
     }
 
     const auto& lambda = flatmap.Lambda();
+    const auto& lambdaArg = lambda.Args().Arg(0).Ref();
 
     YQL_CLOG(TRACE, ProviderKqp) << "Initial OLAP lambda: " << KqpExprToPrettyString(lambda, ctx);
 
@@ -775,55 +763,68 @@ TExprBase KqpPushOlapFilter(TExprBase node, TExprContext& ctx, const TKqpOptimiz
     auto predicate = optionaIf.Predicate();
     auto value = optionaIf.Value();
 
-    if constexpr (NSsa::RuntimeVersion >= 5U) {
-        TExprNode::TPtr afterPeephole;
-        bool hasNonDeterministicFunctions;
-        if (const auto status = PeepHoleOptimizeNode(optionaIf.Ptr(), afterPeephole, ctx, typesCtx, nullptr, hasNonDeterministicFunctions);
-            status != IGraphTransformer::TStatus::Ok) {
-            YQL_CLOG(ERROR, ProviderKqp) << "Peephole OLAP failed." << Endl << ctx.IssueManager.GetIssues().ToString();
-            return node;
-        }
-
-        const TCoIf simplified(std::move(afterPeephole));
-        predicate = simplified.Predicate();
-        value = simplified.ThenValue().Cast<TCoJust>().Input();
-    }
-
     TOLAPPredicateNode predicateTree;
     predicateTree.ExprNode = predicate.Ptr();
-    const auto& lambdaArg = lambda.Args().Arg(0).Ref();
-    CollectPredicates(predicate, predicateTree, &lambdaArg, read.Process().Body());
+    CollectPredicates(predicate, predicateTree, &lambdaArg, read.Process().Body(), false);
     YQL_ENSURE(predicateTree.IsValid(), "Collected OLAP predicates are invalid");
 
-    TOLAPPredicateNode predicatesToPush, remainingPredicates;
-    SplitForPartialPushdown(predicateTree, predicatesToPush, remainingPredicates, ctx, node.Pos());
-    if (!predicatesToPush.IsValid()) {
-        return node;
+    auto [pushable, remaining] = SplitForPartialPushdown(predicateTree);
+    TVector<TFilterOpsLevels> pushedPredicates;
+    for (const auto& p: pushable) {
+        pushedPredicates.emplace_back(PredicatePushdown(TExprBase(p.ExprNode), lambdaArg, ctx, node.Pos()));
     }
 
-    YQL_ENSURE(predicatesToPush.IsValid(), "Predicates to push is invalid");
-    YQL_ENSURE(remainingPredicates.IsValid(), "Remaining predicates is invalid");
-
-    const auto pushedFilters = PredicatePushdown(TExprBase(predicatesToPush.ExprNode), lambdaArg, ctx, node.Pos());
-    // Temporary fix for https://st.yandex-team.ru/KIKIMR-22560
-    // YQL_ENSURE(pushedFilters.IsValid(), "Pushed predicate should be always valid!");
+    if constexpr (NSsa::RuntimeVersion >= 5U) {
+        TVector<TOLAPPredicateNode> remainingAfterApply;
+        for(const auto& p: remaining) {
+            const auto recoveredOptinalIfForNonPushedDownPredicates = Build<TCoOptionalIf>(ctx, node.Pos())
+                .Predicate(p.ExprNode)
+                .Value(value)
+            .Build();
+            TExprNode::TPtr afterPeephole;
+            bool hasNonDeterministicFunctions;
+            if (const auto status = PeepHoleOptimizeNode(recoveredOptinalIfForNonPushedDownPredicates.Value().Ptr(), afterPeephole, ctx, typesCtx, nullptr, hasNonDeterministicFunctions);
+                status != IGraphTransformer::TStatus::Ok) {
+                YQL_CLOG(ERROR, ProviderKqp) << "Peephole OLAP failed." << Endl << ctx.IssueManager.GetIssues().ToString();
+                return node;
+            }
+            const TCoIf simplified(std::move(afterPeephole));
+            predicate = simplified.Predicate();
+            value = simplified.ThenValue().Cast<TCoJust>().Input();
+
+            TOLAPPredicateNode predicateTree;
+            predicateTree.ExprNode = predicate.Ptr();
+            CollectPredicates(predicate, predicateTree, &lambdaArg, read.Process().Body(), true);
+            YQL_ENSURE(predicateTree.IsValid(), "Collected OLAP predicates are invalid");
+            auto [pushableWithApply, remaining] = SplitForPartialPushdown(predicateTree);
+            for (const auto& p: pushableWithApply) {
+               pushedPredicates.emplace_back(PredicatePushdown(TExprBase(p.ExprNode), lambdaArg, ctx, node.Pos()));
+            }
+            remainingAfterApply.insert(remainingAfterApply.end(), remaining.begin(), remaining.end());
+        }
+        remaining = std::move(remainingAfterApply);
+    }
 
-    if (!pushedFilters.IsValid()) {
+    if (pushedPredicates.empty()) {
         return node;
     }
 
+    const auto& pushedFilter = TFilterOpsLevels::Merge(pushedPredicates, ctx, node.Pos());
+
+    const auto remainingFilter = CombinePredicatesWithAnd(remaining, ctx, node.Pos(), false, true);
+
     TMaybeNode<TExprBase> olapFilter;
-    if (pushedFilters.FirstLevelOps.IsValid()) {    
+    if (pushedFilter.FirstLevelOps.IsValid()) {
         olapFilter = Build<TKqpOlapFilter>(ctx, node.Pos())
             .Input(read.Process().Body())
-            .Condition(pushedFilters.FirstLevelOps.Cast())
+            .Condition(pushedFilter.FirstLevelOps.Cast())
             .Done();
     }
 
-    if (pushedFilters.SecondLevelOps.IsValid()) {
+    if (pushedFilter.SecondLevelOps.IsValid()) {
         olapFilter = Build<TKqpOlapFilter>(ctx, node.Pos())
             .Input(olapFilter.IsValid() ? olapFilter.Cast() : read.Process().Body())
-            .Condition(pushedFilters.SecondLevelOps.Cast())
+            .Condition(pushedFilter.SecondLevelOps.Cast())
             .Done();
     }
 
@@ -867,7 +868,7 @@ TExprBase KqpPushOlapFilter(TExprBase node, TExprContext& ctx, const TKqpOptimiz
             .Args({"new_arg"})
             .Body<TCoOptionalIf>()
                 .Predicate<TExprApplier>()
-                    .Apply(TExprBase(remainingPredicates.ExprNode))
+                    .Apply(remainingFilter.Cast())
                     .With(lambda.Args().Arg(0), "new_arg")
                     .Build()
                 .Value<TExprApplier>()
@@ -882,4 +883,32 @@ TExprBase KqpPushOlapFilter(TExprBase node, TExprContext& ctx, const TKqpOptimiz
 #endif
 }
 
+TExprBase KqpAddColumnForEmptyColumnsOlapRead(TExprBase node, TExprContext& ctx, const TKqpOptimizeContext& kqpCtx) {
+    if (!node.Maybe<TKqpReadOlapTableRanges>()) {
+        return node;
+    }
+
+    auto readOlap = node.Cast<TKqpReadOlapTableRanges>();
+    if (readOlap.Columns().Size()!=0) {
+        return node;
+    }
+
+    const auto& tableData = kqpCtx.Tables->ExistingTable(kqpCtx.Cluster, readOlap.Table().Path().Value());
+    auto keyColumns = tableData.Metadata->KeyColumnNames;
+
+    TVector<TExprNode::TPtr> newColumns;
+    newColumns.push_back(ctx.NewAtom(node.Pos(), keyColumns[0]));
+
+    return Build<TKqpReadOlapTableRanges>(ctx, node.Pos())
+        .Table(readOlap.Table())
+        .Ranges(readOlap.Ranges())
+        .Columns()
+            .Add(newColumns)
+            .Build()
+        .Settings(readOlap.Settings())
+        .ExplainPrompt(readOlap.ExplainPrompt())
+        .Process(readOlap.Process())
+        .Done();
+}
+
 } // namespace NKikimr::NKqp::NOpt
diff --git a/ydb/core/kqp/opt/physical/kqp_opt_phy_rules.h b/ydb/core/kqp/opt/physical/kqp_opt_phy_rules.h
index 7128016625dd..587672cb413a 100644
--- a/ydb/core/kqp/opt/physical/kqp_opt_phy_rules.h
+++ b/ydb/core/kqp/opt/physical/kqp_opt_phy_rules.h
@@ -67,6 +67,9 @@ NYql::NNodes::TExprBase KqpPropagatePrecomuteScalarRowset(NYql::NNodes::TExprBas
 NYql::NNodes::TExprBase KqpBuildWriteConstraint(NYql::NNodes::TExprBase node, NYql::TExprContext& ctx,
     NYql::IOptimizationContext& optCtx, const NYql::TParentsMap& parentsMap, bool allowStageMultiUsage);
 
+NYql::NNodes::TExprBase KqpAddColumnForEmptyColumnsOlapRead(NYql::NNodes::TExprBase node, NYql::TExprContext& ctx, 
+    const TKqpOptimizeContext& kqpCtx);
+
 bool AllowFuseJoinInputs(NYql::NNodes::TExprBase node);
 
 bool UseSource(const TKqpOptimizeContext& kqpCtx, const NYql::TKikimrTableDescription& tableDesc);
diff --git a/ydb/core/kqp/opt/physical/kqp_opt_phy_sort.cpp b/ydb/core/kqp/opt/physical/kqp_opt_phy_sort.cpp
index efa9804fce29..f1630e3bca44 100644
--- a/ydb/core/kqp/opt/physical/kqp_opt_phy_sort.cpp
+++ b/ydb/core/kqp/opt/physical/kqp_opt_phy_sort.cpp
@@ -72,17 +72,13 @@ TExprBase KqpRemoveRedundantSortByPk(TExprBase node, TExprContext& ctx, const TK
             return node;
         }
 
-        if (settings.Reverse) {
-            return node;
-        }
-
-        settings.SetReverse();
-        settings.SetSorted();
-
+        AFL_ENSURE(settings.GetSorting() == ERequestSorting::NONE);
+        settings.SetSorting(ERequestSorting::DESC);
         input = BuildReadNode(input.Pos(), ctx, input, settings);
     } else if (direction == ESortDirection::Forward) {
         if (UseSource(kqpCtx, tableDesc)) {
-            settings.SetSorted();
+            AFL_ENSURE(settings.GetSorting() == ERequestSorting::NONE);
+            settings.SetSorting(ERequestSorting::ASC);
             input = BuildReadNode(input.Pos(), ctx, input, settings);
         }
     }
diff --git a/ydb/core/kqp/opt/physical/predicate_collector.cpp b/ydb/core/kqp/opt/physical/predicate_collector.cpp
index 57fa8b334d05..5e911f1de104 100644
--- a/ydb/core/kqp/opt/physical/predicate_collector.cpp
+++ b/ydb/core/kqp/opt/physical/predicate_collector.cpp
@@ -15,7 +15,7 @@ bool IsSupportedPredicate(const TCoCompare& predicate) {
     return !predicate.Ref().Content().starts_with("Aggr");
 }
 
-bool IsSupportedDataType(const TCoDataCtor& node) {
+bool IsSupportedDataType(const TCoDataCtor& node, bool allowOlapApply) {
     if (node.Maybe<TCoBool>() ||
         node.Maybe<TCoFloat>() ||
         node.Maybe<TCoDouble>() ||
@@ -32,13 +32,11 @@ bool IsSupportedDataType(const TCoDataCtor& node) {
         return true;
     }
 
-    if constexpr (NKikimr::NSsa::RuntimeVersion >= 4U) {
-        if (node.Maybe<TCoTimestamp>()) {
-            return true;
-        }
+    if (node.Maybe<TCoTimestamp>()) {
+        return true;
     }
 
-    if constexpr (NKikimr::NSsa::RuntimeVersion >= 5U) {
+    if (allowOlapApply) {
         if (node.Maybe<TCoDate32>() ||  node.Maybe<TCoDatetime64>() || node.Maybe<TCoTimestamp64>() || node.Maybe<TCoInterval64>()) {
             return true;
         }
@@ -88,17 +86,17 @@ bool IsMemberColumn(const TExprBase& node, const TExprNode* lambdaArg) {
     return false;
 }
 
-bool IsGoodTypeForArithmeticPushdown(const TTypeAnnotationNode& type) {
+bool IsGoodTypeForArithmeticPushdown(const TTypeAnnotationNode& type, bool allowOlapApply) {
     const auto fatures = NUdf::GetDataTypeInfo(RemoveOptionality(type).Cast<TDataExprType>()->GetSlot()).Features;
     return NUdf::EDataTypeFeatures::NumericType & fatures
-        || (NKikimr::NSsa::RuntimeVersion >= 5U && (NUdf::EDataTypeFeatures::BigDateType & fatures) && !(NUdf::EDataTypeFeatures::TzDateType & fatures));
+        || (allowOlapApply && (NUdf::EDataTypeFeatures::BigDateType & fatures) && !(NUdf::EDataTypeFeatures::TzDateType & fatures));
 }
 
-bool IsGoodTypeForComparsionPushdown(const TTypeAnnotationNode& type) {
+bool IsGoodTypeForComparsionPushdown(const TTypeAnnotationNode& type, bool allowOlapApply) {
     const auto fatures = NUdf::GetDataTypeInfo(RemoveOptionality(type).Cast<TDataExprType>()->GetSlot()).Features;
     return (NUdf::EDataTypeFeatures::CanCompare  & fatures)
         && (((NUdf::EDataTypeFeatures::NumericType | NUdf::EDataTypeFeatures::StringType) & fatures) ||
-            (NKikimr::NSsa::RuntimeVersion >= 5U && (NUdf::EDataTypeFeatures::BigDateType & fatures) && !(NUdf::EDataTypeFeatures::TzDateType & fatures)));
+            (allowOlapApply && (NUdf::EDataTypeFeatures::BigDateType & fatures) && !(NUdf::EDataTypeFeatures::TzDateType & fatures)));
 }
 
 [[maybe_unused]]
@@ -141,8 +139,8 @@ bool AbstractTreeCanBePushed(const TExprBase& expr, const TExprNode* ) {
     return true;
 }
 
-bool CheckExpressionNodeForPushdown(const TExprBase& node, const TExprNode* lambdaArg) {
-    if constexpr (NKikimr::NSsa::RuntimeVersion >= 5U) {
+bool CheckExpressionNodeForPushdown(const TExprBase& node, const TExprNode* lambdaArg, bool allowOlapApply) {
+    if (allowOlapApply) {
         if (node.Maybe<TCoJust>() || node.Maybe<TCoCoalesce>()) {
             return true;
         }
@@ -158,7 +156,7 @@ bool CheckExpressionNodeForPushdown(const TExprBase& node, const TExprNode* lamb
     if (const auto maybeSafeCast = node.Maybe<TCoSafeCast>()) {
         return IsSupportedCast(maybeSafeCast.Cast());
     } else if (const auto maybeData = node.Maybe<TCoDataCtor>()) {
-        return IsSupportedDataType(maybeData.Cast());
+        return IsSupportedDataType(maybeData.Cast(), allowOlapApply);
     } else if (const auto maybeMember = node.Maybe<TCoMember>()) {
         return IsMemberColumn(maybeMember.Cast(), lambdaArg);
     } else if (const auto maybeJsonValue = node.Maybe<TCoJsonValue>()) {
@@ -168,23 +166,21 @@ bool CheckExpressionNodeForPushdown(const TExprBase& node, const TExprNode* lamb
         return true;
     }
 
-    if constexpr (NKikimr::NSsa::RuntimeVersion >= 4U) {
-        if (const auto op = node.Maybe<TCoUnaryArithmetic>()) {
-            return CheckExpressionNodeForPushdown(op.Cast().Arg(), lambdaArg) && IsGoodTypeForArithmeticPushdown(*op.Cast().Ref().GetTypeAnn());
-        } else if (const auto op = node.Maybe<TCoBinaryArithmetic>()) {
-            return CheckExpressionNodeForPushdown(op.Cast().Left(), lambdaArg) && CheckExpressionNodeForPushdown(op.Cast().Right(), lambdaArg)
-                && IsGoodTypeForArithmeticPushdown(*op.Cast().Ref().GetTypeAnn()) && !op.Cast().Maybe<TCoAggrAdd>();
-        }
+    if (const auto op = node.Maybe<TCoUnaryArithmetic>()) {
+        return CheckExpressionNodeForPushdown(op.Cast().Arg(), lambdaArg, allowOlapApply) && IsGoodTypeForArithmeticPushdown(*op.Cast().Ref().GetTypeAnn(), allowOlapApply);
+    } else if (const auto op = node.Maybe<TCoBinaryArithmetic>()) {
+        return CheckExpressionNodeForPushdown(op.Cast().Left(), lambdaArg, allowOlapApply) && CheckExpressionNodeForPushdown(op.Cast().Right(), lambdaArg, allowOlapApply)
+            && IsGoodTypeForArithmeticPushdown(*op.Cast().Ref().GetTypeAnn(), allowOlapApply) && !op.Cast().Maybe<TCoAggrAdd>();
     }
 
-    if constexpr (NKikimr::NSsa::RuntimeVersion >= 5U) {
+    if (allowOlapApply) {
         return AbstractTreeCanBePushed(node, lambdaArg);
     }
 
     return false;
 }
 
-bool IsGoodTypesForPushdownCompare(const TTypeAnnotationNode& typeOne, const TTypeAnnotationNode& typeTwo) {
+bool IsGoodTypesForPushdownCompare(const TTypeAnnotationNode& typeOne, const TTypeAnnotationNode& typeTwo, bool allowOlapApply) {
     const auto& rawOne = RemoveOptionality(typeOne);
     const auto& rawTwo = RemoveOptionality(typeTwo);
     if (IsSameAnnotation(rawOne, rawTwo))
@@ -206,21 +202,21 @@ bool IsGoodTypesForPushdownCompare(const TTypeAnnotationNode& typeOne, const TTy
             if (size != itemsTwo.size())
                 return false;
             for (auto i = 0U; i < size; ++i) {
-                if (!IsGoodTypesForPushdownCompare(*itemsOne[i], *itemsTwo[i])) {
+                if (!IsGoodTypesForPushdownCompare(*itemsOne[i], *itemsTwo[i], allowOlapApply)) {
                     return false;
                 }
             }
             return true;
         }
         case ETypeAnnotationKind::Data:
-            return IsGoodTypeForComparsionPushdown(typeOne) && IsGoodTypeForComparsionPushdown(typeTwo);
+            return IsGoodTypeForComparsionPushdown(typeOne, allowOlapApply) && IsGoodTypeForComparsionPushdown(typeTwo, allowOlapApply);
         default:
             break;
     }
     return false;
 }
 
-bool CheckComparisonParametersForPushdown(const TCoCompare& compare, const TExprNode* lambdaArg, const TExprBase& input) {
+bool CheckComparisonParametersForPushdown(const TCoCompare& compare, const TExprNode* lambdaArg, const TExprBase& input, bool allowOlapApply) {
     const auto* inputType = input.Ref().GetTypeAnn();
     switch (inputType->GetKind()) {
         case ETypeAnnotationKind::Flow:
@@ -243,7 +239,7 @@ bool CheckComparisonParametersForPushdown(const TCoCompare& compare, const TExpr
         return false;
     }
 
-    if (!IsGoodTypesForPushdownCompare(*compare.Left().Ref().GetTypeAnn(), *compare.Right().Ref().GetTypeAnn())) {
+    if (!IsGoodTypesForPushdownCompare(*compare.Left().Ref().GetTypeAnn(), *compare.Right().Ref().GetTypeAnn(), allowOlapApply)) {
         return false;
     }
 
@@ -252,7 +248,7 @@ bool CheckComparisonParametersForPushdown(const TCoCompare& compare, const TExpr
     YQL_ENSURE(leftList.size() == rightList.size(), "Different sizes of lists in comparison!");
 
     for (size_t i = 0; i < leftList.size(); ++i) {
-        if (!CheckExpressionNodeForPushdown(leftList[i], lambdaArg) || !CheckExpressionNodeForPushdown(rightList[i], lambdaArg)) {
+        if (!CheckExpressionNodeForPushdown(leftList[i], lambdaArg, allowOlapApply) || !CheckExpressionNodeForPushdown(rightList[i], lambdaArg, allowOlapApply)) {
             return false;
         }
     }
@@ -260,11 +256,11 @@ bool CheckComparisonParametersForPushdown(const TCoCompare& compare, const TExpr
     return true;
 }
 
-bool CompareCanBePushed(const TCoCompare& compare, const TExprNode* lambdaArg, const TExprBase& lambdaBody) {
-    return IsSupportedPredicate(compare) && CheckComparisonParametersForPushdown(compare, lambdaArg, lambdaBody);
+bool CompareCanBePushed(const TCoCompare& compare, const TExprNode* lambdaArg, const TExprBase& lambdaBody, bool allowOlapApply) {
+    return IsSupportedPredicate(compare) && CheckComparisonParametersForPushdown(compare, lambdaArg, lambdaBody, allowOlapApply);
 }
 
-bool SafeCastCanBePushed(const TCoFlatMap& flatmap, const TExprNode* lambdaArg) {
+bool SafeCastCanBePushed(const TCoFlatMap& flatmap, const TExprNode* lambdaArg, bool allowOlapApply) {
     /*
      * There are three ways of comparison in following format:
      *
@@ -285,7 +281,7 @@ bool SafeCastCanBePushed(const TCoFlatMap& flatmap, const TExprNode* lambdaArg)
     YQL_ENSURE(leftList.size() == rightList.size(), "Different sizes of lists in comparison!");
 
     for (size_t i = 0; i < leftList.size(); ++i) {
-        if (!CheckExpressionNodeForPushdown(leftList[i], lambdaArg) || !CheckExpressionNodeForPushdown(rightList[i], lambdaArg)) {
+        if (!CheckExpressionNodeForPushdown(leftList[i], lambdaArg, allowOlapApply) || !CheckExpressionNodeForPushdown(rightList[i], lambdaArg, allowOlapApply)) {
             return false;
         }
     }
@@ -319,16 +315,16 @@ bool JsonExistsCanBePushed(const TCoJsonExists& jsonExists, const TExprNode* lam
     return true;
 }
 
-bool CoalesceCanBePushed(const TCoCoalesce& coalesce, const TExprNode* lambdaArg, const TExprBase& lambdaBody) {
+bool CoalesceCanBePushed(const TCoCoalesce& coalesce, const TExprNode* lambdaArg, const TExprBase& lambdaBody, bool allowOlapApply) {
     if (!coalesce.Value().Maybe<TCoBool>()) {
         return false;
     }
 
     const auto predicate = coalesce.Predicate();
     if (const auto maybeCompare = predicate.Maybe<TCoCompare>()) {
-        return CompareCanBePushed(maybeCompare.Cast(), lambdaArg, lambdaBody);
+        return CompareCanBePushed(maybeCompare.Cast(), lambdaArg, lambdaBody, allowOlapApply);
     } else if (const auto maybeFlatmap = predicate.Maybe<TCoFlatMap>()) {
-        return SafeCastCanBePushed(maybeFlatmap.Cast(), lambdaArg);
+        return SafeCastCanBePushed(maybeFlatmap.Cast(), lambdaArg, allowOlapApply);
     } else if (const auto maybeJsonExists = predicate.Maybe<TCoJsonExists>()) {
         return JsonExistsCanBePushed(maybeJsonExists.Cast(), lambdaArg);
     }
@@ -340,47 +336,42 @@ bool ExistsCanBePushed(const TCoExists& exists, const TExprNode* lambdaArg) {
     return IsMemberColumn(exists.Optional(), lambdaArg);
 }
 
-void CollectChildrenPredicates(const TExprNode& opNode, TOLAPPredicateNode& predicateTree, const TExprNode* lambdaArg, const TExprBase& lambdaBody) {
+void CollectChildrenPredicates(const TExprNode& opNode, TOLAPPredicateNode& predicateTree, const TExprNode* lambdaArg, const TExprBase& lambdaBody, bool allowOlapApply) {
     predicateTree.Children.reserve(opNode.ChildrenSize());
     predicateTree.CanBePushed = true;
     for (const auto& childNodePtr: opNode.Children()) {
         TOLAPPredicateNode child;
         child.ExprNode = childNodePtr;
         if (const auto maybeCtor = TMaybeNode<TCoDataCtor>(child.ExprNode))
-            child.CanBePushed = IsSupportedDataType(maybeCtor.Cast());
+            child.CanBePushed = IsSupportedDataType(maybeCtor.Cast(), allowOlapApply);
         else
-            CollectPredicates(TExprBase(child.ExprNode), child, lambdaArg, lambdaBody);
+            CollectPredicates(TExprBase(child.ExprNode), child, lambdaArg, lambdaBody, allowOlapApply);
         predicateTree.Children.emplace_back(child);
         predicateTree.CanBePushed &= child.CanBePushed;
     }
 }
 
-}
-
-void CollectPredicates(const TExprBase& predicate, TOLAPPredicateNode& predicateTree, const TExprNode* lambdaArg, const TExprBase& lambdaBody) {
-    if constexpr (NKikimr::NSsa::RuntimeVersion >= 5U) {
-        if (predicate.Maybe<TCoIf>() || predicate.Maybe<TCoJust>() || predicate.Maybe<TCoCoalesce>()) {
-            return CollectChildrenPredicates(predicate.Ref(), predicateTree, lambdaArg, lambdaBody);
-        }
-    }
+} // namespace
 
+void CollectPredicates(const TExprBase& predicate, TOLAPPredicateNode& predicateTree, const TExprNode* lambdaArg, const TExprBase& lambdaBody, bool allowOlapApply) {
     if (predicate.Maybe<TCoNot>() || predicate.Maybe<TCoAnd>() || predicate.Maybe<TCoOr>() || predicate.Maybe<TCoXor>()) {
-        return CollectChildrenPredicates(predicate.Ref(), predicateTree, lambdaArg, lambdaBody);
+        return CollectChildrenPredicates(predicate.Ref(), predicateTree, lambdaArg, lambdaBody, allowOlapApply);
     } else if (const auto maybeCoalesce = predicate.Maybe<TCoCoalesce>()) {
-        predicateTree.CanBePushed = CoalesceCanBePushed(maybeCoalesce.Cast(), lambdaArg, lambdaBody);
+        predicateTree.CanBePushed = CoalesceCanBePushed(maybeCoalesce.Cast(), lambdaArg, lambdaBody, allowOlapApply);
     } else if (const auto maybeCompare = predicate.Maybe<TCoCompare>()) {
-        predicateTree.CanBePushed = CompareCanBePushed(maybeCompare.Cast(), lambdaArg, lambdaBody);
+        predicateTree.CanBePushed = CompareCanBePushed(maybeCompare.Cast(), lambdaArg, lambdaBody, allowOlapApply);
     } else if (const auto maybeExists = predicate.Maybe<TCoExists>()) {
         predicateTree.CanBePushed = ExistsCanBePushed(maybeExists.Cast(), lambdaArg);
     } else if (const auto maybeJsonExists = predicate.Maybe<TCoJsonExists>()) {
         predicateTree.CanBePushed = JsonExistsCanBePushed(maybeJsonExists.Cast(), lambdaArg);
-    } else {
-        if constexpr (NKikimr::NSsa::RuntimeVersion >= 5U) {
-            predicateTree.CanBePushed = AbstractTreeCanBePushed(predicate, lambdaArg);
-        } else {
-            predicateTree.CanBePushed = false;
+    }
+    if (predicateTree.CanBePushed) {
+        return;
+    } else if (allowOlapApply){
+        if (predicate.Maybe<TCoIf>() || predicate.Maybe<TCoJust>() || predicate.Maybe<TCoCoalesce>()) {
+            return CollectChildrenPredicates(predicate.Ref(), predicateTree, lambdaArg, lambdaBody, allowOlapApply);
         }
+        predicateTree.CanBePushed =  AbstractTreeCanBePushed(predicate, lambdaArg);
     }
 }
-
-}
+} //namespace NKikimr::NKqp::NOpt
diff --git a/ydb/core/kqp/opt/physical/predicate_collector.h b/ydb/core/kqp/opt/physical/predicate_collector.h
index d6663c9d6ab0..f65ac2ebdd45 100644
--- a/ydb/core/kqp/opt/physical/predicate_collector.h
+++ b/ydb/core/kqp/opt/physical/predicate_collector.h
@@ -15,6 +15,6 @@ struct TOLAPPredicateNode {
     }
 };
 
-void CollectPredicates(const NNodes::TExprBase& predicate, TOLAPPredicateNode& predicateTree, const TExprNode* lambdaArg, const NNodes::TExprBase& lambdaBody);
+void CollectPredicates(const NNodes::TExprBase& predicate, TOLAPPredicateNode& predicateTree, const TExprNode* lambdaArg, const NNodes::TExprBase& lambdaBody, bool allowOlapApply);
 
 }
diff --git a/ydb/core/kqp/provider/yql_kikimr_datasink.cpp b/ydb/core/kqp/provider/yql_kikimr_datasink.cpp
index a4202e48c5d8..045207c56815 100644
--- a/ydb/core/kqp/provider/yql_kikimr_datasink.cpp
+++ b/ydb/core/kqp/provider/yql_kikimr_datasink.cpp
@@ -225,6 +225,12 @@ class TKiSinkIntentDeterminationTransformer: public TKiSinkVisitorTransformer {
         return TStatus::Ok;
     }
 
+    TStatus HandleAlterDatabase(TKiAlterDatabase node, TExprContext& ctx) override {
+        Y_UNUSED(ctx);
+        Y_UNUSED(node);
+        return TStatus::Ok;
+    }
+
     TStatus HandleCreateTopic(TKiCreateTopic node, TExprContext& ctx) override {
         Y_UNUSED(ctx);
         Y_UNUSED(node);
@@ -549,7 +555,8 @@ class TKiSinkIntentDeterminationTransformer: public TKiSinkVisitorTransformer {
 
             case TKikimrKey::Type::TableList:
                 break;
-
+            case TKikimrKey::Type::Database:
+                return TStatus::Ok;
             case TKikimrKey::Type::Role:
                 return TStatus::Ok;
             case TKikimrKey::Type::Object:
@@ -724,6 +731,10 @@ class TKikimrDataSink : public TDataProviderBase
     }
 
     bool CanExecute(const TExprNode& node) override {
+        if (node.IsCallable(TKiAlterDatabase::CallableName())) {
+            return true;
+        }
+
         if (node.IsCallable(TKiExecDataQuery::CallableName())) {
             return true;
         }
@@ -1153,6 +1164,23 @@ class TKikimrDataSink : public TDataProviderBase
         YQL_ENSURE(key.Extract(*node->Child(2)), "Failed to extract ydb key.");
 
         switch (key.GetKeyType()) {
+            case TKikimrKey::Type::Database: {
+                NCommon::TDatabaseSettings settings = NCommon::ParseDatabaseSettings(TExprList(node->Child(4)), ctx);
+                YQL_ENSURE(settings.Mode);
+                auto mode = settings.Mode.Cast();
+
+                if (mode == "alterDatabase") {
+                    return Build<TKiAlterDatabase>(ctx, node->Pos())
+                        .World(node->Child(0))
+                        .DataSink(node->Child(1))
+                        .DatabasePath().Build(key.GetDatabasePath())
+                        .Settings(settings.Other)
+                        .Done()
+                        .Ptr();
+                }
+
+                break;
+            }
             case TKikimrKey::Type::Table: {
                 NCommon::TWriteTableSettings settings = NCommon::ParseWriteTableSettings(TExprList(node->Child(4)), ctx);
                 YQL_ENSURE(settings.Mode);
@@ -1954,6 +1982,10 @@ IGraphTransformer::TStatus TKiSinkVisitorTransformer::DoTransform(TExprNode::TPt
 
     auto callable = TCallable(input);
 
+    if (auto node = callable.Maybe<TKiAlterDatabase>()) {
+        return HandleAlterDatabase(node.Cast(), ctx);
+    }
+
     if (auto node = callable.Maybe<TKiWriteTable>()) {
         return HandleWriteTable(node.Cast(), ctx);
     }
diff --git a/ydb/core/kqp/provider/yql_kikimr_datasource.cpp b/ydb/core/kqp/provider/yql_kikimr_datasource.cpp
index 731bcaa10526..89c224b295f2 100644
--- a/ydb/core/kqp/provider/yql_kikimr_datasource.cpp
+++ b/ydb/core/kqp/provider/yql_kikimr_datasource.cpp
@@ -136,6 +136,9 @@ class TKiSourceIntentDeterminationTransformer: public TKiSourceVisitorTransforme
 private:
     TStatus HandleKey(const TStringBuf& cluster, const TKikimrKey& key) {
         switch (key.GetKeyType()) {
+            case TKikimrKey::Type::Database:
+                return TStatus::Ok;
+
             case TKikimrKey::Type::Table:
             case TKikimrKey::Type::TableScheme: {
                 auto& table = SessionCtx->Tables().GetOrAddTable(TString(cluster), SessionCtx->GetDatabase(),
@@ -617,6 +620,7 @@ class TKikimrDataSource : public TDataProviderBase {
                 node.IsCallable(TDqSourceWideBlockWrap::CallableName()) ||
                 node.IsCallable(TDqReadWrap::CallableName()) ||
                 node.IsCallable(TDqReadWideWrap::CallableName()) ||
+                node.IsCallable(TDqReadBlockWideWrap::CallableName()) ||
                 node.IsCallable(TDqSource::CallableName())
             )
         )
diff --git a/ydb/core/kqp/provider/yql_kikimr_exec.cpp b/ydb/core/kqp/provider/yql_kikimr_exec.cpp
index 58869268fd3a..6bef12c2e7a2 100644
--- a/ydb/core/kqp/provider/yql_kikimr_exec.cpp
+++ b/ydb/core/kqp/provider/yql_kikimr_exec.cpp
@@ -100,13 +100,31 @@ namespace {
         return permissionsSettings;
     }
 
+    TAlterDatabaseSettings ParseAlterDatabaseSettings(TKiAlterDatabase alterDatabase) {
+        TAlterDatabaseSettings alterDatabaseSettings;
+        YQL_ENSURE(alterDatabase.DatabasePath().Value().size() > 0);
+        alterDatabaseSettings.DatabasePath = alterDatabase.DatabasePath().Value();
+
+        for (auto setting : alterDatabase.Settings()) {
+            const auto& name = setting.Name().Value();
+
+            if (name == "owner") {
+                alterDatabaseSettings.Owner = setting.Value().Cast<TCoAtom>().StringValue();
+            } else {
+                YQL_ENSURE(false);
+            }
+        }
+
+        return alterDatabaseSettings;
+    }
+
     TCreateUserSettings ParseCreateUserSettings(TKiCreateUser createUser) {
         TCreateUserSettings createUserSettings;
         createUserSettings.UserName = TString(createUser.UserName());
         createUserSettings.CanLogin = true;
 
         for (auto setting : createUser.Settings()) {
-            auto name = setting.Name().Value();
+            const auto& name = setting.Name().Value();
             if (name == "password") {
                 createUserSettings.Password = setting.Value().Cast<TCoAtom>().StringValue();
             } else if (name == "nullPassword") {
@@ -120,6 +138,8 @@ namespace {
                 createUserSettings.CanLogin = true;
             } else if (name == "noLogin") {
                 createUserSettings.CanLogin = false;
+            } else {
+                YQL_ENSURE(false);
             }
         }
         return createUserSettings;
@@ -130,7 +150,7 @@ namespace {
         alterUserSettings.UserName = TString(alterUser.UserName());
 
         for (auto setting : alterUser.Settings()) {
-            auto name = setting.Name().Value();
+            const auto& name = setting.Name().Value();
             if (name == "password") {
                 alterUserSettings.Password = setting.Value().Cast<TCoAtom>().StringValue();
             } else if (name == "nullPassword") {
@@ -144,6 +164,8 @@ namespace {
                 alterUserSettings.CanLogin = true;
             } else if (name == "noLogin") {
                 alterUserSettings.CanLogin = false;
+            } else {
+                YQL_ENSURE(false);
             }
         }
         return alterUserSettings;
@@ -1290,6 +1312,25 @@ class TKiSinkCallableExecutionTransformer : public TAsyncCallbackTransformer<TKi
             return SyncOk();
         }
 
+        if (auto maybeAlterDatabase = TMaybeNode<TKiAlterDatabase>(input)) {
+            auto requireStatus = RequireChild(*input, TKiExecDataQuery::idx_World);
+            if (requireStatus.Level != TStatus::Ok) {
+                return SyncStatus(requireStatus);
+            }
+
+            auto cluster = TString(maybeAlterDatabase.Cast().DataSink().Cluster());
+            TAlterDatabaseSettings alterDatabaseSettings = ParseAlterDatabaseSettings(maybeAlterDatabase.Cast());
+
+            auto future = Gateway->AlterDatabase(cluster, alterDatabaseSettings);
+
+            return WrapFuture(future,
+                [](const IKikimrGateway::TGenericResult& res, const TExprNode::TPtr& input, TExprContext& ctx) {
+                Y_UNUSED(res);
+                auto resultNode = ctx.NewWorld(input->Pos());
+                return resultNode;
+            }, "Executing ALTER DATABASE");
+        }
+
         if (auto maybeCreate = TMaybeNode<TKiCreateTable>(input)) {
             auto requireStatus = RequireChild(*input, 0);
             if (requireStatus.Level != TStatus::Ok) {
@@ -1413,10 +1454,6 @@ class TKiSinkCallableExecutionTransformer : public TAsyncCallbackTransformer<TKi
                     auto resultNode = ctx.NewWorld(input->Pos());
                     return resultNode;
                 }, GetDropTableDebugString(tableTypeItem));
-
-            input->SetState(TExprNode::EState::ExecutionComplete);
-            input->SetResult(ctx.NewWorld(input->Pos()));
-            return SyncOk();
         }
 
         if (auto maybeAlter = TMaybeNode<TKiAlterTable>(input)) {
diff --git a/ydb/core/kqp/provider/yql_kikimr_expr_nodes.json b/ydb/core/kqp/provider/yql_kikimr_expr_nodes.json
index 86f1b84023e3..76ae5ffb828a 100644
--- a/ydb/core/kqp/provider/yql_kikimr_expr_nodes.json
+++ b/ydb/core/kqp/provider/yql_kikimr_expr_nodes.json
@@ -25,6 +25,17 @@
                 {"Index": 1, "Name": "Cluster", "Type": "TCoAtom"}
             ]
         },
+        {
+            "Name": "TKiAlterDatabase",
+            "Base": "TCallable",
+            "Match": {"Type": "Callable", "Name": "KiAlterDatabase!"},
+            "Children": [
+                {"Index": 0, "Name": "World", "Type": "TExprBase"},
+                {"Index": 1, "Name": "DataSink", "Type": "TKiDataSink"},
+                {"Index": 2, "Name": "DatabasePath", "Type": "TCoAtom"},
+                {"Index": 3, "Name": "Settings", "Type": "TCoNameValueTupleList"}
+            ]
+        },
         {
             "Name": "TKiVersionedTable",
             "Base": "TExprBase",
diff --git a/ydb/core/kqp/provider/yql_kikimr_gateway.h b/ydb/core/kqp/provider/yql_kikimr_gateway.h
index c45b1ceb959c..d6ae138c15c9 100644
--- a/ydb/core/kqp/provider/yql_kikimr_gateway.h
+++ b/ydb/core/kqp/provider/yql_kikimr_gateway.h
@@ -667,6 +667,11 @@ struct TKikimrTableMetadata : public TThrRefBase {
     }
 };
 
+struct TAlterDatabaseSettings {
+    TString DatabasePath;
+    std::optional<TString> Owner;
+};
+
 struct TCreateUserSettings {
     TString UserName;
     TString Password;
@@ -1123,6 +1128,8 @@ class IKikimrGateway : public TThrRefBase {
     virtual NThreading::TFuture<TTableMetadataResult> LoadTableMetadata(
         const TString& cluster, const TString& table, TLoadTableMetadataSettings settings) = 0;
 
+    virtual NThreading::TFuture<TGenericResult> AlterDatabase(const TString& cluster, const TAlterDatabaseSettings& settings) = 0;
+
     virtual NThreading::TFuture<TGenericResult> CreateTable(TKikimrTableMetadataPtr metadata, bool createDir, bool existingOk = false, bool replaceIfExists = false) = 0;
 
     virtual NThreading::TFuture<TGenericResult> SendSchemeExecuterRequest(const TString& cluster,
diff --git a/ydb/core/kqp/provider/yql_kikimr_opt_build.cpp b/ydb/core/kqp/provider/yql_kikimr_opt_build.cpp
index 0c4812371e3d..5bccf947583d 100644
--- a/ydb/core/kqp/provider/yql_kikimr_opt_build.cpp
+++ b/ydb/core/kqp/provider/yql_kikimr_opt_build.cpp
@@ -688,6 +688,17 @@ bool ExploreNode(TExprBase node, TExprContext& ctx, const TKiDataSink& dataSink,
         return true;
     }
 
+    if (auto maybeAlterDatabase = node.Maybe<TKiAlterDatabase>()) {
+        auto alterDatabase = maybeAlterDatabase.Cast();
+        if (!checkDataSink(alterDatabase.DataSink())) {
+            return false;
+        }
+
+        txRes.Ops.insert(node.Raw());
+        txRes.AddTableOperation(BuildYdbOpNode(cluster, TYdbOperation::AlterDatabase, alterDatabase.Pos(), ctx));
+        return true;
+    }
+
     if (node.Maybe<TCoCommit>()) {
         return true;
     }
diff --git a/ydb/core/kqp/provider/yql_kikimr_provider.cpp b/ydb/core/kqp/provider/yql_kikimr_provider.cpp
index 587fa657cd50..330bd19957b3 100644
--- a/ydb/core/kqp/provider/yql_kikimr_provider.cpp
+++ b/ydb/core/kqp/provider/yql_kikimr_provider.cpp
@@ -40,6 +40,8 @@ struct TKikimrData {
         DataSourceNames.insert(TKiReadTableScheme::CallableName());
         DataSourceNames.insert(TKiReadTableList::CallableName());
 
+        DataSinkNames.insert(TKiAlterDatabase::CallableName());
+
         DataSinkNames.insert(TKiWriteTable::CallableName());
         DataSinkNames.insert(TKiUpdateTable::CallableName());
         DataSinkNames.insert(TKiDeleteTable::CallableName());
@@ -113,6 +115,7 @@ struct TKikimrData {
         DataOps = ModifyOps | ReadOps;
 
         SchemeOps =
+            TYdbOperation::AlterDatabase |
             TYdbOperation::CreateTable |
             TYdbOperation::DropTable |
             TYdbOperation::AlterTable |
@@ -465,6 +468,9 @@ bool TKikimrKey::Extract(const TExprNode& key) {
         KeyType = Type::BackupCollection;
         Target = key.Child(0)->Child(1)->Child(0)->Content();
         ExplicitPrefix = key.Child(0)->Child(2)->Child(0)->Content();
+    } else if (tagName == "databasePath") {
+        KeyType = Type::Database;
+        Target = key.Child(0)->Child(1)->Child(0)->Content();
     } else {
         Ctx.AddError(TIssue(Ctx.GetPosition(key.Child(0)->Pos()), TString("Unexpected tag for kikimr key: ") + tagName));
         return false;
diff --git a/ydb/core/kqp/provider/yql_kikimr_provider.h b/ydb/core/kqp/provider/yql_kikimr_provider.h
index 789e1db8ccf0..9db6cfb305a5 100644
--- a/ydb/core/kqp/provider/yql_kikimr_provider.h
+++ b/ydb/core/kqp/provider/yql_kikimr_provider.h
@@ -254,6 +254,7 @@ enum class TYdbOperation : ui64 {
     CreateTransfer         = 1ull << 34,
     AlterTransfer          = 1ull << 35,
     DropTransfer           = 1ull << 36,
+    AlterDatabase          = 1ull << 37,
 };
 
 Y_DECLARE_FLAGS(TYdbOperations, TYdbOperation);
diff --git a/ydb/core/kqp/provider/yql_kikimr_provider_impl.h b/ydb/core/kqp/provider/yql_kikimr_provider_impl.h
index 0a15fff6d8cd..3c37d2b4f079 100644
--- a/ydb/core/kqp/provider/yql_kikimr_provider_impl.h
+++ b/ydb/core/kqp/provider/yql_kikimr_provider_impl.h
@@ -31,6 +31,8 @@ class TKiSinkVisitorTransformer : public TSyncTransformerBase {
     void Rewind() override {
     }
 private:
+    virtual TStatus HandleAlterDatabase(NNodes::TKiAlterDatabase node, TExprContext& ctx) = 0;
+
     virtual TStatus HandleWriteTable(NNodes::TKiWriteTable node, TExprContext& ctx) = 0;
     virtual TStatus HandleUpdateTable(NNodes::TKiUpdateTable node, TExprContext& ctx) = 0;
     virtual TStatus HandleDeleteTable(NNodes::TKiDeleteTable node, TExprContext& ctx) = 0;
@@ -91,6 +93,7 @@ class TKiSinkVisitorTransformer : public TSyncTransformerBase {
 class TKikimrKey {
 public:
     enum class Type {
+        Database,
         Table,
         TableList,
         TableScheme,
@@ -130,6 +133,12 @@ class TKikimrKey {
         return Target;
     }
 
+    TString GetDatabasePath() const {
+        Y_DEBUG_ABORT_UNLESS(KeyType.Defined());
+        Y_DEBUG_ABORT_UNLESS(KeyType == Type::Database);
+        return Target;
+    }
+
     TString GetTopicPath() const {
         Y_DEBUG_ABORT_UNLESS(KeyType.Defined());
         Y_DEBUG_ABORT_UNLESS(KeyType == Type::Topic);
diff --git a/ydb/core/kqp/provider/yql_kikimr_settings.cpp b/ydb/core/kqp/provider/yql_kikimr_settings.cpp
index 07cfe81b23dd..36bf85a0f50c 100644
--- a/ydb/core/kqp/provider/yql_kikimr_settings.cpp
+++ b/ydb/core/kqp/provider/yql_kikimr_settings.cpp
@@ -93,6 +93,7 @@ TKikimrConfiguration::TKikimrConfiguration() {
     REGISTER_SETTING(*this, CostBasedOptimizationLevel);
     REGISTER_SETTING(*this, EnableSpillingNodes)
         .Parser([](const TString& v) { return ParseEnableSpillingNodes(v); });
+    REGISTER_SETTING(*this, UseBlockReader);
 
     REGISTER_SETTING(*this, MaxDPHypDPTableSize);
 
diff --git a/ydb/core/kqp/provider/yql_kikimr_settings.h b/ydb/core/kqp/provider/yql_kikimr_settings.h
index 80f13ef811c6..3d7365c954fb 100644
--- a/ydb/core/kqp/provider/yql_kikimr_settings.h
+++ b/ydb/core/kqp/provider/yql_kikimr_settings.h
@@ -69,6 +69,7 @@ struct TKikimrSettings {
     NCommon::TConfSetting<bool, false> OptEnableOlapProvideComputeSharding;
     NCommon::TConfSetting<bool, false> OptUseFinalizeByKey;
     NCommon::TConfSetting<ui32, false> CostBasedOptimizationLevel;
+    NCommon::TConfSetting<bool, false> UseBlockReader;
 
     NCommon::TConfSetting<ui32, false> MaxDPHypDPTableSize;
 
diff --git a/ydb/core/kqp/provider/yql_kikimr_type_ann.cpp b/ydb/core/kqp/provider/yql_kikimr_type_ann.cpp
index 194229e36dc1..b28857f6e179 100644
--- a/ydb/core/kqp/provider/yql_kikimr_type_ann.cpp
+++ b/ydb/core/kqp/provider/yql_kikimr_type_ann.cpp
@@ -198,6 +198,11 @@ class TKiSourceTypeAnnotationTransformer : public TKiSourceVisitorTransformer {
                 return TStatus::Ok;
             }
 
+            case TKikimrKey::Type::Database:
+            {
+                return TStatus::Ok;
+            }
+
             case TKikimrKey::Type::Role:
             {
                 return TStatus::Ok;
@@ -1885,6 +1890,40 @@ virtual TStatus HandleCreateTable(TKiCreateTable create, TExprContext& ctx) over
         return TStatus::Ok;
     }
 
+    virtual TStatus HandleAlterDatabase(NNodes::TKiAlterDatabase node, TExprContext& ctx) override {
+        if (!SessionCtx->Config().FeatureFlags.GetEnableAlterDatabase()) {
+            ctx.AddError(TIssue(ctx.GetPosition(node.Pos()),
+                TStringBuilder() << "ALTER DATABASE statement is not supported"));
+            return TStatus::Error;
+        }
+
+        if (!node.DatabasePath().Value()) {
+                ctx.AddError(TIssue(ctx.GetPosition(node.DatabasePath().Pos()), "DatabasePath can't be empty."));
+            return TStatus::Error;
+        }
+
+        const THashSet<TString> supportedSettings = {
+            "owner"
+        };
+
+        for (const auto& setting : node.Settings()) {
+            auto name = setting.Name().Value();
+
+            if (!supportedSettings.contains(name)) {
+                ctx.AddError(TIssue(ctx.GetPosition(setting.Name().Pos()),
+                    TStringBuilder() << "Unknown create user setting: " << name));
+                return TStatus::Error;
+            }
+
+            if (!EnsureAtom(setting.Value().Ref(), ctx)) {
+                return TStatus::Error;
+            }
+        }
+
+        node.Ptr()->SetTypeAnn(node.World().Ref().GetTypeAnn());
+        return TStatus::Ok;
+    }
+
     virtual TStatus HandleCreateUser(TKiCreateUser node, TExprContext& ctx) override {
         const THashSet<TString> supportedSettings = {
             "password",
diff --git a/ydb/core/kqp/query_compiler/kqp_mkql_compiler.cpp b/ydb/core/kqp/query_compiler/kqp_mkql_compiler.cpp
index fa57a3889940..6158910b6b9a 100644
--- a/ydb/core/kqp/query_compiler/kqp_mkql_compiler.cpp
+++ b/ydb/core/kqp/query_compiler/kqp_mkql_compiler.cpp
@@ -197,7 +197,7 @@ TKqpKeyRange MakeKeyRange(const TKqlReadTableBase& readTable, const TKqlCompileC
     if (settings.ItemsLimit) {
         keyRange.ItemsLimit = MkqlBuildExpr(*settings.ItemsLimit, buildCtx);
     }
-    keyRange.Reverse = settings.Reverse;
+    keyRange.Reverse = settings.IsReverse();
 
     return keyRange;
 }
@@ -210,7 +210,7 @@ TKqpKeyRanges MakeComputedKeyRanges(const TKqlReadTableRangesBase& readTable, co
     TKqpKeyRanges ranges = {
         .Ranges = MkqlBuildExpr(readTable.Ranges().Ref(), buildCtx),
         .ItemsLimit = settings.ItemsLimit ? MkqlBuildExpr(*settings.ItemsLimit, buildCtx) : ctx.PgmBuilder().NewNull(),
-        .Reverse = settings.Reverse,
+        .Reverse = settings.IsReverse(),
     };
 
     return ranges;
diff --git a/ydb/core/kqp/query_compiler/kqp_olap_compiler.cpp b/ydb/core/kqp/query_compiler/kqp_olap_compiler.cpp
index 326de9203b06..ba0f3136039e 100644
--- a/ydb/core/kqp/query_compiler/kqp_olap_compiler.cpp
+++ b/ydb/core/kqp/query_compiler/kqp_olap_compiler.cpp
@@ -279,7 +279,6 @@ ui64 GetOrCreateColumnId(const TExprBase& node, TKqpOlapCompileContext& ctx);
 
 ui64 ConvertValueToColumn(const TCoDataCtor& value, TKqpOlapCompileContext& ctx)
 {
-    constexpr bool yqlTypes = NKikimr::NSsa::RuntimeVersion >= 4U;
     auto *const ssaValue = ctx.CreateAssignCmd();
     const auto& nodeValue = value.Cast<TCoDataCtor>().Literal().Value();
     if (value.Maybe<TCoUtf8>()) {
@@ -287,38 +286,23 @@ ui64 ConvertValueToColumn(const TCoDataCtor& value, TKqpOlapCompileContext& ctx)
     } else if (value.Maybe<TCoString>()) {
         ssaValue->MutableConstant()->SetBytes(TString(nodeValue));
     } else if (value.Maybe<TCoBool>()) {
-        if constexpr (yqlTypes)
-            ssaValue->MutableConstant()->SetUint8(FromString<bool>(nodeValue) ? 1U : 0U);
-        else
-            ssaValue->MutableConstant()->SetBool(FromString<bool>(nodeValue));
+        ssaValue->MutableConstant()->SetUint8(FromString<bool>(nodeValue) ? 1U : 0U);
     } else if (value.Maybe<TCoFloat>()) {
         ssaValue->MutableConstant()->SetFloat(FromString<float>(nodeValue));
     } else if (value.Maybe<TCoDouble>()) {
         ssaValue->MutableConstant()->SetDouble(FromString<double>(nodeValue));
     } else if (value.Maybe<TCoInt8>()) {
-        if constexpr (yqlTypes)
-            ssaValue->MutableConstant()->SetInt8(FromString<i8>(nodeValue));
-        else
-            ssaValue->MutableConstant()->SetInt32(FromString<i32>(nodeValue));
+        ssaValue->MutableConstant()->SetInt8(FromString<i8>(nodeValue));
     } else if (value.Maybe<TCoInt16>()) {
-        if constexpr (yqlTypes)
-            ssaValue->MutableConstant()->SetInt16(FromString<i16>(nodeValue));
-        else
-            ssaValue->MutableConstant()->SetInt32(FromString<i32>(nodeValue));
+        ssaValue->MutableConstant()->SetInt16(FromString<i16>(nodeValue));
     } else if (value.Maybe<TCoInt32>() || value.Maybe<TCoDate32>()) {
         ssaValue->MutableConstant()->SetInt32(FromString<i32>(nodeValue));
     } else if (value.Maybe<TCoInt64>() || value.Maybe<TCoInterval64>() || value.Maybe<TCoDatetime64>() || value.Maybe<TCoTimestamp64>()) {
         ssaValue->MutableConstant()->SetInt64(FromString<i64>(nodeValue));
     } else if (value.Maybe<TCoUint8>()) {
-        if constexpr (yqlTypes)
-            ssaValue->MutableConstant()->SetUint8(FromString<ui8>(nodeValue));
-        else
-            ssaValue->MutableConstant()->SetUint32(FromString<ui32>(nodeValue));
+        ssaValue->MutableConstant()->SetUint8(FromString<ui8>(nodeValue));
     } else if (value.Maybe<TCoUint16>()) {
-        if constexpr (yqlTypes)
-            ssaValue->MutableConstant()->SetUint16(FromString<ui16>(nodeValue));
-        else
-            ssaValue->MutableConstant()->SetUint32(FromString<ui32>(nodeValue));
+        ssaValue->MutableConstant()->SetUint16(FromString<ui16>(nodeValue));
     } else if (value.Maybe<TCoUint32>()) {
         ssaValue->MutableConstant()->SetUint32(FromString<ui32>(nodeValue));
     } else if (value.Maybe<TCoUint64>()) {
@@ -408,8 +392,6 @@ struct TTypedColumn {
 };
 
 const TTypedColumn ConvertJsonValueToColumn(const TKqpOlapJsonValue& jsonValueCallable, TKqpOlapCompileContext& ctx) {
-    Y_ABORT_UNLESS(NKikimr::NSsa::RuntimeVersion >= 3, "JSON_VALUE pushdown is supported starting from the v3 of SSA runtime.");
-
     const auto columnId = GetOrCreateColumnId(jsonValueCallable.Column(), ctx);
     const auto pathId = GetOrCreateColumnId(jsonValueCallable.Path(), ctx);
 
@@ -433,8 +415,6 @@ const TTypedColumn ConvertJsonValueToColumn(const TKqpOlapJsonValue& jsonValueCa
 }
 
 const TTypedColumn CompileJsonExists(const TKqpOlapJsonExists& jsonExistsCallable, TKqpOlapCompileContext& ctx) {
-    Y_ABORT_UNLESS(NKikimr::NSsa::RuntimeVersion >= 3, "JSON_EXISTS pushdown is supported starting from the v3 of SSA runtime.");
-
     const auto columnId = GetOrCreateColumnId(jsonExistsCallable.Column(), ctx);
     const auto pathId = GetOrCreateColumnId(jsonExistsCallable.Path(), ctx);
 
@@ -453,11 +433,7 @@ const TTypedColumn CompileJsonExists(const TKqpOlapJsonExists& jsonExistsCallabl
     jsonExistsFunc->SetKernelName("JsonExists");
     jsonExistsFunc->SetKernelIdx(idx);
 
-    if constexpr (NSsa::RuntimeVersion >= 4U) {
-        return {ConvertSafeCastToColumn(command->GetColumn().GetId(), "Uint8", ctx), ctx.ConvertToBlockType(type)};
-    } else {
-        return {command->GetColumn().GetId(), ctx.ConvertToBlockType(type)};
-    }
+    return {ConvertSafeCastToColumn(command->GetColumn().GetId(), "Uint8", ctx), ctx.ConvertToBlockType(type)};
 }
 
 ui64 GetOrCreateColumnId(const TExprBase& node, TKqpOlapCompileContext& ctx) {
@@ -498,42 +474,35 @@ ui64 CompileYqlKernelComparison(const TKqpOlapFilterBinaryOp& comparison, TKqpOl
     auto *const cmpFunc = command->MutableFunction();
 
     ui32 function = TProgram::TAssignment::FUNC_UNSPECIFIED;
-    bool isYqlKernelsSupported = (NKikimr::NSsa::RuntimeVersion >= 3);
     bool needCastToBool = false;
 
     if (comparison.Operator() == "string_contains") {
         function = TProgram::TAssignment::FUNC_STR_MATCH;
-        if (isYqlKernelsSupported) {
-            cmpFunc->SetFunctionType(TProgram::YQL_KERNEL);
-            auto idx = ctx.AddYqlKernelBinaryFunc(comparison.Pos(), TKernelRequestBuilder::EBinaryOp::StringContains,
-                comparison.Left(),
-                comparison.Right(),
-                ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool));
-            cmpFunc->SetKernelIdx(idx);
-            needCastToBool = true;
-        }
+        cmpFunc->SetFunctionType(TProgram::YQL_KERNEL);
+        auto idx = ctx.AddYqlKernelBinaryFunc(comparison.Pos(), TKernelRequestBuilder::EBinaryOp::StringContains,
+            comparison.Left(),
+            comparison.Right(),
+            ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool));
+        cmpFunc->SetKernelIdx(idx);
+        needCastToBool = true;
     } else if (comparison.Operator() == "starts_with") {
         function = TProgram::TAssignment::FUNC_STR_STARTS_WITH;
-        if (isYqlKernelsSupported) {
-            cmpFunc->SetFunctionType(TProgram::YQL_KERNEL);
-            auto idx = ctx.AddYqlKernelBinaryFunc(comparison.Pos(), TKernelRequestBuilder::EBinaryOp::StartsWith,
-                comparison.Left(),
-                comparison.Right(),
-                ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool));
-            cmpFunc->SetKernelIdx(idx);
-            needCastToBool = true;
-        }
+        cmpFunc->SetFunctionType(TProgram::YQL_KERNEL);
+        auto idx = ctx.AddYqlKernelBinaryFunc(comparison.Pos(), TKernelRequestBuilder::EBinaryOp::StartsWith,
+            comparison.Left(),
+            comparison.Right(),
+            ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool));
+        cmpFunc->SetKernelIdx(idx);
+        needCastToBool = true;
     } else if (comparison.Operator() == "ends_with") {
         function = TProgram::TAssignment::FUNC_STR_ENDS_WITH;
-        if (isYqlKernelsSupported) {
-            cmpFunc->SetFunctionType(TProgram::YQL_KERNEL);
-            auto idx = ctx.AddYqlKernelBinaryFunc(comparison.Pos(), TKernelRequestBuilder::EBinaryOp::EndsWith,
-                comparison.Left(),
-                comparison.Right(),
-                ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool));
-            cmpFunc->SetKernelIdx(idx);
-            needCastToBool = true;
-        }
+        cmpFunc->SetFunctionType(TProgram::YQL_KERNEL);
+        auto idx = ctx.AddYqlKernelBinaryFunc(comparison.Pos(), TKernelRequestBuilder::EBinaryOp::EndsWith,
+            comparison.Left(),
+            comparison.Right(),
+            ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool));
+        cmpFunc->SetKernelIdx(idx);
+        needCastToBool = true;
     }
 
     cmpFunc->SetId(function);
@@ -613,19 +582,11 @@ const TTypedColumn CompileExists(const TExprBase& arg, TKqpOlapCompileContext& c
     isNullFunc->AddArguments()->SetId(column.Id);
 
     if constexpr (Empty) {
-        if constexpr (NSsa::RuntimeVersion >= 4U) {
-            return {ConvertSafeCastToColumn(command->GetColumn().GetId(), "Uint8", ctx), ctx.ConvertToBlockType(type)};
-        } else {
-            return {command->GetColumn().GetId(), type};
-        }
+        return {ConvertSafeCastToColumn(command->GetColumn().GetId(), "Uint8", ctx), ctx.ConvertToBlockType(type)};
     }
 
     auto *const notCommand = InvertResult(command, ctx);
-    if constexpr (NSsa::RuntimeVersion >= 4U) {
-        return {ConvertSafeCastToColumn(notCommand->GetColumn().GetId(), "Uint8", ctx), ctx.ConvertToBlockType(type)};
-    } else {
-        return {notCommand->GetColumn().GetId(), type};
-    }
+    return {ConvertSafeCastToColumn(notCommand->GetColumn().GetId(), "Uint8", ctx), ctx.ConvertToBlockType(type)};
 }
 
 TTypedColumn CompileYqlKernelScalarApply(const TKqpOlapApply& apply, TKqpOlapCompileContext& ctx) {
@@ -639,6 +600,12 @@ TTypedColumn CompileYqlKernelScalarApply(const TKqpOlapApply& apply, TKqpOlapCom
         argTypes.emplace_back(arg.Type);
     }
 
+    for(const auto& param: apply.Parameters()) {
+        const auto& arg = GetOrCreateColumnIdAndType(param, ctx);
+        ids.emplace_back(arg.Id);
+        argTypes.emplace_back(arg.Type);
+    }
+
     auto *const command = ctx.CreateAssignCmd();
     auto *const function = command->MutableFunction();
     const auto idx = ctx.GetKernelRequestBuilder().AddScalarApply(apply.Lambda().Ref(), argTypes, ctx.ExprCtx());
@@ -809,31 +776,21 @@ const TTypedColumn BuildLogicalNot(const TExprBase& arg, TKqpOlapCompileContext&
 
     notFunc->AddArguments()->SetId(value.Id);
 
-    if constexpr (NSsa::RuntimeVersion >= 4U) {
-        const auto block = ctx.ExprCtx().MakeType<TBlockExprType>(ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool));
-        const auto idx = ctx.GetKernelRequestBuilder().AddUnaryOp(TKernelRequestBuilder::EUnaryOp::Not, block, block);
-        notFunc->SetKernelIdx(idx);
-        notFunc->SetFunctionType(TProgram::YQL_KERNEL);
-    } else
-        notFunc->SetId(TProgram::TAssignment::FUNC_BINARY_NOT);
+    const auto block = ctx.ExprCtx().MakeType<TBlockExprType>(ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool));
+    const auto idx = ctx.GetKernelRequestBuilder().AddUnaryOp(TKernelRequestBuilder::EUnaryOp::Not, block, block);
+    notFunc->SetKernelIdx(idx);
+    notFunc->SetFunctionType(TProgram::YQL_KERNEL);
 
     return {notOp->GetColumn().GetId(), value.Type};
 }
 
 TTypedColumn GetOrCreateColumnIdAndType(const TExprBase& node, TKqpOlapCompileContext& ctx) {
     if (const auto& maybeBinaryOp = node.Maybe<TKqpOlapFilterBinaryOp>()) {
-        if constexpr (NSsa::RuntimeVersion >= 4U) {
-            if (const auto& binaryOp = maybeBinaryOp.Cast(); ctx.CheckYqlCompatibleArgsTypes(binaryOp)) {
-                return CompileYqlKernelBinaryOperation(binaryOp, ctx);
-            } else {
-                return {
-                    ConvertSafeCastToColumn(CompileSimpleArrowComparison(binaryOp, ctx), "Uint8", ctx),
-                    ctx.ExprCtx().MakeType<TBlockExprType>(ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool))
-                };
-            }
+        if (const auto& binaryOp = maybeBinaryOp.Cast(); ctx.CheckYqlCompatibleArgsTypes(binaryOp)) {
+            return CompileYqlKernelBinaryOperation(binaryOp, ctx);
         } else {
             return {
-                CompileSimpleArrowComparison(maybeBinaryOp.Cast(), ctx),
+                ConvertSafeCastToColumn(CompileSimpleArrowComparison(binaryOp, ctx), "Uint8", ctx),
                 ctx.ExprCtx().MakeType<TBlockExprType>(ctx.ExprCtx().MakeType<TDataExprType>(EDataSlot::Bool))
             };
         }
@@ -842,20 +799,11 @@ TTypedColumn GetOrCreateColumnIdAndType(const TExprBase& node, TKqpOlapCompileCo
     } else if (const auto& maybeTernaryOp = node.Maybe<TKqpOlapFilterTernaryOp>()) {
         return CompileYqlKernelTernaryOperation(maybeTernaryOp.Cast(), ctx);
     } else if (const auto& maybeAnd = node.Maybe<TKqpOlapAnd>()) {
-        if constexpr (NSsa::RuntimeVersion >= 4U)
-            return BuildLogicalProgram(node.Pos(), maybeAnd.Ref().Children(), TKernelRequestBuilder::EBinaryOp::And, ctx);
-        else
-            return BuildLogicalProgram(node.Pos(), maybeAnd.Ref().Children(), TProgram::TAssignment::FUNC_BINARY_AND, ctx);
+        return BuildLogicalProgram(node.Pos(), maybeAnd.Ref().Children(), TKernelRequestBuilder::EBinaryOp::And, ctx);
     } else if (const auto& maybeOr = node.Maybe<TKqpOlapOr>()) {
-        if constexpr (NSsa::RuntimeVersion >= 4U)
-            return BuildLogicalProgram(node.Pos(), maybeOr.Ref().Children(), TKernelRequestBuilder::EBinaryOp::Or, ctx);
-        else
-            return BuildLogicalProgram(node.Pos(), maybeOr.Ref().Children(), TProgram::TAssignment::FUNC_BINARY_OR, ctx);
+        return BuildLogicalProgram(node.Pos(), maybeOr.Ref().Children(), TKernelRequestBuilder::EBinaryOp::Or, ctx);
     } else if (const auto& maybeXor = node.Maybe<TKqpOlapXor>()) {
-        if constexpr (NSsa::RuntimeVersion >= 4U)
-            return BuildLogicalProgram(node.Pos(), maybeXor.Ref().Children(), TKernelRequestBuilder::EBinaryOp::Xor, ctx);
-        else
-            return BuildLogicalProgram(node.Pos(), maybeXor.Ref().Children(), TProgram::TAssignment::FUNC_BINARY_XOR, ctx);
+        return BuildLogicalProgram(node.Pos(), maybeXor.Ref().Children(), TKernelRequestBuilder::EBinaryOp::Xor, ctx);
     } else if (const auto& maybeNot = node.Maybe<TKqpOlapNot>()) {
         return BuildLogicalNot(maybeNot.Cast().Value(), ctx);
     } else if (const auto& maybeJsonValue = node.Maybe<TKqpOlapJsonValue>()) {
@@ -871,12 +819,10 @@ TTypedColumn GetOrCreateColumnIdAndType(const TExprBase& node, TKqpOlapCompileCo
 
 ui64 CompileComparison(const TKqpOlapFilterBinaryOp& comparison, TKqpOlapCompileContext& ctx)
 {
-    if constexpr (NKikimr::NSsa::RuntimeVersion >= 4U) {
-        if (ctx.CheckYqlCompatibleArgsTypes(comparison)) {
-            return CompileYqlKernelBinaryOperation(comparison, ctx).Id;
-        } else {
-            return ConvertSafeCastToColumn(CompileSimpleArrowComparison(comparison, ctx), "Uint8", ctx);
-        }
+    if (ctx.CheckYqlCompatibleArgsTypes(comparison)) {
+        return CompileYqlKernelBinaryOperation(comparison, ctx).Id;
+    } else {
+        return ConvertSafeCastToColumn(CompileSimpleArrowComparison(comparison, ctx), "Uint8", ctx);
     }
 
     std::string op = comparison.Operator().StringValue().c_str();
@@ -918,26 +864,18 @@ ui64 CompileCondition(const TExprBase& condition, TKqpOlapCompileContext& ctx) {
         return BuildLogicalNot(maybeNot.Cast().Value(), ctx).Id;
     }
 
-    ui32 function = TProgram::TAssignment::FUNC_UNSPECIFIED;
     TKernelRequestBuilder::EBinaryOp op;
 
     if (condition.Maybe<TKqpOlapAnd>()) {
-        function = TProgram::TAssignment::FUNC_BINARY_AND;
         op = TKernelRequestBuilder::EBinaryOp::And;
     } else if (condition.Maybe<TKqpOlapOr>()) {
-        function = TProgram::TAssignment::FUNC_BINARY_OR;
         op = TKernelRequestBuilder::EBinaryOp::Or;
     } else if (condition.Maybe<TKqpOlapXor>()) {
-        function = TProgram::TAssignment::FUNC_BINARY_XOR;
         op = TKernelRequestBuilder::EBinaryOp::Xor;
     } else {
         YQL_ENSURE(false, "Unsuppoted logical operation: " << condition.Ref().Content());
     }
-
-    if constexpr (NSsa::RuntimeVersion >= 4U)
-        return BuildLogicalProgram(condition.Pos(), condition.Ref().Children(), op, ctx).Id;
-    else
-        return BuildLogicalProgram(condition.Pos(), condition.Ref().Children(), function, ctx).Id;
+    return BuildLogicalProgram(condition.Pos(), condition.Ref().Children(), op, ctx).Id;
 }
 
 void CompileFilter(const TKqpOlapFilter& filterNode, TKqpOlapCompileContext& ctx) {
diff --git a/ydb/core/kqp/query_compiler/kqp_query_compiler.cpp b/ydb/core/kqp/query_compiler/kqp_query_compiler.cpp
index c73e29753c7e..fa93d605c726 100644
--- a/ydb/core/kqp/query_compiler/kqp_query_compiler.cpp
+++ b/ydb/core/kqp/query_compiler/kqp_query_compiler.cpp
@@ -359,7 +359,7 @@ void FillReadRange(const TKqpWideReadTable& read, const TKikimrTableMetadata& ta
         }
     }
 
-    readProto.SetReverse(settings.Reverse);
+    readProto.SetReverse(settings.IsReverse());
 }
 
 template <typename TReader, typename TProto>
@@ -395,13 +395,13 @@ void FillReadRanges(const TReader& read, const TKikimrTableMetadata&, TProto& re
     }
 
     if constexpr (std::is_same_v<TProto, NKqpProto::TKqpPhyOpReadOlapRanges>) {
-        readProto.SetSorted(settings.Sorted);
+        readProto.SetSorted(settings.IsSorted());
         if (settings.TabletId) {
             readProto.SetTabletId(*settings.TabletId);
         }
     }
 
-    readProto.SetReverse(settings.Reverse);
+    readProto.SetReverse(settings.IsReverse());
 }
 
 template <typename TEffectCallable, typename TEffectProto>
@@ -1032,8 +1032,8 @@ class TKqpQueryCompiler : public IKqpQueryCompiler {
             }
             auto readSettings = TKqpReadTableSettings::Parse(settings.Settings().Cast());
 
-            readProto.SetReverse(readSettings.Reverse);
-            readProto.SetSorted(readSettings.Sorted);
+            readProto.SetReverse(readSettings.IsReverse());
+            readProto.SetSorted(readSettings.IsSorted());
             YQL_ENSURE(readSettings.SkipNullKeys.empty());
 
             if (readSettings.SequentialInFlight) {
diff --git a/ydb/core/kqp/query_data/kqp_query_data.cpp b/ydb/core/kqp/query_data/kqp_query_data.cpp
index 08ed96d0d944..e2c65ac7d0ca 100644
--- a/ydb/core/kqp/query_data/kqp_query_data.cpp
+++ b/ydb/core/kqp/query_data/kqp_query_data.cpp
@@ -276,12 +276,16 @@ void TQueryData::ValidateParameter(const TString& name, const NKikimrMiniKQL::TT
 void TQueryData::PrepareParameters(const TKqpPhyTxHolder::TConstPtr& tx, const TPreparedQueryHolder::TConstPtr& preparedQuery,
     NMiniKQL::TTypeEnvironment& txTypeEnv)
 {
-    for (const auto& paramDesc : preparedQuery->GetParameters()) {
-        ValidateParameter(paramDesc.GetName(), paramDesc.GetType(), txTypeEnv);
+    if (preparedQuery) {
+        for (const auto& paramDesc : preparedQuery->GetParameters()) {
+            ValidateParameter(paramDesc.GetName(), paramDesc.GetType(), txTypeEnv);
+        }
     }
 
-    for(const auto& paramBinding: tx->GetParamBindings()) {
-        MaterializeParamValue(true, paramBinding);
+    if (tx) {
+        for(const auto& paramBinding: tx->GetParamBindings()) {
+            MaterializeParamValue(true, paramBinding);
+        }
     }
 }
 
diff --git a/ydb/core/kqp/runtime/kqp_read_actor.cpp b/ydb/core/kqp/runtime/kqp_read_actor.cpp
index fe1669341609..9a5b91ededae 100644
--- a/ydb/core/kqp/runtime/kqp_read_actor.cpp
+++ b/ydb/core/kqp/runtime/kqp_read_actor.cpp
@@ -723,6 +723,20 @@ class TKqpReadActor : public TActorBootstrapped<TKqpReadActor>, public NYql::NDq
         }
     }
 
+    bool CheckTotalRetriesExeeded() {
+        const auto limit = MaxTotalRetries();
+        return limit && TotalRetries + 1 > *limit;
+    }
+
+    bool CheckShardRetriesExeeded(ui64 id) {
+        if (!Reads[id] || Reads[id].Finished) {
+            return false;
+        }
+
+        const auto& state = Reads[id].Shard;
+        return state->RetryAttempt + 1 > MaxShardRetries();
+    }
+
     void RetryRead(ui64 id, bool allowInstantRetry = true) {
         if (!Reads[id] || Reads[id].Finished) {
             return;
@@ -730,18 +744,17 @@ class TKqpReadActor : public TActorBootstrapped<TKqpReadActor>, public NYql::NDq
 
         auto state = Reads[id].Shard;
 
-        TotalRetries += 1;
-        auto limit = MaxTotalRetries();
-        if (limit && TotalRetries > *limit) {
+        if (CheckTotalRetriesExeeded()) {
             return RuntimeError(TStringBuilder() << "Table '" << Settings->GetTable().GetTablePath() << "' retry limit exceeded",
                 NDqProto::StatusIds::UNAVAILABLE);
         }
+        ++TotalRetries;
 
-        state->RetryAttempt += 1;
-        if (state->RetryAttempt > MaxShardRetries()) {
+        if (CheckShardRetriesExeeded(id)) {
             ResetRead(id);
             return ResolveShard(state);
         }
+        ++state->RetryAttempt;
 
         auto delay = CalcDelay(state->RetryAttempt, allowInstantRetry);
         if (delay == TDuration::Zero()) {
@@ -825,7 +838,11 @@ class TKqpReadActor : public TActorBootstrapped<TKqpReadActor>, public NYql::NDq
         record.MutableTableId()->SetTableId(Settings->GetTable().GetTableId().GetTableId());
         record.MutableTableId()->SetSchemaVersion(Settings->GetTable().GetSchemaVersion());
 
-        record.SetReverse(Settings->GetReverse());
+        if (Settings->HasOptionalSorting()) {
+            record.SetReverse(Settings->GetOptionalSorting() == (ui32)ERequestSorting::DESC);
+        } else {
+            record.SetReverse(Settings->GetReverse());
+        }
         if (limit) {
             record.SetMaxRows(*limit);
             record.SetTotalRowsLimit(*limit);
@@ -954,12 +971,16 @@ class TKqpReadActor : public TActorBootstrapped<TKqpReadActor>, public NYql::NDq
             Reads[id].Shard->Issues.push_back(issue);
         }
 
+        auto replyError = [&](auto message, auto status) {
+            NYql::TIssues issues;
+            NYql::IssuesFromMessage(record.GetStatus().GetIssues(), issues);
+            return RuntimeError(message, status, issues);
+        };
+
         if (UseFollowers && record.GetStatus().GetCode() != Ydb::StatusIds::SUCCESS && Reads[id].Shard->SuccessBatches > 0) {
             // read from follower is interrupted with error after several successful responses.
             // in this case read is not safe because we can return inconsistent data.
-            NYql::TIssues issues;
-            NYql::IssuesFromMessage(record.GetStatus().GetIssues(), issues);
-            return RuntimeError("Failed to read from follower", NYql::NDqProto::StatusIds::UNAVAILABLE, issues);
+            return replyError("Failed to read from follower", NYql::NDqProto::StatusIds::UNAVAILABLE);
         }
 
         switch (record.GetStatus().GetCode()) {
@@ -968,20 +989,33 @@ class TKqpReadActor : public TActorBootstrapped<TKqpReadActor>, public NYql::NDq
                 break;
             }
             case Ydb::StatusIds::OVERLOADED: {
+                if (CheckTotalRetriesExeeded() || CheckShardRetriesExeeded(id)) {
+                    return replyError(
+                        TStringBuilder() << "Table '" << Settings->GetTable().GetTablePath() << "' retry limit exceeded.",
+                        NYql::NDqProto::StatusIds::OVERLOADED);
+                }
                 return RetryRead(id, false);
             }
             case Ydb::StatusIds::INTERNAL_ERROR: {
+                if (CheckTotalRetriesExeeded() || CheckShardRetriesExeeded(id)) {
+                    return replyError(
+                        TStringBuilder() << "Table '" << Settings->GetTable().GetTablePath() << "' retry limit exceeded.",
+                        NYql::NDqProto::StatusIds::INTERNAL_ERROR);
+                }
                 return RetryRead(id);
             }
             case Ydb::StatusIds::NOT_FOUND: {
+                if (CheckTotalRetriesExeeded() || CheckShardRetriesExeeded(id)) {
+                    return replyError(
+                        TStringBuilder() << "Table '" << Settings->GetTable().GetTablePath() << "' retry limit exceeded.",
+                        NYql::NDqProto::StatusIds::UNAVAILABLE);
+                }
                 auto shard = Reads[id].Shard;
                 ResetRead(id);
                 return ResolveShard(shard);
             }
             default: {
-                NYql::TIssues issues;
-                NYql::IssuesFromMessage(record.GetStatus().GetIssues(), issues);
-                return RuntimeError("Read request aborted", NYql::NDqProto::StatusIds::ABORTED, issues);
+                return replyError("Read request aborted", NYql::NDqProto::StatusIds::ABORTED);
             }
         }
 
diff --git a/ydb/core/kqp/runtime/kqp_stream_lookup_actor.cpp b/ydb/core/kqp/runtime/kqp_stream_lookup_actor.cpp
index d52e826fd378..5f5a51d47622 100644
--- a/ydb/core/kqp/runtime/kqp_stream_lookup_actor.cpp
+++ b/ydb/core/kqp/runtime/kqp_stream_lookup_actor.cpp
@@ -118,6 +118,7 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku
     enum class EReadState {
         Initial,
         Running,
+        Blocked, // Read can't accept new data, but not finished yet
         Finished,
     };
 
@@ -125,6 +126,7 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku
         switch (state) {
             case EReadState::Initial: return "Initial"sv;
             case EReadState::Running: return "Running"sv;
+            case EReadState::Blocked: return "Blocked"sv;
             case EReadState::Finished: return "Finished"sv;
         }
     }
@@ -143,6 +145,10 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku
             return (State == EReadState::Finished);
         }
 
+        void SetBlocked() {
+            State = EReadState::Blocked;
+        }
+
         const ui64 Id;
         const ui64 ShardId;
         EReadState State;
@@ -277,6 +283,7 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku
     }
 
     void Handle(TEvTxProxySchemeCache::TEvResolveKeySetResult::TPtr& ev) {
+        ResoleShardsInProgress = false;
         CA_LOG_D("TEvResolveKeySetResult was received for table: " << StreamLookupWorker->GetTablePath());
         if (ev->Get()->Request->ErrorCount > 0) {
             TString errorMsg = TStringBuilder() << "Failed to get partitioning for table: "
@@ -301,7 +308,7 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku
 
         auto readIt = Reads.find(record.GetReadId());
         if (readIt == Reads.end() || readIt->second.State != EReadState::Running) {
-            CA_LOG_D("Drop read with readId: " << record.GetReadId() << ", because it's already completed");
+            CA_LOG_D("Drop read with readId: " << record.GetReadId() << ", because it's already completed or blocked");
             return;
         }
 
@@ -309,7 +316,8 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku
 
         CA_LOG_D("Recv TEvReadResult (stream lookup) from ShardID=" << read.ShardId
             << ", Table = " << StreamLookupWorker->GetTablePath()
-            << ", ReadId=" << record.GetReadId()
+            << ", ReadId=" << record.GetReadId() << " (current ReadId=" << ReadId << ")"
+            << ", SeqNo=" << record.GetSeqNo()
             << ", Status=" << Ydb::StatusIds::StatusCode_Name(record.GetStatus().GetCode())
             << ", Finished=" << record.GetFinished()
             << ", RowCount=" << record.GetRowCount()
@@ -345,27 +353,55 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku
             Counters->DataShardIteratorFails->Inc();
         }
 
+        auto getIssues = [&record]() {
+            NYql::TIssues issues;
+            NYql::IssuesFromMessage(record.GetStatus().GetIssues(), issues);
+            return issues;
+        };
+
+        auto replyError = [&](auto message, auto status) {
+            return RuntimeError(message, status, getIssues());
+        };
+
         switch (record.GetStatus().GetCode()) {
             case Ydb::StatusIds::SUCCESS:
                 break;
-            case Ydb::StatusIds::NOT_FOUND: {
+            case Ydb::StatusIds::NOT_FOUND:
+            {
                 StreamLookupWorker->ResetRowsProcessing(read.Id, read.FirstUnprocessedQuery, read.LastProcessedKey);
                 read.SetFinished();
+                CA_LOG_D("NOT_FOUND was received from tablet: " << read.ShardId << ". "
+                    << getIssues().ToOneLineString());
                 return ResolveTableShards();
             }
             case Ydb::StatusIds::OVERLOADED: {
+                if (CheckTotalRetriesExeeded() || CheckShardRetriesExeeded(read)) {
+                    return replyError(
+                        TStringBuilder() << "Table '" << StreamLookupWorker->GetTablePath() << "' retry limit exceeded.",
+                        NYql::NDqProto::StatusIds::OVERLOADED);
+                }
+                CA_LOG_D("OVERLOADED was received from tablet: " << read.ShardId << "."
+                    << getIssues().ToOneLineString());
+                read.SetBlocked();
                 return RetryTableRead(read, /*allowInstantRetry = */false);
             }
             case Ydb::StatusIds::INTERNAL_ERROR: {
+                if (CheckTotalRetriesExeeded() || CheckShardRetriesExeeded(read)) {
+                    return replyError(
+                        TStringBuilder() << "Table '" << StreamLookupWorker->GetTablePath() << "' retry limit exceeded.",
+                        NYql::NDqProto::StatusIds::INTERNAL_ERROR);
+                }
+                CA_LOG_D("INTERNAL_ERROR was received from tablet: " << read.ShardId << "."
+                    << getIssues().ToOneLineString());
+                read.SetBlocked();
                 return RetryTableRead(read);
             }
             default: {
-                NYql::TIssues issues;
-                NYql::IssuesFromMessage(record.GetStatus().GetIssues(), issues);
-                return RuntimeError("Read request aborted", NYql::NDqProto::StatusIds::ABORTED, issues);
+                return replyError("Read request aborted", NYql::NDqProto::StatusIds::ABORTED);
             }
         }
 
+        YQL_ENSURE(read.LastSeqNo < record.GetSeqNo());
         read.LastSeqNo = record.GetSeqNo();
 
         if (record.GetFinished()) {
@@ -380,6 +416,8 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku
             if (continuationToken.HasLastProcessedKey()) {
                 TSerializedCellVec lastKey(continuationToken.GetLastProcessedKey());
                 read.LastProcessedKey = TOwnedCellVec(lastKey.GetCells());
+            } else {
+                read.LastProcessedKey.Clear();
             }
 
             Counters->SentIteratorAcks->Inc();
@@ -425,6 +463,7 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku
             }
         }
         for (auto* read : toRetry) {
+            read->SetBlocked();
             RetryTableRead(*read);
         }
     }
@@ -436,6 +475,7 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku
         if (!Partitioning) {
             LookupActorStateSpan.EndError("timeout exceeded");
             CA_LOG_D("Retry attempt to resolve shards for table: " << StreamLookupWorker->GetTablePath());
+            ResoleShardsInProgress = false;
             ResolveTableShards();
         }
     }
@@ -445,7 +485,9 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku
         YQL_ENSURE(readIt != Reads.end(), "Unexpected readId: " << ev->Get()->ReadId);
         auto& read = readIt->second;
 
-        if (read.State == EReadState::Running && read.LastSeqNo <= ev->Get()->LastSeqNo) {
+        YQL_ENSURE(read.State != EReadState::Blocked || read.LastSeqNo <= ev->Get()->LastSeqNo);
+
+        if ((read.State == EReadState::Running && read.LastSeqNo <= ev->Get()->LastSeqNo) || read.State == EReadState::Blocked) {
             if (ev->Get()->InstantStart) {
                 read.SetFinished();
                 auto requests = StreamLookupWorker->RebuildRequest(read.Id, read.FirstUnprocessedQuery, read.LastProcessedKey, ReadId);
@@ -538,24 +580,33 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku
         }
     }
 
+    bool CheckTotalRetriesExeeded() {
+        const auto limit = MaxTotalRetries();
+        return limit && TotalRetryAttempts + 1 > *limit;
+    }
+
+    bool CheckShardRetriesExeeded(TReadState& failedRead) {
+        const auto& shardState = ReadsPerShard[failedRead.ShardId];
+        return shardState.RetryAttempts + 1 > MaxShardRetries();
+    }
+
     void RetryTableRead(TReadState& failedRead, bool allowInstantRetry = true) {
         CA_LOG_D("Retry reading of table: " << StreamLookupWorker->GetTablePath() << ", readId: " << failedRead.Id
             << ", shardId: " << failedRead.ShardId);
 
-        ++TotalRetryAttempts;
-        auto totalRetriesLimit = MaxTotalRetries();
-        if (totalRetriesLimit && TotalRetryAttempts > *totalRetriesLimit) {
+        if (CheckTotalRetriesExeeded()) {
             return RuntimeError(TStringBuilder() << "Table '" << StreamLookupWorker->GetTablePath() << "' retry limit exceeded",
                 NYql::NDqProto::StatusIds::UNAVAILABLE);
         }
+        ++TotalRetryAttempts;
 
-        auto& shardState = ReadsPerShard[failedRead.ShardId];
-        ++shardState.RetryAttempts;
-        if (shardState.RetryAttempts > MaxShardRetries()) {
+        if (CheckShardRetriesExeeded(failedRead)) {
             StreamLookupWorker->ResetRowsProcessing(failedRead.Id, failedRead.FirstUnprocessedQuery, failedRead.LastProcessedKey);
             failedRead.SetFinished();
             return ResolveTableShards();
         }
+        auto& shardState = ReadsPerShard[failedRead.ShardId];
+        ++shardState.RetryAttempts;
 
         auto delay = CalcDelay(shardState.RetryAttempts, allowInstantRetry);
         if (delay == TDuration::Zero()) {
@@ -573,12 +624,17 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku
     }
 
     void ResolveTableShards() {
+        if (ResoleShardsInProgress) {
+            return;
+        }
+
         if (++TotalResolveShardsAttempts > MaxShardResolves()) {
             return RuntimeError(TStringBuilder() << "Table '" << StreamLookupWorker->GetTablePath() << "' resolve attempts limit exceeded",
                 NYql::NDqProto::StatusIds::UNAVAILABLE);
         }
 
         CA_LOG_D("Resolve shards for table: " << StreamLookupWorker->GetTablePath());
+        ResoleShardsInProgress = true;
 
         Partitioning.reset();
 
@@ -658,6 +714,7 @@ class TKqpStreamLookupActor : public NActors::TActorBootstrapped<TKqpStreamLooku
     ui64 ReadId = 0;
     size_t TotalRetryAttempts = 0;
     size_t TotalResolveShardsAttempts = 0;
+    bool ResoleShardsInProgress = false;
 
     // stats
     ui64 ReadRowsCount = 0;
diff --git a/ydb/core/kqp/runtime/kqp_write_actor.cpp b/ydb/core/kqp/runtime/kqp_write_actor.cpp
index 847b4a6ac41e..afe48dfffd16 100644
--- a/ydb/core/kqp/runtime/kqp_write_actor.cpp
+++ b/ydb/core/kqp/runtime/kqp_write_actor.cpp
@@ -214,16 +214,13 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
         const bool inconsistentTx,
         const bool isOlap,
         TVector<NScheme::TTypeInfo> keyColumnTypes,
-        const NMiniKQL::TTypeEnvironment& typeEnv,
         std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc,
         const std::optional<NKikimrDataEvents::TMvccSnapshot>& mvccSnapshot,
         const NKikimrDataEvents::ELockMode lockMode,
         const IKqpTransactionManagerPtr& txManager,
         const TActorId sessionActorId,
-        TIntrusivePtr<TKqpCounters> counters,
-        NWilson::TTraceId traceId)
+        TIntrusivePtr<TKqpCounters> counters)
         : MessageSettings(GetWriteActorSettings())
-        , TypeEnv(typeEnv)
         , Alloc(alloc)
         , MvccSnapshot(mvccSnapshot)
         , LockMode(lockMode)
@@ -237,16 +234,16 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
         , Callbacks(callbacks)
         , TxManager(txManager ? txManager : CreateKqpTransactionManager(/* collectOnly= */ true))
         , Counters(counters)
-        , TableWriteActorSpan(TWilsonKqp::TableWriteActor, NWilson::TTraceId(traceId), "TKqpTableWriteActor")
     {
         LogPrefix = TStringBuilder() << "Table: `" << TablePath << "` (" << TableId << "), " << "SessionActorId: " << sessionActorId;
         ShardedWriteController = CreateShardedWriteController(
             TShardedWriteControllerSettings {
                 .MemoryLimitTotal = MessageSettings.InFlightMemoryLimitPerActorBytes,
-                .MemoryLimitPerMessage = MessageSettings.MemoryLimitPerMessageBytes,
-                .MaxBatchesPerMessage = MessageSettings.MaxBatchesPerMessage,
+                .MemoryLimitPerMessage = std::min(
+                    MessageSettings.InFlightMemoryLimitPerActorBytes,
+                    MessageSettings.MemoryLimitPerMessageBytes),
+                .Inconsistent = InconsistentTx,
             },
-            TypeEnv,
             Alloc);
 
         Counters->WriteActorsCount->Inc();
@@ -254,13 +251,29 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
 
     void Bootstrap() {
         LogPrefix = TStringBuilder() << "SelfId: " << this->SelfId() << ", " << LogPrefix;
-        const auto partitioning = TxManager->GetPartitioning(TableId);
-        if (!partitioning) {
-            Resolve();
-        } else {
-            Partitioning = partitioning;
-            Prepare();
+        try {
+            const auto partitioning = TxManager->GetPartitioning(TableId);
+            if (!partitioning) {
+                Resolve();
+            } else {
+                Partitioning = partitioning;
+                Prepare();
+            }
+        } catch (const TMemoryLimitExceededException&) {
+            RuntimeError(
+                NYql::NDqProto::StatusIds::PRECONDITION_FAILED,
+                NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED,
+                TStringBuilder() << "Memory limit exception"
+                    << ", current limit is " << Alloc->GetLimit() << " bytes.");
+            return;
+        } catch (...) {
+            RuntimeError(
+                NYql::NDqProto::StatusIds::INTERNAL_ERROR,
+                NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,
+                CurrentExceptionMessage());
+            return;
         }
+
         Become(&TKqpTableWriteActor::StateProcessing);
     }
 
@@ -318,30 +331,17 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
         YQL_ENSURE(!Closed);
         YQL_ENSURE(ShardedWriteController);
         CA_LOG_D("Write: token=" << token);
-        try {
-            ShardedWriteController->Write(token, std::move(data));
-            UpdateShards();
-        } catch (...) {
-            RuntimeError(
-                NYql::NDqProto::StatusIds::INTERNAL_ERROR,
-                NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,
-                CurrentExceptionMessage());
-        }
+        ShardedWriteController->Write(token, std::move(data));
+        UpdateShards();
     }
 
     void Close(TWriteToken token) {
         YQL_ENSURE(!Closed);
         YQL_ENSURE(ShardedWriteController);
         CA_LOG_D("Close: token=" << token);
-        try {
-            ShardedWriteController->Close(token);
-            UpdateShards();
-        } catch (...) {
-            RuntimeError(
-                NYql::NDqProto::StatusIds::INTERNAL_ERROR,
-                NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,
-                CurrentExceptionMessage());
-        }
+
+        ShardedWriteController->Close(token);
+        UpdateShards();
     }
 
     void Close() {
@@ -352,6 +352,10 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
         ShardedWriteController->Close();
     }
 
+    void SetParentTraceId(NWilson::TTraceId traceId) {
+        ParentTraceId = std::move(traceId);
+    }
+
     void UpdateShards() {
         // TODO: Maybe there are better ways to initialize new shards...
         for (const auto& shardInfo : ShardedWriteController->GetPendingShards()) {
@@ -389,11 +393,19 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
             default:
                 AFL_ENSURE(false)("unknown message", ev->GetTypeRewrite());
             }
+        } catch (const TMemoryLimitExceededException&) {
+            RuntimeError(
+                NYql::NDqProto::StatusIds::PRECONDITION_FAILED,
+                NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED,
+                TStringBuilder() << "Memory limit exception"
+                    << ", current limit is " << Alloc->GetLimit() << " bytes.");
+            return;
         } catch (...) {
             RuntimeError(
                 NYql::NDqProto::StatusIds::INTERNAL_ERROR,
                 NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,
                 CurrentExceptionMessage());
+            return;
         }
     }
 
@@ -409,6 +421,9 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
 
     void Resolve() {
         AFL_ENSURE(InconsistentTx || IsOlap);
+        TableWriteActorSpan = NWilson::TSpan(TWilsonKqp::TableWriteActor, NWilson::TTraceId(ParentTraceId),
+            "WaitForTableResolve", NWilson::EFlags::AUTO_END);
+
         if (IsOlap) {
             ResolveTable();
         } else {
@@ -424,7 +439,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
     }
 
     void Handle(TEvPrivate::TEvResolveRequestPlanned::TPtr&) {
-        Resolve();
+        RetryResolve();
     }
 
     void ResolveTable() {
@@ -453,10 +468,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
         entry.ShowPrivatePath = true;
         request->ResultSet.emplace_back(entry);
 
-        TableWriteActorStateSpan = NWilson::TSpan(TWilsonKqp::TableWriteActorTableNavigate, TableWriteActorSpan.GetTraceId(),
-            "WaitForShardsResolve", NWilson::EFlags::AUTO_END);
-
-        Send(MakeSchemeCacheID(), new TEvTxProxySchemeCache::TEvNavigateKeySet(request), 0, 0, TableWriteActorStateSpan.GetTraceId());
+        Send(MakeSchemeCacheID(), new TEvTxProxySchemeCache::TEvNavigateKeySet(request), 0, 0, TableWriteActorSpan.GetTraceId());
     }
 
     void Handle(TEvTxProxySchemeCache::TEvNavigateKeySetResult::TPtr& ev) {
@@ -473,7 +485,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
         SchemeEntry = resultSet[0];
 
         CA_LOG_D("Resolved TableId=" << TableId << " ("
-            << TableId.PathId.ToString() << " "
+            << TablePath << " "
             << TableId.SchemaVersion << ")");
 
         if (TableId.SchemaVersion != SchemeEntry->TableId.SchemaVersion) {
@@ -486,20 +498,22 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
 
         YQL_ENSURE(IsOlap && (SchemeEntry->Kind == NSchemeCache::TSchemeCacheNavigate::KindColumnTable));
 
-        ResolveShards();
+        Prepare();
     }
 
     void ResolveShards() {
         YQL_ENSURE(!KeyColumnTypes.empty());
         CA_LOG_D("Resolve shards for TableId=" << TableId);
 
+        AFL_ENSURE(InconsistentTx); // Only for CTAS
+
         const TVector<TCell> minKey(KeyColumnTypes.size());
         const TTableRange range(minKey, true, {}, false, false);
         YQL_ENSURE(range.IsFullRange(KeyColumnTypes.size()));
         auto keyRange = MakeHolder<TKeyDesc>(
             TableId,
             range,
-            TKeyDesc::ERowOperation::Update,
+            TKeyDesc::ERowOperation::Update, // Only for CTAS
             KeyColumnTypes,
             TVector<TKeyDesc::TColumnOp>{});
 
@@ -507,7 +521,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
         request->ResultSet.emplace_back(std::move(keyRange));
 
         TAutoPtr<TEvTxProxySchemeCache::TEvResolveKeySet> resolveReq(new TEvTxProxySchemeCache::TEvResolveKeySet(request));
-        Send(MakeSchemeCacheID(), resolveReq.Release(), 0, 0, TableWriteActorStateSpan.GetTraceId());
+        Send(MakeSchemeCacheID(), resolveReq.Release(), 0, 0, TableWriteActorSpan.GetTraceId());
     }
 
     void Handle(TEvTxProxySchemeCache::TEvResolveKeySetResult::TPtr& ev) {
@@ -548,10 +562,12 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
             << ", Cookie=" << ev->Cookie);
         UpdateStats(ev->Get()->Record.GetTxStats());
 
+        TxManager->AddParticipantNode(ev->Sender.NodeId());
+
         switch (ev->Get()->GetStatus()) {
         case NKikimrDataEvents::TEvWriteResult::STATUS_UNSPECIFIED: {
             CA_LOG_E("Got UNSPECIFIED for table `"
-                    << TableId.PathId.ToString() << "`."
+                    << TablePath << "`."
                     << " ShardID=" << ev->Get()->Record.GetOrigin() << ","
                     << " Sink=" << this->SelfId() << "."
                     << getIssues().ToOneLineString());
@@ -559,7 +575,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
             RuntimeError(
                 NYql::NDqProto::StatusIds::UNSPECIFIED,
                 NYql::TIssuesIds::DEFAULT_ERROR,
-                TStringBuilder() << "Unspecified error for table `"
+                TStringBuilder() << "Unspecified error. Table `"
                     << TablePath << "`.",
                 getIssues());
             return;
@@ -574,7 +590,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
         }
         case NKikimrDataEvents::TEvWriteResult::STATUS_ABORTED: {
             CA_LOG_E("Got ABORTED for table `"
-                    << TableId.PathId.ToString() << "`."
+                    << TablePath << "`."
                     << " ShardID=" << ev->Get()->Record.GetOrigin() << ","
                     << " Sink=" << this->SelfId() << "."
                     << getIssues().ToOneLineString());
@@ -582,14 +598,13 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
             RuntimeError(
                 NYql::NDqProto::StatusIds::ABORTED,
                 NYql::TIssuesIds::KIKIMR_OPERATION_ABORTED,
-                TStringBuilder() << "Aborted for table `"
-                    << TablePath << "`.",
+                TStringBuilder() << "Operation aborted.",
                 getIssues());
             return;
         }
         case NKikimrDataEvents::TEvWriteResult::STATUS_WRONG_SHARD_STATE:
             CA_LOG_E("Got WRONG SHARD STATE for table `"
-                    << SchemeEntry->TableId.PathId.ToString() << "`."
+                    << TablePath << "`."
                     << " ShardID=" << ev->Get()->Record.GetOrigin() << ","
                     << " Sink=" << this->SelfId() << "."
                     << getIssues().ToOneLineString());
@@ -600,16 +615,16 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
                 RetryResolve();
             } else {
                 RuntimeError(
-                    NYql::NDqProto::StatusIds::PRECONDITION_FAILED,
+                    NYql::NDqProto::StatusIds::UNAVAILABLE,
                     NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,
-                    TStringBuilder() << "Wrong shard state for table `"
+                    TStringBuilder() << "Wrong shard state. Table `"
                         << TablePath << "`.",
                     getIssues());
             }
             return;
         case NKikimrDataEvents::TEvWriteResult::STATUS_INTERNAL_ERROR: {
             CA_LOG_E("Got INTERNAL ERROR for table `"
-                    << TableId.PathId.ToString() << "`."
+                    << TablePath << "`."
                     << " ShardID=" << ev->Get()->Record.GetOrigin() << ","
                     << " Sink=" << this->SelfId() << "."
                     << getIssues().ToOneLineString());
@@ -617,14 +632,13 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
             RuntimeError(
                 NYql::NDqProto::StatusIds::INTERNAL_ERROR,
                 NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,
-                TStringBuilder() << "Internal error for table `"
-                    << TablePath << "`.",
+                TStringBuilder() << "Internal error while executing transaction.",
                 getIssues());
             return;
         }
         case NKikimrDataEvents::TEvWriteResult::STATUS_DISK_SPACE_EXHAUSTED: {
             CA_LOG_E("Got DISK_SPACE_EXHAUSTED for table `"
-                    << TableId.PathId.ToString() << "`."
+                    << TablePath << "`."
                     << " ShardID=" << ev->Get()->Record.GetOrigin() << ","
                     << " Sink=" << this->SelfId() << "."
                     << getIssues().ToOneLineString());
@@ -632,14 +646,33 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
             RuntimeError(
                 NYql::NDqProto::StatusIds::UNAVAILABLE,
                 NYql::TIssuesIds::KIKIMR_DISK_SPACE_EXHAUSTED,
-                TStringBuilder() << "Disk space exhausted for table `"
+                TStringBuilder() << "Disk space exhausted. Table `"
                     << TablePath << "`.",
                 getIssues());
             return;
         }
+        case NKikimrDataEvents::TEvWriteResult::STATUS_OUT_OF_SPACE: {
+            CA_LOG_W("Got OUT_OF_SPACE for table `"
+                << TablePath << "`."
+                << " ShardID=" << ev->Get()->Record.GetOrigin() << ","
+                << " Sink=" << this->SelfId() << "."
+                << " Ignored this error."
+                << getIssues().ToOneLineString());
+            // TODO: support waiting
+            if (!InconsistentTx)  {
+                TxManager->SetError(ev->Get()->Record.GetOrigin());
+                RuntimeError(
+                    NYql::NDqProto::StatusIds::OVERLOADED,
+                    NYql::TIssuesIds::KIKIMR_OVERLOADED,
+                    TStringBuilder() << "Tablet " << ev->Get()->Record.GetOrigin() << " is out of space. Table `"
+                        << TablePath << "`.",
+                    getIssues());
+            }
+            return;
+        }        
         case NKikimrDataEvents::TEvWriteResult::STATUS_OVERLOADED: {
             CA_LOG_W("Got OVERLOADED for table `"
-                << TableId.PathId.ToString() << "`."
+                << TablePath << "`."
                 << " ShardID=" << ev->Get()->Record.GetOrigin() << ","
                 << " Sink=" << this->SelfId() << "."
                 << " Ignored this error."
@@ -650,7 +683,8 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
                 RuntimeError(
                     NYql::NDqProto::StatusIds::OVERLOADED,
                     NYql::TIssuesIds::KIKIMR_OVERLOADED,
-                    TStringBuilder() << "Tablet " << ev->Get()->Record.GetOrigin() << " is overloaded. Table `"
+                    TStringBuilder() << "Kikimr cluster or one of its subsystems is overloaded."
+                        << " Tablet " << ev->Get()->Record.GetOrigin() << " is overloaded. Table `"
                         << TablePath << "`.",
                     getIssues());
             }
@@ -658,7 +692,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
         }
         case NKikimrDataEvents::TEvWriteResult::STATUS_CANCELLED: {
             CA_LOG_E("Got CANCELLED for table `"
-                    << TableId.PathId.ToString() << "`."
+                    << TablePath << "`."
                     << " ShardID=" << ev->Get()->Record.GetOrigin() << ","
                     << " Sink=" << this->SelfId() << "."
                     << getIssues().ToOneLineString());
@@ -666,14 +700,13 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
             RuntimeError(
                 NYql::NDqProto::StatusIds::CANCELLED,
                 NYql::TIssuesIds::KIKIMR_OPERATION_CANCELLED,
-                TStringBuilder() << "Cancelled request to table `"
-                    << TablePath << "`.",
+                TStringBuilder() << "Operation cancelled.",
                 getIssues());
             return;
         }
         case NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST: {
             CA_LOG_E("Got BAD REQUEST for table `"
-                    << TableId.PathId.ToString() << "`."
+                    << TablePath << "`."
                     << " ShardID=" << ev->Get()->Record.GetOrigin() << ","
                     << " Sink=" << this->SelfId() << "."
                     << getIssues().ToOneLineString());
@@ -688,7 +721,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
         }
         case NKikimrDataEvents::TEvWriteResult::STATUS_SCHEME_CHANGED: {
             CA_LOG_E("Got SCHEME CHANGED for table `"
-                    << TableId.PathId.ToString() << "`."
+                    << TablePath << "`."
                     << " ShardID=" << ev->Get()->Record.GetOrigin() << ","
                     << " Sink=" << this->SelfId() << "."
                     << getIssues().ToOneLineString());
@@ -708,7 +741,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
         }
         case NKikimrDataEvents::TEvWriteResult::STATUS_LOCKS_BROKEN: {
             CA_LOG_E("Got LOCKS BROKEN for table `"
-                    << TableId.PathId.ToString() << "`."
+                    << TablePath << "`."
                     << " ShardID=" << ev->Get()->Record.GetOrigin() << ","
                     << " Sink=" << this->SelfId() << "."
                     << getIssues().ToOneLineString());
@@ -725,7 +758,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
             return;
         }
         case NKikimrDataEvents::TEvWriteResult::STATUS_CONSTRAINT_VIOLATION: {
-            CA_LOG_E("Got CONSTRAINT VIOLATION for table."
+            CA_LOG_E("Got CONSTRAINT VIOLATION for table `" << TablePath << "`."
                     << " ShardID=" << ev->Get()->Record.GetOrigin() << ","
                     << " Sink=" << this->SelfId() << "."
                     << getIssues().ToOneLineString());
@@ -778,19 +811,20 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
                 return builder;
             }());
 
-        for (const auto& lock : ev->Get()->Record.GetTxLocks()) {
-            Y_ABORT_UNLESS(Mode == EMode::WRITE);
-            if (!TxManager->AddLock(ev->Get()->Record.GetOrigin(), lock)) {
-                YQL_ENSURE(TxManager->BrokenLocks());
-                NYql::TIssues issues;
-                issues.AddIssue(*TxManager->GetLockIssue());
-                RuntimeError(
-                    NYql::NDqProto::StatusIds::ABORTED,
-                    NYql::TIssuesIds::KIKIMR_OPERATION_ABORTED,
-                    TStringBuilder() << "Transaction locks invalidated. Table `"
-                        << TablePath << "`.",
-                    issues);
-                return;
+        if (Mode == EMode::WRITE) {
+            for (const auto& lock : ev->Get()->Record.GetTxLocks()) {
+                if (!TxManager->AddLock(ev->Get()->Record.GetOrigin(), lock)) {
+                    YQL_ENSURE(TxManager->BrokenLocks());
+                    NYql::TIssues issues;
+                    issues.AddIssue(*TxManager->GetLockIssue());
+                    RuntimeError(
+                        NYql::NDqProto::StatusIds::ABORTED,
+                        NYql::TIssuesIds::KIKIMR_OPERATION_ABORTED,
+                        TStringBuilder() << "Transaction locks invalidated. Table `"
+                            << TablePath << "`.",
+                        issues);
+                    return;
+                }
             }
         }
 
@@ -847,13 +881,16 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
         UpdateShards();
     }
 
-    void Flush() {
+    bool Flush() {
         for (const auto& shardInfo : ShardedWriteController->GetPendingShards()) {
-            SendDataToShard(shardInfo.ShardId);
+            if (!SendDataToShard(shardInfo.ShardId)) {
+                return false;
+            }
         }
+        return true;
     }
 
-    void SendDataToShard(const ui64 shardId) {
+    bool SendDataToShard(const ui64 shardId) {
         YQL_ENSURE(Mode != EMode::COMMIT);
 
         const auto metadata = ShardedWriteController->GetMessageMetadata(shardId);
@@ -870,7 +907,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
                     << "ShardId=" << shardId
                     << " for table '" << TablePath
                     << "': retry limit exceeded.");
-            return;
+            return false;
         }
 
         const bool isPrepare = metadata->IsFinal && Mode == EMode::PREPARE;
@@ -945,7 +982,7 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
             new TEvPipeCache::TEvForward(evWrite.release(), shardId, /* subscribe */ true),
             0,
             metadata->Cookie,
-            TableWriteActorSpan.GetTraceId());
+            NWilson::TTraceId(ParentTraceId));
 
         ShardedWriteController->OnMessageSent(shardId, metadata->Cookie);
 
@@ -959,6 +996,8 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
                     0,
                     metadata->Cookie));
         }
+
+        return true;
     }
 
     void RetryShard(const ui64 shardId, const std::optional<ui64> ifCookieEqual) {
@@ -996,21 +1035,26 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
 
             Schedule(reattachState.ReattachInfo.Delay, new TEvPrivate::TEvReattachToShard(ev->Get()->TabletId));
         } else {
-            TxManager->SetError(ev->Get()->TabletId);
-            if (Mode == EMode::IMMEDIATE_COMMIT || Mode == EMode::COMMIT) {
+            if (TxManager->GetState(ev->Get()->TabletId) == IKqpTransactionManager::EXECUTING) {
+                TxManager->SetError(ev->Get()->TabletId);
                 RuntimeError(
                     NYql::NDqProto::StatusIds::UNDETERMINED,
                     NYql::TIssuesIds::KIKIMR_OPERATION_STATE_UNKNOWN,
                     TStringBuilder()
-                        << "Error writing to table `" << TableId.PathId.ToString() << "`"
-                        << ". Transaction state unknown for shard " << ev->Get()->TabletId << ".");
+                        << "State of operation is unknown. "
+                        << "Error writing to table `" << TablePath << "`"
+                        << ". Transaction state unknown for tablet " << ev->Get()->TabletId << ".");
+                return;
             } else {
+                TxManager->SetError(ev->Get()->TabletId);
                 RuntimeError(
                     NYql::NDqProto::StatusIds::UNAVAILABLE,
                     NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,
                     TStringBuilder()
-                        << "Error writing to table `" << TableId.PathId.ToString() << "`"
+                        << "Kikimr cluster or one of its subsystems was unavailable. "
+                        << "Error writing to table `" << TablePath << "`"
                         << ": can't deliver message to tablet " << ev->Get()->TabletId << ".");
+                return;
             }
         }
     }
@@ -1028,8 +1072,10 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
         switch (shardState) {
             case IKqpTransactionManager::EXECUTING:
                 YQL_ENSURE(Mode == EMode::COMMIT || Mode == EMode::IMMEDIATE_COMMIT);
+                break;
             case IKqpTransactionManager::PREPARED:
                 YQL_ENSURE(Mode == EMode::PREPARE);
+                break;
             case IKqpTransactionManager::PREPARING:
             case IKqpTransactionManager::FINISHED:
             case IKqpTransactionManager::ERROR:
@@ -1052,14 +1098,16 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
                     << "ShardId=" << shardId
                     << " for table '" << TablePath
                     << "': attach transaction failed.");
+            return;
         } else {
             RuntimeError(
-                NYql::NDqProto::StatusIds::UNAVAILABLE,
+                NYql::NDqProto::StatusIds::UNDETERMINED,
                 NYql::TIssuesIds::KIKIMR_OPERATION_STATE_UNKNOWN,
                 TStringBuilder()
                     << "ShardId=" << shardId
                     << " for table '" << TablePath
                     << "': attach transaction failed.");
+            return;
         }
     }
 
@@ -1099,31 +1147,24 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
     }
 
     void Prepare() {
-        TableWriteActorStateSpan.EndOk();
+        if (TableWriteActorSpan) {
+            TableWriteActorSpan.EndOk(); // Resolve finished
+        }
+
         ResolveAttempts = 0;
 
-        try {
-            if (IsOlap) {
-                YQL_ENSURE(SchemeEntry);
-                ShardedWriteController->OnPartitioningChanged(*SchemeEntry);
-            } else {
-                ShardedWriteController->OnPartitioningChanged(Partitioning);
-                Partitioning.reset();
-            }
-        } catch (...) {
-            RuntimeError(
-                NYql::NDqProto::StatusIds::INTERNAL_ERROR,
-                NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,
-                CurrentExceptionMessage());
+        if (IsOlap) {
+            YQL_ENSURE(SchemeEntry);
+            ShardedWriteController->OnPartitioningChanged(*SchemeEntry);
+        } else {
+            ShardedWriteController->OnPartitioningChanged(Partitioning);
+            Partitioning.reset();
         }
 
         Callbacks->OnReady();
     }
 
     void RuntimeError(NYql::NDqProto::StatusIds::StatusCode statusCode, NYql::EYqlIssueCode id, const TString& message, const NYql::TIssues& subIssues = {}) {
-        if (TableWriteActorStateSpan) {
-            TableWriteActorStateSpan.EndError(message);
-        }
         if (TableWriteActorSpan) {
             TableWriteActorSpan.EndError(message);
         }
@@ -1132,9 +1173,6 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
     }
 
     void RuntimeError(NYql::NDqProto::StatusIds::StatusCode statusCode, NYql::TIssues&& issues) {
-        if (TableWriteActorStateSpan) {
-            TableWriteActorStateSpan.EndError(issues.ToOneLineString());
-        }
         if (TableWriteActorSpan) {
             TableWriteActorSpan.EndError(issues.ToOneLineString());
         }
@@ -1142,7 +1180,16 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
         Callbacks->OnError(statusCode, std::move(issues));
     }
 
-    void PassAway() override {;
+    void Unlink() {
+        Send(PipeCacheId, new TEvPipeCache::TEvUnlink(0));
+    }
+
+    void PassAway() override {
+        {
+            Y_ABORT_UNLESS(Alloc);
+            TGuard<NMiniKQL::TScopedAlloc> allocGuard(*Alloc);
+            ShardedWriteController.Reset();
+        }
         Counters->WriteActorsCount->Dec();
         Send(PipeCacheId, new TEvPipeCache::TEvUnlink(0));
         TActorBootstrapped<TKqpTableWriteActor>::PassAway();
@@ -1171,6 +1218,10 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
     }
 
     void FillStats(NYql::NDqProto::TDqTaskStats* stats) {
+        if (Stats.ReadRows + Stats.WriteRows + Stats.EraseRows == 0) {
+            // Avoid empty table_access stats
+            return;
+        }
         NYql::NDqProto::TDqTableStats* tableStats = nullptr;
         for (size_t i = 0; i < stats->TablesSize(); ++i) {
             auto* table = stats->MutableTables(i);
@@ -1206,7 +1257,6 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
 
     TString LogPrefix;
     TWriteActorSettings MessageSettings;
-    const NMiniKQL::TTypeEnvironment& TypeEnv;
     std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;
 
     const std::optional<NKikimrDataEvents::TMvccSnapshot> MvccSnapshot;
@@ -1239,8 +1289,8 @@ class TKqpTableWriteActor : public TActorBootstrapped<TKqpTableWriteActor> {
 
     TKqpTableWriterStatistics Stats;
 
+    NWilson::TTraceId ParentTraceId;
     NWilson::TSpan TableWriteActorSpan;
-    NWilson::TSpan TableWriteActorStateSpan;
 };
 
 class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, public NYql::NDq::IDqComputeActorAsyncOutput, public IKqpTableWriterCallbacks {
@@ -1257,7 +1307,6 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu
         , OutputIndex(args.OutputIndex)
         , Callbacks(args.Callback)
         , Counters(counters)
-        , TypeEnv(args.TypeEnv)
         , Alloc(args.Alloc)
         , TxId(std::get<ui64>(args.TxId))
         , TableId(
@@ -1275,10 +1324,11 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu
             Settings.GetWriteIndexes().begin(),
             Settings.GetWriteIndexes().end());
 
+        TGuard guard(*Alloc);
         if (Settings.GetIsOlap()) {
-            Batcher = CreateColumnDataBatcher(columnsMetadata, std::move(writeIndex));
+            Batcher = CreateColumnDataBatcher(columnsMetadata, std::move(writeIndex), Alloc);
         } else {
-            Batcher = CreateRowDataBatcher(columnsMetadata, std::move(writeIndex));
+            Batcher = CreateRowDataBatcher(columnsMetadata, std::move(writeIndex), Alloc);
         }
     }
 
@@ -1303,15 +1353,13 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu
                 Settings.GetInconsistentTx(),
                 Settings.GetIsOlap(),
                 std::move(keyColumnTypes),
-                TypeEnv,
                 Alloc,
                 Settings.GetMvccSnapshot(),
                 Settings.GetLockMode(),
                 nullptr,
                 TActorId{},
-                Counters,
-                DirectWriteActorSpan.GetTraceId());
-
+                Counters);
+            WriteTableActor->SetParentTraceId(DirectWriteActorSpan.GetTraceId());
             WriteTableActorId = RegisterWithSameMailbox(WriteTableActor);
 
             TVector<NKikimrKqp::TKqpColumnMetadataProto> keyColumnsMetadata(
@@ -1331,12 +1379,21 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu
                 std::move(writeIndex),
                 Settings.GetPriority());
             WaitingForTableActor = true;
+        } catch (const TMemoryLimitExceededException&) {
+            RuntimeError(
+                NYql::NDqProto::StatusIds::PRECONDITION_FAILED,
+                NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED,
+                TStringBuilder() << "Memory limit exception"
+                    << ", current limit is " << Alloc->GetLimit() << " bytes.",
+                {});
+            return;
         } catch (...) {
             RuntimeError(
                 NYql::NDqProto::StatusIds::INTERNAL_ERROR,
                 NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,
                 CurrentExceptionMessage(),
                 {});
+            return;
         }
     }
 
@@ -1392,40 +1449,77 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu
         EgressStats.Resume();
         Y_UNUSED(size);
 
-        Batcher->AddData(data);
-        YQL_ENSURE(WriteTableActor);
-        WriteTableActor->Write(*WriteToken, Batcher->Build());
-        if (Closed) {
-            WriteTableActor->Close(*WriteToken);
-            WriteTableActor->Close();
+        try {
+            Batcher->AddData(data);
+            YQL_ENSURE(WriteTableActor);
+            WriteTableActor->Write(*WriteToken, Batcher->Build());
+            if (Closed) {
+                WriteTableActor->Close(*WriteToken);
+                WriteTableActor->Close();
+            }
+        } catch (const TMemoryLimitExceededException&) {
+            RuntimeError(
+                NYql::NDqProto::StatusIds::PRECONDITION_FAILED,
+                NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED,
+                TStringBuilder() << "Memory limit exception"
+                    << ", current limit is " << Alloc->GetLimit() << " bytes.",
+                {});
+            return;
+        } catch (...) {
+            RuntimeError(
+                NYql::NDqProto::StatusIds::INTERNAL_ERROR,
+                NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,
+                CurrentExceptionMessage(),
+                {});
+            return;
         }
+
         Process();
     }
 
     void Process() {
-        const bool outOfMemory = GetFreeSpace() <= 0;
-        if (outOfMemory) {
-            WaitingForTableActor = true;
-        } else if (WaitingForTableActor) {
-            ResumeExecution();
-        }
+        try {
+            const bool outOfMemory = GetFreeSpace() <= 0;
+            if (outOfMemory) {
+                WaitingForTableActor = true;
+            } else if (WaitingForTableActor) {
+                ResumeExecution();
+            }
 
-        if (outOfMemory && !Settings.GetEnableStreamWrite()) {
+            if (outOfMemory && !Settings.GetEnableStreamWrite()) {
+                RuntimeError(
+                    NYql::NDqProto::StatusIds::PRECONDITION_FAILED,
+                    NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED,
+                    TStringBuilder() << "Stream write can't be used for this query.",
+                    {});
+                return;
+            }
+
+            if (Closed || outOfMemory) {
+                if (!WriteTableActor->Flush()) {
+                    return;
+                }
+            }
+
+            if (Closed && WriteTableActor->IsFinished()) {
+                CA_LOG_D("Write actor finished");
+                Callbacks->OnAsyncOutputFinished(GetOutputIndex());
+            }
+        } catch (const TMemoryLimitExceededException&) {
             RuntimeError(
                 NYql::NDqProto::StatusIds::PRECONDITION_FAILED,
                 NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED,
-                TStringBuilder() << "Stream write can't be used for this query.",
+                TStringBuilder() << "Memory limit exception"
+                    << ", current limit is " << Alloc->GetLimit() << " bytes.",
+                {});
+            return;
+        } catch (...) {
+            RuntimeError(
+                NYql::NDqProto::StatusIds::INTERNAL_ERROR,
+                NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,
+                CurrentExceptionMessage(),
                 {});
             return;
-        }
-
-        if (Closed || outOfMemory) {
-            WriteTableActor->Flush();
-        }
-
-        if (Closed && WriteTableActor->IsFinished()) {
-            CA_LOG_D("Write actor finished");
-            Callbacks->OnAsyncOutputFinished(GetOutputIndex());
         }
     }
 
@@ -1504,7 +1598,6 @@ class TKqpDirectWriteActor : public TActorBootstrapped<TKqpDirectWriteActor>, pu
     NYql::NDq::TDqAsyncStats EgressStats;
     NYql::NDq::IDqComputeActorAsyncOutput::ICallbacks * Callbacks = nullptr;
     TIntrusivePtr<TKqpCounters> Counters;
-    const NMiniKQL::TTypeEnvironment& TypeEnv;
     std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;
     IDataBatcherPtr Batcher;
 
@@ -1599,17 +1692,14 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
         : SessionActorId(settings.SessionActorId)
         , MessageSettings(GetWriteActorSettings())
         , TxManager(settings.TxManager)
-        , Alloc(std::make_shared<NKikimr::NMiniKQL::TScopedAlloc>(__LOCATION__))
-        , TypeEnv(*Alloc)
+        , Alloc(settings.Alloc)
         , Counters(settings.Counters)
         , TxProxyMon(settings.TxProxyMon)
-        , BufferWriteActor(TWilsonKqp::BufferWriteActor, NWilson::TTraceId(settings.TraceId), "TKqpBufferWriteActor", NWilson::EFlags::AUTO_END)
-        , BufferWriteActorState(TWilsonKqp::BufferWriteActorState, BufferWriteActor.GetTraceId(),
-            "BufferWriteActorState::Writing", NWilson::EFlags::AUTO_END)
+        , BufferWriteActorSpan(TWilsonKqp::BufferWriteActor, NWilson::TTraceId(settings.TraceId), "BufferWriteActor", NWilson::EFlags::AUTO_END)
     {
         State = EState::WRITING;
-        Alloc->Release();
         Counters->BufferActorsCount->Inc();
+        UpdateTracingState("Write", BufferWriteActorSpan.GetTraceId());
     }
 
     void Bootstrap() {
@@ -1636,12 +1726,21 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
             default:
                 AFL_ENSURE(false)("unknown message", ev->GetTypeRewrite());
             }
+        } catch (const TMemoryLimitExceededException&) {
+            ReplyErrorAndDie(
+                NYql::NDqProto::StatusIds::PRECONDITION_FAILED,
+                NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED,
+                TStringBuilder() << "Memory limit exception"
+                    << ", current limit is " << Alloc->GetLimit() << " bytes.",
+                {});
+            return;
         } catch (...) {
             ReplyErrorAndDie(
                 NYql::NDqProto::StatusIds::INTERNAL_ERROR,
                 NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,
                 CurrentExceptionMessage(),
                 {});
+            return;
         }
     }
 
@@ -1680,14 +1779,13 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
                     InconsistentTx,
                     settings.IsOlap,
                     std::move(keyColumnTypes),
-                    TypeEnv,
                     Alloc,
                     settings.TransactionSettings.MvccSnapshot,
                     settings.TransactionSettings.LockMode,
                     TxManager,
                     SessionActorId,
-                    Counters,
-                    BufferWriteActor.GetTraceId());
+                    Counters);
+                writeInfo.WriteTableActor->SetParentTraceId(BufferWriteActorStateSpan.GetTraceId());
                 writeInfo.WriteTableActorId = RegisterWithSameMailbox(writeInfo.WriteTableActor);
                 CA_LOG_D("Create new TableWriteActor for table `" << settings.TablePath << "` (" << settings.TableId << "). lockId=" << LockTxId << " " << writeInfo.WriteTableActorId);
             }
@@ -1716,9 +1814,11 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
         Process();
     }
 
-    void Process() {
+    bool Process() {
         ProcessRequestQueue();
-        ProcessWrite();
+        if (!ProcessWrite()) {
+            return false;
+        }
         ProcessAckQueue();
 
         if (State == EState::FLUSHING) {
@@ -1730,6 +1830,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
                 OnFlushed();
             }
         }
+        return true;
     }
 
     void ProcessRequestQueue() {
@@ -1777,7 +1878,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
         }
     }
 
-    void ProcessWrite() {
+    bool ProcessWrite() {
         const bool outOfMemory = GetTotalFreeSpace() <= 0;
         const bool needToFlush = outOfMemory
             || State == EState::FLUSHING
@@ -1785,28 +1886,31 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
             || State == EState::COMMITTING
             || State == EState::ROLLINGBACK;
 
-        if (EnableStreamWrite && outOfMemory) {
+        if (!EnableStreamWrite && outOfMemory) {
             ReplyErrorAndDie(
                 NYql::NDqProto::StatusIds::PRECONDITION_FAILED,
                 NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED,
                 TStringBuilder() << "Stream write queries aren't allowed.",
                 {});
+            return false;
         }
 
         if (needToFlush) {
             CA_LOG_D("Flush data");
             for (auto& [_, info] : WriteInfos) {
                 if (info.WriteTableActor->IsReady()) {
-                    info.WriteTableActor->Flush();
+                    if (!info.WriteTableActor->Flush()) {
+                        return false;
+                    }
                 }
             }
         }
+        return true;
     }
 
-    void Flush() {
+    bool Flush(NWilson::TTraceId traceId) {
         Counters->BufferActorFlushes->Inc();
-        BufferWriteActorState = NWilson::TSpan(TWilsonKqp::BufferWriteActorState, BufferWriteActor.GetTraceId(),
-            "BufferWriteActorState::Flushing", NWilson::EFlags::AUTO_END);
+        UpdateTracingState("Flush", std::move(traceId));
         OperationStartTime = TInstant::Now();
 
         CA_LOG_D("Start flush");
@@ -1815,12 +1919,11 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
         for (auto& [_, queue] : DataQueues) {
             YQL_ENSURE(queue.empty());
         }
-        Process();
+        return Process();
     }
 
-    void Prepare(const ui64 txId) {
-        BufferWriteActorState = NWilson::TSpan(TWilsonKqp::BufferWriteActorState, BufferWriteActor.GetTraceId(),
-            "BufferWriteActorState::Preparing", NWilson::EFlags::AUTO_END);
+    bool Prepare(const ui64 txId, NWilson::TTraceId traceId) {
+        UpdateTracingState("Commit", std::move(traceId));
         OperationStartTime = TInstant::Now();
 
         CA_LOG_D("Start prepare for distributed commit");
@@ -1834,15 +1937,17 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
             info.WriteTableActor->SetPrepare(txId);
         }
         Close();
-        Process();
+        if (!Process()) {
+            return false;
+        }
         SendToExternalShards(false);
         SendToTopics(false);
+        return true;
     }
 
-    void ImmediateCommit() {
+    bool ImmediateCommit(NWilson::TTraceId traceId) {
         Counters->BufferActorImmediateCommits->Inc();
-        BufferWriteActorState = NWilson::TSpan(TWilsonKqp::BufferWriteActorState, BufferWriteActor.GetTraceId(),
-            "BufferWriteActorState::Committing", NWilson::EFlags::AUTO_END);
+        UpdateTracingState("Commit", std::move(traceId));
         OperationStartTime = TInstant::Now();
 
         CA_LOG_D("Start immediate commit");
@@ -1856,14 +1961,15 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
             info.WriteTableActor->SetImmediateCommit();
         }
         Close();
-        Process();
+        if (!Process()) {
+            return false;
+        }
         SendToTopics(true);
+        return true;
     }
 
     void DistributedCommit() {
         Counters->BufferActorDistributedCommits->Inc();
-        BufferWriteActorState = NWilson::TSpan(TWilsonKqp::BufferWriteActorState, BufferWriteActor.GetTraceId(),
-            "BufferWriteActorState::Committing", NWilson::EFlags::AUTO_END);
         OperationStartTime = TInstant::Now();
 
         CA_LOG_D("Start distributed commit with TxId=" << *TxId);
@@ -1878,10 +1984,9 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
         SendCommitToCoordinator();
     }
 
-    void Rollback() {
+    void Rollback(NWilson::TTraceId traceId) {
         Counters->BufferActorRollbacks->Inc();
-        BufferWriteActorState = NWilson::TSpan(TWilsonKqp::BufferWriteActorState, BufferWriteActor.GetTraceId(),
-            "BufferWriteActorState::RollingBack", NWilson::EFlags::AUTO_END);
+        UpdateTracingState("RollBack", std::move(traceId));
 
         CA_LOG_D("Start rollback");
         State = EState::ROLLINGBACK;
@@ -1938,7 +2043,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
                 new TEvPipeCache::TEvForward(evWrite.release(), shardId, /* subscribe */ true),
                 0,
                 0,
-                BufferWriteActor.GetTraceId());
+                BufferWriteActorStateSpan.GetTraceId());
         }
     }
 
@@ -1980,7 +2085,6 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
             }
 
             SendTime[tabletId] = TInstant::Now();
-            auto traceId = BufferWriteActor.GetTraceId();
 
             CA_LOG_D("Executing KQP transaction on topic tablet: " << tabletId
             << ", writeId: " << writeId << ", isImmediateCommit: " << isImmediateCommit);
@@ -1990,7 +2094,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
                 new TEvPipeCache::TEvForward(ev.release(), tabletId, /* subscribe */ true),
                 0,
                 0,
-                std::move(traceId));
+                BufferWriteActorStateSpan.GetTraceId());
         }
     }
 
@@ -2029,7 +2133,10 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
             << ", shards: " << affectedSet.size());
         Send(
             MakePipePerNodeCacheID(false),
-            new TEvPipeCache::TEvForward(ev.Release(), *Coordinator, /* subscribe */ true));
+            new TEvPipeCache::TEvForward(ev.Release(), *Coordinator, /* subscribe */ true),
+            0,
+            0,
+            BufferWriteActorStateSpan.GetTraceId());
     }
 
     void Close() {
@@ -2209,7 +2316,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
                 ReplyErrorAndDie(
                     NYql::NDqProto::StatusIds::UNAVAILABLE,
                     NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,
-                    TStringBuilder() << "Failed to deviler message to coordinator.",
+                    TStringBuilder() << "Kikimr cluster or one of its subsystems was unavailable. Failed to deviler message to coordinator.",
                     {});
                 return;
             }
@@ -2222,22 +2329,32 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
             ReplyErrorAndDie(
                     NYql::NDqProto::StatusIds::UNDETERMINED,
                     NYql::TIssuesIds::KIKIMR_OPERATION_STATE_UNKNOWN,
-                    TStringBuilder() << "Failed to deviler message to coordinator.",
+                    TStringBuilder() << "State of operation is unknown. Failed to deviler message to coordinator.",
                     {});
             return;
         }
 
-        ReplyErrorAndDie(
-            NYql::NDqProto::StatusIds::UNAVAILABLE,
-            NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,
-            TStringBuilder() << "Failed to deviler message.",
-            {});
+        if (State == EState::COMMITTING) {
+            ReplyErrorAndDie(
+                NYql::NDqProto::StatusIds::UNDETERMINED,
+                NYql::TIssuesIds::KIKIMR_OPERATION_STATE_UNKNOWN,
+                TStringBuilder() << "State of operation is unknown. Failed to deviler message.",
+                {});
+            return;
+        } else {
+            ReplyErrorAndDie(
+                NYql::NDqProto::StatusIds::UNAVAILABLE,
+                NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,
+                TStringBuilder() << "Kikimr cluster or one of its subsystems was unavailable. Failed to deviler message.",
+                {});
+            return;
+        }
     }
 
     void Handle(TEvKqpBuffer::TEvTerminate::TPtr&) {
         if (State != EState::ROLLINGBACK && State != EState::FINISHED) {
             CancelProposal();
-            Rollback();
+            Rollback(BufferWriteActorSpan.GetTraceId());
         }
         PassAway();
     }
@@ -2247,7 +2364,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
         for (auto& [_, info] : WriteInfos) {
             info.WriteTableActor->FlushBuffers();
         }
-        Flush();
+        Flush(std::move(ev->TraceId));
     }
 
     void Handle(TEvKqpBuffer::TEvCommit::TPtr& ev) {
@@ -2257,23 +2374,23 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
         }
 
         if (!TxManager->NeedCommit()) {
-            RollbackAndDie();
+            RollbackAndDie(std::move(ev->TraceId));
         } else if (TxManager->IsSingleShard() && !TxManager->HasOlapTable() && (!WriteInfos.empty() || TxManager->HasTopics())) {
             TxManager->StartExecute();
-            ImmediateCommit();
+            ImmediateCommit(std::move(ev->TraceId));
         } else {
             TxManager->StartPrepare();
-            Prepare(ev->Get()->TxId);
+            Prepare(ev->Get()->TxId, std::move(ev->TraceId));
         }
     }
 
     void Handle(TEvKqpBuffer::TEvRollback::TPtr& ev) {
         ExecuterActorId = ev->Get()->ExecuterActorId;
-        RollbackAndDie();
+        RollbackAndDie(std::move(ev->TraceId));
     }
 
-    void RollbackAndDie() {
-        Rollback();
+    void RollbackAndDie(NWilson::TTraceId traceId) {
+        Rollback(std::move(traceId));
         Send<ESendingType::Tail>(ExecuterActorId, new TEvKqpBuffer::TEvResult{});
         PassAway();
     }
@@ -2306,9 +2423,11 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
                 }
                 builder << "`" << path << "`";
             }
-            return builder;
+            return (tableInfo.Pathes.size() == 1 ? "Table: " : "Tables: ")  + builder;
         };
 
+        TxManager->AddParticipantNode(ev->Sender.NodeId());
+
         // TODO: get rid of copy-paste
         switch (ev->Get()->GetStatus()) {
         case NKikimrDataEvents::TEvWriteResult::STATUS_UNSPECIFIED: {
@@ -2320,7 +2439,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
             ReplyErrorAndDie(
                 NYql::NDqProto::StatusIds::UNSPECIFIED,
                 NYql::TIssuesIds::DEFAULT_ERROR,
-                TStringBuilder() << "Unspecified error for tables `" << getPathes() << "`. "
+                TStringBuilder() << "Unspecified error. " << getPathes() << ". "
                     << getIssues().ToOneLineString(),
                 getIssues());
             return;
@@ -2342,7 +2461,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
             ReplyErrorAndDie(
                 NYql::NDqProto::StatusIds::ABORTED,
                 NYql::TIssuesIds::KIKIMR_OPERATION_ABORTED,
-                TStringBuilder() << "Aborted for tables " << getPathes() << ". ",
+                TStringBuilder() << "Operation aborted.",
                 getIssues());
             return;
         }
@@ -2353,9 +2472,9 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
                     << getIssues().ToOneLineString());
             TxManager->SetError(ev->Get()->Record.GetOrigin());
             ReplyErrorAndDie(
-                NYql::NDqProto::StatusIds::PRECONDITION_FAILED,
+                NYql::NDqProto::StatusIds::UNAVAILABLE,
                 NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,
-                TStringBuilder() << "Wrong shard state for tables " << getPathes() << ".",
+                TStringBuilder() << "Wrong shard state. " << getPathes() << ".",
                 getIssues());
             return;
         }
@@ -2368,7 +2487,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
             ReplyErrorAndDie(
                 NYql::NDqProto::StatusIds::INTERNAL_ERROR,
                 NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,
-                TStringBuilder() << "Internal error for tables " << getPathes() << ".",
+                TStringBuilder() << "Internal error while executing transaction.",
                 getIssues());
             return;
         }
@@ -2381,9 +2500,23 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
             ReplyErrorAndDie(
                 NYql::NDqProto::StatusIds::UNAVAILABLE,
                 NYql::TIssuesIds::KIKIMR_DISK_SPACE_EXHAUSTED,
-                TStringBuilder() << "Disk space exhausted for tables " << getPathes() << ".",
+                TStringBuilder() << "Disk space exhausted. " << getPathes() << ".",
                 getIssues());
-                return;
+            return;
+        }
+        case NKikimrDataEvents::TEvWriteResult::STATUS_OUT_OF_SPACE: {
+            CA_LOG_W("Got OUT_OF_SPACE for tables."
+                << " ShardID=" << ev->Get()->Record.GetOrigin() << ","
+                << " Sink=" << this->SelfId() << "."
+                << " Ignored this error."
+                << getIssues().ToOneLineString());
+            TxManager->SetError(ev->Get()->Record.GetOrigin());
+            ReplyErrorAndDie(
+                NYql::NDqProto::StatusIds::OVERLOADED,
+                NYql::TIssuesIds::KIKIMR_OVERLOADED,
+                TStringBuilder() << "Tablet " << ev->Get()->Record.GetOrigin() << " is out of space. " << getPathes() << ".",
+                getIssues());
+            return;
         }
         case NKikimrDataEvents::TEvWriteResult::STATUS_OVERLOADED: {
             CA_LOG_W("Got OVERLOADED for tables."
@@ -2395,7 +2528,9 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
             ReplyErrorAndDie(
                 NYql::NDqProto::StatusIds::OVERLOADED,
                 NYql::TIssuesIds::KIKIMR_OVERLOADED,
-                TStringBuilder() << "Tablet " << ev->Get()->Record.GetOrigin() << "(" << getPathes() << ")" << " is overloaded.",
+                TStringBuilder() << "Kikimr cluster or one of its subsystems is overloaded."
+                    << " Tablet " << ev->Get()->Record.GetOrigin() << " is overloaded."
+                    << " " << getPathes() << ".",
                 getIssues());
             return;
         }
@@ -2408,7 +2543,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
             ReplyErrorAndDie(
                 NYql::NDqProto::StatusIds::CANCELLED,
                 NYql::TIssuesIds::KIKIMR_OPERATION_CANCELLED,
-                TStringBuilder() << "Cancelled request to tables " << getPathes() << ".",
+                TStringBuilder() << "Operation cancelled.",
                 getIssues());
             return;
         }
@@ -2421,7 +2556,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
             ReplyErrorAndDie(
                 NYql::NDqProto::StatusIds::BAD_REQUEST,
                 NYql::TIssuesIds::KIKIMR_BAD_REQUEST,
-                TStringBuilder() << "Bad request. Tables: " << getPathes() << ".",
+                TStringBuilder() << "Bad request. " << getPathes() << ".",
                 getIssues());
             return;
         }
@@ -2434,7 +2569,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
             ReplyErrorAndDie(
                 NYql::NDqProto::StatusIds::SCHEME_ERROR,
                 NYql::TIssuesIds::KIKIMR_SCHEME_MISMATCH,
-                TStringBuilder() << "Scheme changed. Tables: " << getPathes() << ".",
+                TStringBuilder() << "Scheme changed. " << getPathes() << ".",
                 getIssues());
             return;
         }
@@ -2449,7 +2584,9 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
             ReplyErrorAndDie(
                 NYql::NDqProto::StatusIds::ABORTED,
                 NYql::TIssuesIds::KIKIMR_LOCKS_INVALIDATED,
-                TStringBuilder() << "Transaction locks invalidated. Tables: " << getPathes() << ".",
+                TStringBuilder()
+                    << "Transaction locks invalidated. "
+                    << getPathes() << ".",
                 getIssues());
             return;
         }
@@ -2462,7 +2599,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
             ReplyErrorAndDie(
                 NYql::NDqProto::StatusIds::PRECONDITION_FAILED,
                 NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION,
-                TStringBuilder() << "Constraint violated. Tables: " << getPathes() << ".",
+                TStringBuilder() << "Constraint violated. " << getPathes() << ".",
                 getIssues());
             return;
         }
@@ -2571,11 +2708,21 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
         Process();
     }
 
-    void OnPrepared(IKqpTransactionManager::TPrepareResult&& preparedInfo, ui64 dataSize) override {
+    void OnPrepared(IKqpTransactionManager::TPrepareResult&& preparedInfo, ui64) override {
         if (State != EState::PREPARING) {
             return;
         }
-        Y_UNUSED(preparedInfo, dataSize);
+        if (!preparedInfo.Coordinator || (TxManager->GetCoordinator() && preparedInfo.Coordinator != TxManager->GetCoordinator())) {
+            CA_LOG_E("Handle TEvWriteResult: unable to select coordinator. Tx canceled, actorId: " << SelfId()
+                << ", previously selected coordinator: " << TxManager->GetCoordinator()
+                << ", coordinator selected at propose result: " << preparedInfo.Coordinator);
+
+            TxProxyMon->TxResultAborted->Inc();
+            ReplyErrorAndDie(NYql::NDqProto::StatusIds::CANCELLED,
+                NKikimrIssues::TIssuesIds::TX_DECLINED_IMPLICIT_COORDINATOR,
+                "Unable to choose coordinator.");
+            return;
+        }
         if (TxManager->ConsumePrepareTransactionResult(std::move(preparedInfo))) {
             OnOperationFinished(Counters->BufferActorPrepareLatencyHistogram);
             TxManager->StartExecute();
@@ -2586,11 +2733,10 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
         Process();
     }
 
-    void OnCommitted(ui64 shardId, ui64 dataSize) override {
+    void OnCommitted(ui64 shardId, ui64) override {
         if (State != EState::COMMITTING) {
             return;
         }
-        Y_UNUSED(dataSize);
         if (TxManager->ConsumeCommitResult(shardId)) {
             CA_LOG_D("Committed TxId=" << TxId.value_or(0));
             OnOperationFinished(Counters->BufferActorCommitLatencyHistogram);
@@ -2605,15 +2751,13 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
         }
     }
 
-    void OnMessageAcknowledged(ui64 dataSize) override {
-        Y_UNUSED(dataSize);
+    void OnMessageAcknowledged(ui64) override {
         Process();
     }
 
     void OnFlushed() {
         YQL_ENSURE(State == EState::FLUSHING);
-        BufferWriteActorState = NWilson::TSpan(TWilsonKqp::BufferWriteActorState, BufferWriteActor.GetTraceId(),
-            "BufferWriteActorState::Writing", NWilson::EFlags::AUTO_END);
+        UpdateTracingState("Write", BufferWriteActorSpan.GetTraceId());
         OnOperationFinished(Counters->BufferActorFlushLatencyHistogram);
         State = EState::WRITING;
         Send<ESendingType::Tail>(ExecuterActorId, new TEvKqpBuffer::TEvResult{
@@ -2621,6 +2765,10 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
         });
         ExecuterActorId = {};
         Y_ABORT_UNLESS(GetTotalMemory() == 0);
+
+        for (auto& [_, info] : WriteInfos) {
+            info.WriteTableActor->Unlink();
+        }
     }
 
     void OnError(NYql::NDqProto::StatusIds::StatusCode statusCode, NYql::EYqlIssueCode id, const TString& message, const NYql::TIssues& subIssues) override {
@@ -2631,9 +2779,8 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
         ReplyErrorAndDie(statusCode, std::move(issues));
     }
 
-    void ReplyErrorAndDie(NYql::NDqProto::StatusIds::StatusCode statusCode, NYql::EYqlIssueCode id, const TString& message, const NYql::TIssues& subIssues = {}) {
-        BufferWriteActorState.EndError(message);
-        BufferWriteActor.EndError(message);
+    void ReplyErrorAndDie(NYql::NDqProto::StatusIds::StatusCode statusCode, auto id, const TString& message, const NYql::TIssues& subIssues = {}) {
+        BufferWriteActorStateSpan.EndError(message);
 
         NYql::TIssue issue(message);
         SetIssueCode(id, issue);
@@ -2648,12 +2795,22 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
     }
 
     void ReplyErrorAndDie(NYql::NDqProto::StatusIds::StatusCode statusCode, NYql::TIssues&& issues) {
-        BufferWriteActorState.EndError(issues.ToOneLineString());
-        BufferWriteActor.EndError(issues.ToOneLineString());
+        BufferWriteActorStateSpan.EndError(issues.ToOneLineString());
 
         ReplyErrorAndDieImpl(statusCode, std::move(issues));
     }
 
+    void UpdateTracingState(const char* name, NWilson::TTraceId traceId) {
+        BufferWriteActorStateSpan = NWilson::TSpan(TWilsonKqp::BufferWriteActorState, std::move(traceId),
+            name, NWilson::EFlags::AUTO_END);
+        if (BufferWriteActorStateSpan.GetTraceId() != BufferWriteActorSpan.GetTraceId()) {
+            BufferWriteActorStateSpan.Link(BufferWriteActorSpan.GetTraceId());
+        }
+        for (auto& [_, info] : WriteInfos) {
+            info.WriteTableActor->SetParentTraceId(BufferWriteActorStateSpan.GetTraceId());
+        }
+    }
+
     void ReplyErrorAndDieImpl(NYql::NDqProto::StatusIds::StatusCode statusCode, NYql::TIssues&& issues) {
         CA_LOG_E("statusCode=" << NYql::NDqProto::StatusIds_StatusCode_Name(statusCode) << ". Issue=" << issues.ToString() << ". sessionActorId=" << SessionActorId << ". isRollback=" << (State == EState::ROLLINGBACK));
 
@@ -2662,7 +2819,7 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
 
         CancelProposal();
         if (State != EState::ROLLINGBACK) {
-            Rollback();
+            Rollback(BufferWriteActorSpan.GetTraceId());
             // Rollback can't finish with error
             Send<ESendingType::Tail>(SessionActorId, new TEvKqpBuffer::TEvError{
                 statusCode,
@@ -2716,7 +2873,6 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
     std::optional<ui64> Coordinator;
 
     std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;
-    NMiniKQL::TTypeEnvironment TypeEnv;
 
     struct TWriteInfo {
         TKqpTableWriteActor* WriteTableActor = nullptr;
@@ -2736,15 +2892,13 @@ class TKqpBufferWriteActor :public TActorBootstrapped<TKqpBufferWriteActor>, pub
     };
     std::queue<TAckMessage> AckQueue;
 
-    IShardedWriteControllerPtr ShardedWriteController = nullptr;
-
     TIntrusivePtr<TKqpCounters> Counters;
     TIntrusivePtr<NTxProxy::TTxProxyMon> TxProxyMon;
     THashMap<ui64, TInstant> SendTime;
     TInstant OperationStartTime;
 
-    NWilson::TSpan BufferWriteActor;
-    NWilson::TSpan BufferWriteActorState;
+    NWilson::TSpan BufferWriteActorSpan;
+    NWilson::TSpan BufferWriteActorStateSpan;
 };
 
 class TKqpForwardWriteActor : public TActorBootstrapped<TKqpForwardWriteActor>, public NYql::NDq::IDqComputeActorAsyncOutput {
@@ -2758,6 +2912,7 @@ class TKqpForwardWriteActor : public TActorBootstrapped<TKqpForwardWriteActor>,
         : LogPrefix(TStringBuilder() << "TxId: " << args.TxId << ", task: " << args.TaskId << ". ")
         , Settings(std::move(settings))
         , MessageSettings(GetWriteActorSettings())
+        , Alloc(args.Alloc)
         , OutputIndex(args.OutputIndex)
         , Callbacks(args.Callback)
         , Counters(counters)
@@ -2767,7 +2922,7 @@ class TKqpForwardWriteActor : public TActorBootstrapped<TKqpForwardWriteActor>,
             Settings.GetTable().GetOwnerId(),
             Settings.GetTable().GetTableId(),
             Settings.GetTable().GetVersion())
-        , ForwardWriteActorSpan(TWilsonKqp::ForwardWriteActor, NWilson::TTraceId(args.TraceId), "TKqpForwardWriteActor")
+        , ForwardWriteActorSpan(TWilsonKqp::ForwardWriteActor, NWilson::TTraceId(args.TraceId), "ForwardWriteActor")
     {
         EgressStats.Level = args.StatsLevel;
 
@@ -2777,10 +2932,11 @@ class TKqpForwardWriteActor : public TActorBootstrapped<TKqpForwardWriteActor>,
         std::vector<ui32> writeIndex(
             Settings.GetWriteIndexes().begin(),
             Settings.GetWriteIndexes().end());
+        TGuard guard(*Alloc);
         if (Settings.GetIsOlap()) {
-            Batcher = CreateColumnDataBatcher(columnsMetadata, std::move(writeIndex));
+            Batcher = CreateColumnDataBatcher(columnsMetadata, std::move(writeIndex), Alloc);
         } else {
-            Batcher = CreateRowDataBatcher(columnsMetadata, std::move(writeIndex));
+            Batcher = CreateRowDataBatcher(columnsMetadata, std::move(writeIndex), Alloc);
         }
 
         Counters->ForwardActorsCount->Inc();
@@ -2805,6 +2961,7 @@ class TKqpForwardWriteActor : public TActorBootstrapped<TKqpForwardWriteActor>,
             RuntimeError(
                 CurrentExceptionMessage(),
                 NYql::NDqProto::StatusIds::INTERNAL_ERROR);
+            return;
         }
     }
 
@@ -2836,6 +2993,7 @@ class TKqpForwardWriteActor : public TActorBootstrapped<TKqpForwardWriteActor>,
         auto ev = std::make_unique<TEvBufferWrite>();
 
         ev->Data = Batcher->Build();
+        ev->Data->DetachAlloc();
         ev->Close = Closed;
 
         if (!WriteToken.IsEmpty()) {
@@ -2934,6 +3092,7 @@ class TKqpForwardWriteActor : public TActorBootstrapped<TKqpForwardWriteActor>,
     TString LogPrefix;
     const NKikimrKqp::TKqpTableSinkSettings Settings;
     TWriteActorSettings MessageSettings;
+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;
     const ui64 OutputIndex;
     NYql::NDq::TDqAsyncStats EgressStats;
     NYql::NDq::IDqComputeActorAsyncOutput::ICallbacks * Callbacks = nullptr;
diff --git a/ydb/core/kqp/runtime/kqp_write_actor_settings.h b/ydb/core/kqp/runtime/kqp_write_actor_settings.h
index 37e8bfe91055..9b02d8e246b9 100644
--- a/ydb/core/kqp/runtime/kqp_write_actor_settings.h
+++ b/ydb/core/kqp/runtime/kqp_write_actor_settings.h
@@ -10,7 +10,6 @@ namespace NKqp {
 struct TWriteActorSettings : TAtomicRefCount<TWriteActorSettings> {
     i64 InFlightMemoryLimitPerActorBytes = 64_MB;
     i64 MemoryLimitPerMessageBytes = 64_MB;
-    i64 MaxBatchesPerMessage = 1000;
     i64 MaxForwardedSize = 64_MB;
 
     TDuration StartRetryDelay = TDuration::Seconds(1);
diff --git a/ydb/core/kqp/runtime/kqp_write_table.cpp b/ydb/core/kqp/runtime/kqp_write_table.cpp
index a917a72c1382..a96793dd1ab6 100644
--- a/ydb/core/kqp/runtime/kqp_write_table.cpp
+++ b/ydb/core/kqp/runtime/kqp_write_table.cpp
@@ -4,6 +4,7 @@
 #include <util/generic/yexception.h>
 #include <ydb/core/engine/mkql_keys.h>
 #include <ydb/core/formats/arrow/arrow_batch_builder.h>
+#include <ydb/core/kqp/runtime/kqp_arrow_memory_pool.h>
 #include <ydb/core/tx/data_events/events.h>
 #include <ydb/core/tx/data_events/payload_helper.h>
 #include <ydb/core/tx/schemeshard/olap/schema/schema.h>
@@ -17,87 +18,244 @@ namespace NKqp {
 
 namespace {
 
-constexpr ui64 DataShardMaxOperationBytes = 8_MB;
-constexpr ui64 ColumnShardMaxOperationBytes = 64_MB;
+constexpr i64 DataShardMaxOperationBytes = 8_MB;
+constexpr i64 ColumnShardMaxOperationBytes = 64_MB;
+
+constexpr size_t InitialBatchPoolSize = 64_KB;
+
+class TOffloadedPoolAllocator : public IAllocator {
+public:
+    TOffloadedPoolAllocator(std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> scopedAlloc)
+        : Alloc(TDefaultAllocator::Instance())
+        , ScopedAlloc(std::move(scopedAlloc)) 
+        , AllocatedSize(0) {
+    }
+
+    ~TOffloadedPoolAllocator() {
+        Y_DEBUG_ABORT_UNLESS(AllocatedSize == 0);
+    }
+
+    TBlock Allocate(size_t len) override {
+        if (ScopedAlloc) {
+            TGuard guard(*ScopedAlloc);
+            ScopedAlloc->Ref().OffloadAlloc(len);
+        }
+        AllocatedSize += len;
+        return Alloc->Allocate(len);
+    }
+
+    void Release(const TBlock& block) override {
+        if (ScopedAlloc) {
+            TGuard guard(*ScopedAlloc);
+            ScopedAlloc->Ref().OffloadFree(block.Len);
+        }
+        AllocatedSize -= block.Len;
+        Alloc->Release(block);
+    }
+
+    void Attach(std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> scopedAlloc) {
+        AFL_ENSURE(!ScopedAlloc);
+        {
+            TGuard guard(*scopedAlloc);
+            scopedAlloc->Ref().OffloadAlloc(AllocatedSize);
+        }
+        ScopedAlloc = std::move(scopedAlloc);
+    }
+
+    void Detach() {
+        AFL_ENSURE(ScopedAlloc);
+        {
+            TGuard guard(*ScopedAlloc);
+            ScopedAlloc->Ref().OffloadFree(AllocatedSize);
+        }
+        ScopedAlloc.reset();
+    }
+
+    bool Attached() const {
+        return ScopedAlloc != nullptr;
+    }
+
+    std::unique_ptr<TMemoryPool> CreateMemoryPool() {
+        return std::make_unique<TMemoryPool>(InitialBatchPoolSize, TMemoryPool::TExpGrow::Instance(), this);
+    }
+
+private:
+    IAllocator* Alloc;
+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> ScopedAlloc;
+
+    size_t AllocatedSize;
+};
+
+using TOffloadedPoolAllocatorPtr = std::shared_ptr<TOffloadedPoolAllocator>;
+
+TOffloadedPoolAllocatorPtr CreateOffloadedPoolAllocator(
+        std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> scopedAlloc) {
+    return std::make_shared<TOffloadedPoolAllocator>(std::move(scopedAlloc));
+}
+
+template <class T>
+struct TNullableAllocLockOps {
+    static inline void Acquire(T* t) noexcept {
+        if (t) {
+            t->Acquire();
+        }
+    }
+
+    static inline void Release(T* t) noexcept {
+        if (t) {
+            t->Release();
+        }
+    }
+};
+
+using TNullableAllocGuard = TGuard<NKikimr::NMiniKQL::TScopedAlloc, TNullableAllocLockOps<NKikimr::NMiniKQL::TScopedAlloc>>;
 
-using TCharVectorPtr = std::unique_ptr<TVector<char>>;
 
 class TColumnBatch : public IDataBatch {
 public:
     using TRecordBatchPtr = std::shared_ptr<arrow::RecordBatch>;
 
     TString SerializeToString() const override {
+        AFL_ENSURE(!Extracted);
         return NArrow::SerializeBatchNoCompression(Data);
     }
 
+    i64 GetSerializedMemory() const override {
+        AFL_ENSURE(!Extracted);
+        return SerializedMemory;
+    }
+
     i64 GetMemory() const override {
+        AFL_ENSURE(!Extracted);
         return Memory;
     }
 
     bool IsEmpty() const override {
-        return GetMemory() == 0;
+        AFL_ENSURE(!Extracted);
+        return !Data || Data->num_rows() == 0;
     }
 
     TRecordBatchPtr Extract() {
+        AFL_ENSURE(!Extracted);
+        Extracted = true;
+        SerializedMemory = 0;
         Memory = 0;
-        TRecordBatchPtr result = std::move(Data);
-        return result;
+        return std::move(Data);
     }
 
     std::shared_ptr<void> ExtractBatch() override {
         return std::dynamic_pointer_cast<void>(Extract());
     }
 
-    explicit TColumnBatch(const TRecordBatchPtr& data)
-        : Data(data)
-        , Memory(NArrow::GetBatchDataSize(Data)) {
+    void DetachAlloc() override {
+        Y_ABORT_UNLESS(false); // Write to CS doesn't need to move data between allocators.
+    }
+
+    void AttachAlloc(std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc) override {
+        Y_ABORT_UNLESS(Alloc == alloc); // Write to CS doesn't need to move data between allocators.
+    }
+
+    bool AttachedAlloc() const override {
+        return true;
+    }
+
+    explicit TColumnBatch(const TRecordBatchPtr& data, std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc = nullptr)
+        : Alloc(alloc) 
+        , Data(data)
+        , SerializedMemory(NArrow::GetBatchDataSize(Data))
+        , Memory(NArrow::GetBatchMemorySize(Data)) {
+    }
+
+    ~TColumnBatch() {
+        TNullableAllocGuard guard(Alloc.get());
+        Data.reset();
     }
 
 private:
+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc = nullptr;
     TRecordBatchPtr Data;
-    i64 Memory;
+    i64 SerializedMemory = 0;
+    i64 Memory = 0;
+
+    bool Extracted = false;
 };
 
 
 class TRowBatch : public IDataBatch {
 public:
     TString SerializeToString() const override {
-        return TSerializedCellMatrix::Serialize(Cells, Rows, Columns);
+        AFL_ENSURE(!Extracted);
+        TVector<TCell> cells;
+        if (!Rows.empty()) {
+            cells.reserve(Rows.Size() * Rows.front().size());
+        }
+        for (const auto& row : Rows) {
+            for (const auto& cell : row) {
+                cells.push_back(cell);
+            }
+        }
+        return TSerializedCellMatrix::Serialize(cells, Rows.Size(), !IsEmpty() ? Rows.front().size() : 0);
+    }
+
+    i64 GetSerializedMemory() const override {
+        AFL_ENSURE(!Extracted);
+        return SerializedMemory;
     }
 
     i64 GetMemory() const override {
-        return Size;
+        AFL_ENSURE(!Extracted);
+        return Memory;
     }
 
     bool IsEmpty() const override {
-        return Cells.empty();
+        AFL_ENSURE(!Extracted);
+        return Rows.empty();
     }
 
-    std::pair<std::vector<TCell>, std::vector<TCharVectorPtr>> Extract() {
-        Size = 0;
-        Rows = 0;
-        return {std::move(Cells), std::move(Data)};
+    TOwnedCellVecBatch Extract() {
+        AFL_ENSURE(!Extracted);
+        Extracted = true;
+        return std::move(Rows);
     }
 
     std::shared_ptr<void> ExtractBatch() override {
-        auto r = std::make_shared<std::pair<std::vector<TCell>, std::vector<TCharVectorPtr>>>(std::move(Extract()));
+        auto r = std::make_shared<TOwnedCellVecBatch>(std::move(Extract()));
         return std::reinterpret_pointer_cast<void>(r);
     }
 
-    TRowBatch(std::vector<TCell>&& cells, std::vector<TCharVectorPtr>&& data, i64 size, ui32 rows, ui16 columns)
-        : Cells(std::move(cells))
-        , Data(std::move(data))
-        , Size(size)
-        , Rows(rows)
-        , Columns(columns) {
+    void DetachAlloc() override {
+        OffloadedAlloc->Detach();
+    }
+
+    void AttachAlloc(std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc) override {
+        OffloadedAlloc->Attach(alloc);
+    }
+
+    bool AttachedAlloc() const override {
+        return OffloadedAlloc->Attached();
+    }
+
+    TRowBatch(
+        TOwnedCellVecBatch&& rows,
+        TOffloadedPoolAllocatorPtr offloadedAlloc)
+            : OffloadedAlloc(std::move(offloadedAlloc))
+            , Rows(std::move(rows)) {
+        SerializedMemory = GetCellMatrixHeaderSize();
+        Memory = 0;
+        for (const auto& row : Rows) {
+            AFL_ENSURE(row.size() == Rows.front().size());
+            const auto size = EstimateSize(row);
+            SerializedMemory += GetCellHeaderSize() * row.size() + size;
+            Memory += size;
+        }
     }
 
 private:
-    std::vector<TCell> Cells;
-    std::vector<TCharVectorPtr> Data;
-    ui64 Size = 0;
-    ui32 Rows = 0;
-    ui16 Columns = 0;
+    TOffloadedPoolAllocatorPtr OffloadedAlloc;
+    TOwnedCellVecBatch Rows;
+    i64 SerializedMemory = 0;
+    i64 Memory = 0;
+    bool Extracted = false;
 };
 
 class IPayloadSerializer : public TThrRefBase {
@@ -170,7 +328,7 @@ std::vector<std::pair<TString, NScheme::TTypeInfo>> BuildBatchBuilderColumns(
     std::vector<std::pair<TString, NScheme::TTypeInfo>> result(writeIndex.size());
     for (size_t index = 0; index < inputColumns.size(); ++index) {
         const auto& column = inputColumns[index];
-        YQL_ENSURE(column.HasTypeId());
+        AFL_ENSURE(column.HasTypeId());
         auto typeInfoMod = NScheme::TypeInfoModFromProtoColumnType(column.GetTypeId(),
             column.HasTypeInfo() ? &column.GetTypeInfo() : nullptr);
         result[writeIndex[index]].first = column.GetName();
@@ -191,17 +349,14 @@ TVector<NScheme::TTypeInfo> BuildKeyColumnTypes(
     return keyColumnTypes;
 }
 
-struct TRowWithData {
-    TVector<TCell> Cells;
-    TCharVectorPtr Data;
-};
-
 class TRowBuilder {
 private:
     struct TCellInfo {
         NScheme::TTypeInfo Type;
         NUdf::TUnboxedValuePod Value;
         TString PgBinaryValue;
+
+        NYql::NDecimal::TInt128 DecimalBuf;
     };
 
 public:
@@ -211,12 +366,16 @@ class TRowBuilder {
 
     TRowBuilder& AddCell(
             const size_t index,
-            const NScheme::TTypeInfo type,
+            const NScheme::TTypeInfo& type,
             const NUdf::TUnboxedValuePod& value,
             const TString& typeMod) {
         CellsInfo[index].Type = type;
         CellsInfo[index].Value = value;
 
+        if (CellsInfo[index].Type.GetTypeId() == NUdf::TDataType<NUdf::TDecimal>::Id && value) {
+            CellsInfo[index].DecimalBuf = value.GetInt128();
+        }
+
         if (type.GetTypeId() == NScheme::NTypeIds::Pg && value) {
             auto typeDesc = type.GetPgTypeDesc();
             if (!typeMod.empty() && NPg::TypeDescNeedsCoercion(typeDesc)) {
@@ -226,7 +385,7 @@ class TRowBuilder {
                     ythrow yexception() << "BinaryTypeModFromTextTypeMod error: " << *typeModResult.Error;
                 }
 
-                YQL_ENSURE(typeModResult.Typmod != -1);
+                AFL_ENSURE(typeModResult.Typmod != -1);
                 TMaybe<TString> err;
                 CellsInfo[index].PgBinaryValue = NYql::NCommon::PgValueCoerce(value, NPg::PgTypeIdFromTypeDesc(typeDesc), typeModResult.Typmod, &err);
                 if (err) {
@@ -241,35 +400,18 @@ class TRowBuilder {
         return *this;
     }
 
-    size_t DataSize() const {
-        size_t result = 0;
-        for (const auto& cellInfo : CellsInfo) {
-            result += GetCellSize(cellInfo);
-        }
-        return result;
-    }
-
-    TRowWithData Build() {
-        TVector<TCell> cells;
-        cells.reserve(CellsInfo.size());
-        const auto size = DataSize();
-        auto data = Allocate(size);
-        char* ptr = data->data();
-
+    TConstArrayRef<TCell> BuildCells() {
+        Cells.clear();
+        Cells.reserve(CellsInfo.size());
+        
         for (const auto& cellInfo : CellsInfo) {
-            cells.push_back(BuildCell(cellInfo, ptr));
+            Cells.emplace_back(BuildCell(cellInfo));
         }
-
-        AFL_ENSURE(ptr == data->data() + size);
-
-        return TRowWithData {
-            .Cells = std::move(cells),
-            .Data = std::move(data),
-        };
+        return Cells;
     }
 
 private:
-    TCell BuildCell(const TCellInfo& cellInfo, char*& dataPtr) {
+    TCell BuildCell(const TCellInfo& cellInfo) {
         if (!cellInfo.Value) {
             return TCell();
         }
@@ -280,13 +422,8 @@ class TRowBuilder {
             KNOWN_FIXED_VALUE_TYPES(MAKE_PRIMITIVE_TYPE_CELL_CASE)
         case NUdf::TDataType<NUdf::TDecimal>::Id:
             {
-                auto intValue = cellInfo.Value.GetInt128();
-                constexpr auto valueSize = sizeof(intValue);
-
-                char* initialPtr = dataPtr;
-                std::memcpy(initialPtr, reinterpret_cast<const char*>(&intValue), valueSize);
-                dataPtr += valueSize;
-                return TCell(initialPtr, valueSize);
+                constexpr auto valueSize = sizeof(cellInfo.DecimalBuf);
+                return TCell(reinterpret_cast<const char*>(&cellInfo.DecimalBuf), valueSize);
             }
         }
 
@@ -296,44 +433,13 @@ class TRowBuilder {
             ? NYql::NUdf::TStringRef(cellInfo.PgBinaryValue)
             : cellInfo.Value.AsStringRef();
 
-        if (!isPg && TCell::CanInline(ref.Size())) {
-            return TCell(ref.Data(), ref.Size());
-        } else {
-            char* initialPtr = dataPtr;
-            std::memcpy(initialPtr, ref.Data(), ref.Size());
-            dataPtr += ref.Size();
-            return TCell(initialPtr, ref.Size());
-        }
-    }
-
-    size_t GetCellSize(const TCellInfo& cellInfo) const {
-        if (!cellInfo.Value) {
-            return 0;
-        }
-
-        switch(cellInfo.Type.GetTypeId()) {
-    #define MAKE_PRIMITIVE_TYPE_CELL_CASE_SIZE(type, layout) \
-        case NUdf::TDataType<type>::Id:
-            KNOWN_FIXED_VALUE_TYPES(MAKE_PRIMITIVE_TYPE_CELL_CASE_SIZE)
-            return 0;
-        case NUdf::TDataType<NUdf::TDecimal>::Id:
-            return sizeof(cellInfo.Value.GetInt128());
-        }
-
-        const bool isPg = cellInfo.Type.GetTypeId() == NScheme::NTypeIds::Pg;
-
-        const auto ref = isPg
-            ? NYql::NUdf::TStringRef(cellInfo.PgBinaryValue)
-            : cellInfo.Value.AsStringRef();
-
-        return (!isPg && TCell::CanInline(ref.Size())) ? 0 : ref.Size();
-    }
-
-    TCharVectorPtr Allocate(size_t size) {
-        return std::make_unique<TVector<char>>(size);
+        return TCell(ref.Data(), ref.Size());
     }
 
     TVector<TCellInfo> CellsInfo;
+    TVector<TCell> Cells;
+
+    TOwnedCellVecBatch Batch;
 };
 
 class TColumnDataBatcher : public IDataBatcher {
@@ -342,17 +448,28 @@ class TColumnDataBatcher : public IDataBatcher {
 
     TColumnDataBatcher(
         const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,
-        std::vector<ui32> writeIndex)
+        std::vector<ui32> writeIndex,
+        std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc)
             : Columns(BuildColumns(inputColumns))
             , WriteIndex(std::move(writeIndex))
-            , BatchBuilder(arrow::Compression::UNCOMPRESSED, BuildNotNullColumns(inputColumns)) {
+            , BatchBuilder(std::make_unique<NArrow::TArrowBatchBuilder>(
+                arrow::Compression::UNCOMPRESSED,
+                BuildNotNullColumns(inputColumns),
+                alloc ? NKikimr::NMiniKQL::GetArrowMemoryPool() : arrow::default_memory_pool()))
+            , Alloc(std::move(alloc)) {
         TString err;
-        if (!BatchBuilder.Start(BuildBatchBuilderColumns(WriteIndex, inputColumns), 0, 0, err)) {
+        if (!BatchBuilder->Start(BuildBatchBuilderColumns(WriteIndex, inputColumns), 0, 0, err)) {
             yexception() << "Failed to start batch builder: " + err;
         }
     }
 
+    ~TColumnDataBatcher() {
+        TNullableAllocGuard guard(Alloc.get());
+        BatchBuilder.reset();
+    }
+
     void AddData(const NMiniKQL::TUnboxedValueBatch& data) override {
+        TNullableAllocGuard guard(Alloc.get());
         TRowBuilder rowBuilder(Columns.size());
         data.ForEachRow([&](const auto& row) {
             for (size_t index = 0; index < Columns.size(); ++index) {
@@ -362,28 +479,30 @@ class TColumnDataBatcher : public IDataBatcher {
                     row.GetElement(index),
                     Columns[index].PTypeMod);
             }
-            auto rowWithData = rowBuilder.Build();
-            BatchBuilder.AddRow(TConstArrayRef<TCell>{rowWithData.Cells.begin(), rowWithData.Cells.end()});
+            BatchBuilder->AddRow(rowBuilder.BuildCells());
         });
     }
 
     i64 GetMemory() const override {
-        return BatchBuilder.Bytes();
+        return BatchBuilder->Bytes();
     }
 
     IDataBatchPtr Build() override {
-        return MakeIntrusive<TColumnBatch>(BatchBuilder.FlushBatch(true));
+        TNullableAllocGuard guard(Alloc.get());
+        auto batch = BatchBuilder->FlushBatch(true);
+        return MakeIntrusive<TColumnBatch>(std::move(batch), Alloc);
     }
 
 private:
     const TVector<TSysTables::TTableColumnInfo> Columns;
     const std::vector<ui32> WriteIndex;
-    NArrow::TArrowBatchBuilder BatchBuilder;
+    std::unique_ptr<NArrow::TArrowBatchBuilder> BatchBuilder;
+
+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;
 };
 
 class TColumnShardPayloadSerializer : public IPayloadSerializer {
     using TRecordBatchPtr = std::shared_ptr<arrow::RecordBatch>;
-    using TBatch = TColumnBatch;
 
     struct TUnpreparedBatch {
         ui64 TotalDataSize = 0;
@@ -394,14 +513,17 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {
     TColumnShardPayloadSerializer(
         const NSchemeCache::TSchemeCacheNavigate::TEntry& schemeEntry,
         const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,
-        const std::vector<ui32> writeIndex) // key columns then value columns
+        const std::vector<ui32> writeIndex,
+        std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc) // key columns then value columns
             : Columns(BuildColumns(inputColumns))
-            , WriteColumnIds(BuildWriteColumnIds(inputColumns, writeIndex)) {
-        YQL_ENSURE(schemeEntry.ColumnTableInfo);
+            , WriteColumnIds(BuildWriteColumnIds(inputColumns, writeIndex))
+            , Alloc(std::move(alloc)) {
+        AFL_ENSURE(Alloc);
+        AFL_ENSURE(schemeEntry.ColumnTableInfo);
         const auto& description = schemeEntry.ColumnTableInfo->Description;
-        YQL_ENSURE(description.HasSchema());
+        AFL_ENSURE(description.HasSchema());
         const auto& scheme = description.GetSchema();
-        YQL_ENSURE(description.HasSharding());
+        AFL_ENSURE(description.HasSharding());
         const auto& sharding = description.GetSharding();
 
         NSchemeShard::TOlapSchema olapSchema;
@@ -410,36 +532,44 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {
         if (shardingConclusion.IsFail()) {
             ythrow yexception() << "Ydb::StatusIds::SCHEME_ERROR : " <<  shardingConclusion.GetErrorMessage();
         }
-        YQL_ENSURE(shardingConclusion.GetResult() != nullptr);
+        AFL_ENSURE(shardingConclusion.GetResult() != nullptr);
         Sharding = shardingConclusion.DetachResult();
     }
 
+    ~TColumnShardPayloadSerializer() {
+        TGuard guard(*Alloc);
+        UnpreparedBatches.clear();
+        Batches.clear();
+    }
+
     void AddData(IDataBatchPtr&& batch) override {
-        YQL_ENSURE(!Closed);
+        AFL_ENSURE(!Closed);
         AddBatch(std::move(batch));
     }
 
     void AddBatch(IDataBatchPtr&& batch) override {
-        auto columnshardBatch = dynamic_cast<TBatch*>(batch.Get());
-        YQL_ENSURE(columnshardBatch);
+        TGuard guard(*Alloc);
+        auto columnshardBatch = dynamic_cast<TColumnBatch*>(batch.Get());
+        AFL_ENSURE(columnshardBatch);
         if (columnshardBatch->IsEmpty()) {
             return;
         }
         auto data = columnshardBatch->Extract();
-        YQL_ENSURE(data);
-        ShardAndFlushBatch(data, false);
+        AFL_ENSURE(data);
+        ShardAndFlushBatch(std::move(data), false);
     }
 
-    void ShardAndFlushBatch(const TRecordBatchPtr& unshardedBatch, bool force) {
-        for (auto [shardId, shardBatch] : Sharding->SplitByShardsToArrowBatches(unshardedBatch)) {
+    void ShardAndFlushBatch(TRecordBatchPtr&& unshardedBatch, bool force) {
+        for (auto [shardId, shardBatch] : Sharding->SplitByShardsToArrowBatches(
+                                                    unshardedBatch, NKikimr::NMiniKQL::GetArrowMemoryPool())) {
             const i64 shardBatchMemory = NArrow::GetBatchDataSize(shardBatch);
-            YQL_ENSURE(shardBatchMemory != 0);
+            AFL_ENSURE(shardBatchMemory != 0);
 
             ShardIds.insert(shardId);
             auto& unpreparedBatch = UnpreparedBatches[shardId];
             unpreparedBatch.TotalDataSize += shardBatchMemory;
-            unpreparedBatch.Batches.emplace_back(shardBatch);
             Memory += shardBatchMemory;
+            unpreparedBatch.Batches.emplace_back(shardBatch);
 
             FlushUnpreparedBatch(shardId, unpreparedBatch, force);
         }
@@ -452,7 +582,7 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {
             while (!unpreparedBatch.Batches.empty()) {
                 auto batch = unpreparedBatch.Batches.front();
                 unpreparedBatch.Batches.pop_front();
-                YQL_ENSURE(batch->num_rows() > 0);
+                AFL_ENSURE(batch->num_rows() > 0);
                 const auto batchDataSize = NArrow::GetBatchDataSize(batch);
                 unpreparedBatch.TotalDataSize -= batchDataSize;
                 Memory -= batchDataSize;
@@ -467,14 +597,14 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {
                     i64 nextRowSize = rowCalculator.GetRowBytesSize(index);
 
                     if (toPrepareSize + nextRowSize >= (i64)ColumnShardMaxOperationBytes) {
-                        YQL_ENSURE(index > 0);
+                        AFL_ENSURE(index > 0);
 
                         toPrepare.push_back(batch->Slice(0, index));
                         unpreparedBatch.Batches.push_front(batch->Slice(index, batch->num_rows() - index));
 
                         const auto newBatchDataSize = NArrow::GetBatchDataSize(unpreparedBatch.Batches.front());
 
-                        unpreparedBatch.TotalDataSize += batchDataSize;
+                        unpreparedBatch.TotalDataSize += newBatchDataSize;
                         Memory += newBatchDataSize;
 
                         splitted = true;
@@ -491,10 +621,10 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {
                 toPrepare.push_back(batch);
             }
 
-            auto batch = MakeIntrusive<TBatch>(NArrow::CombineBatches(toPrepare));
+            auto batch = MakeIntrusive<TColumnBatch>(NArrow::CombineBatches(toPrepare), Alloc);
             Batches[shardId].emplace_back(batch);
             Memory += batch->GetMemory();
-            YQL_ENSURE(batch->GetMemory() != 0);
+            AFL_ENSURE(batch->GetMemory() != 0);
         }
     }
 
@@ -517,7 +647,8 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {
     }
 
     void Close() override {
-        YQL_ENSURE(!Closed);
+        TGuard guard(*Alloc);
+        AFL_ENSURE(!Closed);
         Closed = true;
         FlushUnpreparedForce();
     }
@@ -535,6 +666,7 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {
     }
 
     TBatches FlushBatchesForce() override {
+        TGuard guard(*Alloc);
         FlushUnpreparedForce();
 
         TBatches newBatches;
@@ -548,6 +680,7 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {
     }
 
     IDataBatchPtr FlushBatch(ui64 shardId) override {
+        TGuard guard(*Alloc);
         if (!Batches.contains(shardId)) {
             return {};
         }
@@ -573,6 +706,8 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {
     const TVector<TSysTables::TTableColumnInfo> Columns;
     const std::vector<ui32> WriteColumnIds;
 
+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;
+
     THashMap<ui64, TUnpreparedBatch> UnpreparedBatches;
     TBatches Batches;
     THashSet<ui64> ShardIds;
@@ -583,56 +718,91 @@ class TColumnShardPayloadSerializer : public IPayloadSerializer {
 };
 
 class TRowsBatcher {
+    class TBatch {
+    private:
+        i64 Memory;
+        i64 MemorySerialized;
+        TOffloadedPoolAllocatorPtr Alloc;
+        TOwnedCellVecBatch Rows;
+
+        TOwnedCellVecBatch Extract() {
+            Memory = 0;
+            MemorySerialized = 0;
+            return std::move(Rows);
+        }
+
+    public:
+        TBatch(std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc)
+            : Memory(0)
+            , MemorySerialized(GetCellMatrixHeaderSize())
+            , Alloc(CreateOffloadedPoolAllocator(std::move(alloc)))
+            , Rows(Alloc->CreateMemoryPool()) {
+        }
+
+        i64 AddRow(TConstArrayRef<TCell> row) {
+            const i64 memory = EstimateSize(row);
+            const i64 memorySerialized = memory + GetCellHeaderSize() * row.size();
+
+            Memory += memory;
+            MemorySerialized += memorySerialized;
+
+            Rows.Append(row);
+
+            return memory;
+        }
+
+        i64 GetMemorySerialized() {
+            return MemorySerialized;
+        }
+
+        i64 GetMemory() {
+            return Memory;
+        }
+
+        IDataBatchPtr Build() {
+            return MakeIntrusive<TRowBatch>(Extract(), std::move(Alloc));
+        }
+    };
+    
 public:
-    explicit TRowsBatcher(ui16 columnCount, std::optional<ui64> maxBytesPerBatch)
+    explicit TRowsBatcher(
+            ui16 columnCount,
+            std::optional<i64> maxBytesPerBatch,
+            std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc)
         : ColumnCount(columnCount)
-        , MaxBytesPerBatch(maxBytesPerBatch) {
+        , MaxBytesPerBatch(maxBytesPerBatch)
+        , Alloc(std::move(alloc)) {
     }
 
     bool IsEmpty() const {
         return Batches.empty();
     }
 
-    struct TBatch {
-        i64 Memory = 0;
-        i64 MemorySerialized = 0;
-        TVector<TCell> Cells;
-        TVector<TCharVectorPtr> Data;
-    };
-
-    TBatch Flush(bool force) {
-        TBatch res;
+    IDataBatchPtr Flush(bool force) {
         if ((!Batches.empty() && force) || Batches.size() > 1) {
-            YQL_ENSURE(MaxBytesPerBatch || Batches.size() == 1);
-            res = std::move(Batches.front());
+            AFL_ENSURE(MaxBytesPerBatch || Batches.size() == 1);
+            Memory -= Batches.front()->GetMemory();
+            auto res = Batches.front()->Build();
             Batches.pop_front();
-            Memory -= res.Memory;
+
+            return res;
         }
-        return res;
+
+        auto poolAlloc = CreateOffloadedPoolAllocator(std::move(Alloc));
+        return MakeIntrusive<TRowBatch>(TOwnedCellVecBatch(poolAlloc->CreateMemoryPool()), poolAlloc);
     }
 
-    ui64 AddRow(TRowWithData&& rowWithData) {
-        YQL_ENSURE(rowWithData.Cells.size() == ColumnCount);
-        i64 newMemory = 0;
-        for (const auto& cell : rowWithData.Cells) {
-            newMemory += cell.Size();
-        }
-        if (Batches.empty() || (MaxBytesPerBatch && newMemory + GetCellHeaderSize() * ColumnCount + Batches.back().MemorySerialized > *MaxBytesPerBatch)) {
-            Batches.emplace_back();
-            Batches.back().Memory = 0;
-            Batches.back().MemorySerialized = GetCellMatrixHeaderSize();
-        }
+    void AddRow(TConstArrayRef<TCell> row) {
+        AFL_ENSURE(row.size() == ColumnCount);
 
-        for (auto& cell : rowWithData.Cells) {
-            Batches.back().Cells.emplace_back(std::move(cell));
+        const i64 newMemory = EstimateSize(row);
+        const i64 newMemorySerialized = newMemory + GetCellHeaderSize() * ColumnCount;
+        if (Batches.empty() || (MaxBytesPerBatch && newMemorySerialized + Batches.back()->GetMemorySerialized() > *MaxBytesPerBatch)) {
+            Batches.emplace_back(std::make_unique<TBatch>(Alloc));
         }
-        Batches.back().Data.emplace_back(std::move(rowWithData.Data));
-
+        
+        AFL_ENSURE(newMemory == Batches.back()->AddRow(std::move(row)));
         Memory += newMemory;
-        Batches.back().Memory += newMemory;
-        Batches.back().MemorySerialized += newMemory + GetCellHeaderSize() * ColumnCount;
-
-        return newMemory;
     }
 
     i64 GetMemory() const {
@@ -640,22 +810,24 @@ class TRowsBatcher {
     }
 
 private:
-    std::deque<TBatch> Batches;
+    std::deque<std::unique_ptr<TBatch>> Batches;
     ui16 ColumnCount;
-    std::optional<ui64> MaxBytesPerBatch;
+    std::optional<i64> MaxBytesPerBatch;
     i64 Memory = 0;
+
+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;
 };
 
 class TRowDataBatcher : public IDataBatcher {
 public:
-    using TRecordBatchPtr = std::shared_ptr<arrow::RecordBatch>;
-
     TRowDataBatcher(
         const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,
-        std::vector<ui32> writeIndex)
+        std::vector<ui32> writeIndex,
+        std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc)
             : Columns(BuildColumns(inputColumns))
             , WriteIndex(std::move(writeIndex))
-            , RowBatcher(Columns.size(), std::nullopt) {
+            , RowBatcher(Columns.size(), std::nullopt, alloc)
+            , Alloc(alloc) {
     }
 
     void AddData(const NMiniKQL::TUnboxedValueBatch& data) override {
@@ -668,8 +840,8 @@ class TRowDataBatcher : public IDataBatcher {
                     row.GetElement(index),
                     Columns[index].PTypeMod);
             }
-            auto rowWithData = rowBuilder.Build();
-            RowBatcher.AddRow(std::move(rowWithData));
+            auto cells = rowBuilder.BuildCells();
+            RowBatcher.AddRow(cells);
         });
     }
 
@@ -678,82 +850,73 @@ class TRowDataBatcher : public IDataBatcher {
     }
 
     IDataBatchPtr Build() override {
-        auto batch = RowBatcher.Flush(true);
-        const ui32 rows = batch.Cells.size() / Columns.size();
-
-        return MakeIntrusive<TRowBatch>(
-            std::move(batch.Cells),
-            std::move(batch.Data),
-            batch.MemorySerialized,
-            rows,
-            static_cast<ui16>(Columns.size()));
+        return RowBatcher.Flush(true);
     }
 
 private:
     const TVector<TSysTables::TTableColumnInfo> Columns;
     const std::vector<ui32> WriteIndex;
     TRowsBatcher RowBatcher;
+
+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;
 };
 
 class TDataShardPayloadSerializer : public IPayloadSerializer {
-    using TBatch = TRowBatch;
-
 public:
     TDataShardPayloadSerializer(
         const TVector<TKeyDesc::TPartitionInfo>& partitioning,
         const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto>& keyColumns,
         const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto>& inputColumns,
-        std::vector<ui32> writeIndex)
+        std::vector<ui32> writeIndex,
+        std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc)
         : Partitioning(partitioning)
         , Columns(BuildColumns(inputColumns))
         , WriteIndex(std::move(writeIndex))
         , WriteColumnIds(BuildWriteColumnIds(inputColumns, WriteIndex))
-        , KeyColumnTypes(BuildKeyColumnTypes(keyColumns)) {
+        , KeyColumnTypes(BuildKeyColumnTypes(keyColumns))
+        , Alloc(std::move(alloc)) {
+        AFL_ENSURE(Alloc);
+        AFL_ENSURE(Columns.size() <= std::numeric_limits<ui16>::max());
     }
 
-    void AddRow(TRowWithData&& row, const TVector<TKeyDesc::TPartitionInfo>& partitioning) {
-        YQL_ENSURE(row.Cells.size() >= KeyColumnTypes.size());
+    void AddRow(TConstArrayRef<TCell> row, const TVector<TKeyDesc::TPartitionInfo>& partitioning) {
+        AFL_ENSURE(row.size() >= KeyColumnTypes.size());
         auto shardIter = std::lower_bound(
             std::begin(partitioning),
             std::end(partitioning),
-            TArrayRef(row.Cells.data(), KeyColumnTypes.size()),
+            TArrayRef(row.data(), KeyColumnTypes.size()),
             [this](const auto &partition, const auto& key) {
                 const auto& range = *partition.Range;
                 return 0 > CompareBorders<true, false>(range.EndKeyPrefix.GetCells(), key,
                     range.IsInclusive || range.IsPoint, true, KeyColumnTypes);
             });
 
-        YQL_ENSURE(shardIter != partitioning.end());
+        AFL_ENSURE(shardIter != partitioning.end());
 
         auto batcherIter = Batchers.find(shardIter->ShardId);
         if (batcherIter == std::end(Batchers)) {
             Batchers.emplace(
                 shardIter->ShardId,
-                TRowsBatcher(Columns.size(), DataShardMaxOperationBytes));
+                TRowsBatcher(Columns.size(), DataShardMaxOperationBytes, Alloc));
         }
 
-        Memory += Batchers.at(shardIter->ShardId).AddRow(std::move(row));
+        Batchers.at(shardIter->ShardId).AddRow(row);
         ShardIds.insert(shardIter->ShardId);
     }
 
     void AddData(IDataBatchPtr&& data) override {
-        YQL_ENSURE(!Closed);
+        AFL_ENSURE(!Closed);
         AddBatch(std::move(data));
     }
 
     void AddBatch(IDataBatchPtr&& batch) override {
-        auto datashardBatch = dynamic_cast<TBatch*>(batch.Get());
-        YQL_ENSURE(datashardBatch);
-        auto [cells, data] = datashardBatch->Extract();
-        const auto rows = cells.size() / Columns.size();
-        YQL_ENSURE(cells.size() == rows * Columns.size());
+        auto datashardBatch = dynamic_cast<TRowBatch*>(batch.Get());
+        AFL_ENSURE(datashardBatch);
+        auto rows = datashardBatch->Extract();
 
-        for (size_t rowIndex = 0; rowIndex < rows; ++rowIndex) {
+        for (const auto& row : rows) {
             AddRow(
-                TRowWithData{
-                    TVector<TCell>(cells.begin() + (rowIndex * Columns.size()), cells.begin() + (rowIndex * Columns.size()) + Columns.size()),
-                    std::move(data[rowIndex]),
-                },
+                row,
                 Partitioning);
         }
     }
@@ -767,11 +930,15 @@ class TDataShardPayloadSerializer : public IPayloadSerializer {
     }
 
     i64 GetMemory() override {
-        return Memory;
+        i64 memory = 0;
+        for (const auto& [_, batcher] : Batchers) {
+            memory += batcher.GetMemory();
+        }
+        return memory;
     }
 
     void Close() override {
-        YQL_ENSURE(!Closed);
+        AFL_ENSURE(!Closed);
         Closed = true;
     }
 
@@ -788,16 +955,7 @@ class TDataShardPayloadSerializer : public IPayloadSerializer {
     }
 
     IDataBatchPtr ExtractNextBatch(TRowsBatcher& batcher, bool force) {
-        auto batchResult = batcher.Flush(force);
-        Memory -= batchResult.Memory;
-        const ui32 rows = batchResult.Cells.size() / Columns.size();
-        YQL_ENSURE(Columns.size() <= std::numeric_limits<ui16>::max());
-        return MakeIntrusive<TRowBatch>(
-            std::move(batchResult.Cells),
-            std::move(batchResult.Data),
-            static_cast<i64>(batchResult.MemorySerialized),
-            rows,
-            static_cast<ui16>(Columns.size()));
+        return batcher.Flush(force);
     }
 
     TBatches FlushBatchesForce() override {
@@ -833,41 +991,42 @@ class TDataShardPayloadSerializer : public IPayloadSerializer {
     const std::vector<ui32> WriteIndex;
     const std::vector<ui32> WriteColumnIds;
     const TVector<NScheme::TTypeInfo> KeyColumnTypes;
+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;
 
     THashMap<ui64, TRowsBatcher> Batchers;
     THashSet<ui64> ShardIds;
 
-    i64 Memory = 0;
-
     bool Closed = false;
 };
 IPayloadSerializerPtr CreateColumnShardPayloadSerializer(
         const NSchemeCache::TSchemeCacheNavigate::TEntry& schemeEntry,
         const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,
-        const std::vector<ui32> writeIndex) {
+        const std::vector<ui32> writeIndex,
+        std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc) {
     return MakeIntrusive<TColumnShardPayloadSerializer>(
-        schemeEntry, inputColumns, std::move(writeIndex));
+        schemeEntry, inputColumns, std::move(writeIndex), std::move(alloc));
 }
 
 IPayloadSerializerPtr CreateDataShardPayloadSerializer(
         const TVector<TKeyDesc::TPartitionInfo>& partitioning,
         const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> keyColumns,
         const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,
-        const std::vector<ui32> writeIndex) {
+        const std::vector<ui32> writeIndex,
+        std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc) {
     return MakeIntrusive<TDataShardPayloadSerializer>(
-        partitioning, keyColumns, inputColumns, std::move(writeIndex));
+        partitioning, keyColumns, inputColumns, std::move(writeIndex), std::move(alloc));
 }
 
 }
 
 IDataBatcherPtr CreateColumnDataBatcher(const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,
-        std::vector<ui32> writeIndex) {
-    return MakeIntrusive<TColumnDataBatcher>(inputColumns, std::move(writeIndex));
+        std::vector<ui32> writeIndex, std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc) {
+    return MakeIntrusive<TColumnDataBatcher>(inputColumns, std::move(writeIndex), std::move(alloc));
 }
 
 IDataBatcherPtr CreateRowDataBatcher(const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,
-        std::vector<ui32> writeIndex) {
-    return MakeIntrusive<TRowDataBatcher>(inputColumns, std::move(writeIndex));
+        std::vector<ui32> writeIndex, std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc) {
+    return MakeIntrusive<TRowDataBatcher>(inputColumns, std::move(writeIndex), std::move(alloc));
 }
 
 bool IDataBatch::IsEmpty() const {
@@ -894,6 +1053,10 @@ struct TBatchWithMetadata {
         return Data == nullptr;
     }
 
+    i64 GetSerializedMemory() const {
+        return IsCoveringBatch() ? 0 : Data->GetSerializedMemory();
+    }
+
     i64 GetMemory() const {
         return IsCoveringBatch() ? 0 : Data->GetMemory();
     }
@@ -927,20 +1090,21 @@ class TShardsInfo {
             return IsClosed() && IsEmpty();
         }
 
-        void MakeNextBatches(i64 maxDataSize, ui64 maxCount) {
-            YQL_ENSURE(BatchesInFlight == 0);
-            YQL_ENSURE(!IsEmpty());
-            YQL_ENSURE(maxCount != 0);
+        void MakeNextBatches(i64 maxDataSize, std::optional<ui64> maxCount) {
+            AFL_ENSURE(BatchesInFlight == 0);
+            AFL_ENSURE(!IsEmpty());
             i64 dataSize = 0;
             // For columnshard batch can be slightly larger than the limit.
-            while (BatchesInFlight < maxCount
+            while ((!maxCount || BatchesInFlight < *maxCount)
                     && BatchesInFlight < Batches.size()
-                    && (dataSize + GetBatch(BatchesInFlight).GetMemory() <= maxDataSize || BatchesInFlight == 0)) {
-                dataSize += GetBatch(BatchesInFlight).GetMemory();
+                    && (dataSize + GetBatch(BatchesInFlight).GetSerializedMemory() <= maxDataSize || BatchesInFlight == 0)) {
+                dataSize += GetBatch(BatchesInFlight).GetSerializedMemory();
                 ++BatchesInFlight;
             }
-            YQL_ENSURE(BatchesInFlight != 0);
-            YQL_ENSURE(BatchesInFlight == Batches.size() || BatchesInFlight >= maxCount || dataSize + GetBatch(BatchesInFlight).GetMemory() > maxDataSize);
+            AFL_ENSURE(BatchesInFlight != 0);
+            AFL_ENSURE(BatchesInFlight == Batches.size()
+                || (maxCount && BatchesInFlight >= *maxCount)
+                || dataSize + GetBatch(BatchesInFlight).GetSerializedMemory() > maxDataSize);
         }
 
         TBatchWithMetadata& GetBatch(size_t index) {
@@ -958,7 +1122,9 @@ class TShardsInfo {
             if (BatchesInFlight != 0 && Cookie == cookie) {
                 TBatchInfo result;
                 for (size_t index = 0; index < BatchesInFlight; ++index) {
-                    result.DataSize += Batches.front().GetMemory();
+                    const i64 batchMemory = Batches.front().GetMemory();
+                    result.DataSize += batchMemory;
+                    Memory -= batchMemory;
                     Batches.pop_front();
                 }
 
@@ -966,14 +1132,13 @@ class TShardsInfo {
                 SendAttempts = 0;
                 BatchesInFlight = 0;
 
-                Memory -= result.DataSize;
                 return result;
             }
             return std::nullopt;
         }
 
         void PushBatch(TBatchWithMetadata&& batch) {
-            YQL_ENSURE(!IsClosed());
+            AFL_ENSURE(!IsClosed());
             Batches.emplace_back(std::move(batch));
             Memory += Batches.back().GetMemory();
             HasReadInBatch |= Batches.back().HasRead;
@@ -1101,7 +1266,8 @@ class TShardedWriteController : public IShardedWriteController {
             writeInfo.Serializer = CreateColumnShardPayloadSerializer(
                 *SchemeEntry,
                 writeInfo.Metadata.InputColumnsMetadata,
-                writeInfo.Metadata.WriteIndex);
+                writeInfo.Metadata.WriteIndex,
+                Alloc);
         }
         AfterPartitioningChanged();
     }
@@ -1116,7 +1282,8 @@ class TShardedWriteController : public IShardedWriteController {
                 *Partitioning,
                 writeInfo.Metadata.KeyColumnsMetadata,
                 writeInfo.Metadata.InputColumnsMetadata,
-                writeInfo.Metadata.WriteIndex);
+                writeInfo.Metadata.WriteIndex,
+                Alloc);
         }
         AfterPartitioningChanged();
     }
@@ -1181,22 +1348,27 @@ class TShardedWriteController : public IShardedWriteController {
                 *Partitioning,
                 iter->second.Metadata.KeyColumnsMetadata,
                 iter->second.Metadata.InputColumnsMetadata,
-                iter->second.Metadata.WriteIndex);
+                iter->second.Metadata.WriteIndex,
+                Alloc);
         } else if (SchemeEntry) {
             iter->second.Serializer = CreateColumnShardPayloadSerializer(
                 *SchemeEntry,
                 iter->second.Metadata.InputColumnsMetadata,
-                iter->second.Metadata.WriteIndex);
+                iter->second.Metadata.WriteIndex,
+                Alloc);
         }
         return token;
     }
 
     void Write(TWriteToken token, IDataBatchPtr&& data) override {
         auto& info = WriteInfos.at(token);
-        YQL_ENSURE(!info.Closed);
+        AFL_ENSURE(!info.Closed);
 
-        auto allocGuard = TypeEnv.BindAllocator();
-        YQL_ENSURE(info.Serializer);
+        AFL_ENSURE(info.Serializer);
+        if (!data->AttachedAlloc()) {
+            AFL_ENSURE(!Settings.Inconsistent);
+            data->AttachAlloc(Alloc);
+        }
         info.Serializer->AddData(std::move(data));
 
         if (info.Metadata.Priority == 0) {
@@ -1205,27 +1377,26 @@ class TShardedWriteController : public IShardedWriteController {
     }
 
     void Close(TWriteToken token) override {
-        auto allocGuard = TypeEnv.BindAllocator();
         auto& info = WriteInfos.at(token);
-        YQL_ENSURE(info.Serializer);
+        AFL_ENSURE(info.Serializer);
         info.Closed = true;
         info.Serializer->Close();
         if (info.Metadata.Priority == 0) {
             FlushSerializer(token, true);
-            YQL_ENSURE(info.Serializer->IsFinished());
+            AFL_ENSURE(info.Serializer->IsFinished());
         }
     }
 
     void FlushBuffers() override {
         TVector<TWriteToken> writeTokensFoFlush;
         for (const auto& [token, writeInfo] : WriteInfos) {
-            YQL_ENSURE(writeInfo.Closed);
+            AFL_ENSURE(writeInfo.Closed);
             if (writeInfo.Metadata.Priority != 0) {
                 if (!writeInfo.Serializer->IsFinished()) {
                     writeTokensFoFlush.push_back(token);
                 }
             } else {
-                YQL_ENSURE(writeInfo.Serializer->IsFinished());
+                AFL_ENSURE(writeInfo.Serializer->IsFinished());
             }
         }
 
@@ -1240,7 +1411,7 @@ class TShardedWriteController : public IShardedWriteController {
         
         for (const TWriteToken token : writeTokensFoFlush) {
             FlushSerializer(token, true);
-            YQL_ENSURE(WriteInfos.at(token).Serializer->IsFinished());
+            AFL_ENSURE(WriteInfos.at(token).Serializer->IsFinished());
         }
     }
 
@@ -1294,7 +1465,7 @@ class TShardedWriteController : public IShardedWriteController {
         for (size_t index = 0; index < shardInfo.GetBatchesInFlight(); ++index) {
             const auto& inFlightBatch = shardInfo.GetBatch(index);
             if (inFlightBatch.Data) {
-                YQL_ENSURE(!inFlightBatch.Data->IsEmpty());
+                AFL_ENSURE(!inFlightBatch.Data->IsEmpty());
                 result.TotalDataSize += inFlightBatch.Data->GetMemory();
                 const ui64 payloadIndex = NKikimr::NEvWrite::TPayloadWriter<NKikimr::NEvents::TDataEvents::TEvWrite>(evWrite)
                         .AddDataToPayload(inFlightBatch.Data->SerializeToString());
@@ -1306,7 +1477,7 @@ class TShardedWriteController : public IShardedWriteController {
                     payloadIndex,
                     writeInfo.Serializer->GetDataFormat());
             } else {
-                YQL_ENSURE(index + 1 == shardInfo.GetBatchesInFlight());   
+                AFL_ENSURE(index + 1 == shardInfo.GetBatchesInFlight());   
             }
         }
 
@@ -1314,7 +1485,6 @@ class TShardedWriteController : public IShardedWriteController {
     }
 
     std::optional<TMessageAcknowledgedResult> OnMessageAcknowledged(ui64 shardId, ui64 cookie) override {
-        auto allocGuard = TypeEnv.BindAllocator();
         auto& shardInfo = ShardsInfo.GetShard(shardId);
         const auto result = shardInfo.PopBatches(cookie);
         if (result) {
@@ -1348,7 +1518,7 @@ class TShardedWriteController : public IShardedWriteController {
             if (writeInfo.Serializer) {
                 total += writeInfo.Serializer->GetMemory();
             } else {
-                YQL_ENSURE(writeInfo.Closed);
+                AFL_ENSURE(writeInfo.Closed);
             }
         }
         return total;
@@ -1396,16 +1566,12 @@ class TShardedWriteController : public IShardedWriteController {
 
     TShardedWriteController(
         const TShardedWriteControllerSettings settings,
-        const NMiniKQL::TTypeEnvironment& typeEnv,
         std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc)
         : Settings(settings)
-        , TypeEnv(typeEnv)
-        , Alloc(alloc) {
+        , Alloc(std::move(alloc)) {
     }
 
     ~TShardedWriteController() {
-        Y_ABORT_UNLESS(Alloc);
-        TGuard<NMiniKQL::TScopedAlloc> allocGuard(*Alloc);
         ShardsInfo.Clear();
         for (auto& [_, writeInfo] : WriteInfos) {
             writeInfo.Serializer = nullptr;
@@ -1414,8 +1580,8 @@ class TShardedWriteController : public IShardedWriteController {
 
 private:
     void FlushSerializer(TWriteToken token, bool force) {
+        const auto& writeInfo = WriteInfos.at(token);
         if (force) {
-            const auto& writeInfo = WriteInfos.at(token);
             for (auto& [shardId, batches] : writeInfo.Serializer->FlushBatchesForce()) {
                 for (auto& batch : batches) {
                     if (batch && !batch->IsEmpty()) {
@@ -1429,7 +1595,6 @@ class TShardedWriteController : public IShardedWriteController {
                 }
             }
         } else {
-            const auto& writeInfo = WriteInfos.at(token);
             for (const ui64 shardId : writeInfo.Serializer->GetShardIds()) {
                 auto& shard = ShardsInfo.GetShard(shardId);
                 while (true) {
@@ -1450,29 +1615,30 @@ class TShardedWriteController : public IShardedWriteController {
 
     void BuildBatchesForShard(TShardsInfo::TShardInfo& shard) {
         if (shard.GetBatchesInFlight() == 0) {
-            YQL_ENSURE(IsOlap != std::nullopt);
-            shard.MakeNextBatches(
-                Settings.MemoryLimitPerMessage,
-                (*IsOlap) ? 1 : Settings.MaxBatchesPerMessage);
+            AFL_ENSURE(IsOlap != std::nullopt);
+            if (*IsOlap) {
+                shard.MakeNextBatches(Settings.MemoryLimitPerMessage, 1);
+            } else {
+                shard.MakeNextBatches(Settings.MemoryLimitPerMessage, std::nullopt);
+            }
         }
     }
 
     void ReshardData() {
-        YQL_ENSURE(!Settings.Inconsistent);
+        AFL_ENSURE(Settings.Inconsistent);
         for (auto& [_, shardInfo] : ShardsInfo.GetShards()) {
             for (size_t index = 0; index < shardInfo.Size(); ++index) {
                 auto& batch = shardInfo.GetBatch(index);
                 const auto& writeInfo = WriteInfos.at(batch.Token);
                 // Resharding supported only for inconsistent write,
                 // so convering empty batches don't exist in this case.
-                YQL_ENSURE(batch.Data);
+                AFL_ENSURE(batch.Data);
                 writeInfo.Serializer->AddBatch(std::move(batch.Data));
             }
         }
     }
 
     TShardedWriteControllerSettings Settings;
-    const NMiniKQL::TTypeEnvironment& TypeEnv;
     std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> Alloc;
 
     struct TWriteInfo {
@@ -1496,10 +1662,8 @@ class TShardedWriteController : public IShardedWriteController {
 
 IShardedWriteControllerPtr CreateShardedWriteController(
         const TShardedWriteControllerSettings& settings,
-        const NMiniKQL::TTypeEnvironment& typeEnv,
         std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc) {
-    return MakeIntrusive<TShardedWriteController>(
-        settings, typeEnv, alloc);
+    return MakeIntrusive<TShardedWriteController>(settings, std::move(alloc));
 }
 
 }
diff --git a/ydb/core/kqp/runtime/kqp_write_table.h b/ydb/core/kqp/runtime/kqp_write_table.h
index 83aa4e69f9a8..d1612e6caece 100644
--- a/ydb/core/kqp/runtime/kqp_write_table.h
+++ b/ydb/core/kqp/runtime/kqp_write_table.h
@@ -13,10 +13,15 @@ namespace NKqp {
 class IDataBatch : public TThrRefBase {
 public:
     virtual TString SerializeToString() const = 0;
+    virtual i64 GetSerializedMemory() const = 0;
     virtual i64 GetMemory() const = 0;
     virtual bool IsEmpty() const = 0;
 
     virtual std::shared_ptr<void> ExtractBatch() = 0;
+
+    virtual void AttachAlloc(std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc) = 0;
+    virtual void DetachAlloc() = 0;
+    virtual bool AttachedAlloc() const = 0;
 };
 
 using IDataBatchPtr = TIntrusivePtr<IDataBatch>;
@@ -33,11 +38,13 @@ using IDataBatcherPtr = TIntrusivePtr<IDataBatcher>;
 
 IDataBatcherPtr CreateRowDataBatcher(
     const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,
-    std::vector<ui32> writeIndex);
+    std::vector<ui32> writeIndex,
+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc = nullptr);
 
 IDataBatcherPtr CreateColumnDataBatcher(
     const TConstArrayRef<NKikimrKqp::TKqpColumnMetadataProto> inputColumns,
-    std::vector<ui32> writeIndex);
+    std::vector<ui32> writeIndex,
+    std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc = nullptr);
 
 class IShardedWriteController : public TThrRefBase {
 public:
@@ -114,15 +121,13 @@ using IShardedWriteControllerPtr = TIntrusivePtr<IShardedWriteController>;
 
 
 struct TShardedWriteControllerSettings {
-    i64 MemoryLimitTotal;
-    i64 MemoryLimitPerMessage;
-    i64 MaxBatchesPerMessage;
-    bool Inconsistent;
+    i64 MemoryLimitTotal = 0;
+    i64 MemoryLimitPerMessage = 0;
+    bool Inconsistent = false;
 };
 
 IShardedWriteControllerPtr CreateShardedWriteController(
     const TShardedWriteControllerSettings& settings,
-    const NMiniKQL::TTypeEnvironment& typeEnv,
     std::shared_ptr<NKikimr::NMiniKQL::TScopedAlloc> alloc);
 
 }
diff --git a/ydb/core/kqp/session_actor/kqp_query_state.h b/ydb/core/kqp/session_actor/kqp_query_state.h
index ecbd3a5348ed..57411dde5964 100644
--- a/ydb/core/kqp/session_actor/kqp_query_state.h
+++ b/ydb/core/kqp/session_actor/kqp_query_state.h
@@ -176,12 +176,16 @@ class TKqpQueryState : public TNonCopyable {
         if (RequestEv->GetRequestCtx() == nullptr) {
             return false;
         }
-        if (ParticipantNodes.size() == 1) {
+        if (IsSingleNodeExecution()) {
             return *ParticipantNodes.begin() == nodeId;
         }
         return false;
     }
 
+    bool IsSingleNodeExecution() const {
+        return ParticipantNodes.size() == 1;
+    }
+
     NKikimrKqp::EQueryAction GetAction() const {
         return QueryAction;
     }
diff --git a/ydb/core/kqp/session_actor/kqp_session_actor.cpp b/ydb/core/kqp/session_actor/kqp_session_actor.cpp
index 07c5c58d1f1e..5695f1ea390a 100644
--- a/ydb/core/kqp/session_actor/kqp_session_actor.cpp
+++ b/ydb/core/kqp/session_actor/kqp_session_actor.cpp
@@ -944,7 +944,7 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {
         }
 
         QueryState->TxCtx->SetTempTables(QueryState->TempTablesState);
-        QueryState->TxCtx->ApplyPhysicalQuery(phyQuery);
+        QueryState->TxCtx->ApplyPhysicalQuery(phyQuery, QueryState->Commit);
         auto [success, issues] = QueryState->TxCtx->ApplyTableOperations(phyQuery.GetTableOps(), phyQuery.GetTableInfos(),
             EKikimrQueryType::Dml);
         if (!success) {
@@ -1259,6 +1259,7 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {
             return true;
         }
 
+        YQL_ENSURE(tx || commit);
         if (tx) {
             switch (tx->GetType()) {
                 case NKqpProto::TKqpPhyTx::TYPE_COMPUTE:
@@ -1285,15 +1286,16 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {
 
                 QueryState->QueryData->AddUVParam(paramDesc.GetName(), paramType, value);
             }
+        }
 
-            try {
-                QueryState->QueryData->PrepareParameters(tx, QueryState->PreparedQuery, txCtx.TxAlloc->TypeEnv);
-            } catch (const yexception& ex) {
-                ythrow TRequestFail(Ydb::StatusIds::BAD_REQUEST) << ex.what();
-            }
+        try {
+            QueryState->QueryData->PrepareParameters(tx, QueryState->PreparedQuery, txCtx.TxAlloc->TypeEnv);
+        } catch (const yexception& ex) {
+            ythrow TRequestFail(Ydb::StatusIds::BAD_REQUEST) << ex.what();
+        }
+
+        if (tx) {
             request.Transactions.emplace_back(tx, QueryState->QueryData);
-        } else {
-            YQL_ENSURE(commit);
         }
 
         QueryState->TxCtx->OnNewExecutor(literal);
@@ -1448,12 +1450,32 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {
             txCtx->TxManager->SetTopicOperations(std::move(request.TopicOperations));
             txCtx->TxManager->AddTopicsToShards();
 
+            auto alloc = std::make_shared<NKikimr::NMiniKQL::TScopedAlloc>(
+                __LOCATION__, NKikimr::TAlignedPagePoolCounters(), true, false);
+
+            const auto& queryLimitsProto = Settings.TableService.GetQueryLimits();
+            const auto& bufferLimitsProto = queryLimitsProto.GetBufferLimits();
+            const ui64 writeBufferMemoryLimit = bufferLimitsProto.HasWriteBufferMemoryLimitBytes()
+                ? bufferLimitsProto.GetWriteBufferMemoryLimitBytes()
+                : ui64(Settings.MkqlMaxMemoryLimit);
+            const ui64 writeBufferInitialMemoryLimit = writeBufferMemoryLimit < ui64(Settings.MkqlInitialMemoryLimit)
+                ? writeBufferMemoryLimit
+                : ui64(Settings.MkqlInitialMemoryLimit);
+            alloc->SetLimit(writeBufferInitialMemoryLimit);
+            alloc->Ref().SetIncreaseMemoryLimitCallback([this, alloc=alloc.get(), writeBufferMemoryLimit](ui64 currentLimit, ui64 required) {
+                if (required < writeBufferMemoryLimit) {
+                    LOG_D("Increase memory limit from " << currentLimit << " to " << required);
+                    alloc->SetLimit(required);
+                }
+            });
+
             TKqpBufferWriterSettings settings {
                 .SessionActorId = SelfId(),
                 .TxManager = txCtx->TxManager,
                 .TraceId = request.TraceId.GetTraceId(),
                 .Counters = Counters,
                 .TxProxyMon = RequestCounters->TxProxyMon,
+                .Alloc = std::move(alloc),
             };
             auto* actor = CreateKqpBufferWriterActor(std::move(settings));
             txCtx->BufferActorId = RegisterWithSameMailbox(actor);
@@ -1468,7 +1490,7 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {
             AsyncIoFactory, QueryState ? QueryState->PreparedQuery : nullptr, SelfId(),
             QueryState ? QueryState->UserRequestContext : MakeIntrusive<TUserRequestContext>("", Settings.Database, SessionId),
             QueryState ? QueryState->StatementResultIndex : 0, FederatedQuerySetup,
-            (!Settings.TableService.GetEnableOltpSink() && QueryState && QueryState->RequestEv->GetSyntax() == Ydb::Query::Syntax::SYNTAX_PG)
+            (QueryState && QueryState->RequestEv->GetSyntax() == Ydb::Query::Syntax::SYNTAX_PG)
                 ? GUCSettings : nullptr,
             txCtx->ShardIdToTableInfo, txCtx->TxManager, txCtx->BufferActorId);
 
@@ -1625,8 +1647,12 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {
             QueryState->QueryStats.Executions.back().Swap(executerResults.MutableStats());
         }
 
-        for (auto nodeId : ev->ParticipantNodes) {
-            QueryState->ParticipantNodes.emplace(nodeId);
+        if (QueryState->TxCtx->TxManager) {
+            QueryState->ParticipantNodes = QueryState->TxCtx->TxManager->GetParticipantNodes();
+        } else {
+            for (auto nodeId : ev->ParticipantNodes) {
+                QueryState->ParticipantNodes.emplace(nodeId);
+            }
         }
 
         if (response->GetStatus() != Ydb::StatusIds::SUCCESS) {
@@ -1743,21 +1769,20 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {
     }
 
     void Handle(TEvKqpBuffer::TEvError::TPtr& ev) {
-        const auto& msg = *ev->Get();
+        auto& msg = *ev->Get();
 
         TString logMsg = TStringBuilder() << "got TEvKqpBuffer::TEvError in " << CurrentStateFuncName()
             << ", status: " << NYql::NDqProto::StatusIds_StatusCode_Name(msg.StatusCode) << " send to: " << ExecuterId << " from: " << ev->Sender;
 
         if (!QueryState || !QueryState->TxCtx || QueryState->TxCtx->BufferActorId != ev->Sender) {
-            LOG_E(logMsg <<  ": Old error.");
+            LOG_E(logMsg <<  ": Ignored error.");
             return;
         } else {
             LOG_W(logMsg);
         }
 
         if (ExecuterId) {
-            auto abortEv = MakeHolder<TEvKqp::TEvAbortExecution>(msg.StatusCode, msg.Issues);
-            Send(ExecuterId, abortEv.Release(), IEventHandle::FlagTrackDelivery);
+            Send(ExecuterId, new TEvKqpBuffer::TEvError{msg.StatusCode, std::move(msg.Issues)}, IEventHandle::FlagTrackDelivery);
         } else {
             ReplyQueryError(NYql::NDq::DqStatusToYdbStatus(msg.StatusCode), logMsg, MessageFromIssues(msg.Issues));
         }
@@ -2003,7 +2028,6 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {
             size_t trailingResultsCount = 0;
             for (size_t i = 0; i < phyQuery.ResultBindingsSize(); ++i) {
                 if (QueryState->IsStreamResult()) {
-
                     if (QueryState->QueryData->HasTrailingTxResult(phyQuery.GetResultBindings(i))) {
                         auto ydbResult = QueryState->QueryData->GetYdbTxResult(
                             phyQuery.GetResultBindings(i), response->GetArena(), {});
@@ -2377,7 +2401,7 @@ class TKqpSessionActor : public TActorBootstrapped<TKqpSessionActor> {
             QueryState->PoolHandlerActor = Nothing();
         }
 
-        if (QueryState && QueryState->ParticipantNodes.size() == 1) {
+        if (QueryState && QueryState->IsSingleNodeExecution()) {
             Counters->TotalSingleNodeReqCount->Inc();
             if (!QueryState->IsLocalExecution(SelfId().NodeId())) {
                 Counters->NonLocalSingleNodeReqCount->Inc();
diff --git a/ydb/core/kqp/ut/common/kqp_ut_common.cpp b/ydb/core/kqp/ut/common/kqp_ut_common.cpp
index 86ab759c81c0..fd957cced050 100644
--- a/ydb/core/kqp/ut/common/kqp_ut_common.cpp
+++ b/ydb/core/kqp/ut/common/kqp_ut_common.cpp
@@ -527,6 +527,8 @@ void TKikimrRunner::Initialize(const TKikimrSettings& settings) {
     SetupLogLevelFromTestParam(NKikimrServices::TX_COLUMNSHARD);
     SetupLogLevelFromTestParam(NKikimrServices::TX_COLUMNSHARD_SCAN);
     SetupLogLevelFromTestParam(NKikimrServices::LOCAL_PGWIRE);
+    SetupLogLevelFromTestParam(NKikimrServices::SSA_GRAPH_EXECUTION);
+
 
     RunCall([this, domain = settings.DomainRoot]{
         this->Client->InitRootScheme(domain);
@@ -1612,5 +1614,64 @@ NJson::TJsonValue GetJoinOrderFromDetailedJoinOrder(const TString& deserializedD
     return GetJoinOrderFromDetailedJoinOrderImpl(optRoot);
 }
 
+TTestExtEnv::TTestExtEnv(TTestExtEnv::TEnvSettings envSettings) {
+    auto mbusPort = PortManager.GetPort();
+    auto grpcPort = PortManager.GetPort();
+
+    Settings = new Tests::TServerSettings(mbusPort);
+    EnvSettings = envSettings;
+
+    Settings->SetDomainName("Root");
+    Settings->SetNodeCount(EnvSettings.StaticNodeCount);
+    Settings->SetDynamicNodeCount(EnvSettings.DynamicNodeCount);
+    Settings->SetUseRealThreads(EnvSettings.UseRealThreads);
+    Settings->AddStoragePoolType(EnvSettings.PoolName);
+    Settings->SetFeatureFlags(EnvSettings.FeatureFlags);
+
+    Server = new Tests::TServer(*Settings);
+    Server->EnableGRpc(grpcPort);
+
+    auto sender = Server->GetRuntime()->AllocateEdgeActor();
+    Server->SetupRootStoragePools(sender);
+
+    Client = MakeHolder<Tests::TClient>(*Settings);
+
+    Tenants = MakeHolder<Tests::TTenants>(Server);
+
+    Endpoint = "localhost:" + ToString(grpcPort);
+    DriverConfig = NYdb::TDriverConfig().SetEndpoint(Endpoint);
+    Driver = MakeHolder<NYdb::TDriver>(DriverConfig);
+}
+
+TTestExtEnv::~TTestExtEnv() {
+    Driver->Stop(true);
+}
+
+void TTestExtEnv::CreateDatabase(const TString& databaseName) {
+    auto& runtime = *Server->GetRuntime();
+    auto fullDbName = "/Root/" + databaseName;
+
+    using TEvCreateDatabaseRequest = NKikimr::NGRpcService::TGrpcRequestOperationCall
+    <
+        Ydb::Cms::CreateDatabaseRequest,
+        Ydb::Cms::CreateDatabaseResponse
+    >;
+
+    Ydb::Cms::CreateDatabaseRequest request;
+    request.set_path(fullDbName);
+
+    auto* resources = request.mutable_resources();
+    auto* storage = resources->add_storage_units();
+    storage->set_unit_kind(EnvSettings.PoolName);
+    storage->set_count(1);
+
+    auto future = NRpcService::DoLocalRpc<TEvCreateDatabaseRequest>(std::move(request), "", "", runtime.GetActorSystem(0));
+    auto response = runtime.WaitFuture(std::move(future));
+    UNIT_ASSERT(response.operation().ready());
+    UNIT_ASSERT_VALUES_EQUAL(response.operation().status(), Ydb::StatusIds::SUCCESS);
+
+    Tenants->Run(fullDbName, EnvSettings.DynamicNodeCount);
+}
+
 } // namspace NKqp
 } // namespace NKikimr
diff --git a/ydb/core/kqp/ut/common/kqp_ut_common.h b/ydb/core/kqp/ut/common/kqp_ut_common.h
index 50d82afd2f2c..f2f9bbe559ff 100644
--- a/ydb/core/kqp/ut/common/kqp_ut_common.h
+++ b/ydb/core/kqp/ut/common/kqp_ut_common.h
@@ -403,5 +403,39 @@ NJson::TJsonValue GetJoinOrder(const TString& deserializedPlan);
 
 NJson::TJsonValue GetJoinOrderFromDetailedJoinOrder(const TString& deserializedDetailedJoinOrder);
 
+class TTestExtEnv {
+public:
+    struct TEnvSettings {
+        size_t StaticNodeCount = 1;
+        size_t DynamicNodeCount = 1;
+        TString PoolName = "hdd1";
+        bool UseRealThreads = true;
+        NKikimrConfig::TFeatureFlags FeatureFlags;
+    };
+
+    TTestExtEnv(TEnvSettings envSettings);
+    ~TTestExtEnv();
+
+    NYdb::TDriver& GetDriver() const {
+        return *Driver;
+    }
+
+    void CreateDatabase(const TString& databaseName);
+
+private:
+    TPortManager PortManager;
+
+    Tests::TServerSettings::TPtr Settings;
+    Tests::TServer::TPtr Server;
+    THolder<Tests::TClient> Client;
+    THolder<Tests::TTenants> Tenants;
+
+    TString Endpoint;
+    NYdb::TDriverConfig DriverConfig;
+    THolder<NYdb::TDriver> Driver;
+
+    TEnvSettings EnvSettings;
+};
+
 } // namespace NKqp
 } // namespace NKikimr
diff --git a/ydb/core/kqp/ut/data_integrity/kqp_data_integrity_trails_ut.cpp b/ydb/core/kqp/ut/data_integrity/kqp_data_integrity_trails_ut.cpp
index f8d362bb530e..962bfce88ee2 100644
--- a/ydb/core/kqp/ut/data_integrity/kqp_data_integrity_trails_ut.cpp
+++ b/ydb/core/kqp/ut/data_integrity/kqp_data_integrity_trails_ut.cpp
@@ -1,5 +1,7 @@
 #include <ydb/core/kqp/ut/common/kqp_ut_common.h>
 
+#include <regex>
+
 namespace NKikimr {
 namespace NKqp {
 
@@ -17,10 +19,13 @@ namespace {
 }
 
 Y_UNIT_TEST_SUITE(KqpDataIntegrityTrails) {
-    Y_UNIT_TEST_TWIN(Upsert, LogEnabled) {
+    Y_UNIT_TEST_QUAD(Upsert, LogEnabled, UseSink) {
         TStringStream ss;
         {
+            NKikimrConfig::TAppConfig appConfig;
+            appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
             TKikimrSettings serverSettings;
+            serverSettings.SetAppConfig(appConfig);
             serverSettings.LogStream = &ss;
             TKikimrRunner kikimr(serverSettings);
 
@@ -42,8 +47,13 @@ Y_UNIT_TEST_SUITE(KqpDataIntegrityTrails) {
             UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
         }
 
-        // check executer logs
-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY INFO: Component: Executer"), LogEnabled ? 1 : 0);
+        if (UseSink) {
+            // check write actor logs
+            UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY INFO: Component: WriteActor"), LogEnabled ? 1 : 0);
+        } else {
+            // check executer logs
+            UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY INFO: Component: Executer"), LogEnabled ? 2 : 0);
+        }
         // check session actor logs
         UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY DEBUG: Component: SessionActor"), LogEnabled ? 2 : 0);
         // check grpc logs
@@ -52,49 +62,13 @@ Y_UNIT_TEST_SUITE(KqpDataIntegrityTrails) {
         UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY INFO: Component: DataShard"), LogEnabled ? 2 : 0);
     }
 
-    Y_UNIT_TEST(UpsertEvWrite) {
+    Y_UNIT_TEST_QUAD(UpsertEvWriteQueryService, isOlap, useOltpSink) {
         TStringStream ss;
         {
             NKikimrConfig::TAppConfig AppConfig;
-            AppConfig.MutableTableServiceConfig()->SetEnableOltpSink(true);
-            TKikimrSettings serverSettings = TKikimrSettings().SetAppConfig(AppConfig);
-            serverSettings.LogStream = &ss;
-            TKikimrRunner kikimr(serverSettings);
-            kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::DATA_INTEGRITY, NLog::PRI_TRACE);
-            
-            auto db = kikimr.GetTableClient();
-            auto session = db.CreateSession().GetValueSync().GetSession();
-
-            auto result = session.ExecuteDataQuery(R"(
-                --!syntax_v1
-
-                UPSERT INTO `/Root/KeyValue` (Key, Value) VALUES
-                    (3u, "Value3"),
-                    (101u, "Value101"),
-                    (201u, "Value201");
-            )", TTxControl::BeginTx().CommitTx()).ExtractValueSync();
-            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
-        }
+            AppConfig.MutableTableServiceConfig()->SetEnableOltpSink(useOltpSink);
+            AppConfig.MutableTableServiceConfig()->SetEnableOlapSink(isOlap);
 
-        // check write actor logs
-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY INFO: Component: WriteActor"), 1);
-        // check session actor logs
-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY DEBUG: Component: SessionActor"), 2);
-        // check grpc logs
-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY TRACE: Component: Grpc"), 2);
-        // check datashard logs
-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY INFO: Component: DataShard"), 2);
-    }
-
-    Y_UNIT_TEST_TWIN(UpsertEvWriteQueryService, isOlap) {
-        TStringStream ss;
-        {
-            NKikimrConfig::TAppConfig AppConfig;
-            if (!isOlap) {
-                AppConfig.MutableTableServiceConfig()->SetEnableOltpSink(true);
-            } else {
-                AppConfig.MutableTableServiceConfig()->SetEnableOlapSink(true);
-            }
             TKikimrSettings serverSettings = TKikimrSettings().SetAppConfig(AppConfig);
             serverSettings.LogStream = &ss;
             TKikimrRunner kikimr(serverSettings);
@@ -130,8 +104,13 @@ Y_UNIT_TEST_SUITE(KqpDataIntegrityTrails) {
         }
 
         if (!isOlap) {
-            // check write actor logs
-            UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY INFO: Component: WriteActor"), 1);
+            if (useOltpSink) {
+                // check write actor logs
+                UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY INFO: Component: WriteActor"), 1);
+            } else {
+                // check executer logs
+                UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY INFO: Component: Executer"), 2);
+            }
             // check session actor logs
             UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY DEBUG: Component: SessionActor"), 2);
             // check grpc logs
@@ -141,8 +120,13 @@ Y_UNIT_TEST_SUITE(KqpDataIntegrityTrails) {
         } else {
             // check write actor logs
             UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY INFO: Component: WriteActor"), 3);
-            // check executer logs
-            UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY INFO: Component: Executer"), 4);
+            if (useOltpSink) {
+                // check executer logs
+                UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY INFO: Component: Executer"), 1);
+            } else {
+                // check executer logs
+                UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY INFO: Component: Executer"), 11);
+            }
             // check session actor logs
             UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY DEBUG: Component: SessionActor"), 2);
             // check grpc logs
@@ -203,8 +187,8 @@ Y_UNIT_TEST_SUITE(KqpDataIntegrityTrails) {
             UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
         }
 
-        // check executer logs (should be empty, because executer only logs modification operations)
-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY INFO: Component: Executer"), 0);
+        // check executer logs (should be 1, because executer only logs result for read actor)
+        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY INFO: Component: Executer"), 1);
         // check session actor logs
         UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY DEBUG: Component: SessionActor"), 2);
         // check grpc logs
@@ -213,45 +197,146 @@ Y_UNIT_TEST_SUITE(KqpDataIntegrityTrails) {
         UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY INFO: Component: DataShard"), 0);
     }
 
-    Y_UNIT_TEST_TWIN(UpsertViaLegacyScripting, Streaming) {
+    Y_UNIT_TEST_TWIN(BrokenReadLock, UseSink) {
         TStringStream ss;
         {
+            NKikimrConfig::TAppConfig AppConfig;
+            AppConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
             TKikimrSettings serverSettings;
+            serverSettings.SetAppConfig(AppConfig);
             serverSettings.LogStream = &ss;
             TKikimrRunner kikimr(serverSettings);
             kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::DATA_INTEGRITY, NLog::PRI_TRACE);
-            NYdb::NScripting::TScriptingClient client(kikimr.GetDriver());
+            auto db = kikimr.GetTableClient();
+            auto session = db.CreateSession().GetValueSync().GetSession();
 
+            std::optional<TTransaction> tx1;
 
-            const auto query = R"(
-                --!syntax_v1
+            {  // tx1: read
+                auto result = session.ExecuteDataQuery(R"(
+                    --!syntax_v1
 
-                UPSERT INTO `/Root/KeyValue` (Key, Value) VALUES
-                    (3u, "Value3"),
-                    (101u, "Value101"),
-                    (201u, "Value201");
-            )";
+                    SELECT * FROM `/Root/KeyValue` WHERE Key = 1u OR Key = 2u;
+                )", TTxControl::BeginTx()).ExtractValueSync();
+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
+                CompareYson(R"([
+                    [[1u];["One"]];
+                    [[2u];["Two"]]
+                ])", FormatResultSetYson(result.GetResultSet(0)));
+                tx1 = result.GetTransaction();
+                UNIT_ASSERT(tx1);
+            }
 
-            if (Streaming) {
-                auto result = client.StreamExecuteYqlScript(query).GetValueSync();        
+            {  // tx2: write + commit
+                auto result = session.ExecuteDataQuery(R"(
+                    --!syntax_v1
+
+                    UPSERT INTO `/Root/KeyValue` (Key, Value) VALUES
+                        (1u, "NewValue1");
+                )", TTxControl::BeginTx().CommitTx()).ExtractValueSync();
                 UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
-                CollectStreamResult(result);
-            } else {
-                auto result = client.ExecuteYqlScript(query).GetValueSync();        
+            }
+
+            {  // tx1: commit
+                auto result = tx1->Commit().ExtractValueSync();
                 UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
             }
         }
-            
-        // check executer logs
-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY INFO: Component: Executer"), 1);
-        // check session actor logs (should contain double logs because this query was executed via worker actor)
-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY DEBUG: Component: SessionActor"), 4);
-        // check grpc logs
-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY TRACE: Component: Grpc"), 2);
-        // check datashard logs
-        UNIT_ASSERT_VALUES_EQUAL(CountSubstr(ss.Str(), "DATA_INTEGRITY INFO: Component: DataShard"), 2);
 
-        Cout << ss.Str() << Endl;
+        auto logRows = SplitString(ss.Str(), "DATA_INTEGRITY");
+        std::string readLock;
+        std::string brokenLock;
+        for (const auto& row : logRows) {
+            // we need to find row with info about read physical tx and extract lock id
+            if (row.Contains("Component: Executer,Type: InputActorResult")) {
+                std::regex lockIdRegex(R"(LockId:\s*(\d+))");
+                std::smatch lockIdMatch;
+                UNIT_ASSERT_C(std::regex_search(row.data(), lockIdMatch, lockIdRegex) || lockIdMatch.size() != 2, "failed to extract read lock id");
+                readLock = lockIdMatch[1].str();
+            }
+
+            // we need to find row with info about broken locks and extract lock id
+            if (row.Contains("Component: DataShard,Type: Locks")) {
+                std::regex lockIdRegex(R"(BreakLocks:\s*\[(\d+)\s*\])");
+                std::smatch lockIdMatch;
+                UNIT_ASSERT_C(std::regex_search(row.data(), lockIdMatch, lockIdRegex) || lockIdMatch.size() != 2, "failed to extract broken lock id");
+                brokenLock = lockIdMatch[1].str();
+            } 
+        }
+
+        UNIT_ASSERT_C(!readLock.empty() && readLock == brokenLock, "read lock should be broken");
+    }
+
+    Y_UNIT_TEST(BrokenReadLockAbortedTx) {
+        TStringStream ss;
+        {
+            TKikimrSettings serverSettings;
+            serverSettings.LogStream = &ss;
+            TKikimrRunner kikimr(serverSettings);
+            kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::DATA_INTEGRITY, NLog::PRI_TRACE);
+            auto db = kikimr.GetTableClient();
+            auto session = db.CreateSession().GetValueSync().GetSession();
+
+            std::optional<TTransaction> tx1;
+
+            {  // tx1: read
+                auto result = session.ExecuteDataQuery(R"(
+                    --!syntax_v1
+
+                    SELECT * FROM `/Root/KeyValue` WHERE Key = 1u OR Key = 2u;
+                )", TTxControl::BeginTx()).ExtractValueSync();
+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
+                CompareYson(R"([
+                    [[1u];["One"]];
+                    [[2u];["Two"]]
+                ])", FormatResultSetYson(result.GetResultSet(0)));
+                tx1 = result.GetTransaction();
+                UNIT_ASSERT(tx1);
+            }
+
+            {  // tx2: write + commit
+                auto result = session.ExecuteDataQuery(R"(
+                    --!syntax_v1
+
+                    UPSERT INTO `/Root/KeyValue` (Key, Value) VALUES
+                        (1u, "NewValue1");
+                )", TTxControl::BeginTx().CommitTx()).ExtractValueSync();
+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
+            }
+
+            {  // tx1: write + commit
+                auto result = session.ExecuteDataQuery(R"(
+                    --!syntax_v1
+
+                    UPSERT INTO `/Root/KeyValue` (Key, Value) VALUES
+                        (1000u, "Value1000");
+                )", TTxControl::Tx(*tx1).CommitTx()).ExtractValueSync();
+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::ABORTED, result.GetIssues().ToString());
+            }
+        }
+
+        auto logRows = SplitString(ss.Str(), "DATA_INTEGRITY");
+        std::string readLock;
+        std::string brokenLock;
+        for (const auto& row : logRows) {
+            // we need to find row with info about read physical tx and extract lock id
+            if (row.Contains("Component: Executer,Type: InputActorResult")) {
+                std::regex lockIdRegex(R"(LockId:\s*(\d+))");
+                std::smatch lockIdMatch;
+                UNIT_ASSERT_C(std::regex_search(row.data(), lockIdMatch, lockIdRegex) || lockIdMatch.size() != 2, "failed to extract read lock id");
+                readLock = lockIdMatch[1].str();
+            }
+
+            // we need to find row with info about broken locks and extract lock id
+            if (row.Contains("Component: DataShard,Type: Locks")) {
+                std::regex lockIdRegex(R"(BreakLocks:\s*\[(\d+)\s*\])");
+                std::smatch lockIdMatch;
+                UNIT_ASSERT_C(std::regex_search(row.data(), lockIdMatch, lockIdRegex) || lockIdMatch.size() != 2, "failed to extract broken lock id");
+                brokenLock = lockIdMatch[1].str();
+            } 
+        }
+
+        UNIT_ASSERT_C(!readLock.empty() && readLock == brokenLock, "read lock should be broken");
     }
 }
 
diff --git a/ydb/core/kqp/ut/effects/kqp_effects_ut.cpp b/ydb/core/kqp/ut/effects/kqp_effects_ut.cpp
index 6474a18b0bf2..244743575bfb 100644
--- a/ydb/core/kqp/ut/effects/kqp_effects_ut.cpp
+++ b/ydb/core/kqp/ut/effects/kqp_effects_ut.cpp
@@ -31,8 +31,10 @@ Y_UNIT_TEST_SUITE(KqpEffects) {
         ])", FormatResultSetYson(result.GetResultSet(0)));
     }
 
-    Y_UNIT_TEST(InsertAbort_Literal_Duplicates) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_TWIN(InsertAbort_Literal_Duplicates, UseSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, appConfig);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
 
@@ -41,8 +43,8 @@ Y_UNIT_TEST_SUITE(KqpEffects) {
                 ("foo", 10u), ("bar", 11u), ("baz", 10u)
         )", TTxControl::BeginTx().CommitTx()).ExtractValueSync();
         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());
-        UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, [](const auto& issue) {
-            return issue.GetMessage().contains("Duplicated keys found.");
+        UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, [&](const auto& issue) {
+            return issue.GetMessage().contains(UseSink ? "Duplicate keys have been found." : "Duplicated keys found.");
         }));
 
         result = session.ExecuteDataQuery(R"(
@@ -53,8 +55,10 @@ Y_UNIT_TEST_SUITE(KqpEffects) {
         CompareYson(R"([])", FormatResultSetYson(result.GetResultSet(0)));
     }
 
-    Y_UNIT_TEST(InsertAbort_Literal_Conflict) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_TWIN(InsertAbort_Literal_Conflict, UseSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, appConfig);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
 
@@ -64,7 +68,7 @@ Y_UNIT_TEST_SUITE(KqpEffects) {
         )", TTxControl::BeginTx().CommitTx()).ExtractValueSync();
         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());
         UNIT_ASSERT_C(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, [](const auto& issue) {
-            return issue.GetMessage().contains("Conflict with existing key.");
+            return issue.GetMessage().contains(UseSink ? "Duplicate keys have been found." : "Conflict with existing key.");
         }), result.GetIssues().ToString());
 
         result = session.ExecuteDataQuery(R"(
@@ -114,8 +118,10 @@ Y_UNIT_TEST_SUITE(KqpEffects) {
         ])", FormatResultSetYson(result.GetResultSet(0)));
     }
 
-    Y_UNIT_TEST(InsertAbort_Params_Duplicates) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_TWIN(InsertAbort_Params_Duplicates, UseSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, appConfig);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
 
@@ -145,7 +151,7 @@ Y_UNIT_TEST_SUITE(KqpEffects) {
         )", TTxControl::BeginTx().CommitTx(), std::move(params)).ExtractValueSync();
         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());
         UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, [](const auto& issue) {
-            return issue.GetMessage().contains("Duplicated keys found.");
+            return issue.GetMessage().contains(UseSink ? "Duplicate keys have been found." : "Duplicated keys found.");
         }));
 
         result = session.ExecuteDataQuery(R"(
@@ -158,8 +164,10 @@ Y_UNIT_TEST_SUITE(KqpEffects) {
         ])", FormatResultSetYson(result.GetResultSet(0)));
     }
 
-    Y_UNIT_TEST(InsertAbort_Params_Conflict) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_TWIN(InsertAbort_Params_Conflict, UseSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, appConfig);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
 
@@ -184,7 +192,7 @@ Y_UNIT_TEST_SUITE(KqpEffects) {
         )", TTxControl::BeginTx().CommitTx(), std::move(params)).ExtractValueSync();
         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());
         UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, [](const auto& issue) {
-            return issue.GetMessage().contains("Conflict with existing key.");
+            return issue.GetMessage().contains(UseSink ? "Duplicate keys have been found." : "Conflict with existing key.");
         }));
 
         result = session.ExecuteDataQuery(R"(
@@ -234,8 +242,10 @@ Y_UNIT_TEST_SUITE(KqpEffects) {
         ])", FormatResultSetYson(result.GetResultSet(0)));
     }
 
-    Y_UNIT_TEST(InsertAbort_Select_Duplicates) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_TWIN(InsertAbort_Select_Duplicates, UseSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, appConfig);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
 
@@ -261,7 +271,7 @@ Y_UNIT_TEST_SUITE(KqpEffects) {
         )", TTxControl::BeginTx().CommitTx()).ExtractValueSync();
         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());
         UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, [](const auto& issue) {
-            return issue.GetMessage().contains("Duplicated keys found.");
+            return issue.GetMessage().contains(UseSink ? "Duplicate keys have been found." : "Duplicated keys found.");
         }));
 
         result = session.ExecuteDataQuery(R"(
@@ -274,8 +284,10 @@ Y_UNIT_TEST_SUITE(KqpEffects) {
         ])", FormatResultSetYson(result.GetResultSet(0)));
     }
 
-    Y_UNIT_TEST(InsertAbort_Select_Conflict) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_TWIN(InsertAbort_Select_Conflict, UseSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, appConfig);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
 
@@ -300,7 +312,7 @@ Y_UNIT_TEST_SUITE(KqpEffects) {
         )", TTxControl::BeginTx().CommitTx()).ExtractValueSync();
         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());
         UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, [](const auto& issue) {
-            return issue.GetMessage().contains("Conflict with existing key.");
+            return issue.GetMessage().contains(UseSink ? "Duplicate keys have been found." : "Conflict with existing key.");
         }));
 
         result = session.ExecuteDataQuery(R"(
diff --git a/ydb/core/kqp/ut/effects/kqp_immediate_effects_ut.cpp b/ydb/core/kqp/ut/effects/kqp_immediate_effects_ut.cpp
index 94ef94ccab1a..0e5e78cacfd0 100644
--- a/ydb/core/kqp/ut/effects/kqp_immediate_effects_ut.cpp
+++ b/ydb/core/kqp/ut/effects/kqp_immediate_effects_ut.cpp
@@ -382,8 +382,9 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {
         }
     }
 
-    Y_UNIT_TEST(InsertDuplicates) {
+    Y_UNIT_TEST_TWIN(InsertDuplicates, UseSink) {
         NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         auto serverSettings = TKikimrSettings().SetAppConfig(appConfig);
         TKikimrRunner kikimr(serverSettings);
         auto db = kikimr.GetTableClient();
@@ -404,13 +405,14 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {
             )", TTxControl::BeginTx().CommitTx()).ExtractValueSync();
             UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());
             UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, [](const auto& issue) {
-                return issue.GetMessage().contains("Duplicated keys found.");
+                return issue.GetMessage().contains(UseSink ? "Duplicate keys have been found." : "Duplicated keys found.");
             }));
         }
     }
 
-    Y_UNIT_TEST(InsertExistingKey) {
+    Y_UNIT_TEST_TWIN(InsertExistingKey, UseSink) {
         NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         auto serverSettings = TKikimrSettings().SetAppConfig(appConfig);
         TKikimrRunner kikimr(serverSettings);
         auto db = kikimr.GetTableClient();
@@ -430,7 +432,7 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {
             )", TTxControl::BeginTx().CommitTx()).ExtractValueSync();
             UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());
             UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, [](const auto& issue) {
-                return issue.GetMessage().contains("Conflict with existing key.");
+                return issue.GetMessage().contains(UseSink ? "Duplicate keys have been found." : "Conflict with existing key.");
             }));
         }
     }
@@ -1015,8 +1017,9 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {
         }
     }
 
-    Y_UNIT_TEST(TxWithReadAtTheEnd) {
+    Y_UNIT_TEST_TWIN(TxWithReadAtTheEnd, UseSink) {
         NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         auto serverSettings = TKikimrSettings().SetAppConfig(appConfig);
         TKikimrRunner kikimr(serverSettings);
         auto db = kikimr.GetTableClient();
@@ -1058,8 +1061,9 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {
         UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(stats.query_phases().size() - 1).table_access().size(), 0);
     }
 
-    Y_UNIT_TEST(InteractiveTxWithReadAtTheEnd) {
+    Y_UNIT_TEST_TWIN(InteractiveTxWithReadAtTheEnd, UseSink) {
         NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         auto serverSettings = TKikimrSettings().SetAppConfig(appConfig);
         TKikimrRunner kikimr(serverSettings);
         auto db = kikimr.GetTableClient();
@@ -1115,13 +1119,15 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {
             ])", FormatResultSetYson(result.GetResultSet(0)));
 
             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 4 : 5);
             // check that last (commit) phase is empty
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(stats.query_phases().size() - 1).table_access().size(), 0);
         }
     }
 
-    Y_UNIT_TEST(TxWithWriteAtTheEnd) {
+    Y_UNIT_TEST_TWIN(TxWithWriteAtTheEnd, UseSink) {
         NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         auto serverSettings = TKikimrSettings().SetAppConfig(appConfig);
         TKikimrRunner kikimr(serverSettings);
         auto db = kikimr.GetTableClient();
@@ -2075,8 +2081,9 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {
         }
     }
 
-    Y_UNIT_TEST(ForceImmediateEffectsExecution) {
+    Y_UNIT_TEST_TWIN(ForceImmediateEffectsExecution, UseSink) {
         NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         auto serverSettings = TKikimrSettings().SetAppConfig(appConfig).SetEnableForceImmediateEffectsExecution(true);
         TKikimrRunner kikimr(serverSettings);
         auto db = kikimr.GetTableClient();
@@ -2101,12 +2108,14 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {
 
             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
             // compute phase + effect phase
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);
 
-            const auto& literalPhase = stats.query_phases(0);
-            const auto& effectPhase = stats.query_phases(1);
+            if (!UseSink) {
+                const auto& literalPhase = stats.query_phases(0);
+                UNIT_ASSERT_VALUES_EQUAL(literalPhase.table_access().size(), 0);
+            }
 
-            UNIT_ASSERT_VALUES_EQUAL(literalPhase.table_access().size(), 0);
+            const auto& effectPhase = stats.query_phases(UseSink ? 0 : 1);
             UNIT_ASSERT_VALUES_EQUAL(effectPhase.table_access().size(), 1);
             UNIT_ASSERT_VALUES_EQUAL(effectPhase.table_access(0).name(), "/Root/TestImmediateEffects");
             UNIT_ASSERT_VALUES_EQUAL(effectPhase.table_access(0).updates().rows(), 1);
@@ -2122,12 +2131,14 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {
 
             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
             // compute phase + effect phase
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);
 
-            const auto& literalPhase = stats.query_phases(0);
-            const auto& effectPhase = stats.query_phases(1);
+            if (!UseSink) {
+                const auto& literalPhase = stats.query_phases(0);
+                UNIT_ASSERT_VALUES_EQUAL(literalPhase.table_access().size(), 0);
+            }
 
-            UNIT_ASSERT_VALUES_EQUAL(literalPhase.table_access().size(), 0);
+            const auto& effectPhase = stats.query_phases(UseSink ? 0 : 1);
             UNIT_ASSERT_VALUES_EQUAL(effectPhase.table_access().size(), 1);
             UNIT_ASSERT_VALUES_EQUAL(effectPhase.table_access(0).name(), "/Root/TestImmediateEffects");
             UNIT_ASSERT_VALUES_EQUAL(effectPhase.table_access(0).deletes().rows(), 1);
@@ -2227,6 +2238,160 @@ Y_UNIT_TEST_SUITE(KqpImmediateEffects) {
         }
     }
 
+    Y_UNIT_TEST(ManyFlushes) {
+        NKikimrConfig::TAppConfig appConfig;
+        auto serverSettings = TKikimrSettings().SetAppConfig(appConfig);
+        TKikimrRunner kikimr(serverSettings);
+        auto db = kikimr.GetTableClient();
+        auto session = db.CreateSession().GetValueSync().GetSession();
+
+        CreateTestTable(session);
+
+        {
+            auto result = session.ExecuteDataQuery(R"(
+                --!syntax_v1
+
+                SELECT * FROM TestImmediateEffects;
+                UPSERT INTO TestImmediateEffects (Key, Value) VALUES
+                    (3u, "Three"),
+                    (4u, "Four");
+
+                SELECT * FROM TestImmediateEffects;
+            )", TTxControl::BeginTx().CommitTx()).ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
+            CompareYson(R"([
+                [[1u];["One"]];
+                [[2u];["Two"]]
+            ])", FormatResultSetYson(result.GetResultSet(0)));
+            CompareYson(R"([
+                [[1u];["One"]];
+                [[2u];["Two"]];
+                [[3u];["Three"]];
+                [[4u];["Four"]]
+            ])", FormatResultSetYson(result.GetResultSet(1)));
+        }
+
+        {  // multiple effects
+            auto result = session.ExecuteDataQuery(R"(
+                --!syntax_v1
+
+                UPSERT INTO TestImmediateEffects (Key, Value) VALUES (5u, "Five");
+                SELECT * FROM TestImmediateEffects;
+                UPSERT INTO TestImmediateEffects (Key, Value) VALUES (6u, "Six");
+                SELECT * FROM TestImmediateEffects;
+                UPSERT INTO TestImmediateEffects (Key, Value) VALUES (7u, "Seven");
+                SELECT * FROM TestImmediateEffects;
+            )", TTxControl::BeginTx().CommitTx()).ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
+            CompareYson(R"([
+                [[1u];["One"]];
+                [[2u];["Two"]];
+                [[3u];["Three"]];
+                [[4u];["Four"]];
+                [[5u];["Five"]]
+            ])", FormatResultSetYson(result.GetResultSet(0)));
+            CompareYson(R"([
+                [[1u];["One"]];
+                [[2u];["Two"]];
+                [[3u];["Three"]];
+                [[4u];["Four"]];
+                [[5u];["Five"]];
+                [[6u];["Six"]]
+            ])", FormatResultSetYson(result.GetResultSet(1)));
+            CompareYson(R"([
+                [[1u];["One"]];
+                [[2u];["Two"]];
+                [[3u];["Three"]];
+                [[4u];["Four"]];
+                [[5u];["Five"]];
+                [[6u];["Six"]];
+                [[7u];["Seven"]]
+            ])", FormatResultSetYson(result.GetResultSet(2)));
+        }
+    }
+
+     Y_UNIT_TEST(Interactive) {
+        NKikimrConfig::TAppConfig appConfig;
+        auto serverSettings = TKikimrSettings().SetAppConfig(appConfig);
+        TKikimrRunner kikimr(serverSettings);
+        auto db = kikimr.GetTableClient();
+        auto session = db.CreateSession().GetValueSync().GetSession();
+
+        CreateTestTable(session);
+
+        {
+            auto result = session.ExecuteDataQuery(R"(
+                --!syntax_v1
+
+                SELECT * FROM TestImmediateEffects;
+                UPSERT INTO TestImmediateEffects (Key, Value) VALUES
+                    (3u, "Three"),
+                    (4u, "Four");
+
+                SELECT * FROM TestImmediateEffects;
+            )", TTxControl::BeginTx().CommitTx()).ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
+            CompareYson(R"([
+                [[1u];["One"]];
+                [[2u];["Two"]]
+            ])", FormatResultSetYson(result.GetResultSet(0)));
+            CompareYson(R"([
+                [[1u];["One"]];
+                [[2u];["Two"]];
+                [[3u];["Three"]];
+                [[4u];["Four"]]
+            ])", FormatResultSetYson(result.GetResultSet(1)));
+        }
+
+        {
+            auto result = session.ExecuteDataQuery(R"(
+                --!syntax_v1
+
+                UPSERT INTO TestImmediateEffects (Key, Value) VALUES (5u, "Five");
+            )", TTxControl::BeginTx()).ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
+
+            auto tx = result.GetTransaction();
+
+            result = session.ExecuteDataQuery(R"(
+                --!syntax_v1
+
+                SELECT * FROM TestImmediateEffects;
+                UPSERT INTO TestImmediateEffects (Key, Value) VALUES (6u, "Six");
+                SELECT * FROM TestImmediateEffects;
+                UPSERT INTO TestImmediateEffects (Key, Value) VALUES (7u, "Seven");
+                SELECT * FROM TestImmediateEffects;
+            )", TTxControl::Tx(*tx)).ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
+            CompareYson(R"([
+                [[1u];["One"]];
+                [[2u];["Two"]];
+                [[3u];["Three"]];
+                [[4u];["Four"]];
+                [[5u];["Five"]]
+            ])", FormatResultSetYson(result.GetResultSet(0)));
+            CompareYson(R"([
+                [[1u];["One"]];
+                [[2u];["Two"]];
+                [[3u];["Three"]];
+                [[4u];["Four"]];
+                [[5u];["Five"]];
+                [[6u];["Six"]]
+            ])", FormatResultSetYson(result.GetResultSet(1)));
+            CompareYson(R"([
+                [[1u];["One"]];
+                [[2u];["Two"]];
+                [[3u];["Three"]];
+                [[4u];["Four"]];
+                [[5u];["Five"]];
+                [[6u];["Six"]];
+                [[7u];["Seven"]]
+            ])", FormatResultSetYson(result.GetResultSet(2)));
+
+            auto commitResult = tx->Commit().ExtractValueSync();
+            UNIT_ASSERT(commitResult.IsSuccess());
+        }
+    }
 }
 
 } // namespace NKqp
diff --git a/ydb/core/kqp/ut/effects/kqp_inplace_update_ut.cpp b/ydb/core/kqp/ut/effects/kqp_inplace_update_ut.cpp
index 64130b3546f6..d8cced26c6e5 100644
--- a/ydb/core/kqp/ut/effects/kqp_inplace_update_ut.cpp
+++ b/ydb/core/kqp/ut/effects/kqp_inplace_update_ut.cpp
@@ -61,7 +61,8 @@ void Test(
     TParams&& params,
     const TString& expectedResult,
     std::function<void(const Ydb::TableStats::QueryStats&)>&& check,
-    const std::function<void(TSession& session)>& prepareTable = &PrepareTable
+    const std::function<void(TSession& session)>& prepareTable = &PrepareTable,
+    std::optional<bool> useSink = std::nullopt
 ) {
     auto setting = NKikimrKqp::TKqpSetting();
     setting.SetName("_KqpAllowUnsafeCommit");
@@ -69,6 +70,9 @@ void Test(
 
     // source read and stream lookup use iterator interface, that doesn't use datashard transactions
     NKikimrConfig::TAppConfig appConfig;
+    if (useSink) {
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(*useSink);
+    }
 
     auto settings = TKikimrSettings()
         .SetAppConfig(appConfig)
@@ -105,15 +109,18 @@ void Test(
 #define ASSERT_LITERAL_PHASE(stats, phaseNo) \
     UNIT_ASSERT_C(stats.query_phases(phaseNo).table_access().empty(), stats.DebugString());
 
-#define ASSERT_PHASE(stats, phaseNo, table, readsCnt, updatesCnt) \
+#define ASSERT_PHASE_FULL(stats, phaseNo, table, readsCnt, updatesCnt, partitionsCnt) \
     UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases(phaseNo).table_access().size(), 1, stats.DebugString());                     \
     UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases(phaseNo).table_access(0).name(), table, stats.DebugString());                \
     UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases(phaseNo).table_access(0).reads().rows(), readsCnt, stats.DebugString());     \
     UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases(phaseNo).table_access(0).updates().rows(), updatesCnt, stats.DebugString()); \
-    UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases(phaseNo).table_access(0).partitions_count(), std::max(readsCnt, updatesCnt), stats.DebugString());
+    UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases(phaseNo).table_access(0).partitions_count(), partitionsCnt, stats.DebugString());
+
+#define ASSERT_PHASE(stats, phaseNo, table, readsCnt, updatesCnt) \
+    ASSERT_PHASE_FULL(stats, phaseNo, table, readsCnt, updatesCnt, std::max(readsCnt, updatesCnt));
 
 
-Y_UNIT_TEST(SingleRowSimple) {
+Y_UNIT_TEST_TWIN(SingleRowSimple, UseSink) {
     Test(
         R"( DECLARE $key AS Uint64;
             DECLARE $value AS String;
@@ -130,14 +137,21 @@ Y_UNIT_TEST(SingleRowSimple) {
             [[1u];["updated"];[100u];[101.]];
             [[20u];["Two"];[200u];[202.]]
            ])",
-        [](const Ydb::TableStats::QueryStats& stats) {
-            UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());
-            ASSERT_PHASE(stats, 0, "/Root/InplaceUpdate", 1, 0);
-            ASSERT_PHASE(stats, 1, "/Root/InplaceUpdate", 0, 1);
-        });
+        [&](const Ydb::TableStats::QueryStats& stats) {
+            if (UseSink) {
+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 1, stats.DebugString());
+                ASSERT_PHASE_FULL(stats, 0, "/Root/InplaceUpdate", 1, 1, 2);
+            } else {
+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());
+                ASSERT_PHASE(stats, 0, "/Root/InplaceUpdate", 1, 0);
+                ASSERT_PHASE(stats, 1, "/Root/InplaceUpdate", 0, 1);
+            }
+        },
+        &PrepareTable,
+        UseSink);
 }
 
-Y_UNIT_TEST(SingleRowStr) {
+Y_UNIT_TEST_TWIN(SingleRowStr, UseSink) {
     Test(
         R"( DECLARE $key AS Uint64;
             DECLARE $value AS String;
@@ -154,14 +168,21 @@ Y_UNIT_TEST(SingleRowStr) {
             [[1u];["neupdated"];[100u];[101.]];
             [[20u];["Two"];[200u];[202.]]
            ])",
-        [](const Ydb::TableStats::QueryStats& stats) {
-            UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());
-            ASSERT_PHASE(stats, 0, "/Root/InplaceUpdate", 1, 0);
-            ASSERT_PHASE(stats, 1, "/Root/InplaceUpdate", 0, 1);
-        });
+        [&](const Ydb::TableStats::QueryStats& stats) {
+            if (UseSink) {
+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 1, stats.DebugString());
+                ASSERT_PHASE_FULL(stats, 0, "/Root/InplaceUpdate", 1, 1, 2);
+            } else {
+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());
+                ASSERT_PHASE(stats, 0, "/Root/InplaceUpdate", 1, 0);
+                ASSERT_PHASE(stats, 1, "/Root/InplaceUpdate", 0, 1);
+            }
+        },
+        &PrepareTable,
+        UseSink);
 }
 
-Y_UNIT_TEST(SingleRowArithm) {
+Y_UNIT_TEST_TWIN(SingleRowArithm, UseSink) {
     Test(
         R"( DECLARE $key AS Uint64;
             DECLARE $x AS Uint64;
@@ -181,14 +202,21 @@ Y_UNIT_TEST(SingleRowArithm) {
             [[1u];["One"];[1210u];[16.]];
             [[20u];["Two"];[200u];[202.]]
            ])",
-        [](const Ydb::TableStats::QueryStats& stats) {
-            UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());
-            ASSERT_PHASE(stats, 0, "/Root/InplaceUpdate", 1, 0);
-            ASSERT_PHASE(stats, 1, "/Root/InplaceUpdate", 0, 1);
-        });
+        [&](const Ydb::TableStats::QueryStats& stats) {
+            if (UseSink) {
+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 1, stats.DebugString());
+                ASSERT_PHASE_FULL(stats, 0, "/Root/InplaceUpdate", 1, 1, 2);
+            } else {
+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());
+                ASSERT_PHASE(stats, 0, "/Root/InplaceUpdate", 1, 0);
+                ASSERT_PHASE(stats, 1, "/Root/InplaceUpdate", 0, 1);
+            }
+        },
+        &PrepareTable,
+        UseSink);
 }
 
-Y_UNIT_TEST(SingleRowIf) {
+Y_UNIT_TEST_TWIN(SingleRowIf, UseSink) {
     Test(
         R"( DECLARE $key AS Uint64;
 
@@ -212,15 +240,22 @@ Y_UNIT_TEST(SingleRowIf) {
             [[1u];["One"];[11u];[1.]];
             [[20u];["Two"];[200u];[202.]]
            ])",
-        [](const Ydb::TableStats::QueryStats& stats) {
-            UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());
-            ASSERT_PHASE(stats, 0, "/Root/InplaceUpdate", 1, 0);
-            ASSERT_PHASE(stats, 1, "/Root/InplaceUpdate", 0, 1);
-        });
+        [&](const Ydb::TableStats::QueryStats& stats) {
+            if (UseSink) {
+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 1, stats.DebugString());
+                ASSERT_PHASE_FULL(stats, 0, "/Root/InplaceUpdate", 1, 1, 2);
+            } else {
+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());
+                ASSERT_PHASE(stats, 0, "/Root/InplaceUpdate", 1, 0);
+                ASSERT_PHASE(stats, 1, "/Root/InplaceUpdate", 0, 1);
+            }
+        },
+        &PrepareTable,
+        UseSink);
 }
 
 // allow multiple keys in KqpLookupTable to enable this test
-Y_UNIT_TEST(Negative_SingleRowWithKeyCast) {
+Y_UNIT_TEST_TWIN(Negative_SingleRowWithKeyCast, UseSink) {
     Test(
         R"( DECLARE $key AS Uint32; -- not Uint64
             DECLARE $value AS String;
@@ -237,21 +272,29 @@ Y_UNIT_TEST(Negative_SingleRowWithKeyCast) {
             [[1u];["updated"];[100u];[101.]];
             [[20u];["Two"];[200u];[202.]]
            ])",
-        [](const Ydb::TableStats::QueryStats& stats) {
+        [&](const Ydb::TableStats::QueryStats& stats) {
             // if constexpr (EnableInplaceUpdate) {
             //     UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());
             //     ASSERT_LITERAL_PHASE(stats, 0);
             //     ASSERT_PHASE(stats, 1, "/Root/InplaceUpdate", 1, 1);
             // } else {
+            if (UseSink) {
+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());
+                ASSERT_LITERAL_PHASE(stats, 0);
+                ASSERT_PHASE_FULL(stats, 1, "/Root/InplaceUpdate", 1, 1, 2);
+            } else {
                 UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 3, stats.DebugString());
                 ASSERT_LITERAL_PHASE(stats, 0);
                 ASSERT_PHASE(stats, 1, "/Root/InplaceUpdate", 1, 0);
                 ASSERT_PHASE(stats, 2, "/Root/InplaceUpdate", 0, 1);
+            }
             // }
-        });
+        },
+        &PrepareTable,
+        UseSink);
 }
 
-Y_UNIT_TEST(Negative_SingleRowWithValueCast) {
+Y_UNIT_TEST_TWIN(Negative_SingleRowWithValueCast, UseSink) {
 /*
     (
     (declare $key (DataType 'Uint64))
@@ -280,14 +323,21 @@ Y_UNIT_TEST(Negative_SingleRowWithValueCast) {
             [[1u];["One"];[1u];[101.]];
             [[20u];["Two"];[200u];[202.]]
            ])",
-        [](const Ydb::TableStats::QueryStats& stats) {
-            UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());
-            ASSERT_PHASE(stats, 0, "/Root/InplaceUpdate", 1, 0);
-            ASSERT_PHASE(stats, 1, "/Root/InplaceUpdate", 0, 1);
-        });
+        [&](const Ydb::TableStats::QueryStats& stats) {
+            if (UseSink) {
+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 1, stats.DebugString());
+                ASSERT_PHASE_FULL(stats, 0, "/Root/InplaceUpdate", 1, 1, 2);
+            } else {
+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());
+                ASSERT_PHASE(stats, 0, "/Root/InplaceUpdate", 1, 0);
+                ASSERT_PHASE(stats, 1, "/Root/InplaceUpdate", 0, 1);
+            }
+        },
+        &PrepareTable,
+        UseSink);
 }
 
-Y_UNIT_TEST(Negative_SingleRowListFromRange) {
+Y_UNIT_TEST_TWIN(Negative_SingleRowListFromRange, UseSink) {
     Test(
         R"( DECLARE $key AS Uint64;
 
@@ -307,15 +357,22 @@ Y_UNIT_TEST(Negative_SingleRowListFromRange) {
             [[1u];["One1..2..3..4..5..6..7..8..9"];[100u];[101.]];
             [[20u];["Two"];[200u];[202.]]
            ])",
-        [](const Ydb::TableStats::QueryStats& stats) {
-            UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());
-            ASSERT_PHASE(stats, 0, "/Root/InplaceUpdate", 1, 0);
-            ASSERT_PHASE(stats, 1, "/Root/InplaceUpdate", 0, 1);
-        });
+        [&](const Ydb::TableStats::QueryStats& stats) {
+            if (UseSink) {
+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 1, stats.DebugString());
+                ASSERT_PHASE_FULL(stats, 0, "/Root/InplaceUpdate", 1, 1, 2);
+            } else {
+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());
+                ASSERT_PHASE(stats, 0, "/Root/InplaceUpdate", 1, 0);
+                ASSERT_PHASE(stats, 1, "/Root/InplaceUpdate", 0, 1);
+            }
+        },
+        &PrepareTable,
+        UseSink);
 }
 
 // allow multiple keys in KqpLookupTable to enable this test
-Y_UNIT_TEST(Negative_BatchUpdate) {
+Y_UNIT_TEST_TWIN(Negative_BatchUpdate, UseSink) {
     Test(
         R"( DECLARE $key1 AS Uint64;
             DECLARE $value1 AS String;
@@ -343,19 +400,27 @@ Y_UNIT_TEST(Negative_BatchUpdate) {
             [[1u];["updated-1"];[100u];[101.]];
             [[20u];["updated-2"];[200u];[202.]]
         ])",
-        [](const Ydb::TableStats::QueryStats& stats) {
+        [&](const Ydb::TableStats::QueryStats& stats) {
             // if constexpr (EnableInplaceUpdate) {
             //     UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 3, stats.DebugString());
             //     ASSERT_LITERAL_PHASE(stats, 0);
             //     ASSERT_LITERAL_PHASE(stats, 1);
             //     ASSERT_PHASE(stats, 2, "/Root/InplaceUpdate", 2, 2);
             // } else {
+            if (UseSink) {
+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());
+                ASSERT_LITERAL_PHASE(stats, 0);
+                ASSERT_PHASE_FULL(stats, 1, "/Root/InplaceUpdate", 2, 2, 4);
+            } else {
                 UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 3, stats.DebugString());
                 ASSERT_LITERAL_PHASE(stats, 0);
                 ASSERT_PHASE(stats, 1, "/Root/InplaceUpdate", 2, 0);
                 ASSERT_PHASE(stats, 2, "/Root/InplaceUpdate", 0, 2);
+            }
             // }
-        });
+        },
+        &PrepareTable,
+        UseSink);
 }
 
 Y_UNIT_TEST(BigRow) {
@@ -421,7 +486,7 @@ Y_UNIT_TEST(BigRow) {
     ])", FormatResultSetYson(result.GetResultSet(0)));
 }
 
-Y_UNIT_TEST(SingleRowPgNotNull) {
+Y_UNIT_TEST_TWIN(SingleRowPgNotNull, UseSink) {
     Test(
         R"( DECLARE $key AS Uint64;
             DECLARE $value AS PgInt2;
@@ -438,12 +503,18 @@ Y_UNIT_TEST(SingleRowPgNotNull) {
             [[1u];["One"];"123";[101.]];
             [[20u];["Two"];"200";[202.]]
            ])",
-        [](const Ydb::TableStats::QueryStats& stats) {
-            UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());
-            ASSERT_PHASE(stats, 0, "/Root/InplaceUpdate", 1, 0);
-            ASSERT_PHASE(stats, 1, "/Root/InplaceUpdate", 0, 1);
+        [&](const Ydb::TableStats::QueryStats& stats) {
+            if (UseSink) {
+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 1, stats.DebugString());
+                ASSERT_PHASE_FULL(stats, 0, "/Root/InplaceUpdate", 1, 1, 2);
+            } else {
+                UNIT_ASSERT_VALUES_EQUAL_C(stats.query_phases().size(), 2, stats.DebugString());
+                ASSERT_PHASE(stats, 0, "/Root/InplaceUpdate", 1, 0);
+                ASSERT_PHASE(stats, 1, "/Root/InplaceUpdate", 0, 1);
+            }
         },
-        &PreparePgTable);
+        &PreparePgTable,
+        UseSink);
 }
 
 } // suite
diff --git a/ydb/core/kqp/ut/effects/kqp_write_ut.cpp b/ydb/core/kqp/ut/effects/kqp_write_ut.cpp
index 8a7e369a605c..7fc16a4ad238 100644
--- a/ydb/core/kqp/ut/effects/kqp_write_ut.cpp
+++ b/ydb/core/kqp/ut/effects/kqp_write_ut.cpp
@@ -323,8 +323,10 @@ Y_UNIT_TEST_SUITE(KqpWrite) {
         CompareYson(R"([[[1u]];[[2u]];[[3u]]])", FormatResultSetYson(result.GetResultSet(1)));
     }
 
-    Y_UNIT_TEST(ProjectReplace) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_TWIN(ProjectReplace, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
 
@@ -368,7 +370,7 @@ Y_UNIT_TEST_SUITE(KqpWrite) {
 
         auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
 
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);
     }
 
     Y_UNIT_TEST(CastValues) {
diff --git a/ydb/core/kqp/ut/indexes/kqp_indexes_multishard_ut.cpp b/ydb/core/kqp/ut/indexes/kqp_indexes_multishard_ut.cpp
index 46b1e84f2ca5..b1284f525719 100644
--- a/ydb/core/kqp/ut/indexes/kqp_indexes_multishard_ut.cpp
+++ b/ydb/core/kqp/ut/indexes/kqp_indexes_multishard_ut.cpp
@@ -1767,8 +1767,9 @@ Y_UNIT_TEST_SUITE(KqpMultishardIndex) {
         }
     }
 
-    Y_UNIT_TEST(DataColumnWrite) {
+    Y_UNIT_TEST_TWIN(DataColumnWrite, UseSink) {
         NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
 
         auto setting = NKikimrKqp::TKqpSetting();
         auto serverSettings = TKikimrSettings()
diff --git a/ydb/core/kqp/ut/indexes/kqp_indexes_ut.cpp b/ydb/core/kqp/ut/indexes/kqp_indexes_ut.cpp
index f70a7e16ea87..150dd9f20da9 100644
--- a/ydb/core/kqp/ut/indexes/kqp_indexes_ut.cpp
+++ b/ydb/core/kqp/ut/indexes/kqp_indexes_ut.cpp
@@ -899,10 +899,13 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
         }
     }
 
-    void DoUpsertWithoutIndexUpdate(bool uniq) {
+    void DoUpsertWithoutIndexUpdate(bool uniq, bool useSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);
         auto setting = NKikimrKqp::TKqpSetting();
         auto serverSettings = TKikimrSettings()
-            .SetKqpSettings({setting});
+            .SetKqpSettings({setting})
+            .SetAppConfig(appConfig);
         TKikimrRunner kikimr(serverSettings);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
@@ -945,7 +948,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
 
             Cerr << stats.DebugString() << Endl;
 
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(),  uniqExtraStages + 5);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(),  uniqExtraStages + (useSink ? 4 : 5));
 
             // One read from main table
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniq + 1).table_access().size(), 1);
@@ -953,18 +956,23 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniq + 1).table_access(0).reads().rows(), 0);
 
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 2).table_access().size(), 0);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 3).table_access().size(), 0);
 
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 4).table_access().size(), 2);
+            if (!useSink) {
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 3).table_access().size(), 0);
+            }
+
+            const auto finalStage = useSink ? 3 : 4;
+
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + finalStage).table_access().size(), 2);
 
             // One update of main table
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 4).table_access(0).name(), "/Root/TestTable");
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 4).table_access(0).updates().rows(), 1);
-            UNIT_ASSERT(            !stats.query_phases(uniqExtraStages + 4).table_access(0).has_deletes());
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + finalStage).table_access(0).name(), "/Root/TestTable");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + finalStage).table_access(0).updates().rows(), 1);
+            UNIT_ASSERT(            !stats.query_phases(uniqExtraStages + finalStage).table_access(0).has_deletes());
 
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 4).table_access(1).name(), "/Root/TestTable/Index/indexImplTable");
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 4).table_access(1).updates().rows(), 1);
-            UNIT_ASSERT(            !stats.query_phases(uniqExtraStages + 4).table_access(1).has_deletes());
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + finalStage).table_access(1).name(), "/Root/TestTable/Index/indexImplTable");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + finalStage).table_access(1).updates().rows(), 1);
+            UNIT_ASSERT(            !stats.query_phases(uniqExtraStages + finalStage).table_access(1).has_deletes());
 
             {
                 const auto& yson = ReadTablePartToYson(session, "/Root/TestTable/Index/indexImplTable");
@@ -989,7 +997,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
                           .ExtractValueSync();
             UNIT_ASSERT(result.IsSuccess());
             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), uniqExtraStages + 5);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), uniqExtraStages + (useSink ? 4 : 5));
 
             // One read from main table
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniq + 1).table_access().size(), 1);
@@ -997,13 +1005,18 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniq + 1).table_access(0).reads().rows(), 1);
 
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 2).table_access().size(), 0);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 3).table_access().size(), 0);
+
+            if (!useSink) {
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 3).table_access().size(), 0);
+            }
+
+            const auto finalStage = useSink ? 3 : 4;
 
             // One update of main table
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 4).table_access().size(), 1);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 4).table_access(0).name(), "/Root/TestTable");
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + 4).table_access(0).updates().rows(), 1);
-            UNIT_ASSERT(            !stats.query_phases(uniqExtraStages + 4).table_access(0).has_deletes());
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + finalStage).table_access().size(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + finalStage).table_access(0).name(), "/Root/TestTable");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(uniqExtraStages + finalStage).table_access(0).updates().rows(), 1);
+            UNIT_ASSERT(            !stats.query_phases(uniqExtraStages + finalStage).table_access(0).has_deletes());
 
             {
                 const auto& yson = ReadTablePartToYson(session, "/Root/TestTable/Index/indexImplTable");
@@ -1013,14 +1026,17 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
         }
     }
 
-    Y_UNIT_TEST_TWIN(DoUpsertWithoutIndexUpdate, UniqIndex) {
-        DoUpsertWithoutIndexUpdate(UniqIndex);
+    Y_UNIT_TEST_QUAD(DoUpsertWithoutIndexUpdate, UniqIndex, UseSink) {
+        DoUpsertWithoutIndexUpdate(UniqIndex, UseSink);
     }
 
-    Y_UNIT_TEST(UpsertWithoutExtraNullDelete) {
+    Y_UNIT_TEST_TWIN(UpsertWithoutExtraNullDelete, UseSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         auto setting = NKikimrKqp::TKqpSetting();
         auto serverSettings = TKikimrSettings()
-            .SetKqpSettings({setting});
+            .SetKqpSettings({setting})
+            .SetAppConfig(appConfig);
         TKikimrRunner kikimr(serverSettings);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
@@ -1061,22 +1077,27 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
 
             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
 
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 5);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 4 : 5);
 
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/TestTable");
 
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(2).table_access().size(), 0);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(3).table_access().size(), 0);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access().size(), 2);
 
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(0).name(), "/Root/TestTable");
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(0).updates().rows(), 1);
-            UNIT_ASSERT(            !stats.query_phases(4).table_access(0).has_deletes());
+            if (!UseSink) {
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(3).table_access().size(), 0);
+            }
+
+            const auto finalStage = UseSink ? 3 : 4;
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access().size(), 2);
 
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(1).name(), "/Root/TestTable/Index/indexImplTable");
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(1).updates().rows(), 1);
-            UNIT_ASSERT(            !stats.query_phases(4).table_access(1).has_deletes());
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(0).name(), "/Root/TestTable");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(0).updates().rows(), 1);
+            UNIT_ASSERT(            !stats.query_phases(finalStage).table_access(0).has_deletes());
+
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(1).name(), "/Root/TestTable/Index/indexImplTable");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(1).updates().rows(), 1);
+            UNIT_ASSERT(            !stats.query_phases(finalStage).table_access(1).has_deletes());
         }
 
         {
@@ -1095,25 +1116,30 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
             UNIT_ASSERT(result.IsSuccess());
             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
 
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 5);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 4 : 5);
 
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/TestTable");
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).reads().rows(), 1);
 
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(2).table_access().size(), 0);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(3).table_access().size(), 0);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access().size(), 2);
+            if (!UseSink) {
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(3).table_access().size(), 0);
+            }
+
+            const auto finalStage = UseSink ? 3 : 4;
+
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access().size(), 2);
 
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(0).name(), "/Root/TestTable");
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(0).updates().rows(), 1);
-            UNIT_ASSERT(            !stats.query_phases(4).table_access(0).has_deletes());
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(0).name(), "/Root/TestTable");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(0).updates().rows(), 1);
+            UNIT_ASSERT(            !stats.query_phases(finalStage).table_access(0).has_deletes());
 
 
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(1).name(), "/Root/TestTable/Index/indexImplTable");
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(1).updates().rows(), 1);
-            UNIT_ASSERT(             stats.query_phases(4).table_access(1).has_deletes());
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(1).deletes().rows(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(1).name(), "/Root/TestTable/Index/indexImplTable");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(1).updates().rows(), 1);
+            UNIT_ASSERT(             stats.query_phases(finalStage).table_access(1).has_deletes());
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(1).deletes().rows(), 1);
         }
 
         {
@@ -1132,7 +1158,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
                           .ExtractValueSync();
             UNIT_ASSERT(result.IsSuccess());
             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 5);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 4 : 5);
 
             // One read from main table
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
@@ -1140,13 +1166,17 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).reads().rows(), 1);
 
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(2).table_access().size(), 0);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(3).table_access().size(), 0);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access().size(), 1);
+
+            const auto finalStage = UseSink ? 3 : 4;
+            if (!UseSink) {
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(3).table_access().size(), 0);
+            }
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access().size(), 1);
 
             // One update of main table
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(0).name(), "/Root/TestTable");
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(4).table_access(0).updates().rows(), 1);
-            UNIT_ASSERT(            !stats.query_phases(4).table_access(0).has_deletes());
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(0).name(), "/Root/TestTable");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(finalStage).table_access(0).updates().rows(), 1);
+            UNIT_ASSERT(            !stats.query_phases(finalStage).table_access(0).has_deletes());
 
             {
                 const auto& yson = ReadTablePartToYson(session, "/Root/TestTable/Index/indexImplTable");
@@ -1171,7 +1201,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
                           .ExtractValueSync();
             UNIT_ASSERT(result.IsSuccess());
             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 4);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 3 : 4);
 
             int idx = 1;
 
@@ -1181,10 +1211,10 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).reads().rows(), 1);
 
             // One update of index table
-            idx += 2;
+            idx += UseSink ? 1 : 2;
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access().size(), 1);
             UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).name(), "/Root/TestTable");
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).updates().rows(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).updates().rows(), 1);    
 
             // Thats it, no phase for index table - we remove it on compile time
             {
@@ -1210,17 +1240,24 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
                           .ExtractValueSync();
             UNIT_ASSERT(result.IsSuccess());
             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);
 
-            // One read of main table
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/TestTable");
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 1);
+            if (!UseSink) {
+                // One read of main table
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/TestTable");
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 1);
 
-            // One update of main table
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/TestTable");
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);
+                // One update of main table
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/TestTable");
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);
+            } else {
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/TestTable");
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 1);
+            }
 
             {
                 const auto& yson = ReadTablePartToYson(session, "/Root/TestTable/Index/indexImplTable");
@@ -2313,7 +2350,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
         return session;
     }
 
-    Y_UNIT_TEST(VectorIndexOrderByCosineDistanceNotNullableLevel1) {
+    Y_UNIT_TEST(SimpleVectorIndexOrderByCosineDistanceNotNullableLevel1) {
         NKikimrConfig::TFeatureFlags featureFlags;
         featureFlags.SetEnableVectorIndex(true);
         auto setting = NKikimrKqp::TKqpSetting();
@@ -2355,7 +2392,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
         DoPositiveQueriesVectorIndexOrderByCosine(session);
     }
 
-    Y_UNIT_TEST(VectorIndexOrderByCosineSimilarityNotNullableLevel1) {
+    Y_UNIT_TEST(SimpleVectorIndexOrderByCosineSimilarityNotNullableLevel1) {
         NKikimrConfig::TFeatureFlags featureFlags;
         featureFlags.SetEnableVectorIndex(true);
         auto setting = NKikimrKqp::TKqpSetting();
@@ -2397,7 +2434,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
         DoPositiveQueriesVectorIndexOrderByCosine(session);
     }
 
-    Y_UNIT_TEST(VectorIndexOrderByCosineDistanceNullableLevel1) {
+    Y_UNIT_TEST(SimpleVectorIndexOrderByCosineDistanceNullableLevel1) {
         NKikimrConfig::TFeatureFlags featureFlags;
         featureFlags.SetEnableVectorIndex(true);
         auto setting = NKikimrKqp::TKqpSetting();
@@ -2439,7 +2476,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
         DoPositiveQueriesVectorIndexOrderByCosine(session);
     }
 
-    Y_UNIT_TEST(VectorIndexOrderByCosineSimilarityNullableLevel1) {
+    Y_UNIT_TEST(SimpleVectorIndexOrderByCosineSimilarityNullableLevel1) {
         NKikimrConfig::TFeatureFlags featureFlags;
         featureFlags.SetEnableVectorIndex(true);
         auto setting = NKikimrKqp::TKqpSetting();
@@ -2481,7 +2518,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
         DoPositiveQueriesVectorIndexOrderByCosine(session);
     }
 
-    Y_UNIT_TEST(VectorIndexOrderByCosineDistanceNotNullableLevel2) {
+    Y_UNIT_TEST(SimpleVectorIndexOrderByCosineDistanceNotNullableLevel2) {
         NKikimrConfig::TFeatureFlags featureFlags;
         featureFlags.SetEnableVectorIndex(true);
         auto setting = NKikimrKqp::TKqpSetting();
@@ -2523,7 +2560,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
         DoPositiveQueriesVectorIndexOrderByCosine(session);
     }
 
-    Y_UNIT_TEST(VectorIndexOrderByCosineSimilarityNotNullableLevel2) {
+    Y_UNIT_TEST(SimpleVectorIndexOrderByCosineSimilarityNotNullableLevel2) {
         NKikimrConfig::TFeatureFlags featureFlags;
         featureFlags.SetEnableVectorIndex(true);
         auto setting = NKikimrKqp::TKqpSetting();
@@ -2565,7 +2602,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
         DoPositiveQueriesVectorIndexOrderByCosine(session);
     }
 
-    Y_UNIT_TEST(VectorIndexOrderByCosineDistanceNullableLevel2) {
+    Y_UNIT_TEST(SimpleVectorIndexOrderByCosineDistanceNullableLevel2) {
         NKikimrConfig::TFeatureFlags featureFlags;
         featureFlags.SetEnableVectorIndex(true);
         auto setting = NKikimrKqp::TKqpSetting();
@@ -2607,7 +2644,7 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
         DoPositiveQueriesVectorIndexOrderByCosine(session);
     }
 
-    Y_UNIT_TEST(VectorIndexOrderByCosineSimilarityNullableLevel2) {
+    Y_UNIT_TEST(SimpleVectorIndexOrderByCosineSimilarityNullableLevel2) {
         NKikimrConfig::TFeatureFlags featureFlags;
         featureFlags.SetEnableVectorIndex(true);
         auto setting = NKikimrKqp::TKqpSetting();
@@ -2649,6 +2686,569 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
         DoPositiveQueriesVectorIndexOrderByCosine(session);
     }
 
+    std::vector<i64> DoPositiveQueryPrefixedVectorIndex(TSession& session, const TString& query) {
+        {
+            auto result = session.ExplainDataQuery(query).ExtractValueSync();
+            UNIT_ASSERT_C(result.IsSuccess(),
+                "Failed to explain: `" << query << "` with " << result.GetIssues().ToString());
+        }
+        {
+            auto result = session.ExecuteDataQuery(query,
+                TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx()
+            ).ExtractValueSync();
+            UNIT_ASSERT_C(result.IsSuccess(),
+                "Failed to execute: `" << query << "` with " << result.GetIssues().ToString());
+
+            std::vector<i64> r;
+            auto sets = result.GetResultSets();
+            for (const auto& set : sets) {
+                TResultSetParser parser{set};
+                while (parser.TryNextRow()) {
+                    auto value = parser.GetValue("pk");
+                    UNIT_ASSERT_C(value.GetProto().has_int64_value(), value.GetProto().ShortUtf8DebugString());
+                    r.push_back(value.GetProto().int64_value());
+                }
+            }
+            return r;
+        }
+    }
+
+    void DoPositiveQueriesPrefixedVectorIndex(TSession& session, const TString& mainQuery, const TString& indexQuery) {
+        // TODO(mbkkt) results are not precise so for now can differ between main and index
+        // But they're still should contains exactly 3 unique rows
+        auto mainResults = DoPositiveQueryPrefixedVectorIndex(session, mainQuery);
+        UNIT_ASSERT_EQUAL(mainResults.size(), 3);
+        auto indexResults = DoPositiveQueryPrefixedVectorIndex(session, indexQuery);
+        UNIT_ASSERT_EQUAL(indexResults.size(), 3);
+
+        absl::c_sort(mainResults);
+        UNIT_ASSERT(std::unique(mainResults.begin(), mainResults.end()) == mainResults.end());
+
+        absl::c_sort(indexResults);
+        UNIT_ASSERT(std::unique(indexResults.begin(), indexResults.end()) == indexResults.end());
+    }
+
+    void DoPositiveQueriesPrefixedVectorIndexOrderBy(
+        TSession& session,
+        std::string_view function,
+        std::string_view direction,
+        std::string_view left,
+        std::string_view right) {
+        constexpr std::string_view target = "$target = \"\x67\x73\x03\";";
+        std::string metric = std::format("Knn::{}({}, {})", function, left, right);
+        // no metric in result
+        {
+            const TString plainQuery(Q1_(std::format(R"({}
+                SELECT * FROM `/Root/TestTable`
+                ORDER BY {} {}
+                LIMIT 3;
+            )", target, metric, direction)));
+            const TString indexQuery(Q1_(std::format(R"(
+                pragma ydb.KMeansTreeSearchTopSize = "3";
+                {}
+                SELECT * FROM `/Root/TestTable` VIEW index
+                ORDER BY {} {}
+                LIMIT 3;
+            )", target, metric, direction)));
+            DoPositiveQueriesPrefixedVectorIndex(session, plainQuery, indexQuery);
+        }
+        // metric in result
+        {
+            const TString plainQuery(Q1_(std::format(R"({}
+                SELECT {}, `/Root/TestTable`.* FROM `/Root/TestTable`
+                ORDER BY {} {}
+                LIMIT 3;
+            )", target, metric, metric, direction)));
+            const TString indexQuery(Q1_(std::format(R"({}
+                pragma ydb.KMeansTreeSearchTopSize = "2";
+                SELECT {}, `/Root/TestTable`.* FROM `/Root/TestTable` VIEW index
+                ORDER BY {} {}
+                LIMIT 3;
+            )", target, metric, metric, direction)));
+            DoPositiveQueriesPrefixedVectorIndex(session, plainQuery, indexQuery);
+        }
+        // metric as result
+        {
+            const TString plainQuery(Q1_(std::format(R"({}
+                SELECT {} AS m, `/Root/TestTable`.* FROM `/Root/TestTable`
+                ORDER BY m {}
+                LIMIT 3;
+            )", target, metric, direction)));
+            const TString indexQuery(Q1_(std::format(R"(
+                pragma ydb.KMeansTreeSearchTopSize = "1";
+                {}
+                SELECT {} AS m, `/Root/TestTable`.* FROM `/Root/TestTable` VIEW index
+                ORDER BY m {}
+                LIMIT 3;
+            )", target, metric, direction)));
+            DoPositiveQueriesPrefixedVectorIndex(session, plainQuery, indexQuery);
+        }
+    }
+
+    void DoPositiveQueriesPrefixedVectorIndexOrderBy(
+        TSession& session,
+        std::string_view function,
+        std::string_view direction) {
+        // target is left, member is right
+        DoPositiveQueriesPrefixedVectorIndexOrderBy(session, function, direction, "$target", "emb");
+        // target is right, member is left
+        DoPositiveQueriesPrefixedVectorIndexOrderBy(session, function, direction, "emb", "$target");
+    }
+
+    void DoPositiveQueriesPrefixedVectorIndexOrderByCosine(TSession& session) {
+        // distance, default direction
+        DoPositiveQueriesPrefixedVectorIndexOrderBy(session, "CosineDistance", "");
+        // distance, asc direction
+        DoPositiveQueriesPrefixedVectorIndexOrderBy(session, "CosineDistance", "ASC");
+        // similarity, desc direction
+        DoPositiveQueriesPrefixedVectorIndexOrderBy(session, "CosineSimilarity", "DESC");
+    }
+
+    TSession DoCreateTableForPrefixedVectorIndex(TTableClient& db, bool nullable) {
+        auto session = db.CreateSession().GetValueSync().GetSession();
+
+        {
+            auto tableBuilder = db.GetTableBuilder();
+            if (nullable) {
+                tableBuilder
+                    .AddNullableColumn("pk", EPrimitiveType::Int64)
+                    .AddNullableColumn("user", EPrimitiveType::String)
+                    .AddNullableColumn("emb", EPrimitiveType::String)
+                    .AddNullableColumn("data", EPrimitiveType::String);
+            } else {
+                tableBuilder
+                    .AddNonNullableColumn("pk", EPrimitiveType::Int64)
+                    .AddNonNullableColumn("user", EPrimitiveType::String)
+                    .AddNonNullableColumn("emb", EPrimitiveType::String)
+                    .AddNonNullableColumn("data", EPrimitiveType::String);
+            }
+            tableBuilder.SetPrimaryKeyColumns({"pk"});
+            tableBuilder.BeginPartitioningSettings()
+                .SetMinPartitionsCount(3)
+            .EndPartitioningSettings();
+            auto partitions = TExplicitPartitions{}
+                .AppendSplitPoints(TValueBuilder{}.BeginTuple().AddElement().OptionalInt64(4).EndTuple().Build())
+                .AppendSplitPoints(TValueBuilder{}.BeginTuple().AddElement().OptionalInt64(6).EndTuple().Build());
+            tableBuilder.SetPartitionAtKeys(partitions);
+            auto result = session.CreateTable("/Root/TestTable", tableBuilder.Build()).ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL(result.IsTransportError(), false);
+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
+        }
+
+        {
+            const TString query1(Q_(R"(
+                UPSERT INTO `/Root/TestTable` (pk, user, emb, data) VALUES)"
+                "(0, \"user_a\", \"\x03\x30\x03\", \"0\"),"
+                "(1, \"user_a\", \"\x13\x31\x03\", \"1\"),"
+                "(2, \"user_a\", \"\x23\x32\x03\", \"2\"),"
+                "(3, \"user_a\", \"\x33\x33\x03\", \"3\"),"
+                "(4, \"user_a\", \"\x43\x34\x03\", \"4\"),"
+                "(5, \"user_a\", \"\x60\x60\x03\", \"5\"),"
+                "(6, \"user_a\", \"\x61\x61\x03\", \"6\"),"
+                "(7, \"user_a\", \"\x62\x62\x03\", \"7\"),"
+                "(8, \"user_a\", \"\x75\x76\x03\", \"8\"),"
+                "(9, \"user_a\", \"\x76\x76\x03\", \"9\"),"
+
+                "(0, \"user_b\", \"\x03\x30\x03\", \"0\"),"
+                "(1, \"user_b\", \"\x13\x31\x03\", \"1\"),"
+                "(2, \"user_b\", \"\x23\x32\x03\", \"2\"),"
+                "(3, \"user_b\", \"\x33\x33\x03\", \"3\"),"
+                "(4, \"user_b\", \"\x43\x34\x03\", \"4\"),"
+                "(5, \"user_b\", \"\x60\x60\x03\", \"5\"),"
+                "(6, \"user_b\", \"\x61\x61\x03\", \"6\"),"
+                "(7, \"user_b\", \"\x62\x62\x03\", \"7\"),"
+                "(8, \"user_b\", \"\x75\x76\x03\", \"8\"),"
+                "(9, \"user_b\", \"\x76\x76\x03\", \"9\"),"
+
+                "(0, \"user_c\", \"\x03\x30\x03\", \"0\"),"
+                "(1, \"user_c\", \"\x13\x31\x03\", \"1\"),"
+                "(2, \"user_c\", \"\x23\x32\x03\", \"2\"),"
+                "(3, \"user_c\", \"\x33\x33\x03\", \"3\"),"
+                "(4, \"user_c\", \"\x43\x34\x03\", \"4\"),"
+                "(5, \"user_c\", \"\x60\x60\x03\", \"5\"),"
+                "(6, \"user_c\", \"\x61\x61\x03\", \"6\"),"
+                "(7, \"user_c\", \"\x62\x62\x03\", \"7\"),"
+                "(8, \"user_c\", \"\x75\x76\x03\", \"8\"),"
+                "(9, \"user_c\", \"\x76\x76\x03\", \"9\");"
+            ));
+
+            auto result = session.ExecuteDataQuery(
+                                 query1,
+                                 TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx())
+                          .ExtractValueSync();
+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());
+        }
+        return session;
+    }
+
+    Y_UNIT_TEST(PrefixedVectorIndexOrderByCosineDistanceNotNullableLevel1) {
+        NKikimrConfig::TFeatureFlags featureFlags;
+        featureFlags.SetEnableVectorIndex(true);
+        auto setting = NKikimrKqp::TKqpSetting();
+        auto serverSettings = TKikimrSettings()
+            .SetFeatureFlags(featureFlags)
+            .SetKqpSettings({setting});
+
+        TKikimrRunner kikimr(serverSettings);
+        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_DEBUG);
+
+        auto db = kikimr.GetTableClient();
+        auto session = DoCreateTableForPrefixedVectorIndex(db, false);
+        {
+            const TString createIndex(Q_(R"(
+                ALTER TABLE `/Root/TestTable`
+                    ADD INDEX index
+                    GLOBAL USING vector_kmeans_tree
+                    ON (user, emb)
+                    WITH (distance=cosine, vector_type="uint8", vector_dimension=2, levels=1, clusters=2);
+            )"));
+
+            auto result = session.ExecuteSchemeQuery(createIndex)
+                          .ExtractValueSync();
+
+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());
+        }
+        {
+            auto result = session.DescribeTable("/Root/TestTable").ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);
+            const auto& indexes = result.GetTableDescription().GetIndexDescriptions();
+            UNIT_ASSERT_EQUAL(indexes.size(), 1);
+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexName(), "index");
+            std::vector<std::string> indexKeyColumns{"user", "emb"};
+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexColumns(), indexKeyColumns);
+            const auto& settings = std::get<TKMeansTreeSettings>(indexes[0].GetIndexSettings());
+            UNIT_ASSERT_EQUAL(settings.Settings.Metric, NYdb::NTable::TVectorIndexSettings::EMetric::CosineDistance);
+            UNIT_ASSERT_EQUAL(settings.Settings.VectorType, NYdb::NTable::TVectorIndexSettings::EVectorType::Uint8);
+            UNIT_ASSERT_EQUAL(settings.Settings.VectorDimension, 2);
+            UNIT_ASSERT_EQUAL(settings.Levels, 1);
+            UNIT_ASSERT_EQUAL(settings.Clusters, 2);
+        }
+        // TODO(mbkkt) enable it when kqp part will be ready
+        // DoPositiveQueriesPrefixedVectorIndexOrderByCosine(session);
+    }
+
+    Y_UNIT_TEST(PrefixedVectorIndexOrderByCosineSimilarityNotNullableLevel1) {
+        NKikimrConfig::TFeatureFlags featureFlags;
+        featureFlags.SetEnableVectorIndex(true);
+        auto setting = NKikimrKqp::TKqpSetting();
+        auto serverSettings = TKikimrSettings()
+            .SetFeatureFlags(featureFlags)
+            .SetKqpSettings({setting});
+
+        TKikimrRunner kikimr(serverSettings);
+        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_DEBUG);
+
+        auto db = kikimr.GetTableClient();
+        auto session = DoCreateTableForPrefixedVectorIndex(db, false);
+        {
+            const TString createIndex(Q_(R"(
+                ALTER TABLE `/Root/TestTable`
+                    ADD INDEX index
+                    GLOBAL USING vector_kmeans_tree
+                    ON (user, emb)
+                    WITH (similarity=cosine, vector_type="uint8", vector_dimension=2, levels=1, clusters=2);
+            )"));
+
+            auto result = session.ExecuteSchemeQuery(createIndex)
+                          .ExtractValueSync();
+
+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());
+        }
+        {
+            auto result = session.DescribeTable("/Root/TestTable").ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);
+            const auto& indexes = result.GetTableDescription().GetIndexDescriptions();
+            UNIT_ASSERT_EQUAL(indexes.size(), 1);
+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexName(), "index");
+            std::vector<std::string> indexKeyColumns{"user", "emb"};
+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexColumns(), indexKeyColumns);
+            const auto& settings = std::get<TKMeansTreeSettings>(indexes[0].GetIndexSettings());
+            UNIT_ASSERT_EQUAL(settings.Settings.Metric, NYdb::NTable::TVectorIndexSettings::EMetric::CosineSimilarity);
+            UNIT_ASSERT_EQUAL(settings.Settings.VectorType, NYdb::NTable::TVectorIndexSettings::EVectorType::Uint8);
+            UNIT_ASSERT_EQUAL(settings.Settings.VectorDimension, 2);
+            UNIT_ASSERT_EQUAL(settings.Levels, 1);
+            UNIT_ASSERT_EQUAL(settings.Clusters, 2);
+        }
+        // TODO(mbkkt) enable it when kqp part will be ready
+        // DoPositiveQueriesPrefixedVectorIndexOrderByCosine(session);
+    }
+
+    Y_UNIT_TEST(PrefixedVectorIndexOrderByCosineDistanceNullableLevel1) {
+        NKikimrConfig::TFeatureFlags featureFlags;
+        featureFlags.SetEnableVectorIndex(true);
+        auto setting = NKikimrKqp::TKqpSetting();
+        auto serverSettings = TKikimrSettings()
+            .SetFeatureFlags(featureFlags)
+            .SetKqpSettings({setting});
+
+        TKikimrRunner kikimr(serverSettings);
+        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_DEBUG);
+
+        auto db = kikimr.GetTableClient();
+        auto session = DoCreateTableForPrefixedVectorIndex(db, true);
+        {
+            const TString createIndex(Q_(R"(
+                ALTER TABLE `/Root/TestTable`
+                    ADD INDEX index
+                    GLOBAL USING vector_kmeans_tree
+                    ON (user, emb)
+                    WITH (distance=cosine, vector_type="uint8", vector_dimension=2, levels=1, clusters=2);
+            )"));
+
+            auto result = session.ExecuteSchemeQuery(createIndex)
+                          .ExtractValueSync();
+
+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());
+        }
+        {
+            auto result = session.DescribeTable("/Root/TestTable").ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);
+            const auto& indexes = result.GetTableDescription().GetIndexDescriptions();
+            UNIT_ASSERT_EQUAL(indexes.size(), 1);
+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexName(), "index");
+            std::vector<std::string> indexKeyColumns{"user", "emb"};
+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexColumns(), indexKeyColumns);
+            const auto& settings = std::get<TKMeansTreeSettings>(indexes[0].GetIndexSettings());
+            UNIT_ASSERT_EQUAL(settings.Settings.Metric, NYdb::NTable::TVectorIndexSettings::EMetric::CosineDistance);
+            UNIT_ASSERT_EQUAL(settings.Settings.VectorType, NYdb::NTable::TVectorIndexSettings::EVectorType::Uint8);
+            UNIT_ASSERT_EQUAL(settings.Settings.VectorDimension, 2);
+            UNIT_ASSERT_EQUAL(settings.Levels, 1);
+            UNIT_ASSERT_EQUAL(settings.Clusters, 2);
+        }
+        // TODO(mbkkt) enable it when kqp part will be ready
+        // DoPositiveQueriesPrefixedVectorIndexOrderByCosine(session);
+    }
+
+    Y_UNIT_TEST(PrefixedVectorIndexOrderByCosineSimilarityNullableLevel1) {
+        NKikimrConfig::TFeatureFlags featureFlags;
+        featureFlags.SetEnableVectorIndex(true);
+        auto setting = NKikimrKqp::TKqpSetting();
+        auto serverSettings = TKikimrSettings()
+            .SetFeatureFlags(featureFlags)
+            .SetKqpSettings({setting});
+
+        TKikimrRunner kikimr(serverSettings);
+        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_DEBUG);
+
+        auto db = kikimr.GetTableClient();
+        auto session = DoCreateTableForPrefixedVectorIndex(db, true);
+        {
+            const TString createIndex(Q_(R"(
+                ALTER TABLE `/Root/TestTable`
+                    ADD INDEX index
+                    GLOBAL USING vector_kmeans_tree
+                    ON (user, emb)
+                    WITH (similarity=cosine, vector_type="uint8", vector_dimension=2, levels=1, clusters=2);
+            )"));
+
+            auto result = session.ExecuteSchemeQuery(createIndex)
+                          .ExtractValueSync();
+
+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());
+        }
+        {
+            auto result = session.DescribeTable("/Root/TestTable").ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);
+            const auto& indexes = result.GetTableDescription().GetIndexDescriptions();
+            UNIT_ASSERT_EQUAL(indexes.size(), 1);
+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexName(), "index");
+            std::vector<std::string> indexKeyColumns{"user", "emb"};
+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexColumns(), indexKeyColumns);
+            const auto& settings = std::get<TKMeansTreeSettings>(indexes[0].GetIndexSettings());
+            UNIT_ASSERT_EQUAL(settings.Settings.Metric, NYdb::NTable::TVectorIndexSettings::EMetric::CosineSimilarity);
+            UNIT_ASSERT_EQUAL(settings.Settings.VectorType, NYdb::NTable::TVectorIndexSettings::EVectorType::Uint8);
+            UNIT_ASSERT_EQUAL(settings.Settings.VectorDimension, 2);
+            UNIT_ASSERT_EQUAL(settings.Levels, 1);
+            UNIT_ASSERT_EQUAL(settings.Clusters, 2);
+        }
+        // TODO(mbkkt) enable it when kqp part will be ready
+        // DoPositiveQueriesPrefixedVectorIndexOrderByCosine(session);
+    }
+
+    Y_UNIT_TEST(PrefixedVectorIndexOrderByCosineDistanceNotNullableLevel2) {
+        NKikimrConfig::TFeatureFlags featureFlags;
+        featureFlags.SetEnableVectorIndex(true);
+        auto setting = NKikimrKqp::TKqpSetting();
+        auto serverSettings = TKikimrSettings()
+            .SetFeatureFlags(featureFlags)
+            .SetKqpSettings({setting});
+
+        TKikimrRunner kikimr(serverSettings);
+        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_DEBUG);
+
+        auto db = kikimr.GetTableClient();
+        auto session = DoCreateTableForPrefixedVectorIndex(db, false);
+        {
+            const TString createIndex(Q_(R"(
+                ALTER TABLE `/Root/TestTable`
+                    ADD INDEX index
+                    GLOBAL USING vector_kmeans_tree
+                    ON (user, emb)
+                    WITH (distance=cosine, vector_type="uint8", vector_dimension=2, levels=2, clusters=2);
+            )"));
+
+            auto result = session.ExecuteSchemeQuery(createIndex)
+                          .ExtractValueSync();
+
+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());
+        }
+        {
+            auto result = session.DescribeTable("/Root/TestTable").ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);
+            const auto& indexes = result.GetTableDescription().GetIndexDescriptions();
+            UNIT_ASSERT_EQUAL(indexes.size(), 1);
+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexName(), "index");
+            std::vector<std::string> indexKeyColumns{"user", "emb"};
+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexColumns(), indexKeyColumns);
+            const auto& settings = std::get<TKMeansTreeSettings>(indexes[0].GetIndexSettings());
+            UNIT_ASSERT_EQUAL(settings.Settings.Metric, NYdb::NTable::TVectorIndexSettings::EMetric::CosineDistance);
+            UNIT_ASSERT_EQUAL(settings.Settings.VectorType, NYdb::NTable::TVectorIndexSettings::EVectorType::Uint8);
+            UNIT_ASSERT_EQUAL(settings.Settings.VectorDimension, 2);
+            UNIT_ASSERT_EQUAL(settings.Levels, 2);
+            UNIT_ASSERT_EQUAL(settings.Clusters, 2);
+        }
+        // TODO(mbkkt) enable it when kqp part will be ready
+        // DoPositiveQueriesPrefixedVectorIndexOrderByCosine(session);
+    }
+
+    Y_UNIT_TEST(PrefixedVectorIndexOrderByCosineSimilarityNotNullableLevel2) {
+        NKikimrConfig::TFeatureFlags featureFlags;
+        featureFlags.SetEnableVectorIndex(true);
+        auto setting = NKikimrKqp::TKqpSetting();
+        auto serverSettings = TKikimrSettings()
+            .SetFeatureFlags(featureFlags)
+            .SetKqpSettings({setting});
+
+        TKikimrRunner kikimr(serverSettings);
+        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_DEBUG);
+
+        auto db = kikimr.GetTableClient();
+        auto session = DoCreateTableForPrefixedVectorIndex(db, false);
+        {
+            const TString createIndex(Q_(R"(
+                ALTER TABLE `/Root/TestTable`
+                    ADD INDEX index
+                    GLOBAL USING vector_kmeans_tree
+                    ON (user, emb)
+                    WITH (similarity=cosine, vector_type="uint8", vector_dimension=2, levels=2, clusters=2);
+            )"));
+
+            auto result = session.ExecuteSchemeQuery(createIndex)
+                          .ExtractValueSync();
+
+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());
+        }
+        {
+            auto result = session.DescribeTable("/Root/TestTable").ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);
+            const auto& indexes = result.GetTableDescription().GetIndexDescriptions();
+            UNIT_ASSERT_EQUAL(indexes.size(), 1);
+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexName(), "index");
+            std::vector<std::string> indexKeyColumns{"user", "emb"};
+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexColumns(), indexKeyColumns);
+            const auto& settings = std::get<TKMeansTreeSettings>(indexes[0].GetIndexSettings());
+            UNIT_ASSERT_EQUAL(settings.Settings.Metric, NYdb::NTable::TVectorIndexSettings::EMetric::CosineSimilarity);
+            UNIT_ASSERT_EQUAL(settings.Settings.VectorType, NYdb::NTable::TVectorIndexSettings::EVectorType::Uint8);
+            UNIT_ASSERT_EQUAL(settings.Settings.VectorDimension, 2);
+            UNIT_ASSERT_EQUAL(settings.Levels, 2);
+            UNIT_ASSERT_EQUAL(settings.Clusters, 2);
+        }
+        // TODO(mbkkt) enable it when kqp part will be ready
+        // DoPositiveQueriesPrefixedVectorIndexOrderByCosine(session);
+    }
+
+    Y_UNIT_TEST(PrefixedVectorIndexOrderByCosineDistanceNullableLevel2) {
+        NKikimrConfig::TFeatureFlags featureFlags;
+        featureFlags.SetEnableVectorIndex(true);
+        auto setting = NKikimrKqp::TKqpSetting();
+        auto serverSettings = TKikimrSettings()
+            .SetFeatureFlags(featureFlags)
+            .SetKqpSettings({setting});
+
+        TKikimrRunner kikimr(serverSettings);
+        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_DEBUG);
+
+        auto db = kikimr.GetTableClient();
+        auto session = DoCreateTableForPrefixedVectorIndex(db, true);
+        {
+            const TString createIndex(Q_(R"(
+                ALTER TABLE `/Root/TestTable`
+                    ADD INDEX index
+                    GLOBAL USING vector_kmeans_tree
+                    ON (user, emb)
+                    WITH (distance=cosine, vector_type="uint8", vector_dimension=2, levels=2, clusters=2);
+            )"));
+
+            auto result = session.ExecuteSchemeQuery(createIndex)
+                          .ExtractValueSync();
+
+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());
+        }
+        {
+            auto result = session.DescribeTable("/Root/TestTable").ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);
+            const auto& indexes = result.GetTableDescription().GetIndexDescriptions();
+            UNIT_ASSERT_EQUAL(indexes.size(), 1);
+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexName(), "index");
+            std::vector<std::string> indexKeyColumns{"user", "emb"};
+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexColumns(), indexKeyColumns);
+            const auto& settings = std::get<TKMeansTreeSettings>(indexes[0].GetIndexSettings());
+            UNIT_ASSERT_EQUAL(settings.Settings.Metric, NYdb::NTable::TVectorIndexSettings::EMetric::CosineDistance);
+            UNIT_ASSERT_EQUAL(settings.Settings.VectorType, NYdb::NTable::TVectorIndexSettings::EVectorType::Uint8);
+            UNIT_ASSERT_EQUAL(settings.Settings.VectorDimension, 2);
+            UNIT_ASSERT_EQUAL(settings.Levels, 2);
+            UNIT_ASSERT_EQUAL(settings.Clusters, 2);
+        }
+        // TODO(mbkkt) enable it when kqp part will be ready
+        // DoPositiveQueriesPrefixedVectorIndexOrderByCosine(session);
+    }
+
+    Y_UNIT_TEST(PrefixedVectorIndexOrderByCosineSimilarityNullableLevel2) {
+        NKikimrConfig::TFeatureFlags featureFlags;
+        featureFlags.SetEnableVectorIndex(true);
+        auto setting = NKikimrKqp::TKqpSetting();
+        auto serverSettings = TKikimrSettings()
+            .SetFeatureFlags(featureFlags)
+            .SetKqpSettings({setting});
+
+        TKikimrRunner kikimr(serverSettings);
+        kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_DEBUG);
+
+        auto db = kikimr.GetTableClient();
+        auto session = DoCreateTableForPrefixedVectorIndex(db, true);
+        {
+            const TString createIndex(Q_(R"(
+                ALTER TABLE `/Root/TestTable`
+                    ADD INDEX index
+                    GLOBAL USING vector_kmeans_tree
+                    ON (user, emb)
+                    WITH (similarity=cosine, vector_type="uint8", vector_dimension=2, levels=2, clusters=2);
+            )"));
+
+            auto result = session.ExecuteSchemeQuery(createIndex)
+                          .ExtractValueSync();
+
+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());
+        }
+        {
+            auto result = session.DescribeTable("/Root/TestTable").ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::SUCCESS);
+            const auto& indexes = result.GetTableDescription().GetIndexDescriptions();
+            UNIT_ASSERT_EQUAL(indexes.size(), 1);
+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexName(), "index");
+            std::vector<std::string> indexKeyColumns{"user", "emb"};
+            UNIT_ASSERT_EQUAL(indexes[0].GetIndexColumns(), indexKeyColumns);
+            const auto& settings = std::get<TKMeansTreeSettings>(indexes[0].GetIndexSettings());
+            UNIT_ASSERT_EQUAL(settings.Settings.Metric, NYdb::NTable::TVectorIndexSettings::EMetric::CosineSimilarity);
+            UNIT_ASSERT_EQUAL(settings.Settings.VectorType, NYdb::NTable::TVectorIndexSettings::EVectorType::Uint8);
+            UNIT_ASSERT_EQUAL(settings.Settings.VectorDimension, 2);
+            UNIT_ASSERT_EQUAL(settings.Levels, 2);
+            UNIT_ASSERT_EQUAL(settings.Clusters, 2);
+        }
+        // TODO(mbkkt) enable it when kqp part will be ready
+        // DoPositiveQueriesPrefixedVectorIndexOrderByCosine(session);
+    }
+
     Y_UNIT_TEST(ExplainCollectFullDiagnostics) {
         auto setting = NKikimrKqp::TKqpSetting();
         auto serverSettings = TKikimrSettings()
@@ -2873,10 +3473,13 @@ Y_UNIT_TEST_SUITE(KqpIndexes) {
         }
     }
 
-    Y_UNIT_TEST(SecondaryIndexReplace) {
+    Y_UNIT_TEST_TWIN(SecondaryIndexReplace, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         auto setting = NKikimrKqp::TKqpSetting();
         auto serverSettings = TKikimrSettings()
-            .SetKqpSettings({setting});
+            .SetKqpSettings({setting})
+            .SetAppConfig(app);
         TKikimrRunner kikimr(serverSettings);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
@@ -2994,10 +3597,13 @@ R"([[#;#;["Primary1"];[41u]];[["Secondary2"];[2u];["Primary2"];[42u]];[["Seconda
         }
     }
 
-    Y_UNIT_TEST(MultipleSecondaryIndex) {
+    Y_UNIT_TEST_TWIN(MultipleSecondaryIndex, UseSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         auto setting = NKikimrKqp::TKqpSetting();
         auto serverSettings = TKikimrSettings()
-            .SetKqpSettings({setting});
+            .SetKqpSettings({setting})
+            .SetAppConfig(appConfig);
         TKikimrRunner kikimr(serverSettings);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
@@ -3370,10 +3976,13 @@ R"([[#;#;["Primary1"];[41u]];[["Secondary2"];[2u];["Primary2"];[42u]];[["Seconda
     }
 
 
-    Y_UNIT_TEST(MultipleSecondaryIndexWithSameComulns) {
+    Y_UNIT_TEST_TWIN(MultipleSecondaryIndexWithSameComulns, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         auto setting = NKikimrKqp::TKqpSetting();
         auto serverSettings = TKikimrSettings()
-            .SetKqpSettings({setting});
+            .SetKqpSettings({setting})
+            .SetAppConfig(app);
         TKikimrRunner kikimr(serverSettings);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
@@ -3706,10 +4315,13 @@ R"([[#;#;["Primary1"];[41u]];[["Secondary2"];[2u];["Primary2"];[42u]];[["Seconda
         }
     }
 
-    Y_UNIT_TEST(SecondaryIndexWithPrimaryKeySameComulns) {
+    Y_UNIT_TEST_TWIN(SecondaryIndexWithPrimaryKeySameComulns, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         auto setting = NKikimrKqp::TKqpSetting();
         auto serverSettings = TKikimrSettings()
-            .SetKqpSettings({setting});
+            .SetKqpSettings({setting})
+            .SetAppConfig(app);
         TKikimrRunner kikimr(serverSettings);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
@@ -4550,10 +5162,13 @@ R"([[#;#;["Primary1"];[41u]];[["Secondary2"];[2u];["Primary2"];[42u]];[["Seconda
         }
     }
 
-    Y_UNIT_TEST(DuplicateUpsertInterleaveParams) {
+    Y_UNIT_TEST_TWIN(DuplicateUpsertInterleaveParams, UseSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         auto setting = NKikimrKqp::TKqpSetting();
         auto serverSettings = TKikimrSettings()
-            .SetKqpSettings({setting});
+            .SetKqpSettings({setting})
+            .SetAppConfig(appConfig);
         TKikimrRunner kikimr(serverSettings);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
@@ -5262,10 +5877,13 @@ R"([[#;#;["Primary1"];[41u]];[["Secondary2"];[2u];["Primary2"];[42u]];[["Seconda
         ])", FormatResultSetYson(result.GetResultSet(0)));
     }
 
-    Y_UNIT_TEST(UpdateDeletePlan) {
+    Y_UNIT_TEST_TWIN(UpdateDeletePlan, UseSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         auto setting = NKikimrKqp::TKqpSetting();
         auto serverSettings = TKikimrSettings()
-            .SetKqpSettings({setting});
+            .SetKqpSettings({setting})
+            .SetAppConfig(appConfig);
         TKikimrRunner kikimr(serverSettings);
 
         auto db = kikimr.GetTableClient();
diff --git a/ydb/core/kqp/ut/olap/aggregations_ut.cpp b/ydb/core/kqp/ut/olap/aggregations_ut.cpp
index 8026a2c5b123..b842b9932ade 100644
--- a/ydb/core/kqp/ut/olap/aggregations_ut.cpp
+++ b/ydb/core/kqp/ut/olap/aggregations_ut.cpp
@@ -145,11 +145,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
             CompareYson(result, R"([[23000u;]])");
 
             // Check plan
-#if SSA_RUNTIME_VERSION >= 2U
             CheckPlanForAggregatePushdown(query, tableClient, { "TKqpOlapAgg" }, "TableFullScan");
-#else
-            CheckPlanForAggregatePushdown(query, tableClient, { "CombineCore" }, "");
-#endif
         }
     }
 
@@ -189,12 +185,8 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
             CompareYson(result, R"([[[0];4600u];[[1];4600u];[[2];4600u];[[3];4600u];[[4];4600u]])");
 
             // Check plan
-#if SSA_RUNTIME_VERSION >= 2U
             CheckPlanForAggregatePushdown(query, tableClient, { "WideCombiner" }, "TableFullScan");
 //            CheckPlanForAggregatePushdown(query, tableClient, { "TKqpOlapAgg" }, "TableFullScan");
-#else
-            CheckPlanForAggregatePushdown(query, tableClient, { "CombineCore" }, "");
-#endif
         }
     }
 
@@ -318,11 +310,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
             CompareYson(result, R"([[23000u;]])");
 
             // Check plan
-#if SSA_RUNTIME_VERSION >= 2U
             CheckPlanForAggregatePushdown(query, tableClient, { "TKqpOlapAgg" }, "TableFullScan");
-#else
-            CheckPlanForAggregatePushdown(query, tableClient, { "Condense" }, "");
-#endif
         }
     }
 
@@ -361,11 +349,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
             CompareYson(result, R"([[23000u;]])");
 
             // Check plan
-#if SSA_RUNTIME_VERSION >= 2U
             CheckPlanForAggregatePushdown(query, tableClient, { "TKqpOlapAgg" }, "TableFullScan");
-#else
-            CheckPlanForAggregatePushdown(query, tableClient, { "Condense" }, "");
-#endif
         }
     }
 
@@ -441,12 +425,8 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 )")
             .SetExpectedReply("[[4600u;]]")
             .AddExpectedPlanOptions("KqpOlapFilter")
-#if SSA_RUNTIME_VERSION >= 2U
             .AddExpectedPlanOptions("TKqpOlapAgg")
             .MutableLimitChecker().SetExpectedResultCount(2)
-#else
-            .AddExpectedPlanOptions("Condense")
-#endif
             ;
 
         TestAggregations({ testCase });
@@ -462,13 +442,9 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
             )")
             .SetExpectedReply("[[4600u;]]")
             .AddExpectedPlanOptions("KqpOlapFilter")
-#if SSA_RUNTIME_VERSION >= 2U
             .AddExpectedPlanOptions("TKqpOlapAgg")
             // See https://github.com/ydb-platform/ydb/issues/7299 for explanation, why resultCount = 3
             .MutableLimitChecker().SetExpectedResultCount(3)
-#else
-            .AddExpectedPlanOptions("CombineCore")
-#endif
             ;
 
         TestAggregations({ testCase });
@@ -484,13 +460,8 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
             )")
             .SetExpectedReply("[[4600u;]]")
             .AddExpectedPlanOptions("KqpOlapFilter")
-#if SSA_RUNTIME_VERSION >= 2U
             .AddExpectedPlanOptions("TKqpOlapAgg")
             .MutableLimitChecker().SetExpectedResultCount(2)
-#else
-            .AddExpectedPlanOptions("CombineCore")
-            .AddExpectedPlanOptions("KqpOlapFilter")
-#endif
             ;
 
         TestAggregations({ testCase });
@@ -597,11 +568,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 WHERE id > 5;
             )")
             .SetExpectedReply("[[0u]]")
-#if SSA_RUNTIME_VERSION >= 2U
             .AddExpectedPlanOptions("TKqpOlapAgg");
-#else
-            .AddExpectedPlanOptions("CombineCore");
-#endif
 
         TestTableWithNulls({ testCase });
     }
@@ -614,11 +581,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 FROM `/Root/tableWithNulls`;
             )")
             .SetExpectedReply("[[5u]]")
-#if SSA_RUNTIME_VERSION >= 2U
             .AddExpectedPlanOptions("TKqpOlapAgg");
-#else
-            .AddExpectedPlanOptions("CombineCore");
-#endif
 
         TestTableWithNulls({ testCase });
     }
@@ -730,11 +693,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 WHERE level = 2
             )")
             .SetExpectedReply("[[4600u;]]")
-#if SSA_RUNTIME_VERSION >= 2U
             .AddExpectedPlanOptions("TKqpOlapAgg")
-#else
-            .AddExpectedPlanOptions("CombineCore")
-#endif
             .AddExpectedPlanOptions("KqpOlapFilter");
 
         TestAggregations({ testCase });
@@ -748,11 +707,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 FROM `/Root/olapStore/olapTable`
             )")
             .SetExpectedReply("[[[2.];[0]]]")
-#if SSA_RUNTIME_VERSION >= 2U
             .AddExpectedPlanOptions("TKqpOlapAgg");
-#else
-            .AddExpectedPlanOptions("CombineCore");
-#endif
 
         TestAggregations({ testCase });
     }
@@ -766,11 +721,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 WHERE id > 5;
             )")
             .SetExpectedReply("[[#]]")
-#if SSA_RUNTIME_VERSION >= 2U
             .AddExpectedPlanOptions("TKqpOlapAgg");
-#else
-            .AddExpectedPlanOptions("CombineCore");
-#endif
 
         TestTableWithNulls({ testCase });
     }
@@ -783,11 +734,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 FROM `/Root/tableWithNulls`;
             )")
             .SetExpectedReply("[[[3.]]]")
-#if SSA_RUNTIME_VERSION >= 2U
             .AddExpectedPlanOptions("TKqpOlapAgg");
-#else
-            .AddExpectedPlanOptions("CombineCore");
-#endif
 
         TestTableWithNulls({ testCase });
     }
@@ -880,11 +827,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 FROM `/Root/olapStore/olapTable`
             )")
             .SetExpectedReply("[[[46000;]]]")
-#if SSA_RUNTIME_VERSION >= 2U
             .AddExpectedPlanOptions("TKqpOlapAgg");
-#else
-            .AddExpectedPlanOptions("CombineCore");
-#endif
 
         TestAggregations({ testCase });
     }
@@ -898,11 +841,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 WHERE id > 5;
             )")
             .SetExpectedReply("[[#]]")
-#if SSA_RUNTIME_VERSION >= 2U
             .AddExpectedPlanOptions("TKqpOlapAgg");
-#else
-            .AddExpectedPlanOptions("CombineCore");
-#endif
 
         TestTableWithNulls({ testCase });
     }
@@ -916,11 +855,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 FROM `/Root/tableWithNulls`
             )")
             .SetExpectedReply("[[[15];10u;[3.]]]")
-#if SSA_RUNTIME_VERSION >= 2U
             .AddExpectedPlanOptions("TKqpOlapAgg");
-#else
-            .AddExpectedPlanOptions("CombineCore");
-#endif
 
         TestTableWithNulls({ testCase });
     }
@@ -933,11 +868,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 FROM `/Root/tableWithNulls`;
             )")
             .SetExpectedReply("[[[15]]]")
-#if SSA_RUNTIME_VERSION >= 2U
             .AddExpectedPlanOptions("TKqpOlapAgg");
-#else
-            .AddExpectedPlanOptions("CombineCore");
-#endif
 
         TestTableWithNulls({ testCase });
     }
@@ -1045,11 +976,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 FROM `/Root/olapStore/olapTable`
             )")
             .SetExpectedReply("[[[0]]]")
-#if SSA_RUNTIME_VERSION >= 2U
             .AddExpectedPlanOptions("TKqpOlapAgg");
-#else
-            .AddExpectedPlanOptions("CombineCore");
-#endif
 
         TestAggregations({ testCase });
     }
@@ -1062,11 +989,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 FROM `/Root/olapStore/olapTable`
             )")
             .SetExpectedReply("[[[4]]]")
-#if SSA_RUNTIME_VERSION >= 2U
             .AddExpectedPlanOptions("TKqpOlapAgg");
-#else
-            .AddExpectedPlanOptions("CombineCore");
-#endif
 
         TestAggregations({ testCase });
     }
@@ -1122,11 +1045,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 SELECT SOME(level) FROM `/Root/tableWithNulls` WHERE id=1
             )")
             .SetExpectedReply("[[[1]]]")
-#if SSA_RUNTIME_VERSION >= 2U
             .AddExpectedPlanOptions("TKqpOlapAgg");
-#else
-            .AddExpectedPlanOptions("CombineCore");
-#endif
         TestTableWithNulls({ testCase });
     }
 
@@ -1136,11 +1055,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 SELECT SOME(level) FROM `/Root/tableWithNulls` WHERE id > 5
             )")
             .SetExpectedReply("[[#]]")
-#if SSA_RUNTIME_VERSION >= 2U
             .AddExpectedPlanOptions("TKqpOlapAgg");
-#else
-            .AddExpectedPlanOptions("CombineCore");
-#endif
         TestTableWithNulls({ testCase });
     }
 
@@ -1274,31 +1189,19 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 SELECT id, JSON_VALUE(jsonval, "$.col1"), JSON_VALUE(jsondoc, "$.col1") FROM `/Root/tableWithNulls`
                 WHERE JSON_VALUE(jsonval, "$.col1") = "val1" AND id = 1;
             )")
-#if SSA_RUNTIME_VERSION >= 5U
-            .AddExpectedPlanOptions("KqpOlapApply")
-#elif SSA_RUNTIME_VERSION >= 3U
             .AddExpectedPlanOptions("KqpOlapJsonValue")
-#else
-            .AddExpectedPlanOptions("Udf")
-#endif
             .SetExpectedReply(R"([[1;["val1"];#]])");
-
         TestTableWithNulls({testCase});
     }
 
+
     Y_UNIT_TEST(Json_GetValue_Minus) {
         TAggregationTestCase testCase;
         testCase.SetQuery(R"(
                 SELECT id, JSON_VALUE(jsonval, "$.'col-abc'"), JSON_VALUE(jsondoc, "$.'col-abc'") FROM `/Root/tableWithNulls`
                 WHERE JSON_VALUE(jsonval, "$.'col-abc'") = "val-abc" AND id = 1;
             )")
-#if SSA_RUNTIME_VERSION >= 5U
-            .AddExpectedPlanOptions("KqpOlapApply")
-#elif SSA_RUNTIME_VERSION >= 3U
             .AddExpectedPlanOptions("KqpOlapJsonValue")
-#else
-            .AddExpectedPlanOptions("Udf")
-#endif
             .SetExpectedReply(R"([[1;["val-abc"];#]])");
 
         TestTableWithNulls({testCase});
@@ -1310,13 +1213,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 SELECT id, JSON_VALUE(jsonval, "$.col1" RETURNING String), JSON_VALUE(jsondoc, "$.col1") FROM `/Root/tableWithNulls`
                 WHERE JSON_VALUE(jsonval, "$.col1" RETURNING String) = "val1" AND id = 1;
             )")
-#if SSA_RUNTIME_VERSION >= 5U
-            .AddExpectedPlanOptions("KqpOlapApply")
-#elif SSA_RUNTIME_VERSION >= 3U
             .AddExpectedPlanOptions("KqpOlapJsonValue")
-#else
-            .AddExpectedPlanOptions("Udf")
-#endif
             .SetExpectedReply(R"([[1;["val1"];#]])");
 
         TestTableWithNulls({ testCase });
@@ -1328,13 +1225,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 SELECT id, JSON_VALUE(jsonval, "$.obj.obj_col2_int" RETURNING Int), JSON_VALUE(jsondoc, "$.obj.obj_col2_int" RETURNING Int) FROM `/Root/tableWithNulls`
                 WHERE JSON_VALUE(jsonval, "$.obj.obj_col2_int" RETURNING Int) = 16 AND id = 1;
             )")
-#if SSA_RUNTIME_VERSION >= 5U
-            .AddExpectedPlanOptions("KqpOlapApply")
-#elif SSA_RUNTIME_VERSION >= 3U
             .AddExpectedPlanOptions("KqpOlapJsonValue")
-#else
-            .AddExpectedPlanOptions("Udf")
-#endif
             .SetExpectedReply(R"([[1;[16];#]])");
 
         TestTableWithNulls({ testCase });
@@ -1346,13 +1237,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 SELECT id, JSON_VALUE(jsonval, "$.col1"), JSON_VALUE(jsondoc, "$.col1") FROM `/Root/tableWithNulls`
                 WHERE JSON_VALUE(jsondoc, "$.col1") = "val1" AND id = 6;
             )")
-#if SSA_RUNTIME_VERSION >= 5U
-            .AddExpectedPlanOptions("KqpOlapApply")
-#elif SSA_RUNTIME_VERSION >= 3U
             .AddExpectedPlanOptions("KqpOlapJsonValue")
-#else
-            .AddExpectedPlanOptions("Udf")
-#endif
             .SetExpectedReply(R"([[6;#;["val1"]]])");
 
         TestTableWithNulls({ testCase });
@@ -1364,13 +1249,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 SELECT id, JSON_VALUE(jsonval, "$.col1"), JSON_VALUE(jsondoc, "$.col1" RETURNING String) FROM `/Root/tableWithNulls`
                 WHERE JSON_VALUE(jsondoc, "$.col1" RETURNING String) = "val1" AND id = 6;
             )")
-#if SSA_RUNTIME_VERSION >= 5U
-            .AddExpectedPlanOptions("KqpOlapApply")
-#elif SSA_RUNTIME_VERSION >= 3U
             .AddExpectedPlanOptions("KqpOlapJsonValue")
-#else
-            .AddExpectedPlanOptions("Udf")
-#endif
             .SetExpectedReply(R"([[6;#;["val1"]]])");
 
         TestTableWithNulls({ testCase });
@@ -1382,13 +1261,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 SELECT id, JSON_VALUE(jsonval, "$.obj.obj_col2_int"), JSON_VALUE(jsondoc, "$.obj.obj_col2_int" RETURNING Int) FROM `/Root/tableWithNulls`
                 WHERE JSON_VALUE(jsondoc, "$.obj.obj_col2_int" RETURNING Int) = 16 AND id = 6;
             )")
-#if SSA_RUNTIME_VERSION >= 5U
-            .AddExpectedPlanOptions("KqpOlapApply")
-#elif SSA_RUNTIME_VERSION >= 3U
             .AddExpectedPlanOptions("KqpOlapJsonValue")
-#else
-            .AddExpectedPlanOptions("Udf")
-#endif
             .SetExpectedReply(R"([[6;#;[16]]])");
 
         TestTableWithNulls({ testCase });
@@ -1401,13 +1274,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 WHERE
                     JSON_EXISTS(jsonval, "$.col1") AND level = 1;
             )")
-#if SSA_RUNTIME_VERSION >= 5U
-            .AddExpectedPlanOptions("KqpOlapApply")
-#elif SSA_RUNTIME_VERSION >= 3U
             .AddExpectedPlanOptions("KqpOlapJsonExists")
-#else
-            .AddExpectedPlanOptions("Udf")
-#endif
             .SetExpectedReply(R"([[1;[%true];#]])");
 
         TestTableWithNulls({ testCase });
@@ -1420,13 +1287,7 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
                 WHERE
                     JSON_EXISTS(jsondoc, "$.col1") AND id = 6;
             )")
-#if SSA_RUNTIME_VERSION >= 5U
-            .AddExpectedPlanOptions("KqpOlapApply")
-#elif SSA_RUNTIME_VERSION >= 3U
             .AddExpectedPlanOptions("KqpOlapJsonExists")
-#else
-            .AddExpectedPlanOptions("Udf")
-#endif
             .SetExpectedReply(R"([[6;#;[%true]]])");
 
         TestTableWithNulls({ testCase });
@@ -1447,6 +1308,26 @@ Y_UNIT_TEST_SUITE(KqpOlapAggregations) {
         TestTableWithNulls({ testCase });
     }
 
+    Y_UNIT_TEST(MixedJsonAndOlapApply) {
+        TAggregationTestCase testCase;
+        //(R"({"col1": "val1", "col-abc": "val-abc", "obj": {"obj_col2_int": 16}})"
+        testCase.SetQuery(R"(
+                SELECT id, JSON_VALUE(jsonval, "$.\"col-abc\"") FROM `/Root/tableWithNulls`
+                WHERE id = 1
+                    AND  JSON_VALUE(jsonval, "$.col1") = "val1"
+                    AND  JSON_VALUE(jsonval, "$.\"col-abc\"") ilike "%A%b%"
+                    AND JSON_EXISTS(jsonval, "$.obj.obj_col2_int")
+
+            )")
+            .AddExpectedPlanOptions("KqpOlapJsonValue")
+            .AddExpectedPlanOptions("KqpOlapJsonExists")
+            .AddExpectedPlanOptions("KqpOlapApply")
+            .SetExpectedReply(R"([[1;["val-abc"]]])")
+        ;
+
+        TestTableWithNulls({testCase});
+    }
+
     Y_UNIT_TEST(BlockGenericWithDistinct) {
         TAggregationTestCase testCase;
         testCase.SetQuery(R"(
diff --git a/ydb/core/kqp/ut/olap/blobs_sharing_ut.cpp b/ydb/core/kqp/ut/olap/blobs_sharing_ut.cpp
index 974115f9b6ca..cb222d0a3483 100644
--- a/ydb/core/kqp/ut/olap/blobs_sharing_ut.cpp
+++ b/ydb/core/kqp/ut/olap/blobs_sharing_ut.cpp
@@ -203,68 +203,69 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {
             Controller->SetOverrideMaxReadStaleness(TDuration::Minutes(5));
         }
     };
-    Y_UNIT_TEST(BlobsSharingSplit1_1) {
-        TSharingDataTestCase tester(4);
-        tester.AddRecords(800000);
-        Sleep(TDuration::Seconds(1));
-        tester.Execute(0, { 1 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
-    }
-
-    Y_UNIT_TEST(BlobsSharingSplit1_1_clean) {
-        TSharingDataTestCase tester(2);
-        tester.AddRecords(80000);
-        CompareYson(tester.GetHelper().GetQueryResult("SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`"), R"([[80000u;]])");
-        Sleep(TDuration::Seconds(1));
-        tester.Execute(0, { 1 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
-        CompareYson(tester.GetHelper().GetQueryResult("SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`"), R"([[119928u;]])");
-        tester.AddRecords(80000, 0.8);
-        tester.WaitNormalization();
-        CompareYson(tester.GetHelper().GetQueryResult("SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`"), R"([[183928u;]])");
-    }
-
-    Y_UNIT_TEST(BlobsSharingSplit1_1_clean_with_restarts) {
-        TSharingDataTestCase tester(2);
-        tester.SetRebootTablet(true);
-        tester.AddRecords(80000);
-        CompareYson(tester.GetHelper().GetQueryResult("SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`"), R"([[80000u;]])");
-        Sleep(TDuration::Seconds(1));
-        tester.Execute(0, { 1 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
-        CompareYson(tester.GetHelper().GetQueryResult("SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`"), R"([[119928u;]])");
-        tester.AddRecords(80000, 0.8);
-        tester.WaitNormalization();
-        CompareYson(tester.GetHelper().GetQueryResult("SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`"), R"([[183928u;]])");
-    }
-
-    Y_UNIT_TEST(BlobsSharingSplit3_1) {
-        TSharingDataTestCase tester(4);
-        tester.AddRecords(800000);
-        Sleep(TDuration::Seconds(1));
-        tester.Execute(0, { 1, 2, 3 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
-    }
-
-    Y_UNIT_TEST(BlobsSharingSplit1_3_1) {
-        TSharingDataTestCase tester(4);
-        tester.AddRecords(800000);
-        Sleep(TDuration::Seconds(1));
-        tester.Execute(1, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
-        tester.Execute(2, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
-        tester.Execute(3, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
-        tester.Execute(0, { 1, 2, 3 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
-    }
 
-    Y_UNIT_TEST(BlobsSharingSplit1_3_2_1_clean) {
-        TSharingDataTestCase tester(4);
-        tester.AddRecords(800000);
-        Sleep(TDuration::Seconds(1));
-        tester.Execute(1, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
-        tester.Execute(2, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
-        tester.Execute(3, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
-        tester.AddRecords(800000, 0.9);
-        Sleep(TDuration::Seconds(1));
-        tester.Execute(3, { 2 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
-        tester.Execute(0, { 1, 2 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
-        tester.WaitNormalization();
-    }
+    // Y_UNIT_TEST(BlobsSharingSplit1_1) {
+    //     TSharingDataTestCase tester(4);
+    //     tester.AddRecords(800000);
+    //     Sleep(TDuration::Seconds(1));
+    //     tester.Execute(0, { 1 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
+    // }
+
+    // Y_UNIT_TEST(BlobsSharingSplit1_1_clean) {
+    //     TSharingDataTestCase tester(2);
+    //     tester.AddRecords(80000);
+    //     CompareYson(tester.GetHelper().GetQueryResult("SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`"), R"([[80000u;]])");
+    //     Sleep(TDuration::Seconds(1));
+    //     tester.Execute(0, { 1 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
+    //     CompareYson(tester.GetHelper().GetQueryResult("SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`"), R"([[119928u;]])");
+    //     tester.AddRecords(80000, 0.8);
+    //     tester.WaitNormalization();
+    //     CompareYson(tester.GetHelper().GetQueryResult("SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`"), R"([[183928u;]])");
+    // }
+
+    // Y_UNIT_TEST(BlobsSharingSplit1_1_clean_with_restarts) {
+    //     TSharingDataTestCase tester(2);
+    //     tester.SetRebootTablet(true);
+    //     tester.AddRecords(80000);
+    //     CompareYson(tester.GetHelper().GetQueryResult("SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`"), R"([[80000u;]])");
+    //     Sleep(TDuration::Seconds(1));
+    //     tester.Execute(0, { 1 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
+    //     CompareYson(tester.GetHelper().GetQueryResult("SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`"), R"([[119928u;]])");
+    //     tester.AddRecords(80000, 0.8);
+    //     tester.WaitNormalization();
+    //     CompareYson(tester.GetHelper().GetQueryResult("SELECT COUNT(*) FROM `/Root/olapStore12/olapTable`"), R"([[183928u;]])");
+    // }
+
+    // Y_UNIT_TEST(BlobsSharingSplit3_1) {
+    //     TSharingDataTestCase tester(4);
+    //     tester.AddRecords(800000);
+    //     Sleep(TDuration::Seconds(1));
+    //     tester.Execute(0, { 1, 2, 3 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
+    // }
+
+    // Y_UNIT_TEST(BlobsSharingSplit1_3_1) {
+    //     TSharingDataTestCase tester(4);
+    //     tester.AddRecords(800000);
+    //     Sleep(TDuration::Seconds(1));
+    //     tester.Execute(1, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
+    //     tester.Execute(2, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
+    //     tester.Execute(3, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
+    //     tester.Execute(0, { 1, 2, 3 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
+    // }
+
+    // Y_UNIT_TEST(BlobsSharingSplit1_3_2_1_clean) {
+    //     TSharingDataTestCase tester(4);
+    //     tester.AddRecords(800000);
+    //     Sleep(TDuration::Seconds(1));
+    //     tester.Execute(1, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
+    //     tester.Execute(2, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
+    //     tester.Execute(3, { 0 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
+    //     tester.AddRecords(800000, 0.9);
+    //     Sleep(TDuration::Seconds(1));
+    //     tester.Execute(3, { 2 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
+    //     tester.Execute(0, { 1, 2 }, false, NOlap::TSnapshot(TInstant::Now().MilliSeconds(), 1232123), { 0 });
+    //     tester.WaitNormalization();
+    // }
 
     class TReshardingTest {
     public:
@@ -398,13 +399,13 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {
         }
     };
 
-    Y_UNIT_TEST(TableReshardingConsistency64) {
-        TShardingTypeTest().SetShardingType("HASH_FUNCTION_CONSISTENCY_64").Execute();
-    }
+    // Y_UNIT_TEST(TableReshardingConsistency64) {
+    //     TShardingTypeTest().SetShardingType("HASH_FUNCTION_CONSISTENCY_64").Execute();
+    // }
 
-    Y_UNIT_TEST(TableReshardingModuloN) {
-        TShardingTypeTest().SetShardingType("HASH_FUNCTION_MODULO_N").Execute();
-    }
+    // Y_UNIT_TEST(TableReshardingModuloN) {
+    //     TShardingTypeTest().SetShardingType("HASH_FUNCTION_MODULO_N").Execute();
+    // }
 
     class TAsyncReshardingTest: public TReshardingTest {
         YDB_ACCESSOR(TString, ShardingType, "HASH_FUNCTION_CONSISTENCY_64");
@@ -482,24 +483,24 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {
         ui64 HasNewCol = false;
     };
 
-    Y_UNIT_TEST(UpsertWhileSplitTest) {
-        TAsyncReshardingTest tester;
+    // Y_UNIT_TEST(UpsertWhileSplitTest) {
+    //     TAsyncReshardingTest tester;
 
-        tester.AddBatch(10000);
+    //     tester.AddBatch(10000);
 
-        tester.CheckCount();
+    //     tester.CheckCount();
 
-        for (int i = 0; i < 4; i++) {
-            tester.StartResharding("SPLIT");
+    //     for (int i = 0; i < 4; i++) {
+    //         tester.StartResharding("SPLIT");
 
-            tester.CheckCount();
-            tester.AddBatch(10000);
-            tester.CheckCount();
-            tester.WaitResharding();
-        }
-        tester.AddBatch(10000);
-        tester.CheckCount();
-    }
+    //         tester.CheckCount();
+    //         tester.AddBatch(10000);
+    //         tester.CheckCount();
+    //         tester.WaitResharding();
+    //     }
+    //     tester.AddBatch(10000);
+    //     tester.CheckCount();
+    // }
 
     Y_UNIT_TEST(SplitEmpty) {
         TAsyncReshardingTest tester;
@@ -513,171 +514,171 @@ Y_UNIT_TEST_SUITE(KqpOlapBlobsSharing) {
         tester.CheckCount();
     }
 
-    Y_UNIT_TEST(ChangeSchemaAndSplit) {
-        TAsyncReshardingTest tester;
-        tester.DisableCompaction();
+    // Y_UNIT_TEST(ChangeSchemaAndSplit) {
+    //     TAsyncReshardingTest tester;
+    //     tester.DisableCompaction();
 
-        tester.AddBatch(10000);
-        tester.ChangeSchema();
-        tester.AddBatch(10000);
+    //     tester.AddBatch(10000);
+    //     tester.ChangeSchema();
+    //     tester.AddBatch(10000);
 
-        tester.StartResharding("SPLIT");
-        tester.WaitResharding();
+    //     tester.StartResharding("SPLIT");
+    //     tester.WaitResharding();
 
-        tester.RestartAllShards();
+    //     tester.RestartAllShards();
 
-        tester.CheckCount();
-    }
+    //     tester.CheckCount();
+    // }
 
-    Y_UNIT_TEST(MultipleSchemaVersions) {
-        TAsyncReshardingTest tester;
-        tester.DisableCompaction();
+    // Y_UNIT_TEST(MultipleSchemaVersions) {
+    //     TAsyncReshardingTest tester;
+    //     tester.DisableCompaction();
 
-        for (int i = 0; i < 3; i++) {
-            tester.AddBatch(1);
-            tester.ChangeSchema();
-        }
+    //     for (int i = 0; i < 3; i++) {
+    //         tester.AddBatch(1);
+    //         tester.ChangeSchema();
+    //     }
 
-        tester.StartResharding("SPLIT");
-        tester.WaitResharding();
+    //     tester.StartResharding("SPLIT");
+    //     tester.WaitResharding();
 
-        tester.RestartAllShards();
+    //     tester.RestartAllShards();
 
-        tester.CheckCount();
-    }
+    //     tester.CheckCount();
+    // }
 
-    Y_UNIT_TEST(HugeSchemeHistory) {
-        TAsyncReshardingTest tester;
-        tester.DisableCompaction();
+    // Y_UNIT_TEST(HugeSchemeHistory) {
+    //     TAsyncReshardingTest tester;
+    //     tester.DisableCompaction();
 
-        tester.AddManyColumns();
+    //     tester.AddManyColumns();
 
-        for (int i = 0; i < 100; i++) {
-            tester.AddBatch(1);
-            tester.ChangeSchema();
-        }
+    //     for (int i = 0; i < 100; i++) {
+    //         tester.AddBatch(1);
+    //         tester.ChangeSchema();
+    //     }
 
-        tester.StartResharding("SPLIT");
-        tester.WaitResharding();
+    //     tester.StartResharding("SPLIT");
+    //     tester.WaitResharding();
 
-        tester.RestartAllShards();
+    //     tester.RestartAllShards();
 
-        tester.CheckCount();
-    }
+    //     tester.CheckCount();
+    // }
 
-    Y_UNIT_TEST(MultipleMerge) {
-        TAsyncReshardingTest tester;
-        tester.DisableCompaction();
+    // Y_UNIT_TEST(MultipleMerge) {
+    //     TAsyncReshardingTest tester;
+    //     tester.DisableCompaction();
 
-        tester.AddBatch(10000);
+    //     tester.AddBatch(10000);
 
-        for (int i = 0; i < 4; i++) {
-            tester.StartResharding("MERGE");
-            tester.WaitResharding();
-        }
+    //     for (int i = 0; i < 4; i++) {
+    //         tester.StartResharding("MERGE");
+    //         tester.WaitResharding();
+    //     }
 
-        tester.RestartAllShards();
+    //     tester.RestartAllShards();
 
-        tester.CheckCount();
-    }
+    //     tester.CheckCount();
+    // }
 
-    Y_UNIT_TEST(MultipleSplits) {
-        TAsyncReshardingTest tester;
-        tester.DisableCompaction();
+    // Y_UNIT_TEST(MultipleSplits) {
+    //     TAsyncReshardingTest tester;
+    //     tester.DisableCompaction();
 
-        tester.AddBatch(10000);
+    //     tester.AddBatch(10000);
 
-        for (int i = 0; i < 4; i++) {
-            tester.StartResharding("SPLIT");
-            tester.WaitResharding();
-        }
+    //     for (int i = 0; i < 4; i++) {
+    //         tester.StartResharding("SPLIT");
+    //         tester.WaitResharding();
+    //     }
 
-        tester.RestartAllShards();
+    //     tester.RestartAllShards();
 
-        tester.CheckCount();
-    }
+    //     tester.CheckCount();
+    // }
 
-    Y_UNIT_TEST(MultipleSplitsThenMerges) {
-        TAsyncReshardingTest tester;
-        tester.DisableCompaction();
+    // Y_UNIT_TEST(MultipleSplitsThenMerges) {
+    //     TAsyncReshardingTest tester;
+    //     tester.DisableCompaction();
 
-        tester.AddBatch(10000);
+    //     tester.AddBatch(10000);
 
-        for (int i = 0; i < 4; i++) {
-            tester.StartResharding("SPLIT");
-            tester.WaitResharding();
-        }
+    //     for (int i = 0; i < 4; i++) {
+    //         tester.StartResharding("SPLIT");
+    //         tester.WaitResharding();
+    //     }
 
-        for (int i = 0; i < 8; i++) {
-            tester.StartResharding("MERGE");
-            tester.WaitResharding();
-        }
+    //     for (int i = 0; i < 8; i++) {
+    //         tester.StartResharding("MERGE");
+    //         tester.WaitResharding();
+    //     }
 
-        tester.RestartAllShards();
+    //     tester.RestartAllShards();
 
-        tester.CheckCount();
-    }
+    //     tester.CheckCount();
+    // }
 
-    Y_UNIT_TEST(MultipleSplitsWithRestartsAfterWait) {
-        TAsyncReshardingTest tester;
-        tester.DisableCompaction();
+    // Y_UNIT_TEST(MultipleSplitsWithRestartsAfterWait) {
+    //     TAsyncReshardingTest tester;
+    //     tester.DisableCompaction();
 
-        tester.AddBatch(10000);
+    //     tester.AddBatch(10000);
 
-        for (int i = 0; i < 4; i++) {
-            tester.StartResharding("SPLIT");
-            tester.WaitResharding();
-            tester.RestartAllShards();
-        }
+    //     for (int i = 0; i < 4; i++) {
+    //         tester.StartResharding("SPLIT");
+    //         tester.WaitResharding();
+    //         tester.RestartAllShards();
+    //     }
 
-        tester.CheckCount();
-    }
+    //     tester.CheckCount();
+    // }
 
-    Y_UNIT_TEST(MultipleSplitsWithRestartsWhenWait) {
-        TAsyncReshardingTest tester;
-        tester.DisableCompaction();
+    // Y_UNIT_TEST(MultipleSplitsWithRestartsWhenWait) {
+    //     TAsyncReshardingTest tester;
+    //     tester.DisableCompaction();
 
-        tester.AddBatch(10000);
+    //     tester.AddBatch(10000);
 
-        for (int i = 0; i < 4; i++) {
-            tester.StartResharding("SPLIT");
-            tester.RestartAllShards();
-            tester.WaitResharding();
-        }
-        tester.RestartAllShards();
+    //     for (int i = 0; i < 4; i++) {
+    //         tester.StartResharding("SPLIT");
+    //         tester.RestartAllShards();
+    //         tester.WaitResharding();
+    //     }
+    //     tester.RestartAllShards();
 
-        tester.CheckCount();
-    }
+    //     tester.CheckCount();
+    // }
 
-    Y_UNIT_TEST(MultipleMergesWithRestartsAfterWait) {
-        TAsyncReshardingTest tester;
-        tester.DisableCompaction();
+    // Y_UNIT_TEST(MultipleMergesWithRestartsAfterWait) {
+    //     TAsyncReshardingTest tester;
+    //     tester.DisableCompaction();
 
-        tester.AddBatch(10000);
+    //     tester.AddBatch(10000);
 
-        for (int i = 0; i < 4; i++) {
-            tester.StartResharding("MERGE");
-            tester.WaitResharding();
-            tester.RestartAllShards();
-        }
+    //     for (int i = 0; i < 4; i++) {
+    //         tester.StartResharding("MERGE");
+    //         tester.WaitResharding();
+    //         tester.RestartAllShards();
+    //     }
 
-        tester.CheckCount();
-    }
+    //     tester.CheckCount();
+    // }
 
-    Y_UNIT_TEST(MultipleMergesWithRestartsWhenWait) {
-        TAsyncReshardingTest tester;
-        tester.DisableCompaction();
+    // Y_UNIT_TEST(MultipleMergesWithRestartsWhenWait) {
+    //     TAsyncReshardingTest tester;
+    //     tester.DisableCompaction();
 
-        tester.AddBatch(10000);
+    //     tester.AddBatch(10000);
 
-        for (int i = 0; i < 4; i++) {
-            tester.StartResharding("MERGE");
-            tester.RestartAllShards();
-            tester.WaitResharding();
-        }
-        tester.RestartAllShards();
+    //     for (int i = 0; i < 4; i++) {
+    //         tester.StartResharding("MERGE");
+    //         tester.RestartAllShards();
+    //         tester.WaitResharding();
+    //     }
+    //     tester.RestartAllShards();
 
-        tester.CheckCount();
-    }
+    //     tester.CheckCount();
+    // }
 }
 }
diff --git a/ydb/core/kqp/ut/olap/helpers/get_value.cpp b/ydb/core/kqp/ut/olap/helpers/get_value.cpp
index 617e78da59aa..5e39202426ef 100644
--- a/ydb/core/kqp/ut/olap/helpers/get_value.cpp
+++ b/ydb/core/kqp/ut/olap/helpers/get_value.cpp
@@ -61,9 +61,24 @@ void PrintValue(IOutputStream& out, const NYdb::TValue& v) {
             out << value.GetBool();
             break;
         }
+        case NYdb::EPrimitiveType::String:
+        {
+            out << value.GetString();
+            break;
+        }
+        case NYdb::EPrimitiveType::Json:
+        {
+            out << value.GetJson();
+            break;
+        }
+        case NYdb::EPrimitiveType::JsonDocument:
+        {
+            out << value.GetJsonDocument();
+            break;
+        }
         default:
         {
-            UNIT_ASSERT_C(false, "PrintValue not iplemented for this type");
+            UNIT_ASSERT_C(false, TStringBuilder() << "PrintValue not iplemented for this type: " << (ui64)value.GetPrimitiveType());
         }
     }
 }
diff --git a/ydb/core/kqp/ut/olap/indexes_ut.cpp b/ydb/core/kqp/ut/olap/indexes_ut.cpp
index 95156c78a59c..0cca7681e135 100644
--- a/ydb/core/kqp/ut/olap/indexes_ut.cpp
+++ b/ydb/core/kqp/ut/olap/indexes_ut.cpp
@@ -14,6 +14,43 @@
 namespace NKikimr::NKqp {
 
 Y_UNIT_TEST_SUITE(KqpOlapIndexes) {
+    Y_UNIT_TEST(TablesInStore) {
+        auto settings = TKikimrSettings().SetWithSampleTables(false);
+        TKikimrRunner kikimr(settings);
+
+        TLocalHelper(kikimr).CreateTestOlapTable();
+
+        auto tableClient = kikimr.GetTableClient();
+        {
+            auto alterQuery =
+                R"(ALTER OBJECT `/Root/olapStore` (TYPE TABLESTORE) SET (ACTION=UPSERT_INDEX, NAME=index_ngramm_uid, TYPE=BLOOM_NGRAMM_FILTER,
+                    FEATURES=`{"column_name" : "resource_id", "ngramm_size" : 3, "hashes_count" : 2, "filter_size_bytes" : 512, "records_count" : 1024}`);
+                )";
+            auto session = tableClient.CreateSession().GetValueSync().GetSession();
+            auto alterResult = session.ExecuteSchemeQuery(alterQuery).GetValueSync();
+            UNIT_ASSERT_VALUES_EQUAL_C(alterResult.GetStatus(), NYdb::EStatus::SUCCESS, alterResult.GetIssues().ToString());
+        }
+        {
+            auto session = tableClient.CreateSession().GetValueSync().GetSession();
+
+            auto query = TStringBuilder() << R"(
+            --!syntax_v1
+            CREATE TABLE `/Root/olapStore/olapTableTest`
+            (
+                timestamp Timestamp NOT NULL,
+                resource_id Utf8,
+                uid Utf8 NOT NULL,
+                level Int32,
+                message Utf8,
+                PRIMARY KEY (timestamp, uid)
+            )
+            PARTITION BY HASH(timestamp, uid)
+            WITH (STORE = COLUMN, PARTITION_COUNT = 1))";
+            auto result = session.ExecuteSchemeQuery(query).GetValueSync();
+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), NYdb::EStatus::SUCCESS, result.GetIssues().ToString());
+        }
+    }
+
     Y_UNIT_TEST(IndexesActualization) {
         auto settings = TKikimrSettings().SetWithSampleTables(false);
         TKikimrRunner kikimr(settings);
diff --git a/ydb/core/kqp/ut/olap/json_ut.cpp b/ydb/core/kqp/ut/olap/json_ut.cpp
index 4a6822f05523..d3fdb06e4e89 100644
--- a/ydb/core/kqp/ut/olap/json_ut.cpp
+++ b/ydb/core/kqp/ut/olap/json_ut.cpp
@@ -5,14 +5,19 @@
 #include "helpers/writer.h"
 
 #include <ydb/core/base/tablet_pipecache.h>
+#include <ydb/core/formats/arrow/serializer/native.h>
 #include <ydb/core/kqp/ut/common/columnshard.h>
-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>
 #include <ydb/core/tx/columnshard/engines/reader/common_reader/iterator/source.h>
 #include <ydb/core/tx/columnshard/hooks/testing/controller.h>
+#include <ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h>
 #include <ydb/core/tx/columnshard/test_helper/controllers.h>
 #include <ydb/core/tx/limiter/grouped_memory/service/process.h>
 #include <ydb/core/wrappers/fake_storage.h>
 
+#include <ydb/library/signals/object_counter.h>
+#include <ydb/public/lib/scheme_types/scheme_type_id.h>
+
+#include <library/cpp/string_utils/base64/base64.h>
 #include <library/cpp/testing/unittest/registar.h>
 #include <util/string/strip.h>
 
@@ -106,15 +111,15 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
             Cerr << "HEADER:" << hNoData << "/" << hSkip << "/" << hApproves << Endl;
             if (ExpectIndexSkip) {
                 AFL_VERIFY(iSkip + hSkip == *ExpectIndexSkip)("expect", ExpectIndexSkip)("ireal", iSkip)("hreal", hSkip)(
-                                     "current", controller->GetIndexesSkippingOnSelect().Val())("pred", indexSkipStart);
+                                            "current", controller->GetIndexesSkippingOnSelect().Val())("pred", indexSkipStart);
             }
             if (ExpectIndexNoData) {
                 AFL_VERIFY(iNoData == *ExpectIndexNoData)("expect", ExpectIndexNoData)("real", iNoData)(
-                                       "current", controller->GetIndexesSkippedNoData().Val())("pred", indexNoDataStart);
+                                        "current", controller->GetIndexesSkippedNoData().Val())("pred", indexNoDataStart);
             }
             if (ExpectIndexApprove) {
                 AFL_VERIFY(iApproves == *ExpectIndexApprove)("expect", ExpectIndexApprove)("real", iApproves)(
-                                         "current", controller->GetIndexesApprovedOnSelect().Val())("pred", indexApproveStart);
+                                          "current", controller->GetIndexesApprovedOnSelect().Val())("pred", indexApproveStart);
             }
             return TConclusionStatus::Success();
         }
@@ -243,6 +248,47 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
         }
     };
 
+    class TBulkUpsertCommand: public ICommand {
+    private:
+        TString TableName;
+        TString ArrowBatch;
+        Ydb::StatusIds_StatusCode ExpectedCode = Ydb::StatusIds::SUCCESS;
+
+    public:
+        TBulkUpsertCommand() = default;
+
+        virtual TConclusionStatus DoExecute(TKikimrRunner& kikimr) override {
+            TLocalHelper lHelper(kikimr);
+            lHelper.SendDataViaActorSystem(TableName,
+                NArrow::TStatusValidator::GetValid(NArrow::NSerialization::TNativeSerializer().Deserialize(ArrowBatch)), ExpectedCode);
+            return TConclusionStatus::Success();
+        }
+
+        bool DeserializeFromString(const TString& info) {
+            auto lines = StringSplitter(info).SplitBySet("
").SkipEmpty().ToList<TString>();
+            if (lines.size() < 2 || lines.size() > 3) {
+                return false;
+            }
+            TableName = Strip(lines[0]);
+            ArrowBatch = Base64Decode(Strip(lines[1]));
+            AFL_VERIFY(!!ArrowBatch);
+            if (lines.size() == 3) {
+                if (!Ydb::StatusIds_StatusCode_Parse(Strip(lines[2]), &ExpectedCode)) {
+                    return false;
+                }
+                //                if (lines[2] == "SUCCESS") {
+                //                } else if (lines[2] = "INTERNAL_ERROR") {
+                //                    ExpectedCode = Ydb::StatusIds::INTERNAL_ERROR;
+                //                } else if (lines[2] == "BAD_REQUEST") {
+                //                    ExpectedCode = Ydb::StatusIds::BAD_REQUEST;
+                //                } else {
+                //                    return false;
+                //                }
+            }
+            return true;
+        }
+    };
+
     class TScriptExecutor {
     private:
         std::vector<std::shared_ptr<ICommand>> Commands;
@@ -275,7 +321,12 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
     private:
         std::vector<TScriptExecutor> Scripts;
         std::shared_ptr<ICommand> BuildCommand(TString command) {
-            if (command.StartsWith("SCHEMA:")) {
+            if (command.StartsWith("BULK_UPSERT:")) {
+                command = command.substr(12);
+                auto result = std::make_shared<TBulkUpsertCommand>();
+                AFL_VERIFY(result->DeserializeFromString(command));
+                return result;
+            } else if (command.StartsWith("SCHEMA:")) {
                 command = command.substr(7);
                 return std::make_shared<TSchemaCommand>(command);
             } else if (command.StartsWith("DATA:")) {
@@ -341,7 +392,13 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
 
     public:
         TScriptVariator(const TString& script) {
-            auto commands = StringSplitter(script).SplitByString("------").ToList<TString>();
+            auto lines = StringSplitter(script).SplitByString("
").ToList<TString>();
+            lines.erase(std::remove_if(lines.begin(), lines.end(),
+                            [](const TString& l) {
+                                return Strip(l).StartsWith("#");
+                            }),
+                lines.end());
+            auto commands = StringSplitter(JoinSeq("
", lines)).SplitByString("------").ToList<TString>();
             std::vector<std::vector<std::shared_ptr<ICommand>>> commandsDescription;
             for (auto&& i : commands) {
                 auto& cVariants = commandsDescription.emplace_back();
@@ -380,8 +437,8 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)
             ------
             SCHEMA:
-            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, 
-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`,
+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
             ------
             DATA:
             REPLACE INTO `/Root/ColumnTable` (Col1) VALUES (1u), (2u), (3u), (4u)
@@ -413,7 +470,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)
             ------
             SCHEMA:
-            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5|1$$`)
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `FORCE_SIMD_PARSING`=`$$true|false$$`, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5|1$$`)
             ------
             DATA:
             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES (1u, JsonDocument('{"a" : "", "b" : "", "c" : ""}'))
@@ -441,7 +498,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
             ------
             SCHEMA:
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, 
-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
             ------
             DATA:
             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{"a.b.c" : "a1", "b.c.d" : "b1", "c.d.e" : "c1"}')), (2u, JsonDocument('{"a.b.c" : "a2"}')),
@@ -469,18 +526,147 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)
             ------
             SCHEMA:
-            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, 
-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_EXTRACTOR_CLASS_NAME`=`JSON_SCANNER`, `SCAN_FIRST_LEVEL_ONLY`=`false`, 
+                      `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`,
+                      `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
             ------
             DATA:
-            REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{"a" : "a1", "b" : "b1", "c" : "c1"}')), (2u, JsonDocument('{"a" : "a2"}')),
+            REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{"a" : "a1", "b" : "b1", "c" : "c1", "d" : null, "e.v" : {"c" : 1, "e" : {"c.a" : 2}}}')), (2u, JsonDocument('{"a" : "a2"}')),
                                                                     (3u, JsonDocument('{"b" : "b3", "d" : "d3"}')), (4u, JsonDocument('{"b" : "b4asdsasdaa", "a" : "a4"}'))
             ------
             READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.a") = "a2" ORDER BY Col1;
             EXPECTED: [[2u;["{\"a\":\"a2\"}"]]]
             ------
             READ: SELECT * FROM `/Root/ColumnTable` ORDER BY Col1;
-            EXPECTED: [[1u;["{\"a\":\"a1\",\"b\":\"b1\",\"c\":\"c1\"}"]];[2u;["{\"a\":\"a2\"}"]];[3u;["{\"b\":\"b3\",\"d\":\"d3\"}"]];[4u;["{\"a\":\"a4\",\"b\":\"b4asdsasdaa\"}"]]]
+            EXPECTED: [[1u;["{\"a\":\"a1\",\"b\":\"b1\",\"c\":\"c1\",\"d\":\"NULL\",\"e.v\":{\"c\":\"1\",\"e\":{\"c.a\":\"2\"}}}"]];[2u;["{\"a\":\"a2\"}"]];[3u;["{\"b\":\"b3\",\"d\":\"d3\"}"]];[4u;["{\"a\":\"a4\",\"b\":\"b4asdsasdaa\"}"]]]
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"e.v\".c") = "1" ORDER BY Col1;
+            EXPECTED: [[1u;["{\"a\":\"a1\",\"b\":\"b1\",\"c\":\"c1\",\"d\":\"NULL\",\"e.v\":{\"c\":\"1\",\"e\":{\"c.a\":\"2\"}}}"]]]
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"e.v\".e.\"c.a\"") = "2" ORDER BY Col1;
+            EXPECTED: [[1u;["{\"a\":\"a1\",\"b\":\"b1\",\"c\":\"c1\",\"d\":\"NULL\",\"e.v\":{\"c\":\"1\",\"e\":{\"c.a\":\"2\"}}}"]]]
+            
+        )";
+        TScriptVariator(script).Execute();
+    }
+
+    Y_UNIT_TEST(RestoreFirstLevelVariants) {
+        TString script = R"(
+            SCHEMA:            
+            CREATE TABLE `/Root/ColumnTable` (
+                Col1 Uint64 NOT NULL,
+                Col2 JsonDocument,
+                PRIMARY KEY (Col1)
+            )
+            PARTITION BY HASH(Col1)
+            WITH (STORE = COLUMN, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = $$1|2|10$$);
+            ------
+            SCHEMA:
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)
+            ------
+            SCHEMA:
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_EXTRACTOR_CLASS_NAME`=`JSON_SCANNER`, `SCAN_FIRST_LEVEL_ONLY`=`true`, 
+                      `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`,
+                      `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+            ------
+            DATA:
+            REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{"a" : "a1", "b" : "b1", "c" : "c1", "d" : null, "e.v" : {"c" : 1, "e" : {"c.a" : 2}}}')), (2u, JsonDocument('{"a" : "a2"}')),
+                                                                    (3u, JsonDocument('{"b" : "b3", "d" : "d3", "e" : ["a", {"v" : ["c", 5]}]}')), (4u, JsonDocument('{"b" : "b4asdsasdaa", "a" : "a4"}'))
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` ORDER BY Col1;
+            EXPECTED: [[1u;["{\"a\":\"a1\",\"b\":\"b1\",\"c\":\"c1\",\"d\":\"NULL\",\"e.v\":\"{\\\"c\\\":1,\\\"e\\\":{\\\"c.a\\\":2}}\"}"]];[2u;["{\"a\":\"a2\"}"]];[3u;["{\"b\":\"b3\",\"d\":\"d3\",\"e\":\"[\\\"a\\\",{\\\"v\\\":[\\\"c\\\",5]}]\"}"]];[4u;["{\"a\":\"a4\",\"b\":\"b4asdsasdaa\"}"]]]
+            
+        )";
+        TScriptVariator(script).Execute();
+    }
+
+    Y_UNIT_TEST(RestoreFullJsonVariants) {
+        TString script = R"(
+            SCHEMA:            
+            CREATE TABLE `/Root/ColumnTable` (
+                Col1 Uint64 NOT NULL,
+                Col2 JsonDocument,
+                PRIMARY KEY (Col1)
+            )
+            PARTITION BY HASH(Col1)
+            WITH (STORE = COLUMN, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = $$1|2|10$$);
+            ------
+            SCHEMA:
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)
+            ------
+            SCHEMA:
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_EXTRACTOR_CLASS_NAME`=`JSON_SCANNER`, `SCAN_FIRST_LEVEL_ONLY`=`false`, 
+                      `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`,
+                      `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+            ------
+            DATA:
+            REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{"a" : "a1", "b" : "b1", "c" : "c1", "d" : null, "e.v" : {"c" : 1, "e" : {"c.a" : 2}}}')), (2u, JsonDocument('{"a" : "a2"}')),
+                                                                    (3u, JsonDocument('{"b" : "b3", "d" : "d3", "e" : ["a", {"v" : ["c", 5]}]}')), (4u, JsonDocument('{"b" : "b4asdsasdaa", "a" : "a4"}'))
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` ORDER BY Col1;
+            EXPECTED: [[1u;["{\"a\":\"a1\",\"b\":\"b1\",\"c\":\"c1\",\"d\":\"NULL\",\"e.v\":{\"c\":\"1\",\"e\":{\"c.a\":\"2\"}}}"]];[2u;["{\"a\":\"a2\"}"]];[3u;["{\"b\":\"b3\",\"d\":\"d3\",\"e\":[\"a\",{\"v\":[\"c\",\"5\"]}]}"]];[4u;["{\"a\":\"a4\",\"b\":\"b4asdsasdaa\"}"]]]
+            
+        )";
+        TScriptVariator(script).Execute();
+    }
+
+    Y_UNIT_TEST(BrokenJsonWriting) {
+        NColumnShard::TTableUpdatesBuilder updates(NArrow::MakeArrowSchema(
+            { { "Col1", NScheme::TTypeInfo(NScheme::NTypeIds::Uint64) }, { "Col2", NScheme::TTypeInfo(NScheme::NTypeIds::Utf8) } }));
+        updates.AddRow().Add<int64_t>(1).Add("{\"a\" : \"c}");
+        auto arrowString = Base64Encode(NArrow::NSerialization::TNativeSerializer().SerializeFull(updates.BuildArrow()));
+
+        TString script = Sprintf(R"(
+            SCHEMA:            
+            CREATE TABLE `/Root/ColumnTable` (
+                Col1 Uint64 NOT NULL,
+                Col2 JsonDocument,
+                PRIMARY KEY (Col1)
+            )
+            PARTITION BY HASH(Col1)
+            WITH (STORE = COLUMN, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = $$1|2|10$$);
+            ------
+            SCHEMA:
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)
+            ------
+            SCHEMA:
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_EXTRACTOR_CLASS_NAME`=`JSON_SCANNER`, `SCAN_FIRST_LEVEL_ONLY`=`false`, 
+                      `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`,
+                      `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+            ------
+            BULK_UPSERT:
+                /Root/ColumnTable
+                %s
+                BAD_REQUEST
+        )",
+            arrowString.data());
+        TScriptVariator(script).Execute();
+    }
+
+    Y_UNIT_TEST(RestoreJsonArrayVariants) {
+        TString script = R"(
+            SCHEMA:            
+            CREATE TABLE `/Root/ColumnTable` (
+                Col1 Uint64 NOT NULL,
+                Col2 JsonDocument,
+                PRIMARY KEY (Col1)
+            )
+            PARTITION BY HASH(Col1)
+            WITH (STORE = COLUMN, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = $$1|2|10$$);
+            ------
+            SCHEMA:
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)
+            ------
+            SCHEMA:
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_EXTRACTOR_CLASS_NAME`=`JSON_SCANNER`, `SCAN_FIRST_LEVEL_ONLY`=`false`, 
+                      `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`,
+                      `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+            ------
+            DATA:
+            REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('["a", {"v" : 4}, 1,2,3,4,5,6,7,8,9,10,11,12]'))
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` ORDER BY Col1;
+            EXPECTED: [[1u;["[\"a\",{\"v\":\"4\"},\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\"]"]]]
             
         )";
         TScriptVariator(script).Execute();
@@ -502,7 +688,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
             ------
             SCHEMA:
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, 
-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
             ------
             DATA:
             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{"a" : "a1", "b" : "b1", "c" : "c1"}')), (2u, JsonDocument('{"a" : "a2"}')),
@@ -534,7 +720,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
             ------
             SCHEMA:
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, 
-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
             ------
             DATA:
             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{"a" : "a1", "b" : "b1", "c" : "c1"}')), (2u, JsonDocument('{"a" : "a2"}')),
@@ -564,7 +750,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
             ------
             SCHEMA:
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, 
-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
             ------
             DATA:
             REPLACE INTO `/Root/ColumnTable` (Col1, Col2, Col3) VALUES(1u, JsonDocument('{"a" : "value_a", "b" : "b1", "c" : "c1"}'), "value1"), (2u, JsonDocument('{"a" : "value_a"}'), "value1"),
@@ -594,7 +780,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
             ------
             SCHEMA:
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, 
-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
             ------
             DATA:
             REPLACE INTO `/Root/ColumnTable` (Col1, Col2, Col3) VALUES(1u, JsonDocument('{"a" : "value_a", "b" : "b1", "c" : "c1"}'), "value1"), (2u, JsonDocument('{"a" : "value_a"}'), "value1"),
@@ -624,7 +810,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
             ------
             SCHEMA:
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, 
-                      `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
             ------
             DATA:
             REPLACE INTO `/Root/ColumnTable` (Col1, Col2, Col3) VALUES(1u, JsonDocument('{"a" : "value_a", "b" : "b1", "c" : "c1"}'), "value1"), (2u, JsonDocument('{"a" : "value_a"}'), "value1"),
@@ -653,7 +839,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
             ------
             SCHEMA:
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, 
-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
             ------
             DATA:
             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{"a" : "a1", "b" : "b1", "c" : "c1"}')), (2u, JsonDocument('{"a" : "a2"}')),
@@ -682,7 +868,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
             ------
             SCHEMA:
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, 
-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
             ------
             DATA:
             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{"a" : "a1"}')), (2u, JsonDocument('{"a" : "a2"}')),
@@ -711,7 +897,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
             ------
             SCHEMA:
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, 
-                      `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$1024|0|1$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
             ------
             DATA:
             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{"a" : "a1"}')), (2u, JsonDocument('{"a" : "a2"}')),
@@ -742,7 +928,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
             ------
             SCHEMA:
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, 
-                      `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
             ------
             DATA:
             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{"a" : "a1"}')), (2u, JsonDocument('{"a" : "a2"}')), 
@@ -765,7 +951,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
         TScriptVariator(script).Execute();
     }
 
-    Y_UNIT_TEST(BloomIndexesVariants) {
+    Y_UNIT_TEST(BloomMixIndexesVariants) {
         TString script = R"(
             STOP_COMPACTION
             ------
@@ -776,14 +962,16 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
                 PRIMARY KEY (Col1)
             )
             PARTITION BY HASH(Col1)
-            WITH (STORE = COLUMN, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = $$2$$);
+            WITH (STORE = COLUMN, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = 2);
             ------
             SCHEMA:
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)
             ------
             SCHEMA:
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, 
-                      `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+                      `DATA_EXTRACTOR_CLASS_NAME`=`JSON_SCANNER`, `FORCE_SIMD_PARSING`=`$$true|false$$`, `SCAN_FIRST_LEVEL_ONLY`=`$$true|false$$`,
+                      `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10$$`,
+                      `MEM_LIMIT_CHUNK`=`$$0|1000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
             ------
             DATA:
             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{"a.b.c" : "a1"}')), (2u, JsonDocument('{"a.b.c" : "a2"}')), 
@@ -800,7 +988,12 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
             SCHEMA:
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_INDEX, NAME=index_ngramm_b, TYPE=BLOOM_NGRAMM_FILTER,
                 FEATURES=`{"column_name" : "Col2", "ngramm_size" : 3, "hashes_count" : 2, "filter_size_bytes" : 4096, 
-                           "records_count" : 1024, "data_extractor" : {"class_name" : "SUB_COLUMN", "sub_column_name" : "b.c.d"}}`);
+                           "records_count" : 1024, "case_sensitive" : false, "data_extractor" : {"class_name" : "SUB_COLUMN", "sub_column_name" : '"b.c.d"'}}`);
+            ------
+            SCHEMA:
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_INDEX, NAME=index_ngramm_a, TYPE=BLOOM_NGRAMM_FILTER,
+                FEATURES=`{"column_name" : "Col2", "ngramm_size" : 3, "hashes_count" : 2, "filter_size_bytes" : 4096, 
+                           "records_count" : 1024, "case_sensitive" : true, "data_extractor" : {"class_name" : "SUB_COLUMN", "sub_column_name" : "a"}}`);
             ------
             DATA:
             REPLACE INTO `/Root/ColumnTable` (Col1) VALUES(10u)
@@ -809,14 +1002,14 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
             ------
             READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"a.b.c\"") = "a1" ORDER BY Col1;
             EXPECTED: [[1u;["{\"a.b.c\":\"a1\"}"]]]
-            IDX_ND_SKIP_APPROVE: 0, 3, 1
+            IDX_ND_SKIP_APPROVE: 0, 4, 1
             ------
             SCHEMA:
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=DROP_INDEX, NAME=a_index)
             ------
             READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"a.b.c\"") = "1a1" ORDER BY Col1;
             EXPECTED: [[11u;["{\"a.b.c\":\"1a1\"}"]]]
-            IDX_ND_SKIP_APPROVE: 0, 3, 1
+            IDX_ND_SKIP_APPROVE: 0, 4, 1
             ------
             SCHEMA:
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_INDEX, NAME=b_index, TYPE=CATEGORY_BLOOM_FILTER,
@@ -824,24 +1017,214 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
             ------
             READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"b.c.d\"") = "1b4" ORDER BY Col1;
             EXPECTED: [[14u;["{\"a\":\"a4\",\"b.c.d\":\"1b4\"}"]]]
-            IDX_ND_SKIP_APPROVE: 0, 3, 1
+            IDX_ND_SKIP_APPROVE: 0, 4, 1
             ------
-            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"b.c.d\"") = "1b5" ORDER BY Col1;
+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"b.c.d\"") like "%1b4%" ORDER BY Col1;
+            EXPECTED: [[14u;["{\"a\":\"a4\",\"b.c.d\":\"1b4\"}"]]]
+            IDX_ND_SKIP_APPROVE: 0, 4, 1
+#            ------
+#            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"b.c.d\"") ilike "%1b4%" ORDER BY Col1;
+#            EXPECTED: [[14u;["{\"a\":\"a4\",\"b.c.d\":\"1b4\"}"]]]
+#            IDX_ND_SKIP_APPROVE: 0, 4, 1
+#            ------
+#            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"b.c.d\"") ilike "%1B4" ORDER BY Col1;
+#            EXPECTED: [[14u;["{\"a\":\"a4\",\"b.c.d\":\"1b4\"}"]]]
+#            IDX_ND_SKIP_APPROVE: 0, 4, 1
+#            ------
+#            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"b.c.d\"") ilike "1b5" ORDER BY Col1;
+#            EXPECTED: []
+#            IDX_ND_SKIP_APPROVE: 0, 5, 0
+#            ------
+#            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.a") = "1b5" ORDER BY Col1;
+#            EXPECTED: []
+#            IDX_ND_SKIP_APPROVE: 0, 5, 0
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.a") = "a4" ORDER BY Col1;
+            EXPECTED: [[4u;["{\"a\":\"a4\",\"b.c.d\":\"b4\"}"]];[14u;["{\"a\":\"a4\",\"b.c.d\":\"1b4\"}"]]]
+            IDX_ND_SKIP_APPROVE: 0, 3, 2
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"b.c.d111\"") = "1b5" ORDER BY Col1;
             EXPECTED: []
-            IDX_ND_SKIP_APPROVE: 0, 4, 0
+            IDX_ND_SKIP_APPROVE: 0, 5, 0
             ------
             READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"b.c.d\"") like "1b3" ORDER BY Col1;
             EXPECTED: [[13u;["{\"b.c.d\":\"1b3\"}"]]]
-            IDX_ND_SKIP_APPROVE: 0, 3, 1
+            IDX_ND_SKIP_APPROVE: 0, 4, 1
             ------
             READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"b.c.d\"") like "1b5" ORDER BY Col1;
             EXPECTED: []
-            IDX_ND_SKIP_APPROVE: 0, 4, 0
+            IDX_ND_SKIP_APPROVE: 0, 5, 0
             
         )";
         TScriptVariator(script).Execute();
     }
 
+    Y_UNIT_TEST(BloomCategoryIndexesVariants) {
+        TString script = R"(
+            STOP_COMPACTION
+            ------
+            SCHEMA:            
+            CREATE TABLE `/Root/ColumnTable` (
+                Col1 Uint64 NOT NULL,
+                Col2 JsonDocument,
+                PRIMARY KEY (Col1)
+            )
+            PARTITION BY HASH(Col1)
+            WITH (STORE = COLUMN, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = 2);
+            ------
+            SCHEMA:
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)
+            ------
+            SCHEMA:
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, 
+                      `DATA_EXTRACTOR_CLASS_NAME`=`JSON_SCANNER`, `FORCE_SIMD_PARSING`=`$$true|false$$`, `SCAN_FIRST_LEVEL_ONLY`=`$$true|false$$`,
+                      `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10$$`,
+                      `MEM_LIMIT_CHUNK`=`$$0|1000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+            ------
+            DATA:
+            REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{"a.b.c" : "a1"}')), (2u, JsonDocument('{"a.b.c" : "a2"}')), 
+                                                                    (3u, JsonDocument('{"b.c.d" : "b3"}')), (4u, JsonDocument('{"b.c.d" : "b4", "a" : "a4"}'))
+            ------
+            DATA:
+            REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(11u, JsonDocument('{"a.b.c" : "1a1"}')), (12u, JsonDocument('{"a.b.c" : "1a2"}')), 
+                                                                    (13u, JsonDocument('{"b.c.d" : "1b3"}')), (14u, JsonDocument('{"b.c.d" : "1b4", "a" : "a4"}'))
+            ------
+            SCHEMA:
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_INDEX, NAME=a_index, TYPE=$$CATEGORY_BLOOM_FILTER|BLOOM_FILTER$$,
+                    FEATURES=`{"column_name" : "Col2", "false_positive_probability" : 0.01}`)
+            ------
+            DATA:
+            REPLACE INTO `/Root/ColumnTable` (Col1) VALUES(10u)
+            ------
+            ONE_ACTUALIZATION
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"a.b.c\"") = "a1" ORDER BY Col1;
+            EXPECTED: [[1u;["{\"a.b.c\":\"a1\"}"]]]
+            IDX_ND_SKIP_APPROVE: 0, 4, 1
+            ------
+            SCHEMA:
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=DROP_INDEX, NAME=a_index)
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"a.b.c\"") = "1a1" ORDER BY Col1;
+            EXPECTED: [[11u;["{\"a.b.c\":\"1a1\"}"]]]
+            IDX_ND_SKIP_APPROVE: 0, 4, 1
+            ------
+            SCHEMA:
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_INDEX, NAME=b_index, TYPE=CATEGORY_BLOOM_FILTER,
+                    FEATURES=`{"column_name" : "Col2", "false_positive_probability" : 0.01}`)
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"b.c.d\"") = "1b4" ORDER BY Col1;
+            EXPECTED: [[14u;["{\"a\":\"a4\",\"b.c.d\":\"1b4\"}"]]]
+            IDX_ND_SKIP_APPROVE: 0, 4, 1
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.a") = "1b5" ORDER BY Col1;
+            EXPECTED: []
+            IDX_ND_SKIP_APPROVE: 0, 5, 0
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.a") = "a4" ORDER BY Col1;
+            EXPECTED: [[4u;["{\"a\":\"a4\",\"b.c.d\":\"b4\"}"]];[14u;["{\"a\":\"a4\",\"b.c.d\":\"1b4\"}"]]]
+            IDX_ND_SKIP_APPROVE: 0, 3, 2
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"b.c.d111\"") = "1b5" ORDER BY Col1;
+            EXPECTED: []
+            IDX_ND_SKIP_APPROVE: 0, 5, 0
+            
+        )";
+        TScriptVariator(script).Execute();
+    }
+
+    Y_UNIT_TEST(BloomNGrammIndexesVariants) {
+        TString script = R"(
+            STOP_COMPACTION
+            ------
+            SCHEMA:            
+            CREATE TABLE `/Root/ColumnTable` (
+                Col1 Uint64 NOT NULL,
+                Col2 JsonDocument,
+                PRIMARY KEY (Col1)
+            )
+            PARTITION BY HASH(Col1)
+            WITH (STORE = COLUMN, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = 2);
+            ------
+            SCHEMA:
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`SIMPLE`)
+            ------
+            SCHEMA:
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, 
+                      `DATA_EXTRACTOR_CLASS_NAME`=`JSON_SCANNER`, `FORCE_SIMD_PARSING`=`$$true|false$$`, `SCAN_FIRST_LEVEL_ONLY`=`$$true|false$$`,
+                      `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10$$`,
+                      `MEM_LIMIT_CHUNK`=`$$0|1000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+            ------
+            DATA:
+            REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{"a.b.c" : "a1"}')), (2u, JsonDocument('{"a.b.c" : "a2"}')), 
+                                                                    (3u, JsonDocument('{"b.c.d" : "b3"}')), (4u, JsonDocument('{"b.c.d" : "b4", "a" : "a4"}'))
+            ------
+            DATA:
+            REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(11u, JsonDocument('{"a.b.c" : "1a1"}')), (12u, JsonDocument('{"a.b.c" : "1a2"}')), 
+                                                                    (13u, JsonDocument('{"b.c.d" : "1b3"}')), (14u, JsonDocument('{"b.c.d" : "1b4", "a" : "a4"}'))
+            ------
+            SCHEMA:
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_INDEX, NAME=index_ngramm_b, TYPE=BLOOM_NGRAMM_FILTER,
+                FEATURES=`{"column_name" : "Col2", "ngramm_size" : 3, "hashes_count" : 2, "filter_size_bytes" : 4096, 
+                           "records_count" : 1024, "case_sensitive" : false, "data_extractor" : {"class_name" : "SUB_COLUMN", "sub_column_name" : '"b.c.d"'}}`);
+            ------
+            SCHEMA:
+            ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=UPSERT_INDEX, NAME=index_ngramm_a, TYPE=BLOOM_NGRAMM_FILTER,
+                FEATURES=`{"column_name" : "Col2", "ngramm_size" : 3, "hashes_count" : 2, "filter_size_bytes" : 4096, 
+                           "records_count" : 1024, "case_sensitive" : true, "data_extractor" : {"class_name" : "SUB_COLUMN", "sub_column_name" : "a"}}`);
+            ------
+            DATA:
+            REPLACE INTO `/Root/ColumnTable` (Col1) VALUES(10u)
+            ------
+            ONE_ACTUALIZATION
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"a.b.c\"") = "a1" ORDER BY Col1;
+            EXPECTED: [[1u;["{\"a.b.c\":\"a1\"}"]]]
+            IDX_ND_SKIP_APPROVE: 5, 0, 0
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"b.c.d\"") = "1b4" ORDER BY Col1;
+            EXPECTED: [[14u;["{\"a\":\"a4\",\"b.c.d\":\"1b4\"}"]]]
+            IDX_ND_SKIP_APPROVE: 0, 4, 1
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"b.c.d\"") like "%1b4%" ORDER BY Col1;
+            EXPECTED: [[14u;["{\"a\":\"a4\",\"b.c.d\":\"1b4\"}"]]]
+            IDX_ND_SKIP_APPROVE: 0, 4, 1
+#            ------
+#            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"b.c.d\"") ilike "%1b4%" ORDER BY Col1;
+#            EXPECTED: [[14u;["{\"a\":\"a4\",\"b.c.d\":\"1b4\"}"]]]
+#            IDX_ND_SKIP_APPROVE: 0, 4, 1
+#            ------
+#            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"b.c.d\"") ilike "%1B4" ORDER BY Col1;
+#            EXPECTED: [[14u;["{\"a\":\"a4\",\"b.c.d\":\"1b4\"}"]]]
+#            IDX_ND_SKIP_APPROVE: 0, 4, 1
+#            ------
+#            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"b.c.d\"") ilike "1b5" ORDER BY Col1;
+#            EXPECTED: []
+#            IDX_ND_SKIP_APPROVE: 0, 5, 0
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.a") = "1b5" ORDER BY Col1;
+            EXPECTED: []
+            IDX_ND_SKIP_APPROVE: 0, 5, 0
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.a") = "a4" ORDER BY Col1;
+            EXPECTED: [[4u;["{\"a\":\"a4\",\"b.c.d\":\"b4\"}"]];[14u;["{\"a\":\"a4\",\"b.c.d\":\"1b4\"}"]]]
+            IDX_ND_SKIP_APPROVE: 0, 3, 2
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"b.c.d111\"") = "1b5" ORDER BY Col1;
+            EXPECTED: []
+            IDX_ND_SKIP_APPROVE: 5, 0, 0
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"b.c.d\"") like "1b3" ORDER BY Col1;
+            EXPECTED: [[13u;["{\"b.c.d\":\"1b3\"}"]]]
+            IDX_ND_SKIP_APPROVE: 0, 4, 1
+            ------
+            READ: SELECT * FROM `/Root/ColumnTable` WHERE JSON_VALUE(Col2, "$.\"b.c.d\"") like "1B3" ORDER BY Col1;
+            EXPECTED: []
+            IDX_ND_SKIP_APPROVE: 0, 4, 1
+        )";
+        TScriptVariator(script).Execute();
+    }
+
     Y_UNIT_TEST(SwitchAccessorCompactionVariants) {
         TString script = R"(
             STOP_COMPACTION
@@ -864,7 +1247,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
             ------
             SCHEMA:
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, 
-                      `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
             ------
             DATA:
             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(11u, JsonDocument('{"a" : "1a1"}')), (12u, JsonDocument('{"a" : "1a2"}')), 
@@ -901,7 +1284,7 @@ Y_UNIT_TEST_SUITE(KqpOlapJson) {
             ------
             SCHEMA:
             ALTER OBJECT `/Root/ColumnTable` (TYPE TABLE) SET (ACTION=ALTER_COLUMN, NAME=Col2, `DATA_ACCESSOR_CONSTRUCTOR.CLASS_NAME`=`SUB_COLUMNS`, 
-                      `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
+                      `FORCE_SIMD_PARSING`=`$$true|false$$`, `COLUMNS_LIMIT`=`$$0|1|1024$$`, `SPARSED_DETECTOR_KFF`=`$$0|10|1000$$`, `MEM_LIMIT_CHUNK`=`$$0|100|1000000$$`, `OTHERS_ALLOWED_FRACTION`=`$$0|0.5$$`)
             ------
             DATA:
             REPLACE INTO `/Root/ColumnTable` (Col1, Col2) VALUES(1u, JsonDocument('{"a" : "a1"}')), (2u, JsonDocument('{"a" : "a2"}')), 
diff --git a/ydb/core/kqp/ut/olap/kqp_olap_ut.cpp b/ydb/core/kqp/ut/olap/kqp_olap_ut.cpp
index c4d7f39de174..f55f162ab42b 100644
--- a/ydb/core/kqp/ut/olap/kqp_olap_ut.cpp
+++ b/ydb/core/kqp/ut/olap/kqp_olap_ut.cpp
@@ -332,6 +332,31 @@ Y_UNIT_TEST_SUITE(KqpOlap) {
         }
     }
 
+    Y_UNIT_TEST(EmptyColumnsRead) {
+        auto settings = TKikimrSettings()
+            .SetWithSampleTables(false);
+        TKikimrRunner kikimr(settings);
+
+        TLocalHelper(kikimr).CreateTestOlapTable();
+
+        WriteTestData(kikimr, "/Root/olapStore/olapTable", 0, 1000000, 2);
+
+        auto client = kikimr.GetQueryClient();
+
+        Tests::NCommon::TLoggerInit(kikimr).Initialize();
+
+        {
+            auto it = client.ExecuteQuery(R"(
+                --!syntax_v1
+
+                SELECT 1
+                FROM `/Root/olapStore/olapTable`
+            )",NYdb::NQuery::TTxControl::NoTx(), NYdb::NQuery::TExecuteQuerySettings()).ExtractValueSync();
+
+            UNIT_ASSERT_C(it.IsSuccess(), it.GetIssues().ToString());
+        }
+    }
+
     Y_UNIT_TEST(SimpleQueryOlapStats) {
         auto settings = TKikimrSettings()
             .SetWithSampleTables(false);
@@ -812,54 +837,81 @@ Y_UNIT_TEST_SUITE(KqpOlap) {
         WriteTestData(kikimr, "/Root/olapStore/olapTable", 0, 1000000, 128);
 
         auto tableClient = kikimr.GetTableClient();
-        auto selectQueryWithSort = TString(R"(
+        auto selectQuerySortDesc = TString(R"(
             --!syntax_v1
             SELECT `timestamp` FROM `/Root/olapStore/olapTable` ORDER BY `timestamp` DESC LIMIT 4;
         )");
-        auto selectQuery = TString(R"(
+        auto selectQuerySortAsc = TString(R"(
             --!syntax_v1
             SELECT `timestamp` FROM `/Root/olapStore/olapTable` ORDER BY `timestamp` LIMIT 4;
         )");
-
-        auto it = tableClient.StreamExecuteScanQuery(selectQuery, scanSettings).GetValueSync();
-        auto result = CollectStreamResult(it);
+        auto selectQueryNoSort = TString(R"(
+            --!syntax_v1
+            SELECT `timestamp` FROM `/Root/olapStore/olapTable` LIMIT 4;
+        )");
 
         NJson::TJsonValue plan, node, reverse, limit, pushedLimit;
-        NJson::ReadJsonTree(*result.PlanJson, &plan, true);
-        Cerr << *result.PlanJson << Endl;
-        Cerr << result.QueryStats->query_plan() << Endl;
-        Cerr << result.QueryStats->query_ast() << Endl;
-
-        node = FindPlanNodeByKv(plan, "Node Type", "TopSort-TableFullScan");
-        UNIT_ASSERT(node.IsDefined());
-        reverse = FindPlanNodeByKv(node, "Reverse", "false");
-        UNIT_ASSERT(!reverse.IsDefined());
-        pushedLimit = FindPlanNodeByKv(node, "ReadLimit", "4");
-        UNIT_ASSERT(pushedLimit.IsDefined());
-        limit = FindPlanNodeByKv(node, "Limit", "4");
-        UNIT_ASSERT(limit.IsDefined());
-
-        // Check that Reverse flag is set in query plan
-        it = tableClient.StreamExecuteScanQuery(selectQueryWithSort, scanSettings).GetValueSync();
-        result = CollectStreamResult(it);
+        {
+            auto it = tableClient.StreamExecuteScanQuery(selectQuerySortAsc, scanSettings).GetValueSync();
+            auto result = CollectStreamResult(it);
 
-        NJson::ReadJsonTree(*result.PlanJson, &plan, true);
-        Cerr << "==============================" << Endl;
-        Cerr << *result.PlanJson << Endl;
-        Cerr << result.QueryStats->query_plan() << Endl;
-        Cerr << result.QueryStats->query_ast() << Endl;
-
-        node = FindPlanNodeByKv(plan, "Node Type", "TopSort-TableFullScan");
-        UNIT_ASSERT(node.IsDefined());
-        reverse = FindPlanNodeByKv(node, "Reverse", "true");
-        UNIT_ASSERT(reverse.IsDefined());
-        limit = FindPlanNodeByKv(node, "Limit", "4");
-        UNIT_ASSERT(limit.IsDefined());
-        pushedLimit = FindPlanNodeByKv(node, "ReadLimit", "4");
-        UNIT_ASSERT(pushedLimit.IsDefined());
+            NJson::ReadJsonTree(*result.PlanJson, &plan, true);
+            Cerr << *result.PlanJson << Endl;
+            Cerr << result.QueryStats->query_plan() << Endl;
+            Cerr << result.QueryStats->query_ast() << Endl;
+
+            node = FindPlanNodeByKv(plan, "Node Type", "TopSort-TableFullScan");
+            UNIT_ASSERT(node.IsDefined());
+            reverse = FindPlanNodeByKv(node, "Reverse", "false");
+            UNIT_ASSERT(reverse.IsDefined());
+            pushedLimit = FindPlanNodeByKv(node, "ReadLimit", "4");
+            UNIT_ASSERT(pushedLimit.IsDefined());
+            limit = FindPlanNodeByKv(node, "Limit", "4");
+            UNIT_ASSERT(limit.IsDefined());
+        }
+
+        {
+            // Check that Reverse flag is set in query plan
+            auto it = tableClient.StreamExecuteScanQuery(selectQuerySortDesc, scanSettings).GetValueSync();
+            auto result = CollectStreamResult(it);
+
+            NJson::ReadJsonTree(*result.PlanJson, &plan, true);
+            Cerr << "==============================" << Endl;
+            Cerr << *result.PlanJson << Endl;
+            Cerr << result.QueryStats->query_plan() << Endl;
+            Cerr << result.QueryStats->query_ast() << Endl;
+
+            node = FindPlanNodeByKv(plan, "Node Type", "TopSort-TableFullScan");
+            UNIT_ASSERT(node.IsDefined());
+            reverse = FindPlanNodeByKv(node, "Reverse", "true");
+            UNIT_ASSERT(reverse.IsDefined());
+            limit = FindPlanNodeByKv(node, "Limit", "4");
+            UNIT_ASSERT(limit.IsDefined());
+            pushedLimit = FindPlanNodeByKv(node, "ReadLimit", "4");
+            UNIT_ASSERT(pushedLimit.IsDefined());
+        }
+
+        {
+            // Check that Reverse flag is set in query plan
+            auto it = tableClient.StreamExecuteScanQuery(selectQueryNoSort, scanSettings).GetValueSync();
+            auto result = CollectStreamResult(it);
+
+            NJson::ReadJsonTree(*result.PlanJson, &plan, true);
+            Cerr << "==============================" << Endl;
+            Cerr << *result.PlanJson << Endl;
+            Cerr << result.QueryStats->query_plan() << Endl;
+            Cerr << result.QueryStats->query_ast() << Endl;
+
+            node = FindPlanNodeByKv(plan, "Node Type", "Limit-TableFullScan");
+            UNIT_ASSERT(node.IsDefined());
+            limit = FindPlanNodeByKv(node, "Limit", "4");
+            UNIT_ASSERT(limit.IsDefined());
+            pushedLimit = FindPlanNodeByKv(node, "ReadLimit", "4");
+            UNIT_ASSERT(pushedLimit.IsDefined());
+        }
 
         // Run actual request in case explain did not execute anything
-        it = tableClient.StreamExecuteScanQuery(selectQueryWithSort).GetValueSync();
+        auto it = tableClient.StreamExecuteScanQuery(selectQuerySortDesc).GetValueSync();
 
         UNIT_ASSERT(it.IsSuccess());
 
@@ -1019,7 +1071,7 @@ Y_UNIT_TEST_SUITE(KqpOlap) {
         for (const auto& r : rows) {
             TInstant ts = GetTimestamp(r.at("timestamp"));
             UNIT_ASSERT_GE_C(ts, tsPrev, "result is not sorted in ASC order");
-            UNIT_ASSERT(results.erase(ts.GetValue()));
+            UNIT_ASSERT_C(results.erase(ts.GetValue()), Sprintf("%d", ts.GetValue()));
             tsPrev = ts;
         }
         UNIT_ASSERT(rows.size() == 6);
@@ -1092,11 +1144,7 @@ Y_UNIT_TEST_SUITE(KqpOlap) {
         scanSettings.Explain(true);
 
         TLocalHelper(kikimr).CreateTestOlapTable();
-#if SSA_RUNTIME_VERSION >= 4U
         WriteTestData(kikimr, "/Root/olapStore/olapTable", 10000, 3000000, 5, true);
-#else
-        WriteTestData(kikimr, "/Root/olapStore/olapTable", 10000, 3000000, 5, false);
-#endif
         Tests::NCommon::TLoggerInit(kikimr).Initialize();
 
         auto tableClient = kikimr.GetTableClient();
@@ -1153,13 +1201,10 @@ Y_UNIT_TEST_SUITE(KqpOlap) {
             R"((`level`, `uid`) != (Int32("1"), NULL))",
             R"(`level` >= CAST("2" As Int32))",
             R"(CAST("2" As Int32) >= `level`)",
-#if SSA_RUNTIME_VERSION >= 2U
             R"(`uid` LIKE "%30000%")",
             R"(`uid` LIKE "uid%")",
             R"(`uid` LIKE "%001")",
             R"(`uid` LIKE "uid%001")",
-#endif
-#if SSA_RUNTIME_VERSION >= 4U
             R"(`level` + 2 < 5)",
             R"(`level` - 2 >= 1)",
             R"(`level` * 3 > 4)",
@@ -1187,7 +1232,6 @@ Y_UNIT_TEST_SUITE(KqpOlap) {
             //R"(`timestamp` >= Timestamp("1970-01-01T00:00:00.000001Z"))",
             R"(`timestamp` >= Timestamp("1970-01-01T00:00:03.000001Z") AND `level` < 4)",
             R"((`timestamp`, `level`) >= (Timestamp("1970-01-01T00:00:03.000001Z"), 3))",
-#endif
 #if SSA_RUNTIME_VERSION >= 5U
             R"(`resource_id` != "10001" XOR "XXX" == "YYY")",
             R"(IF(`level` > 3, -`level`, +`level`) < 2)",
@@ -1257,27 +1301,6 @@ Y_UNIT_TEST_SUITE(KqpOlap) {
             R"(`level` = NULL)",
             R"(`level` > NULL)",
             R"(Re2::Match('uid.*')(`uid`))",
-#if SSA_RUNTIME_VERSION < 2U
-            R"(`uid` LIKE "%30000%")",
-            R"(`uid` LIKE "uid%")",
-            R"(`uid` LIKE "%001")",
-            R"(`uid` LIKE "uid%001")",
-#endif
-#if SSA_RUNTIME_VERSION < 4U
-            R"(`level` * 3.14 > 4)",
-            R"(LENGTH(`uid`) > 0 OR `resource_id` = "10001")",
-            R"((LENGTH(`uid`) > 0 AND `resource_id` = "10001") OR `resource_id` = "10002")",
-            R"((LENGTH(`uid`) > 0 OR `resource_id` = "10002") AND (LENGTH(`uid`) < 15 OR `resource_id` = "10001"))",
-            R"(NOT(LENGTH(`uid`) > 0 AND `resource_id` = "10001"))",
-            R"(Unwrap(`level`/1) = `level` AND `resource_id` = "10001")",
-            R"(NOT(LENGTH(`uid`) > 0 OR `resource_id` = "10001"))",
-            R"(`level` + 2 < 5)",
-            R"(`level` - 2 >= 1)",
-            R"(`level` * 3 > 4)",
-            R"(`level` / 2 <= 1)",
-            R"(`level` % 3 != 1)",
-            R"(`timestamp` >= Timestamp("1970-01-01T00:00:00.000001Z"))",
-#endif
         };
 
         for (const auto& predicate: testDataNoPush) {
@@ -1360,7 +1383,6 @@ Y_UNIT_TEST_SUITE(KqpOlap) {
                           TStringBuilder() << "NarrowMap was removed. Query: " << pushQuery);
         }
     }
-#if SSA_RUNTIME_VERSION >= 2U
     Y_UNIT_TEST(PredicatePushdown_DifferentLvlOfFilters) {
         auto settings = TKikimrSettings()
             .SetWithSampleTables(false);
@@ -1380,11 +1402,7 @@ Y_UNIT_TEST_SUITE(KqpOlap) {
             { R"(`uid` NOT LIKE "%30000%")", "Filter-TableFullScan" },
             { R"(`uid` LIKE "uid%")", "Filter-TableFullScan" },
             { R"(`uid` LIKE "%001")", "Filter-TableFullScan" },
-#if SSA_RUNTIME_VERSION >= 4U
             { R"(`uid` LIKE "uid%001")", "Filter-TableFullScan" },
-#else
-            { R"(`uid` LIKE "uid%001")", "Filter-TableFullScan" }, // We have filter (Size >= 6)
-#endif
         };
         std::string query = R"(
             SELECT `timestamp` FROM `/Root/olapStore/olapTable` WHERE
@@ -1412,13 +1430,8 @@ Y_UNIT_TEST_SUITE(KqpOlap) {
             }
         }
     }
-#endif
 
-#if SSA_RUNTIME_VERSION >= 3U
     Y_UNIT_TEST(PredicatePushdown_LikePushedDownForStringType) {
-#else
-    Y_UNIT_TEST(PredicatePushdown_LikeNotPushedDownForStringType) {
-#endif
         auto settings = TKikimrSettings()
             .SetWithSampleTables(false);
         TKikimrRunner kikimr(settings);
@@ -1437,13 +1450,8 @@ Y_UNIT_TEST_SUITE(KqpOlap) {
 
         auto result = CollectStreamResult(it);
         auto ast = result.QueryStats->Getquery_ast();
-#if SSA_RUNTIME_VERSION >= 3U
         UNIT_ASSERT_C(ast.find("KqpOlapFilter") != std::string::npos,
                         TStringBuilder() << "Predicate wasn't pushed down. Query: " << query);
-#else
-        UNIT_ASSERT_C(ast.find("KqpOlapFilter") == std::string::npos,
-                        TStringBuilder() << "Predicate was pushed down. Query: " << query);
-#endif
     }
 #if SSA_RUNTIME_VERSION < 5U
     Y_UNIT_TEST(PredicatePushdown_LikeNotPushedDownIfAnsiLikeDisabled) {
@@ -1496,9 +1504,15 @@ Y_UNIT_TEST_SUITE(KqpOlap) {
         auto result = CollectStreamResult(it);
         auto ast = result.QueryStats->Getquery_ast();
         UNIT_ASSERT_C(ast.find(R"(('eq '"resource_id")") != std::string::npos,
-                          TStringBuilder() << "Predicate not pushed down. Query: " << query);
-        UNIT_ASSERT_C(ast.find(R"(('gt '"level")") == std::string::npos,
-                          TStringBuilder() << "Predicate pushed down. Query: " << query);
+                          TStringBuilder() << "Subpredicate is not pushed down. Query: " << query);
+        UNIT_ASSERT_C(ast.find(R"(('gt '"level")") != std::string::npos,
+                          TStringBuilder() << "Subpredicate is not pushed down. Query: " << query);
+        //This check is based on an assumpltion, that for pushed down predicates column names are preserved in AST
+        //But for non-pushed down predicates column names are (usually) replaced with a label, started with $. It' not a rule, but a heuristic
+        //So this check may require a correction when some ast optimization rules are changed
+        UNIT_ASSERT_C(ast.find(R"((Unwrap (/ $)") != std::string::npos,
+                          TStringBuilder() << "Unsafe subpredicate is pushed down. Query: " << query);
+
         UNIT_ASSERT_C(ast.find("NarrowMap") != std::string::npos,
                           TStringBuilder() << "NarrowMap was removed. Query: " << query);
     }
@@ -1814,6 +1828,87 @@ Y_UNIT_TEST_SUITE(KqpOlap) {
         UNIT_ASSERT_VALUES_EQUAL(result, insertRows);
     }
 
+    Y_UNIT_TEST(PredicatePushdownWithParametersILike) {
+        constexpr bool logQueries = true;
+        auto settings = TKikimrSettings()
+            .SetWithSampleTables(false);
+        TKikimrRunner kikimr(settings);
+
+        TStreamExecScanQuerySettings scanSettings;
+        scanSettings.Explain(true);
+
+        TLocalHelper(kikimr.GetTestServer()).CreateTestOlapTable();
+        WriteTestData(kikimr, "/Root/olapStore/olapTable", 10000, 3000000, 1000);
+
+        auto tableClient = kikimr.GetTableClient();
+
+        auto buildQuery = [](bool pushEnabled) {
+            TStringBuilder builder;
+
+            builder << "--!syntax_v1" << Endl;
+
+            if (!pushEnabled) {
+                builder << "PRAGMA Kikimr.OptEnableOlapPushdown = \"false\";" << Endl;
+            }
+
+            builder << R"(
+                DECLARE $in_uid AS Utf8;
+                DECLARE $in_level AS Int32;
+
+                SELECT `timestamp` FROM `/Root/olapStore/olapTable` WHERE
+                    uid ILIKE "uid_%" || $in_uid || "%" AND level > $in_level
+                ORDER BY `timestamp`;
+            )" << Endl;
+
+            return builder;
+        };
+
+        auto normalQuery = buildQuery(false);
+        auto pushQuery = buildQuery(true);
+
+        auto params = tableClient.GetParamsBuilder()
+            .AddParam("$in_uid")
+                .Utf8("3000")
+                .Build()
+            .AddParam("$in_level")
+                .Int32(2)
+                .Build()
+            .Build();
+
+        auto it = tableClient.StreamExecuteScanQuery(normalQuery, params).GetValueSync();
+        UNIT_ASSERT_C(it.IsSuccess(), it.GetIssues().ToString());
+        auto goodResult = CollectStreamResult(it);
+
+        it = tableClient.StreamExecuteScanQuery(pushQuery, params).GetValueSync();
+        UNIT_ASSERT_C(it.IsSuccess(), it.GetIssues().ToString());
+        auto pushResult = CollectStreamResult(it);
+
+        if (logQueries) {
+            Cerr << "Query: " << normalQuery << Endl;
+            Cerr << "Expected: " << goodResult.ResultSetYson << Endl;
+            Cerr << "Received: " << pushResult.ResultSetYson << Endl;
+        }
+
+        CompareYson(goodResult.ResultSetYson, pushResult.ResultSetYson);
+
+        it = tableClient.StreamExecuteScanQuery(pushQuery, scanSettings).GetValueSync();
+        UNIT_ASSERT_C(it.IsSuccess(), it.GetIssues().ToString());
+
+        auto result = CollectStreamResult(it);
+        auto ast = result.QueryStats->Getquery_ast();
+
+        UNIT_ASSERT_C(ast.find("KqpOlapFilter") != std::string::npos,
+                      TStringBuilder() << "Predicate not pushed down. Query: " << pushQuery);
+
+        NJson::TJsonValue plan, readRange;
+        NJson::ReadJsonTree(*result.PlanJson, &plan, true);
+
+        Cerr << result.PlanJson << Endl;
+
+        readRange = FindPlanNodeByKv(plan, "Name", "TableFullScan");
+        UNIT_ASSERT(readRange.IsDefined());
+    }
+
     Y_UNIT_TEST(PredicatePushdownWithParameters) {
         constexpr bool logQueries = true;
         auto settings = TKikimrSettings()
@@ -2258,7 +2353,6 @@ Y_UNIT_TEST_SUITE(KqpOlap) {
 
         auto tableClient = kikimr.GetTableClient();
 
-#if SSA_RUNTIME_VERSION >= 4U
         const std::set<std::string> numerics = {"Int8", "Int16", "Int32", "Int64", "UInt8", "UInt16", "UInt32", "UInt64", "Float", "Double"};
         const std::map<std::string, std::set<std::string>> exceptions = {
             {"Int8", numerics},
@@ -2274,18 +2368,6 @@ Y_UNIT_TEST_SUITE(KqpOlap) {
             {"String", {"Utf8"}},
             {"Utf8", {"String"}},
         };
-#else
-        std::map<std::string, std::set<std::string>> exceptions = {
-            {"Int8", {"Int16", "Int32"}},
-            {"Int16", {"Int8", "Int32"}},
-            {"Int32", {"Int8", "Int16"}},
-            {"UInt8", {"UInt16", "UInt32"}},
-            {"UInt16", {"UInt8", "UInt32"}},
-            {"UInt32", {"UInt8", "UInt16"}},
-            {"String", {"Utf8"}},
-            {"Utf8", {"String", "Json", "Yson"}},
-        };
-#endif
 
         std::vector<std::string> allTypes = {
             //"Bool",
@@ -3331,9 +3413,9 @@ Y_UNIT_TEST_SUITE(KqpOlap) {
 
             )", noTx).GetValueSync();
             UNIT_ASSERT_C(result.GetStatus() == NYdb::EStatus::SUCCESS, result.GetIssues().ToString());
-            
+
             result = queryClient.ExecuteQuery(R"(
-                UPSERT INTO Test (Id, Name, Comment) VALUES 
+                UPSERT INTO Test (Id, Name, Comment) VALUES
                     (10,  "n1", "aa"),
                     (20, "n2", "bb"),
                     (30, "n3", "cc"),
@@ -3387,5 +3469,64 @@ Y_UNIT_TEST_SUITE(KqpOlap) {
 
         testHelper.ReadData("SELECT COUNT(*) FROM `/Root/ColumnTableTest` WHERE time > CurrentUtcTimestamp()", "[[1u]]");
     }
+
+    Y_UNIT_TEST(WithDefaultValue) {
+        std::unique_ptr<TKikimrRunner> Kikimr;
+        auto settings = TKikimrSettings().SetWithSampleTables(false);
+        auto kikimr = std::make_unique<TKikimrRunner>(settings);
+        Tests::NCommon::TLoggerInit(*kikimr).Initialize();
+        auto queryClient = kikimr->GetQueryClient();
+        {
+            auto result = queryClient.ExecuteQuery(R"(
+                CREATE TABLE Test (
+                    Id Uint32 not null,
+                    Value String DEFAULT "aba",
+                    PRIMARY KEY (Id)
+                ) WITH (
+                    STORE = COLUMN
+                );
+            )", NQuery::TTxControl::NoTx()).GetValueSync();
+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::GENERIC_ERROR);
+            UNIT_ASSERT_STRING_CONTAINS_C(result.GetIssues().ToString(), "Default values are not supported in column tables", result.GetIssues().ToString());
+        }
+    }
+
+    Y_UNIT_TEST(SimpleRequestHasProjections) {
+        auto settings = TKikimrSettings()
+            .SetWithSampleTables(false);
+        TKikimrRunner kikimr(settings);
+        TLocalHelper(kikimr).CreateTestOlapTable();
+        WriteTestData(kikimr, "/Root/olapStore/olapTable", 0, 1000000, 20);
+        auto client = kikimr.GetTableClient();
+        Tests::NCommon::TLoggerInit(kikimr).Initialize();
+
+        {
+            auto it = client.StreamExecuteScanQuery(R"(
+                --!syntax_v1
+
+                SELECT 1
+                FROM `/Root/olapStore/olapTable`
+            )").GetValueSync();
+
+            UNIT_ASSERT_C(it.IsSuccess(), it.GetIssues().ToString());
+            TString result = StreamResultToYson(it);
+
+            CompareYson(result, R"([[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1];[1]])");
+        }
+
+        {
+            auto it = client.StreamExecuteScanQuery(R"(
+                --!syntax_v1
+
+                SELECT count(*)
+                FROM `/Root/olapStore/olapTable`
+            )").GetValueSync();
+
+            UNIT_ASSERT_C(it.IsSuccess(), it.GetIssues().ToString());
+            TString result = StreamResultToYson(it);
+
+            CompareYson(result, R"([[20u]])");
+        }
+    }
 }
 }
diff --git a/ydb/core/kqp/ut/opt/kqp_ne_ut.cpp b/ydb/core/kqp/ut/opt/kqp_ne_ut.cpp
index 280667bf2474..9984729f6244 100644
--- a/ydb/core/kqp/ut/opt/kqp_ne_ut.cpp
+++ b/ydb/core/kqp/ut/opt/kqp_ne_ut.cpp
@@ -1343,8 +1343,10 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {
         UNIT_ASSERT(stats.query_phases(index).duration_us() > 0);
     }
 
-    Y_UNIT_TEST(PruneWritePartitions) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_TWIN(PruneWritePartitions, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
 
@@ -1364,17 +1366,28 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {
         AssertSuccessResult(result);
 
         auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
 
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 0);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 0);
-        UNIT_ASSERT(stats.query_phases(0).table_access().size() == 0);
+        if (UseSink) {
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);
+    
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).partitions_count(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/TwoShard");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 1);
+        } else {
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
 
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).affected_shards(), 1);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).partitions_count(), 1);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/TwoShard");
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 0);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 0);
+            UNIT_ASSERT(stats.query_phases(0).table_access().size() == 0);
+
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).affected_shards(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).partitions_count(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/TwoShard");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);
+        }
 
         result = session.ExecuteDataQuery(R"(
             SELECT * FROM `/Root/TwoShard` WHERE Value2 <= -10 ORDER BY Key;
@@ -1757,8 +1770,10 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {
         ])", FormatResultSetYson(result.GetResultSet(0)));
     }
 
-    Y_UNIT_TEST(Update) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_TWIN(Update, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
 
@@ -1774,17 +1789,28 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {
         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
 
         auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
 
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/TwoShard");
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 0);
+        if (UseSink) {
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);
+    
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/TwoShard");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 2);
+            UNIT_ASSERT(stats.query_phases(0).table_access(0).updates().bytes() > 0);
+            UNIT_ASSERT(stats.query_phases(0).duration_us() > 0); 
+        } else {
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
 
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/TwoShard");
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 2);
-        UNIT_ASSERT(stats.query_phases(1).table_access(0).updates().bytes() > 0);
-        UNIT_ASSERT(stats.query_phases(1).duration_us() > 0);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/TwoShard");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 0);
+
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/TwoShard");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 2);
+            UNIT_ASSERT(stats.query_phases(1).table_access(0).updates().bytes() > 0);
+            UNIT_ASSERT(stats.query_phases(1).duration_us() > 0);
+        }
 
         result = session.ExecuteDataQuery(R"(
             SELECT * FROM `/Root/TwoShard` ORDER BY Key;
@@ -1801,8 +1827,10 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {
         ])", FormatResultSetYson(result.GetResultSet(0)));
     }
 
-    Y_UNIT_TEST(Delete) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_TWIN(Delete, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
 
@@ -1817,19 +1845,30 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {
         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
 
         auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
+        if (UseSink) {
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);
 
-        // Phase reading rows to delete
-        UNIT_ASSERT(stats.query_phases(0).duration_us() > 0);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/TwoShard");
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 6);
+            // Phase reading rows to delete
+            UNIT_ASSERT(stats.query_phases(0).duration_us() > 0);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/TwoShard");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 6);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).deletes().rows(), 2);
+        } else {
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
 
-        // Phase deleting rows
-        UNIT_ASSERT(stats.query_phases(1).duration_us() > 0);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/TwoShard");
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).deletes().rows(), 2);
+            // Phase reading rows to delete
+            UNIT_ASSERT(stats.query_phases(0).duration_us() > 0);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/TwoShard");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 6);
+
+            // Phase deleting rows
+            UNIT_ASSERT(stats.query_phases(1).duration_us() > 0);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/TwoShard");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).deletes().rows(), 2);
+        }
 
         result = session.ExecuteDataQuery(R"(
 
@@ -1845,8 +1884,10 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {
         ])", FormatResultSetYson(result.GetResultSet(0)));
     }
 
-    Y_UNIT_TEST(DeleteOn) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_TWIN(DeleteOn, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
 
@@ -1861,19 +1902,30 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {
         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
 
         auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
+        if (UseSink) {
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);
+
+            // Phase reading rows to delete
+            UNIT_ASSERT(stats.query_phases(0).duration_us() > 0);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/TwoShard");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 6);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).deletes().rows(), 2);
+        } else {
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
 
-        // Phase reading rows to delete
-        UNIT_ASSERT(stats.query_phases(0).duration_us() > 0);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/TwoShard");
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 6);
+            // Phase reading rows to delete
+            UNIT_ASSERT(stats.query_phases(0).duration_us() > 0);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/TwoShard");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 6);
 
-        // Phase deleting rows
-        UNIT_ASSERT(stats.query_phases(1).duration_us() > 0);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/TwoShard");
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).deletes().rows(), 2);
+            // Phase deleting rows
+            UNIT_ASSERT(stats.query_phases(1).duration_us() > 0);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/TwoShard");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).deletes().rows(), 2);
+        }
 
         result = session.ExecuteDataQuery(R"(
 
@@ -1969,8 +2021,11 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {
             ])", FormatResultSetYson(result.GetResultSet(0)));
     }
 
-    Y_UNIT_TEST(PruneEffectPartitions) {
+    Y_UNIT_TEST_TWIN(PruneEffectPartitions, UseSink) {
         TKikimrSettings serverSettings;
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        serverSettings.SetAppConfig(app);
         TKikimrRunner kikimr(serverSettings);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
@@ -1996,19 +2051,29 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {
         UNIT_ASSERT_C(it.IsSuccess(), it.GetIssues().ToString());
 
         auto& stats = NYdb::TProtoAccessor::GetProto(*it.GetStats());
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
+        if (UseSink) {
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);
+
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/EightShard");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 1);
+        } else {
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
 
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/EightShard");
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 1);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 0);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/EightShard");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 0);
 
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).affected_shards(), 1);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).partitions_count(), 1);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/EightShard");
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).reads().rows(), 0);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).affected_shards(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).partitions_count(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/EightShard");
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).reads().rows(), 0);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);
+        }
 
         it = session.ExecuteDataQuery(R"(
 
@@ -2606,8 +2671,10 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {
         }
     }
 
-    Y_UNIT_TEST(DeleteWithBuiltin) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_TWIN(DeleteWithBuiltin, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);;
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
 
@@ -2620,7 +2687,7 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {
         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
 
         auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
-        UNIT_ASSERT_EQUAL(stats.query_phases().size(), 2);
+        UNIT_ASSERT_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);
     }
 
     Y_UNIT_TEST(MultiEffectsOnSameTable) {
@@ -3034,8 +3101,10 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {
         ])", FormatResultSetYson(result.GetResultSet(0)));
     }
 
-    Y_UNIT_TEST(DeleteWithInputMultiConsumption) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_TWIN(DeleteWithInputMultiConsumption, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
 
@@ -3055,7 +3124,7 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {
         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
 
         AssertTableStats(result, "/Root/Join1", {
-            .ExpectedReads = 9,
+            .ExpectedReads = UseSink ? 18 : 9, // without sink: precompute
         });
 
         AssertTableStats(result, "/Root/Join2", {
@@ -3078,8 +3147,10 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {
         ])", FormatResultSetYson(result.GetResultSet(0)));
     }
 
-    Y_UNIT_TEST(DeleteWithInputMultiConsumptionLimit) {
-        TKikimrRunner kikimr;
+    Y_UNIT_TEST_TWIN(DeleteWithInputMultiConsumptionLimit, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
 
@@ -3106,7 +3177,7 @@ Y_UNIT_TEST_SUITE(KqpNewEngine) {
         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
 
         AssertTableStats(result, "/Root/Test", {
-            .ExpectedReads = 1,
+            .ExpectedReads = UseSink ? 2 : 1, // without sink: precompute
             .ExpectedDeletes = 2,
         });
 
diff --git a/ydb/core/kqp/ut/opt/kqp_not_null_ut.cpp b/ydb/core/kqp/ut/opt/kqp_not_null_ut.cpp
index 484bee1fb7af..e361195e91f0 100644
--- a/ydb/core/kqp/ut/opt/kqp_not_null_ut.cpp
+++ b/ydb/core/kqp/ut/opt/kqp_not_null_ut.cpp
@@ -159,8 +159,10 @@ Y_UNIT_TEST_SUITE(KqpNotNullColumns) {
         }
     }
 
-    Y_UNIT_TEST(InsertNotNullPkPg) {
-        TKikimrRunner kikimr(NKqp::TKikimrSettings().SetWithSampleTables(false));
+    Y_UNIT_TEST_TWIN(InsertNotNullPkPg, useSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);
+        TKikimrRunner kikimr(NKqp::TKikimrSettings().SetWithSampleTables(false).SetAppConfig(appConfig));
         auto client = kikimr.GetTableClient();
         auto session = client.CreateSession().GetValueSync().GetSession();
         {
@@ -193,8 +195,12 @@ Y_UNIT_TEST_SUITE(KqpNotNullColumns) {
             auto result = session.ExecuteDataQuery(query, TTxControl::BeginTx().CommitTx()).ExtractValueSync();
             UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::BAD_REQUEST);
             UNIT_ASSERT_C(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_BAD_COLUMN_TYPE), result.GetIssues().ToString());
-            UNIT_ASSERT_NO_DIFF(result.GetIssues().ToString(), "<main>: Error: Execution, code: 1060
"
-            "    <main>: Error: Tried to insert NULL value into NOT NULL column: key, code: 2031
");
+            if (useSink) {
+                UNIT_ASSERT_NO_DIFF(result.GetIssues().ToString(), "<main>: Error: Tried to insert NULL value into NOT NULL column: key, code: 2031
");
+            } else {
+                UNIT_ASSERT_NO_DIFF(result.GetIssues().ToString(), "<main>: Error: Execution, code: 1060
"
+                "    <main>: Error: Tried to insert NULL value into NOT NULL column: key, code: 2031
");
+            }
         }
 
         {   /* set NULL to not null pk column */
@@ -206,8 +212,12 @@ Y_UNIT_TEST_SUITE(KqpNotNullColumns) {
             auto result = session.ExecuteDataQuery(query, TTxControl::BeginTx().CommitTx()).ExtractValueSync();
             UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::BAD_REQUEST);
             UNIT_ASSERT_C(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_BAD_COLUMN_TYPE), result.GetIssues().ToString());
-            UNIT_ASSERT_NO_DIFF(result.GetIssues().ToString(), "<main>: Error: Execution, code: 1060
"
-            "    <main>: Error: Tried to insert NULL value into NOT NULL column: key, code: 2031
");
+            if (useSink) {
+                UNIT_ASSERT_NO_DIFF(result.GetIssues().ToString(), "<main>: Error: Tried to insert NULL value into NOT NULL column: key, code: 2031
");
+            } else {
+                UNIT_ASSERT_NO_DIFF(result.GetIssues().ToString(), "<main>: Error: Execution, code: 1060
"
+                "    <main>: Error: Tried to insert NULL value into NOT NULL column: key, code: 2031
");
+            }
         }
 
         {   /* set NULL to nullable column */
@@ -609,10 +619,13 @@ Y_UNIT_TEST_SUITE(KqpNotNullColumns) {
         }
     }
 
-    Y_UNIT_TEST(InsertNotNullPg) {
+    Y_UNIT_TEST_TWIN(InsertNotNullPg, useSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);
         auto settings = TKikimrSettings()
             .SetWithSampleTables(false)
-            .SetEnableNotNullDataColumns(true);
+            .SetEnableNotNullDataColumns(true)
+            .SetAppConfig(appConfig);
 
         TKikimrRunner kikimr(settings);
         auto client = kikimr.GetTableClient();
@@ -648,8 +661,13 @@ Y_UNIT_TEST_SUITE(KqpNotNullColumns) {
             auto result = session.ExecuteDataQuery(query, TTxControl::BeginTx().CommitTx()).ExtractValueSync();
             UNIT_ASSERT(!result.IsSuccess());
             UNIT_ASSERT_C(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_BAD_COLUMN_TYPE), result.GetIssues().ToString());
-            UNIT_ASSERT_NO_DIFF(result.GetIssues().ToString(), "<main>: Error: Execution, code: 1060
"
-            "    <main>: Error: Tried to insert NULL value into NOT NULL column: Value, code: 2031
");
+            if (useSink) {
+                UNIT_ASSERT_NO_DIFF(result.GetIssues().ToString(),
+                    "<main>: Error: Tried to insert NULL value into NOT NULL column: Value, code: 2031
");
+            } else {
+                UNIT_ASSERT_NO_DIFF(result.GetIssues().ToString(), "<main>: Error: Execution, code: 1060
"
+                    "    <main>: Error: Tried to insert NULL value into NOT NULL column: Value, code: 2031
");
+            }
         }
     }
 
diff --git a/ydb/core/kqp/ut/opt/kqp_ranges_ut.cpp b/ydb/core/kqp/ut/opt/kqp_ranges_ut.cpp
index 6e7f71260123..ae96754614e3 100644
--- a/ydb/core/kqp/ut/opt/kqp_ranges_ut.cpp
+++ b/ydb/core/kqp/ut/opt/kqp_ranges_ut.cpp
@@ -627,8 +627,11 @@ Y_UNIT_TEST_SUITE(KqpRanges) {
         }
     }
 
-    Y_UNIT_TEST(UpdateWhereInNoFullScan) {
+    Y_UNIT_TEST_TWIN(UpdateWhereInNoFullScan, UseSink) {
         TKikimrSettings settings;
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        settings.SetAppConfig(app);
         TKikimrRunner kikimr(settings);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
@@ -645,24 +648,38 @@ Y_UNIT_TEST_SUITE(KqpRanges) {
             UNIT_ASSERT(result.IsSuccess());
 
             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
-            size_t readPhase = 0;
-            if (stats.query_phases().size() == 3) {
-                readPhase = 1;
-            } else {
+            if (UseSink) {
                 UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
-            }
 
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).affected_shards(), 1);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).table_access().size(), 1);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).table_access(0).name(), "/Root/MultiShardTable");
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).table_access(0).reads().rows(), 1);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).table_access(0).partitions_count(), 1);
-
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).affected_shards(), 1);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).table_access().size(), 1);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).table_access(0).name(), "/Root/MultiShardTable");
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).table_access(0).updates().rows(), 1);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).table_access(0).partitions_count(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 0);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 0);
+
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).affected_shards(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/MultiShardTable");
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).reads().rows(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).partitions_count(), 2);
+            } else {
+                size_t readPhase = 0;
+                if (stats.query_phases().size() == 3) {
+                    readPhase = 1;
+                } else {
+                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
+                }
+
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).affected_shards(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).table_access().size(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).table_access(0).name(), "/Root/MultiShardTable");
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).table_access(0).reads().rows(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase).table_access(0).partitions_count(), 1);
+
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).affected_shards(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).table_access().size(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).table_access(0).name(), "/Root/MultiShardTable");
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).table_access(0).updates().rows(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(readPhase + 1).table_access(0).partitions_count(), 1);
+            }
         }
     }
 
@@ -806,8 +823,12 @@ Y_UNIT_TEST_SUITE(KqpRanges) {
         }
     }
 
-    Y_UNIT_TEST(UpdateWhereInFullScan) {
-        TKikimrRunner kikimr;
+    Y_UNIT_TEST_TWIN(UpdateWhereInFullScan, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        TKikimrSettings settings;
+        settings.SetAppConfig(app);
+        TKikimrRunner kikimr(settings);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
 
@@ -823,19 +844,31 @@ Y_UNIT_TEST_SUITE(KqpRanges) {
             UNIT_ASSERT(result.IsSuccess());
 
             auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
 
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 5);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/MultiShardTable");
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 6);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).partitions_count(), 5);
+            if (UseSink) {
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);
 
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).affected_shards(), 5);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/MultiShardTable");
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);
-            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).partitions_count(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 5);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/MultiShardTable");
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 6);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).partitions_count(), 6); // partitions_count is partition operations count
+            } else {
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
+
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 5);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/MultiShardTable");
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 6);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).partitions_count(), 5);
+
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).affected_shards(), 5);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/MultiShardTable");
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);
+                UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).partitions_count(), 1);
+            }
         }
     }
 
@@ -1023,8 +1056,11 @@ Y_UNIT_TEST_SUITE(KqpRanges) {
         UNIT_ASSERT(!read.Has("lookup_by"));
     }
 
-    Y_UNIT_TEST(DeleteNotFullScan) {
+    Y_UNIT_TEST_TWIN(DeleteNotFullScan, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         TKikimrSettings serverSettings;
+        serverSettings.SetAppConfig(app);
         TKikimrRunner kikimr(serverSettings);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
@@ -1045,17 +1081,28 @@ Y_UNIT_TEST_SUITE(KqpRanges) {
         Cerr << result.GetQueryPlan() << Endl;
 
         auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
+        if (UseSink) {
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);
 
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 0);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 0);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 0);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 0);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).deletes().rows(), 3);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).partitions_count(), 1);
+        } else {
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
+
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 0);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 0);
 
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).affected_shards(), 1);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).reads().rows(), 0);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 0);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).deletes().rows(), 3);
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).partitions_count(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).affected_shards(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).reads().rows(), 0);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 0);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).deletes().rows(), 3);
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).partitions_count(), 1);
+        }
     }
 
     Y_UNIT_TEST(LiteralOr) {
diff --git a/ydb/core/kqp/ut/perf/kqp_query_perf_ut.cpp b/ydb/core/kqp/ut/perf/kqp_query_perf_ut.cpp
index eeadaf267bf9..edcc7c74a2ee 100644
--- a/ydb/core/kqp/ut/perf/kqp_query_perf_ut.cpp
+++ b/ydb/core/kqp/ut/perf/kqp_query_perf_ut.cpp
@@ -318,8 +318,10 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {
         UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), EnableStreamLookup ? 1 : 2);
     }
 
-    Y_UNIT_TEST_TWIN(Upsert, QueryService) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_QUAD(Upsert, QueryService, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
 
         auto params = BuildUpdateParams();
 
@@ -338,15 +340,17 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {
 
 
         // TODO: Get rid of additional precompute stage for adding optionality to row members
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);
 
         for (const auto& phase : stats.query_phases()) {
             UNIT_ASSERT(phase.affected_shards() <= 2);
         }
     }
 
-    Y_UNIT_TEST_TWIN(Replace, QueryService) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_QUAD(Replace, QueryService, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
 
         auto params = BuildUpdateParams();
 
@@ -363,15 +367,17 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {
         });
 
         // Single-phase REPLACE require additional runtime write callable
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);
 
         for (const auto& phase : stats.query_phases()) {
             UNIT_ASSERT(phase.affected_shards() <= 2);
         }
     }
 
-    Y_UNIT_TEST_TWIN(UpdateOn, QueryService) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_QUAD(UpdateOn, QueryService, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
 
         auto params = BuildUpdateParams();
 
@@ -383,20 +389,22 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {
         )"), params);
 
         AssertTableStats(stats, "/Root/EightShard", {
-            .ExpectedReads = 1, // Non-existing keys don't count in reads
+            .ExpectedReads = UseSink ? 0 : 1, // Non-existing keys don't count in reads
             .ExpectedUpdates = 1,
         });
 
         // Two-phase UPDATE ON require more complex runtime callables
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 3);
+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 3);
 
         for (const auto& phase : stats.query_phases()) {
             UNIT_ASSERT(phase.affected_shards() <= 2);
         }
     }
 
-    Y_UNIT_TEST_TWIN(Insert, QueryService) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_QUAD(Insert, QueryService, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
 
         auto params = BuildInsertParams();
 
@@ -413,15 +421,17 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {
         });
 
         // Three-phase INSERT require more complex runtime callables
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 4);
+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 4);
 
         for (const auto& phase : stats.query_phases()) {
             UNIT_ASSERT(phase.affected_shards() <= 2);
         }
     }
 
-    Y_UNIT_TEST_TWIN(DeleteOn, QueryService) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_QUAD(DeleteOn, QueryService, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
 
         auto params = BuildDeleteParams();
 
@@ -438,15 +448,17 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {
         });
 
         // TODO: Get rid of additional precompute stage for adding optionality to row members
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);
 
         for (const auto& phase : stats.query_phases()) {
             UNIT_ASSERT(phase.affected_shards() <= 2);
         }
     }
 
-    Y_UNIT_TEST_TWIN(Update, QueryService) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_QUAD(Update, QueryService, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
 
         auto params = TParamsBuilder()
             .AddParam("$key").Uint64(201).Build()
@@ -465,15 +477,17 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {
             .ExpectedUpdates = 1,
         });
 
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);
 
         for (const auto& phase : stats.query_phases()) {
             UNIT_ASSERT(phase.affected_shards() <= 1);
         }
     }
 
-    Y_UNIT_TEST_TWIN(Delete, QueryService) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_QUAD(Delete, QueryService, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
 
         auto params = TParamsBuilder()
             .AddParam("$key").Uint64(201).Build()
@@ -493,15 +507,17 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {
             .ExpectedDeletes = 1,
         });
 
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);
 
         for (const auto& phase : stats.query_phases()) {
             UNIT_ASSERT(phase.affected_shards() <= 1);
         }
     }
 
-    Y_UNIT_TEST_TWIN(IndexUpsert, QueryService) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_QUAD(IndexUpsert, QueryService, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
         CreateSampleTablesWithIndex(session);
@@ -516,11 +532,13 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {
         )"), params);
 
 
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 5);
+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 4 : 5);
     }
 
-    Y_UNIT_TEST_TWIN(IndexReplace, QueryService) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_QUAD(IndexReplace, QueryService, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
         CreateSampleTablesWithIndex(session);
@@ -534,11 +552,13 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {
             SELECT * FROM AS_TABLE($items);
         )"), params);
 
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 5);
+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 4 : 5);
     }
 
-    Y_UNIT_TEST_TWIN(IndexUpdateOn, QueryService) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_QUAD(IndexUpdateOn, QueryService, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
         CreateSampleTablesWithIndex(session);
@@ -552,11 +572,13 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {
             SELECT * FROM AS_TABLE($items);
         )"), params);
 
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 5);
+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 4 : 5);
     }
 
-    Y_UNIT_TEST_TWIN(IndexDeleteOn, QueryService) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_QUAD(IndexDeleteOn, QueryService, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
         CreateSampleTablesWithIndex(session);
@@ -570,11 +592,13 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {
             SELECT * FROM AS_TABLE($items);
         )"), params);
 
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 4);
+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 3 : 4);
     }
 
-    Y_UNIT_TEST_TWIN(IndexInsert, QueryService) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_QUAD(IndexInsert, QueryService, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
         CreateSampleTablesWithIndex(session);
@@ -588,7 +612,7 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {
             SELECT * FROM AS_TABLE($items);
         )"), params);
 
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 5);
+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 4 : 5);
     }
 
     Y_UNIT_TEST_TWIN(IdxLookupJoin, QueryService) {
@@ -672,8 +696,10 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {
         UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
     }
 
-    Y_UNIT_TEST_TWIN(MultiDeleteFromTable, QueryService) {
-        TKikimrRunner kikimr;
+    Y_UNIT_TEST_QUAD(MultiDeleteFromTable, QueryService, UseSink) {
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, app);
 
         auto params = TParamsBuilder()
             .AddParam("$key1_1").Uint32(101).Build()
@@ -701,7 +727,7 @@ Y_UNIT_TEST_SUITE(KqpQueryPerf) {
 
         CompareYson(R"([[7u]])", FormatResultSetYson(checkResults[0]));
 
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
+        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), UseSink ? 1 : 2);
 
         AssertTableStats(stats, "/Root/Join2", {
             .ExpectedReads = 3,
diff --git a/ydb/core/kqp/ut/pg/pg_catalog_ut.cpp b/ydb/core/kqp/ut/pg/pg_catalog_ut.cpp
index abb93736098e..ad9b88a0c48a 100644
--- a/ydb/core/kqp/ut/pg/pg_catalog_ut.cpp
+++ b/ydb/core/kqp/ut/pg/pg_catalog_ut.cpp
@@ -352,8 +352,10 @@ Y_UNIT_TEST_SUITE(PgCatalog) {
         }
     }
 
-    Y_UNIT_TEST(PgDatabase) {
-        TKikimrRunner kikimr(NKqp::TKikimrSettings().SetWithSampleTables(false));
+    Y_UNIT_TEST_TWIN(PgDatabase, useSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);
+        TKikimrRunner kikimr(NKqp::TKikimrSettings().SetWithSampleTables(false).SetAppConfig(appConfig));
         auto db = kikimr.GetQueryClient();
         auto settings = NYdb::NQuery::TExecuteQuerySettings().Syntax(NYdb::NQuery::ESyntax::Pg);
         {
diff --git a/ydb/core/kqp/ut/query/kqp_explain_ut.cpp b/ydb/core/kqp/ut/query/kqp_explain_ut.cpp
index 218a9e49e6d9..ef533a5d67a2 100644
--- a/ydb/core/kqp/ut/query/kqp_explain_ut.cpp
+++ b/ydb/core/kqp/ut/query/kqp_explain_ut.cpp
@@ -495,8 +495,11 @@ Y_UNIT_TEST_SUITE(KqpExplain) {
         }
     }
 
-    Y_UNIT_TEST(FewEffects) {
+    Y_UNIT_TEST_TWIN(FewEffects, UseSink) {
         TKikimrSettings settings;
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        settings.SetAppConfig(app);
         TKikimrRunner kikimr(settings);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
@@ -514,11 +517,17 @@ Y_UNIT_TEST_SUITE(KqpExplain) {
 
         Cerr << plan << Endl;
 
-        auto upsertsCount = CountPlanNodesByKv(plan, "Node Type", "Upsert-ConstantExpr");
-        UNIT_ASSERT_VALUES_EQUAL(upsertsCount, 2);
+        auto upsertsConstCount = CountPlanNodesByKv(plan, "Node Type", "Upsert-ConstantExpr");
+        UNIT_ASSERT_VALUES_EQUAL(upsertsConstCount, UseSink ? 0 : 2);
 
-        auto deletesCount = CountPlanNodesByKv(plan, "Node Type", "Delete-ConstantExpr");
-        UNIT_ASSERT_VALUES_EQUAL(deletesCount, 1);
+        auto deletesConstCount = CountPlanNodesByKv(plan, "Node Type", "Delete-ConstantExpr");
+        UNIT_ASSERT_VALUES_EQUAL(deletesConstCount, UseSink ? 0 : 1);
+
+        auto upsertsCount = CountPlanNodesByKv(plan, "Name", "Upsert");
+        UNIT_ASSERT_VALUES_EQUAL(upsertsCount, UseSink ? 2 : 2);
+
+        auto deletesCount = CountPlanNodesByKv(plan, "Name", "Delete");
+        UNIT_ASSERT_VALUES_EQUAL(deletesCount, UseSink ? 1 : 1);
 
         auto fullScansCount = CountPlanNodesByKv(plan, "Node Type", "TableFullScan");
         UNIT_ASSERT_VALUES_EQUAL(fullScansCount, 1);
@@ -540,8 +549,8 @@ Y_UNIT_TEST_SUITE(KqpExplain) {
         countOperationsByType("reads");
         countOperationsByType("writes");
 
-        UNIT_ASSERT_VALUES_EQUAL(counter["MultiUpsert"], upsertsCount);
-        UNIT_ASSERT_VALUES_EQUAL(counter["MultiErase"], deletesCount);
+        UNIT_ASSERT_VALUES_EQUAL(counter["MultiUpsert"], UseSink ? upsertsCount : upsertsConstCount);
+        UNIT_ASSERT_VALUES_EQUAL(counter["MultiErase"], UseSink ? deletesCount : deletesConstCount);
         UNIT_ASSERT_VALUES_EQUAL(counter["FullScan"], fullScansCount);
         UNIT_ASSERT_VALUES_EQUAL(counter["Scan"], rangeScansCount);
     }
diff --git a/ydb/core/kqp/ut/query/kqp_limits_ut.cpp b/ydb/core/kqp/ut/query/kqp_limits_ut.cpp
index bca95aa56d68..85d59bbf920d 100644
--- a/ydb/core/kqp/ut/query/kqp_limits_ut.cpp
+++ b/ydb/core/kqp/ut/query/kqp_limits_ut.cpp
@@ -54,8 +54,15 @@ namespace {
 }
 
 Y_UNIT_TEST_SUITE(KqpLimits) {
-    Y_UNIT_TEST(QSReplySizeEnsureMemoryLimits) {
-        TKikimrRunner kikimr;
+    Y_UNIT_TEST_TWIN(QSReplySizeEnsureMemoryLimits, useSink) {
+        auto app = NKikimrConfig::TAppConfig();
+        app.MutableTableServiceConfig()->SetEnableOltpSink(useSink);
+
+        auto settings = TKikimrSettings()
+            .SetAppConfig(app)
+            .SetWithSampleTables(true);
+
+        TKikimrRunner kikimr(settings);
         CreateLargeTable(kikimr, 1'000, 100, 1'000, 1'000);
 
         auto db = kikimr.GetQueryClient();
@@ -80,7 +87,58 @@ Y_UNIT_TEST_SUITE(KqpLimits) {
         )", NQuery::TTxControl::BeginTx().CommitTx()).ExtractValueSync();
         result.GetIssues().PrintTo(Cerr);
         UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::PRECONDITION_FAILED);
-        UNIT_ASSERT(!to_lower(TString{result.GetIssues().ToString()}).Contains("query result"));
+        UNIT_ASSERT_C(
+            !to_lower(TString{result.GetIssues().ToString()}).Contains("query result"),
+            result.GetIssues().ToString());
+        if (useSink) {
+            UNIT_ASSERT_C(
+                result.GetIssues().ToString().contains("Memory limit exception, current limit is 1024 bytes."),
+                result.GetIssues().ToString());
+        }
+    }
+
+    Y_UNIT_TEST_TWIN(StreamWrite, Allowed) {
+        auto app = NKikimrConfig::TAppConfig();
+        app.MutableTableServiceConfig()->SetEnableOltpSink(true);
+        app.MutableTableServiceConfig()->SetEnableStreamWrite(Allowed);
+        app.MutableTableServiceConfig()->MutableWriteActorSettings()->SetInFlightMemoryLimitPerActorBytes(64);
+
+        auto settings = TKikimrSettings()
+            .SetAppConfig(app)
+            .SetWithSampleTables(false);
+
+        TKikimrRunner kikimr(settings);
+
+        auto db = kikimr.GetQueryClient();
+        
+        {
+            auto result = db.ExecuteQuery(R"(
+                CREATE TABLE `/Root/DataShard` (
+                    Col1 Uint64 NOT NULL,
+                    Col2 String NOT NULL,
+                    Col3 Int32 NOT NULL,
+                    PRIMARY KEY (Col1)
+                )
+                WITH (UNIFORM_PARTITIONS = 2, AUTO_PARTITIONING_MIN_PARTITIONS_COUNT = 2);)",
+                NQuery::TTxControl::NoTx()).ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::SUCCESS);
+        }
+
+        {
+            auto result = db.ExecuteQuery(R"(
+                UPSERT INTO `/Root/DataShard` (Col1, Col2, Col3) VALUES
+                    (10u, "test1", 10), (20u, "test2", 11), (30u, "test3", 12), (40u, "test", 13);
+            )", NQuery::TTxControl::BeginTx().CommitTx()).ExtractValueSync();
+            result.GetIssues().PrintTo(Cerr);
+            if (!Allowed) {
+                UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::PRECONDITION_FAILED);
+                UNIT_ASSERT_C(
+                    result.GetIssues().ToString().contains("Stream write queries aren't allowed."),
+                    result.GetIssues().ToString());
+            } else {
+                UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::SUCCESS);
+            }
+        }
     }
 
     Y_UNIT_TEST(KqpMkqlMemoryLimitException) {
@@ -164,14 +222,19 @@ Y_UNIT_TEST_SUITE(KqpLimits) {
         UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::BAD_REQUEST);
     }
 
-    Y_UNIT_TEST(ComputeActorMemoryAllocationFailure) {
+    Y_UNIT_TEST_TWIN(ComputeActorMemoryAllocationFailure, useSink) {
         auto app = NKikimrConfig::TAppConfig();
+        app.MutableTableServiceConfig()->SetEnableOltpSink(useSink);
         app.MutableTableServiceConfig()->MutableResourceManager()->SetMkqlLightProgramMemoryLimit(10);
         app.MutableTableServiceConfig()->MutableResourceManager()->SetQueryMemoryLimit(2000);
 
         app.MutableResourceBrokerConfig()->CopyFrom(MakeResourceBrokerTestConfig());
 
-        TKikimrRunner kikimr(app);
+        auto settings = TKikimrSettings()
+            .SetAppConfig(app)
+            .SetWithSampleTables(false);
+
+        TKikimrRunner kikimr(settings);
         CreateLargeTable(kikimr, 0, 0, 0);
 
         kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::KQP_SLOW_LOG, NActors::NLog::PRI_ERROR);
@@ -188,8 +251,9 @@ Y_UNIT_TEST_SUITE(KqpLimits) {
         UNIT_ASSERT_C(result.GetIssues().ToString().contains("Mkql memory limit exceeded"), result.GetIssues().ToString());
     }
 
-    Y_UNIT_TEST(ComputeActorMemoryAllocationFailureQueryService) {
+    Y_UNIT_TEST_TWIN(ComputeActorMemoryAllocationFailureQueryService, useSink) {
         auto app = NKikimrConfig::TAppConfig();
+        app.MutableTableServiceConfig()->SetEnableOltpSink(useSink);
         app.MutableTableServiceConfig()->MutableResourceManager()->SetMkqlLightProgramMemoryLimit(10);
         app.MutableTableServiceConfig()->MutableResourceManager()->SetQueryMemoryLimit(2000);
 
@@ -197,7 +261,11 @@ Y_UNIT_TEST_SUITE(KqpLimits) {
 
         app.MutableFeatureFlags()->SetEnableResourcePools(true);
 
-        TKikimrRunner kikimr(app);
+        auto settings = TKikimrSettings()
+            .SetAppConfig(app)
+            .SetWithSampleTables(false);
+
+        TKikimrRunner kikimr(settings);
         CreateLargeTable(kikimr, 0, 0, 0);
 
         kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::KQP_SLOW_LOG, NActors::NLog::PRI_ERROR);
@@ -220,11 +288,16 @@ Y_UNIT_TEST_SUITE(KqpLimits) {
         Cerr << stats->ToString(true) << Endl;
     }
 
-    Y_UNIT_TEST(DatashardProgramSize) {
+    Y_UNIT_TEST_TWIN(DatashardProgramSize, useSink) {
         auto app = NKikimrConfig::TAppConfig();
+        app.MutableTableServiceConfig()->SetEnableOltpSink(useSink);
         app.MutableTableServiceConfig()->MutableResourceManager()->SetMkqlLightProgramMemoryLimit(1'000'000'000);
 
-        TKikimrRunner kikimr(app);
+        auto settings = TKikimrSettings()
+            .SetAppConfig(app)
+            .SetWithSampleTables(false);
+
+        TKikimrRunner kikimr(settings);
         CreateLargeTable(kikimr, 0, 0, 0);
 
         kikimr.GetTestServer().GetRuntime()->SetLogPriority(NKikimrServices::KQP_SLOW_LOG, NActors::NLog::PRI_ERROR);
@@ -259,9 +332,12 @@ Y_UNIT_TEST_SUITE(KqpLimits) {
             SELECT * FROM AS_TABLE($rows);
         )"), TTxControl::BeginTx().CommitTx(), paramsBuilder.Build()).ExtractValueSync();
         result.GetIssues().PrintTo(Cerr);
-        // UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::PRECONDITION_FAILED);
-        UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::ABORTED);
-        UNIT_ASSERT(HasIssue(result.GetIssues(), NKikimrIssues::TIssuesIds::SHARD_PROGRAM_SIZE_EXCEEDED));
+        if (useSink) {
+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::SUCCESS);
+        } else {
+            UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::ABORTED);
+            UNIT_ASSERT(HasIssue(result.GetIssues(), NKikimrIssues::TIssuesIds::SHARD_PROGRAM_SIZE_EXCEEDED));
+        }
     }
 
     Y_UNIT_TEST(DatashardReplySize) {
@@ -361,13 +437,22 @@ Y_UNIT_TEST_SUITE(KqpLimits) {
         }
     }
 
-    Y_UNIT_TEST(OutOfSpaceYQLUpsertFail) {
-        TKikimrRunner kikimr(NFake::TStorage{
-            .UseDisk = false,
-            .SectorSize = 4096,
-            .ChunkSize = 32_MB,
-            .DiskSize = 8_GB
-        });
+    Y_UNIT_TEST_TWIN(OutOfSpaceYQLUpsertFail, useSink) {
+        auto app = NKikimrConfig::TAppConfig();
+        app.MutableTableServiceConfig()->SetEnableOltpSink(useSink);
+        app.MutableTableServiceConfig()->MutableResourceManager()->SetMkqlLightProgramMemoryLimit(1'000'000'000);
+
+        auto settings = TKikimrSettings()
+            .SetAppConfig(app)
+            .SetWithSampleTables(false)
+            .SetStorage(NFake::TStorage{
+                .UseDisk = false,
+                .SectorSize = 4096,
+                .ChunkSize = 32_MB,
+                .DiskSize = 8_GB
+            });
+
+        TKikimrRunner kikimr(settings);
 
         kikimr.GetTestClient().CreateTable("/Root", R"(
             Name: "LargeTable"
@@ -384,7 +469,6 @@ Y_UNIT_TEST_SUITE(KqpLimits) {
 
         auto session = client.CreateSession().GetValueSync().GetSession();
 
-        bool getOutOfSpace = false;
         ui32 batchIdx = 0;
         ui32 cnt = 0;
 
@@ -412,27 +496,43 @@ Y_UNIT_TEST_SUITE(KqpLimits) {
                 UPSERT INTO `/Root/LargeTable`
                 SELECT * FROM AS_TABLE($rows);
             )"), TTxControl::BeginTx().CommitTx(), paramsBuilder.Build()).ExtractValueSync();
-            if (IsRetryable(result.GetStatus())) {
+ 
+            switch (result.GetStatus()) {
+            case EStatus::SUCCESS:
                 continue;
-            }
-            if (result.GetStatus() != EStatus::SUCCESS) {
-                result.GetIssues().PrintTo(Cerr);
-                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::UNAVAILABLE, result.GetIssues().ToString());
-                if (result.GetIssues().ToString().contains("OUT_OF_SPACE")) {
-                    getOutOfSpace = true;
-                } else if (result.GetIssues().ToString().contains("WRONG_SHARD_STATE")) {
+            case EStatus::OVERLOADED:
+                if (result.GetIssues().ToString().contains("out of disk space")) {
+                    UNIT_ASSERT(useSink);
+                    Cerr << "Got out of space. Successfully inserted " << rowsPerBatch << " x " << batchIdx << " lines, each of size " << dataTextSize << "bytes";
+                    return;
+                } else {
+                    continue;
+                }
+            case EStatus::UNAVAILABLE:
+                if (result.GetIssues().ToString().contains("out of disk space")) {
+                    UNIT_ASSERT(!useSink);
+                    //TODO Should be also EStatus::OVERLOADED
+                    Cerr << "Got out of space. Successfully inserted " << rowsPerBatch << " x " << batchIdx << " lines, each of size " << dataTextSize << "bytes";
+                    return;
+                } else if (result.GetIssues().ToString().contains("WRONG_SHARD_STATE")
+                        || result.GetIssues().ToString().contains("wrong shard state")
+                        || result.GetIssues().ToString().contains("can't deliver message to tablet")) {
                     // shards are allowed to split
                     continue;
                 }
-                break;
+                UNIT_ASSERT_C(false, "Unexpected UNAVAILABLE status" << result.GetIssues().ToString());
+            default:
+                UNIT_ASSERT_C(false, "Unexpected status" << result.GetStatus() << result.GetIssues().ToString());
             }
+
             ++batchIdx;
         }
-        UNIT_ASSERT_C(getOutOfSpace, "Successfully inserted " << rowsPerBatch << " x " << batchCount << " lines, each of size " << dataTextSize << "bytes");
+        UNIT_FAIL("Out of space is expected");
     }
 
-    Y_UNIT_TEST(TooBigQuery) {
+    Y_UNIT_TEST_TWIN(TooBigQuery, useSink) {
         auto app = NKikimrConfig::TAppConfig();
+        app.MutableTableServiceConfig()->SetEnableOltpSink(useSink);
         app.MutableTableServiceConfig()->MutableResourceManager()->SetMkqlLightProgramMemoryLimit(1'000'000'000);
         app.MutableTableServiceConfig()->SetCompileTimeoutMs(TDuration::Minutes(5).MilliSeconds());
 
@@ -468,8 +568,12 @@ Y_UNIT_TEST_SUITE(KqpLimits) {
         auto result = session.ExecuteDataQuery(query, TTxControl::BeginTx().CommitTx()).ExtractValueSync();
         result.GetIssues().PrintTo(Cerr);
         //UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());
-        UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::ABORTED, result.GetIssues().ToString());
-        UNIT_ASSERT(HasIssue(result.GetIssues(), NKikimrIssues::TIssuesIds::SHARD_PROGRAM_SIZE_EXCEEDED));
+        if (useSink) {
+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
+        } else {
+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::ABORTED, result.GetIssues().ToString());
+            UNIT_ASSERT(HasIssue(result.GetIssues(), NKikimrIssues::TIssuesIds::SHARD_PROGRAM_SIZE_EXCEEDED));
+        }
     }
 
     Y_UNIT_TEST(BigParameter) {
@@ -522,8 +626,12 @@ Y_UNIT_TEST_SUITE(KqpLimits) {
         UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
     }
 
-    Y_UNIT_TEST(TooBigKey) {
-        TKikimrRunner kikimr;
+    Y_UNIT_TEST_TWIN(TooBigKey, useSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);
+        appConfig.MutableTableServiceConfig()->MutableWriteActorSettings()->SetInFlightMemoryLimitPerActorBytes(512 * 1024 * 1024); // for ASAN
+
+        TKikimrRunner kikimr(appConfig);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
 
@@ -543,14 +651,21 @@ Y_UNIT_TEST_SUITE(KqpLimits) {
 
         result.GetIssues().PrintTo(Cerr);
         UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::BAD_REQUEST);
-        UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::DEFAULT_ERROR,
-            [] (const auto& issue) {
-                return issue.GetMessage().contains("exceeds limit");
-        }));
+        UNIT_ASSERT_C(HasIssue(result.GetIssues(), useSink ? NYql::TIssuesIds::KIKIMR_BAD_REQUEST : NYql::TIssuesIds::DEFAULT_ERROR,
+            [&](const auto& issue) {
+                if (useSink) {
+                    return issue.GetMessage().contains("Row key size of")
+                        && issue.GetMessage().contains("bytes is larger than the allowed threshold");
+                } else {
+                    return issue.GetMessage().contains("exceeds limit");
+                }
+        }), result.GetIssues().ToString());
     }
 
-    Y_UNIT_TEST(TooBigColumn) {
-        TKikimrRunner kikimr;
+    Y_UNIT_TEST_TWIN(TooBigColumn, useSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);
+        TKikimrRunner kikimr(appConfig);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
 
@@ -567,11 +682,15 @@ Y_UNIT_TEST_SUITE(KqpLimits) {
         )"), TTxControl::BeginTx().CommitTx(), params).ExtractValueSync();
 
         result.GetIssues().PrintTo(Cerr);
-        UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::GENERIC_ERROR);
-        UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::DEFAULT_ERROR,
-            [] (const auto& issue) {
-                return issue.GetMessage().contains("larger than the allowed threshold");
-        }));
+        if (!useSink) {
+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::GENERIC_ERROR, result.GetIssues().ToString());
+        } else {
+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::BAD_REQUEST, result.GetIssues().ToString());
+        }
+        UNIT_ASSERT(HasIssue(result.GetIssues(), useSink ? NYql::TIssuesIds::KIKIMR_BAD_REQUEST : NYql::TIssuesIds::DEFAULT_ERROR,
+                [] (const auto& issue) {
+                    return issue.GetMessage().contains("larger than the allowed threshold");
+            }));
     }
 
     Y_UNIT_TEST(AffectedShardsLimit) {
@@ -700,8 +819,10 @@ Y_UNIT_TEST_SUITE(KqpLimits) {
         }
     }
 
-    Y_UNIT_TEST(CancelAfterRwTx) {
-        TKikimrRunner kikimr;
+    Y_UNIT_TEST_TWIN(CancelAfterRwTx, useSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);
+        TKikimrRunner kikimr(appConfig);
         NKqp::TKqpCounters counters(kikimr.GetTestServer().GetRuntime()->GetAppData().Counters);
 
         {
@@ -1350,8 +1471,15 @@ Y_UNIT_TEST_SUITE(KqpLimits) {
         }
     }
 
-    Y_UNIT_TEST(QSReplySize) {
-        TKikimrRunner kikimr;
+    Y_UNIT_TEST_TWIN(QSReplySize, useSink) {
+        auto app = NKikimrConfig::TAppConfig();
+        app.MutableTableServiceConfig()->SetEnableOltpSink(useSink);
+
+        auto settings = TKikimrSettings()
+            .SetAppConfig(app)
+            .SetWithSampleTables(true);
+
+        TKikimrRunner kikimr(settings);
         CreateLargeTable(kikimr, 10'000, 100, 1'000, 1'000);
 
         auto db = kikimr.GetQueryClient();
@@ -1366,6 +1494,9 @@ Y_UNIT_TEST_SUITE(KqpLimits) {
         result.GetIssues().PrintTo(Cerr);
         UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::PRECONDITION_FAILED);
         UNIT_ASSERT(!to_lower(TString{result.GetIssues().ToString()}).Contains("query result"));
+        if (useSink) {
+            UNIT_ASSERT(result.GetIssues().ToString().contains("Stream write queries aren't allowed"));
+        }
     }
 }
 
diff --git a/ydb/core/kqp/ut/query/kqp_params_ut.cpp b/ydb/core/kqp/ut/query/kqp_params_ut.cpp
index 98690721b1ff..510245dfde3f 100644
--- a/ydb/core/kqp/ut/query/kqp_params_ut.cpp
+++ b/ydb/core/kqp/ut/query/kqp_params_ut.cpp
@@ -797,8 +797,10 @@ Y_UNIT_TEST_SUITE(KqpParams) {
         UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::BAD_REQUEST);
     }
 
-    Y_UNIT_TEST_TWIN(Decimal, QueryService) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_QUAD(Decimal, QueryService, UseSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        auto kikimr = DefaultKikimrRunner({}, appConfig);
         auto tableClient = kikimr.GetTableClient();
         auto queryClient = kikimr.GetQueryClient();
         auto session = tableClient.CreateSession().GetValueSync().GetSession();
diff --git a/ydb/core/kqp/ut/query/kqp_query_ut.cpp b/ydb/core/kqp/ut/query/kqp_query_ut.cpp
index 4549a493ad7f..16bc2da15229 100644
--- a/ydb/core/kqp/ut/query/kqp_query_ut.cpp
+++ b/ydb/core/kqp/ut/query/kqp_query_ut.cpp
@@ -1,6 +1,7 @@
 #include <ydb/core/kqp/ut/common/kqp_ut_common.h>
 
 #include <ydb/core/tx/datashard/datashard_failpoints.h>
+#include <ydb/core/tx/datashard/datashard.h>
 #include <ydb/core/testlib/common_helper.h>
 #include <ydb/core/kqp/provider/yql_kikimr_expr_nodes.h>
 #include <ydb/core/kqp/counters/kqp_counters.h>
@@ -953,8 +954,12 @@ Y_UNIT_TEST_SUITE(KqpQuery) {
         }
     }
 
-    Y_UNIT_TEST(QueryStats) {
-        TKikimrRunner kikimr;
+    Y_UNIT_TEST_TWIN(QueryStats, UseSink) {
+        TKikimrSettings serverSettings;
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        serverSettings.SetAppConfig(app);
+        TKikimrRunner kikimr(serverSettings);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
 
@@ -992,32 +997,51 @@ Y_UNIT_TEST_SUITE(KqpQuery) {
         UNIT_ASSERT(compile.cpu_time_us() > 0);
         totalCpuTimeUs += compile.cpu_time_us();
 
-        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
-
-        auto& phase0 = stats.query_phases(0);
-        UNIT_ASSERT(phase0.duration_us() > 0);
-        UNIT_ASSERT(phase0.cpu_time_us() > 0);
-        totalCpuTimeUs += phase0.cpu_time_us();
-
-        UNIT_ASSERT_VALUES_EQUAL(phase0.table_access().size(), 1);
-        UNIT_ASSERT_VALUES_EQUAL(phase0.table_access(0).name(), "/Root/TwoShard");
-        UNIT_ASSERT_VALUES_EQUAL(phase0.table_access(0).reads().rows(), 3);
-        UNIT_ASSERT(phase0.table_access(0).reads().bytes() > 0);
-        UNIT_ASSERT(!phase0.table_access(0).has_updates());
-        UNIT_ASSERT(!phase0.table_access(0).has_deletes());
-
-        auto& phase1 = stats.query_phases(1);
-        UNIT_ASSERT(phase1.duration_us() > 0);
-        UNIT_ASSERT(phase1.cpu_time_us() > 0);
-        totalCpuTimeUs += phase1.cpu_time_us();
-        UNIT_ASSERT_VALUES_EQUAL(phase1.table_access().size(), 1);
-        UNIT_ASSERT_VALUES_EQUAL(phase1.table_access(0).name(), "/Root/EightShard");
-        UNIT_ASSERT(!phase1.table_access(0).has_reads());
-        UNIT_ASSERT_VALUES_EQUAL(phase1.table_access(0).updates().rows(), 3);
-        UNIT_ASSERT(phase1.table_access(0).updates().bytes() > 0);
-        UNIT_ASSERT(!phase1.table_access(0).has_deletes());
-
-        UNIT_ASSERT_VALUES_EQUAL(stats.total_cpu_time_us(), totalCpuTimeUs);
+        if (UseSink) {
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);
+
+            auto& phase0 = stats.query_phases(0);
+            UNIT_ASSERT(phase0.duration_us() > 0);
+            UNIT_ASSERT(phase0.cpu_time_us() > 0);
+            totalCpuTimeUs += phase0.cpu_time_us();
+            UNIT_ASSERT_VALUES_EQUAL(phase0.table_access().size(), 2);
+            UNIT_ASSERT_VALUES_EQUAL(phase0.table_access(0).name(), "/Root/EightShard");
+            UNIT_ASSERT(!phase0.table_access(0).has_reads());
+            UNIT_ASSERT_VALUES_EQUAL(phase0.table_access(0).updates().rows(), 3);
+            UNIT_ASSERT_VALUES_EQUAL(phase0.table_access(1).reads().rows(), 3);
+            UNIT_ASSERT(phase0.table_access(0).updates().bytes() > 0);
+            UNIT_ASSERT(phase0.table_access(1).reads().bytes() > 0);
+            UNIT_ASSERT(!phase0.table_access(0).has_deletes());
+
+            UNIT_ASSERT_VALUES_EQUAL(stats.total_cpu_time_us(), totalCpuTimeUs);
+        } else {
+            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
+
+            auto& phase0 = stats.query_phases(0);
+            UNIT_ASSERT(phase0.duration_us() > 0);
+            UNIT_ASSERT(phase0.cpu_time_us() > 0);
+            totalCpuTimeUs += phase0.cpu_time_us();
+
+            UNIT_ASSERT_VALUES_EQUAL(phase0.table_access().size(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(phase0.table_access(0).name(), "/Root/TwoShard");
+            UNIT_ASSERT_VALUES_EQUAL(phase0.table_access(0).reads().rows(), 3);
+            UNIT_ASSERT(phase0.table_access(0).reads().bytes() > 0);
+            UNIT_ASSERT(!phase0.table_access(0).has_updates());
+            UNIT_ASSERT(!phase0.table_access(0).has_deletes());
+
+            auto& phase1 = stats.query_phases(1);
+            UNIT_ASSERT(phase1.duration_us() > 0);
+            UNIT_ASSERT(phase1.cpu_time_us() > 0);
+            totalCpuTimeUs += phase1.cpu_time_us();
+            UNIT_ASSERT_VALUES_EQUAL(phase1.table_access().size(), 1);
+            UNIT_ASSERT_VALUES_EQUAL(phase1.table_access(0).name(), "/Root/EightShard");
+            UNIT_ASSERT(!phase1.table_access(0).has_reads());
+            UNIT_ASSERT_VALUES_EQUAL(phase1.table_access(0).updates().rows(), 3);
+            UNIT_ASSERT(phase1.table_access(0).updates().bytes() > 0);
+            UNIT_ASSERT(!phase1.table_access(0).has_deletes());
+
+            UNIT_ASSERT_VALUES_EQUAL(stats.total_cpu_time_us(), totalCpuTimeUs);
+        }
     }
 
     Y_UNIT_TEST(RowsLimit) {
@@ -2142,6 +2166,118 @@ Y_UNIT_TEST_SUITE(KqpQuery) {
             CompareYson(R"([[3u]])", FormatResultSetYson(result.GetResultSet(0)));
         }
     }
+
+    Y_UNIT_TEST_TWIN(ReadOverloaded, StreamLookup) {
+        NKikimrConfig::TAppConfig appConfig;
+        auto setting = NKikimrKqp::TKqpSetting();
+        TKikimrSettings settings;
+        settings.SetAppConfig(appConfig);
+        settings.SetUseRealThreads(false);
+        TKikimrRunner kikimr(settings);
+        auto db = kikimr.GetTableClient();
+        auto session = kikimr.RunCall([&] { return db.CreateSession().GetValueSync().GetSession(); });
+        auto writeSession = kikimr.RunCall([&] { return db.CreateSession().GetValueSync().GetSession(); });
+
+        auto& runtime = *kikimr.GetTestServer().GetRuntime();
+        
+        kikimr.RunCall([&]{ CreateSampleTablesWithIndex(session, false /* no need in table data */); return true; });
+
+        {
+            const TString query(StreamLookup
+                ? Q1_(R"(
+                        SELECT Value FROM `/Root/SecondaryKeys` VIEW Index WHERE Fk = 1
+                    )")
+                : Q1_(R"(
+                        SELECT COUNT(a.Key) FROM `/Root/SecondaryKeys` as a;
+                    )"));
+
+            auto grab = [&](TAutoPtr<IEventHandle> &ev) -> auto {
+                if (ev->GetTypeRewrite() == TEvDataShard::TEvReadResult::EventType) {
+                    auto* msg = ev->Get<TEvDataShard::TEvReadResult>();
+                    msg->Record.MutableStatus()->SetCode(::Ydb::StatusIds::OVERLOADED);
+                }
+
+                return TTestActorRuntime::EEventAction::PROCESS;
+            };
+
+            runtime.SetObserverFunc(grab);
+            auto future = kikimr.RunInThreadPool([&]{
+                auto txc = TTxControl::BeginTx(TTxSettings::SerializableRW()).CommitTx();
+                return session.ExecuteDataQuery(query, txc).ExtractValueSync();
+            });
+
+            auto result = runtime.WaitFuture(future);
+            UNIT_ASSERT_C(!result.IsSuccess(), result.GetIssues().ToString());
+            UNIT_ASSERT(result.GetStatus() == NYdb::EStatus::OVERLOADED);
+        }
+    }
+
+    Y_UNIT_TEST(TableSinkWithSubquery) {
+        NKikimrConfig::TAppConfig appConfig;
+        auto settings = TKikimrSettings()
+            .SetAppConfig(appConfig)
+            .SetWithSampleTables(false);
+
+        TKikimrRunner kikimr(settings);
+        Tests::NCommon::TLoggerInit(kikimr).Initialize();
+
+        auto session = kikimr.GetTableClient().CreateSession().GetValueSync().GetSession();
+
+        const TString query = R"(
+            CREATE TABLE `/Root/table1` (
+                p1 Utf8,
+                PRIMARY KEY (p1)
+            )
+            WITH (
+                STORE = ROW
+            );
+
+            CREATE TABLE `/Root/table2` (
+                p1 Utf8,
+                PRIMARY KEY (p1)
+            )
+            WITH (
+                STORE = ROW
+            );
+        )";
+
+        auto result = session.ExecuteSchemeQuery(query).GetValueSync();
+        UNIT_ASSERT_C(result.GetStatus() == NYdb::EStatus::SUCCESS, result.GetIssues().ToString());
+
+        auto client = kikimr.GetQueryClient();
+
+        {
+            auto prepareResult = client.ExecuteQuery(R"(
+                UPSERT INTO `/Root/table1` (p1) VALUES ("a") , ("b"), ("c");
+            )", NYdb::NQuery::TTxControl::BeginTx().CommitTx()).ExtractValueSync();
+            UNIT_ASSERT_C(prepareResult.IsSuccess(), prepareResult.GetIssues().ToString());
+        }
+
+        {
+            auto result = client.ExecuteQuery(R"(
+                $data2 = Cast(AsList() As List<Struct<p1: Utf8>>);
+
+                /* query */
+                SELECT d1.p1 AS p1,
+                FROM `/Root/table1` AS d1
+                CROSS JOIN AS_TABLE($data2) AS d2;
+            )", NYdb::NQuery::TTxControl::BeginTx().CommitTx()).ExtractValueSync();
+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());
+        }
+
+        {
+            auto result = client.ExecuteQuery(R"(
+                $data2 = Cast(AsList() As List<Struct<p1: Utf8>>);
+
+                /* query */
+                INSERT INTO `/Root/table1`
+                SELECT d1.p1 AS p1,
+                FROM `/Root/table2` AS d1
+                CROSS JOIN AS_TABLE($data2) AS d2;
+            )", NYdb::NQuery::TTxControl::BeginTx().CommitTx()).ExtractValueSync();
+            UNIT_ASSERT_C(result.IsSuccess(), result.GetIssues().ToString());
+        }
+    }
 }
 
 } // namespace NKqp
diff --git a/ydb/core/kqp/ut/query/kqp_stats_ut.cpp b/ydb/core/kqp/ut/query/kqp_stats_ut.cpp
index 5763397cb1c1..8dfbffb136ef 100644
--- a/ydb/core/kqp/ut/query/kqp_stats_ut.cpp
+++ b/ydb/core/kqp/ut/query/kqp_stats_ut.cpp
@@ -193,8 +193,10 @@ Y_UNIT_TEST(MultiTxStatsFullScan) {
     MultiTxStatsFull<NYdb::NTable::TScanQueryPartIterator>(GetScanStreamIterator);
 }
 
-Y_UNIT_TEST(DeferredEffects) {
-    auto kikimr = DefaultKikimrRunner();
+Y_UNIT_TEST_TWIN(DeferredEffects, UseSink) {
+    NKikimrConfig::TAppConfig app;
+    app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+    auto kikimr = DefaultKikimrRunner({}, app);
     auto db = kikimr.GetTableClient();
     auto session = db.CreateSession().GetValueSync().GetSession();
     TString planJson;
@@ -238,7 +240,7 @@ Y_UNIT_TEST(DeferredEffects) {
     UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
 
     NJson::ReadJsonTree(result.GetQueryPlan(), &plan, true);
-    UNIT_ASSERT_VALUES_EQUAL(plan.GetMapSafe().at("Plan").GetMapSafe().at("Plans").GetArraySafe().size(), 3);
+    UNIT_ASSERT_VALUES_EQUAL(plan.GetMapSafe().at("Plan").GetMapSafe().at("Plans").GetArraySafe().size(), UseSink ? 2 : 3);
 
     result = session.ExecuteDataQuery(R"(
         SELECT * FROM `/Root/TwoShard`;
@@ -248,7 +250,7 @@ Y_UNIT_TEST(DeferredEffects) {
     UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
 
     NJson::ReadJsonTree(result.GetQueryPlan(), &plan, true);
-    UNIT_ASSERT_VALUES_EQUAL(plan.GetMapSafe().at("Plan").GetMapSafe().at("Plans").GetArraySafe().size(), 3);
+    UNIT_ASSERT_VALUES_EQUAL(plan.GetMapSafe().at("Plan").GetMapSafe().at("Plans").GetArraySafe().size(), UseSink ? 2 : 3);
 
     auto ru = result.GetResponseMetadata().find(NYdb::YDB_CONSUMED_UNITS_HEADER);
     UNIT_ASSERT(ru != result.GetResponseMetadata().end());
@@ -256,8 +258,10 @@ Y_UNIT_TEST(DeferredEffects) {
     UNIT_ASSERT(std::atoi(ru->second.c_str()) > 1);
 }
 
-Y_UNIT_TEST(DataQueryWithEffects) {
-    auto kikimr = DefaultKikimrRunner();
+Y_UNIT_TEST_TWIN(DataQueryWithEffects, UseSink) {
+    NKikimrConfig::TAppConfig app;
+    app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+    auto kikimr = DefaultKikimrRunner({}, app);
     auto db = kikimr.GetTableClient();
     auto session = db.CreateSession().GetValueSync().GetSession();
 
@@ -274,8 +278,13 @@ Y_UNIT_TEST(DataQueryWithEffects) {
     NJson::TJsonValue plan;
     NJson::ReadJsonTree(result.GetQueryPlan(), &plan, true);
 
-    auto node = FindPlanNodeByKv(plan, "Node Type", "Upsert-ConstantExpr");
-    UNIT_ASSERT_EQUAL(node.GetMap().at("Stats").GetMapSafe().at("Tasks").GetIntegerSafe(), 2);
+    if (UseSink) {
+        auto node = FindPlanNodeByKv(plan, "Node Type", "Stage-Sink");
+        UNIT_ASSERT_EQUAL(node.GetMap().at("Stats").GetMapSafe().at("Tasks").GetIntegerSafe(), 1);
+    } else {
+        auto node = FindPlanNodeByKv(plan, "Node Type", "Upsert-ConstantExpr");
+        UNIT_ASSERT_EQUAL(node.GetMap().at("Stats").GetMapSafe().at("Tasks").GetIntegerSafe(), 2);
+    }
 }
 
 Y_UNIT_TEST(DataQueryMulti) {
@@ -449,6 +458,39 @@ Y_UNIT_TEST_TWIN(StreamLookupStats, StreamLookupJoin) {
     });
 }
 
+Y_UNIT_TEST(SelfJoin) {
+    NKikimrConfig::TAppConfig app;
+    app.MutableTableServiceConfig()->SetEnableKqpDataQueryStreamIdxLookupJoin(true);
+
+    TKikimrRunner kikimr(TKikimrSettings().SetAppConfig(app));
+    auto db = kikimr.GetTableClient();
+    auto session = db.CreateSession().GetValueSync().GetSession();
+
+    TExecDataQuerySettings settings;
+    settings.CollectQueryStats(ECollectQueryStatsMode::Full);
+
+    auto result = session.ExecuteDataQuery(R"(
+        SELECT a.Key FROM `/Root/TwoShard` AS a INNER JOIN `/Root/TwoShard` AS b ON a.Key = b.Key;
+    )", TTxControl::BeginTx().CommitTx(), settings).ExtractValueSync();
+    UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
+
+    Cerr << result.GetQueryPlan() << Endl;
+
+    NJson::TJsonValue plan;
+    NJson::ReadJsonTree(result.GetQueryPlan(), &plan, true);
+
+    auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
+
+    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);
+    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
+    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).affected_shards(), 2);
+    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).partitions_count(), 4); // TODO: fix it
+
+    AssertTableStats(result, "/Root/TwoShard", {
+        .ExpectedReads = 12,
+    });
+}
+
 Y_UNIT_TEST(SysViewClientLost) {
     TKikimrRunner kikimr;
     CreateLargeTable(kikimr, 500000, 10, 100, 5000, 1);
@@ -635,12 +677,16 @@ Y_UNIT_TEST(SysViewCancelled) {
     }
 }
 
-Y_UNIT_TEST(OneShardLocalExec) {
-    TKikimrRunner kikimr;
+Y_UNIT_TEST_TWIN(OneShardLocalExec, UseSink) {
+    NKikimrConfig::TAppConfig app;
+    app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+    auto kikimr = DefaultKikimrRunner({}, app);
     auto db = kikimr.GetTableClient();
     auto session = db.CreateSession().GetValueSync().GetSession();
 
     TKqpCounters counters(kikimr.GetTestServer().GetRuntime()->GetAppData().Counters);
+
+    UNIT_ASSERT_VALUES_EQUAL(counters.TotalSingleNodeReqCount->Val(), 1);
     {
         auto result = session.ExecuteDataQuery(R"(
             SELECT * FROM `/Root/KeyValue` WHERE Key = 1;
@@ -672,8 +718,10 @@ Y_UNIT_TEST(OneShardLocalExec) {
     UNIT_ASSERT_VALUES_EQUAL(counters.NonLocalSingleNodeReqCount->Val(), 0);
 }
 
-Y_UNIT_TEST(OneShardNonLocalExec) {
-    TKikimrRunner kikimr(TKikimrSettings().SetNodeCount(2));
+Y_UNIT_TEST_TWIN(OneShardNonLocalExec, UseSink) {
+    NKikimrConfig::TAppConfig app;
+    app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+    TKikimrRunner kikimr(TKikimrSettings().SetNodeCount(2).SetAppConfig(app));
     auto db = kikimr.GetTableClient();
     auto session = db.CreateSession().GetValueSync().GetSession();
     auto monPort = kikimr.GetTestServer().GetRuntime()->GetMonPort();
diff --git a/ydb/core/kqp/ut/scheme/kqp_acl_ut.cpp b/ydb/core/kqp/ut/scheme/kqp_acl_ut.cpp
index 15f954355ca6..b18d75061448 100644
--- a/ydb/core/kqp/ut/scheme/kqp_acl_ut.cpp
+++ b/ydb/core/kqp/ut/scheme/kqp_acl_ut.cpp
@@ -501,6 +501,200 @@ Y_UNIT_TEST_SUITE(KqpAcl) {
             driver.Stop(true);
         }
     }
+
+    Y_UNIT_TEST_QUAD(AclDml, UseSink, IsOlap) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        appConfig.MutableTableServiceConfig()->SetEnableOlapSink(IsOlap);
+        auto settings = NKqp::TKikimrSettings().SetAppConfig(appConfig);
+        TKikimrRunner kikimr(appConfig);
+
+        {
+            auto driverConfig = TDriverConfig()
+                .SetEndpoint(kikimr.GetEndpoint())
+                .SetAuthToken("root@builtin");
+            auto driver = TDriver(driverConfig);
+            auto client = NYdb::NQuery::TQueryClient(driver);
+
+            const TString query = Sprintf(R"(
+                CREATE TABLE `/Root/test_acl` (
+                    id Uint64 NOT NULL,
+                    name String,
+                    primary key (id)
+                ) WITH (STORE=%s);
+            )", IsOlap ? "COLUMN" : "ROW");
+
+            AssertSuccessResult(client.ExecuteQuery(query, NYdb::NQuery::TTxControl::NoTx()).ExtractValueSync());
+
+            driver.Stop(true);
+        }
+
+        AddConnectPermission(kikimr, UserName);
+        AddPermissions(kikimr, "/Root/test_acl", UserName, {"ydb.deprecated.describe_schema", "ydb.deprecated.update_row"});
+
+        auto driverConfig = TDriverConfig()
+            .SetEndpoint(kikimr.GetEndpoint())
+            .SetAuthToken(UserName);
+        auto driver = TDriver(driverConfig);
+        auto client = NYdb::NQuery::TQueryClient(driver);
+
+        auto session = client.GetSession().GetValueSync().GetSession();
+
+        {
+            auto result = session.ExecuteQuery(R"(
+                UPSERT INTO `/Root/test_acl` (id, name) VALUES
+                    (10u, "One");
+            )", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();
+            AssertSuccessResult(result);
+        }
+
+        {
+            auto result = session.ExecuteQuery(R"(
+                REPLACE INTO `/Root/test_acl` (id, name) VALUES
+                    (11u, "Two");
+            )", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();
+            AssertSuccessResult(result);
+        }
+
+        {
+            auto result = session.ExecuteQuery(R"(
+                INSERT INTO `/Root/test_acl` (id, name) VALUES
+                    (12u, "Three");
+            )", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();
+            AssertSuccessResult(result);
+        }
+
+        {
+            auto result = session.ExecuteQuery(R"(
+                UPDATE `/Root/test_acl` SET name = "test" WHERE id = 10u;
+            )", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::ABORTED, result.GetIssues().ToString());
+        }
+
+        {
+            auto result = session.ExecuteQuery(R"(
+                UPDATE `/Root/test_acl` ON SELECT 11u AS id, "test" AS name;
+            )", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();
+            AssertSuccessResult(result);
+        }
+
+        {
+            auto result = session.ExecuteQuery(R"(
+                DELETE FROM `/Root/test_acl` WHERE id = 10u;
+            )", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::ABORTED, result.GetIssues().ToString());
+        }
+
+        {
+            auto result = session.ExecuteQuery(R"(
+                DELETE FROM `/Root/test_acl` ON SELECT 11u AS id;
+            )", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::ABORTED, result.GetIssues().ToString());
+        }
+
+        AddPermissions(kikimr, "/Root/test_acl", UserName, {"ydb.deprecated.describe_schema", "ydb.deprecated.update_row", "ydb.deprecated.erase_row"});
+
+        {
+            auto result = session.ExecuteQuery(R"(
+                DELETE FROM `/Root/test_acl` WHERE id = 10u;
+            )", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();
+            AssertSuccessResult(result);
+        }
+
+        {
+            auto result = session.ExecuteQuery(R"(
+                DELETE FROM `/Root/test_acl` ON SELECT 11u AS id;
+            )", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();
+            AssertSuccessResult(result);
+        }
+
+        AddPermissions(kikimr, "/Root/test_acl", UserName, {"ydb.deprecated.describe_schema", "ydb.deprecated.update_row", "ydb.deprecated.erase_row", "ydb.deprecated.select_row"});
+
+        {
+            auto result = session.ExecuteQuery(R"(
+                UPDATE `/Root/test_acl` SET name = "test" WHERE id = 10u;
+            )", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();
+            AssertSuccessResult(result);
+        }
+
+        {
+            auto result = session.ExecuteQuery(R"(
+                DELETE FROM `/Root/test_acl` WHERE id = 10u;
+            )", NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();
+            AssertSuccessResult(result);
+        }
+
+        driver.Stop(true);
+    }
+
+    Y_UNIT_TEST_QUAD(AclRevoke, UseSink, IsOlap) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+        appConfig.MutableTableServiceConfig()->SetEnableOlapSink(IsOlap);
+        auto settings = NKqp::TKikimrSettings().SetAppConfig(appConfig);
+        TKikimrRunner kikimr(appConfig);
+
+        {
+            auto driverConfig = TDriverConfig()
+                .SetEndpoint(kikimr.GetEndpoint())
+                .SetAuthToken("root@builtin");
+            auto driver = TDriver(driverConfig);
+            auto client = NYdb::NQuery::TQueryClient(driver);
+
+            const TString query = Sprintf(R"(
+                CREATE TABLE `/Root/test_acl` (
+                    id Uint64 NOT NULL,
+                    name String,
+                    primary key (id)
+                ) WITH (STORE=%s);
+            )", IsOlap ? "COLUMN" : "ROW");
+
+            AssertSuccessResult(client.ExecuteQuery(query, NYdb::NQuery::TTxControl::NoTx()).ExtractValueSync());
+
+            driver.Stop(true);
+        }
+
+        AddConnectPermission(kikimr, UserName);
+        
+        for (const auto permission : {"ydb.deprecated.describe_schema", "ydb.deprecated.update_row"}) {
+            AddPermissions(kikimr, "/Root/test_acl", UserName, {"ydb.deprecated.describe_schema", "ydb.deprecated.update_row"});
+
+            auto driverConfig = TDriverConfig()
+                .SetEndpoint(kikimr.GetEndpoint())
+                .SetAuthToken(UserName);
+            auto driver = TDriver(driverConfig);
+            auto client = NYdb::NQuery::TQueryClient(driver);
+
+            auto session = client.GetSession().GetValueSync().GetSession();
+
+            const TString query = R"(UPSERT INTO `/Root/test_acl` (id, name) VALUES (10u, "One");)";
+
+            for (size_t index = 0; index < 10; ++index) {
+                auto result = session.ExecuteQuery(
+                    query,
+                    NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();
+                AssertSuccessResult(result);
+            }
+
+            {
+                auto schemeClient = kikimr.GetSchemeClient();
+                NYdb::NScheme::TPermissions permissions("user0@builtin", {permission});
+                AssertSuccessResult(schemeClient.ModifyPermissions("/Root/test_acl",
+                        NYdb::NScheme::TModifyPermissionsSettings().AddRevokePermissions(permissions)
+                    ).ExtractValueSync()
+                );
+            }
+
+            {
+                auto result = session.ExecuteQuery(
+                    query,
+                    NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW()).CommitTx()).ExtractValueSync();
+                UNIT_ASSERT_C(!result.IsSuccess(), result.GetIssues().ToString());
+            }
+
+            driver.Stop(true);
+        }
+    }
 }
 
 } // namespace NKqp
diff --git a/ydb/core/kqp/ut/scheme/kqp_scheme_ut.cpp b/ydb/core/kqp/ut/scheme/kqp_scheme_ut.cpp
index 7787e7bdd1a8..d93a34a5c15f 100644
--- a/ydb/core/kqp/ut/scheme/kqp_scheme_ut.cpp
+++ b/ydb/core/kqp/ut/scheme/kqp_scheme_ut.cpp
@@ -3823,6 +3823,81 @@ Y_UNIT_TEST_SUITE(KqpScheme) {
             }
         }
     }
+    
+    void CheckOwner(TSession& session, const TString& path, const TString& name) {
+        TDescribeTableResult describe = session.DescribeTable(path).GetValueSync();
+        UNIT_ASSERT_VALUES_EQUAL(describe.GetStatus(), EStatus::SUCCESS);
+        auto tableDesc = describe.GetTableDescription();
+        const auto& currentOwner = tableDesc.GetOwner();
+        UNIT_ASSERT_VALUES_EQUAL_C(name, currentOwner, "name is not currentOwner");
+    }
+
+    Y_UNIT_TEST_TWIN(AlterDatabaseChangeOwner, EnableAlterDatabase) {
+        /* Default Kikimr runner can not create extsubdomain */
+        TTestExtEnv::TEnvSettings settings;
+        settings.FeatureFlags.SetEnableAlterDatabase(EnableAlterDatabase);
+
+        TTestExtEnv env(settings);
+        env.CreateDatabase("Test");
+
+        TTableClient client(env.GetDriver());
+        auto session = client.CreateSession().GetValueSync().GetSession();
+
+        {
+            auto createUserSql = TStringBuilder() << R"(
+                --!syntax_v1
+                CREATE USER superuser;
+            )";
+
+            auto result = session.ExecuteSchemeQuery(createUserSql).GetValueSync();
+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
+        }
+        {
+            auto createUserSql = TStringBuilder() << R"(
+                --!syntax_v1
+                CREATE TABLE `/Root/Test/table` (
+                    k Uint64,
+                    v Uint64,
+                    PRIMARY KEY(k)
+                );
+            )";
+
+            auto result = session.ExecuteSchemeQuery(createUserSql).GetValueSync();
+            UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
+        }
+        {
+            auto alterDatabaseSql = TStringBuilder() << R"(
+                --!syntax_v1
+                ALTER DATABASE `/Root/Test/table` OWNER TO superuser;
+            )";
+
+            auto result = session.ExecuteSchemeQuery(alterDatabaseSql).GetValueSync();
+
+            if (EnableAlterDatabase) {
+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());
+                UNIT_ASSERT_STRING_CONTAINS(result.GetIssues().ToString(), "Error: fail in ApplyIf section: wrong Path type.");
+            } else {
+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::GENERIC_ERROR, result.GetIssues().ToString());
+                UNIT_ASSERT_STRING_CONTAINS(result.GetIssues().ToString(), "ALTER DATABASE statement is not supported");
+            }
+        }
+        {
+            auto alterDatabaseSql = TStringBuilder() << R"(
+                --!syntax_v1
+                ALTER DATABASE `/Root/Test` OWNER TO superuser;
+            )";
+
+            auto result = session.ExecuteSchemeQuery(alterDatabaseSql).GetValueSync();
+
+            if (EnableAlterDatabase) {
+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
+                CheckOwner(session, "/Root/Test", "superuser");
+            } else {
+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::GENERIC_ERROR, result.GetIssues().ToString());
+                UNIT_ASSERT_STRING_CONTAINS(result.GetIssues().ToString(), "ALTER DATABASE statement is not supported");
+            }
+        }
+    }
 
     Y_UNIT_TEST(ModifyPermissions) {
         TKikimrRunner kikimr;
@@ -9151,9 +9226,10 @@ Y_UNIT_TEST_SUITE(KqpScheme) {
         );
     }
 
-    Y_UNIT_TEST(DoubleCreateResourcePoolClassifier) {
+    Y_UNIT_TEST_TWIN(DoubleCreateResourcePoolClassifier, UseSink) {
         NKikimrConfig::TAppConfig config;
         config.MutableFeatureFlags()->SetEnableResourcePools(true);
+        config.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
 
         TKikimrRunner kikimr(NKqp::TKikimrSettings()
             .SetAppConfig(config)
@@ -9180,7 +9256,11 @@ Y_UNIT_TEST_SUITE(KqpScheme) {
                 );)";
             auto result = session.ExecuteSchemeQuery(query).GetValueSync();
             UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), EStatus::GENERIC_ERROR);
-            UNIT_ASSERT_STRING_CONTAINS(result.GetIssues().ToString(), "Conflict with existing key");
+            if (UseSink) {
+                UNIT_ASSERT_STRING_CONTAINS_C(result.GetIssues().ToString(), "Duplicate keys have been found", result.GetIssues().ToString());
+            } else {
+                UNIT_ASSERT_STRING_CONTAINS_C(result.GetIssues().ToString(), "Conflict with existing key", result.GetIssues().ToString());
+            }
         }
     }
 
@@ -9732,64 +9812,90 @@ Y_UNIT_TEST_SUITE(KqpOlapScheme) {
         }
     }
 
-    Y_UNIT_TEST(AddColumn) {
-        TKikimrSettings runnerSettings;
-        runnerSettings.WithSampleTables = false;
-        TTestHelper testHelper(runnerSettings);
+    class TestAddColumn {
+    private:
+        TString ReaderPolicyName;
 
-        TVector<TTestHelper::TColumnSchema> schema = {
-            TTestHelper::TColumnSchema().SetName("id").SetType(NScheme::NTypeIds::Int32).SetNullable(false),
-            TTestHelper::TColumnSchema().SetName("resource_id").SetType(NScheme::NTypeIds::Utf8),
-            TTestHelper::TColumnSchema().SetName("level").SetType(NScheme::NTypeIds::Int32)
-        };
+    public:
+        TestAddColumn(const TString& reader)
+            : ReaderPolicyName(reader) {
+        }
 
-        Tests::NCommon::TLoggerInit(testHelper.GetKikimr()).Initialize();
-        TTestHelper::TColumnTable testTable;
+        void Run() {
+            TKikimrSettings runnerSettings;
+            runnerSettings.WithSampleTables = false;
+            runnerSettings.SetColumnShardAlterObjectEnabled(true);
+            TTestHelper testHelper(runnerSettings);
 
-        testTable.SetName("/Root/ColumnTableTest").SetPrimaryKey({"id"}).SetSharding({"id"}).SetSchema(schema);
-        testHelper.CreateTable(testTable);
+            TVector<TTestHelper::TColumnSchema> schema = {
+                TTestHelper::TColumnSchema().SetName("id").SetType(NScheme::NTypeIds::Int32).SetNullable(false),
+                TTestHelper::TColumnSchema().SetName("resource_id").SetType(NScheme::NTypeIds::Utf8),
+                TTestHelper::TColumnSchema().SetName("level").SetType(NScheme::NTypeIds::Int32)
+            };
 
-        {
-            TTestHelper::TUpdatesBuilder tableInserter(testTable.GetArrowSchema(schema));
-            tableInserter.AddRow().Add(1).Add("test_res_1").AddNull();
-            tableInserter.AddRow().Add(2).Add("test_res_2").Add(123);
-            testHelper.BulkUpsert(testTable, tableInserter);
-        }
+            Tests::NCommon::TLoggerInit(testHelper.GetKikimr()).Initialize();
+            TTestHelper::TColumnTable testTable;
 
-        testHelper.ReadData("SELECT * FROM `/Root/ColumnTableTest` WHERE id=1", "[[1;#;[\"test_res_1\"]]]");
+            testTable.SetName("/Root/ColumnTableTest").SetPrimaryKey({ "id" }).SetSharding({ "id" }).SetSchema(schema);
+            testHelper.CreateTable(testTable);
+            {
+                auto alterQuery = TStringBuilder()
+                                  << "ALTER OBJECT `" << testTable.GetName()
+                                  << "` (TYPE TABLE) SET (ACTION=UPSERT_OPTIONS, `SCAN_READER_POLICY_NAME`=`" << ReaderPolicyName << "`)";
+                auto alterResult = testHelper.GetSession().ExecuteSchemeQuery(alterQuery).GetValueSync();
+                UNIT_ASSERT_VALUES_EQUAL_C(alterResult.GetStatus(), EStatus::SUCCESS, alterResult.GetIssues().ToString());
+            }
 
-        {
-            schema.push_back(TTestHelper::TColumnSchema().SetName("new_column").SetType(NScheme::NTypeIds::Uint64));
-            auto alterQuery = TStringBuilder() << "ALTER TABLE `" << testTable.GetName() << "` ADD COLUMN new_column Uint64;";
-            auto alterResult = testHelper.GetSession().ExecuteSchemeQuery(alterQuery).GetValueSync();
-            UNIT_ASSERT_VALUES_EQUAL_C(alterResult.GetStatus(), EStatus::SUCCESS, alterResult.GetIssues().ToString());
-        }
+            {
+                TTestHelper::TUpdatesBuilder tableInserter(testTable.GetArrowSchema(schema));
+                tableInserter.AddRow().Add(1).Add("test_res_1").AddNull();
+                tableInserter.AddRow().Add(2).Add("test_res_2").Add(123);
+                testHelper.BulkUpsert(testTable, tableInserter);
+            }
 
-        {
-            auto settings = TDescribeTableSettings().WithTableStatistics(true);
-            auto describeResult = testHelper.GetSession().DescribeTable("/Root/ColumnTableTest", settings).GetValueSync();
-            UNIT_ASSERT_C(describeResult.IsSuccess(), describeResult.GetIssues().ToString());
+            testHelper.ReadData("SELECT * FROM `/Root/ColumnTableTest` WHERE id=1", "[[1;#;[\"test_res_1\"]]]");
 
-            const auto& description = describeResult.GetTableDescription();
-            auto columns = description.GetTableColumns();
-            UNIT_ASSERT_VALUES_EQUAL(columns.size(), 4);
-        }
+            {
+                schema.push_back(TTestHelper::TColumnSchema().SetName("new_column").SetType(NScheme::NTypeIds::Uint64));
+                auto alterQuery = TStringBuilder() << "ALTER TABLE `" << testTable.GetName() << "` ADD COLUMN new_column Uint64;";
+                auto alterResult = testHelper.GetSession().ExecuteSchemeQuery(alterQuery).GetValueSync();
+                UNIT_ASSERT_VALUES_EQUAL_C(alterResult.GetStatus(), EStatus::SUCCESS, alterResult.GetIssues().ToString());
+            }
 
-        testHelper.ReadData("SELECT * FROM `/Root/ColumnTableTest` WHERE id=1", "[[1;#;#;[\"test_res_1\"]]]");
-        testHelper.ReadData("SELECT new_column FROM `/Root/ColumnTableTest` WHERE id=1", "[[#]]");
-        testHelper.ReadData("SELECT resource_id FROM `/Root/ColumnTableTest` WHERE id=1", "[[[\"test_res_1\"]]]");
-        Tests::NCommon::TLoggerInit(testHelper.GetKikimr()).Initialize();
-        {
-            TTestHelper::TUpdatesBuilder tableInserter(testTable.GetArrowSchema(schema));
-            tableInserter.AddRow().Add(3).Add("test_res_3").Add(123).Add<uint64_t>(200);
-            testHelper.BulkUpsert(testTable, tableInserter);
+            {
+                auto settings = TDescribeTableSettings().WithTableStatistics(true);
+                auto describeResult = testHelper.GetSession().DescribeTable("/Root/ColumnTableTest", settings).GetValueSync();
+                UNIT_ASSERT_C(describeResult.IsSuccess(), describeResult.GetIssues().ToString());
+
+                const auto& description = describeResult.GetTableDescription();
+                auto columns = description.GetTableColumns();
+                UNIT_ASSERT_VALUES_EQUAL(columns.size(), 4);
+            }
+
+            testHelper.ReadData("SELECT * FROM `/Root/ColumnTableTest` WHERE id=1", "[[1;#;#;[\"test_res_1\"]]]");
+            testHelper.ReadData("SELECT new_column FROM `/Root/ColumnTableTest` WHERE id=1", "[[#]]");
+            testHelper.ReadData("SELECT resource_id FROM `/Root/ColumnTableTest` WHERE id=1", "[[[\"test_res_1\"]]]");
+            Tests::NCommon::TLoggerInit(testHelper.GetKikimr()).Initialize();
+            {
+                TTestHelper::TUpdatesBuilder tableInserter(testTable.GetArrowSchema(schema));
+                tableInserter.AddRow().Add(3).Add("test_res_3").Add(123).Add<uint64_t>(200);
+                testHelper.BulkUpsert(testTable, tableInserter);
+            }
+
+            testHelper.ReadData("SELECT * FROM `/Root/ColumnTableTest` WHERE id=3", "[[3;[123];[200u];[\"test_res_3\"]]]");
+            testHelper.ReadData("SELECT * FROM `/Root/ColumnTableTest` WHERE new_column=200", "[[3;[123];[200u];[\"test_res_3\"]]]");
+            testHelper.ReadData("SELECT new_column FROM `/Root/ColumnTableTest` WHERE id=3", "[[[200u]]]");
+            testHelper.ReadData("SELECT resource_id FROM `/Root/ColumnTableTest` WHERE id=3", "[[[\"test_res_3\"]]]");
+            testHelper.ReadData("SELECT new_column FROM `/Root/ColumnTableTest`", "[[#];[#];[[200u]]]");
         }
+    };
+
+    Y_UNIT_TEST(AddColumn) {
+        TestAddColumn("PLAIN").Run();
+    }
 
-        testHelper.ReadData("SELECT * FROM `/Root/ColumnTableTest` WHERE id=3", "[[3;[123];[200u];[\"test_res_3\"]]]");
-        testHelper.ReadData("SELECT * FROM `/Root/ColumnTableTest` WHERE new_column=200", "[[3;[123];[200u];[\"test_res_3\"]]]");
-        testHelper.ReadData("SELECT new_column FROM `/Root/ColumnTableTest` WHERE id=3", "[[[200u]]]");
-        testHelper.ReadData("SELECT resource_id FROM `/Root/ColumnTableTest` WHERE id=3", "[[[\"test_res_3\"]]]");
-        testHelper.ReadData("SELECT new_column FROM `/Root/ColumnTableTest`", "[[#];[#];[[200u]]]");
+    Y_UNIT_TEST(AddColumnSimpleReader) {
+        TestAddColumn("SIMPLE").Run();
     }
 
     Y_UNIT_TEST(AddColumnOldSchemeBulkUpsert) {
diff --git a/ydb/core/kqp/ut/service/kqp_qs_queries_ut.cpp b/ydb/core/kqp/ut/service/kqp_qs_queries_ut.cpp
index bafe07a6c55f..0a6c7ca571e5 100644
--- a/ydb/core/kqp/ut/service/kqp_qs_queries_ut.cpp
+++ b/ydb/core/kqp/ut/service/kqp_qs_queries_ut.cpp
@@ -3420,9 +3420,10 @@ Y_UNIT_TEST_SUITE(KqpQueryService) {
         }
     }
 
-    Y_UNIT_TEST(SeveralCTAS) {
+    Y_UNIT_TEST_TWIN(SeveralCTAS, UseSink) {
         NKikimrConfig::TAppConfig appConfig;
         appConfig.MutableTableServiceConfig()->SetEnableAstCache(true);
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         appConfig.MutableTableServiceConfig()->SetEnableOlapSink(true);
         appConfig.MutableTableServiceConfig()->SetEnableCreateTableAs(true);
         appConfig.MutableTableServiceConfig()->SetEnablePerStatementQueryExecution(true);
@@ -3447,19 +3448,12 @@ Y_UNIT_TEST_SUITE(KqpQueryService) {
                 CREATE TABLE Table3 (
                     PRIMARY KEY (Key)
                 ) AS SELECT * FROM Table2 UNION ALL SELECT * FROM Table1;
-                SELECT * FROM Table1 ORDER BY Key;
-                SELECT * FROM Table2 ORDER BY Key;
-                SELECT * FROM Table3 ORDER BY Key;
             )", TTxControl::NoTx(), TExecuteQuerySettings()).ExtractValueSync();
             UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
-            UNIT_ASSERT_VALUES_EQUAL(result.GetResultSets().size(), 3);
-            // Results are empty. Snapshot was taken before tables were created, so we don't see changes after snapshot.
-            // This will be fixed in future, for example, by implicit commit before/after each ddl statement.
-            CompareYson(R"([])", FormatResultSetYson(result.GetResultSet(0)));
-            CompareYson(R"([])", FormatResultSetYson(result.GetResultSet(1)));
-            CompareYson(R"([])", FormatResultSetYson(result.GetResultSet(2)));
+        }
 
-            result = db.ExecuteQuery(R"(
+        {
+            auto result = db.ExecuteQuery(R"(
                 SELECT * FROM Table1 ORDER BY Key;
                 SELECT * FROM Table2 ORDER BY Key;
                 SELECT * FROM Table3 ORDER BY Key;
@@ -4629,7 +4623,8 @@ Y_UNIT_TEST_SUITE(KqpQueryService) {
                 UNIT_ASSERT_C(!it.IsSuccess(), it.GetIssues().ToString());
                 UNIT_ASSERT_C(
                     it.GetIssues().ToString().contains("Operation is aborting because an duplicate key")
-                    || it.GetIssues().ToString().contains("Conflict with existing key."),
+                    || it.GetIssues().ToString().contains("Conflict with existing key.")
+                    || it.GetIssues().ToString().contains("Duplicate keys have been found."),
                     it.GetIssues().ToString());
             }
 
@@ -4812,6 +4807,47 @@ Y_UNIT_TEST_SUITE(KqpQueryService) {
         tester.Execute();
     }
 
+    class TSinkOrderTester: public TTableDataModificationTester {
+    protected:
+        void DoExecute() override {
+            auto client = Kikimr->GetQueryClient();
+
+            for (size_t index = 0; index < 100; ++index) {
+                auto session = client.GetSession().GetValueSync().GetSession();
+
+                auto result = session.ExecuteQuery(fmt::format(R"(
+                    UPSERT INTO `/Root/DataShard` (Col1, Col2) VALUES ({}u, 0);
+                )", index), NYdb::NQuery::TTxControl::BeginTx(NYdb::NQuery::TTxSettings::SerializableRW())).ExtractValueSync();
+                UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::SUCCESS, result.GetIssues().ToString());
+
+                auto tx = result.GetTransaction();
+                UNIT_ASSERT(tx);
+
+                result = session.ExecuteQuery(fmt::format(R"(
+                    INSERT INTO `/Root/DataShard` (Col1, Col2) VALUES ({}u, 0);
+                )", index), NYdb::NQuery::TTxControl::Tx(tx->GetId()).CommitTx()).ExtractValueSync();
+                if (GetIsOlap()) {
+                    // https://github.com/ydb-platform/ydb/issues/14383
+                    UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::BAD_REQUEST, result.GetIssues().ToString());
+                } else {
+                    UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());
+                }
+            }
+        }
+    };
+
+    Y_UNIT_TEST(TableSink_OltpOrder) {
+        TSinkOrderTester tester;
+        tester.SetIsOlap(false);
+        tester.Execute();
+    }
+
+    Y_UNIT_TEST(TableSink_OlapOrder) {
+        TSinkOrderTester tester;
+        tester.SetIsOlap(true);
+        tester.Execute();
+    }
+
     Y_UNIT_TEST(TableSink_ReplaceDuplicatesOlap) {
         NKikimrConfig::TAppConfig appConfig;
         appConfig.MutableTableServiceConfig()->SetEnableOlapSink(true);
diff --git a/ydb/core/kqp/ut/tx/kqp_locks_ut.cpp b/ydb/core/kqp/ut/tx/kqp_locks_ut.cpp
index 735e4f85353a..c25a63f26d74 100644
--- a/ydb/core/kqp/ut/tx/kqp_locks_ut.cpp
+++ b/ydb/core/kqp/ut/tx/kqp_locks_ut.cpp
@@ -241,8 +241,9 @@ Y_UNIT_TEST_SUITE(KqpLocks) {
             }), commitResult.GetIssues().ToString());
     }
 
-    Y_UNIT_TEST(MixedTxFail) {
+    Y_UNIT_TEST_TWIN(MixedTxFail, useSink) {
         NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);
         appConfig.MutableTableServiceConfig()->SetEnableOlapSink(true);
         appConfig.MutableTableServiceConfig()->SetEnableHtapTx(true);
         auto settings = TKikimrSettings().SetAppConfig(appConfig).SetWithSampleTables(false);
diff --git a/ydb/core/kqp/ut/tx/kqp_sink_tx_ut.cpp b/ydb/core/kqp/ut/tx/kqp_sink_tx_ut.cpp
index 085bbf6f12ec..39ddfeb98349 100644
--- a/ydb/core/kqp/ut/tx/kqp_sink_tx_ut.cpp
+++ b/ydb/core/kqp/ut/tx/kqp_sink_tx_ut.cpp
@@ -177,7 +177,6 @@ Y_UNIT_TEST_SUITE(KqpSinkTx) {
 
             auto result = session.ExecuteQuery(Q_(R"(
                 INSERT INTO `/Root/KV` (Key, Value) VALUES (1u, "New");
-                SELECT COUNT(*) FROM `/Root/KV`;
             )"), TTxControl::Tx(tx.GetId())).ExtractValueSync();
             result.GetIssues().PrintTo(Cerr);
             UNIT_ASSERT_VALUES_EQUAL_C(result.GetStatus(), EStatus::PRECONDITION_FAILED, result.GetIssues().ToString());
diff --git a/ydb/core/kqp/ut/tx/kqp_tx_ut.cpp b/ydb/core/kqp/ut/tx/kqp_tx_ut.cpp
index 0976bbadcda3..401e5b17e0eb 100644
--- a/ydb/core/kqp/ut/tx/kqp_tx_ut.cpp
+++ b/ydb/core/kqp/ut/tx/kqp_tx_ut.cpp
@@ -82,7 +82,10 @@ Y_UNIT_TEST_SUITE(KqpTx) {
     }
 
     Y_UNIT_TEST(LocksAbortOnCommit) {
-        auto kikimr = DefaultKikimrRunner();
+        NKikimrConfig::TAppConfig app;
+        // See KqpSinkTx::LocksAbortOnCommit for sink version of this test
+        app.MutableTableServiceConfig()->SetEnableOltpSink(false);
+        auto kikimr = DefaultKikimrRunner({}, app);
         auto db = kikimr.GetTableClient();
         auto session = db.CreateSession().GetValueSync().GetSession();
         {
diff --git a/ydb/core/kqp/ut/yql/kqp_yql_ut.cpp b/ydb/core/kqp/ut/yql/kqp_yql_ut.cpp
index 9bebac0c3786..a3d38fb8c7c5 100644
--- a/ydb/core/kqp/ut/yql/kqp_yql_ut.cpp
+++ b/ydb/core/kqp/ut/yql/kqp_yql_ut.cpp
@@ -202,8 +202,10 @@ Y_UNIT_TEST_SUITE(KqpYql) {
         UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::DEFAULT_ERROR));
     }
 
-    Y_UNIT_TEST(InsertCV) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_TWIN(InsertCV, useSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);
+        auto kikimr = DefaultKikimrRunner({}, appConfig);
         TScriptingClient client(kikimr.GetDriver());
 
         auto result = client.ExecuteYqlScript(R"(
@@ -217,8 +219,10 @@ Y_UNIT_TEST_SUITE(KqpYql) {
         UNIT_ASSERT(HasIssue(result.GetIssues(), NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION));
     }
 
-    Y_UNIT_TEST(InsertCVList) {
-        auto kikimr = DefaultKikimrRunner();
+    Y_UNIT_TEST_TWIN(InsertCVList, useSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);
+        auto kikimr = DefaultKikimrRunner({}, appConfig);
         TScriptingClient client(kikimr.GetDriver());
 
         auto result = client.ExecuteYqlScript(R"(
diff --git a/ydb/core/protos/data_events.proto b/ydb/core/protos/data_events.proto
index 2dfe758f0675..cc505d86a9f6 100644
--- a/ydb/core/protos/data_events.proto
+++ b/ydb/core/protos/data_events.proto
@@ -139,6 +139,7 @@ message TEvWriteResult {
         STATUS_DISK_SPACE_EXHAUSTED = 10;
         STATUS_WRONG_SHARD_STATE = 11;
         STATUS_CONSTRAINT_VIOLATION = 12;
+        STATUS_OUT_OF_SPACE = 13;
     }
 
     // Status
diff --git a/ydb/core/protos/feature_flags.proto b/ydb/core/protos/feature_flags.proto
index f9832ddd78bc..417af4ae787d 100644
--- a/ydb/core/protos/feature_flags.proto
+++ b/ydb/core/protos/feature_flags.proto
@@ -197,4 +197,5 @@ message TFeatureFlags {
     optional bool EnablePermissionsExport = 171 [default = false];
     optional bool EnableDataErasure = 172 [default = false];
     optional bool EnableChangefeedsExport = 174 [default = false];
+    optional bool EnableAlterDatabase = 182 [default = false];
 }
diff --git a/ydb/core/protos/flat_scheme_op.proto b/ydb/core/protos/flat_scheme_op.proto
index 30f0cd1b00c4..ec5b30e751df 100644
--- a/ydb/core/protos/flat_scheme_op.proto
+++ b/ydb/core/protos/flat_scheme_op.proto
@@ -430,6 +430,7 @@ message TRequestedBloomNGrammFilter {
     optional uint32 RecordsCount = 5;
     optional TIndexDataExtractor DataExtractor = 6;
     optional TSkipIndexBitSetStorage BitsStorage = 7;
+    optional bool CaseSensitive = 8 [default = true];
 }
 
 message TRequestedMaxIndex {
@@ -471,6 +472,7 @@ message TBloomNGrammFilter {
     optional uint32 RecordsCount = 5;
     optional TIndexDataExtractor DataExtractor = 6;
     optional TSkipIndexBitSetStorage BitsStorage = 7;
+    optional bool CaseSensitive = 8 [default = true];
 }
 
 message TMaxIndex {
@@ -522,6 +524,7 @@ message TCompactionLevelConstructorContainer {
         optional uint32 PortionsLiveDurationSeconds = 1;
         optional uint64 ExpectedBlobsSize = 2;
         optional uint64 PortionsCountAvailable = 3;
+        optional uint64 PortionsCountLimit = 4;
     }
 
     oneof Implementation {
@@ -1526,6 +1529,7 @@ message TApplyIf {
     optional uint64 PathVersion = 2;
     optional uint64 LockedTxId = 3;
     optional bool CheckEntityVersion = 4 [default = false];
+    repeated EPathType PathTypes = 5;
 }
 
 message TUpgradeSubDomain {
diff --git a/ydb/core/protos/index_builder.proto b/ydb/core/protos/index_builder.proto
index c148577ddeeb..08913a88548c 100644
--- a/ydb/core/protos/index_builder.proto
+++ b/ydb/core/protos/index_builder.proto
@@ -28,7 +28,7 @@ message TIndexBuildSettings {
     optional bool pg_mode = 8 [ default = false];
     optional bool if_not_exist = 9 [ default = false];
 
-    optional uint32 max_batch_rows = 3 [ default = 500 ];
+    optional uint32 max_batch_rows = 3 [ default = 50000 ];
     optional uint64 max_batch_bytes = 4 [ default = 8388608 ];
     optional uint32 max_shards_in_flight = 5 [ default = 32 ];
     optional uint32 max_retries_upload_batch = 6 [ default = 50 ];
diff --git a/ydb/core/protos/kqp.proto b/ydb/core/protos/kqp.proto
index 46dee8ed2fd4..5f1a445ef915 100644
--- a/ydb/core/protos/kqp.proto
+++ b/ydb/core/protos/kqp.proto
@@ -639,7 +639,8 @@ message TEvScanInitActor {
     optional NActorsProto.TActorId ScanActorId = 2;
     optional uint32 Generation = 3;
     optional uint64 TabletId = 4;
-};
+    optional bool AllowPings = 5;
+}
 
 message TEvScanError {
     optional Ydb.StatusIds.StatusCode Status = 1;
@@ -648,16 +649,26 @@ message TEvScanError {
     optional uint64 TabletId = 4;
 }
 
+message TEvScanPing {
+}
+
 message TEvKqpScanCursor {
+    optional uint64 TabletId = 1;
+
     message TColumnShardScanPlain {
     }
     message TColumnShardScanSimple {
         optional uint64 SourceId = 1;
         optional uint32 StartRecordIndex = 2;
     }
+    message TColumnShardScanNotSortedSimple {
+        optional uint64 SourceId = 1;
+        optional uint32 StartRecordIndex = 2;
+    }
     oneof Implementation {
         TColumnShardScanPlain ColumnShardPlain = 10;
         TColumnShardScanSimple ColumnShardSimple = 11;
+        TColumnShardScanNotSortedSimple ColumnShardNotSortedSimple = 12;
     }
 }
 
diff --git a/ydb/core/protos/table_service_config.proto b/ydb/core/protos/table_service_config.proto
index f631f2fd9187..376c0b3b308c 100644
--- a/ydb/core/protos/table_service_config.proto
+++ b/ydb/core/protos/table_service_config.proto
@@ -44,7 +44,7 @@ message TTableServiceConfig {
         optional uint64 KqpPatternCacheCompiledCapacityBytes = 21 [default = 104857600]; // 100 MiB
         optional double SpillingPercent = 22 [default = 80]; // 100 MiB
 
-        optional uint64 MinMemAllocSize = 23 [default = 8388608]; // 8 MiB
+        optional uint64 MinMemAllocSize = 23 [default = 1048576]; // 1 MiB
         optional uint64 MinMemFreeSize = 24  [default = 33554432]; // 32 MiB
 
         optional uint64 MaxNonParallelTasksExecutionLimit = 25 [default = 8];
@@ -84,6 +84,10 @@ message TTableServiceConfig {
         optional uint64 TotalReadSizeLimitBytes = 4;
     }
 
+    message TTxWriteBufferLimits {
+        optional uint64 WriteBufferMemoryLimitBytes = 1;
+    }
+
     message TQueryLimits {
         optional TQueryPhaseLimits PhaseLimits = 1;
         optional uint32 SchemeQueryTimeoutMs = 2 [default = 600000];
@@ -91,6 +95,7 @@ message TTableServiceConfig {
         optional uint32 ScanQueryTimeoutMs = 4 [default = 600000];
         optional uint32 ResultRowsLimit = 5;
         optional uint32 WaitCAStatsTimeoutMs = 6 [default = 1000];
+        optional TTxWriteBufferLimits BufferLimits = 7;
     }
 
     message TShutdownSettings {
@@ -293,7 +298,7 @@ message TTableServiceConfig {
     optional uint64 IdxLookupJoinPointsLimit = 58 [default = 3];
     reserved 59; //optional bool OldLookupJoinBehaviour = 59 [default = false];
 
-    optional bool EnableOltpSink = 60 [default = false];
+    optional bool EnableOltpSink = 60 [default = true];
 
     enum EBlockChannelsMode {
         BLOCK_CHANNELS_SCALAR = 0;
@@ -330,7 +335,6 @@ message TTableServiceConfig {
     message TWriteActorSettings {
         optional uint64 InFlightMemoryLimitPerActorBytes = 1 [ default = 67108864 ];
         optional uint64 MemoryLimitPerMessageBytes = 2 [ default = 67108864 ];
-        optional uint64 MaxBatchesPerMessage = 3 [ default = 1000 ];
 
         optional uint64 StartRetryDelayMs = 4 [ default = 1000 ];
         optional uint64 MaxRetryDelayMs = 5 [ default = 10000 ];
diff --git a/ydb/core/protos/tx_datashard.proto b/ydb/core/protos/tx_datashard.proto
index 708492d91dca..518f19f63803 100644
--- a/ydb/core/protos/tx_datashard.proto
+++ b/ydb/core/protos/tx_datashard.proto
@@ -214,6 +214,7 @@ message TKqpTransaction {
         // Type of read result: unboxed values or Arrow blocks of data
         optional EReadType ReadType = 14;
         repeated string GroupByColumnNames = 15;
+        optional uint32 OptionalSorting = 16;
     }
 
     optional EKqpTransactionType Type = 1;
@@ -263,6 +264,7 @@ message TKqpReadRangesSourceSettings {
     repeated TKqpTransaction.TColumnMeta DuplicateCheckColumns = 19;
 
     optional NKikimrDataEvents.ELockMode LockMode = 20;
+    optional uint32 OptionalSorting = 21;
 }
 
 message TKqpTaskInfo {
@@ -1632,6 +1634,54 @@ message TEvReshuffleKMeansResponse {
     // optional last written primary key
 }
 
+message TEvPrefixKMeansRequest {
+    optional uint64 Id = 1;
+
+    optional uint64 TabletId = 2;
+    optional NKikimrProto.TPathID PathId = 3;
+
+    optional uint64 SeqNoGeneration = 4;
+    optional uint64 SeqNoRound = 5;
+
+    optional Ydb.Table.VectorIndexSettings Settings = 6;
+
+    optional uint64 Seed = 7;
+
+    optional TEvLocalKMeansRequest.EState Upload = 8;
+
+    optional uint32 K = 9;
+    optional uint32 NeedsRounds = 10;
+
+    // [Child ... Child + (1 + TableSize) * ShardIndex]
+    optional uint64 Child = 11;
+
+    optional string LevelName = 12;
+    optional string PostingName = 13;
+    optional string PrefixName = 14;
+
+    optional string EmbeddingColumn = 15;
+    repeated string DataColumns = 16;
+    optional uint32 PrefixColumns = 17;
+}
+
+message TEvPrefixKMeansResponse {
+    optional uint64 Id = 1;
+
+    optional uint64 TabletId = 2;
+    optional NKikimrProto.TPathID PathId = 3;
+
+    optional uint64 RequestSeqNoGeneration = 4;
+    optional uint64 RequestSeqNoRound = 5;
+
+    optional NKikimrIndexBuilder.EBuildStatus Status = 6;
+    repeated Ydb.Issue.IssueMessage Issues = 7;
+
+    optional uint64 UploadRows = 8;
+    optional uint64 UploadBytes = 9;
+    optional uint64 ReadRows = 10;
+    optional uint64 ReadBytes = 11;
+}
+
 message TEvCdcStreamScanRequest {
     message TLimits {
         optional uint32 BatchMaxBytes = 1 [default = 512000];
diff --git a/ydb/core/scheme/scheme_tablecell.cpp b/ydb/core/scheme/scheme_tablecell.cpp
index 4369b9058964..c376e61eb83f 100644
--- a/ydb/core/scheme/scheme_tablecell.cpp
+++ b/ydb/core/scheme/scheme_tablecell.cpp
@@ -617,6 +617,10 @@ TOwnedCellVecBatch::TOwnedCellVecBatch()
     : Pool(std::make_unique<TMemoryPool>(InitialPoolSize)) {
 }
 
+TOwnedCellVecBatch::TOwnedCellVecBatch(std::unique_ptr<TMemoryPool> pool)
+    : Pool(std::move(pool)) {
+}
+
 size_t TOwnedCellVecBatch::Append(TConstArrayRef<TCell> cells) {
     size_t cellsSize = cells.size();
     if (cellsSize == 0) {
diff --git a/ydb/core/scheme/scheme_tablecell.h b/ydb/core/scheme/scheme_tablecell.h
index a40fb60beb75..9d56525dd2d6 100644
--- a/ydb/core/scheme/scheme_tablecell.h
+++ b/ydb/core/scheme/scheme_tablecell.h
@@ -848,11 +848,13 @@ class TOwnedCellVecBatch {
 public:
     TOwnedCellVecBatch();
 
+    TOwnedCellVecBatch(std::unique_ptr<TMemoryPool> pool);
+
     TOwnedCellVecBatch(const TOwnedCellVecBatch& rhs) = delete;
 
     TOwnedCellVecBatch & operator=(const TOwnedCellVecBatch& rhs) = delete;
 
-    TOwnedCellVecBatch(const TOwnedCellVecBatch&& rhs) = default;
+    TOwnedCellVecBatch(TOwnedCellVecBatch&& rhs) = default;
 
     TOwnedCellVecBatch & operator=(TOwnedCellVecBatch&& rhs) = default;
 
@@ -881,6 +883,14 @@ class TOwnedCellVecBatch {
         return CellVectors.end();
     }
 
+    const_iterator begin() const {
+        return CellVectors.begin();
+    }
+
+    const_iterator end() const {
+        return CellVectors.end();
+    }
+
     const_iterator cbegin() {
         return CellVectors.cbegin();
     }
diff --git a/ydb/core/tx/columnshard/blob_cache.cpp b/ydb/core/tx/columnshard/blob_cache.cpp
index f404a25536b1..391f57535cf2 100644
--- a/ydb/core/tx/columnshard/blob_cache.cpp
+++ b/ydb/core/tx/columnshard/blob_cache.cpp
@@ -237,7 +237,7 @@ class TBlobCache: public TActorBootstrapped<TBlobCache> {
         if (it != Cache.End()) {
             Hits->Inc();
             HitsBytes->Add(blobRange.Size);
-            SendResult(sender, blobRange, NKikimrProto::OK, it.Value(), ctx, true);
+            SendResult(sender, blobRange, NKikimrProto::OK, it.Value(),  {}, ctx, true);
             return true;
         }
 
@@ -423,10 +423,10 @@ class TBlobCache: public TActorBootstrapped<TBlobCache> {
     }
 
     void SendResult(const TActorId& to, const TBlobRange& blobRange, NKikimrProto::EReplyStatus status,
-                    const TString& data, const TActorContext& ctx, const bool fromCache = false) {
+                    const TString& data, const TString& detailedError, const TActorContext& ctx, const bool fromCache = false) {
         LOG_S_DEBUG("Send result: " << blobRange << " to: " << to << " status: " << status);
 
-        ctx.Send(to, new TEvBlobCache::TEvReadBlobRangeResult(blobRange, status, data, fromCache));
+        ctx.Send(to, new TEvBlobCache::TEvReadBlobRangeResult(blobRange, status, data, detailedError, fromCache));
     }
 
     void Handle(TEvBlobStorage::TEvGetResult::TPtr& ev, const TActorContext& ctx) {
@@ -436,7 +436,9 @@ class TBlobCache: public TActorBootstrapped<TBlobCache> {
             Y_ABORT("Unexpected reply from blobstorage");
         }
 
+        TString detailedError;
         if (ev->Get()->Status != NKikimrProto::EReplyStatus::OK) {
+            detailedError = ev->Get()->ToString();
             AFL_WARN(NKikimrServices::BLOB_CACHE)("fail", ev->Get()->ToString());
             ReadSimpleFailedBytes->Add(ev->Get()->ResponseSz);
             ReadSimpleFailedCount->Add(1);
@@ -458,14 +460,14 @@ class TBlobCache: public TActorBootstrapped<TBlobCache> {
 
         for (size_t i = 0; i < ev->Get()->ResponseSz; ++i) {
             const auto& res = ev->Get()->Responses[i];
-            ProcessSingleRangeResult(blobRanges[i], readCookie, res.Status, res.Buffer.ConvertToString(), ctx);
+            ProcessSingleRangeResult(blobRanges[i], readCookie, res.Status, res.Buffer.ConvertToString(), detailedError, ctx);
         }
 
         MakeReadRequests(ctx);
     }
 
     void ProcessSingleRangeResult(const TBlobRange& blobRange, const ui64 readCookie,
-        ui32 status, const TString& data, const TActorContext& ctx) noexcept
+        ui32 status, const TString& data, const TString& detailedError, const TActorContext& ctx) noexcept
     {
         AFL_DEBUG(NKikimrServices::BLOB_CACHE)("ProcessSingleRangeResult", blobRange);
         auto readIt = OutstandingReads.find(blobRange);
@@ -500,7 +502,7 @@ class TBlobCache: public TActorBootstrapped<TBlobCache> {
         AFL_DEBUG(NKikimrServices::BLOB_CACHE)("ProcessSingleRangeResult", blobRange)("send_replies", readIt->second.Waiting.size());
         // Send results to all waiters
         for (const auto& to : readIt->second.Waiting) {
-            SendResult(to, blobRange, (NKikimrProto::EReplyStatus)status, data, ctx);
+            SendResult(to, blobRange, (NKikimrProto::EReplyStatus)status, data, detailedError, ctx);
         }
 
         OutstandingReads.erase(readIt);
@@ -525,7 +527,7 @@ class TBlobCache: public TActorBootstrapped<TBlobCache> {
 
             for (size_t i = 0; i < blobRanges.size(); ++i) {
                 Y_ABORT_UNLESS(blobRanges[i].BlobId.GetTabletId() == tabletId);
-                ProcessSingleRangeResult(blobRanges[i], readCookie, NKikimrProto::EReplyStatus::NOTREADY, {}, ctx);
+                ProcessSingleRangeResult(blobRanges[i], readCookie, NKikimrProto::EReplyStatus::NOTREADY, {}, {}, ctx);
             }
         }
 
diff --git a/ydb/core/tx/columnshard/blob_cache.h b/ydb/core/tx/columnshard/blob_cache.h
index 75e0ccf0a677..61aa6edcf9e0 100644
--- a/ydb/core/tx/columnshard/blob_cache.h
+++ b/ydb/core/tx/columnshard/blob_cache.h
@@ -72,14 +72,16 @@ struct TEvBlobCache {
         TBlobRange BlobRange;
         NKikimrProto::EReplyStatus Status;
         TString Data;
+        TString DetailedError;
         const bool FromCache = false;
         const TInstant ConstructTime = Now();
         const TString DataSourceId;
 
-        TEvReadBlobRangeResult(const TBlobRange& blobRange, NKikimrProto::EReplyStatus status, const TString& data, const bool fromCache = false, const TString& dataSourceId = Default<TString>())
+        TEvReadBlobRangeResult(const TBlobRange& blobRange, NKikimrProto::EReplyStatus status, const TString& data, const TString& detailedError, const bool fromCache = false, const TString& dataSourceId = Default<TString>())
             : BlobRange(blobRange)
             , Status(status)
             , Data(data)
+            , DetailedError(detailedError)
             , FromCache(fromCache)
             , DataSourceId(dataSourceId)
         {}
diff --git a/ydb/core/tx/columnshard/blobs_action/counters/read.h b/ydb/core/tx/columnshard/blobs_action/counters/read.h
index d0e8f736f5b4..e081062c5ec0 100644
--- a/ydb/core/tx/columnshard/blobs_action/counters/read.h
+++ b/ydb/core/tx/columnshard/blobs_action/counters/read.h
@@ -1,6 +1,6 @@
 #pragma once
 #include <library/cpp/monlib/dynamic_counters/counters.h>
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 
 namespace NKikimr::NOlap::NBlobOperations {
 
diff --git a/ydb/core/tx/columnshard/blobs_action/counters/remove_declare.h b/ydb/core/tx/columnshard/blobs_action/counters/remove_declare.h
index 4e11a6c68f40..e89f66a784ff 100644
--- a/ydb/core/tx/columnshard/blobs_action/counters/remove_declare.h
+++ b/ydb/core/tx/columnshard/blobs_action/counters/remove_declare.h
@@ -1,6 +1,6 @@
 #pragma once
 #include <library/cpp/monlib/dynamic_counters/counters.h>
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 
 namespace NKikimr::NOlap::NBlobOperations {
 
diff --git a/ydb/core/tx/columnshard/blobs_action/counters/remove_gc.h b/ydb/core/tx/columnshard/blobs_action/counters/remove_gc.h
index f74f7f353f7b..210d730578ef 100644
--- a/ydb/core/tx/columnshard/blobs_action/counters/remove_gc.h
+++ b/ydb/core/tx/columnshard/blobs_action/counters/remove_gc.h
@@ -1,5 +1,5 @@
 #pragma once
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 
 #include <library/cpp/monlib/dynamic_counters/counters.h>
 
diff --git a/ydb/core/tx/columnshard/blobs_action/counters/storage.h b/ydb/core/tx/columnshard/blobs_action/counters/storage.h
index f2ded5d3556f..94b66e47e7c8 100644
--- a/ydb/core/tx/columnshard/blobs_action/counters/storage.h
+++ b/ydb/core/tx/columnshard/blobs_action/counters/storage.h
@@ -4,7 +4,7 @@
 #include "remove_gc.h"
 #include "write.h"
 
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 
 #include <library/cpp/monlib/dynamic_counters/counters.h>
 #include <util/generic/hash.h>
diff --git a/ydb/core/tx/columnshard/blobs_action/counters/write.h b/ydb/core/tx/columnshard/blobs_action/counters/write.h
index a9b7f0282817..91576426ccd5 100644
--- a/ydb/core/tx/columnshard/blobs_action/counters/write.h
+++ b/ydb/core/tx/columnshard/blobs_action/counters/write.h
@@ -1,6 +1,6 @@
 #pragma once
 #include <library/cpp/monlib/dynamic_counters/counters.h>
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 
 namespace NKikimr::NOlap::NBlobOperations {
 
diff --git a/ydb/core/tx/columnshard/blobs_action/tier/adapter.cpp b/ydb/core/tx/columnshard/blobs_action/tier/adapter.cpp
index d0136aa98388..8d42d230ee06 100644
--- a/ydb/core/tx/columnshard/blobs_action/tier/adapter.cpp
+++ b/ydb/core/tx/columnshard/blobs_action/tier/adapter.cpp
@@ -16,11 +16,11 @@ std::unique_ptr<NActors::IEventBase> TRepliesAdapter::RebuildReplyEvent(std::uni
     }
     if (ev->IsSuccess()) {
         AFL_VERIFY(!!ev->Body)("key", ev->Key)("interval_from", ev->GetReadInterval().first)("interval_to", ev->GetReadInterval().second);
-        return std::make_unique<NBlobCache::TEvBlobCache::TEvReadBlobRangeResult>(bRange, NKikimrProto::EReplyStatus::OK, ev->Body, false, StorageId);
+        return std::make_unique<NBlobCache::TEvBlobCache::TEvReadBlobRangeResult>(bRange, NKikimrProto::EReplyStatus::OK, ev->Body, TString{}, false, StorageId);
     } else {
         AFL_DEBUG(NKikimrServices::TX_TIERING)("event", "s3_request_failed")("request_type", "get_object")(
             "exception", ev->GetError().GetExceptionName())("message", ev->GetError().GetMessage())("storage_id", StorageId)("blob", logoBlobId);
-        return std::make_unique<NBlobCache::TEvBlobCache::TEvReadBlobRangeResult>(bRange, NKikimrProto::EReplyStatus::ERROR, TStringBuilder() << ev->Result, false, StorageId);
+        return std::make_unique<NBlobCache::TEvBlobCache::TEvReadBlobRangeResult>(bRange, NKikimrProto::EReplyStatus::ERROR, TStringBuilder() << ev->Result, TStringBuilder{} << ev->GetError().GetExceptionName() << ", " << ev->GetError().GetMessage(), false, StorageId);
     }
 }
 
diff --git a/ydb/core/tx/columnshard/blobs_action/transaction/tx_blobs_written.cpp b/ydb/core/tx/columnshard/blobs_action/transaction/tx_blobs_written.cpp
index 6c730e7f4ea0..e0c5ab30a6b9 100644
--- a/ydb/core/tx/columnshard/blobs_action/transaction/tx_blobs_written.cpp
+++ b/ydb/core/tx/columnshard/blobs_action/transaction/tx_blobs_written.cpp
@@ -1,7 +1,7 @@
-#include <ydb/core/tx/columnshard/common/path_id.h>
 #include "tx_blobs_written.h"
 
 #include <ydb/core/tx/columnshard/blob_cache.h>
+#include <ydb/core/tx/columnshard/common/path_id.h>
 #include <ydb/core/tx/columnshard/engines/column_engine_logs.h>
 #include <ydb/core/tx/columnshard/engines/insert_table/user_data.h>
 #include <ydb/core/tx/columnshard/transactions/locks/write.h>
@@ -97,10 +97,11 @@ void TTxBlobsWritingFinished::DoComplete(const TActorContext& ctx) {
     }
     std::set<TInternalPathId> pathIds;
     for (auto&& writeResult : Pack.GetWriteResults()) {
+        const auto& writeMeta = writeResult.GetWriteMeta();
+        writeMeta.OnStage(NEvWrite::EWriteStage::Replied);
         if (writeResult.GetNoDataToWrite()) {
             continue;
         }
-        const auto& writeMeta = writeResult.GetWriteMeta();
         auto op = Self->GetOperationsManager().GetOperationVerified((TOperationWriteId)writeMeta.GetWriteId());
         pathIds.emplace(op->GetPathId());
         if (op->GetBehaviour() == EOperationBehaviour::WriteWithLock || op->GetBehaviour() == EOperationBehaviour::NoTxWrite) {
@@ -146,13 +147,16 @@ TTxBlobsWritingFinished::TTxBlobsWritingFinished(TColumnShard* self, const NKiki
 bool TTxBlobsWritingFailed::DoExecute(TTransactionContext& txc, const TActorContext& /* ctx */) {
     for (auto&& wResult : Pack.GetWriteResults()) {
         const auto& writeMeta = wResult.GetWriteMeta();
+        writeMeta.OnStage(NEvWrite::EWriteStage::Replied);
         AFL_VERIFY(!writeMeta.HasLongTxId());
         auto op = Self->GetOperationsManager().GetOperationVerified((TOperationWriteId)writeMeta.GetWriteId());
         Self->OperationsManager->AddTemporaryTxLink(op->GetLockId());
         Self->OperationsManager->AbortTransactionOnExecute(*Self, op->GetLockId(), txc);
 
         auto ev = NEvents::TDataEvents::TEvWriteResult::BuildError(Self->TabletID(), op->GetLockId(),
-            NKikimrDataEvents::TEvWriteResult::STATUS_INTERNAL_ERROR, "cannot write blob: " + ::ToString(PutBlobResult));
+            wResult.IsInternalError() ? NKikimrDataEvents::TEvWriteResult::STATUS_INTERNAL_ERROR
+                                      : NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST,
+            wResult.GetErrorMessage());
         Results.emplace_back(std::move(ev), writeMeta.GetSource(), op->GetCookie());
     }
     return true;
diff --git a/ydb/core/tx/columnshard/blobs_action/transaction/tx_blobs_written.h b/ydb/core/tx/columnshard/blobs_action/transaction/tx_blobs_written.h
index 6bb3549b20d4..738ca1e01675 100644
--- a/ydb/core/tx/columnshard/blobs_action/transaction/tx_blobs_written.h
+++ b/ydb/core/tx/columnshard/blobs_action/transaction/tx_blobs_written.h
@@ -55,7 +55,6 @@ class TTxBlobsWritingFinished: public TExtendedTransactionBase {
 class TTxBlobsWritingFailed: public TExtendedTransactionBase {
 private:
     using TBase = TExtendedTransactionBase;
-    const NKikimrProto::EReplyStatus PutBlobResult;
     TInsertedPortions Pack;
 
     class TReplyInfo {
@@ -79,9 +78,8 @@ class TTxBlobsWritingFailed: public TExtendedTransactionBase {
     std::vector<TReplyInfo> Results;
 
 public:
-    TTxBlobsWritingFailed(TColumnShard* self, const NKikimrProto::EReplyStatus writeStatus, TInsertedPortions&& pack)
+    TTxBlobsWritingFailed(TColumnShard* self, TInsertedPortions&& pack)
         : TBase(self)
-        , PutBlobResult(writeStatus)
         , Pack(std::move(pack)) {
     }
 
diff --git a/ydb/core/tx/columnshard/blobs_reader/actor.cpp b/ydb/core/tx/columnshard/blobs_reader/actor.cpp
index 3d27b9d8a0e8..2121d308935f 100644
--- a/ydb/core/tx/columnshard/blobs_reader/actor.cpp
+++ b/ydb/core/tx/columnshard/blobs_reader/actor.cpp
@@ -15,7 +15,7 @@ void TActor::Handle(NBlobCache::TEvBlobCache::TEvReadBlobRangeResult::TPtr& ev)
     bool aborted = false;
     if (event.Status != NKikimrProto::EReplyStatus::OK) {
         WaitingBlobsCount.Sub(Task->GetWaitingRangesCount());
-        if (!Task->AddError(event.DataSourceId, event.BlobRange, IBlobsReadingAction::TErrorStatus::Fail(event.Status, "cannot get blob: " + event.Data.substr(0, 1024)))) {
+        if (!Task->AddError(event.DataSourceId, event.BlobRange, IBlobsReadingAction::TErrorStatus::Fail(event.Status, "cannot get blob: " + event.Data.substr(0, 1024) + ", detailed error: " + event.DetailedError))) {
             aborted = true;
         }
     } else {
diff --git a/ydb/core/tx/columnshard/blobs_reader/read_coordinator.cpp b/ydb/core/tx/columnshard/blobs_reader/read_coordinator.cpp
index df9a740d230c..207b41f00e9d 100644
--- a/ydb/core/tx/columnshard/blobs_reader/read_coordinator.cpp
+++ b/ydb/core/tx/columnshard/blobs_reader/read_coordinator.cpp
@@ -18,7 +18,7 @@ void TReadCoordinatorActor::Handle(NBlobCache::TEvBlobCache::TEvReadBlobRangeRes
     auto tasks = BlobTasks.Extract(event.DataSourceId, event.BlobRange);
     for (auto&& i : tasks) {
         if (event.Status != NKikimrProto::EReplyStatus::OK) {
-            i->AddError(event.DataSourceId, event.BlobRange, IBlobsReadingAction::TErrorStatus::Fail(event.Status, "cannot get blob"));
+            i->AddError(event.DataSourceId, event.BlobRange, IBlobsReadingAction::TErrorStatus::Fail(event.Status, "cannot get blob, detailed error: " + event.DetailedError));
         } else {
             i->AddData(event.DataSourceId, event.BlobRange, event.Data);
         }
diff --git a/ydb/core/tx/columnshard/blobs_reader/task.h b/ydb/core/tx/columnshard/blobs_reader/task.h
index 00aaa396c742..a27fa02d069e 100644
--- a/ydb/core/tx/columnshard/blobs_reader/task.h
+++ b/ydb/core/tx/columnshard/blobs_reader/task.h
@@ -3,7 +3,7 @@
 #include <ydb/library/conclusion/status.h>
 #include <ydb/core/tx/columnshard/blob.h>
 #include <ydb/core/tx/columnshard/blobs_action/abstract/read.h>
-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>
+#include <ydb/library/signals/object_counter.h>
 #include <ydb/core/protos/base.pb.h>
 #include <ydb/core/tx/columnshard/resource_subscriber/task.h>
 
diff --git a/ydb/core/tx/columnshard/columnshard__propose_transaction.cpp b/ydb/core/tx/columnshard/columnshard__propose_transaction.cpp
index 82cf16fec496..f864a1015186 100644
--- a/ydb/core/tx/columnshard/columnshard__propose_transaction.cpp
+++ b/ydb/core/tx/columnshard/columnshard__propose_transaction.cpp
@@ -12,6 +12,8 @@ using namespace NTabletFlatExecutor;
 class TTxProposeTransaction: public NTabletFlatExecutor::TTransactionBase<TColumnShard> {
 private:
     using TBase = NTabletFlatExecutor::TTransactionBase<TColumnShard>;
+    TEvColumnShard::TEvProposeTransaction::TPtr Ev;
+    std::shared_ptr<TTxController::ITransactionOperator> TxOperator;
     std::optional<TTxController::TTxInfo> TxInfo;
 
 public:
@@ -69,7 +71,7 @@ class TTxProposeTransaction: public NTabletFlatExecutor::TTransactionBase<TColum
                 msgSeqNo = SeqNoFromProto(schemaTxBody.GetSeqNo());
             }
         }
-        TxInfo.emplace(txKind, txId, Ev->Get()->GetSource(), Ev->Cookie, msgSeqNo);
+        TxInfo.emplace(txKind, txId, Ev->Get()->GetSource(), Self->GetProgressTxController().GetAllowedStep(), Ev->Cookie, msgSeqNo);
         TxOperator = Self->GetProgressTxController().StartProposeOnExecute(*TxInfo, txBody, txc);
         return true;
     }
@@ -114,8 +116,6 @@ class TTxProposeTransaction: public NTabletFlatExecutor::TTransactionBase<TColum
     }
 
 private:
-    TEvColumnShard::TEvProposeTransaction::TPtr Ev;
-    std::shared_ptr<TTxController::ITransactionOperator> TxOperator;
 
 };
 
diff --git a/ydb/core/tx/columnshard/columnshard__write.cpp b/ydb/core/tx/columnshard/columnshard__write.cpp
index 818263c77181..7e407387d861 100644
--- a/ydb/core/tx/columnshard/columnshard__write.cpp
+++ b/ydb/core/tx/columnshard/columnshard__write.cpp
@@ -34,6 +34,9 @@ void TColumnShard::OverloadWriteFail(const EOverloadStatus overloadReason, const
         case EOverloadStatus::OverloadMetadata:
             Counters.OnWriteOverloadMetadata(writeSize);
             break;
+        case EOverloadStatus::OverloadCompaction:
+            Counters.OnWriteOverloadCompaction(writeSize);
+            break;
         case EOverloadStatus::ShardTxInFly:
             Counters.OnWriteOverloadShardTx(writeSize);
             break;
@@ -58,8 +61,16 @@ TColumnShard::EOverloadStatus TColumnShard::CheckOverloadedWait(const TInternalP
         return EOverloadStatus::InsertTable;
     }
     Counters.GetCSCounters().OnIndexMetadataLimit(NOlap::IColumnEngine::GetMetadataLimit());
-    if (TablesManager.GetPrimaryIndex() && TablesManager.GetPrimaryIndex()->IsOverloadedByMetadata(NOlap::IColumnEngine::GetMetadataLimit())) {
-        return EOverloadStatus::OverloadMetadata;
+    if (TablesManager.GetPrimaryIndex()) {
+        if (TablesManager.GetPrimaryIndex()->IsOverloadedByMetadata(NOlap::IColumnEngine::GetMetadataLimit())) {
+            return EOverloadStatus::OverloadMetadata;
+        }
+        if (TablesManager.GetPrimaryIndexAsVerified<NOlap::TColumnEngineForLogs>()
+                .GetGranuleVerified(pathId)
+                .GetOptimizerPlanner()
+                .IsOverloaded()) {
+            return EOverloadStatus::OverloadCompaction;
+        }
     }
     return EOverloadStatus::None;
 }
@@ -110,12 +121,12 @@ void TColumnShard::Handle(NPrivateEvents::NWrite::TEvWritePortionResult::TPtr& e
             Counters.OnWritePutBlobsFailed(now - i.GetWriteMeta().GetWriteStartInstant(), i.GetRecordsCount());
             Counters.GetCSCounters().OnWritePutBlobsFail(now - i.GetWriteMeta().GetWriteStartInstant());
             AFL_WARN(NKikimrServices::TX_COLUMNSHARD_WRITE)("writing_size", i.GetDataSize())("event", "data_write_error")(
-                "writing_id", i.GetWriteMeta().GetId());
+                "writing_id", i.GetWriteMeta().GetId())("reason", i.GetErrorMessage());
             Counters.GetWritesMonitor()->OnFinishWrite(i.GetDataSize(), 1);
             i.MutableWriteMeta().OnStage(NEvWrite::EWriteStage::Finished);
         }
 
-        Execute(new TTxBlobsWritingFailed(this, ev->Get()->GetWriteStatus(), std::move(writtenData)), ctx);
+        Execute(new TTxBlobsWritingFailed(this, std::move(writtenData)), ctx);
     }
 }
 
@@ -203,7 +214,8 @@ void TColumnShard::Handle(TEvColumnShard::TEvWrite::TPtr& ev, const TActorContex
     writeMeta.SetLongTxId(NLongTxService::TLongTxId::FromProto(record.GetLongTxId()));
     writeMeta.SetWritePartId(record.GetWritePartId());
 
-    const auto returnFail = [&](const NColumnShard::ECumulativeCounters signalIndex, const EWriteFailReason reason, NKikimrTxColumnShard::EResultStatus resultStatus) {
+    const auto returnFail = [&](const NColumnShard::ECumulativeCounters signalIndex, const EWriteFailReason reason,
+                                NKikimrTxColumnShard::EResultStatus resultStatus) {
         Counters.GetTabletCounters()->IncCounter(signalIndex);
 
         ctx.Send(source, std::make_unique<TEvColumnShard::TEvWriteResult>(TabletID(), writeMeta, resultStatus));
@@ -211,7 +223,8 @@ void TColumnShard::Handle(TEvColumnShard::TEvWrite::TPtr& ev, const TActorContex
         return;
     };
 
-    if (SpaceWatcher->SubDomainOutOfSpace && (!record.HasModificationType() || (record.GetModificationType() != NKikimrTxColumnShard::TEvWrite::OPERATION_DELETE))) {
+    if (SpaceWatcher->SubDomainOutOfSpace &&
+        (!record.HasModificationType() || (record.GetModificationType() != NKikimrTxColumnShard::TEvWrite::OPERATION_DELETE))) {
         AFL_WARN(NKikimrServices::TX_COLUMNSHARD)("event", "skip_writing")("reason", "quota_exceeded");
         Counters.GetTabletCounters()->IncCounter(COUNTER_OUT_OF_SPACE);
         return returnFail(COUNTER_WRITE_FAIL, EWriteFailReason::Overload, NKikimrTxColumnShard::EResultStatus::OVERLOADED);
@@ -402,7 +415,8 @@ class TProposeWriteTransaction: public TExtendedTransactionBase {
         }
         proto.SetLockId(WriteCommit->GetLockId());
         TxOperator = Self->GetProgressTxController().StartProposeOnExecute(
-            TTxController::TTxInfo(kind, WriteCommit->GetTxId(), Source, Cookie, {}), proto.SerializeAsString(), txc);
+            TTxController::TTxInfo(kind, WriteCommit->GetTxId(), Source, Self->GetProgressTxController().GetAllowedStep(), 
+            Cookie, {}), proto.SerializeAsString(), txc);
         return true;
     }
 
@@ -487,7 +501,7 @@ void TColumnShard::Handle(NEvents::TDataEvents::TEvWrite::TPtr& ev, const TActor
 
     const auto sendError = [&](const TString& message, const NKikimrDataEvents::TEvWriteResult::EStatus status) {
         Counters.GetTabletCounters()->IncCounter(COUNTER_WRITE_FAIL);
-        auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(TabletID(), 0, status, message);
+        auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(TabletID(), record.GetTxId(), status, message);
         ctx.Send(source, result.release(), 0, cookie);
     };
     if (behaviour == EOperationBehaviour::CommitWriteLock) {
diff --git a/ydb/core/tx/columnshard/columnshard_impl.cpp b/ydb/core/tx/columnshard/columnshard_impl.cpp
index ebaf53c86a37..3f089c2b4d09 100644
--- a/ydb/core/tx/columnshard/columnshard_impl.cpp
+++ b/ydb/core/tx/columnshard/columnshard_impl.cpp
@@ -544,7 +544,7 @@ class TChangesTask: public NConveyor::ITask {
     NOlap::TSnapshot LastCompletedTx;
 
 protected:
-    virtual TConclusionStatus DoExecute(const std::shared_ptr<NConveyor::ITask>& /*taskPtr*/) override {
+    virtual void DoExecute(const std::shared_ptr<NConveyor::ITask>& /*taskPtr*/) override {
         NActors::TLogContextGuard g(NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)("tablet_id", TabletId)("parent_id", ParentActorId));
         {
             NOlap::TConstructionContext context(*TxEvent->IndexInfo, Counters, LastCompletedTx);
@@ -554,7 +554,6 @@ class TChangesTask: public NConveyor::ITask {
             }
         }
         TActorContext::AsActorContext().Send(ParentActorId, std::move(TxEvent));
-        return TConclusionStatus::Success();
     }
 
 public:
@@ -1394,14 +1393,13 @@ class TAccessorsParsingTask: public NConveyor::ITask {
     std::shared_ptr<NOlap::NDataAccessorControl::IAccessorCallback> FetchCallback;
     std::vector<TPortionConstructorV2> Portions;
 
-    virtual TConclusionStatus DoExecute(const std::shared_ptr<ITask>& /*taskPtr*/) override {
+    virtual void DoExecute(const std::shared_ptr<ITask>& /*taskPtr*/) override {
         std::vector<NOlap::TPortionDataAccessor> accessors;
         accessors.reserve(Portions.size());
         for (auto&& i : Portions) {
             accessors.emplace_back(i.BuildAccessor());
         }
         FetchCallback->OnAccessorsFetched(std::move(accessors));
-        return TConclusionStatus::Success();
     }
     virtual void DoOnCannotExecute(const TString& reason) override {
         AFL_VERIFY(false)("cannot parse metadata", reason);
diff --git a/ydb/core/tx/columnshard/columnshard_impl.h b/ydb/core/tx/columnshard/columnshard_impl.h
index eda7afe5e587..ce3f16b9899e 100644
--- a/ydb/core/tx/columnshard/columnshard_impl.h
+++ b/ydb/core/tx/columnshard/columnshard_impl.h
@@ -359,7 +359,8 @@ class TColumnShard: public TActor<TColumnShard>, public NTabletFlatExecutor::TTa
         InsertTable /* "insert_table" */,
         OverloadMetadata /* "overload_metadata" */,
         Disk /* "disk" */,
-        None /* "none" */
+        None /* "none" */,
+        OverloadCompaction /* "overload_compaction" */
     };
 
     // For syslocks
diff --git a/ydb/core/tx/columnshard/common/limits.h b/ydb/core/tx/columnshard/common/limits.h
index ca019a7510f6..e3869f26727f 100644
--- a/ydb/core/tx/columnshard/common/limits.h
+++ b/ydb/core/tx/columnshard/common/limits.h
@@ -10,7 +10,6 @@ class TGlobalLimits {
     static constexpr inline ui64 GeneralCompactionMemoryLimit = 3ULL << 30;
     static constexpr inline ui64 ScanMemoryLimit = 3ULL << 30;
 
-    static constexpr inline ui64 DefaultBlobsMemoryIntervalLimit = ScanMemoryLimit;
     static constexpr inline ui64 DefaultReadSequentiallyBufferSize = ((ui64)8) << 20;
 };
 }
\ No newline at end of file
diff --git a/ydb/core/tx/columnshard/common/snapshot.cpp b/ydb/core/tx/columnshard/common/snapshot.cpp
index e0e873488985..5fcd337b8c9f 100644
--- a/ydb/core/tx/columnshard/common/snapshot.cpp
+++ b/ydb/core/tx/columnshard/common/snapshot.cpp
@@ -39,6 +39,10 @@ NKikimr::NOlap::TSnapshot TSnapshot::MaxForPlanStep(const ui64 planStep) noexcep
     return TSnapshot(planStep, ::Max<ui64>());
 }
 
+NKikimr::NOlap::TSnapshot TSnapshot::MaxForPlanStep(const TPositiveIncreasingControlInteger planStep) noexcept {
+    return MaxForPlanStep(planStep.Val());
+}
+
 NKikimr::NOlap::TSnapshot TSnapshot::MaxForPlanInstant(const TInstant planInstant) noexcept {
     return TSnapshot(planInstant.MilliSeconds(), ::Max<ui64>());
 }
diff --git a/ydb/core/tx/columnshard/common/snapshot.h b/ydb/core/tx/columnshard/common/snapshot.h
index 7f04203eea8a..4f9e3841f791 100644
--- a/ydb/core/tx/columnshard/common/snapshot.h
+++ b/ydb/core/tx/columnshard/common/snapshot.h
@@ -1,6 +1,6 @@
 #pragma once
 #include <ydb/library/conclusion/status.h>
-
+#include <ydb/library/accessor/positive_integer.h>
 #include <util/stream/output.h>
 #include <util/string/cast.h>
 #include <util/datetime/base.h>
@@ -26,6 +26,11 @@ class TSnapshot {
         , TxId(txId) {
     }
 
+    constexpr TSnapshot(const TPositiveIncreasingControlInteger planStep, const ui64 txId) noexcept
+        : PlanStep(planStep.Val())
+        , TxId(txId) {
+    }
+
     NJson::TJsonValue SerializeToJson() const;
 
     constexpr TInstant GetPlanInstant() const noexcept {
@@ -60,6 +65,8 @@ class TSnapshot {
 
     static TSnapshot MaxForPlanStep(const ui64 planStep) noexcept;
 
+    static TSnapshot MaxForPlanStep(const TPositiveIncreasingControlInteger planStep) noexcept;
+
     constexpr bool operator==(const TSnapshot&) const noexcept = default;
 
     constexpr auto operator<=>(const TSnapshot&) const noexcept = default;
diff --git a/ydb/core/tx/columnshard/counters/blobs_manager.h b/ydb/core/tx/columnshard/counters/blobs_manager.h
index 8490ff38814e..cae14e75f869 100644
--- a/ydb/core/tx/columnshard/counters/blobs_manager.h
+++ b/ydb/core/tx/columnshard/counters/blobs_manager.h
@@ -1,5 +1,5 @@
 #pragma once
-#include "common/owner.h"
+#include <ydb/library/signals/owner.h>
 
 #include <ydb/core/base/logoblob.h>
 #include <ydb/core/tx/columnshard/blobs_action/abstract/blob_set.h>
diff --git a/ydb/core/tx/columnshard/counters/columnshard.cpp b/ydb/core/tx/columnshard/counters/columnshard.cpp
index 67c569e1313b..78a3c9785904 100644
--- a/ydb/core/tx/columnshard/counters/columnshard.cpp
+++ b/ydb/core/tx/columnshard/counters/columnshard.cpp
@@ -32,6 +32,8 @@ TCSCounters::TCSCounters()
     OverloadInsertTableCount = TBase::GetDeriviative("Overload/InsertTable/Count");
     OverloadMetadataBytes = TBase::GetDeriviative("Overload/Metadata/Bytes");
     OverloadMetadataCount = TBase::GetDeriviative("Overload/Metadata/Count");
+    OverloadCompactionBytes = TBase::GetDeriviative("Overload/Compaction/Bytes");
+    OverloadCompactionCount = TBase::GetDeriviative("Overload/Compaction/Count");
     OverloadShardTxBytes = TBase::GetDeriviative("Overload/Shard/Tx/Bytes");
     OverloadShardTxCount = TBase::GetDeriviative("Overload/Shard/Tx/Count");
     OverloadShardWritesBytes = TBase::GetDeriviative("Overload/Shard/Writes/Bytes");
diff --git a/ydb/core/tx/columnshard/counters/columnshard.h b/ydb/core/tx/columnshard/counters/columnshard.h
index 97789bc144ca..974bc1433bf2 100644
--- a/ydb/core/tx/columnshard/counters/columnshard.h
+++ b/ydb/core/tx/columnshard/counters/columnshard.h
@@ -2,7 +2,7 @@
 #include "initialization.h"
 #include "tx_progress.h"
 
-#include "common/owner.h"
+#include <ydb/library/signals/owner.h>
 
 #include <ydb/core/tx/columnshard/counters/tablet_counters.h>
 #include <ydb/core/tx/data_events/common/signals_flow.h>
@@ -88,6 +88,8 @@ class TCSCounters: public TCommonCountersOwner {
     NMonitoring::TDynamicCounters::TCounterPtr OverloadInsertTableCount;
     NMonitoring::TDynamicCounters::TCounterPtr OverloadMetadataBytes;
     NMonitoring::TDynamicCounters::TCounterPtr OverloadMetadataCount;
+    NMonitoring::TDynamicCounters::TCounterPtr OverloadCompactionBytes;
+    NMonitoring::TDynamicCounters::TCounterPtr OverloadCompactionCount;
     NMonitoring::TDynamicCounters::TCounterPtr OverloadShardTxBytes;
     NMonitoring::TDynamicCounters::TCounterPtr OverloadShardTxCount;
     NMonitoring::TDynamicCounters::TCounterPtr OverloadShardWritesBytes;
@@ -188,6 +190,11 @@ class TCSCounters: public TCommonCountersOwner {
         OverloadMetadataCount->Add(1);
     }
 
+    void OnWriteOverloadCompaction(const ui64 size) const {
+        OverloadCompactionBytes->Add(size);
+        OverloadCompactionCount->Add(1);
+    }
+
     void OnWriteOverloadShardTx(const ui64 size) const {
         OverloadShardTxBytes->Add(size);
         OverloadShardTxCount->Add(1);
diff --git a/ydb/core/tx/columnshard/counters/common_data.h b/ydb/core/tx/columnshard/counters/common_data.h
index 6c92a4fed41e..f087d2e32d1b 100644
--- a/ydb/core/tx/columnshard/counters/common_data.h
+++ b/ydb/core/tx/columnshard/counters/common_data.h
@@ -1,5 +1,5 @@
 #pragma once
-#include "common/owner.h"
+#include <ydb/library/signals/owner.h>
 
 #include <ydb/library/actors/core/log.h>
 
diff --git a/ydb/core/tx/columnshard/counters/counters_manager.h b/ydb/core/tx/columnshard/counters/counters_manager.h
index 7b287c12fbf4..2f6b2c4ad86a 100644
--- a/ydb/core/tx/columnshard/counters/counters_manager.h
+++ b/ydb/core/tx/columnshard/counters/counters_manager.h
@@ -65,6 +65,10 @@ class TCountersManager {
         CSCounters.OnWriteOverloadMetadata(size);
     }
 
+    void OnWriteOverloadCompaction(const ui64 size) const {
+        CSCounters.OnWriteOverloadCompaction(size);
+    }
+
     void OnWriteOverloadShardTx(const ui64 size) const {
         TabletCounters->IncCounter(COUNTER_WRITE_OVERLOAD);
         CSCounters.OnWriteOverloadShardTx(size);
diff --git a/ydb/core/tx/columnshard/counters/engine_logs.h b/ydb/core/tx/columnshard/counters/engine_logs.h
index 7461981363b6..9c7a4aefb2a8 100644
--- a/ydb/core/tx/columnshard/counters/engine_logs.h
+++ b/ydb/core/tx/columnshard/counters/engine_logs.h
@@ -1,8 +1,8 @@
 #pragma once
 
 #include "common_data.h"
-#include "common/owner.h"
-#include "common/histogram.h"
+#include <ydb/library/signals/owner.h>
+#include <ydb/library/signals/histogram.h>
 #include <ydb/core/tx/columnshard/common/portion.h>
 #include <library/cpp/monlib/dynamic_counters/counters.h>
 #include <util/string/builder.h>
diff --git a/ydb/core/tx/columnshard/counters/indexation.h b/ydb/core/tx/columnshard/counters/indexation.h
index f527a219ff43..5fc395e92f48 100644
--- a/ydb/core/tx/columnshard/counters/indexation.h
+++ b/ydb/core/tx/columnshard/counters/indexation.h
@@ -2,7 +2,7 @@
 #include "splitter.h"
 #include "sub_columns.h"
 
-#include "common/owner.h"
+#include <ydb/library/signals/owner.h>
 
 #include <library/cpp/monlib/dynamic_counters/counters.h>
 
diff --git a/ydb/core/tx/columnshard/counters/initialization.h b/ydb/core/tx/columnshard/counters/initialization.h
index 2a6b432d6135..009c0a79637e 100644
--- a/ydb/core/tx/columnshard/counters/initialization.h
+++ b/ydb/core/tx/columnshard/counters/initialization.h
@@ -1,5 +1,5 @@
 #pragma once
-#include "common/owner.h"
+#include <ydb/library/signals/owner.h>
 
 #include <library/cpp/monlib/dynamic_counters/counters.h>
 
diff --git a/ydb/core/tx/columnshard/counters/insert_table.h b/ydb/core/tx/columnshard/counters/insert_table.h
index 0c20660d609e..32432acc164f 100644
--- a/ydb/core/tx/columnshard/counters/insert_table.h
+++ b/ydb/core/tx/columnshard/counters/insert_table.h
@@ -1,7 +1,7 @@
 #pragma once
 #include "common_data.h"
-#include "common/client.h"
-#include "common/agent.h"
+#include <ydb/library/signals/client.h>
+#include <ydb/library/signals/agent.h>
 
 namespace NKikimr::NColumnShard {
 
diff --git a/ydb/core/tx/columnshard/counters/portions.h b/ydb/core/tx/columnshard/counters/portions.h
index 72915d255b06..cfc06459a521 100644
--- a/ydb/core/tx/columnshard/counters/portions.h
+++ b/ydb/core/tx/columnshard/counters/portions.h
@@ -1,7 +1,7 @@
 #pragma once
-#include "common/agent.h"
-#include "common/client.h"
-#include "common/owner.h"
+#include <ydb/library/signals/agent.h>
+#include <ydb/library/signals/client.h>
+#include <ydb/library/signals/owner.h>
 
 #include <ydb/library/actors/core/log.h>
 
diff --git a/ydb/core/tx/columnshard/counters/req_tracer.h b/ydb/core/tx/columnshard/counters/req_tracer.h
index f70cd02e4840..e8c6b109f0a0 100644
--- a/ydb/core/tx/columnshard/counters/req_tracer.h
+++ b/ydb/core/tx/columnshard/counters/req_tracer.h
@@ -1,5 +1,5 @@
 #pragma once
-#include "common/owner.h"
+#include <ydb/library/signals/owner.h>
 #include <ydb/core/tx/columnshard/common/snapshot.h>
 
 namespace NKikimr::NColumnShard {
diff --git a/ydb/core/tx/columnshard/counters/scan.cpp b/ydb/core/tx/columnshard/counters/scan.cpp
index 36b3c6abae87..144a2b25588e 100644
--- a/ydb/core/tx/columnshard/counters/scan.cpp
+++ b/ydb/core/tx/columnshard/counters/scan.cpp
@@ -24,7 +24,8 @@ TScanCounters::TScanCounters(const TString& module)
     , LinearScanIntervals(TBase::GetDeriviative("LinearScanIntervals"))
     , LogScanRecords(TBase::GetDeriviative("LogScanRecords"))
     , LogScanIntervals(TBase::GetDeriviative("LogScanIntervals"))
-    , NotIndexBlobs(TBase::GetDeriviative("Indexes/NoData/Count"))
+    , NoIndexBlobs(TBase::GetDeriviative("Indexes/NoData/Blobs/Count"))
+    , NoIndex(TBase::GetDeriviative("Indexes/NoData/Index/Count"))
     , RecordsAcceptedByIndex(TBase::GetDeriviative("Indexes/Accepted/Records"))
     , RecordsDeniedByIndex(TBase::GetDeriviative("Indexes/Denied/Records"))
     , RecordsAcceptedByHeader(TBase::GetDeriviative("Headers/Accepted/Records"))
diff --git a/ydb/core/tx/columnshard/counters/scan.h b/ydb/core/tx/columnshard/counters/scan.h
index 78047490d3eb..9c5313f240fd 100644
--- a/ydb/core/tx/columnshard/counters/scan.h
+++ b/ydb/core/tx/columnshard/counters/scan.h
@@ -1,8 +1,8 @@
 #pragma once
 #include "sub_columns.h"
 
-#include "common/histogram.h"
-#include "common/owner.h"
+#include <ydb/library/signals/histogram.h>
+#include <ydb/library/signals/owner.h>
 
 #include <ydb/core/protos/table_stats.pb.h>
 #include <ydb/core/tx/columnshard/resource_subscriber/counters.h>
@@ -149,7 +149,8 @@ class TScanCounters: public TCommonCountersOwner {
     NMonitoring::THistogramPtr HistogramIntervalMemoryRequiredOnFail;
     NMonitoring::THistogramPtr HistogramIntervalMemoryReduceSize;
     NMonitoring::THistogramPtr HistogramIntervalMemoryRequiredAfterReduce;
-    NMonitoring::TDynamicCounters::TCounterPtr NotIndexBlobs;
+    NMonitoring::TDynamicCounters::TCounterPtr NoIndexBlobs;
+    NMonitoring::TDynamicCounters::TCounterPtr NoIndex;
     NMonitoring::TDynamicCounters::TCounterPtr RecordsAcceptedByIndex;
     NMonitoring::TDynamicCounters::TCounterPtr RecordsDeniedByIndex;
     NMonitoring::TDynamicCounters::TCounterPtr RecordsAcceptedByHeader;
@@ -162,8 +163,11 @@ class TScanCounters: public TCommonCountersOwner {
         return SubColumnCounters;
     }
 
-    void OnNotIndexBlobs() const {
-        NotIndexBlobs->Add(1);
+    void OnNoIndexBlobs(const ui32 recordsCount) const {
+        NoIndexBlobs->Add(recordsCount);
+    }
+    void OnNoIndex(const ui32 recordsCount) const {
+        NoIndex->Add(recordsCount);
     }
     void OnAcceptedByIndex(const ui32 recordsCount) const {
         RecordsAcceptedByIndex->Add(recordsCount);
diff --git a/ydb/core/tx/columnshard/counters/splitter.h b/ydb/core/tx/columnshard/counters/splitter.h
index cbde8265a2f7..efe23b850f21 100644
--- a/ydb/core/tx/columnshard/counters/splitter.h
+++ b/ydb/core/tx/columnshard/counters/splitter.h
@@ -1,6 +1,6 @@
 #pragma once
 #include <library/cpp/monlib/dynamic_counters/counters.h>
-#include "common/owner.h"
+#include <ydb/library/signals/owner.h>
 
 namespace NKikimr::NColumnShard {
 
diff --git a/ydb/core/tx/columnshard/counters/sub_columns.h b/ydb/core/tx/columnshard/counters/sub_columns.h
index 36d4aeb2b0a3..66fcfea61a2a 100644
--- a/ydb/core/tx/columnshard/counters/sub_columns.h
+++ b/ydb/core/tx/columnshard/counters/sub_columns.h
@@ -1,5 +1,5 @@
 #pragma once
-#include "common/owner.h"
+#include <ydb/library/signals/owner.h>
 
 #include <library/cpp/monlib/dynamic_counters/counters.h>
 
diff --git a/ydb/core/tx/columnshard/counters/tx_progress.h b/ydb/core/tx/columnshard/counters/tx_progress.h
index 24319a3ab748..24cbd4ffed10 100644
--- a/ydb/core/tx/columnshard/counters/tx_progress.h
+++ b/ydb/core/tx/columnshard/counters/tx_progress.h
@@ -1,5 +1,5 @@
 #pragma once
-#include "common/owner.h"
+#include <ydb/library/signals/owner.h>
 
 #include <library/cpp/monlib/dynamic_counters/counters.h>
 #include <util/generic/hash.h>
diff --git a/ydb/core/tx/columnshard/counters/ya.make b/ydb/core/tx/columnshard/counters/ya.make
index 12efb4545046..f27b507d885b 100644
--- a/ydb/core/tx/columnshard/counters/ya.make
+++ b/ydb/core/tx/columnshard/counters/ya.make
@@ -21,7 +21,7 @@ SRCS(
 PEERDIR(
     library/cpp/monlib/dynamic_counters
     ydb/core/tx/columnshard/counters/aggregation
-    ydb/core/tx/columnshard/counters/common
+    ydb/library/signals
     ydb/core/base
     ydb/library/actors/core
 )
diff --git a/ydb/core/tx/columnshard/data_accessor/request.h b/ydb/core/tx/columnshard/data_accessor/request.h
index 70d1a16eaba0..34876fd9cc35 100644
--- a/ydb/core/tx/columnshard/data_accessor/request.h
+++ b/ydb/core/tx/columnshard/data_accessor/request.h
@@ -1,5 +1,5 @@
 #pragma once
-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>
+#include <ydb/library/signals/object_counter.h>
 #include <ydb/core/tx/columnshard/engines/portions/data_accessor.h>
 #include <ydb/core/tx/columnshard/engines/portions/portion_info.h>
 #include <ydb/core/tx/columnshard/resource_subscriber/task.h>
diff --git a/ydb/core/tx/columnshard/engines/changes/abstract/ya.make b/ydb/core/tx/columnshard/engines/changes/abstract/ya.make
index 78095066a094..27b111dc5682 100644
--- a/ydb/core/tx/columnshard/engines/changes/abstract/ya.make
+++ b/ydb/core/tx/columnshard/engines/changes/abstract/ya.make
@@ -10,7 +10,7 @@ SRCS(
 )
 
 PEERDIR(
-    ydb/core/tx/columnshard/counters/common
+    ydb/library/signals
     ydb/core/tx/columnshard/engines/changes/counters
     ydb/core/tablet_flat
     yql/essentials/core/expr_nodes
diff --git a/ydb/core/tx/columnshard/engines/changes/compaction/sub_columns/ya.make b/ydb/core/tx/columnshard/engines/changes/compaction/sub_columns/ya.make
index f18a5c199024..4f85dd7575d0 100644
--- a/ydb/core/tx/columnshard/engines/changes/compaction/sub_columns/ya.make
+++ b/ydb/core/tx/columnshard/engines/changes/compaction/sub_columns/ya.make
@@ -9,6 +9,7 @@ SRCS(
 
 PEERDIR(
     ydb/core/tx/columnshard/engines/changes/compaction/common
+    ydb/core/formats/arrow/accessor/sub_columns
 )
 
 END()
diff --git a/ydb/core/tx/columnshard/engines/changes/counters/changes.h b/ydb/core/tx/columnshard/engines/changes/counters/changes.h
index 2b2f301ae63b..377444fc5f88 100644
--- a/ydb/core/tx/columnshard/engines/changes/counters/changes.h
+++ b/ydb/core/tx/columnshard/engines/changes/counters/changes.h
@@ -1,7 +1,7 @@
 #pragma once
 
 #include <ydb/core/tx/columnshard/blobs_action/counters/storage.h>
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 
 #include <ydb/library/actors/core/log.h>
 
diff --git a/ydb/core/tx/columnshard/engines/changes/counters/general.h b/ydb/core/tx/columnshard/engines/changes/counters/general.h
index 98deee42a6af..e4fff50744ab 100644
--- a/ydb/core/tx/columnshard/engines/changes/counters/general.h
+++ b/ydb/core/tx/columnshard/engines/changes/counters/general.h
@@ -1,5 +1,5 @@
 #pragma once
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 #include <ydb/core/tx/columnshard/counters/portions.h>
 
 #include <ydb/library/actors/core/log.h>
diff --git a/ydb/core/tx/columnshard/engines/changes/counters/ya.make b/ydb/core/tx/columnshard/engines/changes/counters/ya.make
index b557eaee1e58..3b1dc197d21b 100644
--- a/ydb/core/tx/columnshard/engines/changes/counters/ya.make
+++ b/ydb/core/tx/columnshard/engines/changes/counters/ya.make
@@ -10,7 +10,7 @@ PEERDIR(
     ydb/library/actors/core
     ydb/core/tablet_flat
     ydb/core/tx/columnshard/blobs_action/counters
-    ydb/core/tx/columnshard/counters/common
+    ydb/library/signals
 )
 
 GENERATE_ENUM_SERIALIZATION(changes.h)
diff --git a/ydb/core/tx/columnshard/engines/portions/data_accessor.cpp b/ydb/core/tx/columnshard/engines/portions/data_accessor.cpp
index 3d936b1686bc..7c3394f914ef 100644
--- a/ydb/core/tx/columnshard/engines/portions/data_accessor.cpp
+++ b/ydb/core/tx/columnshard/engines/portions/data_accessor.cpp
@@ -766,10 +766,10 @@ TConclusion<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> TPortionDataAcces
     return builder.Finish();
 }
 
-std::shared_ptr<NArrow::NAccessor::TDeserializeChunkedArray> TPortionDataAccessor::TPreparedColumn::AssembleForSeqAccess() const {
+std::shared_ptr<NArrow::NAccessor::IChunkedArray> TPortionDataAccessor::TPreparedColumn::AssembleForSeqAccess() const {
     Y_ABORT_UNLESS(!Blobs.empty());
 
-    std::vector<NArrow::NAccessor::TDeserializeChunkedArray::TChunk> chunks;
+    std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> chunks;
     chunks.reserve(Blobs.size());
     ui64 recordsCount = 0;
     for (auto& blob : Blobs) {
@@ -781,20 +781,22 @@ std::shared_ptr<NArrow::NAccessor::TDeserializeChunkedArray> TPortionDataAccesso
         }
     }
 
-    return std::make_shared<NArrow::NAccessor::TDeserializeChunkedArray>(recordsCount, Loader, std::move(chunks));
+    if (chunks.size() == 1) {
+        return chunks.front();
+    } else {
+        return std::make_shared<NArrow::NAccessor::TCompositeChunkedArray>(std::move(chunks), recordsCount, Loader->GetResultField()->type());
+    }
 }
 
-NArrow::NAccessor::TDeserializeChunkedArray::TChunk TPortionDataAccessor::TAssembleBlobInfo::BuildDeserializeChunk(
+std::shared_ptr<NArrow::NAccessor::IChunkedArray> TPortionDataAccessor::TAssembleBlobInfo::BuildDeserializeChunk(
     const std::shared_ptr<TColumnLoader>& loader) const {
     if (DefaultRowsCount) {
         AFL_WARN(NKikimrServices::TX_COLUMNSHARD)("event", "build_trivial");
         Y_ABORT_UNLESS(!Data);
-        auto col = std::make_shared<NArrow::NAccessor::TTrivialArray>(
-            NArrow::TThreadSimpleArraysCache::Get(loader->GetField()->type(), DefaultValue, DefaultRowsCount));
-        return NArrow::NAccessor::TDeserializeChunkedArray::TChunk(col);
+        return std::make_shared<NArrow::NAccessor::TSparsedArray>(DefaultValue, loader->GetField()->type(), DefaultRowsCount);
     } else {
         AFL_VERIFY(ExpectedRowsCount);
-        return NArrow::NAccessor::TDeserializeChunkedArray::TChunk(*ExpectedRowsCount, Data);
+        return std::make_shared<NArrow::NAccessor::TDeserializeChunkedArray>(*ExpectedRowsCount, loader, Data);
     }
 }
 
diff --git a/ydb/core/tx/columnshard/engines/portions/data_accessor.h b/ydb/core/tx/columnshard/engines/portions/data_accessor.h
index b9e440dbc86e..7a1418e66fe8 100644
--- a/ydb/core/tx/columnshard/engines/portions/data_accessor.h
+++ b/ydb/core/tx/columnshard/engines/portions/data_accessor.h
@@ -319,7 +319,7 @@ class TPortionDataAccessor {
         }
 
         TConclusion<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> BuildRecordBatch(const TColumnLoader& loader) const;
-        NArrow::NAccessor::TDeserializeChunkedArray::TChunk BuildDeserializeChunk(const std::shared_ptr<TColumnLoader>& loader) const;
+        std::shared_ptr<NArrow::NAccessor::IChunkedArray> BuildDeserializeChunk(const std::shared_ptr<TColumnLoader>& loader) const;
     };
 
     class TPreparedColumn {
@@ -346,7 +346,7 @@ class TPortionDataAccessor {
             AFL_VERIFY(Loader);
         }
 
-        std::shared_ptr<NArrow::NAccessor::TDeserializeChunkedArray> AssembleForSeqAccess() const;
+        std::shared_ptr<NArrow::NAccessor::IChunkedArray> AssembleForSeqAccess() const;
         TConclusion<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> AssembleAccessor() const;
     };
 
diff --git a/ydb/core/tx/columnshard/engines/portions/meta.h b/ydb/core/tx/columnshard/engines/portions/meta.h
index 579c80eb4bc7..a91b29dd08e4 100644
--- a/ydb/core/tx/columnshard/engines/portions/meta.h
+++ b/ydb/core/tx/columnshard/engines/portions/meta.h
@@ -65,7 +65,7 @@ class TPortionMetaBase {
 class TPortionMeta: public TPortionMetaBase {
 private:
     using TBase = TPortionMetaBase;
-    NArrow::TFirstLastSpecialKeys ReplaceKeyEdges;   // first and last PK rows
+    NArrow::TFirstLastSpecialKeys ReplaceKeyEdges;
     YDB_READONLY_DEF(TString, TierName);
     YDB_READONLY(ui32, DeletionsCount, 0);
     YDB_READONLY(ui32, CompactionLevel, 0);
diff --git a/ydb/core/tx/columnshard/engines/predicate/container.cpp b/ydb/core/tx/columnshard/engines/predicate/container.cpp
index 780a3390befa..0c0cf5baf79c 100644
--- a/ydb/core/tx/columnshard/engines/predicate/container.cpp
+++ b/ydb/core/tx/columnshard/engines/predicate/container.cpp
@@ -179,4 +179,36 @@ TConclusion<TPredicateContainer> TPredicateContainer::BuildPredicateTo(
     }
 }
 
+NArrow::TColumnFilter TPredicateContainer::BuildFilter(const std::shared_ptr<NArrow::TGeneralContainer>& data) const {
+    if (!Object) {
+        auto result = NArrow::TColumnFilter::BuildAllowFilter();
+        result.Add(true, data->GetRecordsCount());
+        return result;
+    }
+    if (!data->GetRecordsCount()) {
+        return NArrow::TColumnFilter::BuildAllowFilter();
+    }
+    auto sortingFields = Object->Batch->schema()->field_names();
+    auto position = NArrow::NMerger::TRWSortableBatchPosition(data, 0, sortingFields, {}, false);
+    const auto border = NArrow::NMerger::TSortableBatchPosition(Object->Batch, 0, sortingFields, {}, false);
+    const bool needUppedBound = CompareType == NArrow::ECompareType::LESS_OR_EQUAL || CompareType == NArrow::ECompareType::GREATER;
+    const auto findBound = position.FindBound(position, 0, data->GetRecordsCount() - 1, border, needUppedBound);
+    const ui64 rowsBeforeBound = findBound ? findBound->GetPosition() : data->GetRecordsCount();
+
+    auto filter = NArrow::TColumnFilter::BuildAllowFilter();
+    switch (CompareType) {
+        case NArrow::ECompareType::LESS:
+        case NArrow::ECompareType::LESS_OR_EQUAL:
+            filter.Add(true, rowsBeforeBound);
+            filter.Add(false, data->GetRecordsCount() - rowsBeforeBound);
+            break;
+        case NArrow::ECompareType::GREATER:
+        case NArrow::ECompareType::GREATER_OR_EQUAL:
+            filter.Add(false, rowsBeforeBound);
+            filter.Add(true, data->GetRecordsCount() - rowsBeforeBound);
+            break;
+    }
+    return filter;
 }
+
+}   // namespace NKikimr::NOlap
diff --git a/ydb/core/tx/columnshard/engines/predicate/container.h b/ydb/core/tx/columnshard/engines/predicate/container.h
index bb30aebc59a0..78dcb041447a 100644
--- a/ydb/core/tx/columnshard/engines/predicate/container.h
+++ b/ydb/core/tx/columnshard/engines/predicate/container.h
@@ -1,7 +1,10 @@
 #pragma once
 #include "predicate.h"
 
+#include <ydb/core/formats/arrow/accessor/abstract/accessor.h>
 #include <ydb/core/formats/arrow/arrow_filter.h>
+#include <ydb/core/formats/arrow/common/container.h>
+#include <ydb/core/formats/arrow/reader/position.h>
 
 #include <ydb/library/accessor/accessor.h>
 #include <ydb/library/conclusion/result.h>
@@ -115,12 +118,7 @@ class TPredicateContainer {
     static TConclusion<TPredicateContainer> BuildPredicateTo(
         std::shared_ptr<NOlap::TPredicate> object, const std::shared_ptr<arrow::Schema>& pkSchema);
 
-    NKikimr::NArrow::TColumnFilter BuildFilter(const arrow::Datum& data) const {
-        if (!Object) {
-            return NArrow::TColumnFilter::BuildAllowFilter();
-        }
-        return NArrow::TColumnFilter::MakePredicateFilter(data, Object->Batch, CompareType);
-    }
+    NArrow::TColumnFilter BuildFilter(const std::shared_ptr<NArrow::TGeneralContainer>& data) const;
 };
 
 }   // namespace NKikimr::NOlap
diff --git a/ydb/core/tx/columnshard/engines/predicate/filter.cpp b/ydb/core/tx/columnshard/engines/predicate/filter.cpp
index 1dc7b77bff5b..002988f9aadd 100644
--- a/ydb/core/tx/columnshard/engines/predicate/filter.cpp
+++ b/ydb/core/tx/columnshard/engines/predicate/filter.cpp
@@ -7,13 +7,14 @@
 
 namespace NKikimr::NOlap {
 
-NKikimr::NArrow::TColumnFilter TPKRangesFilter::BuildFilter(const arrow::Datum& data) const {
+NKikimr::NArrow::TColumnFilter TPKRangesFilter::BuildFilter(const std::shared_ptr<NArrow::TGeneralContainer>& data) const {
     if (SortedRanges.empty()) {
         return NArrow::TColumnFilter::BuildAllowFilter();
     }
-    NArrow::TColumnFilter result = SortedRanges.front().BuildFilter(data);
-    for (ui32 i = 1; i < SortedRanges.size(); ++i) {
-        result = result.Or(SortedRanges[i].BuildFilter(data));
+
+    auto result = NArrow::TColumnFilter::BuildDenyFilter();
+    for (const auto& range : SortedRanges) {
+        result = result.Or(range.BuildFilter(data));
     }
     return result;
 }
@@ -36,16 +37,9 @@ TConclusionStatus TPKRangesFilter::Add(
         return toContainerConclusion;
     }
     if (SortedRanges.size() && !FakeRanges) {
-        if (ReverseFlag) {
-            if (fromContainerConclusion->CrossRanges(SortedRanges.front().GetPredicateTo())) {
-                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "add_range_filter")("problem", "not sorted sequence");
-                return TConclusionStatus::Fail("not sorted sequence");
-            }
-        } else {
-            if (fromContainerConclusion->CrossRanges(SortedRanges.back().GetPredicateTo())) {
-                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "add_range_filter")("problem", "not sorted sequence");
-                return TConclusionStatus::Fail("not sorted sequence");
-            }
+        if (fromContainerConclusion->CrossRanges(SortedRanges.back().GetPredicateTo())) {
+            AFL_ERROR(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "add_range_filter")("problem", "not sorted sequence");
+            return TConclusionStatus::Fail("not sorted sequence");
         }
     }
     auto pkRangeFilterConclusion = TPKRangeFilter::Build(fromContainerConclusion.DetachResult(), toContainerConclusion.DetachResult());
@@ -56,11 +50,7 @@ TConclusionStatus TPKRangesFilter::Add(
         FakeRanges = false;
         SortedRanges.clear();
     }
-    if (ReverseFlag) {
-        SortedRanges.emplace_front(pkRangeFilterConclusion.DetachResult());
-    } else {
-        SortedRanges.emplace_back(pkRangeFilterConclusion.DetachResult());
-    }
+    SortedRanges.emplace_back(pkRangeFilterConclusion.DetachResult());
     return TConclusionStatus::Success();
 }
 
@@ -112,8 +102,7 @@ TPKRangeFilter::EUsageClass TPKRangesFilter::GetUsageClass(const NArrow::TReplac
     return TPKRangeFilter::EUsageClass::NoUsage;
 }
 
-TPKRangesFilter::TPKRangesFilter(const bool reverse)
-    : ReverseFlag(reverse) {
+TPKRangesFilter::TPKRangesFilter() {
     auto range = TPKRangeFilter::Build(TPredicateContainer::BuildNullPredicateFrom(), TPredicateContainer::BuildNullPredicateTo());
     Y_ABORT_UNLESS(range);
     SortedRanges.emplace_back(*range);
@@ -148,8 +137,8 @@ std::shared_ptr<arrow::RecordBatch> TPKRangesFilter::SerializeToRecordBatch(cons
 }
 
 std::shared_ptr<NKikimr::NOlap::TPKRangesFilter> TPKRangesFilter::BuildFromRecordBatchLines(
-    const std::shared_ptr<arrow::RecordBatch>& batch, const bool reverse) {
-    std::shared_ptr<TPKRangesFilter> result = std::make_shared<TPKRangesFilter>(reverse);
+    const std::shared_ptr<arrow::RecordBatch>& batch) {
+    std::shared_ptr<TPKRangesFilter> result = std::make_shared<TPKRangesFilter>();
     for (ui32 i = 0; i < batch->num_rows(); ++i) {
         auto batchRow = batch->Slice(i, 1);
         auto pFrom = std::make_shared<NOlap::TPredicate>(NKernels::EOperation::GreaterEqual, batchRow);
@@ -160,8 +149,8 @@ std::shared_ptr<NKikimr::NOlap::TPKRangesFilter> TPKRangesFilter::BuildFromRecor
 }
 
 std::shared_ptr<NKikimr::NOlap::TPKRangesFilter> TPKRangesFilter::BuildFromRecordBatchFull(
-    const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& pkSchema, const bool reverse) {
-    std::shared_ptr<TPKRangesFilter> result = std::make_shared<TPKRangesFilter>(reverse);
+    const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& pkSchema) {
+    std::shared_ptr<TPKRangesFilter> result = std::make_shared<TPKRangesFilter>();
     auto pkBatch = NArrow::TColumnOperator().Adapt(batch, pkSchema).DetachResult();
     auto c = batch->GetColumnByName(".ydb_operation_type");
     AFL_VERIFY(c);
@@ -201,9 +190,9 @@ std::shared_ptr<NKikimr::NOlap::TPKRangesFilter> TPKRangesFilter::BuildFromRecor
 }
 
 std::shared_ptr<NKikimr::NOlap::TPKRangesFilter> TPKRangesFilter::BuildFromString(
-    const TString& data, const std::shared_ptr<arrow::Schema>& pkSchema, const bool reverse) {
+    const TString& data, const std::shared_ptr<arrow::Schema>& pkSchema) {
     auto batch = NArrow::TStatusValidator::GetValid(NArrow::NSerialization::TNativeSerializer().Deserialize(data));
-    return BuildFromRecordBatchFull(batch, pkSchema, reverse);
+    return BuildFromRecordBatchFull(batch, pkSchema);
 }
 
 TString TPKRangesFilter::SerializeToString(const std::shared_ptr<arrow::Schema>& pkSchema) const {
diff --git a/ydb/core/tx/columnshard/engines/predicate/filter.h b/ydb/core/tx/columnshard/engines/predicate/filter.h
index b020320280ef..0241cf20fe5b 100644
--- a/ydb/core/tx/columnshard/engines/predicate/filter.h
+++ b/ydb/core/tx/columnshard/engines/predicate/filter.h
@@ -1,8 +1,8 @@
 #pragma once
 #include "range.h"
 
-#include <ydb/core/protos/tx_datashard.pb.h>
 #include <ydb/core/protos/kqp.pb.h>
+#include <ydb/core/protos/tx_datashard.pb.h>
 
 #include <deque>
 
@@ -12,10 +12,9 @@ class TPKRangesFilter {
 private:
     bool FakeRanges = true;
     std::deque<TPKRangeFilter> SortedRanges;
-    bool ReverseFlag = false;
 
 public:
-    TPKRangesFilter(const bool reverse);
+    TPKRangesFilter();
 
     std::optional<ui32> GetFilteredCountLimit(const std::shared_ptr<arrow::Schema>& pkSchema) {
         ui32 result = 0;
@@ -38,10 +37,6 @@ class TPKRangesFilter {
         return SortedRanges.empty() || FakeRanges;
     }
 
-    bool IsReverse() const {
-        return ReverseFlag;
-    }
-
     const TPKRangeFilter& Front() const {
         Y_ABORT_UNLESS(Size());
         return SortedRanges.front();
@@ -69,7 +64,7 @@ class TPKRangesFilter {
     TPKRangeFilter::EUsageClass GetUsageClass(const NArrow::TReplaceKey& start, const NArrow::TReplaceKey& end) const;
     bool CheckPoint(const NArrow::TReplaceKey& point) const;
 
-    NArrow::TColumnFilter BuildFilter(const arrow::Datum& data) const;
+    NArrow::TColumnFilter BuildFilter(const std::shared_ptr<NArrow::TGeneralContainer>& data) const;
 
     std::set<std::string> GetColumnNames() const {
         std::set<std::string> result;
@@ -85,20 +80,19 @@ class TPKRangesFilter {
 
     std::set<ui32> GetColumnIds(const TIndexInfo& indexInfo) const;
 
-    static std::shared_ptr<TPKRangesFilter> BuildFromRecordBatchLines(const std::shared_ptr<arrow::RecordBatch>& batch, const bool reverse);
+    static std::shared_ptr<TPKRangesFilter> BuildFromRecordBatchLines(const std::shared_ptr<arrow::RecordBatch>& batch);
 
     static std::shared_ptr<TPKRangesFilter> BuildFromRecordBatchFull(
-        const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& pkSchema, const bool reverse);
-    static std::shared_ptr<TPKRangesFilter> BuildFromString(
-        const TString& data, const std::shared_ptr<arrow::Schema>& pkSchema, const bool reverse);
+        const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& pkSchema);
+    static std::shared_ptr<TPKRangesFilter> BuildFromString(const TString& data, const std::shared_ptr<arrow::Schema>& pkSchema);
 
     template <class TProto>
-    static TConclusion<TPKRangesFilter> BuildFromProto(const TProto& proto, const bool reverse, const std::vector<TNameTypeInfo>& ydbPk) {
-        TPKRangesFilter result(reverse);
+    static TConclusion<TPKRangesFilter> BuildFromProto(const TProto& proto, const std::vector<TNameTypeInfo>& ydbPk) {
+        TPKRangesFilter result;
         for (auto& protoRange : proto.GetRanges()) {
             auto fromPredicate = std::make_shared<TPredicate>();
             auto toPredicate = std::make_shared<TPredicate>();
-            std::tie(*fromPredicate, *toPredicate) = TPredicate::DeserializePredicatesRange(TSerializedTableRange{protoRange}, ydbPk);
+            std::tie(*fromPredicate, *toPredicate) = TPredicate::DeserializePredicatesRange(TSerializedTableRange{ protoRange }, ydbPk);
             auto status = result.Add(fromPredicate, toPredicate, NArrow::TStatusValidator::GetValid(NArrow::MakeArrowSchema(ydbPk)));
             if (status.IsFail()) {
                 return status;
@@ -114,6 +108,8 @@ class ICursorEntity {
     virtual ui64 DoGetEntityRecordsCount() const = 0;
 
 public:
+    virtual ~ICursorEntity() = default;
+
     ui64 GetEntityId() const {
         return DoGetEntityId();
     }
@@ -124,8 +120,10 @@ class ICursorEntity {
 
 class IScanCursor {
 private:
+    YDB_ACCESSOR_DEF(std::optional<ui64>, TabletId);
+
     virtual const std::shared_ptr<arrow::RecordBatch>& DoGetPKCursor() const = 0;
-    virtual bool DoCheckEntityIsBorder(const std::shared_ptr<ICursorEntity>& entity, bool& usage) const = 0;
+    virtual bool DoCheckEntityIsBorder(const ICursorEntity& entity, bool& usage) const = 0;
     virtual bool DoCheckSourceIntervalUsage(const ui64 sourceId, const ui32 indexStart, const ui32 recordsCount) const = 0;
     virtual TConclusionStatus DoDeserializeFromProto(const NKikimrKqp::TEvKqpScanCursor& proto) = 0;
     virtual void DoSerializeToProto(NKikimrKqp::TEvKqpScanCursor& proto) const = 0;
@@ -144,17 +142,23 @@ class IScanCursor {
         return DoCheckSourceIntervalUsage(sourceId, indexStart, recordsCount);
     }
 
-    bool CheckEntityIsBorder(const std::shared_ptr<ICursorEntity>& entity, bool& usage) const {
+    bool CheckEntityIsBorder(const ICursorEntity& entity, bool& usage) const {
         AFL_VERIFY(IsInitialized());
         return DoCheckEntityIsBorder(entity, usage);
     }
 
     TConclusionStatus DeserializeFromProto(const NKikimrKqp::TEvKqpScanCursor& proto) {
+        if (proto.HasTabletId()) {
+            TabletId = proto.GetTabletId();
+        }
         return DoDeserializeFromProto(proto);
     }
 
     NKikimrKqp::TEvKqpScanCursor SerializeToProto() const {
         NKikimrKqp::TEvKqpScanCursor result;
+        if (TabletId) {
+            result.SetTabletId(*TabletId);
+        }
         DoSerializeToProto(result);
         return result;
     }
@@ -172,7 +176,6 @@ class TSimpleScanCursor: public IScanCursor {
     }
 
     virtual const std::shared_ptr<arrow::RecordBatch>& DoGetPKCursor() const override {
-        AFL_VERIFY(!!PrimaryKey);
         return PrimaryKey;
     }
 
@@ -180,18 +183,18 @@ class TSimpleScanCursor: public IScanCursor {
         return !!SourceId;
     }
 
-    virtual bool DoCheckEntityIsBorder(const std::shared_ptr<ICursorEntity>& entity, bool& usage) const override {
-        if (SourceId != entity->GetEntityId()) {
+    virtual bool DoCheckEntityIsBorder(const ICursorEntity& entity, bool& usage) const override {
+        if (SourceId != entity.GetEntityId()) {
             return false;
         }
-        AFL_VERIFY(RecordIndex <= entity->GetEntityRecordsCount());
-        usage = RecordIndex < entity->GetEntityRecordsCount();
+        AFL_VERIFY(RecordIndex <= entity.GetEntityRecordsCount());
+        usage = RecordIndex < entity.GetEntityRecordsCount();
         return true;
     }
 
     virtual TConclusionStatus DoDeserializeFromProto(const NKikimrKqp::TEvKqpScanCursor& proto) override {
         if (!proto.HasColumnShardSimple()) {
-            return TConclusionStatus::Success();
+            return TConclusionStatus::Fail("absent sorted cursor data");
         }
         if (!proto.GetColumnShardSimple().HasSourceId()) {
             return TConclusionStatus::Fail("incorrect source id for cursor initialization");
@@ -223,6 +226,68 @@ class TSimpleScanCursor: public IScanCursor {
     }
 };
 
+class TNotSortedSimpleScanCursor: public TSimpleScanCursor {
+private:
+    YDB_READONLY(ui64, SourceId, 0);
+    YDB_READONLY(ui32, RecordIndex, 0);
+
+    virtual void DoSerializeToProto(NKikimrKqp::TEvKqpScanCursor& proto) const override {
+        auto& data = *proto.MutableColumnShardNotSortedSimple();
+        data.SetSourceId(SourceId);
+        data.SetStartRecordIndex(RecordIndex);
+    }
+
+    virtual const std::shared_ptr<arrow::RecordBatch>& DoGetPKCursor() const override {
+        return Default<std::shared_ptr<arrow::RecordBatch>>();
+    }
+
+    virtual bool IsInitialized() const override {
+        return !!SourceId;
+    }
+
+    virtual bool DoCheckEntityIsBorder(const ICursorEntity& entity, bool& usage) const override {
+        if (SourceId != entity.GetEntityId()) {
+            return false;
+        }
+        AFL_VERIFY(RecordIndex <= entity.GetEntityRecordsCount())("index", RecordIndex)("count", entity.GetEntityRecordsCount());
+        usage = RecordIndex < entity.GetEntityRecordsCount();
+        return true;
+    }
+
+    virtual TConclusionStatus DoDeserializeFromProto(const NKikimrKqp::TEvKqpScanCursor& proto) override {
+        if (!proto.HasColumnShardNotSortedSimple()) {
+            return TConclusionStatus::Fail("absent unsorted cursor data");
+        }
+        auto& data = proto.GetColumnShardNotSortedSimple();
+        if (!data.HasSourceId()) {
+            return TConclusionStatus::Fail("incorrect source id for cursor initialization");
+        }
+        SourceId = data.GetSourceId();
+        if (!data.HasStartRecordIndex()) {
+            return TConclusionStatus::Fail("incorrect record index for cursor initialization");
+        }
+        RecordIndex = data.GetStartRecordIndex();
+        return TConclusionStatus::Success();
+    }
+
+    virtual bool DoCheckSourceIntervalUsage(const ui64 sourceId, const ui32 indexStart, const ui32 recordsCount) const override {
+        AFL_VERIFY(sourceId == SourceId);
+        if (indexStart >= RecordIndex) {
+            return true;
+        }
+        AFL_VERIFY(indexStart + recordsCount <= RecordIndex);
+        return false;
+    }
+
+public:
+    TNotSortedSimpleScanCursor() = default;
+
+    TNotSortedSimpleScanCursor(const ui64 portionId, const ui32 recordIndex)
+        : SourceId(portionId)
+        , RecordIndex(recordIndex) {
+    }
+};
+
 class TPlainScanCursor: public IScanCursor {
 private:
     YDB_READONLY_DEF(std::shared_ptr<arrow::RecordBatch>, PrimaryKey);
@@ -244,7 +309,7 @@ class TPlainScanCursor: public IScanCursor {
         return TConclusionStatus::Success();
     }
 
-    virtual bool DoCheckEntityIsBorder(const std::shared_ptr<ICursorEntity>& /*entity*/, bool& usage) const override {
+    virtual bool DoCheckEntityIsBorder(const ICursorEntity& /*entity*/, bool& usage) const override {
         usage = true;
         return true;
     }
diff --git a/ydb/core/tx/columnshard/engines/predicate/range.cpp b/ydb/core/tx/columnshard/engines/predicate/range.cpp
index b00ed126d279..f7516e32d690 100644
--- a/ydb/core/tx/columnshard/engines/predicate/range.cpp
+++ b/ydb/core/tx/columnshard/engines/predicate/range.cpp
@@ -34,8 +34,8 @@ std::set<std::string> TPKRangeFilter::GetColumnNames() const {
     return result;
 }
 
-NKikimr::NArrow::TColumnFilter TPKRangeFilter::BuildFilter(const arrow::Datum& data) const {
-    NArrow::TColumnFilter result = PredicateTo.BuildFilter(data);
+NArrow::TColumnFilter TPKRangeFilter::BuildFilter(const std::shared_ptr<NArrow::TGeneralContainer>& data) const {
+    auto result = PredicateTo.BuildFilter(data);
     return result.And(PredicateFrom.BuildFilter(data));
 }
 
diff --git a/ydb/core/tx/columnshard/engines/predicate/range.h b/ydb/core/tx/columnshard/engines/predicate/range.h
index fab63a7b9bca..91e7d58c4a77 100644
--- a/ydb/core/tx/columnshard/engines/predicate/range.h
+++ b/ydb/core/tx/columnshard/engines/predicate/range.h
@@ -36,7 +36,7 @@ class TPKRangeFilter {
 
     static TConclusion<TPKRangeFilter> Build(TPredicateContainer&& from, TPredicateContainer&& to);
 
-    NArrow::TColumnFilter BuildFilter(const arrow::Datum& data) const;
+    NArrow::TColumnFilter BuildFilter(const std::shared_ptr<NArrow::TGeneralContainer>& data) const;
 
     bool IsUsed(const TPortionInfo& info) const;
     bool CheckPoint(const NArrow::TReplaceKey& point) const;
diff --git a/ydb/core/tx/columnshard/engines/reader/abstract/abstract.h b/ydb/core/tx/columnshard/engines/reader/abstract/abstract.h
index 37ba57b89985..6968fd1be79f 100644
--- a/ydb/core/tx/columnshard/engines/reader/abstract/abstract.h
+++ b/ydb/core/tx/columnshard/engines/reader/abstract/abstract.h
@@ -7,7 +7,7 @@ namespace NKikimr::NOlap::NReader {
 
 class TScanIteratorBase {
 protected:
-    virtual void DoOnSentDataFromInterval(const ui32 /*intervalIdx*/) const {
+    virtual void DoOnSentDataFromInterval(const TPartialSourceAddress& /*intervalAddress*/) {
 
     }
 public:
@@ -21,9 +21,9 @@ class TScanIteratorBase {
 
     virtual const TReadStats& GetStats() const;
 
-    void OnSentDataFromInterval(const std::optional<ui32> intervalIdx) const {
-        if (intervalIdx) {
-            DoOnSentDataFromInterval(*intervalIdx);
+    void OnSentDataFromInterval(const std::optional<TPartialSourceAddress>& intervalAddress) {
+        if (intervalAddress) {
+            DoOnSentDataFromInterval(*intervalAddress);
         }
     }
 
diff --git a/ydb/core/tx/columnshard/engines/reader/abstract/constructor.cpp b/ydb/core/tx/columnshard/engines/reader/abstract/constructor.cpp
index aaaf940f8d2c..f28536de3046 100644
--- a/ydb/core/tx/columnshard/engines/reader/abstract/constructor.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/abstract/constructor.cpp
@@ -6,7 +6,7 @@
 
 namespace NKikimr::NOlap::NReader {
 
-NKikimr::TConclusionStatus IScannerConstructor::ParseProgram(const TVersionedIndex* vIndex, const NKikimrSchemeOp::EOlapProgramType programType,
+TConclusionStatus IScannerConstructor::ParseProgram(const TVersionedIndex* vIndex, const NKikimrSchemeOp::EOlapProgramType programType,
     const TString& serializedProgram, TReadDescription& read, const NArrow::NSSA::IColumnResolver& columnResolver) const {
     std::set<TString> namesChecker;
     if (serializedProgram.empty()) {
@@ -32,7 +32,7 @@ NKikimr::TConclusionStatus IScannerConstructor::ParseProgram(const TVersionedInd
     }
 }
 
-NKikimr::TConclusion<std::shared_ptr<TReadMetadataBase>> IScannerConstructor::BuildReadMetadata(
+TConclusion<std::shared_ptr<TReadMetadataBase>> IScannerConstructor::BuildReadMetadata(
     const NColumnShard::TColumnShard* self, const TReadDescription& read) const {
     TConclusion<std::shared_ptr<TReadMetadataBase>> result = DoBuildReadMetadata(self, read);
     if (result.IsFail()) {
@@ -46,7 +46,7 @@ NKikimr::TConclusion<std::shared_ptr<TReadMetadataBase>> IScannerConstructor::Bu
     }
 }
 
-NKikimr::TConclusion<std::shared_ptr<NKikimr::NOlap::IScanCursor>> IScannerConstructor::BuildCursorFromProto(
+TConclusion<std::shared_ptr<NKikimr::NOlap::IScanCursor>> IScannerConstructor::BuildCursorFromProto(
     const NKikimrKqp::TEvKqpScanCursor& proto) const {
     auto result = DoBuildCursor();
     if (!result) {
diff --git a/ydb/core/tx/columnshard/engines/reader/abstract/constructor.h b/ydb/core/tx/columnshard/engines/reader/abstract/constructor.h
index 3ad1e86821a2..02e2e74b063e 100644
--- a/ydb/core/tx/columnshard/engines/reader/abstract/constructor.h
+++ b/ydb/core/tx/columnshard/engines/reader/abstract/constructor.h
@@ -14,13 +14,13 @@ class TScannerConstructorContext {
 private:
     YDB_READONLY(TSnapshot, Snapshot, TSnapshot::Zero());
     YDB_READONLY(ui32, ItemsLimit, 0);
-    YDB_READONLY(bool, Reverse, false);
+    YDB_READONLY(TReadMetadataBase::ESorting, Sorting, TReadMetadataBase::ESorting::NONE);
 
 public:
-    TScannerConstructorContext(const TSnapshot& snapshot, const ui32 itemsLimit, const bool reverse)
+    TScannerConstructorContext(const TSnapshot& snapshot, const ui32 itemsLimit, const TReadMetadataBase::ESorting sorting)
         : Snapshot(snapshot)
         , ItemsLimit(itemsLimit)
-        , Reverse(reverse) {
+        , Sorting(sorting) {
     }
 };
 
@@ -28,7 +28,7 @@ class IScannerConstructor {
 protected:
     const TSnapshot Snapshot;
     const ui64 ItemsLimit;
-    const bool IsReverse;
+    const TReadMetadataBase::ESorting Sorting;
     TConclusionStatus ParseProgram(const TVersionedIndex* vIndex, const NKikimrSchemeOp::EOlapProgramType programType,
         const TString& serializedProgram, TReadDescription& read, const NArrow::NSSA::IColumnResolver& columnResolver) const;
 
@@ -44,7 +44,7 @@ class IScannerConstructor {
     IScannerConstructor(const TScannerConstructorContext& context)
         : Snapshot(context.GetSnapshot())
         , ItemsLimit(context.GetItemsLimit())
-        , IsReverse(context.GetReverse()) {
+        , Sorting(context.GetSorting()) {
     }
 
     TConclusion<std::shared_ptr<IScanCursor>> BuildCursorFromProto(const NKikimrKqp::TEvKqpScanCursor& proto) const;
diff --git a/ydb/core/tx/columnshard/engines/reader/abstract/read_context.h b/ydb/core/tx/columnshard/engines/reader/abstract/read_context.h
index 22bb1ce13920..c9a63b0bf53f 100644
--- a/ydb/core/tx/columnshard/engines/reader/abstract/read_context.h
+++ b/ydb/core/tx/columnshard/engines/reader/abstract/read_context.h
@@ -13,6 +13,7 @@
 namespace NKikimr::NOlap::NReader {
 
 class TPartialReadResult;
+class TPartialSourceAddress;
 
 class TComputeShardingPolicy {
 private:
@@ -170,7 +171,7 @@ class IDataReader {
         Started = true;
         return DoStart();
     }
-    virtual void OnSentDataFromInterval(const ui32 intervalIdx) const = 0;
+    virtual void OnSentDataFromInterval(const TPartialSourceAddress& address) = 0;
 
     const TReadContext& GetContext() const {
         return *Context;
diff --git a/ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.h b/ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.h
index ab0ded4d32bf..aac729f0a4aa 100644
--- a/ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.h
+++ b/ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.h
@@ -1,9 +1,9 @@
 #pragma once
+#include <ydb/core/tx/columnshard/common/path_id.h>
 #include <ydb/core/tx/columnshard/engines/column_engine.h>
 #include <ydb/core/tx/columnshard/engines/insert_table/insert_table.h>
 #include <ydb/core/tx/columnshard/engines/reader/common/description.h>
 #include <ydb/core/tx/columnshard/engines/scheme/versions/versioned_index.h>
-#include <ydb/core/tx/columnshard/common/path_id.h>
 
 namespace NKikimr::NOlap {
 class TPortionInfo;
@@ -33,11 +33,7 @@ class TDataStorageAccessor {
 // Holds all metadata that is needed to perform read/scan
 class TReadMetadataBase {
 public:
-    enum class ESorting {
-        NONE = 0 /* "not_sorted" */,
-        ASC /* "ascending" */,
-        DESC /* "descending" */,
-    };
+    using ESorting = ERequestSorting;
 
 private:
     YDB_ACCESSOR_DEF(TString, ScanIdentifier);
@@ -50,6 +46,7 @@ class TReadMetadataBase {
     TSnapshot RequestSnapshot;
     std::optional<TGranuleShardingInfo> RequestShardingInfo;
     std::shared_ptr<IScanCursor> ScanCursor;
+    const ui64 TabletId;
     virtual void DoOnReadFinished(NColumnShard::TColumnShard& /*owner*/) const {
     }
     virtual void DoOnBeforeStartReading(NColumnShard::TColumnShard& /*owner*/) const {
@@ -65,7 +62,11 @@ class TReadMetadataBase {
 public:
     using TConstPtr = std::shared_ptr<const TReadMetadataBase>;
 
-    void SetRequestedLimit(const ui64 value) { 
+    ui64 GetTabletId() const {
+        return TabletId;
+    }
+
+    void SetRequestedLimit(const ui64 value) {
         AFL_VERIFY(!RequestedLimit);
         if (value == 0 || value >= Max<i64>()) {
             return;
@@ -125,7 +126,6 @@ class TReadMetadataBase {
 
     void SetPKRangesFilter(const std::shared_ptr<TPKRangesFilter>& value) {
         AFL_VERIFY(value);
-        Y_ABORT_UNLESS(IsSorted() && value->IsReverse() == IsDescSorted());
         Y_ABORT_UNLESS(!PKRangesFilter);
         PKRangesFilter = value;
         if (ResultIndexSchema) {
@@ -177,20 +177,23 @@ class TReadMetadataBase {
     }
 
     TReadMetadataBase(const std::shared_ptr<TVersionedIndex> index, const ESorting sorting, const TProgramContainer& ssaProgram,
-        const std::shared_ptr<ISnapshotSchema>& schema, const TSnapshot& requestSnapshot, const std::shared_ptr<IScanCursor>& scanCursor)
+        const std::shared_ptr<ISnapshotSchema>& schema, const TSnapshot& requestSnapshot, const std::shared_ptr<IScanCursor>& scanCursor,
+        const ui64 tabletId)
         : Sorting(sorting)
         , Program(ssaProgram)
         , IndexVersionsPointer(index)
         , RequestSnapshot(requestSnapshot)
         , ScanCursor(scanCursor)
-        , ResultIndexSchema(schema)
-    {
+        , TabletId(tabletId)
+        , ResultIndexSchema(schema) {
+        AFL_VERIFY(!ScanCursor || !ScanCursor->GetTabletId() || (*ScanCursor->GetTabletId() == TabletId))("cursor", ScanCursor->GetTabletId())(
+                                                                "tablet_id", TabletId);
     }
     virtual ~TReadMetadataBase() = default;
 
     virtual TString DebugString() const {
         return TStringBuilder() << " predicate{" << (PKRangesFilter ? PKRangesFilter->DebugString() : "no_initialized") << "}"
-            << " " << Sorting << " sorted";
+                                << " " << Sorting << " sorted";
     }
 
     std::set<ui32> GetProcessingColumnIds() const {
diff --git a/ydb/core/tx/columnshard/engines/reader/actor/actor.cpp b/ydb/core/tx/columnshard/engines/reader/actor/actor.cpp
index f788ea433ab5..f847b6d177e0 100644
--- a/ydb/core/tx/columnshard/engines/reader/actor/actor.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/actor/actor.cpp
@@ -7,8 +7,8 @@
 #include <yql/essentials/core/issue/yql_issue.h>
 
 namespace NKikimr::NOlap::NReader {
-constexpr TDuration SCAN_HARD_TIMEOUT = TDuration::Minutes(10);
-constexpr TDuration SCAN_HARD_TIMEOUT_GAP = TDuration::Seconds(5);
+constexpr TDuration SCAN_HARD_TIMEOUT = TDuration::Minutes(60);
+constexpr TDuration COMPUTE_HARD_TIMEOUT = TDuration::Minutes(10);
 
 void TColumnShardScan::PassAway() {
     Send(ResourceSubscribeActorId, new TEvents::TEvPoisonPill);
@@ -34,7 +34,7 @@ TColumnShardScan::TColumnShardScan(const TActorId& columnShardActorId, const TAc
     , DataFormat(dataFormat)
     , TabletId(tabletId)
     , ReadMetadataRange(readMetadataRange)
-    , Timeout(timeout ? timeout + SCAN_HARD_TIMEOUT_GAP : SCAN_HARD_TIMEOUT)
+    , Timeout(timeout ? timeout : COMPUTE_HARD_TIMEOUT)
     , ScanCountersPool(scanCountersPool, TValidator::CheckNotNull(ReadMetadataRange)->GetProgram().GetGraphOptional())
     , Stats(NTracing::TTraceClient::GetLocalClient("SHARD", ::ToString(TabletId) /*, "SCAN_TXID:" + ::ToString(TxId)*/))
     , ComputeShardingPolicy(computeShardingPolicy) {
@@ -65,7 +65,7 @@ void TColumnShardScan::Bootstrap(const TActorContext& ctx) {
         ScheduleWakeup(TMonotonic::Now() + Timeout / 5);
 
         // propagate self actor id // TODO: FlagSubscribeOnSession ?
-        Send(ScanComputeActorId, new NKqp::TEvKqpCompute::TEvScanInitActor(ScanId, ctx.SelfID, ScanGen, TabletId),
+        Send(ScanComputeActorId, new NKqp::TEvKqpCompute::TEvScanInitActor(ScanId, ctx.SelfID, ScanGen, TabletId, true),
             IEventHandle::FlagTrackDelivery);
 
         Become(&TColumnShardScan::StateScan);
@@ -93,6 +93,7 @@ void TColumnShardScan::HandleScan(NColumnShard::TEvPrivate::TEvTaskProcessedResu
 
 void TColumnShardScan::HandleScan(NKqp::TEvKqpCompute::TEvScanDataAck::TPtr& ev) {
     auto g = Stats->MakeGuard("ack");
+
     AFL_VERIFY(!AckReceivedInstant);
     AckReceivedInstant = TMonotonic::Now();
 
@@ -111,6 +112,12 @@ void TColumnShardScan::HandleScan(NKqp::TEvKqpCompute::TEvScanDataAck::TPtr& ev)
     ContinueProcessing();
 }
 
+void TColumnShardScan::HandleScan(NKqp::TEvKqpCompute::TEvScanPing::TPtr&) {
+    if (!AckReceivedInstant) {
+        LastResultInstant = TMonotonic::Now();
+    }
+}
+
 void TColumnShardScan::HandleScan(NActors::TEvents::TEvPoison::TPtr& /*ev*/) noexcept {
     PassAway();
 }
@@ -165,10 +172,7 @@ void TColumnShardScan::HandleScan(TEvents::TEvWakeup::TPtr& /*ev*/) {
                 << " txId: " << TxId << " scanId: " << ScanId << " gen: " << ScanGen << " tablet: " << TabletId);
 
     CheckHanging(true);
-    if (!!AckReceivedInstant && TMonotonic::Now() >= GetDeadline() + Timeout * 0.5) {
-        SendScanError("ColumnShard scanner timeout: HAS_ACK=1");
-        Finish(NColumnShard::TScanCounters::EStatusFinish::Deadline);
-    } else if (!AckReceivedInstant && TMonotonic::Now() >= GetDeadline()) {
+    if (!AckReceivedInstant && TMonotonic::Now() >= GetComputeDeadline()) {
         SendScanError("ColumnShard scanner timeout: HAS_ACK=0");
         Finish(NColumnShard::TScanCounters::EStatusFinish::Deadline);
     } else {
@@ -245,21 +249,23 @@ bool TColumnShardScan::ProduceResults() noexcept {
         ACFL_DEBUG("stage", "data_format")("batch_size", NArrow::GetTableDataSize(Result->ArrowBatch))("num_rows", numRows)(
             "batch_columns", JoinSeq(",", batch->schema()->field_names()));
     }
-    if (CurrentLastReadKey) {
+    if (CurrentLastReadKey && result.GetScanCursor()->GetPKCursor() && CurrentLastReadKey->GetPKCursor()) {
         auto pNew = NArrow::TReplaceKey::FromBatch(result.GetScanCursor()->GetPKCursor(), 0);
         auto pOld = NArrow::TReplaceKey::FromBatch(CurrentLastReadKey->GetPKCursor(), 0);
-        if (!ReadMetadataRange->IsDescSorted()) {
+        if (ReadMetadataRange->IsAscSorted()) {
             AFL_VERIFY(!(pNew < pOld))("old", pOld.DebugJson().GetStringRobust())("new", pNew.DebugJson().GetStringRobust());
-        } else {
+        } else if (ReadMetadataRange->IsDescSorted()) {
             AFL_VERIFY(!(pOld < pNew))("old", pOld.DebugJson().GetStringRobust())("new", pNew.DebugJson().GetStringRobust());
         }
     }
     CurrentLastReadKey = result.GetScanCursor();
 
-    Result->LastKey = ConvertLastKey(CurrentLastReadKey->GetPKCursor());
+    if (CurrentLastReadKey->GetPKCursor()) {
+        Result->LastKey = ConvertLastKey(CurrentLastReadKey->GetPKCursor());
+    }
     Result->LastCursorProto = CurrentLastReadKey->SerializeToProto();
     SendResult(false, false);
-    ScanIterator->OnSentDataFromInterval(result.GetNotFinishedIntervalIdx());
+    ScanIterator->OnSentDataFromInterval(result.GetNotFinishedInterval());
     ACFL_DEBUG("stage", "finished")("iterator", ScanIterator->DebugString());
     return true;
 }
@@ -353,8 +359,6 @@ bool TColumnShardScan::SendResult(bool pageFault, bool lastBatch) {
     if (ScanIterator) {
         Result->AvailablePacks = ScanIterator->GetAvailableResultsCount();
     }
-    TDuration totalElapsedTime = TDuration::Seconds(GetElapsedTicksAsSeconds());
-    LastReportedElapsedTime = totalElapsedTime;
 
     PageFaults = 0;
 
@@ -425,11 +429,14 @@ void TColumnShardScan::ScheduleWakeup(const TMonotonic deadline) {
     }
 }
 
-TMonotonic TColumnShardScan::GetDeadline() const {
-    AFL_VERIFY(StartInstant);
-    if (LastResultInstant) {
-        return *LastResultInstant + Timeout;
-    }
-    return *StartInstant + Timeout;
+TMonotonic TColumnShardScan::GetScanDeadline() const {
+    AFL_VERIFY(!!AckReceivedInstant);
+    return *AckReceivedInstant + SCAN_HARD_TIMEOUT;
 }
+
+TMonotonic TColumnShardScan::GetComputeDeadline() const {
+    AFL_VERIFY(!AckReceivedInstant);
+    return (LastResultInstant ? *LastResultInstant : *StartInstant) + Timeout;
+}
+
 }   // namespace NKikimr::NOlap::NReader
diff --git a/ydb/core/tx/columnshard/engines/reader/actor/actor.h b/ydb/core/tx/columnshard/engines/reader/actor/actor.h
index de4f0a2502aa..09c5f4279aba 100644
--- a/ydb/core/tx/columnshard/engines/reader/actor/actor.h
+++ b/ydb/core/tx/columnshard/engines/reader/actor/actor.h
@@ -46,6 +46,7 @@ class TColumnShardScan: public TActorBootstrapped<TColumnShardScan>,
             "TabletId", TabletId)("ScanId", ScanId)("TxId", TxId)("ScanGen", ScanGen)("task_identifier", ReadMetadataRange->GetScanIdentifier()));
         switch (ev->GetTypeRewrite()) {
             hFunc(NKqp::TEvKqpCompute::TEvScanDataAck, HandleScan);
+            hFunc(NKqp::TEvKqpCompute::TEvScanPing, HandleScan);
             hFunc(NKqp::TEvKqp::TEvAbortExecution, HandleScan);
             hFunc(NActors::TEvents::TEvPoison, HandleScan);
             hFunc(TEvents::TEvUndelivered, HandleScan);
@@ -60,6 +61,8 @@ class TColumnShardScan: public TActorBootstrapped<TColumnShardScan>,
 
     void HandleScan(NKqp::TEvKqpCompute::TEvScanDataAck::TPtr& ev);
 
+    void HandleScan(NKqp::TEvKqpCompute::TEvScanPing::TPtr& ev);
+
     // Returns true if it was able to produce new batch
     bool ProduceResults() noexcept;
 
@@ -109,7 +112,9 @@ class TColumnShardScan: public TActorBootstrapped<TColumnShardScan>,
 
     void ScheduleWakeup(const TMonotonic deadline);
 
-    TMonotonic GetDeadline() const;
+    TMonotonic GetScanDeadline() const;
+
+    TMonotonic GetComputeDeadline() const;
 
 private:
     const TActorId ColumnShardActorId;
@@ -186,7 +191,6 @@ class TColumnShardScan: public TActorBootstrapped<TColumnShardScan>,
     ui64 PacksSum = 0;
     ui64 Bytes = 0;
     ui32 PageFaults = 0;
-    TDuration LastReportedElapsedTime;
 };
 
 }   // namespace NKikimr::NOlap::NReader
diff --git a/ydb/core/tx/columnshard/engines/reader/common/conveyor_task.cpp b/ydb/core/tx/columnshard/engines/reader/common/conveyor_task.cpp
index ac778b00a6c7..1bcd853bec32 100644
--- a/ydb/core/tx/columnshard/engines/reader/common/conveyor_task.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/common/conveyor_task.cpp
@@ -4,7 +4,7 @@
 
 namespace NKikimr::NOlap::NReader {
 
-NKikimr::TConclusionStatus IDataTasksProcessor::ITask::DoExecute(const std::shared_ptr<NConveyor::ITask>& taskPtr) {
+void IDataTasksProcessor::ITask::DoExecute(const std::shared_ptr<NConveyor::ITask>& taskPtr) {
     auto result = DoExecuteImpl();
     if (result.IsFail()) {
         NActors::TActivationContext::AsActorContext().Send(OwnerId, new NColumnShard::TEvPrivate::TEvTaskProcessedResult(result));
@@ -12,7 +12,6 @@ NKikimr::TConclusionStatus IDataTasksProcessor::ITask::DoExecute(const std::shar
         NActors::TActivationContext::AsActorContext().Send(
             OwnerId, new NColumnShard::TEvPrivate::TEvTaskProcessedResult(static_pointer_cast<IDataTasksProcessor::ITask>(taskPtr)));
     }
-    return result;
 }
 
 void IDataTasksProcessor::ITask::DoOnCannotExecute(const TString& reason) {
diff --git a/ydb/core/tx/columnshard/engines/reader/common/conveyor_task.h b/ydb/core/tx/columnshard/engines/reader/common/conveyor_task.h
index 0342577c2554..504bb41b6488 100644
--- a/ydb/core/tx/columnshard/engines/reader/common/conveyor_task.h
+++ b/ydb/core/tx/columnshard/engines/reader/common/conveyor_task.h
@@ -28,7 +28,7 @@ class IDataTasksProcessor {
         virtual TConclusionStatus DoExecuteImpl() = 0;
 
     protected:
-        virtual TConclusionStatus DoExecute(const std::shared_ptr<NConveyor::ITask>& taskPtr) override final;
+        virtual void DoExecute(const std::shared_ptr<NConveyor::ITask>& taskPtr) override final;
         virtual void DoOnCannotExecute(const TString& reason) override;
 
     public:
diff --git a/ydb/core/tx/columnshard/engines/reader/common/description.h b/ydb/core/tx/columnshard/engines/reader/common/description.h
index a08291316ec8..0572c4e8fc40 100644
--- a/ydb/core/tx/columnshard/engines/reader/common/description.h
+++ b/ydb/core/tx/columnshard/engines/reader/common/description.h
@@ -1,12 +1,18 @@
 #pragma once
-#include <ydb/core/tx/columnshard/common/snapshot.h>
 #include <ydb/core/tx/columnshard/common/path_id.h>
+#include <ydb/core/tx/columnshard/common/snapshot.h>
 #include <ydb/core/tx/columnshard/engines/predicate/filter.h>
 #include <ydb/core/tx/program/program.h>
 
 #include <ydb/library/yql/dq/actors/protos/dq_stats.pb.h>
 namespace NKikimr::NOlap::NReader {
 
+enum class ERequestSorting {
+    NONE = 0 /* "not_sorted" */,
+    ASC /* "ascending" */,
+    DESC /* "descending" */,
+};
+
 // Describes read/scan request
 struct TReadDescription {
 private:
@@ -14,6 +20,8 @@ struct TReadDescription {
     TProgramContainer Program;
     std::shared_ptr<IScanCursor> ScanCursor;
     YDB_ACCESSOR_DEF(TString, ScanIdentifier);
+    YDB_ACCESSOR(ERequestSorting, Sorting, ERequestSorting::NONE);
+    YDB_READONLY(ui64, TabletId, 0);
 
 public:
     // Table
@@ -40,9 +48,11 @@ struct TReadDescription {
         ScanCursor = cursor;
     }
 
-    TReadDescription(const TSnapshot& snapshot, const bool isReverse)
+    TReadDescription(const ui64 tabletId, const TSnapshot& snapshot, const ERequestSorting sorting)
         : Snapshot(snapshot)
-        , PKRangesFilter(std::make_shared<NOlap::TPKRangesFilter>(isReverse)) {
+        , Sorting(sorting)
+        , TabletId(tabletId)
+        , PKRangesFilter(std::make_shared<NOlap::TPKRangesFilter>()) {
     }
 
     void SetProgram(TProgramContainer&& value) {
@@ -58,4 +68,4 @@ struct TReadDescription {
     }
 };
 
-}
+}   // namespace NKikimr::NOlap::NReader
diff --git a/ydb/core/tx/columnshard/engines/reader/common/result.cpp b/ydb/core/tx/columnshard/engines/reader/common/result.cpp
index 92f55f3dfc77..38805a998232 100644
--- a/ydb/core/tx/columnshard/engines/reader/common/result.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/common/result.cpp
@@ -55,12 +55,12 @@ std::vector<std::shared_ptr<TPartialReadResult>> TPartialReadResult::SplitResult
 TPartialReadResult::TPartialReadResult(const std::vector<std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>>& resourceGuards,
     const std::shared_ptr<NGroupedMemoryManager::TGroupGuard>& gGuard, const NArrow::TShardedRecordBatch& batch,
     const std::shared_ptr<IScanCursor>& scanCursor, const std::shared_ptr<TReadContext>& context,
-    const std::optional<ui32> notFinishedIntervalIdx)
+    const std::optional<TPartialSourceAddress> notFinishedInterval)
     : ResourceGuards(resourceGuards)
     , GroupGuard(gGuard)
     , ResultBatch(batch)
     , ScanCursor(scanCursor)
-    , NotFinishedIntervalIdx(notFinishedIntervalIdx)
+    , NotFinishedInterval(notFinishedInterval)
     , Guard(TValidator::CheckNotNull(context)->GetCounters().GetResultsForReplyGuard()) {
     Y_ABORT_UNLESS(ResultBatch.GetRecordsCount());
     Y_ABORT_UNLESS(ScanCursor);
diff --git a/ydb/core/tx/columnshard/engines/reader/common/result.h b/ydb/core/tx/columnshard/engines/reader/common/result.h
index f4e7d7d4b1ee..6fff2c86083c 100644
--- a/ydb/core/tx/columnshard/engines/reader/common/result.h
+++ b/ydb/core/tx/columnshard/engines/reader/common/result.h
@@ -12,6 +12,22 @@ namespace NKikimr::NOlap::NReader {
 
 class TReadContext;
 
+class TPartialSourceAddress {
+private:
+    YDB_READONLY(ui32, SourceId, 0);
+    YDB_READONLY(ui32, SourceIdx, 0);
+    YDB_READONLY(ui32, SyncPointIndex, 0);
+
+public:
+    TPartialSourceAddress(const ui32 sourceId, const ui32 sourceIdx, const ui32 syncPointIndex)
+        : SourceId(sourceId)
+        , SourceIdx(sourceIdx)
+        , SyncPointIndex(syncPointIndex)
+    {
+    
+    }
+};
+
 // Represents a batch of rows produced by ASC or DESC scan with applied filters and partial aggregation
 class TPartialReadResult: public TNonCopyable {
 private:
@@ -22,7 +38,7 @@ class TPartialReadResult: public TNonCopyable {
     // This 1-row batch contains the last key that was read while producing the ResultBatch.
     // NOTE: it might be different from the Key of last row in ResulBatch in case of filtering/aggregation/limit
     std::shared_ptr<IScanCursor> ScanCursor;
-    YDB_READONLY_DEF(std::optional<ui32>, NotFinishedIntervalIdx);
+    YDB_READONLY_DEF(std::optional<TPartialSourceAddress>, NotFinishedInterval);
     const NColumnShard::TCounterGuard Guard;
 
 public:
@@ -61,11 +77,11 @@ class TPartialReadResult: public TNonCopyable {
     explicit TPartialReadResult(const std::vector<std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>>& resourceGuards,
         const std::shared_ptr<NGroupedMemoryManager::TGroupGuard>& gGuard, const NArrow::TShardedRecordBatch& batch,
         const std::shared_ptr<IScanCursor>& scanCursor, const std::shared_ptr<TReadContext>& context,
-        const std::optional<ui32> notFinishedIntervalIdx);
+        const std::optional<TPartialSourceAddress> notFinishedInterval);
 
     explicit TPartialReadResult(const NArrow::TShardedRecordBatch& batch, const std::shared_ptr<IScanCursor>& scanCursor,
-        const std::shared_ptr<TReadContext>& context, const std::optional<ui32> notFinishedIntervalIdx)
-        : TPartialReadResult({}, nullptr, batch, scanCursor, context, notFinishedIntervalIdx) {
+        const std::shared_ptr<TReadContext>& context, const std::optional<TPartialSourceAddress> notFinishedInterval)
+        : TPartialReadResult({}, nullptr, batch, scanCursor, context, notFinishedInterval) {
     }
 };
 
diff --git a/ydb/core/tx/columnshard/engines/reader/common/ya.make b/ydb/core/tx/columnshard/engines/reader/common/ya.make
index 8c7beb01bd69..d2b891818ea7 100644
--- a/ydb/core/tx/columnshard/engines/reader/common/ya.make
+++ b/ydb/core/tx/columnshard/engines/reader/common/ya.make
@@ -13,4 +13,6 @@ PEERDIR(
     ydb/core/formats/arrow/reader
 )
 
+GENERATE_ENUM_SERIALIZATION(description.h)
+
 END()
diff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/constructor/read_metadata.cpp b/ydb/core/tx/columnshard/engines/reader/common_reader/constructor/read_metadata.cpp
index e3cf7231287a..a42de044970c 100644
--- a/ydb/core/tx/columnshard/engines/reader/common_reader/constructor/read_metadata.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/constructor/read_metadata.cpp
@@ -43,8 +43,8 @@ TConclusionStatus TReadMetadata::Init(
 }
 
 TReadMetadata::TReadMetadata(const std::shared_ptr<TVersionedIndex>& schemaIndex, const TReadDescription& read)
-    : TBase(schemaIndex, read.PKRangesFilter->IsReverse() ? TReadMetadataBase::ESorting::DESC : TReadMetadataBase::ESorting::ASC,
-          read.GetProgram(), schemaIndex->GetSchemaVerified(read.GetSnapshot()), read.GetSnapshot(), read.GetScanCursorOptional())
+    : TBase(schemaIndex, read.GetSorting(), read.GetProgram(), schemaIndex->GetSchemaVerified(read.GetSnapshot()), read.GetSnapshot(),
+          read.GetScanCursorOptional(), read.GetTabletId())
     , PathId(read.PathId)
     , ReadStats(std::make_shared<TReadStats>()) {
 }
diff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/columns_set.h b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/columns_set.h
index a21652522430..4a14d95727f2 100644
--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/columns_set.h
+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/columns_set.h
@@ -14,13 +14,6 @@ enum class EMemType {
     RawSequential
 };
 
-enum class EStageFeaturesIndexes {
-    Accessors = 0,
-    Filter = 1,
-    Fetching = 2,
-    Merge = 3
-};
-
 class TIndexesSet {
 private:
     YDB_READONLY_DEF(std::vector<ui32>, IndexIds);
diff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/constructor.cpp b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/constructor.cpp
index 800ef6841e73..6d4027801631 100644
--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/constructor.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/constructor.cpp
@@ -10,7 +10,7 @@ void TBlobsFetcherTask::DoOnDataReady(const std::shared_ptr<NResourceBroker::NSu
     FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, Source->AddEvent("fbf"));
     Source->MutableStageData().AddBlobs(Source->DecodeBlobAddresses(ExtractBlobsData()));
     AFL_VERIFY(Step.Next());
-    auto task = std::make_shared<TStepAction>(Source, std::move(Step), Context->GetCommonContext()->GetScanActorId());
+    auto task = std::make_shared<TStepAction>(Source, std::move(Step), Context->GetCommonContext()->GetScanActorId(), false);
     NConveyor::TScanServiceOperator::SendTaskToExecute(task, Context->GetCommonContext()->GetConveyorProcessId());
 }
 
@@ -54,7 +54,7 @@ void TColumnsFetcherTask::DoOnDataReady(const std::shared_ptr<NResourceBroker::N
         for (auto&& i : DataFetchers) {
             Source->MutableStageData().AddFetcher(i.second);
         }
-        auto task = std::make_shared<TStepAction>(Source, std::move(Cursor), Source->GetContext()->GetCommonContext()->GetScanActorId());
+        auto task = std::make_shared<TStepAction>(Source, std::move(Cursor), Source->GetContext()->GetCommonContext()->GetScanActorId(), false);
         NConveyor::TScanServiceOperator::SendTaskToExecute(task, Source->GetContext()->GetCommonContext()->GetConveyorProcessId());
     } else {
         FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, Source->AddEvent("cf_next"));
diff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/default_fetching.h b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/default_fetching.h
index ab886429a77e..4a0cc71cb5f3 100644
--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/default_fetching.h
+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/default_fetching.h
@@ -6,6 +6,15 @@ namespace NKikimr::NOlap::NReader::NCommon {
 class TDefaultFetchLogic: public IKernelFetchLogic {
 private:
     using TBase = IKernelFetchLogic;
+    std::optional<bool> IsEmptyChunks;
+
+    std::shared_ptr<NArrow::NAccessor::TColumnLoader> GetColumnLoader(const std::shared_ptr<NCommon::IDataSource>& source) const {
+        if (auto loader = source->GetSourceSchema()->GetColumnLoaderOptional(GetEntityId())) {
+            return loader;
+        }
+        AFL_VERIFY(IsEmptyChunks && *IsEmptyChunks);
+        return source->GetContext()->GetReadMetadata()->GetResultSchema()->GetColumnLoaderVerified(GetEntityId());
+    }
 
     class TChunkRestoreInfo {
     private:
@@ -36,6 +45,7 @@ class TDefaultFetchLogic: public IKernelFetchLogic {
 
         void SetBlobData(const TString& data) {
             AFL_VERIFY(!Data);
+            BlobRange.reset();
             Data.emplace(data);
         }
     };
@@ -49,8 +59,7 @@ class TDefaultFetchLogic: public IKernelFetchLogic {
             chunks.emplace_back(i.ExtractDataVerified());
         }
 
-        TPortionDataAccessor::TPreparedColumn column(
-            std::move(chunks), context.GetSource()->GetSourceSchema()->GetColumnLoaderVerified(GetEntityId()));
+        TPortionDataAccessor::TPreparedColumn column(std::move(chunks), GetColumnLoader(context.GetSource()));
         context.GetAccessors().AddVerified(GetEntityId(), column.AssembleAccessor().DetachResult(), true);
     }
 
@@ -70,9 +79,10 @@ class TDefaultFetchLogic: public IKernelFetchLogic {
     virtual void DoStart(TReadActionsCollection& nextRead, TFetchingResultContext& context) override {
         auto source = context.GetSource();
         auto columnChunks = source->GetStageData().GetPortionAccessor().GetColumnChunksPointers(GetEntityId());
+        IsEmptyChunks.emplace(columnChunks.empty());
         if (columnChunks.empty()) {
-            ColumnChunks.emplace_back(source->GetRecordsCount(), TPortionDataAccessor::TAssembleBlobInfo(source->GetRecordsCount(),
-                                                                     source->GetSourceSchema()->GetExternalDefaultValueVerified(GetEntityId())));
+            ColumnChunks.emplace_back(source->GetRecordsCount(),
+                TPortionDataAccessor::TAssembleBlobInfo(source->GetRecordsCount(), GetColumnLoader(context.GetSource())->GetDefaultValue()));
             return;
         }
         StorageId = source->GetColumnStorageId(GetEntityId());
diff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.cpp b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.cpp
index 51bfe780e313..3559e599b051 100644
--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.cpp
@@ -48,25 +48,28 @@ bool TAllocateMemoryStep::TFetchingStepAllocation::DoOnAllocated(std::shared_ptr
         guard->Release();
         return false;
     }
-    if (StageIndex == EStageFeaturesIndexes::Accessors) {
+    if (StageIndex == NArrow::NSSA::IMemoryCalculationPolicy::EStage::Accessors) {
         data->MutableStageData().SetAccessorsGuard(std::move(guard));
     } else {
         data->RegisterAllocationGuard(std::move(guard));
     }
-    Step.Next();
+    if (NeedNextStep) {
+        Step.Next();
+    }
     FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, data->AddEvent("fmalloc"));
-    auto task = std::make_shared<TStepAction>(data, std::move(Step), data->GetContext()->GetCommonContext()->GetScanActorId());
+    auto task = std::make_shared<TStepAction>(data, std::move(Step), data->GetContext()->GetCommonContext()->GetScanActorId(), false);
     NConveyor::TScanServiceOperator::SendTaskToExecute(task, data->GetContext()->GetCommonContext()->GetConveyorProcessId());
     return true;
 }
 
-TAllocateMemoryStep::TFetchingStepAllocation::TFetchingStepAllocation(
-    const std::shared_ptr<IDataSource>& source, const ui64 mem, const TFetchingScriptCursor& step, const EStageFeaturesIndexes stageIndex)
+TAllocateMemoryStep::TFetchingStepAllocation::TFetchingStepAllocation(const std::shared_ptr<IDataSource>& source, const ui64 mem,
+    const TFetchingScriptCursor& step, const NArrow::NSSA::IMemoryCalculationPolicy::EStage stageIndex, const bool needNextStep)
     : TBase(mem)
     , Source(source)
     , Step(step)
     , TasksGuard(source->GetContext()->GetCommonContext()->GetCounters().GetResourcesAllocationTasksGuard())
-    , StageIndex(stageIndex) {
+    , StageIndex(stageIndex)
+    , NeedNextStep(needNextStep) {
 }
 
 void TAllocateMemoryStep::TFetchingStepAllocation::DoOnAllocationImpossible(const TString& errorMessage) {
@@ -75,6 +78,8 @@ void TAllocateMemoryStep::TFetchingStepAllocation::DoOnAllocationImpossible(cons
         FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, sourcePtr->AddEvent("fail_malloc"));
         sourcePtr->GetContext()->GetCommonContext()->AbortWithError(
             "cannot allocate memory for step " + Step.GetName() + ": '" + errorMessage + "'");
+    } else {
+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "allocation_impossible")("error", errorMessage);
     }
 }
 
diff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.h b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.h
index 0123678d75c9..3b8abd40ea48 100644
--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.h
+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.h
@@ -21,25 +21,10 @@ class TAllocateMemoryStep: public IFetchingStep {
     };
     std::vector<TColumnsPack> Packs;
     THashMap<ui32, THashSet<EMemType>> Control;
-    const EStageFeaturesIndexes StageIndex;
+    const NArrow::NSSA::IMemoryCalculationPolicy::EStage StageIndex;
     const std::optional<ui64> PredefinedSize;
 
 protected:
-    class TFetchingStepAllocation: public NGroupedMemoryManager::IAllocation {
-    private:
-        using TBase = NGroupedMemoryManager::IAllocation;
-        std::weak_ptr<IDataSource> Source;
-        TFetchingScriptCursor Step;
-        NColumnShard::TCounterGuard TasksGuard;
-        const EStageFeaturesIndexes StageIndex;
-        virtual bool DoOnAllocated(std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>&& guard,
-            const std::shared_ptr<NGroupedMemoryManager::IAllocation>& allocation) override;
-        virtual void DoOnAllocationImpossible(const TString& errorMessage) override;
-
-    public:
-        TFetchingStepAllocation(const std::shared_ptr<IDataSource>& source, const ui64 mem, const TFetchingScriptCursor& step,
-            const EStageFeaturesIndexes stageIndex);
-    };
     virtual TConclusion<bool> DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step) const override;
     virtual ui64 GetProcessingDataSize(const std::shared_ptr<IDataSource>& source) const override;
     virtual TString DoDebugString() const override {
@@ -53,6 +38,22 @@ class TAllocateMemoryStep: public IFetchingStep {
     }
 
 public:
+    class TFetchingStepAllocation: public NGroupedMemoryManager::IAllocation {
+    private:
+        using TBase = NGroupedMemoryManager::IAllocation;
+        std::weak_ptr<IDataSource> Source;
+        TFetchingScriptCursor Step;
+        NColumnShard::TCounterGuard TasksGuard;
+        const NArrow::NSSA::IMemoryCalculationPolicy::EStage StageIndex;
+        const bool NeedNextStep;
+        virtual bool DoOnAllocated(std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>&& guard,
+            const std::shared_ptr<NGroupedMemoryManager::IAllocation>& allocation) override;
+        virtual void DoOnAllocationImpossible(const TString& errorMessage) override;
+
+    public:
+        TFetchingStepAllocation(const std::shared_ptr<IDataSource>& source, const ui64 mem, const TFetchingScriptCursor& step,
+            const NArrow::NSSA::IMemoryCalculationPolicy::EStage stageIndex, const bool needNextStep = true);
+    };
     void AddAllocation(const TColumnsSetIds& ids, const EMemType memType) {
         if (!ids.GetColumnsCount()) {
             return;
@@ -62,17 +63,17 @@ class TAllocateMemoryStep: public IFetchingStep {
         }
         Packs.emplace_back(ids, memType);
     }
-    EStageFeaturesIndexes GetStage() const {
+    NArrow::NSSA::IMemoryCalculationPolicy::EStage GetStage() const {
         return StageIndex;
     }
 
-    TAllocateMemoryStep(const TColumnsSetIds& columns, const EMemType memType, const EStageFeaturesIndexes stageIndex)
+    TAllocateMemoryStep(const TColumnsSetIds& columns, const EMemType memType, const NArrow::NSSA::IMemoryCalculationPolicy::EStage stageIndex)
         : TBase("ALLOCATE_MEMORY::" + ::ToString(stageIndex))
         , StageIndex(stageIndex) {
         AddAllocation(columns, memType);
     }
 
-    TAllocateMemoryStep(const ui64 memSize, const EStageFeaturesIndexes stageIndex)
+    TAllocateMemoryStep(const ui64 memSize, const NArrow::NSSA::IMemoryCalculationPolicy::EStage stageIndex)
         : TBase("ALLOCATE_MEMORY::" + ::ToString(stageIndex))
         , StageIndex(stageIndex)
         , PredefinedSize(memSize) {
diff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetched_data.h b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetched_data.h
index 6551b39c271d..e80f376d7913 100644
--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetched_data.h
+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetched_data.h
@@ -149,8 +149,8 @@ class TFetchedData {
         }
     }
 
-    bool IsEmptyFiltered() const {
-        return Table->IsEmptyFiltered();
+    bool IsEmptyWithData() const {
+        return Table->HasDataAndResultIsEmpty();
     }
 
     void Clear() {
@@ -177,12 +177,35 @@ class TFetchedData {
     }
 };
 
+class TSourceChunkToReply {
+private:
+    YDB_READONLY(ui32, StartIndex, 0);
+    YDB_READONLY(ui32, RecordsCount, 0);
+    std::shared_ptr<arrow::Table> Table;
+
+public:
+    const std::shared_ptr<arrow::Table>& GetTable() const {
+        AFL_VERIFY(Table);
+        return Table;
+    }
+
+    bool HasData() const {
+        return !!Table && Table->num_rows();
+    }
+
+    TSourceChunkToReply(const ui32 startIndex, const ui32 recordsCount, const std::shared_ptr<arrow::Table>& table)
+        : StartIndex(startIndex)
+        , RecordsCount(recordsCount)
+        , Table(table) {
+    }
+};
+
 class TFetchedResult {
 private:
     YDB_READONLY_DEF(std::shared_ptr<NArrow::TGeneralContainer>, Batch);
     YDB_READONLY_DEF(std::shared_ptr<NArrow::TColumnFilter>, NotAppliedFilter);
     std::optional<std::deque<TPortionDataAccessor::TReadPage>> PagesToResult;
-    std::optional<std::shared_ptr<arrow::Table>> ChunkToReply;
+    std::optional<TSourceChunkToReply> ChunkToReply;
 
     TFetchedResult() = default;
 
@@ -225,7 +248,7 @@ class TFetchedResult {
         AFL_VERIFY(page.GetIndexStart() == indexStart)("real", page.GetIndexStart())("expected", indexStart);
         AFL_VERIFY(page.GetRecordsCount() == recordsCount)("real", page.GetRecordsCount())("expected", recordsCount);
         AFL_VERIFY(!ChunkToReply);
-        ChunkToReply = std::move(table);
+        ChunkToReply = TSourceChunkToReply(indexStart, recordsCount, std::move(table));
     }
 
     bool IsFinished() const {
@@ -236,7 +259,7 @@ class TFetchedResult {
         return !!ChunkToReply;
     }
 
-    std::shared_ptr<arrow::Table> ExtractResultChunk() {
+    std::optional<TSourceChunkToReply> ExtractResultChunk() {
         AFL_VERIFY(!!ChunkToReply);
         auto result = std::move(*ChunkToReply);
         ChunkToReply.reset();
diff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetching.cpp b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetching.cpp
index dfb83d035a4c..b9a686530b9b 100644
--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetching.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetching.cpp
@@ -15,6 +15,7 @@ namespace NKikimr::NOlap::NReader::NCommon {
 bool TStepAction::DoApply(IDataReader& owner) const {
     if (FinishedFlag) {
         AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "apply");
+        Source->StartSyncSection();
         Source->OnSourceFetchingFinishedSafe(owner, Source);
     }
     return true;
@@ -26,7 +27,7 @@ TConclusionStatus TStepAction::DoExecuteImpl() {
         return TConclusionStatus::Success();
     }
     auto executeResult = Cursor.Execute(Source);
-    if (!executeResult) {
+    if (executeResult.IsFail()) {
         return executeResult;
     }
     if (*executeResult) {
@@ -35,11 +36,17 @@ TConclusionStatus TStepAction::DoExecuteImpl() {
     return TConclusionStatus::Success();
 }
 
-TStepAction::TStepAction(const std::shared_ptr<IDataSource>& source, TFetchingScriptCursor&& cursor, const NActors::TActorId& ownerActorId)
+TStepAction::TStepAction(const std::shared_ptr<IDataSource>& source, TFetchingScriptCursor&& cursor, const NActors::TActorId& ownerActorId,
+    const bool changeSyncSection)
     : TBase(ownerActorId)
     , Source(source)
     , Cursor(std::move(cursor))
     , CountersGuard(Source->GetContext()->GetCommonContext()->GetCounters().GetAssembleTasksGuard()) {
+    if (changeSyncSection) {
+        Source->StartAsyncSection();
+    } else {
+        Source->CheckAsyncSection();
+    }
 }
 
 TConclusion<bool> TFetchingScriptCursor::Execute(const std::shared_ptr<IDataSource>& source) {
@@ -48,14 +55,16 @@ TConclusion<bool> TFetchingScriptCursor::Execute(const std::shared_ptr<IDataSour
     Script->OnExecute();
     AFL_VERIFY(!Script->IsFinished(CurrentStepIdx));
     while (!Script->IsFinished(CurrentStepIdx)) {
-        if (source->HasStageData() && source->GetStageData().IsEmptyFiltered()) {
+        if (source->HasStageData() && source->GetStageData().IsEmptyWithData()) {
             source->OnEmptyStageData(source);
             break;
+        } else if (source->HasStageResult() && source->GetStageResult().IsEmpty()) {
+            break;
         }
         auto step = Script->GetStep(CurrentStepIdx);
         TMemoryProfileGuard mGuard("SCAN_PROFILE::FETCHING::" + step->GetName() + "::" + Script->GetBranchName(),
             IS_DEBUG_LOG_ENABLED(NKikimrServices::TX_COLUMNSHARD_SCAN_MEMORY));
-        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("scan_step", step->DebugString())("scan_step_idx", CurrentStepIdx);
+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("scan_step", step->DebugString())("scan_step_idx", CurrentStepIdx)("source_id", source->GetSourceId());
 
         const TMonotonic startInstant = TMonotonic::Now();
         const TConclusion<bool> resultStep = step->ExecuteInplace(source, *this);
@@ -105,7 +114,8 @@ TString TFetchingScript::ProfileDebugString() const {
     return sb;
 }
 
-void TFetchingScriptBuilder::AddAllocation(const std::set<ui32>& entityIds, const EStageFeaturesIndexes stage, const EMemType mType) {
+void TFetchingScriptBuilder::AddAllocation(
+    const std::set<ui32>& entityIds, const NArrow::NSSA::IMemoryCalculationPolicy::EStage stage, const EMemType mType) {
     if (Steps.size() == 0) {
         AddStep(std::make_shared<TAllocateMemoryStep>(entityIds, mType, stage));
     } else {
@@ -148,7 +158,7 @@ TFetchingScriptBuilder::TFetchingScriptBuilder(const TSpecialReadContext& contex
     : TFetchingScriptBuilder(context.GetReadMetadata()->GetResultSchema(), context.GetMergeColumns()) {
 }
 
-void TFetchingScriptBuilder::AddFetchingStep(const TColumnsSetIds& columns, const EStageFeaturesIndexes stage) {
+void TFetchingScriptBuilder::AddFetchingStep(const TColumnsSetIds& columns, const NArrow::NSSA::IMemoryCalculationPolicy::EStage stage) {
     auto actualColumns = columns - AddedFetchingColumns;
     AddedFetchingColumns += columns;
     if (actualColumns.IsEmpty()) {
@@ -166,7 +176,7 @@ void TFetchingScriptBuilder::AddFetchingStep(const TColumnsSetIds& columns, cons
 }
 
 void TFetchingScriptBuilder::AddAssembleStep(
-    const TColumnsSetIds& columns, const TString& purposeId, const EStageFeaturesIndexes stage, const bool sequential) {
+    const TColumnsSetIds& columns, const TString& purposeId, const NArrow::NSSA::IMemoryCalculationPolicy::EStage stage, const bool sequential) {
     auto actualColumns = columns - AddedAssembleColumns;
     AddedAssembleColumns += columns;
     if (actualColumns.IsEmpty()) {
@@ -182,7 +192,7 @@ void TFetchingScriptBuilder::AddAssembleStep(
             *actualSet = *actualSet - *cross;
         }
         if (!actualSet->IsEmpty()) {
-            AddAllocation(notSequentialColumnIds, stage, EMemType::RawSequential);
+            AddAllocation(actualSet->GetColumnIds(), stage, EMemType::RawSequential);
             AddStep(std::make_shared<TOptionalAssemblerStep>(actualSet, purposeId));
         }
     } else {
diff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetching.h b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetching.h
index 952c3cda3a3f..e8ca12f666d9 100644
--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetching.h
+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetching.h
@@ -1,7 +1,7 @@
 #pragma once
 #include "columns_set.h"
 
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 #include <ydb/core/tx/columnshard/counters/scan.h>
 #include <ydb/core/tx/columnshard/engines/reader/common/conveyor_task.h>
 
@@ -253,7 +253,7 @@ class TFetchingScriptBuilder {
     }
 
 private:
-    void AddAllocation(const std::set<ui32>& entityIds, const EStageFeaturesIndexes stage, const EMemType mType);
+    void AddAllocation(const std::set<ui32>& entityIds, const NArrow::NSSA::IMemoryCalculationPolicy::EStage stage, const EMemType mType);
 
     template <class T, typename... Args>
     std::shared_ptr<T> InsertStep(const ui32 index, Args... args) {
@@ -275,8 +275,9 @@ class TFetchingScriptBuilder {
         Steps.emplace_back(step);
     }
 
-    void AddFetchingStep(const TColumnsSetIds& columns, const EStageFeaturesIndexes stage);
-    void AddAssembleStep(const TColumnsSetIds& columns, const TString& purposeId, const EStageFeaturesIndexes stage, const bool sequential);
+    void AddFetchingStep(const TColumnsSetIds& columns, const NArrow::NSSA::IMemoryCalculationPolicy::EStage stage);
+    void AddAssembleStep(const TColumnsSetIds& columns, const TString& purposeId, const NArrow::NSSA::IMemoryCalculationPolicy::EStage stage,
+        const bool sequential);
 
     static TFetchingScriptBuilder MakeForTests(ISnapshotSchema::TPtr schema, std::shared_ptr<TColumnsSetIds> guaranteeNotOptional = nullptr) {
         return TFetchingScriptBuilder(schema, guaranteeNotOptional ? guaranteeNotOptional : std::make_shared<TColumnsSetIds>());
@@ -331,10 +332,11 @@ class TStepAction: public IDataTasksProcessor::ITask {
     }
 
     template <class T>
-    TStepAction(const std::shared_ptr<T>& source, TFetchingScriptCursor&& cursor, const NActors::TActorId& ownerActorId)
-        : TStepAction(std::static_pointer_cast<IDataSource>(source), std::move(cursor), ownerActorId) {
+    TStepAction(const std::shared_ptr<T>& source, TFetchingScriptCursor&& cursor, const NActors::TActorId& ownerActorId, const bool changeSyncSection)
+        : TStepAction(std::static_pointer_cast<IDataSource>(source), std::move(cursor), ownerActorId, changeSyncSection) {
     }
-    TStepAction(const std::shared_ptr<IDataSource>& source, TFetchingScriptCursor&& cursor, const NActors::TActorId& ownerActorId);
+    TStepAction(const std::shared_ptr<IDataSource>& source, TFetchingScriptCursor&& cursor, const NActors::TActorId& ownerActorId,
+        const bool changeSyncSection);
 };
 
 class TProgramStep: public IFetchingStep {
diff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/iterator.cpp b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/iterator.cpp
index 093daee5a6b3..21a7e016baf1 100644
--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/iterator.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/iterator.cpp
@@ -9,7 +9,6 @@ TColumnShardScanIterator::TColumnShardScanIterator(const std::shared_ptr<TReadCo
     , ReadMetadata(context->GetReadMetadataPtrVerifiedAs<TReadMetadata>())
     , ReadyResults(context->GetCounters()) {
     IndexedData = ReadMetadata->BuildReader(Context);
-    Y_ABORT_UNLESS(Context->GetReadMetadata()->IsSorted());
 }
 
 TConclusion<std::shared_ptr<TPartialReadResult>> TColumnShardScanIterator::GetBatch() {
@@ -25,8 +24,8 @@ TConclusion<bool> TColumnShardScanIterator::ReadNextInterval() {
     return IndexedData->ReadNextInterval();
 }
 
-void TColumnShardScanIterator::DoOnSentDataFromInterval(const ui32 intervalIdx) const {
-    return IndexedData->OnSentDataFromInterval(intervalIdx);
+void TColumnShardScanIterator::DoOnSentDataFromInterval(const TPartialSourceAddress& address) {
+    return IndexedData->OnSentDataFromInterval(address);
 }
 
 TColumnShardScanIterator::~TColumnShardScanIterator() {
diff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/iterator.h b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/iterator.h
index cd570090aa7d..f525af31b9cd 100644
--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/iterator.h
+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/iterator.h
@@ -55,7 +55,7 @@ class TReadyResults {
 
 class TColumnShardScanIterator: public TScanIteratorBase {
 private:
-    virtual void DoOnSentDataFromInterval(const ui32 intervalIdx) const override;
+    virtual void DoOnSentDataFromInterval(const TPartialSourceAddress& address) override;
 
 protected:
     ui64 ItemsRead = 0;
diff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/source.h b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/source.h
index 466250fa20b9..afdc0b4e36f1 100644
--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/source.h
+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/source.h
@@ -114,8 +114,9 @@ class TExecutionContext {
     }
 };
 
-class IDataSource: public ICursorEntity, public NArrow::NSSA::IDataSource, public NColumnShard::TMonitoringObjectsCounter<IDataSource> {
+class IDataSource: public ICursorEntity, public NArrow::NSSA::IDataSource {
 private:
+    TAtomic SyncSectionFlag = 1;
     YDB_READONLY(ui64, SourceId, 0);
     YDB_READONLY(ui32, SourceIdx, 0);
     YDB_READONLY(TSnapshot, RecordSnapshotMin, TSnapshot::Zero());
@@ -153,20 +154,37 @@ class IDataSource: public ICursorEntity, public NArrow::NSSA::IDataSource, publi
         const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const TColumnsSetIds& columns) = 0;
     virtual void DoAssembleColumns(const std::shared_ptr<TColumnsSet>& columns, const bool sequential) = 0;
 
-    NEvLog::TLogsThread Events;
+    std::optional<NEvLog::TLogsThread> Events;
+    std::unique_ptr<TFetchedData> StageData;
 
 protected:
     std::vector<std::shared_ptr<NGroupedMemoryManager::TAllocationGuard>> ResourceGuards;
-    std::unique_ptr<TFetchedData> StageData;
     std::unique_ptr<TFetchedResult> StageResult;
 
 public:
+    void StartAsyncSection() {
+        AFL_VERIFY(AtomicCas(&SyncSectionFlag, 0, 1));
+    }
+
+    void CheckAsyncSection() {
+        AFL_VERIFY(AtomicGet(SyncSectionFlag) == 0);
+    }
+
+    void StartSyncSection() {
+        AFL_VERIFY(AtomicCas(&SyncSectionFlag, 1, 0));
+    }
+
+    bool IsSyncSection() const {
+        return AtomicGet(SyncSectionFlag) == 1;
+    }
+
     void AddEvent(const TString& evDescription) {
-        Events.AddEvent(evDescription);
+        AFL_VERIFY(!!Events);
+        Events->AddEvent(evDescription);
     }
 
     TString GetEventsReport() const {
-        return Events.DebugString();
+        return Events ? Events->DebugString() : Default<TString>();
     }
 
     TExecutionContext& MutableExecutionContext() {
@@ -212,6 +230,7 @@ class IDataSource: public ICursorEntity, public NArrow::NSSA::IDataSource, publi
         , RecordsCount(recordsCount)
         , ShardingVersionOptional(shardingVersion)
         , HasDeletions(hasDeletions) {
+        FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, Events.emplace(NEvLog::TLogsThread()));
         FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, AddEvent("c"));
     }
 
@@ -272,6 +291,10 @@ class IDataSource: public ICursorEntity, public NArrow::NSSA::IDataSource, publi
         return DoStartFetchingColumns(sourcePtr, step, columns);
     }
 
+    void ResetSourceFinishedFlag() {
+        AFL_VERIFY(AtomicCas(&SourceFinishedSafeFlag, 0, 1));
+    }
+
     void OnSourceFetchingFinishedSafe(IDataReader& owner, const std::shared_ptr<IDataSource>& sourcePtr) {
         AFL_VERIFY(AtomicCas(&SourceFinishedSafeFlag, 1, 0));
         AFL_VERIFY(sourcePtr);
@@ -315,8 +338,20 @@ class IDataSource: public ICursorEntity, public NArrow::NSSA::IDataSource, publi
         return false;
     }
 
-    bool HasStageData() const {
-        return !!StageData;
+    void InitStageData(std::unique_ptr<TFetchedData>&& data) {
+        AFL_VERIFY(!StageData);
+        StageData = std::move(data);
+    }
+
+    std::unique_ptr<TFetchedData> ExtractStageData() {
+        AFL_VERIFY(StageData);
+        auto result = std::move(StageData);
+        StageData.reset();
+        return std::move(result);
+    }
+
+    void ClearStageData() {
+        StageData.reset();
     }
 
     const TFetchedData& GetStageData() const {
@@ -324,6 +359,10 @@ class IDataSource: public ICursorEntity, public NArrow::NSSA::IDataSource, publi
         return *StageData;
     }
 
+    bool HasStageData() const {
+        return !!StageData;
+    }
+
     TFetchedData& MutableStageData() {
         AFL_VERIFY(StageData);
         return *StageData;
diff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/sub_columns_fetching.h b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/sub_columns_fetching.h
index a7ff2592f096..57cb35904c8d 100644
--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/sub_columns_fetching.h
+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/sub_columns_fetching.h
@@ -76,12 +76,10 @@ class TColumnChunkRestoreInfo {
                 PartialArray->GetHeader().GetField(i.second.GetColumnIdx()), nullptr, 0);
             source->GetContext()->GetCommonContext()->GetCounters().GetSubColumns()->GetColumnCounters().OnRead(
                 i.second.GetBlobDataVerified().size());
-            std::vector<NArrow::NAccessor::TDeserializeChunkedArray::TChunk> chunks = { NArrow::NAccessor::TDeserializeChunkedArray::TChunk(
-                GetRecordsCount(), i.second.GetBlobDataVerified()) };
             const std::shared_ptr<NArrow::NAccessor::IChunkedArray> arrOriginal =
-                deserialize
-                    ? columnLoader->ApplyVerified(i.second.GetBlobDataVerified(), GetRecordsCount())
-                    : std::make_shared<NArrow::NAccessor::TDeserializeChunkedArray>(GetRecordsCount(), columnLoader, std::move(chunks), true);
+                deserialize ? columnLoader->ApplyVerified(i.second.GetBlobDataVerified(), GetRecordsCount())
+                            : std::make_shared<NArrow::NAccessor::TDeserializeChunkedArray>(
+                                  GetRecordsCount(), columnLoader, i.second.GetBlobDataVerified(), true);
             if (applyFilter) {
                 PartialArray->AddColumn(i.first, applyFilter->Apply(arrOriginal));
             } else {
diff --git a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/ya.make b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/ya.make
index 1f3ed011557d..6dd94c3943c8 100644
--- a/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/ya.make
+++ b/ydb/core/tx/columnshard/engines/reader/common_reader/iterator/ya.make
@@ -15,6 +15,7 @@ SRCS(
 
 PEERDIR(
     ydb/core/tx/columnshard/engines/scheme
+    ydb/core/formats/arrow/accessor/sub_columns
     yql/essentials/minikql
     ydb/core/util/evlog
 )
diff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/constructor.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/constructor.cpp
index d3654d881f57..ee01720c604c 100644
--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/constructor.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/constructor/constructor.cpp
@@ -35,7 +35,11 @@ NKikimr::TConclusion<std::shared_ptr<TReadMetadataBase>> TIndexScannerConstructo
 
     TDataStorageAccessor dataAccessor(insertTable, index);
     AFL_VERIFY(read.PathId);
-    auto readMetadata = std::make_shared<TReadMetadata>(index->CopyVersionedIndexPtr(), read);
+    auto readCopy = read;
+    if (readCopy.GetSorting() == ERequestSorting::NONE) {
+        readCopy.SetSorting(ERequestSorting::ASC);
+    }
+    auto readMetadata = std::make_shared<TReadMetadata>(index->CopyVersionedIndexPtr(), readCopy);
 
     auto initResult = readMetadata->Init(self, read, dataAccessor);
     if (!initResult) {
diff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.cpp
index ae2deb2810ea..2636db28693e 100644
--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.cpp
@@ -30,7 +30,7 @@ std::shared_ptr<TFetchingScript> TSpecialReadContext::DoGetColumnsFetchingPlan(c
         if (!AskAccumulatorsScript) {
             NCommon::TFetchingScriptBuilder acc(*this);
             if (ui64 size = source->PredictAccessorsMemory()) {
-                acc.AddStep(std::make_shared<NCommon::TAllocateMemoryStep>(size, EStageFeaturesIndexes::Accessors));
+                acc.AddStep(std::make_shared<NCommon::TAllocateMemoryStep>(size, NArrow::NSSA::IMemoryCalculationPolicy::EStage::Accessors));
             }
             acc.AddStep(std::make_shared<TPortionAccessorFetchingStep>());
             acc.AddStep(std::make_shared<TDetectInMem>(*GetFFColumns()));
@@ -90,25 +90,25 @@ std::shared_ptr<TFetchingScript> TSpecialReadContext::BuildColumnsFetchingPlan(c
     bool hasFilterSharding = false;
     if (needFilterSharding && !GetShardingColumns()->IsEmpty()) {
         hasFilterSharding = true;
-        acc.AddFetchingStep(*GetShardingColumns(), EStageFeaturesIndexes::Filter);
+        acc.AddFetchingStep(*GetShardingColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);
         if (!exclusiveSource) {
-            acc.AddFetchingStep(*GetPKColumns(), EStageFeaturesIndexes::Filter);
-            acc.AddFetchingStep(*GetSpecColumns(), EStageFeaturesIndexes::Filter);
+            acc.AddFetchingStep(*GetPKColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);
+            acc.AddFetchingStep(*GetSpecColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);
         }
-        acc.AddAssembleStep(acc.GetAddedFetchingColumns(), "SPEC_SHARDING", EStageFeaturesIndexes::Filter, false);
+        acc.AddAssembleStep(acc.GetAddedFetchingColumns(), "SPEC_SHARDING", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);
         acc.AddStep(std::make_shared<TShardingFilter>());
     }
     if (!GetEFColumns()->GetColumnsCount() && !partialUsageByPredicate) {
         acc.SetBranchName("simple");
-        acc.AddFetchingStep(*GetFFColumns(), EStageFeaturesIndexes::Fetching);
+        acc.AddFetchingStep(*GetFFColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching);
         if (needFilterDeletion) {
-            acc.AddFetchingStep(*GetDeletionColumns(), EStageFeaturesIndexes::Fetching);
+            acc.AddFetchingStep(*GetDeletionColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching);
         }
         if (needSnapshots) {
-            acc.AddFetchingStep(*GetSpecColumns(), EStageFeaturesIndexes::Fetching);
+            acc.AddFetchingStep(*GetSpecColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching);
         }
         if (!exclusiveSource) {
-            acc.AddFetchingStep(*GetMergeColumns(), EStageFeaturesIndexes::Fetching);
+            acc.AddFetchingStep(*GetMergeColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching);
         } else {
             if (acc.GetAddedFetchingColumns().GetColumnsCount() == 1 && GetSpecColumns()->Contains(acc.GetAddedFetchingColumns()) && !hasFilterSharding) {
                 return nullptr;
@@ -116,76 +116,77 @@ std::shared_ptr<TFetchingScript> TSpecialReadContext::BuildColumnsFetchingPlan(c
         }
         if (acc.GetAddedFetchingColumns().GetColumnsCount() || hasFilterSharding || needFilterDeletion) {
             if (needSnapshots) {
-                acc.AddAssembleStep(*GetSpecColumns(), "SPEC", EStageFeaturesIndexes::Fetching, false);
+                acc.AddAssembleStep(*GetSpecColumns(), "SPEC", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching, false);
             }
             if (!exclusiveSource) {
-                acc.AddAssembleStep(*GetMergeColumns(), "LAST_PK", EStageFeaturesIndexes::Fetching, false);
+                acc.AddAssembleStep(*GetMergeColumns(), "LAST_PK", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching, false);
             }
             if (needSnapshots) {
                 acc.AddStep(std::make_shared<TSnapshotFilter>());
             }
             if (needFilterDeletion) {
-                acc.AddAssembleStep(*GetDeletionColumns(), "SPEC_DELETION", EStageFeaturesIndexes::Fetching, false);
+                acc.AddAssembleStep(*GetDeletionColumns(), "SPEC_DELETION", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching, false);
                 acc.AddStep(std::make_shared<TDeletionFilter>());
             }
-            acc.AddAssembleStep(acc.GetAddedFetchingColumns().GetColumnIds(), "LAST", EStageFeaturesIndexes::Fetching, !exclusiveSource);
+            acc.AddAssembleStep(acc.GetAddedFetchingColumns().GetColumnIds(), "LAST", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching,
+                !exclusiveSource);
         } else {
             return nullptr;
         }
     } else if (exclusiveSource) {
         acc.SetBranchName("exclusive");
-        acc.AddFetchingStep(*GetEFColumns(), EStageFeaturesIndexes::Filter);
+        acc.AddFetchingStep(*GetEFColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);
         if (needFilterDeletion) {
-            acc.AddFetchingStep(*GetDeletionColumns(), EStageFeaturesIndexes::Filter);
+            acc.AddFetchingStep(*GetDeletionColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);
         }
         if (needSnapshots || GetFFColumns()->Cross(*GetSpecColumns())) {
-            acc.AddFetchingStep(*GetSpecColumns(), EStageFeaturesIndexes::Filter);
+            acc.AddFetchingStep(*GetSpecColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);
         }
         if (partialUsageByPredicate) {
-            acc.AddFetchingStep(*GetPredicateColumns(), EStageFeaturesIndexes::Filter);
+            acc.AddFetchingStep(*GetPredicateColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);
         }
 
         AFL_VERIFY(acc.GetAddedFetchingColumns().GetColumnsCount());
 
         if (needFilterDeletion) {
-            acc.AddAssembleStep(*GetDeletionColumns(), "SPEC_DELETION", EStageFeaturesIndexes::Filter, false);
+            acc.AddAssembleStep(*GetDeletionColumns(), "SPEC_DELETION", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);
             acc.AddStep(std::make_shared<TDeletionFilter>());
         }
         if (partialUsageByPredicate) {
-            acc.AddAssembleStep(*GetPredicateColumns(), "PREDICATE", EStageFeaturesIndexes::Filter, false);
+            acc.AddAssembleStep(*GetPredicateColumns(), "PREDICATE", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);
             acc.AddStep(std::make_shared<TPredicateFilter>());
         }
         if (needSnapshots || GetFFColumns()->Cross(*GetSpecColumns())) {
-            acc.AddAssembleStep(*GetSpecColumns(), "SPEC", EStageFeaturesIndexes::Filter, false);
+            acc.AddAssembleStep(*GetSpecColumns(), "SPEC", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);
             acc.AddStep(std::make_shared<TSnapshotFilter>());
         } else if (GetProgramInputColumns()->Cross(*GetSpecColumns())) {
             acc.AddStep(std::make_shared<TBuildFakeSpec>());
         }
-        acc.AddFetchingStep(*GetFFColumns(), EStageFeaturesIndexes::Fetching);
-        acc.AddAssembleStep(*GetFFColumns(), "LAST", EStageFeaturesIndexes::Fetching, !exclusiveSource);
+        acc.AddFetchingStep(*GetFFColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching);
+        acc.AddAssembleStep(*GetFFColumns(), "LAST", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching, !exclusiveSource);
     } else {
         acc.SetBranchName("merge");
-        acc.AddFetchingStep(*GetMergeColumns(), EStageFeaturesIndexes::Filter);
-        acc.AddFetchingStep(*GetEFColumns(), EStageFeaturesIndexes::Filter);
+        acc.AddFetchingStep(*GetMergeColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);
+        acc.AddFetchingStep(*GetEFColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);
         if (needFilterDeletion) {
-            acc.AddFetchingStep(*GetDeletionColumns(), EStageFeaturesIndexes::Filter);
+            acc.AddFetchingStep(*GetDeletionColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);
         }
         AFL_VERIFY(acc.GetAddedFetchingColumns().GetColumnsCount());
 
-        acc.AddAssembleStep(*GetSpecColumns(), "SPEC", EStageFeaturesIndexes::Filter, false);
-        acc.AddAssembleStep(*GetPKColumns(), "PK", EStageFeaturesIndexes::Filter, false);
+        acc.AddAssembleStep(*GetSpecColumns(), "SPEC", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);
+        acc.AddAssembleStep(*GetPKColumns(), "PK", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);
         if (needSnapshots) {
             acc.AddStep(std::make_shared<TSnapshotFilter>());
         }
         if (needFilterDeletion) {
-            acc.AddAssembleStep(*GetDeletionColumns(), "SPEC_DELETION", EStageFeaturesIndexes::Filter, false);
+            acc.AddAssembleStep(*GetDeletionColumns(), "SPEC_DELETION", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);
             acc.AddStep(std::make_shared<TDeletionFilter>());
         }
         if (partialUsageByPredicate) {
             acc.AddStep(std::make_shared<TPredicateFilter>());
         }
-        acc.AddFetchingStep(*GetFFColumns(), EStageFeaturesIndexes::Fetching);
-        acc.AddAssembleStep(*GetFFColumns(), "LAST", EStageFeaturesIndexes::Fetching, !exclusiveSource);
+        acc.AddFetchingStep(*GetFFColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching);
+        acc.AddAssembleStep(*GetFFColumns(), "LAST", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching, !exclusiveSource);
     }
     acc.AddStep(std::make_shared<NCommon::TBuildStageResultStep>());
     return std::move(acc).Build();
diff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.h
index 4d35be2eca8f..9500e54a3cf1 100644
--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.h
+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/context.h
@@ -13,7 +13,6 @@ namespace NKikimr::NOlap::NReader::NPlain {
 
 class IDataSource;
 using TColumnsSet = NCommon::TColumnsSet;
-using EStageFeaturesIndexes = NCommon::EStageFeaturesIndexes;
 using TColumnsSetIds = NCommon::TColumnsSetIds;
 using EMemType = NCommon::EMemType;
 using TFetchingScript = NCommon::TFetchingScript;
diff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.cpp
index 3c74c4fd25f3..97ddcb1968d0 100644
--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.cpp
@@ -14,9 +14,10 @@ namespace NKikimr::NOlap::NReader::NPlain {
 
 TConclusion<bool> TPredicateFilter::DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& /*step*/) const {
     auto filter = source->GetContext()->GetReadMetadata()->GetPKRangesFilter().BuildFilter(
-        source->GetStageData().GetTable()->ToTable(source->GetContext()->GetReadMetadata()->GetPKRangesFilter().GetColumnIds(
-                                                       source->GetContext()->GetReadMetadata()->GetResultSchema()->GetIndexInfo()),
-            source->GetContext()->GetCommonContext()->GetResolver(), true));
+        source->GetStageData().GetTable()->ToGeneralContainer(source->GetContext()->GetCommonContext()->GetResolver(),
+            source->GetContext()->GetReadMetadata()->GetPKRangesFilter().GetColumnIds(
+                source->GetContext()->GetReadMetadata()->GetResultSchema()->GetIndexInfo()),
+            true));
     source->MutableStageData().AddFilter(filter);
     return true;
 }
@@ -34,7 +35,8 @@ TConclusion<bool> TSnapshotFilter::DoExecuteInplace(const std::shared_ptr<IDataS
 }
 
 TConclusion<bool> TDeletionFilter::DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& /*step*/) const {
-    auto collection = source->GetStageData().GetTable()->SelectOptional(std::vector<ui32>({ (ui32)IIndexInfo::ESpecialColumn::DELETE_FLAG }), false);
+    auto collection =
+        source->GetStageData().GetTable()->SelectOptional(std::vector<ui32>({ (ui32)IIndexInfo::ESpecialColumn::DELETE_FLAG }), false);
     if (!collection) {
         return true;
     }
@@ -86,7 +88,7 @@ TConclusion<bool> TDetectInMem::DoExecuteInplace(const std::shared_ptr<IDataSour
     auto plan = source->GetContext()->GetColumnsFetchingPlan(source);
     source->InitFetchingPlan(plan);
     TFetchingScriptCursor cursor(plan, 0);
-    auto task = std::make_shared<TStepAction>(source, std::move(cursor), source->GetContext()->GetCommonContext()->GetScanActorId());
+    auto task = std::make_shared<TStepAction>(source, std::move(cursor), source->GetContext()->GetCommonContext()->GetScanActorId(), false);
     NConveyor::TScanServiceOperator::SendTaskToExecute(task);
     return false;
 }
@@ -94,9 +96,16 @@ TConclusion<bool> TDetectInMem::DoExecuteInplace(const std::shared_ptr<IDataSour
 TConclusion<bool> TBuildFakeSpec::DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& /*step*/) const {
     std::vector<std::shared_ptr<arrow::Array>> columns;
     for (auto&& f : IIndexInfo::ArrowSchemaSnapshot()->fields()) {
-        source->MutableStageData().GetTable()->AddVerified(IIndexInfo::GetColumnIdVerified(f->name()),
-            std::make_shared<NArrow::NAccessor::TTrivialArray>(
-                NArrow::TThreadSimpleArraysCache::GetConst(f->type(), NArrow::DefaultScalar(f->type()), source->GetRecordsCount())), true);
+        if (source->MutableStageData().GetTable()->HasColumn(IIndexInfo::GetColumnIdVerified(f->name()))) {
+            auto arr = source->MutableStageData().GetTable()->GetArrayVerified(IIndexInfo::GetColumnIdVerified(f->name()));
+            AFL_WARN(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "spec_column_exists")("column_name", f->name())(
+                "col", NArrow::DebugJson(arr, 2, 2).GetStringRobust());
+        } else {
+            source->MutableStageData().GetTable()->AddVerified(IIndexInfo::GetColumnIdVerified(f->name()),
+                std::make_shared<NArrow::NAccessor::TTrivialArray>(
+                    NArrow::TThreadSimpleArraysCache::GetConst(f->type(), NArrow::DefaultScalar(f->type()), source->GetRecordsCount())),
+                true);
+        }
     }
     return true;
 }
diff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.h
index 1e3fa3a98b5a..b2fcbe88b7e9 100644
--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.h
+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/fetching.h
@@ -14,7 +14,6 @@ namespace NKikimr::NOlap::NReader::NPlain {
 
 using TColumnsSet = NCommon::TColumnsSet;
 using TIndexesSet = NCommon::TIndexesSet;
-using EStageFeaturesIndexes = NCommon::EStageFeaturesIndexes;
 using TColumnsSetIds = NCommon::TColumnsSetIds;
 using EMemType = NCommon::EMemType;
 using TFetchingScriptCursor = NCommon::TFetchingScriptCursor;
diff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/interval.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/interval.cpp
index 7f44376f3ad9..a431b81077f4 100644
--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/interval.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/interval.cpp
@@ -20,7 +20,7 @@ void TFetchingInterval::ConstructResult() {
         auto task = std::make_shared<TStartMergeTask>(MergingContext, Context, std::move(Sources));
         task->SetPriority(NConveyor::ITask::EPriority::High);
         NGroupedMemoryManager::TScanMemoryLimiterOperator::SendToAllocation(Context->GetProcessMemoryControlId(),
-            Context->GetCommonContext()->GetScanId(), GetIntervalId(), { task }, (ui32)EStageFeaturesIndexes::Merge);
+            Context->GetCommonContext()->GetScanId(), GetIntervalId(), { task }, (ui32)NArrow::NSSA::IMemoryCalculationPolicy::EStage::Merge);
     }
 }
 
@@ -83,7 +83,7 @@ void TFetchingInterval::OnPartSendingComplete() {
     auto task = std::make_shared<TContinueMergeTask>(MergingContext, Context, std::move(Merger));
     task->SetPriority(NConveyor::ITask::EPriority::High);
     NGroupedMemoryManager::TScanMemoryLimiterOperator::SendToAllocation(Context->GetProcessMemoryControlId(),
-        Context->GetCommonContext()->GetScanId(), GetIntervalId(), { task }, (ui32)EStageFeaturesIndexes::Merge);
+        Context->GetCommonContext()->GetScanId(), GetIntervalId(), { task }, (ui32)NArrow::NSSA::IMemoryCalculationPolicy::EStage::Merge);
 }
 
 }   // namespace NKikimr::NOlap::NReader::NPlain
diff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/merge.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/merge.cpp
index 1432002370ea..9c351d4f7845 100644
--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/merge.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/merge.cpp
@@ -142,7 +142,7 @@ TConclusionStatus TStartMergeTask::DoExecuteImpl() {
         }
     }
     Merger->PutControlPoint(MergingContext->GetFinish(), false);
-    Merger->SkipToLowerBound(MergingContext->GetStart(), MergingContext->GetIncludeStart());
+    Merger->SkipToBound(MergingContext->GetStart(), MergingContext->GetIncludeStart());
     const ui32 originalSourcesCount = Sources.size();
     Sources.clear();
 
diff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/plain_read_data.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/plain_read_data.h
index 960f49541bc6..2b2f5e250fd7 100644
--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/plain_read_data.h
+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/plain_read_data.h
@@ -45,8 +45,8 @@ class TPlainReadData: public IDataReader, TNonCopyable, NColumnShard::TMonitorin
     }
 
 public:
-    virtual void OnSentDataFromInterval(const ui32 intervalIdx) const override {
-        Scanner->OnSentDataFromInterval(intervalIdx);
+    virtual void OnSentDataFromInterval(const TPartialSourceAddress& address) override {
+        Scanner->OnSentDataFromInterval(address);
     }
 
     template <class T>
diff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.cpp
index b0e489fa74ea..076dd63d495d 100644
--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.cpp
@@ -21,10 +21,10 @@ void TScanHead::OnIntervalResult(std::shared_ptr<NGroupedMemoryManager::TAllocat
     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "interval_result_received")("interval_idx", intervalIdx)(
         "intervalId", itInterval->second->GetIntervalId());
     if (newBatch && newBatch->GetRecordsCount()) {
-        std::optional<ui32> callbackIdxSubscriver;
+        std::optional<TPartialSourceAddress> callbackIdxSubscriver;
         std::shared_ptr<NGroupedMemoryManager::TGroupGuard> gGuard;
         if (itInterval->second->HasMerger()) {
-            callbackIdxSubscriver = intervalIdx;
+            callbackIdxSubscriver = TPartialSourceAddress(itInterval->second->GetIntervalId(), intervalIdx, 0);
         } else {
             gGuard = itInterval->second->GetGroupGuard();
         }
@@ -203,4 +203,13 @@ void TScanHead::Abort() {
     Y_ABORT_UNLESS(IsFinished());
 }
 
+void TScanHead::OnSentDataFromInterval(const TPartialSourceAddress& address) const {
+    if (Context->IsAborted()) {
+        return;
+    }
+    auto it = FetchingIntervals.find(address.GetSourceIdx());
+    AFL_VERIFY(it != FetchingIntervals.end())("interval_idx", address.GetSourceIdx())("count", FetchingIntervals.size());
+    it->second->OnPartSendingComplete();
+}
+
 }   // namespace NKikimr::NOlap::NReader::NPlain
diff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.h
index 09649e788147..23888d410815 100644
--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.h
+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/scanner.h
@@ -84,14 +84,7 @@ class TScanHead {
     void DrainSources();
     [[nodiscard]] TConclusionStatus DetectSourcesFeatureInContextIntervalScan(const THashMap<ui32, std::shared_ptr<IDataSource>>& intervalSources, const bool isExclusiveInterval) const;
 public:
-    void OnSentDataFromInterval(const ui32 intervalIdx) const {
-        if (Context->IsAborted()) {
-            return;
-        }
-        auto it = FetchingIntervals.find(intervalIdx);
-        AFL_VERIFY(it != FetchingIntervals.end())("interval_idx", intervalIdx)("count", FetchingIntervals.size());
-        it->second->OnPartSendingComplete();
-    }
+    void OnSentDataFromInterval(const TPartialSourceAddress& address) const;
 
     bool IsReverse() const;
     void Abort();
diff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.cpp b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.cpp
index 1c3945298734..9f74bc79c656 100644
--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.cpp
@@ -28,7 +28,7 @@ void IDataSource::RegisterInterval(TFetchingInterval& interval, const std::share
     if (AtomicCas(&SourceStartedFlag, 1, 0)) {
         SetMemoryGroupId(interval.GetIntervalId());
         AFL_VERIFY(FetchingPlan);
-        StageData = std::make_unique<TFetchedData>(GetExclusiveIntervalOnly(), GetRecordsCount());
+        InitStageData(std::make_unique<TFetchedData>(GetExclusiveIntervalOnly(), GetRecordsCount()));
         AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("InitFetchingPlan", FetchingPlan->DebugString())("source_idx", GetSourceIdx());
         NActors::TLogContextGuard logGuard(NActors::TLogContextBuilder::Build()("source", GetSourceIdx())("method", "InitFetchingPlan"));
         if (GetContext()->IsAborted()) {
@@ -36,7 +36,7 @@ void IDataSource::RegisterInterval(TFetchingInterval& interval, const std::share
             return;
         }
         TFetchingScriptCursor cursor(FetchingPlan, 0);
-        auto task = std::make_shared<TStepAction>(sourcePtr, std::move(cursor), GetContext()->GetCommonContext()->GetScanActorId());
+        auto task = std::make_shared<TStepAction>(sourcePtr, std::move(cursor), GetContext()->GetCommonContext()->GetScanActorId(), true);
         NConveyor::TScanServiceOperator::SendTaskToExecute(task);
     }
 }
@@ -64,15 +64,15 @@ void IDataSource::DoOnEmptyStageData(const std::shared_ptr<NCommon::IDataSource>
         StageResult = TFetchedResult::BuildEmpty();
     } else {
         StageResult = std::make_unique<TFetchedResult>(
-            std::move(StageData), GetContext()->GetMergeColumns()->GetColumnIds(), *GetContext()->GetCommonContext()->GetResolver());
+            ExtractStageData(), GetContext()->GetMergeColumns()->GetColumnIds(), *GetContext()->GetCommonContext()->GetResolver());
     }
-    StageData.reset();
+    ClearStageData();
 }
 
 void IDataSource::DoBuildStageResult(const std::shared_ptr<NCommon::IDataSource>& /*sourcePtr*/) {
     TMemoryProfileGuard mpg("SCAN_PROFILE::STAGE_RESULT", IS_DEBUG_LOG_ENABLED(NKikimrServices::TX_COLUMNSHARD_SCAN_MEMORY));
-    StageResult = std::make_unique<TFetchedResult>(std::move(StageData), *GetContext()->GetCommonContext()->GetResolver());
-    StageData.reset();
+    StageResult = std::make_unique<TFetchedResult>(ExtractStageData(), *GetContext()->GetCommonContext()->GetResolver());
+    ClearStageData();
 }
 
 void TPortionDataSource::NeedFetchColumns(const std::set<ui32>& columnIds, TBlobsAction& blobsAction,
@@ -111,15 +111,15 @@ bool TPortionDataSource::DoStartFetchingColumns(
     const std::shared_ptr<NCommon::IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const TColumnsSetIds& columns) {
     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", step.GetName());
     AFL_VERIFY(columns.GetColumnsCount());
-    AFL_VERIFY(!StageData->GetAppliedFilter() || !StageData->GetAppliedFilter()->IsTotalDenyFilter());
+    AFL_VERIFY(!GetStageData().GetAppliedFilter() || !GetStageData().GetAppliedFilter()->IsTotalDenyFilter());
     auto& columnIds = columns.GetColumnIds();
     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", step.GetName())("fetching_info", step.DebugString());
 
     TBlobsAction action(GetContext()->GetCommonContext()->GetStoragesManager(), NBlobOperations::EConsumer::SCAN);
     {
         THashMap<TChunkAddress, TPortionDataAccessor::TAssembleBlobInfo> nullBlocks;
-        NeedFetchColumns(columnIds, action, nullBlocks, StageData->GetAppliedFilter());
-        StageData->AddDefaults(std::move(nullBlocks));
+        NeedFetchColumns(columnIds, action, nullBlocks, GetStageData().GetAppliedFilter());
+        MutableStageData().AddDefaults(std::move(nullBlocks));
     }
 
     auto readActions = action.GetReadingActions();
@@ -170,7 +170,7 @@ class TPortionAccessorFetchingSubscriber: public IDataAccessorRequestsSubscriber
         AFL_VERIFY(result.GetPortions().size() == 1)("count", result.GetPortions().size());
         Source->MutableStageData().SetPortionAccessor(std::move(result.ExtractPortionsVector().front()));
         AFL_VERIFY(Step.Next());
-        auto task = std::make_shared<TStepAction>(Source, std::move(Step), Source->GetContext()->GetCommonContext()->GetScanActorId());
+        auto task = std::make_shared<TStepAction>(Source, std::move(Step), Source->GetContext()->GetCommonContext()->GetScanActorId(), false);
         NConveyor::TScanServiceOperator::SendTaskToExecute(task);
     }
 
@@ -184,7 +184,7 @@ class TPortionAccessorFetchingSubscriber: public IDataAccessorRequestsSubscriber
 }   // namespace
 
 bool TPortionDataSource::DoStartFetchingAccessor(const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step) {
-    AFL_VERIFY(!StageData->HasPortionAccessor());
+    AFL_VERIFY(!GetStageData().HasPortionAccessor());
     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", step.GetName())("fetching_info", step.DebugString());
 
     std::shared_ptr<TDataAccessorsRequest> request = std::make_shared<TDataAccessorsRequest>("PLAIN::" + step.GetName());
@@ -219,7 +219,8 @@ void TCommittedDataSource::DoAssembleColumns(const std::shared_ptr<TColumnsSet>&
     const ISnapshotSchema::TPtr batchSchema =
         GetContext()->GetReadMetadata()->GetIndexVersions().GetSchemaVerified(GetCommitted().GetSchemaVersion());
     const ISnapshotSchema::TPtr resultSchema = GetContext()->GetReadMetadata()->GetResultSchema();
-    if (!GetStageData().GetTable()->HasAccessors()) {
+    if (!AssembledFlag) {
+        AssembledFlag = true;
         AFL_VERIFY(GetStageData().GetBlobs().size() == 1);
         auto bData = MutableStageData().ExtractBlob(GetStageData().GetBlobs().begin()->first);
         auto schema = GetContext()->GetReadMetadata()->GetBlobSchema(CommittedBlob.GetSchemaVersion());
diff --git a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.h b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.h
index e43e8d75cd86..69cce115dfd2 100644
--- a/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.h
+++ b/ydb/core/tx/columnshard/engines/reader/plain_reader/iterator/source.h
@@ -239,7 +239,7 @@ class TPortionDataSource: public IDataSource {
     }
 
     virtual bool NeedAccessorsFetching() const override {
-        return !StageData || !StageData->HasPortionAccessor();
+        return !HasStageData() || !GetStageData().HasPortionAccessor();
     }
 
     virtual bool DoAddTxConflict() override {
@@ -308,6 +308,7 @@ class TCommittedDataSource: public IDataSource {
     using TBase = IDataSource;
     TCommittedBlob CommittedBlob;
     bool ReadStarted = false;
+    bool AssembledFlag = false;
 
     virtual void DoAbort() override {
     }
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/constructor/constructor.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/constructor/constructor.cpp
index 07b1a7653b12..0363e2385c33 100644
--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/constructor/constructor.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/constructor/constructor.cpp
@@ -43,4 +43,14 @@ NKikimr::TConclusion<std::shared_ptr<TReadMetadataBase>> TIndexScannerConstructo
     return static_pointer_cast<TReadMetadataBase>(readMetadata);
 }
 
+std::shared_ptr<NKikimr::NOlap::IScanCursor> TIndexScannerConstructor::DoBuildCursor() const {
+    switch (Sorting) {
+        case ERequestSorting::ASC:
+        case ERequestSorting::DESC:
+            return std::make_shared<TSimpleScanCursor>();
+        case ERequestSorting::NONE:
+            return std::make_shared<TNotSortedSimpleScanCursor>();
+    }
+}
+
 }   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/constructor/constructor.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/constructor/constructor.h
index 76596f8dd94e..7f52b721565a 100644
--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/constructor/constructor.h
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/constructor/constructor.h
@@ -13,9 +13,7 @@ class TIndexScannerConstructor: public IScannerConstructor {
     using TBase = IScannerConstructor;
     static const inline TFactory::TRegistrator<TIndexScannerConstructor> Registrator =
         TFactory::TRegistrator<TIndexScannerConstructor>(GetClassNameStatic());
-    virtual std::shared_ptr<IScanCursor> DoBuildCursor() const override {
-        return std::make_shared<TSimpleScanCursor>();
-    }
+    virtual std::shared_ptr<IScanCursor> DoBuildCursor() const override;
 
 protected:
     virtual TConclusion<std::shared_ptr<TReadMetadataBase>> DoBuildReadMetadata(const NColumnShard::TColumnShard* self, const TReadDescription& read) const override;
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/abstract.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/abstract.cpp
new file mode 100644
index 000000000000..d40f3ee3b2a5
--- /dev/null
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/abstract.cpp
@@ -0,0 +1,14 @@
+#include "abstract.h"
+
+#include <ydb/core/tx/columnshard/engines/predicate/filter.h>
+
+namespace NKikimr::NOlap::NReader::NSimple {
+
+ISourcesCollection::ISourcesCollection(const std::shared_ptr<TSpecialReadContext>& context)
+    : Context(context) {
+    if (HasAppData() && AppDataVerified().ColumnShardConfig.HasMaxInFlightIntervalsOnRequest()) {
+        MaxInFlight = AppDataVerified().ColumnShardConfig.GetMaxInFlightIntervalsOnRequest();
+    }
+}
+
+}   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/abstract.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/abstract.h
new file mode 100644
index 000000000000..6f9eb00eff23
--- /dev/null
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/abstract.h
@@ -0,0 +1,81 @@
+#pragma once
+#include <ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.h>
+#include <ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.h>
+
+#include <ydb/library/accessor/positive_integer.h>
+
+namespace NKikimr::NOlap::NReader::NSimple {
+
+class ISourcesCollection {
+private:
+    virtual bool DoIsFinished() const = 0;
+    virtual std::shared_ptr<IDataSource> DoExtractNext() = 0;
+    virtual bool DoCheckInFlightLimits() const = 0;
+    virtual void DoOnSourceFinished(const std::shared_ptr<IDataSource>& source) = 0;
+    virtual void DoClear() = 0;
+    virtual void DoAbort() = 0;
+
+    TPositiveControlInteger SourcesInFlightCount;
+    YDB_READONLY(ui64, MaxInFlight, 1024);
+
+    virtual TString DoDebugString() const {
+        return "";
+    }
+    virtual std::shared_ptr<IScanCursor> DoBuildCursor(const std::shared_ptr<IDataSource>& source, const ui32 readyRecords) const = 0;
+    virtual bool DoHasData() const = 0;
+
+protected:
+    const std::shared_ptr<TSpecialReadContext> Context;
+
+public:
+    bool HasData() const {
+        return DoHasData();
+    }
+
+    std::shared_ptr<IScanCursor> BuildCursor(const std::shared_ptr<IDataSource>& source, const ui32 readyRecords, const ui64 tabletId) const {
+        AFL_VERIFY(source);
+        AFL_VERIFY(readyRecords <= source->GetRecordsCount())("count", source->GetRecordsCount())("ready", readyRecords);
+        auto result = DoBuildCursor(source, readyRecords);
+        AFL_VERIFY(result);
+        result->SetTabletId(tabletId);
+        AFL_VERIFY(tabletId);
+        return result;
+    }
+
+    TString DebugString() const {
+        return DoDebugString();
+    }
+
+    virtual ~ISourcesCollection() = default;
+
+    std::shared_ptr<IDataSource> ExtractNext() {
+        SourcesInFlightCount.Inc();
+        return DoExtractNext();
+    }
+
+    bool IsFinished() const {
+        return DoIsFinished();
+    }
+
+    void OnSourceFinished(const std::shared_ptr<IDataSource>& source) {
+        AFL_VERIFY(source);
+        SourcesInFlightCount.Dec();
+        DoOnSourceFinished(source);
+    }
+
+    bool CheckInFlightLimits() const {
+        return DoCheckInFlightLimits();
+    }
+
+    void Clear() {
+        DoClear();
+    }
+
+    void Abort() {
+        DoAbort();
+    }
+
+    ISourcesCollection(const std::shared_ptr<TSpecialReadContext>& context);
+};
+
+}   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/full_scan_sorted.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/full_scan_sorted.cpp
new file mode 100644
index 000000000000..a24f1158b65f
--- /dev/null
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/full_scan_sorted.cpp
@@ -0,0 +1,5 @@
+#include "full_scan_sorted.h"
+
+namespace NKikimr::NOlap::NReader::NSimple {
+
+}   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/full_scan_sorted.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/full_scan_sorted.h
new file mode 100644
index 000000000000..9fe6771159ca
--- /dev/null
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/full_scan_sorted.h
@@ -0,0 +1,65 @@
+#pragma once
+#include "abstract.h"
+
+#include <ydb/library/accessor/positive_integer.h>
+
+namespace NKikimr::NOlap::NReader::NSimple {
+
+class TSortedFullScanCollection: public ISourcesCollection {
+private:
+    using TBase = ISourcesCollection;
+    std::deque<TSourceConstructor> HeapSources;
+    TPositiveControlInteger InFlightCount;
+    ui32 SourceIdx = 0;
+    virtual void DoClear() override {
+        HeapSources.clear();
+    }
+    virtual bool DoHasData() const override {
+        return HeapSources.size();
+    }
+    virtual void DoAbort() override {
+        HeapSources.clear();
+    }
+    virtual bool DoIsFinished() const override {
+        return HeapSources.empty();
+    }
+    virtual std::shared_ptr<IScanCursor> DoBuildCursor(const std::shared_ptr<IDataSource>& source, const ui32 readyRecords) const override {
+        return std::make_shared<TSimpleScanCursor>(source->GetStartPKRecordBatch(), source->GetSourceId(), readyRecords);
+    }
+    virtual std::shared_ptr<IDataSource> DoExtractNext() override {
+        AFL_VERIFY(HeapSources.size());
+        auto result = HeapSources.front().Construct(SourceIdx++, Context);
+        std::pop_heap(HeapSources.begin(), HeapSources.end());
+        HeapSources.pop_back();
+        InFlightCount.Inc();
+        return result;
+    }
+    virtual bool DoCheckInFlightLimits() const override {
+        return InFlightCount < GetMaxInFlight();
+    }
+    virtual void DoOnSourceFinished(const std::shared_ptr<IDataSource>& /*source*/) override {
+        InFlightCount.Dec();
+    }
+
+public:
+    TSortedFullScanCollection(const std::shared_ptr<TSpecialReadContext>& context, std::deque<TSourceConstructor>&& sources,
+        const std::shared_ptr<IScanCursor>& cursor)
+        : TBase(context) {
+        if (cursor && cursor->IsInitialized()) {
+            for (auto&& i : sources) {
+                bool usage = false;
+                if (!context->GetCommonContext()->GetScanCursor()->CheckEntityIsBorder(i, usage)) {
+                    continue;
+                }
+                if (usage) {
+                    i.SetIsStartedByCursor();
+                }
+                break;
+            }
+        }
+        HeapSources = std::move(sources);
+        std::make_heap(HeapSources.begin(), HeapSources.end());
+    }
+};
+
+}   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/limit_sorted.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/limit_sorted.cpp
new file mode 100644
index 000000000000..33b2c050e534
--- /dev/null
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/limit_sorted.cpp
@@ -0,0 +1,51 @@
+#include "limit_sorted.h"
+
+namespace NKikimr::NOlap::NReader::NSimple {
+
+std::shared_ptr<IDataSource> TScanWithLimitCollection::DoExtractNext() {
+    AFL_VERIFY(HeapSources.size());
+    std::pop_heap(HeapSources.begin(), HeapSources.end());
+    auto result = NextSource ? NextSource : HeapSources.back().Construct(SourceIdxCurrent++, Context);
+    AFL_VERIFY(FetchingInFlightSources.emplace(result->GetSourceId()).second);
+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "DoExtractNext")("source_id", result->GetSourceId());
+    HeapSources.pop_back();
+    if (HeapSources.size()) {
+        NextSource = HeapSources.front().Construct(SourceIdxCurrent++, Context);
+    } else {
+        NextSource = nullptr;
+    }
+    return result;
+}
+
+void TScanWithLimitCollection::DoOnSourceFinished(const std::shared_ptr<IDataSource>& source) {
+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "DoOnSourceFinished")("source_id", source->GetSourceId())("limit", Limit)(
+        "max", GetMaxInFlight())("in_flight_limit", InFlightLimit)("count", FetchingInFlightSources.size());
+    if (!source->GetResultRecordsCount() && InFlightLimit < GetMaxInFlight()) {
+        InFlightLimit = 2 * InFlightLimit;
+    }
+    AFL_VERIFY(Cleared || Aborted || FetchingInFlightSources.erase(source->GetSourceId()))("source_id", source->GetSourceId());
+}
+
+TScanWithLimitCollection::TScanWithLimitCollection(
+    const std::shared_ptr<TSpecialReadContext>& context, std::deque<TSourceConstructor>&& sources, const std::shared_ptr<IScanCursor>& cursor)
+    : TBase(context)
+    , Limit((ui64)Context->GetCommonContext()->GetReadMetadata()->GetLimitRobust()) {
+    HeapSources = std::move(sources);
+    std::make_heap(HeapSources.begin(), HeapSources.end());
+    if (cursor && cursor->IsInitialized()) {
+        while (HeapSources.size()) {
+            bool usage = false;
+            if (!context->GetCommonContext()->GetScanCursor()->CheckEntityIsBorder(HeapSources.front(), usage)) {
+                std::pop_heap(HeapSources.begin(), HeapSources.end());
+                HeapSources.pop_back();
+                continue;
+            }
+            if (usage) {
+                HeapSources.front().SetIsStartedByCursor();
+            }
+            break;
+        }
+    }
+}
+
+}   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/limit_sorted.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/limit_sorted.h
new file mode 100644
index 000000000000..e04b1059645b
--- /dev/null
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/limit_sorted.h
@@ -0,0 +1,79 @@
+#pragma once
+#include "abstract.h"
+
+#include <ydb/library/accessor/positive_integer.h>
+
+namespace NKikimr::NOlap::NReader::NSimple {
+
+class TScanWithLimitCollection: public ISourcesCollection {
+private:
+    using TBase = ISourcesCollection;
+    class TFinishedDataSource {
+    private:
+        YDB_READONLY(ui32, RecordsCount, 0);
+        YDB_READONLY(ui32, SourceId, 0);
+        YDB_READONLY(ui32, SourceIdx, 0);
+
+    public:
+        TFinishedDataSource(const std::shared_ptr<IDataSource>& source)
+            : RecordsCount(source->GetResultRecordsCount())
+            , SourceId(source->GetSourceId())
+            , SourceIdx(source->GetSourceIdx()) {
+        }
+
+        TFinishedDataSource(const std::shared_ptr<IDataSource>& source, const ui32 partSize)
+            : RecordsCount(partSize)
+            , SourceId(source->GetSourceId())
+            , SourceIdx(source->GetSourceIdx()) {
+            AFL_VERIFY(partSize < source->GetResultRecordsCount());
+        }
+    };
+
+    virtual bool DoHasData() const override {
+        return HeapSources.size();
+    }
+    ui32 SourceIdxCurrent = 0;
+    std::shared_ptr<IDataSource> NextSource;
+    std::deque<TSourceConstructor> HeapSources;
+    ui64 Limit = 0;
+    ui64 InFlightLimit = 1;
+    std::set<ui32> FetchingInFlightSources;
+    bool Aborted = false;
+    bool Cleared = false;
+
+    void DrainToLimit();
+
+    virtual std::shared_ptr<IScanCursor> DoBuildCursor(const std::shared_ptr<IDataSource>& source, const ui32 readyRecords) const override {
+        return std::make_shared<TSimpleScanCursor>(nullptr, source->GetSourceId(), readyRecords);
+    }
+    virtual void DoClear() override {
+        Cleared = true;
+        HeapSources.clear();
+        FetchingInFlightSources.clear();
+    }
+    virtual void DoAbort() override {
+        Aborted = true;
+        HeapSources.clear();
+        FetchingInFlightSources.clear();
+    }
+    virtual bool DoIsFinished() const override {
+        return HeapSources.empty() && FetchingInFlightSources.empty();
+    }
+    virtual std::shared_ptr<IDataSource> DoExtractNext() override;
+    virtual bool DoCheckInFlightLimits() const override {
+        return FetchingInFlightSources.size() < InFlightLimit;
+    }
+
+    virtual void DoOnSourceFinished(const std::shared_ptr<IDataSource>& source) override;
+    ui32 GetInFlightIntervalsCount(const TCompareKeyForScanSequence& from, const TCompareKeyForScanSequence& to) const;
+
+public:
+    const std::shared_ptr<IDataSource>& GetNextSource() const {
+        return NextSource;
+    }
+
+    TScanWithLimitCollection(const std::shared_ptr<TSpecialReadContext>& context, std::deque<TSourceConstructor>&& sources,
+        const std::shared_ptr<IScanCursor>& cursor);
+};
+
+}   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/not_sorted.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/not_sorted.cpp
new file mode 100644
index 000000000000..8962f0263340
--- /dev/null
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/not_sorted.cpp
@@ -0,0 +1,10 @@
+#include "not_sorted.h"
+
+namespace NKikimr::NOlap::NReader::NSimple {
+
+    std::shared_ptr<NKikimr::NOlap::IScanCursor> TNotSortedCollection::DoBuildCursor(
+    const std::shared_ptr<IDataSource>& source, const ui32 readyRecords) const {
+    return std::make_shared<TNotSortedSimpleScanCursor>(source->GetSourceId(), readyRecords);
+}
+
+}   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/not_sorted.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/not_sorted.h
new file mode 100644
index 000000000000..45b855d9db0e
--- /dev/null
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/not_sorted.h
@@ -0,0 +1,78 @@
+#pragma once
+#include "abstract.h"
+
+namespace NKikimr::NOlap::NReader::NSimple {
+
+class TNotSortedCollection: public ISourcesCollection {
+private:
+    using TBase = ISourcesCollection;
+    std::optional<ui32> Limit;
+    ui32 InFlightLimit = 1;
+    std::deque<TSourceConstructor> Sources;
+    TPositiveControlInteger InFlightCount;
+    ui32 FetchedCount = 0;
+    ui32 SourceIdx = 0;
+    virtual bool DoHasData() const override {
+        return Sources.size();
+    }
+    virtual void DoClear() override {
+        Sources.clear();
+    }
+    virtual void DoAbort() override {
+        Sources.clear();
+    }
+
+    virtual std::shared_ptr<IScanCursor> DoBuildCursor(const std::shared_ptr<IDataSource>& source, const ui32 readyRecords) const override;
+    virtual bool DoIsFinished() const override {
+        return Sources.empty();
+    }
+    virtual std::shared_ptr<IDataSource> DoExtractNext() override {
+        AFL_VERIFY(Sources.size());
+        auto result = Sources.front().Construct(SourceIdx++, Context);
+        Sources.pop_front();
+        InFlightCount.Inc();
+        return result;
+    }
+    virtual bool DoCheckInFlightLimits() const override {
+        return InFlightCount < InFlightLimit;
+    }
+    virtual void DoOnSourceFinished(const std::shared_ptr<IDataSource>& source) override {
+        if (!source->GetResultRecordsCount() && InFlightLimit * 2 < GetMaxInFlight()) {
+            InFlightLimit *= 2;
+        }
+        FetchedCount += source->GetResultRecordsCount();
+        if (Limit && *Limit <= FetchedCount && Sources.size()) {
+            AFL_NOTICE(NKikimrServices::TX_COLUMNSHARD)("event", "limit_exhausted")("limit", Limit)("fetched", FetchedCount);
+            Sources.clear();
+        }
+        InFlightCount.Dec();
+    }
+
+public:
+    TNotSortedCollection(const std::shared_ptr<TSpecialReadContext>& context, std::deque<TSourceConstructor>&& sources,
+        const std::shared_ptr<IScanCursor>& cursor, const std::optional<ui32> limit)
+        : TBase(context)
+        , Limit(limit) {
+        if (Limit) {
+            InFlightLimit = 1;
+        } else {
+            InFlightLimit = GetMaxInFlight();
+        }
+        if (cursor && cursor->IsInitialized()) {
+            while (sources.size()) {
+                bool usage = false;
+                if (!context->GetCommonContext()->GetScanCursor()->CheckEntityIsBorder(sources.front(), usage)) {
+                    sources.pop_front();
+                    continue;
+                }
+                if (usage) {
+                    sources.front().SetIsStartedByCursor();
+                }
+                break;
+            }
+        }
+        Sources = std::move(sources);
+    }
+};
+
+}   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/ya.make b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/ya.make
new file mode 100644
index 000000000000..640e7bbbe839
--- /dev/null
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/ya.make
@@ -0,0 +1,14 @@
+LIBRARY()
+
+SRCS(
+    abstract.cpp
+    not_sorted.cpp
+    full_scan_sorted.cpp
+    limit_sorted.cpp
+)
+
+PEERDIR(
+    ydb/core/formats/arrow
+)
+
+END()
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.cpp
index edd0fc45092a..59f3601bf55e 100644
--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.cpp
@@ -11,11 +11,11 @@ std::shared_ptr<TFetchingScript> TSpecialReadContext::DoGetColumnsFetchingPlan(c
     const bool needSnapshots = GetReadMetadata()->GetRequestSnapshot() < source->GetRecordSnapshotMax();
     const bool dontNeedColumns = !needSnapshots && GetFFColumns()->GetColumnIds().size() == 1 &&
                                  GetFFColumns()->GetColumnIds().contains(NOlap::NPortion::TSpecialColumns::SPEC_COL_PLAN_STEP_INDEX);
-    if (!dontNeedColumns && !source->GetStageData().HasPortionAccessor()) {
+    if (!dontNeedColumns && !source->HasStageData()) {
         if (!AskAccumulatorsScript) {
             NCommon::TFetchingScriptBuilder acc(*this);
-            acc.AddStep(std::make_shared<NCommon::TAllocateMemoryStep>
-                (source->PredictAccessorsSize(GetFFColumns()->GetColumnIds()), EStageFeaturesIndexes::Accessors));
+            acc.AddStep(std::make_shared<NCommon::TAllocateMemoryStep>(
+                source->PredictAccessorsSize(GetFFColumns()->GetColumnIds()), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Accessors));
             acc.AddStep(std::make_shared<TPortionAccessorFetchingStep>());
             acc.AddStep(std::make_shared<TDetectInMem>(*GetFFColumns()));
             AskAccumulatorsScript = std::move(acc).Build();
@@ -64,31 +64,31 @@ std::shared_ptr<TFetchingScript> TSpecialReadContext::BuildColumnsFetchingPlan(c
     NCommon::TFetchingScriptBuilder acc(*this);
     if (needFilterSharding && !GetShardingColumns()->IsEmpty()) {
         const TColumnsSetIds columnsFetch = *GetShardingColumns();
-        acc.AddFetchingStep(columnsFetch, EStageFeaturesIndexes::Filter);
-        acc.AddAssembleStep(columnsFetch, "SPEC_SHARDING", EStageFeaturesIndexes::Filter, false);
+        acc.AddFetchingStep(columnsFetch, NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);
+        acc.AddAssembleStep(columnsFetch, "SPEC_SHARDING", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);
         acc.AddStep(std::make_shared<TShardingFilter>());
     }
     {
         acc.SetBranchName("exclusive");
         if (needFilterDeletion) {
-            acc.AddFetchingStep(*GetDeletionColumns(), EStageFeaturesIndexes::Filter);
+            acc.AddFetchingStep(*GetDeletionColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);
         }
         if (partialUsageByPredicate) {
-            acc.AddFetchingStep(*GetPredicateColumns(), EStageFeaturesIndexes::Filter);
+            acc.AddFetchingStep(*GetPredicateColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);
         }
         if (needSnapshots || GetFFColumns()->Cross(*GetSpecColumns())) {
-            acc.AddFetchingStep(*GetSpecColumns(), EStageFeaturesIndexes::Filter);
+            acc.AddFetchingStep(*GetSpecColumns(), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);
         }
         if (needFilterDeletion) {
-            acc.AddAssembleStep(*GetDeletionColumns(), "SPEC_DELETION", EStageFeaturesIndexes::Filter, false);
+            acc.AddAssembleStep(*GetDeletionColumns(), "SPEC_DELETION", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);
             acc.AddStep(std::make_shared<TDeletionFilter>());
         }
         if (partialUsageByPredicate) {
-            acc.AddAssembleStep(*GetPredicateColumns(), "PREDICATE", EStageFeaturesIndexes::Filter, false);
+            acc.AddAssembleStep(*GetPredicateColumns(), "PREDICATE", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);
             acc.AddStep(std::make_shared<TPredicateFilter>());
         }
         if (needSnapshots || GetFFColumns()->Cross(*GetSpecColumns())) {
-            acc.AddAssembleStep(*GetSpecColumns(), "SPEC", EStageFeaturesIndexes::Filter, false);
+            acc.AddAssembleStep(*GetSpecColumns(), "SPEC", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);
             acc.AddStep(std::make_shared<TSnapshotFilter>());
         }
         const auto& chainProgram = GetReadMetadata()->GetProgram().GetChainVerified();
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.h
index f4e3d0ab36c3..c1859a3062d7 100644
--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.h
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.h
@@ -12,7 +12,6 @@ namespace NKikimr::NOlap::NReader::NSimple {
 
 class IDataSource;
 using TColumnsSet = NCommon::TColumnsSet;
-using EStageFeaturesIndexes = NCommon::EStageFeaturesIndexes;
 using TColumnsSetIds = NCommon::TColumnsSetIds;
 using EMemType = NCommon::EMemType;
 using TFetchingScript = NCommon::TFetchingScript;
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/fetching.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/fetching.cpp
index bd787e135ff3..7d82fa672338 100644
--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/fetching.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/fetching.cpp
@@ -22,9 +22,10 @@ ui64 IFetchingStep::GetProcessingDataSize(const std::shared_ptr<NCommon::IDataSo
 
 TConclusion<bool> TPredicateFilter::DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& /*step*/) const {
     auto filter = source->GetContext()->GetReadMetadata()->GetPKRangesFilter().BuildFilter(
-        source->GetStageData().GetTable()->ToTable(source->GetContext()->GetReadMetadata()->GetPKRangesFilter().GetColumnIds(
-                                                       source->GetContext()->GetReadMetadata()->GetResultSchema()->GetIndexInfo()),
-            source->GetContext()->GetCommonContext()->GetResolver(), true));
+        source->GetStageData().GetTable()->ToGeneralContainer(source->GetContext()->GetCommonContext()->GetResolver(),
+            source->GetContext()->GetReadMetadata()->GetPKRangesFilter().GetColumnIds(
+                source->GetContext()->GetReadMetadata()->GetResultSchema()->GetIndexInfo()),
+            true));
     source->MutableStageData().AddFilter(filter);
     return true;
 }
@@ -99,7 +100,7 @@ TConclusion<bool> TDetectInMem::DoExecuteInplace(const std::shared_ptr<IDataSour
     source->InitFetchingPlan(plan);
     TFetchingScriptCursor cursor(plan, 0);
     FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, source->AddEvent("sdmem"));
-    auto task = std::make_shared<TStepAction>(source, std::move(cursor), source->GetContext()->GetCommonContext()->GetScanActorId());
+    auto task = std::make_shared<TStepAction>(source, std::move(cursor), source->GetContext()->GetCommonContext()->GetScanActorId(), false);
     NConveyor::TScanServiceOperator::SendTaskToExecute(task);
     return false;
 }
@@ -108,25 +109,19 @@ namespace {
 class TApplySourceResult: public IDataTasksProcessor::ITask {
 private:
     using TBase = IDataTasksProcessor::ITask;
-    YDB_READONLY_DEF(std::shared_ptr<arrow::Table>, Result);
     YDB_READONLY_DEF(std::shared_ptr<IDataSource>, Source);
-    YDB_READONLY(ui32, StartIndex, 0);
-    YDB_READONLY(ui32, OriginalRecordsCount, 0);
     NColumnShard::TCounterGuard Guard;
     TFetchingScriptCursor Step;
 
 public:
-    TString GetTaskClassIdentifier() const override {
+    virtual TString GetTaskClassIdentifier() const override {
         return "TApplySourceResult";
     }
 
-    TApplySourceResult(const std::shared_ptr<IDataSource>& source, std::shared_ptr<arrow::Table>&& result, const ui32 startIndex,
-        const ui32 originalRecordsCount, const TFetchingScriptCursor& step)
+    TApplySourceResult(
+        const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& step)
         : TBase(NActors::TActorId())
-        , Result(result)
         , Source(source)
-        , StartIndex(startIndex)
-        , OriginalRecordsCount(originalRecordsCount)
         , Guard(source->GetContext()->GetCommonContext()->GetCounters().GetResultsForSourceGuard())
         , Step(step) {
     }
@@ -137,9 +132,9 @@ class TApplySourceResult: public IDataTasksProcessor::ITask {
     }
     virtual bool DoApply(IDataReader& indexedDataRead) const override {
         auto* plainReader = static_cast<TPlainReadData*>(&indexedDataRead);
-        auto resultCopy = Result;
         Source->SetCursor(Step);
-        plainReader->MutableScanner().OnSourceReady(Source, std::move(resultCopy), StartIndex, OriginalRecordsCount, *plainReader);
+        Source->StartSyncSection();
+        plainReader->MutableScanner().GetResultSyncPoint()->OnSourcePrepared(Source, *plainReader);
         return true;
     }
 };
@@ -155,40 +150,55 @@ TConclusion<bool> TBuildResultStep::DoExecuteInplace(const std::shared_ptr<IData
         AFL_VERIFY(StartIndex == 0);
         AFL_VERIFY(RecordsCount == source->GetRecordsCount())("records_count", RecordsCount)("source", source->GetRecordsCount());
     }
+    contextTableConstruct.SetFilter(source->GetStageResult().GetNotAppliedFilter());
     std::shared_ptr<arrow::Table> resultBatch;
     if (!source->GetStageResult().IsEmpty()) {
         resultBatch = source->GetStageResult().GetBatch()->BuildTableVerified(contextTableConstruct);
-        if (auto filter = source->GetStageResult().GetNotAppliedFilter()) {
-            AFL_VERIFY(filter->Apply(resultBatch, NArrow::TColumnFilter::TApplyContext(StartIndex, RecordsCount).SetTrySlices(true)));
+        if (!resultBatch->num_rows()) {
+            resultBatch = nullptr;
         }
     }
-
+    const ui32 recordsCount = resultBatch ? resultBatch->num_rows() : 0;
+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "TBuildResultStep")("source_id", source->GetSourceId())("count", recordsCount);
+    context->GetCommonContext()->GetCounters().OnSourceFinished(source->GetRecordsCount(), source->GetUsedRawBytes(), recordsCount);
+    source->MutableResultRecordsCount() += recordsCount;
+    if (!resultBatch || !resultBatch->num_rows()) {
+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("empty_source", source->DebugJson().GetStringRobust());
+    }
+    source->MutableStageResult().SetResultChunk(std::move(resultBatch), StartIndex, RecordsCount);
     NActors::TActivationContext::AsActorContext().Send(context->GetCommonContext()->GetScanActorId(),
-        new NColumnShard::TEvPrivate::TEvTaskProcessedResult(
-            std::make_shared<TApplySourceResult>(source, std::move(resultBatch), StartIndex, RecordsCount, step)));
+        new NColumnShard::TEvPrivate::TEvTaskProcessedResult(std::make_shared<TApplySourceResult>(source, step)));
     return false;
 }
 
 TConclusion<bool> TPrepareResultStep::DoExecuteInplace(const std::shared_ptr<IDataSource>& source, const TFetchingScriptCursor& /*step*/) const {
-    NCommon::TFetchingScriptBuilder acc(*source->GetContext());
+    const auto context = source->GetContext();
+    NCommon::TFetchingScriptBuilder acc(*context);
     if (source->IsSourceInMemory()) {
         AFL_VERIFY(source->GetStageResult().GetPagesToResultVerified().size() == 1);
     }
+    AFL_VERIFY(!source->GetStageResult().IsEmpty());
     for (auto&& i : source->GetStageResult().GetPagesToResultVerified()) {
-        if (source->GetIsStartedByCursor() && !source->GetContext()->GetCommonContext()->GetScanCursor()->CheckSourceIntervalUsage(
+        if (source->GetIsStartedByCursor() && !context->GetCommonContext()->GetScanCursor()->CheckSourceIntervalUsage(
                                                   source->GetSourceId(), i.GetIndexStart(), i.GetRecordsCount())) {
+            AFL_WARN(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "TPrepareResultStep_ResultStep_SKIP_CURSOR")("source_id", source->GetSourceId());
             continue;
+        } else {
+            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "TPrepareResultStep_ResultStep")("source_id", source->GetSourceId());
         }
         acc.AddStep(std::make_shared<TBuildResultStep>(i.GetIndexStart(), i.GetRecordsCount()));
     }
     auto plan = std::move(acc).Build();
     AFL_VERIFY(!plan->IsFinished(0));
     source->InitFetchingPlan(plan);
-
-    TFetchingScriptCursor cursor(plan, 0);
-    auto task = std::make_shared<TStepAction>(source, std::move(cursor), source->GetContext()->GetCommonContext()->GetScanActorId());
-    NConveyor::TScanServiceOperator::SendTaskToExecute(task);
-    return false;
+    if (source->NeedFullAnswer()) {
+        TFetchingScriptCursor cursor(plan, 0);
+        auto task = std::make_shared<TStepAction>(source, std::move(cursor), context->GetCommonContext()->GetScanActorId(), false);
+        NConveyor::TScanServiceOperator::SendTaskToExecute(task);
+        return false;
+    } else {
+        return true;
+    }
 }
 
 }   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/fetching.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/fetching.h
index 0a62e6c0a593..d1dcc822b035 100644
--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/fetching.h
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/fetching.h
@@ -15,7 +15,6 @@ namespace NKikimr::NOlap::NReader::NSimple {
 class IDataSource;
 using TColumnsSet = NCommon::TColumnsSet;
 using TIndexesSet = NCommon::TIndexesSet;
-using EStageFeaturesIndexes = NCommon::EStageFeaturesIndexes;
 using TColumnsSetIds = NCommon::TColumnsSetIds;
 using EMemType = NCommon::EMemType;
 using TFetchingScriptCursor = NCommon::TFetchingScriptCursor;
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.cpp
index 485956208185..898c6f92c5db 100644
--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.cpp
@@ -8,7 +8,7 @@ TPlainReadData::TPlainReadData(const std::shared_ptr<TReadContext>& context)
     : TBase(context)
     , SpecialReadContext(std::make_shared<TSpecialReadContext>(context)) {
     ui32 sourceIdx = 0;
-    std::deque<std::shared_ptr<IDataSource>> sources;
+    std::deque<TSourceConstructor> sources;
     const auto& portions = GetReadMetadata()->SelectInfo->Portions;
     ui64 compactedPortionsBytes = 0;
     ui64 insertedPortionsBytes = 0;
@@ -19,9 +19,8 @@ TPlainReadData::TPlainReadData(const std::shared_ptr<TReadContext>& context)
             insertedPortionsBytes += i->GetTotalBlobBytes();
         }
 
-        sources.emplace_back(std::make_shared<TPortionDataSource>(sourceIdx++, i, SpecialReadContext));
+        sources.emplace_back(TSourceConstructor(sourceIdx++, i, context));
     }
-    std::sort(sources.begin(), sources.end(), IDataSource::TCompareStartForScanSequence());
     Scanner = std::make_shared<TScanHead>(std::move(sources), SpecialReadContext);
 
     auto& stats = GetReadMetadata()->ReadStats;
@@ -58,4 +57,11 @@ void TPlainReadData::OnIntervalResult(const std::shared_ptr<TPartialReadResult>&
     PartialResults.emplace_back(result);
 }
 
+void TPlainReadData::OnSentDataFromInterval(const TPartialSourceAddress& sourceAddress) {
+    if (!SpecialReadContext->IsActive()) {
+        return;
+    }
+    Scanner->GetSyncPoint(sourceAddress.GetSyncPointIndex())->Continue(sourceAddress, *this);
+}
+
 }   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.h
index adfe861d6319..19c8e14acedf 100644
--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.h
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.h
@@ -60,12 +60,7 @@ class TPlainReadData: public IDataReader, TNonCopyable, NColumnShard::TMonitorin
     TScanHead& MutableScanner() {
         return *Scanner;
     }
-    virtual void OnSentDataFromInterval(const ui32 sourceIdx) const override {
-        if (!SpecialReadContext->IsActive()) {
-            return;
-        }
-        Scanner->ContinueSource(sourceIdx);
-    }
+    virtual void OnSentDataFromInterval(const TPartialSourceAddress& sourceAddress) override;
 
     void OnIntervalResult(const std::shared_ptr<TPartialReadResult>& result);
 
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/scanner.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/scanner.cpp
index fd0bbde7b3ea..94602e987849 100644
--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/scanner.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/scanner.cpp
@@ -1,6 +1,12 @@
 #include "plain_read_data.h"
 #include "scanner.h"
 
+#include "collections/full_scan_sorted.h"
+#include "collections/limit_sorted.h"
+#include "collections/not_sorted.h"
+#include "sync_points/limit.h"
+#include "sync_points/result.h"
+
 #include <ydb/core/tx/columnshard/engines/reader/abstract/read_metadata.h>
 #include <ydb/core/tx/columnshard/engines/reader/common/result.h>
 
@@ -8,158 +14,39 @@
 
 namespace NKikimr::NOlap::NReader::NSimple {
 
-void TScanHead::OnSourceReady(const std::shared_ptr<IDataSource>& source, std::shared_ptr<arrow::Table>&& tableExt, const ui32 startIndex,
-    const ui32 recordsCount, TPlainReadData& reader) {
-    FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, source->AddEvent("f"));
-    AFL_DEBUG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG)("event_log", source->GetEventsReport())("count", FetchingSources.size());
-    source->MutableResultRecordsCount() += tableExt ? tableExt->num_rows() : 0;
-    if (!tableExt || !tableExt->num_rows()) {
-        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("empty_source", source->DebugJson().GetStringRobust());
-    }
-    Context->GetCommonContext()->GetCounters().OnSourceFinished(
-        source->GetRecordsCount(), source->GetUsedRawBytes(), tableExt ? tableExt->num_rows() : 0);
-
-    source->MutableStageResult().SetResultChunk(std::move(tableExt), startIndex, recordsCount);
-    if (source->GetStageResult().IsFinished()) {
-        SourcesInFlightCount.Dec();
-    }
-    while (FetchingSources.size()) {
-        auto frontSource = FetchingSources.front();
-        if (!frontSource->HasStageResult()) {
-            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)("event", "skip_no_result")("source_id", frontSource->GetSourceId())(
-                "source_idx", frontSource->GetSourceIdx());
-            break;
-        }
-        if (!frontSource->GetStageResult().HasResultChunk()) {
-            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)("event", "skip_no_result_chunk")("source_id", frontSource->GetSourceId())(
-                "source_idx", frontSource->GetSourceIdx());
-            break;
-        }
-        auto table = frontSource->MutableStageResult().ExtractResultChunk();
-        const bool isFinished = frontSource->GetStageResult().IsFinished();
-        std::optional<ui32> sourceIdxToContinue;
-        if (!isFinished) {
-            sourceIdxToContinue = frontSource->GetSourceIdx();
-        }
-        if (table && table->num_rows()) {
-            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)("event", "has_result")("source_id", frontSource->GetSourceId())(
-                "source_idx", frontSource->GetSourceIdx())("table", table->num_rows());
-            auto cursor =
-                std::make_shared<TSimpleScanCursor>(frontSource->GetStartPKRecordBatch(), frontSource->GetSourceId(), startIndex + recordsCount);
-            reader.OnIntervalResult(std::make_shared<TPartialReadResult>(frontSource->GetResourceGuards(), frontSource->GetGroupGuard(), table,
-                cursor, Context->GetCommonContext(), sourceIdxToContinue));
-        } else if (sourceIdxToContinue) {
-            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)("event", "continue_source")("source_id", frontSource->GetSourceId())(
-                "source_idx", frontSource->GetSourceIdx());
-            ContinueSource(*sourceIdxToContinue);
-            break;
-        }
-        if (!isFinished) {
-            break;
-        }
-        AFL_VERIFY(FetchingSourcesByIdx.erase(frontSource->GetSourceIdx()));
-        FetchingSources.pop_front();
-        frontSource->ClearResult();
-        if (Context->GetCommonContext()->GetReadMetadata()->HasLimit()) {
-            AFL_VERIFY(FetchingInFlightSources.erase(TCompareKeyForScanSequence::FromFinish(frontSource)));
-            AFL_VERIFY(FinishedSources.emplace(TCompareKeyForScanSequence::FromFinish(frontSource), frontSource).second);
-            while (FinishedSources.size() &&
-                   (SortedSources.empty() || FinishedSources.begin()->second->GetFinish() < SortedSources.front()->GetStart())) {
-                auto finishedSource = FinishedSources.begin()->second;
-                if (!finishedSource->GetResultRecordsCount() && InFlightLimit < MaxInFlight) {
-                    InFlightLimit = 2 * InFlightLimit;
-                }
-                FetchedCount += finishedSource->GetResultRecordsCount();
-                FinishedSources.erase(FinishedSources.begin());
-                if (Context->IsActive()) {
-                    --IntervalsInFlightCount;
-                }
-                AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)("event", "source_finished")("source_id", finishedSource->GetSourceId())(
-                    "source_idx", finishedSource->GetSourceIdx())("limit", Context->GetCommonContext()->GetReadMetadata()->GetLimitRobust())(
-                    "fetched", finishedSource->GetResultRecordsCount());
-                if (FetchedCount > (ui64)Context->GetCommonContext()->GetReadMetadata()->GetLimitRobust() && SortedSources.size()) {
-                    AFL_NOTICE(NKikimrServices::TX_COLUMNSHARD)("event", "limit_exhausted")(
-                        "limit", Context->GetCommonContext()->GetReadMetadata()->GetLimitRobust())("fetched", FetchedCount);
-                    SortedSources.clear();
-                    IntervalsInFlightCount = GetInFlightIntervalsCount();
-                }
-            }
-        }
-    }
-}
-
 TConclusionStatus TScanHead::Start() {
-    for (auto&& i : SortedSources) {
-        i->InitFetchingPlan(Context->GetColumnsFetchingPlan(i));
-    }
     return TConclusionStatus::Success();
 }
 
-TScanHead::TScanHead(std::deque<std::shared_ptr<IDataSource>>&& sources, const std::shared_ptr<TSpecialReadContext>& context)
+TScanHead::TScanHead(std::deque<TSourceConstructor>&& sources, const std::shared_ptr<TSpecialReadContext>& context)
     : Context(context) {
-    if (HasAppData() && AppDataVerified().ColumnShardConfig.HasMaxInFlightIntervalsOnRequest()) {
-        MaxInFlight = AppDataVerified().ColumnShardConfig.GetMaxInFlightIntervalsOnRequest();
-    }
-    if (Context->GetReadMetadata()->HasLimit()) {
-        InFlightLimit = 1;
+    if (Context->GetReadMetadata()->IsSorted()) {
+        if (Context->GetReadMetadata()->HasLimit()) {
+            auto collection =
+                std::make_shared<TScanWithLimitCollection>(Context, std::move(sources), context->GetCommonContext()->GetScanCursor());
+            SourcesCollection = collection;
+            SyncPoints.emplace_back(std::make_shared<TSyncPointLimitControl>(
+                (ui64)Context->GetCommonContext()->GetReadMetadata()->GetLimitRobust(), SyncPoints.size(), context, collection));
+        } else {
+            SourcesCollection =
+                std::make_shared<TSortedFullScanCollection>(Context, std::move(sources), context->GetCommonContext()->GetScanCursor());
+        }
     } else {
-        InFlightLimit = MaxInFlight;
+        SourcesCollection = std::make_shared<TNotSortedCollection>(
+            Context, std::move(sources), context->GetCommonContext()->GetScanCursor(), Context->GetReadMetadata()->GetLimitRobustOptional());
     }
-    bool started = !context->GetCommonContext()->GetScanCursor()->IsInitialized();
-    for (auto&& i : sources) {
-        if (!started) {
-            bool usage = false;
-            if (!context->GetCommonContext()->GetScanCursor()->CheckEntityIsBorder(i, usage)) {
-                continue;
-            }
-            started = true;
-            if (!usage) {
-                continue;
-            }
-            i->SetIsStartedByCursor();
-        }
-        SortedSources.emplace_back(i);
+    SyncPoints.emplace_back(std::make_shared<TSyncPointResult>(SyncPoints.size(), context, SourcesCollection));
+    for (ui32 i = 0; i + 1 < SyncPoints.size(); ++i) {
+        SyncPoints[i]->SetNext(SyncPoints[i + 1]);
     }
 }
 
 TConclusion<bool> TScanHead::BuildNextInterval() {
-    if (!Context->IsActive()) {
-        return false;
-    }
-    if (SortedSources.size() == 0) {
-        return false;
-    }
     bool changed = false;
-    if (!Context->GetCommonContext()->GetReadMetadata()->HasLimit()) {
-        while (SortedSources.size() && SourcesInFlightCount.Val() < InFlightLimit && Context->IsActive()) {
-            FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, SortedSources.front()->AddEvent("f"));
-            SortedSources.front()->StartProcessing(SortedSources.front());
-            FetchingSources.emplace_back(SortedSources.front());
-            SourcesInFlightCount.Inc();
-            AFL_VERIFY(FetchingSourcesByIdx.emplace(SortedSources.front()->GetSourceIdx(), SortedSources.front()).second);
-            SortedSources.pop_front();
-            changed = true;
-        }
-    } else {
-        if (InFlightLimit <= IntervalsInFlightCount) {
-            return false;
-        }
-        ui32 inFlightCountLocal = GetInFlightIntervalsCount();
-        AFL_VERIFY(IntervalsInFlightCount == inFlightCountLocal)("count_global", IntervalsInFlightCount)("count_local", inFlightCountLocal);
-        while (SortedSources.size() && inFlightCountLocal < InFlightLimit && Context->IsActive()) {
-            FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, SortedSources.front()->AddEvent("f"));
-            SortedSources.front()->StartProcessing(SortedSources.front());
-            FetchingSources.emplace_back(SortedSources.front());
-            SourcesInFlightCount.Inc();
-            AFL_VERIFY(FetchingSourcesByIdx.emplace(SortedSources.front()->GetSourceIdx(), SortedSources.front()).second);
-            AFL_VERIFY(FetchingInFlightSources.emplace(TCompareKeyForScanSequence::FromFinish(SortedSources.front()), SortedSources.front()).second);
-            SortedSources.pop_front();
-            const ui32 inFlightCountLocalNew = GetInFlightIntervalsCount();
-            AFL_VERIFY(inFlightCountLocal <= inFlightCountLocalNew);
-            inFlightCountLocal = inFlightCountLocalNew;
-            changed = true;
-        }
-        IntervalsInFlightCount = inFlightCountLocal;
+    while (SourcesCollection->HasData() && SourcesCollection->CheckInFlightLimits()) {
+        auto source = SourcesCollection->ExtractNext();
+        SyncPoints.front()->AddSource(source);
+        changed = true;
     }
     return changed;
 }
@@ -174,35 +61,15 @@ bool TScanHead::IsReverse() const {
 
 void TScanHead::Abort() {
     AFL_VERIFY(!Context->IsActive());
-    for (auto&& i : FetchingSources) {
+    for (auto&& i : SyncPoints) {
         i->Abort();
     }
-    for (auto&& i : SortedSources) {
-        i->Abort();
-    }
-    FetchingSources.clear();
-    SortedSources.clear();
+    SourcesCollection->Abort();
     Y_ABORT_UNLESS(IsFinished());
 }
 
 TScanHead::~TScanHead() {
-    AFL_VERIFY(!IntervalsInFlightCount || !Context->IsActive());
-}
-
-ui32 TScanHead::GetInFlightIntervalsCount() const {
-    if (SortedSources.empty()) {
-        return FetchingInFlightSources.size() + FinishedSources.size();
-    }
-    ui32 inFlightCountLocal = 0;
-    auto itUpperFinished = FinishedSources.upper_bound(TCompareKeyForScanSequence::BorderStart(SortedSources.front()));
-    for (auto&& it = FinishedSources.begin(); it != itUpperFinished; ++it) {
-        ++inFlightCountLocal;
-    }
-    auto itUpperFetching = FetchingInFlightSources.upper_bound(TCompareKeyForScanSequence::BorderStart(SortedSources.front()));
-    for (auto&& it = FetchingInFlightSources.begin(); it != itUpperFetching; ++it) {
-        ++inFlightCountLocal;
-    }
-    return inFlightCountLocal;
+    AFL_VERIFY(IsFinished() || !Context->IsActive());
 }
 
 }   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/scanner.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/scanner.h
index 02315e54957f..c505433c14b7 100644
--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/scanner.h
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/scanner.h
@@ -1,5 +1,9 @@
 #pragma once
 #include "source.h"
+
+#include "collections/abstract.h"
+#include "sync_points/abstract.h"
+
 #include <ydb/core/formats/arrow/reader/position.h>
 #include <ydb/core/tx/columnshard/common/limits.h>
 #include <ydb/core/tx/columnshard/engines/reader/abstract/read_context.h>
@@ -9,77 +13,62 @@ namespace NKikimr::NOlap::NReader::NSimple {
 
 class TPlainReadData;
 
-class TDataSourceEndpoint {
+class TScanHead {
 private:
-    YDB_READONLY_DEF(std::vector<std::shared_ptr<IDataSource>>, StartSources);
-    YDB_READONLY_DEF(std::vector<std::shared_ptr<IDataSource>>, FinishSources);
+    std::shared_ptr<TSpecialReadContext> Context;
+    std::shared_ptr<ISourcesCollection> SourcesCollection;
+    std::vector<std::shared_ptr<ISyncPoint>> SyncPoints;
+
 public:
-    void AddStart(std::shared_ptr<IDataSource> source) {
-        StartSources.emplace_back(source);
+    const std::shared_ptr<ISyncPoint>& GetResultSyncPoint() const {
+        return SyncPoints.back();
     }
-    void AddFinish(std::shared_ptr<IDataSource> source) {
-        FinishSources.emplace_back(source);
+
+    const std::shared_ptr<ISyncPoint>& GetSyncPoint(const ui32 index) const {
+        AFL_VERIFY(index < SyncPoints.size());
+        return SyncPoints[index];
     }
-};
 
-class TScanHead {
-private:
-    using TCompareKeyForScanSequence = TPortionDataSource::TCompareKeyForScanSequence;
+    ISourcesCollection& MutableSourcesCollection() const {
+        return *SourcesCollection;
+    }
 
-    std::shared_ptr<TSpecialReadContext> Context;
-    THashMap<ui64, std::shared_ptr<IDataSource>> FetchingSourcesByIdx;
-    std::deque<std::shared_ptr<IDataSource>> SortedSources;
-    std::deque<std::shared_ptr<IDataSource>> FetchingSources;
-    std::map<TCompareKeyForScanSequence, std::shared_ptr<IDataSource>> FinishedSources;
-    std::map<TCompareKeyForScanSequence, std::shared_ptr<IDataSource>> FetchingInFlightSources;
-    TPositiveControlInteger IntervalsInFlightCount;
-    ui64 FetchedCount = 0;
-    ui64 InFlightLimit = 1;
-    ui64 MaxInFlight = 256;
-    TPositiveControlInteger SourcesInFlightCount;
-
-    ui32 GetInFlightIntervalsCount() const;
+    const ISourcesCollection& GetSourcesCollection() const {
+        return *SourcesCollection;
+    }
 
-public:
     ~TScanHead();
 
-    void ContinueSource(const ui32 sourceIdx) const {
-        auto it = FetchingSourcesByIdx.find(sourceIdx);
-        AFL_VERIFY(it != FetchingSourcesByIdx.end())("source_idx", sourceIdx)("count", FetchingSourcesByIdx.size());
-        it->second->ContinueCursor(it->second);
-    }
-
     bool IsReverse() const;
     void Abort();
 
     bool IsFinished() const {
-        return FetchingSources.empty() && SortedSources.empty();
+        for (auto&& i : SyncPoints) {
+            if (!i->IsFinished()) {
+                return false;
+            }
+        }
+        return SourcesCollection->IsFinished();
     }
 
     const TReadContext& GetContext() const;
 
     TString DebugString() const {
         TStringBuilder sb;
-        sb << "S:";
-        for (auto&& i : SortedSources) {
-            sb << i->GetSourceId() << ";";
-        }
-        sb << "F:";
-        for (auto&& i : FetchingSources) {
-            sb << i->GetSourceId() << ";";
+        sb << "S:{" << SourcesCollection->DebugString() << "};";
+        sb << "SP:[";
+        for (auto&& i : SyncPoints) {
+            sb << "{" << i->DebugString() << "};";
         }
+        sb << "]";
         return sb;
     }
 
-    void OnSourceReady(const std::shared_ptr<IDataSource>& source, std::shared_ptr<arrow::Table>&& table, const ui32 startIndex,
-        const ui32 recordsCount, TPlainReadData& reader);
-
     TConclusionStatus Start();
 
-    TScanHead(std::deque<std::shared_ptr<IDataSource>>&& sources, const std::shared_ptr<TSpecialReadContext>& context);
+    TScanHead(std::deque<TSourceConstructor>&& sources, const std::shared_ptr<TSpecialReadContext>& context);
 
     [[nodiscard]] TConclusion<bool> BuildNextInterval();
-
 };
 
-}
+}   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.cpp
index 589b8e8632dc..e075573a6ea8 100644
--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.cpp
@@ -8,6 +8,7 @@
 #include <ydb/core/tx/columnshard/engines/portions/data_accessor.h>
 #include <ydb/core/tx/columnshard/engines/reader/common_reader/iterator/constructor.h>
 #include <ydb/core/tx/columnshard/engines/reader/common_reader/iterator/default_fetching.h>
+#include <ydb/core/tx/columnshard/engines/reader/common_reader/iterator/fetch_steps.h>
 #include <ydb/core/tx/columnshard/engines/reader/common_reader/iterator/sub_columns_fetching.h>
 #include <ydb/core/tx/columnshard/engines/storage/indexes/portions/meta.h>
 #include <ydb/core/tx/columnshard/engines/storage/indexes/skip_index/meta.h>
@@ -26,39 +27,47 @@ void IDataSource::InitFetchingPlan(const std::shared_ptr<TFetchingScript>& fetch
 }
 
 void IDataSource::StartProcessing(const std::shared_ptr<IDataSource>& sourcePtr) {
-    AFL_VERIFY(!ProcessingStarted);
     AFL_VERIFY(FetchingPlan);
-    ProcessingStarted = true;
-    SourceGroupGuard = NGroupedMemoryManager::TScanMemoryLimiterOperator::BuildGroupGuard(
-        GetContext()->GetProcessMemoryControlId(), GetContext()->GetCommonContext()->GetScanId());
-    SetMemoryGroupId(SourceGroupGuard->GetGroupId());
-    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("InitFetchingPlan", FetchingPlan->DebugString())("source_idx", GetSourceIdx());
-    //    NActors::TLogContextGuard logGuard(NActors::TLogContextBuilder::Build()("source", SourceIdx)("method", "InitFetchingPlan"));
+    if (!ProcessingStarted) {
+        InitStageData(std::make_unique<TFetchedData>(
+            GetContext()->GetReadMetadata()->GetProgram().GetChainVerified()->HasAggregations(), sourcePtr->GetRecordsCount()));
+        ProcessingStarted = true;
+        SourceGroupGuard = NGroupedMemoryManager::TScanMemoryLimiterOperator::BuildGroupGuard(
+            GetContext()->GetProcessMemoryControlId(), GetContext()->GetCommonContext()->GetScanId());
+        SetMemoryGroupId(SourceGroupGuard->GetGroupId());
+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("InitFetchingPlan", FetchingPlan->DebugString())("source_idx", GetSourceIdx());
+        //    NActors::TLogContextGuard logGuard(NActors::TLogContextBuilder::Build()("source", SourceIdx)("method", "InitFetchingPlan"));
+    }
     TFetchingScriptCursor cursor(FetchingPlan, 0);
-    auto task = std::make_shared<TStepAction>(sourcePtr, std::move(cursor), GetContext()->GetCommonContext()->GetScanActorId());
+    auto task = std::make_shared<TStepAction>(sourcePtr, std::move(cursor), GetContext()->GetCommonContext()->GetScanActorId(), true);
     NConveyor::TScanServiceOperator::SendTaskToExecute(task);
 }
 
 void IDataSource::ContinueCursor(const std::shared_ptr<IDataSource>& sourcePtr) {
-    AFL_VERIFY(!!ScriptCursor);
+    AFL_VERIFY(!!ScriptCursor)("source_id", GetSourceId());
     if (ScriptCursor->Next()) {
-        auto task = std::make_shared<TStepAction>(sourcePtr, std::move(*ScriptCursor), GetContext()->GetCommonContext()->GetScanActorId());
-        NConveyor::TScanServiceOperator::SendTaskToExecute(task);
+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("source_id", GetSourceId())("event", "ContinueCursor");
+        auto cursor = std::move(*ScriptCursor);
         ScriptCursor.reset();
+        auto task = std::make_shared<TStepAction>(sourcePtr, std::move(cursor), GetContext()->GetCommonContext()->GetScanActorId(), true);
+        NConveyor::TScanServiceOperator::SendTaskToExecute(task);
+    } else {
+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD_SCAN)("source_id", GetSourceId())("event", "CannotContinueCursor");
     }
 }
 
 void IDataSource::DoOnSourceFetchingFinishedSafe(IDataReader& owner, const std::shared_ptr<NCommon::IDataSource>& sourcePtr) {
     auto* plainReader = static_cast<TPlainReadData*>(&owner);
-    plainReader->MutableScanner().OnSourceReady(std::static_pointer_cast<IDataSource>(sourcePtr), nullptr, 0, GetRecordsCount(), *plainReader);
+    auto sourceSimple = std::static_pointer_cast<IDataSource>(sourcePtr);
+    plainReader->MutableScanner().GetSyncPoint(sourceSimple->GetPurposeSyncPointIndex())->OnSourcePrepared(sourceSimple, *plainReader);
 }
 
 void IDataSource::DoOnEmptyStageData(const std::shared_ptr<NCommon::IDataSource>& /*sourcePtr*/) {
     TMemoryProfileGuard mpg("SCAN_PROFILE::STAGE_RESULT_EMPTY", IS_DEBUG_LOG_ENABLED(NKikimrServices::TX_COLUMNSHARD_SCAN_MEMORY));
     ResourceGuards.clear();
     StageResult = TFetchedResult::BuildEmpty();
-    StageResult->SetPages({ TPortionDataAccessor::TReadPage(0, GetRecordsCount(), 0) });
-    StageData.reset();
+    StageResult->SetPages({});
+    ClearStageData();
 }
 
 void IDataSource::DoBuildStageResult(const std::shared_ptr<NCommon::IDataSource>& /*sourcePtr*/) {
@@ -67,15 +76,20 @@ void IDataSource::DoBuildStageResult(const std::shared_ptr<NCommon::IDataSource>
 
 void IDataSource::Finalize(const std::optional<ui64> memoryLimit) {
     TMemoryProfileGuard mpg("SCAN_PROFILE::STAGE_RESULT", IS_DEBUG_LOG_ENABLED(NKikimrServices::TX_COLUMNSHARD_SCAN_MEMORY));
+    AFL_VERIFY(!GetStageData().IsEmptyWithData());
     if (memoryLimit && !IsSourceInMemory()) {
-        const auto accessor = StageData->GetPortionAccessor();
-        StageResult = std::make_unique<TFetchedResult>(std::move(StageData), *GetContext()->GetCommonContext()->GetResolver());
+        const auto accessor = GetStageData().GetPortionAccessor();
+        StageResult = std::make_unique<TFetchedResult>(ExtractStageData(), *GetContext()->GetCommonContext()->GetResolver());
         StageResult->SetPages(accessor.BuildReadPages(*memoryLimit, GetContext()->GetProgramInputColumns()->GetColumnIds()));
     } else {
-        StageResult = std::make_unique<TFetchedResult>(std::move(StageData), *GetContext()->GetCommonContext()->GetResolver());
+        StageResult = std::make_unique<TFetchedResult>(ExtractStageData(), *GetContext()->GetCommonContext()->GetResolver());
         StageResult->SetPages({ TPortionDataAccessor::TReadPage(0, GetRecordsCount(), 0) });
     }
-    StageData.reset();
+    if (StageResult->IsEmpty()) {
+        StageResult = TFetchedResult::BuildEmpty();
+        StageResult->SetPages({});
+    }
+    ClearStageData();
 }
 
 void TPortionDataSource::NeedFetchColumns(const std::set<ui32>& columnIds, TBlobsAction& blobsAction,
@@ -114,15 +128,15 @@ bool TPortionDataSource::DoStartFetchingColumns(
     const std::shared_ptr<NCommon::IDataSource>& sourcePtr, const TFetchingScriptCursor& step, const TColumnsSetIds& columns) {
     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", step.GetName());
     AFL_VERIFY(columns.GetColumnsCount());
-    AFL_VERIFY(!StageData->GetAppliedFilter() || !StageData->GetAppliedFilter()->IsTotalDenyFilter());
+    AFL_VERIFY(!GetStageData().GetAppliedFilter() || !GetStageData().GetAppliedFilter()->IsTotalDenyFilter());
     auto& columnIds = columns.GetColumnIds();
     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", step.GetName())("fetching_info", step.DebugString());
 
     TBlobsAction action(GetContext()->GetCommonContext()->GetStoragesManager(), NBlobOperations::EConsumer::SCAN);
     {
         THashMap<TChunkAddress, TPortionDataAccessor::TAssembleBlobInfo> nullBlocks;
-        NeedFetchColumns(columnIds, action, nullBlocks, StageData->GetAppliedFilter());
-        StageData->AddDefaults(std::move(nullBlocks));
+        NeedFetchColumns(columnIds, action, nullBlocks, GetStageData().GetAppliedFilter());
+        MutableStageData().AddDefaults(std::move(nullBlocks));
     }
 
     auto readActions = action.GetReadingActions();
@@ -137,7 +151,7 @@ bool TPortionDataSource::DoStartFetchingColumns(
 }
 
 std::shared_ptr<NIndexes::TSkipIndex> TPortionDataSource::SelectOptimalIndex(
-    const std::vector<std::shared_ptr<NIndexes::TSkipIndex>>& indexes, const NArrow::NSSA::EIndexCheckOperation /*op*/) const {
+    const std::vector<std::shared_ptr<NIndexes::TSkipIndex>>& indexes, const NArrow::NSSA::TIndexCheckOperation& /*op*/) const {
     if (indexes.size() == 0) {
         return nullptr;
     }
@@ -217,6 +231,7 @@ TConclusion<NArrow::TColumnFilter> TPortionDataSource::DoCheckIndex(
     auto meta = MutableStageData().GetRemapDataToIndex(fetchContext);
     if (!meta) {
         NYDBTest::TControllers::GetColumnShardController()->OnIndexSelectProcessed({});
+        GetContext()->GetCommonContext()->GetCounters().OnNoIndex(GetRecordsCount());
         return NArrow::TColumnFilter::BuildAllowFilter();
     }
     AFL_VERIFY(meta->IsSkipIndex());
@@ -232,6 +247,7 @@ TConclusion<NArrow::TColumnFilter> TPortionDataSource::DoCheckIndex(
     const std::optional<ui64> cat = meta->CalcCategory(fetchContext.GetSubColumnName());
     const NIndexes::TIndexColumnChunked* infoPointer = GetStageData().GetIndexes()->GetIndexDataOptional(meta->GetIndexId());
     if (!infoPointer) {
+        GetContext()->GetCommonContext()->GetCounters().OnNoIndexBlobs(GetRecordsCount());
         return filter;
     }
     const auto info = *infoPointer;
@@ -370,7 +386,7 @@ class TPortionAccessorFetchingSubscriber: public IDataAccessorRequestsSubscriber
         Source->MutableStageData().SetPortionAccessor(std::move(result.ExtractPortionsVector().front()));
         Source->InitUsedRawBytes();
         AFL_VERIFY(Step.Next());
-        auto task = std::make_shared<TStepAction>(Source, std::move(Step), Source->GetContext()->GetCommonContext()->GetScanActorId());
+        auto task = std::make_shared<TStepAction>(Source, std::move(Step), Source->GetContext()->GetCommonContext()->GetScanActorId(), false);
         NConveyor::TScanServiceOperator::SendTaskToExecute(task);
     }
 
@@ -384,8 +400,16 @@ class TPortionAccessorFetchingSubscriber: public IDataAccessorRequestsSubscriber
 
 }   // namespace
 
+TCompareKeyForScanSequence TCompareKeyForScanSequence::FromStart(const std::shared_ptr<IDataSource>& src) {
+    return TCompareKeyForScanSequence(src->GetStart(), src->GetSourceId());
+}
+
+TCompareKeyForScanSequence TCompareKeyForScanSequence::FromFinish(const std::shared_ptr<IDataSource>& src) {
+    return TCompareKeyForScanSequence(src->GetFinish(), src->GetSourceId());
+}
+
 bool TPortionDataSource::DoStartFetchingAccessor(const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step) {
-    AFL_VERIFY(!StageData->HasPortionAccessor());
+    AFL_VERIFY(!GetStageData().HasPortionAccessor());
     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", step.GetName())("fetching_info", step.DebugString());
 
     std::shared_ptr<TDataAccessorsRequest> request = std::make_shared<TDataAccessorsRequest>("SIMPLE::" + step.GetName());
@@ -405,4 +429,49 @@ TPortionDataSource::TPortionDataSource(
     , Schema(GetContext()->GetReadMetadata()->GetLoadSchemaVerified(*portion)) {
 }
 
+TConclusion<bool> TPortionDataSource::DoStartReserveMemory(const NArrow::NSSA::TProcessorContext& context,
+    const THashMap<ui32, IDataSource::TDataAddress>& columns, const THashMap<ui32, IDataSource::TFetchIndexContext>& /*indexes*/,
+    const THashMap<ui32, IDataSource::TFetchHeaderContext>& /*headers*/, const std::shared_ptr<NArrow::NSSA::IMemoryCalculationPolicy>& policy) {
+    class TEntitySize {
+    private:
+        YDB_READONLY(ui64, BlobsSize, 0);
+        YDB_READONLY(ui64, RawSize, 0);
+
+    public:
+        void Add(const TEntitySize& item) {
+            Add(item.BlobsSize, item.RawSize);
+        }
+
+        void Add(const ui64 blob, const ui64 raw) {
+            BlobsSize += blob;
+            RawSize += raw;
+        }
+    };
+
+    THashMap<ui32, TEntitySize> sizeByColumn;
+    for (auto&& [_, info] : columns) {
+        auto chunks = GetStageData().GetPortionAccessor().GetColumnChunksPointers(info.GetColumnId());
+        auto& sizes = sizeByColumn[info.GetColumnId()];
+        for (auto&& i : chunks) {
+            sizes.Add(i->GetBlobRange().GetSize(), i->GetMeta().GetRawBytes());
+        }
+    }
+    TEntitySize result;
+    for (auto&& i : sizeByColumn) {
+        result.Add(i.second);
+    }
+
+    auto source = context.GetDataSourceVerifiedAs<NCommon::IDataSource>();
+
+    const ui64 sizeToReserve = policy->GetReserveMemorySize(
+        result.GetBlobsSize(), result.GetRawSize(), GetContext()->GetReadMetadata()->GetLimitRobustOptional(), GetRecordsCount());
+
+    auto allocation = std::make_shared<NCommon::TAllocateMemoryStep::TFetchingStepAllocation>(
+        source, sizeToReserve, GetExecutionContext().GetCursorStep(), policy->GetStage(), false);
+    FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, AddEvent("mr"));
+    NGroupedMemoryManager::TScanMemoryLimiterOperator::SendToAllocation(GetContext()->GetProcessMemoryControlId(),
+        GetContext()->GetCommonContext()->GetScanId(), GetMemoryGroupId(), { allocation }, (ui32)policy->GetStage());
+    return true;
+}
+
 }   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.h
index 2c58a5d3933e..de0d8faa3b54 100644
--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.h
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.h
@@ -6,8 +6,8 @@
 #include <ydb/core/formats/arrow/reader/position.h>
 #include <ydb/core/tx/columnshard/blob.h>
 #include <ydb/core/tx/columnshard/blobs_action/abstract/action.h>
-#include <ydb/core/tx/columnshard/common/snapshot.h>
 #include <ydb/core/tx/columnshard/common/path_id.h>
+#include <ydb/core/tx/columnshard/common/snapshot.h>
 #include <ydb/core/tx/columnshard/engines/portions/portion_info.h>
 #include <ydb/core/tx/columnshard/engines/predicate/range.h>
 #include <ydb/core/tx/columnshard/engines/reader/common_reader/iterator/columns_set.h>
@@ -47,18 +47,27 @@ class TPortionPage {
 
 class TReplaceKeyAdapter {
 private:
-    const bool Reverse = false;
-    const NArrow::TReplaceKey Value;
+    bool Reverse = false;
+    NArrow::TComparablePosition Value;
 
 public:
+    const NArrow::TComparablePosition& GetValue() const {
+        return Value;
+    }
+
     TReplaceKeyAdapter(const NArrow::TReplaceKey& rk, const bool reverse)
         : Reverse(reverse)
         , Value(rk) {
     }
 
+    TReplaceKeyAdapter(const NArrow::TComparablePosition& pos, const bool reverse)
+        : Reverse(reverse)
+        , Value(pos) {
+    }
+
     std::partial_ordering Compare(const TReplaceKeyAdapter& item) const {
         AFL_VERIFY(Reverse == item.Reverse);
-        const std::partial_ordering result = Value.CompareNotNull(item.Value);
+        const std::partial_ordering result = Value.Compare(item.Value);
         if (result == std::partial_ordering::equivalent) {
             return std::partial_ordering::equivalent;
         } else if (result == std::partial_ordering::less) {
@@ -72,18 +81,7 @@ class TReplaceKeyAdapter {
     }
 
     bool operator<(const TReplaceKeyAdapter& item) const {
-        AFL_VERIFY(Reverse == item.Reverse);
-        const std::partial_ordering result = Value.CompareNotNull(item.Value);
-        if (result == std::partial_ordering::equivalent) {
-            return false;
-        } else if (result == std::partial_ordering::less) {
-            return !Reverse;
-        } else if (result == std::partial_ordering::greater) {
-            return Reverse;
-        } else {
-            AFL_VERIFY(false);
-            return false;
-        }
+        return Compare(item) == std::partial_ordering::less;
     }
 
     TString DebugString() const {
@@ -91,6 +89,38 @@ class TReplaceKeyAdapter {
     }
 };
 
+class TCompareKeyForScanSequence {
+private:
+    TReplaceKeyAdapter Key;
+    YDB_READONLY(ui32, SourceId, 0);
+
+public:
+    const TReplaceKeyAdapter GetKey() const {
+        return Key;
+    }
+
+    explicit TCompareKeyForScanSequence(const TReplaceKeyAdapter& key, const ui32 sourceId)
+        : Key(key)
+        , SourceId(sourceId) {
+    }
+
+    static TCompareKeyForScanSequence FromStart(const std::shared_ptr<IDataSource>& src);
+    static TCompareKeyForScanSequence FromFinish(const std::shared_ptr<IDataSource>& src);
+
+    static TCompareKeyForScanSequence BorderStart(const TReplaceKeyAdapter& key) {
+        return TCompareKeyForScanSequence(key, 0);
+    }
+
+    bool operator<(const TCompareKeyForScanSequence& item) const {
+        const std::partial_ordering compareResult = Key.Compare(item.Key);
+        if (compareResult == std::partial_ordering::equivalent) {
+            return SourceId < item.SourceId;
+        } else {
+            return compareResult == std::partial_ordering::less;
+        }
+    };
+};
+
 class IDataSource: public NCommon::IDataSource {
 private:
     using TBase = NCommon::IDataSource;
@@ -112,6 +142,8 @@ class IDataSource: public NCommon::IDataSource {
     virtual void DoOnEmptyStageData(const std::shared_ptr<NCommon::IDataSource>& /*sourcePtr*/) override;
 
     void Finalize(const std::optional<ui64> memoryLimit);
+    bool NeedFullAnswerFlag = true;
+    std::optional<ui32> PurposeSyncPointIndex;
 
 protected:
     std::optional<ui64> UsedRawBytes;
@@ -123,6 +155,33 @@ class IDataSource: public NCommon::IDataSource {
     virtual bool DoStartFetchingAccessor(const std::shared_ptr<IDataSource>& sourcePtr, const TFetchingScriptCursor& step) = 0;
 
 public:
+    bool NeedFullAnswer() const {
+        return NeedFullAnswerFlag;
+    }
+
+    void SetNeedFullAnswer(const bool value) {
+        NeedFullAnswerFlag = value;
+    }
+
+    ui32 GetPurposeSyncPointIndex() const {
+        AFL_VERIFY(PurposeSyncPointIndex);
+        return *PurposeSyncPointIndex;
+    }
+
+    void ResetPurposeSyncPointIndex() {
+        AFL_VERIFY(PurposeSyncPointIndex);
+        PurposeSyncPointIndex.reset();
+    }
+
+    void SetPurposeSyncPointIndex(const ui32 value) {
+        if (!PurposeSyncPointIndex) {
+            AFL_VERIFY(value == 0);
+        } else {
+            AFL_VERIFY(*PurposeSyncPointIndex < value);
+        }
+        PurposeSyncPointIndex = value;
+    }
+
     virtual void InitUsedRawBytes() = 0;
 
     ui64 GetUsedRawBytes() const {
@@ -157,7 +216,7 @@ class IDataSource: public NCommon::IDataSource {
     }
 
     virtual void ClearResult() {
-        StageData.reset();
+        ClearStageData();
         StageResult.reset();
         ResourceGuards.clear();
         SourceGroupGuard = nullptr;
@@ -174,6 +233,7 @@ class IDataSource: public NCommon::IDataSource {
 
     void ContinueCursor(const std::shared_ptr<IDataSource>& sourcePtr);
 
+    template <bool Reverse>
     class TCompareStartForScanSequence {
     public:
         bool operator()(const std::shared_ptr<IDataSource>& l, const std::shared_ptr<IDataSource>& r) const {
@@ -181,40 +241,7 @@ class IDataSource: public NCommon::IDataSource {
             if (compareResult == std::partial_ordering::equivalent) {
                 return l->GetSourceId() < r->GetSourceId();
             } else {
-                return compareResult == std::partial_ordering::less;
-            }
-        };
-    };
-
-    class TCompareKeyForScanSequence {
-    private:
-        const TReplaceKeyAdapter Key;
-        const ui32 SourceId;
-
-    public:
-        TCompareKeyForScanSequence(const TReplaceKeyAdapter& key, const ui32 sourceId)
-            : Key(key)
-            , SourceId(sourceId) {
-        }
-
-        static TCompareKeyForScanSequence FromStart(const std::shared_ptr<IDataSource>& src) {
-            return TCompareKeyForScanSequence(src->GetStart(), src->GetSourceId());
-        }
-
-        static TCompareKeyForScanSequence FromFinish(const std::shared_ptr<IDataSource>& src) {
-            return TCompareKeyForScanSequence(src->GetFinish(), src->GetSourceId());
-        }
-
-        static TCompareKeyForScanSequence BorderStart(const std::shared_ptr<IDataSource>& src) {
-            return TCompareKeyForScanSequence(src->GetStart(), 0);
-        }
-
-        bool operator<(const TCompareKeyForScanSequence& item) const {
-            const std::partial_ordering compareResult = Key.Compare(item.Key);
-            if (compareResult == std::partial_ordering::equivalent) {
-                return SourceId < item.SourceId;
-            } else {
-                return compareResult == std::partial_ordering::less;
+                return Reverse ? compareResult == std::partial_ordering::greater : compareResult == std::partial_ordering::less;
             }
         };
     };
@@ -232,6 +259,9 @@ class IDataSource: public NCommon::IDataSource {
     virtual bool HasIndexes(const std::set<ui32>& indexIds) const = 0;
 
     void InitFetchingPlan(const std::shared_ptr<TFetchingScript>& fetching);
+    bool HasFetchingPlan() const {
+        return !!FetchingPlan;
+    }
 
     virtual ui64 GetIndexRawBytes(const std::set<ui32>& indexIds) const = 0;
 
@@ -264,12 +294,11 @@ class IDataSource: public NCommon::IDataSource {
         : TBase(sourceId, sourceIdx, context, recordSnapshotMin, recordSnapshotMax, recordsCount, shardingVersion, hasDeletions)
         , Start(context->GetReadMetadata()->IsDescSorted() ? finish : start, context->GetReadMetadata()->IsDescSorted())
         , Finish(context->GetReadMetadata()->IsDescSorted() ? start : finish, context->GetReadMetadata()->IsDescSorted()) {
-        StageData = std::make_unique<TFetchedData>(true, recordsCount);
         UsageClass = GetContext()->GetReadMetadata()->GetPKRangesFilter().GetUsageClass(start, finish);
         AFL_VERIFY(UsageClass != TPKRangeFilter::EUsageClass::NoUsage);
         AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "portions_for_merge")("start", Start.DebugString())(
             "finish", Finish.DebugString());
-        Y_ABORT_UNLESS(Start.Compare(Finish) != std::partial_ordering::greater);
+        AFL_VERIFY_DEBUG(Start.Compare(Finish) != std::partial_ordering::greater);
     }
 
     virtual ~IDataSource() = default;
@@ -286,7 +315,7 @@ class TPortionDataSource: public IDataSource {
 
     virtual void InitUsedRawBytes() override {
         AFL_VERIFY(!UsedRawBytes);
-        UsedRawBytes = StageData->GetPortionAccessor().GetColumnRawBytes(GetContext()->GetAllUsageColumns()->GetColumnIds(), false);
+        UsedRawBytes = GetStageData().GetPortionAccessor().GetColumnRawBytes(GetContext()->GetAllUsageColumns()->GetColumnIds(), false);
     }
 
     virtual bool DoStartFetchingColumns(
@@ -294,11 +323,14 @@ class TPortionDataSource: public IDataSource {
     virtual void DoAssembleColumns(const std::shared_ptr<TColumnsSet>& columns, const bool sequential) override;
 
     std::shared_ptr<NIndexes::TSkipIndex> SelectOptimalIndex(
-        const std::vector<std::shared_ptr<NIndexes::TSkipIndex>>& indexes, const NArrow::NSSA::EIndexCheckOperation op) const;
+        const std::vector<std::shared_ptr<NIndexes::TSkipIndex>>& indexes, const NArrow::NSSA::TIndexCheckOperation& op) const;
 
     virtual TConclusion<bool> DoStartFetchImpl(
         const NArrow::NSSA::TProcessorContext& context, const std::vector<std::shared_ptr<NCommon::IKernelFetchLogic>>& fetchersExt) override;
 
+    virtual TConclusion<bool> DoStartReserveMemory(const NArrow::NSSA::TProcessorContext& context,
+        const THashMap<ui32, IDataSource::TDataAddress>& columns, const THashMap<ui32, IDataSource::TFetchIndexContext>& indexes,
+        const THashMap<ui32, IDataSource::TFetchHeaderContext>& headers, const std::shared_ptr<NArrow::NSSA::IMemoryCalculationPolicy>& policy) override;
     virtual TConclusion<std::vector<std::shared_ptr<NArrow::NSSA::IFetchLogic>>> DoStartFetchIndex(
         const NArrow::NSSA::TProcessorContext& context, const TFetchIndexContext& fetchContext) override;
     virtual TConclusion<NArrow::TColumnFilter> DoCheckIndex(const NArrow::NSSA::TProcessorContext& context,
@@ -437,4 +469,56 @@ class TPortionDataSource: public IDataSource {
     TPortionDataSource(const ui32 sourceIdx, const std::shared_ptr<TPortionInfo>& portion, const std::shared_ptr<TSpecialReadContext>& context);
 };
 
+class TSourceConstructor: public ICursorEntity {
+private:
+    TCompareKeyForScanSequence Start;
+    YDB_READONLY(ui32, SourceId, 0);
+    YDB_READONLY(ui32, PortionIdx, 0);
+    ui32 RecordsCount = 0;
+    bool IsStartedByCursorFlag = false;
+
+    virtual ui64 DoGetEntityId() const override {
+        return SourceId;
+    }
+    virtual ui64 DoGetEntityRecordsCount() const override {
+        return RecordsCount;
+    }
+
+public:
+    void SetIsStartedByCursor() {
+        IsStartedByCursorFlag = true;
+    }
+    bool GetIsStartedByCursor() const {
+        return IsStartedByCursorFlag;
+    }
+
+    const TCompareKeyForScanSequence& GetStart() const {
+        return Start;
+    }
+
+    TSourceConstructor(const ui32 portionIdx, const std::shared_ptr<TPortionInfo>& portion, const std::shared_ptr<TReadContext>& context)
+        : Start(TReplaceKeyAdapter(context->GetReadMetadata()->IsDescSorted() ? portion->IndexKeyEnd() : portion->IndexKeyStart(),
+                    context->GetReadMetadata()->IsDescSorted()),
+              portion->GetPortionId())
+        , SourceId(portion->GetPortionId())
+        , PortionIdx(portionIdx)
+        , RecordsCount(portion->GetRecordsCount()) {
+    }
+
+    bool operator<(const TSourceConstructor& item) const {
+        return item.Start < Start;
+    }
+
+    std::shared_ptr<TPortionDataSource> Construct(const ui32 sourceIdx, const std::shared_ptr<TSpecialReadContext>& context) const {
+        const auto& portions = context->GetReadMetadata()->SelectInfo->Portions;
+        AFL_VERIFY(sourceIdx < portions.size());
+        auto result = std::make_shared<TPortionDataSource>(sourceIdx, portions[PortionIdx], context);
+        if (IsStartedByCursorFlag) {
+            result->SetIsStartedByCursor();
+        }
+        FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, result->AddEvent("s"));
+        return result;
+    }
+};
+
 }   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/abstract.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/abstract.cpp
new file mode 100644
index 000000000000..9d840e46432c
--- /dev/null
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/abstract.cpp
@@ -0,0 +1,93 @@
+#include "abstract.h"
+
+#include <ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.h>
+
+#include <util/string/builder.h>
+
+namespace NKikimr::NOlap::NReader::NSimple {
+
+void ISyncPoint::OnSourcePrepared(const std::shared_ptr<IDataSource>& sourceInput, TPlainReadData& reader) {
+    const NActors::TLogContextGuard gLogging = NActors::TLogContextBuilder::Build()("sync_point", GetPointName())("aborted", AbortFlag);
+    if (AbortFlag) {
+        FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, sourceInput->AddEvent("a" + GetShortPointName()));
+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "sync_point_aborted")("source_id", sourceInput->GetSourceId());
+        return;
+    } else {
+        FOR_DEBUG_LOG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG, sourceInput->AddEvent("f" + GetShortPointName()));
+    }
+    AFL_DEBUG(NKikimrServices::COLUMNSHARD_SCAN_EVLOG)("event_log", sourceInput->GetEventsReport())("count", SourcesSequentially.size())(
+        "source_id", sourceInput->GetSourceId());
+    AFL_VERIFY(sourceInput->IsSyncSection())("source_id", sourceInput->GetSourceId());
+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "OnSourcePrepared")("source_id", sourceInput->GetSourceId());
+    while (SourcesSequentially.size() && IsSourcePrepared(SourcesSequentially.front())) {
+        auto source = SourcesSequentially.front();
+        switch (OnSourceReady(source, reader)) {
+            case ESourceAction::Finish: {
+                AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "finish_source")("source_id", source->GetSourceId());
+                reader.GetScanner().MutableSourcesCollection().OnSourceFinished(source);
+                SourcesSequentially.pop_front();
+                break;
+            }
+            case ESourceAction::ProvideNext: {
+                AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "provide_source")("source_id", source->GetSourceId());
+                if (Next) {
+                    source->ResetSourceFinishedFlag();
+                    Next->AddSource(source);
+                } else {
+                    reader.GetScanner().MutableSourcesCollection().OnSourceFinished(source);
+                }
+                SourcesSequentially.pop_front();
+                break;
+            }
+            case ESourceAction::Wait: {
+                AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "wait_source")("source_id", source->GetSourceId());
+                return;
+            }
+        }
+    }
+}
+
+TString ISyncPoint::DebugString() const {
+    TStringBuilder sb;
+    sb << "{";
+    for (auto&& i : SourcesSequentially) {
+        sb << i->GetSourceId() << ",";
+    }
+    sb << "}";
+    return sb;
+}
+
+void ISyncPoint::Continue(const TPartialSourceAddress& continueAddress, TPlainReadData& /*reader*/) {
+    AFL_VERIFY(PointIndex == continueAddress.GetSyncPointIndex());
+    AFL_VERIFY(SourcesSequentially.size() && SourcesSequentially.front()->GetSourceId() == continueAddress.GetSourceId())("first_source_id",
+                                                                                           SourcesSequentially.front()->GetSourceId())(
+                                                                                           "continue_source_id", continueAddress.GetSourceId());
+    const NActors::TLogContextGuard gLogging = NActors::TLogContextBuilder::Build()("sync_point", GetPointName())("event", "continue_source");
+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("source_id", SourcesSequentially.front()->GetSourceId());
+    SourcesSequentially.front()->ContinueCursor(SourcesSequentially.front());
+}
+
+void ISyncPoint::AddSource(const std::shared_ptr<IDataSource>& source) {
+    const NActors::TLogContextGuard gLogging = NActors::TLogContextBuilder::Build()("sync_point", GetPointName())("event", "add_source");
+    AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("source_id", source->GetSourceId());
+    AFL_VERIFY(!AbortFlag);
+    source->SetPurposeSyncPointIndex(GetPointIndex());
+    if (Next) {
+        source->SetNeedFullAnswer(false);
+    }
+    AFL_VERIFY(!!source);
+    if (!LastSourceIdx) {
+        LastSourceIdx = source->GetSourceIdx();
+    } else {
+        AFL_VERIFY(*LastSourceIdx < source->GetSourceIdx());
+    }
+    LastSourceIdx = source->GetSourceIdx();
+    SourcesSequentially.emplace_back(source);
+    if (!source->HasFetchingPlan()) {
+        source->InitFetchingPlan(Context->GetColumnsFetchingPlan(source));
+    }
+    OnAddSource(source);
+    source->StartProcessing(source);
+}
+
+}   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/abstract.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/abstract.h
new file mode 100644
index 000000000000..5ef3e4ede21a
--- /dev/null
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/abstract.h
@@ -0,0 +1,83 @@
+#pragma once
+#include <ydb/core/tx/columnshard/engines/reader/common/result.h>
+#include <ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/context.h>
+#include <ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/source.h>
+
+#include <ydb/library/accessor/accessor.h>
+
+namespace NKikimr::NOlap::NReader::NSimple {
+
+class TPlainReadData;
+class ISourcesCollection;
+
+class ISyncPoint {
+public:
+    enum class ESourceAction {
+        Finish,
+        ProvideNext,
+        Wait
+    };
+
+private:
+    YDB_READONLY(ui32, PointIndex, 0);
+    YDB_READONLY_DEF(TString, PointName);
+    std::optional<ui32> LastSourceIdx;
+    virtual void OnAddSource(const std::shared_ptr<IDataSource>& /*source*/) {
+    }
+    virtual bool IsSourcePrepared(const std::shared_ptr<IDataSource>& source) const = 0;
+    virtual ESourceAction OnSourceReady(const std::shared_ptr<IDataSource>& source, TPlainReadData& reader) = 0;
+    virtual void DoAbort() = 0;
+    bool AbortFlag = false;
+
+protected:
+    const std::shared_ptr<TSpecialReadContext> Context;
+    const std::shared_ptr<ISourcesCollection> Collection;
+    std::shared_ptr<ISyncPoint> Next;
+    std::deque<std::shared_ptr<IDataSource>> SourcesSequentially;
+
+public:
+    virtual ~ISyncPoint() = default;
+
+    void Continue(const TPartialSourceAddress& continueAddress, TPlainReadData& reader);
+
+    TString DebugString() const;
+
+    void Abort() {
+        SourcesSequentially.clear();
+        if (!AbortFlag) {
+            AbortFlag = true;
+            DoAbort();
+        }
+    }
+
+    bool IsFinished() const {
+        return SourcesSequentially.empty();
+    }
+
+    void SetNext(const std::shared_ptr<ISyncPoint>& next) {
+        AFL_VERIFY(!Next);
+        Next = next;
+    }
+
+    TString GetShortPointName() const {
+        if (PointName.size() < 2) {
+            return PointName;
+        } else {
+            return PointName.substr(0, 2);
+        }
+    }
+
+    ISyncPoint(const ui32 pointIndex, const TString& pointName, const std::shared_ptr<TSpecialReadContext>& context,
+        const std::shared_ptr<ISourcesCollection>& collection)
+        : PointIndex(pointIndex)
+        , PointName(pointName)
+        , Context(context)
+        , Collection(collection) {
+    }
+
+    void AddSource(const std::shared_ptr<IDataSource>& source);
+
+    void OnSourcePrepared(const std::shared_ptr<IDataSource>& sourceInput, TPlainReadData& reader);
+};
+
+}   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/limit.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/limit.cpp
new file mode 100644
index 000000000000..ef6b890ea39d
--- /dev/null
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/limit.cpp
@@ -0,0 +1,96 @@
+#include "limit.h"
+
+#include <ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections/limit_sorted.h>
+
+namespace NKikimr::NOlap::NReader::NSimple {
+
+TSyncPointLimitControl::TSyncPointLimitControl(const ui32 limit, const ui32 pointIndex, const std::shared_ptr<TSpecialReadContext>& context,
+    const std::shared_ptr<TScanWithLimitCollection>& collection)
+    : TBase(pointIndex, "SYNC_LIMIT", context, collection)
+    , Limit(limit)
+    , Collection(collection) {
+    AFL_VERIFY(Collection);
+}
+
+bool TSyncPointLimitControl::DrainToLimit() {
+    std::optional<TSourceIterator> nextInHeap;
+    if (Collection->GetNextSource()) {
+        nextInHeap = TSourceIterator(Collection->GetNextSource());
+    }
+    if (Iterators.empty() || (nextInHeap && Iterators.front() < *nextInHeap)) {
+        return false;
+    }
+
+    while (Iterators.size()) {
+        if (!Iterators.front().IsFilled()) {
+            return false;
+        }
+        std::pop_heap(Iterators.begin(), Iterators.end());
+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "LimitIteratorNext")("source_id", Iterators.back().GetSourceId())(
+            "fetched", FetchedCount)("limit", Limit)("iterators", Iterators.size());
+        if (!Iterators.back().Next()) {
+            Iterators.pop_back();
+        } else {
+            std::push_heap(Iterators.begin(), Iterators.end());
+            if (++FetchedCount >= Limit) {
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+ISyncPoint::ESourceAction TSyncPointLimitControl::OnSourceReady(const std::shared_ptr<IDataSource>& source, TPlainReadData& /*reader*/) {
+    if (FetchedCount >= Limit) {
+        return ESourceAction::Finish;
+    }
+    const auto& rk = *source->GetSourceSchema()->GetIndexInfo().GetReplaceKey();
+    const auto& g = source->GetStageResult().GetBatch();
+    AFL_VERIFY(Iterators.size());
+    AFL_VERIFY(Iterators.front().GetSourceId() == source->GetSourceId())("front", Iterators.front().DebugString())(
+                                                    "source", source->GetStart().DebugString())("source_id", source->GetSourceId());
+    std::pop_heap(Iterators.begin(), Iterators.end());
+    if (!g || !g->GetRecordsCount()) {
+        Iterators.pop_back();
+    } else {
+        std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> arrs;
+        for (auto&& i : rk.fields()) {
+            auto acc = g->GetAccessorByNameOptional(i->name());
+            if (!acc) {
+                break;
+            }
+            arrs.emplace_back(acc);
+        }
+        AFL_VERIFY(arrs.size());
+        if (!PKPrefixSize) {
+            PKPrefixSize = arrs.size();
+        } else {
+            AFL_VERIFY(*PKPrefixSize == arrs.size())("prefix", PKPrefixSize)("arr", arrs.size());
+        }
+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "DoOnSourceCheckLimitFillIterator")("source_id", source->GetSourceId())(
+            "fetched", FetchedCount)("limit", Limit);
+        Iterators.back() = TSourceIterator(arrs, source->GetStageResult().GetNotAppliedFilter(), source);
+        AFL_VERIFY(Iterators.back().IsFilled());
+        std::push_heap(Iterators.begin(), Iterators.end());
+    }
+    if (DrainToLimit()) {
+        Collection->Clear();
+    }
+    if (source->GetStageResult().IsEmpty()) {
+        return ESourceAction::Finish;
+    } else {
+        return ESourceAction::ProvideNext;
+    }
+}
+
+TString TSyncPointLimitControl::TSourceIterator::DebugString() const {
+    TStringBuilder sb;
+    sb << "{";
+    sb << "id=" << Source->GetSourceId() << ";";
+    sb << "f=" << IsFilled() << ";";
+    sb << "record=" << SortableRecord->DebugJson() << ";";
+    sb << "start=" << Source->GetStart().DebugString() << ";";
+    return sb;
+}
+
+}   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/limit.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/limit.h
new file mode 100644
index 000000000000..47ef3894275b
--- /dev/null
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/limit.h
@@ -0,0 +1,142 @@
+#pragma once
+#include "abstract.h"
+
+namespace NKikimr::NOlap::NReader::NSimple {
+
+class TScanWithLimitCollection;
+
+class TSyncPointLimitControl: public ISyncPoint {
+private:
+    using TBase = ISyncPoint;
+
+    const ui32 Limit;
+    std::shared_ptr<TScanWithLimitCollection> Collection;
+    ui32 FetchedCount = 0;
+    std::optional<ui32> PKPrefixSize;
+
+    virtual bool IsSourcePrepared(const std::shared_ptr<IDataSource>& source) const override {
+        if (source->IsSyncSection() && source->HasStageResult()) {
+            AFL_VERIFY(!source->GetStageResult().HasResultChunk());
+            return true;
+        }
+        return false;
+    }
+    class TSourceIterator {
+    private:
+        std::shared_ptr<IDataSource> Source;
+        bool Reverse;
+        int Delta = 0;
+        i64 Start = 0;
+        i64 Finish = 0;
+        std::shared_ptr<NArrow::NMerger::TRWSortableBatchPosition> SortableRecord;
+        std::shared_ptr<NArrow::TColumnFilter> Filter;
+        std::shared_ptr<NArrow::TColumnFilter::TIterator> FilterIterator;
+        bool IsValidFlag = true;
+
+        bool ShiftWithFilter() const {
+            AFL_VERIFY(IsValidFlag);
+            while (!FilterIterator->GetCurrentAcceptance()) {
+                if (!FilterIterator->Next(1)) {
+                    AFL_VERIFY(!SortableRecord->NextPosition(Delta));
+                    return false;
+                } else {
+                    AFL_VERIFY(SortableRecord->NextPosition(Delta));
+                }
+            }
+            return true;
+        }
+
+    public:
+        TString DebugString() const;
+
+        const std::shared_ptr<IDataSource>& GetSource() const {
+            AFL_VERIFY(Source);
+            return Source;
+        }
+
+        TSourceIterator(const std::shared_ptr<IDataSource>& source)
+            : Source(source)
+            , Reverse(Source->GetContext()->GetReadMetadata()->IsDescSorted())
+            , Delta(Reverse ? -1 : 1) {
+            AFL_VERIFY(Source);
+            auto arr = Source->GetStart().GetValue().GetArrays();
+            auto batch =
+                arrow::RecordBatch::Make(Source->GetSourceSchema()->GetIndexInfo().GetReplaceKey(), arr.front()->length(), std::move(arr));
+            SortableRecord =
+                std::make_shared<NArrow::NMerger::TRWSortableBatchPosition>(batch, Source->GetStart().GetValue().GetMonoPosition(), Reverse);
+        }
+
+        TSourceIterator(const std::vector<std::shared_ptr<NArrow::NAccessor::IChunkedArray>>& arrs,
+            const std::shared_ptr<NArrow::TColumnFilter>& filter, const std::shared_ptr<IDataSource>& source)
+            : Source(source)
+            , Reverse(Source->GetContext()->GetReadMetadata()->IsDescSorted())
+            , Delta(Reverse ? -1 : 1)
+            , Start(Reverse ? (arrs.front()->GetRecordsCount() - 1) : 0)
+            , Finish(Reverse ? 0 : (arrs.front()->GetRecordsCount() - 1))
+            , Filter(filter ? filter : std::make_shared<NArrow::TColumnFilter>(NArrow::TColumnFilter::BuildAllowFilter())) {
+            AFL_VERIFY(arrs.size());
+            AFL_VERIFY(arrs.front()->GetRecordsCount());
+            FilterIterator = std::make_shared<NArrow::TColumnFilter::TIterator>(Filter->GetIterator(Reverse, arrs.front()->GetRecordsCount()));
+            auto prefixSchema = Source->GetSourceSchema()->GetIndexInfo().GetReplaceKeyPrefix(arrs.size());
+            auto copyArrs = arrs;
+            auto batch = std::make_shared<NArrow::TGeneralContainer>(prefixSchema->fields(), std::move(copyArrs));
+            SortableRecord = std::make_shared<NArrow::NMerger::TRWSortableBatchPosition>(batch, Start, Reverse);
+            IsValidFlag = ShiftWithFilter();
+        }
+
+        ui64 GetSourceId() const {
+            AFL_VERIFY(Source);
+            return Source->GetSourceId();
+        }
+
+        bool IsFilled() const {
+            return !!Filter;
+        }
+
+        bool IsValid() const {
+            return IsValidFlag;
+        }
+
+        bool Next() {
+            AFL_VERIFY(IsValidFlag);
+            AFL_VERIFY(!!SortableRecord);
+            AFL_VERIFY(!!Filter);
+            IsValidFlag = SortableRecord->NextPosition(Delta);
+            AFL_VERIFY(FilterIterator->Next(1) == IsValidFlag);
+            if (IsValidFlag) {
+                IsValidFlag = ShiftWithFilter();
+            }
+            return IsValidFlag;
+        }
+
+        bool operator<(const TSourceIterator& item) const {
+            const auto cmp = SortableRecord->ComparePartial(*item.SortableRecord);
+            if (cmp == std::partial_ordering::equivalent) {
+                return item.Source->GetSourceId() < Source->GetSourceId();
+            }
+            return cmp == std::partial_ordering::greater;
+        }
+    };
+
+    std::vector<TSourceIterator> Iterators;
+
+    virtual void OnAddSource(const std::shared_ptr<IDataSource>& source) override {
+        AFL_VERIFY(FetchedCount < Limit);
+        Iterators.emplace_back(TSourceIterator(source));
+        std::push_heap(Iterators.begin(), Iterators.end());
+    }
+
+    virtual void DoAbort() override {
+        Iterators.clear();
+    }
+
+    virtual ESourceAction OnSourceReady(const std::shared_ptr<IDataSource>& source, TPlainReadData& reader) override;
+
+    bool DrainToLimit();
+
+public:
+    TSyncPointLimitControl(const ui32 limit, const ui32 pointIndex, const std::shared_ptr<TSpecialReadContext>& context,
+        const std::shared_ptr<TScanWithLimitCollection>& collection);
+};
+
+}   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/result.cpp b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/result.cpp
new file mode 100644
index 000000000000..d848cd6f7a69
--- /dev/null
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/result.cpp
@@ -0,0 +1,36 @@
+#include "result.h"
+
+#include <ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/plain_read_data.h>
+
+namespace NKikimr::NOlap::NReader::NSimple {
+
+ISyncPoint::ESourceAction TSyncPointResult::OnSourceReady(const std::shared_ptr<IDataSource>& source, TPlainReadData& reader) {
+    if (source->GetStageResult().IsEmpty()) {
+        return ESourceAction::Finish;
+    }
+    auto resultChunk = source->MutableStageResult().ExtractResultChunk();
+    const bool isFinished = source->GetStageResult().IsFinished();
+    if (resultChunk && resultChunk->HasData()) {
+        std::optional<TPartialSourceAddress> partialSourceAddress;
+        if (!isFinished) {
+            partialSourceAddress = TPartialSourceAddress(source->GetSourceId(), source->GetSourceIdx(), GetPointIndex());
+        }
+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "has_result")("source_id", source->GetSourceId())(
+            "source_idx", source->GetSourceIdx())("table", resultChunk->GetTable()->num_rows())("is_finished", isFinished);
+        auto cursor = Collection->BuildCursor(source, resultChunk->GetStartIndex() + resultChunk->GetRecordsCount(),
+            Context->GetCommonContext()->GetReadMetadata()->GetTabletId());
+        reader.OnIntervalResult(std::make_shared<TPartialReadResult>(source->GetResourceGuards(), source->GetGroupGuard(),
+            resultChunk->GetTable(), cursor, Context->GetCommonContext(), partialSourceAddress));
+    } else if (!isFinished) {
+        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_SCAN)("event", "continue_source")("source_id", source->GetSourceId())(
+            "source_idx", source->GetSourceIdx());
+        source->ContinueCursor(source);
+    }
+    if (!isFinished) {
+        return ESourceAction::Wait;
+    }
+    source->ClearResult();
+    return ESourceAction::ProvideNext;
+}
+
+}   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/result.h b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/result.h
new file mode 100644
index 000000000000..8df2879d938b
--- /dev/null
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/result.h
@@ -0,0 +1,25 @@
+#pragma once
+#include "abstract.h"
+
+namespace NKikimr::NOlap::NReader::NSimple {
+
+class TSyncPointResult: public ISyncPoint {
+private:
+    using TBase = ISyncPoint;
+    virtual void DoAbort() override {
+    }
+
+    virtual ESourceAction OnSourceReady(const std::shared_ptr<IDataSource>& source, TPlainReadData& reader) override;
+    virtual bool IsSourcePrepared(const std::shared_ptr<IDataSource>& source) const override {
+        return source->IsSyncSection() && source->HasStageResult() &&
+               (source->GetStageResult().HasResultChunk() || source->GetStageResult().IsEmpty());
+    }
+
+public:
+    TSyncPointResult(
+        const ui32 pointIndex, const std::shared_ptr<TSpecialReadContext>& context, const std::shared_ptr<ISourcesCollection>& collection)
+        : TBase(pointIndex, "RESULT", context, collection) {
+    }
+};
+
+}   // namespace NKikimr::NOlap::NReader::NSimple
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/ya.make b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/ya.make
new file mode 100644
index 000000000000..58d66933ef7b
--- /dev/null
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points/ya.make
@@ -0,0 +1,13 @@
+LIBRARY()
+
+SRCS(
+    abstract.cpp
+    result.cpp
+    limit.cpp
+)
+
+PEERDIR(
+    ydb/core/formats/arrow
+)
+
+END()
diff --git a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/ya.make b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/ya.make
index 45fef368d323..baff60941f27 100644
--- a/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/ya.make
+++ b/ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/ya.make
@@ -14,6 +14,8 @@ PEERDIR(
     ydb/core/formats/arrow
     ydb/core/tx/columnshard/blobs_action
     ydb/core/tx/columnshard/engines/reader/common_reader/iterator
+    ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/collections
+    ydb/core/tx/columnshard/engines/reader/simple_reader/iterator/sync_points
     ydb/core/tx/conveyor/usage
     ydb/core/tx/limiter/grouped_memory/usage
 )
diff --git a/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/iterator.cpp b/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/iterator.cpp
index abbfad5c92f6..26e1ebdb0950 100644
--- a/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/iterator.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/iterator.cpp
@@ -44,8 +44,9 @@ TConclusion<std::shared_ptr<TPartialReadResult>> TStatsIteratorBase::GetBatch()
         auto lastKey = keyBatch->Slice(keyBatch->num_rows() - 1, 1);
 
         {
-            NArrow::TColumnFilter filter = ReadMetadata->GetPKRangesFilter().BuildFilter(originalBatch);
-            AFL_VERIFY(filter.Apply(originalBatch));
+            NArrow::TColumnFilter filter =
+                ReadMetadata->GetPKRangesFilter().BuildFilter(std::make_shared<NArrow::TGeneralContainer>(originalBatch));
+            filter.Apply(originalBatch);
         }
 
         // Leave only requested columns
diff --git a/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/metadata.h b/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/metadata.h
index 7a9ee6bd36b5..63eff2dc866c 100644
--- a/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/metadata.h
+++ b/ydb/core/tx/columnshard/engines/reader/sys_view/abstract/metadata.h
@@ -11,15 +11,13 @@ struct TReadStatsMetadata: public TReadMetadataBase {
 public:
     using TConstPtr = std::shared_ptr<const TReadStatsMetadata>;
 
-    const ui64 TabletId;
     std::vector<ui32> ReadColumnIds;
     std::vector<ui32> ResultColumnIds;
     std::deque<TGranuleMetaView> IndexGranules;
 
     explicit TReadStatsMetadata(const std::shared_ptr<TVersionedIndex>& info, ui64 tabletId, const ESorting sorting,
         const TProgramContainer& ssaProgram, const std::shared_ptr<ISnapshotSchema>& schema, const TSnapshot& requestSnapshot)
-        : TBase(info, sorting, ssaProgram, schema, requestSnapshot, nullptr)
-        , TabletId(tabletId) {
+        : TBase(info, sorting, ssaProgram, schema, requestSnapshot, nullptr, tabletId) {
     }
 };
 
diff --git a/ydb/core/tx/columnshard/engines/reader/sys_view/chunks/chunks.cpp b/ydb/core/tx/columnshard/engines/reader/sys_view/chunks/chunks.cpp
index 1df5bfeae1d1..664a4ac881cc 100644
--- a/ydb/core/tx/columnshard/engines/reader/sys_view/chunks/chunks.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/sys_view/chunks/chunks.cpp
@@ -37,7 +37,7 @@ void TStatsIterator::AppendStats(
         for (auto&& r : records) {
             NArrow::Append<arrow::UInt64Type>(*builders[0], portion.GetPathId().GetRawValue());
             NArrow::Append<arrow::StringType>(*builders[1], prodView);
-            NArrow::Append<arrow::UInt64Type>(*builders[2], ReadMetadata->TabletId);
+            NArrow::Append<arrow::UInt64Type>(*builders[2], ReadMetadata->GetTabletId());
             NArrow::Append<arrow::UInt64Type>(*builders[3], r->GetMeta().GetRecordsCount());
             NArrow::Append<arrow::UInt64Type>(*builders[4], r->GetMeta().GetRawBytes());
             NArrow::Append<arrow::UInt64Type>(*builders[5], portion.GetPortionId());
@@ -94,7 +94,7 @@ void TStatsIterator::AppendStats(
         for (auto&& r : indexes) {
             NArrow::Append<arrow::UInt64Type>(*builders[0], portion.GetPathId().GetRawValue());
             NArrow::Append<arrow::StringType>(*builders[1], prodView);
-            NArrow::Append<arrow::UInt64Type>(*builders[2], ReadMetadata->TabletId);
+            NArrow::Append<arrow::UInt64Type>(*builders[2], ReadMetadata->GetTabletId());
             NArrow::Append<arrow::UInt64Type>(*builders[3], r->GetRecordsCount());
             NArrow::Append<arrow::UInt64Type>(*builders[4], r->GetRawBytes());
             NArrow::Append<arrow::UInt64Type>(*builders[5], portion.GetPortionId());
@@ -131,8 +131,7 @@ std::vector<std::pair<TString, NKikimr::NScheme::TTypeInfo>> TReadStatsMetadata:
 std::shared_ptr<NAbstract::TReadStatsMetadata> TConstructor::BuildMetadata(
     const NColumnShard::TColumnShard* self, const TReadDescription& read) const {
     auto* index = self->GetIndexOptional();
-    return std::make_shared<TReadStatsMetadata>(index ? index->CopyVersionedIndexPtr() : nullptr, self->TabletID(),
-        IsReverse ? TReadMetadataBase::ESorting::DESC : TReadMetadataBase::ESorting::ASC, read.GetProgram(),
+    return std::make_shared<TReadStatsMetadata>(index ? index->CopyVersionedIndexPtr() : nullptr, self->TabletID(), Sorting, read.GetProgram(),
         index ? index->GetVersionedIndex().GetLastSchema() : nullptr, read.GetSnapshot());
 }
 
diff --git a/ydb/core/tx/columnshard/engines/reader/sys_view/granules/granules.cpp b/ydb/core/tx/columnshard/engines/reader/sys_view/granules/granules.cpp
index 62d911c5f8f7..b714821d7c9f 100644
--- a/ydb/core/tx/columnshard/engines/reader/sys_view/granules/granules.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/sys_view/granules/granules.cpp
@@ -1,14 +1,16 @@
 #include "granules.h"
+
 #include <ydb/core/formats/arrow/switch/switch_type.h>
 #include <ydb/core/tx/columnshard/blobs_action/common/const.h>
 #include <ydb/core/tx/columnshard/engines/reader/abstract/read_context.h>
+
 #include <util/system/hostname.h>
 
 namespace NKikimr::NOlap::NReader::NSysView::NGranules {
 
 bool TStatsIterator::AppendStats(const std::vector<std::unique_ptr<arrow::ArrayBuilder>>& builders, NAbstract::TGranuleMetaView& granule) const {
     NArrow::Append<arrow::UInt64Type>(*builders[0], granule.GetPathId().GetRawValue());
-    NArrow::Append<arrow::UInt64Type>(*builders[1], ReadMetadata->TabletId);
+    NArrow::Append<arrow::UInt64Type>(*builders[1], ReadMetadata->GetTabletId());
     NArrow::Append<arrow::UInt64Type>(*builders[2], granule.GetPortions().size());
     NArrow::Append<arrow::StringType>(*builders[3], HostNameField);
     NArrow::Append<arrow::UInt64Type>(*builders[4], NActors::TActivationContext::AsActorContext().SelfID.NodeId());
@@ -23,11 +25,11 @@ std::vector<std::pair<TString, NKikimr::NScheme::TTypeInfo>> TReadStatsMetadata:
     return GetColumns(TStatsIterator::StatsSchema, TStatsIterator::StatsSchema.KeyColumns);
 }
 
-std::shared_ptr<NAbstract::TReadStatsMetadata> TConstructor::BuildMetadata(const NColumnShard::TColumnShard* self, const TReadDescription& read) const {
+std::shared_ptr<NAbstract::TReadStatsMetadata> TConstructor::BuildMetadata(
+    const NColumnShard::TColumnShard* self, const TReadDescription& read) const {
     auto* index = self->GetIndexOptional();
-    return std::make_shared<TReadStatsMetadata>(index ? index->CopyVersionedIndexPtr() : nullptr, self->TabletID(),
-        IsReverse ? TReadMetadataBase::ESorting::DESC : TReadMetadataBase::ESorting::ASC,
-        read.GetProgram(), index ? index->GetVersionedIndex().GetLastSchema() : nullptr, read.GetSnapshot());
+    return std::make_shared<TReadStatsMetadata>(index ? index->CopyVersionedIndexPtr() : nullptr, self->TabletID(), Sorting, read.GetProgram(),
+        index ? index->GetVersionedIndex().GetLastSchema() : nullptr, read.GetSnapshot());
 }
 
-}
+}   // namespace NKikimr::NOlap::NReader::NSysView::NGranules
diff --git a/ydb/core/tx/columnshard/engines/reader/sys_view/optimizer/optimizer.cpp b/ydb/core/tx/columnshard/engines/reader/sys_view/optimizer/optimizer.cpp
index 813362a71329..c43e82b690fd 100644
--- a/ydb/core/tx/columnshard/engines/reader/sys_view/optimizer/optimizer.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/sys_view/optimizer/optimizer.cpp
@@ -1,7 +1,9 @@
 #include "optimizer.h"
+
 #include <ydb/core/formats/arrow/switch/switch_type.h>
 #include <ydb/core/tx/columnshard/blobs_action/common/const.h>
 #include <ydb/core/tx/columnshard/engines/reader/abstract/read_context.h>
+
 #include <util/system/hostname.h>
 
 namespace NKikimr::NOlap::NReader::NSysView::NOptimizer {
@@ -9,7 +11,7 @@ namespace NKikimr::NOlap::NReader::NSysView::NOptimizer {
 bool TStatsIterator::AppendStats(const std::vector<std::unique_ptr<arrow::ArrayBuilder>>& builders, NAbstract::TGranuleMetaView& granule) const {
     for (auto&& i : granule.GetOptimizerTasks()) {
         NArrow::Append<arrow::UInt64Type>(*builders[0], granule.GetPathId().GetRawValue());
-        NArrow::Append<arrow::UInt64Type>(*builders[1], ReadMetadata->TabletId);
+        NArrow::Append<arrow::UInt64Type>(*builders[1], ReadMetadata->GetTabletId());
         NArrow::Append<arrow::UInt64Type>(*builders[2], i.GetTaskId());
         NArrow::Append<arrow::StringType>(*builders[3], HostNameField);
         NArrow::Append<arrow::UInt64Type>(*builders[4], NActors::TActivationContext::AsActorContext().SelfID.NodeId());
@@ -30,11 +32,11 @@ std::vector<std::pair<TString, NKikimr::NScheme::TTypeInfo>> TReadStatsMetadata:
     return GetColumns(TStatsIterator::StatsSchema, TStatsIterator::StatsSchema.KeyColumns);
 }
 
-std::shared_ptr<NAbstract::TReadStatsMetadata> TConstructor::BuildMetadata(const NColumnShard::TColumnShard* self, const TReadDescription& read) const {
+std::shared_ptr<NAbstract::TReadStatsMetadata> TConstructor::BuildMetadata(
+    const NColumnShard::TColumnShard* self, const TReadDescription& read) const {
     auto* index = self->GetIndexOptional();
-    return std::make_shared<TReadStatsMetadata>(index ? index->CopyVersionedIndexPtr() : nullptr, self->TabletID(),
-        IsReverse ? TReadMetadataBase::ESorting::DESC : TReadMetadataBase::ESorting::ASC,
-        read.GetProgram(), index ? index->GetVersionedIndex().GetLastSchema() : nullptr, read.GetSnapshot());
+    return std::make_shared<TReadStatsMetadata>(index ? index->CopyVersionedIndexPtr() : nullptr, self->TabletID(), Sorting, read.GetProgram(),
+        index ? index->GetVersionedIndex().GetLastSchema() : nullptr, read.GetSnapshot());
 }
 
-}
+}   // namespace NKikimr::NOlap::NReader::NSysView::NOptimizer
diff --git a/ydb/core/tx/columnshard/engines/reader/sys_view/portions/portions.cpp b/ydb/core/tx/columnshard/engines/reader/sys_view/portions/portions.cpp
index 3e58ce3a82e7..ae0e9bf3e29f 100644
--- a/ydb/core/tx/columnshard/engines/reader/sys_view/portions/portions.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/sys_view/portions/portions.cpp
@@ -1,4 +1,5 @@
 #include "portions.h"
+
 #include <ydb/core/formats/arrow/switch/switch_type.h>
 #include <ydb/core/tx/columnshard/blobs_action/common/const.h>
 #include <ydb/core/tx/columnshard/engines/reader/abstract/read_context.h>
@@ -9,7 +10,7 @@ void TStatsIterator::AppendStats(const std::vector<std::unique_ptr<arrow::ArrayB
     NArrow::Append<arrow::UInt64Type>(*builders[0], portion.GetPathId().GetRawValue());
     const std::string prod = ::ToString(portion.GetMeta().Produced);
     NArrow::Append<arrow::StringType>(*builders[1], prod);
-    NArrow::Append<arrow::UInt64Type>(*builders[2], ReadMetadata->TabletId);
+    NArrow::Append<arrow::UInt64Type>(*builders[2], ReadMetadata->GetTabletId());
     NArrow::Append<arrow::UInt64Type>(*builders[3], portion.GetRecordsCount());
     NArrow::Append<arrow::UInt64Type>(*builders[4], portion.GetColumnRawBytes());
     NArrow::Append<arrow::UInt64Type>(*builders[5], portion.GetIndexRawBytes());
@@ -60,11 +61,11 @@ std::vector<std::pair<TString, NKikimr::NScheme::TTypeInfo>> TReadStatsMetadata:
     return GetColumns(TStatsIterator::StatsSchema, TStatsIterator::StatsSchema.KeyColumns);
 }
 
-std::shared_ptr<NAbstract::TReadStatsMetadata> TConstructor::BuildMetadata(const NColumnShard::TColumnShard* self, const TReadDescription& read) const {
+std::shared_ptr<NAbstract::TReadStatsMetadata> TConstructor::BuildMetadata(
+    const NColumnShard::TColumnShard* self, const TReadDescription& read) const {
     auto* index = self->GetIndexOptional();
-    return std::make_shared<TReadStatsMetadata>(index ? index->CopyVersionedIndexPtr() : nullptr, self->TabletID(),
-        IsReverse ? TReadMetadataBase::ESorting::DESC : TReadMetadataBase::ESorting::ASC,
-        read.GetProgram(), index ? index->GetVersionedIndex().GetLastSchema() : nullptr, read.GetSnapshot());
+    return std::make_shared<TReadStatsMetadata>(index ? index->CopyVersionedIndexPtr() : nullptr, self->TabletID(), Sorting, read.GetProgram(),
+        index ? index->GetVersionedIndex().GetLastSchema() : nullptr, read.GetSnapshot());
 }
 
-}
+}   // namespace NKikimr::NOlap::NReader::NSysView::NPortions
diff --git a/ydb/core/tx/columnshard/engines/reader/transaction/tx_internal_scan.cpp b/ydb/core/tx/columnshard/engines/reader/transaction/tx_internal_scan.cpp
index 76a66c25b475..519cba47c90a 100644
--- a/ydb/core/tx/columnshard/engines/reader/transaction/tx_internal_scan.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/transaction/tx_internal_scan.cpp
@@ -38,9 +38,13 @@ void TTxInternalScan::Complete(const TActorContext& ctx) {
     const NActors::TLogContextGuard gLogging =
         NActors::TLogContextBuilder::Build()("tablet", Self->TabletID())("snapshot", snapshot.DebugString())("task_id", request.TaskIdentifier);
     TReadMetadataPtr readMetadataRange;
-    TScannerConstructorContext context(snapshot, 0, request.GetReverse());
+    const TReadMetadataBase::ESorting sorting = [&]() {
+        return request.GetReverse() ? TReadMetadataBase::ESorting::DESC : TReadMetadataBase::ESorting::ASC;
+    }();
+
+    TScannerConstructorContext context(snapshot, 0, sorting);
     {
-        TReadDescription read(snapshot, request.GetReverse());
+        TReadDescription read(Self->TabletID(), snapshot, sorting);
         read.SetScanIdentifier(request.TaskIdentifier);
         read.PathId = request.GetPathId();
         read.LockId = LockId;
diff --git a/ydb/core/tx/columnshard/engines/reader/transaction/tx_scan.cpp b/ydb/core/tx/columnshard/engines/reader/transaction/tx_scan.cpp
index 3ab63b339ce8..bcca02549984 100644
--- a/ydb/core/tx/columnshard/engines/reader/transaction/tx_scan.cpp
+++ b/ydb/core/tx/columnshard/engines/reader/transaction/tx_scan.cpp
@@ -38,7 +38,16 @@ void TTxScan::Complete(const TActorContext& ctx) {
     if (snapshot.IsZero()) {
         snapshot = Self->GetLastTxSnapshot();
     }
-    TScannerConstructorContext context(snapshot, request.HasItemsLimit() ? request.GetItemsLimit() : 0, request.GetReverse());
+    const TReadMetadataBase::ESorting sorting =
+        [&]() {
+            if (request.HasReverse()) {
+                return request.GetReverse() ? TReadMetadataBase::ESorting::DESC : TReadMetadataBase::ESorting::ASC;
+            } else {
+                return TReadMetadataBase::ESorting::NONE;
+            }
+    }();
+
+    TScannerConstructorContext context(snapshot, request.HasItemsLimit() ? request.GetItemsLimit() : 0, sorting);
     const auto scanId = request.GetScanId();
     const ui64 txId = request.GetTxId();
     const ui32 scanGen = request.GetGeneration();
@@ -55,7 +64,7 @@ void TTxScan::Complete(const TActorContext& ctx) {
     {
         LOG_S_DEBUG("TTxScan prepare txId: " << txId << " scanId: " << scanId << " at tablet " << Self->TabletID());
 
-        TReadDescription read(snapshot, request.GetReverse());
+        TReadDescription read(Self->TabletID(), snapshot, sorting);
         read.TxId = txId;
         if (request.HasLockTxId()) {
             read.LockId = request.GetLockTxId();
@@ -95,7 +104,7 @@ void TTxScan::Complete(const TActorContext& ctx) {
         if (!scannerConstructor) {
             return SendError("cannot build scanner", AppDataVerified().ColumnShardConfig.GetReaderClassName(), ctx);
         }
-        {
+        if (request.HasScanCursor()) {
             auto cursorConclusion = scannerConstructor->BuildCursorFromProto(request.GetScanCursor());
             if (cursorConclusion.IsFail()) {
                 return SendError("cannot build scanner cursor", cursorConclusion.GetErrorMessage(), ctx);
@@ -110,28 +119,23 @@ void TTxScan::Complete(const TActorContext& ctx) {
         if (!parseResult) {
             return SendError("cannot parse program", parseResult.GetErrorMessage(), ctx);
         }
-
-        if (!request.RangesSize()) {
+        {
+            if (request.RangesSize()) {
+                auto ydbKey = scannerConstructor->GetPrimaryKeyScheme(Self);
+                {
+                    auto filterConclusion = NOlap::TPKRangesFilter::BuildFromProto(request, ydbKey);
+                    if (filterConclusion.IsFail()) {
+                        return SendError("cannot build ranges filter", filterConclusion.GetErrorMessage(), ctx);
+                    }
+                    read.PKRangesFilter = std::make_shared<NOlap::TPKRangesFilter>(filterConclusion.DetachResult());
+                }
+            }
             auto newRange = scannerConstructor->BuildReadMetadata(Self, read);
             if (newRange.IsSuccess()) {
                 readMetadataRange = TValidator::CheckNotNull(newRange.DetachResult());
             } else {
                 return SendError("cannot build metadata withno ranges", newRange.GetErrorMessage(), ctx);
             }
-        } else {
-            auto ydbKey = scannerConstructor->GetPrimaryKeyScheme(Self);
-            {
-                auto filterConclusion = NOlap::TPKRangesFilter::BuildFromProto(request, request.GetReverse(), ydbKey);
-                if (filterConclusion.IsFail()) {
-                    return SendError("cannot build ranges filter", filterConclusion.GetErrorMessage(), ctx);
-                }
-                read.PKRangesFilter = std::make_shared<NOlap::TPKRangesFilter>(filterConclusion.DetachResult());
-            }
-            auto newRange = scannerConstructor->BuildReadMetadata(Self, read);
-            if (!newRange) {
-                return SendError("cannot build metadata", newRange.GetErrorMessage(), ctx);
-            }
-            readMetadataRange = TValidator::CheckNotNull(newRange.DetachResult());
         }
     }
     AFL_VERIFY(readMetadataRange);
diff --git a/ydb/core/tx/columnshard/engines/scheme/index_info.cpp b/ydb/core/tx/columnshard/engines/scheme/index_info.cpp
index b49760873c23..12b1a1b9c6f7 100644
--- a/ydb/core/tx/columnshard/engines/scheme/index_info.cpp
+++ b/ydb/core/tx/columnshard/engines/scheme/index_info.cpp
@@ -667,7 +667,7 @@ ui32 TIndexInfo::GetColumnIndexVerified(const ui32 id) const {
 }
 
 std::vector<std::shared_ptr<NIndexes::TSkipIndex>> TIndexInfo::FindSkipIndexes(
-    const NIndexes::NRequest::TOriginalDataAddress& originalDataAddress, const NArrow::NSSA::EIndexCheckOperation op) const {
+    const NIndexes::NRequest::TOriginalDataAddress& originalDataAddress, const NArrow::NSSA::TIndexCheckOperation& op) const {
     std::vector<std::shared_ptr<NIndexes::TSkipIndex>> result;
     for (auto&& [_, i] : Indexes) {
         if (!i->IsSkipIndex()) {
diff --git a/ydb/core/tx/columnshard/engines/scheme/index_info.h b/ydb/core/tx/columnshard/engines/scheme/index_info.h
index bb45f1e45a0b..7fc0cce69a22 100644
--- a/ydb/core/tx/columnshard/engines/scheme/index_info.h
+++ b/ydb/core/tx/columnshard/engines/scheme/index_info.h
@@ -174,6 +174,11 @@ struct TIndexInfo: public IIndexInfo {
         return ColumnFeatures[colIndex]->GetIsNullable();
     }
 
+    const TColumnFeatures& GetColumnFeaturesVerifiedByIndex(const ui32 colIndex) const {
+        AFL_VERIFY(colIndex < ColumnFeatures.size());
+        return *ColumnFeatures[colIndex];
+    }
+
     bool IsNullableVerified(const ui32 colId) const {
         return GetColumnFeaturesVerified(colId).GetIsNullable();
     }
@@ -330,7 +335,7 @@ struct TIndexInfo: public IIndexInfo {
     }
 
     std::vector<std::shared_ptr<NIndexes::TSkipIndex>> FindSkipIndexes(
-        const NIndexes::NRequest::TOriginalDataAddress& originalDataAddress, const NArrow::NSSA::EIndexCheckOperation op) const;
+        const NIndexes::NRequest::TOriginalDataAddress& originalDataAddress, const NArrow::NSSA::TIndexCheckOperation& op) const;
     std::shared_ptr<NIndexes::NMax::TIndexMeta> GetIndexMetaMax(const ui32 columnId) const;
     std::shared_ptr<NIndexes::NCountMinSketch::TIndexMeta> GetIndexMetaCountMinSketch(const std::set<ui32>& columnIds) const;
 
@@ -377,6 +382,16 @@ struct TIndexInfo: public IIndexInfo {
         return PKColumnIds[0];
     }
 
+    std::shared_ptr<arrow::Schema> GetReplaceKeyPrefix(const ui32 size) const {
+        AFL_VERIFY(size);
+        AFL_VERIFY(size <= (ui32)PrimaryKey->num_fields());
+        if (size == (ui32)PrimaryKey->num_fields()) {
+            return PrimaryKey;
+        } else {
+            std::vector<std::shared_ptr<arrow::Field>> fields(PrimaryKey->fields().begin(), PrimaryKey->fields().begin() + size);
+            return std::make_shared<arrow::Schema>(std::move(fields));
+        }
+    }
     const std::shared_ptr<arrow::Schema>& GetReplaceKey() const {
         return PrimaryKey;
     }
diff --git a/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/collection.cpp b/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/collection.cpp
index 07a765aacb9a..12b6d788a38e 100644
--- a/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/collection.cpp
+++ b/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/collection.cpp
@@ -6,7 +6,7 @@
 namespace NKikimr::NOlap::NIndexes {
 
 std::shared_ptr<IIndexMeta> TIndexesCollection::FindIndexFor(
-    const NRequest::TOriginalDataAddress& address, const NArrow::NSSA::EIndexCheckOperation op) const {
+    const NRequest::TOriginalDataAddress& address, const NArrow::NSSA::TIndexCheckOperation& op) const {
     auto it = IndexByOriginalData.find(address);
     if (it == IndexByOriginalData.end()) {
         return nullptr;
diff --git a/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/collection.h b/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/collection.h
index 5b6a88985f6a..1fc9c5adc2ce 100644
--- a/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/collection.h
+++ b/ydb/core/tx/columnshard/engines/scheme/indexes/abstract/collection.h
@@ -181,7 +181,7 @@ class TIndexesCollection {
         }
     }
 
-    std::shared_ptr<IIndexMeta> FindIndexFor(const NRequest::TOriginalDataAddress& address, const NArrow::NSSA::EIndexCheckOperation op) const;
+    std::shared_ptr<IIndexMeta> FindIndexFor(const NRequest::TOriginalDataAddress& address, const NArrow::NSSA::TIndexCheckOperation& op) const;
 };
 
 }   // namespace NKikimr::NOlap::NIndexes
diff --git a/ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.cpp b/ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.cpp
index b93bb5d1cbf1..833ea12ff37d 100644
--- a/ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.cpp
+++ b/ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.cpp
@@ -101,8 +101,17 @@ TConclusion<NArrow::TContainerWithIndexes<arrow::RecordBatch>> ISnapshotSchema::
         if (targetIdx == -1) {
             return TConclusionStatus::Success();
         }
-        const auto hasNull = NArrow::HasNulls(incomingBatch->column(incomingIdx));
-        const std::optional<i32> pkFieldIdx = GetIndexInfo().GetPKColumnIndexByIndexVerified(targetIdx);
+        const auto& incomingColumn = incomingBatch->column(incomingIdx);
+        const auto hasNull = NArrow::HasNulls(incomingColumn);
+        const TColumnFeatures& features = GetIndexInfo().GetColumnFeaturesVerifiedByIndex(targetIdx);
+        const std::optional<i32> pkFieldIdx = features.GetPKColumnIndex();
+        if (!features.GetDataAccessorConstructor()->HasInternalConversion() || !!pkFieldIdx) {
+            if (!features.GetArrowField()->type()->Equals(incomingColumn->type())) {
+                return TConclusionStatus::Fail(
+                    "not equal type for column: " + features.GetColumnName() + ": " + features.GetArrowField()->type()->ToString()
+                    + " vs " + incomingColumn->type()->ToString());
+            }
+        }
         if (pkFieldIdx && hasNull && !AppData()->ColumnShardConfig.GetAllowNullableColumnsInPK()) {
             return TConclusionStatus::Fail("null data for pk column is impossible for '" + dstSchema.field(targetIdx)->name() + "'");
         }
@@ -130,7 +139,7 @@ TConclusion<NArrow::TContainerWithIndexes<arrow::RecordBatch>> ISnapshotSchema::
     const auto nameResolver = [&](const std::string& fieldName) -> i32 {
         return GetIndexInfo().GetColumnIndexOptional(fieldName).value_or(-1);
     };
-    auto batchConclusion = NArrow::TColumnOperator().SkipIfAbsent().ErrorOnDifferentFieldTypes().AdaptIncomingToDestinationExt(
+    auto batchConclusion = NArrow::TColumnOperator().SkipIfAbsent().IgnoreOnDifferentFieldTypes().AdaptIncomingToDestinationExt(
         incomingBatch, dstSchema, pred, nameResolver);
     if (batchConclusion.IsFail()) {
         return batchConclusion;
@@ -331,6 +340,7 @@ TConclusion<TWritePortionInfoWithBlobsResult> ISnapshotSchema::PrepareForWrite(c
             TConclusion<std::shared_ptr<NArrow::NAccessor::IChunkedArray>> arrToWrite =
                 loader->GetAccessorConstructor()->Construct(accessor, loader->BuildAccessorContext(accessor->GetRecordsCount()));
             if (arrToWrite.IsFail()) {
+                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)("event", "cannot build accessor")("reason", arrToWrite.GetErrorMessage());
                 return arrToWrite;
             }
 
diff --git a/ydb/core/tx/columnshard/engines/storage/actualizer/counters/counters.h b/ydb/core/tx/columnshard/engines/storage/actualizer/counters/counters.h
index e803df700f7b..1452f7bb342c 100644
--- a/ydb/core/tx/columnshard/engines/storage/actualizer/counters/counters.h
+++ b/ydb/core/tx/columnshard/engines/storage/actualizer/counters/counters.h
@@ -1,5 +1,5 @@
 #pragma once
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 #include <ydb/core/tx/columnshard/engines/portions/portion_info.h>
 
 namespace NKikimr::NOlap::NActualizer {
diff --git a/ydb/core/tx/columnshard/engines/storage/actualizer/counters/ya.make b/ydb/core/tx/columnshard/engines/storage/actualizer/counters/ya.make
index d73b370747be..81a1e3cdd937 100644
--- a/ydb/core/tx/columnshard/engines/storage/actualizer/counters/ya.make
+++ b/ydb/core/tx/columnshard/engines/storage/actualizer/counters/ya.make
@@ -7,7 +7,7 @@ SRCS(
 PEERDIR(
     ydb/library/actors/core
     ydb/core/tx/columnshard/engines/portions
-    ydb/core/tx/columnshard/counters/common
+    ydb/library/signals
 )
 
 END()
diff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/abstract.h b/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/abstract.h
index 923bd35a8478..208daf711ac7 100644
--- a/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/abstract.h
+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/abstract.h
@@ -50,7 +50,7 @@ class IBitsStorageConstructor {
     virtual TConclusion<std::shared_ptr<IBitsStorage>> DoBuild(const TString& data) const = 0;
 
 public:
-    static std::shared_ptr<IBitsStorageConstructor> GetDefault();;
+    static std::shared_ptr<IBitsStorageConstructor> GetDefault();
 
     virtual ~IBitsStorageConstructor() = default;
 
diff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/bitset.h b/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/bitset.h
index 4674af24374b..63b7e6abfc62 100644
--- a/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/bitset.h
+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/bitset.h
@@ -30,6 +30,9 @@ class TBitSetStorage: public IBitsStorage {
     }
 
     bool TestHash(const ui64 hash) const {
+        if (!Bits.Size()) {
+            return false;
+        }
         return Bits.Get(hash % Bits.Size());
     }
 
diff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/string.cpp b/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/string.cpp
index c2a4b2a451d0..54e52e803445 100644
--- a/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/string.cpp
+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bits_storage/string.cpp
@@ -7,6 +7,9 @@
 namespace NKikimr::NOlap::NIndexes {
 
 bool TFixStringBitsStorage::DoGet(const ui32 idx) const {
+    if (!Data.size()) {
+        return false;
+    }
     AFL_VERIFY(idx < Data.size() * 8);
     const ui8 start = (*(ui8*)&Data[idx / 8]);
     return start & (1 << (idx % 8));
diff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.cpp b/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.cpp
index 6a2bc50a2dfa..2ba8811ff4ad 100644
--- a/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.cpp
+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.cpp
@@ -63,10 +63,10 @@ TString TBloomIndexMeta::DoBuildIndexImpl(TChunkedBatchReader& reader, const ui3
     return GetBitsStorageConstructor()->Build(std::move(filterBits))->SerializeToString();
 }
 
-bool TBloomIndexMeta::DoCheckValueImpl(
-    const IBitsStorage& data, const std::optional<ui64> category, const std::shared_ptr<arrow::Scalar>& value, const EOperation op) const {
+bool TBloomIndexMeta::DoCheckValueImpl(const IBitsStorage& data, const std::optional<ui64> category, const std::shared_ptr<arrow::Scalar>& value,
+    const NArrow::NSSA::TIndexCheckOperation& op) const {
     std::set<ui64> hashes;
-    AFL_VERIFY(op == EOperation::Equals)("op", op);
+    AFL_VERIFY(op.GetOperation() == EOperation::Equals)("op", op.DebugString());
     const ui32 bitsCount = data.GetBitsCount();
     if (!!category) {
         for (ui64 hashSeed = 0; hashSeed < HashesCount; ++hashSeed) {
@@ -88,8 +88,8 @@ bool TBloomIndexMeta::DoCheckValueImpl(
 
 std::optional<ui64> TBloomIndexMeta::DoCalcCategory(const TString& subColumnName) const {
     ui64 result;
-    const NRequest::TOriginalDataAddress addr(Max<ui32>(), subColumnName);
-    AFL_VERIFY(GetDataExtractor()->CheckForIndex(addr, result));
+    const NRequest::TOriginalDataAddress addr(GetColumnId(), subColumnName);
+    AFL_VERIFY(GetDataExtractor()->CheckForIndex(addr, &result));
     if (subColumnName) {
         return result;
     } else {
diff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.h b/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.h
index 2be01b8d7942..bdb39bb44508 100644
--- a/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.h
+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bloom/meta.h
@@ -20,8 +20,8 @@ class TBloomIndexMeta: public TSkipBitmapIndex {
 
     virtual std::optional<ui64> DoCalcCategory(const TString& subColumnName) const override;
 
-    virtual bool DoIsAppropriateFor(const TString& /*subColumnName*/, const EOperation op) const override {
-        return op == EOperation::Equals;
+    virtual bool DoIsAppropriateFor(const NArrow::NSSA::TIndexCheckOperation& op) const override {
+        return op.GetOperation() == EOperation::Equals && op.GetCaseSensitive();
     }
 
 protected:
@@ -32,7 +32,7 @@ class TBloomIndexMeta: public TSkipBitmapIndex {
     virtual void DoSerializeToProto(NKikimrSchemeOp::TOlapIndexDescription& proto) const override;
 
     virtual bool DoCheckValueImpl(const IBitsStorage& data, const std::optional<ui64> category, const std::shared_ptr<arrow::Scalar>& value,
-        const EOperation op) const override;
+        const NArrow::NSSA::TIndexCheckOperation& op) const override;
 
 public:
     TBloomIndexMeta() = default;
diff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/constructor.cpp b/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/constructor.cpp
index b73e9195feab..60131226f065 100644
--- a/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/constructor.cpp
+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/constructor.cpp
@@ -16,7 +16,7 @@ std::shared_ptr<IIndexMeta> TIndexConstructor::DoCreateIndexMeta(
     }
     const ui32 columnId = columnInfo->GetId();
     return std::make_shared<TIndexMeta>(indexId, indexName, GetStorageId().value_or(NBlobOperations::TGlobal::DefaultStorageId), columnId,
-        GetDataExtractor(), HashesCount, FilterSizeBytes, NGrammSize, RecordsCount, TBase::GetBitsStorageConstructor());
+        GetDataExtractor(), HashesCount, FilterSizeBytes, NGrammSize, RecordsCount, TBase::GetBitsStorageConstructor(), CaseSensitive);
 }
 
 TConclusionStatus TIndexConstructor::DoDeserializeFromJson(const NJson::TJsonValue& jsonInfo) {
@@ -61,7 +61,15 @@ TConclusionStatus TIndexConstructor::DoDeserializeFromJson(const NJson::TJsonVal
         return TConclusionStatus::Fail(
             "hashes_count have to be in bloom ngramm filter in interval " + TConstants::GetHashesCountIntervalString());
     }
+
+    if (jsonInfo.Has("case_sensitive")) {
+        if (!jsonInfo["case_sensitive"].IsBoolean()) {
+            return TConclusionStatus::Fail("case_sensitive have to be in bloom filter features as boolean field");
+        }
+        CaseSensitive = jsonInfo["case_sensitive"].GetBoolean();
+    }
     return TConclusionStatus::Success();
+
 }
 
 NKikimr::TConclusionStatus TIndexConstructor::DoDeserializeFromProto(const NKikimrSchemeOp::TOlapIndexRequested& proto) {
@@ -77,6 +85,9 @@ NKikimr::TConclusionStatus TIndexConstructor::DoDeserializeFromProto(const NKiki
             return conclusion;
         }
     }
+    if (bFilter.HasCaseSensitive()) {
+        CaseSensitive = bFilter.GetCaseSensitive();
+    }
     RecordsCount = bFilter.GetRecordsCount();
     if (!TConstants::CheckRecordsCount(RecordsCount)) {
         return TConclusionStatus::Fail("RecordsCount have to be in " + TConstants::GetRecordsCountIntervalString());
@@ -107,6 +118,7 @@ void TIndexConstructor::DoSerializeToProto(NKikimrSchemeOp::TOlapIndexRequested&
     auto* filterProto = proto.MutableBloomNGrammFilter();
     TBase::SerializeToProtoBitsStorageOnly(*filterProto);
     filterProto->SetColumnName(GetColumnName());
+    filterProto->SetCaseSensitive(CaseSensitive);
     filterProto->SetRecordsCount(RecordsCount);
     filterProto->SetNGrammSize(NGrammSize);
     filterProto->SetFilterSizeBytes(FilterSizeBytes);
diff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/constructor.h b/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/constructor.h
index 375de80ebd78..343984c0a993 100644
--- a/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/constructor.h
+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/constructor.h
@@ -19,6 +19,7 @@ class TIndexConstructor: public TSkipBitmapIndexConstructor {
     ui32 FilterSizeBytes = 512;
     ui32 HashesCount = 2;
     ui32 RecordsCount = 10000;
+    bool CaseSensitive = true;
     static inline auto Registrator = TFactory::TRegistrator<TIndexConstructor>(GetClassNameStatic());
 
 protected:
diff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/meta.cpp b/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/meta.cpp
index c0dabbc4ba5a..e13c1086c548 100644
--- a/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/meta.cpp
+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/meta.cpp
@@ -10,12 +10,14 @@
 #include <contrib/libs/apache/arrow/cpp/src/arrow/array/builder_primitive.h>
 #include <library/cpp/deprecated/atomic/atomic.h>
 #include <util/generic/bitmap.h>
+#include <util/string/ascii.h>
 
 namespace NKikimr::NOlap::NIndexes::NBloomNGramm {
 
 class TNGrammBuilder {
 private:
     const ui32 HashesCount;
+    const bool CaseSensitive;
 
     template <ui32 CharsRemained>
     class THashesBuilder {
@@ -133,17 +135,29 @@ class TNGrammBuilder {
             AFL_VERIFY(false);
         }
     };
+    TBuffer LowerStringBuffer;
 
 public:
-    TNGrammBuilder(const ui32 hashesCount)
-        : HashesCount(hashesCount) {
+    TNGrammBuilder(const ui32 hashesCount, const bool caseSensitive)
+        : HashesCount(hashesCount)
+        , CaseSensitive(caseSensitive) {
     }
 
     template <class TAction>
     void BuildNGramms(
         const char* data, const ui32 dataSize, const std::optional<NRequest::TLikePart::EOperation> op, const ui32 nGrammSize, TAction& pred) {
-        THashesSelector<TConstants::MaxHashesCount, TConstants::MaxNGrammSize>::BuildHashes(
-            (const ui8*)data, dataSize, HashesCount, nGrammSize, op, pred);
+        if (CaseSensitive) {
+            THashesSelector<TConstants::MaxHashesCount, TConstants::MaxNGrammSize>::BuildHashes(
+                (const ui8*)data, dataSize, HashesCount, nGrammSize, op, pred);
+        } else {
+            LowerStringBuffer.Clear();
+            LowerStringBuffer.Resize(dataSize);
+            for (ui32 i = 0; i < dataSize; ++i) {
+                LowerStringBuffer.Data()[i] = AsciiToLower(data[i]);
+            }
+            THashesSelector<TConstants::MaxHashesCount, TConstants::MaxNGrammSize>::BuildHashes(
+                (const ui8*)LowerStringBuffer.Data(), dataSize, HashesCount, nGrammSize, op, pred);
+        }
     }
 
     template <class TFiller>
@@ -172,7 +186,12 @@ class TNGrammBuilder {
 
     template <class TFiller>
     void FillNGrammHashes(const ui32 nGrammSize, const NRequest::TLikePart::EOperation op, const TString& userReq, TFiller& fillData) {
-        BuildNGramms(userReq.data(), userReq.size(), op, nGrammSize, fillData);
+        if (CaseSensitive) {
+            BuildNGramms(userReq.data(), userReq.size(), op, nGrammSize, fillData);
+        } else {
+            const TString lowerString = to_lower(userReq);
+            BuildNGramms(lowerString.data(), lowerString.size(), op, nGrammSize, fillData);
+        }
     }
 };
 
@@ -259,7 +278,7 @@ class TBitmapDetector<0> {
 
 TString TIndexMeta::DoBuildIndexImpl(TChunkedBatchReader& reader, const ui32 recordsCount) const {
     AFL_VERIFY(reader.GetColumnsCount() == 1)("count", reader.GetColumnsCount());
-    TNGrammBuilder builder(HashesCount);
+    TNGrammBuilder builder(HashesCount, CaseSensitive);
 
     ui32 size = FilterSizeBytes * 8;
     if ((size & (size - 1)) == 0) {
@@ -311,8 +330,8 @@ TString TIndexMeta::DoBuildIndexImpl(TChunkedBatchReader& reader, const ui32 rec
     return GetBitsStorageConstructor()->Build(inserter.ExtractBits())->SerializeToString();
 }
 
-bool TIndexMeta::DoCheckValueImpl(
-    const IBitsStorage& data, const std::optional<ui64> category, const std::shared_ptr<arrow::Scalar>& value, const EOperation op) const {
+bool TIndexMeta::DoCheckValueImpl(const IBitsStorage& data, const std::optional<ui64> category, const std::shared_ptr<arrow::Scalar>& value,
+    const NArrow::NSSA::TIndexCheckOperation& op) const {
     AFL_VERIFY(!category);
     AFL_VERIFY(value->type->id() == arrow::utf8()->id() || value->type->id() == arrow::binary()->id())("id", value->type->ToString());
     bool result = true;
@@ -322,10 +341,11 @@ bool TIndexMeta::DoCheckValueImpl(
             result = false;
         }
     };
-    TNGrammBuilder builder(HashesCount);
+    TNGrammBuilder builder(HashesCount, CaseSensitive);
+    AFL_VERIFY(!CaseSensitive || op.GetCaseSensitive());
 
     NRequest::TLikePart::EOperation opLike;
-    switch (op) {
+    switch (op.GetOperation()) {
         case TSkipIndex::EOperation::Equals:
             opLike = NRequest::TLikePart::EOperation::Equals;
             break;
diff --git a/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/meta.h b/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/meta.h
index d1326c3da469..31f29d1e7a5f 100644
--- a/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/meta.h
+++ b/ydb/core/tx/columnshard/engines/storage/indexes/bloom_ngramm/meta.h
@@ -13,6 +13,7 @@ class TIndexMeta: public TSkipBitmapIndex {
 private:
     using TBase = TSkipBitmapIndex;
     std::shared_ptr<arrow::Schema> ResultSchema;
+    bool CaseSensitive = true;
     ui32 NGrammSize = 3;
     ui32 FilterSizeBytes = 512;
     ui32 RecordsCount = 10000;
@@ -28,16 +29,13 @@ class TIndexMeta: public TSkipBitmapIndex {
         AFL_VERIFY(TConstants::CheckRecordsCount(RecordsCount));
     }
 
-    virtual bool DoIsAppropriateFor(const TString& subColumnName, const EOperation op) const override {
-        if (!!subColumnName) {
-            return false;
-        }
-        switch (op) {
+    virtual bool DoIsAppropriateFor(const NArrow::NSSA::TIndexCheckOperation& op) const override {
+        switch (op.GetOperation()) {
             case EOperation::Equals:
             case EOperation::StartsWith:
             case EOperation::EndsWith:
             case EOperation::Contains:
-                return true;
+                return !CaseSensitive || op.GetCaseSensitive();
         }
 
         return false;
@@ -50,12 +48,6 @@ class TIndexMeta: public TSkipBitmapIndex {
             return TConclusionStatus::Fail(
                 "cannot read meta as appropriate class: " + GetClassName() + ". Meta said that class name is " + newMeta.GetClassName());
         }
-        if (HashesCount != bMeta->HashesCount) {
-            return TConclusionStatus::Fail("cannot modify hashes count");
-        }
-        if (NGrammSize != bMeta->NGrammSize) {
-            return TConclusionStatus::Fail("cannot modify ngramm size");
-        }
         return TBase::CheckSameColumnsForModification(newMeta);
     }
     virtual TString DoBuildIndexImpl(TChunkedBatchReader& reader, const ui32 recordsCount) const override;
@@ -80,6 +72,9 @@ class TIndexMeta: public TSkipBitmapIndex {
         if (!MutableDataExtractor().DeserializeFromProto(bFilter.GetDataExtractor())) {
             return false;
         }
+        if (bFilter.HasCaseSensitive()) {
+            CaseSensitive = bFilter.GetCaseSensitive();
+        }
         HashesCount = bFilter.GetHashesCount();
         if (!TConstants::CheckHashesCount(HashesCount)) {
             return false;
@@ -111,18 +106,20 @@ class TIndexMeta: public TSkipBitmapIndex {
         filterProto->SetFilterSizeBytes(FilterSizeBytes);
         filterProto->SetHashesCount(HashesCount);
         filterProto->SetColumnId(GetColumnId());
+        filterProto->SetCaseSensitive(CaseSensitive);
         *filterProto->MutableDataExtractor() = GetDataExtractor().SerializeToProto();
     }
 
     virtual bool DoCheckValueImpl(const IBitsStorage& data, const std::optional<ui64> category, const std::shared_ptr<arrow::Scalar>& value,
-        const EOperation op) const override;
+        const NArrow::NSSA::TIndexCheckOperation& op) const override;
 
 public:
     TIndexMeta() = default;
     TIndexMeta(const ui32 indexId, const TString& indexName, const TString& storageId, const ui32 columnId,
         const TReadDataExtractorContainer& dataExtractor, const ui32 hashesCount, const ui32 filterSizeBytes, const ui32 nGrammSize,
-        const ui32 recordsCount, const std::shared_ptr<IBitsStorageConstructor>& bitsStorageConstructor)
+        const ui32 recordsCount, const std::shared_ptr<IBitsStorageConstructor>& bitsStorageConstructor, const bool caseSensitive)
         : TBase(indexId, indexName, columnId, storageId, dataExtractor, bitsStorageConstructor)
+        , CaseSensitive(caseSensitive)
         , NGrammSize(nGrammSize)
         , FilterSizeBytes(filterSizeBytes)
         , RecordsCount(recordsCount)
diff --git a/ydb/core/tx/columnshard/engines/storage/indexes/categories_bloom/meta.cpp b/ydb/core/tx/columnshard/engines/storage/indexes/categories_bloom/meta.cpp
index 813605c1ec05..6ce01b442d55 100644
--- a/ydb/core/tx/columnshard/engines/storage/indexes/categories_bloom/meta.cpp
+++ b/ydb/core/tx/columnshard/engines/storage/indexes/categories_bloom/meta.cpp
@@ -166,11 +166,15 @@ TConclusion<std::shared_ptr<IIndexHeader>> TIndexMeta::DoBuildHeader(const TChun
     return std::make_shared<TCompositeBloomHeader>(std::move(proto), IIndexHeader::ReadHeaderSize(data.GetDataVerified(), true).DetachResult());
 }
 
-bool TIndexMeta::DoCheckValueImpl(
-    const IBitsStorage& data, const std::optional<ui64> category, const std::shared_ptr<arrow::Scalar>& value, const EOperation op) const {
+bool TIndexMeta::DoCheckValueImpl(const IBitsStorage& data, const std::optional<ui64> category, const std::shared_ptr<arrow::Scalar>& value,
+    const NArrow::NSSA::TIndexCheckOperation& op) const {
     AFL_VERIFY(!!category);
-    AFL_VERIFY(op == EOperation::Equals)("op", op);
+    AFL_VERIFY(op.GetOperation() == EOperation::Equals)("op", op.DebugString());
+    AFL_VERIFY(op.GetCaseSensitive());
     const ui32 bitsCount = data.GetBitsCount();
+    if (!bitsCount) {
+        return false;
+    }
     for (ui64 hashSeed = 0; hashSeed < HashesCount; ++hashSeed) {
         const ui64 hash = NArrow::NHash::TXX64::CalcForScalar(value, hashSeed);
         if (!data.Get(hash % bitsCount)) {
@@ -182,8 +186,8 @@ bool TIndexMeta::DoCheckValueImpl(
 
 std::optional<ui64> TIndexMeta::DoCalcCategory(const TString& subColumnName) const {
     ui64 result;
-    const NRequest::TOriginalDataAddress addr(Max<ui32>(), subColumnName);
-    AFL_VERIFY(GetDataExtractor()->CheckForIndex(addr, result));
+    const NRequest::TOriginalDataAddress addr(GetColumnId(), subColumnName);
+    AFL_VERIFY(GetDataExtractor()->CheckForIndex(addr, &result));
     return result;
 }
 
diff --git a/ydb/core/tx/columnshard/engines/storage/indexes/categories_bloom/meta.h b/ydb/core/tx/columnshard/engines/storage/indexes/categories_bloom/meta.h
index 6f7a2396971c..decf03fb7920 100644
--- a/ydb/core/tx/columnshard/engines/storage/indexes/categories_bloom/meta.h
+++ b/ydb/core/tx/columnshard/engines/storage/indexes/categories_bloom/meta.h
@@ -21,15 +21,15 @@ class TIndexMeta: public TSkipBitmapIndex {
     }
 
     virtual bool DoCheckValueImpl(const IBitsStorage& data, const std::optional<ui64> category, const std::shared_ptr<arrow::Scalar>& value,
-        const EOperation op) const override;
+        const NArrow::NSSA::TIndexCheckOperation& op) const override;
 
     virtual TConclusion<std::shared_ptr<IIndexHeader>> DoBuildHeader(const TChunkOriginalData& data) const override;
 
-    virtual bool DoIsAppropriateFor(const TString& subColumnName, const EOperation op) const override {
-        if (!subColumnName) {
+    virtual bool DoIsAppropriateFor(const NArrow::NSSA::TIndexCheckOperation& op) const override {
+        if (!op.GetCaseSensitive()) {
             return false;
         }
-        if (op != EOperation::Equals) {
+        if (op.GetOperation() != EOperation::Equals) {
             return false;
         }
         return true;
diff --git a/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/abstract.h b/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/abstract.h
index 82fda999716d..ebdb32051afa 100644
--- a/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/abstract.h
+++ b/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/abstract.h
@@ -23,7 +23,7 @@ class IReadDataExtractor {
 
     virtual void DoSerializeToProto(TProto& proto) const = 0;
     virtual bool DoDeserializeFromProto(const TProto& proto) = 0;
-    virtual bool DoCheckForIndex(const NRequest::TOriginalDataAddress& dataSource, ui64& baseHash) const = 0;
+    virtual bool DoCheckForIndex(const NRequest::TOriginalDataAddress& dataSource, ui64* baseHash) const = 0;
     virtual THashMap<ui64, ui32> DoGetIndexHitsCount(const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& dataArray) const = 0;
 
 public:
@@ -34,8 +34,10 @@ class IReadDataExtractor {
         return DoGetIndexHitsCount(dataArray);
     }
 
-    bool CheckForIndex(const NRequest::TOriginalDataAddress& dataSource, ui64& baseHash) const {
-        baseHash = 0;
+    bool CheckForIndex(const NRequest::TOriginalDataAddress& dataSource, ui64* baseHash) const {
+        if (baseHash) {
+            *baseHash = 0;
+        }
         return DoCheckForIndex(dataSource, baseHash);
     }
 
diff --git a/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/default.cpp b/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/default.cpp
index 2da8da4da2ae..9a38a9580ea2 100644
--- a/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/default.cpp
+++ b/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/default.cpp
@@ -37,7 +37,7 @@ void TDefaultDataExtractor::DoVisitAll(const std::shared_ptr<NArrow::NAccessor::
     }
 }
 
-bool TDefaultDataExtractor::DoCheckForIndex(const NRequest::TOriginalDataAddress& request, ui64& hashBase) const {
+bool TDefaultDataExtractor::DoCheckForIndex(const NRequest::TOriginalDataAddress& request, ui64* hashBase) const {
     if (request.GetSubColumnName()) {
         std::string_view sv = [&]() {
             if (request.GetSubColumnName().StartsWith("$.")) {
@@ -46,10 +46,9 @@ bool TDefaultDataExtractor::DoCheckForIndex(const NRequest::TOriginalDataAddress
                 return std::string_view(request.GetSubColumnName().data(), request.GetSubColumnName().size());
             }
         }();
-        if (sv.starts_with("\"") && sv.ends_with("\"")) {
-            sv = std::string_view(sv.data() + 1, sv.size() - 2);
+        if (hashBase) {
+            *hashBase = NRequest::TOriginalDataAddress::CalcSubColumnHash(sv);
         }
-        hashBase = NRequest::TOriginalDataAddress::CalcSubColumnHash(sv);
     }
     return true;
 }
diff --git a/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/default.h b/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/default.h
index 64f534edf594..47de05f3f942 100644
--- a/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/default.h
+++ b/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/default.h
@@ -27,7 +27,7 @@ class TDefaultDataExtractor: public IReadDataExtractor {
     virtual void DoVisitAll(const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& dataArray, const TChunkVisitor& chunkVisitor,
         const TRecordVisitor& recordVisitor) const override;
 
-    virtual bool DoCheckForIndex(const NRequest::TOriginalDataAddress& request, ui64& hashBase) const override;
+    virtual bool DoCheckForIndex(const NRequest::TOriginalDataAddress& request, ui64* hashBase) const override;
     virtual THashMap<ui64, ui32> DoGetIndexHitsCount(const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& dataArray) const override;
 
 public:
diff --git a/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/sub_column.h b/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/sub_column.h
index f7e9e6daa697..6479afc78927 100644
--- a/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/sub_column.h
+++ b/ydb/core/tx/columnshard/engines/storage/indexes/portions/extractor/sub_column.h
@@ -45,7 +45,7 @@ class TSubColumnDataExtractor: public IReadDataExtractor {
     virtual void DoVisitAll(const std::shared_ptr<NArrow::NAccessor::IChunkedArray>& dataArray, const TChunkVisitor& chunkVisitor,
         const TRecordVisitor& recordVisitor) const override;
 
-    virtual bool DoCheckForIndex(const NRequest::TOriginalDataAddress& request, ui64& /*hashBase*/) const override {
+    virtual bool DoCheckForIndex(const NRequest::TOriginalDataAddress& request, ui64* /*hashBase*/) const override {
         return request.GetSubColumnName() == SubColumnName;
     }
 
diff --git a/ydb/core/tx/columnshard/engines/storage/indexes/skip_index/meta.h b/ydb/core/tx/columnshard/engines/storage/indexes/skip_index/meta.h
index eb63fe0d6b38..329419088768 100644
--- a/ydb/core/tx/columnshard/engines/storage/indexes/skip_index/meta.h
+++ b/ydb/core/tx/columnshard/engines/storage/indexes/skip_index/meta.h
@@ -13,15 +13,16 @@ class TSkipIndex: public TIndexByColumns {
     using TBase = TIndexByColumns;
 
 public:
-    using EOperation = NArrow::NSSA::EIndexCheckOperation;
+    using EOperation = NArrow::NSSA::TIndexCheckOperation::EOperation;
 
 private:
-    virtual bool DoIsAppropriateFor(const TString& subColumnName, const EOperation op) const = 0;
-    virtual bool DoCheckValue(
-        const TString& data, const std::optional<ui64> cat, const std::shared_ptr<arrow::Scalar>& value, const EOperation op) const = 0;
+    virtual bool DoIsAppropriateFor(const NArrow::NSSA::TIndexCheckOperation& op) const = 0;
+    virtual bool DoCheckValue(const TString& data, const std::optional<ui64> cat, const std::shared_ptr<arrow::Scalar>& value,
+        const NArrow::NSSA::TIndexCheckOperation& op) const = 0;
 
 public:
-    bool CheckValue(const TString& data, const std::optional<ui64> cat, const std::shared_ptr<arrow::Scalar>& value, const EOperation op) const {
+    bool CheckValue(const TString& data, const std::optional<ui64> cat, const std::shared_ptr<arrow::Scalar>& value,
+        const NArrow::NSSA::TIndexCheckOperation& op) const {
         return DoCheckValue(data, cat, value, op);
     }
 
@@ -29,11 +30,14 @@ class TSkipIndex: public TIndexByColumns {
         return true;
     }
 
-    bool IsAppropriateFor(const NRequest::TOriginalDataAddress& addr, const EOperation op) const {
+    bool IsAppropriateFor(const NRequest::TOriginalDataAddress& addr, const NArrow::NSSA::TIndexCheckOperation& op) const {
         if (GetColumnId() != addr.GetColumnId()) {
             return false;
         }
-        return DoIsAppropriateFor(addr.GetSubColumnName(), op);
+        if (!GetDataExtractor()->CheckForIndex(addr, nullptr)) {
+            return false;
+        }
+        return DoIsAppropriateFor(op);
     }
     using TBase::TBase;
 };
@@ -42,11 +46,14 @@ class TSkipBitmapIndex: public TSkipIndex {
 private:
     std::shared_ptr<IBitsStorageConstructor> BitsStorageConstructor;
     using TBase = TSkipIndex;
-    virtual bool DoCheckValueImpl(
-        const IBitsStorage& data, const std::optional<ui64> cat, const std::shared_ptr<arrow::Scalar>& value, const EOperation op) const = 0;
+    virtual bool DoCheckValueImpl(const IBitsStorage& data, const std::optional<ui64> cat, const std::shared_ptr<arrow::Scalar>& value,
+        const NArrow::NSSA::TIndexCheckOperation& op) const = 0;
 
     virtual bool DoCheckValue(const TString& data, const std::optional<ui64> cat, const std::shared_ptr<arrow::Scalar>& value,
-        const EOperation op) const override final {
+        const NArrow::NSSA::TIndexCheckOperation& op) const override final {
+        if (data.empty()) {
+            return false;
+        }
         auto storageConclusion = BitsStorageConstructor->Build(data);
         return DoCheckValueImpl(*storageConclusion.GetResult(), cat, value, op);
     }
diff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/abstract/optimizer.h b/ydb/core/tx/columnshard/engines/storage/optimizer/abstract/optimizer.h
index 633e3a519e53..20c68212068e 100644
--- a/ydb/core/tx/columnshard/engines/storage/optimizer/abstract/optimizer.h
+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/abstract/optimizer.h
@@ -84,6 +84,10 @@ class IOptimizerPlanner {
     const TInternalPathId PathId;
     YDB_READONLY(TInstant, ActualizationInstant, TInstant::Zero());
 
+    virtual bool DoIsOverloaded() const {
+        return false;
+    }
+
 protected:
     virtual void DoModifyPortions(const THashMap<ui64, std::shared_ptr<TPortionInfo>>& add,
         const THashMap<ui64, std::shared_ptr<TPortionInfo>>& remove) = 0;
@@ -107,7 +111,9 @@ class IOptimizerPlanner {
     IOptimizerPlanner(const TInternalPathId pathId)
         : PathId(pathId) {
     }
-
+    bool IsOverloaded() const {
+        return DoIsOverloaded();
+    }
     TConclusionStatus CheckWriteData() const {
         return DoCheckWriteData();
     }
diff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/constructor/zero_level.cpp b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/constructor/zero_level.cpp
index 18c383861af4..5d612baa6604 100644
--- a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/constructor/zero_level.cpp
+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/constructor/zero_level.cpp
@@ -33,6 +33,13 @@ TConclusionStatus TZeroLevelConstructor::DoDeserializeFromJson(const NJson::TJso
         }
         ExpectedBlobsSize = jsonValue.GetUInteger();
     }
+    if (json.Has("portions_count_limit")) {
+        const auto& jsonValue = json["portions_count_limit"];
+        if (!jsonValue.IsUInteger()) {
+            return TConclusionStatus::Fail("incorrect portions_count_limit value (have to be unsigned int)");
+        }
+        PortionsCountLimit = jsonValue.GetUInteger();
+    }
     return TConclusionStatus::Success();
 }
 
@@ -49,6 +56,9 @@ bool TZeroLevelConstructor::DoDeserializeFromProto(const NKikimrSchemeOp::TCompa
     if (proto.GetZeroLevel().HasPortionsCountAvailable()) {
         PortionsCountAvailable = proto.GetZeroLevel().GetPortionsCountAvailable();
     }
+    if (proto.GetZeroLevel().HasPortionsCountLimit()) {
+        PortionsCountLimit = proto.GetZeroLevel().GetPortionsCountLimit();
+    }
     return true;
 }
 
@@ -62,12 +72,15 @@ void TZeroLevelConstructor::DoSerializeToProto(NKikimrSchemeOp::TCompactionLevel
     if (PortionsCountAvailable) {
         proto.MutableZeroLevel()->SetPortionsCountAvailable(*PortionsCountAvailable);
     }
+    if (PortionsCountLimit) {
+        proto.MutableZeroLevel()->SetPortionsCountLimit(*PortionsCountLimit);
+    }
 }
 
 std::shared_ptr<NKikimr::NOlap::NStorageOptimizer::NLCBuckets::IPortionsLevel> TZeroLevelConstructor::DoBuildLevel(
     const std::shared_ptr<IPortionsLevel>& nextLevel, const ui32 indexLevel, const TLevelCounters& counters) const {
     return std::make_shared<TZeroLevelPortions>(indexLevel, nextLevel, counters, PortionsLiveDuration.value_or(TDuration::Max()),
-        ExpectedBlobsSize.value_or((ui64)1 << 20), PortionsCountAvailable.value_or(10));
+        ExpectedBlobsSize.value_or((ui64)1 << 20), PortionsCountAvailable.value_or(10), PortionsCountLimit);
 }
 
 }   // namespace NKikimr::NOlap::NStorageOptimizer::NLCBuckets
diff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/constructor/zero_level.h b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/constructor/zero_level.h
index 0ebce6554aeb..9b838c1beccb 100644
--- a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/constructor/zero_level.h
+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/constructor/zero_level.h
@@ -13,6 +13,7 @@ class TZeroLevelConstructor: public ILevelConstructor {
     std::optional<TDuration> PortionsLiveDuration;
     std::optional<ui64> ExpectedBlobsSize;
     std::optional<ui64> PortionsCountAvailable;
+    std::optional<ui64> PortionsCountLimit;
 
     virtual std::shared_ptr<IPortionsLevel> DoBuildLevel(
         const std::shared_ptr<IPortionsLevel>& nextLevel, const ui32 indexLevel, const TLevelCounters& counters) const override;
diff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/abstract.h b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/abstract.h
index a43ab27668b0..2233e71122a7 100644
--- a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/abstract.h
+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/abstract.h
@@ -295,6 +295,10 @@ class IPortionsLevel {
     mutable std::optional<TInstant> PredOptimization = TInstant::Now();
 
 public:
+    virtual bool IsOverloaded() const {
+        return false;
+    }
+
     bool HasData() const {
         return PortionsInfo.GetCount();
     }
diff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/optimizer.cpp b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/optimizer.cpp
index fcc5ce4a58d7..b20d6c1a0fde 100644
--- a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/optimizer.cpp
+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/optimizer.cpp
@@ -30,11 +30,11 @@ TOptimizerPlanner::TOptimizerPlanner(const TInternalPathId pathId, const std::sh
             nextLevel = Levels.back();
         }
     } else {
-        Levels.emplace_back(std::make_shared<TZeroLevelPortions>(2, nullptr, Counters->GetLevelCounters(2), TDuration::Max(), 1 << 20, 10));
+        Levels.emplace_back(std::make_shared<TZeroLevelPortions>(2, nullptr, Counters->GetLevelCounters(2), TDuration::Max(), 1 << 20, 10, std::nullopt));
         Levels.emplace_back(
-            std::make_shared<TZeroLevelPortions>(1, Levels.back(), Counters->GetLevelCounters(1), TDuration::Max(), 1 << 20, 10));
-        Levels.emplace_back(
-            std::make_shared<TZeroLevelPortions>(0, Levels.back(), Counters->GetLevelCounters(0), TDuration::Seconds(180), 1 << 20, 10));
+            std::make_shared<TZeroLevelPortions>(1, Levels.back(), Counters->GetLevelCounters(1), TDuration::Max(), 1 << 20, 10, std::nullopt));
+        Levels.emplace_back(std::make_shared<TZeroLevelPortions>(
+            0, Levels.back(), Counters->GetLevelCounters(0), TDuration::Seconds(180), 1 << 20, 10, std::nullopt));
     }
     std::reverse(Levels.begin(), Levels.end());
     RefreshWeights();
diff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/optimizer.h b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/optimizer.h
index 6d0071b99dce..e34f678f896a 100644
--- a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/optimizer.h
+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/optimizer.h
@@ -17,6 +17,15 @@ class TOptimizerPlanner: public IOptimizerPlanner {
     std::map<ui64, std::shared_ptr<IPortionsLevel>, std::greater<ui64>> LevelsByWeight;
     const std::shared_ptr<IStoragesManager> StoragesManager;
     const std::shared_ptr<arrow::Schema> PrimaryKeysSchema;
+    virtual bool DoIsOverloaded() const override {
+        for (auto&& i : Levels) {
+            if (i->IsOverloaded()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
     virtual std::vector<TTaskDescription> DoGetTasksDescription() const override {
         std::vector<TTaskDescription> result;
         for (auto&& i : Levels) {
diff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/zero_level.cpp b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/zero_level.cpp
index 60e99b9a3d06..d79bc6c40e40 100644
--- a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/zero_level.cpp
+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/zero_level.cpp
@@ -68,4 +68,18 @@ TInstant TZeroLevelPortions::DoGetWeightExpirationInstant() const {
     return *PredOptimization + DurationToDrop;
 }
 
+TZeroLevelPortions::TZeroLevelPortions(const ui32 levelIdx, const std::shared_ptr<IPortionsLevel>& nextLevel,
+    const TLevelCounters& levelCounters, const TDuration durationToDrop, const ui64 expectedBlobsSize, const ui64 portionsCountAvailable,
+    const std::optional<ui64> portionsCountLimit)
+    : TBase(levelIdx, nextLevel)
+    , LevelCounters(levelCounters)
+    , DurationToDrop(durationToDrop)
+    , ExpectedBlobsSize(expectedBlobsSize)
+    , PortionsCountAvailable(portionsCountAvailable)
+    , PortionsCountLimit(portionsCountLimit) {
+    if (DurationToDrop != TDuration::Max() && PredOptimization) {
+        *PredOptimization -= TDuration::Seconds(RandomNumber<ui32>(DurationToDrop.Seconds()));
+    }
+}
+
 }   // namespace NKikimr::NOlap::NStorageOptimizer::NLCBuckets
diff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/zero_level.h b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/zero_level.h
index e4cbd13259da..6ec690182e5b 100644
--- a/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/zero_level.h
+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/lcbuckets/planner/zero_level.h
@@ -11,6 +11,7 @@ class TZeroLevelPortions: public IPortionsLevel {
     const TDuration DurationToDrop;
     const ui64 ExpectedBlobsSize;
     const ui64 PortionsCountAvailable;
+    const std::optional<ui64> PortionsCountLimit;
     class TOrderedPortion {
     private:
         YDB_READONLY_DEF(TPortionInfo::TConstPtr, Portion);
@@ -39,6 +40,13 @@ class TZeroLevelPortions: public IPortionsLevel {
     };
     std::set<TOrderedPortion> Portions;
 
+    virtual bool IsOverloaded() const override {
+        if (!PortionsCountLimit) {
+            return false;
+        }
+        return Portions.size() > *PortionsCountLimit;
+    }
+
     virtual NArrow::NMerger::TIntervalPositions DoGetBucketPositions(const std::shared_ptr<arrow::Schema>& /*pkSchema*/) const override {
         return NArrow::NMerger::TIntervalPositions();
     }
@@ -95,13 +103,7 @@ class TZeroLevelPortions: public IPortionsLevel {
 
 public:
     TZeroLevelPortions(const ui32 levelIdx, const std::shared_ptr<IPortionsLevel>& nextLevel, const TLevelCounters& levelCounters,
-        const TDuration durationToDrop, const ui64 expectedBlobsSize, const ui64 portionsCountAvailable)
-        : TBase(levelIdx, nextLevel)
-        , LevelCounters(levelCounters)
-        , DurationToDrop(durationToDrop)
-        , ExpectedBlobsSize(expectedBlobsSize)
-        , PortionsCountAvailable(portionsCountAvailable) {
-    }
+        const TDuration durationToDrop, const ui64 expectedBlobsSize, const ui64 portionsCountAvailable, const std::optional<ui64> portionsCountLimit);
 };
 
 }   // namespace NKikimr::NOlap::NStorageOptimizer::NLCBuckets
diff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/counters/counters.h b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/counters/counters.h
index 0f04067f8ef4..8a309059eecf 100644
--- a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/counters/counters.h
+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/counters/counters.h
@@ -1,6 +1,6 @@
 #pragma once
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
-#include <ydb/core/tx/columnshard/counters/common/agent.h>
+#include <ydb/library/signals/owner.h>
+#include <ydb/library/signals/agent.h>
 #include <ydb/core/tx/columnshard/engines/portions/portion_info.h>
 
 namespace NKikimr::NOlap::NStorageOptimizer::NSBuckets {
diff --git a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/counters/ya.make b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/counters/ya.make
index 7f45975900a7..762de70f968d 100644
--- a/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/counters/ya.make
+++ b/ydb/core/tx/columnshard/engines/storage/optimizer/sbuckets/counters/ya.make
@@ -5,7 +5,7 @@ SRCS(
 )
 
 PEERDIR(
-    ydb/core/tx/columnshard/counters/common
+    ydb/library/signals
     ydb/core/tx/columnshard/engines/portions
 )
 
diff --git a/ydb/core/tx/columnshard/engines/ut/ut_logs_engine.cpp b/ydb/core/tx/columnshard/engines/ut/ut_logs_engine.cpp
index 017d43015c86..c8b4dc2dc6b4 100644
--- a/ydb/core/tx/columnshard/engines/ut/ut_logs_engine.cpp
+++ b/ydb/core/tx/columnshard/engines/ut/ut_logs_engine.cpp
@@ -570,28 +570,28 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {
         {   // select from snap before insert
             ui64 planStep = 1;
             ui64 txId = 0;
-            auto selectInfo = engine.Select(paths[0], TSnapshot(planStep, txId), NOlap::TPKRangesFilter(false), false);
+            auto selectInfo = engine.Select(paths[0], TSnapshot(planStep, txId), NOlap::TPKRangesFilter(), false);
             UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 0);
         }
 
         {   // select from snap between insert (greater txId)
             ui64 planStep = 1;
             ui64 txId = 2;
-            auto selectInfo = engine.Select(paths[0], TSnapshot(planStep, txId), NOlap::TPKRangesFilter(false), false);
+            auto selectInfo = engine.Select(paths[0], TSnapshot(planStep, txId), NOlap::TPKRangesFilter(), false);
             UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 0);
         }
 
         {   // select from snap after insert (greater planStep)
             ui64 planStep = 2;
             ui64 txId = 1;
-            auto selectInfo = engine.Select(paths[0], TSnapshot(planStep, txId), NOlap::TPKRangesFilter(false), false);
+            auto selectInfo = engine.Select(paths[0], TSnapshot(planStep, txId), NOlap::TPKRangesFilter(), false);
             UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 1);
         }
 
         {   // select another pathId
             ui64 planStep = 2;
             ui64 txId = 1;
-            auto selectInfo = engine.Select(paths[1], TSnapshot(planStep, txId), NOlap::TPKRangesFilter(false), false);
+            auto selectInfo = engine.Select(paths[1], TSnapshot(planStep, txId), NOlap::TPKRangesFilter(), false);
             UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 0);
         }
     }
@@ -661,7 +661,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {
 
         {   // full scan
             ui64 txId = 1;
-            auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(false), false);
+            auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(), false);
             UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 20);
         }
 
@@ -673,7 +673,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {
             if (key[0].GetType() == TTypeInfo(NTypeIds::Utf8)) {
                 gt10k = MakeStrPredicate("10000", NKikimr::NKernels::EOperation::Greater);
             }
-            NOlap::TPKRangesFilter pkFilter(false);
+            NOlap::TPKRangesFilter pkFilter;
             Y_ABORT_UNLESS(pkFilter.Add(gt10k, nullptr, indexInfo.GetReplaceKey()));
             auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), pkFilter, false);
             UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 10);
@@ -685,7 +685,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {
             if (key[0].GetType() == TTypeInfo(NTypeIds::Utf8)) {
                 lt10k = MakeStrPredicate("08999", NKikimr::NKernels::EOperation::Less);
             }
-            NOlap::TPKRangesFilter pkFilter(false);
+            NOlap::TPKRangesFilter pkFilter;
             Y_ABORT_UNLESS(pkFilter.Add(nullptr, lt10k, indexInfo.GetReplaceKey()));
             auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), pkFilter, false);
             UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 9);
@@ -845,7 +845,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {
 
             {   // full scan
                 ui64 txId = 1;
-                auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(false), false);
+                auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(), false);
                 UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 20);
             }
 
@@ -854,7 +854,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {
 
             {   // full scan
                 ui64 txId = 1;
-                auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(false), false);
+                auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(), false);
                 UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 20);
             }
 
@@ -870,7 +870,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {
 
             {   // full scan
                 ui64 txId = 1;
-                auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(false), false);
+                auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(), false);
                 UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 10);
             }
         }
@@ -886,7 +886,7 @@ Y_UNIT_TEST_SUITE(TColumnEngineTestLogs) {
 
             {   // full scan
                 ui64 txId = 1;
-                auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(false), false);
+                auto selectInfo = engine.Select(pathId, TSnapshot(planStep, txId), NOlap::TPKRangesFilter(), false);
                 UNIT_ASSERT_VALUES_EQUAL(selectInfo->Portions.size(), 10);
             }
         }
diff --git a/ydb/core/tx/columnshard/engines/ut/ut_script.cpp b/ydb/core/tx/columnshard/engines/ut/ut_script.cpp
index a50388e8bfb9..1ee5dd5091fa 100644
--- a/ydb/core/tx/columnshard/engines/ut/ut_script.cpp
+++ b/ydb/core/tx/columnshard/engines/ut/ut_script.cpp
@@ -26,26 +26,26 @@ Y_UNIT_TEST_SUITE(TestScript) {
                 { 1, NTable::TColumn("c1", 0, NScheme::TTypeInfo(NScheme::NTypeIds::Int32), "") },
                 { 2, NTable::TColumn("c2", 0, NScheme::TTypeInfo(NScheme::NTypeIds::Int32), "") } }));
 
-        acc.AddFetchingStep(std::vector<ui32>({ 0 }), NCommon::EStageFeaturesIndexes::Filter);
-        acc.AddFetchingStep(std::vector<ui32>({ 0 }), NCommon::EStageFeaturesIndexes::Filter);
-        acc.AddAssembleStep(std::vector<ui32>({ 0 }), "", NCommon::EStageFeaturesIndexes::Filter, false);
+        acc.AddFetchingStep(std::vector<ui32>({ 0 }), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);
+        acc.AddFetchingStep(std::vector<ui32>({ 0 }), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);
+        acc.AddAssembleStep(std::vector<ui32>({ 0 }), "", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter, false);
         acc.AddStep(std::make_shared<NSimple::TDeletionFilter>());
-        acc.AddFetchingStep(std::vector<ui32>({ 0, 1 }), NCommon::EStageFeaturesIndexes::Filter);
-        acc.AddFetchingStep(std::vector<ui32>({ 1, 2 }), NCommon::EStageFeaturesIndexes::Fetching);
-        acc.AddFetchingStep(std::vector<ui32>({ 0 }), NCommon::EStageFeaturesIndexes::Fetching);
-        acc.AddAssembleStep(std::vector<ui32>({ 0, 1, 2 }), "", NCommon::EStageFeaturesIndexes::Fetching, false);
+        acc.AddFetchingStep(std::vector<ui32>({ 0, 1 }), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Filter);
+        acc.AddFetchingStep(std::vector<ui32>({ 1, 2 }), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching);
+        acc.AddFetchingStep(std::vector<ui32>({ 0 }), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching);
+        acc.AddAssembleStep(std::vector<ui32>({ 0, 1, 2 }), "", NArrow::NSSA::IMemoryCalculationPolicy::EStage::Fetching, false);
         acc.AddStep(std::make_shared<NSimple::TDeletionFilter>());
-        acc.AddFetchingStep(std::vector<ui32>({ 0 }), NCommon::EStageFeaturesIndexes::Merge);
+        acc.AddFetchingStep(std::vector<ui32>({ 0 }), NArrow::NSSA::IMemoryCalculationPolicy::EStage::Merge);
 
         auto script = std::move(acc).Build();
         UNIT_ASSERT_STRINGS_EQUAL(script->DebugString(),
             "{branch:UNDEFINED;steps:["
-            "{name=ALLOCATE_MEMORY::Filter;details={stage=Filter;column_ids=[Blob:0,Raw:0];};};"
+            "{name=ALLOCATE_MEMORY::FILTER;details={stage=FILTER;column_ids=[Blob:0,Raw:0];};};"
             "{name=FETCHING_COLUMNS;details={columns=0;};};"
             "{name=ASSEMBLER;details={columns=(column_ids=0;column_names=c0;);;};};"
             "{name=DELETION;details={};};"
-            "{name=ALLOCATE_MEMORY::Filter;details={stage=Filter;column_ids=[Blob:1];};};"
-            "{name=ALLOCATE_MEMORY::Fetching;details={stage=Fetching;column_ids=[Blob:2,Raw:1,Raw:2];};};"
+            "{name=ALLOCATE_MEMORY::FILTER;details={stage=FILTER;column_ids=[Blob:1];};};"
+            "{name=ALLOCATE_MEMORY::FETCHING;details={stage=FETCHING;column_ids=[Blob:2,Raw:1,Raw:2];};};"
             "{name=FETCHING_COLUMNS;details={columns=1,2;};};"
             "{name=ASSEMBLER;details={columns=(column_ids=1,2;column_names=c1,c2;);;};};"
             "{name=DELETION;details={};};]}");
diff --git a/ydb/core/tx/columnshard/engines/writer/buffer/actor2.cpp b/ydb/core/tx/columnshard/engines/writer/buffer/actor2.cpp
index faff75816478..dfa57b5bee89 100644
--- a/ydb/core/tx/columnshard/engines/writer/buffer/actor2.cpp
+++ b/ydb/core/tx/columnshard/engines/writer/buffer/actor2.cpp
@@ -71,7 +71,7 @@ void TWriteAggregation::Flush(const ui64 tabletId) {
         Context.GetWritingCounters()->OnAggregationWrite(Units.size(), SumSize);
         std::shared_ptr<NConveyor::ITask> task =
             std::make_shared<TBuildPackSlicesTask>(std::move(Units), Context, PathId, tabletId, ModificationType);
-        NConveyor::TInsertServiceOperator::AsyncTaskToExecute(task);
+        NConveyor::TInsertServiceOperator::SendTaskToExecute(task);
         Units.clear();
         SumSize = 0;
     }
diff --git a/ydb/core/tx/columnshard/engines/writer/indexed_blob_constructor.h b/ydb/core/tx/columnshard/engines/writer/indexed_blob_constructor.h
index 8765968a0a00..1fcff6975285 100644
--- a/ydb/core/tx/columnshard/engines/writer/indexed_blob_constructor.h
+++ b/ydb/core/tx/columnshard/engines/writer/indexed_blob_constructor.h
@@ -7,7 +7,7 @@
 #include <ydb/core/tx/columnshard/blobs_action/abstract/write.h>
 #include <ydb/core/tx/columnshard/blobs_action/counters/storage.h>
 #include <ydb/core/tx/columnshard/columnshard.h>
-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>
+#include <ydb/library/signals/object_counter.h>
 #include <ydb/core/tx/columnshard/engines/insert_table/user_data.h>
 #include <ydb/core/tx/columnshard/engines/portions/portion_info.h>
 #include <ydb/core/tx/data_events/write_data.h>
diff --git a/ydb/core/tx/columnshard/normalizer/portion/chunks.cpp b/ydb/core/tx/columnshard/normalizer/portion/chunks.cpp
index 7cfdfcd21308..1d7e9656cd43 100644
--- a/ydb/core/tx/columnshard/normalizer/portion/chunks.cpp
+++ b/ydb/core/tx/columnshard/normalizer/portion/chunks.cpp
@@ -52,7 +52,7 @@ class TRowsAndBytesChangesTask: public NConveyor::ITask {
     TNormalizationContext NormContext;
 
 protected:
-    virtual TConclusionStatus DoExecute(const std::shared_ptr<NConveyor::ITask>& /*taskPtr*/) override {
+    virtual void DoExecute(const std::shared_ptr<NConveyor::ITask>& /*taskPtr*/) override {
         for (auto&& chunkInfo : Chunks) {
             const auto& blobRange = chunkInfo.GetBlobRange();
 
@@ -73,7 +73,6 @@ class TRowsAndBytesChangesTask: public NConveyor::ITask {
         auto changes = std::make_shared<TChunksNormalizer::TNormalizerResult>(std::move(Chunks));
         TActorContext::AsActorContext().Send(
             NormContext.GetShardActor(), std::make_unique<NColumnShard::TEvPrivate::TEvNormalizerResult>(changes));
-        return TConclusionStatus::Success();
     }
 
 public:
diff --git a/ydb/core/tx/columnshard/operations/batch_builder/builder.cpp b/ydb/core/tx/columnshard/operations/batch_builder/builder.cpp
index cf9746640459..7f886c8be62e 100644
--- a/ydb/core/tx/columnshard/operations/batch_builder/builder.cpp
+++ b/ydb/core/tx/columnshard/operations/batch_builder/builder.cpp
@@ -21,19 +21,19 @@ void TBuildBatchesTask::ReplyError(const TString& message, const NColumnShard::T
     TActorContext::AsActorContext().Send(Context.GetTabletActorId(), result.release());
 }
 
-TConclusionStatus TBuildBatchesTask::DoExecute(const std::shared_ptr<ITask>& /*taskPtr*/) {
+void TBuildBatchesTask::DoExecute(const std::shared_ptr<ITask>& /*taskPtr*/) {
     const NActors::TLogContextGuard lGuard = NActors::TLogContextBuilder::Build()("scope", "TBuildBatchesTask::DoExecute");
     if (!Context.IsActive()) {
         AFL_WARN(NKikimrServices::TX_COLUMNSHARD_WRITE)("event", "abort_external");
         ReplyError("writing aborted", NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Internal);
-        return TConclusionStatus::Fail("writing aborted");
+        return;
     }
     TConclusion<std::shared_ptr<arrow::RecordBatch>> batchConclusion = WriteData.GetData()->ExtractBatch();
     if (batchConclusion.IsFail()) {
         AFL_WARN(NKikimrServices::TX_COLUMNSHARD_WRITE)("event", "abort_on_extract")("reason", batchConclusion.GetErrorMessage());
         ReplyError("cannot extract incoming batch: " + batchConclusion.GetErrorMessage(),
             NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Internal);
-        return TConclusionStatus::Fail("cannot extract incoming batch: " + batchConclusion.GetErrorMessage());
+        return;
     }
     Context.GetWritingCounters()->OnIncomingData(NArrow::GetBatchDataSize(*batchConclusion));
 
@@ -43,7 +43,7 @@ TConclusionStatus TBuildBatchesTask::DoExecute(const std::shared_ptr<ITask>& /*t
         AFL_WARN(NKikimrServices::TX_COLUMNSHARD_WRITE)("event", "abort_on_prepare")("reason", preparedConclusion.GetErrorMessage());
         ReplyError("cannot prepare incoming batch: " + preparedConclusion.GetErrorMessage(),
             NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Request);
-        return TConclusionStatus::Fail("cannot prepare incoming batch: " + preparedConclusion.GetErrorMessage());
+        return;
     }
     auto batch = preparedConclusion.DetachResult();
     std::shared_ptr<IMerger> merger;
@@ -54,13 +54,13 @@ TConclusionStatus TBuildBatchesTask::DoExecute(const std::shared_ptr<ITask>& /*t
                 if (!WriteData.GetWritePortions() || !Context.GetNoTxWrite()) {
                     std::shared_ptr<NConveyor::ITask> task =
                         std::make_shared<NOlap::TBuildSlicesTask>(std::move(WriteData), batch.GetContainer(), Context);
-                    NConveyor::TInsertServiceOperator::AsyncTaskToExecute(task);
+                    NConveyor::TInsertServiceOperator::SendTaskToExecute(task);
                 } else {
                     NActors::TActivationContext::ActorSystem()->Send(Context.GetBufferizationPortionsActorId(),
                         new NWritingPortions::TEvAddInsertedDataToBuffer(
                             std::make_shared<NEvWrite::TWriteData>(WriteData), batch, std::make_shared<TWritingContext>(Context)));
                 }
-                return TConclusionStatus::Success();
+                return;
             } else {
                 auto insertionConclusion = Context.GetActualSchema()->CheckColumnsDefault(defaultFields);
                 auto conclusion = Context.GetActualSchema()->BuildDefaultBatch(Context.GetActualSchema()->GetIndexInfo().ArrowSchema(), 1, true);
@@ -86,20 +86,18 @@ TConclusionStatus TBuildBatchesTask::DoExecute(const std::shared_ptr<ITask>& /*t
             if (!WriteData.GetWritePortions() || !Context.GetNoTxWrite()) {
                 std::shared_ptr<NConveyor::ITask> task =
                     std::make_shared<NOlap::TBuildSlicesTask>(std::move(WriteData), batch.GetContainer(), Context);
-                NConveyor::TInsertServiceOperator::AsyncTaskToExecute(task);
+                NConveyor::TInsertServiceOperator::SendTaskToExecute(task);
             } else {
                 NActors::TActivationContext::ActorSystem()->Send(Context.GetBufferizationPortionsActorId(),
                     new NWritingPortions::TEvAddInsertedDataToBuffer(
                                        std::make_shared<NEvWrite::TWriteData>(WriteData), batch, std::make_shared<TWritingContext>(Context)));
             }
-            return TConclusionStatus::Success();
+            return;
         }
     }
     std::shared_ptr<NDataReader::IRestoreTask> task =
         std::make_shared<NOlap::TModificationRestoreTask>(std::move(WriteData), merger, ActualSnapshot, batch, Context);
     NActors::TActivationContext::AsActorContext().Register(new NDataReader::TActor(task));
-
-    return TConclusionStatus::Success();
 }
 
 }   // namespace NKikimr::NOlap
diff --git a/ydb/core/tx/columnshard/operations/batch_builder/builder.h b/ydb/core/tx/columnshard/operations/batch_builder/builder.h
index 1ec9b1ae551f..50e156542972 100644
--- a/ydb/core/tx/columnshard/operations/batch_builder/builder.h
+++ b/ydb/core/tx/columnshard/operations/batch_builder/builder.h
@@ -17,7 +17,7 @@ class TBuildBatchesTask: public NConveyor::ITask, public NColumnShard::TMonitori
     void ReplyError(const TString& message, const NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass errorClass);
 
 protected:
-    virtual TConclusionStatus DoExecute(const std::shared_ptr<ITask>& taskPtr) override;
+    virtual void DoExecute(const std::shared_ptr<ITask>& taskPtr) override;
 
 public:
     virtual TString GetTaskClassIdentifier() const override {
diff --git a/ydb/core/tx/columnshard/operations/batch_builder/merger.h b/ydb/core/tx/columnshard/operations/batch_builder/merger.h
index f1d8fcddfa84..148af13daf6f 100644
--- a/ydb/core/tx/columnshard/operations/batch_builder/merger.h
+++ b/ydb/core/tx/columnshard/operations/batch_builder/merger.h
@@ -67,7 +67,7 @@ class TReplaceMerger: public IMerger {
 
     virtual NArrow::TContainerWithIndexes<arrow::RecordBatch> BuildResultBatch() override {
         auto result = IncomingData;
-        AFL_VERIFY(Filter.Apply(result.MutableContainer()));
+        Filter.Apply(result.MutableContainer());
         return result;
     }
 };
diff --git a/ydb/core/tx/columnshard/operations/batch_builder/restore.cpp b/ydb/core/tx/columnshard/operations/batch_builder/restore.cpp
index 3d6d8e03ed40..4854fc010fe7 100644
--- a/ydb/core/tx/columnshard/operations/batch_builder/restore.cpp
+++ b/ydb/core/tx/columnshard/operations/batch_builder/restore.cpp
@@ -13,7 +13,7 @@ std::unique_ptr<TEvColumnShard::TEvInternalScan> TModificationRestoreTask::DoBui
     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_RESTORE)("event", "restore_start")("count", IncomingData.HasContainer() ? IncomingData->num_rows() : 0)(
         "task_id", WriteData.GetWriteMeta().GetId());
     auto pkData = NArrow::TColumnOperator().VerifyIfAbsent().Extract(IncomingData.GetContainer(), Context.GetActualSchema()->GetPKColumnNames());
-    request->RangesFilter = TPKRangesFilter::BuildFromRecordBatchLines(pkData, false);
+    request->RangesFilter = TPKRangesFilter::BuildFromRecordBatchLines(pkData);
     for (auto&& i : Context.GetActualSchema()->GetIndexInfo().GetColumnIds(false)) {
         request->AddColumn(i);
     }
@@ -49,7 +49,7 @@ NKikimr::TConclusionStatus TModificationRestoreTask::DoOnFinished() {
     if (!WriteData.GetWritePortions() || !Context.GetNoTxWrite()) {
         std::shared_ptr<NConveyor::ITask> task =
             std::make_shared<NOlap::TBuildSlicesTask>(std::move(WriteData), batchResult.GetContainer(), Context);
-        NConveyor::TInsertServiceOperator::AsyncTaskToExecute(task);
+        NConveyor::TInsertServiceOperator::SendTaskToExecute(task);
     } else {
         NActors::TActivationContext::ActorSystem()->Send(
             Context.GetBufferizationPortionsActorId(), new NWritingPortions::TEvAddInsertedDataToBuffer(
diff --git a/ydb/core/tx/columnshard/operations/events.h b/ydb/core/tx/columnshard/operations/events.h
index 30328c0bfc49..bf0ac210c627 100644
--- a/ydb/core/tx/columnshard/operations/events.h
+++ b/ydb/core/tx/columnshard/operations/events.h
@@ -29,10 +29,36 @@ class TWriteResult {
     std::shared_ptr<NEvWrite::TWriteMeta> WriteMeta;
     YDB_READONLY(ui64, DataSize, 0);
     YDB_READONLY(bool, NoDataToWrite, false);
+    TString ErrorMessage;
+    std::optional<bool> IsInternalErrorFlag;
     std::shared_ptr<arrow::RecordBatch> PKBatch;
     ui32 RecordsCount;
 
 public:
+    TWriteResult& SetErrorMessage(const TString& value, const bool isInternal) {
+        AFL_VERIFY(!ErrorMessage);
+        IsInternalErrorFlag = isInternal;
+        ErrorMessage = value;
+        return *this;
+    }
+
+    bool IsInternalError() const {
+        AFL_VERIFY_DEBUG(!!IsInternalErrorFlag);
+        if (!IsInternalErrorFlag) {
+            return true;
+        }
+        return *IsInternalErrorFlag;
+    }
+
+    const TString& GetErrorMessage() const {
+        static TString undefinedMessage = "UNKNOWN_WRITE_RESULT_MESSAGE";
+        AFL_VERIFY_DEBUG(!!ErrorMessage);
+        if (!ErrorMessage) {
+            return undefinedMessage;
+        }
+        return ErrorMessage;
+    }
+
     const std::shared_ptr<arrow::RecordBatch>& GetPKBatchVerified() const {
         AFL_VERIFY(PKBatch);
         return PKBatch;
@@ -91,11 +117,16 @@ namespace NKikimr::NColumnShard::NPrivateEvents::NWrite {
 class TEvWritePortionResult: public TEventLocal<TEvWritePortionResult, TEvPrivate::EvWritePortionResult> {
 private:
     YDB_READONLY_DEF(NKikimrProto::EReplyStatus, WriteStatus);
-    YDB_READONLY_DEF(std::shared_ptr<NOlap::IBlobsWritingAction>, WriteAction);
+    std::optional<std::shared_ptr<NOlap::IBlobsWritingAction>> WriteAction;
     bool Detached = false;
     TInsertedPortions InsertedData;
 
 public:
+    const std::shared_ptr<NOlap::IBlobsWritingAction>& GetWriteAction() const {
+        AFL_VERIFY(!!WriteAction);
+        return *WriteAction;
+    }
+
     const TInsertedPortions& DetachInsertedData() {
         AFL_VERIFY(!Detached);
         Detached = true;
diff --git a/ydb/core/tx/columnshard/operations/slice_builder/builder.cpp b/ydb/core/tx/columnshard/operations/slice_builder/builder.cpp
index 866720bb1a65..fb79e54284b4 100644
--- a/ydb/core/tx/columnshard/operations/slice_builder/builder.cpp
+++ b/ydb/core/tx/columnshard/operations/slice_builder/builder.cpp
@@ -99,19 +99,19 @@ class TPortionWriteController: public NColumnShard::IWriteController,
     }
 };
 
-TConclusionStatus TBuildSlicesTask::DoExecute(const std::shared_ptr<ITask>& /*taskPtr*/) {
+void TBuildSlicesTask::DoExecute(const std::shared_ptr<ITask>& /*taskPtr*/) {
     const NActors::TLogContextGuard g = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD_WRITE)("tablet_id", TabletId)(
         "parent_id", Context.GetTabletActorId())("write_id", WriteData.GetWriteMeta().GetWriteId())(
         "table_id", WriteData.GetWriteMeta().GetTableId());
     if (!Context.IsActive()) {
         AFL_WARN(NKikimrServices::TX_COLUMNSHARD_WRITE)("event", "abort_execution");
         ReplyError("execution aborted", NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Internal);
-        return TConclusionStatus::Fail("execution aborted");
+        return;
     }
     if (!OriginalBatch) {
         AFL_WARN(NKikimrServices::TX_COLUMNSHARD_WRITE)("event", "ev_write_bad_data");
         ReplyError("no data in batch", NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Internal);
-        return TConclusionStatus::Fail("no data in batch");
+        return;
     }
     if (WriteData.GetWritePortions()) {
         if (OriginalBatch->num_rows() == 0) {
@@ -136,7 +136,7 @@ TConclusionStatus TBuildSlicesTask::DoExecute(const std::shared_ptr<ITask>& /*ta
                         WriteData.GetWriteMeta().GetModificationType(), Context.GetStoragesManager(), Context.GetSplitterCounters());
                 if (portionConclusion.IsFail()) {
                     ReplyError(portionConclusion.GetErrorMessage(), NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Request);
-                    return portionConclusion;
+                    return;
                 }
                 portions.emplace_back(portionConclusion.DetachResult());
             }
@@ -157,7 +157,7 @@ TConclusionStatus TBuildSlicesTask::DoExecute(const std::shared_ptr<ITask>& /*ta
                 "problem", subsetConclusion.GetErrorMessage());
             ReplyError("unadaptable schema: " + subsetConclusion.GetErrorMessage(),
                 NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Internal);
-            return TConclusionStatus::Fail("cannot reorder schema: " + subsetConclusion.GetErrorMessage());
+            return;
         }
         NArrow::TSchemaSubset subset = subsetConclusion.DetachResult();
 
@@ -186,9 +186,8 @@ TConclusionStatus TBuildSlicesTask::DoExecute(const std::shared_ptr<ITask>& /*ta
             TActorContext::AsActorContext().Send(Context.GetBufferizationInsertionActorId(), result.release());
         } else {
             ReplyError("Cannot slice input to batches", NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass::Internal);
-            return TConclusionStatus::Fail("Cannot slice input to batches");
+            return;
         }
     }
-    return TConclusionStatus::Success();
 }
 }   // namespace NKikimr::NOlap
diff --git a/ydb/core/tx/columnshard/operations/slice_builder/builder.h b/ydb/core/tx/columnshard/operations/slice_builder/builder.h
index 0efd53378e3f..5d6bb4159777 100644
--- a/ydb/core/tx/columnshard/operations/slice_builder/builder.h
+++ b/ydb/core/tx/columnshard/operations/slice_builder/builder.h
@@ -18,7 +18,7 @@ class TBuildSlicesTask: public NConveyor::ITask, public NColumnShard::TMonitorin
     void ReplyError(const TString& message, const NColumnShard::TEvPrivate::TEvWriteBlobsResult::EErrorClass errorClass);
 
 protected:
-    virtual TConclusionStatus DoExecute(const std::shared_ptr<ITask>& taskPtr) override;
+    virtual void DoExecute(const std::shared_ptr<ITask>& taskPtr) override;
 
 public:
     virtual TString GetTaskClassIdentifier() const override {
diff --git a/ydb/core/tx/columnshard/operations/slice_builder/pack_builder.cpp b/ydb/core/tx/columnshard/operations/slice_builder/pack_builder.cpp
index 6ab38d7cbc21..9b9b0e351b5b 100644
--- a/ydb/core/tx/columnshard/operations/slice_builder/pack_builder.cpp
+++ b/ydb/core/tx/columnshard/operations/slice_builder/pack_builder.cpp
@@ -44,6 +44,11 @@ class TPortionWriteController: public NColumnShard::IWriteController,
         for (auto&& i : Portions) {
             portions.emplace_back(i.ExtractPortion());
         }
+        if (putResult->GetPutStatus() != NKikimrProto::OK) {
+            for (auto&& i : WriteResults) {
+                i.SetErrorMessage("cannot put blobs: " + ::ToString(putResult->GetPutStatus()), true);
+            }
+        }
         NColumnShard::TInsertedPortions pack(std::move(WriteResults), std::move(portions));
         auto result =
             std::make_unique<NColumnShard::NPrivateEvents::NWrite::TEvWritePortionResult>(putResult->GetPutStatus(), Action, std::move(pack));
@@ -89,13 +94,18 @@ class TSliceToMerge {
         SequentialWriteId.emplace_back(data->GetWriteMeta().GetWriteId());
     }
 
-    [[nodiscard]] TConclusionStatus Finalize(const NOlap::TWritingContext& context, std::vector<TPortionWriteController::TInsertPortion>& result) {
+    [[nodiscard]] TConclusionStatus Finalize(
+        const NOlap::TWritingContext& context, std::vector<TPortionWriteController::TInsertPortion>& result) {
         if (Batches.size() == 0) {
             return TConclusionStatus::Success();
         }
         if (Batches.size() == 1) {
-            auto portionConclusion = context.GetActualSchema()->PrepareForWrite(context.GetActualSchema(), PathId, Batches.front().GetContainer(),
-                ModificationType, context.GetStoragesManager(), context.GetSplitterCounters());
+            auto portionConclusion = context.GetActualSchema()->PrepareForWrite(context.GetActualSchema(), PathId,
+                Batches.front().GetContainer(), ModificationType, context.GetStoragesManager(), context.GetSplitterCounters());
+            if (portionConclusion.IsFail()) {
+                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)("event", "cannot prepare for write")("reason", portionConclusion.GetErrorMessage());
+                return portionConclusion;
+            }
             result.emplace_back(portionConclusion.DetachResult());
         } else {
             ui32 idx = 0;
@@ -119,12 +129,16 @@ class TSliceToMerge {
                         if (itBatchIndexes == i.GetColumnIndexes().end() || *itAllIndexes < *itBatchIndexes) {
                             auto defaultColumn = indexInfo.BuildDefaultColumn(*itAllIndexes, i->num_rows(), false);
                             if (defaultColumn.IsFail()) {
+                                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)("event", "cannot build default column")(
+                                    "reason", defaultColumn.GetErrorMessage());
                                 return defaultColumn;
                             }
-                            gContainer->AddField(context.GetActualSchema()->GetFieldByIndexVerified(*itAllIndexes), defaultColumn.DetachResult()).Validate();
+                            gContainer->AddField(context.GetActualSchema()->GetFieldByIndexVerified(*itAllIndexes), defaultColumn.DetachResult())
+                                .Validate();
                         } else {
                             AFL_VERIFY(*itAllIndexes == *itBatchIndexes);
-                            gContainer->AddField(context.GetActualSchema()->GetFieldByIndexVerified(*itAllIndexes),
+                            gContainer
+                                ->AddField(context.GetActualSchema()->GetFieldByIndexVerified(*itAllIndexes),
                                     i->column(itBatchIndexes - i.GetColumnIndexes().begin()))
                                 .Validate();
                             ++itBatchIndexes;
@@ -152,19 +166,19 @@ class TSliceToMerge {
             stream.DrainAll(rbBuilder);
             auto portionConclusion = context.GetActualSchema()->PrepareForWrite(context.GetActualSchema(), PathId, rbBuilder.Finalize(),
                 ModificationType, context.GetStoragesManager(), context.GetSplitterCounters());
+            if (portionConclusion.IsFail()) {
+                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)("event", "cannot prepare for write")("reason", portionConclusion.GetErrorMessage());
+                return portionConclusion;
+            }
             result.emplace_back(portionConclusion.DetachResult());
         }
         return TConclusionStatus::Success();
     }
 };
 
-TConclusionStatus TBuildPackSlicesTask::DoExecute(const std::shared_ptr<ITask>& /*taskPtr*/) {
+void TBuildPackSlicesTask::DoExecute(const std::shared_ptr<ITask>& /*taskPtr*/) {
     const NActors::TLogContextGuard g = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD_WRITE)("tablet_id", TabletId)(
         "parent_id", Context.GetTabletActorId())("path_id", PathId);
-    if (!Context.IsActive()) {
-        AFL_WARN(NKikimrServices::TX_COLUMNSHARD_WRITE)("event", "abort_execution");
-        return TConclusionStatus::Fail("execution aborted");
-    }
     NArrow::NMerger::TIntervalPositions splitPositions;
     for (auto&& unit : WriteUnits) {
         splitPositions.Merge(unit.GetData()->GetData()->GetSeparationPoints());
@@ -192,18 +206,39 @@ TConclusionStatus TBuildPackSlicesTask::DoExecute(const std::shared_ptr<ITask>&
         }
     }
     std::vector<TPortionWriteController::TInsertPortion> portionsToWrite;
-    for (auto&& i : slicesToMerge) {
-        i.Finalize(Context, portionsToWrite).Validate();
+    TString cancelWritingReason;
+    if (!Context.IsActive()) {
+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD_WRITE)("event", "abort_execution");
+        cancelWritingReason = "execution aborted";
+    } else {
+        for (auto&& i : slicesToMerge) {
+            auto conclusion = i.Finalize(Context, portionsToWrite);
+            if (conclusion.IsFail()) {
+                AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)("event", "cannot build slice")("reason", conclusion.GetErrorMessage());
+                cancelWritingReason = conclusion.GetErrorMessage();
+                break;
+            }
+        }
     }
-    auto actions = WriteUnits.front().GetData()->GetBlobsAction();
-    auto writeController =
-        std::make_shared<TPortionWriteController>(Context.GetTabletActorId(), actions, std::move(writeResults), std::move(portionsToWrite));
-    if (actions->NeedDraftTransaction()) {
-        TActorContext::AsActorContext().Send(
-            Context.GetTabletActorId(), std::make_unique<NColumnShard::TEvPrivate::TEvWriteDraft>(writeController));
+    if (!cancelWritingReason) {
+        auto actions = WriteUnits.front().GetData()->GetBlobsAction();
+        auto writeController =
+            std::make_shared<TPortionWriteController>(Context.GetTabletActorId(), actions, std::move(writeResults), std::move(portionsToWrite));
+        if (actions->NeedDraftTransaction()) {
+            TActorContext::AsActorContext().Send(
+                Context.GetTabletActorId(), std::make_unique<NColumnShard::TEvPrivate::TEvWriteDraft>(writeController));
+        } else {
+            TActorContext::AsActorContext().Register(NColumnShard::CreateWriteActor(TabletId, writeController, TInstant::Max()));
+        }
     } else {
-        TActorContext::AsActorContext().Register(NColumnShard::CreateWriteActor(TabletId, writeController, TInstant::Max()));
+        for (auto&& i : writeResults) {
+            i.SetErrorMessage(cancelWritingReason, false);
+        }
+        NColumnShard::TInsertedPortions pack(std::move(writeResults), std::vector<NColumnShard::TInsertedPortion>());
+        auto result =
+            std::make_unique<NColumnShard::NPrivateEvents::NWrite::TEvWritePortionResult>(NKikimrProto::EReplyStatus::ERROR, nullptr, std::move(pack));
+        TActorContext::AsActorContext().Send(Context.GetTabletActorId(), result.release());
+    
     }
-    return TConclusionStatus::Success();
 }
 }   // namespace NKikimr::NOlap::NWritingPortions
diff --git a/ydb/core/tx/columnshard/operations/slice_builder/pack_builder.h b/ydb/core/tx/columnshard/operations/slice_builder/pack_builder.h
index f8f46e35ba6d..cbcc954630db 100644
--- a/ydb/core/tx/columnshard/operations/slice_builder/pack_builder.h
+++ b/ydb/core/tx/columnshard/operations/slice_builder/pack_builder.h
@@ -1,7 +1,7 @@
 #pragma once
 #include <ydb/core/formats/arrow/size_calcer.h>
 #include <ydb/core/tx/columnshard/columnshard_private_events.h>
-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>
+#include <ydb/library/signals/object_counter.h>
 #include <ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.h>
 #include <ydb/core/tx/columnshard/operations/common/context.h>
 #include <ydb/core/tx/columnshard/common/path_id.h>
@@ -35,7 +35,7 @@ class TBuildPackSlicesTask: public NConveyor::ITask, public NColumnShard::TMonit
     std::optional<std::vector<NArrow::TSerializedBatch>> BuildSlices();
 
 protected:
-    virtual TConclusionStatus DoExecute(const std::shared_ptr<ITask>& taskPtr) override;
+    virtual void DoExecute(const std::shared_ptr<ITask>& taskPtr) override;
 
 public:
     virtual TString GetTaskClassIdentifier() const override {
diff --git a/ydb/core/tx/columnshard/operations/write.cpp b/ydb/core/tx/columnshard/operations/write.cpp
index d739caf6aedc..b7d184b9c07c 100644
--- a/ydb/core/tx/columnshard/operations/write.cpp
+++ b/ydb/core/tx/columnshard/operations/write.cpp
@@ -38,7 +38,7 @@ void TWriteOperation::Start(
     NEvWrite::TWriteData writeData(writeMeta, data, owner.TablesManager.GetPrimaryIndex()->GetReplaceKey(),
         owner.StoragesManager->GetInsertOperator()->StartWritingAction(NOlap::NBlobOperations::EConsumer::WRITING_OPERATOR), WritePortions);
     std::shared_ptr<NConveyor::ITask> task = std::make_shared<NOlap::TBuildBatchesTask>(std::move(writeData), context);
-    NConveyor::TInsertServiceOperator::AsyncTaskToExecute(task);
+    NConveyor::TInsertServiceOperator::SendTaskToExecute(task);
 
     Status = EOperationStatus::Started;
 }
diff --git a/ydb/core/tx/columnshard/operations/write.h b/ydb/core/tx/columnshard/operations/write.h
index 735a8aa93b0d..97800d78dc8a 100644
--- a/ydb/core/tx/columnshard/operations/write.h
+++ b/ydb/core/tx/columnshard/operations/write.h
@@ -5,7 +5,7 @@
 #include <ydb/core/protos/tx_columnshard.pb.h>
 #include <ydb/core/tablet_flat/flat_cxx_database.h>
 #include <ydb/core/tx/columnshard/common/snapshot.h>
-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>
+#include <ydb/library/signals/object_counter.h>
 #include <ydb/core/tx/columnshard/engines/defs.h>
 #include <ydb/core/tx/columnshard/engines/scheme/versions/abstract_scheme.h>
 #include <ydb/core/tx/columnshard/common/path_id.h>
diff --git a/ydb/core/tx/columnshard/resource_subscriber/counters.h b/ydb/core/tx/columnshard/resource_subscriber/counters.h
index 230222f8ffa3..5495f9cf2327 100644
--- a/ydb/core/tx/columnshard/resource_subscriber/counters.h
+++ b/ydb/core/tx/columnshard/resource_subscriber/counters.h
@@ -1,6 +1,6 @@
 #pragma once
 #include <library/cpp/monlib/dynamic_counters/counters.h>
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 #include <util/generic/hash.h>
 
 namespace NKikimr::NOlap::NResourceBroker::NSubscribe {
diff --git a/ydb/core/tx/columnshard/resource_subscriber/task.h b/ydb/core/tx/columnshard/resource_subscriber/task.h
index 46a1ebebd32c..a065c8946691 100644
--- a/ydb/core/tx/columnshard/resource_subscriber/task.h
+++ b/ydb/core/tx/columnshard/resource_subscriber/task.h
@@ -1,5 +1,5 @@
 #pragma once
-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>
+#include <ydb/library/signals/object_counter.h>
 #include "counters.h"
 
 namespace NKikimr::NOlap::NResourceBroker::NSubscribe {
diff --git a/ydb/core/tx/columnshard/resources/memory.h b/ydb/core/tx/columnshard/resources/memory.h
index 3f0683d38dec..388caf15a6ae 100644
--- a/ydb/core/tx/columnshard/resources/memory.h
+++ b/ydb/core/tx/columnshard/resources/memory.h
@@ -1,6 +1,6 @@
 #pragma once
-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/object_counter.h>
+#include <ydb/library/signals/owner.h>
 #include <ydb/library/services/services.pb.h>
 #include <ydb/library/actors/core/log.h>
 #include <util/system/mutex.h>
diff --git a/ydb/core/tx/columnshard/tablet/write_queue.cpp b/ydb/core/tx/columnshard/tablet/write_queue.cpp
index 41291f1d6f08..75726189c77e 100644
--- a/ydb/core/tx/columnshard/tablet/write_queue.cpp
+++ b/ydb/core/tx/columnshard/tablet/write_queue.cpp
@@ -7,12 +7,6 @@
 namespace NKikimr::NColumnShard {
 
 bool TWriteTask::Execute(TColumnShard* owner, const TActorContext& /* ctx */) {
-    auto overloadStatus = owner->CheckOverloadedWait(PathId);
-    if (overloadStatus != TColumnShard::EOverloadStatus::None) {
-        AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_WRITE)("event", "wait_overload")("status", overloadStatus);
-        return false;
-    }
-
     owner->Counters.GetCSCounters().WritingCounters->OnWritingTaskDequeue(TMonotonic::Now() - Created);
     owner->OperationsManager->RegisterLock(LockId, owner->Generation());
     auto writeOperation = owner->OperationsManager->RegisterOperation(
@@ -37,21 +31,39 @@ bool TWriteTasksQueue::Drain(const bool onWakeup, const TActorContext& ctx) {
     if (onWakeup) {
         WriteTasksOverloadCheckerScheduled = false;
     }
-    while (WriteTasks.size() && WriteTasks.front().Execute(Owner, ctx)) {
-        WriteTasks.pop_front();
+    std::vector<TInternalPathId> toRemove;
+    ui32 countTasks = 0;
+    for (auto&& i : WriteTasks) {
+        auto overloadStatus = Owner->CheckOverloadedWait(i.first);
+        if (overloadStatus != TColumnShard::EOverloadStatus::None) {
+            countTasks += i.second.size();
+            AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD_WRITE)("event", "wait_overload")("status", overloadStatus)("path_id", i.first)(
+                "size", i.second.size());
+            continue;
+        }
+        for (auto&& t : i.second) {
+            t.Execute(Owner, ctx);
+        }
+        toRemove.emplace_back(i.first);
     }
-    if (WriteTasks.size() && !WriteTasksOverloadCheckerScheduled) {
+
+    for (auto&& i : toRemove) {
+        AFL_VERIFY(WriteTasks.erase(i));
+    }
+
+    if (countTasks && !WriteTasksOverloadCheckerScheduled) {
         Owner->Schedule(TDuration::MilliSeconds(300), new NActors::TEvents::TEvWakeup(1));
         WriteTasksOverloadCheckerScheduled = true;
-        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)("event", "queue_on_write")("size", WriteTasks.size());
+        AFL_WARN(NKikimrServices::TX_COLUMNSHARD)("event", "queue_on_write")("size", countTasks);
     }
-    Owner->Counters.GetCSCounters().WritingCounters->QueueWaitSize->Add((i64)WriteTasks.size() - PredWriteTasksSize);
-    PredWriteTasksSize = (i64)WriteTasks.size();
-    return !WriteTasks.size();
+    Owner->Counters.GetCSCounters().WritingCounters->QueueWaitSize->Add((i64)countTasks - PredWriteTasksSize);
+    PredWriteTasksSize = (i64)countTasks;
+    return !countTasks;
 }
 
 void TWriteTasksQueue::Enqueue(TWriteTask&& task) {
-    WriteTasks.emplace_back(std::move(task));
+    const TInternalPathId pathId = task.GetPathId();
+    WriteTasks[pathId].emplace_back(std::move(task));
 }
 
 TWriteTasksQueue::~TWriteTasksQueue() {
diff --git a/ydb/core/tx/columnshard/tablet/write_queue.h b/ydb/core/tx/columnshard/tablet/write_queue.h
index 4e0c63363b1d..aba35e5a6a20 100644
--- a/ydb/core/tx/columnshard/tablet/write_queue.h
+++ b/ydb/core/tx/columnshard/tablet/write_queue.h
@@ -35,6 +35,10 @@ class TWriteTask: TMoveOnly {
         , Behaviour(behaviour) {
     }
 
+    const TInternalPathId& GetPathId() const {
+        return PathId;
+    }
+
     const TMonotonic& GetCreatedMonotonic() const {
         return Created;
     }
@@ -45,7 +49,7 @@ class TWriteTask: TMoveOnly {
 class TWriteTasksQueue {
 private:
     bool WriteTasksOverloadCheckerScheduled = false;
-    std::deque<TWriteTask> WriteTasks;
+    THashMap<TInternalPathId, std::deque<TWriteTask>> WriteTasks;
     i64 PredWriteTasksSize = 0;
     TColumnShard* Owner;
 
diff --git a/ydb/core/tx/columnshard/transactions/locks/read_start.cpp b/ydb/core/tx/columnshard/transactions/locks/read_start.cpp
index 963c47b068a9..5165e8f194d7 100644
--- a/ydb/core/tx/columnshard/transactions/locks/read_start.cpp
+++ b/ydb/core/tx/columnshard/transactions/locks/read_start.cpp
@@ -17,7 +17,7 @@ bool TEvReadStart::DoDeserializeFromProto(const NKikimrColumnShardTxProto::TEven
         AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)("error", "cannot_parse_TEvReadStart")("reason", "cannot_parse_schema");
         return false;
     }
-    Filter = TPKRangesFilter::BuildFromString(proto.GetRead().GetFilter(), Schema, false);
+    Filter = TPKRangesFilter::BuildFromString(proto.GetRead().GetFilter(), Schema);
     if (!Filter) {
         AFL_ERROR(NKikimrServices::TX_COLUMNSHARD)("error", "cannot_parse_TEvReadStart")("reason", "cannot_parse_filter");
         return false;
diff --git a/ydb/core/tx/columnshard/transactions/tx_controller.cpp b/ydb/core/tx/columnshard/transactions/tx_controller.cpp
index 1e36aedd39ef..c423e8915e3a 100644
--- a/ydb/core/tx/columnshard/transactions/tx_controller.cpp
+++ b/ydb/core/tx/columnshard/transactions/tx_controller.cpp
@@ -71,6 +71,7 @@ bool TTxController::Load(NTabletFlatExecutor::TTransactionContext& txc) {
             ++countNoDeadline;
         }
         txInfo.PlanStep = rowset.GetValueOrDefault<Schema::TxInfo::PlanStep>(0);
+        AFL_INFO(NKikimrServices::TX_COLUMNSHARD_TX)("event", "Load")("tx_id", txInfo.TxId)("plan_step", txInfo.PlanStep);
         txInfo.Source = rowset.GetValue<Schema::TxInfo::Source>();
         txInfo.Cookie = rowset.GetValue<Schema::TxInfo::Cookie>();
         txInfo.DeserializeSeqNoFromString(rowset.GetValue<Schema::TxInfo::SeqNo>());
@@ -97,6 +98,8 @@ std::shared_ptr<TTxController::ITransactionOperator> TTxController::UpdateTxSour
     op->ResetStatusOnUpdate();
     auto& txInfo = op->MutableTxInfo();
     txInfo.Source = tx.Source;
+    txInfo.MinStep = tx.MinStep;
+    txInfo.MaxStep = tx.MaxStep;
     txInfo.Cookie = tx.Cookie;
     txInfo.SeqNo = tx.SeqNo;
 
@@ -111,7 +114,7 @@ TTxController::TTxInfo TTxController::RegisterTx(const std::shared_ptr<TTxContro
     auto& txInfo = txOperator->GetTxInfo();
     AFL_VERIFY(txInfo.MaxStep == Max<ui64>());
     AFL_VERIFY(Operators.emplace(txInfo.TxId, txOperator).second);
-
+    AFL_INFO(NKikimrServices::TX_COLUMNSHARD_TX)("event", "RegisterTx")("tx_id", txInfo.TxId)("plan_step", txInfo.PlanStep);
     Schema::SaveTxInfo(db, txInfo, txBody);
     Counters.OnRegisterTx(txOperator->GetOpType());
     return txInfo;
@@ -126,7 +129,7 @@ TTxController::TTxInfo TTxController::RegisterTxWithDeadline(const std::shared_p
     txInfo.MaxStep = txInfo.MinStep + MaxCommitTxDelay.MilliSeconds();
 
     AFL_VERIFY(Operators.emplace(txOperator->GetTxId(), txOperator).second);
-
+    AFL_INFO(NKikimrServices::TX_COLUMNSHARD_TX)("event", "RegisterTxWithDeadline")("tx_id", txInfo.TxId)("plan_step", txInfo.PlanStep);
     Schema::SaveTxInfo(db, txInfo, txBody);
     DeadlineQueue.emplace(txInfo.MaxStep, txOperator->GetTxId());
     Counters.OnRegisterTx(txOperator->GetOpType());
@@ -295,6 +298,8 @@ TTxController::EPlanResult TTxController::PlanTx(const ui64 planStep, const ui64
             DeadlineQueue.erase(TPlanQueueItem(txInfo.MaxStep, txId));
         }
         return EPlanResult::Planned;
+    } else {
+        AFL_INFO(NKikimrServices::TX_COLUMNSHARD_TX)("event", "skip_plan_tx_plan_step_is_not_zero")("tx_id", txId)("plan_step", txInfo.PlanStep)("schemeshard_plan_step", planStep);
     }
     return EPlanResult::AlreadyPlanned;
 }
diff --git a/ydb/core/tx/columnshard/transactions/tx_controller.h b/ydb/core/tx/columnshard/transactions/tx_controller.h
index 664b32bde0b9..af7a497b47a9 100644
--- a/ydb/core/tx/columnshard/transactions/tx_controller.h
+++ b/ydb/core/tx/columnshard/transactions/tx_controller.h
@@ -50,7 +50,7 @@ struct TFullTxInfo: public TBasicTxInfo {
 
 public:
     static TFullTxInfo BuildFake(const NKikimrTxColumnShard::ETransactionKind kind) {
-        return TFullTxInfo(kind, 0, NActors::TActorId(), 0, {});
+        return TFullTxInfo(kind, 0, NActors::TActorId(), 0, 0, {});
     }
 
     bool operator==(const TFullTxInfo& item) const = default;
@@ -86,9 +86,10 @@ struct TFullTxInfo: public TBasicTxInfo {
         : TBasicTxInfo(txKind, txId) {
     }
 
-    TFullTxInfo(const NKikimrTxColumnShard::ETransactionKind& txKind, const ui64 txId, const TActorId& source, const ui64 cookie,
-        const std::optional<TMessageSeqNo>& seqNo)
+    TFullTxInfo(const NKikimrTxColumnShard::ETransactionKind& txKind, const ui64 txId, const TActorId& source, const ui64 minAllowedPlanStep, 
+        const ui64 cookie, const std::optional<TMessageSeqNo>& seqNo)
         : TBasicTxInfo(txKind, txId)
+        , MinStep(minAllowedPlanStep)
         , Source(source)
         , Cookie(cookie)
         , SeqNo(seqNo) {
@@ -414,7 +415,6 @@ class TTxController {
 
     THashMap<ui64, ITransactionOperator::TPtr> Operators;
 private:
-    ui64 GetAllowedStep() const;
     bool AbortTx(const TPlanQueueItem planQueueItem, NTabletFlatExecutor::TTransactionContext& txc);
 
     TTxInfo RegisterTx(const std::shared_ptr<TTxController::ITransactionOperator>& txOperator, const TString& txBody,
@@ -426,6 +426,8 @@ class TTxController {
 public:
     TTxController(TColumnShard& owner);
 
+    ui64 GetAllowedStep() const;
+
     ITransactionOperator::TPtr GetTxOperatorOptional(const ui64 txId) const {
         auto it = Operators.find(txId);
         if (it == Operators.end()) {
diff --git a/ydb/core/tx/columnshard/ut_rw/ut_backup.cpp b/ydb/core/tx/columnshard/ut_rw/ut_backup.cpp
index 8ca1b5a87245..f0a8aeda7a64 100644
--- a/ydb/core/tx/columnshard/ut_rw/ut_backup.cpp
+++ b/ydb/core/tx/columnshard/ut_rw/ut_backup.cpp
@@ -17,7 +17,7 @@ using namespace NTxUT;
 
 Y_UNIT_TEST_SUITE(Backup) {
 
-    bool ProposeTx(TTestBasicRuntime& runtime, TActorId& sender, NKikimrTxColumnShard::ETransactionKind txKind, const TString& txBody, const ui64 txId) {
+    [[nodiscard]] TPlanStep ProposeTx(TTestBasicRuntime& runtime, TActorId& sender, NKikimrTxColumnShard::ETransactionKind txKind, const TString& txBody, const ui64 txId) {
         auto event = std::make_unique<TEvColumnShard::TEvProposeTransaction>(
             txKind, sender, txId, txBody);
 
@@ -26,7 +26,8 @@ Y_UNIT_TEST_SUITE(Backup) {
         const auto& res = ev->Get()->Record;
         UNIT_ASSERT_EQUAL(res.GetTxId(), txId);
         UNIT_ASSERT_EQUAL(res.GetTxKind(), txKind);
-        return (res.GetStatus() == NKikimrTxColumnShard::PREPARED);
+        UNIT_ASSERT_EQUAL(res.GetStatus(),  NKikimrTxColumnShard::PREPARED);
+        return TPlanStep{res.GetMinStep()};
     }
 
     void PlanTx(TTestBasicRuntime& runtime, TActorId& sender, NKikimrTxColumnShard::ETransactionKind txKind, NOlap::TSnapshot snap, bool waitResult = true) {
@@ -67,10 +68,8 @@ Y_UNIT_TEST_SUITE(Backup) {
                                                                     NArrow::NTest::TTestColumn("field", TTypeInfo(NTypeIds::Utf8) )
                                                                 };
         auto csControllerGuard = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<NOlap::TWaitCompactionController>();
-        PrepareTablet(runtime, tableId, schema, 2);
+        auto planStep = PrepareTablet(runtime, tableId, schema, 2);
         ui64 txId = 111;
-        ui64 planStep = 1000000000; // greater then delays
-
         ui64 writeId = 1;
 
         TActorId sender = runtime.AllocateEdgeActor();
@@ -78,8 +77,8 @@ Y_UNIT_TEST_SUITE(Backup) {
         {
             std::vector<ui64> writeIds;
             UNIT_ASSERT(WriteData(runtime, sender, writeId++, tableId, MakeTestBlob({0, 100}, schema), schema, true, &writeIds));
-            ProposeCommit(runtime, sender, ++txId, writeIds);
-            PlanCommit(runtime, sender, ++planStep, txId);
+            planStep = ProposeCommit(runtime, sender, ++txId, writeIds);
+            PlanCommit(runtime, sender, planStep, txId);
         }
 
         TestWaitCondition(runtime, "insert compacted",
@@ -87,13 +86,13 @@ Y_UNIT_TEST_SUITE(Backup) {
             ++writeId;
             std::vector<ui64> writeIds;
             WriteData(runtime, sender, writeId, tableId, MakeTestBlob({writeId * 100, (writeId + 1) * 100}, schema), schema, true, &writeIds);
-            ProposeCommit(runtime, sender, ++txId, writeIds);
-            PlanCommit(runtime, sender, ++planStep, txId);
+            planStep = ProposeCommit(runtime, sender, ++txId, writeIds);
+            PlanCommit(runtime, sender, planStep, txId);
             return true;
         }, TDuration::Seconds(1000));
 
         NKikimrTxColumnShard::TBackupTxBody txBody;
-        NOlap::TSnapshot backupSnapshot(planStep, txId);
+        NOlap::TSnapshot backupSnapshot(planStep.Val(), txId);
         txBody.MutableBackupTask()->SetTableName("abcde");
         txBody.MutableBackupTask()->SetTableId(tableId);
         txBody.MutableBackupTask()->SetSnapshotStep(backupSnapshot.GetPlanStep());
@@ -101,9 +100,9 @@ Y_UNIT_TEST_SUITE(Backup) {
         txBody.MutableBackupTask()->MutableS3Settings()->SetEndpoint("fake.fake");
         txBody.MutableBackupTask()->MutableS3Settings()->SetSecretKey("fakeSecret");
         AFL_VERIFY(csControllerGuard->GetFinishedExportsCount() == 0);
-        UNIT_ASSERT(ProposeTx(runtime, sender, NKikimrTxColumnShard::TX_KIND_BACKUP, txBody.SerializeAsString(), ++txId));
+        planStep = ProposeTx(runtime, sender, NKikimrTxColumnShard::TX_KIND_BACKUP, txBody.SerializeAsString(), ++txId);
         AFL_VERIFY(csControllerGuard->GetFinishedExportsCount() == 1);
-        PlanTx(runtime, sender, NKikimrTxColumnShard::TX_KIND_BACKUP, NOlap::TSnapshot(++planStep, txId), false);
+        PlanTx(runtime, sender, NKikimrTxColumnShard::TX_KIND_BACKUP, NOlap::TSnapshot(planStep, txId), false);
         TestWaitCondition(runtime, "export",
             []() {return Singleton<NKikimr::NWrappers::NExternalStorage::TFakeExternalStorage>()->GetSize(); });
     }
diff --git a/ydb/core/tx/columnshard/ut_rw/ut_columnshard_read_write.cpp b/ydb/core/tx/columnshard/ut_rw/ut_columnshard_read_write.cpp
index f0441b79b15f..9d3ee177a7b0 100644
--- a/ydb/core/tx/columnshard/ut_rw/ut_columnshard_read_write.cpp
+++ b/ydb/core/tx/columnshard/ut_rw/ut_columnshard_read_write.cpp
@@ -10,6 +10,7 @@
 #include <ydb/core/tx/columnshard/hooks/testing/controller.h>
 #include <ydb/core/tx/columnshard/operations/write_data.h>
 #include <ydb/core/tx/columnshard/test_helper/columnshard_ut_common.h>
+#include <ydb/core/tx/columnshard/test_helper/test_combinator.h>
 #include <ydb/core/tx/columnshard/test_helper/controllers.h>
 #include <ydb/core/tx/columnshard/test_helper/shard_reader.h>
 #include <ydb/core/tx/columnshard/test_helper/shard_writer.h>
@@ -354,7 +355,7 @@ void TestWrite(const TestTableDescription& table) {
     ui64 writeId = 0;
     ui64 tableId = 1;
 
-    SetupSchema(runtime, sender, tableId, table);
+    Y_UNUSED(SetupSchema(runtime, sender, tableId, table));
 
     const auto& ydbSchema = table.Schema;
 
@@ -434,11 +435,12 @@ void TestWrite(const TestTableDescription& table) {
     UNIT_ASSERT(ok);
 }
 
-void TestWriteOverload(const TestTableDescription& table) {
+void TestWriteOverload(const TestTableDescription& table, bool WritePortionsOnInsert) {
     TTestBasicRuntime runtime;
     TTester::Setup(runtime);
+    runtime.GetAppData().FeatureFlags.SetEnableWritePortionsOnInsert(WritePortionsOnInsert);
     auto csDefaultControllerGuard = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<TDefaultTestsController>();
-
+    csDefaultControllerGuard->SetOverrideBlobSplitSettings(std::nullopt);
     TActorId sender = runtime.AllocateEdgeActor();
     CreateTestBootstrapper(runtime, CreateTestTabletInfo(TTestTxConfig::TxTablet0, TTabletTypes::ColumnShard), &CreateColumnShard);
 
@@ -450,7 +452,7 @@ void TestWriteOverload(const TestTableDescription& table) {
     ui64 writeId = 0;
     ui64 tableId = 1;
 
-    SetupSchema(runtime, sender, tableId, table);
+    Y_UNUSED(SetupSchema(runtime, sender, tableId, table));
 
     TString testBlob = MakeTestBlob({ 0, 100 * 1000 }, table.Schema);
     UNIT_ASSERT(testBlob.size() > NOlap::TCompactionLimits::MAX_BLOB_SIZE / 2);
@@ -462,26 +464,31 @@ void TestWriteOverload(const TestTableDescription& table) {
     TDeque<TAutoPtr<IEventHandle>> capturedWrites;
 
     auto captureEvents = [&](TTestActorRuntimeBase&, TAutoPtr<IEventHandle>& ev) {
-        if (auto* msg = TryGetPrivateEvent<NColumnShard::TEvPrivate::TEvWriteBlobsResult>(ev)) {
-            Cerr << "CATCH TEvWrite, status " << msg->GetPutResult().GetPutStatus() << Endl;
-            if (toCatch && msg->GetPutResult().GetPutStatus() != NKikimrProto::UNKNOWN) {
-                capturedWrites.push_back(ev.Release());
+        if (toCatch) {
+            TAutoPtr<IEventHandle> eventToCapture;
+            if (WritePortionsOnInsert) {
+                if (auto* msg = TryGetPrivateEvent<NColumnShard::NPrivateEvents::NWrite::TEvWritePortionResult>(ev)) {
+                    Cerr << "CATCH TEvWritePortionResult, status " << msg->GetWriteStatus() << Endl;
+                    if (msg->GetWriteStatus() != NKikimrProto::EReplyStatus::UNKNOWN) {
+                        eventToCapture = ev.Release();
+                    }
+                }
+             } else {
+                if (auto* msg = TryGetPrivateEvent<NColumnShard::TEvPrivate::TEvWriteBlobsResult>(ev)) {
+                    Cerr << "CATCH TEvWrite, status " << msg->GetPutResult().GetPutStatus() << Endl;
+                    if (msg->GetPutResult().GetPutStatus() != NKikimrProto::UNKNOWN) {
+                        eventToCapture = ev.Release();
+                    }
+                }
+            }
+            if (eventToCapture) {
                 --toCatch;
+                capturedWrites.push_back(std::move(eventToCapture));
                 return true;
-            } else {
-                return false;
             }
         }
         return false;
     };
-
-    auto resendOneCaptured = [&]() {
-        UNIT_ASSERT(capturedWrites.size());
-        Cerr << "RESEND TEvWrite" << Endl;
-        runtime.Send(capturedWrites.front().Release());
-        capturedWrites.pop_front();
-    };
-
     runtime.SetEventFilter(captureEvents);
 
     const ui32 toSend = toCatch + 1;
@@ -492,7 +499,8 @@ void TestWriteOverload(const TestTableDescription& table) {
     UNIT_ASSERT_VALUES_EQUAL(WaitWriteResult(runtime, TTestTxConfig::TxTablet0), (ui32)NKikimrDataEvents::TEvWriteResult::STATUS_OVERLOADED);
 
     while (capturedWrites.size()) {
-        resendOneCaptured();
+        runtime.Send(capturedWrites.front().Release());
+        capturedWrites.pop_front();
         UNIT_ASSERT_VALUES_EQUAL(WaitWriteResult(runtime, TTestTxConfig::TxTablet0), (ui32)NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED);
     }
 
@@ -518,7 +526,7 @@ void TestWriteReadDup(const TestTableDescription& table = {}) {
     ui64 tableId = 1;
 
     auto ydbSchema = table.Schema;
-    SetupSchema(runtime, sender, tableId);
+    auto planStep = SetupSchema(runtime, sender, tableId);
 
     constexpr ui32 numRows = 10;
     std::pair<ui64, ui64> portion = { 10, 10 + numRows };
@@ -526,21 +534,20 @@ void TestWriteReadDup(const TestTableDescription& table = {}) {
     TAutoPtr<IEventHandle> handle;
 
     ui64 txId = 0;
-    ui64 initPlanStep = 100;
-    for (ui64 planStep = initPlanStep; planStep < initPlanStep + 50; ++planStep) {
+    for (auto count = 0; count != 50; ++count) {
         TSet<ui64> txIds;
         for (ui32 i = 0; i <= 5; ++i) {
             std::vector<ui64> writeIds;
             ++txId;
             UNIT_ASSERT(
                 WriteData(runtime, sender, ++writeId, tableId, testData, ydbSchema, true, &writeIds, NEvWrite::EModificationType::Upsert, txId));
-            ProposeCommit(runtime, sender, txId, writeIds, txId);
+            planStep = ProposeCommit(runtime, sender, txId, writeIds, txId);
             txIds.insert(txId);
         }
         PlanCommit(runtime, sender, planStep, txIds);
 
         // read
-        if (planStep != initPlanStep) {
+        if (count != 0) {
             TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep - 1, Max<ui64>()));
             reader.SetReplyColumnIds(table.GetColumnIds({ "timestamp" }));
             auto rb = reader.ReadAll();
@@ -579,13 +586,14 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString
     };
 
     auto proposeCommit = [&](TTestBasicRuntime& runtime, TActorId& sender, ui64 txId, const std::vector<ui64>& writeIds) {
-        ProposeCommit(runtime, sender, txId, writeIds);
+        const auto result = ProposeCommit(runtime, sender, txId, writeIds);
         if (reboots) {
             RebootTablet(runtime, TTestTxConfig::TxTablet0, sender);
         }
+        return result;
     };
 
-    auto planCommit = [&](TTestBasicRuntime& runtime, TActorId& sender, ui64 planStep, ui64 txId) {
+    auto planCommit = [&](TTestBasicRuntime& runtime, TActorId& sender, TPlanStep planStep, ui64 txId) {
         PlanCommit(runtime, sender, planStep, txId);
         if (reboots) {
             RebootTablet(runtime, TTestTxConfig::TxTablet0, sender);
@@ -597,7 +605,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString
     ui64 writeId = 0;
     ui64 tableId = 1;
 
-    SetupSchema(runtime, sender, tableId, table, codec);
+    auto planStep = SetupSchema(runtime, sender, tableId, table, codec);
 
     const std::vector<NArrow::NTest::TTestColumn>& ydbSchema = table.Schema;
     const std::vector<NArrow::NTest::TTestColumn>& testYdbPk = table.Pk;
@@ -627,10 +635,10 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString
     }
     // commit 1: ins:0, cmt:1, idx:0
 
-    ui64 planStep = 21;
     ui64 txId = 100;
-    proposeCommit(runtime, sender, txId, intWriteIds);
+    planStep = proposeCommit(runtime, sender, txId, intWriteIds);
     planCommit(runtime, sender, planStep, txId);
+    const auto firstWritePlanStep = planStep;
 
     // read 2 (committed, old snapshot)
     {
@@ -700,9 +708,8 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString
 
     // commit 2 (init indexation): ins:0, cmt:0, idx:1
 
-    planStep = 22;
     ++txId;
-    proposeCommit(runtime, sender, txId, intWriteIds);
+    planStep = proposeCommit(runtime, sender, txId, intWriteIds);
     planCommit(runtime, sender, planStep, txId);
 
     // write 3: ins:1, cmt:0, idx:1
@@ -721,10 +728,10 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString
         UNIT_ASSERT(reader.IsCorrectlyFinished());
     }
 
-    // read 7, planstep 21 (part of index)
+    // read 7, first write snapshot
     {
         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)("TEST_STEP", 7);
-        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(21, txId));
+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(firstWritePlanStep, txId));
         reader.SetReplyColumnIds(TTestSchema::ExtractIds(ydbSchema));
         auto rb = reader.ReadAll();
         UNIT_ASSERT(rb);
@@ -738,10 +745,10 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString
         UNIT_ASSERT(DataNotHas({ rb }, portion[2]));
     }
 
-    // read 8, planstep 22 (full index)
+    // read 8 (full index)
     {
         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)("TEST_STEP", 8);
-        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(22, txId));
+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));
         reader.SetReplyColumnIds(TTestSchema::ExtractIds(ydbSchema));
         auto rb = reader.ReadAll();
         UNIT_ASSERT(rb);
@@ -757,9 +764,8 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString
 
     // commit 3: ins:0, cmt:1, idx:1
 
-    planStep = 23;
     ++txId;
-    proposeCommit(runtime, sender, txId, intWriteIds);
+    planStep = proposeCommit(runtime, sender, txId, intWriteIds);
     planCommit(runtime, sender, planStep, txId);
 
     // write 4: ins:1, cmt:1, idx:1
@@ -771,7 +777,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString
     // read 9 (committed, indexed)
     {
         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)("TEST_STEP", 9);
-        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(23, txId));
+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));
         reader.SetReplyColumnIds(TTestSchema::ExtractIds(ydbSchema));
         auto rb = reader.ReadAll();
         UNIT_ASSERT(rb);
@@ -788,15 +794,14 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString
 
     // commit 4: ins:0, cmt:2, idx:1 (with duplicates in PK)
 
-    planStep = 24;
     ++txId;
-    proposeCommit(runtime, sender, txId, intWriteIds);
+    planStep = proposeCommit(runtime, sender, txId, intWriteIds);
     planCommit(runtime, sender, planStep, txId);
 
     // read 10
     {
         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)("TEST_STEP", 10);
-        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(24, txId));
+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));
         reader.SetReplyColumnIds(TTestSchema::ExtractIds(ydbSchema));
         auto rb = reader.ReadAll();
         UNIT_ASSERT(rb);
@@ -841,7 +846,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString
     // read 11 (range predicate: closed interval)
     {
         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)("TEST_STEP", 11);
-        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(24, txId));
+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));
         reader.SetReplyColumnIds(TTestSchema::ExtractIds(ydbSchema));
         reader.AddRange(MakeTestRange({ 10, 42 }, true, true, testYdbPk));
         auto rb = reader.ReadAll();
@@ -858,7 +863,7 @@ void TestWriteRead(bool reboots, const TestTableDescription& table = {}, TString
     // read 12 (range predicate: open interval)
     {
         NActors::TLogContextGuard guard = NActors::TLogContextBuilder::Build(NKikimrServices::TX_COLUMNSHARD)("TEST_STEP", 11);
-        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(24, txId));
+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));
         reader.SetReplyColumnIds(TTestSchema::ExtractIds(ydbSchema));
         reader.AddRange(MakeTestRange({ 10, 42 }, false, false, testYdbPk));
         auto rb = reader.ReadAll();
@@ -896,13 +901,14 @@ void TestCompactionInGranuleImpl(bool reboots, const TestTableDescription& table
     };
 
     auto proposeCommit = [&](TTestBasicRuntime& runtime, TActorId& sender, ui64 txId, const std::vector<ui64>& writeIds) {
-        ProposeCommit(runtime, sender, txId, writeIds);
+        auto result = ProposeCommit(runtime, sender, txId, writeIds);
         if (reboots) {
             RebootTablet(runtime, TTestTxConfig::TxTablet0, sender);
         }
+        return result;
     };
 
-    auto planCommit = [&](TTestBasicRuntime& runtime, TActorId& sender, ui64 planStep, ui64 txId) {
+    auto planCommit = [&](TTestBasicRuntime& runtime, TActorId& sender, TPlanStep planStep, ui64 txId) {
         PlanCommit(runtime, sender, planStep, txId);
         if (reboots) {
             RebootTablet(runtime, TTestTxConfig::TxTablet0, sender);
@@ -913,10 +919,9 @@ void TestCompactionInGranuleImpl(bool reboots, const TestTableDescription& table
 
     ui64 writeId = 0;
     ui64 tableId = 1;
-    ui64 planStep = 100;
     ui64 txId = 100;
 
-    SetupSchema(runtime, sender, tableId, table);
+    auto planStep = SetupSchema(runtime, sender, tableId, table);
     TAutoPtr<IEventHandle> handle;
     const auto& ydbSchema = table.Schema;
     const auto& ydbPk = table.Pk;
@@ -935,7 +940,7 @@ void TestCompactionInGranuleImpl(bool reboots, const TestTableDescription& table
 
     // inserts triggered by count
     ui32 pos = triggerPortionSize;
-    for (ui32 i = 0; i < 1; ++i, ++planStep, ++txId) {
+    for (ui32 i = 0; i < 1; ++i, ++txId) {
         std::vector<ui64> ids;
         ids.reserve(numWrites);
         for (ui32 w = 0; w < numWrites; ++w, ++writeId, pos += portionSize) {
@@ -949,7 +954,7 @@ void TestCompactionInGranuleImpl(bool reboots, const TestTableDescription& table
             RebootTablet(runtime, TTestTxConfig::TxTablet0, sender);
         }
 
-        proposeCommit(runtime, sender, txId, ids);
+        planStep = proposeCommit(runtime, sender, txId, ids);
         planCommit(runtime, sender, planStep, txId);
     }
     std::pair<ui64, ui64> smallWrites = { triggerPortionSize, pos };
@@ -958,16 +963,15 @@ void TestCompactionInGranuleImpl(bool reboots, const TestTableDescription& table
     NOlap::TCompactionLimits engineLimits;
     ui32 numTxs = engineLimits.GranuleSizeForOverloadPrevent / triggerData.size() + 1;
 
-    for (ui32 i = 0; i < numTxs; ++i, ++writeId, ++planStep, ++txId) {
+    for (ui32 i = 0; i < numTxs; ++i, ++writeId, ++txId) {
         std::vector<ui64> writeIds;
         UNIT_ASSERT(write(runtime, sender, writeId, tableId, triggerData, ydbSchema, writeIds));
 
-        proposeCommit(runtime, sender, txId, writeIds);
+        planStep = proposeCommit(runtime, sender, txId, writeIds);
         planCommit(runtime, sender, planStep, txId);
     }
 
     // TODO: Move tablet's time to the future with mediator timecast instead
-    --planStep;
     --txId;
 
     for (ui32 i = 0; i < 2; ++i) {
@@ -1169,17 +1173,15 @@ void TestReadWithProgram(const TestTableDescription& table = {}) {
 
     ui64 writeId = 0;
     ui64 tableId = 1;
-    ui64 planStep = 100;
     ui64 txId = 100;
 
-    SetupSchema(runtime, sender, tableId, table);
+    auto planStep = SetupSchema(runtime, sender, tableId, table);
 
     {   // write some data
         std::vector<ui64> writeIds;
         bool ok = WriteData(runtime, sender, writeId, tableId, MakeTestBlob({ 0, 100 }, table.Schema), table.Schema, true, &writeIds);
         UNIT_ASSERT(ok);
-
-        ProposeCommit(runtime, sender, txId, writeIds);
+        planStep = ProposeCommit(runtime, sender, txId, writeIds);
         PlanCommit(runtime, sender, planStep, txId);
     }
 
@@ -1253,17 +1255,16 @@ void TestReadWithProgramLike(const TestTableDescription& table = {}) {
 
     ui64 writeId = 0;
     ui64 tableId = 1;
-    ui64 planStep = 100;
     ui64 txId = 100;
 
-    SetupSchema(runtime, sender, tableId, table);
+    auto planStep = SetupSchema(runtime, sender, tableId, table);
 
     {   // write some data
         std::vector<ui64> writeIds;
         bool ok = WriteData(runtime, sender, writeId, tableId, MakeTestBlob({ 0, 100 }, table.Schema), table.Schema, true, &writeIds);
         UNIT_ASSERT(ok);
 
-        ProposeCommit(runtime, sender, txId, writeIds);
+        planStep = ProposeCommit(runtime, sender, txId, writeIds);
         PlanCommit(runtime, sender, planStep, txId);
     }
 
@@ -1317,17 +1318,16 @@ void TestSomePrograms(const TestTableDescription& table) {
 
     ui64 writeId = 0;
     ui64 tableId = 1;
-    ui64 planStep = 100;
     ui64 txId = 100;
 
-    SetupSchema(runtime, sender, tableId, table);
+    auto planStep = SetupSchema(runtime, sender, tableId, table);
 
     {   // write some data
         std::vector<ui64> writeIds;
         bool ok = WriteData(runtime, sender, writeId, tableId, MakeTestBlob({ 0, 100 }, table.Schema), table.Schema, true, &writeIds);
         UNIT_ASSERT(ok);
 
-        ProposeCommit(runtime, sender, txId, writeIds);
+        planStep = ProposeCommit(runtime, sender, txId, writeIds);
         PlanCommit(runtime, sender, planStep, txId);
     }
 
@@ -1354,6 +1354,83 @@ void TestSomePrograms(const TestTableDescription& table) {
     }
 }
 
+void TestReadWithProgramNoProjection(const TestTableDescription& table = {}) {
+    TTestBasicRuntime runtime;
+    TTester::Setup(runtime);
+    auto csDefaultControllerGuard = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<TDefaultTestsController>();
+
+    TActorId sender = runtime.AllocateEdgeActor();
+    CreateTestBootstrapper(runtime, CreateTestTabletInfo(TTestTxConfig::TxTablet0, TTabletTypes::ColumnShard), &CreateColumnShard);
+
+    TDispatchOptions options;
+    options.FinalEvents.push_back(TDispatchOptions::TFinalEventCondition(TEvTablet::EvBoot));
+    runtime.DispatchEvents(options);
+
+    ui64 writeId = 0;
+    ui64 tableId = 1;
+    ui64 txId = 100;
+
+    auto planStep = SetupSchema(runtime, sender, tableId, table);
+
+    {   // write some data
+        std::vector<ui64> writeIds;
+        bool ok = WriteData(runtime, sender, writeId, tableId, MakeTestBlob({ 0, 100 }, table.Schema), table.Schema, true, &writeIds);
+        UNIT_ASSERT(ok);
+        planStep = ProposeCommit(runtime, sender, txId, writeIds);
+        PlanCommit(runtime, sender, planStep, txId);
+    }
+
+    std::vector<TString> programs;
+    programs.push_back("XXXYYYZZZ");
+    {
+        NKikimrSSA::TProgram ssa = MakeSelect(TAssignment::FUNC_CMP_EQUAL);
+        TString serialized;
+        UNIT_ASSERT(ssa.SerializeToString(&serialized));
+
+        NKikimrSSA::TOlapProgram program;
+        program.SetProgram(serialized);
+
+        programs.push_back("");
+        UNIT_ASSERT(program.SerializeToString(&programs.back()));
+
+        //remove projections
+        auto* commands = ssa.MutableCommand();
+        for(int i = commands->size() - 1; i >= 0; --i) {
+            if ((*commands)[i].HasProjection()) {
+                commands->DeleteSubrange(i, 1);
+            }
+        }
+
+        UNIT_ASSERT(ssa.SerializeToString(&serialized));
+        program.SetProgram(serialized);
+        programs.push_back("");
+        UNIT_ASSERT(program.SerializeToString(&programs.back()));
+    }
+
+    ui32 i = 0;
+    for (auto& programText : programs) {
+        TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, txId));
+        reader.SetProgram(programText);
+        auto rb = reader.ReadAll();
+        switch(i) {
+            case 0:
+            UNIT_ASSERT(reader.IsError());
+            break;
+
+            case 1:
+            UNIT_ASSERT(!reader.IsError());
+            break;
+
+            case 2:
+            UNIT_ASSERT(reader.IsError());
+            UNIT_ASSERT(reader.GetErrors().back().Getmessage().Contains("program has no projections"));
+            break;
+        }
+        UNIT_ASSERT(reader.IsFinished());
+        ++i;
+    }
+}
+
 struct TReadAggregateResult {
     ui32 NumRows = 1;
 
@@ -1379,19 +1456,18 @@ void TestReadAggregate(const std::vector<NArrow::NTest::TTestColumn>& ydbSchema,
 
     ui64 writeId = 0;
     ui64 tableId = 1;
-    ui64 planStep = 100;
     ui64 txId = 100;
 
     auto pk = NArrow::NTest::TTestColumn::CropSchema(ydbSchema, 4);
     TestTableDescription table{ .Schema = ydbSchema, .Pk = pk };
-    SetupSchema(runtime, sender, tableId, table);
+    auto planStep = SetupSchema(runtime, sender, tableId, table);
 
     {   // write some data
         std::vector<ui64> writeIds;
         bool ok = WriteData(runtime, sender, writeId, tableId, testDataBlob, table.Schema, true, &writeIds);
         UNIT_ASSERT(ok);
 
-        ProposeCommit(runtime, sender, txId, writeIds);
+        planStep = ProposeCommit(runtime, sender, txId, writeIds);
         PlanCommit(runtime, sender, planStep, txId);
     }
 
@@ -1496,7 +1572,8 @@ Y_UNIT_TEST_SUITE(EvWrite) {
         const std::vector<NArrow::NTest::TTestColumn> schema = { NArrow::NTest::TTestColumn("key", TTypeInfo(NTypeIds::Uint64)),
             NArrow::NTest::TTestColumn("field", TTypeInfo(NTypeIds::Utf8)) };
         const std::vector<ui32> columnsIds = { 1, 2 };
-        PrepareTablet(runtime, tableId, schema);
+        auto planStep = PrepareTablet(runtime, tableId, schema);
+        const auto schemaPlanStep = planStep;
         const ui64 txId = 111;
 
         NConstruction::IArrayBuilder::TPtr keyColumn =
@@ -1508,21 +1585,19 @@ Y_UNIT_TEST_SUITE(EvWrite) {
 
         NTxUT::TShardWriter writer(runtime, TTestTxConfig::TxTablet0, tableId, 222);
         AFL_VERIFY(writer.Write(batch, {1, 2}, txId) == NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED);
-        AFL_VERIFY(writer.StartCommit(txId) == NKikimrDataEvents::TEvWriteResult::STATUS_PREPARED);
+        planStep = writer.StartCommit(txId);
 
         {
             NTxUT::TShardWriter writer(runtime, TTestTxConfig::TxTablet0, tableId, 444);
-            AFL_VERIFY(writer.StartCommit(444) == NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST);
+            writer.StartCommitFail(444);
         }
-
         {
-            auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(10, txId), schema);
+            auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(schemaPlanStep, txId), schema);
             UNIT_ASSERT_VALUES_EQUAL(readResult->num_rows(), 0);
-
-            PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(11, txId));
+            PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(planStep, txId));
         }
 
-        auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot::MaxForPlanStep(11), schema);
+        auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot::MaxForPlanStep(planStep), schema);
         UNIT_ASSERT_VALUES_EQUAL(readResult->num_rows(), 2048);
     }
 
@@ -1537,7 +1612,7 @@ Y_UNIT_TEST_SUITE(EvWrite) {
         const std::vector<NArrow::NTest::TTestColumn> schema = { NArrow::NTest::TTestColumn("key", TTypeInfo(NTypeIds::Uint64)),
             NArrow::NTest::TTestColumn("field", TTypeInfo(NTypeIds::Utf8)) };
         const std::vector<ui32> columnsIds = { 1, 2 };
-        PrepareTablet(runtime, tableId, schema);
+        auto planStep = PrepareTablet(runtime, tableId, schema);
         const ui64 txId = 111;
 
         NConstruction::IArrayBuilder::TPtr keyColumn =
@@ -1550,9 +1625,9 @@ Y_UNIT_TEST_SUITE(EvWrite) {
         AFL_VERIFY(writer.Write(batch, {1, 2}, txId) == NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED);
         AFL_VERIFY(writer.Abort(txId) == NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED);
 
-        PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(10, txId + 1), false);
+        PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(planStep, txId + 1), false);
 
-        auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot::MaxForPlanStep(10), schema);
+        auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot::MaxForPlanStep(planStep), schema);
         UNIT_ASSERT_VALUES_EQUAL(readResult->num_rows(), 0);
     }
 
@@ -1566,7 +1641,7 @@ Y_UNIT_TEST_SUITE(EvWrite) {
         const ui64 tableId = 1;
         const std::vector<NArrow::NTest::TTestColumn> schema = { NArrow::NTest::TTestColumn("key", TTypeInfo(NTypeIds::Uint64)),
             NArrow::NTest::TTestColumn("field", TTypeInfo(NTypeIds::Utf8)) };
-        PrepareTablet(runtime, tableId, schema);
+        auto planStep = PrepareTablet(runtime, tableId, schema);
         const ui64 txId = 111;
 
         NConstruction::IArrayBuilder::TPtr keyColumn =
@@ -1580,11 +1655,11 @@ Y_UNIT_TEST_SUITE(EvWrite) {
 
         NTxUT::TShardWriter writer(runtime, TTestTxConfig::TxTablet0, tableId, 222);
         AFL_VERIFY(writer.Write(batch, {1, 2}, txId) == NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED);
-        AFL_VERIFY(writer.StartCommit(txId) == NKikimrDataEvents::TEvWriteResult::STATUS_PREPARED);
+        planStep = writer.StartCommit(txId);
 
-        PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(11, txId));
+        PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(planStep, txId));
 
-        auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot::MaxForPlanStep(11), schema);
+        auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot::MaxForPlanStep(planStep), schema);
         UNIT_ASSERT_VALUES_EQUAL(readResult->num_rows(), 2048);
     }
 
@@ -1599,7 +1674,7 @@ Y_UNIT_TEST_SUITE(EvWrite) {
         const std::vector<NArrow::NTest::TTestColumn> schema = { NArrow::NTest::TTestColumn("key", TTypeInfo(NTypeIds::Uint64)),
             NArrow::NTest::TTestColumn("field", TTypeInfo(NTypeIds::Utf8)) };
         const std::vector<ui32> columnIds = { 1, 2 };
-        PrepareTablet(runtime, tableId, schema);
+        auto planStep = PrepareTablet(runtime, tableId, schema);
         const ui64 txId = 111;
 
         NTxUT::TShardWriter writer(runtime, TTestTxConfig::TxTablet0, tableId, 222);
@@ -1612,7 +1687,7 @@ Y_UNIT_TEST_SUITE(EvWrite) {
             auto batch = NConstruction::TRecordBatchConstructor({ keyColumn, column }).BuildBatch(2048);
             AFL_VERIFY(writer.Write(batch, columnIds, txId) == NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED);
             {
-                auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(10, txId), schema);
+                auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(planStep, txId), schema);
                 UNIT_ASSERT_VALUES_EQUAL(readResult->num_rows(), 0);
             }
         }
@@ -1626,16 +1701,16 @@ Y_UNIT_TEST_SUITE(EvWrite) {
             AFL_VERIFY(writer.Write(batch, columnIds, txId) == NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED);
 
             {
-                auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(10, txId), schema);
+                auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(planStep, txId), schema);
                 UNIT_ASSERT_VALUES_EQUAL(readResult->num_rows(), 0);
             }
         }
         {
-            AFL_VERIFY(writer.StartCommit(txId) == NKikimrDataEvents::TEvWriteResult::STATUS_PREPARED);
-            PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(11, txId));
+            planStep = writer.StartCommit(txId);
+            PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(planStep, txId));
         }
 
-        auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(11, txId), schema);
+        auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(planStep, txId), schema);
         UNIT_ASSERT_VALUES_EQUAL(readResult->num_rows(), 2 * 2048);
     }
 }
@@ -1665,15 +1740,10 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
         TestWrite(table);
     }
 
-    Y_UNIT_TEST(WriteOverload) {
+    Y_UNIT_TEST_QUATRO(WriteOverload, InStore, WithWritePortionsOnInsert) {
         TestTableDescription table;
-        TestWriteOverload(table);
-    }
-
-    Y_UNIT_TEST(WriteStandaloneOverload) {
-        TestTableDescription table;
-        table.InStore = false;
-        TestWriteOverload(table);
+        table.InStore = InStore;
+        TestWriteOverload(table, WithWritePortionsOnInsert);
     }
 
     Y_UNIT_TEST(WriteReadDuplicate) {
@@ -1699,7 +1769,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
         ui64 tableId = 1;
 
         auto ydbSchema = table.Schema;
-        SetupSchema(runtime, sender, tableId);
+        auto planStep = SetupSchema(runtime, sender, tableId);
 
         constexpr ui32 numRows = 10;
         std::pair<ui64, ui64> portion = { 10, 10 + numRows };
@@ -1707,13 +1777,12 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
         TAutoPtr<IEventHandle> handle;
 
         ui64 txId = 0;
-        ui64 planStep = 100;
         {
             TSet<ui64> txIds;
             std::vector<ui64> writeIds;
             UNIT_ASSERT(
                 WriteData(runtime, sender, ++writeId, tableId, testData, ydbSchema, true, &writeIds, NEvWrite::EModificationType::Update));
-            ProposeCommit(runtime, sender, ++txId, writeIds);
+            planStep = ProposeCommit(runtime, sender, ++txId, writeIds);
             txIds.insert(txId);
             PlanCommit(runtime, sender, planStep, txIds);
 
@@ -1722,14 +1791,13 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
             auto rb = reader.ReadAll();
             UNIT_ASSERT(reader.IsCorrectlyFinished());
             UNIT_ASSERT(!rb || rb->num_rows() == 0);
-            ++planStep;
         }
         {
             TSet<ui64> txIds;
             std::vector<ui64> writeIds;
             UNIT_ASSERT(
                 WriteData(runtime, sender, ++writeId, tableId, testData, ydbSchema, true, &writeIds, NEvWrite::EModificationType::Insert));
-            ProposeCommit(runtime, sender, ++txId, writeIds);
+            planStep = ProposeCommit(runtime, sender, ++txId, writeIds);
             txIds.insert(txId);
             PlanCommit(runtime, sender, planStep, txIds);
 
@@ -1739,14 +1807,13 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
             UNIT_ASSERT(reader.IsCorrectlyFinished());
             UNIT_ASSERT(CheckOrdered(rb));
             UNIT_ASSERT(DataHas({ rb }, portion, true));
-            ++planStep;
         }
         {
             TSet<ui64> txIds;
             std::vector<ui64> writeIds;
             UNIT_ASSERT(
                 WriteData(runtime, sender, ++writeId, tableId, testData, ydbSchema, true, &writeIds, NEvWrite::EModificationType::Upsert));
-            ProposeCommit(runtime, sender, ++txId, writeIds);
+            planStep = ProposeCommit(runtime, sender, ++txId, writeIds);
             txIds.insert(txId);
             PlanCommit(runtime, sender, planStep, txIds);
 
@@ -1756,14 +1823,13 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
             UNIT_ASSERT(reader.IsCorrectlyFinished());
             UNIT_ASSERT(CheckOrdered(rb));
             UNIT_ASSERT(DataHas({ rb }, portion, true));
-            ++planStep;
         }
         {
             TSet<ui64> txIds;
             std::vector<ui64> writeIds;
             UNIT_ASSERT(
                 WriteData(runtime, sender, ++writeId, tableId, testData, ydbSchema, true, &writeIds, NEvWrite::EModificationType::Update));
-            ProposeCommit(runtime, sender, ++txId, writeIds);
+            planStep = ProposeCommit(runtime, sender, ++txId, writeIds);
             txIds.insert(txId);
             PlanCommit(runtime, sender, planStep, txIds);
 
@@ -1773,7 +1839,6 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
             UNIT_ASSERT(reader.IsCorrectlyFinished());
             UNIT_ASSERT(CheckOrdered(rb));
             UNIT_ASSERT(DataHas({ rb }, portion, true));
-            ++planStep;
         }
         {
             TSet<ui64> txIds;
@@ -1786,7 +1851,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
             std::vector<ui64> writeIds;
             UNIT_ASSERT(
                 WriteData(runtime, sender, ++writeId, tableId, testData, ydbSchema, true, &writeIds, NEvWrite::EModificationType::Delete));
-            ProposeCommit(runtime, sender, ++txId, writeIds);
+            auto planStep = ProposeCommit(runtime, sender, ++txId, writeIds);
             txIds.insert(txId);
             PlanCommit(runtime, sender, planStep, txIds);
 
@@ -1795,7 +1860,6 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
             auto rb = reader.ReadAll();
             UNIT_ASSERT(reader.IsCorrectlyFinished());
             AFL_VERIFY(!rb || rb->num_rows() == 0)("count", rb->num_rows());
-            ++planStep;
         }
     }
 
@@ -1933,6 +1997,10 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
         TestSomePrograms(table);
     }
 
+    Y_UNIT_TEST(ReadWithProgramNoProjection) {
+        TestReadWithProgramNoProjection();
+    }
+
     Y_UNIT_TEST(ReadAggregate) {
         auto schema = TTestSchema::YdbAllTypesSchema();
         auto testBlob = MakeTestBlob({ 0, 100 }, schema);
@@ -1990,13 +2058,13 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
     class TTabletReadPredicateTest {
     private:
         TTestBasicRuntime& Runtime;
-        const ui64 PlanStep;
+        const TPlanStep PlanStep;
         const ui64 TxId;
         const std::vector<NArrow::NTest::TTestColumn> YdbPk;
 
     public:
         TTabletReadPredicateTest(
-            TTestBasicRuntime& runtime, const ui64 planStep, const ui64 txId, const std::vector<NArrow::NTest::TTestColumn>& ydbPk)
+            TTestBasicRuntime& runtime, const TPlanStep planStep, const ui64 txId, const std::vector<NArrow::NTest::TTestColumn>& ydbPk)
             : Runtime(runtime)
             , PlanStep(planStep)
             , TxId(txId)
@@ -2126,10 +2194,9 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
         runtime.DispatchEvents(options);
 
         const ui64 tableId = 1;
-        ui64 planStep = 100;
         ui64 txId = 100;
 
-        SetupSchema(runtime, sender, tableId, table, "lz4");
+        auto planStep = SetupSchema(runtime, sender, tableId, table, "lz4");
         TAutoPtr<IEventHandle> handle;
 
         bool isStrPk0 = table.Pk[0].GetType() == TTypeInfo(NTypeIds::String) || table.Pk[0].GetType() == TTypeInfo(NTypeIds::Utf8);
@@ -2142,7 +2209,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
         const ui32 numWrites = 23;
         {
             ui64 writeId = 0;
-            for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++planStep, ++txId) {
+            for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++txId) {
                 ui64 start = i * (triggerPortionSize - overlapSize);
                 std::pair<ui64, ui64> triggerPortion = { start, start + triggerPortionSize };
                 TString triggerData = MakeTestBlob(triggerPortion, table.Schema, testBlobOptions);
@@ -2152,13 +2219,12 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
                 std::vector<ui64> writeIds;
                 UNIT_ASSERT(WriteData(runtime, sender, writeId, tableId, triggerData, table.Schema, true, &writeIds));
 
-                ProposeCommit(runtime, sender, txId, writeIds);
+                planStep = ProposeCommit(runtime, sender, txId, writeIds);
                 PlanCommit(runtime, sender, planStep, txId);
             }
         }
 
         // TODO: Move tablet's time to the future with mediator timecast instead
-        --planStep;
         --txId;
 
         const ui32 fullNumRows = numWrites * (triggerPortionSize - overlapSize) + overlapSize;
@@ -2368,11 +2434,10 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
 
         ui64 writeId = 0;
         ui64 tableId = 1;
-        ui64 planStep = 1000000;
         ui64 txId = 100;
 
         auto ydbSchema = TTestSchema::YdbSchema();
-        SetupSchema(runtime, sender, tableId);
+        auto planStep = SetupSchema(runtime, sender, tableId);
         TAutoPtr<IEventHandle> handle;
 
         // Write some test data to advance the time
@@ -2383,7 +2448,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
             std::vector<ui64> writeIds;
             UNIT_ASSERT(WriteData(runtime, sender, writeId, tableId, triggerData, ydbSchema, true, &writeIds));
 
-            ProposeCommit(runtime, sender, txId, writeIds);
+            planStep = ProposeCommit(runtime, sender, txId, writeIds);
             PlanCommit(runtime, sender, planStep, txId);
         }
 
@@ -2397,7 +2462,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
                 request->Record.SetScanId(1);
                 request->Record.SetLocalPathId(tableId);
                 request->Record.SetTablePath("test_olap_table");
-                request->Record.MutableSnapshot()->SetStep(planStep - staleness.MilliSeconds());
+                request->Record.MutableSnapshot()->SetStep(planStep.Val() - staleness.MilliSeconds());
                 request->Record.MutableSnapshot()->SetTxId(Max<ui64>());
 
                 ForwardToTablet(runtime, TTestTxConfig::TxTablet0, sender, request.release());
@@ -2410,7 +2475,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
             // Cerr << response << Endl;
             UNIT_ASSERT_VALUES_EQUAL(response.GetStatus(), Ydb::StatusIds::BAD_REQUEST);
             UNIT_ASSERT_VALUES_EQUAL(response.IssuesSize(), 1);
-            UNIT_ASSERT_STRING_CONTAINS(response.GetIssues(0).message(), "Snapshot too old: {640000:max}");
+            UNIT_ASSERT_STRING_CONTAINS(response.GetIssues(0).message(), TStringBuilder() << "Snapshot too old: {" << planStep - staleness.MilliSeconds() << ":max}");
         }
 
         // Try to read snapshot that is too old
@@ -2444,7 +2509,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
         ui64 tableId = 1;
 
         auto ydbSchema = TTestSchema::YdbSchema();
-        SetupSchema(runtime, sender, tableId);
+        auto planStep = SetupSchema(runtime, sender, tableId);
         TAutoPtr<IEventHandle> handle;
 
         bool blockReadFinished = true;
@@ -2538,17 +2603,6 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
         };
         runtime.SetEventFilter(captureEvents);
 
-        // Disable GC batching so that deleted blobs get collected without a delay
-        {
-            TAtomic unusedPrev;
-            runtime.GetAppData().Icb->SetValue("ColumnShardControls.BlobCountToTriggerGC", 1, unusedPrev);
-        }
-
-        {
-            TAtomic unusedPrev;
-            runtime.GetAppData().Icb->SetValue("ColumnShardControls.MaxPortionsInGranule", 10, unusedPrev);
-        }
-
         // Write different keys: grow on compaction
 
         static const ui32 triggerPortionSize = 75 * 1000;
@@ -2557,16 +2611,15 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
         UNIT_ASSERT(triggerData.size() > NColumnShard::TLimits::MIN_BYTES_TO_INSERT);
         UNIT_ASSERT(triggerData.size() < NColumnShard::TLimits::GetMaxBlobSize());
 
-        ui64 planStep = 5000000;
         ui64 txId = 1000;
 
         // Overwrite the same data multiple times to produce multiple portions at different timestamps
         ui32 numWrites = 14;
-        for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++planStep, ++txId) {
+        for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++txId) {
             std::vector<ui64> writeIds;
             UNIT_ASSERT(WriteData(runtime, sender, writeId, tableId, triggerData, ydbSchema, true, &writeIds));
 
-            ProposeCommit(runtime, sender, txId, writeIds);
+            planStep = ProposeCommit(runtime, sender, txId, writeIds);
             PlanCommit(runtime, sender, planStep, txId);
         }
 
@@ -2577,14 +2630,12 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
             std::vector<ui64> writeIds;
             UNIT_ASSERT(WriteData(runtime, sender, writeId, tableId, smallData, ydbSchema, true, &writeIds));
 
-            ProposeCommit(runtime, sender, txId, writeIds);
+            planStep = ProposeCommit(runtime, sender, txId, writeIds);
             PlanCommit(runtime, sender, planStep, txId);
             ++writeId;
-            ++planStep;
             ++txId;
         }
 
-        --planStep;
         --txId;
         Cerr << compactionsHappened << Endl;
         //        UNIT_ASSERT_GE(compactionsHappened, 3); // we catch it three times per action
@@ -2607,14 +2658,12 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
         // read request is in progress and keeps the portions
 
         // Advance the time in order to trigger GC
-        TDuration delay = TDuration::Minutes(6);
-        planStep += delay.MilliSeconds();
         numWrites = 10;
-        for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++planStep, ++txId) {
+        for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++txId) {
             std::vector<ui64> writeIds;
             UNIT_ASSERT(WriteData(runtime, sender, writeId, tableId, triggerData, ydbSchema, true, &writeIds));
 
-            ProposeCommit(runtime, sender, txId, writeIds);
+            planStep = ProposeCommit(runtime, sender, txId, writeIds);
             PlanCommit(runtime, sender, planStep, txId);
         }
         {
@@ -2632,7 +2681,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
         // Check that GC happened but it didn't collect some old portions
         UNIT_ASSERT_GT(compactionsHappened, previousCompactionsHappened);
         UNIT_ASSERT_EQUAL(cleanupsHappened, 0);
-        UNIT_ASSERT_GT_C(oldPortions.size(), deletedPortions.size(), "Some old portions must not be deleted because the are in use by read");
+        UNIT_ASSERT_GT_C(oldPortions.size(), deletedPortions.size(), "Some old portions must not be deleted because they are in use by read");
         UNIT_ASSERT_GT_C(delayedBlobs.size(), 0, "Read request is expected to have at least one committed blob, which deletion must be delayed");
         previousCompactionsHappened = compactionsHappened;
         previousCleanupsHappened = cleanupsHappened;
@@ -2646,17 +2695,17 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
         }
 
         // Advance the time and trigger some more cleanups withno compactions
+        csDefaultControllerGuard->SetOverrideUsedSnapshotLivetime(csDefaultControllerGuard->GetMaxReadStalenessInMem() - TDuration::MilliSeconds(1));
         csDefaultControllerGuard->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Compaction);
         {
             auto read = std::make_unique<NColumnShard::TEvPrivate::TEvPingSnapshotsUsage>();
             ForwardToTablet(runtime, TTestTxConfig::TxTablet0, sender, read.release());
         }
-        planStep += (2 * delay).MilliSeconds();
-        for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++planStep, ++txId) {
+        for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++txId) {
             std::vector<ui64> writeIds;
             UNIT_ASSERT(WriteData(runtime, sender, writeId, tableId, triggerData, ydbSchema, true, &writeIds));
 
-            ProposeCommit(runtime, sender, txId, writeIds);
+            planStep = ProposeCommit(runtime, sender, txId, writeIds);
             PlanCommit(runtime, sender, planStep, txId);
         }
         UNIT_ASSERT_EQUAL(cleanupsHappened, 0);
@@ -2666,16 +2715,17 @@ Y_UNIT_TEST_SUITE(TColumnShardTestReadWrite) {
             auto read = std::make_unique<NColumnShard::TEvPrivate::TEvPingSnapshotsUsage>();
             ForwardToTablet(runtime, TTestTxConfig::TxTablet0, sender, read.release());
         }
-        for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++planStep, ++txId) {
+        for (ui32 i = 0; i < numWrites; ++i, ++writeId, ++txId) {
             std::vector<ui64> writeIds;
             UNIT_ASSERT(WriteData(runtime, sender, writeId, tableId, triggerData, ydbSchema, true, &writeIds));
 
-            ProposeCommit(runtime, sender, txId, writeIds);
+            planStep = ProposeCommit(runtime, sender, txId, writeIds);
             PlanCommit(runtime, sender, planStep, txId);
         }
         AFL_VERIFY(csDefaultControllerGuard->GetRequestTracingSnapshotsSave().Val() == 1);
         AFL_VERIFY(csDefaultControllerGuard->GetRequestTracingSnapshotsRemove().Val() == 1);
-
+        csDefaultControllerGuard->SetOverrideMaxReadStaleness(TDuration::Zero());
+        csDefaultControllerGuard->WaitCleaning(TDuration::Seconds(20), &runtime);
         Cerr << "Compactions happened: " << csDefaultControllerGuard->GetCompactionStartedCounter().Val() << Endl;
         Cerr << "Indexations happened: " << csDefaultControllerGuard->GetInsertStartedCounter().Val() << Endl;
         Cerr << "Cleanups happened: " << csDefaultControllerGuard->GetCleaningStartedCounter().Val() << Endl;
diff --git a/ydb/core/tx/columnshard/ut_rw/ut_normalizer.cpp b/ydb/core/tx/columnshard/ut_rw/ut_normalizer.cpp
index 305778a5d0e3..731c578deea9 100644
--- a/ydb/core/tx/columnshard/ut_rw/ut_normalizer.cpp
+++ b/ydb/core/tx/columnshard/ut_rw/ut_normalizer.cpp
@@ -259,7 +259,7 @@ Y_UNIT_TEST_SUITE(Normalizers) {
         const std::vector<NArrow::NTest::TTestColumn> schema = { NArrow::NTest::TTestColumn("key1", TTypeInfo(NTypeIds::Uint64)),
             NArrow::NTest::TTestColumn("key2", TTypeInfo(NTypeIds::Uint64)), NArrow::NTest::TTestColumn("field", TTypeInfo(NTypeIds::Utf8)) };
         const std::vector<ui32> columnsIds = { 1, 2, 3 };
-        PrepareTablet(runtime, tableId, schema, 2);
+        auto planStep = PrepareTablet(runtime, tableId, schema, 2);
         const ui64 txId = 111;
 
         NConstruction::IArrayBuilder::TPtr key1Column =
@@ -272,17 +272,17 @@ Y_UNIT_TEST_SUITE(Normalizers) {
         auto batch = NConstruction::TRecordBatchConstructor({ key1Column, key2Column, column }).BuildBatch(20048);
         NTxUT::TShardWriter writer(runtime, TTestTxConfig::TxTablet0, tableId, 222);
         AFL_VERIFY(writer.Write(batch, {1, 2, 3}, txId) == NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED);
-        AFL_VERIFY(writer.StartCommit(txId) == NKikimrDataEvents::TEvWriteResult::STATUS_PREPARED);
-        PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(11, txId));
+        planStep = writer.StartCommit(txId);
+        PlanWriteTx(runtime, writer.GetSender(), NOlap::TSnapshot(planStep, txId));
 
         {
-            auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(11, txId), schema);
+            auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(planStep, txId), schema);
             UNIT_ASSERT_VALUES_EQUAL(readResult->num_rows(), 20048);
         }
         RebootTablet(runtime, TTestTxConfig::TxTablet0, writer.GetSender());
 
         {
-            auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(11, txId), schema);
+            auto readResult = ReadAllAsBatch(runtime, tableId, NOlap::TSnapshot(planStep, txId), schema);
             UNIT_ASSERT_VALUES_EQUAL(readResult->num_rows(), checker.RecordsCountAfterReboot(20048));
         }
     }
diff --git a/ydb/core/tx/columnshard/ut_schema/ut_columnshard_schema.cpp b/ydb/core/tx/columnshard/ut_schema/ut_columnshard_schema.cpp
index 663e8557de71..439e58fe36d1 100644
--- a/ydb/core/tx/columnshard/ut_schema/ut_columnshard_schema.cpp
+++ b/ydb/core/tx/columnshard/ut_schema/ut_columnshard_schema.cpp
@@ -6,6 +6,7 @@
 #include <ydb/core/tx/tx_proxy/proxy.h>
 #include <ydb/core/tx/schemeshard/schemeshard.h>
 #include <ydb/core/tx/columnshard/test_helper/shard_reader.h>
+#include <ydb/core/tx/columnshard/test_helper/test_combinator.h>
 #include <ydb/core/tx/columnshard/hooks/abstract/abstract.h>
 #include <ydb/core/tx/columnshard/hooks/testing/controller.h>
 #include <ydb/core/tx/columnshard/blobs_reader/actor.h>
@@ -20,6 +21,7 @@
 #include <library/cpp/deprecated/atomic/atomic.h>
 #include <library/cpp/testing/hook/hook.h>
 
+
 namespace NKikimr {
 
 using namespace NTxUT;
@@ -168,23 +170,20 @@ static constexpr ui32 PORTION_ROWS = 80 * 1000;
 
 // ts[0] = 1600000000; // date -u --date='@1600000000' Sun Sep 13 12:26:40 UTC 2020
 // ts[1] = 1620000000; // date -u --date='@1620000000' Mon May  3 00:00:00 UTC 2021
-void TestTtl(bool reboots, bool internal, TTestSchema::TTableSpecials spec = {},
-             const std::vector<NArrow::NTest::TTestColumn>& ydbSchema = testYdbSchema)
+void TestTtl(bool reboots, bool internal, bool useFirstPkColumnForTtl, NScheme::TTypeId ttlColumnTypeId)
 {
     auto csControllerGuard = NKikimr::NYDBTest::TControllers::RegisterCSControllerGuard<NOlap::TWaitCompactionController>();
     csControllerGuard->DisableBackground(NKikimr::NYDBTest::ICSController::EBackground::Compaction);
     csControllerGuard->SetOverrideTasksActualizationLag(TDuration::Zero());
     std::vector<ui64> ts = { 1600000000, 1620000000 };
 
-    ui32 ttlIncSeconds = 1;
-    for (auto& c : ydbSchema) {
-        if (c.GetName() == spec.TtlColumn) {
-            if (c.GetType().GetTypeId() == NTypeIds::Date) {
-                ttlIncSeconds = TDuration::Days(1).Seconds();
-            }
-            break;
-        }
-    }
+    auto ydbSchema = TTestSchema::YdbSchema();
+    const auto ttlColumnNameIdx = useFirstPkColumnForTtl ? 0 : 8;
+    const auto ttlColumnName = ydbSchema[ttlColumnNameIdx].GetName();
+    UNIT_ASSERT(ttlColumnName == (useFirstPkColumnForTtl ? "timestamp" : "saved_at")); //to detect default schema changes
+    ydbSchema[ttlColumnNameIdx].SetType(ttlColumnTypeId);
+    const auto ttlIncSeconds = ttlColumnTypeId == NTypeIds::Date ? TDuration::Days(1).Seconds() : 1;
+    TTestSchema::TTableSpecials specs;
 
     TTestBasicRuntime runtime;
     TTester::Setup(runtime);
@@ -203,7 +202,6 @@ void TestTtl(bool reboots, bool internal, TTestSchema::TTableSpecials spec = {},
 
     ui64 writeId = 0;
     ui64 tableId = 1;
-    ui64 planStep = 1000000000; // greater then delays
     ui64 txId = 100;
 
     UNIT_ASSERT(ts.size() == 2);
@@ -214,15 +212,11 @@ void TestTtl(bool reboots, bool internal, TTestSchema::TTableSpecials spec = {},
     } else {
         ttlSec -= ts[0] + ttlIncSeconds;
     }
-    if (spec.HasTiers()) {
-        spec.Tiers[0].EvictAfter = TDuration::Seconds(ttlSec);
-    } else {
-        UNIT_ASSERT(!spec.TtlColumn.empty());
-        spec.EvictAfter = TDuration::Seconds(ttlSec);
-    }
-    SetupSchema(runtime, sender,
-                              TTestSchema::CreateInitShardTxBody(tableId, ydbSchema, testYdbPk, spec, "/Root/olapStore"),
-                              NOlap::TSnapshot(++planStep, ++txId));
+    TTestSchema::TTableSpecials spec;
+    spec.TtlColumn = ttlColumnName;
+    spec.EvictAfter = TDuration::Seconds(ttlSec);
+    auto planStep = SetupSchema(runtime, sender,
+        TTestSchema::CreateInitShardTxBody(tableId, ydbSchema, testYdbPk, spec, "/Root/olapStore"), ++txId);
     if (spec.HasTiers()) {
         csControllerGuard->OverrideTierConfigs(runtime, sender, TTestSchema::BuildSnapshot(spec));
     }
@@ -234,8 +228,8 @@ void TestTtl(bool reboots, bool internal, TTestSchema::TTableSpecials spec = {},
     for (auto& data : blobs) {
         std::vector<ui64> writeIds;
         UNIT_ASSERT(WriteData(runtime, sender, ++writeId, tableId, data, ydbSchema, true, &writeIds));
-        ProposeCommit(runtime, sender, ++txId, writeIds);
-        PlanCommit(runtime, sender, ++planStep, txId);
+        planStep = ProposeCommit(runtime, sender, ++txId, writeIds);
+        PlanCommit(runtime, sender, planStep, txId);
     }
 
     // TODO: write into path 2 (no ttl)
@@ -270,9 +264,8 @@ void TestTtl(bool reboots, bool internal, TTestSchema::TTableSpecials spec = {},
     } else {
         spec.EvictAfter = TDuration::Seconds(ttlSec);
     }
-    SetupSchema(runtime, sender,
-                         TTestSchema::AlterTableTxBody(tableId, 2, spec),
-                         NOlap::TSnapshot(++planStep, ++txId));
+    planStep = SetupSchema(runtime, sender,
+                         TTestSchema::AlterTableTxBody(tableId, 2, spec), ++txId);
     if (spec.HasTiers()) {
         csControllerGuard->OverrideTierConfigs(runtime, sender, TTestSchema::BuildSnapshot(spec));
     }
@@ -294,10 +287,8 @@ void TestTtl(bool reboots, bool internal, TTestSchema::TTableSpecials spec = {},
 
     // Disable TTL
     lastTtlFinishedCount = csControllerGuard->GetTTLFinishedCounter().Val();
-    auto ok = ProposeSchemaTx(runtime, sender,
-                         TTestSchema::AlterTableTxBody(tableId, 3, TTestSchema::TTableSpecials()),
-                         NOlap::TSnapshot(++planStep, ++txId));
-    UNIT_ASSERT(ok);
+    planStep = SetupSchema(runtime, sender,
+                         TTestSchema::AlterTableTxBody(tableId, 3, TTestSchema::TTableSpecials()), ++txId);
     if (spec.HasTiers()) {
         csControllerGuard->OverrideTierConfigs(runtime, sender, TTestSchema::BuildSnapshot(TTestSchema::TTableSpecials()));
     }
@@ -306,8 +297,8 @@ void TestTtl(bool reboots, bool internal, TTestSchema::TTableSpecials spec = {},
 
     std::vector<ui64> writeIds;
     UNIT_ASSERT(WriteData(runtime, sender, ++writeId, tableId, blobs[0], ydbSchema, true, &writeIds));
-    ProposeCommit(runtime, sender, ++txId, writeIds);
-    PlanCommit(runtime, sender, ++planStep, txId);
+    planStep  = ProposeCommit(runtime, sender, ++txId, writeIds);
+    PlanCommit(runtime, sender, planStep, txId);
 
     ForwardToTablet(runtime, TTestTxConfig::TxTablet0, sender, new TEvPrivate::TEvPeriodicWakeup(true));
 
@@ -535,24 +526,14 @@ std::vector<std::pair<ui32, ui64>> TestTiers(bool reboots, const std::vector<TSt
         runtime.GetAppData().Icb->SetValue("BlobCache.MaxCacheDataSize", 0, unused);
     }
 
-    // Disable GC batching so that deleted blobs get collected without a delay
-    {
-        TAtomic unused;
-        runtime.GetAppData().Icb->SetValue("ColumnShardControls.BlobCountToTriggerGC", 1, unused);
-    }
-
-    //
-
     ui64 writeId = 0;
     ui64 tableId = 1;
-    ui64 planStep = 1000000000; // greater then delays
     ui64 txId = 100;
 //    const TDuration exportTimeout = TDuration::Seconds(40);
 
     UNIT_ASSERT(specs.size() > 0);
-    SetupSchema(runtime, sender,
-            TTestSchema::CreateInitShardTxBody(tableId, testYdbSchema, testYdbPk, specs[0], "/Root/olapStore"),
-            NOlap::TSnapshot(++planStep, ++txId));
+    auto planStep = SetupSchema(runtime, sender,
+            TTestSchema::CreateInitShardTxBody(tableId, testYdbSchema, testYdbPk, specs[0], "/Root/olapStore"), ++txId);
     if (specs[0].Tiers.size()) {
         csControllerGuard->OverrideTierConfigs(runtime, sender, TTestSchema::BuildSnapshot(specs[0]));
     }
@@ -560,8 +541,8 @@ std::vector<std::pair<ui32, ui64>> TestTiers(bool reboots, const std::vector<TSt
     for (auto& data : blobs) {
         std::vector<ui64> writeIds;
         UNIT_ASSERT(WriteData(runtime, sender, ++writeId, tableId, data, testYdbSchema, true, &writeIds));
-        ProposeCommit(runtime, sender, ++txId, writeIds);
-        PlanCommit(runtime, sender, ++planStep, txId);
+        planStep = ProposeCommit(runtime, sender, ++txId, writeIds);
+        PlanCommit(runtime, sender, planStep, txId);
     }
 
     if (reboots) {
@@ -602,9 +583,7 @@ std::vector<std::pair<ui32, ui64>> TestTiers(bool reboots, const std::vector<TSt
         }
         if (i) {
             const ui32 version = 2 * i + 1;
-            SetupSchema(runtime, sender,
-                TTestSchema::AlterTableTxBody(tableId, version, specs[i]),
-                NOlap::TSnapshot(++planStep, ++txId));
+            planStep = SetupSchema(runtime, sender, TTestSchema::AlterTableTxBody(tableId, version, specs[i]), ++txId);
         }
         if (specs[i].HasTiers() || reboots) {
             csControllerGuard->OverrideTierConfigs(runtime, sender, TTestSchema::BuildSnapshot(specs[i]));
@@ -939,13 +918,10 @@ void TestDrop(bool reboots) {
 
     ui64 writeId = 0;
     ui64 tableId = 1;
-    ui64 planStep = 1000000000; // greater then delays
     ui64 txId = 100;
 
-    SetupSchema(runtime, sender, TTestSchema::CreateTableTxBody(tableId, testYdbSchema, testYdbPk),
-                              NOlap::TSnapshot(++planStep, ++txId));
-    //
-
+    auto planStep = SetupSchema(runtime, sender,
+        TTestSchema::CreateTableTxBody(tableId, testYdbSchema, testYdbPk), ++txId);
     TString data1 = MakeTestBlob({0, PORTION_ROWS}, testYdbSchema);
     UNIT_ASSERT(data1.size() > NColumnShard::TLimits::MIN_BYTES_TO_INSERT);
     UNIT_ASSERT(data1.size() < 7 * 1024 * 1024);
@@ -956,21 +932,21 @@ void TestDrop(bool reboots) {
     // Write into index
     std::vector<ui64> writeIds;
     UNIT_ASSERT(WriteData(runtime, sender, ++writeId, tableId, data1, testYdbSchema, true, &writeIds));
-    ProposeCommit(runtime, sender, ++txId, writeIds);
-    PlanCommit(runtime, sender, ++planStep, txId);
+    planStep = ProposeCommit(runtime, sender, ++txId, writeIds);
+    PlanCommit(runtime, sender, planStep, txId);
 
     // Write into InsertTable
     writeIds.clear();
     UNIT_ASSERT(WriteData(runtime, sender, ++writeId, tableId, data2, testYdbSchema, true, &writeIds));
-    ProposeCommit(runtime, sender, ++txId, writeIds);
-    PlanCommit(runtime, sender, ++planStep, txId);
+    planStep = ProposeCommit(runtime, sender, ++txId, writeIds);
+    PlanCommit(runtime, sender, planStep, txId);
 
     if (reboots) {
         RebootTablet(runtime, TTestTxConfig::TxTablet0, sender);
     }
 
     // Drop table
-    SetupSchema(runtime, sender, TTestSchema::DropTableTxBody(tableId, 2), NOlap::TSnapshot(++planStep, ++txId));
+    planStep = SetupSchema(runtime, sender, TTestSchema::DropTableTxBody(tableId, 2), ++txId);
 
     if (reboots) {
         RebootTablet(runtime, TTestTxConfig::TxTablet0, sender);
@@ -978,7 +954,6 @@ void TestDrop(bool reboots) {
 
     TAutoPtr<IEventHandle> handle;
     {
-        --planStep;
         TShardReader reader(runtime, TTestTxConfig::TxTablet0, tableId, NOlap::TSnapshot(planStep, Max<ui64>()));
         reader.SetReplyColumnIds(TTestSchema::GetColumnIds(TTestSchema::YdbSchema(), { TTestSchema::DefaultTtlColumn }));
         auto rb = reader.ReadAll();
@@ -1004,32 +979,29 @@ void TestDropWriteRace() {
     //
 
     ui64 tableId = 1;
-    ui64 planStep = 1000000000; // greater then delays
     ui64 txId = 100;
     ui32 writeId = 0;
 
     NLongTxService::TLongTxId longTxId;
     UNIT_ASSERT(longTxId.ParseString("ydb://long-tx/01ezvvxjdk2hd4vdgjs68knvp8?node_id=1"));
 
-    SetupSchema(runtime, sender, TTestSchema::CreateTableTxBody(tableId, testYdbSchema, testYdbPk),
-                              NOlap::TSnapshot(++planStep, ++txId));
+    auto planStep = SetupSchema(runtime, sender,
+        TTestSchema::CreateTableTxBody(tableId, testYdbSchema, testYdbPk), ++txId);
     TString data = MakeTestBlob({0, 100}, testYdbSchema);
     UNIT_ASSERT(data.size() < NColumnShard::TLimits::MIN_BYTES_TO_INSERT);
 
     // Write into InsertTable
     ++txId;
     AFL_VERIFY(WriteData(runtime, sender, ++writeId, tableId, data, testYdbSchema));
-    ProposeCommit(runtime, sender, txId, { writeId });
-    auto commitTxId = txId;
+    planStep = ProposeCommit(runtime, sender, txId, { writeId });
+    const auto commitTxId = txId;
 
     // Drop table
-    auto ok = ProposeSchemaTx(runtime, sender, TTestSchema::DropTableTxBody(tableId, 2), NOlap::TSnapshot(++planStep, ++txId));
-    if (ok) {
-        PlanSchemaTx(runtime, sender, NOlap::TSnapshot(planStep, txId));
-    }
+    planStep = ProposeSchemaTx(runtime, sender, TTestSchema::DropTableTxBody(tableId, 2), ++txId);
+    PlanSchemaTx(runtime, sender, NOlap::TSnapshot(planStep, txId));
 
     // Plan commit
-    PlanCommit(runtime, sender, ++planStep, commitTxId);
+    PlanCommit(runtime, sender, planStep + 1, commitTxId);
 }
 
 void TestCompaction(std::optional<ui32> numWrites = {}) {
@@ -1049,11 +1021,10 @@ void TestCompaction(std::optional<ui32> numWrites = {}) {
     // Create table
     ui64 writeId = 0;
     ui64 tableId = 1;
-    ui64 planStep = 100;
     ui64 txId = 100;
 
-    SetupSchema(runtime, sender, TTestSchema::CreateTableTxBody(tableId, testYdbSchema, testYdbPk),
-                              NOlap::TSnapshot(++planStep, ++txId));
+    auto planStep = SetupSchema(runtime, sender,
+        TTestSchema::CreateTableTxBody(tableId, testYdbSchema, testYdbPk), ++txId);
     // Set tiering
 
     ui64 ts = 1620000000;
@@ -1069,8 +1040,8 @@ void TestCompaction(std::optional<ui32> numWrites = {}) {
     spec.Tiers.back().EvictAfter = allow;
     spec.Tiers.back().S3 = TTestSchema::TStorageTier::FakeS3();
 
-    SetupSchema(runtime, sender, TTestSchema::AlterTableTxBody(tableId, 1, spec),
-                            NOlap::TSnapshot(++planStep, ++txId));
+    planStep = SetupSchema(runtime, sender, TTestSchema::AlterTableTxBody(tableId, 1, spec),
+                           ++txId);
     csControllerGuard->OverrideTierConfigs(runtime, sender, TTestSchema::BuildSnapshot(spec));
 
     // Writes
@@ -1084,13 +1055,12 @@ void TestCompaction(std::optional<ui32> numWrites = {}) {
         numWrites = NOlap::TCompactionLimits().GranuleOverloadSize / triggerData.size();
     }
 
-    ++planStep;
     ++txId;
-    for (ui32 i = 0; i < *numWrites; ++i, ++writeId, ++planStep, ++txId) {
+    for (ui32 i = 0; i < *numWrites; ++i, ++writeId, ++txId) {
         std::vector<ui64> writeIds;
         UNIT_ASSERT(WriteData(runtime, sender, writeId, tableId, triggerData, testYdbSchema, true, &writeIds));
 
-        ProposeCommit(runtime, sender, txId, writeIds);
+        planStep = ProposeCommit(runtime, sender, txId, writeIds);
         PlanCommit(runtime, sender, planStep, txId);
 
     }
@@ -1141,7 +1111,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestSchema) {
         auto schema = TTestSchema::YdbSchema(NArrow::NTest::TTestColumn("k0", TTypeInfo(NTypeIds::Timestamp)));
         auto pk = NArrow::NTest::TTestColumn::CropSchema(schema, 4);
 
-        ui64 planStep = 1000;
+        TPlanStep planStep;
         ui64 txId = 100;
         ui64 generation = 0;
 
@@ -1149,7 +1119,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestSchema) {
             schema[0].SetType(TTypeInfo(ydbType));
             pk[0].SetType(TTypeInfo(ydbType));
             auto txBody = TTestSchema::CreateTableTxBody(tableId++, schema, pk, {}, ++generation);
-            SetupSchema(runtime, sender, txBody, NOlap::TSnapshot(planStep++, txId++));
+            planStep = SetupSchema(runtime, sender, txBody, txId++);
         }
 
         // TODO: support float types
@@ -1162,7 +1132,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestSchema) {
             schema[0].SetType(TTypeInfo(ydbType));
             pk[0].SetType(TTypeInfo(ydbType));
             auto txBody = TTestSchema::CreateTableTxBody(tableId++, schema, pk, {}, ++generation);
-            SetupSchema(runtime, sender, txBody, NOlap::TSnapshot(planStep++, txId++), false);
+            ProposeSchemaTxFail(runtime, sender, txBody, txId++);
         }
 
         std::vector<TTypeId> strTypes = {
@@ -1174,7 +1144,7 @@ Y_UNIT_TEST_SUITE(TColumnShardTestSchema) {
             schema[0].SetType(TTypeInfo(ydbType));
             pk[0].SetType(TTypeInfo(ydbType));
             auto txBody = TTestSchema::CreateTableTxBody(tableId++, schema, pk, {}, ++generation);
-            SetupSchema(runtime, sender, txBody, NOlap::TSnapshot(planStep++, txId++));
+            planStep = SetupSchema(runtime, sender, txBody, txId++);
         }
 
         std::vector<TTypeId> xsonTypes = {
@@ -1187,83 +1157,18 @@ Y_UNIT_TEST_SUITE(TColumnShardTestSchema) {
             schema[0].SetType(TTypeInfo(ydbType));
             pk[0].SetType(TTypeInfo(ydbType));
             auto txBody = TTestSchema::CreateTableTxBody(tableId++, schema, pk, {}, ++generation);
-            SetupSchema(runtime, sender, txBody, NOlap::TSnapshot(planStep++, txId++), false);
+            ProposeSchemaTxFail(runtime, sender, txBody, txId++);
         }
     }
 
-    Y_UNIT_TEST(ExternalTTL) {
-        TestTtl(false, false); // over NTypeIds::Timestamp ttl column
-    }
-
-    Y_UNIT_TEST(ExternalTTL_Types) {
-        auto ydbSchema = testYdbSchema;
-        for (auto typeId : {NTypeIds::Datetime, NTypeIds::Date, NTypeIds::Uint32, NTypeIds::Uint64}) {
-            UNIT_ASSERT_EQUAL(ydbSchema[8].GetName(), "saved_at");
-            ydbSchema[8].SetType(TTypeInfo(typeId));
-
-            TTestSchema::TTableSpecials specs;
-            specs.SetTtlColumn("saved_at");
-
-            TestTtl(false, false, specs, ydbSchema);
+    Y_UNIT_TEST_OCTO(TTL, Reboot, Internal, FirstPkColumn) {
+        for (auto typeId : {NTypeIds::Timestamp, NTypeIds::Datetime, NTypeIds::Date, NTypeIds::Uint32, NTypeIds::Uint64}) {
+            TestTtl(Reboot, Internal, FirstPkColumn, typeId);
         }
     }
 
-    Y_UNIT_TEST(RebootExternalTTL) {
-        NColumnShard::gAllowLogBatchingDefaultValue = false;
-        TestTtl(true, false);
-    }
-
-    Y_UNIT_TEST(InternalTTL) {
-        TestTtl(false, true); // over NTypeIds::Timestamp ttl column
-    }
-
-    Y_UNIT_TEST(InternalTTL_Types) {
-        auto ydbSchema = testYdbSchema;
-        for (auto typeId : {NTypeIds::Datetime, NTypeIds::Date, NTypeIds::Uint32, NTypeIds::Uint64}) {
-            UNIT_ASSERT_EQUAL(ydbSchema[8].GetName(), "saved_at");
-            ydbSchema[8].SetType(TTypeInfo(typeId));
-
-            TTestSchema::TTableSpecials specs;
-            specs.SetTtlColumn("saved_at");
 
-            TestTtl(false, true, specs, ydbSchema);
-        }
-    }
 
-    Y_UNIT_TEST(RebootInternalTTL) {
-        NColumnShard::gAllowLogBatchingDefaultValue = false;
-        TestTtl(true, true);
-    }
-
-    Y_UNIT_TEST(OneTier) {
-        TTestSchema::TTableSpecials specs;
-        specs.SetTtlColumn("timestamp");
-//        specs.Tiers.emplace_back(TTestSchema::TStorageTier("default").SetTtlColumn("timestamp"));
-        TestTtl(false, true, specs);
-    }
-
-    Y_UNIT_TEST(RebootOneTier) {
-        NColumnShard::gAllowLogBatchingDefaultValue = false;
-        TTestSchema::TTableSpecials specs;
-        specs.SetTtlColumn("timestamp");
-//        specs.Tiers.emplace_back(TTestSchema::TStorageTier("default").SetTtlColumn("timestamp"));
-        TestTtl(true, true, specs);
-    }
-
-    Y_UNIT_TEST(OneTierExternalTtl) {
-        TTestSchema::TTableSpecials specs;
-        specs.SetTtlColumn("timestamp");
-//        specs.Tiers.emplace_back(TTestSchema::TStorageTier("default").SetTtlColumn("timestamp"));
-        TestTtl(false, false, specs);
-    }
-
-    Y_UNIT_TEST(RebootOneTierExternalTtl) {
-        NColumnShard::gAllowLogBatchingDefaultValue = false;
-        TTestSchema::TTableSpecials specs;
-        specs.SetTtlColumn("timestamp");
-//        specs.Tiers.emplace_back(TTestSchema::TStorageTier("default").SetTtlColumn("timestamp"));
-        TestTtl(true, false, specs);
-    }
 
     // TODO: EnableOneTierAfterTtl, EnableTtlAfterOneTier
 
diff --git a/ydb/core/tx/conveyor/service/service.cpp b/ydb/core/tx/conveyor/service/service.cpp
index 295745c4e603..3f93fed0dc19 100644
--- a/ydb/core/tx/conveyor/service/service.cpp
+++ b/ydb/core/tx/conveyor/service/service.cpp
@@ -36,9 +36,10 @@ void TDistributor::HandleMain(TEvInternal::TEvTaskProcessedResult::TPtr& evExt)
         ("queue", ProcessesOrdered.size())("workers", Workers.size())("count", ev->GetProcessIds().size())("d", ev->GetInstants().back() - ev->GetInstants().front());
     for (ui32 idx = 0; idx < ev->GetProcessIds().size(); ++idx) {
         AddCPUTime(ev->GetProcessIds()[idx], ev->GetInstants()[idx + 1] - std::max(LastAddProcessInstant, ev->GetInstants()[idx]));
+        Counters.TaskExecuteHistogram->Collect((ev->GetInstants()[idx + 1] - ev->GetInstants()[idx]).MicroSeconds());
     }
     const TDuration dExecution = ev->GetInstants().back() - ev->GetInstants().front();
-    Counters.ExecuteHistogram->Collect(dExecution.MicroSeconds());
+    Counters.PackExecuteHistogram->Collect(dExecution.MicroSeconds());
     Counters.ExecuteDuration->Add(dExecution.MicroSeconds());
 
     const TMonotonic now = TMonotonic::Now();
diff --git a/ydb/core/tx/conveyor/service/service.h b/ydb/core/tx/conveyor/service/service.h
index e42ae5ec0056..b3af6ea71d5a 100644
--- a/ydb/core/tx/conveyor/service/service.h
+++ b/ydb/core/tx/conveyor/service/service.h
@@ -2,7 +2,7 @@
 #include "worker.h"
 #include <ydb/core/tx/conveyor/usage/config.h>
 #include <ydb/core/tx/conveyor/usage/events.h>
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 #include <ydb/library/accessor/positive_integer.h>
 #include <ydb/library/actors/core/actor_bootstrapped.h>
 #include <ydb/library/actors/core/log.h>
@@ -35,7 +35,8 @@ class TCounters: public NColumnShard::TCommonCountersOwner {
 
     const ::NMonitoring::THistogramPtr WaitingHistogram;
     const ::NMonitoring::THistogramPtr PackHistogram;
-    const ::NMonitoring::THistogramPtr ExecuteHistogram;
+    const ::NMonitoring::THistogramPtr PackExecuteHistogram;
+    const ::NMonitoring::THistogramPtr TaskExecuteHistogram;
     const ::NMonitoring::THistogramPtr SendBackHistogram;
     const ::NMonitoring::THistogramPtr SendFwdHistogram;
     const ::NMonitoring::THistogramPtr ReceiveTaskHistogram;
@@ -58,7 +59,8 @@ class TCounters: public NColumnShard::TCommonCountersOwner {
         , UseWorkerRate(TBase::GetDeriviative("UseWorker"))
         , WaitingHistogram(TBase::GetHistogram("Waiting/Duration/Us", NMonitoring::ExponentialHistogram(25, 2, 50)))
         , PackHistogram(TBase::GetHistogram("ExecutionPack/Count", NMonitoring::LinearHistogram(25, 1, 1)))
-        , ExecuteHistogram(TBase::GetHistogram("Execute/Duration/Us", NMonitoring::ExponentialHistogram(25, 2, 50)))
+        , PackExecuteHistogram(TBase::GetHistogram("PackExecute/Duration/Us", NMonitoring::ExponentialHistogram(25, 2, 50)))
+        , TaskExecuteHistogram(TBase::GetHistogram("TaskExecute/Duration/Us", NMonitoring::ExponentialHistogram(25, 2, 50)))
         , SendBackHistogram(TBase::GetHistogram("SendBack/Duration/Us", NMonitoring::ExponentialHistogram(25, 2, 50)))
         , SendFwdHistogram(TBase::GetHistogram("SendForward/Duration/Us", NMonitoring::ExponentialHistogram(25, 2, 50)))
         , ReceiveTaskHistogram(TBase::GetHistogram("ReceiveTask/Duration/Us", NMonitoring::ExponentialHistogram(25, 2, 50)))
diff --git a/ydb/core/tx/conveyor/service/worker.cpp b/ydb/core/tx/conveyor/service/worker.cpp
index 6450725f15f3..a9e68d7b9359 100644
--- a/ydb/core/tx/conveyor/service/worker.cpp
+++ b/ydb/core/tx/conveyor/service/worker.cpp
@@ -8,7 +8,7 @@ void TWorker::ExecuteTask(std::vector<TWorkerTask>&& workerTasks) {
     std::vector<ui64> processes;
     instants.emplace_back(TMonotonic::Now());
     for (auto&& t : workerTasks) {
-        Y_UNUSED(t.GetTask()->Execute(t.GetTaskSignals(), t.GetTask()));
+        t.GetTask()->Execute(t.GetTaskSignals(), t.GetTask());
         instants.emplace_back(TMonotonic::Now());
         processes.emplace_back(t.GetProcessId());
     }
diff --git a/ydb/core/tx/conveyor/usage/abstract.cpp b/ydb/core/tx/conveyor/usage/abstract.cpp
index 55c19e7bba87..2c670d5a0227 100644
--- a/ydb/core/tx/conveyor/usage/abstract.cpp
+++ b/ydb/core/tx/conveyor/usage/abstract.cpp
@@ -8,30 +8,22 @@
 #include <util/string/builder.h>
 
 namespace NKikimr::NConveyor {
-TConclusionStatus ITask::Execute(std::shared_ptr<TTaskSignals> signals, const std::shared_ptr<ITask>& taskPtr) {
+void ITask::Execute(std::shared_ptr<TTaskSignals> signals, const std::shared_ptr<ITask>& taskPtr) {
     AFL_VERIFY(!ExecutedFlag);
     ExecutedFlag = true;
     const TMonotonic start = TMonotonic::Now();
     try {
-        TConclusionStatus result = DoExecute(taskPtr);
-        if (result.IsFail()) {
-            if (signals) {
-                signals->Fails->Add(1);
-                signals->FailsDuration->Add((TMonotonic::Now() - start).MicroSeconds());
-            }
-        } else {
-            if (signals) {
-                signals->Success->Add(1);
-                signals->SuccessDuration->Add((TMonotonic::Now() - start).MicroSeconds());
-            }
+        DoExecute(taskPtr);
+        if (signals) {
+            signals->Success->Add(1);
+            signals->SuccessDuration->Add((TMonotonic::Now() - start).MicroSeconds());
         }
-        return result;
     } catch (...) {
         if (signals) {
             signals->Fails->Add(1);
             signals->FailsDuration->Add((TMonotonic::Now() - start).MicroSeconds());
         }
-        return TConclusionStatus::Fail("exception: " + CurrentExceptionMessage());
+        AFL_ERROR(NKikimrServices::TX_CONVEYOR)("event", "exception_on_execute")("message", CurrentExceptionMessage());
     }
 }
 
diff --git a/ydb/core/tx/conveyor/usage/abstract.h b/ydb/core/tx/conveyor/usage/abstract.h
index d66e203274bb..909136d42639 100644
--- a/ydb/core/tx/conveyor/usage/abstract.h
+++ b/ydb/core/tx/conveyor/usage/abstract.h
@@ -1,6 +1,6 @@
 #pragma once
 #include <memory>
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 
 #include <ydb/library/accessor/accessor.h>
 #include <ydb/library/actors/core/actorid.h>
@@ -65,7 +65,7 @@ class ITask {
     YDB_ACCESSOR(EPriority, Priority, EPriority::Normal);
     bool ExecutedFlag = false;
 protected:
-    virtual TConclusionStatus DoExecute(const std::shared_ptr<ITask>& taskPtr) = 0;
+    virtual void DoExecute(const std::shared_ptr<ITask>& taskPtr) = 0;
     virtual void DoOnCannotExecute(const TString& reason);
 public:
     using TPtr = std::shared_ptr<ITask>;
@@ -76,7 +76,7 @@ class ITask {
     void OnCannotExecute(const TString& reason) {
         return DoOnCannotExecute(reason);
     }
-    TConclusionStatus Execute(std::shared_ptr<TTaskSignals> signals, const std::shared_ptr<ITask>& taskPtr);
+    void Execute(std::shared_ptr<TTaskSignals> signals, const std::shared_ptr<ITask>& taskPtr);
 };
 
 }
diff --git a/ydb/core/tx/data_events/common/error_codes.cpp b/ydb/core/tx/data_events/common/error_codes.cpp
index 2c86d4b52152..06cc5703d0f3 100644
--- a/ydb/core/tx/data_events/common/error_codes.cpp
+++ b/ydb/core/tx/data_events/common/error_codes.cpp
@@ -13,6 +13,8 @@ TConclusion<NErrorCodes::TOperator::TYdbStatusInfo> TOperator::GetStatusInfo(
             return TYdbStatusInfo(Ydb::StatusIds::ABORTED, NYql::TIssuesIds::KIKIMR_OPERATION_ABORTED, "Request aborted");
         case NKikimrDataEvents::TEvWriteResult::STATUS_DISK_SPACE_EXHAUSTED:
             return TYdbStatusInfo(Ydb::StatusIds::INTERNAL_ERROR, NYql::TIssuesIds::KIKIMR_DISK_SPACE_EXHAUSTED, "Disk space exhausted");
+        case NKikimrDataEvents::TEvWriteResult::STATUS_OUT_OF_SPACE:
+            return TYdbStatusInfo(Ydb::StatusIds::OVERLOADED, NYql::TIssuesIds::KIKIMR_OVERLOADED, "Out of space");
         case NKikimrDataEvents::TEvWriteResult::STATUS_INTERNAL_ERROR:
             return TYdbStatusInfo(Ydb::StatusIds::INTERNAL_ERROR, NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR, "Request aborted");
         case NKikimrDataEvents::TEvWriteResult::STATUS_OVERLOADED:
@@ -29,8 +31,8 @@ TConclusion<NErrorCodes::TOperator::TYdbStatusInfo> TOperator::GetStatusInfo(
         case NKikimrDataEvents::TEvWriteResult::STATUS_WRONG_SHARD_STATE:
             return TYdbStatusInfo(Ydb::StatusIds::PRECONDITION_FAILED, NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED, "Wrong shard state");
         case NKikimrDataEvents::TEvWriteResult::STATUS_CONSTRAINT_VIOLATION:
-            return TYdbStatusInfo(Ydb::StatusIds::PRECONDITION_FAILED, NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED, "Constraint violated");
+            return TYdbStatusInfo(Ydb::StatusIds::PRECONDITION_FAILED, NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION, "Constraint violated");
     }
 }
 
-}
\ No newline at end of file
+}
diff --git a/ydb/core/tx/data_events/common/signals_flow.cpp b/ydb/core/tx/data_events/common/signals_flow.cpp
index cbe1839dcd4f..d043c9c4a98c 100644
--- a/ydb/core/tx/data_events/common/signals_flow.cpp
+++ b/ydb/core/tx/data_events/common/signals_flow.cpp
@@ -18,7 +18,7 @@ TWriteFlowCounters::TWriteFlowCounters()
         for (auto&& to : GetEnumAllValues<EWriteStage>()) {
             auto subTo = sub.CreateSubGroup("stage_to", ::ToString(to));
             CountByStageMoving.back().emplace_back(subTo.GetDeriviative("Transfers/Count"));
-            CountByStageDuration.back().emplace_back(subTo.GetDeriviative("Transfers/Count"));
+            CountByStageDuration.back().emplace_back(subTo.GetDeriviative("Transfers/Duration/Ms"));
         }
     }
 }
diff --git a/ydb/core/tx/data_events/common/signals_flow.h b/ydb/core/tx/data_events/common/signals_flow.h
index 4cd74a3c5f3a..fcf6b9426819 100644
--- a/ydb/core/tx/data_events/common/signals_flow.h
+++ b/ydb/core/tx/data_events/common/signals_flow.h
@@ -1,5 +1,5 @@
 #pragma once
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 
 namespace NKikimr::NEvWrite {
 
@@ -13,7 +13,8 @@ enum class EWriteStage {
     BuildSlicesPack,
     Result,
     Finished,
-    Aborted
+    Aborted,
+    Replied
 };
 
 class TWriteFlowCounters: public NColumnShard::TCommonCountersOwner {
diff --git a/ydb/core/tx/data_events/events.h b/ydb/core/tx/data_events/events.h
index 87279ec784f0..eeff29d2bf77 100644
--- a/ydb/core/tx/data_events/events.h
+++ b/ydb/core/tx/data_events/events.h
@@ -2,14 +2,18 @@
 
 #include <library/cpp/lwtrace/shuttle.h>
 
-#include <ydb/core/scheme/scheme_tabledefs.h>
-#include <ydb/core/protos/data_events.pb.h>
 #include <ydb/core/base/events.h>
+#include <ydb/core/protos/data_events.pb.h>
+#include <ydb/core/scheme/scheme_tabledefs.h>
+#include <ydb/core/tx/data_events/common/error_codes.h>
 #include <ydb/public/api/protos/ydb_issue_message.pb.h>
 
 #include <ydb/library/accessor/accessor.h>
 #include <ydb/library/actors/core/event_pb.h>
 #include <ydb/library/actors/core/log.h>
+#include <yql/essentials/core/issue/yql_issue.h>
+
+#include <yql/essentials/public/issue/yql_issue_message.h>
 
 namespace NKikimr::NEvents {
 
@@ -100,8 +104,11 @@ struct TDataEvents {
             result->Record.SetOrigin(origin);
             result->Record.SetTxId(txId);
             result->Record.SetStatus(status);
-            auto issue = result->Record.AddIssues();
-            issue->set_message(errorMsg);
+            NYql::TIssue issue(errorMsg);
+            if (const auto statusConclusion = NKikimr::NEvWrite::NErrorCodes::TOperator::GetStatusInfo(status); statusConclusion.IsSuccess()) {
+                NYql::SetIssueCode(statusConclusion->GetIssueCode(), issue);
+            }
+            NYql::IssueToMessage(issue, result->Record.AddIssues());
             return result;
         }
 
diff --git a/ydb/core/tx/data_events/shard_writer.cpp b/ydb/core/tx/data_events/shard_writer.cpp
index d4d38101e6be..1ce27af0d670 100644
--- a/ydb/core/tx/data_events/shard_writer.cpp
+++ b/ydb/core/tx/data_events/shard_writer.cpp
@@ -29,12 +29,10 @@ namespace NKikimr::NEvWrite {
     void TWritersController::OnFail(const Ydb::StatusIds::StatusCode code, const TString& message) {
         Counters->OnCSFailed(code);
         FailsCount.Inc();
-        if (!Code) {
-            TGuard<TMutex> g(Mutex);
-            if (!Code) {
-                Issues.AddIssue(message);
-                Code = code;
-            }
+        if (AtomicCas(&HasCodeFail, 1, 0)) {
+            AFL_VERIFY(!Code);
+            Issues.AddIssue(message);
+            Code = code;
         }
         if (!WritesCount.Dec()) {
             SendReply();
diff --git a/ydb/core/tx/data_events/shard_writer.h b/ydb/core/tx/data_events/shard_writer.h
index b3c53d3d36d7..595d61e7c5e2 100644
--- a/ydb/core/tx/data_events/shard_writer.h
+++ b/ydb/core/tx/data_events/shard_writer.h
@@ -6,7 +6,7 @@
 #include "common/modification_type.h"
 
 #include <ydb/core/base/tablet_pipecache.h>
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 #include <ydb/core/tx/long_tx_service/public/events.h>
 
 #include <ydb/library/accessor/accessor.h>
@@ -105,9 +105,11 @@ class TWritersController {
     TAtomicCounter WritesCount = 0;
     TAtomicCounter WritesIndex = 0;
     TAtomicCounter FailsCount = 0;
-    TMutex Mutex;
+
+    TAtomic HasCodeFail = 0;
     NYql::TIssues Issues;
     std::optional<Ydb::StatusIds::StatusCode> Code;
+
     NActors::TActorIdentity LongTxActorId;
     std::vector<TWriteIdForShard> WriteIds;
     const TMonotonic StartInstant = TMonotonic::Now();
diff --git a/ydb/core/tx/data_events/write_data.cpp b/ydb/core/tx/data_events/write_data.cpp
index 4e05aeccea73..f3779a1cb5af 100644
--- a/ydb/core/tx/data_events/write_data.cpp
+++ b/ydb/core/tx/data_events/write_data.cpp
@@ -21,10 +21,13 @@ TWriteData::TWriteData(const std::shared_ptr<TWriteMeta>& writeMeta, IDataContai
 }
 
 void TWriteMeta::OnStage(const EWriteStage stage) const {
-    AFL_VERIFY(CurrentStage != EWriteStage::Finished && CurrentStage != EWriteStage::Aborted);
+    if (stage == CurrentStage) {
+        return;
+    }
     AFL_VERIFY((ui32)stage > (ui32)CurrentStage)("from", CurrentStage)("to", stage);
     const TMonotonic nextStageInstant = TMonotonic::Now();
     Counters->OnStageMove(CurrentStage, stage, nextStageInstant - LastStageInstant);
+    CurrentStage = stage;
     LastStageInstant = nextStageInstant;
     if (stage == EWriteStage::Finished) {
         Counters->OnWriteFinished(nextStageInstant - WriteStartInstant);
diff --git a/ydb/core/tx/data_events/write_data.h b/ydb/core/tx/data_events/write_data.h
index 56407661b1ce..33af6e744eb1 100644
--- a/ydb/core/tx/data_events/write_data.h
+++ b/ydb/core/tx/data_events/write_data.h
@@ -4,7 +4,7 @@
 
 #include <ydb/core/formats/arrow/arrow_helpers.h>
 #include <ydb/core/formats/arrow/reader/position.h>
-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>
+#include <ydb/library/signals/object_counter.h>
 #include <ydb/core/tx/long_tx_service/public/types.h>
 
 #include <ydb/library/accessor/accessor.h>
@@ -58,8 +58,8 @@ class TWriteMeta: public NColumnShard::TMonitoringObjectsCounter<TWriteMeta>, TN
     void OnStage(const EWriteStage stage) const;
 
     ~TWriteMeta() {
-        if (CurrentStage != EWriteStage::Finished && CurrentStage != EWriteStage::Aborted) {
-            Counters->OnWriteAborted(TMonotonic::Now() - WriteStartInstant);
+        if (CurrentStage != EWriteStage::Replied) {
+            OnStage(EWriteStage::Aborted);
         }
     }
 
diff --git a/ydb/core/tx/datashard/check_write_unit.cpp b/ydb/core/tx/datashard/check_write_unit.cpp
index 303d136b4ff9..6cf2b2b02938 100644
--- a/ydb/core/tx/datashard/check_write_unit.cpp
+++ b/ydb/core/tx/datashard/check_write_unit.cpp
@@ -65,7 +65,7 @@ EExecutionStatus TCheckWriteUnit::Execute(TOperation::TPtr op,
 
         DataShard.IncCounter(COUNTER_WRITE_OUT_OF_SPACE);
 
-        writeOp->SetError(NKikimrDataEvents::TEvWriteResult::STATUS_OVERLOADED, err);
+        writeOp->SetError(NKikimrDataEvents::TEvWriteResult::STATUS_OUT_OF_SPACE, err);
         op->Abort(EExecutionUnitKind::FinishProposeWrite);
 
         DataShard.SetOverloadSubscribed(writeOp->GetWriteTx()->GetOverloadSubscribe(), writeOp->GetRecipient(), op->GetTarget(), ERejectReasons::YellowChannels, writeOp->GetWriteResult()->Record);
@@ -115,7 +115,7 @@ EExecutionStatus TCheckWriteUnit::Execute(TOperation::TPtr op,
         if (!Pipeline.AssignPlanInterval(op)) {
             TString err = TStringBuilder() << "Can't propose tx " << op->GetTxId() << " at blocked shard " << DataShard.TabletID();
 
-            writeOp->SetError(NKikimrDataEvents::TEvWriteResult::STATUS_INTERNAL_ERROR, err);
+            writeOp->SetError(NKikimrDataEvents::TEvWriteResult::STATUS_OVERLOADED, err);
             op->Abort(EExecutionUnitKind::FinishProposeWrite);
 
             LOG_NOTICE_S(ctx, NKikimrServices::TX_DATASHARD, err);
diff --git a/ydb/core/tx/datashard/datashard.h b/ydb/core/tx/datashard/datashard.h
index 37143a514cf2..1f2b0973d245 100644
--- a/ydb/core/tx/datashard/datashard.h
+++ b/ydb/core/tx/datashard/datashard.h
@@ -349,6 +349,9 @@ namespace TEvDataShard {
         EvForceDataCleanup,
         EvForceDataCleanupResult,
 
+        EvPrefixKMeansRequest,
+        EvPrefixKMeansResponse,
+
         EvEnd
     };
 
@@ -1514,6 +1517,18 @@ namespace TEvDataShard {
                           TEvDataShard::EvLocalKMeansResponse> {
     };
 
+    struct TEvPrefixKMeansRequest
+        : public TEventPB<TEvPrefixKMeansRequest,
+                          NKikimrTxDataShard::TEvPrefixKMeansRequest,
+                          TEvDataShard::EvPrefixKMeansRequest> {
+    };
+
+    struct TEvPrefixKMeansResponse
+        : public TEventPB<TEvPrefixKMeansResponse,
+                          NKikimrTxDataShard::TEvPrefixKMeansResponse,
+                          TEvDataShard::EvPrefixKMeansResponse> {
+    };
+
     struct TEvKqpScan
         : public TEventPB<TEvKqpScan,
                           NKikimrTxDataShard::TEvKqpScan,
diff --git a/ydb/core/tx/datashard/datashard__read_iterator.cpp b/ydb/core/tx/datashard/datashard__read_iterator.cpp
index 263caa364af0..a85007280560 100644
--- a/ydb/core/tx/datashard/datashard__read_iterator.cpp
+++ b/ydb/core/tx/datashard/datashard__read_iterator.cpp
@@ -2326,7 +2326,7 @@ class TDataShard::TReadOperation : public TOperation, public IReadOperation {
             sysLocks.BreakSetLocks();
         }
 
-        auto locks = sysLocks.ApplyLocks();
+        auto [locks, _] = sysLocks.ApplyLocks();
 
         for (auto& lock : locks) {
             NKikimrDataEvents::TLock* addLock;
@@ -2958,7 +2958,7 @@ class TDataShard::TTxReadContinue : public NTabletFlatExecutor::TTransactionBase
                 state.Lock = nullptr;
             } else {
                 // Lock valid, apply conflict changes
-                auto locks = sysLocks.ApplyLocks();
+                auto [locks, _] = sysLocks.ApplyLocks();
                 Y_ABORT_UNLESS(locks.empty(), "ApplyLocks acquired unexpected locks");
             }
         }
diff --git a/ydb/core/tx/datashard/datashard_impl.h b/ydb/core/tx/datashard/datashard_impl.h
index c36c6331bb1f..3381708b9a0a 100644
--- a/ydb/core/tx/datashard/datashard_impl.h
+++ b/ydb/core/tx/datashard/datashard_impl.h
@@ -250,6 +250,7 @@ class TDataShard
     class TTxHandleSafeBuildIndexScan;
     class TTxHandleSafeSampleKScan;
     class TTxHandleSafeLocalKMeansScan;
+    class TTxHandleSafePrefixKMeansScan;
     class TTxHandleSafeReshuffleKMeansScan;
     class TTxHandleSafeStatisticsScan;
 
@@ -1335,6 +1336,8 @@ class TDataShard
     void HandleSafe(TEvDataShard::TEvReshuffleKMeansRequest::TPtr& ev, const TActorContext& ctx);
     void Handle(TEvDataShard::TEvLocalKMeansRequest::TPtr& ev, const TActorContext& ctx);
     void HandleSafe(TEvDataShard::TEvLocalKMeansRequest::TPtr& ev, const TActorContext& ctx);
+    void Handle(TEvDataShard::TEvPrefixKMeansRequest::TPtr& ev, const TActorContext& ctx);
+    void HandleSafe(TEvDataShard::TEvPrefixKMeansRequest::TPtr& ev, const TActorContext& ctx);
     void Handle(TEvDataShard::TEvCdcStreamScanRequest::TPtr& ev, const TActorContext& ctx);
     void Handle(TEvPrivate::TEvCdcStreamScanRegistered::TPtr& ev, const TActorContext& ctx);
     void Handle(TEvPrivate::TEvCdcStreamScanProgress::TPtr& ev, const TActorContext& ctx);
@@ -3197,6 +3200,7 @@ class TDataShard
             HFunc(TEvDataShard::TEvSampleKRequest, Handle);
             HFunc(TEvDataShard::TEvReshuffleKMeansRequest, Handle);
             HFunc(TEvDataShard::TEvLocalKMeansRequest, Handle);
+            HFunc(TEvDataShard::TEvPrefixKMeansRequest, Handle);
             HFunc(TEvDataShard::TEvCdcStreamScanRequest, Handle);
             HFunc(TEvPrivate::TEvCdcStreamScanRegistered, Handle);
             HFunc(TEvPrivate::TEvCdcStreamScanProgress, Handle);
diff --git a/ydb/core/tx/datashard/datashard_integrity_trails.h b/ydb/core/tx/datashard/datashard_integrity_trails.h
index de0a65569af4..0883b7f8d92c 100644
--- a/ydb/core/tx/datashard/datashard_integrity_trails.h
+++ b/ydb/core/tx/datashard/datashard_integrity_trails.h
@@ -126,6 +126,32 @@ inline void LogIntegrityTrailsKeys(const NActors::TActorContext& ctx, const ui64
     }
 }
 
+inline void LogIntegrityTrailsLocks(const TActorContext& ctx, const ui64 tabletId, const ui64 txId, const TVector<ui64>& locks) {
+    if (locks.empty()) {
+        return;
+    }
+
+    auto logFn = [&]() {
+        TStringStream ss;
+
+        LogKeyValue("Component", "DataShard", ss);
+        LogKeyValue("Type", "Locks", ss);
+        LogKeyValue("TabletId", ToString(tabletId), ss);
+        LogKeyValue("PhyTxId", ToString(txId), ss);
+
+        ss << "BreakLocks: [";
+        for (const auto& lock : locks) {
+            ss << lock << " ";
+        }
+        ss << "]";
+
+        return ss.Str();
+    };
+
+    LOG_INFO_S(ctx, NKikimrServices::DATA_INTEGRITY, logFn());
+
+}
+
 template <typename TxResult>
 inline void LogIntegrityTrailsFinish(const NActors::TActorContext& ctx, const ui64 tabletId, const ui64 txId, const typename TxResult::EStatus status) {
     auto logFn = [&]() {
diff --git a/ydb/core/tx/datashard/datashard_ut_change_exchange.cpp b/ydb/core/tx/datashard/datashard_ut_change_exchange.cpp
index 9981bd2ce3fe..7580867e814f 100644
--- a/ydb/core/tx/datashard/datashard_ut_change_exchange.cpp
+++ b/ydb/core/tx/datashard/datashard_ut_change_exchange.cpp
@@ -2434,6 +2434,14 @@ Y_UNIT_TEST_SUITE(Cdc) {
                     }
                 }
                 return TTestActorRuntime::EEventAction::PROCESS;
+            
+            case NKikimr::NEvents::TDataEvents::EvWriteResult:
+                if (auto* msg = ev->Get<NKikimr::NEvents::TDataEvents::TEvWriteResult>()) {
+                    if (msg->GetStatus() == NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED) {
+                        txCompleted = true;
+                    }
+                }
+                return TTestActorRuntime::EEventAction::PROCESS;
 
             case TEvChangeExchange::EvSplitAck:
                 splitAcked = true;
diff --git a/ydb/core/tx/datashard/datashard_ut_kqp_errors.cpp b/ydb/core/tx/datashard/datashard_ut_kqp_errors.cpp
index 58bda03fd2ab..9094c940a6a6 100644
--- a/ydb/core/tx/datashard/datashard_ut_kqp_errors.cpp
+++ b/ydb/core/tx/datashard/datashard_ut_kqp_errors.cpp
@@ -16,12 +16,12 @@ using namespace NKikimrTxDataShard;
 
 namespace {
 
-bool HasIssue(const TIssues& issues, ui32 code, TStringBuf message, std::function<bool(const TIssue& issue)> predicate = {}) {
+bool HasIssueImpl(const TIssues& issues, ui32 code, TStringBuf message, std::function<bool(const TIssue& issue)> predicate, bool contains) {
     bool hasIssue = false;
 
     for (auto& issue : issues) {
         WalkThroughIssues(issue, false, [&] (const TIssue& issue, int) {
-            if (!hasIssue && issue.GetCode() == code && (!message || message == issue.GetMessage())) {
+            if (!hasIssue && issue.GetCode() == code && (!message || message == issue.GetMessage() || (contains && issue.GetMessage().Contains(message)))) {
                 hasIssue = !predicate || predicate(issue);
             }
         });
@@ -30,14 +30,25 @@ bool HasIssue(const TIssues& issues, ui32 code, TStringBuf message, std::functio
     return hasIssue;
 }
 
+bool HasIssue(const TIssues& issues, ui32 code, TStringBuf message, std::function<bool(const TIssue& issue)> predicate = {}) {
+    return HasIssueImpl(issues, code, message, predicate, false);
+}
+
+bool HasIssueContains(const TIssues& issues, ui32 code, TStringBuf message, std::function<bool(const TIssue& issue)> predicate = {}) {
+    return HasIssueImpl(issues, code, message, predicate, true);
+}
+
 } // anonymous namespace
 
 class TLocalFixture {
 public:
-    TLocalFixture(bool enableResourcePools = true) {
+    TLocalFixture(bool enableResourcePools = true, std::optional<bool> enableOltpSink = std::nullopt) {
         TPortManager pm;
         NKikimrConfig::TAppConfig app;
         app.MutableFeatureFlags()->SetEnableResourcePools(enableResourcePools);
+        if (enableOltpSink) {
+            app.MutableTableServiceConfig()->SetEnableOltpSink(*enableOltpSink);
+        }
         TServerSettings serverSettings(pm.GetPort(2134));
         serverSettings.SetDomainName("Root")
             .SetNodeCount(2)
@@ -112,7 +123,7 @@ Y_UNIT_TEST(ResolveTableError) {
 }
 
 Y_UNIT_TEST(ProposeError) {
-    TLocalFixture fixture;
+    TLocalFixture fixture(true, false);
     THashSet<TActorId> knownExecuters;
 
     using TMod = std::function<void(NKikimrTxDataShard::TEvProposeTransactionResult&)>;
@@ -227,6 +238,107 @@ Y_UNIT_TEST(ProposeError) {
             "Error executing transaction: transaction failed.");
 }
 
+Y_UNIT_TEST(ProposeErrorEvWrite) {
+    TLocalFixture fixture(true, true);
+    THashSet<TActorId> knownExecuters;
+
+    using TMod = std::function<void(NKikimrDataEvents::TEvWriteResult&)>;
+
+    auto test = [&](auto proposeStatus, auto ydbStatus, auto issue, auto issueMessage, TMod mod = {}) {
+        auto client = fixture.Runtime->AllocateEdgeActor();
+
+        bool done = false;
+        auto mitm = [&](TAutoPtr<IEventHandle> &ev) {
+            if (!done && ev->GetTypeRewrite() == NKikimr::NEvents::TDataEvents::TEvWriteResult::EventType &&
+                !knownExecuters.contains(ev->Recipient))
+            {
+                auto event = ev.Get()->Get<NKikimr::NEvents::TDataEvents::TEvWriteResult>();
+                event->Record.SetStatus(proposeStatus);
+                if (mod) {
+                    mod(event->Record);
+                }
+                knownExecuters.insert(ev->Recipient);
+                done = true;
+            }
+            return TTestActorRuntime::EEventAction::PROCESS;
+        };
+        fixture.Runtime->SetObserverFunc(mitm);
+
+        SendRequest(*fixture.Runtime, client, MakeSQLRequest(Q_("upsert into `/Root/table-1` (key, value) values (5, 5);")));
+
+        auto ev = fixture.Runtime->GrabEdgeEventRethrow<NKqp::TEvKqp::TEvQueryResponse>(client);
+        auto& record = ev->Get()->Record;
+        UNIT_ASSERT_VALUES_EQUAL_C(record.GetYdbStatus(), ydbStatus, record.DebugString());
+
+        // Cerr << record.DebugString() << Endl;
+
+        TIssues issues;
+        IssuesFromMessage(record.GetResponse().GetQueryIssues(), issues);
+        UNIT_ASSERT_C(HasIssueContains(issues, issue, issueMessage), "issue not found, issue: " << (int) issue
+            << ", message: " << issueMessage << ", response: " << record.GetResponse().DebugString());
+    };
+
+    test(NKikimrDataEvents::TEvWriteResult::STATUS_OVERLOADED,                    // propose error
+         Ydb::StatusIds::OVERLOADED,                                 // ydb status
+         NYql::TIssuesIds::KIKIMR_OVERLOADED,                        // issue status
+         "Kikimr cluster or one of its subsystems is overloaded.");  // main issue message (more detailed info can be in subissues)
+
+    test(NKikimrDataEvents::TEvWriteResult::STATUS_UNSPECIFIED,
+         Ydb::StatusIds::STATUS_CODE_UNSPECIFIED,
+         NYql::TIssuesIds::DEFAULT_ERROR,
+         "Unspecified error.");
+
+    test(NKikimrDataEvents::TEvWriteResult::STATUS_ABORTED,
+         Ydb::StatusIds::ABORTED,
+         NYql::TIssuesIds::KIKIMR_OPERATION_ABORTED,
+         "Operation aborted.");
+
+    test(NKikimrDataEvents::TEvWriteResult::STATUS_INTERNAL_ERROR,
+         Ydb::StatusIds::INTERNAL_ERROR,
+         NYql::TIssuesIds::KIKIMR_INTERNAL_ERROR,
+         "Internal error while executing transaction.");
+
+    test(NKikimrDataEvents::TEvWriteResult::STATUS_CANCELLED,
+         Ydb::StatusIds::CANCELLED,
+         NYql::TIssuesIds::KIKIMR_OPERATION_CANCELLED,
+         "Operation cancelled.");
+
+    test(NKikimrDataEvents::TEvWriteResult::STATUS_BAD_REQUEST,
+         Ydb::StatusIds::BAD_REQUEST,
+         NYql::TIssuesIds::KIKIMR_BAD_REQUEST,
+         "Bad request.");
+
+    test(NKikimrDataEvents::TEvWriteResult::STATUS_SCHEME_CHANGED,
+         Ydb::StatusIds::ABORTED,
+         NYql::TIssuesIds::KIKIMR_SCHEME_MISMATCH,
+         "Scheme changed.");
+
+    test(NKikimrDataEvents::TEvWriteResult::STATUS_LOCKS_BROKEN,
+         Ydb::StatusIds::ABORTED,
+         NYql::TIssuesIds::KIKIMR_LOCKS_INVALIDATED,
+         "Transaction locks invalidated.");
+    
+    test(NKikimrDataEvents::TEvWriteResult::STATUS_DISK_SPACE_EXHAUSTED,
+         Ydb::StatusIds::UNAVAILABLE,
+         NYql::TIssuesIds::KIKIMR_DISK_SPACE_EXHAUSTED,
+         "Disk space exhausted.");
+
+    test(NKikimrDataEvents::TEvWriteResult::STATUS_WRONG_SHARD_STATE,
+         Ydb::StatusIds::UNAVAILABLE,
+         NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,
+         "Wrong shard state.");
+
+    test(NKikimrDataEvents::TEvWriteResult::STATUS_CONSTRAINT_VIOLATION,
+         Ydb::StatusIds::PRECONDITION_FAILED,
+         NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION,
+         "Constraint violated.");
+    
+    test(NKikimrDataEvents::TEvWriteResult::STATUS_OUT_OF_SPACE,
+         Ydb::StatusIds::OVERLOADED,
+         NYql::TIssuesIds::KIKIMR_OVERLOADED,
+         "out of space.");
+}
+
 void TestProposeResultLost(TTestActorRuntime& runtime, TActorId client, const TString& query,
                            std::function<void(const NKikimrKqp::TEvQueryResponse& resp)> fn)
 {
@@ -236,7 +348,8 @@ void TestProposeResultLost(TTestActorRuntime& runtime, TActorId client, const TS
     auto prev = runtime.SetObserverFunc([&](TAutoPtr<IEventHandle>& ev) {
         if (ev->GetTypeRewrite() == TEvPipeCache::TEvForward::EventType) {
             auto* fe = ev.Get()->Get<TEvPipeCache::TEvForward>();
-            if (fe->Ev->Type() == TEvDataShard::TEvProposeTransaction::EventType) {
+            if (fe->Ev->Type() == TEvDataShard::TEvProposeTransaction::EventType
+                || fe->Ev->Type() == NKikimr::NEvents::TDataEvents::TEvWrite::EventType) {
                 executer = ev->Sender;
                 // Cerr << "-- executer: " << executer << Endl;
                 return TTestActorRuntime::EEventAction::PROCESS;
@@ -256,6 +369,19 @@ void TestProposeResultLost(TTestActorRuntime& runtime, TActorId client, const TS
             }
         }
 
+        if (ev->GetTypeRewrite() == NKikimr::NEvents::TDataEvents::TEvWriteResult::EventType) {
+            auto* msg = ev.Get()->Get<NKikimr::NEvents::TDataEvents::TEvWriteResult>();
+            if (msg->Record.GetStatus() == NKikimrDataEvents::TEvWriteResult::STATUS_PREPARED) {
+                if (ev->Sender.NodeId() == executer.NodeId()) {
+                    ++droppedEvents;
+                    // Cerr << "-- send undelivery to " << ev->Recipient << ", executer: " << executer << Endl;
+                    runtime.Send(new IEventHandle(executer, ev->Sender,
+                        new TEvPipeCache::TEvDeliveryProblem(msg->Record.GetOrigin(), /* NotDelivered */ false)));
+                    return TTestActorRuntime::EEventAction::DROP;
+                }
+            }
+        }
+
         return TTestActorRuntime::EEventAction::PROCESS;
     });
     SendRequest(runtime, client, MakeSQLRequest(query));
@@ -270,8 +396,8 @@ void TestProposeResultLost(TTestActorRuntime& runtime, TActorId client, const TS
     runtime.SetObserverFunc(prev);
 }
 
-Y_UNIT_TEST(ProposeResultLost_RwTx) {
-    TLocalFixture fixture;
+Y_UNIT_TEST_TWIN(ProposeResultLost_RwTx, UseSink) {
+    TLocalFixture fixture(true, UseSink);
     TestProposeResultLost(*fixture.Runtime, fixture.Client,
         Q_(R"(
             upsert into `/Root/table-1` (key, value) VALUES
@@ -283,7 +409,7 @@ Y_UNIT_TEST(ProposeResultLost_RwTx) {
             TIssues issues;
             IssuesFromMessage(record.GetResponse().GetQueryIssues(), issues);
             UNIT_ASSERT_C(
-                HasIssue(issues, NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,
+                HasIssueContains(issues, NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE,
                     "Kikimr cluster or one of its subsystems was unavailable."),
                 record.GetResponse().DebugString());
         });
diff --git a/ydb/core/tx/datashard/datashard_ut_locks.cpp b/ydb/core/tx/datashard/datashard_ut_locks.cpp
index 60f3ed8b03d9..e512e223e6dd 100644
--- a/ydb/core/tx/datashard/datashard_ut_locks.cpp
+++ b/ydb/core/tx/datashard/datashard_ut_locks.cpp
@@ -201,7 +201,7 @@ namespace NTest {
         }
 
         TVector<TSysLocks::TLock> ApplyTxLocks() {
-            auto locks = Locks.ApplyLocks();
+            auto [locks, _] = Locks.ApplyLocks();
             Locks.ResetUpdate();
             return locks;
         }
diff --git a/ydb/core/tx/datashard/datashard_ut_order.cpp b/ydb/core/tx/datashard/datashard_ut_order.cpp
index 1ff5e1f32f25..25f943ebf894 100644
--- a/ydb/core/tx/datashard/datashard_ut_order.cpp
+++ b/ydb/core/tx/datashard/datashard_ut_order.cpp
@@ -1352,6 +1352,7 @@ Y_UNIT_TEST(TestOutOfOrderLockLost) {
 Y_UNIT_TEST_TWIN(TestOutOfOrderReadOnlyAllowed, EvWrite) {
     TPortManager pm;
     NKikimrConfig::TAppConfig app;
+    app.MutableTableServiceConfig()->SetEnableOltpSink(EvWrite);
     TServerSettings serverSettings(pm.GetPort(2134));
     serverSettings.SetDomainName("Root")
         .SetUseRealThreads(false)
@@ -1372,9 +1373,6 @@ Y_UNIT_TEST_TWIN(TestOutOfOrderReadOnlyAllowed, EvWrite) {
     auto [shards2, tableId2] = CreateShardedTable(server, sender, "/Root", "table-2", 1);
 
     {
-        auto rows = EvWrite ? TEvWriteRows{{tableId1, {1, 1}}, {tableId2, {2, 1}}} : TEvWriteRows{};
-        auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(runtime, rows);
-
         ExecSQL(server, sender, Q_("UPSERT INTO `/Root/table-1` (key, value) VALUES (1, 1);"));
         ExecSQL(server, sender, Q_("UPSERT INTO `/Root/table-2` (key, value) VALUES (2, 1);"));
     }
@@ -1405,16 +1403,11 @@ Y_UNIT_TEST_TWIN(TestOutOfOrderReadOnlyAllowed, EvWrite) {
     };
     auto prevObserverFunc = runtime.SetObserverFunc(captureRS);
 
-    auto rows = EvWrite ? TEvWriteRows{{tableId1, {3, 2}}, {tableId2, {4, 2}}} : TEvWriteRows{};
-    auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(runtime, rows);
-
     // Send a commit request, it would block on readset exchange
     auto f2 = SendRequest(runtime, MakeSimpleRequestRPC(Q_(R"(
         UPSERT INTO `/Root/table-1` (key, value) VALUES (3, 2);
         UPSERT INTO `/Root/table-2` (key, value) VALUES (4, 2))"), sessionId, txId, true));
 
-    evWriteObservers = TTestActorRuntimeBase::TEventObserverHolderPair{};
-
     // Wait until we captured both readsets
     const size_t expectedReadSets = usesVolatileTxs ? 4 : 2;
     {
@@ -1464,6 +1457,7 @@ Y_UNIT_TEST_TWIN(TestOutOfOrderReadOnlyAllowed, EvWrite) {
 Y_UNIT_TEST_TWIN(TestOutOfOrderNonConflictingWrites, EvWrite) {
     TPortManager pm;
     NKikimrConfig::TAppConfig app;
+    app.MutableTableServiceConfig()->SetEnableOltpSink(EvWrite);
     TServerSettings serverSettings(pm.GetPort(2134));
     serverSettings.SetDomainName("Root")
         .SetAppConfig(app)
@@ -1484,9 +1478,6 @@ Y_UNIT_TEST_TWIN(TestOutOfOrderNonConflictingWrites, EvWrite) {
     auto [shards2, tableId2] = CreateShardedTable(server, sender, "/Root", "table-2", 1);
 
     {
-        auto rows = EvWrite ? TEvWriteRows{{tableId1, {1, 1}}, {tableId2, {2, 1}}} : TEvWriteRows{};
-        auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(runtime, rows);
-
         ExecSQL(server, sender, Q_("UPSERT INTO `/Root/table-1` (key, value) VALUES (1, 1);"));
         ExecSQL(server, sender, Q_("UPSERT INTO `/Root/table-2` (key, value) VALUES (2, 1);"));
     }
@@ -1518,16 +1509,11 @@ Y_UNIT_TEST_TWIN(TestOutOfOrderNonConflictingWrites, EvWrite) {
     };
     auto prevObserverFunc = runtime.SetObserverFunc(captureRS);
 
-    auto rows = EvWrite ? TEvWriteRows{{tableId1, {3, 2}}, {tableId2, {4, 2}}} : TEvWriteRows{};
-    auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(runtime, rows);
-
     // Send a commit request, it would block on readset exchange
     auto f2 = SendRequest(runtime, MakeSimpleRequestRPC(Q_(R"(
         UPSERT INTO `/Root/table-1` (key, value) VALUES (3, 2);
         UPSERT INTO `/Root/table-2` (key, value) VALUES (4, 2))"), sessionId, txId, true));
 
-    evWriteObservers = TTestActorRuntimeBase::TEventObserverHolderPair{};
-
     // Wait until we captured both readsets
     const size_t expectedReadSets = usesVolatileTxs ? 4 : 2;
     if (readSets.size() < expectedReadSets) {
@@ -1542,9 +1528,6 @@ Y_UNIT_TEST_TWIN(TestOutOfOrderNonConflictingWrites, EvWrite) {
 
     // Now send non-conflicting upsert to both tables
     {
-        auto rows1 = EvWrite ? TEvWriteRows{{tableId1, {5, 3}}, {tableId2, {6, 3}}} : TEvWriteRows{};
-        auto evWriteObservers1 = ReplaceEvProposeTransactionWithEvWrite(runtime, rows1);
-
         blockReadSets = false;  // needed for volatile transactions
         auto result = KqpSimpleExec(runtime, Q_(R"(
             UPSERT INTO `/Root/table-1` (key, value) VALUES (5, 3);
@@ -1555,9 +1538,6 @@ Y_UNIT_TEST_TWIN(TestOutOfOrderNonConflictingWrites, EvWrite) {
 
     // Check that immediate non-conflicting upsert is working too
     {
-        auto rows1 = EvWrite ? TEvWriteRows{{tableId1, {7, 4}}} : TEvWriteRows{};
-        auto evWriteObservers1 = ReplaceEvProposeTransactionWithEvWrite(runtime, rows1);
-
         auto result = KqpSimpleExec(runtime, Q_("UPSERT INTO `/Root/table-1` (key, value) VALUES (7, 4)"));
         UNIT_ASSERT_VALUES_EQUAL(result, "<empty>");
     }
@@ -2040,11 +2020,14 @@ Y_UNIT_TEST(TestPlannedTimeoutSplit) {
     }
 }
 
-Y_UNIT_TEST(TestPlannedHalfOverloadedSplit) {
+Y_UNIT_TEST_TWIN(TestPlannedHalfOverloadedSplit, UseSink) {
     TPortManager pm;
     TServerSettings serverSettings(pm.GetPort(2134));
+    NKikimrConfig::TAppConfig app;
+    app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
     serverSettings.SetDomainName("Root")
-        .SetUseRealThreads(false);
+        .SetUseRealThreads(false)
+        .SetAppConfig(app);
 
     Tests::TServer::TPtr server = new TServer(serverSettings);
     auto &runtime = *server->GetRuntime();
@@ -2075,7 +2058,8 @@ Y_UNIT_TEST(TestPlannedHalfOverloadedSplit) {
     TVector<THolder<IEventHandle>> txProposeResults;
     auto captureMessages = [&](TAutoPtr<IEventHandle> &event) -> auto {
         switch (event->GetTypeRewrite()) {
-            case TEvDataShard::EvProposeTransaction: {
+            case TEvDataShard::EvProposeTransaction:
+            case NKikimr::NEvents::TDataEvents::EvWrite: {
                 Cerr << "---- observed EvProposeTransactionResult ----" << Endl;
                 if (txProposes.size() == 0) {
                     // Capture the first propose
@@ -2084,7 +2068,8 @@ Y_UNIT_TEST(TestPlannedHalfOverloadedSplit) {
                 }
                 break;
             }
-            case TEvDataShard::EvProposeTransactionResult: {
+            case TEvDataShard::EvProposeTransactionResult:
+            case NKikimr::NEvents::TDataEvents::EvWriteResult: {
                 Cerr << "---- observed EvProposeTransactionResult ----" << Endl;
                 if (txProposes.size() > 0) {
                     // Capture all propose results
@@ -2472,11 +2457,14 @@ Y_UNIT_TEST(TestReadTableSingleShardImmediate) {
     UNIT_ASSERT_VALUES_EQUAL(seenPlanSteps, 0u);
 }
 
-Y_UNIT_TEST(TestImmediateQueueThenSplit) {
+Y_UNIT_TEST_TWIN(TestImmediateQueueThenSplit, UseSink) {
     TPortManager pm;
     TServerSettings serverSettings(pm.GetPort(2134));
+    NKikimrConfig::TAppConfig app;
+    app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
     serverSettings.SetDomainName("Root")
-        .SetUseRealThreads(false);
+        .SetUseRealThreads(false)
+        .SetAppConfig(app);
 
     Tests::TServer::TPtr server = new TServer(serverSettings);
     auto &runtime = *server->GetRuntime();
@@ -2519,6 +2507,7 @@ Y_UNIT_TEST(TestImmediateQueueThenSplit) {
                 }
                 break;
             case TEvDataShard::EvProposeTransaction:
+            case NKikimr::NEvents::TDataEvents::EvWrite:
                 if (capturePropose) {
                     Cerr << "---- capture EvProposeTransaction ----" << Endl;
                     eventsPropose.emplace_back(event.Release());
@@ -2640,10 +2629,11 @@ Y_UNIT_TEST(TestImmediateQueueThenSplit) {
         << failures << " failures");
 }
 
-void TestLateKqpQueryAfterColumnDrop(bool dataQuery, const TString& query) {
+void TestLateKqpQueryAfterColumnDrop(bool dataQuery, bool useSink, const TString& query) {
     TPortManager pm;
     NKikimrConfig::TAppConfig app;
     app.MutableTableServiceConfig()->SetEnableKqpScanQuerySourceRead(false);
+    app.MutableTableServiceConfig()->SetEnableOltpSink(useSink);
     TServerSettings serverSettings(pm.GetPort(2134));
     serverSettings.SetDomainName("Root")
         .SetUseRealThreads(false)
@@ -2691,6 +2681,15 @@ void TestLateKqpQueryAfterColumnDrop(bool dataQuery, const TString& query) {
                 break;
             }
 
+            case NKikimr::NEvents::TDataEvents::EvWrite: {
+                if (capturePropose) {
+                    Cerr << "---- capture EvWrite ----" << Endl;
+                    eventsPropose.emplace_back(ev.Release());
+                    return TTestActorRuntime::EEventAction::DROP;
+                }
+                break;
+            }
+
             case TEvDataShard::EvKqpScan: {
                 if (capturePropose) {
                     Cerr << "---- capture EvKqpScan ----" << Endl;
@@ -2755,8 +2754,8 @@ void TestLateKqpQueryAfterColumnDrop(bool dataQuery, const TString& query) {
     }
 }
 
-Y_UNIT_TEST(TestLateKqpScanAfterColumnDrop) {
-    TestLateKqpQueryAfterColumnDrop(false, "SELECT SUM(value2) FROM `/Root/table-1`");
+Y_UNIT_TEST_TWIN(TestLateKqpScanAfterColumnDrop, UseSink) {
+    TestLateKqpQueryAfterColumnDrop(false, UseSink, "SELECT SUM(value2) FROM `/Root/table-1`");
 }
 
 Y_UNIT_TEST(TestSecondaryClearanceAfterShardRestartRace) {
@@ -2963,6 +2962,7 @@ Y_UNIT_TEST(TestShardRestartNoUndeterminedImmediate) {
 Y_UNIT_TEST_TWIN(TestShardRestartPlannedCommitShouldSucceed, EvWrite) {
     TPortManager pm;
     NKikimrConfig::TAppConfig app;
+    app.MutableTableServiceConfig()->SetEnableOltpSink(EvWrite);
     TServerSettings serverSettings(pm.GetPort(2134));
     serverSettings.SetDomainName("Root")
         .SetUseRealThreads(false)
@@ -2983,9 +2983,6 @@ Y_UNIT_TEST_TWIN(TestShardRestartPlannedCommitShouldSucceed, EvWrite) {
     auto [shards2, tableId2] = CreateShardedTable(server, sender, "/Root", "table-2", 1);
 
     {
-        auto rows = EvWrite ? TEvWriteRows{{tableId1, {1, 1}}, {tableId2, {2, 1}}} : TEvWriteRows{};
-        auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(runtime, rows);
-
         Cerr << "===== UPSERT initial rows" << Endl;
 
         ExecSQL(server, sender, Q_("UPSERT INTO `/Root/table-1` (key, value) VALUES (1, 1)"));
@@ -3035,9 +3032,6 @@ Y_UNIT_TEST_TWIN(TestShardRestartPlannedCommitShouldSucceed, EvWrite) {
     };
     auto prevObserverFunc = runtime.SetObserverFunc(captureRS);
 
-    auto rows = EvWrite ? TEvWriteRows{{tableId1, {3, 2}}, {tableId2, {4, 2}}} : TEvWriteRows{};
-    auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(runtime, rows);
-
     Cerr << "===== UPSERT and commit" << Endl;
 
     // Send a commit request, it would block on readset exchange
@@ -3063,8 +3057,6 @@ Y_UNIT_TEST_TWIN(TestShardRestartPlannedCommitShouldSucceed, EvWrite) {
         UNIT_ASSERT_VALUES_EQUAL(response.operation().status(), Ydb::StatusIds::SUCCESS);
     }
 
-    evWriteObservers = TTestActorRuntimeBase::TEventObserverHolderPair{};
-
     // Select key 3 and verify its value was updated
     {
         Cerr << "===== Last SELECT" << Endl;
@@ -3284,10 +3276,13 @@ Y_UNIT_TEST(TestShardSnapshotReadNoEarlyReply) {
 }
 
 Y_UNIT_TEST_TWIN(TestSnapshotReadAfterBrokenLock, EvWrite) {
+    NKikimrConfig::TAppConfig app;
+    app.MutableTableServiceConfig()->SetEnableOltpSink(EvWrite);
     TPortManager pm;
     TServerSettings serverSettings(pm.GetPort(2134));
     serverSettings.SetDomainName("Root")
-        .SetUseRealThreads(false);
+        .SetUseRealThreads(false)
+        .SetAppConfig(app);
 
     Tests::TServer::TPtr server = new TServer(serverSettings);
     auto &runtime = *server->GetRuntime();
@@ -3298,9 +3293,6 @@ Y_UNIT_TEST_TWIN(TestSnapshotReadAfterBrokenLock, EvWrite) {
     CreateShardedTable(server, sender, "/Root", "table-1", 1);
     CreateShardedTable(server, sender, "/Root", "table-2", 1);
 
-    auto rows = EvWrite ? TEvWriteRows{{{1, 1}}, {{2, 2}}, {{3, 3}}, {{5, 5}}} : TEvWriteRows{};
-    auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(runtime, rows);
-
     ExecSQL(server, sender, Q_("UPSERT INTO `/Root/table-1` (key, value) VALUES (1, 1)"));
     ExecSQL(server, sender, Q_("UPSERT INTO `/Root/table-2` (key, value) VALUES (2, 2)"));
 
diff --git a/ydb/core/tx/datashard/datashard_ut_prefix_kmeans.cpp b/ydb/core/tx/datashard/datashard_ut_prefix_kmeans.cpp
new file mode 100644
index 000000000000..b163e3b7c69a
--- /dev/null
+++ b/ydb/core/tx/datashard/datashard_ut_prefix_kmeans.cpp
@@ -0,0 +1,565 @@
+#include <ydb/core/base/table_index.h>
+#include <ydb/core/testlib/test_client.h>
+#include <ydb/core/tx/datashard/ut_common/datashard_ut_common.h>
+#include <ydb/core/tx/schemeshard/schemeshard.h>
+#include <ydb/core/tx/tx_proxy/proxy.h>
+#include <ydb/core/tx/tx_proxy/upload_rows.h>
+#include <ydb/core/protos/index_builder.pb.h>
+
+#include <yql/essentials/public/issue/yql_issue_message.h>
+
+#include <library/cpp/testing/unittest/registar.h>
+
+namespace NKikimr {
+using namespace Tests;
+using Ydb::Table::VectorIndexSettings;
+using namespace NTableIndex::NTableVectorKmeansTreeIndex;
+
+static std::atomic<ui64> sId = 1;
+static constexpr const char* kMainTable = "/Root/table-main";
+static constexpr const char* kLevelTable = "/Root/table-level";
+static constexpr const char* kPostingTable = "/Root/table-posting";
+static constexpr const char* kPrefixTable = "/Root/table-prefix";
+
+Y_UNIT_TEST_SUITE (TTxDataShardPrefixKMeansScan) {
+    static void DoBadRequest(Tests::TServer::TPtr server, TActorId sender,
+                             std::unique_ptr<TEvDataShard::TEvPrefixKMeansRequest> & ev, size_t dims = 2,
+                             VectorIndexSettings::VectorType type = VectorIndexSettings::VECTOR_TYPE_FLOAT,
+                             VectorIndexSettings::Metric metric = VectorIndexSettings::DISTANCE_COSINE)
+    {
+        auto id = sId.fetch_add(1, std::memory_order_relaxed);
+        auto& runtime = *server->GetRuntime();
+        auto datashards = GetTableShards(server, sender, kMainTable);
+        TTableId tableId = ResolveTableId(server, sender, kMainTable);
+
+        TStringBuilder data;
+        TString err;
+        UNIT_ASSERT(datashards.size() == 1);
+
+        for (auto tid : datashards) {
+            auto& rec = ev->Record;
+            rec.SetId(1);
+
+            rec.SetSeqNoGeneration(id);
+            rec.SetSeqNoRound(1);
+
+            if (!rec.HasTabletId()) {
+                rec.SetTabletId(tid);
+            }
+            if (!rec.HasPathId()) {
+                tableId.PathId.ToProto(rec.MutablePathId());
+            }
+
+            VectorIndexSettings settings;
+            settings.set_vector_dimension(dims);
+            settings.set_vector_type(type);
+            settings.set_metric(metric);
+            *rec.MutableSettings() = settings;
+
+            if (!rec.HasK()) {
+                rec.SetK(2);
+            }
+            rec.SetSeed(1337);
+
+            rec.SetUpload(NKikimrTxDataShard::TEvLocalKMeansRequest::UPLOAD_BUILD_TO_POSTING);
+
+            rec.SetNeedsRounds(3);
+
+            rec.SetChild(1);
+
+            if (rec.HasEmbeddingColumn()) {
+                rec.ClearEmbeddingColumn();
+            } else {
+                rec.SetEmbeddingColumn("embedding");
+            }
+
+            rec.SetLevelName(kLevelTable);
+            rec.SetPostingName(kPostingTable);
+
+            runtime.SendToPipe(tid, sender, ev.release(), 0, GetPipeConfigWithRetries());
+
+            TAutoPtr<IEventHandle> handle;
+            auto reply = runtime.GrabEdgeEventRethrow<TEvDataShard::TEvPrefixKMeansResponse>(handle);
+            UNIT_ASSERT_VALUES_EQUAL(reply->Record.GetStatus(), NKikimrIndexBuilder::EBuildStatus::BAD_REQUEST);
+        }
+    }
+
+    static std::tuple<TString, TString> DoPrefixKMeans(
+        Tests::TServer::TPtr server, TActorId sender, NTableIndex::TClusterId parent, ui64 seed, ui64 k,
+        NKikimrTxDataShard::TEvLocalKMeansRequest::EState upload, VectorIndexSettings::VectorType type,
+        VectorIndexSettings::Metric metric)
+    {
+        auto id = sId.fetch_add(1, std::memory_order_relaxed);
+        auto& runtime = *server->GetRuntime();
+        auto datashards = GetTableShards(server, sender, kMainTable);
+        TTableId tableId = ResolveTableId(server, sender, kMainTable);
+
+        TString err;
+
+        for (auto tid : datashards) {
+            auto ev1 = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();
+            auto ev2 = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();
+            auto fill = [&](std::unique_ptr<TEvDataShard::TEvPrefixKMeansRequest>& ev) {
+                auto& rec = ev->Record;
+                rec.SetId(1);
+
+                rec.SetSeqNoGeneration(id);
+                rec.SetSeqNoRound(1);
+
+                rec.SetTabletId(tid);
+                tableId.PathId.ToProto(rec.MutablePathId());
+
+                VectorIndexSettings settings;
+                settings.set_vector_dimension(2);
+                settings.set_vector_type(type);
+                settings.set_metric(metric);
+                *rec.MutableSettings() = settings;
+
+                rec.SetK(k);
+                rec.SetSeed(seed);
+
+                rec.SetUpload(upload);
+
+                rec.SetNeedsRounds(300);
+
+                rec.SetChild(parent);
+
+                rec.SetEmbeddingColumn("embedding");
+                rec.AddDataColumns("data");
+                rec.SetPrefixColumns(1);
+
+                rec.SetLevelName(kLevelTable);
+                rec.SetPostingName(kPostingTable);
+                rec.SetPrefixName(kPrefixTable);
+            };
+            fill(ev1);
+            fill(ev2);
+
+            runtime.SendToPipe(tid, sender, ev1.release(), 0, GetPipeConfigWithRetries());
+            runtime.SendToPipe(tid, sender, ev2.release(), 0, GetPipeConfigWithRetries());
+
+            TAutoPtr<IEventHandle> handle;
+            auto reply = runtime.GrabEdgeEventRethrow<TEvDataShard::TEvPrefixKMeansResponse>(handle);
+
+            NYql::TIssues issues;
+            NYql::IssuesFromMessage(reply->Record.GetIssues(), issues);
+            UNIT_ASSERT_EQUAL_C(reply->Record.GetStatus(), NKikimrIndexBuilder::EBuildStatus::DONE,
+                                issues.ToOneLineString());
+        }
+
+        auto level = ReadShardedTable(server, kLevelTable);
+        auto posting = ReadShardedTable(server, kPostingTable);
+        return {std::move(level), std::move(posting)};
+    }
+
+    static void DropTable(Tests::TServer::TPtr server, TActorId sender, const char* name)
+    {
+        ui64 txId = AsyncDropTable(server, sender, "/Root", name);
+        WaitTxNotification(server, sender, txId);
+    }
+
+    static void CreateLevelTable(Tests::TServer::TPtr server, TActorId sender, TShardedTableOptions options)
+    {
+        options.AllowSystemColumnNames(true);
+        options.Columns({
+            {ParentColumn, NTableIndex::ClusterIdTypeName, true, true},
+            {IdColumn, NTableIndex::ClusterIdTypeName, true, true},
+            {CentroidColumn, "String", false, true},
+        });
+        CreateShardedTable(server, sender, "/Root", "table-level", options);
+    }
+
+    static void CreatePostingTable(Tests::TServer::TPtr server, TActorId sender, TShardedTableOptions options)
+    {
+        options.AllowSystemColumnNames(true);
+        options.Columns({
+            {ParentColumn, NTableIndex::ClusterIdTypeName, true, true},
+            {"key", "Uint32", true, true},
+            {"data", "String", false, false},
+        });
+        CreateShardedTable(server, sender, "/Root", "table-posting", options);
+    }
+
+    static void CreateBuildTable(Tests::TServer::TPtr server, TActorId sender, TShardedTableOptions options,
+                                 const char* name)
+    {
+        options.AllowSystemColumnNames(true);
+        options.Columns({
+            {ParentColumn, NTableIndex::ClusterIdTypeName, true, true},
+            {"key", "Uint32", true, true},
+            {"embedding", "String", false, false},
+            {"data", "String", false, false},
+        });
+        CreateShardedTable(server, sender, "/Root", name, options);
+    }
+
+    static void CreateBuildPrefixTable(Tests::TServer::TPtr server, TActorId sender, TShardedTableOptions options,
+                                       const char* name)
+    {
+        options.Columns({
+            {"user", "String", true, true},
+            {"key", "Uint32", true, true},
+            {"embedding", "String", false, false},
+            {"data", "String", false, false},
+        });
+        CreateShardedTable(server, sender, "/Root", name, options);
+    }
+
+    Y_UNIT_TEST (BadRequest) {
+        TPortManager pm;
+        TServerSettings serverSettings(pm.GetPort(2134));
+        serverSettings.SetDomainName("Root");
+
+        Tests::TServer::TPtr server = new TServer(serverSettings);
+        auto& runtime = *server->GetRuntime();
+        auto sender = runtime.AllocateEdgeActor();
+
+        runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_DEBUG);
+
+        InitRoot(server, sender);
+
+        CreateShardedTable(server, sender, "/Root", "table-main", 1);
+
+        {
+            auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();
+            auto& rec = ev->Record;
+
+            rec.SetK(0);
+            DoBadRequest(server, sender, ev);
+        }
+        {
+            auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();
+            auto& rec = ev->Record;
+
+            rec.SetK(1);
+            DoBadRequest(server, sender, ev);
+        }
+        {
+            auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();
+            auto& rec = ev->Record;
+
+            rec.SetEmbeddingColumn("some");
+            DoBadRequest(server, sender, ev);
+        }
+        {
+            auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();
+            auto& rec = ev->Record;
+
+            rec.SetTabletId(0);
+            DoBadRequest(server, sender, ev);
+        }
+        {
+            auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();
+            auto& rec = ev->Record;
+
+            TPathId(0, 0).ToProto(rec.MutablePathId());
+            DoBadRequest(server, sender, ev);
+        }
+        {
+            auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();
+
+            DoBadRequest(server, sender, ev, 0);
+        }
+        {
+            auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();
+
+            // TODO(mbkkt) bit vector not supported for now
+            DoBadRequest(server, sender, ev, 2, VectorIndexSettings::VECTOR_TYPE_BIT);
+        }
+        {
+            auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();
+
+            DoBadRequest(server, sender, ev, 2, VectorIndexSettings::VECTOR_TYPE_UNSPECIFIED);
+        }
+        {
+            auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();
+
+            DoBadRequest(server, sender, ev, 2, VectorIndexSettings::VECTOR_TYPE_FLOAT,
+                         VectorIndexSettings::METRIC_UNSPECIFIED);
+        }
+        // TODO(mbkkt) For now all build_index, sample_k, build_columns, local_kmeans, prefix_kmeans doesn't really check this
+        // {
+        //     auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();
+        //     auto snapshotCopy = snapshot;
+        //     snapshotCopy.Step++;
+        //     DoBadRequest(server, sender, ev);
+        // }
+        // {
+        //     auto ev = std::make_unique<TEvDataShard::TEvPrefixKMeansRequest>();
+        //     auto snapshotCopy = snapshot;
+        //     snapshotCopy.TxId++;
+        //     DoBadRequest(server, sender, ev);
+        // }
+    }
+
+    Y_UNIT_TEST (BuildToPosting) {
+        TPortManager pm;
+        TServerSettings serverSettings(pm.GetPort(2134));
+        serverSettings.SetDomainName("Root");
+
+        Tests::TServer::TPtr server = new TServer(serverSettings);
+        auto& runtime = *server->GetRuntime();
+        auto sender = runtime.AllocateEdgeActor();
+
+        runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_DEBUG);
+        runtime.SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_DEBUG);
+
+        InitRoot(server, sender);
+
+        TShardedTableOptions options;
+        options.EnableOutOfOrder(true); // TODO(mbkkt) what is it?
+        options.Shards(1);
+
+        CreateBuildPrefixTable(server, sender, options, "table-main");
+        // Upsert some initial values
+        ExecSQL(server, sender,
+                R"(
+        UPSERT INTO `/Root/table-main`
+            (user, key, embedding, data)
+        VALUES )"
+                "(\"user-1\", 11, \"\x30\x30\3\", \"1-one\"),"
+                "(\"user-1\", 12, \"\x31\x31\3\", \"1-two\"),"
+                "(\"user-1\", 13, \"\x32\x32\3\", \"1-three\"),"
+                "(\"user-1\", 14, \"\x65\x65\3\", \"1-four\"),"
+                "(\"user-1\", 15, \"\x75\x75\3\", \"1-five\"),"
+
+                "(\"user-2\", 21, \"\x30\x30\3\", \"2-one\"),"
+                "(\"user-2\", 22, \"\x31\x31\3\", \"2-two\"),"
+                "(\"user-2\", 23, \"\x32\x32\3\", \"2-three\"),"
+                "(\"user-2\", 24, \"\x65\x65\3\", \"2-four\"),"
+                "(\"user-2\", 25, \"\x75\x75\3\", \"2-five\");");
+
+        auto create = [&] {
+            CreateLevelTable(server, sender, options);
+            CreatePostingTable(server, sender, options);
+        };
+        create();
+        auto recreate = [&] {
+            DropTable(server, sender, "table-level");
+            DropTable(server, sender, "table-posting");
+            create();
+        };
+
+        ui64 seed, k;
+        k = 2;
+
+        seed = 0;
+        for (auto distance : {VectorIndexSettings::DISTANCE_MANHATTAN, VectorIndexSettings::DISTANCE_EUCLIDEAN}) {
+            auto [level, posting] = DoPrefixKMeans(server, sender, 40, seed, k,
+                                                  NKikimrTxDataShard::TEvLocalKMeansRequest::UPLOAD_BUILD_TO_POSTING,
+                                                  VectorIndexSettings::VECTOR_TYPE_UINT8, distance);
+            UNIT_ASSERT_VALUES_EQUAL(level, 
+                "__ydb_parent = 40, __ydb_id = 41, __ydb_centroid = mm\3
"
+                "__ydb_parent = 40, __ydb_id = 42, __ydb_centroid = 11\3
"
+
+                "__ydb_parent = 43, __ydb_id = 44, __ydb_centroid = 11\3
"
+                "__ydb_parent = 43, __ydb_id = 45, __ydb_centroid = mm\3
"
+            );
+            UNIT_ASSERT_VALUES_EQUAL(posting, 
+                "__ydb_parent = 41, key = 14, data = 1-four
"
+                "__ydb_parent = 41, key = 15, data = 1-five
"
+                "__ydb_parent = 42, key = 11, data = 1-one
"
+                "__ydb_parent = 42, key = 12, data = 1-two
"
+                "__ydb_parent = 42, key = 13, data = 1-three
"
+
+                "__ydb_parent = 44, key = 21, data = 2-one
"
+                "__ydb_parent = 44, key = 22, data = 2-two
"
+                "__ydb_parent = 44, key = 23, data = 2-three
"
+                "__ydb_parent = 45, key = 24, data = 2-four
"
+                "__ydb_parent = 45, key = 25, data = 2-five
"
+            );
+            recreate();
+        }
+
+        seed = 111;
+        for (auto distance : {VectorIndexSettings::DISTANCE_MANHATTAN, VectorIndexSettings::DISTANCE_EUCLIDEAN}) {
+            auto [level, posting] = DoPrefixKMeans(server, sender, 40, seed, k,
+                                                  NKikimrTxDataShard::TEvLocalKMeansRequest::UPLOAD_BUILD_TO_POSTING,
+                                                  VectorIndexSettings::VECTOR_TYPE_UINT8, distance);
+            UNIT_ASSERT_VALUES_EQUAL(level, 
+                "__ydb_parent = 40, __ydb_id = 41, __ydb_centroid = 11\3
"
+                "__ydb_parent = 40, __ydb_id = 42, __ydb_centroid = mm\3
"
+
+                "__ydb_parent = 43, __ydb_id = 44, __ydb_centroid = 11\3
"
+                "__ydb_parent = 43, __ydb_id = 45, __ydb_centroid = mm\3
"
+            );
+            UNIT_ASSERT_VALUES_EQUAL(posting, 
+                "__ydb_parent = 41, key = 11, data = 1-one
"
+                "__ydb_parent = 41, key = 12, data = 1-two
"
+                "__ydb_parent = 41, key = 13, data = 1-three
"
+                "__ydb_parent = 42, key = 14, data = 1-four
"
+                "__ydb_parent = 42, key = 15, data = 1-five
"
+
+                "__ydb_parent = 44, key = 21, data = 2-one
"
+                "__ydb_parent = 44, key = 22, data = 2-two
"
+                "__ydb_parent = 44, key = 23, data = 2-three
"
+                "__ydb_parent = 45, key = 24, data = 2-four
"
+                "__ydb_parent = 45, key = 25, data = 2-five
"
+            );
+            recreate();
+        }
+        seed = 32;
+        for (auto similarity : {VectorIndexSettings::SIMILARITY_INNER_PRODUCT, VectorIndexSettings::SIMILARITY_COSINE,
+                                VectorIndexSettings::DISTANCE_COSINE})
+        {
+            auto [level, posting] = DoPrefixKMeans(server, sender, 40, seed, k,
+                                                  NKikimrTxDataShard::TEvLocalKMeansRequest::UPLOAD_BUILD_TO_POSTING,
+                                                  VectorIndexSettings::VECTOR_TYPE_UINT8, similarity);
+            UNIT_ASSERT_VALUES_EQUAL(level, 
+                "__ydb_parent = 40, __ydb_id = 41, __ydb_centroid = II\3
"
+
+                "__ydb_parent = 43, __ydb_id = 44, __ydb_centroid = II\3
"
+            );
+            UNIT_ASSERT_VALUES_EQUAL(posting, 
+                "__ydb_parent = 41, key = 11, data = 1-one
"
+                "__ydb_parent = 41, key = 12, data = 1-two
"
+                "__ydb_parent = 41, key = 13, data = 1-three
"
+                "__ydb_parent = 41, key = 14, data = 1-four
"
+                "__ydb_parent = 41, key = 15, data = 1-five
"
+
+                "__ydb_parent = 44, key = 21, data = 2-one
"
+                "__ydb_parent = 44, key = 22, data = 2-two
"
+                "__ydb_parent = 44, key = 23, data = 2-three
"
+                "__ydb_parent = 44, key = 24, data = 2-four
"
+                "__ydb_parent = 44, key = 25, data = 2-five
"
+            );
+            recreate();
+        }
+    }
+
+    Y_UNIT_TEST (BuildToBuild) {
+        TPortManager pm;
+        TServerSettings serverSettings(pm.GetPort(2134));
+        serverSettings.SetDomainName("Root");
+
+        Tests::TServer::TPtr server = new TServer(serverSettings);
+        auto& runtime = *server->GetRuntime();
+        auto sender = runtime.AllocateEdgeActor();
+
+        runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_DEBUG);
+
+        InitRoot(server, sender);
+
+        TShardedTableOptions options;
+        options.EnableOutOfOrder(true); // TODO(mbkkt) what is it?
+        options.Shards(1);
+
+        CreateBuildPrefixTable(server, sender, options, "table-main");
+        // Upsert some initial values
+        ExecSQL(server, sender,
+                R"(
+        UPSERT INTO `/Root/table-main`
+            (user, key, embedding, data)
+        VALUES )"
+                "(\"user-1\", 11, \"\x30\x30\3\", \"1-one\"),"
+                "(\"user-1\", 12, \"\x31\x31\3\", \"1-two\"),"
+                "(\"user-1\", 13, \"\x32\x32\3\", \"1-three\"),"
+                "(\"user-1\", 14, \"\x65\x65\3\", \"1-four\"),"
+                "(\"user-1\", 15, \"\x75\x75\3\", \"1-five\"),"
+
+                "(\"user-2\", 21, \"\x30\x30\3\", \"2-one\"),"
+                "(\"user-2\", 22, \"\x31\x31\3\", \"2-two\"),"
+                "(\"user-2\", 23, \"\x32\x32\3\", \"2-three\"),"
+                "(\"user-2\", 24, \"\x65\x65\3\", \"2-four\"),"
+                "(\"user-2\", 25, \"\x75\x75\3\", \"2-five\");");
+
+        auto create = [&] {
+            CreateLevelTable(server, sender, options);
+            CreateBuildTable(server, sender, options, "table-posting");
+        };
+        create();
+        auto recreate = [&] {
+            DropTable(server, sender, "table-level");
+            DropTable(server, sender, "table-posting");
+            create();
+        };
+
+        ui64 seed, k;
+        k = 2;
+
+        seed = 0;
+        for (auto distance : {VectorIndexSettings::DISTANCE_MANHATTAN, VectorIndexSettings::DISTANCE_EUCLIDEAN}) {
+            auto [level, posting] = DoPrefixKMeans(server, sender, 40, seed, k,
+                                                  NKikimrTxDataShard::TEvLocalKMeansRequest::UPLOAD_BUILD_TO_BUILD,
+                                                  VectorIndexSettings::VECTOR_TYPE_UINT8, distance);
+            UNIT_ASSERT_VALUES_EQUAL(level, 
+                "__ydb_parent = 40, __ydb_id = 41, __ydb_centroid = mm\3
"
+                "__ydb_parent = 40, __ydb_id = 42, __ydb_centroid = 11\3
"
+
+                "__ydb_parent = 43, __ydb_id = 44, __ydb_centroid = 11\3
"
+                "__ydb_parent = 43, __ydb_id = 45, __ydb_centroid = mm\3
"
+            );
+            UNIT_ASSERT_VALUES_EQUAL(posting, 
+                "__ydb_parent = 41, key = 14, embedding = \x65\x65\3, data = 1-four
"
+                "__ydb_parent = 41, key = 15, embedding = \x75\x75\3, data = 1-five
"
+                "__ydb_parent = 42, key = 11, embedding = \x30\x30\3, data = 1-one
"
+                "__ydb_parent = 42, key = 12, embedding = \x31\x31\3, data = 1-two
"
+                "__ydb_parent = 42, key = 13, embedding = \x32\x32\3, data = 1-three
"
+
+                "__ydb_parent = 44, key = 21, embedding = \x30\x30\3, data = 2-one
"
+                "__ydb_parent = 44, key = 22, embedding = \x31\x31\3, data = 2-two
"
+                "__ydb_parent = 44, key = 23, embedding = \x32\x32\3, data = 2-three
"
+                "__ydb_parent = 45, key = 24, embedding = \x65\x65\3, data = 2-four
"
+                "__ydb_parent = 45, key = 25, embedding = \x75\x75\3, data = 2-five
"
+            );
+            recreate();
+        }
+
+        seed = 111;
+        for (auto distance : {VectorIndexSettings::DISTANCE_MANHATTAN, VectorIndexSettings::DISTANCE_EUCLIDEAN}) {
+            auto [level, posting] = DoPrefixKMeans(server, sender, 40, seed, k,
+                                                  NKikimrTxDataShard::TEvLocalKMeansRequest::UPLOAD_BUILD_TO_BUILD,
+                                                  VectorIndexSettings::VECTOR_TYPE_UINT8, distance);
+            UNIT_ASSERT_VALUES_EQUAL(level, 
+                "__ydb_parent = 40, __ydb_id = 41, __ydb_centroid = 11\3
"
+                "__ydb_parent = 40, __ydb_id = 42, __ydb_centroid = mm\3
"
+
+                "__ydb_parent = 43, __ydb_id = 44, __ydb_centroid = 11\3
"
+                "__ydb_parent = 43, __ydb_id = 45, __ydb_centroid = mm\3
"
+            );
+            UNIT_ASSERT_VALUES_EQUAL(posting, 
+                "__ydb_parent = 41, key = 11, embedding = \x30\x30\3, data = 1-one
"
+                "__ydb_parent = 41, key = 12, embedding = \x31\x31\3, data = 1-two
"
+                "__ydb_parent = 41, key = 13, embedding = \x32\x32\3, data = 1-three
"
+                "__ydb_parent = 42, key = 14, embedding = \x65\x65\3, data = 1-four
"
+                "__ydb_parent = 42, key = 15, embedding = \x75\x75\3, data = 1-five
"
+
+                "__ydb_parent = 44, key = 21, embedding = \x30\x30\3, data = 2-one
"
+                "__ydb_parent = 44, key = 22, embedding = \x31\x31\3, data = 2-two
"
+                "__ydb_parent = 44, key = 23, embedding = \x32\x32\3, data = 2-three
"
+                "__ydb_parent = 45, key = 24, embedding = \x65\x65\3, data = 2-four
"
+                "__ydb_parent = 45, key = 25, embedding = \x75\x75\3, data = 2-five
"
+            );
+            recreate();
+        }
+        seed = 32;
+        for (auto similarity : {VectorIndexSettings::SIMILARITY_INNER_PRODUCT, VectorIndexSettings::SIMILARITY_COSINE,
+                                VectorIndexSettings::DISTANCE_COSINE})
+        {
+            auto [level, posting] = DoPrefixKMeans(server, sender, 40, seed, k,
+                                                  NKikimrTxDataShard::TEvLocalKMeansRequest::UPLOAD_BUILD_TO_BUILD,
+                                                  VectorIndexSettings::VECTOR_TYPE_UINT8, similarity);
+            UNIT_ASSERT_VALUES_EQUAL(level, 
+                "__ydb_parent = 40, __ydb_id = 41, __ydb_centroid = II\3
"
+
+                "__ydb_parent = 43, __ydb_id = 44, __ydb_centroid = II\3
"
+            );
+            UNIT_ASSERT_VALUES_EQUAL(posting, 
+                "__ydb_parent = 41, key = 11, embedding = \x30\x30\3, data = 1-one
"
+                "__ydb_parent = 41, key = 12, embedding = \x31\x31\3, data = 1-two
"
+                "__ydb_parent = 41, key = 13, embedding = \x32\x32\3, data = 1-three
"
+                "__ydb_parent = 41, key = 14, embedding = \x65\x65\3, data = 1-four
"
+                "__ydb_parent = 41, key = 15, embedding = \x75\x75\3, data = 1-five
"
+
+                "__ydb_parent = 44, key = 21, embedding = \x30\x30\3, data = 2-one
"
+                "__ydb_parent = 44, key = 22, embedding = \x31\x31\3, data = 2-two
"
+                "__ydb_parent = 44, key = 23, embedding = \x32\x32\3, data = 2-three
"
+                "__ydb_parent = 44, key = 24, embedding = \x65\x65\3, data = 2-four
"
+                "__ydb_parent = 44, key = 25, embedding = \x75\x75\3, data = 2-five
"
+            );
+            recreate();
+        }
+    }
+}
+
+}
diff --git a/ydb/core/tx/datashard/datashard_ut_read_iterator.cpp b/ydb/core/tx/datashard/datashard_ut_read_iterator.cpp
index 252e414d895d..2eb7e5bf5ef1 100644
--- a/ydb/core/tx/datashard/datashard_ut_read_iterator.cpp
+++ b/ydb/core/tx/datashard/datashard_ut_read_iterator.cpp
@@ -2570,16 +2570,19 @@ Y_UNIT_TEST_SUITE(DataShardReadIterator) {
         });
     }
 
-    Y_UNIT_TEST(ShouldReadFromHeadWithConflict) {
+    Y_UNIT_TEST_TWIN(ShouldReadFromHeadWithConflict, UseSink) {
         // Similar to ShouldReadFromHead, but there is conflicting hanged operation.
         // We will read all at once thus should not block
 
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
             // Blocked volatile transactions block reads, disable
-            .SetEnableDataShardVolatileTransactions(false);
+            .SetEnableDataShardVolatileTransactions(false)
+            .SetAppConfig(app);
 
         const ui64 shardCount = 1;
         TTestHelper helper(serverSettings, shardCount);
@@ -2624,7 +2627,7 @@ Y_UNIT_TEST_SUITE(DataShardReadIterator) {
         }
     }
 
-    Y_UNIT_TEST(ShouldReadFromHeadToMvccWithConflict) {
+    Y_UNIT_TEST_TWIN(ShouldReadFromHeadToMvccWithConflict, UseSink) {
         // Similar to ShouldProperlyOrderConflictingTransactionsMvcc, but we read HEAD
         //
         // In this test HEAD read waits conflicting transaction: first time we read from HEAD and
@@ -2632,8 +2635,11 @@ Y_UNIT_TEST_SUITE(DataShardReadIterator) {
 
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
-            .SetUseRealThreads(false);
+            .SetUseRealThreads(false)
+            .SetAppConfig(app);
 
         const ui64 shardCount = 1;
         TTestHelper helper(serverSettings, shardCount);
@@ -2714,7 +2720,7 @@ Y_UNIT_TEST_SUITE(DataShardReadIterator) {
         }
     }
 
-    Y_UNIT_TEST(ShouldProperlyOrderConflictingTransactionsMvcc) {
+    Y_UNIT_TEST_TWIN(ShouldProperlyOrderConflictingTransactionsMvcc, UseSink) {
         // 1. Start read-write multishard transaction: readset will be blocked
         // to hang transaction. Write is the key we want to read.
         // 2a. Check that we can read prior blocked step.
@@ -2727,8 +2733,11 @@ Y_UNIT_TEST_SUITE(DataShardReadIterator) {
 
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
-            .SetUseRealThreads(false);
+            .SetUseRealThreads(false)
+            .SetAppConfig(app);
 
         const ui64 shardCount = 1;
         TTestHelper helper(serverSettings, shardCount);
@@ -3705,7 +3714,16 @@ Y_UNIT_TEST_SUITE(DataShardReadIterator) {
         // 2. tx2: upsert into range2 > range1 range and commit.
         // 3. tx1: read range2 -> lock should be broken
 
-        TTestHelper helper;
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(EvWrite);
+        TPortManager pm;
+        TServerSettings serverSettings(pm.GetPort(2134));
+        serverSettings
+            .SetDomainName("Root")
+            .SetUseRealThreads(false)
+            .SetAppConfig(app);
+
+        TTestHelper helper(serverSettings);
 
         auto readVersion = CreateVolatileSnapshot(
             helper.Server,
@@ -3724,9 +3742,6 @@ Y_UNIT_TEST_SUITE(DataShardReadIterator) {
         UNIT_ASSERT_VALUES_EQUAL(readResult1->Record.TxLocksSize(), 1);
         UNIT_ASSERT_VALUES_EQUAL(readResult1->Record.BrokenTxLocksSize(), 0);
 
-        auto rows = EvWrite ? TEvWriteRows{{{300, 0, 0, 3000}}} : TEvWriteRows{};
-        auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(*helper.Server->GetRuntime(), rows);
-
         // write new data above snapshot
         ExecSQL(helper.Server, helper.Sender, R"(
             SELECT * FROM `/Root/table-1` WHERE key1 == 300;
diff --git a/ydb/core/tx/datashard/datashard_ut_replication.cpp b/ydb/core/tx/datashard/datashard_ut_replication.cpp
index 2334ad48bd01..76dc29c026b2 100644
--- a/ydb/core/tx/datashard/datashard_ut_replication.cpp
+++ b/ydb/core/tx/datashard/datashard_ut_replication.cpp
@@ -228,11 +228,14 @@ Y_UNIT_TEST_SUITE(DataShardReplication) {
         DoSplitMergeChanges(true);
     }
 
-    Y_UNIT_TEST(ReplicatedTable) {
+    Y_UNIT_TEST_TWIN(ReplicatedTable, UseSink) {
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
-            .SetUseRealThreads(false);
+            .SetUseRealThreads(false)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -244,8 +247,13 @@ Y_UNIT_TEST_SUITE(DataShardReplication) {
         CreateShardedTable(server, sender, "/Root", "table-1", TShardedTableOptions().Replicated(true));
 
         ExecSQL(server, sender, "SELECT * FROM `/Root/table-1`");
-        ExecSQL(server, sender, "INSERT INTO `/Root/table-1` (key, value) VALUES (1, 10);", true,
-            Ydb::StatusIds::GENERIC_ERROR);
+        if (UseSink) {
+            ExecSQL(server, sender, "INSERT INTO `/Root/table-1` (key, value) VALUES (1, 10);", true,
+                Ydb::StatusIds::BAD_REQUEST);
+        } else {
+            ExecSQL(server, sender, "INSERT INTO `/Root/table-1` (key, value) VALUES (1, 10);", true,
+                Ydb::StatusIds::GENERIC_ERROR);
+        }
 
         WaitTxNotification(server, sender, AsyncAlterDropReplicationConfig(server, "/Root", "table-1"));
         ExecSQL(server, sender, "INSERT INTO `/Root/table-1` (key, value) VALUES (1, 10);");
diff --git a/ydb/core/tx/datashard/datashard_ut_rs.cpp b/ydb/core/tx/datashard/datashard_ut_rs.cpp
index b15784d66c22..e7d0c3765ee7 100644
--- a/ydb/core/tx/datashard/datashard_ut_rs.cpp
+++ b/ydb/core/tx/datashard/datashard_ut_rs.cpp
@@ -63,13 +63,16 @@ struct IsReadSet {
 };
 
 Y_UNIT_TEST_SUITE(TDataShardRSTest) {
-    Y_UNIT_TEST(TestCleanupInRS) {
+    Y_UNIT_TEST_TWIN(TestCleanupInRS, UseSink) {
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
             // Volatile transactions avoid storing readsets in InReadSets table
-            .SetEnableDataShardVolatileTransactions(false);
+            .SetEnableDataShardVolatileTransactions(false)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
diff --git a/ydb/core/tx/datashard/datashard_ut_snapshot.cpp b/ydb/core/tx/datashard/datashard_ut_snapshot.cpp
index 1b3a3454569b..011487a1973b 100644
--- a/ydb/core/tx/datashard/datashard_ut_snapshot.cpp
+++ b/ydb/core/tx/datashard/datashard_ut_snapshot.cpp
@@ -1278,6 +1278,56 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
                     }
                     break;
                 }
+                case NKikimr::NEvents::TDataEvents::TEvWrite::EventType: {
+                    auto& record = ev->Get<NKikimr::NEvents::TDataEvents::TEvWrite>()->Record;
+                    Cerr << "TEvWrite:" << Endl;
+                    Cerr << record.DebugString() << Endl;
+                    if (InjectClearTasks) {
+                        record.ClearOperations();
+                    }
+                    if (InjectLocks) {
+                        auto* protoLocks = record.MutableLocks();
+                        protoLocks->SetOp(InjectLocks->Op);
+                        protoLocks->ClearLocks();
+                        TSet<ui64> shards;
+                        for (auto& lock : InjectLocks->Locks) {
+                            auto* protoLock = protoLocks->AddLocks();
+                            protoLock->SetLockId(lock.LockId);
+                            protoLock->SetDataShard(lock.DataShard);
+                            protoLock->SetGeneration(lock.Generation);
+                            protoLock->SetCounter(lock.Counter);
+                            protoLock->SetSchemeShard(lock.SchemeShard);
+                            protoLock->SetPathId(lock.PathId);
+                            shards.insert(lock.DataShard);
+                        }
+                        protoLocks->ClearSendingShards();
+                        for (ui64 shard : shards) {
+                            protoLocks->AddSendingShards(shard);
+                            protoLocks->AddReceivingShards(shard);
+                        }
+                        Cerr << "TEvWrite: injected Locks" << Endl;
+                    }
+                    Last = {};
+                    if (record.GetLockTxId()) {
+                        Last.LockId = record.GetLockTxId();
+                        Last.LockNodeId = record.GetLockNodeId();
+                    } else if (Inject.LockId) {
+                        record.SetLockTxId(Inject.LockId);
+                        if (Inject.LockNodeId) {
+                            record.SetLockNodeId(Inject.LockNodeId);
+                        }
+                        Cerr << "TEvWrite: injected LockId" << Endl;
+                    }
+                    if (record.HasMvccSnapshot()) {
+                        Last.MvccSnapshot.Step = record.GetMvccSnapshot().GetStep();
+                        Last.MvccSnapshot.TxId = record.GetMvccSnapshot().GetTxId();
+                    } else if (Inject.MvccSnapshot) {
+                        record.MutableMvccSnapshot()->SetStep(Inject.MvccSnapshot.Step);
+                        record.MutableMvccSnapshot()->SetTxId(Inject.MvccSnapshot.TxId);
+                        Cerr << "TEvWrite: injected MvccSnapshot" << Endl;
+                    }
+                    break;
+                }
                 case TEvDataShard::TEvProposeTransactionResult::EventType: {
                     auto& record = ev->Get<TEvDataShard::TEvProposeTransactionResult>()->Record;
                     Cerr << "TEvProposeTransactionResult:" << Endl;
@@ -1294,6 +1344,22 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
                     }
                     break;
                 }
+                case NKikimr::NEvents::TDataEvents::TEvWriteResult::EventType: {
+                    auto& record = ev->Get<NKikimr::NEvents::TDataEvents::TEvWriteResult>()->Record;
+                    Cerr << "TEvWriteResult:" << Endl;
+                    Cerr << record.DebugString() << Endl;
+                    LastLocks.clear();
+                    for (auto& protoLock : record.GetTxLocks()) {
+                        auto& lock = LastLocks.emplace_back();
+                        lock.LockId = protoLock.GetLockId();
+                        lock.DataShard = protoLock.GetDataShard();
+                        lock.Generation = protoLock.GetGeneration();
+                        lock.Counter = protoLock.GetCounter();
+                        lock.SchemeShard = protoLock.GetSchemeShard();
+                        lock.PathId = protoLock.GetPathId();
+                    }
+                    break;
+                }
                 case TEvTxProcessing::TEvReadSet::EventType: {
                     if (BlockReadSets) {
                         Cerr << "... blocked TEvReadSet" << Endl;
@@ -1337,15 +1403,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
         TVector<THolder<IEventHandle>> BlockedApplyRecords;
     };
 
-    Y_UNIT_TEST(MvccSnapshotLockedWrites) {
+    Y_UNIT_TEST_TWIN(MvccSnapshotLockedWrites, UseSink) {
         TPortManager pm;
         TServerSettings::TControls controls;
         controls.MutableDataShardControls()->SetEnableLockedWrites(1);
 
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetControls(controls);
+            .SetControls(controls)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -1429,15 +1498,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
             "{ items { uint32_value: 3 } items { uint32_value: 3 } }");
     }
 
-    Y_UNIT_TEST(MvccSnapshotLockedWritesRestart) {
+    Y_UNIT_TEST_TWIN(MvccSnapshotLockedWritesRestart, UseSink) {
         TPortManager pm;
         TServerSettings::TControls controls;
         controls.MutableDataShardControls()->SetEnableLockedWrites(1);
 
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetControls(controls);
+            .SetControls(controls)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -1528,15 +1600,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
             "{ items { uint32_value: 3 } items { uint32_value: 3 } }");
     }
 
-    Y_UNIT_TEST(MvccSnapshotLockedWritesWithoutConflicts) {
+    Y_UNIT_TEST_TWIN(MvccSnapshotLockedWritesWithoutConflicts, UseSink) {
         TPortManager pm;
         TServerSettings::TControls controls;
         controls.MutableDataShardControls()->SetEnableLockedWrites(1);
 
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetControls(controls);
+            .SetControls(controls)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -1655,15 +1730,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
             "ERROR: ABORTED");
     }
 
-    Y_UNIT_TEST(MvccSnapshotLockedWritesWithConflicts) {
+    Y_UNIT_TEST_TWIN(MvccSnapshotLockedWritesWithConflicts, UseSink) {
         TPortManager pm;
         TServerSettings::TControls controls;
         controls.MutableDataShardControls()->SetEnableLockedWrites(1);
 
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetControls(controls);
+            .SetControls(controls)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -1818,15 +1896,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
         return builder;
     }
 
-    Y_UNIT_TEST(MvccSnapshotReadLockedWrites) {
+    Y_UNIT_TEST_TWIN(MvccSnapshotReadLockedWrites, UseSink) {
         TPortManager pm;
         TServerSettings::TControls controls;
         controls.MutableDataShardControls()->SetEnableLockedWrites(1);
 
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetControls(controls);
+            .SetControls(controls)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -2118,15 +2199,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
         observer.Inject = {};
     }
 
-    Y_UNIT_TEST(LockedWriteBulkUpsertConflict) {
+    Y_UNIT_TEST_TWIN(LockedWriteBulkUpsertConflict, UseSink) {
         TPortManager pm;
         TServerSettings::TControls controls;
         controls.MutableDataShardControls()->SetEnableLockedWrites(1);
 
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetControls(controls);
+            .SetControls(controls)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -2214,15 +2298,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
         observer.InjectLocks.reset();
     }
 
-    Y_UNIT_TEST(LockedWriteReuseAfterCommit) {
+    Y_UNIT_TEST_TWIN(LockedWriteReuseAfterCommit, UseSink) {
         TPortManager pm;
         TServerSettings::TControls controls;
         controls.MutableDataShardControls()->SetEnableLockedWrites(1);
 
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetControls(controls);
+            .SetControls(controls)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -2297,15 +2384,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
         observer.Inject = {};
     }
 
-    Y_UNIT_TEST(LockedWriteDistributedCommitSuccess) {
+    Y_UNIT_TEST_TWIN(LockedWriteDistributedCommitSuccess, UseSink) {
         TPortManager pm;
         TServerSettings::TControls controls;
         controls.MutableDataShardControls()->SetEnableLockedWrites(1);
 
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetControls(controls);
+            .SetControls(controls)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -2402,15 +2492,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
 
     }
 
-    Y_UNIT_TEST(LockedWriteDistributedCommitAborted) {
+    Y_UNIT_TEST_TWIN(LockedWriteDistributedCommitAborted, UseSink) {
         TPortManager pm;
         TServerSettings::TControls controls;
         controls.MutableDataShardControls()->SetEnableLockedWrites(1);
 
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetControls(controls);
+            .SetControls(controls)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -2512,15 +2605,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
             "{ items { uint32_value: 20 } items { uint32_value: 22 } }");
     }
 
-    Y_UNIT_TEST(LockedWriteDistributedCommitFreeze) {
+    Y_UNIT_TEST_TWIN(LockedWriteDistributedCommitFreeze, UseSink) {
         TPortManager pm;
         TServerSettings::TControls controls;
         controls.MutableDataShardControls()->SetEnableLockedWrites(1);
 
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetControls(controls);
+            .SetControls(controls)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -2637,15 +2733,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
         }
     }
 
-    Y_UNIT_TEST(LockedWriteDistributedCommitCrossConflict) {
+    Y_UNIT_TEST_TWIN(LockedWriteDistributedCommitCrossConflict, UseSink) {
         TPortManager pm;
         TServerSettings::TControls controls;
         controls.MutableDataShardControls()->SetEnableLockedWrites(1);
 
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetControls(controls);
+            .SetControls(controls)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -2817,15 +2916,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
             "{ items { uint32_value: 30 } items { uint32_value: 21 } }");
     }
 
-    Y_UNIT_TEST(LockedWriteCleanupOnSplit) {
+    Y_UNIT_TEST_TWIN(LockedWriteCleanupOnSplit, UseSink) {
         TPortManager pm;
         TServerSettings::TControls controls;
         controls.MutableDataShardControls()->SetEnableLockedWrites(1);
 
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetControls(controls);
+            .SetControls(controls)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -2912,15 +3014,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
         }
     }
 
-    Y_UNIT_TEST(LockedWriteCleanupOnCopyTable) {
+    Y_UNIT_TEST_TWIN(LockedWriteCleanupOnCopyTable, UseSink) {
         TPortManager pm;
         TServerSettings::TControls controls;
         controls.MutableDataShardControls()->SetEnableLockedWrites(1);
 
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetControls(controls);
+            .SetControls(controls)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -3032,15 +3137,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
             "{ items { uint32_value: 1 } items { uint32_value: 1 } }");
     }
 
-    Y_UNIT_TEST_TWIN(LockedWriteWithAsyncIndex, WithRestart) {
+    Y_UNIT_TEST_QUAD(LockedWriteWithAsyncIndex, WithRestart, UseSink) {
         TPortManager pm;
         TServerSettings::TControls controls;
         controls.MutableDataShardControls()->SetEnableLockedWrites(1);
 
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetControls(controls);
+            .SetControls(controls)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -3165,16 +3273,19 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
         observer.InjectLocks.reset();
     }
 
-    Y_UNIT_TEST(LockedWritesLimitedPerKey) {
+    Y_UNIT_TEST_TWIN(LockedWritesLimitedPerKey, UseSink) {
         TPortManager pm;
         TServerSettings::TControls controls;
         controls.MutableDataShardControls()->SetEnableLockedWrites(1);
         controls.MutableDataShardControls()->SetMaxLockedWritesPerKey(2);
 
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetControls(controls);
+            .SetControls(controls)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -3244,7 +3355,7 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
             KqpSimpleExec(runtime, Q_(R"(
                 UPSERT INTO `/Root/table-1` (key, value) VALUES (2, 23)
                 )")),
-            "ERROR: GENERIC_ERROR");
+            UseSink ? "ERROR: INTERNAL_ERROR" : "ERROR: GENERIC_ERROR");
         observer.Inject = {};
 
         // Abort tx 234, this would allow adding one more change to key 2
@@ -3358,15 +3469,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
             "ERROR: WrongRequest
");
     }
 
-    Y_UNIT_TEST(LockedWriteWithAsyncIndexAndVolatileCommit) {
+    Y_UNIT_TEST_TWIN(LockedWriteWithAsyncIndexAndVolatileCommit, UseSink) {
         TPortManager pm;
         TServerSettings::TControls controls;
         controls.MutableDataShardControls()->SetEnableLockedWrites(1);
 
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetControls(controls);
+            .SetControls(controls)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -3492,15 +3606,18 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
             "{ items { uint32_value: 20 } items { uint32_value: 210 } }");
     }
 
-    Y_UNIT_TEST(LockedWriteWithPendingVolatileCommit) {
+    Y_UNIT_TEST_TWIN(LockedWriteWithPendingVolatileCommit, UseSink) {
         TServerSettings::TControls controls;
         controls.MutableDataShardControls()->SetEnableLockedWrites(1);
 
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetControls(controls);
+            .SetControls(controls)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -5084,19 +5201,25 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
             "{ items { int32_value: 2 } items { int32_value: 20 } }");
     }
 
-    Y_UNIT_TEST(UncommittedChangesRenameTable) {
+    Y_UNIT_TEST_TWIN(UncommittedChangesRenameTable, UseSink) {
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
             .SetDomainPlanResolution(100)
-            .SetEnableDataShardVolatileTransactions(true);
+            .SetEnableDataShardVolatileTransactions(true)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
         auto sender = runtime.AllocateEdgeActor();
 
         runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_TRACE);
+        runtime.SetLogPriority(NKikimrServices::KQP_COMPUTE, NLog::PRI_DEBUG);
+        runtime.SetLogPriority(NKikimrServices::KQP_EXECUTER, NLog::PRI_DEBUG);
+        runtime.SetLogPriority(NKikimrServices::KQP_SESSION, NLog::PRI_DEBUG);
 
         InitRoot(server, sender);
 
@@ -5444,12 +5567,15 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
             "{ items { uint32_value: 6 } items { uint32_value: 66 } }");
     }
 
-    Y_UNIT_TEST(ShardRestartLockNotBrokenByUncommittedBeforeRead) {
+    Y_UNIT_TEST_TWIN(ShardRestartLockNotBrokenByUncommittedBeforeRead, UseSink) {
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetDomainPlanResolution(100);
+            .SetDomainPlanResolution(100)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -5513,12 +5639,15 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
             "{ items { uint32_value: 6 } items { uint32_value: 66 } }");
     }
 
-    Y_UNIT_TEST(ShardRestartLockBrokenByUncommittedBeforeRead) {
+    Y_UNIT_TEST_TWIN(ShardRestartLockBrokenByUncommittedBeforeRead, UseSink) {
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetDomainPlanResolution(100);
+            .SetDomainPlanResolution(100)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -5582,12 +5711,15 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
     }
 
 
-    Y_UNIT_TEST(ShardRestartLockNotBrokenByUncommittedAfterRead) {
+    Y_UNIT_TEST_TWIN(ShardRestartLockNotBrokenByUncommittedAfterRead, UseSink) {
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetDomainPlanResolution(100);
+            .SetDomainPlanResolution(100)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -5651,12 +5783,15 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
             "{ items { uint32_value: 6 } items { uint32_value: 66 } }");
     }
 
-    Y_UNIT_TEST(ShardRestartLockBrokenByUncommittedAfterRead) {
+    Y_UNIT_TEST_TWIN(ShardRestartLockBrokenByUncommittedAfterRead, UseSink) {
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetDomainPlanResolution(100);
+            .SetDomainPlanResolution(100)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -5735,9 +5870,6 @@ Y_UNIT_TEST_SUITE(DataShardSnapshots) {
         TBlockEvents<TEvMediatorTimecast::TEvGranularUpdate> blockGranularUpdate(runtime);
 
         runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_TRACE);
-        runtime.SetLogPriority(NKikimrServices::TX_PROXY, NLog::PRI_DEBUG);
-        runtime.SetLogPriority(NKikimrServices::KQP_EXECUTER, NLog::PRI_TRACE);
-        runtime.SetLogPriority(NKikimrServices::KQP_SESSION, NLog::PRI_TRACE);
 
         InitRoot(server, sender);
 
diff --git a/ydb/core/tx/datashard/datashard_ut_trace.cpp b/ydb/core/tx/datashard/datashard_ut_trace.cpp
index 5b593c5b7fc4..0f7ac5d09bc2 100644
--- a/ydb/core/tx/datashard/datashard_ut_trace.cpp
+++ b/ydb/core/tx/datashard/datashard_ut_trace.cpp
@@ -48,11 +48,16 @@ Y_UNIT_TEST_SUITE(TDataShardTrace) {
         UNIT_ASSERT(tablets.size() == 2);
     }
 
-    std::tuple<TTestActorRuntime&, Tests::TServer::TPtr, TActorId> TestCreateServer() {
+    std::tuple<TTestActorRuntime&, Tests::TServer::TPtr, TActorId> TestCreateServer(std::optional<bool> useSink = std::nullopt) {
         TPortManager pm;
+        NKikimrConfig::TAppConfig appConfig;
+        if (useSink) {
+            appConfig.MutableTableServiceConfig()->SetEnableOltpSink(*useSink);
+        }
         TServerSettings serverSettings(pm.GetPort(2134));
         serverSettings.SetDomainName("Root")
-            .SetUseRealThreads(false);
+            .SetUseRealThreads(false)
+            .SetAppConfig(appConfig);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -203,8 +208,8 @@ Y_UNIT_TEST_SUITE(TDataShardTrace) {
         UNIT_ASSERT_VALUES_EQUAL(count, unitSpans.size());
     }
 
-    Y_UNIT_TEST(TestTraceDistributedUpsert) {
-        auto [runtime, server, sender] = TestCreateServer();
+    Y_UNIT_TEST_TWIN(TestTraceDistributedUpsert, UseSink) {
+        auto [runtime, server, sender] = TestCreateServer(UseSink);
 
         CreateShardedTable(server, sender, "/Root", "table-1", 1, false);
 
@@ -231,54 +236,108 @@ Y_UNIT_TEST_SUITE(TDataShardTrace) {
 
         TFakeWilsonUploader::Trace &trace = uploader->Traces.begin()->second;
 
-        auto deSpan = trace.Root.BFSFindOne("DataExecuter");
-        UNIT_ASSERT(deSpan);
+        Cerr << "Trace: " << trace.ToString() << Endl;
+
+        if (!UseSink) {
+            auto deSpan = trace.Root.BFSFindOne("DataExecuter");
+            UNIT_ASSERT(deSpan);
+            auto dsTxSpans = deSpan->get().FindAll("Datashard.Transaction");
+            UNIT_ASSERT_VALUES_EQUAL(2, dsTxSpans.size()); // Two shards, each executes a user transaction.
 
-        auto dsTxSpans = deSpan->get().FindAll("Datashard.Transaction");
-        UNIT_ASSERT_VALUES_EQUAL(2, dsTxSpans.size()); // Two shards, each executes a user transaction.
+            for (auto dsTxSpan : dsTxSpans) {
+                auto tabletTxs = dsTxSpan.get().FindAll("Tablet.Transaction");
+                UNIT_ASSERT_VALUES_EQUAL(2, tabletTxs.size()); // Each shard executes a proposal tablet tx and a progress tablet tx.
 
-        for (auto dsTxSpan : dsTxSpans) {
-            auto tabletTxs = dsTxSpan.get().FindAll("Tablet.Transaction");
-            UNIT_ASSERT_VALUES_EQUAL(2, tabletTxs.size()); // Each shard executes a proposal tablet tx and a progress tablet tx.
+                auto propose = tabletTxs[0];
+                // Note: when volatile transactions are enabled propose doesn't persist anything
+                if (!usesVolatileTxs) {
+                    CheckTxHasWriteLog(propose);
+                }
+                CheckTxHasDatashardUnits(propose, 3);
 
-            auto propose = tabletTxs[0];
-            // Note: when volatile transactions are enabled propose doesn't persist anything
-            if (!usesVolatileTxs) {
-                CheckTxHasWriteLog(propose);
+                auto progress = tabletTxs[1];
+                CheckTxHasWriteLog(progress);
+                CheckTxHasDatashardUnits(progress, usesVolatileTxs ? 6 : 11);
             }
-            CheckTxHasDatashardUnits(propose, 3);
 
-            auto progress = tabletTxs[1];
-            CheckTxHasWriteLog(progress);
-            CheckTxHasDatashardUnits(progress, usesVolatileTxs ? 6 : 11);
-        }
+            std::string canon = ExpectedSpan("Session.query.QUERY_ACTION_EXECUTE",
+                ExpectedSpan("CompileService", "CompileActor"),
+                "LiteralExecuter",
+                ExpectedSpan("DataExecuter",
+                    "WaitForTableResolve",
+                    "RunTasks",
+                    Repeat(
+                        ExpectedSpan("Datashard.Transaction",
+                            ExpectedSpan("Tablet.Transaction",
+                                ExpectedSpan("Tablet.Transaction.Execute",
+                                    Repeat("Datashard.Unit", 3)),
+                                Conditional(!usesVolatileTxs,
+                                    ExpectedSpan("Tablet.WriteLog", "Tablet.WriteLog.LogEntry")),
+                                "Tablet.Transaction.Complete"),
+                            Conditional(usesVolatileTxs, "Datashard.SendWithConfirmedReadOnlyLease"),
+                            ExpectedSpan("Tablet.Transaction",
+                                ExpectedSpan("Tablet.Transaction.Execute",
+                                    Repeat("Datashard.Unit", usesVolatileTxs ? 6 : 11)),
+                                ExpectedSpan("Tablet.WriteLog",
+                                    "Tablet.WriteLog.LogEntry"),
+                                "Tablet.Transaction.Complete"),
+                            "Datashard.SendResult"),
+                        2)))
+                .ToString();
+
+            UNIT_ASSERT_VALUES_EQUAL(trace.ToString(), canon);
+        } else {
+            auto commitSpan = trace.Root.BFSFindOne("Commit");
+            UNIT_ASSERT(commitSpan);
+            auto dsTxSpans = commitSpan->get().FindAll("Datashard.WriteTransaction");
+            UNIT_ASSERT_VALUES_EQUAL(2, dsTxSpans.size()); // Two shards, each executes a user transaction.
+
+            for (auto dsTxSpan : dsTxSpans) {
+                auto tabletTxs = dsTxSpan.get().FindAll("Tablet.Transaction");
+                UNIT_ASSERT_VALUES_EQUAL(2, tabletTxs.size()); // Each shard executes a proposal tablet tx and a progress tablet tx.
+
+                auto propose = tabletTxs[0];
+                // Note: when volatile transactions are enabled propose doesn't persist anything
+                if (!usesVolatileTxs) {
+                    CheckTxHasWriteLog(propose);
+                }
+                CheckTxHasDatashardUnits(propose, 3);
 
-        std::string canon = ExpectedSpan("Session.query.QUERY_ACTION_EXECUTE",
-            ExpectedSpan("CompileService", "CompileActor"),
-            "LiteralExecuter",
-            ExpectedSpan("DataExecuter",
-                "WaitForTableResolve",
-                "RunTasks",
-                Repeat(
-                    ExpectedSpan("Datashard.Transaction",
-                        ExpectedSpan("Tablet.Transaction",
-                            ExpectedSpan("Tablet.Transaction.Execute",
-                                Repeat("Datashard.Unit", 3)),
-                            Conditional(!usesVolatileTxs,
-                                ExpectedSpan("Tablet.WriteLog", "Tablet.WriteLog.LogEntry")),
-                            "Tablet.Transaction.Complete"),
-                        Conditional(usesVolatileTxs, "Datashard.SendWithConfirmedReadOnlyLease"),
-                        ExpectedSpan("Tablet.Transaction",
-                            ExpectedSpan("Tablet.Transaction.Execute",
-                                Repeat("Datashard.Unit", usesVolatileTxs ? 6 : 11)),
-                            ExpectedSpan("Tablet.WriteLog",
-                                "Tablet.WriteLog.LogEntry"),
-                            "Tablet.Transaction.Complete"),
-                        "Datashard.SendResult"),
-                    2)))
-            .ToString();
+                auto progress = tabletTxs[1];
+                CheckTxHasWriteLog(progress);
+                CheckTxHasDatashardUnits(progress, usesVolatileTxs ? 6 : 11);
+            }
 
-        UNIT_ASSERT_VALUES_EQUAL(trace.ToString(), canon);
+            std::string canon = ExpectedSpan("Session.query.QUERY_ACTION_EXECUTE",
+                ExpectedSpan("CompileService", "CompileActor"),
+                ExpectedSpan("DataExecuter",
+                    "WaitForTableResolve",
+                    ExpectedSpan("ComputeActor",
+                        Repeat(("ForwardWriteActor"), 1)),
+                    "RunTasks",
+                    ExpectedSpan(
+                        "Commit",
+                        Repeat(
+                            ExpectedSpan("Datashard.WriteTransaction",
+                                ExpectedSpan("Tablet.Transaction",
+                                    ExpectedSpan("Tablet.Transaction.Execute",
+                                        Repeat("Datashard.Unit", 3)),
+                                    Conditional(!usesVolatileTxs,
+                                        ExpectedSpan("Tablet.WriteLog", "Tablet.WriteLog.LogEntry")),
+                                    "Tablet.Transaction.Complete"),
+                                Conditional(usesVolatileTxs, "Datashard.SendWithConfirmedReadOnlyLease"),
+                                ExpectedSpan("Tablet.Transaction",
+                                    ExpectedSpan("Tablet.Transaction.Execute",
+                                        Repeat("Datashard.Unit", usesVolatileTxs ? 6 : 11)),
+                                    ExpectedSpan("Tablet.WriteLog",
+                                        "Tablet.WriteLog.LogEntry"),
+                                    "Tablet.Transaction.Complete"),
+                                "Datashard.SendWriteResult"),
+                            2))))
+                .ToString();
+
+            UNIT_ASSERT_VALUES_EQUAL(trace.ToString(), canon);
+        }
     }
 
     Y_UNIT_TEST(TestTraceDistributedSelect) {
diff --git a/ydb/core/tx/datashard/datashard_ut_volatile.cpp b/ydb/core/tx/datashard/datashard_ut_volatile.cpp
index dfc079377292..0af89d12d665 100644
--- a/ydb/core/tx/datashard/datashard_ut_volatile.cpp
+++ b/ydb/core/tx/datashard/datashard_ut_volatile.cpp
@@ -141,12 +141,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
             "{ items { uint32_value: 10 } items { uint32_value: 10 } }");
     }
 
-    Y_UNIT_TEST(DistributedWriteShardRestartBeforePlan) {
+    Y_UNIT_TEST_TWIN(DistributedWriteShardRestartBeforePlan, UseSink) {
+        NKikimrConfig::TAppConfig appConfig;
+        appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetDomainPlanResolution(1000);
+            .SetDomainPlanResolution(1000)
+            .SetAppConfig(appConfig);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -220,12 +223,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
             "{ items { uint32_value: 10 } items { uint32_value: 10 } }");
     }
 
-    Y_UNIT_TEST(DistributedWriteShardRestartAfterExpectation) {
+    Y_UNIT_TEST_TWIN(DistributedWriteShardRestartAfterExpectation, UseSink) {
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetDomainPlanResolution(1000);
+            .SetDomainPlanResolution(1000)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -384,9 +390,10 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
             "{ items { uint32_value: 10 } items { uint32_value: 10 } }");
     }
 
-    Y_UNIT_TEST(DistributedWriteLaterSnapshotBlockedThenCommit) {
+    Y_UNIT_TEST_TWIN(DistributedWriteLaterSnapshotBlockedThenCommit, UseSink) {
         TPortManager pm;
         NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         TServerSettings serverSettings(pm.GetPort(2134));
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
@@ -2195,14 +2202,17 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
             "{ items { uint32_value: 4 } items { uint32_value: 40 } }");
     }
 
-    Y_UNIT_TEST(TwoAppendsMustBeVolatile) {
+    Y_UNIT_TEST_TWIN(TwoAppendsMustBeVolatile, UseSink) {
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetNodeCount(2)
             .SetUseRealThreads(false)
             .SetDomainPlanResolution(100)
-            .SetEnableDataShardVolatileTransactions(true);
+            .SetEnableDataShardVolatileTransactions(true)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -2229,6 +2239,12 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
                 ++volatileTxs;
             }
         });
+        auto proposeObserverEvWrite = runtime.AddObserver<NKikimr::NEvents::TDataEvents::TEvWrite>([&](NKikimr::NEvents::TDataEvents::TEvWrite::TPtr& ev) {
+            auto* msg = ev->Get();
+            if (msg->Record.GetTxMode() == NKikimrDataEvents::TEvWrite::MODE_VOLATILE_PREPARE) {
+                ++volatileTxs;
+            }
+        });
 
         // This simulates a jepsen transaction that appends two values at different shards
         TString sessionId, txId;
@@ -2265,13 +2281,16 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
     }
 
     // Regression test for KIKIMR-21156
-    Y_UNIT_TEST(VolatileCommitOnBlobStorageFailure) {
+    Y_UNIT_TEST_TWIN(VolatileCommitOnBlobStorageFailure, UseSink) {
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
             .SetDomainPlanResolution(1000)
-            .SetEnableDataShardVolatileTransactions(true);
+            .SetEnableDataShardVolatileTransactions(true)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -2509,10 +2528,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
                 [this](auto& ev) {
                     this->OnEvent(ev);
                 }))
+            , ObserverEvWrite(runtime.AddObserver<NKikimr::NEvents::TDataEvents::TEvWrite>(
+                [this](auto& ev) {
+                    this->OnEvent(ev);
+                }))
         {}
 
         void Remove() {
             Observer.Remove();
+            ObserverEvWrite.Remove();
         }
 
     private:
@@ -2577,12 +2601,45 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
             ++Modified;
         }
 
+        void OnEvent(NKikimr::NEvents::TDataEvents::TEvWrite::TPtr& ev) {
+            auto* msg = ev->Get();
+
+            if (msg->Record.GetTxMode() != NKikimrDataEvents::TEvWrite::MODE_VOLATILE_PREPARE) {
+                Cerr << "... skipping TEvWrite with TxMode=" << NKikimrDataEvents::TEvWrite_ETxMode_Name(msg->Record.GetTxMode())
+                    << "(expected " << NKikimrDataEvents::TEvWrite_ETxMode_Name(NKikimrDataEvents::TEvWrite::MODE_VOLATILE_PREPARE) << ")"<< Endl;
+                return;
+            }
+
+            if (!msg->Record.HasLocks()) {
+                Cerr << "... skipping TEvWrite without locks" << Endl;
+                return;
+            }
+
+            auto* kqpLocks = msg->Record.MutableLocks();
+            const auto& sendingShards = kqpLocks->GetSendingShards();
+            const auto& receivingShards = kqpLocks->GetReceivingShards();
+
+            if (std::find(sendingShards.begin(), sendingShards.end(), ArbiterShard) == sendingShards.end()) {
+                Cerr << "... skipping TEvWrite without " << ArbiterShard << " in sending shards" << Endl;
+                return;
+            }
+
+            if (std::find(receivingShards.begin(), receivingShards.end(), ArbiterShard) == receivingShards.end()) {
+                Cerr << "... skipping TEvWrite without " << ArbiterShard << " in receiving shards" << Endl;
+                return;
+            }
+
+            kqpLocks->SetArbiterShard(ArbiterShard);
+            ++Modified;
+        }
+
     public:
         size_t Modified = 0;
 
     private:
         const ui64 ArbiterShard;
         TTestActorRuntime::TEventObserverHolder Observer;
+        TTestActorRuntime::TEventObserverHolder ObserverEvWrite;
     };
 
     class TForceBrokenLock {
@@ -2595,6 +2652,10 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
                 [this](auto& ev) {
                     this->OnEvent(ev);
                 }))
+            , ObserverEvWrite(runtime.AddObserver<NKikimr::NEvents::TDataEvents::TEvWrite>(
+                [this](auto& ev) {
+                    this->OnEvent(ev);
+                }))
         {}
 
     private:
@@ -2659,6 +2720,38 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
             ++Modified;
         }
 
+        void OnEvent(NKikimr::NEvents::TDataEvents::TEvWrite::TPtr& ev) {
+            if (ev->GetRecipientRewrite() != ShardActor) {
+                return;
+            }
+
+            auto* msg = ev->Get();
+
+            if (msg->Record.GetTxMode() != NKikimrDataEvents::TEvWrite::MODE_VOLATILE_PREPARE) {
+                Cerr << "... skipping TEvWrite with TxMode=" << NKikimrDataEvents::TEvWrite_ETxMode_Name(msg->Record.GetTxMode())
+                    << "(expected " << NKikimrDataEvents::TEvWrite_ETxMode_Name(NKikimrDataEvents::TEvWrite::MODE_VOLATILE_PREPARE) << ")"<< Endl;
+                return;
+            }
+
+            if (!msg->Record.HasLocks()) {
+                Cerr << "... skipping TEvWrite without locks" << Endl;
+                return;
+            }
+
+            auto* kqpLocks = msg->Record.MutableLocks();
+
+            // We use a lock that should have never existed to simulate a broken lock
+            auto* kqpLock = kqpLocks->AddLocks();
+            kqpLock->SetLockId(msg->Record.GetTxId());
+            kqpLock->SetDataShard(Shard);
+            kqpLock->SetGeneration(1);
+            kqpLock->SetCounter(1);
+            kqpLock->SetSchemeShard(TableId.PathId.OwnerId);
+            kqpLock->SetPathId(TableId.PathId.LocalPathId);
+
+            ++Modified;
+        }
+
     public:
         size_t Modified = 0;
 
@@ -2667,6 +2760,7 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
         const ui64 Shard;
         const TActorId ShardActor;
         TTestActorRuntime::TEventObserverHolder Observer;
+        TTestActorRuntime::TEventObserverHolder ObserverEvWrite;
     };
 
     class TBlockReadSets : public std::vector<TEvTxProcessing::TEvReadSet::TPtr> {
@@ -2723,12 +2817,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
         TTestActorRuntime::TEventObserverHolder Observer;
     };
 
-    Y_UNIT_TEST(UpsertNoLocksArbiter) {
+    Y_UNIT_TEST_TWIN(UpsertNoLocksArbiter, UseSink) {
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetEnableDataShardVolatileTransactions(true);
+            .SetEnableDataShardVolatileTransactions(true)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -2778,12 +2875,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
             "{ items { int32_value: 31 } items { int32_value: 311 } }");
     }
 
-    Y_UNIT_TEST(UpsertBrokenLockArbiter) {
+    Y_UNIT_TEST_TWIN(UpsertBrokenLockArbiter, UseSink) {
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetEnableDataShardVolatileTransactions(true);
+            .SetEnableDataShardVolatileTransactions(true)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -2844,12 +2944,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
             "");
     }
 
-    Y_UNIT_TEST(UpsertNoLocksArbiterRestart) {
+    Y_UNIT_TEST_TWIN(UpsertNoLocksArbiterRestart, UseSink) {
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetEnableDataShardVolatileTransactions(true);
+            .SetEnableDataShardVolatileTransactions(true)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -2916,12 +3019,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
             "ERROR: UNDETERMINED");
     }
 
-    Y_UNIT_TEST(UpsertBrokenLockArbiterRestart) {
+    Y_UNIT_TEST_TWIN(UpsertBrokenLockArbiterRestart, UseSink) {
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetEnableDataShardVolatileTransactions(true);
+            .SetEnableDataShardVolatileTransactions(true)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -2989,12 +3095,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
             "ERROR: ABORTED");
     }
 
-    Y_UNIT_TEST(UpsertDependenciesShardsRestart) {
+    Y_UNIT_TEST_TWIN(UpsertDependenciesShardsRestart, UseSink) {
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetEnableDataShardVolatileTransactions(true);
+            .SetEnableDataShardVolatileTransactions(true)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -3079,12 +3188,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
         Cerr << "... split finished" << Endl;
     }
 
-    Y_UNIT_TEST(DistributedUpsertRestartBeforePrepare) {
+    Y_UNIT_TEST_TWIN(DistributedUpsertRestartBeforePrepare, UseSink) {
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetEnableDataShardVolatileTransactions(true);
+            .SetEnableDataShardVolatileTransactions(true)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -3116,6 +3228,7 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
             "<empty>");
 
         TBlockEvents<TEvDataShard::TEvProposeTransaction> blockedPrepare(runtime);
+        TBlockEvents<NKikimr::NEvents::TDataEvents::TEvWrite> blockedEvWrite(runtime);
 
         Cerr << "========= Starting upsert 1 =========" << Endl;
         auto upsertFuture1 = KqpSimpleSend(runtime, R"(
@@ -3123,10 +3236,11 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
             VALUES (2, 2), (12, 12);
             )");
 
-        runtime.WaitFor("prepare requests", [&]{ return blockedPrepare.size() >= 2; });
-        UNIT_ASSERT_VALUES_EQUAL(blockedPrepare.size(), 2u);
+        runtime.WaitFor("prepare requests", [&]{ return blockedPrepare.size() + blockedEvWrite.size() >= 2; });
+        UNIT_ASSERT_VALUES_EQUAL(blockedPrepare.size() + blockedEvWrite.size(), 2u);
 
         blockedPrepare.Stop();
+        blockedEvWrite.Stop();
 
         Cerr << "========= Restarting shard 1 =========" << Endl;
         GracefulRestartTablet(runtime, shards.at(0), sender);
@@ -3136,12 +3250,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
             "ERROR: UNAVAILABLE");
     }
 
-    Y_UNIT_TEST(DistributedUpsertRestartAfterPrepare) {
+    Y_UNIT_TEST_TWIN(DistributedUpsertRestartAfterPrepare, UseSink) {
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetEnableDataShardVolatileTransactions(true);
+            .SetEnableDataShardVolatileTransactions(true)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -3173,6 +3290,7 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
             "<empty>");
 
         TBlockEvents<TEvDataShard::TEvProposeTransactionResult> blockedPrepare(runtime);
+        TBlockEvents<NKikimr::NEvents::TDataEvents::TEvWriteResult> blockedEvWrite(runtime);
 
         Cerr << "========= Starting upsert 1 =========" << Endl;
         auto upsertFuture1 = KqpSimpleSend(runtime, R"(
@@ -3180,16 +3298,22 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
             VALUES (2, 2), (12, 12);
             )");
 
-        runtime.WaitFor("prepare results", [&]{ return blockedPrepare.size() >= 2; });
-        UNIT_ASSERT_VALUES_EQUAL(blockedPrepare.size(), 2u);
+        runtime.WaitFor("prepare results", [&]{ return blockedPrepare.size() + blockedEvWrite.size() >= 2; });
+        UNIT_ASSERT_VALUES_EQUAL(blockedPrepare.size() + blockedEvWrite.size(), 2u);
 
         for (auto& ev : blockedPrepare) {
             auto* msg = ev->Get();
             UNIT_ASSERT_VALUES_EQUAL(msg->Record.GetStatus(), NKikimrTxDataShard::TEvProposeTransactionResult::PREPARED);
         }
 
+        for (auto& ev : blockedEvWrite) {
+            auto* msg = ev->Get();
+            UNIT_ASSERT_VALUES_EQUAL(msg->Record.GetStatus(), NKikimrDataEvents::TEvWriteResult::STATUS_PREPARED);
+        }
+
         // Unblock prepare results and restart the first shard
         blockedPrepare.Stop().Unblock();
+        blockedEvWrite.Stop().Unblock();
 
         Cerr << "========= Restarting shard 1 =========" << Endl;
         GracefulRestartTablet(runtime, shards.at(0), sender);
@@ -3280,12 +3404,15 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
     }
 
     // Regression test for KIKIMR-22506
-    Y_UNIT_TEST(NotCachingAbortingDeletes) {
+    Y_UNIT_TEST_TWIN(NotCachingAbortingDeletes, UseSink) {
         TPortManager pm;
         TServerSettings serverSettings(pm.GetPort(2134));
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
         serverSettings.SetDomainName("Root")
             .SetUseRealThreads(false)
-            .SetEnableDataShardVolatileTransactions(true);
+            .SetEnableDataShardVolatileTransactions(true)
+            .SetAppConfig(app);
 
         Tests::TServer::TPtr server = new TServer(serverSettings);
         auto &runtime = *server->GetRuntime();
@@ -3383,6 +3510,14 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
                 }
                 return true;
             });
+        TBlockEvents<NKikimr::NEvents::TDataEvents::TEvWriteResult> blockedEvWriteResults(runtime,
+            [&](const auto& ev) {
+                auto* msg = ev->Get();
+                if (msg->Record.GetStatus() == NKikimrDataEvents::TEvWriteResult::STATUS_PREPARED) {
+                    return false;
+                }
+                return true;
+            });
 
         size_t otherReadSets = 0;
         TBlockEvents<TEvTxProcessing::TEvReadSet> blockedReadSets(runtime,
@@ -3425,8 +3560,9 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {
         Cerr << "========= Unblocking commits and checking results =========" << Endl;
         blockedCommits.Stop().Unblock();
 
-        runtime.WaitFor("both results", [&]{ return blockedResults.size() >= 2; });
+        runtime.WaitFor("both results", [&]{ return blockedResults.size() + blockedEvWriteResults.size() >= 2; });
         blockedResults.Stop().Unblock();
+        blockedEvWriteResults.Stop().Unblock();
 
         UNIT_ASSERT_VALUES_EQUAL(
             FormatResult(runtime.WaitFuture(std::move(commitFuture))),
diff --git a/ydb/core/tx/datashard/datashard_ut_write.cpp b/ydb/core/tx/datashard/datashard_ut_write.cpp
index 8d2254d68a4b..8852ff8438dc 100644
--- a/ydb/core/tx/datashard/datashard_ut_write.cpp
+++ b/ydb/core/tx/datashard/datashard_ut_write.cpp
@@ -40,14 +40,20 @@ Y_UNIT_TEST_SUITE(DataShardWrite) {
     }
 
     Y_UNIT_TEST_TWIN(ExecSQLUpsertImmediate, EvWrite) {
-        auto [runtime, server, sender] = TestCreateServer();
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(EvWrite);
+        TPortManager pm;
+        TServerSettings serverSettings(pm.GetPort(2134));
+        serverSettings
+            .SetDomainName("Root")
+            .SetUseRealThreads(false)
+            .SetAppConfig(app);
+
+        auto [runtime, server, sender] = TestCreateServer(serverSettings);
 
         TShardedTableOptions opts;
         auto [shards, tableId] = CreateShardedTable(server, sender, "/Root", "table-1", opts);
 
-        auto rows = EvWrite ? TEvWriteRows{{{0, 1}}, {{2, 3}}, {{4, 5}}} : TEvWriteRows{};
-        auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(runtime, rows);
-
         Cout << "========= Send immediate write =========
";
         {
             ExecSQL(server, sender, Q_("UPSERT INTO `/Root/table-1` (key, value) VALUES (0, 1);"));
@@ -63,7 +69,16 @@ Y_UNIT_TEST_SUITE(DataShardWrite) {
     }
 
     Y_UNIT_TEST_QUAD(ExecSQLUpsertPrepared, EvWrite, Volatile) {
-        auto [runtime, server, sender] = TestCreateServer();
+        NKikimrConfig::TAppConfig app;
+        app.MutableTableServiceConfig()->SetEnableOltpSink(EvWrite);
+        TPortManager pm;
+        TServerSettings serverSettings(pm.GetPort(2134));
+        serverSettings
+            .SetDomainName("Root")
+            .SetUseRealThreads(false)
+            .SetAppConfig(app);
+
+        auto [runtime, server, sender] = TestCreateServer(serverSettings);
 
         runtime.GetAppData().FeatureFlags.SetEnableDataShardVolatileTransactions(Volatile);
 
@@ -71,9 +86,6 @@ Y_UNIT_TEST_SUITE(DataShardWrite) {
         auto [shards1, tableId1] = CreateShardedTable(server, sender, "/Root", "table-1", opts);
         auto [shards2, tableId2] = CreateShardedTable(server, sender, "/Root", "table-2", opts);
 
-        auto rows = EvWrite ? TEvWriteRows{{tableId1, {0, 1}}, {tableId2, {2, 3}}} : TEvWriteRows{};
-        auto evWriteObservers = ReplaceEvProposeTransactionWithEvWrite(runtime, rows);
-
         Cout << "========= Send distributed write =========
";
         {
             ExecSQL(server, sender, Q_(
diff --git a/ydb/core/tx/datashard/execute_data_tx_unit.cpp b/ydb/core/tx/datashard/execute_data_tx_unit.cpp
index 5d45d8820254..310bf3c539b8 100644
--- a/ydb/core/tx/datashard/execute_data_tx_unit.cpp
+++ b/ydb/core/tx/datashard/execute_data_tx_unit.cpp
@@ -346,7 +346,7 @@ void TExecuteDataTxUnit::ExecuteDataTx(TOperation::TPtr op,
 }
 
 void TExecuteDataTxUnit::AddLocksToResult(TOperation::TPtr op, const TActorContext& ctx) {
-    auto locks = DataShard.SysLocksTable().ApplyLocks();
+    auto [locks, _] = DataShard.SysLocksTable().ApplyLocks();
     for (const auto& lock : locks) {
         if (lock.IsError()) {
             LOG_NOTICE_S(TActivationContext::AsActorContext(), NKikimrServices::TX_DATASHARD,
diff --git a/ydb/core/tx/datashard/execute_kqp_data_tx_unit.cpp b/ydb/core/tx/datashard/execute_kqp_data_tx_unit.cpp
index 8c667b4266b7..7e989238ab3c 100644
--- a/ydb/core/tx/datashard/execute_kqp_data_tx_unit.cpp
+++ b/ydb/core/tx/datashard/execute_kqp_data_tx_unit.cpp
@@ -1,4 +1,5 @@
 #include "datashard_impl.h"
+#include "datashard_integrity_trails.h"
 #include "datashard_kqp.h"
 #include "datashard_pipeline.h"
 #include "execution_unit_ctors.h"
@@ -214,7 +215,8 @@ EExecutionStatus TExecuteKqpDataTxUnit::Execute(TOperation::TPtr op, TTransactio
             }
 
             KqpEraseLocks(tabletId, kqpLocks, sysLocks);
-            sysLocks.ApplyLocks();
+            auto [_, locksBrokenByTx] = sysLocks.ApplyLocks();
+            NDataIntegrity::LogIntegrityTrailsLocks(ctx, tabletId, txId, locksBrokenByTx);
             DataShard.SubscribeNewLocks(ctx);
             if (locksDb.HasChanges()) {
                 op->SetWaitCompletionFlag(true);
@@ -469,7 +471,8 @@ EExecutionStatus TExecuteKqpDataTxUnit::Execute(TOperation::TPtr op, TTransactio
 }
 
 void TExecuteKqpDataTxUnit::AddLocksToResult(TOperation::TPtr op, const TActorContext& ctx) {
-    auto locks = DataShard.SysLocksTable().ApplyLocks();
+    auto [locks, locksBrokenByTx] = DataShard.SysLocksTable().ApplyLocks();
+    NDataIntegrity::LogIntegrityTrailsLocks(ctx, DataShard.TabletID(), op->GetTxId(), locksBrokenByTx);
     LOG_T("add locks to result: " << locks.size());
     for (const auto& lock : locks) {
         if (lock.IsError()) {
diff --git a/ydb/core/tx/datashard/execute_write_unit.cpp b/ydb/core/tx/datashard/execute_write_unit.cpp
index e6b7c43f2aa2..afa4a61724df 100644
--- a/ydb/core/tx/datashard/execute_write_unit.cpp
+++ b/ydb/core/tx/datashard/execute_write_unit.cpp
@@ -4,6 +4,7 @@
 #include "datashard_locks_db.h"
 #include "datashard_user_db.h"
 #include "datashard_kqp.h"
+#include "datashard_integrity_trails.h"
 
 #include <ydb/core/engine/mkql_engine_flat_host.h>
 
@@ -41,7 +42,8 @@ class TExecuteWriteUnit : public TExecutionUnit {
     void AddLocksToResult(TWriteOperation* writeOp, const TActorContext& ctx) {
         NEvents::TDataEvents::TEvWriteResult& writeResult = *writeOp->GetWriteResult();
 
-        auto locks = DataShard.SysLocksTable().ApplyLocks();
+        auto [locks, locksBrokenByTx] = DataShard.SysLocksTable().ApplyLocks();
+        NDataIntegrity::LogIntegrityTrailsLocks(ctx, DataShard.TabletID(), writeOp->GetTxId(), locksBrokenByTx);
         LOG_TRACE_S(ctx, NKikimrServices::TX_DATASHARD, "add locks to result: " << locks.size());
         for (const auto& lock : locks) {
             if (lock.IsError()) {
@@ -95,8 +97,8 @@ class TExecuteWriteUnit : public TExecutionUnit {
         if (CheckForVolatileReadDependencies(userDb, writeOp, txc, ctx)) 
             return EExecutionStatus::Continue;
         
-        LOG_TRACE_S(ctx, NKikimrServices::TX_DATASHARD, "Operation " << writeOp << " at " << DataShard.TabletID() << " aborting because an duplicate key");
-        writeOp.SetError(NKikimrDataEvents::TEvWriteResult::STATUS_CONSTRAINT_VIOLATION, "Operation is aborting because an duplicate key");
+        LOG_TRACE_S(ctx, NKikimrServices::TX_DATASHARD, "Operation " << writeOp << " at " << DataShard.TabletID() << " aborting. Duplicate keys have been found.");
+        writeOp.SetError(NKikimrDataEvents::TEvWriteResult::STATUS_CONSTRAINT_VIOLATION, "Duplicate keys have been found.");
         ResetChanges(userDb, writeOp, txc);
         return EExecutionStatus::Executed;
     }
@@ -344,7 +346,8 @@ class TExecuteWriteUnit : public TExecutionUnit {
                 }
 
                 KqpEraseLocks(tabletId, kqpLocks, sysLocks);
-                sysLocks.ApplyLocks();
+                auto [_, locksBrokenByTx] = sysLocks.ApplyLocks();
+                NDataIntegrity::LogIntegrityTrailsLocks(ctx, tabletId, txId, locksBrokenByTx);
                 DataShard.SubscribeNewLocks(ctx);
                 if (locksDb.HasChanges()) {
                     op->SetWaitCompletionFlag(true);
diff --git a/ydb/core/tx/datashard/kmeans_helper.cpp b/ydb/core/tx/datashard/kmeans_helper.cpp
index 080771c20f28..3a74b92c74aa 100644
--- a/ydb/core/tx/datashard/kmeans_helper.cpp
+++ b/ydb/core/tx/datashard/kmeans_helper.cpp
@@ -47,21 +47,23 @@ void AddRowMain2Posting(TBufferData& buffer, NTableIndex::TClusterId parent, TAr
                   TSerializedCellVec::Serialize((*row).Slice(dataPos)));
 }
 
-void AddRowBuild2Build(TBufferData& buffer, NTableIndex::TClusterId parent, TArrayRef<const TCell> key, const NTable::TRowState& row) {
+void AddRowBuild2Build(TBufferData& buffer, NTableIndex::TClusterId parent, TArrayRef<const TCell> key, const NTable::TRowState& row,
+                       ui32 prefixColumns)
+{
     std::array<TCell, 1> cells;
     cells[0] = TCell::Make(parent);
     auto pk = TSerializedCellVec::Serialize(cells);
-    TSerializedCellVec::UnsafeAppendCells(key.Slice(1), pk);
+    TSerializedCellVec::UnsafeAppendCells(key.Slice(prefixColumns), pk);
     buffer.AddRow(TSerializedCellVec{key}, TSerializedCellVec{std::move(pk)}, TSerializedCellVec::Serialize(*row));
 }
 
 void AddRowBuild2Posting(TBufferData& buffer, NTableIndex::TClusterId parent, TArrayRef<const TCell> key, const NTable::TRowState& row,
-                         ui32 dataPos)
+                         ui32 dataPos, ui32 prefixColumns)
 {
     std::array<TCell, 1> cells;
     cells[0] = TCell::Make(parent);
     auto pk = TSerializedCellVec::Serialize(cells);
-    TSerializedCellVec::UnsafeAppendCells(key.Slice(1), pk);
+    TSerializedCellVec::UnsafeAppendCells(key.Slice(prefixColumns), pk);
     buffer.AddRow(TSerializedCellVec{key}, TSerializedCellVec{std::move(pk)},
                   TSerializedCellVec::Serialize((*row).Slice(dataPos)));
 }
@@ -88,12 +90,13 @@ TTags MakeUploadTags(const TUserTable& table, const TProtoStringType& embedding,
 
 std::shared_ptr<NTxProxy::TUploadTypes>
 MakeUploadTypes(const TUserTable& table, NKikimrTxDataShard::TEvLocalKMeansRequest::EState uploadState,
-                const TProtoStringType& embedding, const google::protobuf::RepeatedPtrField<TProtoStringType>& data)
+                const TProtoStringType& embedding, const google::protobuf::RepeatedPtrField<TProtoStringType>& data,
+                ui32 prefixColumns)
 {
     auto types = GetAllTypes(table);
 
     auto uploadTypes = std::make_shared<NTxProxy::TUploadTypes>();
-    uploadTypes->reserve(1 + 1 + std::min(table.KeyColumnTypes.size() + data.size(), types.size()));
+    uploadTypes->reserve(1 + 1 + std::min((table.KeyColumnTypes.size() - prefixColumns) + data.size(), types.size()));
 
     Ydb::Type type;
     type.set_type_id(NTableIndex::ClusterIdType);
@@ -107,7 +110,7 @@ MakeUploadTypes(const TUserTable& table, NKikimrTxDataShard::TEvLocalKMeansReque
             types.erase(it);
         }
     };
-    for (const auto& column : table.KeyColumnIds) {
+    for (const auto& column : table.KeyColumnIds | std::views::drop(prefixColumns)) {
         addType(table.Columns.at(column).Name);
     }
     switch (uploadState) {
diff --git a/ydb/core/tx/datashard/kmeans_helper.h b/ydb/core/tx/datashard/kmeans_helper.h
index 42449519b4d5..92ea345ccdde 100644
--- a/ydb/core/tx/datashard/kmeans_helper.h
+++ b/ydb/core/tx/datashard/kmeans_helper.h
@@ -206,10 +206,11 @@ void AddRowMain2Build(TBufferData& buffer, NTableIndex::TClusterId parent, TArra
 void AddRowMain2Posting(TBufferData& buffer, NTableIndex::TClusterId parent, TArrayRef<const TCell> key, const NTable::TRowState& row,
                         ui32 dataPos);
 
-void AddRowBuild2Build(TBufferData& buffer, NTableIndex::TClusterId parent, TArrayRef<const TCell> key, const NTable::TRowState& row);
+void AddRowBuild2Build(TBufferData& buffer, NTableIndex::TClusterId parent, TArrayRef<const TCell> key, const NTable::TRowState& row,
+                       ui32 prefixColumns = 1);
 
 void AddRowBuild2Posting(TBufferData& buffer, NTableIndex::TClusterId parent, TArrayRef<const TCell> key, const NTable::TRowState& row,
-                         ui32 dataPos);
+                         ui32 dataPos, ui32 prefixColumns = 1);
 
 TTags MakeUploadTags(const TUserTable& table, const TProtoStringType& embedding,
                      const google::protobuf::RepeatedPtrField<TProtoStringType>& data, ui32& embeddingPos,
@@ -217,7 +218,8 @@ TTags MakeUploadTags(const TUserTable& table, const TProtoStringType& embedding,
 
 std::shared_ptr<NTxProxy::TUploadTypes>
 MakeUploadTypes(const TUserTable& table, NKikimrTxDataShard::TEvLocalKMeansRequest::EState uploadState,
-                const TProtoStringType& embedding, const google::protobuf::RepeatedPtrField<TProtoStringType>& data);
+                const TProtoStringType& embedding, const google::protobuf::RepeatedPtrField<TProtoStringType>& data,
+                ui32 prefixColumns = 0);
 
 void MakeScan(auto& record, const auto& createScan, const auto& badRequest)
 {
diff --git a/ydb/core/tx/datashard/prefix_kmeans.cpp b/ydb/core/tx/datashard/prefix_kmeans.cpp
new file mode 100644
index 000000000000..053ca5ed7325
--- /dev/null
+++ b/ydb/core/tx/datashard/prefix_kmeans.cpp
@@ -0,0 +1,716 @@
+#include "datashard_impl.h"
+#include "kmeans_helper.h"
+#include "scan_common.h"
+#include "upload_stats.h"
+#include "buffer_data.h"
+
+#include <ydb/core/base/appdata.h>
+#include <ydb/core/base/counters.h>
+#include <ydb/core/kqp/common/kqp_types.h>
+#include <ydb/core/scheme/scheme_tablecell.h>
+
+#include <ydb/core/tx/tx_proxy/proxy.h>
+#include <ydb/core/tx/tx_proxy/upload_rows.h>
+
+#include <ydb/core/ydb_convert/table_description.h>
+#include <ydb/core/ydb_convert/ydb_convert.h>
+#include <yql/essentials/public/issue/yql_issue_message.h>
+
+#include <util/generic/algorithm.h>
+#include <util/string/builder.h>
+
+namespace NKikimr::NDataShard {
+using namespace NKMeans;
+
+// This scan needed to run kmeans reshuffle which is part of global kmeans run.
+static constexpr double MinVectorsNeedsReassigned = 0.01;
+
+class TPrefixKMeansScanBase: public TActor<TPrefixKMeansScanBase>, public NTable::IScan {
+protected:
+    using EState = NKikimrTxDataShard::TEvLocalKMeansRequest;
+
+    NTableIndex::TClusterId Parent = 0;
+    NTableIndex::TClusterId Child = 0;
+
+    ui32 Round = 0;
+    const ui32 MaxRounds = 0;
+
+    const ui32 InitK = 0;
+    ui32 K = 0;
+
+    EState::EState State;
+    const EState::EState UploadState;
+
+    IDriver* Driver = nullptr;
+
+    TLead Lead;
+
+    ui64 BuildId = 0;
+
+    ui64 ReadRows = 0;
+    ui64 ReadBytes = 0;
+
+    // Sample
+    ui64 MaxProbability = std::numeric_limits<ui64>::max();
+    TReallyFastRng32 Rng;
+
+    struct TProbability {
+        ui64 P = 0;
+        ui64 I = 0;
+
+        bool operator==(const TProbability&) const noexcept = default;
+        auto operator<=>(const TProbability&) const noexcept = default;
+    };
+
+    std::vector<TProbability> MaxRows;
+    std::vector<TString> Clusters;
+    std::vector<ui64> ClusterSizes;
+
+    // Upload
+    std::shared_ptr<NTxProxy::TUploadTypes> InitTargetTypes;
+    std::shared_ptr<NTxProxy::TUploadTypes> InitNextTypes;
+
+    std::shared_ptr<NTxProxy::TUploadTypes> TargetTypes;
+    std::shared_ptr<NTxProxy::TUploadTypes> NextTypes;
+
+    const TString TargetTable;
+    const TString NextTable;
+    TString CurrTable;
+
+    TBufferData ReadBuf;
+    TBufferData WriteBuf;
+
+    NTable::TPos EmbeddingPos = 0;
+    NTable::TPos DataPos = 1;
+
+    ui32 RetryCount = 0;
+
+    TActorId Uploader;
+    TUploadLimits Limits;
+
+    NTable::TTag KMeansScan;
+    TTags UploadScan;
+
+    TUploadStatus UploadStatus;
+
+    ui64 UploadRows = 0;
+    ui64 UploadBytes = 0;
+
+    // Response
+    TActorId ResponseActorId;
+    TAutoPtr<TEvDataShard::TEvPrefixKMeansResponse> Response;
+
+    ui32 PrefixColulmns;
+    TSerializedCellVec Key;
+    bool HasNextKey = false;
+
+public:
+    static constexpr NKikimrServices::TActivity::EType ActorActivityType()
+    {
+        return NKikimrServices::TActivity::LOCAL_KMEANS_SCAN_ACTOR;
+    }
+
+    TPrefixKMeansScanBase(const TUserTable& table, TLead&& lead,
+                          const NKikimrTxDataShard::TEvPrefixKMeansRequest& request,
+                          const TActorId& responseActorId,
+                          TAutoPtr<TEvDataShard::TEvPrefixKMeansResponse>&& response)
+        : TActor{&TThis::StateWork}
+        , Parent{request.GetChild()}
+        , Child{Parent + 1}
+        , MaxRounds{request.GetNeedsRounds()}
+        , InitK{request.GetK()}
+        , K{request.GetK()}
+        , State{EState::SAMPLE}
+        , UploadState{request.GetUpload()}
+        , Lead{std::move(lead)}
+        , BuildId{request.GetId()}
+        , Rng{request.GetSeed()}
+        , TargetTable{request.GetLevelName()}
+        , NextTable{request.GetPostingName()}
+        , ResponseActorId{responseActorId}
+        , Response{std::move(response)}
+        , PrefixColulmns{request.GetPrefixColumns()}
+    {
+        const auto& embedding = request.GetEmbeddingColumn();
+        const auto& data = request.GetDataColumns();
+        // scan tags
+        UploadScan = MakeUploadTags(table, embedding, data, EmbeddingPos, DataPos, KMeansScan);
+        // upload types
+        if (Ydb::Type type; State <= EState::KMEANS) {
+            TargetTypes = std::make_shared<NTxProxy::TUploadTypes>(3);
+            type.set_type_id(NTableIndex::ClusterIdType);
+            (*TargetTypes)[0] = {NTableIndex::NTableVectorKmeansTreeIndex::ParentColumn, type};
+            (*TargetTypes)[1] = {NTableIndex::NTableVectorKmeansTreeIndex::IdColumn, type};
+            type.set_type_id(Ydb::Type::STRING);
+            (*TargetTypes)[2] = {NTableIndex::NTableVectorKmeansTreeIndex::CentroidColumn, type};
+        }
+        NextTypes = MakeUploadTypes(table, UploadState, embedding, data, PrefixColulmns);
+
+        InitTargetTypes = TargetTypes;
+        InitNextTypes = NextTypes;
+        CurrTable = TargetTable;
+    }
+
+    TInitialState Prepare(IDriver* driver, TIntrusiveConstPtr<TScheme>) noexcept final
+    {
+        TActivationContext::AsActorContext().RegisterWithSameMailbox(this);
+        LOG_D("Prepare " << Debug());
+
+        Driver = driver;
+        return {EScan::Feed, {}};
+    }
+
+    TAutoPtr<IDestructable> Finish(EAbort abort) noexcept final
+    {
+        LOG_D("Finish " << Debug());
+
+        if (Uploader) {
+            Send(Uploader, new TEvents::TEvPoison);
+            Uploader = {};
+        }
+
+        auto& record = Response->Record;
+        record.SetReadRows(ReadRows);
+        record.SetReadBytes(ReadBytes);
+        record.SetUploadRows(UploadRows);
+        record.SetUploadBytes(UploadBytes);
+        if (abort != EAbort::None) {
+            record.SetStatus(NKikimrIndexBuilder::EBuildStatus::ABORTED);
+        } else if (UploadStatus.IsSuccess()) {
+            record.SetStatus(NKikimrIndexBuilder::EBuildStatus::DONE);
+        } else {
+            record.SetStatus(NKikimrIndexBuilder::EBuildStatus::BUILD_ERROR);
+        }
+        NYql::IssuesToMessage(UploadStatus.Issues, record.MutableIssues());
+        Send(ResponseActorId, Response.Release());
+
+        Driver = nullptr;
+        this->PassAway();
+        return nullptr;
+    }
+
+    void Describe(IOutputStream& out) const noexcept final
+    {
+        out << Debug();
+    }
+
+    TString Debug() const
+    {
+        return TStringBuilder() << " TPrefixKMeansScan Id: " << BuildId << " Parent: " << Parent << " Child: " << Child
+            << " CurrTable: " << CurrTable << " K: " << K << " Clusters: " << Clusters.size()
+            << " State: " << State << " Round: " << Round << " / " << MaxRounds
+            << " ReadBuf size: " << ReadBuf.Size() << " WriteBuf size: " << WriteBuf.Size() << " ";
+    }
+
+    EScan PageFault() noexcept final
+    {
+        LOG_T("PageFault " << Debug());
+
+        if (!ReadBuf.IsEmpty() && WriteBuf.IsEmpty()) {
+            ReadBuf.FlushTo(WriteBuf);
+            Upload(false);
+        }
+
+        return EScan::Feed;
+    }
+
+protected:
+    STFUNC(StateWork)
+    {
+        switch (ev->GetTypeRewrite()) {
+            HFunc(TEvTxUserProxy::TEvUploadRowsResponse, Handle);
+            CFunc(TEvents::TSystem::Wakeup, HandleWakeup);
+            default:
+                LOG_E("TPrefixKMeansScan: StateWork unexpected event type: " << ev->GetTypeRewrite() << " event: "
+                                                                            << ev->ToString() << " " << Debug());
+        }
+    }
+
+    void HandleWakeup(const NActors::TActorContext& /*ctx*/)
+    {
+        LOG_T("Retry upload " << Debug());
+
+        if (!WriteBuf.IsEmpty()) {
+            Upload(true);
+        }
+    }
+
+    void Handle(TEvTxUserProxy::TEvUploadRowsResponse::TPtr& ev, const TActorContext& ctx)
+    {
+        LOG_D("Handle TEvUploadRowsResponse " << Debug()
+            << " Uploader: " << Uploader.ToString() << " ev->Sender: " << ev->Sender.ToString());
+
+        if (Uploader) {
+            Y_VERIFY_S(Uploader == ev->Sender, "Mismatch Uploader: " << Uploader.ToString() << " ev->Sender: "
+                                                                     << ev->Sender.ToString() << Debug());
+        } else {
+            Y_ABORT_UNLESS(Driver == nullptr);
+            return;
+        }
+
+        UploadStatus.StatusCode = ev->Get()->Status;
+        UploadStatus.Issues = ev->Get()->Issues;
+        if (UploadStatus.IsSuccess()) {
+            UploadRows += WriteBuf.GetRows();
+            UploadBytes += WriteBuf.GetBytes();
+            WriteBuf.Clear();
+            if (!ReadBuf.IsEmpty() && ReadBuf.IsReachLimits(Limits)) {
+                ReadBuf.FlushTo(WriteBuf);
+                Upload(false);
+            }
+
+            Driver->Touch(EScan::Feed);
+            return;
+        }
+
+        if (RetryCount < Limits.MaxUploadRowsRetryCount && UploadStatus.IsRetriable()) {
+            LOG_N("Got retriable error, " << Debug() << UploadStatus.ToString());
+
+            ctx.Schedule(Limits.GetTimeoutBackouff(RetryCount), new TEvents::TEvWakeup());
+            return;
+        }
+
+        LOG_N("Got error, abort scan, " << Debug() << UploadStatus.ToString());
+
+        Driver->Touch(EScan::Final);
+    }
+
+    EScan FeedUpload()
+    {
+        if (!ReadBuf.IsReachLimits(Limits)) {
+            return EScan::Feed;
+        }
+        if (!WriteBuf.IsEmpty()) {
+            return EScan::Sleep;
+        }
+        ReadBuf.FlushTo(WriteBuf);
+        Upload(false);
+        return EScan::Feed;
+    }
+
+    ui64 GetProbability()
+    {
+        return Rng.GenRand64();
+    }
+
+    void Upload(bool isRetry)
+    {
+        if (isRetry) {
+            ++RetryCount;
+        } else {
+            RetryCount = 0;
+            if (State != EState::KMEANS && NextTypes) {
+                TargetTypes = std::exchange(NextTypes, {});
+                CurrTable = NextTable;
+            }
+        }
+
+        auto actor = NTxProxy::CreateUploadRowsInternal(
+            this->SelfId(), CurrTable, TargetTypes, WriteBuf.GetRowsData(),
+            NTxProxy::EUploadRowsMode::WriteToTableShadow, true /*writeToPrivateTable*/);
+
+        Uploader = this->Register(actor);
+    }
+
+    void UploadSample()
+    {
+        Y_ASSERT(ReadBuf.IsEmpty());
+        Y_ASSERT(WriteBuf.IsEmpty());
+        std::array<TCell, 2> pk;
+        std::array<TCell, 1> data;
+        for (NTable::TPos pos = 0; const auto& row : Clusters) {
+            pk[0] = TCell::Make(Parent);
+            pk[1] = TCell::Make(Child + pos);
+            data[0] = TCell{row};
+            WriteBuf.AddRow({}, TSerializedCellVec{pk}, TSerializedCellVec::Serialize(data));
+            ++pos;
+        }
+        Upload(false);
+    }
+};
+
+template <typename TMetric>
+class TPrefixKMeansScan final: public TPrefixKMeansScanBase, private TCalculation<TMetric> {
+    // KMeans
+    using TEmbedding = std::vector<typename TMetric::TSum>;
+
+    struct TAggregatedCluster {
+        TEmbedding Cluster;
+        ui64 Size = 0;
+    };
+    std::vector<TAggregatedCluster> AggregatedClusters;
+
+
+    bool MoveToNextKey() {
+        if (!HasNextKey) {
+            if (UploadStatus.IsNone()) {
+                UploadStatus.StatusCode = Ydb::StatusIds::SUCCESS;
+            }
+            return false;
+        }
+        Parent = Child + K;
+        Child = Parent + 1;
+        Round = 0;
+        K = InitK;
+        State = EState::SAMPLE;
+        // TODO(mbkkt) Upper or Lower doesn't matter here, because we seek to (prefix, inf)
+        // so we can choose Lower if it's faster.
+        // Exact seek with Lower also possible but needs to rewrite some code in Feed
+        Lead.To(Key.GetCells().subspan(0, PrefixColulmns), NTable::ESeek::Upper);
+        Key = {};
+        MaxProbability = std::numeric_limits<ui64>::max();
+        MaxRows.clear();
+        Clusters.clear();
+        ClusterSizes.clear();
+        TargetTypes = InitTargetTypes;
+        NextTypes = InitNextTypes;
+        CurrTable = TargetTable;
+        HasNextKey = false;
+        AggregatedClusters.clear();
+        return true;
+    }
+
+public:
+    TPrefixKMeansScan(const TUserTable& table, TLead&& lead, NKikimrTxDataShard::TEvPrefixKMeansRequest& request,
+                      const TActorId& responseActorId, TAutoPtr<TEvDataShard::TEvPrefixKMeansResponse>&& response)
+        : TPrefixKMeansScanBase{table, std::move(lead), request, responseActorId, std::move(response)}
+    {
+        this->Dimensions = request.GetSettings().vector_dimension();
+        LOG_D("Create " << Debug());
+    }
+
+    EScan Seek(TLead& lead, ui64 seq) noexcept final
+    {
+        LOG_D("Seek " << Debug());
+        ui64 zeroSeq = 0;
+        while (true) {
+            if (State == UploadState) {
+                if (!WriteBuf.IsEmpty()) {
+                    return EScan::Sleep;
+                }
+                if (!ReadBuf.IsEmpty()) {
+                    ReadBuf.FlushTo(WriteBuf);
+                    Upload(false);
+                    return EScan::Sleep;
+                }
+                if (MoveToNextKey()) {
+                    zeroSeq = seq;
+                    continue;
+                }
+                return EScan::Final;
+            }
+
+            lead = Lead;
+            if (State == EState::SAMPLE) {
+                lead.SetTags({&KMeansScan, 1});
+                if (seq == zeroSeq && !HasNextKey) {
+                    return EScan::Feed;
+                }
+                State = EState::KMEANS;
+                if (!InitAggregatedClusters()) {
+                    // We don't need to do anything,
+                    // because this datashard doesn't have valid embeddings for this parent
+                    if (MoveToNextKey()) {
+                        zeroSeq = seq;
+                        continue;
+                    }
+                    return EScan::Final;
+                }
+                ++Round;
+                return EScan::Feed;
+            }
+
+            Y_ASSERT(State == EState::KMEANS);
+            if (RecomputeClusters()) {
+                lead.SetTags(UploadScan);
+
+                UploadSample();
+                State = UploadState;
+            } else {
+                lead.SetTags({&KMeansScan, 1});
+                ++Round;
+            }
+            return EScan::Feed;
+        }
+    }
+
+    EScan Feed(TArrayRef<const TCell> key, const TRow& row) noexcept final
+    {
+        LOG_T("Feed " << Debug());
+        if (!Key) {
+            Key = TSerializedCellVec{key};
+        } else if (!TCellVectorsEquals{}(Key.GetCells().subspan(0, PrefixColulmns), key.subspan(0, PrefixColulmns))) {
+            HasNextKey = true;
+            return EScan::Reset;
+        }
+        ++ReadRows;
+        ReadBytes += CountBytes(key, row);
+        switch (State) {
+            case EState::SAMPLE:
+                return FeedSample(row);
+            case EState::KMEANS:
+                return FeedKMeans(row);
+            case EState::UPLOAD_BUILD_TO_BUILD:
+                return FeedUploadBuild2Build(key, row);
+            case EState::UPLOAD_BUILD_TO_POSTING:
+                return FeedUploadBuild2Posting(key, row);
+            default:
+                Y_ASSERT(false);
+                return EScan::Final;
+        }
+    }
+
+private:
+    bool InitAggregatedClusters()
+    {
+        if (Clusters.size() == 0) {
+            return false;
+        }
+        if (Clusters.size() < K) {
+            // if this datashard have smaller than K count of valid embeddings for this parent
+            // lets make single centroid for it
+            K = 1;
+            Clusters.resize(K);
+        }
+        Y_ASSERT(Clusters.size() == K);
+        ClusterSizes.resize(K, 0);
+        AggregatedClusters.resize(K);
+        for (auto& aggregate : AggregatedClusters) {
+            aggregate.Cluster.resize(this->Dimensions, 0);
+        }
+        return true;
+    }
+
+    void AggregateToCluster(ui32 pos, const char* embedding)
+    {
+        if (pos >= K) {
+            return;
+        }
+        auto& aggregate = AggregatedClusters[pos];
+        auto* coords = aggregate.Cluster.data();
+        for (auto coord : this->GetCoords(embedding)) {
+            *coords++ += coord;
+        }
+        ++aggregate.Size;
+    }
+
+    bool RecomputeClusters()
+    {
+        Y_ASSERT(K >= 1);
+        ui64 vectorCount = 0;
+        ui64 reassignedCount = 0;
+        for (size_t i = 0; auto& aggregate : AggregatedClusters) {
+            vectorCount += aggregate.Size;
+
+            auto& clusterSize = ClusterSizes[i];
+            reassignedCount += clusterSize < aggregate.Size ? aggregate.Size - clusterSize : 0;
+            clusterSize = aggregate.Size;
+
+            if (aggregate.Size != 0) {
+                this->Fill(Clusters[i], aggregate.Cluster.data(), aggregate.Size);
+                Y_ASSERT(aggregate.Size == 0);
+            }
+            ++i;
+        }
+        Y_ASSERT(vectorCount >= K);
+        Y_ASSERT(reassignedCount <= vectorCount);
+        if (K == 1) {
+            return true;
+        }
+
+        bool last = Round >= MaxRounds;
+        if (!last && Round > 1) {
+            const auto changes = static_cast<double>(reassignedCount) / static_cast<double>(vectorCount);
+            last = changes < MinVectorsNeedsReassigned;
+        }
+        if (!last) {
+            return false;
+        }
+
+        size_t w = 0;
+        for (size_t r = 0; r < ClusterSizes.size(); ++r) {
+            if (ClusterSizes[r] != 0) {
+                ClusterSizes[w] = ClusterSizes[r];
+                Clusters[w] = std::move(Clusters[r]);
+                ++w;
+            }
+        }
+        ClusterSizes.erase(ClusterSizes.begin() + w, ClusterSizes.end());
+        Clusters.erase(Clusters.begin() + w, Clusters.end());
+        return true;
+    }
+
+    EScan FeedSample(const TRow& row) noexcept
+    {
+        Y_ASSERT(row.Size() == 1);
+        const auto embedding = row.Get(0).AsRef();
+        if (!this->IsExpectedSize(embedding)) {
+            return EScan::Feed;
+        }
+
+        const auto probability = GetProbability();
+        if (Clusters.size() < K) {
+            MaxRows.push_back({probability, Clusters.size()});
+            Clusters.emplace_back(embedding.data(), embedding.size());
+            if (Clusters.size() == K) {
+                std::make_heap(MaxRows.begin(), MaxRows.end());
+                MaxProbability = MaxRows.front().P;
+            }
+        } else if (probability < MaxProbability) {
+            // TODO(mbkkt) use tournament tree to make less compare and swaps
+            std::pop_heap(MaxRows.begin(), MaxRows.end());
+            Clusters[MaxRows.back().I].assign(embedding.data(), embedding.size());
+            MaxRows.back().P = probability;
+            std::push_heap(MaxRows.begin(), MaxRows.end());
+            MaxProbability = MaxRows.front().P;
+        }
+        return MaxProbability != 0 ? EScan::Feed : EScan::Reset;
+    }
+
+    EScan FeedKMeans(const TRow& row) noexcept
+    {
+        Y_ASSERT(row.Size() == 1);
+        const ui32 pos = FeedEmbedding(*this, Clusters, row, 0);
+        AggregateToCluster(pos, row.Get(0).Data());
+        return EScan::Feed;
+    }
+
+    EScan FeedUploadBuild2Build(TArrayRef<const TCell> key, const TRow& row) noexcept
+    {
+        const ui32 pos = FeedEmbedding(*this, Clusters, row, EmbeddingPos);
+        if (pos > K) {
+            return EScan::Feed;
+        }
+        AddRowBuild2Build(ReadBuf, Child + pos, key, row, PrefixColulmns);
+        return FeedUpload();
+    }
+
+    EScan FeedUploadBuild2Posting(TArrayRef<const TCell> key, const TRow& row) noexcept
+    {
+        const ui32 pos = FeedEmbedding(*this, Clusters, row, EmbeddingPos);
+        if (pos > K) {
+            return EScan::Feed;
+        }
+        AddRowBuild2Posting(ReadBuf, Child + pos, key, row, DataPos, PrefixColulmns);
+        return FeedUpload();
+    }
+};
+
+class TDataShard::TTxHandleSafePrefixKMeansScan final: public NTabletFlatExecutor::TTransactionBase<TDataShard> {
+public:
+    TTxHandleSafePrefixKMeansScan(TDataShard* self, TEvDataShard::TEvPrefixKMeansRequest::TPtr&& ev)
+        : TTransactionBase(self)
+        , Ev(std::move(ev))
+    {
+    }
+
+    bool Execute(TTransactionContext&, const TActorContext& ctx) final
+    {
+        Self->HandleSafe(Ev, ctx);
+        return true;
+    }
+
+    void Complete(const TActorContext&) final
+    {
+    }
+
+private:
+    TEvDataShard::TEvPrefixKMeansRequest::TPtr Ev;
+};
+
+void TDataShard::Handle(TEvDataShard::TEvPrefixKMeansRequest::TPtr& ev, const TActorContext&)
+{
+    Execute(new TTxHandleSafePrefixKMeansScan(this, std::move(ev)));
+}
+
+void TDataShard::HandleSafe(TEvDataShard::TEvPrefixKMeansRequest::TPtr& ev, const TActorContext& ctx)
+{
+    auto& record = ev->Get()->Record;
+    TRowVersion rowVersion = GetMvccTxVersion(EMvccTxMode::ReadOnly);
+
+    // Note: it's very unlikely that we have volatile txs before this snapshot
+    if (VolatileTxManager.HasVolatileTxsAtSnapshot(rowVersion)) {
+        VolatileTxManager.AttachWaitingSnapshotEvent(rowVersion, std::unique_ptr<IEventHandle>(ev.Release()));
+        return;
+    }
+    const ui64 id = record.GetId();
+
+    auto response = MakeHolder<TEvDataShard::TEvPrefixKMeansResponse>();
+    response->Record.SetId(id);
+    response->Record.SetTabletId(TabletID());
+
+    TScanRecord::TSeqNo seqNo = {record.GetSeqNoGeneration(), record.GetSeqNoRound()};
+    response->Record.SetRequestSeqNoGeneration(seqNo.Generation);
+    response->Record.SetRequestSeqNoRound(seqNo.Round);
+
+    auto badRequest = [&](const TString& error) {
+        response->Record.SetStatus(NKikimrIndexBuilder::EBuildStatus::BAD_REQUEST);
+        auto issue = response->Record.AddIssues();
+        issue->set_severity(NYql::TSeverityIds::S_ERROR);
+        issue->set_message(error);
+        ctx.Send(ev->Sender, std::move(response));
+        response.Reset();
+    };
+
+    if (const ui64 shardId = record.GetTabletId(); shardId != TabletID()) {
+        badRequest(TStringBuilder() << "Wrong shard " << shardId << " this is " << TabletID());
+        return;
+    }
+
+    const auto pathId = TPathId::FromProto(record.GetPathId());
+    const auto* userTableIt = GetUserTables().FindPtr(pathId.LocalPathId);
+    if (!userTableIt) {
+        badRequest(TStringBuilder() << "Unknown table id: " << pathId.LocalPathId);
+        return;
+    }
+    Y_ABORT_UNLESS(*userTableIt);
+    const auto& userTable = **userTableIt;
+
+    if (const auto* recCard = ScanManager.Get(id)) {
+        if (recCard->SeqNo == seqNo) {
+            // do no start one more scan
+            return;
+        }
+
+        for (auto scanId : recCard->ScanIds) {
+            CancelScan(userTable.LocalTid, scanId);
+        }
+        ScanManager.Drop(id);
+    }
+
+    const auto range = userTable.GetTableRange();
+    if (range.IsEmptyRange(userTable.KeyColumnTypes)) {
+        badRequest(TStringBuilder() << " requested range doesn't intersect with table range");
+        return;
+    }
+
+    if (!IsStateActive()) {
+        badRequest(TStringBuilder() << "Shard " << TabletID() << " is not ready for requests");
+        return;
+    }
+
+    if (record.GetK() < 2) {
+        badRequest("Should be requested partition on at least two rows");
+        return;
+    }
+
+    TAutoPtr<NTable::IScan> scan;
+    auto createScan = [&]<typename T> {
+        scan = new TPrefixKMeansScan<T>{
+            userTable, CreateLeadFrom(range), record, ev->Sender, std::move(response),
+        };
+    };
+    MakeScan(record, createScan, badRequest);
+    if (!scan) {
+        Y_ASSERT(!response);
+        return;
+    }
+
+    TScanOptions scanOpts;
+    scanOpts.SetSnapshotRowVersion(rowVersion);
+    scanOpts.SetResourceBroker("build_index", 10); // TODO(mbkkt) Should be different group?
+    const auto scanId = QueueScan(userTable.LocalTid, std::move(scan), 0, scanOpts);
+    ScanManager.Set(id, seqNo).push_back(scanId);
+}
+
+}
diff --git a/ydb/core/tx/datashard/ut_common/datashard_ut_common.cpp b/ydb/core/tx/datashard/ut_common/datashard_ut_common.cpp
index 6e19f17694b3..8dff10e43014 100644
--- a/ydb/core/tx/datashard/ut_common/datashard_ut_common.cpp
+++ b/ydb/core/tx/datashard/ut_common/datashard_ut_common.cpp
@@ -2257,114 +2257,6 @@ NKikimrDataEvents::TEvWriteResult Update(TTestActorRuntime& runtime, TActorId se
     return Write(runtime, sender, shardId, std::move(request), expectedStatus);
 }
 
-TTestActorRuntimeBase::TEventObserverHolderPair ReplaceEvProposeTransactionWithEvWrite(TTestActorRuntime& runtime, TEvWriteRows& rows) {
-    if (rows.empty())
-        return {};
-
-    auto requestObserver = runtime.AddObserver([&rows](TAutoPtr<IEventHandle>& event) {
-        if (event->GetTypeRewrite() != TEvDataShard::EvProposeTransaction)
-            return;
-
-        const auto& record = event->Get<TEvDataShard::TEvProposeTransaction>()->Record;
-
-        if (record.GetTxKind() != NKikimrTxDataShard::TX_KIND_DATA)
-            return;
-
-        // Parse original TEvProposeTransaction
-        const ui64 txId = record.GetTxId();
-        const TString& txBody = record.GetTxBody();
-        NKikimrTxDataShard::TDataTransaction tx;
-        Y_VERIFY(tx.ParseFromArray(txBody.data(), txBody.size()));
-
-        // Construct new EvWrite
-        TVector<TCell> cells;
-        TTableId tableId;
-        ui16 colCount = 0;
-        for (const auto& task : tx.GetKqpTransaction().GetTasks()) {
-            NKikimrTxDataShard::TKqpTransaction::TDataTaskMeta meta;
-            Y_VERIFY(task.GetMeta().UnpackTo(&meta));
-            if (!meta.HasWrites())
-                continue;
-
-            const auto& tableMeta = meta.GetTable();
-            TTableId tableIdProto(tableMeta.GetTableId().GetOwnerId(), tableMeta.GetTableId().GetTableId(), tableMeta.GetSchemaVersion());
-            Y_VERIFY_S(tableId == TTableId{} || tableId == tableIdProto, "Only writes to one table is supported now");
-            tableId = tableIdProto;
-            const auto& writes = meta.GetWrites();
-            Y_VERIFY_S(colCount == 0 || colCount == writes.GetColumns().size(), "Only equal column count is supported now.");
-            colCount = writes.GetColumns().size();
-
-            const auto& row = rows.ProcessRow(tableId, txId);
-            Y_VERIFY(row.Cells.size() == colCount);
-            std::copy(row.Cells.begin(), row.Cells.end(), std::back_inserter(cells));
-        }
-
-        Cerr << "TEvProposeTransaction " << txId << " is observed and will be replaced with EvWrite: " << record.ShortDebugString() << Endl;
-
-        auto txMode = NKikimr::NDataShard::NEvWrite::TConvertor::GetTxMode(record.GetFlags());
-
-        auto evWrite = std::make_unique<NKikimr::NEvents::TDataEvents::TEvWrite>(txId, txMode);
-
-        if (!cells.empty()) {
-            TSerializedCellMatrix matrix(cells, cells.size() / colCount, colCount);
-            TString blobData = matrix.ReleaseBuffer();
-
-            UNIT_ASSERT(blobData.size() < 8_MB);
-
-            std::vector<ui32> columnIds(colCount);
-            std::iota(columnIds.begin(), columnIds.end(), 1);
-
-            ui64 payloadIndex = NKikimr::NEvWrite::TPayloadWriter<NKikimr::NEvents::TDataEvents::TEvWrite>(*evWrite).AddDataToPayload(std::move(blobData));
-            evWrite->AddOperation(NKikimrDataEvents::TEvWrite::TOperation::OPERATION_UPSERT, tableId, columnIds, payloadIndex, NKikimrDataEvents::FORMAT_CELLVEC);
-        }
-
-        // Copy locks
-        if (tx.HasLockTxId())
-            evWrite->Record.SetLockTxId(tx.GetLockTxId());
-        if (tx.HasLockNodeId())
-            evWrite->Record.SetLockNodeId(tx.GetLockNodeId());
-        if (tx.GetKqpTransaction().HasLocks())
-            evWrite->Record.MutableLocks()->CopyFrom(tx.GetKqpTransaction().GetLocks());
-
-        if (record.HasMvccSnapshot()) {
-            *evWrite->Record.MutableMvccSnapshot() = record.GetMvccSnapshot();
-        }
-
-        // Replace event
-        auto handle = new IEventHandle(event->Recipient, event->Sender, evWrite.release(), 0, event->Cookie);
-        handle->Rewrite(handle->GetTypeRewrite(), event->GetRecipientRewrite());
-        event.Reset(handle);
-    });
-
-    auto responseObserver = runtime.AddObserver([](TAutoPtr<IEventHandle>& event) {
-        if (event->GetTypeRewrite() != NEvents::TDataEvents::EvWriteResult)
-            return;
-
-        const auto& record = event->Get<NEvents::TDataEvents::TEvWriteResult>()->Record;
-        ui64 txId = record.GetTxId();
-
-        Cerr << "EvWriteResult " << txId << " is observed and will be replaced with EvProposeTransactionResult: " << record.ShortDebugString() << Endl;
-
-        // Construct new EvProposeTransactionResult
-        ui64 origin = record.GetOrigin();
-        auto status = NKikimr::NDataShard::NEvWrite::TConvertor::GetStatus(record.GetStatus());
-
-        auto evResult = std::make_unique<TEvDataShard::TEvProposeTransactionResult>(NKikimrTxDataShard::TX_KIND_DATA, origin, txId, status);
-
-        if (status == NKikimrTxDataShard::TEvProposeTransactionResult::PREPARED) {
-            evResult->SetPrepared(record.GetMinStep(), record.GetMaxStep(), {});
-            evResult->Record.MutableDomainCoordinators()->CopyFrom(record.GetDomainCoordinators());
-        }
-
-        // Replace event
-        auto handle = new IEventHandle(event->Recipient, event->Sender, evResult.release(), 0, event->Cookie);
-        handle->Rewrite(handle->GetTypeRewrite(), event->GetRecipientRewrite());
-        event.Reset(handle);
-    });
-
-    return {std::move(requestObserver), std::move(responseObserver)};
-}
-
 NKikimrDataEvents::TEvWriteResult WaitForWriteCompleted(TTestActorRuntime& runtime, TActorId sender, NKikimrDataEvents::TEvWriteResult::EStatus expectedStatus)
 {
     auto ev = runtime.GrabEdgeEventRethrow<NEvents::TDataEvents::TEvWriteResult>(sender);
diff --git a/ydb/core/tx/datashard/ut_common/datashard_ut_common.h b/ydb/core/tx/datashard/ut_common/datashard_ut_common.h
index 2c42040fdcaa..3381b4dae7ca 100644
--- a/ydb/core/tx/datashard/ut_common/datashard_ut_common.h
+++ b/ydb/core/tx/datashard/ut_common/datashard_ut_common.h
@@ -836,8 +836,6 @@ class TEvWriteRows : public std::vector<TEvWriteRow> {
     }
 };
 
-TTestActorRuntimeBase::TEventObserverHolderPair ReplaceEvProposeTransactionWithEvWrite(TTestActorRuntime& runtime, TEvWriteRows& rows);
-
 void UploadRows(TTestActorRuntime& runtime, const TString& tablePath, const TVector<std::pair<TString, Ydb::Type_PrimitiveTypeId>>& types, const TVector<TCell>& keys, const TVector<TCell>& values);
 
 struct TSendProposeToCoordinatorOptions {
@@ -862,6 +860,11 @@ struct IsTxResultComplete {
             if (status == NKikimrTxDataShard::TEvProposeTransactionResult::COMPLETE)
                 return true;
         }
+        if (ev.GetTypeRewrite() == NKikimr::NEvents::TDataEvents::EvWriteResult) {
+            auto status = ev.Get<NKikimr::NEvents::TDataEvents::TEvWriteResult>()->GetStatus();
+            if (status == NKikimrDataEvents::TEvWriteResult::STATUS_COMPLETED)
+                return true;
+        }
         return false;
     }
 };
diff --git a/ydb/core/tx/datashard/ut_prefix_kmeans/ya.make b/ydb/core/tx/datashard/ut_prefix_kmeans/ya.make
new file mode 100644
index 000000000000..8c1a7869e441
--- /dev/null
+++ b/ydb/core/tx/datashard/ut_prefix_kmeans/ya.make
@@ -0,0 +1,33 @@
+UNITTEST_FOR(ydb/core/tx/datashard)
+
+FORK_SUBTESTS()
+
+SPLIT_FACTOR(1)
+
+IF (SANITIZER_TYPE == "thread" OR WITH_VALGRIND)
+    SIZE(LARGE)
+    TAG(ya:fat)
+ELSE()
+    SIZE(MEDIUM)
+ENDIF()
+
+PEERDIR(
+    ydb/core/tx/datashard/ut_common
+    library/cpp/getopt
+    library/cpp/regex/pcre
+    library/cpp/svnversion
+    ydb/core/kqp/ut/common
+    ydb/core/testlib/default
+    ydb/core/tx
+    yql/essentials/public/udf/service/exception_policy
+    ydb/public/lib/yson_value
+    ydb/public/sdk/cpp/src/client/result
+)
+
+YQL_LAST_ABI_VERSION()
+
+SRCS(
+    datashard_ut_prefix_kmeans.cpp
+)
+
+END()
diff --git a/ydb/core/tx/datashard/ya.make b/ydb/core/tx/datashard/ya.make
index 82fee3c74e78..4c7087836059 100644
--- a/ydb/core/tx/datashard/ya.make
+++ b/ydb/core/tx/datashard/ya.make
@@ -181,6 +181,7 @@ SRCS(
     operation.cpp
     operation.h
     plan_queue_unit.cpp
+    prefix_kmeans.cpp
     prepare_data_tx_in_rs_unit.cpp
     prepare_distributed_erase_tx_in_rs_unit.cpp
     prepare_kqp_data_tx_in_rs_unit.cpp
@@ -326,6 +327,7 @@ RECURSE_FOR_TESTS(
     ut_minstep
     ut_object_storage_listing
     ut_order
+    ut_prefix_kmeans
     ut_range_ops
     ut_read_iterator
     ut_read_table
diff --git a/ydb/core/tx/limiter/grouped_memory/service/allocation.h b/ydb/core/tx/limiter/grouped_memory/service/allocation.h
index 678a4f97f859..a96377258984 100644
--- a/ydb/core/tx/limiter/grouped_memory/service/allocation.h
+++ b/ydb/core/tx/limiter/grouped_memory/service/allocation.h
@@ -1,5 +1,5 @@
 #pragma once
-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>
+#include <ydb/library/signals/object_counter.h>
 #include <ydb/core/tx/limiter/grouped_memory/usage/abstract.h>
 
 namespace NKikimr::NOlap::NGroupedMemoryManager {
diff --git a/ydb/core/tx/limiter/grouped_memory/service/counters.h b/ydb/core/tx/limiter/grouped_memory/service/counters.h
index 1d55b7b17f4a..2e75604b5792 100644
--- a/ydb/core/tx/limiter/grouped_memory/service/counters.h
+++ b/ydb/core/tx/limiter/grouped_memory/service/counters.h
@@ -1,5 +1,5 @@
 #pragma once
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 
 namespace NKikimr::NOlap::NGroupedMemoryManager {
 
diff --git a/ydb/core/tx/limiter/grouped_memory/service/group.h b/ydb/core/tx/limiter/grouped_memory/service/group.h
index 1c988081b02e..d97bf79012e8 100644
--- a/ydb/core/tx/limiter/grouped_memory/service/group.h
+++ b/ydb/core/tx/limiter/grouped_memory/service/group.h
@@ -1,7 +1,7 @@
 #pragma once
 #include "allocation.h"
 
-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>
+#include <ydb/library/signals/object_counter.h>
 
 namespace NKikimr::NOlap::NGroupedMemoryManager {
 
diff --git a/ydb/core/tx/limiter/grouped_memory/service/process.h b/ydb/core/tx/limiter/grouped_memory/service/process.h
index 3a53ff542750..a7631dd390ef 100644
--- a/ydb/core/tx/limiter/grouped_memory/service/process.h
+++ b/ydb/core/tx/limiter/grouped_memory/service/process.h
@@ -2,7 +2,7 @@
 #include "group.h"
 #include "ids.h"
 
-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>
+#include <ydb/library/signals/object_counter.h>
 
 #include <ydb/library/accessor/validator.h>
 
diff --git a/ydb/core/tx/limiter/grouped_memory/service/ya.make b/ydb/core/tx/limiter/grouped_memory/service/ya.make
index d67332688426..7611cc6b7cb9 100644
--- a/ydb/core/tx/limiter/grouped_memory/service/ya.make
+++ b/ydb/core/tx/limiter/grouped_memory/service/ya.make
@@ -12,7 +12,7 @@ SRCS(
 
 PEERDIR(
     ydb/core/protos
-    ydb/core/tx/columnshard/counters/common
+    ydb/library/signals
 )
 
 GENERATE_ENUM_SERIALIZATION(allocation.h)
diff --git a/ydb/core/tx/limiter/service/service.h b/ydb/core/tx/limiter/service/service.h
index 32e9c45faca5..dd7fd10f3d49 100644
--- a/ydb/core/tx/limiter/service/service.h
+++ b/ydb/core/tx/limiter/service/service.h
@@ -1,5 +1,5 @@
 #pragma once
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 #include <ydb/core/tx/limiter/usage/abstract.h>
 #include <ydb/core/tx/limiter/usage/config.h>
 #include <ydb/core/tx/limiter/usage/events.h>
diff --git a/ydb/core/tx/limiter/usage/abstract.h b/ydb/core/tx/limiter/usage/abstract.h
index ff3e460a771c..3a4b45983b5b 100644
--- a/ydb/core/tx/limiter/usage/abstract.h
+++ b/ydb/core/tx/limiter/usage/abstract.h
@@ -1,6 +1,6 @@
 #pragma once
 #include <memory>
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 
 namespace NKikimr::NLimiter {
 class IResourceRequest {
diff --git a/ydb/core/tx/locks/locks.cpp b/ydb/core/tx/locks/locks.cpp
index 8b2b6ef03b5d..6162f8443245 100644
--- a/ydb/core/tx/locks/locks.cpp
+++ b/ydb/core/tx/locks/locks.cpp
@@ -973,7 +973,7 @@ TLocksUpdate::~TLocksUpdate() {
 
 // TSysLocks
 
-TVector<TSysLocks::TLock> TSysLocks::ApplyLocks() {
+std::pair<TVector<TSysLocks::TLock>, TVector<ui64>> TSysLocks::ApplyLocks() {
     Y_ABORT_UNLESS(Update);
 
     TMicrosecTimerCounter measureApplyLocks(*Self, COUNTER_APPLY_LOCKS_USEC);
@@ -988,8 +988,14 @@ TVector<TSysLocks::TLock> TSysLocks::ApplyLocks() {
     Locker.RemoveBrokenRanges();
 
     Update->FlattenBreakLocks();
+
+    TVector<ui64> brokenLocks;
+    brokenLocks.reserve(Update->BreakLocks.Size());
     if (Update->BreakLocks) {
         Locker.BreakLocks(Update->BreakLocks, breakVersion);
+        for (const auto& lock : Update->BreakLocks) {
+            brokenLocks.push_back(lock.GetLockId());
+        }
     }
 
     Locker.SaveBrokenPersistentLocks(Db);
@@ -1019,7 +1025,7 @@ TVector<TSysLocks::TLock> TSysLocks::ApplyLocks() {
         // Adding read/write conflicts implies locking
         Y_ABORT_UNLESS(!Update->ReadConflictLocks);
         Y_ABORT_UNLESS(!Update->WriteConflictLocks);
-        return TVector<TLock>();
+        return {TVector<TLock>(), brokenLocks};
     }
 
     TLockInfo::TPtr lock;
@@ -1093,7 +1099,7 @@ TVector<TSysLocks::TLock> TSysLocks::ApplyLocks() {
         out.emplace_back(MakeLock(Update->LockTxId, lock ? lock->GetGeneration() : Self->Generation(), counter,
             table.GetTableId(), Update->Lock && Update->Lock->IsWriteLock()));
     }
-    return out;
+    return {out, brokenLocks};
 }
 
 void TSysLocks::UpdateCounters() {
diff --git a/ydb/core/tx/locks/locks.h b/ydb/core/tx/locks/locks.h
index 76c486123aa0..042c079e5f10 100644
--- a/ydb/core/tx/locks/locks.h
+++ b/ydb/core/tx/locks/locks.h
@@ -878,7 +878,7 @@ class TSysLocks {
         Locker.RemoveSchema(tableId, db);
     }
 
-    TVector<TLock> ApplyLocks();
+    std::pair<TVector<TLock>, TVector<ui64>> ApplyLocks();
     ui64 ExtractLockTxId(const TArrayRef<const TCell>& syslockKey) const;
     TLock GetLock(const TArrayRef<const TCell>& syslockKey) const;
     void EraseLock(ui64 lockId);
diff --git a/ydb/core/tx/priorities/service/counters.h b/ydb/core/tx/priorities/service/counters.h
index 7eb2202d9556..660b84a40429 100644
--- a/ydb/core/tx/priorities/service/counters.h
+++ b/ydb/core/tx/priorities/service/counters.h
@@ -1,5 +1,5 @@
 #pragma once
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 
 #include <library/cpp/monlib/dynamic_counters/counters.h>
 
diff --git a/ydb/core/tx/program/builder.cpp b/ydb/core/tx/program/builder.cpp
index 31a5d1be32f5..144a1b2bfe8c 100644
--- a/ydb/core/tx/program/builder.cpp
+++ b/ydb/core/tx/program/builder.cpp
@@ -17,8 +17,17 @@
 
 namespace NKikimr::NArrow::NSSA {
 
-TConclusion<std::shared_ptr<IStepFunction>> TProgramBuilder::MakeFunction(
-    const TColumnInfo& name, const NKikimrSSA::TProgram::TAssignment::TFunction& func, std::vector<TColumnChainInfo>& arguments) const {
+TConclusion<std::shared_ptr<IStepFunction>> TProgramBuilder::MakeFunction(const TColumnInfo& name,
+    const NKikimrSSA::TProgram::TAssignment::TFunction& func, std::shared_ptr<NArrow::NSSA::IKernelLogic>& kernelLogic,
+    std::vector<TColumnChainInfo>& arguments) const {
+    if (func.GetKernelName()) {
+        kernelLogic.reset(IKernelLogic::TFactory::Construct(func.GetKernelName()));
+    } else if (func.HasYqlOperationId()) {
+        kernelLogic = std::make_shared<TSimpleKernelLogic>(func.GetYqlOperationId());
+    } else {
+        kernelLogic = std::make_shared<TSimpleKernelLogic>();
+    }
+
     using TId = NKikimrSSA::TProgram::TAssignment;
 
     arguments.clear();
@@ -27,6 +36,15 @@ TConclusion<std::shared_ptr<IStepFunction>> TProgramBuilder::MakeFunction(
     }
 
     if (func.GetFunctionType() == NKikimrSSA::TProgram::EFunctionType::TProgram_EFunctionType_YQL_KERNEL) {
+        if (func.GetYqlOperationId() == (ui32)NYql::TKernelRequestBuilder::EBinaryOp::Equals) {
+            kernelLogic = std::make_shared<TLogicEquals>(false);
+        } else if (func.GetYqlOperationId() == (ui32)NYql::TKernelRequestBuilder::EBinaryOp::StringContains) {
+            kernelLogic = std::make_shared<TLogicMatchString>(TIndexCheckOperation::EOperation::Contains, true, false);
+        } else if (func.GetYqlOperationId() == (ui32)NYql::TKernelRequestBuilder::EBinaryOp::StartsWith) {
+            kernelLogic = std::make_shared<TLogicMatchString>(TIndexCheckOperation::EOperation::StartsWith, true, false);
+        } else if (func.GetYqlOperationId() == (ui32)NYql::TKernelRequestBuilder::EBinaryOp::EndsWith) {
+            kernelLogic = std::make_shared<TLogicMatchString>(TIndexCheckOperation::EOperation::EndsWith, true, false);
+        }
         auto kernelFunction = KernelsRegistry.GetFunction(func.GetKernelIdx());
         if (!kernelFunction) {
             return TConclusionStatus::Fail(
@@ -59,6 +77,7 @@ TConclusion<std::shared_ptr<IStepFunction>> TProgramBuilder::MakeFunction(
 
     switch (func.GetId()) {
         case TId::FUNC_CMP_EQUAL:
+            kernelLogic = std::make_shared<TLogicEquals>(true);
             return std::make_shared<TSimpleFunction>(EOperation::Equal);
         case TId::FUNC_CMP_NOT_EQUAL:
             return std::make_shared<TSimpleFunction>(EOperation::NotEqual);
@@ -76,6 +95,7 @@ TConclusion<std::shared_ptr<IStepFunction>> TProgramBuilder::MakeFunction(
             return std::make_shared<TSimpleFunction>(EOperation::BinaryLength);
         case TId::FUNC_STR_MATCH: {
             if (auto opts = mkLikeOptions(false)) {
+                kernelLogic = std::make_shared<TLogicMatchString>(TIndexCheckOperation::EOperation::Contains, true, true);
                 return std::make_shared<TSimpleFunction>(EOperation::MatchSubstring, opts);
             }
             break;
@@ -88,30 +108,35 @@ TConclusion<std::shared_ptr<IStepFunction>> TProgramBuilder::MakeFunction(
         }
         case TId::FUNC_STR_STARTS_WITH: {
             if (auto opts = mkLikeOptions(false)) {
+                kernelLogic = std::make_shared<TLogicMatchString>(TIndexCheckOperation::EOperation::StartsWith, true, true);
                 return std::make_shared<TSimpleFunction>(EOperation::StartsWith, opts);
             }
             break;
         }
         case TId::FUNC_STR_ENDS_WITH: {
             if (auto opts = mkLikeOptions(false)) {
+                kernelLogic = std::make_shared<TLogicMatchString>(TIndexCheckOperation::EOperation::EndsWith, true, true);
                 return std::make_shared<TSimpleFunction>(EOperation::EndsWith, opts);
             }
             break;
         }
         case TId::FUNC_STR_MATCH_IGNORE_CASE: {
             if (auto opts = mkLikeOptions(true)) {
+                kernelLogic = std::make_shared<TLogicMatchString>(TIndexCheckOperation::EOperation::Contains, false, true);
                 return std::make_shared<TSimpleFunction>(EOperation::MatchSubstring, opts);
             }
             break;
         }
         case TId::FUNC_STR_STARTS_WITH_IGNORE_CASE: {
             if (auto opts = mkLikeOptions(true)) {
+                kernelLogic = std::make_shared<TLogicMatchString>(TIndexCheckOperation::EOperation::StartsWith, false, true);
                 return std::make_shared<TSimpleFunction>(EOperation::StartsWith, opts);
             }
             break;
         }
         case TId::FUNC_STR_ENDS_WITH_IGNORE_CASE: {
             if (auto opts = mkLikeOptions(true)) {
+                kernelLogic = std::make_shared<TLogicMatchString>(TIndexCheckOperation::EOperation::EndsWith, false, true);
                 return std::make_shared<TSimpleFunction>(EOperation::EndsWith, opts);
             }
             break;
@@ -276,18 +301,14 @@ TConclusionStatus TProgramBuilder::ReadAssign(
     switch (assign.GetExpressionCase()) {
         case TId::kFunction: {
             std::shared_ptr<IKernelLogic> kernelLogic;
-            if (assign.GetFunction().GetKernelName()) {
-                kernelLogic.reset(IKernelLogic::TFactory::Construct(assign.GetFunction().GetKernelName()));
-            }
-
             std::vector<TColumnChainInfo> arguments;
-            auto function = MakeFunction(columnName, assign.GetFunction(), arguments);
+            auto function = MakeFunction(columnName, assign.GetFunction(), kernelLogic, arguments);
             if (function.IsFail()) {
                 return function;
             }
 
-            if (assign.GetFunction().HasYqlOperationId() && assign.GetFunction().GetYqlOperationId() ==
-                (ui32)NYql::TKernelRequestBuilder::EBinaryOp::And) {
+            if (assign.GetFunction().HasYqlOperationId() &&
+                assign.GetFunction().GetYqlOperationId() == (ui32)NYql::TKernelRequestBuilder::EBinaryOp::And) {
                 auto processor =
                     std::make_shared<TStreamLogicProcessor>(std::move(arguments), columnName.GetColumnId(), NKernels::EOperation::And);
                 Builder.Add(processor);
@@ -301,9 +322,6 @@ TConclusionStatus TProgramBuilder::ReadAssign(
                 if (processor.IsFail()) {
                     return processor;
                 }
-                if (assign.GetFunction().HasYqlOperationId()) {
-                    processor.GetResult()->SetYqlOperationId(assign.GetFunction().GetYqlOperationId());
-                }
                 Builder.Add(processor.DetachResult());
             }
             break;
@@ -399,7 +417,7 @@ TConclusionStatus TProgramBuilder::ReadGroupBy(const NKikimrSSA::TProgram::TGrou
             }
             auto aggrType = GetAggregationType(agg.GetFunction());
             auto argColumnIds = extractColumnIds(agg.GetFunction().GetArguments());
-            auto status = TCalculationProcessor::Build(std::move(argColumnIds), columnName.GetColumnId(), func.DetachResult(), nullptr);
+            auto status = TCalculationProcessor::Build(std::move(argColumnIds), columnName.GetColumnId(), func.DetachResult(), std::make_shared<TSimpleKernelLogic>());
             if (status.IsFail()) {
                 return status;
             }
diff --git a/ydb/core/tx/program/builder.h b/ydb/core/tx/program/builder.h
index 94d679300874..5e7b0fcb17dd 100644
--- a/ydb/core/tx/program/builder.h
+++ b/ydb/core/tx/program/builder.h
@@ -7,6 +7,7 @@
 #include <ydb/core/formats/arrow/program/functions.h>
 #include <ydb/core/formats/arrow/program/graph_execute.h>
 #include <ydb/core/formats/arrow/program/graph_optimization.h>
+#include <ydb/core/formats/arrow/program/kernel_logic.h>
 
 #include <ydb/library/formats/arrow/protos/ssa.pb.h>
 
@@ -37,8 +38,9 @@ class TProgramBuilder {
     TColumnInfo GetColumnInfo(const NKikimrSSA::TProgram::TColumn& column) const;
 
     std::string GenerateName(const NKikimrSSA::TProgram::TColumn& column) const;
-    [[nodiscard]] TConclusion<std::shared_ptr<IStepFunction>> MakeFunction(
-        const TColumnInfo& name, const NKikimrSSA::TProgram::TAssignment::TFunction& func, std::vector<TColumnChainInfo>& arguments) const;
+    [[nodiscard]] TConclusion<std::shared_ptr<IStepFunction>> MakeFunction(const TColumnInfo& name,
+        const NKikimrSSA::TProgram::TAssignment::TFunction& func, std::shared_ptr<IKernelLogic>& kernelLogic,
+        std::vector<TColumnChainInfo>& arguments) const;
     [[nodiscard]] TConclusion<std::shared_ptr<TConstProcessor>> MakeConstant(
         const TColumnInfo& name, const NKikimrSSA::TProgram::TConstant& constant) const;
     [[nodiscard]] TConclusion<std::shared_ptr<TConstProcessor>> MaterializeParameter(const TColumnInfo& name,
diff --git a/ydb/core/tx/program/program.cpp b/ydb/core/tx/program/program.cpp
index 19eaf54a7d1d..bd08ca83b361 100644
--- a/ydb/core/tx/program/program.cpp
+++ b/ydb/core/tx/program/program.cpp
@@ -94,8 +94,8 @@ TConclusionStatus TProgramContainer::ParseProgram(const NArrow::NSSA::IColumnRes
     using TId = NKikimrSSA::TProgram::TCommand;
 
     AFL_DEBUG(NKikimrServices::TX_COLUMNSHARD)("parse_proto_program", program.DebugString());
-//    Cerr << program.DebugString() << Endl;
     NArrow::NSSA::TProgramBuilder programBuilder(columnResolver, KernelsRegistry);
+    bool hasProjection = false;
     for (auto& cmd : program.GetCommand()) {
         switch (cmd.GetLineCase()) {
             case TId::kAssign: {
@@ -117,6 +117,7 @@ TConclusionStatus TProgramContainer::ParseProgram(const NArrow::NSSA::IColumnRes
                 if (status.IsFail()) {
                     return status;
                 }
+                hasProjection = true;
                 break;
             }
             case TId::kGroupBy: {
@@ -130,6 +131,9 @@ TConclusionStatus TProgramContainer::ParseProgram(const NArrow::NSSA::IColumnRes
                 return TConclusionStatus::Fail("incorrect SSA line case");
         }
     }
+    if (!hasProjection) {
+        return TConclusionStatus::Fail("program has no projections");
+    }
     auto programStatus = programBuilder.Finish();
     if (programStatus.IsFail()) {
         return programStatus;
diff --git a/ydb/core/tx/schemeshard/olap/column_families/schema.cpp b/ydb/core/tx/schemeshard/olap/column_families/schema.cpp
index 957788be869a..7453de281940 100644
--- a/ydb/core/tx/schemeshard/olap/column_families/schema.cpp
+++ b/ydb/core/tx/schemeshard/olap/column_families/schema.cpp
@@ -87,7 +87,7 @@ void TOlapColumnFamiliesDescription::Serialize(NKikimrSchemeOp::TColumnTableSche
     }
 }
 
-bool TOlapColumnFamiliesDescription::Validate(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const {
+bool TOlapColumnFamiliesDescription::ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const {
     ui32 lastColumnFamilyId = 0;
     THashSet<ui32> usedColumnFamilies;
     for (const auto& familyProto : opSchema.GetColumnFamilies()) {
diff --git a/ydb/core/tx/schemeshard/olap/column_families/schema.h b/ydb/core/tx/schemeshard/olap/column_families/schema.h
index 046321f8a2e9..2fd6736d8231 100644
--- a/ydb/core/tx/schemeshard/olap/column_families/schema.h
+++ b/ydb/core/tx/schemeshard/olap/column_families/schema.h
@@ -39,6 +39,6 @@ class TOlapColumnFamiliesDescription {
 
     bool Parse(const NKikimrSchemeOp::TColumnTableSchema& tableSchema);
     void Serialize(NKikimrSchemeOp::TColumnTableSchema& tableSchema) const;
-    bool Validate(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;
+    bool ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;
 };
 }
diff --git a/ydb/core/tx/schemeshard/olap/columns/schema.cpp b/ydb/core/tx/schemeshard/olap/columns/schema.cpp
index f533a3476bf9..3ff56dbbdbaf 100644
--- a/ydb/core/tx/schemeshard/olap/columns/schema.cpp
+++ b/ydb/core/tx/schemeshard/olap/columns/schema.cpp
@@ -165,7 +165,7 @@ void TOlapColumnsDescription::Serialize(NKikimrSchemeOp::TColumnTableSchema& tab
     }
 }
 
-bool TOlapColumnsDescription::Validate(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const {
+bool TOlapColumnsDescription::ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const {
     const NScheme::TTypeRegistry* typeRegistry = AppData()->TypeRegistry;
 
     ui32 lastColumnId = 0;
diff --git a/ydb/core/tx/schemeshard/olap/columns/schema.h b/ydb/core/tx/schemeshard/olap/columns/schema.h
index c8604d55e997..c4c8d88998c4 100644
--- a/ydb/core/tx/schemeshard/olap/columns/schema.h
+++ b/ydb/core/tx/schemeshard/olap/columns/schema.h
@@ -58,6 +58,6 @@ class TOlapColumnsDescription {
 
     void Parse(const NKikimrSchemeOp::TColumnTableSchema& tableSchema);
     void Serialize(NKikimrSchemeOp::TColumnTableSchema& tableSchema) const;
-    bool Validate(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;
+    bool ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;
 };
 }
diff --git a/ydb/core/tx/schemeshard/olap/indexes/schema.cpp b/ydb/core/tx/schemeshard/olap/indexes/schema.cpp
index 8b00178a459c..a0fe974394e0 100644
--- a/ydb/core/tx/schemeshard/olap/indexes/schema.cpp
+++ b/ydb/core/tx/schemeshard/olap/indexes/schema.cpp
@@ -83,7 +83,10 @@ void TOlapIndexesDescription::Serialize(NKikimrSchemeOp::TColumnTableSchema& tab
     }
 }
 
-bool TOlapIndexesDescription::Validate(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const {
+bool TOlapIndexesDescription::ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const {
+    if (opSchema.GetIndexes().size() == 0) {
+        return true;
+    }
     THashSet<ui32> usedIndexes;
     ui32 lastIdx = 0;
     for (const auto& proto : opSchema.GetIndexes()) {
diff --git a/ydb/core/tx/schemeshard/olap/indexes/schema.h b/ydb/core/tx/schemeshard/olap/indexes/schema.h
index 630016fe96a5..66a79eeed588 100644
--- a/ydb/core/tx/schemeshard/olap/indexes/schema.h
+++ b/ydb/core/tx/schemeshard/olap/indexes/schema.h
@@ -77,6 +77,6 @@ class TOlapIndexesDescription {
 
     void Parse(const NKikimrSchemeOp::TColumnTableSchema& tableSchema);
     void Serialize(NKikimrSchemeOp::TColumnTableSchema& tableSchema) const;
-    bool Validate(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;
+    bool ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;
 };
 }
diff --git a/ydb/core/tx/schemeshard/olap/operations/create_table.cpp b/ydb/core/tx/schemeshard/olap/operations/create_table.cpp
index 7e5211821d3b..01403b255aa2 100644
--- a/ydb/core/tx/schemeshard/olap/operations/create_table.cpp
+++ b/ydb/core/tx/schemeshard/olap/operations/create_table.cpp
@@ -99,7 +99,7 @@ class TTableConstructorBase {
 
 class TOlapPresetConstructor : public TTableConstructorBase {
     ui32 PresetId = 0;
-    TString PresetName = "default";
+    TString PresetName = TOlapStoreInfo::DefaultPresetName;
     const TOlapStoreInfo& StoreInfo;
     mutable bool NeedUpdateObject = false;
 public:
@@ -118,27 +118,16 @@ class TOlapPresetConstructor : public TTableConstructorBase {
             return false;
         }
 
-        if (description.HasSchemaPresetId()) {
-            PresetId = description.GetSchemaPresetId();
-            if (!StoreInfo.SchemaPresets.contains(PresetId)) {
-                errors.AddError(Sprintf("Specified schema preset %" PRIu32 " does not exist in tablestore", PresetId));
-                return false;
-            }
-            PresetName = StoreInfo.SchemaPresets.at(PresetId).GetName();
-        } else {
-            if (description.HasSchemaPresetName()) {
-                PresetName = description.GetSchemaPresetName();
-            }
-            if (!StoreInfo.SchemaPresetByName.contains(PresetName)) {
-                errors.AddError(Sprintf("Specified schema preset '%s' does not exist in tablestore", PresetName.c_str()));
-                return false;
-            }
-            PresetId = StoreInfo.SchemaPresetByName.at(PresetName);
-            Y_ABORT_UNLESS(StoreInfo.SchemaPresets.contains(PresetId));
+        auto* preset = StoreInfo.GetPresetOptional(description);
+        if (!preset) {
+            errors.AddError("preset not found in tables store");
+            return false;
         }
+        PresetId = preset->GetId();
+        PresetName = preset->GetName();
 
         if (description.HasSchema()) {
-            if (!GetSchema().Validate(description.GetSchema(), errors)) {
+            if (!GetSchema().ValidateForStore(description.GetSchema(), errors)) {
                 return false;
             }
         }
diff --git a/ydb/core/tx/schemeshard/olap/options/schema.cpp b/ydb/core/tx/schemeshard/olap/options/schema.cpp
index 59f9df521f34..033ef33ccd0d 100644
--- a/ydb/core/tx/schemeshard/olap/options/schema.cpp
+++ b/ydb/core/tx/schemeshard/olap/options/schema.cpp
@@ -42,7 +42,10 @@ void TOlapOptionsDescription::Serialize(NKikimrSchemeOp::TColumnTableSchema& tab
     }
 }
 
-bool TOlapOptionsDescription::Validate(const NKikimrSchemeOp::TColumnTableSchema& /*opSchema*/, IErrorCollector& /*errors*/) const {
+bool TOlapOptionsDescription::ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& /*errors*/) const {
+    if (!opSchema.HasOptions()) {
+        return true;
+    }
     return true;
 }
 
diff --git a/ydb/core/tx/schemeshard/olap/options/schema.h b/ydb/core/tx/schemeshard/olap/options/schema.h
index 070bd16437e7..575152a271d2 100644
--- a/ydb/core/tx/schemeshard/olap/options/schema.h
+++ b/ydb/core/tx/schemeshard/olap/options/schema.h
@@ -16,6 +16,6 @@ class TOlapOptionsDescription {
 
     void Parse(const NKikimrSchemeOp::TColumnTableSchema& tableSchema);
     void Serialize(NKikimrSchemeOp::TColumnTableSchema& tableSchema) const;
-    bool Validate(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;
+    bool ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;
 };
 }
diff --git a/ydb/core/tx/schemeshard/olap/schema/schema.cpp b/ydb/core/tx/schemeshard/olap/schema/schema.cpp
index 82e2a499bdd9..03428f46e551 100644
--- a/ydb/core/tx/schemeshard/olap/schema/schema.cpp
+++ b/ydb/core/tx/schemeshard/olap/schema/schema.cpp
@@ -71,16 +71,20 @@ void TOlapSchema::Serialize(NKikimrSchemeOp::TColumnTableSchema& tableSchemaExt)
     std::swap(resultLocal, tableSchemaExt);
 }
 
-bool TOlapSchema::Validate(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const {
-    if (!Columns.Validate(opSchema, errors)) {
+bool TOlapSchema::ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const {
+    if (!Columns.ValidateForStore(opSchema, errors)) {
         return false;
     }
 
-    if (!Indexes.Validate(opSchema, errors)) {
+    if (!Indexes.ValidateForStore(opSchema, errors)) {
         return false;
     }
 
-    if (!Options.Validate(opSchema, errors)) {
+    if (!Options.ValidateForStore(opSchema, errors)) {
+        return false;
+    }
+
+    if (!ColumnFamilies.ValidateForStore(opSchema, errors)) {
         return false;
     }
     return true;
diff --git a/ydb/core/tx/schemeshard/olap/schema/schema.h b/ydb/core/tx/schemeshard/olap/schema/schema.h
index 9e950b36c99e..3086ff883fa2 100644
--- a/ydb/core/tx/schemeshard/olap/schema/schema.h
+++ b/ydb/core/tx/schemeshard/olap/schema/schema.h
@@ -30,7 +30,7 @@ namespace NKikimr::NSchemeShard {
 
         void ParseFromLocalDB(const NKikimrSchemeOp::TColumnTableSchema& tableSchema);
         void Serialize(NKikimrSchemeOp::TColumnTableSchema& tableSchema) const;
-        bool Validate(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;
+        bool ValidateForStore(const NKikimrSchemeOp::TColumnTableSchema& opSchema, IErrorCollector& errors) const;
         bool ValidateTtlSettings(const NKikimrSchemeOp::TColumnDataLifeCycle& ttlSettings, const TOperationContext& context, IErrorCollector& errors) const;
     };
 
diff --git a/ydb/core/tx/schemeshard/olap/store/store.h b/ydb/core/tx/schemeshard/olap/store/store.h
index 84ae9148573c..b5719f3aed91 100644
--- a/ydb/core/tx/schemeshard/olap/store/store.h
+++ b/ydb/core/tx/schemeshard/olap/store/store.h
@@ -17,6 +17,8 @@ struct TOlapStoreInfo {
     NKikimrSchemeOp::TColumnStoreDescription Description;
     ui64 AlterVersion = 0;
 public:
+    static const inline TString DefaultPresetName = "default";
+
     using TPtr = std::shared_ptr<TOlapStoreInfo>;
 
     class TLayoutInfo {
@@ -99,6 +101,41 @@ struct TOlapStoreInfo {
             shardInfoProto->SetLocalId(idx.GetLocalId().GetValue());
         }
     }
+
+    const TOlapStoreSchemaPreset* GetPresetOptional(const ui32 presetId) const {
+        auto it = SchemaPresets.find(presetId);
+        if (it == SchemaPresets.end()) {
+            return nullptr;
+        }
+        return &it->second;
+    }
+
+    const TOlapStoreSchemaPreset& GetPresetVerified(const ui32 presetId) const {
+        auto* result = GetPresetOptional(presetId);
+        AFL_VERIFY(result);
+        return *result;
+    }
+
+    const TOlapStoreSchemaPreset* GetPresetOptional(const TString& presetName) const {
+        auto it = SchemaPresetByName.find(presetName);
+        if (it == SchemaPresetByName.end()) {
+            return nullptr;
+        }
+        return &GetPresetVerified(it->second);
+    }
+
+    const TOlapStoreSchemaPreset* GetPresetOptional(const NKikimrSchemeOp::TColumnTableDescription& description) const {
+        if (description.HasSchemaPresetId()) {
+            return GetPresetOptional(description.GetSchemaPresetId());
+        } else {
+            if (description.HasSchemaPresetName()) {
+                return GetPresetOptional(description.GetSchemaPresetName());
+            } else {
+                return GetPresetOptional(DefaultPresetName);
+            }
+        }
+    }
+
     void SerializeDescription(NKikimrSchemeOp::TColumnStoreDescription& descriptionProto) const;
     void ParseFromLocalDB(const NKikimrSchemeOp::TColumnStoreDescription& descriptionProto);
     bool ParseFromRequest(const NKikimrSchemeOp::TColumnStoreDescription& descriptionProto, IErrorCollector& errors);
diff --git a/ydb/core/tx/schemeshard/schemeshard__operation_modify_acl.cpp b/ydb/core/tx/schemeshard/schemeshard__operation_modify_acl.cpp
index f54c004cf5f9..b021c7d656c7 100644
--- a/ydb/core/tx/schemeshard/schemeshard__operation_modify_acl.cpp
+++ b/ydb/core/tx/schemeshard/schemeshard__operation_modify_acl.cpp
@@ -54,7 +54,7 @@ class TModifyACL: public TSubOperationBase {
         }
 
         TString errStr;
-        if (!context.SS->CheckApplyIf(Transaction, errStr)) {
+        if (!context.SS->CheckApplyIf(Transaction, errStr, path->PathType)) {
             result->SetError(NKikimrScheme::StatusPreconditionFailed, errStr);
             return result;
         }
diff --git a/ydb/core/tx/schemeshard/schemeshard_build_index.cpp b/ydb/core/tx/schemeshard/schemeshard_build_index.cpp
index 90a93627e866..9071b11c5b72 100644
--- a/ydb/core/tx/schemeshard/schemeshard_build_index.cpp
+++ b/ydb/core/tx/schemeshard/schemeshard_build_index.cpp
@@ -40,6 +40,10 @@ void TSchemeShard::Handle(TEvDataShard::TEvLocalKMeansResponse::TPtr& ev, const
     Execute(CreateTxReply(ev), ctx);
 }
 
+void TSchemeShard::Handle(TEvDataShard::TEvPrefixKMeansResponse::TPtr& ev, const TActorContext& ctx) {
+    Execute(CreateTxReply(ev), ctx);
+}
+
 void TSchemeShard::Handle(TEvIndexBuilder::TEvUploadSampleKResponse::TPtr& ev, const TActorContext& ctx) {
     Execute(CreateTxReply(ev), ctx);
 }
diff --git a/ydb/core/tx/schemeshard/schemeshard_build_index__create.cpp b/ydb/core/tx/schemeshard/schemeshard_build_index__create.cpp
index 98c75f6de42b..5c5e08eff44b 100644
--- a/ydb/core/tx/schemeshard/schemeshard_build_index__create.cpp
+++ b/ydb/core/tx/schemeshard/schemeshard_build_index__create.cpp
@@ -224,13 +224,15 @@ class TSchemeShard::TIndexBuilder::TTxCreate: public TSchemeShard::TIndexBuilder
             explain = "unsupported index type to build";
             return false;
         case Ydb::Table::TableIndex::TypeCase::kGlobalVectorKmeansTreeIndex: {
-            buildInfo.BuildKind = TIndexBuildInfo::EBuildKind::BuildVectorIndex;
+            buildInfo.BuildKind = index.index_columns().size() == 1
+                ? TIndexBuildInfo::EBuildKind::BuildVectorIndex
+                : TIndexBuildInfo::EBuildKind::BuildPrefixedVectorIndex;
             buildInfo.IndexType = NKikimrSchemeOp::EIndexType::EIndexTypeGlobalVectorKmeansTree;
             NKikimrSchemeOp::TVectorIndexKmeansTreeDescription vectorIndexKmeansTreeDescription;
             *vectorIndexKmeansTreeDescription.MutableSettings() = index.global_vector_kmeans_tree_index().vector_settings();
             buildInfo.SpecializedIndexDescription = vectorIndexKmeansTreeDescription;
             buildInfo.KMeans.K = std::max<ui32>(2, vectorIndexKmeansTreeDescription.GetSettings().clusters());
-            buildInfo.KMeans.Levels = std::max<ui32>(1, vectorIndexKmeansTreeDescription.GetSettings().levels());
+            buildInfo.KMeans.Levels = buildInfo.IsBuildPrefixedVectorIndex() + std::max<ui32>(1, vectorIndexKmeansTreeDescription.GetSettings().levels());
             break;
         }
         case Ydb::Table::TableIndex::TypeCase::TYPE_NOT_SET:
diff --git a/ydb/core/tx/schemeshard/schemeshard_build_index__progress.cpp b/ydb/core/tx/schemeshard/schemeshard_build_index__progress.cpp
index e124b34d69cc..df3e83bc1b80 100644
--- a/ydb/core/tx/schemeshard/schemeshard_build_index__progress.cpp
+++ b/ydb/core/tx/schemeshard/schemeshard_build_index__progress.cpp
@@ -21,6 +21,9 @@
 namespace NKikimr {
 namespace NSchemeShard {
 
+// TODO(mbkkt) get table rows count (but even better to have unique prefixes count)
+static constexpr ui64 TableSize = 1'000;
+
 static constexpr const char* Name(TIndexBuildInfo::EState state) noexcept {
     switch (state) {
     case TIndexBuildInfo::EState::Invalid:
@@ -64,7 +67,7 @@ static constexpr const char* Name(TIndexBuildInfo::EState state) noexcept {
 static std::tuple<NTableIndex::TClusterId, NTableIndex::TClusterId, NTableIndex::TClusterId> ComputeKMeansBoundaries(const NSchemeShard::TTableInfo& tableInfo, const TIndexBuildInfo& buildInfo) {
     const auto& kmeans = buildInfo.KMeans;
     Y_ASSERT(kmeans.K != 0);
-    const auto count = TIndexBuildInfo::TKMeans::BinPow(kmeans.K, kmeans.Level);
+    const auto count = kmeans.ChildCount();
     NTableIndex::TClusterId step = 1;
     auto parts = count;
     auto shards = tableInfo.GetShard2PartitionIdx().size();
@@ -321,10 +324,14 @@ THolder<TEvSchemeShard::TEvModifySchemeTransaction> CreateBuildPropose(
         buildInfo.SerializeToProto(ss, modifyScheme.MutableInitiateIndexBuild());
         const auto& indexDesc = modifyScheme.GetInitiateIndexBuild().GetIndex();
         const auto& baseTableColumns = NTableIndex::ExtractInfo(tableInfo);
-        const auto& indexKeys = NTableIndex::ExtractInfo(indexDesc);
+        auto indexKeys = NTableIndex::ExtractInfo(indexDesc);
+        if (buildInfo.IsBuildPrefixedVectorIndex() && buildInfo.KMeans.Level != 1) {
+            Y_ASSERT(indexKeys.KeyColumns.size() >= 2);
+            indexKeys.KeyColumns.erase(indexKeys.KeyColumns.begin(), indexKeys.KeyColumns.end() - 1);
+        }
         implTableColumns = CalcTableImplDescription(buildInfo.IndexType, baseTableColumns, indexKeys);
-        Y_ABORT_UNLESS(indexKeys.KeyColumns.size() == 1);
-        implTableColumns.Columns.emplace(indexKeys.KeyColumns[0]);
+        Y_ABORT_UNLESS(indexKeys.KeyColumns.size() >= 1);
+        implTableColumns.Columns.emplace(indexKeys.KeyColumns.back());
         modifyScheme.ClearInitiateIndexBuild();
     }
 
@@ -337,26 +344,38 @@ THolder<TEvSchemeShard::TEvModifySchemeTransaction> CreateBuildPropose(
     modifyScheme.SetOperationType(NKikimrSchemeOp::ESchemeOpInitiateBuildIndexImplTable);
     auto& op = *modifyScheme.MutableCreateTable();
     std::string_view suffix = buildInfo.KMeans.Level % 2 != 0 ? BuildSuffix0 : BuildSuffix1;
+    auto resetPartitionsSettings = [&] {
+        auto& config = *op.MutablePartitionConfig();
+        config.SetShadowData(false);
+
+        auto& policy = *config.MutablePartitioningPolicy();
+        policy.SetSizeToSplit(0); // disable auto split/merge
+        policy.ClearFastSplitSettings();
+        policy.ClearSplitByLoadSettings();
+
+        op.ClearSplitBoundary();
+        return &policy;
+    };
+    if (buildInfo.IsBuildPrefixedVectorIndex() && buildInfo.KMeans.Level == 1) {
+        op.SetName(TString::Join(PostingTable, suffix));
+        NTableIndex::FillIndexTableColumns(tableInfo->Columns, implTableColumns.Keys, implTableColumns.Columns, op);
+        auto& policy = *resetPartitionsSettings();
+        const auto shards = tableInfo->GetShard2PartitionIdx().size();
+        policy.SetMinPartitionsCount(shards);
+        policy.SetMaxPartitionsCount(shards);
+        return propose;
+    }
     op = CalcVectorKmeansTreePostingImplTableDesc({}, tableInfo, tableInfo->PartitionConfig(), implTableColumns, {}, suffix);
-
     const auto [count, parts, step] = ComputeKMeansBoundaries(*tableInfo, buildInfo);
 
-    auto& config = *op.MutablePartitionConfig();
-    config.SetShadowData(false);
-
-    auto& policy = *config.MutablePartitioningPolicy();
-    policy.SetSizeToSplit(0); // disable auto split/merge
-    policy.ClearFastSplitSettings();
-    policy.ClearSplitByLoadSettings();
-
-    op.ClearSplitBoundary();
+    auto& policy = *resetPartitionsSettings();
     static constexpr std::string_view LogPrefix = "Create build table boundaries for ";
     LOG_D(buildInfo.Id << " table " << suffix
         << ", count: " << count << ", parts: " << parts << ", step: " << step
         << ", kmeans: " << buildInfo.KMeansTreeToDebugStr());
     if (parts > 1) {
-        const auto parentFrom = buildInfo.KMeans.ParentEnd + 1;
-        for (auto i = parentFrom + step, e = parentFrom + count; i < e; i += step) {
+        const auto from = buildInfo.KMeans.ChildBegin;
+        for (auto i = from + step, e = from + count; i < e; i += step) {
             LOG_D(buildInfo.Id << " table " << suffix << " value: " << i);
             auto cell = TCell::Make(i);
             op.AddSplitBoundary()->SetSerializedKeyPrefix(TSerializedCellVec::Serialize({&cell, 1}));
@@ -491,14 +510,16 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
 
     TDeque<std::tuple<TTabletId, ui64, THolder<IEventBase>>> ToTabletSend;
 
-    template <typename Record>
+    template <bool WithSnapshot = true, typename Record>
     TTabletId CommonFillRecord(Record& record, TShardIdx shardIdx, TIndexBuildInfo& buildInfo) {
         TTabletId shardId = Self->ShardInfos.at(shardIdx).TabletID;
         record.SetTabletId(ui64(shardId));
-        if (buildInfo.SnapshotTxId) {
-            Y_ASSERT(buildInfo.SnapshotStep);
-            record.SetSnapshotTxId(ui64(buildInfo.SnapshotTxId));
-            record.SetSnapshotStep(ui64(buildInfo.SnapshotStep));
+        if constexpr (WithSnapshot) {
+            if (buildInfo.SnapshotTxId) {
+                Y_ASSERT(buildInfo.SnapshotStep);
+                record.SetSnapshotTxId(ui64(buildInfo.SnapshotTxId));
+                record.SetSnapshotStep(ui64(buildInfo.SnapshotStep));
+            }
         }
 
         auto& shardStatus = buildInfo.Shards.at(shardIdx);
@@ -521,7 +542,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
         auto ev = MakeHolder<TEvDataShard::TEvSampleKRequest>();
         ev->Record.SetId(ui64(BuildId));
 
-        if (buildInfo.KMeans.Parent == 0) {
+        if (buildInfo.KMeans.Level == 1) {
             buildInfo.TablePathId.ToProto(ev->Record.MutablePathId());
         } else {
             auto path = TPath::Init(buildInfo.TablePathId, Self).Dive(buildInfo.IndexName);
@@ -537,7 +558,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
             range.Serialize(*ev->Record.MutableKeyRange());
         }
 
-        ev->Record.AddColumns(buildInfo.IndexColumns[0]);
+        ev->Record.AddColumns(buildInfo.IndexColumns.back());
 
         auto shardId = CommonFillRecord(ev->Record, shardIdx, buildInfo);
         ev->Record.SetSeed(ui64(shardId));
@@ -552,7 +573,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
         ev->Record.SetId(ui64(BuildId));
 
         auto path = TPath::Init(buildInfo.TablePathId, Self).Dive(buildInfo.IndexName);
-        if (buildInfo.KMeans.Parent == 0) {
+        if (buildInfo.KMeans.Level == 1) {
             buildInfo.TablePathId.ToProto(ev->Record.MutablePathId());
         } else {
             path.Dive(buildInfo.KMeans.ReadFrom())->PathId.ToProto(ev->Record.MutablePathId());
@@ -563,7 +584,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
             buildInfo.SpecializedIndexDescription).GetSettings().settings();
         ev->Record.SetUpload(buildInfo.KMeans.GetUpload());
         ev->Record.SetParent(buildInfo.KMeans.Parent);
-        ev->Record.SetChild(buildInfo.KMeans.ChildBegin);
+        ev->Record.SetChild(buildInfo.KMeans.Child);
 
         auto& clusters = *ev->Record.MutableClusters();
         clusters.Reserve(buildInfo.Sample.Rows.size());
@@ -573,7 +594,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
 
         ev->Record.SetPostingName(path.Dive(buildInfo.KMeans.WriteTo()).PathString());
 
-        ev->Record.SetEmbeddingColumn(buildInfo.IndexColumns[0]);
+        ev->Record.SetEmbeddingColumn(buildInfo.IndexColumns.back());
         *ev->Record.MutableDataColumns() = {
             buildInfo.DataColumns.begin(), buildInfo.DataColumns.end()
         };
@@ -596,7 +617,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
         ev->Record.SetId(ui64(BuildId));
 
         auto path = TPath::Init(buildInfo.TablePathId, Self).Dive(buildInfo.IndexName);
-        if (buildInfo.KMeans.Parent == 0) {
+        if (buildInfo.KMeans.Level == 1) {
             buildInfo.TablePathId.ToProto(ev->Record.MutablePathId());
         } else {
             path.Dive(buildInfo.KMeans.ReadFrom())->PathId.ToProto(ev->Record.MutablePathId());
@@ -614,12 +635,11 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
         if (buildInfo.KMeans.State != TIndexBuildInfo::TKMeans::MultiLocal) {
             ev->Record.SetParentFrom(buildInfo.KMeans.Parent);
             ev->Record.SetParentTo(buildInfo.KMeans.Parent);
-            ev->Record.SetChild(buildInfo.KMeans.ChildBegin);
+            ev->Record.SetChild(buildInfo.KMeans.Child);
         } else {
             const auto& range = buildInfo.Shards.at(shardIdx).Range;
             const auto [parentFrom, parentTo] = buildInfo.KMeans.RangeToBorders(range);
-            // child begin for parent from = (last child begin + K) - (last parent - parent from + 1) * K
-            const auto childBegin = buildInfo.KMeans.ChildBegin - (buildInfo.KMeans.ParentEnd - parentFrom) * buildInfo.KMeans.K;
+            const auto childBegin = buildInfo.KMeans.ChildBegin + (parentFrom - buildInfo.KMeans.ParentBegin) * buildInfo.KMeans.K;
             LOG_D("shard " << shardIdx << ", parent range { From: " << parentFrom << ", To: " << parentTo << " }, child begin " << childBegin);
             ev->Record.SetParentFrom(parentFrom);
             ev->Record.SetParentTo(parentTo);
@@ -630,7 +650,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
         path.Rise().Dive(NTableIndex::NTableVectorKmeansTreeIndex::LevelTable);
         ev->Record.SetLevelName(path.PathString());
 
-        ev->Record.SetEmbeddingColumn(buildInfo.IndexColumns[0]);
+        ev->Record.SetEmbeddingColumn(buildInfo.IndexColumns.back());
         *ev->Record.MutableDataColumns() = {
             buildInfo.DataColumns.begin(), buildInfo.DataColumns.end()
         };
@@ -642,6 +662,46 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
         ToTabletSend.emplace_back(shardId, ui64(BuildId), std::move(ev));
     }
 
+    void SendPrefixKMeansRequest(TShardIdx shardIdx, TIndexBuildInfo& buildInfo) {
+        Y_ASSERT(buildInfo.IsBuildPrefixedVectorIndex());
+        Y_ASSERT(buildInfo.KMeans.Parent == buildInfo.KMeans.ParentEnd());
+        Y_ASSERT(buildInfo.KMeans.Level == 2);
+
+        auto ev = MakeHolder<TEvDataShard::TEvPrefixKMeansRequest>();
+        ev->Record.SetId(ui64(BuildId));
+
+        auto path = TPath::Init(buildInfo.TablePathId, Self).Dive(buildInfo.IndexName);
+        path.Dive(buildInfo.KMeans.ReadFrom())->PathId.ToProto(ev->Record.MutablePathId());
+        path.Rise();
+        *ev->Record.MutableSettings() = std::get<NKikimrSchemeOp::TVectorIndexKmeansTreeDescription>(
+            buildInfo.SpecializedIndexDescription).GetSettings().settings();
+        ev->Record.SetK(buildInfo.KMeans.K);
+        ev->Record.SetUpload(buildInfo.KMeans.GetUpload());
+
+        ev->Record.SetNeedsRounds(3); // TODO(mbkkt) should be configurable
+
+        const auto shardIndex = buildInfo.Shards.at(shardIdx).Index;
+        ev->Record.SetChild(buildInfo.KMeans.ChildBegin + (1 + TableSize) * shardIndex);
+
+        ev->Record.SetPostingName(path.Dive(buildInfo.KMeans.WriteTo()).PathString());
+        path.Rise().Dive(NTableIndex::NTableVectorKmeansTreeIndex::LevelTable);
+        ev->Record.SetLevelName(path.PathString());
+        path.Rise().Dive(NTableIndex::NTableVectorKmeansTreeIndex::PrefixTable);
+        ev->Record.SetPrefixName(path.PathString());
+
+        ev->Record.SetPrefixColumns(buildInfo.IndexColumns.size() - 1);
+        ev->Record.SetEmbeddingColumn(buildInfo.IndexColumns.back());
+        *ev->Record.MutableDataColumns() = {
+            buildInfo.DataColumns.begin(), buildInfo.DataColumns.end()
+        };
+
+        auto shardId = CommonFillRecord<false>(ev->Record, shardIdx, buildInfo);
+        ev->Record.SetSeed(ui64(shardId));
+        LOG_D("TTxBuildProgress: TEvPrefixKMeansRequest: " << ev->Record.ShortDebugString());
+
+        ToTabletSend.emplace_back(shardId, ui64(BuildId), std::move(ev));
+    }
+
     void SendBuildIndexRequest(TShardIdx shardIdx, TIndexBuildInfo& buildInfo) {
         auto ev = MakeHolder<TEvDataShard::TEvBuildIndexCreateRequest>();
         ev->Record.SetBuildIndexId(ui64(BuildId));
@@ -649,9 +709,12 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
         ev->Record.SetOwnerId(buildInfo.TablePathId.OwnerId);
         ev->Record.SetPathId(buildInfo.TablePathId.LocalPathId);
 
-        if (buildInfo.IsBuildSecondaryIndex()) {
+        if (buildInfo.IsBuildColumns()) {
+            buildInfo.SerializeToProto(Self, ev->Record.MutableColumnBuildSettings());
+        } else {
             if (buildInfo.TargetName.empty()) {
-                TPath implTable = TPath::Init(buildInfo.TablePathId, Self).Dive(buildInfo.IndexName).Dive(NTableIndex::ImplTable);
+                TPath implTable = TPath::Init(buildInfo.TablePathId, Self).Dive(buildInfo.IndexName).Dive(
+                    buildInfo.IsBuildPrefixedVectorIndex() ? buildInfo.KMeans.WriteTo() : NTableIndex::ImplTable);
                 buildInfo.TargetName = implTable.PathString();
 
                 const auto& implTableInfo = Self->Tables.at(implTable.Base()->PathId);
@@ -662,6 +725,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
                     buildInfo.FillIndexColumns.emplace_back(x);
                     implTableColumns.Columns.erase(x);
                 }
+                // TODO(mbkkt) why order doesn't matter?
                 buildInfo.FillDataColumns.clear();
                 buildInfo.FillDataColumns.reserve(implTableColumns.Columns.size());
                 for (const auto& x: implTableColumns.Columns) {
@@ -676,8 +740,6 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
                 buildInfo.FillDataColumns.begin(),
                 buildInfo.FillDataColumns.end()
             };
-        } else if (buildInfo.IsBuildColumns()) {
-            buildInfo.SerializeToProto(Self, ev->Record.MutableColumnBuildSettings());
         }
 
         ev->Record.SetTargetName(buildInfo.TargetName);
@@ -701,7 +763,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
         Y_ASSERT(buildInfo.Sample.Rows.size() <= buildInfo.KMeans.K);
         auto actor = new TUploadSampleK(path.PathString(),
             buildInfo.Limits, Self->SelfId(), ui64(BuildId),
-            buildInfo.Sample.Rows, buildInfo.KMeans.Parent, buildInfo.KMeans.ChildBegin);
+            buildInfo.Sample.Rows, buildInfo.KMeans.Parent, buildInfo.KMeans.Child);
 
         TActivationContext::AsActorContext().MakeFor(Self->SelfId()).Register(actor);
         buildInfo.Sample.State = TIndexBuildInfo::TSample::EState::Upload;
@@ -758,6 +820,14 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
                buildInfo.DoneShards.size() == buildInfo.Shards.size();
     }
 
+    bool FillPrefixKMeans(TIndexBuildInfo& buildInfo) {
+        if (buildInfo.DoneShards.empty() && buildInfo.ToUploadShards.empty() && buildInfo.InProgressShards.empty()) {
+            AddAllShards(buildInfo);
+        }
+        return SendToShards(buildInfo, [&](TShardIdx shardIdx) { SendPrefixKMeansRequest(shardIdx, buildInfo); }) &&
+               buildInfo.DoneShards.size() == buildInfo.Shards.size();
+    }
+
     bool InitSingleKMeans(TIndexBuildInfo& buildInfo) {
         if (!buildInfo.DoneShards.empty() || !buildInfo.InProgressShards.empty() || !buildInfo.ToUploadShards.empty()) {
             return false;
@@ -866,6 +936,47 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
     }
 
     bool FillVectorIndex(TTransactionContext& txc, TIndexBuildInfo& buildInfo) {
+        if (buildInfo.IsBuildPrefixedVectorIndex() && buildInfo.KMeans.Level == 1) {
+            LOG_D("FillIndex::Prefixed::Level1::Start " << buildInfo.KMeansTreeToDebugStr());
+            if (!FillTable(buildInfo)) {
+                return false;
+            }
+            const ui64 doneShards = buildInfo.DoneShards.size();
+
+            ClearDoneShards(txc, buildInfo);
+            Y_ABORT_UNLESS(buildInfo.KMeans.PrefixTableDone(TableSize, doneShards));
+            PersistKMeansState(txc, buildInfo);
+            NIceDb::TNiceDb db{txc.DB};
+            Self->PersistBuildIndexUploadReset(db, buildInfo);
+            LOG_D("FillIndex::Prefixed::Level1::Done " << buildInfo.KMeansTreeToDebugStr());
+            ChangeState(BuildId, TIndexBuildInfo::EState::CreateBuild);
+            Progress(BuildId);
+            return false;
+        }
+
+        if (buildInfo.IsBuildPrefixedVectorIndex() && buildInfo.KMeans.Level == 2) {
+            LOG_D("FillIndex::Prefixed::Level2::Start " << buildInfo.KMeansTreeToDebugStr());
+            if (!FillPrefixKMeans(buildInfo)) {
+                return false;
+            }
+
+            ClearDoneShards(txc, buildInfo);
+            Y_ASSERT(buildInfo.KMeans.State == TIndexBuildInfo::TKMeans::MultiLocal);
+            const bool needsAnotherLevel = buildInfo.KMeans.NextLevel();
+            buildInfo.KMeans.State = TIndexBuildInfo::TKMeans::MultiLocal;
+            buildInfo.KMeans.Parent = buildInfo.KMeans.ParentEnd();
+            PersistKMeansState(txc, buildInfo);
+            NIceDb::TNiceDb db{txc.DB};
+            Self->PersistBuildIndexUploadReset(db, buildInfo);
+            LOG_D("FillIndex::Prefixed::Level2::Done " << buildInfo.KMeansTreeToDebugStr());
+            if (!needsAnotherLevel) {
+                return true;
+            }
+            ChangeState(BuildId, TIndexBuildInfo::EState::DropBuild);
+            Progress(BuildId);
+            return false;
+        }
+
         if (buildInfo.Sample.State == TIndexBuildInfo::TSample::EState::Upload) {
             return false;
         }
@@ -932,9 +1043,9 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
     }
 
     bool FillIndex(TTransactionContext& txc, TIndexBuildInfo& buildInfo) {
-        // About Parent == 0, for now build index impl tables don't need snapshot,
+        // About Level == 1, for now build index impl tables don't need snapshot,
         // because they're used only by build index
-        if (buildInfo.KMeans.Parent == 0 && !buildInfo.SnapshotTxId) {
+        if (buildInfo.KMeans.Level == 1 && !buildInfo.SnapshotTxId) {
             Y_ABORT_UNLESS(!buildInfo.SnapshotStep);
             Y_ABORT_UNLESS(Self->TablesWithSnapshots.contains(buildInfo.TablePathId));
             Y_ABORT_UNLESS(Self->TablesWithSnapshots.at(buildInfo.TablePathId) == buildInfo.InitiateTxId);
@@ -1012,11 +1123,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
             } else if (!buildInfo.InitiateTxDone) {
                 Send(Self->SelfId(), MakeHolder<TEvSchemeShard::TEvNotifyTxCompletion>(ui64(buildInfo.InitiateTxId)));
             } else {
-                if (buildInfo.IsBuildVectorIndex() && buildInfo.IndexColumns.size() != 1) {
-                    // TODO(mbkkt) in this state every prefixed vector index is empty
-                    // So we need some new code to fill it
-                    ChangeState(BuildId, TIndexBuildInfo::EState::Applying);
-                } else if (buildInfo.IsBuildVectorIndex() && buildInfo.KMeans.NeedsAnotherLevel()) {
+                if (buildInfo.IsBuildVectorIndex() && buildInfo.KMeans.NeedsAnotherLevel()) {
                     ChangeState(BuildId, TIndexBuildInfo::EState::CreateBuild);
                 } else {
                     ChangeState(BuildId, TIndexBuildInfo::EState::Filling);
@@ -1200,7 +1307,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
         Y_ASSERT(buildInfo.DoneShards.empty());
 
         TTableInfo::TPtr table;
-        if (buildInfo.KMeans.Parent == 0) {
+        if (buildInfo.KMeans.Level == 1) {
             table = Self->Tables.at(buildInfo.TablePathId);
         } else {
             auto path = TPath::Init(buildInfo.TablePathId, Self).Dive(buildInfo.IndexName);
@@ -1218,7 +1325,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil
             shardRange.To = bound;
             LOG_D("shard " << x.ShardIdx << " range " << buildInfo.KMeans.RangeToDebugStr(shardRange));
             buildInfo.AddParent(shardRange, x.ShardIdx);
-            auto [it, emplaced] = buildInfo.Shards.emplace(x.ShardIdx, TIndexBuildInfo::TShardStatus{std::move(shardRange), ""});
+            auto [it, emplaced] = buildInfo.Shards.emplace(x.ShardIdx, TIndexBuildInfo::TShardStatus{std::move(shardRange), "", buildInfo.Shards.size()});
             Y_ASSERT(emplaced);
             shardRange.From = std::move(bound);
 
@@ -1763,6 +1870,131 @@ struct TSchemeShard::TIndexBuilder::TTxReplyReshuffleKMeans: public TSchemeShard
     }
 };
 
+struct TSchemeShard::TIndexBuilder::TTxReplyPrefixKMeans: public TSchemeShard::TIndexBuilder::TTxReply {
+private:
+    TEvDataShard::TEvPrefixKMeansResponse::TPtr Prefix;
+
+public:
+    explicit TTxReplyPrefixKMeans(TSelf* self, TEvDataShard::TEvPrefixKMeansResponse::TPtr& prefix)
+        : TTxReply(self)
+        , Prefix(prefix)
+    {
+    }
+
+    bool DoExecute(TTransactionContext& txc, const TActorContext& ctx) override {
+        auto& record = Prefix->Get()->Record;
+
+        LOG_I("TTxReply : TEvPrefixKMeansResponse, id# " << record.GetId());
+
+        const auto buildId = TIndexBuildId(record.GetId());
+        const auto* buildInfoPtr = Self->IndexBuilds.FindPtr(buildId);
+        if (!buildInfoPtr) {
+            return true;
+        }
+        auto& buildInfo = *buildInfoPtr->Get();
+        LOG_D("TTxReply : TEvPrefixKMeansResponse"
+              << ", TIndexBuildInfo: " << buildInfo
+              << ", record: " << record.ShortDebugString());
+
+        TTabletId shardId = TTabletId(record.GetTabletId());
+        if (!Self->TabletIdToShardIdx.contains(shardId)) {
+            return true;
+        }
+
+        TShardIdx shardIdx = Self->TabletIdToShardIdx.at(shardId);
+        if (!buildInfo.Shards.contains(shardIdx)) {
+            return true;
+        }
+
+        switch (const auto state = buildInfo.State; state) {
+        case TIndexBuildInfo::EState::Filling:
+        {
+            TIndexBuildInfo::TShardStatus& shardStatus = buildInfo.Shards.at(shardIdx);
+
+            auto actualSeqNo = std::pair<ui64, ui64>(Self->Generation(), shardStatus.SeqNoRound);
+            auto recordSeqNo = std::pair<ui64, ui64>(record.GetRequestSeqNoGeneration(), record.GetRequestSeqNoRound());
+
+            if (actualSeqNo != recordSeqNo) {
+                LOG_D("TTxReply : TEvPrefixKMeansResponse"
+                      << " ignore progress message by seqNo"
+                      << ", TIndexBuildInfo: " << buildInfo
+                      << ", actual seqNo for the shard " << shardId << " (" << shardIdx << ") is: "  << Self->Generation() << ":" <<  shardStatus.SeqNoRound
+                      << ", record: " << record.ShortDebugString());
+                Y_ABORT_UNLESS(actualSeqNo > recordSeqNo);
+                return true;
+            }
+
+            TBillingStats stats{record.GetUploadRows(), record.GetUploadBytes(), record.GetReadRows(), record.GetReadBytes()};
+            shardStatus.Processed += stats;
+            buildInfo.Processed += stats;
+
+            NYql::TIssues issues;
+            NYql::IssuesFromMessage(record.GetIssues(), issues);
+            shardStatus.DebugMessage = issues.ToString();
+
+            NIceDb::TNiceDb db(txc.DB);
+            shardStatus.Status = record.GetStatus();
+
+            switch (shardStatus.Status) {
+            case  NKikimrIndexBuilder::EBuildStatus::DONE:
+                if (buildInfo.InProgressShards.erase(shardIdx)) {
+                    buildInfo.DoneShards.emplace_back(shardIdx);
+                }
+                break;
+            case  NKikimrIndexBuilder::EBuildStatus::ABORTED:
+                // datashard gracefully rebooted, reschedule shard
+                if (buildInfo.InProgressShards.erase(shardIdx)) {
+                    buildInfo.ToUploadShards.emplace_front(shardIdx);
+                }
+                break;
+            case  NKikimrIndexBuilder::EBuildStatus::BUILD_ERROR:
+            case  NKikimrIndexBuilder::EBuildStatus::BAD_REQUEST:
+                buildInfo.Issue += TStringBuilder()
+                    << "One of the shards report "<< shardStatus.Status
+                    << " at Filling stage, process has to be canceled"
+                    << ", shardId: " << shardId
+                    << ", shardIdx: " << shardIdx;
+                Self->PersistBuildIndexIssue(db, buildInfo);
+                ChangeState(buildInfo.Id, TIndexBuildInfo::EState::Rejection_Applying);
+
+                Progress(buildId);
+                return true;
+            case  NKikimrIndexBuilder::EBuildStatus::INVALID:
+            case  NKikimrIndexBuilder::EBuildStatus::ACCEPTED:
+            case  NKikimrIndexBuilder::EBuildStatus::IN_PROGRESS:
+                Y_ABORT("Unreachable");
+            }
+            Self->PersistBuildIndexUploadProgress(db, buildId, shardIdx, shardStatus);
+            Self->IndexBuildPipes.Close(buildId, shardId, ctx);
+            Progress(buildId);
+            break;
+        }
+        case TIndexBuildInfo::EState::AlterMainTable:
+        case TIndexBuildInfo::EState::Invalid:
+        case TIndexBuildInfo::EState::Locking:
+        case TIndexBuildInfo::EState::GatheringStatistics:
+        case TIndexBuildInfo::EState::Initiating:
+        case TIndexBuildInfo::EState::DropBuild:
+        case TIndexBuildInfo::EState::CreateBuild:
+        case TIndexBuildInfo::EState::Applying:
+        case TIndexBuildInfo::EState::Unlocking:
+        case TIndexBuildInfo::EState::Done:
+            Y_FAIL_S("Unreachable " << Name(state));
+        case TIndexBuildInfo::EState::Cancellation_Applying:
+        case TIndexBuildInfo::EState::Cancellation_Unlocking:
+        case TIndexBuildInfo::EState::Cancelled:
+        case TIndexBuildInfo::EState::Rejection_Applying:
+        case TIndexBuildInfo::EState::Rejection_Unlocking:
+        case TIndexBuildInfo::EState::Rejected:
+            LOG_D("TTxReply : TEvPrefixKMeansResponse"
+                  << " superfluous message " << record.ShortDebugString());
+            break;
+        }
+
+        return true;
+    }
+};
+
 struct TSchemeShard::TIndexBuilder::TTxReplyUpload: public TSchemeShard::TIndexBuilder::TTxReply  {
 private:
     TEvIndexBuilder::TEvUploadSampleKResponse::TPtr Upload;
@@ -2398,6 +2630,10 @@ ITransaction* TSchemeShard::CreateTxReply(TEvDataShard::TEvLocalKMeansResponse::
     return new TIndexBuilder::TTxReplyLocalKMeans(this, local);
 }
 
+ITransaction* TSchemeShard::CreateTxReply(TEvDataShard::TEvPrefixKMeansResponse::TPtr& prefix) {
+    return new TIndexBuilder::TTxReplyPrefixKMeans(this, prefix);
+}
+
 ITransaction* TSchemeShard::CreateTxReply(TEvIndexBuilder::TEvUploadSampleKResponse::TPtr& upload) {
     return new TIndexBuilder::TTxReplyUpload(this, upload);
 }
diff --git a/ydb/core/tx/schemeshard/schemeshard_impl.cpp b/ydb/core/tx/schemeshard/schemeshard_impl.cpp
index 6cd469fdee8b..d2a74329d106 100644
--- a/ydb/core/tx/schemeshard/schemeshard_impl.cpp
+++ b/ydb/core/tx/schemeshard/schemeshard_impl.cpp
@@ -1256,120 +1256,158 @@ TString TSchemeShard::PathToString(TPathElement::TPtr item) {
     return path.PathString();
 }
 
-bool TSchemeShard::CheckApplyIf(const NKikimrSchemeOp::TModifyScheme &scheme, TString &errStr) {
+bool TSchemeShard::CheckApplyIf(const NKikimrSchemeOp::TModifyScheme& scheme, TString& errStr, std::optional<TPathElement::EPathType> pathType) {
     const auto& conditions = scheme.GetApplyIf();
 
-    for(const auto& item: conditions) {
-        if (!item.HasPathId()) {
-            continue;
-        }
-        TLocalPathId localPathId = item.GetPathId();
-        const auto pathId = TPathId(TabletID(), localPathId);
+    for (const auto& item: conditions) {
+        if (item.HasPathId()) {
+            TLocalPathId localPathId = item.GetPathId();
+            const auto pathId = TPathId(TabletID(), localPathId);
 
-        if (!PathsById.contains(pathId)) {
-            errStr = TStringBuilder()
-                << "fail user constraint: ApplyIf section:"
-                << " no path with id " << pathId;
-            return false;
-        }
-        const TPathElement::TPtr pathEl = PathsById.at(pathId);
+            if (!PathsById.contains(pathId)) {
+                errStr = TStringBuilder()
+                    << "fail user constraint: ApplyIf section:"
+                    << " no path with id " << pathId;
+                return false;
+            }
+            const TPathElement::TPtr pathEl = PathsById.at(pathId);
 
-        if (pathEl->Dropped()) {
-            errStr = TStringBuilder()
-                << "fail user constraint: ApplyIf section:"
-                << " path with id " << pathId << " has been dropped";
-            return false;
-        }
+            if (pathEl->Dropped()) {
+                errStr = TStringBuilder()
+                    << "fail user constraint: ApplyIf section:"
+                    << " path with id " << pathId << " has been dropped";
+                return false;
+            }
 
-        if (item.HasPathVersion()) {
-            const auto requiredVersion = item.GetPathVersion();
-            arc_ui64 actualVersion;
-            auto path = TPath::Init(pathId, this);
-            auto pathVersion = GetPathVersion(path);
-
-            if (item.HasCheckEntityVersion() && item.GetCheckEntityVersion()) {
-                switch(path.Base()->PathType) {
-                    case NKikimrSchemeOp::EPathTypePersQueueGroup:
-                        actualVersion = pathVersion.GetPQVersion();
-                        break;
-                    case NKikimrSchemeOp::EPathType::EPathTypeSubDomain:
-                    case NKikimrSchemeOp::EPathType::EPathTypeExtSubDomain:
-                        actualVersion = pathVersion.GetSubDomainVersion();
-                        break;
-                    case NKikimrSchemeOp::EPathTypeTable:
-                        actualVersion = pathVersion.GetTableSchemaVersion();
-                        break;
-                    case NKikimrSchemeOp::EPathType::EPathTypeBlockStoreVolume:
-                        actualVersion = pathVersion.GetBSVVersion();
-                        break;
-                    case NKikimrSchemeOp::EPathType::EPathTypeFileStore:
-                        actualVersion = pathVersion.GetFileStoreVersion();
-                        break;
-                    case NKikimrSchemeOp::EPathType::EPathTypeKesus:
-                        actualVersion = pathVersion.GetKesusVersion();
-                        break;
-                    case NKikimrSchemeOp::EPathType::EPathTypeRtmrVolume:
-                        actualVersion = pathVersion.GetRTMRVersion();
-                        break;
-                    case NKikimrSchemeOp::EPathType::EPathTypeSolomonVolume:
-                        actualVersion = pathVersion.GetSolomonVersion();
-                        break;
-                    case NKikimrSchemeOp::EPathType::EPathTypeTableIndex:
-                        actualVersion = pathVersion.GetTableIndexVersion();
-                        break;
-                    case NKikimrSchemeOp::EPathType::EPathTypeColumnStore:
-                        actualVersion = pathVersion.GetColumnStoreVersion();
-                        break;
-                    case NKikimrSchemeOp::EPathType::EPathTypeColumnTable:
-                        actualVersion = pathVersion.GetColumnTableVersion();
-                        break;
-                    case NKikimrSchemeOp::EPathType::EPathTypeCdcStream:
-                        actualVersion = pathVersion.GetCdcStreamVersion();
-                        break;
-                    case NKikimrSchemeOp::EPathType::EPathTypeSequence:
-                        actualVersion = pathVersion.GetSequenceVersion();
-                        break;
-                    case NKikimrSchemeOp::EPathType::EPathTypeReplication:
-                    case NKikimrSchemeOp::EPathType::EPathTypeTransfer:
-                        actualVersion = pathVersion.GetReplicationVersion();
-                        break;
-                    case NKikimrSchemeOp::EPathType::EPathTypeExternalTable:
-                        actualVersion = pathVersion.GetExternalTableVersion();
-                        break;
-                    case NKikimrSchemeOp::EPathType::EPathTypeExternalDataSource:
-                        actualVersion = pathVersion.GetExternalDataSourceVersion();
-                        break;
-                    case NKikimrSchemeOp::EPathType::EPathTypeView:
-                        actualVersion = pathVersion.GetViewVersion();
-                        break;
-                    default:
-                        actualVersion = pathVersion.GetGeneralVersion();
-                        break;
+            if (item.HasPathVersion()) {
+                const auto requiredVersion = item.GetPathVersion();
+                arc_ui64 actualVersion;
+                auto path = TPath::Init(pathId, this);
+                auto pathVersion = GetPathVersion(path);
+
+                if (item.HasCheckEntityVersion() && item.GetCheckEntityVersion()) {
+                    switch(path.Base()->PathType) {
+                        case NKikimrSchemeOp::EPathTypePersQueueGroup:
+                            actualVersion = pathVersion.GetPQVersion();
+                            break;
+                        case NKikimrSchemeOp::EPathType::EPathTypeSubDomain:
+                        case NKikimrSchemeOp::EPathType::EPathTypeExtSubDomain:
+                            actualVersion = pathVersion.GetSubDomainVersion();
+                            break;
+                        case NKikimrSchemeOp::EPathTypeTable:
+                            actualVersion = pathVersion.GetTableSchemaVersion();
+                            break;
+                        case NKikimrSchemeOp::EPathType::EPathTypeBlockStoreVolume:
+                            actualVersion = pathVersion.GetBSVVersion();
+                            break;
+                        case NKikimrSchemeOp::EPathType::EPathTypeFileStore:
+                            actualVersion = pathVersion.GetFileStoreVersion();
+                            break;
+                        case NKikimrSchemeOp::EPathType::EPathTypeKesus:
+                            actualVersion = pathVersion.GetKesusVersion();
+                            break;
+                        case NKikimrSchemeOp::EPathType::EPathTypeRtmrVolume:
+                            actualVersion = pathVersion.GetRTMRVersion();
+                            break;
+                        case NKikimrSchemeOp::EPathType::EPathTypeSolomonVolume:
+                            actualVersion = pathVersion.GetSolomonVersion();
+                            break;
+                        case NKikimrSchemeOp::EPathType::EPathTypeTableIndex:
+                            actualVersion = pathVersion.GetTableIndexVersion();
+                            break;
+                        case NKikimrSchemeOp::EPathType::EPathTypeColumnStore:
+                            actualVersion = pathVersion.GetColumnStoreVersion();
+                            break;
+                        case NKikimrSchemeOp::EPathType::EPathTypeColumnTable:
+                            actualVersion = pathVersion.GetColumnTableVersion();
+                            break;
+                        case NKikimrSchemeOp::EPathType::EPathTypeCdcStream:
+                            actualVersion = pathVersion.GetCdcStreamVersion();
+                            break;
+                        case NKikimrSchemeOp::EPathType::EPathTypeSequence:
+                            actualVersion = pathVersion.GetSequenceVersion();
+                            break;
+                        case NKikimrSchemeOp::EPathType::EPathTypeReplication:
+                        case NKikimrSchemeOp::EPathType::EPathTypeTransfer:
+                            actualVersion = pathVersion.GetReplicationVersion();
+                            break;
+                        case NKikimrSchemeOp::EPathType::EPathTypeExternalTable:
+                            actualVersion = pathVersion.GetExternalTableVersion();
+                            break;
+                        case NKikimrSchemeOp::EPathType::EPathTypeExternalDataSource:
+                            actualVersion = pathVersion.GetExternalDataSourceVersion();
+                            break;
+                        case NKikimrSchemeOp::EPathType::EPathTypeView:
+                            actualVersion = pathVersion.GetViewVersion();
+                            break;
+                        default:
+                            actualVersion = pathVersion.GetGeneralVersion();
+                            break;
+                    }
+                } else {
+                    actualVersion = pathVersion.GetGeneralVersion();
+                }
+
+                if (requiredVersion != actualVersion) {
+                    errStr = TStringBuilder()
+                        << "fail user constraint in ApplyIf section:"
+                        //FIXME: revert to misspelled text as there is dependency on it in the nbs code.
+                        // Dependency on text should be replaced by introducing special error code.
+                        << " path version mistmach, path with id " << pathEl->PathId
+                        << " has actual version " << actualVersion
+                        << " but version " << requiredVersion << " was required";
+                    return false;
                 }
-            } else {
-                actualVersion = pathVersion.GetGeneralVersion();
             }
 
-            if (requiredVersion != actualVersion) {
-                errStr = TStringBuilder()
-                    << "fail user constraint in ApplyIf section:"
-                    //FIXME: revert to misspelled text as there is dependency on it in the nbs code.
-                    // Dependency on text should be replaced by introducing special error code.
-                    << " path version mistmach, path with id " << pathEl->PathId
-                    << " has actual version " << actualVersion
-                    << " but version " << requiredVersion << " was required";
-                return false;
+            if (item.HasLockedTxId()) {
+                const auto lockOwnerTxId = TTxId(item.GetLockedTxId());
+    
+                TString lockErr = "fail user constraint in ApplyIf section:";
+                if (!CheckLocks(pathId, lockOwnerTxId, lockErr)) {
+                    errStr = lockErr;
+                    return false;
+                }
             }
         }
 
-        if (item.HasLockedTxId()) {
-            const auto lockOwnerTxId = TTxId(item.GetLockedTxId());
+        if (AppData()->FeatureFlags.GetEnableAlterDatabase()) {
+            if (!item.GetPathTypes().empty()) {
+                if (!pathType.has_value()) {
+                    errStr = TStringBuilder()
+                        << "fail in ApplyIf section:"
+                        << " argument `pathType` is undefined,"
+                        << " but ApplyIf has non-empty field `PathTypes.`";
 
-            TString lockErr = "fail user constraint in ApplyIf section:";
-            if (!CheckLocks(pathId, lockOwnerTxId, lockErr)) {
-                errStr = lockErr;
-                return false;
+                    return false;
+                }
+
+                const auto& pathTypes = item.GetPathTypes();
+                bool allowed = (std::find(pathTypes.begin(), pathTypes.end(), pathType) != pathTypes.end());
+                if (!allowed) {
+                    auto enumToString = [](TPathElement::EPathType type) {
+                        return NKikimrSchemeOp::EPathType_Name(type);
+                    };
+
+                    errStr = TStringBuilder()
+                        << "fail in ApplyIf section:"
+                        << " wrong Path type."
+                        << " Expected types: ";
+
+                        for (int i = 0; i < pathTypes.size(); i++) {
+                            errStr += enumToString(static_cast<TPathElement::EPathType>(pathTypes[i]) ) + ",;"[i + 1 == pathTypes.size()] + " ";
+                        }
+
+                        errStr += TStringBuilder() << "But actual Path type is " << enumToString(pathType.value());
+                    return false;
+                }
             }
+        } else if (!item.GetPathTypes().empty()) {
+            errStr = TStringBuilder()
+                << "fail in ApplyIf section:"
+                << " Check Path Type is not supported";
+
+            return false;
         }
     }
 
@@ -4911,6 +4949,7 @@ void TSchemeShard::StateWork(STFUNC_SIG) {
         HFuncTraced(TEvDataShard::TEvSampleKResponse, Handle);
         HFuncTraced(TEvDataShard::TEvReshuffleKMeansResponse, Handle);
         HFuncTraced(TEvDataShard::TEvLocalKMeansResponse, Handle);
+        HFuncTraced(TEvDataShard::TEvPrefixKMeansResponse, Handle);
         HFuncTraced(TEvIndexBuilder::TEvUploadSampleKResponse, Handle);
         // } // NIndexBuilder
 
diff --git a/ydb/core/tx/schemeshard/schemeshard_impl.h b/ydb/core/tx/schemeshard/schemeshard_impl.h
index f4bf218201ac..925fa69c31d4 100644
--- a/ydb/core/tx/schemeshard/schemeshard_impl.h
+++ b/ydb/core/tx/schemeshard/schemeshard_impl.h
@@ -603,7 +603,7 @@ class TSchemeShard
     TTabletId SelectCoordinator(TTxId txId, TPathId pathId) const;
     TTabletId SelectCoordinator(TTxId txId, TPathElement::TPtr pathEl) const;
 
-    bool CheckApplyIf(const NKikimrSchemeOp::TModifyScheme& scheme, TString& errStr);
+    bool CheckApplyIf(const NKikimrSchemeOp::TModifyScheme& scheme, TString& errStr, std::optional<TPathElement::EPathType> pathType = {});
     bool CheckLocks(const TPathId pathId, const TTxId lockTxId, TString& errStr) const;
     bool CheckLocks(const TPathId pathId, const NKikimrSchemeOp::TModifyScheme& scheme, TString& errStr) const;
     bool CheckInFlightLimit(TTxState::ETxType txType, TString& errStr) const;
@@ -1426,6 +1426,7 @@ class TSchemeShard
         struct TTxReplySampleK;
         struct TTxReplyReshuffleKMeans;
         struct TTxReplyLocalKMeans;
+        struct TTxReplyPrefixKMeans;
         struct TTxReplyUpload;
 
         struct TTxPipeReset;
@@ -1445,6 +1446,7 @@ class TSchemeShard
     NTabletFlatExecutor::ITransaction* CreateTxReply(TEvDataShard::TEvSampleKResponse::TPtr& sampleK);
     NTabletFlatExecutor::ITransaction* CreateTxReply(TEvDataShard::TEvReshuffleKMeansResponse::TPtr& reshuffle);
     NTabletFlatExecutor::ITransaction* CreateTxReply(TEvDataShard::TEvLocalKMeansResponse::TPtr& local);
+    NTabletFlatExecutor::ITransaction* CreateTxReply(TEvDataShard::TEvPrefixKMeansResponse::TPtr& prefix);
     NTabletFlatExecutor::ITransaction* CreateTxReply(TEvIndexBuilder::TEvUploadSampleKResponse::TPtr& upload);
     NTabletFlatExecutor::ITransaction* CreatePipeRetry(TIndexBuildId indexBuildId, TTabletId tabletId);
     NTabletFlatExecutor::ITransaction* CreateTxBilling(TEvPrivate::TEvIndexBuildingMakeABill::TPtr& ev);
@@ -1459,6 +1461,7 @@ class TSchemeShard
     void Handle(TEvDataShard::TEvSampleKResponse::TPtr& ev, const TActorContext& ctx);
     void Handle(TEvDataShard::TEvReshuffleKMeansResponse::TPtr& ev, const TActorContext& ctx);
     void Handle(TEvDataShard::TEvLocalKMeansResponse::TPtr& ev, const TActorContext& ctx);
+    void Handle(TEvDataShard::TEvPrefixKMeansResponse::TPtr& ev, const TActorContext& ctx);
     void Handle(TEvIndexBuilder::TEvUploadSampleKResponse::TPtr& ev, const TActorContext& ctx);
 
     void Handle(TEvPrivate::TEvIndexBuildingMakeABill::TPtr& ev, const TActorContext& ctx);
diff --git a/ydb/core/tx/schemeshard/schemeshard_info_types.cpp b/ydb/core/tx/schemeshard/schemeshard_info_types.cpp
index ddd148f18bb3..1de46a0f63db 100644
--- a/ydb/core/tx/schemeshard/schemeshard_info_types.cpp
+++ b/ydb/core/tx/schemeshard/schemeshard_info_types.cpp
@@ -2164,9 +2164,10 @@ void TImportInfo::AddNotifySubscriber(const TActorId &actorId) {
     Subscribers.insert(actorId);
 }
 
-TIndexBuildInfo::TShardStatus::TShardStatus(TSerializedTableRange range, TString lastKeyAck)
+TIndexBuildInfo::TShardStatus::TShardStatus(TSerializedTableRange range, TString lastKeyAck, size_t shardsCount)
     : Range(std::move(range))
     , LastKeyAck(std::move(lastKeyAck))
+    , Index(shardsCount)
 {}
 
 void TIndexBuildInfo::SerializeToProto(TSchemeShard* ss, NKikimrSchemeOp::TIndexBuildConfig* result) const {
@@ -2208,7 +2209,6 @@ void TIndexBuildInfo::SerializeToProto([[maybe_unused]] TSchemeShard* ss, NKikim
 
 void TIndexBuildInfo::AddParent(const TSerializedTableRange& range, TShardIdx shard) {
     if (KMeans.Parent == 0) {
-        Y_ASSERT(KMeans.ParentEnd == 0);
         // For Parent == 0 only single kmeans needed, so there is only two options:
         // 1. It fits entirely in the single shard => local kmeans for single shard
         // 2. It doesn't fit entirely in the single shard => global kmeans for all shards
diff --git a/ydb/core/tx/schemeshard/schemeshard_info_types.h b/ydb/core/tx/schemeshard/schemeshard_info_types.h
index 6d52d76f207f..1f59bffd68db 100644
--- a/ydb/core/tx/schemeshard/schemeshard_info_types.h
+++ b/ydb/core/tx/schemeshard/schemeshard_info_types.h
@@ -3047,6 +3047,7 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {
         BuildKindUnspecified = 0,
         BuildSecondaryIndex = 10,
         BuildVectorIndex = 11,
+        BuildPrefixedVectorIndex = 12,
         BuildColumns = 20,
     };
 
@@ -3092,42 +3093,46 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {
 
         EState State = Sample;
 
-        NTableIndex::TClusterId Parent = 0;
-        NTableIndex::TClusterId ParentEnd = 0;  // included
+        NTableIndex::TClusterId ParentBegin = 0;  // included
+        NTableIndex::TClusterId Parent = ParentBegin;
 
         NTableIndex::TClusterId ChildBegin = 1;  // included
+        NTableIndex::TClusterId Child = ChildBegin;
+
+        ui64 ParentEnd() const noexcept {  // included
+            return ChildBegin - 1;
+        }
+        ui64 ChildEnd() const noexcept {  // included
+            return ChildBegin + ChildCount() - 1;
+        }
+
+        ui64 ParentCount() const noexcept {
+            return ParentEnd() - ParentBegin + 1;
+        }
+        ui64 ChildCount() const noexcept {
+            return ParentCount() * K;
+        }
 
         TString ToStr() const {
             return TStringBuilder()
                 << "{ K = " << K
                 << ", Level = " << Level << " / " << Levels
-                << ", Parent = " << Parent << " / " << ParentEnd
-                << ", State = " << State << " }";
-        }
-
-        static NTableIndex::TClusterId BinPow(NTableIndex::TClusterId k, ui32 l) {
-            NTableIndex::TClusterId r = 1;
-            while (l != 0) {
-                if (l % 2 != 0) {
-                    r *= k;
-                }
-                k *= k;
-                l /= 2;
-            }
-            return r;
+                << ", Parent = [" << ParentBegin << ".." << Parent << ".." << ParentEnd()
+                << "], Child = [" << ChildBegin << ".." << Child << ".." << ChildEnd()
+                << "], State = " << State << " }";
         }
 
-        bool NeedsAnotherLevel() const {
+        bool NeedsAnotherLevel() const noexcept {
             return Level < Levels;
         }
-        bool NeedsAnotherParent() const {
-            return Parent < ParentEnd;
+        bool NeedsAnotherParent() const noexcept {
+            return Parent < ParentEnd();
         }
-        bool NeedsAnotherState() const {
+        bool NeedsAnotherState() const noexcept {
             return State == Sample /*|| State == Recompute*/;
         }
 
-        bool NextState() {
+        bool NextState() noexcept {
             if (!NeedsAnotherState()) {
                 return false;
             }
@@ -3135,25 +3140,32 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {
             return true;
         }
 
-        bool NextParent() {
+        bool NextParent() noexcept {
             if (!NeedsAnotherParent()) {
                 return false;
             }
-            ChildBegin += K;
             State = Sample;
             ++Parent;
+            Child += K;
             return true;
         }
 
-        bool NextLevel() {
+        bool NextLevel() noexcept {
             if (!NeedsAnotherLevel()) {
                 return false;
             }
-            ChildBegin += K;
             State = Sample;
-            ++Parent;
-            ParentEnd += BinPow(K, Level);
-            ++Level;
+            NextLevel(ChildCount());
+            return true;
+        }
+
+        bool PrefixTableDone(ui64 tableSize, ui64 shards) {
+            if (!NeedsAnotherLevel()) {
+                return false;
+            }
+            State = MultiLocal;
+            NextLevel((1 + tableSize) * shards);
+            Parent = ParentEnd();
             return true;
         }
 
@@ -3169,7 +3181,7 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {
         }
 
         NKikimrTxDataShard::TEvLocalKMeansRequest::EState GetUpload() const {
-            if (Parent == 0) {
+            if (Level == 1) {
                 if (NeedsAnotherLevel()) {
                     return NKikimrTxDataShard::TEvLocalKMeansRequest::UPLOAD_MAIN_TO_BUILD;
                 } else {
@@ -3193,7 +3205,7 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {
             return name;
         }
         TString ReadFrom() const {
-            Y_ASSERT(Parent != 0);
+            Y_ASSERT(Level > 1);
             using namespace NTableIndex::NTableVectorKmeansTreeIndex;
             TString name = PostingTable;
             name += Level % 2 != 0 ? BuildSuffix1 : BuildSuffix0;
@@ -3201,11 +3213,8 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {
         }
 
         std::pair<NTableIndex::TClusterId, NTableIndex::TClusterId> RangeToBorders(const TSerializedTableRange& range) const {
-            Y_ASSERT(ParentEnd != 0);
-            const NTableIndex::TClusterId maxParent = ParentEnd;
-            const NTableIndex::TClusterId levelSize = TKMeans::BinPow(K, Level - 1);
-            Y_ASSERT(levelSize <= maxParent);
-            const NTableIndex::TClusterId minParent = maxParent - levelSize + 1;
+            const NTableIndex::TClusterId minParent = ParentBegin;
+            const NTableIndex::TClusterId maxParent = ParentEnd();
             const NTableIndex::TClusterId parentFrom = [&, from = range.From.GetCells()] {
                 if (!from.empty()) {
                     if (!from[0].IsNull()) {
@@ -3222,9 +3231,9 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {
                 }
                 return maxParent;
             }();
-            Y_VERIFY_DEBUG_S(minParent <= parentFrom, "minParent(" << minParent << ") > parentFrom(" << parentFrom << ")");
-            Y_VERIFY_DEBUG_S(parentFrom <= parentTo, "parentFrom(" << parentFrom << ") > parentTo(" << parentTo << ")");
-            Y_VERIFY_DEBUG_S(parentTo <= maxParent, "parentTo(" << parentTo << ") > maxParent(" << maxParent << ")");
+            Y_VERIFY_DEBUG_S(minParent <= parentFrom, "minParent(" << minParent << ") > parentFrom(" << parentFrom << ") " << ToStr());
+            Y_VERIFY_DEBUG_S(parentFrom <= parentTo, "parentFrom(" << parentFrom << ") > parentTo(" << parentTo << ") " << ToStr());
+            Y_VERIFY_DEBUG_S(parentTo <= maxParent, "parentTo(" << parentTo << ") > maxParent(" << maxParent << ") " << ToStr());
             return {parentFrom, parentTo};
         }
 
@@ -3249,6 +3258,15 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {
             };
             return TStringBuilder{} << "{ From: " << toStr(range.From) << ", To: " << toStr(range.To) << " }";
         }
+
+    private:
+        void NextLevel(ui64 childCount) noexcept {
+            ParentBegin = ChildBegin;
+            Parent = ParentBegin;
+            ChildBegin = ParentBegin + childCount;
+            Child = ChildBegin;
+            ++Level;
+        }
     };
     TKMeans KMeans;
 
@@ -3288,6 +3306,7 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {
         TSerializedTableRange Range;
         TString LastKeyAck;
         ui64 SeqNoRound = 0;
+        size_t Index = 0;  // size of Shards map before this element was added
 
         NKikimrIndexBuilder::EBuildStatus Status = NKikimrIndexBuilder::EBuildStatus::INVALID;
 
@@ -3296,7 +3315,7 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {
 
         TBillingStats Processed;
 
-        TShardStatus(TSerializedTableRange range, TString lastKeyAck);
+        TShardStatus(TSerializedTableRange range, TString lastKeyAck, size_t shardsCount);
 
         TString ToString(TShardIdx shardIdx = InvalidShardIdx) const {
             TStringBuilder result;
@@ -3485,6 +3504,12 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {
         indexInfo->IndexName = row.template GetValue<Schema::IndexBuild::IndexName>();
         indexInfo->IndexType = row.template GetValue<Schema::IndexBuild::IndexType>();
 
+        // note: please note that here we specify BuildSecondaryIndex as operation default,
+        // because previosly this table was dedicated for build secondary index operations only.
+        indexInfo->BuildKind = TIndexBuildInfo::EBuildKind(
+            row.template GetValueOrDefault<Schema::IndexBuild::BuildKind>(
+                ui32(TIndexBuildInfo::EBuildKind::BuildSecondaryIndex)));
+
         // Restore the operation details: ImplTableDescriptions and SpecializedIndexDescription.
         if (row.template HaveValue<Schema::IndexBuild::CreationConfig>()) {
             NKikimrSchemeOp::TIndexCreationConfig creationConfig;
@@ -3500,7 +3525,7 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {
                 case NKikimrSchemeOp::TIndexCreationConfig::kVectorIndexKmeansTreeDescription: {
                     auto& desc = *creationConfig.MutableVectorIndexKmeansTreeDescription();
                     indexInfo->KMeans.K = std::max<ui32>(2, desc.settings().clusters());
-                    indexInfo->KMeans.Levels = std::max<ui32>(1, desc.settings().levels());
+                    indexInfo->KMeans.Levels = indexInfo->IsBuildPrefixedVectorIndex() + std::max<ui32>(1, desc.settings().levels());
                     indexInfo->SpecializedIndexDescription =std::move(desc);
                 } break;
                 case NKikimrSchemeOp::TIndexCreationConfig::SPECIALIZEDINDEXDESCRIPTION_NOT_SET:
@@ -3566,19 +3591,12 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {
             row.template GetValueOrDefault<Schema::IndexBuild::UnlockTxDone>(
                 indexInfo->UnlockTxDone);
 
-        // note: please note that here we specify BuildSecondaryIndex as operation default,
-        // because previosly this table was dedicated for build secondary index operations only.
-        indexInfo->BuildKind = TIndexBuildInfo::EBuildKind(
-            row.template GetValueOrDefault<Schema::IndexBuild::BuildKind>(
-                ui32(TIndexBuildInfo::EBuildKind::BuildSecondaryIndex)));
-
         indexInfo->AlterMainTableTxId =
             row.template GetValueOrDefault<Schema::IndexBuild::AlterMainTableTxId>(
                 indexInfo->AlterMainTableTxId);
         indexInfo->AlterMainTableTxStatus =
-            row
-                .template GetValueOrDefault<Schema::IndexBuild::AlterMainTableTxStatus>(
-                    indexInfo->AlterMainTableTxStatus);
+            row.template GetValueOrDefault<Schema::IndexBuild::AlterMainTableTxStatus>(
+                indexInfo->AlterMainTableTxStatus);
         indexInfo->AlterMainTableTxDone =
             row.template GetValueOrDefault<Schema::IndexBuild::AlterMainTableTxDone>(
                 indexInfo->AlterMainTableTxDone);
@@ -3623,7 +3641,7 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {
             "AddShardStatus id# " << Id << " shard " << shardIdx << " range " << KMeans.RangeToDebugStr(bound));
         AddParent(bound, shardIdx);
         Shards.emplace(
-            shardIdx, TIndexBuildInfo::TShardStatus(std::move(bound), std::move(lastKeyAck)));
+            shardIdx, TIndexBuildInfo::TShardStatus(std::move(bound), std::move(lastKeyAck), Shards.size()));
         TIndexBuildInfo::TShardStatus &shardStatus = Shards.at(shardIdx);
 
         shardStatus.Status =
@@ -3661,8 +3679,12 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {
         return BuildKind == EBuildKind::BuildSecondaryIndex;
     }
 
+    bool IsBuildPrefixedVectorIndex() const {
+        return BuildKind == EBuildKind::BuildPrefixedVectorIndex;
+    }
+
     bool IsBuildVectorIndex() const {
-        return BuildKind == EBuildKind::BuildVectorIndex;
+        return BuildKind == EBuildKind::BuildVectorIndex || IsBuildPrefixedVectorIndex();
     }
 
     bool IsBuildIndex() const {
@@ -3701,16 +3723,8 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {
                 && toUpload == 0 && inProgress == 0) {
                 return 100.f;
             }
-            auto percent = static_cast<float>(KMeans.Level - 1) / KMeans.Levels;
-            auto multiply = 1.f / KMeans.Levels;
-            if (KMeans.State == TKMeans::MultiLocal) {
-                percent += (multiply * (total - inProgress - toUpload)) / total;
-            } else {
-                const auto parentSize = KMeans.BinPow(KMeans.K, KMeans.Level - 1);
-                const auto parentFrom = KMeans.ParentEnd - parentSize + 1;
-                percent += (multiply * (KMeans.Parent - parentFrom)) / parentSize;
-            }
-            return 100.f * percent;
+            // TODO(mbkkt) more detailed progress?
+            return (100.f * (KMeans.Level - 1)) / KMeans.Levels;
         }
         if (Shards) {
             return (100.f * done) / total;
diff --git a/ydb/core/tx/schemeshard/schemeshard_path.cpp b/ydb/core/tx/schemeshard/schemeshard_path.cpp
index d01f285c0f8f..01bae14754e7 100644
--- a/ydb/core/tx/schemeshard/schemeshard_path.cpp
+++ b/ydb/core/tx/schemeshard/schemeshard_path.cpp
@@ -578,6 +578,19 @@ const TPath::TChecker& TPath::TChecker::IsDirectory(EStatus status) const {
         << " (" << BasicPathInfo(Path.Base()) << ")");
 }
 
+const TPath::TChecker& TPath::TChecker::IsRtmrVolume(EStatus status) const {
+    if (Failed) {
+        return *this;
+    }
+
+    if (Path.Base()->IsRtmrVolume()) {
+        return *this;
+    }
+
+    return Fail(status, TStringBuilder() << "path is not a run time map-reduce volume"
+        << " (" << BasicPathInfo(Path.Base()) << ")");
+}
+
 const TPath::TChecker& TPath::TChecker::IsTheSameDomain(const TPath& another, EStatus status) const {
     if (Failed) {
         return *this;
diff --git a/ydb/core/tx/schemeshard/schemeshard_path.h b/ydb/core/tx/schemeshard/schemeshard_path.h
index 4e017c51b05a..4e167ac23dc3 100644
--- a/ydb/core/tx/schemeshard/schemeshard_path.h
+++ b/ydb/core/tx/schemeshard/schemeshard_path.h
@@ -78,6 +78,7 @@ class TPath {
         const TChecker& IsCdcStream(EStatus status = EStatus::StatusNameConflict) const;
         const TChecker& IsLikeDirectory(EStatus status = EStatus::StatusPathIsNotDirectory) const;
         const TChecker& IsDirectory(EStatus status = EStatus::StatusPathIsNotDirectory) const;
+        const TChecker& IsRtmrVolume(EStatus status = EStatus::StatusNameConflict) const;
         const TChecker& IsTheSameDomain(const TPath& another, EStatus status = EStatus::StatusInvalidParameter) const;
         const TChecker& FailOnWrongType(const TSet<TPathElement::EPathType>& expectedTypes) const;
         const TChecker& FailOnWrongType(TPathElement::EPathType expectedType) const;
diff --git a/ydb/core/tx/schemeshard/schemeshard_path_describer.cpp b/ydb/core/tx/schemeshard/schemeshard_path_describer.cpp
index 9a266bd00694..819471cac026 100644
--- a/ydb/core/tx/schemeshard/schemeshard_path_describer.cpp
+++ b/ydb/core/tx/schemeshard/schemeshard_path_describer.cpp
@@ -1398,12 +1398,6 @@ void TSchemeShard::DescribeTableIndex(const TPathId& pathId, const TString& name
     const auto* indexPathPtr = PathsById.FindPtr(pathId);
     Y_ABORT_UNLESS(indexPathPtr);
     const auto& indexPath = *indexPathPtr->Get();
-    if (const auto size = indexPath.GetChildren().size(); indexInfo->Type == NKikimrSchemeOp::EIndexType::EIndexTypeGlobalVectorKmeansTree) {
-        // For vector index we have 2 impl tables and 2 build impl tables
-        Y_VERIFY_S(2 <= size && size <= 4, size);
-    } else {
-        Y_VERIFY_S(size == 1, size);
-    }
 
     ui64 dataSize = 0;
     for (const auto& indexImplTablePathId : indexPath.GetChildren()) {
diff --git a/ydb/core/tx/schemeshard/schemeshard_utils.cpp b/ydb/core/tx/schemeshard/schemeshard_utils.cpp
index 3d3b99bc7af6..ec70a4fe58b4 100644
--- a/ydb/core/tx/schemeshard/schemeshard_utils.cpp
+++ b/ydb/core/tx/schemeshard/schemeshard_utils.cpp
@@ -317,6 +317,14 @@ auto CalcVectorKmeansTreePrefixImplTableDescImpl(
 
 }
 
+void FillIndexTableColumns(
+    const THashMap<ui32, NSchemeShard::TTableInfo::TColumn>& baseTableColumns,
+    std::span<const TString> keys,
+    const THashSet<TString>& columns,
+    NKikimrSchemeOp::TTableDescription& implTableDesc) {
+    FillIndexImplTableColumns(baseTableColumns, keys, columns, implTableDesc);
+}
+
 NKikimrSchemeOp::TTableDescription CalcImplTableDesc(
     const NSchemeShard::TTableInfo::TPtr& baseTableInfo,
     const TTableColumns& implTableColumns,
diff --git a/ydb/core/tx/schemeshard/schemeshard_utils.h b/ydb/core/tx/schemeshard/schemeshard_utils.h
index aac12855b5db..0557a4ecab04 100644
--- a/ydb/core/tx/schemeshard/schemeshard_utils.h
+++ b/ydb/core/tx/schemeshard/schemeshard_utils.h
@@ -96,6 +96,12 @@ TTableColumns ExtractInfo(const NSchemeShard::TTableInfo::TPtr& tableInfo);
 TTableColumns ExtractInfo(const NKikimrSchemeOp::TTableDescription& tableDesc);
 TIndexColumns ExtractInfo(const NKikimrSchemeOp::TIndexCreationConfig& indexDesc);
 
+void FillIndexTableColumns(
+    const THashMap<ui32, NSchemeShard::TTableInfo::TColumn>& baseTableColumns,
+    std::span<const TString> keys,
+    const THashSet<TString>& columns,
+    NKikimrSchemeOp::TTableDescription& implTableDesc);
+
 using TColumnTypes = THashMap<TString, NScheme::TTypeInfo>;
 
 bool ExtractTypes(const NSchemeShard::TTableInfo::TPtr& baseTableInfo, TColumnTypes& columnsTypes, TString& explain);
diff --git a/ydb/core/tx/schemeshard/ut_base/ut_base.cpp b/ydb/core/tx/schemeshard/ut_base/ut_base.cpp
index f71e0e5d8b2e..57569ae1cb6a 100644
--- a/ydb/core/tx/schemeshard/ut_base/ut_base.cpp
+++ b/ydb/core/tx/schemeshard/ut_base/ut_base.cpp
@@ -11784,4 +11784,83 @@ Y_UNIT_TEST_SUITE(TSchemeShardTest) {
             });
         }
     }
+
+    Y_UNIT_TEST(NewOwnerOnDatabase) {
+        TTestBasicRuntime runtime;
+        TTestEnv env(runtime);
+        runtime.GetAppData().FeatureFlags.SetEnableAlterDatabase(true);
+
+        ui64 txId = 100;
+
+        TString newOwner = "user1";
+
+        TApplyIfUnit applyIfUnit;
+        applyIfUnit.PathTypes = {NKikimrSchemeOp::EPathTypeSubDomain, NKikimrSchemeOp::EPathTypeExtSubDomain};
+        TApplyIf applyIf = {applyIfUnit};
+
+        auto checkOwner = [=] (const NKikimrScheme::TEvDescribeSchemeResult& record) {
+            const auto& self = record.GetPathDescription().GetSelf();
+            UNIT_ASSERT_EQUAL(self.GetOwner(), newOwner);
+        };
+
+        {
+            TestCreateSubDomain(runtime, ++txId, "/MyRoot", R"(
+                Name: "Subdomain"
+            )");
+
+            {
+                TestModifyACL(runtime, ++txId, "/MyRoot", "Subdomain", TString(), newOwner, NKikimrScheme::StatusSuccess, applyIf);
+                TestDescribeResult(DescribePath(runtime, "/MyRoot/Subdomain"), {checkOwner});
+            }
+        }
+
+        {
+            TestCreateExtSubDomain(runtime, ++txId,  "/MyRoot", R"(
+                Name: "Extsubdomain"
+            )");
+
+            {
+                TestModifyACL(runtime, ++txId, "/MyRoot", "Extsubdomain", TString(), newOwner, NKikimrScheme::StatusSuccess, applyIf);
+                TestDescribeResult(DescribePath(runtime, "/MyRoot/Extsubdomain"), {checkOwner});
+            }
+        }
+
+        { // last case didnt create external subdomain
+            TestCreateExtSubDomain(runtime, ++txId,  "/MyRoot", R"(
+                Name: "Extsubdomain2"
+            )");
+
+            TestAlterExtSubDomain(runtime, ++txId, "/MyRoot", R"(
+                Name: "Extsubdomain2"
+                PlanResolution: 50
+                Coordinators: 1
+                Mediators: 1
+                TimeCastBucketsPerMediator: 2
+                ExternalSchemeShard: true
+                StoragePools {
+                    Name: "/dc-1/users/tenant-1:hdd"
+                    Kind: "hdd"
+                }
+            )");
+
+            {
+                TestModifyACL(runtime, ++txId, "/MyRoot", "Extsubdomain2", TString(), newOwner, NKikimrScheme::StatusSuccess, applyIf);
+                TestDescribeResult(DescribePath(runtime, "/MyRoot/Extsubdomain2"), {checkOwner});
+            }
+        }
+
+        {
+            TestCreateTable(runtime, txId, "/MyRoot", R"(
+                Name: "Table"
+                Columns { Name: "key"   Type: "Uint64" }
+                Columns { Name: "value" Type: "Utf8" }
+                KeyColumnNames: ["key"]
+            )");
+
+            {
+                TestModifyACL(runtime, ++txId, "/MyRoot", "Table", TString(), newOwner, NKikimrScheme::StatusPreconditionFailed, applyIf);
+                TestModifyACL(runtime, ++txId, "/MyRoot", "Table", TString(), newOwner, NKikimrScheme::StatusSuccess);
+            }
+        }
+    }
 }
diff --git a/ydb/core/tx/schemeshard/ut_helpers/helpers.cpp b/ydb/core/tx/schemeshard/ut_helpers/helpers.cpp
index 0e10fedcdea5..3936cb23652c 100644
--- a/ydb/core/tx/schemeshard/ut_helpers/helpers.cpp
+++ b/ydb/core/tx/schemeshard/ut_helpers/helpers.cpp
@@ -187,19 +187,33 @@ namespace NSchemeShardUT_Private {
     }
 
     void SetApplyIf(NKikimrSchemeOp::TModifyScheme& transaction, const TApplyIf& applyIf) {
-        for (auto& pathVersion: applyIf) {
+        for (const auto& applyIfUnit: applyIf) {
             auto condition = transaction.AddApplyIf();
-            condition->SetPathId(pathVersion.PathId.LocalPathId);
-            condition->SetPathVersion(pathVersion.Version);
+
+            if (applyIfUnit.PathId != TPathId()) {
+                condition->SetPathId(applyIfUnit.PathId.LocalPathId);
+                condition->SetPathVersion(applyIfUnit.Version);
+            }
+
+            for (auto pathType : applyIfUnit.PathTypes) {
+                condition->AddPathTypes(pathType);
+            }
         }
     }
 
-    TEvSchemeShard::TEvModifySchemeTransaction* CreateModifyACLRequest(ui64 txId, ui64 schemeshard, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner) {
+    TEvSchemeShard::TEvModifySchemeTransaction* CreateModifyACLRequest(
+        ui64 txId, ui64 schemeshard,
+        TString parentPath, TString name, 
+        const TString& diffAcl, const TString& newOwner, const TApplyIf& applyIf
+    )
+    {
         auto evTx = new TEvSchemeShard::TEvModifySchemeTransaction(txId, schemeshard);
         auto transaction = evTx->Record.AddTransaction();
         transaction->SetWorkingDir(parentPath);
         transaction->SetOperationType(NKikimrSchemeOp::EOperationType::ESchemeOpModifyACL);
 
+        SetApplyIf(*transaction, applyIf);
+
         auto op = transaction->MutableModifyACL();
         op->SetName(name);
         if (diffAcl) {
@@ -212,25 +226,47 @@ namespace NSchemeShardUT_Private {
         return evTx;
     }
 
-    void AsyncModifyACL(TTestActorRuntime& runtime, ui64 schemeShardId, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner) {
-        AsyncSend(runtime, schemeShardId, CreateModifyACLRequest(txId, schemeShardId, parentPath, name, diffAcl, newOwner));
+    void AsyncModifyACL(
+        TTestActorRuntime& runtime,
+        ui64 schemeShardId, ui64 txId,
+        TString parentPath, TString name,
+        const TString& diffAcl, const TString& newOwner, const TApplyIf& applyIf
+    )
+    {
+        AsyncSend(runtime, schemeShardId, CreateModifyACLRequest(txId, schemeShardId, parentPath, name, diffAcl, newOwner, applyIf));
     }
 
-    void AsyncModifyACL(TTestActorRuntime& runtime, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner) {
-        return AsyncModifyACL(runtime, TTestTxConfig::SchemeShard, txId, parentPath, name, diffAcl, newOwner);
+    void AsyncModifyACL(
+        TTestActorRuntime& runtime,
+        ui64 txId, TString parentPath, TString name,
+        const TString& diffAcl, const TString& newOwner, const TApplyIf& applyIf
+    )
+    {
+        return AsyncModifyACL(runtime, TTestTxConfig::SchemeShard, txId, parentPath, name, diffAcl, newOwner, applyIf);
     }
 
-    void TestModifyACL(TTestActorRuntime& runtime, ui64 schemeShardId, ui64 txId, TString parentPath, TString name,
-                       const TString& diffAcl, const TString& newOwner,
-                       TEvSchemeShard::EStatus expectedResult) {
-        AsyncModifyACL(runtime, schemeShardId, txId, parentPath, name, diffAcl, newOwner);
+    void TestModifyACL(
+        TTestActorRuntime& runtime,
+        ui64 schemeShardId, ui64 txId,
+        TString parentPath, TString name,
+        const TString& diffAcl, const TString& newOwner,
+        TEvSchemeShard::EStatus expectedResult,
+        const TApplyIf& applyIf
+    )
+    {
+        AsyncModifyACL(runtime, schemeShardId, txId, parentPath, name, diffAcl, newOwner, applyIf);
         TestModificationResult(runtime, txId, expectedResult);
     }
 
-    void TestModifyACL(TTestActorRuntime& runtime, ui64 txId, TString parentPath, TString name,
-                       const TString& diffAcl, const TString& newOwner,
-                       TEvSchemeShard::EStatus expectedResult) {
-        TestModifyACL(runtime, TTestTxConfig::SchemeShard, txId, parentPath, name, diffAcl, newOwner, expectedResult);
+    void TestModifyACL(
+        TTestActorRuntime& runtime,
+        ui64 txId, TString parentPath, TString name,
+        const TString& diffAcl, const TString& newOwner,
+        TEvSchemeShard::EStatus expectedResult,
+        const TApplyIf& applyIf
+    )
+    {
+        TestModifyACL(runtime, TTestTxConfig::SchemeShard, txId, parentPath, name, diffAcl, newOwner, expectedResult, applyIf);
     }
 
 
diff --git a/ydb/core/tx/schemeshard/ut_helpers/helpers.h b/ydb/core/tx/schemeshard/ut_helpers/helpers.h
index bcca433cc1cc..f44b17ca7a7c 100644
--- a/ydb/core/tx/schemeshard/ut_helpers/helpers.h
+++ b/ydb/core/tx/schemeshard/ut_helpers/helpers.h
@@ -326,11 +326,11 @@ namespace NSchemeShardUT_Private {
                                const TVector<TExpectedResult>& expectedResults = {NKikimrScheme::StatusAccepted});
 
     // modify acl
-    TEvTx* CreateModifyACLRequest(ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner);
-    void AsyncModifyACL(TTestActorRuntime& runtime, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner);
-    void AsyncModifyACL(TTestActorRuntime& runtime, ui64 schemeShard, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner);
-    void TestModifyACL(TTestActorRuntime& runtime, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner, TEvSchemeShard::EStatus expectedResult = NKikimrScheme::StatusSuccess);
-    void TestModifyACL(TTestActorRuntime& runtime, ui64 schemeShard, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner, TEvSchemeShard::EStatus expectedResult = NKikimrScheme::StatusSuccess);
+    TEvTx* CreateModifyACLRequest(ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner, const TApplyIf& applyIf = {});
+    void AsyncModifyACL(TTestActorRuntime& runtime, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner, const TApplyIf& applyIf = {});
+    void AsyncModifyACL(TTestActorRuntime& runtime, ui64 schemeShard, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner, const TApplyIf& applyIf = {});
+    void TestModifyACL(TTestActorRuntime& runtime, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner, TEvSchemeShard::EStatus expectedResult = NKikimrScheme::StatusSuccess, const TApplyIf& applyIf = {});
+    void TestModifyACL(TTestActorRuntime& runtime, ui64 schemeShard, ui64 txId, TString parentPath, TString name, const TString& diffAcl, const TString& newOwner, TEvSchemeShard::EStatus expectedResult = NKikimrScheme::StatusSuccess, const TApplyIf& applyIf = {});
 
     // upgrade subdomain
     TEvTx* UpgradeSubDomainRequest(ui64 txId, const TString& parentPath, const TString& name);
diff --git a/ydb/core/tx/schemeshard/ut_helpers/ls_checks.h b/ydb/core/tx/schemeshard/ut_helpers/ls_checks.h
index eb42a9ef8f60..e41ad8b5e6b9 100644
--- a/ydb/core/tx/schemeshard/ut_helpers/ls_checks.h
+++ b/ydb/core/tx/schemeshard/ut_helpers/ls_checks.h
@@ -23,7 +23,24 @@ struct TPathVersion {
     TPathId PathId = TPathId();
     ui64 Version = Max<ui64>();
 };
-using TApplyIf = TVector<TPathVersion>;
+
+struct TApplyIfUnit : TPathVersion {
+    std::vector<NKikimrSchemeOp::EPathType> PathTypes;
+
+    TApplyIfUnit() {}
+
+    TApplyIfUnit(const TPathVersion& pathVersion) {
+        PathId = pathVersion.PathId;
+        Version = pathVersion.Version;
+    }
+
+    TApplyIfUnit(TPathVersion&& pathVersion) {
+        PathId = std::move(pathVersion.PathId);
+        Version = std::move(pathVersion.Version);
+    }
+};
+
+using TApplyIf = TVector<TApplyIfUnit>;
 
 using TUserAttrs = TVector<std::pair<TString, TString>>;
 
diff --git a/ydb/core/tx/schemeshard/ut_olap/ut_olap.cpp b/ydb/core/tx/schemeshard/ut_olap/ut_olap.cpp
index 527c067c0d7d..a4e65b233a48 100644
--- a/ydb/core/tx/schemeshard/ut_olap/ut_olap.cpp
+++ b/ydb/core/tx/schemeshard/ut_olap/ut_olap.cpp
@@ -887,12 +887,12 @@ Y_UNIT_TEST_SUITE(TOlap) {
 
         ui64 pathId = 0;
         ui64 shardId = 0;
-        ui64 planStep = 0;
+        NTxUT::TPlanStep planStep;
         auto checkFn = [&](const NKikimrScheme::TEvDescribeSchemeResult& record) {
             auto& self = record.GetPathDescription().GetSelf();
             pathId = self.GetPathId();
             txId = self.GetCreateTxId() + 1;
-            planStep = self.GetCreateStep();
+            planStep =  NTxUT::TPlanStep{self.GetCreateStep()};
             auto& sharding = record.GetPathDescription().GetColumnTableDescription().GetSharding();
             UNIT_ASSERT_VALUES_EQUAL(sharding.ColumnShardsSize(), 1);
             shardId = sharding.GetColumnShards()[0];
@@ -902,7 +902,7 @@ Y_UNIT_TEST_SUITE(TOlap) {
         TestLsPathId(runtime, 3, checkFn);
         UNIT_ASSERT(shardId);
         UNIT_ASSERT(pathId);
-        UNIT_ASSERT(planStep);
+        UNIT_ASSERT(planStep.Val());
         {
             auto description = DescribePrivatePath(runtime, TTestTxConfig::SchemeShard, "/MyRoot/OlapStore/ColumnTable", true, true);
             Cerr << description.DebugString() << Endl;
@@ -927,11 +927,11 @@ Y_UNIT_TEST_SUITE(TOlap) {
                 std::vector<ui64> writeIds;
                 ++txId;
                 NTxUT::WriteData(runtime, sender, shardId, ++writeId, pathId, data, defaultYdbSchema, &writeIds, NEvWrite::EModificationType::Upsert, txId);
-                NTxUT::ProposeCommit(runtime, sender, shardId, txId, writeIds, txId);
+                planStep = NTxUT::ProposeCommit(runtime, sender, shardId, txId, writeIds, txId);
                 txIds.insert(txId);
             }
 
-            NTxUT::PlanCommit(runtime, sender, shardId, ++planStep, txIds);
+            NTxUT::PlanCommit(runtime, sender, shardId, planStep, txIds);
 
             // emulate timeout
             runtime.UpdateCurrentTime(TInstant::Now());
@@ -940,8 +940,8 @@ Y_UNIT_TEST_SUITE(TOlap) {
             std::vector<ui64> writeIds;
             ++txId;
             NTxUT::WriteData(runtime, sender, shardId, ++writeId, pathId, data, defaultYdbSchema, &writeIds, NEvWrite::EModificationType::Upsert, txId);
-            NTxUT::ProposeCommit(runtime, sender, shardId, txId, writeIds, txId);
-            NTxUT::PlanCommit(runtime, sender, shardId, ++planStep, { txId });
+            planStep = NTxUT::ProposeCommit(runtime, sender, shardId, txId, writeIds, txId);
+            NTxUT::PlanCommit(runtime, sender, shardId, planStep, { txId });
         }
         csController->WaitIndexation(TDuration::Seconds(5));
         {
@@ -1066,12 +1066,12 @@ Y_UNIT_TEST_SUITE(TOlap) {
 
         ui64 pathId = 0;
         ui64 shardId = 0;
-        ui64 planStep = 0;
+        NTxUT::TPlanStep planStep;
         auto checkFn = [&](const NKikimrScheme::TEvDescribeSchemeResult& record) {
             auto& self = record.GetPathDescription().GetSelf();
             pathId = self.GetPathId();
             txId = self.GetCreateTxId() + 1;
-            planStep = self.GetCreateStep();
+            planStep = NTxUT::TPlanStep{self.GetCreateStep()};
             auto& sharding = record.GetPathDescription().GetColumnTableDescription().GetSharding();
             UNIT_ASSERT_VALUES_EQUAL(sharding.ColumnShardsSize(), 1);
             shardId = sharding.GetColumnShards()[0];
@@ -1081,7 +1081,7 @@ Y_UNIT_TEST_SUITE(TOlap) {
         TestLsPathId(runtime, 4, checkFn);
         UNIT_ASSERT(shardId);
         UNIT_ASSERT(pathId);
-        UNIT_ASSERT(planStep);
+        UNIT_ASSERT(planStep.Val());
         {
             auto description = DescribePrivatePath(runtime, TTestTxConfig::SchemeShard, "/MyRoot/SomeDatabase/OlapStore/ColumnTable", true, true);
             Cerr << description.DebugString() << Endl;
@@ -1106,11 +1106,11 @@ Y_UNIT_TEST_SUITE(TOlap) {
                 std::vector<ui64> writeIds;
                 ++txId;
                 NTxUT::WriteData(runtime, sender, shardId, ++writeId, pathId, data, defaultYdbSchema, &writeIds, NEvWrite::EModificationType::Upsert, txId);
-                NTxUT::ProposeCommit(runtime, sender, shardId, txId, writeIds, txId);
+                planStep = NTxUT::ProposeCommit(runtime, sender, shardId, txId, writeIds, txId);
                 txIds.insert(txId);
             }
 
-            NTxUT::PlanCommit(runtime, sender, shardId, ++planStep, txIds);
+            NTxUT::PlanCommit(runtime, sender, shardId, planStep, txIds);
 
             WaitTableStats(runtime, shardId);
             CheckQuotaExceedance(runtime, TTestTxConfig::SchemeShard, "/MyRoot/SomeDatabase", true, DEBUG_HINT);
@@ -1155,9 +1155,9 @@ Y_UNIT_TEST_SUITE(TOlap) {
         ++txId;
         bool delResult = NTxUT::WriteData(runtime, sender, shardId, ++writeId, pathId, data, defaultYdbSchema, &writeIds, NEvWrite::EModificationType::Delete, txId);
         Y_UNUSED(delResult);
-        NTxUT::ProposeCommit(runtime, sender, shardId, txId, writeIds, txId);
+        planStep = NTxUT::ProposeCommit(runtime, sender, shardId, txId, writeIds, txId);
         txIds.insert(txId);
-        NTxUT::PlanCommit(runtime, sender, shardId, ++planStep, txIds);
+        NTxUT::PlanCommit(runtime, sender, shardId, planStep, txIds);
 
         csController->EnableBackground(NKikimr::NYDBTest::ICSController::EBackground::Compaction);
         csController->WaitCompactions(TDuration::Seconds(60));
diff --git a/ydb/core/tx/sharding/sharding.cpp b/ydb/core/tx/sharding/sharding.cpp
index d95970482917..b8bef2a4108e 100644
--- a/ydb/core/tx/sharding/sharding.cpp
+++ b/ydb/core/tx/sharding/sharding.cpp
@@ -241,13 +241,13 @@ NKikimrSchemeOp::TColumnTableSharding IShardingBase::SerializeToProto() const {
     return result;
 }
 
-THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> IShardingBase::SplitByShardsToArrowBatches(const std::shared_ptr<arrow::RecordBatch>& batch) {
+THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> IShardingBase::SplitByShardsToArrowBatches(const std::shared_ptr<arrow::RecordBatch>& batch, arrow::MemoryPool* memoryPool) {
     THashMap<ui64, std::vector<ui32>> sharding = MakeSharding(batch);
     THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> chunks;
     if (sharding.size() == 1) {
         AFL_VERIFY(chunks.emplace(sharding.begin()->first, batch).second);
     } else {
-        chunks = NArrow::ShardingSplit(batch, sharding);
+        chunks = NArrow::ShardingSplit(batch, sharding, memoryPool);
     }
     AFL_VERIFY(chunks.size() == sharding.size());
     return chunks;
diff --git a/ydb/core/tx/sharding/sharding.h b/ydb/core/tx/sharding/sharding.h
index 4e0ba237a8b3..30c8a99ac175 100644
--- a/ydb/core/tx/sharding/sharding.h
+++ b/ydb/core/tx/sharding/sharding.h
@@ -310,7 +310,7 @@ class IShardingBase {
 
     virtual THashMap<ui64, std::vector<ui32>> MakeSharding(const std::shared_ptr<arrow::RecordBatch>& batch) const = 0;
 
-    THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> SplitByShardsToArrowBatches(const std::shared_ptr<arrow::RecordBatch>& batch);
+    THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> SplitByShardsToArrowBatches(const std::shared_ptr<arrow::RecordBatch>& batch, arrow::MemoryPool* memoryPool = arrow::default_memory_pool());
     TConclusion<THashMap<ui64, std::vector<NArrow::TSerializedBatch>>> SplitByShards(const std::shared_ptr<arrow::RecordBatch>& batch, const ui64 chunkBytesLimit);
 
     virtual TString DebugString() const;
diff --git a/ydb/core/tx/tx_proxy/rpc_long_tx.cpp b/ydb/core/tx/tx_proxy/rpc_long_tx.cpp
index 435dd536bec6..24f0d1a8bae6 100644
--- a/ydb/core/tx/tx_proxy/rpc_long_tx.cpp
+++ b/ydb/core/tx/tx_proxy/rpc_long_tx.cpp
@@ -2,7 +2,7 @@
 
 #include <ydb/core/formats/arrow/size_calcer.h>
 #include <ydb/core/tx/columnshard/columnshard.h>
-#include <ydb/core/tx/columnshard/counters/common/object_counter.h>
+#include <ydb/library/signals/object_counter.h>
 #include <ydb/core/tx/data_events/shard_writer.h>
 #include <ydb/core/tx/long_tx_service/public/events.h>
 #include <ydb/core/tx/schemeshard/schemeshard.h>
diff --git a/ydb/core/tx/tx_proxy/upload_rows.cpp b/ydb/core/tx/tx_proxy/upload_rows.cpp
index 5bf5d915eea1..c7e542f7e987 100644
--- a/ydb/core/tx/tx_proxy/upload_rows.cpp
+++ b/ydb/core/tx/tx_proxy/upload_rows.cpp
@@ -70,8 +70,7 @@ class TUploadRowsInternal : public TUploadRowsBase<NKikimrServices::TActivity::U
         return false;
     }
 
-    TVector<std::pair<TString, Ydb::Type>> GetRequestColumns(TString& errorMessage) const override {
-        Y_UNUSED(errorMessage);
+    TConclusion<TVector<std::pair<TString, Ydb::Type>>> GetRequestColumns() const override {
         return *ColumnTypes;
     }
 
diff --git a/ydb/core/tx/tx_proxy/upload_rows_common_impl.h b/ydb/core/tx/tx_proxy/upload_rows_common_impl.h
index 171ac8690ec7..e7c98d3ac5d5 100644
--- a/ydb/core/tx/tx_proxy/upload_rows_common_impl.h
+++ b/ydb/core/tx/tx_proxy/upload_rows_common_impl.h
@@ -17,10 +17,11 @@
 #include <ydb/core/tx/datashard/datashard.h>
 #include <ydb/core/tx/scheme_cache/scheme_cache.h>
 #include <ydb/core/tx/tx_proxy/upload_rows_counters.h>
+#include <ydb/core/formats/arrow/accessor/abstract/constructor.h>
 #include <ydb/core/formats/arrow/size_calcer.h>
 
 #include <library/cpp/monlib/dynamic_counters/counters.h>
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 
 #include <ydb/public/api/protos/ydb_status_codes.pb.h>
 #include <ydb/public/api/protos/ydb_value.pb.h>
@@ -302,7 +303,7 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit
     virtual const TString& GetTable() = 0;
     virtual const TVector<std::pair<TSerializedCellVec, TString>>& GetRows() const = 0;
     virtual bool CheckAccess(TString& errorMessage) = 0;
-    virtual TVector<std::pair<TString, Ydb::Type>> GetRequestColumns(TString& errorMessage) const = 0;
+    virtual TConclusion<TVector<std::pair<TString, Ydb::Type>>> GetRequestColumns() const = 0;
     virtual bool ExtractRows(TString& errorMessage) = 0;
     virtual bool ExtractBatch(TString& errorMessage) = 0;
     virtual void RaiseIssue(const NYql::TIssue& issue) = 0;
@@ -343,7 +344,7 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit
     }
 
     TStringBuilder LogPrefix() {
-        return TStringBuilder() << "Bulk upsert to table '" << GetTable() << "'";
+        return TStringBuilder() << "Bulk upsert to table '" << GetTable() << "' ";
     }
 
     static bool SameDstType(NScheme::TTypeInfo type1, NScheme::TTypeInfo type2, bool allowConvert) {
@@ -366,9 +367,10 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit
         return ok;
     }
 
-    bool BuildSchema(const NActors::TActorContext& ctx, TString& errorMessage, bool makeYqbSchema) {
+    [[nodiscard]] TConclusionStatus BuildSchema(const NActors::TActorContext& ctx, bool makeYqbSchema) {
         Y_UNUSED(ctx);
         Y_ABORT_UNLESS(ResolveNamesResult);
+        AFL_VERIFY(ResolveNamesResult->ResultSet.size() == 1);
 
         auto& entry = ResolveNamesResult->ResultSet.front();
 
@@ -377,6 +379,7 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit
         THashSet<TString> keyColumnsLeft;
         THashSet<TString> notNullColumnsLeft = entry.NotNullColumns;
         SrcColumns.reserve(entry.Columns.size());
+        THashSet<TString> HasInternalConversion;
 
         for (const auto& [_, colInfo] : entry.Columns) {
             ui32 id = colInfo.Id;
@@ -396,87 +399,95 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit
             }
         }
 
+        if (entry.ColumnTableInfo) {
+            for (const auto& colInfo : entry.ColumnTableInfo->Description.GetSchema().GetColumns()) {
+                auto& name = colInfo.GetName();
+                NArrow::NAccessor::TConstructorContainer accessor;
+                if (colInfo.HasDataAccessorConstructor()) {
+                    if (!accessor.DeserializeFromProto(colInfo.GetDataAccessorConstructor())) {
+                        return TConclusionStatus::Fail("cannot parse accessor for column: " + name);
+                    }
+                    if (accessor->HasInternalConversion()) {
+                        HasInternalConversion.emplace(name);
+                    }
+                }
+            }
+        }
+
         KeyColumnPositions.resize(KeyColumnTypes.size());
         KeyColumnNames.resize(KeyColumnTypes.size());
 
-        auto reqColumns = GetRequestColumns(errorMessage);
-        if (!errorMessage.empty()) {
-            return false;
-        } else if (reqColumns.empty()) {
+        auto reqColumns = GetRequestColumns();
+        if (reqColumns.IsFail()) {
+            return reqColumns;
+        } else if (reqColumns->empty()) {
             for (auto& [name, typeInfo] : SrcColumns) {
                 Ydb::Type ydbType;
                 ProtoFromTypeInfo(typeInfo, ydbType);
-                reqColumns.emplace_back(name, std::move(ydbType));
+                reqColumns->emplace_back(name, std::move(ydbType));
             }
         }
 
-        for (size_t pos = 0; pos < reqColumns.size(); ++pos) {
-            auto& name = reqColumns[pos].first;
+        for (size_t pos = 0; pos < reqColumns->size(); ++pos) {
+            auto& name = (*reqColumns)[pos].first;
             const auto* cp = columnByName.FindPtr(name);
             if (!cp) {
-                errorMessage = Sprintf("Unknown column: %s", name.c_str());
-                return false;
+                return TConclusionStatus::Fail(Sprintf("Unknown column: %s", name.c_str()));
             }
             i32 pgTypeMod = -1;            
-            ui32 colId = *cp;
+            const ui32 colId = *cp;
             auto& ci = *entry.Columns.FindPtr(colId);
 
             TString columnTypeName = NScheme::TypeName(ci.PType, ci.PTypeMod);
 
-            const Ydb::Type& typeInProto = reqColumns[pos].second;
+            const Ydb::Type& typeInProto = (*reqColumns)[pos].second;
             
             TString parseProtoError;
             NScheme::TTypeInfoMod inTypeInfoMod;
             if (!NScheme::TypeInfoFromProto(typeInProto, inTypeInfoMod, parseProtoError)){
-                errorMessage = Sprintf("Type parse error for column %s: %s",
-                    name.c_str(), parseProtoError.c_str());
-                return false;
+                return TConclusionStatus::Fail(Sprintf("Type parse error for column %s: %s",
+                    name.c_str(), parseProtoError.c_str()));
             }
 
             const NScheme::TTypeInfo& typeInRequest = inTypeInfoMod.TypeInfo;
 
             TString inTypeName = NScheme::TypeName(typeInRequest, typeInRequest.GetPgTypeMod(ci.PTypeMod));
 
-            if (typeInProto.has_type_id()) {
-                bool sourceIsArrow = GetSourceType() != EUploadSource::ProtoValues;
+                if (typeInProto.has_type_id()) {
+                    bool sourceIsArrow = GetSourceType() != EUploadSource::ProtoValues;
                 bool ok = SameOrConvertableDstType(typeInRequest, ci.PType, sourceIsArrow); // TODO
-                if (!ok) {
-                    errorMessage = Sprintf("Type mismatch, got type %s for column %s, but expected %s",
-                        inTypeName.c_str(), name.c_str(), columnTypeName.c_str());
-                    return false;
-                }
-                if (NArrow::TArrowToYdbConverter::NeedInplaceConversion(typeInRequest, ci.PType)) {
-                    ColumnsToConvertInplace[name] = ci.PType;
-                }
-            } else if (typeInProto.has_decimal_type()) {
-                if (typeInRequest != ci.PType) {
-                    errorMessage = Sprintf("Type mismatch, got type %s for column %s, but expected %s",
-                        inTypeName.c_str(), name.c_str(), columnTypeName.c_str());
-                    return false;
-                }
-            } else if (typeInProto.has_pg_type()) {
-                bool ok = SameDstType(typeInRequest, ci.PType, false);
-                if (!ok) {
-                    errorMessage = Sprintf("Type mismatch, got type %s for column %s, but expected %s",
-                        inTypeName.c_str(), name.c_str(), columnTypeName.c_str());
-                    return false;
-                }
-                if (!ci.PTypeMod.empty() && NPg::TypeDescNeedsCoercion(typeInRequest.GetPgTypeDesc())) {
-                    if (inTypeInfoMod.TypeMod != ci.PTypeMod) {
-                        errorMessage = Sprintf("Typemod mismatch, got type %s for column %s, type mod %s, but expected %s",
-                            inTypeName.c_str(), name.c_str(), inTypeInfoMod.TypeMod.c_str(), ci.PTypeMod.c_str());
-                        return false;
+                    if (!ok) {
+                    return TConclusionStatus::Fail(Sprintf("Type mismatch, got type %s for column %s, but expected %s",
+                        inTypeName.c_str(), name.c_str(), columnTypeName.c_str()));
                     }
+                    if (NArrow::TArrowToYdbConverter::NeedInplaceConversion(typeInRequest, ci.PType)) {
+                        ColumnsToConvertInplace[name] = ci.PType;
+                    }
+                } else if (typeInProto.has_decimal_type()) {
+                    if (typeInRequest != ci.PType) {
+                    return TConclusionStatus::Fail(Sprintf("Type mismatch, got type %s for column %s, but expected %s",
+                        inTypeName.c_str(), name.c_str(), columnTypeName.c_str()));
+                    }
+                } else if (typeInProto.has_pg_type()) {
+                    bool ok = SameDstType(typeInRequest, ci.PType, false);
+                    if (!ok) {
+                    return TConclusionStatus::Fail(Sprintf("Type mismatch, got type %s for column %s, but expected %s",
+                        inTypeName.c_str(), name.c_str(), columnTypeName.c_str()));
+                    }
+                    if (!ci.PTypeMod.empty() && NPg::TypeDescNeedsCoercion(typeInRequest.GetPgTypeDesc())) {
+                        if (inTypeInfoMod.TypeMod != ci.PTypeMod) {
+                            return TConclusionStatus::Fail(Sprintf("Typemod mismatch, got type %s for column %s, type mod %s, but expected %s",
+                                inTypeName.c_str(), name.c_str(), inTypeInfoMod.TypeMod.c_str(), ci.PTypeMod.c_str()));
+                        }
 
-                    const auto result = NPg::BinaryTypeModFromTextTypeMod(inTypeInfoMod.TypeMod, typeInRequest.GetPgTypeDesc());
-                    if (result.Error) {
-                        errorMessage = Sprintf("Invalid typemod %s, got type %s for column %s, error %s",
-                           inTypeInfoMod.TypeMod.c_str(), inTypeName.c_str(), name.c_str(), result.Error->c_str());
-                        return false;
+                        const auto result = NPg::BinaryTypeModFromTextTypeMod(inTypeInfoMod.TypeMod, typeInRequest.GetPgTypeDesc());
+                        if (result.Error) {
+                            return TConclusionStatus::Fail(Sprintf("Invalid typemod %s, got type %s for column %s, error %s",
+                                inTypeInfoMod.TypeMod.c_str(), inTypeName.c_str(), name.c_str(), result.Error->c_str()));
+                        }
+                        pgTypeMod = result.Typmod;
                     }
-                    pgTypeMod = result.Typmod;
                 }
-            }
 
             bool notNull = entry.NotNullColumns.contains(ci.Name);
             if (notNull) {
@@ -524,8 +535,7 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit
             }
 
             if (!allowUpdate) {
-                errorMessage = "Only async-indexed tables are supported by BulkUpsert";
-                return false;
+                return TConclusionStatus::Fail("Only async-indexed tables are supported by BulkUpsert");
             }
         }
 
@@ -546,6 +556,9 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit
             }
 
             for (const auto& [colName, colType] : YdbSchema) {
+                if (HasInternalConversion.contains(colName)) {
+                    continue;
+                }
                 if (NArrow::TArrowToYdbConverter::NeedDataConversion(colType)) {
                     ColumnsToConvert[colName] = colType;
                 }
@@ -553,8 +566,7 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit
         }
 
         if (!keyColumnsLeft.empty()) {
-            errorMessage = Sprintf("Missing key columns: %s", JoinSeq(", ", keyColumnsLeft).c_str());
-            return false;
+            return TConclusionStatus::Fail(Sprintf("Missing key columns: %s", JoinSeq(", ", keyColumnsLeft).c_str()));
         }
 
         if (!notNullColumnsLeft.empty() && UpsertIfExists) {
@@ -564,11 +576,10 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit
         }
 
         if (!notNullColumnsLeft.empty()) {
-            errorMessage = Sprintf("Missing not null columns: %s", JoinSeq(", ", notNullColumnsLeft).c_str());
-            return false;
+            return TConclusionStatus::Fail(Sprintf("Missing not null columns: %s", JoinSeq(", ", notNullColumnsLeft).c_str()));
         }
 
-        return true;
+        return TConclusionStatus::Success();
     }
 
     void ResolveTable(const TString& table, const NActors::TActorContext& ctx) {
@@ -615,7 +626,7 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit
         }
 
         TableKind = entry.Kind;
-        bool isColumnTable = (TableKind == NSchemeCache::TSchemeCacheNavigate::KindColumnTable);
+        const bool isColumnTable = (TableKind == NSchemeCache::TSchemeCacheNavigate::KindColumnTable);
 
         if (entry.TableId.IsSystemView()) {
             return ReplyWithError(Ydb::StatusIds::SCHEME_ERROR, "is not supported. Table is a system view", ctx);
@@ -631,11 +642,14 @@ class TUploadRowsBase : public TActorBootstrapped<TUploadRowsBase<DerivedActivit
         ResolveNamesResult.reset(ev->Get()->Request.Release());
 
         bool makeYdbSchema = isColumnTable || (GetSourceType() != EUploadSource::ProtoValues);
-        TString errorMessage;
-        if (!BuildSchema(ctx, errorMessage, makeYdbSchema)) {
-            return ReplyWithError(Ydb::StatusIds::SCHEME_ERROR, errorMessage, ctx);
+        {
+            auto conclusion = BuildSchema(ctx, makeYdbSchema);
+            if (conclusion.IsFail()) {
+                return ReplyWithError(Ydb::StatusIds::SCHEME_ERROR, conclusion.GetErrorMessage(), ctx);
+            }
         }
 
+        TString errorMessage;
         switch (GetSourceType()) {
             case EUploadSource::ProtoValues:
             {
diff --git a/ydb/core/tx/tx_proxy/upload_rows_counters.h b/ydb/core/tx/tx_proxy/upload_rows_counters.h
index 4839e76da172..f48292b896c1 100644
--- a/ydb/core/tx/tx_proxy/upload_rows_counters.h
+++ b/ydb/core/tx/tx_proxy/upload_rows_counters.h
@@ -1,7 +1,7 @@
 #pragma once
 
 #include <ydb/library/actors/core/log.h>
-#include <ydb/core/tx/columnshard/counters/common/owner.h>
+#include <ydb/library/signals/owner.h>
 #include <ydb/core/tx/scheme_cache/scheme_cache.h>
 
 #include <ydb/public/api/protos/ydb_status_codes.pb.h>
diff --git a/ydb/core/ydb_convert/table_description.cpp b/ydb/core/ydb_convert/table_description.cpp
index afe68309c8a2..94041248b9af 100644
--- a/ydb/core/ydb_convert/table_description.cpp
+++ b/ydb/core/ydb_convert/table_description.cpp
@@ -740,6 +740,18 @@ bool FillColumnDescriptionImpl(TColumnTable& out, const google::protobuf::Repeat
         if (!column.Getfamily().empty()) {
             columnDesc->SetColumnFamilyName(column.Getfamily());
         }
+
+        if (column.has_from_literal()) {
+            status = Ydb::StatusIds::BAD_REQUEST;
+            error = TStringBuilder() << "Default values are not supported in column tables";
+            return false;
+        }
+
+        if (column.has_from_sequence()) {
+            status = Ydb::StatusIds::BAD_REQUEST;
+            error = TStringBuilder() << "Default sequences are not supported in column tables";
+            return false;
+        }
     }
 
     return true;
diff --git a/ydb/docs/en/core/yql/reference/_includes/permissions_list.md b/ydb/docs/en/core/yql/reference/_includes/permissions_list.md
index 4c3a108b2d86..edbbe713739a 100644
--- a/ydb/docs/en/core/yql/reference/_includes/permissions_list.md
+++ b/ydb/docs/en/core/yql/reference/_includes/permissions_list.md
@@ -12,8 +12,8 @@ The possible names of rights are listed in the table below.
 | `ydb.database.drop`                   | `DROP`              | The right to delete databases in the cluster                                                        |
 | **Elementary rights for database objects** |                |                                                                                                      |
 | `ydb.granular.select_row`             | `SELECT ROW`        | The right to read rows from a table (select), read messages from topics                             |
-| `ydb.granular.update_row`             | `UPDATE ROW`        | The right to update rows in a table (insert, update, erase), write messages to topics               |
-| `ydb.granular.erase_row`              | `ERASE ROW`         | The right to delete rows from a table                                                               |
+| `ydb.granular.update_row`             | `UPDATE ROW`        | The right to update rows in a table (insert, update, upsert, replace), write messages to topics     |
+| `ydb.granular.erase_row`              | `ERASE ROW`         | The right to delete rows from a table (delete)                                                      |
 | `ydb.granular.create_directory`       | `CREATE DIRECTORY`  | The right to create and delete directories, including existing and nested ones                      |
 | `ydb.granular.create_table`           | `CREATE TABLE`      | The right to create tables (including index, external, columnar), views, sequences                  |
 | `ydb.granular.create_queue`           | `CREATE QUEUE`      | The right to create topics                                                                          |
diff --git a/ydb/docs/ru/core/yql/reference/_includes/permissions_list.md b/ydb/docs/ru/core/yql/reference/_includes/permissions_list.md
index 08ceae13ba4c..6fc055287861 100644
--- a/ydb/docs/ru/core/yql/reference/_includes/permissions_list.md
+++ b/ydb/docs/ru/core/yql/reference/_includes/permissions_list.md
@@ -11,8 +11,8 @@
 `ydb.database.drop` | `DROP` |      
      
 `ydb.granular.select_row` | `SELECT ROW` |      (select),     
-`ydb.granular.update_row` | `UPDATE ROW` |      (insert, update, insert, erase),    
-`ydb.granular.erase_row` | `ERASE ROW` |     
+`ydb.granular.update_row` | `UPDATE ROW` |      (insert, update, upsert, replace),    
+`ydb.granular.erase_row` | `ERASE ROW` |      (delete)
 `ydb.granular.create_directory` | `CREATE DIRECTORY` |     ,      
 `ydb.granular.create_table` | `CREATE TABLE` |    (   , , ), , 
 `ydb.granular.create_queue` | `CREATE QUEUE` |   
diff --git a/ydb/library/accessor/positive_integer.cpp b/ydb/library/accessor/positive_integer.cpp
index dce6a9c33af3..65f5a01bc609 100644
--- a/ydb/library/accessor/positive_integer.cpp
+++ b/ydb/library/accessor/positive_integer.cpp
@@ -34,10 +34,25 @@ ui64 TPositiveControlInteger::Val() const {
     return Value.Val();
 }
 
+TPositiveIncreasingControlInteger&TPositiveIncreasingControlInteger::operator=(const TPositiveIncreasingControlInteger& v) {
+    if (&v != this) {
+        AFL_VERIFY(Value < v.Value);
+        Value = v.Value;
+    }
+    return *this;
 }
 
+} //namespace NKikimr
+
 template<>
 void Out<NKikimr::TPositiveControlInteger>(IOutputStream& o,
     typename TTypeTraits<NKikimr::TPositiveControlInteger>::TFuncParam x) {
     o << x.Val();
 }
+
+
+template<>
+void Out<NKikimr::TPositiveIncreasingControlInteger>(IOutputStream& o,
+    typename TTypeTraits<NKikimr::TPositiveIncreasingControlInteger>::TFuncParam x) {
+    o << x.Val();
+}
diff --git a/ydb/library/accessor/positive_integer.h b/ydb/library/accessor/positive_integer.h
index 3df6e2a6e4b6..266d49453e73 100644
--- a/ydb/library/accessor/positive_integer.h
+++ b/ydb/library/accessor/positive_integer.h
@@ -1,4 +1,5 @@
 #pragma once
+#include <ydb/library/actors/core/log.h>
 #include <util/system/types.h>
 #include <util/stream/output.h>
 #include <util/generic/typetraits.h>
@@ -40,4 +41,26 @@ class TPositiveControlInteger {
     }
 };
 
+class TPositiveIncreasingControlInteger {
+    private:
+        ui64 Value = 0;
+    public:
+        constexpr TPositiveIncreasingControlInteger() = default;
+        explicit constexpr TPositiveIncreasingControlInteger(const ui64 value)
+            : Value(value) {
+        }
+        TPositiveIncreasingControlInteger(const TPositiveIncreasingControlInteger&) = default;
+        TPositiveIncreasingControlInteger& operator=(const TPositiveIncreasingControlInteger& v);
+
+        TPositiveIncreasingControlInteger operator+(ui64 v) const {
+            return TPositiveIncreasingControlInteger(Value + v);
+        }
+        TPositiveIncreasingControlInteger operator-(const ui64 v) const {
+            AFL_VERIFY(v <= Value);
+            return TPositiveIncreasingControlInteger(Value - v);
+        }
+        ui64 Val() const {
+            return Value;
+        }
+    };
 }
diff --git a/ydb/library/conclusion/generic/string_status.h b/ydb/library/conclusion/generic/string_status.h
index 81541395d055..c485bcc7e757 100644
--- a/ydb/library/conclusion/generic/string_status.h
+++ b/ydb/library/conclusion/generic/string_status.h
@@ -44,6 +44,7 @@ class TConclusionStatusImpl: public TConclusionStatusGenericImpl<TConclusionStat
     }
 
     [[nodiscard]] TString GetErrorMessage() const {
+        Y_ABORT_UNLESS(TBase::IsFail());
         return TBase::GetErrorDescription();
     }
 };
diff --git a/ydb/library/formats/arrow/arrow_helpers.cpp b/ydb/library/formats/arrow/arrow_helpers.cpp
index a5efddc2f6a2..2a2c8cd0ce1c 100644
--- a/ydb/library/formats/arrow/arrow_helpers.cpp
+++ b/ydb/library/formats/arrow/arrow_helpers.cpp
@@ -83,20 +83,26 @@ bool IsTrivial(const arrow::UInt64Array& permutation, const ui64 originalLength)
 }
 
 std::shared_ptr<arrow::RecordBatch> Reorder(
-    const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::UInt64Array>& permutation, const bool canRemove) {
+        const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::UInt64Array>& permutation,
+        const bool canRemove, arrow::MemoryPool* memoryPool) {
     Y_ABORT_UNLESS(permutation->length() == batch->num_rows() || canRemove);
 
-    auto res = IsTrivial(*permutation, batch->num_rows()) ? batch : arrow::compute::Take(batch, permutation);
+    arrow::compute::ExecContext ctx(memoryPool);
+    auto res = IsTrivial(*permutation, batch->num_rows())
+        ? batch
+        : arrow::compute::Take(batch, permutation, arrow::compute::TakeOptions::Defaults(), &ctx);
     Y_ABORT_UNLESS(res.ok());
     return (*res).record_batch();
 }
 
 THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> ShardingSplit(
-    const std::shared_ptr<arrow::RecordBatch>& batch, const THashMap<ui64, std::vector<ui32>>& shardRows) {
+        const std::shared_ptr<arrow::RecordBatch>& batch,
+        const THashMap<ui64, std::vector<ui32>>& shardRows,
+        arrow::MemoryPool* memoryPool) {
     AFL_VERIFY(batch);
     std::shared_ptr<arrow::UInt64Array> permutation;
     {
-        arrow::UInt64Builder builder;
+        arrow::UInt64Builder builder(memoryPool);
         Y_VERIFY_OK(builder.Reserve(batch->num_rows()));
 
         for (auto&& [shardId, rowIdxs] : shardRows) {
@@ -742,7 +748,7 @@ std::vector<std::shared_ptr<arrow::RecordBatch>> SliceToRecordBatches(const std:
                 positions.emplace_back(pos);
                 pos += arr->length();
             }
-            AFL_VERIFY(pos == t->num_rows());
+            AFL_VERIFY(pos == t->num_rows())("pos", pos)("length", t->num_rows());
         }
         positions.emplace_back(t->num_rows());
     }
diff --git a/ydb/library/formats/arrow/arrow_helpers.h b/ydb/library/formats/arrow/arrow_helpers.h
index faa630a0904d..e2ece344d9fa 100644
--- a/ydb/library/formats/arrow/arrow_helpers.h
+++ b/ydb/library/formats/arrow/arrow_helpers.h
@@ -53,7 +53,7 @@ std::vector<std::shared_ptr<arrow::RecordBatch>> ShardingSplit(
 std::vector<std::shared_ptr<arrow::RecordBatch>> ShardingSplit(
     const std::shared_ptr<arrow::RecordBatch>& batch, const std::vector<std::vector<ui32>>& shardRows, const ui32 numShards);
 THashMap<ui64, std::shared_ptr<arrow::RecordBatch>> ShardingSplit(
-    const std::shared_ptr<arrow::RecordBatch>& batch, const THashMap<ui64, std::vector<ui32>>& shardRows);
+    const std::shared_ptr<arrow::RecordBatch>& batch, const THashMap<ui64, std::vector<ui32>>& shardRows, arrow::MemoryPool* memoryPool);
 
 std::unique_ptr<arrow::ArrayBuilder> MakeBuilder(
     const std::shared_ptr<arrow::Field>& field, const ui32 reserveItems = 0, const ui32 reserveSize = 0);
@@ -110,7 +110,10 @@ TString DebugString(std::shared_ptr<arrow::Array> array, const ui32 position);
 NJson::TJsonValue DebugJson(std::shared_ptr<arrow::RecordBatch> array, const ui32 position);
 
 std::shared_ptr<arrow::RecordBatch> Reorder(
-    const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::UInt64Array>& permutation, const bool canRemove);
+    const std::shared_ptr<arrow::RecordBatch>& batch,
+    const std::shared_ptr<arrow::UInt64Array>& permutation,
+    const bool canRemove,
+    arrow::MemoryPool* pool = arrow::default_memory_pool());
 
 // Deep-copies all internal arrow::buffers - and makes sure that new buffers don't have any parents.
 std::shared_ptr<arrow::Table> DeepCopy(const std::shared_ptr<arrow::Table>& table, arrow::MemoryPool* pool = arrow::default_memory_pool());
diff --git a/ydb/library/formats/arrow/protos/accessor.proto b/ydb/library/formats/arrow/protos/accessor.proto
index b9edfe1be126..7cb298cf6978 100644
--- a/ydb/library/formats/arrow/protos/accessor.proto
+++ b/ydb/library/formats/arrow/protos/accessor.proto
@@ -1,5 +1,23 @@
 package NKikimrArrowAccessorProto;
 
+message TDataExtractor {
+    optional string ClassName = 1;
+
+    message TJsonScanner {
+        optional bool FirstLevelOnly = 1 [default = false];
+        optional bool ForceSIMDJsonParsing = 2 [default = false];
+    }
+
+    message TSIMDJsonScanner {
+        optional bool FirstLevelOnly = 1 [default = false];
+    }
+
+    oneof Implementation {
+        TJsonScanner JsonScanner = 20;
+        TSIMDJsonScanner SIMDJsonScanner = 21;
+    }
+}
+
 message TRequestedConstructor {
     optional string ClassName = 1;
 
@@ -15,6 +33,7 @@ message TRequestedConstructor {
             optional uint32 ColumnsLimit = 2 [default = 1024];
             optional uint32 ChunkMemoryLimit = 3 [default = 50000000];
             optional double OthersAllowedFraction = 4 [default = 0.05];
+            optional TDataExtractor DataExtractor = 5;
         }
         optional TSettings Settings = 1;
     }
@@ -41,6 +60,7 @@ message TConstructor {
             optional uint32 ColumnsLimit = 2 [default = 1024];
             optional uint32 ChunkMemoryLimit = 3 [default = 50000000];
             optional double OthersAllowedFraction = 4 [default = 0.05];
+            optional TDataExtractor DataExtractor = 5;
         }
         optional TSettings Settings = 1;
     }
diff --git a/ydb/library/formats/arrow/replace_key.h b/ydb/library/formats/arrow/replace_key.h
index a0e3a26b27e5..c4fe75d21d0e 100644
--- a/ydb/library/formats/arrow/replace_key.h
+++ b/ydb/library/formats/arrow/replace_key.h
@@ -8,7 +8,6 @@
 
 #include <contrib/libs/apache/arrow/cpp/src/arrow/api.h>
 #include <contrib/libs/apache/arrow/cpp/src/arrow/compute/api_vector.h>
-
 #include <util/string/builder.h>
 #include <util/string/join.h>
 
@@ -18,7 +17,7 @@ namespace NKikimr::NArrow {
 
 using TArrayVec = std::vector<std::shared_ptr<arrow::Array>>;
 
-template<typename TArrayVecPtr>
+template <typename TArrayVecPtr>
 class TReplaceKeyTemplate {
 public:
     static constexpr bool IsOwning = std::is_same_v<TArrayVecPtr, std::shared_ptr<TArrayVec>>;
@@ -64,21 +63,20 @@ class TReplaceKeyTemplate {
 
     TReplaceKeyTemplate(TArrayVecPtr columns, const ui64 position)
         : Columns(columns)
-        , Position(position)
-    {
+        , Position(position) {
         Y_ABORT_UNLESS(Size() > 0 && Position < (ui64)Column(0).length());
     }
 
-    template<typename T = TArrayVecPtr> requires IsOwning
+    template <typename T = TArrayVecPtr>
+        requires IsOwning
     TReplaceKeyTemplate(TArrayVec&& columns, const ui64 position)
         : Columns(std::make_shared<TArrayVec>(std::move(columns)))
-        , Position(position)
-    {
+        , Position(position) {
         Y_ABORT_UNLESS(Size() > 0 && Position < (ui64)Column(0).length());
     }
 
-    template<typename T>
-    bool operator == (const TReplaceKeyTemplate<T>& key) const {
+    template <typename T>
+    bool operator==(const TReplaceKeyTemplate<T>& key) const {
         Y_ABORT_UNLESS(Size() == key.Size());
 
         for (ui32 i = 0; i < Size(); ++i) {
@@ -90,8 +88,8 @@ class TReplaceKeyTemplate {
         return true;
     }
 
-    template<typename T>
-    std::partial_ordering operator <=> (const TReplaceKeyTemplate<T>& key) const {
+    template <typename T>
+    std::partial_ordering operator<=>(const TReplaceKeyTemplate<T>& key) const {
         Y_ABORT_UNLESS(Size() == key.Size());
 
         for (ui32 i = 0; i < Size(); ++i) {
@@ -103,7 +101,7 @@ class TReplaceKeyTemplate {
         return std::partial_ordering::equivalent;
     }
 
-    template<typename T>
+    template <typename T>
     std::partial_ordering CompareNotNull(const TReplaceKeyTemplate<T>& key) const {
         Y_ABORT_UNLESS(Size() == key.Size());
 
@@ -116,7 +114,7 @@ class TReplaceKeyTemplate {
         return std::partial_ordering::equivalent;
     }
 
-    template<typename T>
+    template <typename T>
     std::partial_ordering ComparePartNotNull(const TReplaceKeyTemplate<T>& key, const ui32 size) const {
         Y_ABORT_UNLESS(size <= key.Size());
         Y_ABORT_UNLESS(size <= Size());
@@ -130,13 +128,13 @@ class TReplaceKeyTemplate {
         return std::partial_ordering::equivalent;
     }
 
-    template<typename T>
+    template <typename T>
     std::partial_ordering CompareColumnValueNotNull(int column, const TReplaceKeyTemplate<T>& key, int keyColumn) const {
         Y_DEBUG_ABORT_UNLESS(Column(column).type_id() == key.Column(keyColumn).type_id());
         return TComparator::TypedCompare<true>(Column(column), Position, key.Column(keyColumn), key.Position);
     }
 
-    template<typename T>
+    template <typename T>
     std::partial_ordering CompareColumnValue(int column, const TReplaceKeyTemplate<T>& key, int keyColumn) const {
         Y_DEBUG_ABORT_UNLESS(Column(column).type_id() == key.Column(keyColumn).type_id());
         return TComparator::TypedCompare<false>(Column(column), Position, key.Column(keyColumn), key.Position);
@@ -172,23 +170,26 @@ class TReplaceKeyTemplate {
         }
     }
 
-    template<typename T = TArrayVecPtr> requires IsOwning
+    template <typename T = TArrayVecPtr>
+        requires IsOwning
     std::shared_ptr<arrow::RecordBatch> RestoreBatch(const std::shared_ptr<arrow::Schema>& schema) const {
         AFL_VERIFY(Size() && Size() == (ui32)schema->num_fields())("columns", DebugString())("schema", JoinSeq(",", schema->field_names()));
         const auto& columns = *Columns;
         return arrow::RecordBatch::Make(schema, columns[0]->length(), columns);
     }
 
-    template<typename T = TArrayVecPtr> requires IsOwning
+    template <typename T = TArrayVecPtr>
+        requires IsOwning
     std::shared_ptr<arrow::RecordBatch> ToBatch(const std::shared_ptr<arrow::Schema>& schema) const {
         auto batch = RestoreBatch(schema);
         Y_ABORT_UNLESS(Position < (ui64)batch->num_rows());
         return batch->Slice(Position, 1);
     }
 
-    template<typename T = TArrayVecPtr> requires IsOwning
-    static TReplaceKeyTemplate<TArrayVecPtr> FromBatch(const std::shared_ptr<arrow::RecordBatch>& batch,
-                                                       const std::shared_ptr<arrow::Schema>& key, int row) {
+    template <typename T = TArrayVecPtr>
+        requires IsOwning
+    static TReplaceKeyTemplate<TArrayVecPtr> FromBatch(
+        const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& key, int row) {
         Y_ABORT_UNLESS(key->num_fields() <= batch->num_columns());
 
         TArrayVec columns;
@@ -204,7 +205,8 @@ class TReplaceKeyTemplate {
         return TReplaceKeyTemplate<TArrayVecPtr>(std::move(columns), row);
     }
 
-    template<typename T = TArrayVecPtr> requires IsOwning
+    template <typename T = TArrayVecPtr>
+        requires IsOwning
     static TReplaceKeyTemplate<TArrayVecPtr> FromBatch(const std::shared_ptr<arrow::RecordBatch>& batch, int row) {
         auto columns = std::make_shared<TArrayVec>(batch->columns());
         return TReplaceKeyTemplate<TArrayVecPtr>(columns, row);
@@ -226,24 +228,153 @@ class TReplaceKeyTemplate {
         return *res;
     }
 
+    const TArrayVecPtr& GetColumns() const {
+        return Columns;
+    }
+
 private:
     TArrayVecPtr Columns = nullptr;
     ui64 Position = 0;
-
 };
 
 using TReplaceKey = TReplaceKeyTemplate<std::shared_ptr<TArrayVec>>;
 
+class TComparablePosition {
+private:
+    std::vector<std::shared_ptr<arrow::Array>> Arrays;
+    std::vector<ui32> Positions;
+
+public:
+    ui32 GetMonoPosition() const {
+        std::optional<ui32> result;
+        for (auto&& i : Positions) {
+            if (!result) {
+                result = i;
+            } else {
+                AFL_VERIFY(*result == i);
+            }
+        }
+        AFL_VERIFY(result);
+        return *result;
+    }
+
+    const std::vector<std::shared_ptr<arrow::Array>>& GetArrays() const {
+        return Arrays;
+    }
+
+    TComparablePosition(const TReplaceKey& key)
+        : Arrays(*key.GetColumns())
+        , Positions(Arrays.size(), key.GetPosition()) {
+    }
+
+    TComparablePosition(const std::shared_ptr<arrow::Table>& table, const ui32 position) {
+        AFL_VERIFY(position < table->num_rows());
+        for (auto&& col : table->columns()) {
+            ui32 pos = 0;
+            bool found = false;
+            for (auto&& chunk : col->chunks()) {
+                if (position < pos + chunk->length()) {
+                    AFL_VERIFY(pos <= position);
+                    Arrays.emplace_back(chunk);
+                    Positions.emplace_back(position - pos);
+                    found = true;
+                    break;
+                }
+                pos += chunk->length();
+            }
+            AFL_VERIFY(found);
+        }
+    }
+
+    TComparablePosition(const std::vector<std::shared_ptr<arrow::ChunkedArray>>& tableColumns, const ui32 position) {
+        for (auto&& col : tableColumns) {
+            ui32 pos = 0;
+            bool found = false;
+            for (auto&& chunk : col->chunks()) {
+                if (position < pos + chunk->length()) {
+                    AFL_VERIFY(pos <= position);
+                    Arrays.emplace_back(chunk);
+                    Positions.emplace_back(position - pos);
+                    found = true;
+                    break;
+                }
+                pos += chunk->length();
+            }
+            AFL_VERIFY(found);
+        }
+    }
+
+    TComparablePosition(const std::shared_ptr<arrow::RecordBatch>& rb, const ui32 position) {
+        AFL_VERIFY(position < rb->num_rows());
+        for (auto&& col : rb->columns()) {
+            Arrays.emplace_back(col);
+            Positions.emplace_back(position);
+        }
+    }
+
+    TString DebugString() const {
+        TStringBuilder sb;
+        for (ui32 i = 0; i < Arrays.size(); ++i) {
+            auto res = Arrays[i]->GetScalar(Positions[i]);
+            if (!res.ok()) {
+                sb << res.status().ToString() << ";";
+            } else {
+                sb << (*res)->ToString() << ";";
+            }
+        }
+        return sb;
+    }
+
+    template <bool NotNull = false>
+    std::partial_ordering Compare(const TComparablePosition& pos) const {
+        AFL_VERIFY(pos.Positions.size() == Positions.size());
+        for (ui32 i = 0; i < Positions.size(); ++i) {
+            AFL_VERIFY(Arrays[i]->type()->id() == pos.Arrays[i]->type()->id());
+            const std::partial_ordering cmpResult =
+                TComparator::TypedCompare<NotNull>(*Arrays[i], Positions[i], *pos.Arrays[i], pos.Positions[i]);
+            if (cmpResult != std::partial_ordering::equivalent) {
+                return cmpResult;
+            }
+        }
+        return std::partial_ordering::equivalent;
+    }
+
+    template <bool NotNull = false>
+    std::partial_ordering ComparePartial(const TComparablePosition& pos) const {
+        for (ui32 i = 0; i < std::min<ui32>(Positions.size(), pos.Positions.size()); ++i) {
+            AFL_VERIFY(Arrays[i]->type()->id() == pos.Arrays[i]->type()->id());
+            const std::partial_ordering cmpResult =
+                TComparator::TypedCompare<NotNull>(*Arrays[i], Positions[i], *pos.Arrays[i], pos.Positions[i]);
+            if (cmpResult != std::partial_ordering::equivalent) {
+                return cmpResult;
+            }
+        }
+        if (Positions.size() < pos.Positions.size()) {
+            return std::partial_ordering::less;
+        } else if (pos.Positions.size() < Positions.size()) {
+            return std::partial_ordering::greater;
+        }
+        return std::partial_ordering::equivalent;
+    }
+
+    bool operator==(const TComparablePosition& pos) const {
+        return Compare(pos) == std::partial_ordering::equivalent;
+    }
+
+    bool operator<(const TComparablePosition& pos) const {
+        return Compare(pos) == std::partial_ordering::less;
+    }
+};
+
 class TReplaceKeyInterval {
 private:
     NArrow::TReplaceKey Start;
     NArrow::TReplaceKey Finish;
+
 public:
     TReplaceKeyInterval(const NArrow::TReplaceKey& start, const NArrow::TReplaceKey& finish)
         : Start(start)
-        , Finish(finish)
-    {
-
+        , Finish(finish) {
     }
 
     const NArrow::TReplaceKey& GetStart() const {
@@ -264,10 +395,10 @@ using TRawReplaceKey = TReplaceKeyTemplate<const TArrayVec*>;
 class TStoreReplaceKey: public TReplaceKey {
 private:
     using TBase = TReplaceKey;
+
 public:
     TStoreReplaceKey(const TReplaceKey& baseKey)
-        : TBase(baseKey)
-    {
+        : TBase(baseKey) {
         TBase::ShrinkToFit();
     }
 };
@@ -289,12 +420,14 @@ static bool IsSelfSorted(const std::shared_ptr<arrow::RecordBatch>& batch) {
         TRawReplaceKey current(&columns, i);
         if constexpr (desc) {
             if (prev < current) {
-                AFL_DEBUG(NKikimrServices::ARROW_HELPER)("event", "prev < current")("current", current.DebugString())("prev", prev.DebugString());
+                AFL_DEBUG(NKikimrServices::ARROW_HELPER)("event", "prev < current")("current", current.DebugString())(
+                    "prev", prev.DebugString());
                 return false;
             }
         } else {
             if (current < prev) {
-                AFL_DEBUG(NKikimrServices::ARROW_HELPER)("event", "current < prev")("current", current.DebugString())("prev", prev.DebugString());
+                AFL_DEBUG(NKikimrServices::ARROW_HELPER)("event", "current < prev")("current", current.DebugString())(
+                    "prev", prev.DebugString());
                 return false;
             }
         }
@@ -308,5 +441,4 @@ static bool IsSelfSorted(const std::shared_ptr<arrow::RecordBatch>& batch) {
     return true;
 }
 
-}
-
+}   // namespace NKikimr::NArrow
diff --git a/ydb/library/formats/arrow/simple_arrays_cache.h b/ydb/library/formats/arrow/simple_arrays_cache.h
index 2d307171658f..a15c8430c87c 100644
--- a/ydb/library/formats/arrow/simple_arrays_cache.h
+++ b/ydb/library/formats/arrow/simple_arrays_cache.h
@@ -1,38 +1,69 @@
 #pragma once
 #include "size_calcer.h"
 
-#include <util/generic/hash.h>
+#include <ydb/library/actors/core/log.h>
 
 #include <contrib/libs/apache/arrow/cpp/src/arrow/array/array_base.h>
-#include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>
 #include <contrib/libs/apache/arrow/cpp/src/arrow/scalar.h>
-#include <ydb/library/actors/core/log.h>
+#include <contrib/libs/apache/arrow/cpp/src/arrow/type.h>
+#include <library/cpp/cache/cache.h>
+#include <util/generic/hash.h>
 
 namespace NKikimr::NArrow {
 
 class TThreadSimpleArraysCache {
 private:
-    THashMap<TString, std::shared_ptr<arrow::Array>> Arrays;
-    const ui64 MaxOneArrayMemorySize = 10 * 1024 * 1024;
+    class TCachedArrayData {
+    private:
+        YDB_READONLY_DEF(std::shared_ptr<arrow::Array>, Array);
+        YDB_READONLY(ui64, Size, 0);
+
+    public:
+        TCachedArrayData() = default;
+        TCachedArrayData(const std::shared_ptr<arrow::Array>& array)
+            : Array(array)
+            , Size(NArrow::GetArrayDataSize(array)) {
+        }
+    };
+
+    struct TCachedSizeProvider {
+        size_t operator()(const TCachedArrayData& data) {
+            return data.GetSize();
+        }
+    };
+
+    TLRUCache<TString, TCachedArrayData, TNoopDelete, TCachedSizeProvider> Arrays;
+    static const ui64 MaxOneArrayMemorySize = 1 * 1024 * 1024;
+    static const ui64 MaxSumMemorySize = 50 * 1024 * 1024;
 
     template <class TInitializeActor>
     std::shared_ptr<arrow::Array> InitializePosition(const TString& key, const ui32 recordsCountExt, const TInitializeActor actor) {
-        const ui32 recordsCount = (recordsCountExt < 1024) ? 1024 : recordsCountExt;
-        auto it = Arrays.find(key);
-        if (it == Arrays.end() || it->second->length() < recordsCount) {
-            auto arrNew = actor(recordsCount);
-            if (NArrow::GetArrayMemorySize(arrNew->data()) < MaxOneArrayMemorySize) {
-                if (it == Arrays.end()) {
-                    it = Arrays.emplace(key, arrNew).first;
+        TCachedArrayData currentValue;
+        std::shared_ptr<arrow::Array> result;
+        {
+            auto it = Arrays.Find(key);
+            if (it == Arrays.End() || it->GetArray()->length() < recordsCountExt) {
+                result = actor(recordsCountExt);
+                TCachedArrayData cache(result);
+                if (cache.GetSize() < MaxOneArrayMemorySize) {
+                    AFL_INFO(NKikimrServices::ARROW_HELPER)("event", "insert_to_cache")("key", key)("records", recordsCountExt)(
+                        "size", cache.GetSize());
+                    if (it != Arrays.End()) {
+                        Arrays.Erase(it);
+                    }
+                    AFL_VERIFY(Arrays.Insert(key, result));
                 } else {
-                    it->second = arrNew;
+                    AFL_INFO(NKikimrServices::ARROW_HELPER)("event", "too_big_to_add")("key", key)("records", recordsCountExt)(
+                        "size", cache.GetSize());
                 }
             } else {
-                AFL_VERIFY(recordsCountExt == recordsCount)("ext", recordsCountExt)("count", recordsCount);
-                return arrNew;
+                result = it->GetArray();
             }
         }
-        return it->second->Slice(0, recordsCountExt);
+        AFL_VERIFY(result);
+        AFL_VERIFY(recordsCountExt <= result->length())("result", result->length())("ext", recordsCountExt);
+        AFL_INFO(NKikimrServices::ARROW_HELPER)("event", "slice_from_cache")("key", key)("records", recordsCountExt)("count", result->length());
+        return result->Slice(0, recordsCountExt);
     }
 
     std::shared_ptr<arrow::Array> GetNullImpl(const std::shared_ptr<arrow::DataType>& type, const ui32 recordsCount);
@@ -40,6 +71,10 @@ class TThreadSimpleArraysCache {
         const std::shared_ptr<arrow::DataType>& type, const std::shared_ptr<arrow::Scalar>& scalar, const ui32 recordsCount);
 
 public:
+    TThreadSimpleArraysCache()
+        : Arrays(MaxSumMemorySize) {
+    }
+
     static std::shared_ptr<arrow::Array> GetNull(const std::shared_ptr<arrow::DataType>& type, const ui32 recordsCount);
     static std::shared_ptr<arrow::Array> GetConst(
         const std::shared_ptr<arrow::DataType>& type, const std::shared_ptr<arrow::Scalar>& scalar, const ui32 recordsCount);
diff --git a/ydb/library/signal_backtrace/signal_backtrace.cpp b/ydb/library/signal_backtrace/signal_backtrace.cpp
new file mode 100644
index 000000000000..1a07ddde6e7e
--- /dev/null
+++ b/ydb/library/signal_backtrace/signal_backtrace.cpp
@@ -0,0 +1,234 @@
+#include "signal_backtrace.h"
+
+#include <ydb/library/yverify_stream/yverify_stream.h>
+
+#include <library/cpp/dwarf_backtrace/backtrace.h>
+#include <library/cpp/logger/log.h>
+
+#include <util/generic/scope.h>
+#include <util/string/builder.h>
+
+#include <sys/wait.h>
+
+using namespace NKikimr;
+
+namespace {
+
+    using TSignalHandlerFn = std::function<void(int, siginfo_t*, void*)>;
+
+    void SetSignalHandler(int signal, TSignalHandlerFn&& newHandler, struct sigaction* oldAction) {
+        static std::array<TSignalHandlerFn, NSIG> signalHandlers;
+
+        Y_VERIFY_S(signal > 0 && signal < NSIG, "Unsupported signal: " << signal);
+        signalHandlers[signal] = std::move(newHandler);
+
+        struct sigaction action;
+        memset(&action, 0, sizeof(action));
+        action.sa_flags = SA_SIGINFO | SA_RESTART;
+        if (signal == SIGCHLD) {
+            action.sa_flags |= SA_NOCLDSTOP; // always receive SIGCHLD only on process termination.
+        }
+        action.sa_sigaction = [](int sig, siginfo_t* info, void* ucontext) {
+            signalHandlers[sig](sig, info, ucontext);
+        };
+        sigaction(signal, &action, oldAction);
+    }
+
+} // namespace
+
+class TTraceCollector::TPipeConnection {
+public:
+    TPipeConnection() {
+        TPipe::Pipe(ReadPipe, WritePipe);
+    }
+
+    ~TPipeConnection() {
+        ReadPipe.Close();
+        WritePipe.Close();
+    }
+
+    size_t Write(const void* buffer, size_t size) const {
+        return WritePipe.Write(buffer, size);
+    }
+
+    size_t Read(void* buffer, size_t size) const {
+        return ReadPipe.Read(buffer, size);
+    }
+
+    void CloseRead() {
+        ReadPipe.Close();
+    }
+    void CloseWrite() {
+        WritePipe.Close();
+    }
+
+private:
+    TPipe ReadPipe;
+    TPipe WritePipe;
+};
+
+class TTraceCollector::TStackTrace {
+public:
+    TStackTrace() : Size(BackTrace(Backtrace.data(), Backtrace.size())) {}
+
+    inline const void* const* Get() const {
+        return Backtrace.data();
+    }
+
+    inline size_t GetSize() const {
+        return Size;
+    }
+
+private:
+    static_assert(PIPE_BUF >= 512);
+
+    // The constant 60 is used because PIPE_BUF >= 512 and
+    // sizeof(TStackTrace) = Backtrace.size() * 8 + 8 should be <= 512
+    std::array<void*, 60> Backtrace;
+    const size_t Size;
+};
+
+// static
+const THashSet<int> TTraceCollector::DEFAULT_SIGNALS = {SIGABRT, SIGBUS, SIGILL, SIGSEGV};
+
+TTraceCollector::TTraceCollector(const THashSet<int>& signalHandlers, IOutputStream& out)
+    : Out(out)
+    , HandledSignals(signalHandlers)
+    , Connection(MakeHolder<TPipeConnection>())
+{
+    static_assert(sizeof(TStackTrace) <= PIPE_BUF, "Reading and writing TStackTrace to the pipe should be atomic");
+
+    CollectorPid = fork();
+
+    if (CollectorPid < 0) {
+        Out << "Failed to fork process: " << strerror(-CollectorPid) << Endl;
+    } else if (CollectorPid == 0) {
+        // TODO: place to setup custom logging facility for the trace collector in the future
+        // Trace collector process
+        RunChildMain();
+    } else {
+        // Main process
+        Connection->CloseRead();
+        SetSignalHandlers();
+
+        Out << "Trace collector pid: " << CollectorPid << Endl;
+    }
+}
+
+TTraceCollector::~TTraceCollector() {
+    Connection->CloseWrite();
+    if (CollectorPid != -1) {
+        waitpid(CollectorPid, nullptr, 0);
+        RestoreSignalHandlers();
+    }
+}
+
+void TTraceCollector::SetSignalHandlers() {
+    // Send the stacktrace when the handled signal is received
+    for (const auto signal: HandledSignals) {
+        // SIGCHLD cannot be caught because it has a special handler
+        Y_VERIFY_S(signal != SIGCHLD, "Trace collector doesn't support signal SIGCHLD");
+        Y_VERIFY_S(signal < NSIG, "Signal number is too big");
+
+        SetSignalHandler(signal, [&](int sig, siginfo_t*, void*) {
+            // TODO: it's a dubious place for log - make sure that in case of heap corruption we don't make things worse
+            Out << "Received signal " << sig << Endl;
+
+            static_assert(PIPE_BUF >= 512);
+            static_assert(sizeof(TStackTrace) <= PIPE_BUF, "Only write to pipe the chunk of size PIPE_BUF is atomic");
+
+            TStackTrace stackTrace;
+            size_t written = Connection->Write(&stackTrace, sizeof(stackTrace));
+            Y_VERIFY_S(sizeof(stackTrace) == written, "Write to pipe is not atomic!");
+
+            waitpid(CollectorPid, nullptr, 0);
+            CollectorPid = -1;
+
+            RestoreSignalHandlers();
+            raise(sig);
+        }, &OldActions[signal]);
+    }
+
+    // Special handler to log the shutdown of the trace collector process
+    SetSignalHandler(SIGCHLD, [&](int sig, siginfo_t* info, void* ucontext) {
+        if (info->si_pid == CollectorPid) {
+            switch(info->si_code) {
+                case CLD_EXITED:
+                    if (info->si_status == 0) {
+                        Out << "The trace collector has finished work normally" << Endl;
+                    } else {
+                        Out << "The trace collector has finished work with exit_code=" << info->si_status << Endl;
+                    }
+                    break;
+                case CLD_KILLED:
+                    Out << "The trace collector was killed by signal=" << info->si_status << Endl;
+                    break;
+                case CLD_DUMPED:
+                    Out << "The trace collector terminated abnormally by signal=" << info->si_status << Endl;
+                    break;
+                default: [[unlikely]]
+                    Out << "Unexpected si_code: " << info->si_code << Endl;
+                    ;
+            }
+
+            RestoreSignalHandlers();
+        } else {
+            const auto& oldHandler = OldActions[sig].sa_handler;
+            if (oldHandler == SIG_DFL || oldHandler == SIG_IGN) {
+                // TODO: we should raise signal again in case of SIG_DFL
+                return;
+            } else {
+                // Call previous signal handler
+                OldActions[sig].sa_sigaction(sig, info, ucontext);
+            }
+        }
+    },
+    &OldActions[SIGCHLD]);
+}
+
+void TTraceCollector::RestoreSignalHandlers() {
+    for (auto sig: HandledSignals) {
+        sigaction(sig, &OldActions[sig], nullptr);
+    }
+}
+
+void TTraceCollector::RunChildMain() {
+    Out << "The trace collector is running" << Endl;
+
+    Connection->CloseWrite();
+    try {
+        TStackTrace trace;
+        size_t read = Connection->Read(&trace, sizeof(trace));
+
+        if (read != 0) {
+            Y_VERIFY_S(sizeof(TStackTrace) == read, "Read from pipe is not atomic");
+            {
+                TStringStream backtrace;
+                backtrace << "Backtrace:
" << Symbolize(trace) << Endl;
+                Out << backtrace.Str();
+            }
+        }
+    } catch (const std::exception& error) {
+        Y_FAIL_S("Error while the trace collector is running: " << error.what());
+    }
+
+    Connection->CloseRead();
+    std::exit(0);
+}
+
+TString TTraceCollector::Symbolize(const TStackTrace& stackTrace) const {
+    TStringStream trace;
+
+    auto error = NDwarf::ResolveBacktrace({stackTrace.Get() + 1, stackTrace.GetSize() - 1}, [&trace](const NDwarf::TLineInfo& info) {
+        trace << "#" << info.Index << " " << info.FunctionName << " at " << info.FileName << ':' << info.Line << ':' << info.Col << '
';
+        return NDwarf::EResolving::Continue;
+    });
+
+    if (error) {
+        trace << "Failed to resolve backtrace
";
+    } else {
+        trace << '
';
+    }
+
+    return trace.Str();
+}
diff --git a/ydb/library/signal_backtrace/signal_backtrace.h b/ydb/library/signal_backtrace/signal_backtrace.h
new file mode 100644
index 000000000000..76835c8960c4
--- /dev/null
+++ b/ydb/library/signal_backtrace/signal_backtrace.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#include <util/generic/hash_set.h>
+#include <util/stream/buffer.h>
+#include <util/system/pipe.h>
+
+#include <array>
+
+namespace NKikimr {
+
+class TTraceCollector : public TSingletonTraits<TTraceCollector> {
+    class TPipeConnection;
+    class TStackTrace;
+
+public:
+    static const THashSet<int> DEFAULT_SIGNALS;
+
+    explicit TTraceCollector(const THashSet<int>& signalHandlers, IOutputStream& out = Cerr);
+    ~TTraceCollector();
+
+private:
+    // Main process routines
+    void SetSignalHandlers();
+    void RestoreSignalHandlers();
+
+    // Forked process routines
+    void RunChildMain();
+    TString Symbolize(const TStackTrace& stackTrace) const;
+
+private:
+    IOutputStream& Out;
+    const THashSet<int> HandledSignals;
+    THolder<TPipeConnection> Connection;
+    pid_t CollectorPid;
+    std::array<struct sigaction, NSIG> OldActions;
+};
+
+} // namespace NKikimr
diff --git a/ydb/library/signal_backtrace/ya.make b/ydb/library/signal_backtrace/ya.make
new file mode 100644
index 000000000000..9f896e039a3f
--- /dev/null
+++ b/ydb/library/signal_backtrace/ya.make
@@ -0,0 +1,11 @@
+LIBRARY()
+
+PEERDIR(
+    library/cpp/dwarf_backtrace
+)
+
+SRCS(
+    signal_backtrace.cpp
+)
+
+END()
diff --git a/ydb/core/tx/columnshard/counters/common/agent.cpp b/ydb/library/signals/agent.cpp
similarity index 100%
rename from ydb/core/tx/columnshard/counters/common/agent.cpp
rename to ydb/library/signals/agent.cpp
diff --git a/ydb/core/tx/columnshard/counters/common/agent.h b/ydb/library/signals/agent.h
similarity index 100%
rename from ydb/core/tx/columnshard/counters/common/agent.h
rename to ydb/library/signals/agent.h
diff --git a/ydb/core/tx/columnshard/counters/common/client.cpp b/ydb/library/signals/client.cpp
similarity index 100%
rename from ydb/core/tx/columnshard/counters/common/client.cpp
rename to ydb/library/signals/client.cpp
diff --git a/ydb/core/tx/columnshard/counters/common/client.h b/ydb/library/signals/client.h
similarity index 100%
rename from ydb/core/tx/columnshard/counters/common/client.h
rename to ydb/library/signals/client.h
diff --git a/ydb/core/tx/columnshard/counters/common/histogram.cpp b/ydb/library/signals/histogram.cpp
similarity index 100%
rename from ydb/core/tx/columnshard/counters/common/histogram.cpp
rename to ydb/library/signals/histogram.cpp
diff --git a/ydb/core/tx/columnshard/counters/common/histogram.h b/ydb/library/signals/histogram.h
similarity index 100%
rename from ydb/core/tx/columnshard/counters/common/histogram.h
rename to ydb/library/signals/histogram.h
diff --git a/ydb/core/tx/columnshard/counters/common/object_counter.cpp b/ydb/library/signals/object_counter.cpp
similarity index 100%
rename from ydb/core/tx/columnshard/counters/common/object_counter.cpp
rename to ydb/library/signals/object_counter.cpp
diff --git a/ydb/core/tx/columnshard/counters/common/object_counter.h b/ydb/library/signals/object_counter.h
similarity index 100%
rename from ydb/core/tx/columnshard/counters/common/object_counter.h
rename to ydb/library/signals/object_counter.h
diff --git a/ydb/core/tx/columnshard/counters/common/owner.cpp b/ydb/library/signals/owner.cpp
similarity index 100%
rename from ydb/core/tx/columnshard/counters/common/owner.cpp
rename to ydb/library/signals/owner.cpp
diff --git a/ydb/core/tx/columnshard/counters/common/owner.h b/ydb/library/signals/owner.h
similarity index 100%
rename from ydb/core/tx/columnshard/counters/common/owner.h
rename to ydb/library/signals/owner.h
diff --git a/ydb/core/tx/columnshard/counters/common/private.cpp b/ydb/library/signals/private.cpp
similarity index 100%
rename from ydb/core/tx/columnshard/counters/common/private.cpp
rename to ydb/library/signals/private.cpp
diff --git a/ydb/core/tx/columnshard/counters/common/private.h b/ydb/library/signals/private.h
similarity index 100%
rename from ydb/core/tx/columnshard/counters/common/private.h
rename to ydb/library/signals/private.h
diff --git a/ydb/core/tx/columnshard/counters/common/ya.make b/ydb/library/signals/ya.make
similarity index 100%
rename from ydb/core/tx/columnshard/counters/common/ya.make
rename to ydb/library/signals/ya.make
diff --git a/ydb/library/wilson_ids/wilson.h b/ydb/library/wilson_ids/wilson.h
index e768c21024c7..27c22d11053e 100644
--- a/ydb/library/wilson_ids/wilson.h
+++ b/ydb/library/wilson_ids/wilson.h
@@ -82,14 +82,11 @@ namespace NKikimr {
                 LookupActor = TComponentTracingLevels::TQueryProcessor::Basic,
                     LookupActorShardsResolve = TComponentTracingLevels::TQueryProcessor::Detailed,
 
-                TableWriteActor = TComponentTracingLevels::TQueryProcessor::Basic,
-                    TableWriteActorTableNavigate = TComponentTracingLevels::TQueryProcessor::Detailed,
-
-                DirectWriteActor = TComponentTracingLevels::TQueryProcessor::Basic,
                 ForwardWriteActor = TComponentTracingLevels::TQueryProcessor::Basic,
-
+                DirectWriteActor = TComponentTracingLevels::TQueryProcessor::Basic,
                 BufferWriteActor = TComponentTracingLevels::TQueryProcessor::Basic,
-                    BufferWriteActorState = TComponentTracingLevels::TQueryProcessor::Basic,
+                    BufferWriteActorState = TComponentTracingLevels::TQueryProcessor::Detailed,
+                    TableWriteActor = TComponentTracingLevels::TQueryProcessor::Detailed,
 
             BulkUpsertActor = TComponentTracingLevels::TQueryProcessor::TopLevel,
         };
diff --git a/ydb/library/ya.make b/ydb/library/ya.make
index 20e9b7445853..21f5dcc51358 100644
--- a/ydb/library/ya.make
+++ b/ydb/library/ya.make
@@ -28,6 +28,8 @@ RECURSE(
     query_actor
     schlab
     security
+    signal_backtrace
+    signals
     table_creator
     testlib
     time_series_vec
diff --git a/ydb/library/yql/dq/actors/compute/dq_compute_actor_impl.h b/ydb/library/yql/dq/actors/compute/dq_compute_actor_impl.h
index 28e44c1e983a..db0b3bf61784 100644
--- a/ydb/library/yql/dq/actors/compute/dq_compute_actor_impl.h
+++ b/ydb/library/yql/dq/actors/compute/dq_compute_actor_impl.h
@@ -653,8 +653,11 @@ class TDqComputeActorBase : public NActors::TActorBootstrapped<TDerived>
         Terminate(State == NDqProto::COMPUTE_STATE_FINISHED, NDqProto::EComputeState_Name(State));
     }
 
-    void InternalError(TIssuesIds::EIssueCode issueCode, const TString& message) {
-        InternalError(NYql::NDqProto::StatusIds::PRECONDITION_FAILED, issueCode, message);
+    void ErrorFromIssue(TIssuesIds::EIssueCode issueCode, const TString& message) {
+        TIssue issue(message);
+        SetIssueCode(issueCode, issue);
+        const auto statusCode = GetDqStatus(issue).GetOrElse(NYql::NDqProto::StatusIds::PRECONDITION_FAILED);
+        InternalError(statusCode, std::move(issue));
     }
 
     void InternalError(NYql::NDqProto::StatusIds::StatusCode statusCode, TIssuesIds::EIssueCode issueCode, const TString& message) {
diff --git a/ydb/library/yql/dq/actors/dq.cpp b/ydb/library/yql/dq/actors/dq.cpp
index 793d1f0c7f90..b7bdff74db0d 100644
--- a/ydb/library/yql/dq/actors/dq.cpp
+++ b/ydb/library/yql/dq/actors/dq.cpp
@@ -1,5 +1,7 @@
 #include "dq.h"
 
+#include <yql/essentials/core/issue/yql_issue.h>
+
 namespace NYql::NDq {
 
 Ydb::StatusIds::StatusCode DqStatusToYdbStatus(NYql::NDqProto::StatusIds::StatusCode statusCode) {
@@ -16,6 +18,8 @@ Ydb::StatusIds::StatusCode DqStatusToYdbStatus(NYql::NDqProto::StatusIds::Status
         return Ydb::StatusIds::ABORTED;
     case NYql::NDqProto::StatusIds::UNAVAILABLE:
         return Ydb::StatusIds::UNAVAILABLE;
+    case NYql::NDqProto::StatusIds::UNDETERMINED:
+        return Ydb::StatusIds::UNDETERMINED;
     case NYql::NDqProto::StatusIds::BAD_REQUEST:
         return Ydb::StatusIds::BAD_REQUEST;
     case NYql::NDqProto::StatusIds::PRECONDITION_FAILED:
@@ -58,6 +62,8 @@ NYql::NDqProto::StatusIds::StatusCode YdbStatusToDqStatus(Ydb::StatusIds::Status
         return NYql::NDqProto::StatusIds::ABORTED;
     case Ydb::StatusIds::UNAVAILABLE:
         return NYql::NDqProto::StatusIds::UNAVAILABLE;
+    case Ydb::StatusIds::UNDETERMINED:
+        return NYql::NDqProto::StatusIds::UNDETERMINED;
     case Ydb::StatusIds::OVERLOADED:
         return NYql::NDqProto::StatusIds::OVERLOADED;
     case Ydb::StatusIds::TIMEOUT:
@@ -80,4 +86,58 @@ NYql::NDqProto::StatusIds::StatusCode YdbStatusToDqStatus(Ydb::StatusIds::Status
     }
 }
 
+TMaybe<NYql::NDqProto::StatusIds::StatusCode> GetDqStatus(const TIssue& issue) {
+    if (issue.GetSeverity() == TSeverityIds::S_FATAL) {
+        return NYql::NDqProto::StatusIds::INTERNAL_ERROR;
+    }
+
+    switch (issue.GetCode()) {
+        case NYql::TIssuesIds::KIKIMR_LOCKS_INVALIDATED:
+        case NYql::TIssuesIds::KIKIMR_LOCKS_ACQUIRE_FAILURE:
+        case NYql::TIssuesIds::KIKIMR_OPERATION_ABORTED:
+        case NYql::TIssuesIds::KIKIMR_SCHEME_MISMATCH:
+            return NYql::NDqProto::StatusIds::ABORTED;
+
+        case NYql::TIssuesIds::KIKIMR_SCHEME_ERROR:
+            return NYql::NDqProto::StatusIds::SCHEME_ERROR;
+
+        case NYql::TIssuesIds::KIKIMR_TEMPORARILY_UNAVAILABLE:
+            return NYql::NDqProto::StatusIds::UNAVAILABLE;
+
+        case NYql::TIssuesIds::KIKIMR_OVERLOADED:
+        case NYql::TIssuesIds::KIKIMR_MULTIPLE_SCHEME_MODIFICATIONS:
+            return NYql::NDqProto::StatusIds::OVERLOADED;
+
+        case NYql::TIssuesIds::KIKIMR_CONSTRAINT_VIOLATION:
+        case NYql::TIssuesIds::KIKIMR_PRECONDITION_FAILED:
+            return NYql::NDqProto::StatusIds::PRECONDITION_FAILED;
+
+        case NYql::TIssuesIds::KIKIMR_BAD_REQUEST:
+        case NYql::TIssuesIds::KIKIMR_BAD_COLUMN_TYPE:
+        case NYql::TIssuesIds::KIKIMR_NO_COLUMN_DEFAULT_VALUE:
+            return NYql::NDqProto::StatusIds::BAD_REQUEST;
+
+        case NYql::TIssuesIds::KIKIMR_ACCESS_DENIED:
+            return NYql::NDqProto::StatusIds::UNAUTHORIZED;
+
+        case NYql::TIssuesIds::KIKIMR_TIMEOUT:
+            return NYql::NDqProto::StatusIds::TIMEOUT;
+
+        case NYql::TIssuesIds::KIKIMR_OPERATION_CANCELLED:
+            return NYql::NDqProto::StatusIds::CANCELLED;
+
+        case NYql::TIssuesIds::KIKIMR_RESULT_UNAVAILABLE:
+        case NYql::TIssuesIds::KIKIMR_OPERATION_STATE_UNKNOWN:
+            return NYql::NDqProto::StatusIds::UNDETERMINED;
+
+        case NYql::TIssuesIds::KIKIMR_UNSUPPORTED:
+            return NYql::NDqProto::StatusIds::UNSUPPORTED;
+
+        default:
+            break;
+    }
+
+    return Nothing();
+}
+
 } // namespace NYql::NDq
diff --git a/ydb/library/yql/dq/actors/dq.h b/ydb/library/yql/dq/actors/dq.h
index 09e44c2fb2b0..f7dbce057c20 100644
--- a/ydb/library/yql/dq/actors/dq.h
+++ b/ydb/library/yql/dq/actors/dq.h
@@ -18,6 +18,7 @@ enum class EStatusCompatibilityLevel {
 
 Ydb::StatusIds::StatusCode DqStatusToYdbStatus(NYql::NDqProto::StatusIds::StatusCode statusCode);
 NYql::NDqProto::StatusIds::StatusCode YdbStatusToDqStatus(Ydb::StatusIds::StatusCode statusCode, EStatusCompatibilityLevel compatibility = EStatusCompatibilityLevel::Basic);
+TMaybe<NYql::NDqProto::StatusIds::StatusCode> GetDqStatus(const TIssue& issue);
 
 struct TEvDq {
 
diff --git a/ydb/library/yql/dq/runtime/dq_tasks_runner.cpp b/ydb/library/yql/dq/runtime/dq_tasks_runner.cpp
index ef941b5741ca..e21821436e2e 100644
--- a/ydb/library/yql/dq/runtime/dq_tasks_runner.cpp
+++ b/ydb/library/yql/dq/runtime/dq_tasks_runner.cpp
@@ -594,18 +594,22 @@ class TDqTaskRunner : public IDqTaskRunner {
                 }
             }
 
-            auto entryNode = AllocatedHolder->ProgramParsed.CompGraph->GetEntryPoint(i, true);
-            if (transform) {
-                transform->TransformInput = DqBuildInputValue(inputDesc, transform->TransformInputType, std::move(inputs), holderFactory, {}, Stats->StartTs, InputConsumed, PgBuilder_.get());
-                inputs.clear();
-                inputs.emplace_back(transform->TransformOutput);
-                entryNode->SetValue(AllocatedHolder->ProgramParsed.CompGraph->GetContext(),
-                    CreateInputUnionValue(transform->TransformOutput->GetInputType(), std::move(inputs), holderFactory,
-                        {inputStats, transform->TransformOutputType}, Stats->StartTs, InputConsumed));
+            auto entryNode = AllocatedHolder->ProgramParsed.CompGraph->GetEntryPoint(i, false);
+            if (entryNode) {
+                if (transform) {
+                    transform->TransformInput = DqBuildInputValue(inputDesc, transform->TransformInputType, std::move(inputs), holderFactory, {}, Stats->StartTs, InputConsumed, PgBuilder_.get());
+                    inputs.clear();
+                    inputs.emplace_back(transform->TransformOutput);
+                    entryNode->SetValue(AllocatedHolder->ProgramParsed.CompGraph->GetContext(),
+                        CreateInputUnionValue(transform->TransformOutput->GetInputType(), std::move(inputs), holderFactory,
+                            {inputStats, transform->TransformOutputType}, Stats->StartTs, InputConsumed));
+                } else {
+                    entryNode->SetValue(AllocatedHolder->ProgramParsed.CompGraph->GetContext(),
+                        DqBuildInputValue(inputDesc, entry->InputItemTypes[i], std::move(inputs), holderFactory,
+                            {inputStats, entry->InputItemTypes[i]}, Stats->StartTs, InputConsumed, PgBuilder_.get()));
+                }
             } else {
-                entryNode->SetValue(AllocatedHolder->ProgramParsed.CompGraph->GetContext(),
-                    DqBuildInputValue(inputDesc, entry->InputItemTypes[i], std::move(inputs), holderFactory,
-                        {inputStats, entry->InputItemTypes[i]}, Stats->StartTs, InputConsumed, PgBuilder_.get()));
+                // In some cases we don't need input. For example, for joining EmptyIterator with table.
             }
         }
 
diff --git a/ydb/services/persqueue_v1/ut/topic_service_ut.cpp b/ydb/services/persqueue_v1/ut/topic_service_ut.cpp
index 4df8f2fc7556..8409f81fc184 100644
--- a/ydb/services/persqueue_v1/ut/topic_service_ut.cpp
+++ b/ydb/services/persqueue_v1/ut/topic_service_ut.cpp
@@ -412,7 +412,11 @@ Y_UNIT_TEST_F(MultiplePartitionsAndNoGapsInTheOffsets, TUpdateOffsetsInTransacti
     auto result = tx->Commit().ExtractValueSync();
     Cerr << ">>> CommitTx >>>" << Endl;
     UNIT_ASSERT_EQUAL(result.IsTransportError(), false);
-    UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::ABORTED);
+    if (server->ServerSettings.AppConfig->GetTableServiceConfig().GetEnableOltpSink()) {
+        UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::BAD_REQUEST);
+    } else {
+        UNIT_ASSERT_VALUES_EQUAL(result.GetStatus(), NYdb::EStatus::ABORTED);
+    }
 }
 
 }
diff --git a/ydb/services/ydb/backup_ut/ydb_backup_ut.cpp b/ydb/services/ydb/backup_ut/ydb_backup_ut.cpp
index d35f6f8f9680..5e9774c5dee5 100644
--- a/ydb/services/ydb/backup_ut/ydb_backup_ut.cpp
+++ b/ydb/services/ydb/backup_ut/ydb_backup_ut.cpp
@@ -235,7 +235,7 @@ auto CreateMinPartitionsChecker(ui32 expectedMinPartitions, const TString& debug
     };
 }
 
-auto CreateHasIndexChecker(const TString& indexName, EIndexType indexType) {
+auto CreateHasIndexChecker(const TString& indexName, EIndexType indexType, bool prefix) {
     return [=](const TTableDescription& tableDescription) {
         for (const auto& indexDesc : tableDescription.GetIndexDescriptions()) {
             if (indexDesc.GetIndexName() != indexName) {
@@ -244,13 +244,16 @@ auto CreateHasIndexChecker(const TString& indexName, EIndexType indexType) {
             if (indexDesc.GetIndexType() != indexType) {
                 continue;
             }
-            if (indexDesc.GetIndexColumns().size() != 1) {
+            if (indexDesc.GetIndexColumns().size() != (prefix ? 2 : 1)) {
                 continue;
             }
             if (indexDesc.GetDataColumns().size() != 0) {
                 continue;
             }
-            if (indexDesc.GetIndexColumns()[0] != "Value") {
+            if (prefix && indexDesc.GetIndexColumns().front() != "Group") {
+                continue;
+            }
+            if (indexDesc.GetIndexColumns().back() != "Value") {
                 continue;
             }
             if (indexType != NYdb::NTable::EIndexType::GlobalVectorKMeansTree) {
@@ -587,23 +590,37 @@ NYdb::NTable::EIndexType ConvertIndexTypeToAPI(NKikimrSchemeOp::EIndexType index
 }
 
 void TestRestoreTableWithIndex(
-    const char* table, const char* index, NKikimrSchemeOp::EIndexType indexType, TSession& session,
+    const char* table, const char* index, NKikimrSchemeOp::EIndexType indexType, bool prefix, TSession& session,
     TBackupFunction&& backup, TRestoreFunction&& restore
 ) {
     TString query;
     if (indexType == NKikimrSchemeOp::EIndexTypeGlobalVectorKmeansTree) {
-        query = Sprintf(R"(CREATE TABLE `%s` (
-            Key Uint32,
-            Value String,
-            PRIMARY KEY (Key),
-            INDEX %s GLOBAL USING vector_kmeans_tree
-                ON (Value)
-                WITH (similarity=inner_product, vector_type=float, vector_dimension=768, levels=2, clusters=80)
-        );)", table, index);
+        if (prefix) {
+            query = Sprintf(R"(CREATE TABLE `%s` (
+                Key Uint32,
+                Group Uint32,
+                Value String,
+                PRIMARY KEY (Key),
+                INDEX %s GLOBAL USING vector_kmeans_tree
+                    ON (Group, Value)
+                    WITH (similarity=inner_product, vector_type=float, vector_dimension=768, levels=2, clusters=80)
+            );)", table, index);
+        } else {
+            query = Sprintf(R"(CREATE TABLE `%s` (
+                Key Uint32,
+                Group Uint32,
+                Value String,
+                PRIMARY KEY (Key),
+                INDEX %s GLOBAL USING vector_kmeans_tree
+                    ON (Value)
+                    WITH (similarity=inner_product, vector_type=float, vector_dimension=768, levels=2, clusters=80)
+            );)", table, index);
+        }
     } else {
         query = Sprintf(R"(
             CREATE TABLE `%s` (
                 Key Uint32,
+                Group Uint32,
                 Value Uint32,
                 PRIMARY KEY (Key),
                 INDEX %s %s ON (Value)
@@ -622,7 +639,7 @@ void TestRestoreTableWithIndex(
 
     restore();
 
-    CheckTableDescription(session, table, CreateHasIndexChecker(index, ConvertIndexTypeToAPI(indexType)));
+    CheckTableDescription(session, table, CreateHasIndexChecker(index, ConvertIndexTypeToAPI(indexType), prefix));
 }
 
 void TestRestoreDirectory(const char* directory, TSchemeClient& client, TBackupFunction&& backup, TRestoreFunction&& restore) {
@@ -1487,7 +1504,7 @@ Y_UNIT_TEST_SUITE(BackupRestore) {
         );
     }
 
-    void TestTableWithIndexBackupRestore(NKikimrSchemeOp::EIndexType indexType = NKikimrSchemeOp::EIndexTypeGlobal) {
+    void TestTableWithIndexBackupRestore(NKikimrSchemeOp::EIndexType indexType = NKikimrSchemeOp::EIndexTypeGlobal, bool prefix = false) {
         NKikimrConfig::TAppConfig appConfig;
         appConfig.MutableFeatureFlags()->SetEnableVectorIndex(true);
         TKikimrWithGrpcAndRootSchema server{std::move(appConfig)};
@@ -1504,6 +1521,7 @@ Y_UNIT_TEST_SUITE(BackupRestore) {
             table,
             index,
             indexType,
+            prefix,
             session,
             CreateBackupLambda(driver, pathToBackup),
             CreateRestoreLambda(driver, pathToBackup)
@@ -1830,6 +1848,10 @@ Y_UNIT_TEST_SUITE(BackupRestore) {
                 UNIT_FAIL("Client backup/restore were not implemented for this index type");
         }
     }
+
+    Y_UNIT_TEST(PrefixedVectorIndex) {
+        TestTableWithIndexBackupRestore(NKikimrSchemeOp::EIndexTypeGlobalVectorKmeansTree, true);
+    }
 }
 
 Y_UNIT_TEST_SUITE(BackupRestoreS3) {
@@ -2217,7 +2239,7 @@ Y_UNIT_TEST_SUITE(BackupRestoreS3) {
         );
     }
 
-    void TestTableWithIndexBackupRestore(NKikimrSchemeOp::EIndexType indexType = NKikimrSchemeOp::EIndexTypeGlobal) {
+    void TestTableWithIndexBackupRestore(NKikimrSchemeOp::EIndexType indexType = NKikimrSchemeOp::EIndexTypeGlobal, bool prefix = false) {
         TS3TestEnv testEnv;
         constexpr const char* table = "/Root/table";
         constexpr const char* index = "value_idx";
@@ -2226,6 +2248,7 @@ Y_UNIT_TEST_SUITE(BackupRestoreS3) {
             table,
             index,
             indexType,
+            prefix,
             testEnv.GetTableSession(),
             CreateBackupLambda(testEnv.GetDriver(), testEnv.GetS3Port()),
             CreateRestoreLambda(testEnv.GetDriver(), testEnv.GetS3Port(), { "table" })
@@ -2345,4 +2368,8 @@ Y_UNIT_TEST_SUITE(BackupRestoreS3) {
                 UNIT_FAIL("S3 backup/restore were not implemented for this index type");
         }
     }
+
+    Y_UNIT_TEST(PrefixedVectorIndex) {
+        TestTableWithIndexBackupRestore(NKikimrSchemeOp::EIndexTypeGlobalVectorKmeansTree, true);
+    }
 }
diff --git a/ydb/services/ydb/ydb_common_ut.h b/ydb/services/ydb/ydb_common_ut.h
index 5a0083485514..aad0d679a1fa 100644
--- a/ydb/services/ydb/ydb_common_ut.h
+++ b/ydb/services/ydb/ydb_common_ut.h
@@ -139,10 +139,12 @@ class TBasicKikimrWithGrpcAndRootSchema {
 
         //Server_->GetRuntime()->SetLogPriority(NKikimrServices::TX_PROXY_SCHEME_CACHE, NActors::NLog::PRI_DEBUG);
         //Server_->GetRuntime()->SetLogPriority(NKikimrServices::SCHEME_BOARD_REPLICA, NActors::NLog::PRI_DEBUG);
-        Server_->GetRuntime()->SetLogPriority(NKikimrServices::FLAT_TX_SCHEMESHARD, NActors::NLog::PRI_INFO);
+        //Server_->GetRuntime()->SetLogPriority(NKikimrServices::FLAT_TX_SCHEMESHARD, NActors::NLog::PRI_INFO);
         //Server_->GetRuntime()->SetLogPriority(NKikimrServices::TX_PROXY, NActors::NLog::PRI_DEBUG);
         //Server_->GetRuntime()->SetLogPriority(NKikimrServices::TX_OLAPSHARD, NActors::NLog::PRI_DEBUG);
         //Server_->GetRuntime()->SetLogPriority(NKikimrServices::TX_COLUMNSHARD, NActors::NLog::PRI_DEBUG);
+        //Server_->GetRuntime()->SetLogPriority(NKikimrServices::KQP_SESSION, NActors::NLog::PRI_DEBUG);
+        //Server_->GetRuntime()->SetLogPriority(NKikimrServices::KQP_EXECUTER, NActors::NLog::PRI_DEBUG);
         if (enableYq) {
             Server_->GetRuntime()->SetLogPriority(NKikimrServices::YQL_PROXY, NActors::NLog::PRI_DEBUG);
             Server_->GetRuntime()->SetLogPriority(NKikimrServices::KQP_COMPUTE, NActors::NLog::PRI_DEBUG);
diff --git a/ydb/services/ydb/ydb_table_ut.cpp b/ydb/services/ydb/ydb_table_ut.cpp
index 68e90446d36e..f5bbaeb1712f 100644
--- a/ydb/services/ydb/ydb_table_ut.cpp
+++ b/ydb/services/ydb/ydb_table_ut.cpp
@@ -2841,168 +2841,181 @@ R"___(<main>: Error: Transaction not found: , code: 2015
 
 
     Y_UNIT_TEST(QueryStats) {
-        TKikimrWithGrpcAndRootSchema server;
+        for (bool useSink : {false, true}) {
+            NKikimrConfig::TAppConfig appConfig;
+            appConfig.MutableTableServiceConfig()->SetEnableOltpSink(useSink);
+            TKikimrWithGrpcAndRootSchema server(appConfig);
 
-        NYdb::TDriver driver(TDriverConfig().SetEndpoint(TStringBuilder() << "localhost:" << server.GetPort()));
-        NYdb::NTable::TTableClient client(driver);
+            NYdb::TDriver driver(TDriverConfig().SetEndpoint(TStringBuilder() << "localhost:" << server.GetPort()));
+            NYdb::NTable::TTableClient client(driver);
 
-        auto sessionResult = client.CreateSession().ExtractValueSync();
-        UNIT_ASSERT_VALUES_EQUAL(sessionResult.GetStatus(), EStatus::SUCCESS);
-        auto session = sessionResult.GetSession();
+            auto sessionResult = client.CreateSession().ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL(sessionResult.GetStatus(), EStatus::SUCCESS);
+            auto session = sessionResult.GetSession();
 
-        const ui32 SHARD_COUNT = 4;
+            const ui32 SHARD_COUNT = 4;
 
-        {
-            auto tableBuilder = client.GetTableBuilder();
-            tableBuilder
-                .AddNullableColumn("Key", EPrimitiveType::Uint32)
-                .AddNullableColumn("Value", EPrimitiveType::Utf8);
-            tableBuilder.SetPrimaryKeyColumn("Key");
+            {
+                auto tableBuilder = client.GetTableBuilder();
+                tableBuilder
+                    .AddNullableColumn("Key", EPrimitiveType::Uint32)
+                    .AddNullableColumn("Value", EPrimitiveType::Utf8);
+                tableBuilder.SetPrimaryKeyColumn("Key");
 
-            auto tableSettings = NYdb::NTable::TCreateTableSettings().PartitioningPolicy(
-                NYdb::NTable::TPartitioningPolicy().UniformPartitions(SHARD_COUNT));
+                auto tableSettings = NYdb::NTable::TCreateTableSettings().PartitioningPolicy(
+                    NYdb::NTable::TPartitioningPolicy().UniformPartitions(SHARD_COUNT));
 
-            auto result = session.CreateTable("/Root/Foo", tableBuilder.Build(), tableSettings).ExtractValueSync();
-            UNIT_ASSERT_EQUAL(result.IsTransportError(), false);
-            UNIT_ASSERT_EQUAL(result.GetStatus(), EStatus::SUCCESS);
-        }
-
-        for (bool returnStats : {false, true}) {
-            NYdb::NTable::TExecDataQuerySettings execSettings;
-            if (returnStats) {
-                execSettings.CollectQueryStats(ECollectQueryStatsMode::Profile);
+                auto result = session.CreateTable("/Root/Foo", tableBuilder.Build(), tableSettings).ExtractValueSync();
+                UNIT_ASSERT_EQUAL(result.IsTransportError(), false);
+                UNIT_ASSERT_EQUAL(result.GetStatus(), EStatus::SUCCESS);
             }
-            {
-                auto query = "UPSERT INTO `/Root/Foo` (Key, Value) VALUES (0, 'aa');";
-                auto result = session.ExecuteDataQuery(
-                            query,
-                            TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();
 
-                if (!returnStats) {
-                    UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);
-                } else {
-                    // Cerr << "
QUERY: " << query << "
STATS:
" << result.GetStats()->ToString() << Endl;
-                    auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
-                    if (stats.query_phases().size() == 1) {
-                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
-                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/Foo");
-                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 1);
-                        UNIT_ASSERT(stats.query_phases(0).table_access(0).updates().bytes() > 1);
-                        UNIT_ASSERT(stats.query_phases(0).cpu_time_us() > 0);
-                        UNIT_ASSERT(stats.total_duration_us() > 0);
+            for (bool returnStats : {false, true}) {
+                NYdb::NTable::TExecDataQuerySettings execSettings;
+                if (returnStats) {
+                    execSettings.CollectQueryStats(ECollectQueryStatsMode::Profile);
+                }
+                {
+                    auto query = "UPSERT INTO `/Root/Foo` (Key, Value) VALUES (0, 'aa');";
+                    auto result = session.ExecuteDataQuery(
+                                query,
+                                TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();
+
+                    if (!returnStats) {
+                        UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);
                     } else {
-                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
-                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
-                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/Foo");
-                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);
-                        UNIT_ASSERT(stats.query_phases(1).table_access(0).updates().bytes() > 1);
-                        UNIT_ASSERT(stats.query_phases(1).cpu_time_us() > 0);
-                        UNIT_ASSERT(stats.total_duration_us() > 0);
+                        // Cerr << "
QUERY: " << query << "
STATS:
" << result.GetStats()->ToString() << Endl;
+                        auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
+                        if (stats.query_phases().size() == 1) {
+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/Foo");
+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).updates().rows(), 1);
+                            UNIT_ASSERT(stats.query_phases(0).table_access(0).updates().bytes() > 1);
+                            UNIT_ASSERT(stats.query_phases(0).cpu_time_us() > 0);
+                            UNIT_ASSERT(stats.total_duration_us() > 0);
+                        } else {
+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/Foo");
+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 1);
+                            UNIT_ASSERT(stats.query_phases(1).table_access(0).updates().bytes() > 1);
+                            UNIT_ASSERT(stats.query_phases(1).cpu_time_us() > 0);
+                            UNIT_ASSERT(stats.total_duration_us() > 0);
+                        }
                     }
                 }
-            }
 
-            {
-                auto query = "UPSERT INTO `/Root/Foo` (Key, Value) VALUES (1, Utf8('bb')), (0xffffffff, Utf8('cc'));";
-                auto result = session.ExecuteDataQuery(
-                            query,
-                            TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();
+                {
+                    auto query = "UPSERT INTO `/Root/Foo` (Key, Value) VALUES (1, Utf8('bb')), (0xffffffff, Utf8('cc'));";
+                    auto result = session.ExecuteDataQuery(
+                                query,
+                                TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();
 
-                if (!returnStats) {
-                    UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);
-                } else {
-                    // Cerr << "
QUERY: " << query << "
STATS:
" << result.GetStats()->ToString() << Endl;
-                    auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 2);
-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access().size(), 1);
-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).name(), "/Root/Foo");
-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(1).table_access(0).updates().rows(), 2);
-                    UNIT_ASSERT(stats.query_phases(1).table_access(0).updates().bytes() > 1);
-                    UNIT_ASSERT(stats.query_phases(1).cpu_time_us() > 0);
-                    UNIT_ASSERT(stats.total_duration_us() > 0);
+                    if (!returnStats) {
+                        UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);
+                    } else {
+                        // Cerr << "
QUERY: " << query << "
STATS:
" << result.GetStats()->ToString() << Endl;
+                        auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), useSink ? 1 : 2);
+                        const auto idx = stats.query_phases().size() - 1;
+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access().size(), 1);
+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).name(), "/Root/Foo");
+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).updates().rows(), 2);
+                        UNIT_ASSERT(stats.query_phases(idx).table_access(0).updates().bytes() > 1);
+                        UNIT_ASSERT(stats.query_phases(idx).cpu_time_us() > 0);
+                        UNIT_ASSERT(stats.total_duration_us() > 0);
+                    }
                 }
-            }
 
-            {
-                auto query = "SELECT * FROM `/Root/Foo`;";
-                auto result = session.ExecuteDataQuery(
-                            query,
-                            TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();
+                {
+                    auto query = "SELECT * FROM `/Root/Foo`;";
+                    auto result = session.ExecuteDataQuery(
+                                query,
+                                TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();
 
-                if (!returnStats) {
-                    UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);
-                } else {
-                    // Cerr << "
QUERY: " << query << "
STATS:
" << result.GetStats()->ToString() << Endl;
-                    auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);
-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/Foo");
-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 3);
-                    UNIT_ASSERT(stats.query_phases(0).table_access(0).reads().bytes() > 3);
-                    UNIT_ASSERT(stats.query_phases(0).cpu_time_us() > 0);
-                    UNIT_ASSERT(stats.total_duration_us() > 0);
+                    if (!returnStats) {
+                        UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);
+                    } else {
+                        // Cerr << "
QUERY: " << query << "
STATS:
" << result.GetStats()->ToString() << Endl;
+                        auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);
+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/Foo");
+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 3);
+                        UNIT_ASSERT(stats.query_phases(0).table_access(0).reads().bytes() > 3);
+                        UNIT_ASSERT(stats.query_phases(0).cpu_time_us() > 0);
+                        UNIT_ASSERT(stats.total_duration_us() > 0);
+                    }
                 }
-            }
 
-            {
-                auto query = "SELECT * FROM `/Root/Foo` WHERE Key == 1;";
-                auto result = session.ExecuteDataQuery(
-                            query,
-                            TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();
+                {
+                    auto query = "SELECT * FROM `/Root/Foo` WHERE Key == 1;";
+                    auto result = session.ExecuteDataQuery(
+                                query,
+                                TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();
 
-                if (!returnStats) {
-                    UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);
-                } else {
-                    // Cerr << "
QUERY: " << query << "
STATS:
" << result.GetStats()->ToString() << Endl;
-                    auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);
-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/Foo");
-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 1);
-                    UNIT_ASSERT(stats.query_phases(0).table_access(0).reads().bytes() > 1);
-                    UNIT_ASSERT(stats.query_phases(0).cpu_time_us() > 0);
-                    UNIT_ASSERT(stats.total_duration_us() > 0);
+                    if (!returnStats) {
+                        UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);
+                    } else {
+                        // Cerr << "
QUERY: " << query << "
STATS:
" << result.GetStats()->ToString() << Endl;
+                        auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);
+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access().size(), 1);
+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).name(), "/Root/Foo");
+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(0).table_access(0).reads().rows(), 1);
+                        UNIT_ASSERT(stats.query_phases(0).table_access(0).reads().bytes() > 1);
+                        UNIT_ASSERT(stats.query_phases(0).cpu_time_us() > 0);
+                        UNIT_ASSERT(stats.total_duration_us() > 0);
+                    }
                 }
-            }
 
-            {
-                auto query = "DELETE FROM `/Root/Foo` WHERE Key > 0;";
-                auto result = session.ExecuteDataQuery(
-                            query,
-                            TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();
-
-                if (!returnStats) {
-                    UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);
-                } else {
-                    // Cerr << "
QUERY: " << query << "
STATS:
" << result.GetStats()->ToString() << Endl;
-                    auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
+                {
+                    auto query = "DELETE FROM `/Root/Foo` WHERE Key > 0;";
+                    auto result = session.ExecuteDataQuery(
+                                query,
+                                TTxControl::BeginTx().CommitTx(), execSettings).ExtractValueSync();
 
-                    int idx = 0;
-                    if (stats.query_phases().size() == 2) {
-                        idx = 0;
+                    if (!returnStats) {
+                        UNIT_ASSERT_VALUES_EQUAL(result.GetStats().has_value(), false);
                     } else {
-                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 3);
-                        UNIT_ASSERT(stats.query_phases(0).table_access().empty());
-                        idx = 1;
+                        // Cerr << "
QUERY: " << query << "
STATS:
" << result.GetStats()->ToString() << Endl;
+                        auto& stats = NYdb::TProtoAccessor::GetProto(*result.GetStats());
+
+                        int idx = 0;
+                        if (useSink) {
+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 1);
+                            idx = 0;
+                        } else if (stats.query_phases().size() == 2) {
+                            idx = 0;
+                        } else {
+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases().size(), 3);
+                            UNIT_ASSERT(stats.query_phases(0).table_access().empty());
+                            idx = 1;
+                        }
+
+                        // 1st phase: find matching rows
+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access().size(), 1);
+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).name(), "/Root/Foo");
+                        UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).reads().rows(), 2);
+                        if (useSink) {
+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).deletes().rows(), 2);
+                        }
+                        UNIT_ASSERT(stats.query_phases(idx).cpu_time_us() > 0);
+                        // 2nd phase: delete found rows
+                        if (!useSink) {
+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx + 1).table_access().size(), 1);
+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx + 1).table_access(0).name(), "/Root/Foo");
+                            UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx + 1).table_access(0).deletes().rows(), 2);
+                            UNIT_ASSERT(stats.query_phases(idx + 1).cpu_time_us() > 0);
+                        }
+                        UNIT_ASSERT(stats.total_duration_us() > 0);
                     }
-
-                    // 1st phase: find matching rows
-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access().size(), 1);
-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).name(), "/Root/Foo");
-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx).table_access(0).reads().rows(), 2);
-                    UNIT_ASSERT(stats.query_phases(idx).cpu_time_us() > 0);
-                    // 2nd phase: delete found rows
-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx + 1).table_access().size(), 1);
-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx + 1).table_access(0).name(), "/Root/Foo");
-                    UNIT_ASSERT_VALUES_EQUAL(stats.query_phases(idx + 1).table_access(0).deletes().rows(), 2);
-                    UNIT_ASSERT(stats.query_phases(idx + 1).cpu_time_us() > 0);
-                    UNIT_ASSERT(stats.total_duration_us() > 0);
                 }
             }
-        }
 
-        sessionResult = client.CreateSession().ExtractValueSync();
-        UNIT_ASSERT_VALUES_EQUAL(sessionResult.GetStatus(), EStatus::SUCCESS);
+            sessionResult = client.CreateSession().ExtractValueSync();
+            UNIT_ASSERT_VALUES_EQUAL(sessionResult.GetStatus(), EStatus::SUCCESS);
+        }
     }
 
     Y_UNIT_TEST(CopyTables) {
diff --git a/ydb/services/ydb/ydb_ut.cpp b/ydb/services/ydb/ydb_ut.cpp
index 3b17744f0a4d..b6bfd312b4b4 100644
--- a/ydb/services/ydb/ydb_ut.cpp
+++ b/ydb/services/ydb/ydb_ut.cpp
@@ -5703,8 +5703,10 @@ Y_UNIT_TEST_SUITE(TYqlDateTimeTests) {
 #endif
 
 Y_UNIT_TEST_SUITE(LocalityOperation) {
-Y_UNIT_TEST(LocksFromAnotherTenants) {
-    TKikimrWithGrpcAndRootSchema server;
+Y_UNIT_TEST_TWIN(LocksFromAnotherTenants, UseSink) {
+    NKikimrConfig::TAppConfig appConfig;
+    appConfig.MutableTableServiceConfig()->SetEnableOltpSink(UseSink);
+    TKikimrWithGrpcAndRootSchema server(appConfig);
     //server.Server_->SetupLogging(
 
     auto connection = NYdb::TDriver(
diff --git a/yql/essentials/types/binary_json/read.cpp b/yql/essentials/types/binary_json/read.cpp
index 0786e59853ac..d50f8b82d8cc 100644
--- a/yql/essentials/types/binary_json/read.cpp
+++ b/yql/essentials/types/binary_json/read.cpp
@@ -330,9 +330,7 @@ TString SerializeToJson(const TBinaryJson& binaryJson) {
     return SerializeToJson(TStringBuf(binaryJson.Data(), binaryJson.Size()));
 }
 
-TString SerializeToJson(TStringBuf binaryJson) {
-    auto reader = TBinaryJsonReader::Make(binaryJson);
-
+TString SerializeToJson(const TContainerCursor& cursor) {
     TJsonWriterConfig config;
     config.DoubleNDigits = 16;
     config.FloatNDigits = 8;
@@ -340,11 +338,16 @@ TString SerializeToJson(TStringBuf binaryJson) {
 
     TStringStream output;
     TJsonWriter writer(&output, config);
-    ReadContainerToJson(reader->GetRootCursor(), writer);
+    ReadContainerToJson(cursor, writer);
     writer.Flush();
     return output.Str();
 }
 
+TString SerializeToJson(TStringBuf binaryJson) {
+    auto reader = TBinaryJsonReader::Make(binaryJson);
+    return SerializeToJson(reader->GetRootCursor());
+}
+
 namespace {
 
 struct TPODReader {
diff --git a/yql/essentials/types/binary_json/read.h b/yql/essentials/types/binary_json/read.h
index c9b2c1cbf0bb..a0fdf931bf1d 100644
--- a/yql/essentials/types/binary_json/read.h
+++ b/yql/essentials/types/binary_json/read.h
@@ -177,6 +177,8 @@ NUdf::TUnboxedValue ReadToJsonDom(TStringBuf binaryJson, const NUdf::IValueBuild
 /**
  * @brief Serializes whole BinaryJson into textual JSON
  */
+TString SerializeToJson(const TContainerCursor& cursor);
+
 TString SerializeToJson(const TBinaryJson& binaryJson);
 
 TString SerializeToJson(TStringBuf binaryJson);
