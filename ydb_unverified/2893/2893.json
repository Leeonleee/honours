{
  "repo": "ydb-platform/ydb",
  "pull_number": 2893,
  "instance_id": "ydb-platform__ydb-2893",
  "issue_numbers": [
    "2765"
  ],
  "base_commit": "59fa8b633ec5f5c66d88a18e36021c4a0e317d17",
  "patch": "diff --git a/library/cpp/monlib/encode/prometheus/prometheus_encoder.cpp b/library/cpp/monlib/encode/prometheus/prometheus_encoder.cpp\nindex f3015c48bc29..8083221b63d0 100644\n--- a/library/cpp/monlib/encode/prometheus/prometheus_encoder.cpp\n+++ b/library/cpp/monlib/encode/prometheus/prometheus_encoder.cpp\n@@ -370,9 +370,9 @@ namespace NMonitoring {\n                 }\n \n                 TMaybe<TLabel> nameLabel = MetricState_.Labels.Extract(MetricNameLabel_);\n-                Y_ENSURE(nameLabel,\n-                         \"labels \" << MetricState_.Labels <<\n-                         \" does not contain label '\" << MetricNameLabel_ << '\\'');\n+                if (!nameLabel) {\n+                    return;\n+                }\n \n                 const TString& metricName = ToString(nameLabel->Value());\n                 if (MetricState_.Type != EMetricType::DSUMMARY) {\ndiff --git a/ydb/apps/CMakeLists.txt b/ydb/apps/CMakeLists.txt\nindex e1c6d2181e21..08df7dd2187e 100644\n--- a/ydb/apps/CMakeLists.txt\n+++ b/ydb/apps/CMakeLists.txt\n@@ -7,5 +7,6 @@\n \n \n add_subdirectory(pgwire)\n+add_subdirectory(version)\n add_subdirectory(ydb)\n add_subdirectory(ydbd)\ndiff --git a/ydb/apps/version/CMakeLists.darwin-arm64.txt b/ydb/apps/version/CMakeLists.darwin-arm64.txt\nnew file mode 100644\nindex 000000000000..ce969ee15772\n--- /dev/null\n+++ b/ydb/apps/version/CMakeLists.darwin-arm64.txt\n@@ -0,0 +1,18 @@\n+\n+# This file was generated by the build system used internally in the Yandex monorepo.\n+# Only simple modifications are allowed (adding source-files to targets, adding simple properties\n+# like target_include_directories). These modifications will be ported to original\n+# ya.make files by maintainers. Any complex modifications which can't be ported back to the\n+# original buildsystem will not be accepted.\n+\n+\n+\n+add_library(version_definition)\n+target_link_libraries(version_definition PUBLIC\n+  contrib-libs-cxxsupp\n+  yutil\n+  version\n+)\n+target_sources(version_definition PRIVATE\n+  ${CMAKE_SOURCE_DIR}/ydb/apps/version/version_definition.cpp\n+)\ndiff --git a/ydb/apps/version/CMakeLists.darwin-x86_64.txt b/ydb/apps/version/CMakeLists.darwin-x86_64.txt\nnew file mode 100644\nindex 000000000000..ce969ee15772\n--- /dev/null\n+++ b/ydb/apps/version/CMakeLists.darwin-x86_64.txt\n@@ -0,0 +1,18 @@\n+\n+# This file was generated by the build system used internally in the Yandex monorepo.\n+# Only simple modifications are allowed (adding source-files to targets, adding simple properties\n+# like target_include_directories). These modifications will be ported to original\n+# ya.make files by maintainers. Any complex modifications which can't be ported back to the\n+# original buildsystem will not be accepted.\n+\n+\n+\n+add_library(version_definition)\n+target_link_libraries(version_definition PUBLIC\n+  contrib-libs-cxxsupp\n+  yutil\n+  version\n+)\n+target_sources(version_definition PRIVATE\n+  ${CMAKE_SOURCE_DIR}/ydb/apps/version/version_definition.cpp\n+)\ndiff --git a/ydb/apps/version/CMakeLists.linux-aarch64.txt b/ydb/apps/version/CMakeLists.linux-aarch64.txt\nnew file mode 100644\nindex 000000000000..bca854e1db0f\n--- /dev/null\n+++ b/ydb/apps/version/CMakeLists.linux-aarch64.txt\n@@ -0,0 +1,19 @@\n+\n+# This file was generated by the build system used internally in the Yandex monorepo.\n+# Only simple modifications are allowed (adding source-files to targets, adding simple properties\n+# like target_include_directories). These modifications will be ported to original\n+# ya.make files by maintainers. Any complex modifications which can't be ported back to the\n+# original buildsystem will not be accepted.\n+\n+\n+\n+add_library(version_definition)\n+target_link_libraries(version_definition PUBLIC\n+  contrib-libs-linux-headers\n+  contrib-libs-cxxsupp\n+  yutil\n+  version\n+)\n+target_sources(version_definition PRIVATE\n+  ${CMAKE_SOURCE_DIR}/ydb/apps/version/version_definition.cpp\n+)\ndiff --git a/ydb/apps/version/CMakeLists.linux-x86_64.txt b/ydb/apps/version/CMakeLists.linux-x86_64.txt\nnew file mode 100644\nindex 000000000000..bca854e1db0f\n--- /dev/null\n+++ b/ydb/apps/version/CMakeLists.linux-x86_64.txt\n@@ -0,0 +1,19 @@\n+\n+# This file was generated by the build system used internally in the Yandex monorepo.\n+# Only simple modifications are allowed (adding source-files to targets, adding simple properties\n+# like target_include_directories). These modifications will be ported to original\n+# ya.make files by maintainers. Any complex modifications which can't be ported back to the\n+# original buildsystem will not be accepted.\n+\n+\n+\n+add_library(version_definition)\n+target_link_libraries(version_definition PUBLIC\n+  contrib-libs-linux-headers\n+  contrib-libs-cxxsupp\n+  yutil\n+  version\n+)\n+target_sources(version_definition PRIVATE\n+  ${CMAKE_SOURCE_DIR}/ydb/apps/version/version_definition.cpp\n+)\ndiff --git a/ydb/apps/version/CMakeLists.txt b/ydb/apps/version/CMakeLists.txt\nnew file mode 100644\nindex 000000000000..d863ebd18067\n--- /dev/null\n+++ b/ydb/apps/version/CMakeLists.txt\n@@ -0,0 +1,19 @@\n+\n+# This file was generated by the build system used internally in the Yandex monorepo.\n+# Only simple modifications are allowed (adding source-files to targets, adding simple properties\n+# like target_include_directories). These modifications will be ported to original\n+# ya.make files by maintainers. Any complex modifications which can't be ported back to the\n+# original buildsystem will not be accepted.\n+\n+\n+if (CMAKE_SYSTEM_NAME STREQUAL \"Linux\" AND CMAKE_SYSTEM_PROCESSOR STREQUAL \"x86_64\" AND NOT HAVE_CUDA)\n+  include(CMakeLists.linux-x86_64.txt)\n+elseif (CMAKE_SYSTEM_NAME STREQUAL \"Linux\" AND CMAKE_SYSTEM_PROCESSOR STREQUAL \"aarch64\" AND NOT HAVE_CUDA)\n+  include(CMakeLists.linux-aarch64.txt)\n+elseif (CMAKE_SYSTEM_NAME STREQUAL \"Darwin\" AND CMAKE_SYSTEM_PROCESSOR STREQUAL \"x86_64\")\n+  include(CMakeLists.darwin-x86_64.txt)\n+elseif (CMAKE_SYSTEM_NAME STREQUAL \"Darwin\" AND CMAKE_SYSTEM_PROCESSOR STREQUAL \"arm64\")\n+  include(CMakeLists.darwin-arm64.txt)\n+elseif (WIN32 AND CMAKE_SYSTEM_PROCESSOR STREQUAL \"AMD64\" AND NOT HAVE_CUDA)\n+  include(CMakeLists.windows-x86_64.txt)\n+endif()\ndiff --git a/ydb/apps/version/CMakeLists.windows-x86_64.txt b/ydb/apps/version/CMakeLists.windows-x86_64.txt\nnew file mode 100644\nindex 000000000000..ce969ee15772\n--- /dev/null\n+++ b/ydb/apps/version/CMakeLists.windows-x86_64.txt\n@@ -0,0 +1,18 @@\n+\n+# This file was generated by the build system used internally in the Yandex monorepo.\n+# Only simple modifications are allowed (adding source-files to targets, adding simple properties\n+# like target_include_directories). These modifications will be ported to original\n+# ya.make files by maintainers. Any complex modifications which can't be ported back to the\n+# original buildsystem will not be accepted.\n+\n+\n+\n+add_library(version_definition)\n+target_link_libraries(version_definition PUBLIC\n+  contrib-libs-cxxsupp\n+  yutil\n+  version\n+)\n+target_sources(version_definition PRIVATE\n+  ${CMAKE_SOURCE_DIR}/ydb/apps/version/version_definition.cpp\n+)\ndiff --git a/ydb/apps/version/version_definition.cpp b/ydb/apps/version/version_definition.cpp\nnew file mode 100644\nindex 000000000000..6f71ec44e6d4\n--- /dev/null\n+++ b/ydb/apps/version/version_definition.cpp\n@@ -0,0 +1,38 @@\n+#include <ydb/core/driver_lib/version/version.h>\n+\n+NKikimrConfig::TCurrentCompatibilityInfo NKikimr::TCompatibilityInfo::MakeCurrent() {\n+    using TCurrentConstructor = NKikimr::TCompatibilityInfo::TProtoConstructor::TCurrentCompatibilityInfo;\n+    using TVersionConstructor = NKikimr::TCompatibilityInfo::TProtoConstructor::TVersion;\n+    using TCompatibilityRuleConstructor = NKikimr::TCompatibilityInfo::TProtoConstructor::TCompatibilityRule;\n+\n+    return TCurrentConstructor{\n+        .Application = \"ydb\",\n+        .Version = TVersionConstructor{\n+            .Year = 24,\n+            .Major = 1,\n+        },\n+        .CanLoadFrom = {\n+            TCompatibilityRuleConstructor{\n+                .LowerLimit = TVersionConstructor{ .Year = 23, .Major = 4 },\n+                .UpperLimit = TVersionConstructor{ .Year = 24, .Major = 1 },\n+            },\n+        },\n+        .StoresReadableBy = {\n+            TCompatibilityRuleConstructor{\n+                .LowerLimit = TVersionConstructor{ .Year = 23, .Major = 4 },\n+                .UpperLimit = TVersionConstructor{ .Year = 24, .Major = 1 },\n+            },\n+        },\n+        .CanConnectTo = {\n+            TCompatibilityRuleConstructor{\n+                .LowerLimit = TVersionConstructor{ .Year = 23, .Major = 4 },\n+                .UpperLimit = TVersionConstructor{ .Year = 24, .Major = 1 },\n+            },\n+            TCompatibilityRuleConstructor{\n+                .Application = \"nbs\",\n+                .LowerLimit = TVersionConstructor{ .Year = 23, .Major = 3 },\n+                .UpperLimit = TVersionConstructor{ .Year = 24, .Major = 1 },\n+            },\n+        }\n+    }.ToPB();\n+}\ndiff --git a/ydb/apps/version/ya.make b/ydb/apps/version/ya.make\nnew file mode 100644\nindex 000000000000..d3b1eb34a7f1\n--- /dev/null\n+++ b/ydb/apps/version/ya.make\n@@ -0,0 +1,11 @@\n+LIBRARY(version_definition)\n+\n+SRCS(\n+    version_definition.cpp\n+)\n+\n+PEERDIR(\n+    ydb/core/driver_lib/version\n+)\n+\n+END()\ndiff --git a/ydb/apps/ydbd/CMakeLists.darwin-arm64.txt b/ydb/apps/ydbd/CMakeLists.darwin-arm64.txt\nindex 55cb758927dd..e9139a985617 100644\n--- a/ydb/apps/ydbd/CMakeLists.darwin-arm64.txt\n+++ b/ydb/apps/ydbd/CMakeLists.darwin-arm64.txt\n@@ -14,6 +14,7 @@ target_compile_options(ydbd PRIVATE\n target_link_libraries(ydbd PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n+  version_definition\n   run\n   ydb-core-protos\n   ydb-core-security\ndiff --git a/ydb/apps/ydbd/CMakeLists.darwin-x86_64.txt b/ydb/apps/ydbd/CMakeLists.darwin-x86_64.txt\nindex c14caccd9816..1d6341727d76 100644\n--- a/ydb/apps/ydbd/CMakeLists.darwin-x86_64.txt\n+++ b/ydb/apps/ydbd/CMakeLists.darwin-x86_64.txt\n@@ -16,6 +16,7 @@ target_link_libraries(ydbd PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   udfs-common-hyperscan\n+  version_definition\n   run\n   ydb-core-protos\n   ydb-core-security\ndiff --git a/ydb/apps/ydbd/CMakeLists.linux-aarch64.txt b/ydb/apps/ydbd/CMakeLists.linux-aarch64.txt\nindex 39d8a56655d5..1cecfe06897d 100644\n--- a/ydb/apps/ydbd/CMakeLists.linux-aarch64.txt\n+++ b/ydb/apps/ydbd/CMakeLists.linux-aarch64.txt\n@@ -15,6 +15,7 @@ target_link_libraries(ydbd PUBLIC\n   contrib-libs-linux-headers\n   contrib-libs-cxxsupp\n   yutil\n+  version_definition\n   run\n   ydb-core-protos\n   ydb-core-security\ndiff --git a/ydb/apps/ydbd/CMakeLists.linux-x86_64.txt b/ydb/apps/ydbd/CMakeLists.linux-x86_64.txt\nindex c1e2d6955ed2..dd34e31acbb1 100644\n--- a/ydb/apps/ydbd/CMakeLists.linux-x86_64.txt\n+++ b/ydb/apps/ydbd/CMakeLists.linux-x86_64.txt\n@@ -17,6 +17,7 @@ target_link_libraries(ydbd PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   hyperscan_udf\n+  version_definition\n   run\n   ydb-core-protos\n   ydb-core-security\ndiff --git a/ydb/apps/ydbd/CMakeLists.windows-x86_64.txt b/ydb/apps/ydbd/CMakeLists.windows-x86_64.txt\nindex 92044a6688cf..2e7334f4eb8f 100644\n--- a/ydb/apps/ydbd/CMakeLists.windows-x86_64.txt\n+++ b/ydb/apps/ydbd/CMakeLists.windows-x86_64.txt\n@@ -17,6 +17,7 @@ target_link_libraries(ydbd PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   udfs-common-hyperscan\n+  version_definition\n   run\n   ydb-core-protos\n   ydb-core-security\ndiff --git a/ydb/apps/ydbd/ya.make b/ydb/apps/ydbd/ya.make\nindex 4f15c464fba0..e4176a682398 100644\n--- a/ydb/apps/ydbd/ya.make\n+++ b/ydb/apps/ydbd/ya.make\n@@ -35,6 +35,7 @@ IF (ARCH_X86_64)\n ENDIF()\n \n PEERDIR(\n+    ydb/apps/version\n     ydb/core/driver_lib/run\n     ydb/core/protos\n     ydb/core/security\ndiff --git a/ydb/core/actorlib_impl/ut/CMakeLists.darwin-arm64.txt b/ydb/core/actorlib_impl/ut/CMakeLists.darwin-arm64.txt\nindex b23f1701861d..8cf38ba69fb3 100644\n--- a/ydb/core/actorlib_impl/ut/CMakeLists.darwin-arm64.txt\n+++ b/ydb/core/actorlib_impl/ut/CMakeLists.darwin-arm64.txt\n@@ -19,6 +19,7 @@ target_link_libraries(ydb-core-actorlib_impl-ut PUBLIC\n   yutil\n   cpp-testing-unittest_main\n   ydb-core-actorlib_impl\n+  version_definition\n   library-actors-core\n   library-actors-interconnect\n   library-cpp-getopt\ndiff --git a/ydb/core/actorlib_impl/ut/CMakeLists.darwin-x86_64.txt b/ydb/core/actorlib_impl/ut/CMakeLists.darwin-x86_64.txt\nindex 97b02c598742..089fb719b212 100644\n--- a/ydb/core/actorlib_impl/ut/CMakeLists.darwin-x86_64.txt\n+++ b/ydb/core/actorlib_impl/ut/CMakeLists.darwin-x86_64.txt\n@@ -20,6 +20,7 @@ target_link_libraries(ydb-core-actorlib_impl-ut PUBLIC\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n   ydb-core-actorlib_impl\n+  version_definition\n   library-actors-core\n   library-actors-interconnect\n   library-cpp-getopt\ndiff --git a/ydb/core/actorlib_impl/ut/CMakeLists.linux-aarch64.txt b/ydb/core/actorlib_impl/ut/CMakeLists.linux-aarch64.txt\nindex 8884fae6ef3e..5b399007a656 100644\n--- a/ydb/core/actorlib_impl/ut/CMakeLists.linux-aarch64.txt\n+++ b/ydb/core/actorlib_impl/ut/CMakeLists.linux-aarch64.txt\n@@ -20,6 +20,7 @@ target_link_libraries(ydb-core-actorlib_impl-ut PUBLIC\n   yutil\n   cpp-testing-unittest_main\n   ydb-core-actorlib_impl\n+  version_definition\n   library-actors-core\n   library-actors-interconnect\n   library-cpp-getopt\ndiff --git a/ydb/core/actorlib_impl/ut/CMakeLists.linux-x86_64.txt b/ydb/core/actorlib_impl/ut/CMakeLists.linux-x86_64.txt\nindex cc8f189feba3..cec69ce080fd 100644\n--- a/ydb/core/actorlib_impl/ut/CMakeLists.linux-x86_64.txt\n+++ b/ydb/core/actorlib_impl/ut/CMakeLists.linux-x86_64.txt\n@@ -21,6 +21,7 @@ target_link_libraries(ydb-core-actorlib_impl-ut PUBLIC\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n   ydb-core-actorlib_impl\n+  version_definition\n   library-actors-core\n   library-actors-interconnect\n   library-cpp-getopt\ndiff --git a/ydb/core/actorlib_impl/ut/CMakeLists.windows-x86_64.txt b/ydb/core/actorlib_impl/ut/CMakeLists.windows-x86_64.txt\nindex cc5c27df7c96..dfcd699fb474 100644\n--- a/ydb/core/actorlib_impl/ut/CMakeLists.windows-x86_64.txt\n+++ b/ydb/core/actorlib_impl/ut/CMakeLists.windows-x86_64.txt\n@@ -20,6 +20,7 @@ target_link_libraries(ydb-core-actorlib_impl-ut PUBLIC\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n   ydb-core-actorlib_impl\n+  version_definition\n   library-actors-core\n   library-actors-interconnect\n   library-cpp-getopt\ndiff --git a/ydb/core/actorlib_impl/ut/ya.make b/ydb/core/actorlib_impl/ut/ya.make\nindex 0a89b3e4b6e9..d4f2a0bb1540 100644\n--- a/ydb/core/actorlib_impl/ut/ya.make\n+++ b/ydb/core/actorlib_impl/ut/ya.make\n@@ -13,6 +13,7 @@ ELSE()\n ENDIF()\n \n PEERDIR(\n+    ydb/apps/version\n     ydb/library/actors/core\n     ydb/library/actors/interconnect\n     library/cpp/getopt\ndiff --git a/ydb/core/blobstorage/dsproxy/dsproxy_blackboard.cpp b/ydb/core/blobstorage/dsproxy/dsproxy_blackboard.cpp\nindex 97706a1b6f13..6df5e4ce8698 100644\n--- a/ydb/core/blobstorage/dsproxy/dsproxy_blackboard.cpp\n+++ b/ydb/core/blobstorage/dsproxy/dsproxy_blackboard.cpp\n@@ -48,12 +48,6 @@ void TBlobState::AddPartToPut(ui32 partIdx, TRope&& partData) {\n     IsChanged = true;\n }\n \n-void TBlobState::MarkBlobReadyToPut(ui8 blobIdx) {\n-    Y_ABORT_UNLESS(WholeSituation == ESituation::Unknown || WholeSituation == ESituation::Present);\n-    BlobIdx = blobIdx;\n-    IsChanged = true;\n-}\n-\n bool TBlobState::Restore(const TBlobStorageGroupInfo &info) {\n     const TIntervalVec<i32> fullBlobInterval(0, Id.BlobSize());\n     const TIntervalSet<i32> here = Whole.Here();\n@@ -227,7 +221,7 @@ TString TBlobState::ToString() const {\n     for (ui32 i = 0; i < Disks.size(); ++i) {\n         str << Endl << \" Disks[\" << i << \"]# \" << Disks[i].ToString() << Endl;\n     }\n-    str << \" BlobIdx# \" << (ui32)BlobIdx << Endl;\n+    str << \" BlobIdx# \" << BlobIdx << Endl;\n     str << \"}\";\n     return str.Str();\n }\n@@ -304,7 +298,7 @@ void TGroupDiskRequests::AddGet(ui32 diskOrderNumber, const TLogoBlobID &id, ui3\n }\n \n void TGroupDiskRequests::AddPut(ui32 diskOrderNumber, const TLogoBlobID &id, TRope buffer,\n-        TDiskPutRequest::EPutReason putReason, bool isHandoff, ui8 blobIdx) {\n+        TDiskPutRequest::EPutReason putReason, bool isHandoff, size_t blobIdx) {\n     PutsPending.emplace_back(diskOrderNumber, id, buffer, putReason, isHandoff, blobIdx);\n }\n \n@@ -340,20 +334,6 @@ void TBlackboard::AddPartToPut(const TLogoBlobID &id, ui32 partIdx, TRope&& part\n     (*this)[id].AddPartToPut(partIdx, std::move(partData));\n }\n \n-void TBlackboard::MarkBlobReadyToPut(const TLogoBlobID &id, ui8 blobIdx) {\n-    Y_ABORT_UNLESS(bool(id));\n-    Y_ABORT_UNLESS(id.PartId() == 0);\n-    Y_ABORT_UNLESS(id.BlobSize() != 0);\n-    (*this)[id].MarkBlobReadyToPut(blobIdx);\n-}\n-\n-void TBlackboard::MoveBlobStateToDone(const TLogoBlobID &id) {\n-    Y_ABORT_UNLESS(bool(id));\n-    Y_ABORT_UNLESS(id.PartId() == 0);\n-    Y_ABORT_UNLESS(id.BlobSize() != 0);\n-    DoneBlobStates.insert(BlobStates.extract(id));\n-}\n-\n void TBlackboard::AddPutOkResponse(const TLogoBlobID &id, ui32 orderNumber) {\n     Y_ABORT_UNLESS(bool(id));\n     Y_ABORT_UNLESS(id.PartId() != 0);\n@@ -390,8 +370,7 @@ void TBlackboard::AddErrorResponse(const TLogoBlobID &id, ui32 orderNumber) {\n }\n \n EStrategyOutcome TBlackboard::RunStrategies(TLogContext &logCtx, const TStackVec<IStrategy*, 1>& s,\n-        TBatchedVec<TBlobStates::value_type*> *finished, const TBlobStorageGroupInfo::TGroupVDisks *expired) {\n-    TString errorReason;\n+        TBatchedVec<TFinishedBlob> *finished, const TBlobStorageGroupInfo::TGroupVDisks *expired) {\n     for (auto it = BlobStates.begin(); it != BlobStates.end(); ) {\n         auto& blob = it->second;\n         if (!std::exchange(blob.IsChanged, false)) {\n@@ -401,6 +380,7 @@ EStrategyOutcome TBlackboard::RunStrategies(TLogContext &logCtx, const TStackVec\n \n         // recalculate blob outcome if it is not yet determined\n         NKikimrProto::EReplyStatus status = NKikimrProto::OK;\n+        TString errorReason;\n         for (IStrategy *strategy : s) {\n             switch (auto res = strategy->Process(logCtx, blob, *Info, *this, GroupDiskRequests)) {\n                 case EStrategyOutcome::IN_PROGRESS:\n@@ -408,16 +388,11 @@ EStrategyOutcome TBlackboard::RunStrategies(TLogContext &logCtx, const TStackVec\n                     break;\n \n                 case EStrategyOutcome::ERROR:\n-                    if (IsAllRequestsTogether) {\n+                    if (!finished) {\n                         return res;\n                     }\n-                    if (errorReason) {\n-                        errorReason += \" && \";\n-                        errorReason += res.ErrorReason;\n-                    } else {\n-                        errorReason = res.ErrorReason;\n-                    }\n                     status = NKikimrProto::ERROR;\n+                    errorReason = std::move(res.ErrorReason);\n                     break;\n \n                 case EStrategyOutcome::DONE:\n@@ -431,26 +406,25 @@ EStrategyOutcome TBlackboard::RunStrategies(TLogContext &logCtx, const TStackVec\n             status = NKikimrProto::UNKNOWN;\n         }\n         if (status != NKikimrProto::UNKNOWN) {\n+            if (finished) { // we are operating on independent blobs\n+                finished->push_back(TFinishedBlob{\n+                    blob.BlobIdx,\n+                    status,\n+                    std::move(errorReason),\n+                });\n+            }\n             const auto [doneIt, inserted, node] = DoneBlobStates.insert(BlobStates.extract(it++));\n             Y_ABORT_UNLESS(inserted);\n-            if (!IsAllRequestsTogether) {\n-                blob.Status = status;\n-                if (finished) {\n-                    finished->push_back(&*doneIt);\n-                }\n-            }\n         } else {\n             ++it;\n         }\n     }\n \n-    EStrategyOutcome outcome(BlobStates.empty() ? EStrategyOutcome::DONE : EStrategyOutcome::IN_PROGRESS);\n-    outcome.ErrorReason = std::move(errorReason);\n-    return outcome;\n+    return BlobStates.empty() ? EStrategyOutcome::DONE : EStrategyOutcome::IN_PROGRESS;\n }\n \n EStrategyOutcome TBlackboard::RunStrategy(TLogContext &logCtx, const IStrategy& s,\n-        TBatchedVec<TBlobStates::value_type*> *finished, const TBlobStorageGroupInfo::TGroupVDisks *expired) {\n+        TBatchedVec<TFinishedBlob> *finished, const TBlobStorageGroupInfo::TGroupVDisks *expired) {\n     return RunStrategies(logCtx, {const_cast<IStrategy*>(&s)}, finished, expired);\n }\n \n@@ -464,8 +438,7 @@ TBlobState& TBlackboard::GetState(const TLogoBlobID &id) {\n                 << \" blobId# \" << fullId\n                 << \" BlackBoard# \" << ToString());\n     }\n-    TBlobState &state = it->second;\n-    return state;\n+    return it->second;\n }\n \n ssize_t TBlackboard::AddPartMap(const TLogoBlobID &id, ui32 diskOrderNumber, ui32 requestIndex) {\n@@ -512,8 +485,12 @@ void TBlackboard::GetWorstPredictedDelaysNs(const TBlobStorageGroupInfo &info, T\n     }\n }\n \n-void TBlackboard::RegisterBlobForPut(const TLogoBlobID& id) {\n-    (*this)[id];\n+void TBlackboard::RegisterBlobForPut(const TLogoBlobID& id, size_t blobIdx) {\n+    const auto [it, inserted] = BlobStates.try_emplace(id);\n+    Y_ABORT_UNLESS(inserted);\n+    TBlobState& state = it->second;\n+    state.Init(id, *Info);\n+    state.BlobIdx = blobIdx;\n }\n \n TBlobState& TBlackboard::operator [](const TLogoBlobID& id) {\n@@ -559,9 +536,7 @@ void TBlackboard::InvalidatePartStates(ui32 orderNumber) {\n     const TVDiskID vdiskId = Info->GetVDiskId(orderNumber);\n     for (auto& [id, state] : BlobStates) {\n         if (const ui32 diskIdx = Info->GetIdxInSubgroup(vdiskId, id.Hash()); diskIdx != Info->Type.BlobSubgroupSize()) {\n-            TBlobState::TDisk& disk = state.Disks[diskIdx];\n-            for (ui32 partIdx = 0; partIdx < disk.DiskParts.size(); ++partIdx) {\n-                TBlobState::TDiskPart& part = disk.DiskParts[partIdx];\n+            for (TBlobState::TDiskPart& part : state.Disks[diskIdx].DiskParts) {\n                 if (part.Situation == TBlobState::ESituation::Present) {\n                     part.Situation = TBlobState::ESituation::Unknown;\n                     if (state.WholeSituation == TBlobState::ESituation::Present) {\ndiff --git a/ydb/core/blobstorage/dsproxy/dsproxy_blackboard.h b/ydb/core/blobstorage/dsproxy/dsproxy_blackboard.h\nindex c128a013e507..84dc4780c9a5 100644\n--- a/ydb/core/blobstorage/dsproxy/dsproxy_blackboard.h\n+++ b/ydb/core/blobstorage/dsproxy/dsproxy_blackboard.h\n@@ -81,14 +81,12 @@ struct TBlobState {\n     TStackVec<TState, TypicalPartsInBlob> Parts;\n     TStackVec<TDisk, TypicalDisksInSubring> Disks;\n     TVector<TEvBlobStorage::TEvGetResult::TPartMapItem> PartMap;\n-    NKikimrProto::EReplyStatus Status = NKikimrProto::UNKNOWN;\n-    ui8 BlobIdx;\n+    size_t BlobIdx;\n     bool IsChanged = false;\n \n     void Init(const TLogoBlobID &id, const TBlobStorageGroupInfo &Info);\n     void AddNeeded(ui64 begin, ui64 size);\n     void AddPartToPut(ui32 partIdx, TRope&& partData);\n-    void MarkBlobReadyToPut(ui8 blobIdx = 0);\n     bool Restore(const TBlobStorageGroupInfo &info);\n     void AddResponseData(const TBlobStorageGroupInfo &info, const TLogoBlobID &id, ui32 diskIdxInSubring,\n             ui32 shift, TRope&& data);\n@@ -133,9 +131,9 @@ struct TDiskPutRequest {\n     TRope Buffer;\n     EPutReason Reason;\n     bool IsHandoff;\n-    ui8 BlobIdx;\n+    size_t BlobIdx;\n \n-    TDiskPutRequest(ui32 orderNumber, const TLogoBlobID &id, TRope buffer, EPutReason reason, bool isHandoff, ui8 blobIdx)\n+    TDiskPutRequest(ui32 orderNumber, const TLogoBlobID &id, TRope buffer, EPutReason reason, bool isHandoff, size_t blobIdx)\n         : OrderNumber(orderNumber)\n         , Id(id)\n         , Buffer(std::move(buffer))\n@@ -152,7 +150,7 @@ struct TGroupDiskRequests {\n     void AddGet(ui32 diskOrderNumber, const TLogoBlobID &id, const TIntervalSet<i32> &intervalSet);\n     void AddGet(ui32 diskOrderNumber, const TLogoBlobID &id, ui32 shift, ui32 size);\n     void AddPut(ui32 diskOrderNumber, const TLogoBlobID &id, TRope buffer,\n-        TDiskPutRequest::EPutReason putReason, bool isHandoff, ui8 blobIdx);\n+        TDiskPutRequest::EPutReason putReason, bool isHandoff, size_t blobIdx);\n };\n \n struct TBlackboard;\n@@ -170,6 +168,12 @@ struct TBlackboard {\n         AccelerationModeSkipMarked\n     };\n \n+    struct TFinishedBlob {\n+        size_t BlobIdx;\n+        NKikimrProto::EReplyStatus Status;\n+        TString ErrorReason;\n+    };\n+\n     using TBlobStates = TMap<TLogoBlobID, TBlobState>;\n     TBlobStates BlobStates;\n     TBlobStates DoneBlobStates;\n@@ -179,31 +183,27 @@ struct TBlackboard {\n     EAccelerationMode AccelerationMode;\n     const NKikimrBlobStorage::EPutHandleClass PutHandleClass;\n     const NKikimrBlobStorage::EGetHandleClass GetHandleClass;\n-    const bool IsAllRequestsTogether;\n \n     TBlackboard(const TIntrusivePtr<TBlobStorageGroupInfo> &info, const TIntrusivePtr<TGroupQueues> &groupQueues,\n-            NKikimrBlobStorage::EPutHandleClass putHandleClass, NKikimrBlobStorage::EGetHandleClass getHandleClass,\n-            bool isAllRequestsTogether = true)\n+            NKikimrBlobStorage::EPutHandleClass putHandleClass, NKikimrBlobStorage::EGetHandleClass getHandleClass)\n         : Info(info)\n         , GroupQueues(groupQueues)\n         , AccelerationMode(AccelerationModeSkipOneSlowest)\n         , PutHandleClass(putHandleClass)\n         , GetHandleClass(getHandleClass)\n-        , IsAllRequestsTogether(isAllRequestsTogether)\n     {}\n \n     void AddNeeded(const TLogoBlobID &id, ui32 inShift, ui32 inSize);\n     void AddPartToPut(const TLogoBlobID &id, ui32 partIdx, TRope&& partData);\n-    void MarkBlobReadyToPut(const TLogoBlobID &id, ui8 blobIdx = 0);\n-    void MoveBlobStateToDone(const TLogoBlobID &id);\n     void AddResponseData(const TLogoBlobID &id, ui32 orderNumber, ui32 shift, TRope&& data);\n     void AddPutOkResponse(const TLogoBlobID &id, ui32 orderNumber);\n     void AddNoDataResponse(const TLogoBlobID &id, ui32 orderNumber);\n     void AddErrorResponse(const TLogoBlobID &id, ui32 orderNumber);\n     void AddNotYetResponse(const TLogoBlobID &id, ui32 orderNumber);\n+\n     EStrategyOutcome RunStrategies(TLogContext& logCtx, const TStackVec<IStrategy*, 1>& strategies,\n-        TBatchedVec<TBlobStates::value_type*> *finished = nullptr, const TBlobStorageGroupInfo::TGroupVDisks *expired = nullptr);\n-    EStrategyOutcome RunStrategy(TLogContext &logCtx, const IStrategy& s, TBatchedVec<TBlobStates::value_type*> *finished = nullptr,\n+        TBatchedVec<TFinishedBlob> *finished = nullptr, const TBlobStorageGroupInfo::TGroupVDisks *expired = nullptr);\n+    EStrategyOutcome RunStrategy(TLogContext &logCtx, const IStrategy& s, TBatchedVec<TFinishedBlob> *finished = nullptr,\n             const TBlobStorageGroupInfo::TGroupVDisks *expired = nullptr);\n     TBlobState& GetState(const TLogoBlobID &id);\n     ssize_t AddPartMap(const TLogoBlobID &id, ui32 diskOrderNumber, ui32 requestIndex);\n@@ -221,7 +221,7 @@ struct TBlackboard {\n \n     void InvalidatePartStates(ui32 orderNumber);\n \n-    void RegisterBlobForPut(const TLogoBlobID& id);\n+    void RegisterBlobForPut(const TLogoBlobID& id, size_t blobIdx);\n \n     TBlobState& operator [](const TLogoBlobID& id);\n };\ndiff --git a/ydb/core/blobstorage/dsproxy/dsproxy_put.cpp b/ydb/core/blobstorage/dsproxy/dsproxy_put.cpp\nindex a092e45872a7..4f815af5a8d9 100644\n--- a/ydb/core/blobstorage/dsproxy/dsproxy_put.cpp\n+++ b/ydb/core/blobstorage/dsproxy/dsproxy_put.cpp\n@@ -103,11 +103,11 @@ class TBlobStorageGroupPutRequest : public TBlobStorageGroupRequestActor<TBlobSt\n         SanityCheck(); // May Die\n     }\n \n-    bool Action() {\n+    bool Action(bool accelerate = false) {\n         UpdateExpiredVDiskSet();\n \n         TPutImpl::TPutResultVec putResults;\n-        PutImpl.Step(LogCtx, putResults, ExpiredVDiskSet);\n+        PutImpl.Step(LogCtx, putResults, ExpiredVDiskSet, accelerate);\n         if (ReplyAndDieWithLastResponse(putResults)) {\n             return true;\n         }\n@@ -133,9 +133,7 @@ class TBlobStorageGroupPutRequest : public TBlobStorageGroupRequestActor<TBlobSt\n             return;\n         }\n         IsAccelerated = true;\n-\n-        PutImpl.Accelerate(LogCtx);\n-        Action();\n+        Action(true);\n //        *(IsMultiPutMode ? Mon->NodeMon->AccelerateEvVMultiPutCount : Mon->NodeMon->AccelerateEvVPutCount) += v.size();\n     }\n \n@@ -210,9 +208,7 @@ class TBlobStorageGroupPutRequest : public TBlobStorageGroupRequestActor<TBlobSt\n             HandleIncarnation(issue, orderNumber, record.GetIncarnationGuid());\n         }\n \n-        if (Action()) {\n-            return;\n-        }\n+        Action();\n     }\n \n     void Handle(TEvBlobStorage::TEvVPutResult::TPtr &ev) {\n@@ -265,7 +261,7 @@ class TBlobStorageGroupPutRequest : public TBlobStorageGroupRequestActor<TBlobSt\n         if (status == NKikimrProto::BLOCKED || status == NKikimrProto::DEADLINE) {\n             TString error = TStringBuilder() << \"Got VPutResult status# \" << status << \" from VDiskId# \" << vdiskId;\n             TPutImpl::TPutResultVec putResults;\n-            PutImpl.PrepareOneReply(status, blobId.FullID(), blobIdx, LogCtx, std::move(error), putResults);\n+            PutImpl.PrepareOneReply(status, blobIdx, LogCtx, std::move(error), putResults);\n             ReplyAndDieWithLastResponse(putResults);\n         } else {\n             PutImpl.ProcessResponse(*ev->Get());\n@@ -351,7 +347,7 @@ class TBlobStorageGroupPutRequest : public TBlobStorageGroupRequestActor<TBlobSt\n             Y_ABORT_UNLESS(itemStatus != NKikimrProto::RACE); // we should get RACE for the whole request and handle it in CheckForTermErrors\n             if (itemStatus == NKikimrProto::BLOCKED || itemStatus == NKikimrProto::DEADLINE) {\n                 ErrorReason = TStringBuilder() << \"Got VMultiPutResult itemStatus# \" << itemStatus << \" from VDiskId# \" << vdiskId;\n-                PutImpl.PrepareOneReply(itemStatus, blobId.FullID(), blobIdx, LogCtx, ErrorReason, putResults);\n+                PutImpl.PrepareOneReply(itemStatus, blobIdx, LogCtx, ErrorReason, putResults);\n             }\n         }\n         if (ReplyAndDieWithLastResponse(putResults)) {\n@@ -405,7 +401,7 @@ class TBlobStorageGroupPutRequest : public TBlobStorageGroupRequestActor<TBlobSt\n         return false;\n     }\n \n-    void SendReply(std::unique_ptr<TEvBlobStorage::TEvPutResult> putResult, ui64 blobIdx) {\n+    void SendReply(std::unique_ptr<TEvBlobStorage::TEvPutResult> putResult, size_t blobIdx) {\n         NKikimrProto::EReplyStatus status = putResult->Status;\n         A_LOG_LOG_S(false, status == NKikimrProto::OK ? NLog::PRI_INFO : NLog::PRI_NOTICE, \"BPP21\",\n             \"SendReply putResult# \" << putResult->ToString() << \" ResponsesSent# \" << ResponsesSent\n@@ -449,7 +445,7 @@ class TBlobStorageGroupPutRequest : public TBlobStorageGroupRequestActor<TBlobSt\n     TString BlobIdSequenceToString() const {\n         TStringBuilder blobIdsStr;\n         blobIdsStr << '[';\n-        for (ui64 blobIdx = 0; blobIdx < PutImpl.Blobs.size(); ++blobIdx) {\n+        for (size_t blobIdx = 0; blobIdx < PutImpl.Blobs.size(); ++blobIdx) {\n             if (blobIdx) {\n                 blobIdsStr << ' ';\n             }\n@@ -603,7 +599,7 @@ class TBlobStorageGroupPutRequest : public TBlobStorageGroupRequestActor<TBlobSt\n \n         StartTime = TActivationContext::Monotonic();\n \n-        for (ui64 blobIdx = 0; blobIdx < PutImpl.Blobs.size(); ++blobIdx) {\n+        for (size_t blobIdx = 0; blobIdx < PutImpl.Blobs.size(); ++blobIdx) {\n             LWTRACK(DSProxyPutBootstrapStart, PutImpl.Blobs[blobIdx].Orbit);\n         }\n \n@@ -703,12 +699,11 @@ class TBlobStorageGroupPutRequest : public TBlobStorageGroupRequestActor<TBlobSt\n                     s << ' ';\n                 }\n                 s << i;\n-                auto& record = IncarnationRecords[i];\n-                s << '{';\n-                s << \"IncarnationGuid# \" << record.IncarnationGuid;\n-                s << \" ExpirationTimestamp# \" << record.ExpirationTimestamp;\n-                s << \" StatusIssueTimestamp# \" << record.StatusIssueTimestamp;\n-                s << '}';\n+                auto& r = IncarnationRecords[i];\n+                s << '{' << r.IncarnationGuid\n+                    << ' ' << (r.ExpirationTimestamp != TMonotonic::Max() ? TStringBuilder() << r.ExpirationTimestamp : \"-\"_sb)\n+                    << ' ' << (r.StatusIssueTimestamp != TMonotonic::Zero() ? TStringBuilder() << r.StatusIssueTimestamp : \"-\"_sb)\n+                    << '}';\n             }\n             s << '}';\n             return s.Str();\n@@ -735,7 +730,7 @@ class TBlobStorageGroupPutRequest : public TBlobStorageGroupRequestActor<TBlobSt\n     }\n \n     STATEFN(StateWait) {\n-        if (ProcessEvent(ev, IsManyPuts)) {\n+        if (ProcessEvent(ev, true)) {\n             return;\n         }\n         const ui32 type = ev->GetTypeRewrite();\ndiff --git a/ydb/core/blobstorage/dsproxy/dsproxy_put_impl.cpp b/ydb/core/blobstorage/dsproxy/dsproxy_put_impl.cpp\nindex 81f56bed5363..3049ab1a039b 100644\n--- a/ydb/core/blobstorage/dsproxy/dsproxy_put_impl.cpp\n+++ b/ydb/core/blobstorage/dsproxy/dsproxy_put_impl.cpp\n@@ -11,22 +11,44 @@ namespace NKikimr {\n \n using TPutResultVec = TPutImpl::TPutResultVec;\n \n-void TPutImpl::RunStrategies(TLogContext &logCtx, TPutResultVec &outPutResults, const TBlobStorageGroupInfo::TGroupVDisks& expired) {\n+void TPutImpl::RunStrategies(TLogContext &logCtx, TPutResultVec &outPutResults,\n+        const TBlobStorageGroupInfo::TGroupVDisks& expired, bool accelerate) {\n+    if (accelerate) {\n+        ChangeAll();\n+    }\n+\n     switch (Info->Type.GetErasure()) {\n         case TBlobStorageGroupType::ErasureMirror3dc:\n-            return RunStrategy(logCtx, TPut3dcStrategy(Tactic, EnableRequestMod3x3ForMinLatecy), outPutResults, expired);\n+            return accelerate\n+                ? RunStrategy(logCtx, TAcceleratePut3dcStrategy(Tactic, EnableRequestMod3x3ForMinLatecy), outPutResults, expired)\n+                : RunStrategy(logCtx, TPut3dcStrategy(Tactic, EnableRequestMod3x3ForMinLatecy), outPutResults, expired);\n         case TBlobStorageGroupType::ErasureMirror3of4:\n-            return RunStrategy(logCtx, TPut3of4Strategy(Tactic), outPutResults, expired);\n+            return accelerate\n+                ? RunStrategy(logCtx, TPut3of4Strategy(Tactic, true), outPutResults, expired)\n+                : RunStrategy(logCtx, TPut3of4Strategy(Tactic), outPutResults, expired);\n         default:\n-            return RunStrategy(logCtx, TRestoreStrategy(), outPutResults, expired);\n+            return accelerate\n+                ? RunStrategy(logCtx, TAcceleratePutStrategy(), outPutResults, expired)\n+                : RunStrategy(logCtx, TRestoreStrategy(), outPutResults, expired);\n     }\n }\n \n void TPutImpl::RunStrategy(TLogContext &logCtx, const IStrategy& strategy, TPutResultVec &outPutResults,\n         const TBlobStorageGroupInfo::TGroupVDisks& expired) {\n-    TBatchedVec<TBlackboard::TBlobStates::value_type*> finished;\n+    Y_VERIFY_S(Blackboard.BlobStates.size(), \"State# \" << DumpFullState());\n+    TBatchedVec<TBlackboard::TFinishedBlob> finished;\n     const EStrategyOutcome outcome = Blackboard.RunStrategy(logCtx, strategy, &finished, &expired);\n-    PrepareReply(logCtx, outcome.ErrorReason, finished, outPutResults);\n+    for (const TBlackboard::TFinishedBlob& item : finished) {\n+        Y_ABORT_UNLESS(item.BlobIdx < Blobs.size());\n+        Y_ABORT_UNLESS(!IsDone[item.BlobIdx]);\n+        PrepareOneReply(item.Status, item.BlobIdx, logCtx, item.ErrorReason, outPutResults);\n+        Y_VERIFY_S(IsDone[item.BlobIdx], \"State# \" << DumpFullState());\n+    }\n+    if (outcome == EStrategyOutcome::DONE) {\n+        for (const auto& done : IsDone) {\n+            Y_VERIFY_S(done, \"finished.size# \" << finished.size() << \" State# \" << DumpFullState());\n+        }\n+    }\n }\n \n NLog::EPriority GetPriorityForReply(TAtomicLogPriorityMuteChecker<NLog::PRI_ERROR, NLog::PRI_DEBUG> &checker,\n@@ -40,62 +62,23 @@ NLog::EPriority GetPriorityForReply(TAtomicLogPriorityMuteChecker<NLog::PRI_ERRO\n     }\n }\n \n-void TPutImpl::PrepareOneReply(NKikimrProto::EReplyStatus status, TLogoBlobID blobId, ui64 blobIdx, TLogContext &logCtx,\n+void TPutImpl::PrepareOneReply(NKikimrProto::EReplyStatus status, size_t blobIdx, TLogContext &logCtx,\n         TString errorReason, TPutResultVec &outPutResults) {\n-    Y_ABORT_UNLESS(IsInitialized);\n-    if (!IsDone[blobIdx]) {\n-        outPutResults.emplace_back(blobIdx, new TEvBlobStorage::TEvPutResult(status, blobId, StatusFlags, Info->GroupID,\n-                    ApproximateFreeSpaceShare));\n-        outPutResults.back().second->ErrorReason = errorReason;\n-        NLog::EPriority priority = GetPriorityForReply(Info->PutErrorMuteChecker, status);\n-        A_LOG_LOG_SX(logCtx, true, priority, \"BPP12\", \"Result# \" << outPutResults.back().second->Print(false));\n-        MarkBlobAsSent(blobIdx);\n+    if (!std::exchange(IsDone[blobIdx], true)) {\n+        auto ev = std::make_unique<TEvBlobStorage::TEvPutResult>(status, Blobs[blobIdx].BlobId, StatusFlags,\n+            Info->GroupID, ApproximateFreeSpaceShare);\n+        ev->ErrorReason = std::move(errorReason);\n+        const NLog::EPriority priority = GetPriorityForReply(Info->PutErrorMuteChecker, status);\n+        A_LOG_LOG_SX(logCtx, true, priority, \"BPP12\", \"Result# \" << ev->Print(false));\n+        outPutResults.emplace_back(blobIdx, std::move(ev));\n     }\n }\n \n void TPutImpl::PrepareReply(NKikimrProto::EReplyStatus status, TLogContext &logCtx, TString errorReason,\n         TPutResultVec &outPutResults) {\n     A_LOG_DEBUG_SX(logCtx, \"BPP34\", \"PrepareReply status# \" << status << \" errorReason# \" << errorReason);\n-    for (ui64 idx = 0; idx < Blobs.size(); ++idx) {\n-        if (IsDone[idx]) {\n-            A_LOG_DEBUG_SX(logCtx, \"BPP35\", \"blob# \" << Blobs[idx].ToString() <<\n-                \" idx# \" << idx << \" is sent, skipped\");\n-            continue;\n-        }\n-\n-        outPutResults.emplace_back(idx, new TEvBlobStorage::TEvPutResult(status, Blobs[idx].BlobId, StatusFlags,\n-            Info->GroupID, ApproximateFreeSpaceShare));\n-        outPutResults.back().second->ErrorReason = errorReason;\n-\n-        NLog::EPriority priority = GetPriorityForReply(Info->PutErrorMuteChecker, status);\n-        A_LOG_LOG_SX(logCtx, true, priority, \"BPP38\",\n-                \"PrepareReply Result# \" << outPutResults.back().second->Print(false));\n-\n-        if (IsInitialized) {\n-            MarkBlobAsSent(idx);\n-        }\n-    }\n-}\n-\n-void TPutImpl::PrepareReply(TLogContext &logCtx, TString errorReason,\n-        TBatchedVec<TBlackboard::TBlobStates::value_type*>& finished, TPutResultVec &outPutResults) {\n-    A_LOG_DEBUG_SX(logCtx, \"BPP36\", \"PrepareReply errorReason# \" << errorReason);\n-    Y_ABORT_UNLESS(IsInitialized);\n-    for (auto item : finished) {\n-        auto &[blobId, state] = *item;\n-        const ui64 idx = state.BlobIdx;\n-        Y_ABORT_UNLESS(blobId == Blobs[idx].BlobId, \"BlobIdx# %\" PRIu64 \" BlobState# %s Blackboard# %s\",\n-            idx, state.ToString().c_str(), Blackboard.ToString().c_str());\n-        Y_ABORT_UNLESS(!IsDone[idx]);\n-        Y_ABORT_UNLESS(state.Status != NKikimrProto::UNKNOWN);\n-        outPutResults.emplace_back(idx, new TEvBlobStorage::TEvPutResult(state.Status, blobId, StatusFlags,\n-            Info->GroupID, ApproximateFreeSpaceShare));\n-        outPutResults.back().second->ErrorReason = errorReason;\n-\n-        NLog::EPriority priority = GetPriorityForReply(Info->PutErrorMuteChecker, state.Status);\n-        A_LOG_LOG_SX(logCtx, true, priority, \"BPP37\",\n-                \"PrepareReply Result# \" << outPutResults.back().second->Print(false));\n-        MarkBlobAsSent(idx);\n+    for (size_t blobIdx = 0; blobIdx < Blobs.size(); ++blobIdx) {\n+        PrepareOneReply(status, blobIdx, logCtx, errorReason, outPutResults);\n     }\n }\n \n@@ -125,7 +108,7 @@ TString TPutImpl::DumpFullState() const {\n     str << Endl;\n     str << \" Blobs# \" << Blobs.ToString();\n     str << Endl;\n-    str << \"IsDone# \" << IsDone.ToString();\n+    str << \" IsDone# \" << IsDone.ToString();\n     str << Endl;\n     str << \" HandoffPartsSent# \" << HandoffPartsSent;\n     str << Endl;\n@@ -143,15 +126,6 @@ TString TPutImpl::DumpFullState() const {\n     return str.Str();\n }\n \n-bool TPutImpl::MarkBlobAsSent(ui64 idx) {\n-    Y_ABORT_UNLESS(idx < Blobs.size());\n-    Y_ABORT_UNLESS(!IsDone[idx]);\n-    Blackboard.MoveBlobStateToDone(Blobs[idx].BlobId);\n-    IsDone[idx] = true;\n-    DoneBlobs++;\n-    return true;\n-}\n-\n }//NKikimr\n \n Y_DECLARE_OUT_SPEC(, NKikimr::TPutImpl::TBlobInfo, stream, value) {\ndiff --git a/ydb/core/blobstorage/dsproxy/dsproxy_put_impl.h b/ydb/core/blobstorage/dsproxy/dsproxy_put_impl.h\nindex 5c499eda22ab..b15b864837aa 100644\n--- a/ydb/core/blobstorage/dsproxy/dsproxy_put_impl.h\n+++ b/ydb/core/blobstorage/dsproxy/dsproxy_put_impl.h\n@@ -43,8 +43,6 @@ class TPutImpl {\n     bool AtLeastOneResponseWasNotOk = false;\n     bool EnableRequestMod3x3ForMinLatecy = false;\n \n-    ui64 DoneBlobs = 0;\n-\n     const TEvBlobStorage::TEvPut::ETactic Tactic;\n \n     struct TBlobInfo {\n@@ -99,8 +97,6 @@ class TPutImpl {\n \n     friend class TBlobStorageGroupPutRequest;\n \n-    bool IsInitialized = false;\n-\n     friend void ::Out<TBlobInfo>(IOutputStream&, const TBlobInfo&);\n \n public:\n@@ -109,7 +105,7 @@ class TPutImpl {\n             bool enableRequestMod3x3ForMinLatecy, TActorId recipient, ui64 cookie, NWilson::TTraceId traceId)\n         : Deadline(ev->Deadline)\n         , Info(info)\n-        , Blackboard(info, state, ev->HandleClass, NKikimrBlobStorage::EGetHandleClass::AsyncRead, false)\n+        , Blackboard(info, state, ev->HandleClass, NKikimrBlobStorage::EGetHandleClass::AsyncRead)\n         , IsDone(1)\n         , WrittenBeyondBarrier(1)\n         , StatusFlags(0)\n@@ -133,7 +129,7 @@ class TPutImpl {\n             bool enableRequestMod3x3ForMinLatecy)\n         : Deadline(TInstant::Zero())\n         , Info(info)\n-        , Blackboard(info, state, putHandleClass, NKikimrBlobStorage::EGetHandleClass::AsyncRead, false)\n+        , Blackboard(info, state, putHandleClass, NKikimrBlobStorage::EGetHandleClass::AsyncRead)\n         , IsDone(events.size())\n         , WrittenBeyondBarrier(events.size())\n         , StatusFlags(0)\n@@ -175,47 +171,26 @@ class TPutImpl {\n         Y_VERIFY_S(partSets.size() == Blobs.size(), \"partSets.size# \" << partSets.size()\n                 << \" Blobs.size# \" << Blobs.size());\n         const ui32 totalParts = Info->Type.TotalPartCount();\n-        for (ui64 blobIdx = 0; blobIdx < Blobs.size(); ++blobIdx) {\n+        for (size_t blobIdx = 0; blobIdx < Blobs.size(); ++blobIdx) {\n             TBlobInfo& blob = Blobs[blobIdx];\n-            Blackboard.RegisterBlobForPut(blob.BlobId);\n+            Blackboard.RegisterBlobForPut(blob.BlobId, blobIdx);\n             for (ui32 i = 0; i < totalParts; ++i) {\n                 if (Info->Type.PartSize(TLogoBlobID(blob.BlobId, i + 1))) {\n                     Blackboard.AddPartToPut(blob.BlobId, i, TRope(partSets[blobIdx][i]));\n                 }\n             }\n-            Blackboard.MarkBlobReadyToPut(blob.BlobId, blobIdx);\n         }\n-        IsInitialized = true;\n     }\n \n     void PrepareReply(NKikimrProto::EReplyStatus status, TLogContext &logCtx, TString errorReason,\n             TPutResultVec &outPutResults);\n-    void PrepareReply(TLogContext &logCtx, TString errorReason, TBatchedVec<TBlackboard::TBlobStates::value_type*>& finished,\n-            TPutResultVec &outPutResults);\n-    void PrepareOneReply(NKikimrProto::EReplyStatus status, TLogoBlobID blobId, ui64 blobIdx, TLogContext &logCtx,\n+    void PrepareOneReply(NKikimrProto::EReplyStatus status, size_t blobIdx, TLogContext &logCtx,\n             TString errorReason, TPutResultVec &outPutResults);\n \n     ui64 GetTimeToAccelerateNs(TLogContext &logCtx);\n \n-    void Accelerate(TLogContext &logCtx) {\n-        Blackboard.ChangeAll();\n-        switch (Info->Type.GetErasure()) {\n-            case TBlobStorageGroupType::ErasureMirror3dc:\n-                Blackboard.RunStrategy(logCtx, TAcceleratePut3dcStrategy(Tactic, EnableRequestMod3x3ForMinLatecy));\n-                break;\n-            case TBlobStorageGroupType::ErasureMirror3of4:\n-                Blackboard.RunStrategy(logCtx, TPut3of4Strategy(Tactic, true));\n-                break;\n-            default:\n-                Blackboard.RunStrategy(logCtx, TAcceleratePutStrategy());\n-                break;\n-        }\n-    }\n-\n     TString DumpFullState() const;\n \n-    bool MarkBlobAsSent(ui64 blobIdx);\n-\n     TString ToString() const;\n \n     void InvalidatePartStates(ui32 orderNumber) {\n@@ -226,8 +201,8 @@ class TPutImpl {\n         Blackboard.ChangeAll();\n     }\n \n-    void Step(TLogContext &logCtx, TPutResultVec& putResults, const TBlobStorageGroupInfo::TGroupVDisks& expired) {\n-        RunStrategies(logCtx, putResults, expired);\n+    void Step(TLogContext &logCtx, TPutResultVec& putResults, const TBlobStorageGroupInfo::TGroupVDisks& expired, bool accelerate) {\n+        RunStrategies(logCtx, putResults, expired, accelerate);\n     }\n \n     TDeque<TPutEvent> GeneratePutRequests() {\n@@ -299,7 +274,8 @@ class TPutImpl {\n     }\n \n protected:\n-    void RunStrategies(TLogContext &logCtx, TPutResultVec &outPutResults, const TBlobStorageGroupInfo::TGroupVDisks& expired);\n+    void RunStrategies(TLogContext &logCtx, TPutResultVec &outPutResults, const TBlobStorageGroupInfo::TGroupVDisks& expired,\n+        bool accelerate);\n     void RunStrategy(TLogContext &logCtx, const IStrategy& strategy, TPutResultVec &outPutResults,\n         const TBlobStorageGroupInfo::TGroupVDisks& expired);\n \n@@ -339,7 +315,7 @@ class TPutImpl {\n     void ProcessResponseCommonPart(TProtobuf& record) {\n         Y_ABORT_UNLESS(record.HasStatus());\n         const NKikimrProto::EReplyStatus status = record.GetStatus();\n-        Y_ABORT_UNLESS(status != NKikimrProto::BLOCKED && status != NKikimrProto::RACE && status != NKikimrProto::DEADLINE);\n+        Y_ABORT_UNLESS(status != NKikimrProto::RACE);\n         if (record.HasStatusFlags()) {\n             StatusFlags.Merge(record.GetStatusFlags());\n         }\ndiff --git a/ydb/core/blobstorage/dsproxy/ut/dsproxy_put_ut.cpp b/ydb/core/blobstorage/dsproxy/ut/dsproxy_put_ut.cpp\nindex 09dca39bb5fd..2af3baccace5 100644\n--- a/ydb/core/blobstorage/dsproxy/ut/dsproxy_put_ut.cpp\n+++ b/ydb/core/blobstorage/dsproxy/ut/dsproxy_put_ut.cpp\n@@ -76,7 +76,7 @@ void TestPutMaxPartCountOnHandoff(TErasureType::EErasureSpecies erasureSpecies)\n     TPutImpl::TPutResultVec putResults;\n \n     putImpl.GenerateInitialRequests(logCtx, partSetSingleton);\n-    putImpl.Step(logCtx, putResults, {&group.GetInfo()->GetTopology()});\n+    putImpl.Step(logCtx, putResults, {&group.GetInfo()->GetTopology()}, false);\n     auto vPuts = putImpl.GeneratePutRequests();\n     group.SetError(0, NKikimrProto::ERROR);\n \n@@ -119,7 +119,7 @@ void TestPutMaxPartCountOnHandoff(TErasureType::EErasureSpecies erasureSpecies)\n         vPutResult.MakeError(status, TString(), vPut.Record);\n \n         putImpl.ProcessResponse(vPutResult);\n-        putImpl.Step(logCtx, putResults, {&group.GetInfo()->GetTopology()});\n+        putImpl.Step(logCtx, putResults, {&group.GetInfo()->GetTopology()}, false);\n         auto nextVPuts = putImpl.GeneratePutRequests();\n \n         if (putResults.size()) {\n@@ -273,7 +273,7 @@ struct TTestPutAllOk {\n             }\n \n             std::visit([&](auto &ev) { putImpl.ProcessResponse(*ev); }, vPutResults[resIdx]);\n-            putImpl.Step(LogCtx, putResults, &Group.GetInfo()->GetTopology());\n+            putImpl.Step(LogCtx, putResults, &Group.GetInfo()->GetTopology(), false);\n             auto vPuts = putImpl.GeneratePutRequests();\n             if (putResults.size() == BlobCount) {\n                 break;\n@@ -309,7 +309,7 @@ struct TTestPutAllOk {\n             }\n \n             putImpl->GenerateInitialRequests(LogCtx, PartSets);\n-            putImpl->Step(LogCtx, putResults, &Group.GetInfo()->GetTopology());\n+            putImpl->Step(LogCtx, putResults, &Group.GetInfo()->GetTopology(), false);\n             auto vPuts = putImpl->GeneratePutRequests();\n             UNIT_ASSERT(vPuts.size() == 6 || !IsVPut);\n             TDeque<TPutResultEvent> vPutResults;\n@@ -367,7 +367,7 @@ Y_UNIT_TEST(TestMirror3dcWith3x3MinLatencyMod) {\n     ErasureSplit((TErasureType::ECrcMode)blobId.CrcMode(), env.Info->Type, TRope(encryptedData), partSetSingleton[0]);\n     putImpl.GenerateInitialRequests(logCtx, partSetSingleton);\n     TPutImpl::TPutResultVec putResults;\n-    putImpl.Step(logCtx, putResults, &env.Info->GetTopology());\n+    putImpl.Step(logCtx, putResults, &env.Info->GetTopology(), false);\n     auto vPuts = putImpl.GeneratePutRequests();\n \n     UNIT_ASSERT_VALUES_EQUAL(vPuts.size(), 9);\ndiff --git a/ydb/core/blobstorage/dsproxy/ut_strategy/strategy_ut.cpp b/ydb/core/blobstorage/dsproxy/ut_strategy/strategy_ut.cpp\nindex 8b77cc4ee6b8..64ace509dd63 100644\n--- a/ydb/core/blobstorage/dsproxy/ut_strategy/strategy_ut.cpp\n+++ b/ydb/core/blobstorage/dsproxy/ut_strategy/strategy_ut.cpp\n@@ -105,7 +105,7 @@ void RunStrategyTest(TBlobStorageGroupType type) {\n         TLogoBlobID id(1'000'000'000, 1, 1, 0, data.size(), 0);\n         std::vector<TRope> parts(type.TotalPartCount());\n         ErasureSplit(TBlobStorageGroupType::CrcModeNone, type, TRope(data), parts);\n-        blackboard.RegisterBlobForPut(id);\n+        blackboard.RegisterBlobForPut(id, 0);\n         for (ui32 i = 0; i < parts.size(); ++i) {\n             blackboard.AddPartToPut(id, i, TRope(parts[i]));\n         }\ndiff --git a/ydb/core/blobstorage/incrhuge/ut/CMakeLists.darwin-arm64.txt b/ydb/core/blobstorage/incrhuge/ut/CMakeLists.darwin-arm64.txt\nindex 6f2136d8d1d8..51b840c6a43a 100644\n--- a/ydb/core/blobstorage/incrhuge/ut/CMakeLists.darwin-arm64.txt\n+++ b/ydb/core/blobstorage/incrhuge/ut/CMakeLists.darwin-arm64.txt\n@@ -12,6 +12,7 @@ target_link_libraries(ydb-core-blobstorage-incrhuge-ut PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n   cpp-testing-unittest_main\n+  version_definition\n   library-actors-protos\n   ydb-core-blobstorage\n   core-blobstorage-incrhuge\ndiff --git a/ydb/core/blobstorage/incrhuge/ut/CMakeLists.darwin-x86_64.txt b/ydb/core/blobstorage/incrhuge/ut/CMakeLists.darwin-x86_64.txt\nindex 832140620685..f0293a9024ff 100644\n--- a/ydb/core/blobstorage/incrhuge/ut/CMakeLists.darwin-x86_64.txt\n+++ b/ydb/core/blobstorage/incrhuge/ut/CMakeLists.darwin-x86_64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(ydb-core-blobstorage-incrhuge-ut PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n+  version_definition\n   library-actors-protos\n   ydb-core-blobstorage\n   core-blobstorage-incrhuge\ndiff --git a/ydb/core/blobstorage/incrhuge/ut/CMakeLists.linux-aarch64.txt b/ydb/core/blobstorage/incrhuge/ut/CMakeLists.linux-aarch64.txt\nindex 0966d091dc40..4b62e15a07c2 100644\n--- a/ydb/core/blobstorage/incrhuge/ut/CMakeLists.linux-aarch64.txt\n+++ b/ydb/core/blobstorage/incrhuge/ut/CMakeLists.linux-aarch64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(ydb-core-blobstorage-incrhuge-ut PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n   cpp-testing-unittest_main\n+  version_definition\n   library-actors-protos\n   ydb-core-blobstorage\n   core-blobstorage-incrhuge\ndiff --git a/ydb/core/blobstorage/incrhuge/ut/CMakeLists.linux-x86_64.txt b/ydb/core/blobstorage/incrhuge/ut/CMakeLists.linux-x86_64.txt\nindex 88ae35a5387f..1b632fce1e63 100644\n--- a/ydb/core/blobstorage/incrhuge/ut/CMakeLists.linux-x86_64.txt\n+++ b/ydb/core/blobstorage/incrhuge/ut/CMakeLists.linux-x86_64.txt\n@@ -14,6 +14,7 @@ target_link_libraries(ydb-core-blobstorage-incrhuge-ut PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n+  version_definition\n   library-actors-protos\n   ydb-core-blobstorage\n   core-blobstorage-incrhuge\ndiff --git a/ydb/core/blobstorage/incrhuge/ut/CMakeLists.windows-x86_64.txt b/ydb/core/blobstorage/incrhuge/ut/CMakeLists.windows-x86_64.txt\nindex c81f9ff136bf..264ff4621bdf 100644\n--- a/ydb/core/blobstorage/incrhuge/ut/CMakeLists.windows-x86_64.txt\n+++ b/ydb/core/blobstorage/incrhuge/ut/CMakeLists.windows-x86_64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(ydb-core-blobstorage-incrhuge-ut PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n+  version_definition\n   library-actors-protos\n   ydb-core-blobstorage\n   core-blobstorage-incrhuge\ndiff --git a/ydb/core/blobstorage/incrhuge/ut/ya.make b/ydb/core/blobstorage/incrhuge/ut/ya.make\nindex 1dab38ef3f26..c7936f615c71 100644\n--- a/ydb/core/blobstorage/incrhuge/ut/ya.make\n+++ b/ydb/core/blobstorage/incrhuge/ut/ya.make\n@@ -12,6 +12,7 @@ ELSE()\n ENDIF()\n \n PEERDIR(\n+    ydb/apps/version\n     ydb/library/actors/protos\n     ydb/core/blobstorage\n     ydb/core/blobstorage/incrhuge\ndiff --git a/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.darwin-arm64.txt b/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.darwin-arm64.txt\nindex 5e5bdff5c9c6..60160019c364 100644\n--- a/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.darwin-arm64.txt\n+++ b/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.darwin-arm64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(blobstorage-ut_blobstorage-lib PUBLIC\n   yutil\n   cpp-digest-md5\n   cpp-testing-unittest\n+  version_definition\n   ydb-core-base\n   ydb-core-blob_depot\n   core-blobstorage-backpressure\ndiff --git a/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.darwin-x86_64.txt b/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.darwin-x86_64.txt\nindex 5e5bdff5c9c6..60160019c364 100644\n--- a/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.darwin-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.darwin-x86_64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(blobstorage-ut_blobstorage-lib PUBLIC\n   yutil\n   cpp-digest-md5\n   cpp-testing-unittest\n+  version_definition\n   ydb-core-base\n   ydb-core-blob_depot\n   core-blobstorage-backpressure\ndiff --git a/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.linux-aarch64.txt b/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.linux-aarch64.txt\nindex be9f296fefb5..26965076f973 100644\n--- a/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.linux-aarch64.txt\n+++ b/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.linux-aarch64.txt\n@@ -14,6 +14,7 @@ target_link_libraries(blobstorage-ut_blobstorage-lib PUBLIC\n   yutil\n   cpp-digest-md5\n   cpp-testing-unittest\n+  version_definition\n   ydb-core-base\n   ydb-core-blob_depot\n   core-blobstorage-backpressure\ndiff --git a/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.linux-x86_64.txt b/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.linux-x86_64.txt\nindex be9f296fefb5..26965076f973 100644\n--- a/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.linux-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.linux-x86_64.txt\n@@ -14,6 +14,7 @@ target_link_libraries(blobstorage-ut_blobstorage-lib PUBLIC\n   yutil\n   cpp-digest-md5\n   cpp-testing-unittest\n+  version_definition\n   ydb-core-base\n   ydb-core-blob_depot\n   core-blobstorage-backpressure\ndiff --git a/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.windows-x86_64.txt b/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.windows-x86_64.txt\nindex 5e5bdff5c9c6..60160019c364 100644\n--- a/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.windows-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_blobstorage/lib/CMakeLists.windows-x86_64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(blobstorage-ut_blobstorage-lib PUBLIC\n   yutil\n   cpp-digest-md5\n   cpp-testing-unittest\n+  version_definition\n   ydb-core-base\n   ydb-core-blob_depot\n   core-blobstorage-backpressure\ndiff --git a/ydb/core/blobstorage/ut_blobstorage/lib/ya.make b/ydb/core/blobstorage/ut_blobstorage/lib/ya.make\nindex 0572ce32b6a4..58b44a1be8e2 100644\n--- a/ydb/core/blobstorage/ut_blobstorage/lib/ya.make\n+++ b/ydb/core/blobstorage/ut_blobstorage/lib/ya.make\n@@ -16,6 +16,7 @@ SRCS(\n PEERDIR(\n     library/cpp/digest/md5\n     library/cpp/testing/unittest\n+    ydb/apps/version\n     ydb/core/base\n     ydb/core/blob_depot\n     ydb/core/blobstorage/backpressure\ndiff --git a/ydb/core/blobstorage/ut_group/CMakeLists.darwin-arm64.txt b/ydb/core/blobstorage/ut_group/CMakeLists.darwin-arm64.txt\nindex 353b5cf2d3de..ac67abed5452 100644\n--- a/ydb/core/blobstorage/ut_group/CMakeLists.darwin-arm64.txt\n+++ b/ydb/core/blobstorage/ut_group/CMakeLists.darwin-arm64.txt\n@@ -12,6 +12,7 @@ target_link_libraries(ydb-core-blobstorage-ut_group PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n   cpp-testing-unittest_main\n+  version_definition\n   actors-interconnect-mock\n   cpp-testing-unittest\n   core-blobstorage-crypto\ndiff --git a/ydb/core/blobstorage/ut_group/CMakeLists.darwin-x86_64.txt b/ydb/core/blobstorage/ut_group/CMakeLists.darwin-x86_64.txt\nindex 6312ab3ac606..e0c4daf3fe72 100644\n--- a/ydb/core/blobstorage/ut_group/CMakeLists.darwin-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_group/CMakeLists.darwin-x86_64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(ydb-core-blobstorage-ut_group PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n+  version_definition\n   actors-interconnect-mock\n   cpp-testing-unittest\n   core-blobstorage-crypto\ndiff --git a/ydb/core/blobstorage/ut_group/CMakeLists.linux-aarch64.txt b/ydb/core/blobstorage/ut_group/CMakeLists.linux-aarch64.txt\nindex 746f31afd9b7..8aee02b36535 100644\n--- a/ydb/core/blobstorage/ut_group/CMakeLists.linux-aarch64.txt\n+++ b/ydb/core/blobstorage/ut_group/CMakeLists.linux-aarch64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(ydb-core-blobstorage-ut_group PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n   cpp-testing-unittest_main\n+  version_definition\n   actors-interconnect-mock\n   cpp-testing-unittest\n   core-blobstorage-crypto\ndiff --git a/ydb/core/blobstorage/ut_group/CMakeLists.linux-x86_64.txt b/ydb/core/blobstorage/ut_group/CMakeLists.linux-x86_64.txt\nindex 9d161e135ce8..a050e4a489be 100644\n--- a/ydb/core/blobstorage/ut_group/CMakeLists.linux-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_group/CMakeLists.linux-x86_64.txt\n@@ -14,6 +14,7 @@ target_link_libraries(ydb-core-blobstorage-ut_group PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n+  version_definition\n   actors-interconnect-mock\n   cpp-testing-unittest\n   core-blobstorage-crypto\ndiff --git a/ydb/core/blobstorage/ut_group/CMakeLists.windows-x86_64.txt b/ydb/core/blobstorage/ut_group/CMakeLists.windows-x86_64.txt\nindex 2d97bd8714b7..f47b37d786a1 100644\n--- a/ydb/core/blobstorage/ut_group/CMakeLists.windows-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_group/CMakeLists.windows-x86_64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(ydb-core-blobstorage-ut_group PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n+  version_definition\n   actors-interconnect-mock\n   cpp-testing-unittest\n   core-blobstorage-crypto\ndiff --git a/ydb/core/blobstorage/ut_group/ya.make b/ydb/core/blobstorage/ut_group/ya.make\nindex aa0a9c0ebab8..88e601a9eaa3 100644\n--- a/ydb/core/blobstorage/ut_group/ya.make\n+++ b/ydb/core/blobstorage/ut_group/ya.make\n@@ -16,6 +16,7 @@ ELSE()\n ENDIF()\n \n PEERDIR(\n+    ydb/apps/version\n     ydb/library/actors/interconnect/mock\n     library/cpp/testing/unittest\n     ydb/core/blobstorage/crypto\ndiff --git a/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.darwin-arm64.txt b/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.darwin-arm64.txt\nindex cd619388db4d..4c7cad058acb 100644\n--- a/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.darwin-arm64.txt\n+++ b/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.darwin-arm64.txt\n@@ -12,6 +12,7 @@ target_link_libraries(ydb-core-blobstorage-ut_mirror3of4 PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n   cpp-testing-unittest_main\n+  version_definition\n   actors-interconnect-mock\n   cpp-testing-unittest\n   core-blobstorage-backpressure\ndiff --git a/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.darwin-x86_64.txt b/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.darwin-x86_64.txt\nindex 23d89529f7cc..ce6f8ca30e0f 100644\n--- a/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.darwin-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.darwin-x86_64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(ydb-core-blobstorage-ut_mirror3of4 PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n+  version_definition\n   actors-interconnect-mock\n   cpp-testing-unittest\n   core-blobstorage-backpressure\ndiff --git a/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.linux-aarch64.txt b/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.linux-aarch64.txt\nindex e6a8877d5f34..dc13b4d1f416 100644\n--- a/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.linux-aarch64.txt\n+++ b/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.linux-aarch64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(ydb-core-blobstorage-ut_mirror3of4 PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n   cpp-testing-unittest_main\n+  version_definition\n   actors-interconnect-mock\n   cpp-testing-unittest\n   core-blobstorage-backpressure\ndiff --git a/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.linux-x86_64.txt b/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.linux-x86_64.txt\nindex 9f496b5c44c0..a696701b1d63 100644\n--- a/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.linux-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.linux-x86_64.txt\n@@ -14,6 +14,7 @@ target_link_libraries(ydb-core-blobstorage-ut_mirror3of4 PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n+  version_definition\n   actors-interconnect-mock\n   cpp-testing-unittest\n   core-blobstorage-backpressure\ndiff --git a/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.windows-x86_64.txt b/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.windows-x86_64.txt\nindex 37faed49d804..01fde9d224d7 100644\n--- a/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.windows-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_mirror3of4/CMakeLists.windows-x86_64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(ydb-core-blobstorage-ut_mirror3of4 PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n+  version_definition\n   actors-interconnect-mock\n   cpp-testing-unittest\n   core-blobstorage-backpressure\ndiff --git a/ydb/core/blobstorage/ut_mirror3of4/ya.make b/ydb/core/blobstorage/ut_mirror3of4/ya.make\nindex 4d89f5e383fd..bfd43f049cd1 100644\n--- a/ydb/core/blobstorage/ut_mirror3of4/ya.make\n+++ b/ydb/core/blobstorage/ut_mirror3of4/ya.make\n@@ -9,6 +9,7 @@ SIZE(MEDIUM)\n TIMEOUT(600)\n \n PEERDIR(\n+    ydb/apps/version\n     ydb/library/actors/interconnect/mock\n     library/cpp/testing/unittest\n     ydb/core/blobstorage/backpressure\ndiff --git a/ydb/core/blobstorage/ut_pdiskfit/pdiskfit/CMakeLists.linux-aarch64.txt b/ydb/core/blobstorage/ut_pdiskfit/pdiskfit/CMakeLists.linux-aarch64.txt\nindex c4f854dfecec..aed8d4e44586 100644\n--- a/ydb/core/blobstorage/ut_pdiskfit/pdiskfit/CMakeLists.linux-aarch64.txt\n+++ b/ydb/core/blobstorage/ut_pdiskfit/pdiskfit/CMakeLists.linux-aarch64.txt\n@@ -12,6 +12,7 @@ target_link_libraries(pdiskfit PUBLIC\n   contrib-libs-linux-headers\n   contrib-libs-cxxsupp\n   yutil\n+  version_definition\n   library-cpp-getopt\n   cpp-string_utils-parse_size\n   ydb-core-blobstorage\ndiff --git a/ydb/core/blobstorage/ut_pdiskfit/pdiskfit/CMakeLists.linux-x86_64.txt b/ydb/core/blobstorage/ut_pdiskfit/pdiskfit/CMakeLists.linux-x86_64.txt\nindex ff3d93d99608..25dd867af41f 100644\n--- a/ydb/core/blobstorage/ut_pdiskfit/pdiskfit/CMakeLists.linux-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_pdiskfit/pdiskfit/CMakeLists.linux-x86_64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(pdiskfit PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n   library-cpp-cpuid_check\n+  version_definition\n   library-cpp-getopt\n   cpp-string_utils-parse_size\n   ydb-core-blobstorage\ndiff --git a/ydb/core/blobstorage/ut_pdiskfit/pdiskfit/ya.make b/ydb/core/blobstorage/ut_pdiskfit/pdiskfit/ya.make\nindex 3f1ae9920495..ef98e816685e 100644\n--- a/ydb/core/blobstorage/ut_pdiskfit/pdiskfit/ya.make\n+++ b/ydb/core/blobstorage/ut_pdiskfit/pdiskfit/ya.make\n@@ -6,6 +6,7 @@ IF (OS_LINUX)\n     )\n \n     PEERDIR(\n+        ydb/apps/version\n         library/cpp/getopt\n         library/cpp/string_utils/parse_size\n         ydb/core/blobstorage\ndiff --git a/ydb/core/blobstorage/ut_pdiskfit/ut/CMakeLists.linux-aarch64.txt b/ydb/core/blobstorage/ut_pdiskfit/ut/CMakeLists.linux-aarch64.txt\nindex 629ca9bf1cd2..6a6dce60f5a0 100644\n--- a/ydb/core/blobstorage/ut_pdiskfit/ut/CMakeLists.linux-aarch64.txt\n+++ b/ydb/core/blobstorage/ut_pdiskfit/ut/CMakeLists.linux-aarch64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(ydb-core-blobstorage-ut_pdiskfit-ut PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n   cpp-testing-unittest_main\n+  version_definition\n   ydb-core-blobstorage\n   blobstorage-ut_pdiskfit-lib\n )\ndiff --git a/ydb/core/blobstorage/ut_pdiskfit/ut/CMakeLists.linux-x86_64.txt b/ydb/core/blobstorage/ut_pdiskfit/ut/CMakeLists.linux-x86_64.txt\nindex ea899890610e..5b779405228d 100644\n--- a/ydb/core/blobstorage/ut_pdiskfit/ut/CMakeLists.linux-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_pdiskfit/ut/CMakeLists.linux-x86_64.txt\n@@ -14,6 +14,7 @@ target_link_libraries(ydb-core-blobstorage-ut_pdiskfit-ut PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n+  version_definition\n   ydb-core-blobstorage\n   blobstorage-ut_pdiskfit-lib\n )\ndiff --git a/ydb/core/blobstorage/ut_pdiskfit/ut/ya.make b/ydb/core/blobstorage/ut_pdiskfit/ut/ya.make\nindex b4e9ff9707ba..31b328c8a37f 100644\n--- a/ydb/core/blobstorage/ut_pdiskfit/ut/ya.make\n+++ b/ydb/core/blobstorage/ut_pdiskfit/ut/ya.make\n@@ -16,6 +16,7 @@ IF (OS_LINUX AND NOT WITH_VALGRIND)\n     ENDIF ()\n \n     PEERDIR(\n+        ydb/apps/version\n         ydb/core/blobstorage\n         ydb/core/blobstorage/ut_pdiskfit/lib\n     )\ndiff --git a/ydb/core/blobstorage/ut_vdisk/CMakeLists.darwin-arm64.txt b/ydb/core/blobstorage/ut_vdisk/CMakeLists.darwin-arm64.txt\nindex 84b2321057db..fe3bd0df4a23 100644\n--- a/ydb/core/blobstorage/ut_vdisk/CMakeLists.darwin-arm64.txt\n+++ b/ydb/core/blobstorage/ut_vdisk/CMakeLists.darwin-arm64.txt\n@@ -20,6 +20,7 @@ target_link_libraries(ydb-core-blobstorage-ut_vdisk PUBLIC\n   yutil\n   cpp-testing-unittest_main\n   ydb-core-blobstorage\n+  version_definition\n   library-actors-protos\n   library-cpp-codecs\n   ydb-core-base\ndiff --git a/ydb/core/blobstorage/ut_vdisk/CMakeLists.darwin-x86_64.txt b/ydb/core/blobstorage/ut_vdisk/CMakeLists.darwin-x86_64.txt\nindex 0c581b6e4f34..2b13c91661e2 100644\n--- a/ydb/core/blobstorage/ut_vdisk/CMakeLists.darwin-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_vdisk/CMakeLists.darwin-x86_64.txt\n@@ -21,6 +21,7 @@ target_link_libraries(ydb-core-blobstorage-ut_vdisk PUBLIC\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n   ydb-core-blobstorage\n+  version_definition\n   library-actors-protos\n   library-cpp-codecs\n   ydb-core-base\ndiff --git a/ydb/core/blobstorage/ut_vdisk/CMakeLists.linux-aarch64.txt b/ydb/core/blobstorage/ut_vdisk/CMakeLists.linux-aarch64.txt\nindex 2260e8b0bcb1..30f3761dce83 100644\n--- a/ydb/core/blobstorage/ut_vdisk/CMakeLists.linux-aarch64.txt\n+++ b/ydb/core/blobstorage/ut_vdisk/CMakeLists.linux-aarch64.txt\n@@ -21,6 +21,7 @@ target_link_libraries(ydb-core-blobstorage-ut_vdisk PUBLIC\n   yutil\n   cpp-testing-unittest_main\n   ydb-core-blobstorage\n+  version_definition\n   library-actors-protos\n   library-cpp-codecs\n   ydb-core-base\ndiff --git a/ydb/core/blobstorage/ut_vdisk/CMakeLists.linux-x86_64.txt b/ydb/core/blobstorage/ut_vdisk/CMakeLists.linux-x86_64.txt\nindex 9d8dbd248282..c350eb55659e 100644\n--- a/ydb/core/blobstorage/ut_vdisk/CMakeLists.linux-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_vdisk/CMakeLists.linux-x86_64.txt\n@@ -22,6 +22,7 @@ target_link_libraries(ydb-core-blobstorage-ut_vdisk PUBLIC\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n   ydb-core-blobstorage\n+  version_definition\n   library-actors-protos\n   library-cpp-codecs\n   ydb-core-base\ndiff --git a/ydb/core/blobstorage/ut_vdisk/CMakeLists.windows-x86_64.txt b/ydb/core/blobstorage/ut_vdisk/CMakeLists.windows-x86_64.txt\nindex 7a391ae50e24..284a5a11ac12 100644\n--- a/ydb/core/blobstorage/ut_vdisk/CMakeLists.windows-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_vdisk/CMakeLists.windows-x86_64.txt\n@@ -21,6 +21,7 @@ target_link_libraries(ydb-core-blobstorage-ut_vdisk PUBLIC\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n   ydb-core-blobstorage\n+  version_definition\n   library-actors-protos\n   library-cpp-codecs\n   ydb-core-base\ndiff --git a/ydb/core/blobstorage/ut_vdisk/ya.make b/ydb/core/blobstorage/ut_vdisk/ya.make\nindex 6b95175079a9..526d1e82de93 100644\n--- a/ydb/core/blobstorage/ut_vdisk/ya.make\n+++ b/ydb/core/blobstorage/ut_vdisk/ya.make\n@@ -18,6 +18,7 @@ SRCS(\n )\n \n PEERDIR(\n+    ydb/apps/version\n     ydb/library/actors/protos\n     library/cpp/codecs\n     ydb/core/base\ndiff --git a/ydb/core/blobstorage/ut_vdisk2/CMakeLists.darwin-arm64.txt b/ydb/core/blobstorage/ut_vdisk2/CMakeLists.darwin-arm64.txt\nindex ca0fee8a8348..3f16b18c6b95 100644\n--- a/ydb/core/blobstorage/ut_vdisk2/CMakeLists.darwin-arm64.txt\n+++ b/ydb/core/blobstorage/ut_vdisk2/CMakeLists.darwin-arm64.txt\n@@ -12,6 +12,7 @@ target_link_libraries(ydb-core-blobstorage-ut_vdisk2 PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n   cpp-testing-unittest_main\n+  version_definition\n   cpp-testing-unittest\n   core-blobstorage-backpressure\n   core-blobstorage-groupinfo\ndiff --git a/ydb/core/blobstorage/ut_vdisk2/CMakeLists.darwin-x86_64.txt b/ydb/core/blobstorage/ut_vdisk2/CMakeLists.darwin-x86_64.txt\nindex 0a4fdd94186d..a163d72935b2 100644\n--- a/ydb/core/blobstorage/ut_vdisk2/CMakeLists.darwin-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_vdisk2/CMakeLists.darwin-x86_64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(ydb-core-blobstorage-ut_vdisk2 PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n+  version_definition\n   cpp-testing-unittest\n   core-blobstorage-backpressure\n   core-blobstorage-groupinfo\ndiff --git a/ydb/core/blobstorage/ut_vdisk2/CMakeLists.linux-aarch64.txt b/ydb/core/blobstorage/ut_vdisk2/CMakeLists.linux-aarch64.txt\nindex 137fc6d3b9af..767d418c4ebf 100644\n--- a/ydb/core/blobstorage/ut_vdisk2/CMakeLists.linux-aarch64.txt\n+++ b/ydb/core/blobstorage/ut_vdisk2/CMakeLists.linux-aarch64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(ydb-core-blobstorage-ut_vdisk2 PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n   cpp-testing-unittest_main\n+  version_definition\n   cpp-testing-unittest\n   core-blobstorage-backpressure\n   core-blobstorage-groupinfo\ndiff --git a/ydb/core/blobstorage/ut_vdisk2/CMakeLists.linux-x86_64.txt b/ydb/core/blobstorage/ut_vdisk2/CMakeLists.linux-x86_64.txt\nindex dff8445d7de9..b6cfc5355922 100644\n--- a/ydb/core/blobstorage/ut_vdisk2/CMakeLists.linux-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_vdisk2/CMakeLists.linux-x86_64.txt\n@@ -14,6 +14,7 @@ target_link_libraries(ydb-core-blobstorage-ut_vdisk2 PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n+  version_definition\n   cpp-testing-unittest\n   core-blobstorage-backpressure\n   core-blobstorage-groupinfo\ndiff --git a/ydb/core/blobstorage/ut_vdisk2/CMakeLists.windows-x86_64.txt b/ydb/core/blobstorage/ut_vdisk2/CMakeLists.windows-x86_64.txt\nindex b4109c6cb45b..19ffd0ac9b8f 100644\n--- a/ydb/core/blobstorage/ut_vdisk2/CMakeLists.windows-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_vdisk2/CMakeLists.windows-x86_64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(ydb-core-blobstorage-ut_vdisk2 PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n+  version_definition\n   cpp-testing-unittest\n   core-blobstorage-backpressure\n   core-blobstorage-groupinfo\ndiff --git a/ydb/core/blobstorage/ut_vdisk2/ya.make b/ydb/core/blobstorage/ut_vdisk2/ya.make\nindex 8d2d47103207..394f0576b6ac 100644\n--- a/ydb/core/blobstorage/ut_vdisk2/ya.make\n+++ b/ydb/core/blobstorage/ut_vdisk2/ya.make\n@@ -16,6 +16,7 @@ SRCS(\n )\n \n PEERDIR(\n+    ydb/apps/version\n     library/cpp/testing/unittest\n     ydb/core/blobstorage/backpressure\n     ydb/core/blobstorage/groupinfo\ndiff --git a/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.darwin-arm64.txt b/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.darwin-arm64.txt\nindex 7c716b4a5553..578fa0238b10 100644\n--- a/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.darwin-arm64.txt\n+++ b/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.darwin-arm64.txt\n@@ -16,6 +16,7 @@ target_link_libraries(ydb-core-blobstorage-vdisk-syncer-ut PUBLIC\n   yutil\n   cpp-testing-unittest_main\n   blobstorage-vdisk-syncer\n+  version_definition\n   library-cpp-getopt\n   library-cpp-svnversion\n   ydb-core-base\ndiff --git a/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.darwin-x86_64.txt b/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.darwin-x86_64.txt\nindex 75256f3af926..a4157f2d94fe 100644\n--- a/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.darwin-x86_64.txt\n+++ b/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.darwin-x86_64.txt\n@@ -17,6 +17,7 @@ target_link_libraries(ydb-core-blobstorage-vdisk-syncer-ut PUBLIC\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n   blobstorage-vdisk-syncer\n+  version_definition\n   library-cpp-getopt\n   library-cpp-svnversion\n   ydb-core-base\ndiff --git a/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.linux-aarch64.txt b/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.linux-aarch64.txt\nindex f4f1ee69f448..cfee695d7895 100644\n--- a/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.linux-aarch64.txt\n+++ b/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.linux-aarch64.txt\n@@ -17,6 +17,7 @@ target_link_libraries(ydb-core-blobstorage-vdisk-syncer-ut PUBLIC\n   yutil\n   cpp-testing-unittest_main\n   blobstorage-vdisk-syncer\n+  version_definition\n   library-cpp-getopt\n   library-cpp-svnversion\n   ydb-core-base\ndiff --git a/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.linux-x86_64.txt b/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.linux-x86_64.txt\nindex 996ac0bd9406..8ce55a24c606 100644\n--- a/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.linux-x86_64.txt\n+++ b/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.linux-x86_64.txt\n@@ -18,6 +18,7 @@ target_link_libraries(ydb-core-blobstorage-vdisk-syncer-ut PUBLIC\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n   blobstorage-vdisk-syncer\n+  version_definition\n   library-cpp-getopt\n   library-cpp-svnversion\n   ydb-core-base\ndiff --git a/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.windows-x86_64.txt b/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.windows-x86_64.txt\nindex 657e7e41f3c3..8eb0e7465a02 100644\n--- a/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.windows-x86_64.txt\n+++ b/ydb/core/blobstorage/vdisk/syncer/ut/CMakeLists.windows-x86_64.txt\n@@ -17,6 +17,7 @@ target_link_libraries(ydb-core-blobstorage-vdisk-syncer-ut PUBLIC\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n   blobstorage-vdisk-syncer\n+  version_definition\n   library-cpp-getopt\n   library-cpp-svnversion\n   ydb-core-base\ndiff --git a/ydb/core/blobstorage/vdisk/syncer/ut/ya.make b/ydb/core/blobstorage/vdisk/syncer/ut/ya.make\nindex 8844b2aeafd0..21f122b246d4 100644\n--- a/ydb/core/blobstorage/vdisk/syncer/ut/ya.make\n+++ b/ydb/core/blobstorage/vdisk/syncer/ut/ya.make\n@@ -7,6 +7,7 @@ TIMEOUT(600)\n SIZE(MEDIUM)\n \n PEERDIR(\n+    ydb/apps/version\n     library/cpp/getopt\n     library/cpp/svnversion\n     ydb/core/base\ndiff --git a/ydb/core/cms/api_adapters.cpp b/ydb/core/cms/api_adapters.cpp\nindex 18fe27185554..55572dbb9931 100644\n--- a/ydb/core/cms/api_adapters.cpp\n+++ b/ydb/core/cms/api_adapters.cpp\n@@ -163,6 +163,7 @@ class TListClusterNodes: public TAdapterActor<\n         out.set_host(in.Host);\n         out.set_port(in.IcPort);\n         out.set_state(ConvertNodeState(in.State));\n+        out.set_version(in.Version);\n         *out.mutable_start_time() = TimeUtil::MicrosecondsToTimestamp(in.StartTime.GetValue());\n \n         auto& location = *out.mutable_location();\ndiff --git a/ydb/core/cms/cms_ut_common.cpp b/ydb/core/cms/cms_ut_common.cpp\nindex ab8843330d19..876bde9982ef 100644\n--- a/ydb/core/cms/cms_ut_common.cpp\n+++ b/ydb/core/cms/cms_ut_common.cpp\n@@ -486,7 +486,13 @@ static void SetupServices(TTestActorRuntime &runtime, const TTestEnvOpts &option\n     NKikimrConfig::TAppConfig appConfig;\n     appConfig.MutableBootstrapConfig()->CopyFrom(TFakeNodeWhiteboardService::BootstrapConfig);\n     runtime.AddLocalService(MakeConfigsDispatcherID(runtime.GetNodeId(0)),\n-                            TActorSetupCmd(CreateConfigsDispatcher(appConfig, {}), TMailboxType::Simple, 0), 0);\n+                            TActorSetupCmd(CreateConfigsDispatcher(\n+                                NKikimr::NConsole::TConfigsDispatcherInitInfo {\n+                                    .InitialConfig = appConfig,\n+                                }),\n+                                TMailboxType::Simple,\n+                                0),\n+                            0);\n \n     runtime.Initialize(app.Unwrap());\n     auto dnsConfig = new TDynamicNameserviceConfig();\ndiff --git a/ydb/core/cms/console/configs_dispatcher.cpp b/ydb/core/cms/console/configs_dispatcher.cpp\nindex bd6b40d2edf8..d1834fe1018d 100644\n--- a/ydb/core/cms/console/configs_dispatcher.cpp\n+++ b/ydb/core/cms/console/configs_dispatcher.cpp\n@@ -133,12 +133,7 @@ class TConfigsDispatcher : public TActorBootstrapped<TConfigsDispatcher> {\n         return NKikimrServices::TActivity::CONFIGS_DISPATCHER_ACTOR;\n     }\n \n-    TConfigsDispatcher(\n-        const NKikimrConfig::TAppConfig &config,\n-        const TMap<TString, TString> &labels,\n-        const NKikimrConfig::TAppConfig &initialCmsConfig,\n-        const NKikimrConfig::TAppConfig &initialCmsYamlConfig,\n-        const THashMap<ui32, TConfigItemInfo> &configInitInfo);\n+    TConfigsDispatcher(const TConfigsDispatcherInitInfo& initInfo);\n \n     void Bootstrap();\n \n@@ -163,6 +158,8 @@ class TConfigsDispatcher : public TActorBootstrapped<TConfigsDispatcher> {\n \n     NKikimrConfig::TAppConfig ParseYamlProtoConfig();\n \n+    TDynBitMap FilterKinds(const TDynBitMap& in);\n+\n     void Handle(NMon::TEvHttpInfo::TPtr &ev);\n     void Handle(TEvInterconnect::TEvNodesInfo::TPtr &ev);\n     void Handle(TEvConsole::TEvConfigSubscriptionNotification::TPtr &ev);\n@@ -230,12 +227,11 @@ class TConfigsDispatcher : public TActorBootstrapped<TConfigsDispatcher> {\n \n \n private:\n-    TMap<TString, TString> Labels;\n-    const NKikimrConfig::TAppConfig InitialConfig;\n+    const TMap<TString, TString> Labels;\n+    const std::variant<std::monostate, TDenyList, TAllowList> ItemsServeRules;\n+    const NKikimrConfig::TAppConfig BaseConfig;\n     NKikimrConfig::TAppConfig CurrentConfig;\n-    const NKikimrConfig::TAppConfig InitialCmsConfig;\n-    const NKikimrConfig::TAppConfig InitialCmsYamlConfig;\n-    const THashMap<ui32, TConfigItemInfo> ConfigInitInfo;\n+    const std::optional<TDebugInfo> DebugInfo;\n     ui64 NextRequestCookie;\n     TVector<TActorId> HttpRequests;\n     TActorId CommonSubscriptionClient;\n@@ -255,21 +251,14 @@ class TConfigsDispatcher : public TActorBootstrapped<TConfigsDispatcher> {\n \n };\n \n-TConfigsDispatcher::TConfigsDispatcher(\n-    const NKikimrConfig::TAppConfig &config,\n-    const TMap<TString, TString> &labels,\n-    const NKikimrConfig::TAppConfig &initialCmsConfig,\n-    const NKikimrConfig::TAppConfig &initialCmsYamlConfig,\n-    const THashMap<ui32, TConfigItemInfo> &configInitInfo)\n-        : Labels(labels)\n-        , InitialConfig(config)\n-        , CurrentConfig(config)\n-        , InitialCmsConfig(initialCmsConfig)\n-        , InitialCmsYamlConfig(initialCmsYamlConfig)\n-        , ConfigInitInfo(configInitInfo)\n+TConfigsDispatcher::TConfigsDispatcher(const TConfigsDispatcherInitInfo& initInfo)\n+        : Labels(initInfo.Labels)\n+        , ItemsServeRules(initInfo.ItemsServeRules)\n+        , BaseConfig(initInfo.InitialConfig)\n+        , CurrentConfig(initInfo.InitialConfig)\n+        , DebugInfo(initInfo.DebugInfo)\n         , NextRequestCookie(Now().GetValue())\n-{\n-}\n+{}\n \n void TConfigsDispatcher::Bootstrap()\n {\n@@ -400,9 +389,12 @@ void TConfigsDispatcher::ReplyMonJson(TActorId mailbox) {\n     response.InsertValue(\"yaml_config\", YamlConfig);\n     response.InsertValue(\"resolved_json_config\", NJson::ReadJsonFastTree(ResolvedJsonConfig, true));\n     response.InsertValue(\"current_json_config\", NJson::ReadJsonFastTree(NProtobufJson::Proto2Json(CurrentConfig, NYamlConfig::GetProto2JsonConfig()), true));\n-    response.InsertValue(\"initial_json_config\", NJson::ReadJsonFastTree(NProtobufJson::Proto2Json(InitialConfig, NYamlConfig::GetProto2JsonConfig()), true));\n-    response.InsertValue(\"initial_cms_json_config\", NJson::ReadJsonFastTree(NProtobufJson::Proto2Json(InitialCmsConfig, NYamlConfig::GetProto2JsonConfig()), true));\n-    response.InsertValue(\"initial_cms_yaml_json_config\", NJson::ReadJsonFastTree(NProtobufJson::Proto2Json(InitialCmsYamlConfig, NYamlConfig::GetProto2JsonConfig()), true));\n+\n+    if (DebugInfo) {\n+        response.InsertValue(\"initial_json_config\", NJson::ReadJsonFastTree(NProtobufJson::Proto2Json(DebugInfo->StaticConfig, NYamlConfig::GetProto2JsonConfig()), true));\n+        response.InsertValue(\"initial_cms_json_config\", NJson::ReadJsonFastTree(NProtobufJson::Proto2Json(DebugInfo->OldDynConfig, NYamlConfig::GetProto2JsonConfig()), true));\n+        response.InsertValue(\"initial_cms_yaml_json_config\", NJson::ReadJsonFastTree(NProtobufJson::Proto2Json(DebugInfo->NewDynConfig, NYamlConfig::GetProto2JsonConfig()), true));\n+    }\n \n     NJson::WriteJson(&str, &response, {});\n \n@@ -419,6 +411,29 @@ void TConfigsDispatcher::Handle(TEvConsole::TEvConfigNotificationRequest::TPtr &\n     Send(ev->Sender, resp.Release(), 0, ev->Cookie);\n }\n \n+\n+TDynBitMap TConfigsDispatcher::FilterKinds(const TDynBitMap& in) {\n+    TDynBitMap out;\n+\n+    if (const auto* denyList = std::get_if<TDenyList>(&ItemsServeRules)) {\n+        Y_FOR_EACH_BIT(kind, in) {\n+            if (!denyList->Items.contains(kind)) {\n+                out.Set(kind);\n+            }\n+        }\n+    } else if (const auto* allowList = std::get_if<TAllowList>(&ItemsServeRules)) {\n+        Y_FOR_EACH_BIT(kind, in) {\n+            if (allowList->Items.contains(kind)) {\n+                out.Set(kind);\n+            }\n+        }\n+    } else {\n+        out = in;\n+    }\n+\n+    return out;\n+}\n+\n void TConfigsDispatcher::Handle(TEvInterconnect::TEvNodesInfo::TPtr &ev)\n {\n     Y_UNUSED(ev);\n@@ -494,14 +509,14 @@ void TConfigsDispatcher::Handle(TEvInterconnect::TEvNodesInfo::TPtr &ev)\n                     str << \"Coloring: \\\"<font color=\\\"red\\\">config not set</font>\\\",\"\n                         << \" \\\"<font color=\\\"green\\\">config set in dynamic config</font>\\\", \\\"<font color=\\\"#007bff\\\">config set in static config</font>\\\"\" << Endl;\n                     str << \"</div>\" << Endl;\n-                    NHttp::OutputRichConfigHTML(str, InitialConfig, YamlProtoConfig, CurrentConfig, DYNAMIC_KINDS, NON_YAML_KINDS, YamlConfigEnabled);\n+                    NHttp::OutputRichConfigHTML(str, BaseConfig, YamlProtoConfig, CurrentConfig, DYNAMIC_KINDS, NON_YAML_KINDS, YamlConfigEnabled);\n                 }\n                 str << \"<br />\" << Endl;\n                 COLLAPSED_REF_CONTENT(\"effective-startup-config\", \"Effective startup config\") {\n                     str << \"<div class=\\\"alert alert-primary tab-left\\\" role=\\\"alert\\\">\" << Endl;\n                     str << \"Some of these configs may be overwritten by dynamic ones.\" << Endl;\n                     str << \"</div>\" << Endl;\n-                    NHttp::OutputConfigHTML(str, InitialConfig);\n+                    NHttp::OutputConfigHTML(str, BaseConfig);\n                 }\n                 str << \"<br />\" << Endl;\n                 COLLAPSED_REF_CONTENT(\"effective-dynamic-config\", \"Effective dynamic config\") {\n@@ -510,10 +525,10 @@ void TConfigsDispatcher::Handle(TEvInterconnect::TEvNodesInfo::TPtr &ev)\n                     str << \"</div>\" << Endl;\n                     NKikimrConfig::TAppConfig trunc;\n                     if (YamlConfigEnabled) {\n-                        ReplaceConfigItems(YamlProtoConfig, trunc, KindsToBitMap(DYNAMIC_KINDS), InitialConfig);\n-                        ReplaceConfigItems(CurrentConfig, trunc, KindsToBitMap(NON_YAML_KINDS), trunc, false);\n+                        ReplaceConfigItems(YamlProtoConfig, trunc, FilterKinds(KindsToBitMap(DYNAMIC_KINDS)), BaseConfig);\n+                        ReplaceConfigItems(CurrentConfig, trunc, FilterKinds(KindsToBitMap(NON_YAML_KINDS)), trunc, false);\n                     } else {\n-                        ReplaceConfigItems(CurrentConfig, trunc, KindsToBitMap(DYNAMIC_KINDS), InitialConfig);\n+                        ReplaceConfigItems(CurrentConfig, trunc, FilterKinds(KindsToBitMap(DYNAMIC_KINDS)), BaseConfig);\n                     }\n                     NHttp::OutputConfigHTML(str, trunc);\n                 }\n@@ -521,7 +536,15 @@ void TConfigsDispatcher::Handle(TEvInterconnect::TEvNodesInfo::TPtr &ev)\n                 COLLAPSED_REF_CONTENT(\"debug-info\", \"Debug info\") {\n                     DIV_CLASS(\"tab-left\") {\n                         COLLAPSED_REF_CONTENT(\"effective-config-debug-info\", \"Effective config debug info\") {\n-                            NHttp::OutputConfigDebugInfoHTML(str, InitialConfig, YamlProtoConfig, CurrentConfig, ConfigInitInfo, DYNAMIC_KINDS, NON_YAML_KINDS, YamlConfigEnabled);\n+                            NHttp::OutputConfigDebugInfoHTML(\n+                                str,\n+                                BaseConfig,\n+                                YamlProtoConfig,\n+                                CurrentConfig,\n+                                {DebugInfo ? DebugInfo->InitInfo : THashMap<ui32, TConfigItemInfo>{}},\n+                                DYNAMIC_KINDS,\n+                                NON_YAML_KINDS,\n+                                YamlConfigEnabled);\n                         }\n                         str << \"<br />\" << Endl;\n                         COLLAPSED_REF_CONTENT(\"state\", \"State\") {\n@@ -651,15 +674,17 @@ void TConfigsDispatcher::Handle(TEvInterconnect::TEvNodesInfo::TPtr &ev)\n                         }\n                         str << \"<br />\" << Endl;\n                         COLLAPSED_REF_CONTENT(\"initial-config\", \"Initial config\") {\n-                            NHttp::OutputConfigHTML(str, InitialConfig);\n+                            NHttp::OutputConfigHTML(str, BaseConfig);\n                         }\n-                        str << \"<br />\" << Endl;\n-                        COLLAPSED_REF_CONTENT(\"initial-cms-config\", \"Initial CMS config\") {\n-                            NHttp::OutputConfigHTML(str, InitialCmsConfig);\n-                        }\n-                        str << \"<br />\" << Endl;\n-                        COLLAPSED_REF_CONTENT(\"initial-cms-yaml-config\", \"Initial CMS YAML config\") {\n-                            NHttp::OutputConfigHTML(str, InitialCmsYamlConfig);\n+                        if  (DebugInfo) {\n+                            str << \"<br />\" << Endl;\n+                            COLLAPSED_REF_CONTENT(\"initial-cms-config\", \"Initial CMS config\") {\n+                                NHttp::OutputConfigHTML(str, DebugInfo->OldDynConfig);\n+                            }\n+                            str << \"<br />\" << Endl;\n+                            COLLAPSED_REF_CONTENT(\"initial-cms-yaml-config\", \"Initial CMS YAML config\") {\n+                                NHttp::OutputConfigHTML(str, DebugInfo->NewDynConfig);\n+                            }\n                         }\n                     }\n                 }\n@@ -742,7 +767,7 @@ void TConfigsDispatcher::Handle(TEvConsole::TEvConfigSubscriptionNotification::T\n         bool hasAffectedKinds = false;\n \n         if (subscription->Yaml && YamlConfigEnabled) {\n-            ReplaceConfigItems(YamlProtoConfig, trunc, subscription->Kinds, InitialConfig);\n+            ReplaceConfigItems(YamlProtoConfig, trunc, FilterKinds(subscription->Kinds), BaseConfig);\n         } else {\n             Y_FOR_EACH_BIT(kind, kinds) {\n                 if (affectedKinds.contains(kind)) {\n@@ -755,7 +780,7 @@ void TConfigsDispatcher::Handle(TEvConsole::TEvConfigSubscriptionNotification::T\n                 continue;\n             }\n \n-            ReplaceConfigItems(ev->Get()->Record.GetConfig(), trunc, kinds, InitialConfig);\n+            ReplaceConfigItems(ev->Get()->Record.GetConfig(), trunc, FilterKinds(kinds), BaseConfig);\n         }\n \n         if (hasAffectedKinds || !CompareConfigs(subscription->CurrentConfig.Config, trunc) || CurrentStateFunc() == &TThis::StateInit) {\n@@ -820,9 +845,9 @@ void TConfigsDispatcher::Handle(TEvConfigsDispatcher::TEvGetConfigRequest::TPtr\n     auto trunc = std::make_shared<NKikimrConfig::TAppConfig>();\n     auto kinds = KindsToBitMap(ev->Get()->ConfigItemKinds);\n     if (YamlConfigEnabled && yamlKinds) {\n-        ReplaceConfigItems(YamlProtoConfig, *trunc, kinds, InitialConfig);\n+        ReplaceConfigItems(YamlProtoConfig, *trunc, FilterKinds(kinds), BaseConfig);\n     } else {\n-        ReplaceConfigItems(CurrentConfig, *trunc, kinds, InitialConfig);\n+        ReplaceConfigItems(CurrentConfig, *trunc, FilterKinds(kinds), BaseConfig);\n     }\n     resp->Config = trunc;\n \n@@ -893,9 +918,9 @@ void TConfigsDispatcher::Handle(TEvConfigsDispatcher::TEvSetConfigSubscriptionRe\n             subscription->UpdateInProcess = MakeHolder<TEvConsole::TEvConfigNotificationRequest>();\n             NKikimrConfig::TAppConfig trunc;\n             if (YamlConfigEnabled) {\n-                ReplaceConfigItems(YamlProtoConfig, trunc, kinds, InitialConfig);\n+                ReplaceConfigItems(YamlProtoConfig, trunc, FilterKinds(kinds), BaseConfig);\n             } else {\n-                ReplaceConfigItems(CurrentConfig, trunc, kinds, InitialConfig);\n+                ReplaceConfigItems(CurrentConfig, trunc, FilterKinds(kinds), BaseConfig);\n             }\n             subscription->UpdateInProcess->Record.MutableConfig()->CopyFrom(trunc);\n             Y_FOR_EACH_BIT(kind, kinds) {\n@@ -997,14 +1022,8 @@ void TConfigsDispatcher::Handle(TEvConsole::TEvGetNodeLabelsRequest::TPtr &ev) {\n     Send(ev->Sender, Response.Release());\n }\n \n-IActor *CreateConfigsDispatcher(\n-    const NKikimrConfig::TAppConfig &config,\n-    const TMap<TString, TString> &labels,\n-    const NKikimrConfig::TAppConfig &initialCmsConfig,\n-    const NKikimrConfig::TAppConfig &initialCmsYamlConfig,\n-    const THashMap<ui32, TConfigItemInfo> &configInitInfo)\n-{\n-    return new TConfigsDispatcher(config, labels, initialCmsConfig, initialCmsYamlConfig, configInitInfo);\n+IActor *CreateConfigsDispatcher(const TConfigsDispatcherInitInfo& initInfo) {\n+    return new TConfigsDispatcher(initInfo);\n }\n \n } // namespace NKikimr::NConsole\ndiff --git a/ydb/core/cms/console/configs_dispatcher.h b/ydb/core/cms/console/configs_dispatcher.h\nindex b771a8a72529..e3034f932522 100644\n--- a/ydb/core/cms/console/configs_dispatcher.h\n+++ b/ydb/core/cms/console/configs_dispatcher.h\n@@ -5,6 +5,7 @@\n #include <ydb/core/cms/console/config_item_info.h>\n \n #include <util/generic/vector.h>\n+#include <util/generic/map.h>\n \n namespace NKikimr::NConsole {\n \n@@ -107,17 +108,34 @@ struct TEvConfigsDispatcher {\n     };\n };\n \n+struct TDenyList {\n+    std::set<ui32> Items;\n+};\n+\n+struct TAllowList {\n+    std::set<ui32> Items;\n+};\n+\n+struct TDebugInfo {\n+    NKikimrConfig::TAppConfig StaticConfig;\n+    NKikimrConfig::TAppConfig OldDynConfig;\n+    NKikimrConfig::TAppConfig NewDynConfig;\n+    THashMap<ui32, TConfigItemInfo> InitInfo;\n+};\n+\n+struct TConfigsDispatcherInitInfo {\n+    NKikimrConfig::TAppConfig InitialConfig;\n+    TMap<TString, TString> Labels;\n+    std::variant<std::monostate, TDenyList, TAllowList> ItemsServeRules;\n+    std::optional<TDebugInfo> DebugInfo;\n+};\n+\n /**\n  * Initial config is used to initilize Configs Dispatcher. All received configs\n  * are compared to the current one and notifications are not sent to local\n  * subscribers if there is no config modification detected.\n  */\n-IActor *CreateConfigsDispatcher(\n-    const NKikimrConfig::TAppConfig &config,\n-    const TMap<TString, TString> &labels,\n-    const NKikimrConfig::TAppConfig &initialCmsConfig = {},\n-    const NKikimrConfig::TAppConfig &initialCmsYamlConfig = {},\n-    const THashMap<ui32, TConfigItemInfo> &configInitInfo = {});\n+IActor *CreateConfigsDispatcher(const TConfigsDispatcherInitInfo& initInfo);\n \n inline TActorId MakeConfigsDispatcherID(ui32 node = 0) {\n     char x[12] = { 'c', 'o', 'n', 'f', 'i', 'g', 's', 'd', 'i', 's', 'p' };\ndiff --git a/ydb/core/driver_lib/run/kikimr_services_initializers.cpp b/ydb/core/driver_lib/run/kikimr_services_initializers.cpp\nindex 38da10016654..0dae3013e17b 100644\n--- a/ydb/core/driver_lib/run/kikimr_services_initializers.cpp\n+++ b/ydb/core/driver_lib/run/kikimr_services_initializers.cpp\n@@ -2381,7 +2381,18 @@ TConfigsDispatcherInitializer::TConfigsDispatcherInitializer(const TKikimrRunCon\n }\n \n void TConfigsDispatcherInitializer::InitializeServices(NActors::TActorSystemSetup* setup, const NKikimr::TAppData* appData) {\n-    IActor* actor = NConsole::CreateConfigsDispatcher(Config, Labels, InitialCmsConfig, InitialCmsYamlConfig, ConfigInitInfo);\n+    NKikimr::NConsole::TConfigsDispatcherInitInfo initInfo {\n+        .InitialConfig = Config,\n+        .Labels = Labels,\n+        .ItemsServeRules = std::monostate{},\n+        .DebugInfo = NKikimr::NConsole::TDebugInfo {\n+            .StaticConfig = Config,\n+            .OldDynConfig = InitialCmsConfig,\n+            .NewDynConfig = InitialCmsYamlConfig,\n+            .InitInfo = ConfigInitInfo,\n+        },\n+    };\n+    IActor* actor = NConsole::CreateConfigsDispatcher(initInfo);\n     setup->LocalServices.push_back(std::pair<TActorId, TActorSetupCmd>(\n             NConsole::MakeConfigsDispatcherID(NodeId),\n             TActorSetupCmd(actor, TMailboxType::HTSwap, appData->UserPoolId)));\ndiff --git a/ydb/core/driver_lib/run/run.cpp b/ydb/core/driver_lib/run/run.cpp\nindex f75eb3c765e9..03b8ce3c2a20 100644\n--- a/ydb/core/driver_lib/run/run.cpp\n+++ b/ydb/core/driver_lib/run/run.cpp\n@@ -584,6 +584,10 @@ void TKikimrRunner::InitializeGRpc(const TKikimrRunConfig& runConfig) {\n         TServiceCfg hasKeyValue = services.empty();\n         names[\"keyvalue\"] = &hasKeyValue;\n \n+        if (hasTableService || hasYql) {\n+            hasQueryService = true;\n+        }\n+\n         std::unordered_set<TString> enabled;\n         for (const auto& name : services) {\n             enabled.insert(name);\ndiff --git a/ydb/core/driver_lib/version/ut/CMakeLists.darwin-arm64.txt b/ydb/core/driver_lib/version/ut/CMakeLists.darwin-arm64.txt\nindex 923cb8c2f35a..340107041898 100644\n--- a/ydb/core/driver_lib/version/ut/CMakeLists.darwin-arm64.txt\n+++ b/ydb/core/driver_lib/version/ut/CMakeLists.darwin-arm64.txt\n@@ -16,6 +16,7 @@ target_link_libraries(ydb-core-driver_lib-version-ut PUBLIC\n   yutil\n   cpp-testing-unittest_main\n   version\n+  version_definition\n )\n target_link_options(ydb-core-driver_lib-version-ut PRIVATE\n   -Wl,-platform_version,macos,11.0,11.0\ndiff --git a/ydb/core/driver_lib/version/ut/CMakeLists.darwin-x86_64.txt b/ydb/core/driver_lib/version/ut/CMakeLists.darwin-x86_64.txt\nindex ff98a9080641..11879a5ca99b 100644\n--- a/ydb/core/driver_lib/version/ut/CMakeLists.darwin-x86_64.txt\n+++ b/ydb/core/driver_lib/version/ut/CMakeLists.darwin-x86_64.txt\n@@ -17,6 +17,7 @@ target_link_libraries(ydb-core-driver_lib-version-ut PUBLIC\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n   version\n+  version_definition\n )\n target_link_options(ydb-core-driver_lib-version-ut PRIVATE\n   -Wl,-platform_version,macos,11.0,11.0\ndiff --git a/ydb/core/driver_lib/version/ut/CMakeLists.linux-aarch64.txt b/ydb/core/driver_lib/version/ut/CMakeLists.linux-aarch64.txt\nindex 3ecb12cd4036..c2f3a1a268e1 100644\n--- a/ydb/core/driver_lib/version/ut/CMakeLists.linux-aarch64.txt\n+++ b/ydb/core/driver_lib/version/ut/CMakeLists.linux-aarch64.txt\n@@ -17,6 +17,7 @@ target_link_libraries(ydb-core-driver_lib-version-ut PUBLIC\n   yutil\n   cpp-testing-unittest_main\n   version\n+  version_definition\n )\n target_link_options(ydb-core-driver_lib-version-ut PRIVATE\n   -ldl\ndiff --git a/ydb/core/driver_lib/version/ut/CMakeLists.linux-x86_64.txt b/ydb/core/driver_lib/version/ut/CMakeLists.linux-x86_64.txt\nindex 999ad8804d32..6b89d73255c3 100644\n--- a/ydb/core/driver_lib/version/ut/CMakeLists.linux-x86_64.txt\n+++ b/ydb/core/driver_lib/version/ut/CMakeLists.linux-x86_64.txt\n@@ -18,6 +18,7 @@ target_link_libraries(ydb-core-driver_lib-version-ut PUBLIC\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n   version\n+  version_definition\n )\n target_link_options(ydb-core-driver_lib-version-ut PRIVATE\n   -ldl\ndiff --git a/ydb/core/driver_lib/version/ut/CMakeLists.windows-x86_64.txt b/ydb/core/driver_lib/version/ut/CMakeLists.windows-x86_64.txt\nindex f611bebb0fcc..5d3d9db541e7 100644\n--- a/ydb/core/driver_lib/version/ut/CMakeLists.windows-x86_64.txt\n+++ b/ydb/core/driver_lib/version/ut/CMakeLists.windows-x86_64.txt\n@@ -17,6 +17,7 @@ target_link_libraries(ydb-core-driver_lib-version-ut PUBLIC\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n   version\n+  version_definition\n )\n target_sources(ydb-core-driver_lib-version-ut PRIVATE\n   ${CMAKE_SOURCE_DIR}/ydb/core/driver_lib/version/ut/version_ut.cpp\ndiff --git a/ydb/core/driver_lib/version/ut/ya.make b/ydb/core/driver_lib/version/ut/ya.make\nindex 0c5a755c2a82..4b3833beacea 100644\n--- a/ydb/core/driver_lib/version/ut/ya.make\n+++ b/ydb/core/driver_lib/version/ut/ya.make\n@@ -7,6 +7,7 @@ SIZE(MEDIUM)\n \n PEERDIR(\n     ydb/core/driver_lib/version\n+    ydb/apps/version\n )\n \n END()\ndiff --git a/ydb/core/driver_lib/version/version.cpp b/ydb/core/driver_lib/version/version.cpp\nindex b57042bde71b..3852aea33897 100644\n--- a/ydb/core/driver_lib/version/version.cpp\n+++ b/ydb/core/driver_lib/version/version.cpp\n@@ -17,45 +17,14 @@ using EComponentId = NKikimrConfig::TCompatibilityRule;\n using TComponentId = NKikimrConfig::TCompatibilityRule::EComponentId;\n \n TCompatibilityInfo::TCompatibilityInfo() {\n-    using TCurrentConstructor = TCompatibilityInfo::TProtoConstructor::TCurrentCompatibilityInfo;\n     using TStoredConstructor = TCompatibilityInfo::TProtoConstructor::TStoredCompatibilityInfo;\n-    using TCompatibilityRuleConstructor = TCompatibilityInfo::TProtoConstructor::TCompatibilityRule;\n     using TVersionConstructor = TCompatibilityInfo::TProtoConstructor::TVersion;\n \n     /////////////////////////////////////////////////////////\n     // Current CompatibilityInfo\n     /////////////////////////////////////////////////////////\n \n-    auto current = TCurrentConstructor{\n-        .Application = \"ydb\",\n-        .Version = TVersionConstructor{\n-            .Year = 24,\n-            .Major = 1,\n-        },\n-        .CanLoadFrom = {\n-            TCompatibilityRuleConstructor{\n-                .LowerLimit = TVersionConstructor{ .Year = 23, .Major = 4 },\n-                .UpperLimit = TVersionConstructor{ .Year = 24, .Major = 1 },\n-            },\n-        },\n-        .StoresReadableBy = {\n-            TCompatibilityRuleConstructor{\n-                .LowerLimit = TVersionConstructor{ .Year = 23, .Major = 4 },\n-                .UpperLimit = TVersionConstructor{ .Year = 24, .Major = 1 },\n-            },\n-        },\n-        .CanConnectTo = {\n-            TCompatibilityRuleConstructor{\n-                .LowerLimit = TVersionConstructor{ .Year = 23, .Major = 4 },\n-                .UpperLimit = TVersionConstructor{ .Year = 24, .Major = 1 },\n-            },\n-            TCompatibilityRuleConstructor{\n-                .Application = \"nbs\",\n-                .LowerLimit = TVersionConstructor{ .Year = 23, .Major = 3 },\n-                .UpperLimit = TVersionConstructor{ .Year = 24, .Major = 1 },\n-            },\n-        }\n-    }.ToPB();\n+    auto current = MakeCurrent();\n \n     bool success = CompleteFromTag(current);\n     Y_UNUSED(success);\ndiff --git a/ydb/core/driver_lib/version/version.h b/ydb/core/driver_lib/version/version.h\nindex 1ecf76cb9e28..a18b2ad0cb5b 100644\n--- a/ydb/core/driver_lib/version/version.h\n+++ b/ydb/core/driver_lib/version/version.h\n@@ -141,6 +141,8 @@ class TCompatibilityInfo {\n \n     bool CompleteFromTag(NKikimrConfig::TCurrentCompatibilityInfo& current);\n \n+    static NKikimrConfig::TCurrentCompatibilityInfo MakeCurrent();\n+\n     NKikimrConfig::TStoredCompatibilityInfo MakeStored(TComponentId componentId) const;\n     NKikimrConfig::TStoredCompatibilityInfo MakeStored(TComponentId componentId,\n             const NKikimrConfig::TCurrentCompatibilityInfo* current) const;\ndiff --git a/ydb/core/kqp/executer_actor/kqp_data_executer.cpp b/ydb/core/kqp/executer_actor/kqp_data_executer.cpp\nindex b8dd4a1824ba..15fe364f8d25 100644\n--- a/ydb/core/kqp/executer_actor/kqp_data_executer.cpp\n+++ b/ydb/core/kqp/executer_actor/kqp_data_executer.cpp\n@@ -2006,16 +2006,12 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n                                     TTopicTabletTxs& topicTxs) {\n         TDatashardTxs datashardTxs;\n \n-        std::vector<ui64> affectedShardsSet;\n-        affectedShardsSet.reserve(datashardTasks.size());\n-\n         for (auto& [shardId, tasks]: datashardTasks) {\n             auto [it, success] = datashardTxs.emplace(\n                 shardId,\n                 TasksGraph.GetMeta().Allocate<NKikimrTxDataShard::TKqpTransaction>());\n \n             YQL_ENSURE(success, \"unexpected duplicates in datashard transactions\");\n-            affectedShardsSet.emplace_back(shardId);\n             NKikimrTxDataShard::TKqpTransaction* dsTxs = it->second;\n             dsTxs->MutableTasks()->Reserve(tasks.size());\n             for (auto& task: tasks) {\n@@ -2023,6 +2019,55 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n             }\n         }\n \n+        // Note: when locks map is present it will be mutated to avoid copying data\n+        auto& locksMap = Request.DataShardLocks;\n+        if (!locksMap.empty()) {\n+            YQL_ENSURE(Request.LocksOp == ELocksOp::Commit || Request.LocksOp == ELocksOp::Rollback);\n+        }\n+\n+        // Materialize (possibly empty) txs for all shards with locks (either commit or rollback)\n+        for (auto& [shardId, locksList] : locksMap) {\n+            YQL_ENSURE(!locksList.empty(), \"unexpected empty locks list in DataShardLocks\");\n+\n+            auto it = datashardTxs.find(shardId);\n+            if (it == datashardTxs.end()) {\n+                auto [emplaced, success] = datashardTxs.emplace(\n+                    shardId,\n+                    TasksGraph.GetMeta().Allocate<NKikimrTxDataShard::TKqpTransaction>());\n+\n+                YQL_ENSURE(success, \"unexpected failure to emplace a datashard transaction\");\n+                it = emplaced;\n+            }\n+\n+            NKikimrTxDataShard::TKqpTransaction* tx = it->second;\n+            switch (Request.LocksOp) {\n+                case ELocksOp::Commit:\n+                    tx->MutableLocks()->SetOp(NKikimrDataEvents::TKqpLocks::Commit);\n+                    break;\n+                case ELocksOp::Rollback:\n+                    tx->MutableLocks()->SetOp(NKikimrDataEvents::TKqpLocks::Rollback);\n+                    break;\n+                case ELocksOp::Unspecified:\n+                    break;\n+            }\n+\n+            // Move lock descriptions to the datashard tx\n+            auto* protoLocks = tx->MutableLocks()->MutableLocks();\n+            protoLocks->Reserve(locksList.size());\n+            bool hasWrites = false;\n+            for (auto& lock : locksList) {\n+                hasWrites = hasWrites || lock.GetHasWrites();\n+                protoLocks->Add(std::move(lock));\n+            }\n+            locksList.clear();\n+\n+            // When locks with writes are committed this commits accumulated effects\n+            if (Request.LocksOp == ELocksOp::Commit && hasWrites) {\n+                ShardsWithEffects.insert(shardId);\n+                YQL_ENSURE(!ReadOnlyTx);\n+            }\n+        }\n+\n         Request.TopicOperations.BuildTopicTxs(topicTxs);\n \n         const bool needRollback = Request.LocksOp == ELocksOp::Rollback;\n@@ -2042,7 +2087,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n             // TODO: add support in the future\n             topicTxs.empty() &&\n             // We only want to use volatile transactions for multiple shards\n-            (affectedShardsSet.size() + topicTxs.size()) > 1 &&\n+            (datashardTxs.size() + topicTxs.size()) > 1 &&\n             // We cannot use volatile transactions with persistent channels\n             // Note: currently persistent channels are never used\n             !HasPersistentChannels);\n@@ -2055,30 +2100,29 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n             // Transactions with topics must always use generic readsets\n             !topicTxs.empty());\n \n-        if (auto locksMap = Request.DataShardLocks;\n-            !locksMap.empty() ||\n-            VolatileTx ||\n+        if (!locksMap.empty() || VolatileTx ||\n             Request.TopicOperations.HasReadOperations())\n         {\n             YQL_ENSURE(Request.LocksOp == ELocksOp::Commit || Request.LocksOp == ELocksOp::Rollback || VolatileTx);\n \n             bool needCommit = Request.LocksOp == ELocksOp::Commit || VolatileTx;\n \n-            auto locksOp = needCommit\n-                ? NKikimrDataEvents::TKqpLocks::Commit\n-                : NKikimrDataEvents::TKqpLocks::Rollback;\n-\n             absl::flat_hash_set<ui64> sendingShardsSet;\n             absl::flat_hash_set<ui64> receivingShardsSet;\n \n             // Gather shards that need to send/receive readsets (shards with effects)\n             if (needCommit) {\n-                for (auto& shardId: affectedShardsSet) {\n+                for (auto& [shardId, tx] : datashardTxs) {\n+                    if (tx->HasLocks()) {\n+                        // Locks may be broken so shards with locks need to send readsets\n+                        sendingShardsSet.insert(shardId);\n+                    }\n                     if (ShardsWithEffects.contains(shardId)) {\n                         // Volatile transactions may abort effects, so they send readsets\n                         if (VolatileTx) {\n                             sendingShardsSet.insert(shardId);\n                         }\n+                        // Effects are only applied when all locks are valid\n                         receivingShardsSet.insert(shardId);\n                     }\n                 }\n@@ -2093,44 +2137,7 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n                 }\n             }\n \n-            // Gather locks that need to be committed or erased\n-            for (auto& [shardId, locksList] : locksMap) {\n-                NKikimrTxDataShard::TKqpTransaction* tx = nullptr;\n-                auto it = datashardTxs.find(shardId);\n-                if (it != datashardTxs.end()) {\n-                    tx = it->second;\n-                } else {\n-                    auto [eIt, success] = datashardTxs.emplace(\n-                        shardId,\n-                        TasksGraph.GetMeta().Allocate<NKikimrTxDataShard::TKqpTransaction>());\n-                    tx = eIt->second;\n-                }\n-\n-                tx->MutableLocks()->SetOp(locksOp);\n-\n-                if (!locksList.empty()) {\n-                    auto* protoLocks = tx->MutableLocks()->MutableLocks();\n-                    protoLocks->Reserve(locksList.size());\n-                    bool hasWrites = false;\n-                    for (auto& lock : locksList) {\n-                        hasWrites = hasWrites || lock.GetHasWrites();\n-                        protoLocks->Add()->Swap(&lock);\n-                    }\n-\n-                    if (needCommit) {\n-                        // We also send the result on commit\n-                        sendingShardsSet.insert(shardId);\n-\n-                        if (hasWrites) {\n-                            // Tx with uncommitted changes can be aborted due to conflicts,\n-                            // so shards with write locks should receive readsets\n-                            receivingShardsSet.insert(shardId);\n-                            YQL_ENSURE(!ReadOnlyTx);\n-                        }\n-                    }\n-                }\n-            }\n-\n+            // Encode sending/receiving shards in tx bodies\n             if (needCommit) {\n                 NProtoBuf::RepeatedField<ui64> sendingShards(sendingShardsSet.begin(), sendingShardsSet.end());\n                 NProtoBuf::RepeatedField<ui64> receivingShards(receivingShardsSet.begin(), receivingShardsSet.end());\n@@ -2139,23 +2146,13 @@ class TKqpDataExecuter : public TKqpExecuterBase<TKqpDataExecuter, EExecType::Da\n                 std::sort(receivingShards.begin(), receivingShards.end());\n \n                 for (auto& [shardId, shardTx] : datashardTxs) {\n-                    shardTx->MutableLocks()->SetOp(locksOp);\n+                    shardTx->MutableLocks()->SetOp(NKikimrDataEvents::TKqpLocks::Commit);\n                     *shardTx->MutableLocks()->MutableSendingShards() = sendingShards;\n                     *shardTx->MutableLocks()->MutableReceivingShards() = receivingShards;\n                 }\n \n                 for (auto& [_, tx] : topicTxs) {\n-                    switch (locksOp) {\n-                    case NKikimrDataEvents::TKqpLocks::Commit:\n-                        tx.SetOp(NKikimrPQ::TDataTransaction::Commit);\n-                        break;\n-                    case NKikimrDataEvents::TKqpLocks::Rollback:\n-                        tx.SetOp(NKikimrPQ::TDataTransaction::Rollback);\n-                        break;\n-                    case NKikimrDataEvents::TKqpLocks::Unspecified:\n-                        break;\n-                    }\n-\n+                    tx.SetOp(NKikimrPQ::TDataTransaction::Commit);\n                     *tx.MutableSendingShards() = sendingShards;\n                     *tx.MutableReceivingShards() = receivingShards;\n                 }\ndiff --git a/ydb/core/kqp/proxy_service/kqp_proxy_ut.cpp b/ydb/core/kqp/proxy_service/kqp_proxy_ut.cpp\nindex 3e090a42c665..e88af0455f22 100644\n--- a/ydb/core/kqp/proxy_service/kqp_proxy_ut.cpp\n+++ b/ydb/core/kqp/proxy_service/kqp_proxy_ut.cpp\n@@ -492,8 +492,8 @@ Y_UNIT_TEST_SUITE(KqpProxy) {\n \n     Y_UNIT_TEST(ExecuteScriptFailsWithoutFeatureFlag) {\n         NKikimrConfig::TAppConfig appConfig;\n+        appConfig.MutableFeatureFlags()->SetEnableScriptExecutionOperations(false);\n         NYdb::TKikimrWithGrpcAndRootSchema server(appConfig);\n-        appConfig.MutableFeatureFlags()->SetEnableScriptExecutionOperations(false); // default\n         server.Server_->GetRuntime()->SetLogPriority(NKikimrServices::KQP_PROXY, NActors::NLog::PRI_DEBUG);\n \n         ui16 grpc = server.GetPort();\ndiff --git a/ydb/core/kqp/ut/view/view_ut.cpp b/ydb/core/kqp/ut/view/view_ut.cpp\nindex cfd6adf5c654..3a74e319bef7 100644\n--- a/ydb/core/kqp/ut/view/view_ut.cpp\n+++ b/ydb/core/kqp/ut/view/view_ut.cpp\n@@ -316,6 +316,24 @@ Y_UNIT_TEST_SUITE(TKQPViewTest) {\n             UNIT_ASSERT(dropResult.GetIssues().ToString().Contains(\"Error: Path does not exist\"));\n         }\n     }\n+\n+    Y_UNIT_TEST(ContextPollution) {\n+        TKikimrRunner kikimr(TKikimrSettings().SetWithSampleTables(false));\n+        EnableViewsFeatureFlag(kikimr);\n+        auto session = kikimr.GetTableClient().CreateSession().GetValueSync().GetSession();\n+\n+        ExecuteDataDefinitionQuery(session, R\"(\n+            CREATE VIEW InnerView WITH (security_invoker = TRUE) AS SELECT 1;\n+        )\");\n+        ExecuteDataDefinitionQuery(session, R\"(\n+            CREATE VIEW OuterView WITH (security_invoker = TRUE) AS SELECT * FROM InnerView;\n+        )\");\n+        \n+        ExecuteDataDefinitionQuery(session, R\"(\n+            DROP VIEW OuterView;\n+            CREATE VIEW OuterView WITH (security_invoker = TRUE) AS SELECT * FROM InnerView;\n+        )\");\n+    }\n }\n \n Y_UNIT_TEST_SUITE(TSelectFromViewTest) {\ndiff --git a/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.darwin-arm64.txt b/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.darwin-arm64.txt\nindex a58014c2f253..681c447ff2b1 100644\n--- a/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.darwin-arm64.txt\n+++ b/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.darwin-arm64.txt\n@@ -15,6 +15,7 @@ target_link_libraries(ydb-core-mind-bscontroller-ut_selfheal PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n   cpp-testing-unittest_main\n+  version_definition\n   blobstorage-dsproxy-mock\n   blobstorage-pdisk-mock\n   core-mind-bscontroller\ndiff --git a/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.darwin-x86_64.txt b/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.darwin-x86_64.txt\nindex 556785ce5eec..a971d8b38b01 100644\n--- a/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.darwin-x86_64.txt\n+++ b/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.darwin-x86_64.txt\n@@ -16,6 +16,7 @@ target_link_libraries(ydb-core-mind-bscontroller-ut_selfheal PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n+  version_definition\n   blobstorage-dsproxy-mock\n   blobstorage-pdisk-mock\n   core-mind-bscontroller\ndiff --git a/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.linux-aarch64.txt b/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.linux-aarch64.txt\nindex e70a88c2eace..573524420487 100644\n--- a/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.linux-aarch64.txt\n+++ b/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.linux-aarch64.txt\n@@ -16,6 +16,7 @@ target_link_libraries(ydb-core-mind-bscontroller-ut_selfheal PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n   cpp-testing-unittest_main\n+  version_definition\n   blobstorage-dsproxy-mock\n   blobstorage-pdisk-mock\n   core-mind-bscontroller\ndiff --git a/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.linux-x86_64.txt b/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.linux-x86_64.txt\nindex 85bda2ed3f1a..e919aa17cbc2 100644\n--- a/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.linux-x86_64.txt\n+++ b/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.linux-x86_64.txt\n@@ -17,6 +17,7 @@ target_link_libraries(ydb-core-mind-bscontroller-ut_selfheal PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n+  version_definition\n   blobstorage-dsproxy-mock\n   blobstorage-pdisk-mock\n   core-mind-bscontroller\ndiff --git a/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.windows-x86_64.txt b/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.windows-x86_64.txt\nindex 8b59fa168205..3b6a02137fe6 100644\n--- a/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.windows-x86_64.txt\n+++ b/ydb/core/mind/bscontroller/ut_selfheal/CMakeLists.windows-x86_64.txt\n@@ -16,6 +16,7 @@ target_link_libraries(ydb-core-mind-bscontroller-ut_selfheal PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n+  version_definition\n   blobstorage-dsproxy-mock\n   blobstorage-pdisk-mock\n   core-mind-bscontroller\ndiff --git a/ydb/core/mind/bscontroller/ut_selfheal/ya.make b/ydb/core/mind/bscontroller/ut_selfheal/ya.make\nindex c3b4ba285713..1189fc7e7025 100644\n--- a/ydb/core/mind/bscontroller/ut_selfheal/ya.make\n+++ b/ydb/core/mind/bscontroller/ut_selfheal/ya.make\n@@ -16,6 +16,7 @@ SRCS(\n )\n \n PEERDIR(\n+    ydb/apps/version\n     ydb/core/blobstorage/dsproxy/mock\n     ydb/core/blobstorage/pdisk/mock\n     ydb/core/mind/bscontroller\ndiff --git a/ydb/core/persqueue/writer/partition_chooser_impl__abstract_chooser_actor.h b/ydb/core/persqueue/writer/partition_chooser_impl__abstract_chooser_actor.h\nindex 4b385f779cda..0e975c6cec67 100644\n--- a/ydb/core/persqueue/writer/partition_chooser_impl__abstract_chooser_actor.h\n+++ b/ydb/core/persqueue/writer/partition_chooser_impl__abstract_chooser_actor.h\n@@ -207,7 +207,7 @@ class TAbstractPartitionChooserActor: public TActorBootstrapped<TDerived> {\n         TRACE_EVENT(NKikimrServices::PQ_PARTITION_CHOOSER);\n         switch (ev->GetTypeRewrite()) {\n             HFunc(NKqp::TEvKqp::TEvQueryResponse, HandleUpdate);\n-            sFunc(TEvents::TEvPoison, ScheduleStop);\n+            SFunc(TEvents::TEvPoison, TThis::Die);\n         }\n     }\n \n@@ -237,7 +237,7 @@ class TAbstractPartitionChooserActor: public TActorBootstrapped<TDerived> {\n             HFunc(NKikimr::TEvPQ::TEvCheckPartitionStatusResponse, Handle);\n             HFunc(TEvTabletPipe::TEvClientConnected, HandleOwnership);\n             HFunc(TEvTabletPipe::TEvClientDestroyed, HandleOwnership);\n-            sFunc(TEvents::TEvPoison, ScheduleStop);\n+            SFunc(TEvents::TEvPoison, TThis::Die);\n         }\n     }\n \ndiff --git a/ydb/core/tx/datashard/datashard.cpp b/ydb/core/tx/datashard/datashard.cpp\nindex 6b10f4632c76..314060536c8e 100644\n--- a/ydb/core/tx/datashard/datashard.cpp\n+++ b/ydb/core/tx/datashard/datashard.cpp\n@@ -2952,13 +2952,13 @@ void TDataShard::Handle(TEvPrivate::TEvDelayedProposeTransaction::TPtr &ev, cons\n                     kind, TabletID(), txId,\n                     NKikimrTxDataShard::TEvProposeTransactionResult::CANCELLED);\n                 ctx.Send(target, result, 0, cookie);\n-                return;\n+                break;\n             }\n             case NEvents::TDataEvents::TEvWrite::EventType: {\n                 auto* msg = item.Event->Get<NEvents::TDataEvents::TEvWrite>();\n                 auto result = NEvents::TDataEvents::TEvWriteResult::BuildError(TabletID(), msg->GetTxId(), NKikimrDataEvents::TEvWriteResult::STATUS_CANCELLED, \"Canceled\");\n                 ctx.Send(target, result.release(), 0, cookie);\n-                return;\n+                break;\n             }\n             default:\n                 Y_FAIL_S(\"Unexpected event type \" << item.Event->GetTypeRewrite());\ndiff --git a/ydb/core/tx/datashard/datashard__read_iterator.cpp b/ydb/core/tx/datashard/datashard__read_iterator.cpp\nindex 928592a56959..bb4fbe8de801 100644\n--- a/ydb/core/tx/datashard/datashard__read_iterator.cpp\n+++ b/ydb/core/tx/datashard/datashard__read_iterator.cpp\n@@ -665,6 +665,10 @@ class TReader {\n             }\n         }\n \n+        if (record.TxLocksSize() > 0 || record.BrokenTxLocksSize() > 0) {\n+            useful = true;\n+        }\n+\n         Self->IncCounter(COUNTER_READ_ITERATOR_ROWS_READ, RowsRead);\n         if (!isKeysRequest) {\n             Self->IncCounter(COUNTER_ENGINE_HOST_SELECT_RANGE_ROW_SKIPS, DeletedRowSkips);\n@@ -2490,9 +2494,9 @@ class TDataShard::TTxReadContinue : public NTabletFlatExecutor::TTransactionBase\n         if (record.HasStatus()) {\n             record.SetSeqNo(state.SeqNo + 1);\n             record.SetReadId(readId.ReadId);\n-            Self->SendImmediateReadResult(request->Reader, Result.release(), 0, state.SessionId);\n             LOG_DEBUG_S(ctx, NKikimrServices::TX_DATASHARD, Self->TabletID() << \" read iterator# \" << readId\n                 << \" TTxReadContinue::Execute() finished with error, aborting: \" << record.DebugString());\n+            Self->SendImmediateReadResult(request->Reader, Result.release(), 0, state.SessionId);\n \n             state.Request->ReadSpan.EndError(\"Finished with error\");\n             Self->DeleteReadIterator(it);\ndiff --git a/ydb/core/tx/datashard/datashard_active_transaction.cpp b/ydb/core/tx/datashard/datashard_active_transaction.cpp\nindex a4a2c4ea5b5a..745010c5401d 100644\n--- a/ydb/core/tx/datashard/datashard_active_transaction.cpp\n+++ b/ydb/core/tx/datashard/datashard_active_transaction.cpp\n@@ -404,7 +404,7 @@ TValidatedDataTx::TPtr TActiveTransaction::BuildDataTx(TDataShard *self,\n     if (!DataTx) {\n         Y_ABORT_UNLESS(TxBody);\n         DataTx = std::make_shared<TValidatedDataTx>(self, txc, ctx, GetStepOrder(),\n-                                                    GetReceivedAt(), TxBody, MvccSnapshotRepeatable);\n+                                                    GetReceivedAt(), TxBody, IsMvccSnapshotRepeatable());\n         if (DataTx->HasStreamResponse())\n             SetStreamSink(DataTx->GetSink());\n     }\n@@ -635,7 +635,7 @@ ERestoreDataStatus TActiveTransaction::RestoreTxData(\n \n     bool extractKeys = DataTx->IsTxInfoLoaded();\n     DataTx = std::make_shared<TValidatedDataTx>(self, txc, ctx, GetStepOrder(),\n-                                                GetReceivedAt(), TxBody, MvccSnapshotRepeatable);\n+                                                GetReceivedAt(), TxBody, IsMvccSnapshotRepeatable());\n     if (DataTx->Ready() && extractKeys) {\n         DataTx->ExtractKeys(true);\n     }\ndiff --git a/ydb/core/tx/datashard/datashard_ut_common_kqp.h b/ydb/core/tx/datashard/datashard_ut_common_kqp.h\nindex d7182e08e3da..de0e2ef7a24d 100644\n--- a/ydb/core/tx/datashard/datashard_ut_common_kqp.h\n+++ b/ydb/core/tx/datashard/datashard_ut_common_kqp.h\n@@ -42,7 +42,7 @@ namespace NKqpHelpers {\n     inline TString CreateSessionRPC(TTestActorRuntime& runtime, const TString& database = {}) {\n         Ydb::Table::CreateSessionRequest request;\n         auto future = NRpcService::DoLocalRpc<TEvCreateSessionRequest>(\n-           std::move(request), database, \"\", /* token */ runtime.GetActorSystem(0));\n+           std::move(request), database, /* token */ \"\", runtime.GetActorSystem(0));\n         TString sessionId;\n         auto response = AwaitResponse(runtime, future);\n         UNIT_ASSERT_VALUES_EQUAL(response.operation().status(), Ydb::StatusIds::SUCCESS);\n@@ -71,7 +71,7 @@ namespace NKqpHelpers {\n         TTestActorRuntime& runtime, Ydb::Table::ExecuteDataQueryRequest&& request, const TString& database = {})\n     {\n         return NRpcService::DoLocalRpc<TEvExecuteDataQueryRequest>(\n-            std::move(request), database, \"\" /* token */, runtime.GetActorSystem(0));\n+            std::move(request), database, /* token */ \"\", runtime.GetActorSystem(0));\n     }\n \n     inline Ydb::Table::ExecuteDataQueryRequest MakeSimpleRequestRPC(\n@@ -119,7 +119,7 @@ namespace NKqpHelpers {\n         Ydb::Table::DeleteSessionRequest request;\n         request.set_session_id(sessionId);\n         auto future = NRpcService::DoLocalRpc<TEvDeleteSessionRequest>(\n-            std::move(request), \"\", \"\", /* token */ runtime.GetActorSystem(0));\n+            std::move(request), \"\", /* token */ \"\", runtime.GetActorSystem(0));\n     }\n \n     inline THolder<NKqp::TEvKqp::TEvQueryRequest> MakeStreamRequest(\n@@ -168,17 +168,15 @@ namespace NKqpHelpers {\n         return FormatResult(result);\n     }\n \n-    inline TString KqpSimpleExec(TTestActorRuntime& runtime, const TString& query, bool staleRo = false, const TString& database = {}) {\n+    inline auto KqpSimpleSend(TTestActorRuntime& runtime, const TString& query, bool staleRo = false, const TString& database = {}) {\n         TString sessionId = CreateSessionRPC(runtime, database);\n         TString txId;\n-        auto response = AwaitResponse(\n-            runtime, SendRequest(runtime, MakeSimpleRequestRPC(query, sessionId, txId, true /* commitTx */, staleRo), database));\n-        if (response.operation().status() != Ydb::StatusIds::SUCCESS) {\n-            return TStringBuilder() << \"ERROR: \" << response.operation().status();\n-        }\n-        Ydb::Table::ExecuteQueryResult result;\n-        response.operation().result().UnpackTo(&result);\n-        return FormatResult(result);\n+        return SendRequest(runtime, MakeSimpleRequestRPC(query, sessionId, txId, /* commitTx */ true, staleRo), database);\n+    }\n+\n+    inline TString KqpSimpleExec(TTestActorRuntime& runtime, const TString& query, bool staleRo = false, const TString& database = {}) {\n+        auto response = AwaitResponse(runtime, KqpSimpleSend(runtime, query, staleRo, database));\n+        return FormatResult(response);\n     }\n \n     inline TString KqpSimpleStaleRoExec(TTestActorRuntime& runtime, const TString& query, const TString& database = {}) {\ndiff --git a/ydb/core/tx/datashard/datashard_ut_order.cpp b/ydb/core/tx/datashard/datashard_ut_order.cpp\nindex ee1af9e056c1..4f58e3fe804f 100644\n--- a/ydb/core/tx/datashard/datashard_ut_order.cpp\n+++ b/ydb/core/tx/datashard/datashard_ut_order.cpp\n@@ -4279,6 +4279,7 @@ Y_UNIT_TEST(UncommittedReadSetAck) {\n \n     bool capturePlanSteps = true;\n     TVector<THolder<IEventHandle>> capturedPlanSteps;\n+    TVector<ui64> capturedPlanTxIds;\n     THashSet<ui64> passReadSetTxIds;\n     ui64 observedReadSets = 0;\n     TVector<THolder<IEventHandle>> capturedReadSets;\n@@ -4294,6 +4295,12 @@ Y_UNIT_TEST(UncommittedReadSetAck) {\n             case TEvTxProcessing::TEvPlanStep::EventType: {\n                 if (nodeIndex == 1 && ev->GetRecipientRewrite() == table3actor && capturePlanSteps) {\n                     Cerr << \"... captured plan step for table-3\" << Endl;\n+                    auto* msg = ev->Get<TEvTxProcessing::TEvPlanStep>();\n+                    for (const auto& tx : msg->Record.GetTransactions()) {\n+                        ui64 txId = tx.GetTxId();\n+                        capturedPlanTxIds.push_back(txId);\n+                        Cerr << \"... captured plan step tx \" << txId << \" for table-3\" << Endl;\n+                    }\n                     capturedPlanSteps.emplace_back(ev.Release());\n                     return TTestActorRuntime::EEventAction::DROP;\n                 }\n@@ -4303,6 +4310,12 @@ Y_UNIT_TEST(UncommittedReadSetAck) {\n                 if (nodeIndex == 1 && ev->GetRecipientRewrite() == table3actor) {\n                     auto* msg = ev->Get<TEvTxProcessing::TEvReadSet>();\n                     ui64 txId = msg->Record.GetTxId();\n+                    if ((msg->Record.GetFlags() & NKikimrTx::TEvReadSet::FLAG_EXPECT_READSET) &&\n+                        (msg->Record.GetFlags() & NKikimrTx::TEvReadSet::FLAG_NO_DATA))\n+                    {\n+                        Cerr << \"... passing expectation for txid# \" << txId << Endl;\n+                        break;\n+                    }\n                     ++observedReadSets;\n                     if (!passReadSetTxIds.contains(txId)) {\n                         Cerr << \"... readset for txid# \" << txId << \" was blocked\" << Endl;\n@@ -4353,20 +4366,11 @@ Y_UNIT_TEST(UncommittedReadSetAck) {\n         }\n     };\n \n-    waitFor([&]{ return capturedPlanSteps.size() > 0; }, \"plan step\");\n-    UNIT_ASSERT_VALUES_EQUAL(capturedPlanSteps.size(), 1u);\n-    ui64 realTxId1, realTxId2;\n-    {\n-        auto* msg = capturedPlanSteps[0]->Get<TEvTxProcessing::TEvPlanStep>();\n-        TVector<ui64> realTxIds;\n-        for (const auto& tx : msg->Record.GetTransactions()) {\n-            realTxIds.emplace_back(tx.GetTxId());\n-        }\n-        UNIT_ASSERT_VALUES_EQUAL(realTxIds.size(), 2u);\n-        std::sort(realTxIds.begin(), realTxIds.end());\n-        realTxId1 = realTxIds.at(0);\n-        realTxId2 = realTxIds.at(1);\n-    }\n+    waitFor([&]{ return capturedPlanTxIds.size() >= 2; }, \"captured transactions\");\n+    UNIT_ASSERT_C(capturedPlanTxIds.size(), 2u);\n+    std::sort(capturedPlanTxIds.begin(), capturedPlanTxIds.end());\n+    ui64 realTxId1 = capturedPlanTxIds.at(0);\n+    ui64 realTxId2 = capturedPlanTxIds.at(1);\n \n     // Unblock and resend the plan step message\n     capturePlanSteps = false;\n@@ -4375,7 +4379,7 @@ Y_UNIT_TEST(UncommittedReadSetAck) {\n     }\n     capturedPlanSteps.clear();\n \n-    // Wait until there are 2 readset messages\n+    // Wait until there are 2 readset messages (with data)\n     waitFor([&]{ return capturedReadSets.size() >= 2; }, \"initial readsets\");\n     SimulateSleep(runtime, TDuration::MilliSeconds(5));\n \ndiff --git a/ydb/core/tx/datashard/datashard_ut_read_iterator.cpp b/ydb/core/tx/datashard/datashard_ut_read_iterator.cpp\nindex 044080f8d711..876f58415ad0 100644\n--- a/ydb/core/tx/datashard/datashard_ut_read_iterator.cpp\n+++ b/ydb/core/tx/datashard/datashard_ut_read_iterator.cpp\n@@ -21,6 +21,7 @@\n namespace NKikimr {\n \n using namespace NKikimr::NDataShard;\n+using namespace NKikimr::NDataShard::NKqpHelpers;\n using namespace NSchemeShard;\n using namespace Tests;\n \n@@ -348,7 +349,7 @@ struct TTestHelper {\n         auto &runtime = *Server->GetRuntime();\n         Sender = runtime.AllocateEdgeActor();\n \n-        runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_NOTICE);\n+        runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_TRACE);\n         runtime.SetLogPriority(NKikimrServices::TX_PROXY, NLog::PRI_INFO);\n \n         InitRoot(Server, Sender);\n@@ -818,7 +819,11 @@ struct TTestHelper {\n                     break;\n                 }\n                 case TEvTxProcessing::EvReadSet: {\n-                    if (dropRS) {\n+                    auto* msg = event->Get<TEvTxProcessing::TEvReadSet>();\n+                    auto flags = msg->Record.GetFlags();\n+                    auto isExpect = flags & NKikimrTx::TEvReadSet::FLAG_EXPECT_READSET;\n+                    auto isNoData = flags & NKikimrTx::TEvReadSet::FLAG_NO_DATA;\n+                    if (dropRS && !(isExpect && isNoData)) {\n                         result.ReadSets.push_back(std::move(event));\n                         return TTestActorRuntime::EEventAction::DROP;\n                     }\n@@ -852,7 +857,10 @@ struct TTestHelper {\n             )\"));\n         }\n \n-        waitFor([&]{ return result.ReadSets.size() == 1; }, \"intercepted RS\");\n+        const bool usesVolatileTxs = runtime.GetAppData(0).FeatureFlags.GetEnableDataShardVolatileTransactions();\n+        const size_t expectedReadSets = 1 + (finalUpserts && usesVolatileTxs ? 2 : 0);\n+\n+        waitFor([&]{ return result.ReadSets.size() == expectedReadSets; }, \"intercepted RS\");\n \n         // restore original observer (note we used lambda function and stack variables)\n         Server->GetRuntime()->SetObserverFunc(prevObserverFunc);\n@@ -2576,7 +2584,9 @@ Y_UNIT_TEST_SUITE(DataShardReadIterator) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n         serverSettings.SetDomainName(\"Root\")\n-            .SetUseRealThreads(false);\n+            .SetUseRealThreads(false)\n+            // Blocked volatile transactions block reads, disable\n+            .SetEnableDataShardVolatileTransactions(false);\n \n         const ui64 shardCount = 1;\n         TTestHelper helper(serverSettings, shardCount);\n@@ -3600,7 +3610,7 @@ Y_UNIT_TEST_SUITE(DataShardReadIteratorPageFaults) {\n         auto& runtime = *server->GetRuntime();\n         auto sender = runtime.AllocateEdgeActor();\n \n-        runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_NOTICE);\n+        runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_TRACE);\n         runtime.SetLogPriority(NKikimrServices::TX_PROXY, NLog::PRI_INFO);\n         // runtime.SetLogPriority(NKikimrServices::TABLET_EXECUTOR, NLog::PRI_DEBUG);\n \n@@ -3680,6 +3690,83 @@ Y_UNIT_TEST_SUITE(DataShardReadIteratorPageFaults) {\n         // We should be able to drop table\n         WaitTxNotification(server, AsyncDropTable(server, sender, \"/Root\", \"table-1\"));\n     }\n+\n+    Y_UNIT_TEST(LocksNotLostOnPageFault) {\n+        TPortManager pm;\n+        NFake::TCaches caches;\n+        caches.Shared = 1 /* bytes */;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings.SetDomainName(\"Root\")\n+            .SetUseRealThreads(false)\n+            .SetCacheParams(caches);\n+        TServer::TPtr server = new TServer(serverSettings);\n+\n+        auto& runtime = *server->GetRuntime();\n+        auto sender = runtime.AllocateEdgeActor();\n+\n+        runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_TRACE);\n+\n+        InitRoot(server, sender);\n+\n+        TDisableDataShardLogBatching disableDataShardLogBatching;\n+\n+        // Use a policy that forces very small page sizes, effectively making each row on its own page\n+        NLocalDb::TCompactionPolicyPtr policy = NLocalDb::CreateDefaultTablePolicy();\n+        policy->MinDataPageSize = 1;\n+\n+        auto opts = TShardedTableOptions()\n+                .Columns({{\"key\", \"Int32\", true, false},\n+                          {\"index\", \"Int32\", true, false},\n+                          {\"value\", \"Int32\", false, false}})\n+                .Policy(policy.Get())\n+                .ExecutorCacheSize(1 /* byte */);\n+        auto [shards, tableId] = CreateShardedTable(server, sender, \"/Root\", \"table-1\", opts);\n+\n+        ExecSQL(server, sender, \"UPSERT INTO `/Root/table-1` (key, index, value) VALUES (1, 0, 10), (3, 0, 30), (5, 0, 50), (7, 0, 70), (9, 0, 90);\");\n+        runtime.SimulateSleep(TDuration::Seconds(1));\n+\n+        const auto shard1 = shards.at(0);\n+        CompactTable(runtime, shard1, tableId, false);\n+        RebootTablet(runtime, shard1, sender);\n+        runtime.SimulateSleep(TDuration::Seconds(1));\n+\n+        // Start a write transaction that has uncommitted write to key (2, 0)\n+        // This is because read iterator measures \"work\" in processed/skipped rows, so we have to give it something\n+        TString writeSessionId, writeTxId;\n+        UNIT_ASSERT_VALUES_EQUAL(\n+            KqpSimpleBegin(runtime, writeSessionId, writeTxId, R\"(\n+                UPSERT INTO `/Root/table-1` (key, index, value) VALUES (2, 0, 20), (4, 0, 40);\n+\n+                SELECT key, index, value FROM `/Root/table-1`\n+                WHERE key = 2\n+                ORDER BY key, index;\n+                )\"),\n+            \"{ items { int32_value: 2 } items { int32_value: 0 } items { int32_value: 20 } }\");\n+\n+        // Start a read transaction with several range read in a specific order\n+        // The first two prefixes don't exist (nothing committed yet)\n+        // The other two prefixes are supposed to page fault\n+        TString sessionId, txId;\n+        UNIT_ASSERT_VALUES_EQUAL(\n+            KqpSimpleBegin(runtime, sessionId, txId, R\"(\n+                SELECT key, index, value FROM `/Root/table-1`\n+                WHERE key IN (2, 4, 7, 9)\n+                ORDER BY key, index;\n+                )\"),\n+            \"{ items { int32_value: 7 } items { int32_value: 0 } items { int32_value: 70 } }, \"\n+            \"{ items { int32_value: 9 } items { int32_value: 0 } items { int32_value: 90 } }\");\n+\n+        // Commit the first transaction, it must succeed\n+        UNIT_ASSERT_VALUES_EQUAL(\n+            KqpSimpleCommit(runtime, writeSessionId, writeTxId, \"SELECT 1;\"),\n+            \"{ items { int32_value: 1 } }\");\n+\n+        // Commit the second transaction with a new upsert, it must not succeed\n+        UNIT_ASSERT_VALUES_EQUAL(\n+            KqpSimpleCommit(runtime, sessionId, txId,\n+                \"UPSERT INTO `/Root/table-1` (key, index, value) VALUES (2, 0, 22);\"),\n+            \"ERROR: ABORTED\");\n+    }\n }\n \n } // namespace NKikimr\ndiff --git a/ydb/core/tx/datashard/datashard_ut_rs.cpp b/ydb/core/tx/datashard/datashard_ut_rs.cpp\nindex 1f6ca976a929..b15784d66c22 100644\n--- a/ydb/core/tx/datashard/datashard_ut_rs.cpp\n+++ b/ydb/core/tx/datashard/datashard_ut_rs.cpp\n@@ -48,7 +48,10 @@ struct IsReadSet {\n     {\n         if (ev.GetTypeRewrite() == TEvTxProcessing::EvReadSet) {\n             auto &rec = ev.Get<TEvTxProcessing::TEvReadSet>()->Record;\n-            if (rec.GetTabletSource() == Source && rec.GetTabletDest() == Dest) {\n+            bool isExpectation = (\n+                (rec.GetFlags() & NKikimrTx::TEvReadSet::FLAG_EXPECT_READSET) &&\n+                (rec.GetFlags() & NKikimrTx::TEvReadSet::FLAG_NO_DATA));\n+            if (rec.GetTabletSource() == Source && rec.GetTabletDest() == Dest && !isExpectation) {\n                 return true;\n             }\n         }\n@@ -64,7 +67,9 @@ Y_UNIT_TEST_SUITE(TDataShardRSTest) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n         serverSettings.SetDomainName(\"Root\")\n-            .SetUseRealThreads(false);\n+            .SetUseRealThreads(false)\n+            // Volatile transactions avoid storing readsets in InReadSets table\n+            .SetEnableDataShardVolatileTransactions(false);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -250,7 +255,13 @@ Y_UNIT_TEST_SUITE(TDataShardRSTest) {\n         TPortManager pm;\n         TServerSettings serverSettings(pm.GetPort(2134));\n         serverSettings.SetDomainName(\"Root\")\n-            .SetUseRealThreads(false);\n+            .SetUseRealThreads(false)\n+            // This test expects rs acks to be delayed during one of restarts,\n+            // which doesn't happen with volatile transactions. With volatile\n+            // transactions both upserts have already executed, one of them is\n+            // just waiting for confirmation before making changes visible.\n+            // Since acks are not delayed they are just gone when dropped.\n+            .SetEnableDataShardVolatileTransactions(false);\n \n         Tests::TServer::TPtr server = new TServer(serverSettings);\n         auto &runtime = *server->GetRuntime();\n@@ -278,7 +289,10 @@ Y_UNIT_TEST_SUITE(TDataShardRSTest) {\n         auto captureRS = [shard1,shard3](TAutoPtr<IEventHandle> &event) -> auto {\n             if (event->GetTypeRewrite() == TEvTxProcessing::EvReadSet) {\n                 auto &rec = event->Get<TEvTxProcessing::TEvReadSet>()->Record;\n-                if (rec.GetTabletSource() == shard1) {\n+                bool isExpectation = (\n+                    (rec.GetFlags() & NKikimrTx::TEvReadSet::FLAG_EXPECT_READSET) &&\n+                    (rec.GetFlags() & NKikimrTx::TEvReadSet::FLAG_NO_DATA));\n+                if (rec.GetTabletSource() == shard1 && !isExpectation) {\n                     return TTestActorRuntime::EEventAction::DROP;\n                 }\n             } else if (event->GetTypeRewrite() == TEvTxProcessing::EvReadSetAck) {\n@@ -359,6 +373,9 @@ Y_UNIT_TEST_SUITE(TDataShardRSTest) {\n             switch (ev->GetTypeRewrite()) {\n                 case TEvTxProcessing::TEvReadSet::EventType: {\n                     auto* msg = ev->Get<TEvTxProcessing::TEvReadSet>();\n+                    if (msg->Record.GetFlags() & NKikimrTx::TEvReadSet::FLAG_NO_DATA) {\n+                        break;\n+                    }\n                     NKikimrTx::TReadSetData genericData;\n                     Y_ABORT_UNLESS(genericData.ParseFromString(msg->Record.GetReadSet()));\n                     Cerr << \"... generic readset: \" << genericData.DebugString() << Endl;\n@@ -419,6 +436,13 @@ Y_UNIT_TEST_SUITE(TDataShardRSTest) {\n             switch (ev->GetTypeRewrite()) {\n                 case TEvTxProcessing::TEvReadSet::EventType: {\n                     auto* msg = ev->Get<TEvTxProcessing::TEvReadSet>();\n+                    if (msg->Record.GetFlags() & NKikimrTx::TEvReadSet::FLAG_NO_DATA) {\n+                        if (!(msg->Record.GetFlags() & NKikimrTx::TEvReadSet::FLAG_EXPECT_READSET)) {\n+                            Cerr << \"... nodata readset\" << Endl;\n+                            ++readSets;\n+                        }\n+                        break;\n+                    }\n                     NKikimrTx::TReadSetData genericData;\n                     Y_ABORT_UNLESS(genericData.ParseFromString(msg->Record.GetReadSet()));\n                     Cerr << \"... generic readset: \" << genericData.DebugString() << Endl;\ndiff --git a/ydb/core/tx/datashard/datashard_ut_volatile.cpp b/ydb/core/tx/datashard/datashard_ut_volatile.cpp\nindex 9d12f0ee2deb..c5eff03c43b3 100644\n--- a/ydb/core/tx/datashard/datashard_ut_volatile.cpp\n+++ b/ydb/core/tx/datashard/datashard_ut_volatile.cpp\n@@ -2214,6 +2214,189 @@ Y_UNIT_TEST_SUITE(DataShardVolatile) {\n             \"{ items { uint32_value: 4 } items { uint32_value: 40 } }\");\n     }\n \n+    Y_UNIT_TEST(TwoAppendsMustBeVolatile) {\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings.SetDomainName(\"Root\")\n+            .SetNodeCount(2)\n+            .SetUseRealThreads(false)\n+            .SetDomainPlanResolution(100)\n+            .SetEnableDataShardVolatileTransactions(true);\n+\n+        Tests::TServer::TPtr server = new TServer(serverSettings);\n+        auto &runtime = *server->GetRuntime();\n+        auto sender = runtime.AllocateEdgeActor();\n+\n+        runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_TRACE);\n+        runtime.SetLogPriority(NKikimrServices::TX_PROXY, NLog::PRI_DEBUG);\n+        runtime.SetLogPriority(NKikimrServices::KQP_EXECUTER, NLog::PRI_TRACE);\n+        runtime.SetLogPriority(NKikimrServices::KQP_SESSION, NLog::PRI_TRACE);\n+\n+        InitRoot(server, sender);\n+\n+        CreateShardedTable(server, sender, \"/Root\", \"table-1\", 1);\n+        CreateShardedTable(server, sender, \"/Root\", \"table-2\", 1);\n+\n+        // Insert initial values\n+        ExecSQL(server, sender, Q_(\"UPSERT INTO `/Root/table-1` (key, value) VALUES (1, 10);\"));\n+        ExecSQL(server, sender, Q_(\"UPSERT INTO `/Root/table-2` (key, value) VALUES (2, 20);\"));\n+\n+        size_t volatileTxs = 0;\n+        auto proposeObserver = runtime.AddObserver<TEvDataShard::TEvProposeTransaction>([&](TEvDataShard::TEvProposeTransaction::TPtr& ev) {\n+            auto* msg = ev->Get();\n+            if (msg->Record.GetFlags() & TTxFlags::VolatilePrepare) {\n+                ++volatileTxs;\n+            }\n+        });\n+\n+        // This simulates a jepsen transaction that appends two values at different shards\n+        TString sessionId, txId;\n+        UNIT_ASSERT_VALUES_EQUAL(\n+            KqpSimpleBegin(runtime, sessionId, txId, Q_(R\"(\n+                $next_index = (\n+                    SELECT COALESCE(MAX(key) + 1u, 0u)\n+                    FROM (\n+                        SELECT key FROM `/Root/table-1`\n+                        UNION ALL\n+                        SELECT key FROM `/Root/table-2`\n+                    )\n+                );\n+                UPSERT INTO `/Root/table-1` (key, value) VALUES ($next_index, 30u);\n+                )\")),\n+            \"<empty>\");\n+\n+        UNIT_ASSERT_VALUES_EQUAL(\n+            KqpSimpleCommit(runtime, sessionId, txId, Q_(R\"(\n+                $next_index = (\n+                    SELECT COALESCE(MAX(key) + 1u, 0u)\n+                    FROM (\n+                        SELECT key FROM `/Root/table-1`\n+                        UNION ALL\n+                        SELECT key FROM `/Root/table-2`\n+                    )\n+                );\n+                UPSERT INTO `/Root/table-2` (key, value) VALUES ($next_index, 40u);\n+                )\")),\n+            \"<empty>\");\n+\n+        // There should have been volatile transactions at both shards\n+        UNIT_ASSERT_VALUES_EQUAL(volatileTxs, 2u);\n+    }\n+\n+    // Regression test for KIKIMR-21156\n+    Y_UNIT_TEST(VolatileCommitOnBlobStorageFailure) {\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings.SetDomainName(\"Root\")\n+            .SetUseRealThreads(false)\n+            .SetDomainPlanResolution(1000)\n+            .SetEnableDataShardVolatileTransactions(true);\n+\n+        Tests::TServer::TPtr server = new TServer(serverSettings);\n+        auto &runtime = *server->GetRuntime();\n+        auto sender = runtime.AllocateEdgeActor();\n+\n+        runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_TRACE);\n+        runtime.SetLogPriority(NKikimrServices::TX_PROXY, NLog::PRI_DEBUG);\n+        runtime.SetLogPriority(NKikimrServices::KQP_EXECUTER, NLog::PRI_TRACE);\n+        runtime.SetLogPriority(NKikimrServices::KQP_SESSION, NLog::PRI_TRACE);\n+\n+        InitRoot(server, sender);\n+\n+        TDisableDataShardLogBatching disableDataShardLogBatching;\n+        CreateShardedTable(server, sender, \"/Root\", \"table-1\", 1);\n+        CreateShardedTable(server, sender, \"/Root\", \"table-2\", 1);\n+\n+        // Make sure read flags are persisted by performing a snapshot read\n+        UNIT_ASSERT_VALUES_EQUAL(\n+            KqpSimpleExec(runtime, R\"(\n+                SELECT key, value FROM `/Root/table-1`\n+                UNION ALL\n+                SELECT key, value FROM `/Root/table-2`\n+                ORDER BY key\n+                )\"),\n+            \"\");\n+\n+        // Insert initial values\n+        ExecSQL(server, sender, Q_(\"UPSERT INTO `/Root/table-1` (key, value) VALUES (1, 10);\"));\n+        ExecSQL(server, sender, Q_(\"UPSERT INTO `/Root/table-2` (key, value) VALUES (2, 20);\"));\n+\n+        // Start blocking commits for table-1\n+        const auto shards1 = GetTableShards(server, sender, \"/Root/table-1\");\n+        UNIT_ASSERT_VALUES_EQUAL(shards1.size(), 1u);\n+        std::deque<TEvBlobStorage::TEvPut::TPtr> blockedPuts;\n+        auto blockCommits = runtime.AddObserver<TEvBlobStorage::TEvPut>([&](TEvBlobStorage::TEvPut::TPtr& ev) {\n+            auto* msg = ev->Get();\n+            // Drop all put requests for table-1\n+            if (msg->Id.TabletID() == shards1.at(0)) {\n+                Cerr << \"... blocking put \" << msg->Id << Endl;\n+                blockedPuts.push_back(std::move(ev));\n+            }\n+        });\n+\n+        // Start an upsert to table-1, this will block further readonly localdb tx completions\n+        Cerr << \"... starting an upsert to table-1\" << Endl;\n+        auto firstUpsertFuture = KqpSimpleSend(runtime, R\"(\n+            UPSERT INTO `/Root/table-1` (key, value) VALUES (3, 30);\n+            )\");\n+\n+        // Wait until puts are blocked\n+        WaitFor(runtime, [&]{ return blockedPuts.size() > 0; }, \"blocked puts\");\n+        auto firstUpsertPuts = std::move(blockedPuts);\n+        UNIT_ASSERT(blockedPuts.empty());\n+\n+        // Read from table-2 and write to table-1 based on the result\n+        // This will result in a two-shard volatile tx writing to table-1\n+        Cerr << \"... starting distributed tx between table-1 and table-2\" << Endl;\n+        auto volatileFuture = KqpSimpleSend(runtime, R\"(\n+            UPSERT INTO `/Root/table-1`\n+                SELECT key + 2u AS key, value + 2u AS value\n+                FROM `/Root/table-2`;\n+            )\");\n+\n+        // Wait until it also tries to commit\n+        WaitFor(runtime, [&]{ return blockedPuts.size() > 0; }, \"blocked puts\");\n+\n+        // Now unblock the first upsert puts\n+        blockCommits.Remove();\n+        for (auto& ev : firstUpsertPuts) {\n+            runtime.Send(ev.Release(), 0, true);\n+        }\n+        firstUpsertPuts.clear();\n+\n+        // And wait for it to finish successfully\n+        Cerr << \"... waiting for first upsert result\" << Endl;\n+        UNIT_ASSERT_VALUES_EQUAL(\n+            FormatResult(AwaitResponse(runtime, std::move(firstUpsertFuture))),\n+            \"<empty>\");\n+\n+        // Reply to everything previously blocked with an error, the shard will restart\n+        for (auto& ev : blockedPuts) {\n+            auto proxy = ev->Recipient;\n+            ui32 groupId = GroupIDFromBlobStorageProxyID(proxy);\n+            auto res = ev->Get()->MakeErrorResponse(NKikimrProto::ERROR, \"Something went wrong\", groupId);\n+            runtime.Send(new IEventHandle(ev->Sender, proxy, res.release()), 0, true);\n+        }\n+\n+        // Wait for the volatile tx result\n+        Cerr << \"... waiting for volatile tx result\" << Endl;\n+        auto result = FormatResult(AwaitResponse(runtime, std::move(volatileFuture)));\n+        if (result == \"<empty>\") {\n+            // A success result is not ok now, but in the future we might migrate state\n+            // Check that the supposedly committed row actually exists\n+            UNIT_ASSERT_VALUES_EQUAL(\n+                KqpSimpleExec(runtime, R\"(\n+                    SELECT key, value FROM `/Root/table-1` ORDER BY key;\n+                    )\"),\n+                \"{ items { uint32_value: 1 } items { uint32_value: 10 } }, \"\n+                \"{ items { uint32_value: 3 } items { uint32_value: 30 } }, \"\n+                \"{ items { uint32_value: 4 } items { uint32_value: 22 } }\");\n+        } else {\n+            // Otherwise the result must be undetermined\n+            UNIT_ASSERT_VALUES_EQUAL(result, \"ERROR: UNDETERMINED\");\n+        }\n+    }\n+\n } // Y_UNIT_TEST_SUITE(DataShardVolatile)\n \n } // namespace NKikimr\ndiff --git a/ydb/core/tx/datashard/finish_propose_unit.cpp b/ydb/core/tx/datashard/finish_propose_unit.cpp\nindex 7c30cb960093..bfc7a166d2aa 100644\n--- a/ydb/core/tx/datashard/finish_propose_unit.cpp\n+++ b/ydb/core/tx/datashard/finish_propose_unit.cpp\n@@ -99,8 +99,11 @@ EExecutionStatus TFinishProposeUnit::Execute(TOperation::TPtr op,\n         op->SetFinishProposeTs(DataShard.ConfirmReadOnlyLease());\n     }\n \n-    if (!op->HasResultSentFlag() && (op->IsDirty() || op->HasVolatilePrepareFlag() || !Pipeline.WaitCompletion(op)))\n+    if (!op->HasResultSentFlag() && (op->IsDirty() || op->HasVolatilePrepareFlag() || !Pipeline.WaitCompletion(op))) {\n+        DataShard.IncCounter(COUNTER_PREPARE_COMPLETE);\n+        op->SetProposeResultSentEarly();\n         CompleteRequest(op, ctx);\n+    }\n \n     if (!DataShard.IsFollower())\n         DataShard.PlanCleanup(ctx);\n@@ -128,7 +131,7 @@ EExecutionStatus TFinishProposeUnit::Execute(TOperation::TPtr op,\n void TFinishProposeUnit::Complete(TOperation::TPtr op,\n                                   const TActorContext &ctx)\n {\n-    if (!op->HasResultSentFlag()) {\n+    if (!op->HasResultSentFlag() && !op->IsProposeResultSentEarly()) {\n         DataShard.IncCounter(COUNTER_PREPARE_COMPLETE);\n \n         if (op->Result())\ndiff --git a/ydb/core/tx/datashard/finish_propose_write_unit.cpp b/ydb/core/tx/datashard/finish_propose_write_unit.cpp\nindex d6c9dffa10fa..7ed6d64ff24f 100644\n--- a/ydb/core/tx/datashard/finish_propose_write_unit.cpp\n+++ b/ydb/core/tx/datashard/finish_propose_write_unit.cpp\n@@ -97,8 +97,11 @@ EExecutionStatus TFinishProposeWriteUnit::Execute(TOperation::TPtr op,\n         op->SetFinishProposeTs(DataShard.ConfirmReadOnlyLease());\n     }\n \n-    if (!op->HasResultSentFlag() && (op->IsDirty() || op->HasVolatilePrepareFlag() || !Pipeline.WaitCompletion(op)))\n+    if (!op->HasResultSentFlag() && (op->IsDirty() || op->HasVolatilePrepareFlag() || !Pipeline.WaitCompletion(op))) {\n+        DataShard.IncCounter(COUNTER_PREPARE_COMPLETE);\n+        op->SetProposeResultSentEarly();\n         CompleteRequest(op, ctx);\n+    }\n \n     if (!DataShard.IsFollower())\n         DataShard.PlanCleanup(ctx);\n@@ -127,7 +130,7 @@ void TFinishProposeWriteUnit::Complete(TOperation::TPtr op, const TActorContext\n {\n     TWriteOperation* writeOp = TWriteOperation::CastWriteOperation(op);\n \n-    if (!op->HasResultSentFlag()) {\n+    if (!op->HasResultSentFlag() && !op->IsProposeResultSentEarly()) {\n         DataShard.IncCounter(COUNTER_WRITE_COMPLETE);\n \n         if (writeOp->GetWriteResult())\ndiff --git a/ydb/core/tx/datashard/operation.h b/ydb/core/tx/datashard/operation.h\nindex 201e22636a74..8cffc801f97b 100644\n--- a/ydb/core/tx/datashard/operation.h\n+++ b/ydb/core/tx/datashard/operation.h\n@@ -402,12 +402,15 @@ class TBasicOpInfo {\n \n     bool IsMvccSnapshotRead() const { return !MvccSnapshot.IsMax(); }\n     const TRowVersion& GetMvccSnapshot() const { return MvccSnapshot; }\n-    bool IsMvccSnapshotRepeatable() const { return MvccSnapshotRepeatable; }\n+    bool IsMvccSnapshotRepeatable() const { return MvccSnapshotRepeatable_; }\n     void SetMvccSnapshot(const TRowVersion& snapshot, bool isRepeatable = true) {\n         MvccSnapshot = snapshot;\n-        MvccSnapshotRepeatable = isRepeatable;\n+        MvccSnapshotRepeatable_ = isRepeatable;\n     }\n \n+    bool IsProposeResultSentEarly() const { return ProposeResultSentEarly_; }\n+    void SetProposeResultSentEarly(bool value = true) { ProposeResultSentEarly_ = value; }\n+\n     ///////////////////////////////////\n     //     DEBUG AND MONITORING      //\n     ///////////////////////////////////\n@@ -429,7 +432,11 @@ class TBasicOpInfo {\n \n     TSnapshotKey AcquiredSnapshotKey;\n     TRowVersion MvccSnapshot = TRowVersion::Max();\n-    bool MvccSnapshotRepeatable = false;\n+\n+private:\n+    // Runtime flags\n+    ui8 MvccSnapshotRepeatable_ : 1 = 0;\n+    ui8 ProposeResultSentEarly_ : 1 = 0;\n };\n \n struct TRSData {\ndiff --git a/ydb/core/tx/scheme_board/CMakeLists.darwin-arm64.txt b/ydb/core/tx/scheme_board/CMakeLists.darwin-arm64.txt\nindex 65a6b9453ca1..1a1f1257a6a5 100644\n--- a/ydb/core/tx/scheme_board/CMakeLists.darwin-arm64.txt\n+++ b/ydb/core/tx/scheme_board/CMakeLists.darwin-arm64.txt\n@@ -35,6 +35,7 @@ target_link_libraries(core-tx-scheme_board PUBLIC\n )\n target_sources(core-tx-scheme_board PRIVATE\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/cache.cpp\n+  ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/events.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/helpers.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/load_test.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/monitoring.cpp\n@@ -42,6 +43,7 @@ target_sources(core-tx-scheme_board PRIVATE\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/replica.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/subscriber.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/two_part_description.cpp\n+  ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/opaque_path_description.cpp\n )\n generate_enum_serilization(core-tx-scheme_board\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/subscriber.h\ndiff --git a/ydb/core/tx/scheme_board/CMakeLists.darwin-x86_64.txt b/ydb/core/tx/scheme_board/CMakeLists.darwin-x86_64.txt\nindex 65a6b9453ca1..1a1f1257a6a5 100644\n--- a/ydb/core/tx/scheme_board/CMakeLists.darwin-x86_64.txt\n+++ b/ydb/core/tx/scheme_board/CMakeLists.darwin-x86_64.txt\n@@ -35,6 +35,7 @@ target_link_libraries(core-tx-scheme_board PUBLIC\n )\n target_sources(core-tx-scheme_board PRIVATE\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/cache.cpp\n+  ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/events.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/helpers.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/load_test.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/monitoring.cpp\n@@ -42,6 +43,7 @@ target_sources(core-tx-scheme_board PRIVATE\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/replica.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/subscriber.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/two_part_description.cpp\n+  ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/opaque_path_description.cpp\n )\n generate_enum_serilization(core-tx-scheme_board\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/subscriber.h\ndiff --git a/ydb/core/tx/scheme_board/CMakeLists.linux-aarch64.txt b/ydb/core/tx/scheme_board/CMakeLists.linux-aarch64.txt\nindex ec77757c3e0f..b3b223597a8d 100644\n--- a/ydb/core/tx/scheme_board/CMakeLists.linux-aarch64.txt\n+++ b/ydb/core/tx/scheme_board/CMakeLists.linux-aarch64.txt\n@@ -36,6 +36,7 @@ target_link_libraries(core-tx-scheme_board PUBLIC\n )\n target_sources(core-tx-scheme_board PRIVATE\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/cache.cpp\n+  ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/events.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/helpers.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/load_test.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/monitoring.cpp\n@@ -43,6 +44,7 @@ target_sources(core-tx-scheme_board PRIVATE\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/replica.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/subscriber.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/two_part_description.cpp\n+  ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/opaque_path_description.cpp\n )\n generate_enum_serilization(core-tx-scheme_board\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/subscriber.h\ndiff --git a/ydb/core/tx/scheme_board/CMakeLists.linux-x86_64.txt b/ydb/core/tx/scheme_board/CMakeLists.linux-x86_64.txt\nindex ec77757c3e0f..b3b223597a8d 100644\n--- a/ydb/core/tx/scheme_board/CMakeLists.linux-x86_64.txt\n+++ b/ydb/core/tx/scheme_board/CMakeLists.linux-x86_64.txt\n@@ -36,6 +36,7 @@ target_link_libraries(core-tx-scheme_board PUBLIC\n )\n target_sources(core-tx-scheme_board PRIVATE\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/cache.cpp\n+  ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/events.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/helpers.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/load_test.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/monitoring.cpp\n@@ -43,6 +44,7 @@ target_sources(core-tx-scheme_board PRIVATE\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/replica.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/subscriber.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/two_part_description.cpp\n+  ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/opaque_path_description.cpp\n )\n generate_enum_serilization(core-tx-scheme_board\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/subscriber.h\ndiff --git a/ydb/core/tx/scheme_board/CMakeLists.windows-x86_64.txt b/ydb/core/tx/scheme_board/CMakeLists.windows-x86_64.txt\nindex 65a6b9453ca1..1a1f1257a6a5 100644\n--- a/ydb/core/tx/scheme_board/CMakeLists.windows-x86_64.txt\n+++ b/ydb/core/tx/scheme_board/CMakeLists.windows-x86_64.txt\n@@ -35,6 +35,7 @@ target_link_libraries(core-tx-scheme_board PUBLIC\n )\n target_sources(core-tx-scheme_board PRIVATE\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/cache.cpp\n+  ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/events.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/helpers.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/load_test.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/monitoring.cpp\n@@ -42,6 +43,7 @@ target_sources(core-tx-scheme_board PRIVATE\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/replica.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/subscriber.cpp\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/two_part_description.cpp\n+  ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/opaque_path_description.cpp\n )\n generate_enum_serilization(core-tx-scheme_board\n   ${CMAKE_SOURCE_DIR}/ydb/core/tx/scheme_board/subscriber.h\ndiff --git a/ydb/core/tx/scheme_board/replica.cpp b/ydb/core/tx/scheme_board/replica.cpp\nindex c1600b4bd644..cb5ddd2e923f 100644\n--- a/ydb/core/tx/scheme_board/replica.cpp\n+++ b/ydb/core/tx/scheme_board/replica.cpp\n@@ -248,17 +248,6 @@ class TReplica: public TMonitorableActor<TReplica> {\n             TrackMemory();\n         }\n \n-        explicit TDescription(\n-                TReplica* owner,\n-                const TPathId& pathId,\n-                TOpaquePathDescription&& pathDescription)\n-            : Owner(owner)\n-            , PathId(pathId)\n-            , PathDescription(std::move(pathDescription))\n-        {\n-            TrackMemory();\n-        }\n-\n         explicit TDescription(\n                 TReplica* owner,\n                 const TString& path,\n@@ -540,13 +529,13 @@ class TReplica: public TMonitorableActor<TReplica> {\n     }\n \n     // upsert description only by pathId\n-    TDescription& UpsertDescription(const TPathId& pathId, TOpaquePathDescription&& pathDescription) {\n+    TDescription& UpsertDescriptionByPathId(const TString& path, const TPathId& pathId, TOpaquePathDescription&& pathDescription) {\n         SBR_LOG_I(\"Upsert description\"\n             << \": pathId# \" << pathId\n             << \", pathDescription# \" << pathDescription.ToString()\n         );\n \n-        return Descriptions.Upsert(pathId, TDescription(this, pathId, std::move(pathDescription)));\n+        return Descriptions.Upsert(pathId, TDescription(this, path, pathId, std::move(pathDescription)));\n     }\n \n     // upsert description by path AND pathId both\n@@ -898,7 +887,7 @@ class TReplica: public TMonitorableActor<TReplica> {\n             if (abandonedSchemeShards.contains(pathId.OwnerId)) { // TSS is ignored, present GSS reverted it\n                 log(\"Replace GSS by TSS description is rejected, GSS implicitly knows that TSS has been reverted\"\n                     \", but still inject description only by pathId for safe\");\n-                UpsertDescription(pathId, std::move(pathDescription));\n+                UpsertDescriptionByPathId(path, pathId, std::move(pathDescription));\n                 return AckUpdate(ev);\n             }\n \n@@ -923,7 +912,7 @@ class TReplica: public TMonitorableActor<TReplica> {\n             }\n \n             log(\"Inject description only by pathId, it is update from GSS\");\n-            UpsertDescription(pathId, std::move(pathDescription));\n+            UpsertDescriptionByPathId(path, pathId, std::move(pathDescription));\n             return AckUpdate(ev);\n         }\n \ndiff --git a/ydb/library/yql/minikql/mkql_node.cpp b/ydb/library/yql/minikql/mkql_node.cpp\nindex 82815a8e3e4b..6fa8d8f55db9 100644\n--- a/ydb/library/yql/minikql/mkql_node.cpp\n+++ b/ydb/library/yql/minikql/mkql_node.cpp\n@@ -2525,7 +2525,7 @@ EValueRepresentation GetValueRepresentation(const TType* type) {\n }\n \n TArrayRef<TType* const> GetWideComponents(const TFlowType* type) {\n-    if (RuntimeVersion > 35) {\n+    if (type->GetItemType()->IsMulti()) {\n         return AS_TYPE(TMultiType, type->GetItemType())->GetElements();\n     }\n     return AS_TYPE(TTupleType, type->GetItemType())->GetElements();\ndiff --git a/ydb/library/yql/sql/v1/sql_translation.cpp b/ydb/library/yql/sql/v1/sql_translation.cpp\nindex 073dd5e07397..aaef357bd06c 100644\n--- a/ydb/library/yql/sql/v1/sql_translation.cpp\n+++ b/ydb/library/yql/sql/v1/sql_translation.cpp\n@@ -53,6 +53,33 @@ TString CollectTokens(const TRule_select_stmt& selectStatement) {\n     return tokenCollector.Tokens;\n }\n \n+NSQLTranslation::TTranslationSettings CreateViewTranslationSettings(const NSQLTranslation::TTranslationSettings& base) {\n+    NSQLTranslation::TTranslationSettings settings;\n+    \n+    settings.ClusterMapping = base.ClusterMapping;\n+    settings.Mode = NSQLTranslation::ESqlMode::LIMITED_VIEW;\n+\n+    return settings;\n+}\n+\n+TNodePtr BuildViewSelect(const TRule_select_stmt& query, TContext& ctx) {\n+    const auto viewTranslationSettings = CreateViewTranslationSettings(ctx.Settings);\n+    TContext viewParsingContext(viewTranslationSettings, {}, ctx.Issues);\n+    TSqlSelect select(viewParsingContext, viewTranslationSettings.Mode);\n+    TPosition pos;\n+    auto source = select.Build(query, pos);\n+    if (!source) {\n+        return nullptr;\n+    }\n+    return BuildSelectResult(\n+        pos,\n+        std::move(source),\n+        false,\n+        false,\n+        viewParsingContext.Scoped\n+    );\n+}\n+\n }\n \n namespace NSQLTranslationV1 {\n@@ -4484,19 +4511,11 @@ bool TSqlTranslation::ParseViewQuery(std::map<TString, TDeferredAtom>& features,\n     const TString queryText = CollectTokens(query);\n     features[\"query_text\"] = {Ctx.Pos(), queryText};\n \n-    {\n-        TSqlSelect select(Ctx, Mode);\n-        TPosition pos;\n-        auto source = select.Build(query, pos);\n-        if (!source) {\n-            return false;\n-        }\n-        features[\"query_ast\"] = {BuildSelectResult(pos,\n-                                                   std::move(source),\n-                                                   false,\n-                                                   false,\n-                                                   Ctx.Scoped), Ctx};\n+    const auto viewSelect = BuildViewSelect(query, Ctx);\n+    if (!viewSelect) {\n+        return false;\n     }\n+    features[\"query_ast\"] = {viewSelect, Ctx};\n \n     return true;\n }\ndiff --git a/ydb/public/api/protos/draft/ydb_maintenance.proto b/ydb/public/api/protos/draft/ydb_maintenance.proto\nindex 8dc461221314..c37356b98527 100644\n--- a/ydb/public/api/protos/draft/ydb_maintenance.proto\n+++ b/ydb/public/api/protos/draft/ydb_maintenance.proto\n@@ -43,6 +43,9 @@ message Node {\n     }\n     // start_time defines time when node was registered in cms.\n     google.protobuf.Timestamp start_time = 8;\n+    // version defines YDB version for current Node.\n+    // For example, 'ydb-stable-24-1'.\n+    string version = 9;\n }\n \n message ListClusterNodesRequest {\ndiff --git a/ydb/services/deprecated/persqueue_v0/grpc_pq_actor.h b/ydb/services/deprecated/persqueue_v0/grpc_pq_actor.h\nindex 0d5e472ca443..cb1ca35ecd86 100644\n--- a/ydb/services/deprecated/persqueue_v0/grpc_pq_actor.h\n+++ b/ydb/services/deprecated/persqueue_v0/grpc_pq_actor.h\n@@ -554,6 +554,8 @@ class TWriteSessionActor : public NActors::TActorBootstrapped<TWriteSessionActor\n     NPersQueue::TWriteRequest::TInit InitRequest;\n \n     TActorId PartitionChooser;\n+\n+    bool SessionClosed = false;\n };\n \n class TReadSessionActor : public TActorBootstrapped<TReadSessionActor> {\ndiff --git a/ydb/services/deprecated/persqueue_v0/grpc_pq_write_actor.cpp b/ydb/services/deprecated/persqueue_v0/grpc_pq_write_actor.cpp\nindex e29b4bc4f304..6172305476af 100644\n--- a/ydb/services/deprecated/persqueue_v0/grpc_pq_write_actor.cpp\n+++ b/ydb/services/deprecated/persqueue_v0/grpc_pq_write_actor.cpp\n@@ -310,7 +310,10 @@ void TWriteSessionActor::SetupCounters(const TString& cloudId, const TString& db\n \n \n void TWriteSessionActor::Handle(TEvDescribeTopicsResponse::TPtr& ev, const TActorContext& ctx) {\n-    Y_ABORT_UNLESS(State == ES_WAIT_SCHEME || State == ES_INITED);\n+    if (State != ES_WAIT_SCHEME && State != ES_INITED) {\n+        return CloseSession(\"erroneous internal state\", NPersQueue::NErrorCode::ERROR, ctx);\n+    }\n+\n     auto& res = ev->Get()->Result;\n     Y_ABORT_UNLESS(res->ResultSet.size() == 1);\n \n@@ -503,6 +506,11 @@ void TWriteSessionActor::ProceedPartition(const ui32 partition, const TActorCont\n }\n \n void TWriteSessionActor::CloseSession(const TString& errorReason, const NPersQueue::NErrorCode::EErrorCode errorCode, const NActors::TActorContext& ctx) {\n+    if (SessionClosed) {\n+        return;\n+    }\n+    SessionClosed = true;\n+\n     if (errorCode != NPersQueue::NErrorCode::OK) {\n         if (InternalErrorCode(errorCode)) {\n             SLIErrors.Inc();\n@@ -865,7 +873,7 @@ void TWriteSessionActor::LogSession(const TActorContext& ctx) {\n \n void TWriteSessionActor::HandleWakeup(const TActorContext& ctx) {\n     if (State != ES_INITED) {\n-        return;\n+        return CloseSession(\"erroneous internal state\", NPersQueue::NErrorCode::ERROR, ctx);\n     }\n \n     auto now = ctx.Now();\ndiff --git a/ydb/services/lib/actors/pq_schema_actor.cpp b/ydb/services/lib/actors/pq_schema_actor.cpp\nindex c6564b247985..8d18aa9edde2 100644\n--- a/ydb/services/lib/actors/pq_schema_actor.cpp\n+++ b/ydb/services/lib/actors/pq_schema_actor.cpp\n@@ -136,12 +136,6 @@ namespace NKikimr::NGRpcProxy::V1 {\n         }\n \n         if (rr.important()) {\n-            if (AppData(ctx)->PQConfig.GetTopicsAreFirstClassCitizen()) {\n-                return TMsgPqCodes(\n-                    TStringBuilder() << \"important flag is forbiden for consumer \" << rr.consumer_name(),\n-                    Ydb::PersQueue::ErrorCode::VALIDATION_ERROR\n-                );\n-            }\n             config->MutablePartitionConfig()->AddImportantClientId(consumerName);\n         }\n \ndiff --git a/ydb/services/persqueue_v1/actors/write_session_actor.h b/ydb/services/persqueue_v1/actors/write_session_actor.h\nindex 2d69db971d7f..17c47aab7837 100644\n--- a/ydb/services/persqueue_v1/actors/write_session_actor.h\n+++ b/ydb/services/persqueue_v1/actors/write_session_actor.h\n@@ -271,6 +271,8 @@ class TWriteSessionActor\n \n     TActorId PartitionWriterCache;\n     TActorId PartitionChooser;\n+\n+    bool SessionClosed = false;\n };\n \n }\ndiff --git a/ydb/services/persqueue_v1/actors/write_session_actor.ipp b/ydb/services/persqueue_v1/actors/write_session_actor.ipp\nindex b76ab8fb24a7..825e342b7ead 100644\n--- a/ydb/services/persqueue_v1/actors/write_session_actor.ipp\n+++ b/ydb/services/persqueue_v1/actors/write_session_actor.ipp\n@@ -724,6 +724,10 @@ void TWriteSessionActor<UseMigrationProtocol>::DestroyPartitionWriterCache(const\n \n template<bool UseMigrationProtocol>\n void TWriteSessionActor<UseMigrationProtocol>::CloseSession(const TString& errorReason, const PersQueue::ErrorCode::ErrorCode errorCode, const NActors::TActorContext& ctx) {\n+    if (SessionClosed) {\n+        return;\n+    }\n+    SessionClosed = true;\n \n     if (errorCode != PersQueue::ErrorCode::OK) {\n \n@@ -1503,7 +1507,10 @@ void TWriteSessionActor<UseMigrationProtocol>::Handle(TEvents::TEvWakeup::TPtr&\n \n template<bool UseMigrationProtocol>\n void TWriteSessionActor<UseMigrationProtocol>::RecheckACL(const TActorContext& ctx) {\n-    Y_ABORT_UNLESS(State == ES_INITED);\n+    if (State != ES_INITED) {\n+        LOG_ERROR_S(ctx, NKikimrServices::PQ_WRITE_PROXY, \"WriteSessionActor state is wrong. Actual state '\" << (int)State << \"'\");\n+        return CloseSession(\"erroneous internal state\", PersQueue::ErrorCode::ERROR, ctx);\n+    }\n \n     auto now = ctx.Now();\n \n",
  "test_patch": "diff --git a/ydb/core/blobstorage/ut_testshard/CMakeLists.darwin-arm64.txt b/ydb/core/blobstorage/ut_testshard/CMakeLists.darwin-arm64.txt\nindex 46b220972149..19b8a576735e 100644\n--- a/ydb/core/blobstorage/ut_testshard/CMakeLists.darwin-arm64.txt\n+++ b/ydb/core/blobstorage/ut_testshard/CMakeLists.darwin-arm64.txt\n@@ -12,6 +12,7 @@ target_link_libraries(ydb-core-blobstorage-ut_testshard PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n   cpp-testing-unittest_main\n+  version_definition\n   ydb-core-base\n   ydb-core-blob_depot\n   core-blobstorage-backpressure\ndiff --git a/ydb/core/blobstorage/ut_testshard/CMakeLists.darwin-x86_64.txt b/ydb/core/blobstorage/ut_testshard/CMakeLists.darwin-x86_64.txt\nindex 5c635e0b11b3..972e7c84ccaa 100644\n--- a/ydb/core/blobstorage/ut_testshard/CMakeLists.darwin-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_testshard/CMakeLists.darwin-x86_64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(ydb-core-blobstorage-ut_testshard PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n+  version_definition\n   ydb-core-base\n   ydb-core-blob_depot\n   core-blobstorage-backpressure\ndiff --git a/ydb/core/blobstorage/ut_testshard/CMakeLists.linux-aarch64.txt b/ydb/core/blobstorage/ut_testshard/CMakeLists.linux-aarch64.txt\nindex 13632cba37ce..59ed90704881 100644\n--- a/ydb/core/blobstorage/ut_testshard/CMakeLists.linux-aarch64.txt\n+++ b/ydb/core/blobstorage/ut_testshard/CMakeLists.linux-aarch64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(ydb-core-blobstorage-ut_testshard PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n   cpp-testing-unittest_main\n+  version_definition\n   ydb-core-base\n   ydb-core-blob_depot\n   core-blobstorage-backpressure\ndiff --git a/ydb/core/blobstorage/ut_testshard/CMakeLists.linux-x86_64.txt b/ydb/core/blobstorage/ut_testshard/CMakeLists.linux-x86_64.txt\nindex 9e02e5a34a5b..1d86546dcea5 100644\n--- a/ydb/core/blobstorage/ut_testshard/CMakeLists.linux-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_testshard/CMakeLists.linux-x86_64.txt\n@@ -14,6 +14,7 @@ target_link_libraries(ydb-core-blobstorage-ut_testshard PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n+  version_definition\n   ydb-core-base\n   ydb-core-blob_depot\n   core-blobstorage-backpressure\ndiff --git a/ydb/core/blobstorage/ut_testshard/CMakeLists.windows-x86_64.txt b/ydb/core/blobstorage/ut_testshard/CMakeLists.windows-x86_64.txt\nindex 0fd1655f0b30..e1748212ae74 100644\n--- a/ydb/core/blobstorage/ut_testshard/CMakeLists.windows-x86_64.txt\n+++ b/ydb/core/blobstorage/ut_testshard/CMakeLists.windows-x86_64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(ydb-core-blobstorage-ut_testshard PUBLIC\n   yutil\n   library-cpp-cpuid_check\n   cpp-testing-unittest_main\n+  version_definition\n   ydb-core-base\n   ydb-core-blob_depot\n   core-blobstorage-backpressure\ndiff --git a/ydb/core/blobstorage/ut_testshard/ya.make b/ydb/core/blobstorage/ut_testshard/ya.make\nindex e1c6adef761d..47409b20d301 100644\n--- a/ydb/core/blobstorage/ut_testshard/ya.make\n+++ b/ydb/core/blobstorage/ut_testshard/ya.make\n@@ -12,6 +12,7 @@ UNITTEST()\n     )\n \n     PEERDIR(\n+        ydb/apps/version\n         ydb/core/base\n         ydb/core/blob_depot\n         ydb/core/blobstorage/backpressure\ndiff --git a/ydb/core/testlib/CMakeLists.darwin-arm64.txt b/ydb/core/testlib/CMakeLists.darwin-arm64.txt\nindex d234d9d9e6a0..887f4f370184 100644\n--- a/ydb/core/testlib/CMakeLists.darwin-arm64.txt\n+++ b/ydb/core/testlib/CMakeLists.darwin-arm64.txt\n@@ -18,6 +18,7 @@ target_compile_options(ydb-core-testlib PRIVATE\n target_link_libraries(ydb-core-testlib PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n+  version_definition\n   library-actors-core\n   library-actors-interconnect\n   library-grpc-client\ndiff --git a/ydb/core/testlib/CMakeLists.darwin-x86_64.txt b/ydb/core/testlib/CMakeLists.darwin-x86_64.txt\nindex d234d9d9e6a0..887f4f370184 100644\n--- a/ydb/core/testlib/CMakeLists.darwin-x86_64.txt\n+++ b/ydb/core/testlib/CMakeLists.darwin-x86_64.txt\n@@ -18,6 +18,7 @@ target_compile_options(ydb-core-testlib PRIVATE\n target_link_libraries(ydb-core-testlib PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n+  version_definition\n   library-actors-core\n   library-actors-interconnect\n   library-grpc-client\ndiff --git a/ydb/core/testlib/CMakeLists.linux-aarch64.txt b/ydb/core/testlib/CMakeLists.linux-aarch64.txt\nindex f5e108c012be..0a6dcd6d400c 100644\n--- a/ydb/core/testlib/CMakeLists.linux-aarch64.txt\n+++ b/ydb/core/testlib/CMakeLists.linux-aarch64.txt\n@@ -19,6 +19,7 @@ target_link_libraries(ydb-core-testlib PUBLIC\n   contrib-libs-linux-headers\n   contrib-libs-cxxsupp\n   yutil\n+  version_definition\n   library-actors-core\n   library-actors-interconnect\n   library-grpc-client\ndiff --git a/ydb/core/testlib/CMakeLists.linux-x86_64.txt b/ydb/core/testlib/CMakeLists.linux-x86_64.txt\nindex f5e108c012be..0a6dcd6d400c 100644\n--- a/ydb/core/testlib/CMakeLists.linux-x86_64.txt\n+++ b/ydb/core/testlib/CMakeLists.linux-x86_64.txt\n@@ -19,6 +19,7 @@ target_link_libraries(ydb-core-testlib PUBLIC\n   contrib-libs-linux-headers\n   contrib-libs-cxxsupp\n   yutil\n+  version_definition\n   library-actors-core\n   library-actors-interconnect\n   library-grpc-client\ndiff --git a/ydb/core/testlib/CMakeLists.windows-x86_64.txt b/ydb/core/testlib/CMakeLists.windows-x86_64.txt\nindex d234d9d9e6a0..887f4f370184 100644\n--- a/ydb/core/testlib/CMakeLists.windows-x86_64.txt\n+++ b/ydb/core/testlib/CMakeLists.windows-x86_64.txt\n@@ -18,6 +18,7 @@ target_compile_options(ydb-core-testlib PRIVATE\n target_link_libraries(ydb-core-testlib PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n+  version_definition\n   library-actors-core\n   library-actors-interconnect\n   library-grpc-client\ndiff --git a/ydb/core/testlib/actors/CMakeLists.darwin-arm64.txt b/ydb/core/testlib/actors/CMakeLists.darwin-arm64.txt\nindex 652256b272aa..559ad8cb1896 100644\n--- a/ydb/core/testlib/actors/CMakeLists.darwin-arm64.txt\n+++ b/ydb/core/testlib/actors/CMakeLists.darwin-arm64.txt\n@@ -12,6 +12,7 @@ add_library(core-testlib-actors)\n target_link_libraries(core-testlib-actors PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n+  version_definition\n   library-actors-testlib\n   cpp-testing-unittest\n   ydb-core-base\ndiff --git a/ydb/core/testlib/actors/CMakeLists.darwin-x86_64.txt b/ydb/core/testlib/actors/CMakeLists.darwin-x86_64.txt\nindex 652256b272aa..559ad8cb1896 100644\n--- a/ydb/core/testlib/actors/CMakeLists.darwin-x86_64.txt\n+++ b/ydb/core/testlib/actors/CMakeLists.darwin-x86_64.txt\n@@ -12,6 +12,7 @@ add_library(core-testlib-actors)\n target_link_libraries(core-testlib-actors PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n+  version_definition\n   library-actors-testlib\n   cpp-testing-unittest\n   ydb-core-base\ndiff --git a/ydb/core/testlib/actors/CMakeLists.linux-aarch64.txt b/ydb/core/testlib/actors/CMakeLists.linux-aarch64.txt\nindex 3aa61780092e..296b9c055c85 100644\n--- a/ydb/core/testlib/actors/CMakeLists.linux-aarch64.txt\n+++ b/ydb/core/testlib/actors/CMakeLists.linux-aarch64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(core-testlib-actors PUBLIC\n   contrib-libs-linux-headers\n   contrib-libs-cxxsupp\n   yutil\n+  version_definition\n   library-actors-testlib\n   cpp-testing-unittest\n   ydb-core-base\ndiff --git a/ydb/core/testlib/actors/CMakeLists.linux-x86_64.txt b/ydb/core/testlib/actors/CMakeLists.linux-x86_64.txt\nindex 3aa61780092e..296b9c055c85 100644\n--- a/ydb/core/testlib/actors/CMakeLists.linux-x86_64.txt\n+++ b/ydb/core/testlib/actors/CMakeLists.linux-x86_64.txt\n@@ -13,6 +13,7 @@ target_link_libraries(core-testlib-actors PUBLIC\n   contrib-libs-linux-headers\n   contrib-libs-cxxsupp\n   yutil\n+  version_definition\n   library-actors-testlib\n   cpp-testing-unittest\n   ydb-core-base\ndiff --git a/ydb/core/testlib/actors/CMakeLists.windows-x86_64.txt b/ydb/core/testlib/actors/CMakeLists.windows-x86_64.txt\nindex 652256b272aa..559ad8cb1896 100644\n--- a/ydb/core/testlib/actors/CMakeLists.windows-x86_64.txt\n+++ b/ydb/core/testlib/actors/CMakeLists.windows-x86_64.txt\n@@ -12,6 +12,7 @@ add_library(core-testlib-actors)\n target_link_libraries(core-testlib-actors PUBLIC\n   contrib-libs-cxxsupp\n   yutil\n+  version_definition\n   library-actors-testlib\n   cpp-testing-unittest\n   ydb-core-base\ndiff --git a/ydb/core/testlib/actors/ya.make b/ydb/core/testlib/actors/ya.make\nindex fc27aa01c236..25f814605794 100644\n--- a/ydb/core/testlib/actors/ya.make\n+++ b/ydb/core/testlib/actors/ya.make\n@@ -5,6 +5,7 @@ SRCS(\n )\n \n PEERDIR(\n+    ydb/apps/version\n     ydb/library/actors/testlib\n     library/cpp/testing/unittest\n     ydb/core/base\ndiff --git a/ydb/core/testlib/tenant_runtime.cpp b/ydb/core/testlib/tenant_runtime.cpp\nindex 88ba8b75905c..3f1d14f4a977 100644\n--- a/ydb/core/testlib/tenant_runtime.cpp\n+++ b/ydb/core/testlib/tenant_runtime.cpp\n@@ -1034,7 +1034,12 @@ void TTenantTestRuntime::Setup(bool createTenantPools)\n                 labels[label.GetName()] = label.GetValue();\n             }\n             labels.emplace(\"node_id\", ToString(i));\n-            auto aid = Register(CreateConfigsDispatcher(Extension, labels));\n+            auto aid = Register(CreateConfigsDispatcher(\n+                    NKikimr::NConsole::TConfigsDispatcherInitInfo {\n+                        .InitialConfig = Extension,\n+                        .Labels = labels,\n+                    }\n+                ));\n             EnableScheduleForActor(aid, true);\n             RegisterService(MakeConfigsDispatcherID(GetNodeId(0)), aid, 0);\n         }\ndiff --git a/ydb/core/testlib/test_client.cpp b/ydb/core/testlib/test_client.cpp\nindex b4c35f7375ac..978d3e3b1f97 100644\n--- a/ydb/core/testlib/test_client.cpp\n+++ b/ydb/core/testlib/test_client.cpp\n@@ -739,7 +739,10 @@ namespace Tests {\n             if (!initial.HasImmediateControlsConfig()) {\n                 initial.MutableImmediateControlsConfig()->CopyFrom(Settings->Controls);\n             }\n-            auto *dispatcher = NConsole::CreateConfigsDispatcher(initial, {});\n+            auto *dispatcher = NConsole::CreateConfigsDispatcher(\n+                    NKikimr::NConsole::TConfigsDispatcherInitInfo {\n+                        .InitialConfig = initial,\n+                    });\n             auto aid = Runtime->Register(dispatcher, nodeIdx, appData.SystemPoolId, TMailboxType::Revolving, 0);\n             Runtime->RegisterService(NConsole::MakeConfigsDispatcherID(Runtime->GetNodeId(nodeIdx)), aid, nodeIdx);\n         }\ndiff --git a/ydb/core/testlib/ya.make b/ydb/core/testlib/ya.make\nindex e7a93b69ae78..009636936e28 100644\n--- a/ydb/core/testlib/ya.make\n+++ b/ydb/core/testlib/ya.make\n@@ -22,6 +22,7 @@ SRCS(\n )\n \n PEERDIR(\n+    ydb/apps/version\n     ydb/library/actors/core\n     ydb/library/actors/interconnect\n     ydb/library/grpc/client\n",
  "problem_statement": "Jepsen: multiple conflicting appends sometimes succeed\nI rewrote jepsen test to merge multiple micro ops into a single query (does UPSERT from SELECT with LEFT JOIN and GROUP BY) and started to get inconsistent read failures. It appears that multiple transactions claim the same list index and successfully overwrite it, even though only one transaction should have succeeded.\r\n\r\nA good example of such failure:\r\n\r\n* We append to key 192\r\n* One transaction appends 630, another appends 637, both succeeds\r\n* Other transactions see the list ending in 630, but then it changes to 637\r\n\r\nHistory has this info on two appends:\r\n\r\n```\r\n# append 630\r\n{:index 300389, :time 240680658687, :type :ok, :process 1547, :f :txn,\r\n    :value [\r\n        [:append 192 630]\r\n        [:append 3 52]],\r\n    :modified-txn [\r\n        [:batch #{192 3} #jepsen.ydb.append.OperationBatch{:ops [[:append 192 630] [:append 3 52]], :reads [], :writes [[192 630] [3 52]], :readmap {}}]],\r\n    :debug-info [\r\n        [\r\n            {:tablet 72075186226226475, :gen 25, :read-version \"v1710410837721/18446744073709551615\", :op \"read\", :node 50003, :read-id 2, :snapshot-repeatable true, :lock-tx-id 844430958736899}\r\n            {:tablet 72075186226227048, :gen 2, :read-version \"v1710410837721/18446744073709551615\", :op \"read\", :node 50008, :read-id 1, :snapshot-repeatable true, :lock-tx-id 844430958736899}]\r\n        [\r\n            {:tablet 72075186226227048, :node 50008, :gen 2, :op \"kqp-tx\", :tx-id 281481004377038, :step 1710410838273, :version \"v1710410838273/281481004377038\"}\r\n            {:tablet 72075186226226475, :node 50003, :gen 25, :op \"kqp-tx\", :tx-id 281481004377038, :step 1710410838273, :version \"v1710410838273/281481004377038\"}]]}\r\n\r\n# append 637\r\n{:index 300437, :time 240689511468, :type :ok, :process 1159, :f :txn,\r\n    :value [\r\n        [:append 192 637]\r\n        [:append 196 45]\r\n        [:append 196 46]],\r\n    :modified-txn [\r\n        [:batch #{192 196} #jepsen.ydb.append.OperationBatch{:ops [[:append 192 637] [:append 196 45]], :reads [], :writes [[192 637] [196 45]], :readmap {}}]\r\n        [:commit nil [:append 196 46]]],\r\n    :debug-info [\r\n        [\r\n            {:tablet 72075186226227048, :gen 2, :read-version \"v1710410838260/18446744073709551615\", :op \"read\", :node 50008, :read-id 1, :snapshot-repeatable true, :lock-tx-id 562955991686003}\r\n            {:tablet 72075186226227048, :gen 2, :read-version \"v1710410838260/18446744073709551615\", :op \"read\", :node 50008, :read-id 1, :snapshot-repeatable true, :lock-tx-id 562955991686003}]\r\n        [\r\n            {:tablet 72075186226227048, :gen 2, :op \"kqp-tx\", :node 50008, :snapshot \"v1710410838260/18446744073709551615\", :tx-id 562955991686035, :snapshot-repeatable true, :lock-tx-id 562955991686035}\r\n            {:tablet 72075186226227048, :gen 2, :read-version \"v1710410838260/18446744073709551615\", :op \"read\", :node 50008, :read-id 0, :snapshot-repeatable true, :lock-tx-id 562955991686035}\r\n            {:tablet 72075186226227048, :node 50008, :gen 2, :op \"kqp-tx\", :tx-id 562955991686134, :version \"v1710410838283/18446744073709551615\"}]]}\r\n```\r\n\r\nWhat I could infer from this:\r\n\r\n* Tx with `:append 192 630` committed first at `v1710410838273/281481004377038`, it was a pretty straight forward batch, single query with a separate commit, which applied deferred effects directly at commit time\r\n* Tx with `:append 192 637` was part of a batch query (without commit), it performed reads at `v1710410838260/18446744073709551615` with `:lock-tx-id 562955991686003`, deferred effects should have been buffered in memory\r\n* Then the second tx performed `[:append 196 46]` with fused commit. Since it append reads from the table it needed to flush deferred effects, and you can see it happened with `:tx-id 562955991686035` and `:lock-tx-id 562955991686035`. Notice LockTxId is different (not 562955991686003) and matches TxId. This means `AcquireLocksTxId` was 0, and this can only happen when transaction has absolutely no locks in the list.\r\n* Since lock 562955991686003 (apparently) wasn't in memory we committed without checking it, and it successfully committed write of value 637 to the same index as 630.\r\n* All cases I've seen so far had `:read-id` that was not zero, apparently read was restarted for some reason, but current debug-info is only passed on success.\r\n* Currently debug-info doesn't log any info about acquired and validated locks, so it's unclear what the read actually returned (it's unclear whether the lock was successfully taken, for example, or whether it was initially broken).\r\n\r\nI started seeing this after switching to complex query, so join and group by might be involved somehow.\n",
  "hints_text": "",
  "created_at": "2024-03-18T13:30:55Z"
}