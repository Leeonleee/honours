diff --git a/build/platform/test_tool/host.ya.make.inc b/build/platform/test_tool/host.ya.make.inc
index fdf84687f2fc..5c08a611c7ae 100644
--- a/build/platform/test_tool/host.ya.make.inc
+++ b/build/platform/test_tool/host.ya.make.inc
@@ -1,12 +1,12 @@
 IF (HOST_OS_DARWIN AND HOST_ARCH_X86_64)
-    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6052371779)
+    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6101880269)
 ELSEIF (HOST_OS_DARWIN AND HOST_ARCH_ARM64)
-    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6052370170)
+    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6101879402)
 ELSEIF (HOST_OS_LINUX AND HOST_ARCH_X86_64)
-    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6052374369)
+    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6101882623)
 ELSEIF (HOST_OS_LINUX AND HOST_ARCH_AARCH64)
-    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6052369086)
+    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6101878379)
 ELSEIF (HOST_OS_WINDOWS AND HOST_ARCH_X86_64)
-    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6052372920)
+    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6101881365)
 
 ENDIF()
diff --git a/build/platform/test_tool/host_os.ya.make.inc b/build/platform/test_tool/host_os.ya.make.inc
index f28c64e58f57..53ed9b91a74e 100644
--- a/build/platform/test_tool/host_os.ya.make.inc
+++ b/build/platform/test_tool/host_os.ya.make.inc
@@ -1,12 +1,12 @@
 IF (HOST_OS_DARWIN AND HOST_ARCH_X86_64)
-    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6052177415)
+    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6101887681)
 ELSEIF (HOST_OS_DARWIN AND HOST_ARCH_ARM64)
-    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6052176424)
+    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6101887336)
 ELSEIF (HOST_OS_LINUX AND HOST_ARCH_X86_64)
-    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6052179215)
+    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6101888639)
 ELSEIF (HOST_OS_LINUX AND HOST_ARCH_AARCH64)
-    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6052175367)
+    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6101887021)
 ELSEIF (HOST_OS_WINDOWS AND HOST_ARCH_X86_64)
-    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6052178311)
+    DECLARE_EXTERNAL_RESOURCE(TEST_TOOL_HOST sbr:6101888065)
 
 ENDIF()
diff --git a/build/plugins/ytest.py b/build/plugins/ytest.py
index a290b831f364..e995e534a79c 100644
--- a/build/plugins/ytest.py
+++ b/build/plugins/ytest.py
@@ -636,9 +636,6 @@ def onadd_check(unit, *args):
     if check_type in ("check.data", "check.resource") and unit.get('VALIDATE_DATA') == "no":
         return
 
-    if check_type == "check.external" and (len(flat_args) == 1 or not flat_args[1]):
-        return
-
     test_dir = _common.get_norm_unit_path(unit)
 
     test_timeout = ''
diff --git a/build/scripts/gen_test_apk_gradle_script.py b/build/scripts/gen_test_apk_gradle_script.py
index 6efa7fd90fe4..0c37ae681821 100644
--- a/build/scripts/gen_test_apk_gradle_script.py
+++ b/build/scripts/gen_test_apk_gradle_script.py
@@ -71,7 +71,7 @@
     }}
 
     defaultConfig {{
-        minSdkVersion 21
+        minSdkVersion 23
         targetSdkVersion 33
         applicationId "{app_id}"
     }}
diff --git a/contrib/go/_std_1.21/src/internal/testlog/ya.make b/contrib/go/_std_1.21/src/internal/testlog/ya.make
deleted file mode 100644
index 1a6b08a6e850..000000000000
--- a/contrib/go/_std_1.21/src/internal/testlog/ya.make
+++ /dev/null
@@ -1,8 +0,0 @@
-GO_LIBRARY()
-IF (TRUE)
-    SRCS(
-		exit.go
-		log.go
-    )
-ENDIF()
-END()
diff --git a/contrib/go/_std_1.21/src/net/http/httptest/server.go b/contrib/go/_std_1.21/src/net/http/httptest/server.go
deleted file mode 100644
index f254a494d162..000000000000
--- a/contrib/go/_std_1.21/src/net/http/httptest/server.go
+++ /dev/null
@@ -1,385 +0,0 @@
-// Copyright 2011 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Implementation of Server
-
-package httptest
-
-import (
-	"crypto/tls"
-	"crypto/x509"
-	"flag"
-	"fmt"
-	"log"
-	"net"
-	"net/http"
-	"net/http/internal/testcert"
-	"os"
-	"strings"
-	"sync"
-	"time"
-)
-
-// A Server is an HTTP server listening on a system-chosen port on the
-// local loopback interface, for use in end-to-end HTTP tests.
-type Server struct {
-	URL      string // base URL of form http://ipaddr:port with no trailing slash
-	Listener net.Listener
-
-	// EnableHTTP2 controls whether HTTP/2 is enabled
-	// on the server. It must be set between calling
-	// NewUnstartedServer and calling Server.StartTLS.
-	EnableHTTP2 bool
-
-	// TLS is the optional TLS configuration, populated with a new config
-	// after TLS is started. If set on an unstarted server before StartTLS
-	// is called, existing fields are copied into the new config.
-	TLS *tls.Config
-
-	// Config may be changed after calling NewUnstartedServer and
-	// before Start or StartTLS.
-	Config *http.Server
-
-	// certificate is a parsed version of the TLS config certificate, if present.
-	certificate *x509.Certificate
-
-	// wg counts the number of outstanding HTTP requests on this server.
-	// Close blocks until all requests are finished.
-	wg sync.WaitGroup
-
-	mu     sync.Mutex // guards closed and conns
-	closed bool
-	conns  map[net.Conn]http.ConnState // except terminal states
-
-	// client is configured for use with the server.
-	// Its transport is automatically closed when Close is called.
-	client *http.Client
-}
-
-func newLocalListener() net.Listener {
-	if serveFlag != "" {
-		l, err := net.Listen("tcp", serveFlag)
-		if err != nil {
-			panic(fmt.Sprintf("httptest: failed to listen on %v: %v", serveFlag, err))
-		}
-		return l
-	}
-	l, err := net.Listen("tcp", "127.0.0.1:0")
-	if err != nil {
-		if l, err = net.Listen("tcp6", "[::1]:0"); err != nil {
-			panic(fmt.Sprintf("httptest: failed to listen on a port: %v", err))
-		}
-	}
-	return l
-}
-
-// When debugging a particular http server-based test,
-// this flag lets you run
-//
-//	go test -run=BrokenTest -httptest.serve=127.0.0.1:8000
-//
-// to start the broken server so you can interact with it manually.
-// We only register this flag if it looks like the caller knows about it
-// and is trying to use it as we don't want to pollute flags and this
-// isn't really part of our API. Don't depend on this.
-var serveFlag string
-
-func init() {
-	if strSliceContainsPrefix(os.Args, "-httptest.serve=") || strSliceContainsPrefix(os.Args, "--httptest.serve=") {
-		flag.StringVar(&serveFlag, "httptest.serve", "", "if non-empty, httptest.NewServer serves on this address and blocks.")
-	}
-}
-
-func strSliceContainsPrefix(v []string, pre string) bool {
-	for _, s := range v {
-		if strings.HasPrefix(s, pre) {
-			return true
-		}
-	}
-	return false
-}
-
-// NewServer starts and returns a new Server.
-// The caller should call Close when finished, to shut it down.
-func NewServer(handler http.Handler) *Server {
-	ts := NewUnstartedServer(handler)
-	ts.Start()
-	return ts
-}
-
-// NewUnstartedServer returns a new Server but doesn't start it.
-//
-// After changing its configuration, the caller should call Start or
-// StartTLS.
-//
-// The caller should call Close when finished, to shut it down.
-func NewUnstartedServer(handler http.Handler) *Server {
-	return &Server{
-		Listener: newLocalListener(),
-		Config:   &http.Server{Handler: handler},
-	}
-}
-
-// Start starts a server from NewUnstartedServer.
-func (s *Server) Start() {
-	if s.URL != "" {
-		panic("Server already started")
-	}
-	if s.client == nil {
-		s.client = &http.Client{Transport: &http.Transport{}}
-	}
-	s.URL = "http://" + s.Listener.Addr().String()
-	s.wrap()
-	s.goServe()
-	if serveFlag != "" {
-		fmt.Fprintln(os.Stderr, "httptest: serving on", s.URL)
-		select {}
-	}
-}
-
-// StartTLS starts TLS on a server from NewUnstartedServer.
-func (s *Server) StartTLS() {
-	if s.URL != "" {
-		panic("Server already started")
-	}
-	if s.client == nil {
-		s.client = &http.Client{Transport: &http.Transport{}}
-	}
-	cert, err := tls.X509KeyPair(testcert.LocalhostCert, testcert.LocalhostKey)
-	if err != nil {
-		panic(fmt.Sprintf("httptest: NewTLSServer: %v", err))
-	}
-
-	existingConfig := s.TLS
-	if existingConfig != nil {
-		s.TLS = existingConfig.Clone()
-	} else {
-		s.TLS = new(tls.Config)
-	}
-	if s.TLS.NextProtos == nil {
-		nextProtos := []string{"http/1.1"}
-		if s.EnableHTTP2 {
-			nextProtos = []string{"h2"}
-		}
-		s.TLS.NextProtos = nextProtos
-	}
-	if len(s.TLS.Certificates) == 0 {
-		s.TLS.Certificates = []tls.Certificate{cert}
-	}
-	s.certificate, err = x509.ParseCertificate(s.TLS.Certificates[0].Certificate[0])
-	if err != nil {
-		panic(fmt.Sprintf("httptest: NewTLSServer: %v", err))
-	}
-	certpool := x509.NewCertPool()
-	certpool.AddCert(s.certificate)
-	s.client.Transport = &http.Transport{
-		TLSClientConfig: &tls.Config{
-			RootCAs: certpool,
-		},
-		ForceAttemptHTTP2: s.EnableHTTP2,
-	}
-	s.Listener = tls.NewListener(s.Listener, s.TLS)
-	s.URL = "https://" + s.Listener.Addr().String()
-	s.wrap()
-	s.goServe()
-}
-
-// NewTLSServer starts and returns a new Server using TLS.
-// The caller should call Close when finished, to shut it down.
-func NewTLSServer(handler http.Handler) *Server {
-	ts := NewUnstartedServer(handler)
-	ts.StartTLS()
-	return ts
-}
-
-type closeIdleTransport interface {
-	CloseIdleConnections()
-}
-
-// Close shuts down the server and blocks until all outstanding
-// requests on this server have completed.
-func (s *Server) Close() {
-	s.mu.Lock()
-	if !s.closed {
-		s.closed = true
-		s.Listener.Close()
-		s.Config.SetKeepAlivesEnabled(false)
-		for c, st := range s.conns {
-			// Force-close any idle connections (those between
-			// requests) and new connections (those which connected
-			// but never sent a request). StateNew connections are
-			// super rare and have only been seen (in
-			// previously-flaky tests) in the case of
-			// socket-late-binding races from the http Client
-			// dialing this server and then getting an idle
-			// connection before the dial completed. There is thus
-			// a connected connection in StateNew with no
-			// associated Request. We only close StateIdle and
-			// StateNew because they're not doing anything. It's
-			// possible StateNew is about to do something in a few
-			// milliseconds, but a previous CL to check again in a
-			// few milliseconds wasn't liked (early versions of
-			// https://golang.org/cl/15151) so now we just
-			// forcefully close StateNew. The docs for Server.Close say
-			// we wait for "outstanding requests", so we don't close things
-			// in StateActive.
-			if st == http.StateIdle || st == http.StateNew {
-				s.closeConn(c)
-			}
-		}
-		// If this server doesn't shut down in 5 seconds, tell the user why.
-		t := time.AfterFunc(5*time.Second, s.logCloseHangDebugInfo)
-		defer t.Stop()
-	}
-	s.mu.Unlock()
-
-	// Not part of httptest.Server's correctness, but assume most
-	// users of httptest.Server will be using the standard
-	// transport, so help them out and close any idle connections for them.
-	if t, ok := http.DefaultTransport.(closeIdleTransport); ok {
-		t.CloseIdleConnections()
-	}
-
-	// Also close the client idle connections.
-	if s.client != nil {
-		if t, ok := s.client.Transport.(closeIdleTransport); ok {
-			t.CloseIdleConnections()
-		}
-	}
-
-	s.wg.Wait()
-}
-
-func (s *Server) logCloseHangDebugInfo() {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-	var buf strings.Builder
-	buf.WriteString("httptest.Server blocked in Close after 5 seconds, waiting for connections:
")
-	for c, st := range s.conns {
-		fmt.Fprintf(&buf, "  %T %p %v in state %v
", c, c, c.RemoteAddr(), st)
-	}
-	log.Print(buf.String())
-}
-
-// CloseClientConnections closes any open HTTP connections to the test Server.
-func (s *Server) CloseClientConnections() {
-	s.mu.Lock()
-	nconn := len(s.conns)
-	ch := make(chan struct{}, nconn)
-	for c := range s.conns {
-		go s.closeConnChan(c, ch)
-	}
-	s.mu.Unlock()
-
-	// Wait for outstanding closes to finish.
-	//
-	// Out of paranoia for making a late change in Go 1.6, we
-	// bound how long this can wait, since golang.org/issue/14291
-	// isn't fully understood yet. At least this should only be used
-	// in tests.
-	timer := time.NewTimer(5 * time.Second)
-	defer timer.Stop()
-	for i := 0; i < nconn; i++ {
-		select {
-		case <-ch:
-		case <-timer.C:
-			// Too slow. Give up.
-			return
-		}
-	}
-}
-
-// Certificate returns the certificate used by the server, or nil if
-// the server doesn't use TLS.
-func (s *Server) Certificate() *x509.Certificate {
-	return s.certificate
-}
-
-// Client returns an HTTP client configured for making requests to the server.
-// It is configured to trust the server's TLS test certificate and will
-// close its idle connections on Server.Close.
-func (s *Server) Client() *http.Client {
-	return s.client
-}
-
-func (s *Server) goServe() {
-	s.wg.Add(1)
-	go func() {
-		defer s.wg.Done()
-		s.Config.Serve(s.Listener)
-	}()
-}
-
-// wrap installs the connection state-tracking hook to know which
-// connections are idle.
-func (s *Server) wrap() {
-	oldHook := s.Config.ConnState
-	s.Config.ConnState = func(c net.Conn, cs http.ConnState) {
-		s.mu.Lock()
-		defer s.mu.Unlock()
-
-		switch cs {
-		case http.StateNew:
-			if _, exists := s.conns[c]; exists {
-				panic("invalid state transition")
-			}
-			if s.conns == nil {
-				s.conns = make(map[net.Conn]http.ConnState)
-			}
-			// Add c to the set of tracked conns and increment it to the
-			// waitgroup.
-			s.wg.Add(1)
-			s.conns[c] = cs
-			if s.closed {
-				// Probably just a socket-late-binding dial from
-				// the default transport that lost the race (and
-				// thus this connection is now idle and will
-				// never be used).
-				s.closeConn(c)
-			}
-		case http.StateActive:
-			if oldState, ok := s.conns[c]; ok {
-				if oldState != http.StateNew && oldState != http.StateIdle {
-					panic("invalid state transition")
-				}
-				s.conns[c] = cs
-			}
-		case http.StateIdle:
-			if oldState, ok := s.conns[c]; ok {
-				if oldState != http.StateActive {
-					panic("invalid state transition")
-				}
-				s.conns[c] = cs
-			}
-			if s.closed {
-				s.closeConn(c)
-			}
-		case http.StateHijacked, http.StateClosed:
-			// Remove c from the set of tracked conns and decrement it from the
-			// waitgroup, unless it was previously removed.
-			if _, ok := s.conns[c]; ok {
-				delete(s.conns, c)
-				// Keep Close from returning until the user's ConnState hook
-				// (if any) finishes.
-				defer s.wg.Done()
-			}
-		}
-		if oldHook != nil {
-			oldHook(c, cs)
-		}
-	}
-}
-
-// closeConn closes c.
-// s.mu must be held.
-func (s *Server) closeConn(c net.Conn) { s.closeConnChan(c, nil) }
-
-// closeConnChan is like closeConn, but takes an optional channel to receive a value
-// when the goroutine closing c is done.
-func (s *Server) closeConnChan(c net.Conn, done chan<- struct{}) {
-	c.Close()
-	if done != nil {
-		done <- struct{}{}
-	}
-}
diff --git a/contrib/go/_std_1.21/src/net/http/httptest/ya.make b/contrib/go/_std_1.21/src/net/http/httptest/ya.make
deleted file mode 100644
index 1b030201584e..000000000000
--- a/contrib/go/_std_1.21/src/net/http/httptest/ya.make
+++ /dev/null
@@ -1,9 +0,0 @@
-GO_LIBRARY()
-IF (TRUE)
-    SRCS(
-		httptest.go
-		recorder.go
-		server.go
-    )
-ENDIF()
-END()
diff --git a/contrib/go/_std_1.21/src/net/http/internal/testcert/ya.make b/contrib/go/_std_1.21/src/net/http/internal/testcert/ya.make
deleted file mode 100644
index f55b3d806911..000000000000
--- a/contrib/go/_std_1.21/src/net/http/internal/testcert/ya.make
+++ /dev/null
@@ -1,7 +0,0 @@
-GO_LIBRARY()
-IF (TRUE)
-    SRCS(
-		testcert.go
-    )
-ENDIF()
-END()
diff --git a/contrib/go/_std_1.21/src/runtime/test_amd64.s b/contrib/go/_std_1.21/src/runtime/test_amd64.s
deleted file mode 100644
index 80fa8c99489f..000000000000
--- a/contrib/go/_std_1.21/src/runtime/test_amd64.s
+++ /dev/null
@@ -1,7 +0,0 @@
-// Create a large frame to force stack growth. See #62326.
-TEXT ·testSPWrite(SB),0,$16384-0
-	// Write to SP
-	MOVQ SP, AX
-	ANDQ $~0xf, SP
-	MOVQ AX, SP
-	RET
diff --git a/contrib/go/_std_1.21/src/testing/example.go b/contrib/go/_std_1.21/src/testing/example.go
deleted file mode 100644
index 42ee555cb28f..000000000000
--- a/contrib/go/_std_1.21/src/testing/example.go
+++ /dev/null
@@ -1,101 +0,0 @@
-// Copyright 2009 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package testing
-
-import (
-	"fmt"
-	"os"
-	"sort"
-	"strings"
-	"time"
-)
-
-type InternalExample struct {
-	Name      string
-	F         func()
-	Output    string
-	Unordered bool
-}
-
-// RunExamples is an internal function but exported because it is cross-package;
-// it is part of the implementation of the "go test" command.
-func RunExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ok bool) {
-	_, ok = runExamples(matchString, examples)
-	return ok
-}
-
-func runExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ran, ok bool) {
-	ok = true
-
-	var eg InternalExample
-
-	for _, eg = range examples {
-		matched, err := matchString(*match, eg.Name)
-		if err != nil {
-			fmt.Fprintf(os.Stderr, "testing: invalid regexp for -test.run: %s
", err)
-			os.Exit(1)
-		}
-		if !matched {
-			continue
-		}
-		ran = true
-		if !runExample(eg) {
-			ok = false
-		}
-	}
-
-	return ran, ok
-}
-
-func sortLines(output string) string {
-	lines := strings.Split(output, "
")
-	sort.Strings(lines)
-	return strings.Join(lines, "
")
-}
-
-// processRunResult computes a summary and status of the result of running an example test.
-// stdout is the captured output from stdout of the test.
-// recovered is the result of invoking recover after running the test, in case it panicked.
-//
-// If stdout doesn't match the expected output or if recovered is non-nil, it'll print the cause of failure to stdout.
-// If the test is chatty/verbose, it'll print a success message to stdout.
-// If recovered is non-nil, it'll panic with that value.
-// If the test panicked with nil, or invoked runtime.Goexit, it'll be
-// made to fail and panic with errNilPanicOrGoexit
-func (eg *InternalExample) processRunResult(stdout string, timeSpent time.Duration, finished bool, recovered any) (passed bool) {
-	passed = true
-	dstr := fmtDuration(timeSpent)
-	var fail string
-	got := strings.TrimSpace(stdout)
-	want := strings.TrimSpace(eg.Output)
-	if eg.Unordered {
-		if sortLines(got) != sortLines(want) && recovered == nil {
-			fail = fmt.Sprintf("got:
%s
want (unordered):
%s
", stdout, eg.Output)
-		}
-	} else {
-		if got != want && recovered == nil {
-			fail = fmt.Sprintf("got:
%s
want:
%s
", got, want)
-		}
-	}
-	if fail != "" || !finished || recovered != nil {
-		fmt.Printf("%s--- FAIL: %s (%s)
%s", chatty.prefix(), eg.Name, dstr, fail)
-		passed = false
-	} else if chatty.on {
-		fmt.Printf("%s--- PASS: %s (%s)
", chatty.prefix(), eg.Name, dstr)
-	}
-
-	if chatty.on && chatty.json {
-		fmt.Printf("%s=== NAME   %s
", chatty.prefix(), "")
-	}
-
-	if recovered != nil {
-		// Propagate the previously recovered result, by panicking.
-		panic(recovered)
-	} else if !finished {
-		panic(errNilPanicOrGoexit)
-	}
-
-	return
-}
diff --git a/contrib/go/_std_1.21/src/testing/internal/testdeps/ya.make b/contrib/go/_std_1.21/src/testing/internal/testdeps/ya.make
deleted file mode 100644
index badabe43b97e..000000000000
--- a/contrib/go/_std_1.21/src/testing/internal/testdeps/ya.make
+++ /dev/null
@@ -1,7 +0,0 @@
-GO_LIBRARY()
-IF (TRUE)
-    SRCS(
-		deps.go
-    )
-ENDIF()
-END()
diff --git a/contrib/go/_std_1.21/src/testing/match.go b/contrib/go/_std_1.21/src/testing/match.go
deleted file mode 100644
index 92b7dc622de2..000000000000
--- a/contrib/go/_std_1.21/src/testing/match.go
+++ /dev/null
@@ -1,319 +0,0 @@
-// Copyright 2015 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package testing
-
-import (
-	"fmt"
-	"os"
-	"strconv"
-	"strings"
-	"sync"
-)
-
-// matcher sanitizes, uniques, and filters names of subtests and subbenchmarks.
-type matcher struct {
-	filter    filterMatch
-	skip      filterMatch
-	matchFunc func(pat, str string) (bool, error)
-
-	mu sync.Mutex
-
-	// subNames is used to deduplicate subtest names.
-	// Each key is the subtest name joined to the deduplicated name of the parent test.
-	// Each value is the count of the number of occurrences of the given subtest name
-	// already seen.
-	subNames map[string]int32
-}
-
-type filterMatch interface {
-	// matches checks the name against the receiver's pattern strings using the
-	// given match function.
-	matches(name []string, matchString func(pat, str string) (bool, error)) (ok, partial bool)
-
-	// verify checks that the receiver's pattern strings are valid filters by
-	// calling the given match function.
-	verify(name string, matchString func(pat, str string) (bool, error)) error
-}
-
-// simpleMatch matches a test name if all of the pattern strings match in
-// sequence.
-type simpleMatch []string
-
-// alternationMatch matches a test name if one of the alternations match.
-type alternationMatch []filterMatch
-
-// TODO: fix test_main to avoid race and improve caching, also allowing to
-// eliminate this Mutex.
-var matchMutex sync.Mutex
-
-func allMatcher() *matcher {
-	return newMatcher(nil, "", "", "")
-}
-
-func newMatcher(matchString func(pat, str string) (bool, error), patterns, name, skips string) *matcher {
-	var filter, skip filterMatch
-	if patterns == "" {
-		filter = simpleMatch{} // always partial true
-	} else {
-		filter = splitRegexp(patterns)
-		if err := filter.verify(name, matchString); err != nil {
-			fmt.Fprintf(os.Stderr, "testing: invalid regexp for %s
", err)
-			os.Exit(1)
-		}
-	}
-	if skips == "" {
-		skip = alternationMatch{} // always false
-	} else {
-		skip = splitRegexp(skips)
-		if err := skip.verify("-test.skip", matchString); err != nil {
-			fmt.Fprintf(os.Stderr, "testing: invalid regexp for %v
", err)
-			os.Exit(1)
-		}
-	}
-	return &matcher{
-		filter:    filter,
-		skip:      skip,
-		matchFunc: matchString,
-		subNames:  map[string]int32{},
-	}
-}
-
-func (m *matcher) fullName(c *common, subname string) (name string, ok, partial bool) {
-	name = subname
-
-	m.mu.Lock()
-	defer m.mu.Unlock()
-
-	if c != nil && c.level > 0 {
-		name = m.unique(c.name, rewrite(subname))
-	}
-
-	matchMutex.Lock()
-	defer matchMutex.Unlock()
-
-	// We check the full array of paths each time to allow for the case that a pattern contains a '/'.
-	elem := strings.Split(name, "/")
-
-	// filter must match.
-	// accept partial match that may produce full match later.
-	ok, partial = m.filter.matches(elem, m.matchFunc)
-	if !ok {
-		return name, false, false
-	}
-
-	// skip must not match.
-	// ignore partial match so we can get to more precise match later.
-	skip, partialSkip := m.skip.matches(elem, m.matchFunc)
-	if skip && !partialSkip {
-		return name, false, false
-	}
-
-	return name, ok, partial
-}
-
-// clearSubNames clears the matcher's internal state, potentially freeing
-// memory. After this is called, T.Name may return the same strings as it did
-// for earlier subtests.
-func (m *matcher) clearSubNames() {
-	m.mu.Lock()
-	defer m.mu.Unlock()
-	for key := range m.subNames {
-		delete(m.subNames, key)
-	}
-}
-
-func (m simpleMatch) matches(name []string, matchString func(pat, str string) (bool, error)) (ok, partial bool) {
-	for i, s := range name {
-		if i >= len(m) {
-			break
-		}
-		if ok, _ := matchString(m[i], s); !ok {
-			return false, false
-		}
-	}
-	return true, len(name) < len(m)
-}
-
-func (m simpleMatch) verify(name string, matchString func(pat, str string) (bool, error)) error {
-	for i, s := range m {
-		m[i] = rewrite(s)
-	}
-	// Verify filters before doing any processing.
-	for i, s := range m {
-		if _, err := matchString(s, "non-empty"); err != nil {
-			return fmt.Errorf("element %d of %s (%q): %s", i, name, s, err)
-		}
-	}
-	return nil
-}
-
-func (m alternationMatch) matches(name []string, matchString func(pat, str string) (bool, error)) (ok, partial bool) {
-	for _, m := range m {
-		if ok, partial = m.matches(name, matchString); ok {
-			return ok, partial
-		}
-	}
-	return false, false
-}
-
-func (m alternationMatch) verify(name string, matchString func(pat, str string) (bool, error)) error {
-	for i, m := range m {
-		if err := m.verify(name, matchString); err != nil {
-			return fmt.Errorf("alternation %d of %s", i, err)
-		}
-	}
-	return nil
-}
-
-func splitRegexp(s string) filterMatch {
-	a := make(simpleMatch, 0, strings.Count(s, "/"))
-	b := make(alternationMatch, 0, strings.Count(s, "|"))
-	cs := 0
-	cp := 0
-	for i := 0; i < len(s); {
-		switch s[i] {
-		case '[':
-			cs++
-		case ']':
-			if cs--; cs < 0 { // An unmatched ']' is legal.
-				cs = 0
-			}
-		case '(':
-			if cs == 0 {
-				cp++
-			}
-		case ')':
-			if cs == 0 {
-				cp--
-			}
-		case '\\':
-			i++
-		case '/':
-			if cs == 0 && cp == 0 {
-				a = append(a, s[:i])
-				s = s[i+1:]
-				i = 0
-				continue
-			}
-		case '|':
-			if cs == 0 && cp == 0 {
-				a = append(a, s[:i])
-				s = s[i+1:]
-				i = 0
-				b = append(b, a)
-				a = make(simpleMatch, 0, len(a))
-				continue
-			}
-		}
-		i++
-	}
-
-	a = append(a, s)
-	if len(b) == 0 {
-		return a
-	}
-	return append(b, a)
-}
-
-// unique creates a unique name for the given parent and subname by affixing it
-// with one or more counts, if necessary.
-func (m *matcher) unique(parent, subname string) string {
-	base := parent + "/" + subname
-
-	for {
-		n := m.subNames[base]
-		if n < 0 {
-			panic("subtest count overflow")
-		}
-		m.subNames[base] = n + 1
-
-		if n == 0 && subname != "" {
-			prefix, nn := parseSubtestNumber(base)
-			if len(prefix) < len(base) && nn < m.subNames[prefix] {
-				// This test is explicitly named like "parent/subname#NN",
-				// and #NN was already used for the NNth occurrence of "parent/subname".
-				// Loop to add a disambiguating suffix.
-				continue
-			}
-			return base
-		}
-
-		name := fmt.Sprintf("%s#%02d", base, n)
-		if m.subNames[name] != 0 {
-			// This is the nth occurrence of base, but the name "parent/subname#NN"
-			// collides with the first occurrence of a subtest *explicitly* named
-			// "parent/subname#NN". Try the next number.
-			continue
-		}
-
-		return name
-	}
-}
-
-// parseSubtestNumber splits a subtest name into a "#%02d"-formatted int32
-// suffix (if present), and a prefix preceding that suffix (always).
-func parseSubtestNumber(s string) (prefix string, nn int32) {
-	i := strings.LastIndex(s, "#")
-	if i < 0 {
-		return s, 0
-	}
-
-	prefix, suffix := s[:i], s[i+1:]
-	if len(suffix) < 2 || (len(suffix) > 2 && suffix[0] == '0') {
-		// Even if suffix is numeric, it is not a possible output of a "%02" format
-		// string: it has either too few digits or too many leading zeroes.
-		return s, 0
-	}
-	if suffix == "00" {
-		if !strings.HasSuffix(prefix, "/") {
-			// We only use "#00" as a suffix for subtests named with the empty
-			// string — it isn't a valid suffix if the subtest name is non-empty.
-			return s, 0
-		}
-	}
-
-	n, err := strconv.ParseInt(suffix, 10, 32)
-	if err != nil || n < 0 {
-		return s, 0
-	}
-	return prefix, int32(n)
-}
-
-// rewrite rewrites a subname to having only printable characters and no white
-// space.
-func rewrite(s string) string {
-	b := []byte{}
-	for _, r := range s {
-		switch {
-		case isSpace(r):
-			b = append(b, '_')
-		case !strconv.IsPrint(r):
-			s := strconv.QuoteRune(r)
-			b = append(b, s[1:len(s)-1]...)
-		default:
-			b = append(b, string(r)...)
-		}
-	}
-	return string(b)
-}
-
-func isSpace(r rune) bool {
-	if r < 0x2000 {
-		switch r {
-		// Note: not the same as Unicode Z class.
-		case '\t', '
', '\v', '\f', '\r', ' ', 0x85, 0xA0, 0x1680:
-			return true
-		}
-	} else {
-		if r <= 0x200a {
-			return true
-		}
-		switch r {
-		case 0x2028, 0x2029, 0x202f, 0x205f, 0x3000:
-			return true
-		}
-	}
-	return false
-}
diff --git a/contrib/go/_std_1.21/src/testing/ya.make b/contrib/go/_std_1.21/src/testing/ya.make
deleted file mode 100644
index 80c42e2d1864..000000000000
--- a/contrib/go/_std_1.21/src/testing/ya.make
+++ /dev/null
@@ -1,29 +0,0 @@
-GO_LIBRARY()
-IF (OS_DARWIN AND ARCH_ARM64 AND RACE AND CGO_ENABLED OR OS_DARWIN AND ARCH_ARM64 AND RACE AND NOT CGO_ENABLED OR OS_DARWIN AND ARCH_ARM64 AND NOT RACE AND CGO_ENABLED OR OS_DARWIN AND ARCH_ARM64 AND NOT RACE AND NOT CGO_ENABLED OR OS_DARWIN AND ARCH_X86_64 AND RACE AND CGO_ENABLED OR OS_DARWIN AND ARCH_X86_64 AND RACE AND NOT CGO_ENABLED OR OS_DARWIN AND ARCH_X86_64 AND NOT RACE AND CGO_ENABLED OR OS_DARWIN AND ARCH_X86_64 AND NOT RACE AND NOT CGO_ENABLED OR OS_LINUX AND ARCH_AARCH64 AND RACE AND CGO_ENABLED OR OS_LINUX AND ARCH_AARCH64 AND RACE AND NOT CGO_ENABLED OR OS_LINUX AND ARCH_AARCH64 AND NOT RACE AND CGO_ENABLED OR OS_LINUX AND ARCH_AARCH64 AND NOT RACE AND NOT CGO_ENABLED OR OS_LINUX AND ARCH_X86_64 AND RACE AND CGO_ENABLED OR OS_LINUX AND ARCH_X86_64 AND RACE AND NOT CGO_ENABLED OR OS_LINUX AND ARCH_X86_64 AND NOT RACE AND CGO_ENABLED OR OS_LINUX AND ARCH_X86_64 AND NOT RACE AND NOT CGO_ENABLED)
-    SRCS(
-		allocs.go
-		benchmark.go
-		cover.go
-		example.go
-		fuzz.go
-		match.go
-		newcover.go
-		run_example.go
-		testing.go
-		testing_other.go
-    )
-ELSEIF (OS_WINDOWS AND ARCH_X86_64 AND RACE AND CGO_ENABLED OR OS_WINDOWS AND ARCH_X86_64 AND RACE AND NOT CGO_ENABLED OR OS_WINDOWS AND ARCH_X86_64 AND NOT RACE AND CGO_ENABLED OR OS_WINDOWS AND ARCH_X86_64 AND NOT RACE AND NOT CGO_ENABLED)
-    SRCS(
-		allocs.go
-		benchmark.go
-		cover.go
-		example.go
-		fuzz.go
-		match.go
-		newcover.go
-		run_example.go
-		testing.go
-		testing_windows.go
-    )
-ENDIF()
-END()
diff --git a/contrib/go/_std_1.21/src/internal/abi/abi_test.s b/contrib/go/_std_1.22/src/internal/abi/abi_test.s
similarity index 100%
rename from contrib/go/_std_1.21/src/internal/abi/abi_test.s
rename to contrib/go/_std_1.22/src/internal/abi/abi_test.s
diff --git a/contrib/go/_std_1.21/src/internal/testlog/exit.go b/contrib/go/_std_1.22/src/internal/testlog/exit.go
similarity index 100%
rename from contrib/go/_std_1.21/src/internal/testlog/exit.go
rename to contrib/go/_std_1.22/src/internal/testlog/exit.go
diff --git a/contrib/go/_std_1.21/src/internal/testlog/log.go b/contrib/go/_std_1.22/src/internal/testlog/log.go
similarity index 100%
rename from contrib/go/_std_1.21/src/internal/testlog/log.go
rename to contrib/go/_std_1.22/src/internal/testlog/log.go
diff --git a/contrib/go/_std_1.22/src/internal/testlog/ya.make b/contrib/go/_std_1.22/src/internal/testlog/ya.make
new file mode 100644
index 000000000000..9083a354b8c9
--- /dev/null
+++ b/contrib/go/_std_1.22/src/internal/testlog/ya.make
@@ -0,0 +1,8 @@
+GO_LIBRARY()
+IF (TRUE)
+    SRCS(
+        exit.go
+        log.go
+    )
+ENDIF()
+END()
diff --git a/contrib/go/_std_1.21/src/net/http/httptest/httptest.go b/contrib/go/_std_1.22/src/net/http/httptest/httptest.go
similarity index 97%
rename from contrib/go/_std_1.21/src/net/http/httptest/httptest.go
rename to contrib/go/_std_1.22/src/net/http/httptest/httptest.go
index 9bedefd2bc0a..f0ca64362d7f 100644
--- a/contrib/go/_std_1.21/src/net/http/httptest/httptest.go
+++ b/contrib/go/_std_1.22/src/net/http/httptest/httptest.go
@@ -15,7 +15,7 @@ import (
 )
 
 // NewRequest returns a new incoming server Request, suitable
-// for passing to an http.Handler for testing.
+// for passing to an [http.Handler] for testing.
 //
 // The target is the RFC 7230 "request-target": it may be either a
 // path or an absolute URL. If target is an absolute URL, the host name
diff --git a/contrib/go/_std_1.21/src/net/http/httptest/recorder.go b/contrib/go/_std_1.22/src/net/http/httptest/recorder.go
similarity index 91%
rename from contrib/go/_std_1.21/src/net/http/httptest/recorder.go
rename to contrib/go/_std_1.22/src/net/http/httptest/recorder.go
index 1c1d8801558e..dd51901b0d3b 100644
--- a/contrib/go/_std_1.21/src/net/http/httptest/recorder.go
+++ b/contrib/go/_std_1.22/src/net/http/httptest/recorder.go
@@ -16,7 +16,7 @@ import (
 	"golang.org/x/net/http/httpguts"
 )
 
-// ResponseRecorder is an implementation of http.ResponseWriter that
+// ResponseRecorder is an implementation of [http.ResponseWriter] that
 // records its mutations for later inspection in tests.
 type ResponseRecorder struct {
 	// Code is the HTTP response code set by WriteHeader.
@@ -47,7 +47,7 @@ type ResponseRecorder struct {
 	wroteHeader bool
 }
 
-// NewRecorder returns an initialized ResponseRecorder.
+// NewRecorder returns an initialized [ResponseRecorder].
 func NewRecorder() *ResponseRecorder {
 	return &ResponseRecorder{
 		HeaderMap: make(http.Header),
@@ -57,12 +57,12 @@ func NewRecorder() *ResponseRecorder {
 }
 
 // DefaultRemoteAddr is the default remote address to return in RemoteAddr if
-// an explicit DefaultRemoteAddr isn't set on ResponseRecorder.
+// an explicit DefaultRemoteAddr isn't set on [ResponseRecorder].
 const DefaultRemoteAddr = "1.2.3.4"
 
-// Header implements http.ResponseWriter. It returns the response
+// Header implements [http.ResponseWriter]. It returns the response
 // headers to mutate within a handler. To test the headers that were
-// written after a handler completes, use the Result method and see
+// written after a handler completes, use the [ResponseRecorder.Result] method and see
 // the returned Response value's Header.
 func (rw *ResponseRecorder) Header() http.Header {
 	m := rw.HeaderMap
@@ -112,7 +112,7 @@ func (rw *ResponseRecorder) Write(buf []byte) (int, error) {
 	return len(buf), nil
 }
 
-// WriteString implements io.StringWriter. The data in str is written
+// WriteString implements [io.StringWriter]. The data in str is written
 // to rw.Body, if not nil.
 func (rw *ResponseRecorder) WriteString(str string) (int, error) {
 	rw.writeHeader(nil, str)
@@ -139,7 +139,7 @@ func checkWriteHeaderCode(code int) {
 	}
 }
 
-// WriteHeader implements http.ResponseWriter.
+// WriteHeader implements [http.ResponseWriter].
 func (rw *ResponseRecorder) WriteHeader(code int) {
 	if rw.wroteHeader {
 		return
@@ -154,7 +154,7 @@ func (rw *ResponseRecorder) WriteHeader(code int) {
 	rw.snapHeader = rw.HeaderMap.Clone()
 }
 
-// Flush implements http.Flusher. To test whether Flush was
+// Flush implements [http.Flusher]. To test whether Flush was
 // called, see rw.Flushed.
 func (rw *ResponseRecorder) Flush() {
 	if !rw.wroteHeader {
@@ -175,7 +175,7 @@ func (rw *ResponseRecorder) Flush() {
 // did a write.
 //
 // The Response.Body is guaranteed to be non-nil and Body.Read call is
-// guaranteed to not return any error other than io.EOF.
+// guaranteed to not return any error other than [io.EOF].
 //
 // Result must only be called after the handler has finished running.
 func (rw *ResponseRecorder) Result() *http.Response {
diff --git a/contrib/go/_std_1.22/src/net/http/httptest/server.go b/contrib/go/_std_1.22/src/net/http/httptest/server.go
new file mode 100644
index 000000000000..5095b438ec94
--- /dev/null
+++ b/contrib/go/_std_1.22/src/net/http/httptest/server.go
@@ -0,0 +1,385 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Implementation of Server
+
+package httptest
+
+import (
+	"crypto/tls"
+	"crypto/x509"
+	"flag"
+	"fmt"
+	"log"
+	"net"
+	"net/http"
+	"net/http/internal/testcert"
+	"os"
+	"strings"
+	"sync"
+	"time"
+)
+
+// A Server is an HTTP server listening on a system-chosen port on the
+// local loopback interface, for use in end-to-end HTTP tests.
+type Server struct {
+	URL      string // base URL of form http://ipaddr:port with no trailing slash
+	Listener net.Listener
+
+	// EnableHTTP2 controls whether HTTP/2 is enabled
+	// on the server. It must be set between calling
+	// NewUnstartedServer and calling Server.StartTLS.
+	EnableHTTP2 bool
+
+	// TLS is the optional TLS configuration, populated with a new config
+	// after TLS is started. If set on an unstarted server before StartTLS
+	// is called, existing fields are copied into the new config.
+	TLS *tls.Config
+
+	// Config may be changed after calling NewUnstartedServer and
+	// before Start or StartTLS.
+	Config *http.Server
+
+	// certificate is a parsed version of the TLS config certificate, if present.
+	certificate *x509.Certificate
+
+	// wg counts the number of outstanding HTTP requests on this server.
+	// Close blocks until all requests are finished.
+	wg sync.WaitGroup
+
+	mu     sync.Mutex // guards closed and conns
+	closed bool
+	conns  map[net.Conn]http.ConnState // except terminal states
+
+	// client is configured for use with the server.
+	// Its transport is automatically closed when Close is called.
+	client *http.Client
+}
+
+func newLocalListener() net.Listener {
+	if serveFlag != "" {
+		l, err := net.Listen("tcp", serveFlag)
+		if err != nil {
+			panic(fmt.Sprintf("httptest: failed to listen on %v: %v", serveFlag, err))
+		}
+		return l
+	}
+	l, err := net.Listen("tcp", "127.0.0.1:0")
+	if err != nil {
+		if l, err = net.Listen("tcp6", "[::1]:0"); err != nil {
+			panic(fmt.Sprintf("httptest: failed to listen on a port: %v", err))
+		}
+	}
+	return l
+}
+
+// When debugging a particular http server-based test,
+// this flag lets you run
+//
+//	go test -run='^BrokenTest$' -httptest.serve=127.0.0.1:8000
+//
+// to start the broken server so you can interact with it manually.
+// We only register this flag if it looks like the caller knows about it
+// and is trying to use it as we don't want to pollute flags and this
+// isn't really part of our API. Don't depend on this.
+var serveFlag string
+
+func init() {
+	if strSliceContainsPrefix(os.Args, "-httptest.serve=") || strSliceContainsPrefix(os.Args, "--httptest.serve=") {
+		flag.StringVar(&serveFlag, "httptest.serve", "", "if non-empty, httptest.NewServer serves on this address and blocks.")
+	}
+}
+
+func strSliceContainsPrefix(v []string, pre string) bool {
+	for _, s := range v {
+		if strings.HasPrefix(s, pre) {
+			return true
+		}
+	}
+	return false
+}
+
+// NewServer starts and returns a new [Server].
+// The caller should call Close when finished, to shut it down.
+func NewServer(handler http.Handler) *Server {
+	ts := NewUnstartedServer(handler)
+	ts.Start()
+	return ts
+}
+
+// NewUnstartedServer returns a new [Server] but doesn't start it.
+//
+// After changing its configuration, the caller should call Start or
+// StartTLS.
+//
+// The caller should call Close when finished, to shut it down.
+func NewUnstartedServer(handler http.Handler) *Server {
+	return &Server{
+		Listener: newLocalListener(),
+		Config:   &http.Server{Handler: handler},
+	}
+}
+
+// Start starts a server from NewUnstartedServer.
+func (s *Server) Start() {
+	if s.URL != "" {
+		panic("Server already started")
+	}
+	if s.client == nil {
+		s.client = &http.Client{Transport: &http.Transport{}}
+	}
+	s.URL = "http://" + s.Listener.Addr().String()
+	s.wrap()
+	s.goServe()
+	if serveFlag != "" {
+		fmt.Fprintln(os.Stderr, "httptest: serving on", s.URL)
+		select {}
+	}
+}
+
+// StartTLS starts TLS on a server from NewUnstartedServer.
+func (s *Server) StartTLS() {
+	if s.URL != "" {
+		panic("Server already started")
+	}
+	if s.client == nil {
+		s.client = &http.Client{}
+	}
+	cert, err := tls.X509KeyPair(testcert.LocalhostCert, testcert.LocalhostKey)
+	if err != nil {
+		panic(fmt.Sprintf("httptest: NewTLSServer: %v", err))
+	}
+
+	existingConfig := s.TLS
+	if existingConfig != nil {
+		s.TLS = existingConfig.Clone()
+	} else {
+		s.TLS = new(tls.Config)
+	}
+	if s.TLS.NextProtos == nil {
+		nextProtos := []string{"http/1.1"}
+		if s.EnableHTTP2 {
+			nextProtos = []string{"h2"}
+		}
+		s.TLS.NextProtos = nextProtos
+	}
+	if len(s.TLS.Certificates) == 0 {
+		s.TLS.Certificates = []tls.Certificate{cert}
+	}
+	s.certificate, err = x509.ParseCertificate(s.TLS.Certificates[0].Certificate[0])
+	if err != nil {
+		panic(fmt.Sprintf("httptest: NewTLSServer: %v", err))
+	}
+	certpool := x509.NewCertPool()
+	certpool.AddCert(s.certificate)
+	s.client.Transport = &http.Transport{
+		TLSClientConfig: &tls.Config{
+			RootCAs: certpool,
+		},
+		ForceAttemptHTTP2: s.EnableHTTP2,
+	}
+	s.Listener = tls.NewListener(s.Listener, s.TLS)
+	s.URL = "https://" + s.Listener.Addr().String()
+	s.wrap()
+	s.goServe()
+}
+
+// NewTLSServer starts and returns a new [Server] using TLS.
+// The caller should call Close when finished, to shut it down.
+func NewTLSServer(handler http.Handler) *Server {
+	ts := NewUnstartedServer(handler)
+	ts.StartTLS()
+	return ts
+}
+
+type closeIdleTransport interface {
+	CloseIdleConnections()
+}
+
+// Close shuts down the server and blocks until all outstanding
+// requests on this server have completed.
+func (s *Server) Close() {
+	s.mu.Lock()
+	if !s.closed {
+		s.closed = true
+		s.Listener.Close()
+		s.Config.SetKeepAlivesEnabled(false)
+		for c, st := range s.conns {
+			// Force-close any idle connections (those between
+			// requests) and new connections (those which connected
+			// but never sent a request). StateNew connections are
+			// super rare and have only been seen (in
+			// previously-flaky tests) in the case of
+			// socket-late-binding races from the http Client
+			// dialing this server and then getting an idle
+			// connection before the dial completed. There is thus
+			// a connected connection in StateNew with no
+			// associated Request. We only close StateIdle and
+			// StateNew because they're not doing anything. It's
+			// possible StateNew is about to do something in a few
+			// milliseconds, but a previous CL to check again in a
+			// few milliseconds wasn't liked (early versions of
+			// https://golang.org/cl/15151) so now we just
+			// forcefully close StateNew. The docs for Server.Close say
+			// we wait for "outstanding requests", so we don't close things
+			// in StateActive.
+			if st == http.StateIdle || st == http.StateNew {
+				s.closeConn(c)
+			}
+		}
+		// If this server doesn't shut down in 5 seconds, tell the user why.
+		t := time.AfterFunc(5*time.Second, s.logCloseHangDebugInfo)
+		defer t.Stop()
+	}
+	s.mu.Unlock()
+
+	// Not part of httptest.Server's correctness, but assume most
+	// users of httptest.Server will be using the standard
+	// transport, so help them out and close any idle connections for them.
+	if t, ok := http.DefaultTransport.(closeIdleTransport); ok {
+		t.CloseIdleConnections()
+	}
+
+	// Also close the client idle connections.
+	if s.client != nil {
+		if t, ok := s.client.Transport.(closeIdleTransport); ok {
+			t.CloseIdleConnections()
+		}
+	}
+
+	s.wg.Wait()
+}
+
+func (s *Server) logCloseHangDebugInfo() {
+	s.mu.Lock()
+	defer s.mu.Unlock()
+	var buf strings.Builder
+	buf.WriteString("httptest.Server blocked in Close after 5 seconds, waiting for connections:
")
+	for c, st := range s.conns {
+		fmt.Fprintf(&buf, "  %T %p %v in state %v
", c, c, c.RemoteAddr(), st)
+	}
+	log.Print(buf.String())
+}
+
+// CloseClientConnections closes any open HTTP connections to the test Server.
+func (s *Server) CloseClientConnections() {
+	s.mu.Lock()
+	nconn := len(s.conns)
+	ch := make(chan struct{}, nconn)
+	for c := range s.conns {
+		go s.closeConnChan(c, ch)
+	}
+	s.mu.Unlock()
+
+	// Wait for outstanding closes to finish.
+	//
+	// Out of paranoia for making a late change in Go 1.6, we
+	// bound how long this can wait, since golang.org/issue/14291
+	// isn't fully understood yet. At least this should only be used
+	// in tests.
+	timer := time.NewTimer(5 * time.Second)
+	defer timer.Stop()
+	for i := 0; i < nconn; i++ {
+		select {
+		case <-ch:
+		case <-timer.C:
+			// Too slow. Give up.
+			return
+		}
+	}
+}
+
+// Certificate returns the certificate used by the server, or nil if
+// the server doesn't use TLS.
+func (s *Server) Certificate() *x509.Certificate {
+	return s.certificate
+}
+
+// Client returns an HTTP client configured for making requests to the server.
+// It is configured to trust the server's TLS test certificate and will
+// close its idle connections on [Server.Close].
+func (s *Server) Client() *http.Client {
+	return s.client
+}
+
+func (s *Server) goServe() {
+	s.wg.Add(1)
+	go func() {
+		defer s.wg.Done()
+		s.Config.Serve(s.Listener)
+	}()
+}
+
+// wrap installs the connection state-tracking hook to know which
+// connections are idle.
+func (s *Server) wrap() {
+	oldHook := s.Config.ConnState
+	s.Config.ConnState = func(c net.Conn, cs http.ConnState) {
+		s.mu.Lock()
+		defer s.mu.Unlock()
+
+		switch cs {
+		case http.StateNew:
+			if _, exists := s.conns[c]; exists {
+				panic("invalid state transition")
+			}
+			if s.conns == nil {
+				s.conns = make(map[net.Conn]http.ConnState)
+			}
+			// Add c to the set of tracked conns and increment it to the
+			// waitgroup.
+			s.wg.Add(1)
+			s.conns[c] = cs
+			if s.closed {
+				// Probably just a socket-late-binding dial from
+				// the default transport that lost the race (and
+				// thus this connection is now idle and will
+				// never be used).
+				s.closeConn(c)
+			}
+		case http.StateActive:
+			if oldState, ok := s.conns[c]; ok {
+				if oldState != http.StateNew && oldState != http.StateIdle {
+					panic("invalid state transition")
+				}
+				s.conns[c] = cs
+			}
+		case http.StateIdle:
+			if oldState, ok := s.conns[c]; ok {
+				if oldState != http.StateActive {
+					panic("invalid state transition")
+				}
+				s.conns[c] = cs
+			}
+			if s.closed {
+				s.closeConn(c)
+			}
+		case http.StateHijacked, http.StateClosed:
+			// Remove c from the set of tracked conns and decrement it from the
+			// waitgroup, unless it was previously removed.
+			if _, ok := s.conns[c]; ok {
+				delete(s.conns, c)
+				// Keep Close from returning until the user's ConnState hook
+				// (if any) finishes.
+				defer s.wg.Done()
+			}
+		}
+		if oldHook != nil {
+			oldHook(c, cs)
+		}
+	}
+}
+
+// closeConn closes c.
+// s.mu must be held.
+func (s *Server) closeConn(c net.Conn) { s.closeConnChan(c, nil) }
+
+// closeConnChan is like closeConn, but takes an optional channel to receive a value
+// when the goroutine closing c is done.
+func (s *Server) closeConnChan(c net.Conn, done chan<- struct{}) {
+	c.Close()
+	if done != nil {
+		done <- struct{}{}
+	}
+}
diff --git a/contrib/go/_std_1.22/src/net/http/httptest/ya.make b/contrib/go/_std_1.22/src/net/http/httptest/ya.make
new file mode 100644
index 000000000000..eb2e918667d1
--- /dev/null
+++ b/contrib/go/_std_1.22/src/net/http/httptest/ya.make
@@ -0,0 +1,9 @@
+GO_LIBRARY()
+IF (TRUE)
+    SRCS(
+        httptest.go
+        recorder.go
+        server.go
+    )
+ENDIF()
+END()
diff --git a/contrib/go/_std_1.21/src/net/http/internal/testcert/testcert.go b/contrib/go/_std_1.22/src/net/http/internal/testcert/testcert.go
similarity index 100%
rename from contrib/go/_std_1.21/src/net/http/internal/testcert/testcert.go
rename to contrib/go/_std_1.22/src/net/http/internal/testcert/testcert.go
diff --git a/contrib/go/_std_1.22/src/net/http/internal/testcert/ya.make b/contrib/go/_std_1.22/src/net/http/internal/testcert/ya.make
new file mode 100644
index 000000000000..adb7784e5f1b
--- /dev/null
+++ b/contrib/go/_std_1.22/src/net/http/internal/testcert/ya.make
@@ -0,0 +1,7 @@
+GO_LIBRARY()
+IF (TRUE)
+    SRCS(
+        testcert.go
+    )
+ENDIF()
+END()
diff --git a/contrib/go/_std_1.21/src/runtime/test_amd64.go b/contrib/go/_std_1.22/src/runtime/test_amd64.go
similarity index 100%
rename from contrib/go/_std_1.21/src/runtime/test_amd64.go
rename to contrib/go/_std_1.22/src/runtime/test_amd64.go
diff --git a/contrib/go/_std_1.22/src/runtime/test_amd64.s b/contrib/go/_std_1.22/src/runtime/test_amd64.s
new file mode 100644
index 000000000000..cc4bc6296dfc
--- /dev/null
+++ b/contrib/go/_std_1.22/src/runtime/test_amd64.s
@@ -0,0 +1,11 @@
+// Copyright 2023 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Create a large frame to force stack growth. See #62326.
+TEXT ·testSPWrite(SB),0,$16384-0
+	// Write to SP
+	MOVQ SP, AX
+	ANDQ $~0xf, SP
+	MOVQ AX, SP
+	RET
diff --git a/contrib/go/_std_1.21/src/runtime/test_stubs.go b/contrib/go/_std_1.22/src/runtime/test_stubs.go
similarity index 100%
rename from contrib/go/_std_1.21/src/runtime/test_stubs.go
rename to contrib/go/_std_1.22/src/runtime/test_stubs.go
diff --git a/contrib/go/_std_1.21/src/testing/allocs.go b/contrib/go/_std_1.22/src/testing/allocs.go
similarity index 100%
rename from contrib/go/_std_1.21/src/testing/allocs.go
rename to contrib/go/_std_1.22/src/testing/allocs.go
diff --git a/contrib/go/_std_1.21/src/testing/benchmark.go b/contrib/go/_std_1.22/src/testing/benchmark.go
similarity index 94%
rename from contrib/go/_std_1.21/src/testing/benchmark.go
rename to contrib/go/_std_1.22/src/testing/benchmark.go
index be9b87f80bbd..9491213ef156 100644
--- a/contrib/go/_std_1.21/src/testing/benchmark.go
+++ b/contrib/go/_std_1.22/src/testing/benchmark.go
@@ -7,7 +7,6 @@ package testing
 import (
 	"flag"
 	"fmt"
-	"internal/race"
 	"internal/sysinfo"
 	"io"
 	"math"
@@ -25,7 +24,7 @@ import (
 func initBenchmarkFlags() {
 	matchBenchmarks = flag.String("test.bench", "", "run only benchmarks matching `regexp`")
 	benchmarkMemory = flag.Bool("test.benchmem", false, "print memory allocations for benchmarks")
-	flag.Var(&benchTime, "test.benchtime", "run each benchmark for duration `d`")
+	flag.Var(&benchTime, "test.benchtime", "run each benchmark for duration `d` or N times if `d` is of the form Nx")
 }
 
 var (
@@ -78,7 +77,7 @@ type InternalBenchmark struct {
 	F    func(b *B)
 }
 
-// B is a type passed to Benchmark functions to manage benchmark
+// B is a type passed to [Benchmark] functions to manage benchmark
 // timing and to specify the number of iterations to run.
 //
 // A benchmark ends when its Benchmark function returns or calls any of the methods
@@ -118,7 +117,7 @@ type B struct {
 
 // StartTimer starts timing a test. This function is called automatically
 // before a benchmark starts, but it can also be used to resume timing after
-// a call to StopTimer.
+// a call to [B.StopTimer].
 func (b *B) StartTimer() {
 	if !b.timerOn {
 		runtime.ReadMemStats(&memStats)
@@ -151,9 +150,7 @@ func (b *B) ResetTimer() {
 		// Pre-size it to make more allocation unlikely.
 		b.extra = make(map[string]float64, 16)
 	} else {
-		for k := range b.extra {
-			delete(b.extra, k)
-		}
+		clear(b.extra)
 	}
 	if b.timerOn {
 		runtime.ReadMemStats(&memStats)
@@ -181,11 +178,14 @@ func (b *B) ReportAllocs() {
 func (b *B) runN(n int) {
 	benchmarkLock.Lock()
 	defer benchmarkLock.Unlock()
-	defer b.runCleanup(normalPanic)
+	defer func() {
+		b.runCleanup(normalPanic)
+		b.checkRaces()
+	}()
 	// Try to get a comparable environment for each run
 	// by clearing garbage from previous runs.
 	runtime.GC()
-	b.raceErrors = -race.Errors()
+	b.resetRaces()
 	b.N = n
 	b.parallelism = 1
 	b.ResetTimer()
@@ -194,24 +194,6 @@ func (b *B) runN(n int) {
 	b.StopTimer()
 	b.previousN = n
 	b.previousDuration = b.duration
-	b.raceErrors += race.Errors()
-	if b.raceErrors > 0 {
-		b.Errorf("race detected during execution of benchmark")
-	}
-}
-
-func min(x, y int64) int64 {
-	if x > y {
-		return y
-	}
-	return x
-}
-
-func max(x, y int64) int64 {
-	if x < y {
-		return y
-	}
-	return x
 }
 
 // run1 runs the first iteration of benchFunc. It reports whether more
@@ -267,7 +249,7 @@ func (b *B) run() {
 		if b.importPath != "" {
 			fmt.Fprintf(b.w, "pkg: %s
", b.importPath)
 		}
-		if cpu := sysinfo.CPU.Name(); cpu != "" {
+		if cpu := sysinfo.CPUName(); cpu != "" {
 			fmt.Fprintf(b.w, "cpu: %s
", cpu)
 		}
 	})
@@ -339,7 +321,7 @@ func (b *B) launch() {
 
 // Elapsed returns the measured elapsed time of the benchmark.
 // The duration reported by Elapsed matches the one measured by
-// StartTimer, StopTimer, and ResetTimer.
+// [B.StartTimer], [B.StopTimer], and [B.ResetTimer].
 func (b *B) Elapsed() time.Duration {
 	d := b.duration
 	if b.timerOn {
@@ -431,7 +413,7 @@ func (r BenchmarkResult) AllocedBytesPerOp() int64 {
 // benchmark name.
 // Extra metrics override built-in metrics of the same name.
 // String does not include allocs/op or B/op, since those are reported
-// by MemString.
+// by [BenchmarkResult.MemString].
 func (r BenchmarkResult) String() string {
 	buf := new(strings.Builder)
 	fmt.Fprintf(buf, "%8d", r.N)
@@ -684,7 +666,7 @@ func (b *B) Run(name string, f func(b *B)) bool {
 			if b.importPath != "" {
 				fmt.Printf("pkg: %s
", b.importPath)
 			}
-			if cpu := sysinfo.CPU.Name(); cpu != "" {
+			if cpu := sysinfo.CPUName(); cpu != "" {
 				fmt.Printf("cpu: %s
", cpu)
 			}
 		})
@@ -745,16 +727,16 @@ func (b *B) trimOutput() {
 
 // A PB is used by RunParallel for running parallel benchmarks.
 type PB struct {
-	globalN *uint64 // shared between all worker goroutines iteration counter
-	grain   uint64  // acquire that many iterations from globalN at once
-	cache   uint64  // local cache of acquired iterations
-	bN      uint64  // total number of iterations to execute (b.N)
+	globalN *atomic.Uint64 // shared between all worker goroutines iteration counter
+	grain   uint64         // acquire that many iterations from globalN at once
+	cache   uint64         // local cache of acquired iterations
+	bN      uint64         // total number of iterations to execute (b.N)
 }
 
 // Next reports whether there are more iterations to execute.
 func (pb *PB) Next() bool {
 	if pb.cache == 0 {
-		n := atomic.AddUint64(pb.globalN, pb.grain)
+		n := pb.globalN.Add(pb.grain)
 		if n <= pb.bN {
 			pb.cache = pb.grain
 		} else if n < pb.bN+pb.grain {
@@ -770,13 +752,13 @@ func (pb *PB) Next() bool {
 // RunParallel runs a benchmark in parallel.
 // It creates multiple goroutines and distributes b.N iterations among them.
 // The number of goroutines defaults to GOMAXPROCS. To increase parallelism for
-// non-CPU-bound benchmarks, call SetParallelism before RunParallel.
+// non-CPU-bound benchmarks, call [B.SetParallelism] before RunParallel.
 // RunParallel is usually used with the go test -cpu flag.
 //
 // The body function will be run in each goroutine. It should set up any
 // goroutine-local state and then iterate until pb.Next returns false.
-// It should not use the StartTimer, StopTimer, or ResetTimer functions,
-// because they have global effect. It should also not call Run.
+// It should not use the [B.StartTimer], [B.StopTimer], or [B.ResetTimer] functions,
+// because they have global effect. It should also not call [B.Run].
 //
 // RunParallel reports ns/op values as wall time for the benchmark as a whole,
 // not the sum of wall time or CPU time over each parallel goroutine.
@@ -800,7 +782,7 @@ func (b *B) RunParallel(body func(*PB)) {
 		grain = 1e4
 	}
 
-	n := uint64(0)
+	var n atomic.Uint64
 	numProcs := b.parallelism * runtime.GOMAXPROCS(0)
 	var wg sync.WaitGroup
 	wg.Add(numProcs)
@@ -816,12 +798,12 @@ func (b *B) RunParallel(body func(*PB)) {
 		}()
 	}
 	wg.Wait()
-	if n <= uint64(b.N) && !b.Failed() {
+	if n.Load() <= uint64(b.N) && !b.Failed() {
 		b.Fatal("RunParallel: body exited without pb.Next() == false")
 	}
 }
 
-// SetParallelism sets the number of goroutines used by RunParallel to p*GOMAXPROCS.
+// SetParallelism sets the number of goroutines used by [B.RunParallel] to p*GOMAXPROCS.
 // There is usually no need to call SetParallelism for CPU-bound benchmarks.
 // If p is less than 1, this call will have no effect.
 func (b *B) SetParallelism(p int) {
@@ -833,8 +815,8 @@ func (b *B) SetParallelism(p int) {
 // Benchmark benchmarks a single function. It is useful for creating
 // custom benchmarks that do not use the "go test" command.
 //
-// If f depends on testing flags, then Init must be used to register
-// those flags before calling Benchmark and before calling flag.Parse.
+// If f depends on testing flags, then [Init] must be used to register
+// those flags before calling Benchmark and before calling [flag.Parse].
 //
 // If f calls Run, the result will be an estimate of running all its
 // subbenchmarks that don't call Run in sequence in a single benchmark.
diff --git a/contrib/go/_std_1.21/src/testing/cover.go b/contrib/go/_std_1.22/src/testing/cover.go
similarity index 100%
rename from contrib/go/_std_1.21/src/testing/cover.go
rename to contrib/go/_std_1.22/src/testing/cover.go
diff --git a/contrib/go/_std_1.22/src/testing/example.go b/contrib/go/_std_1.22/src/testing/example.go
new file mode 100644
index 000000000000..07aa5cb66c19
--- /dev/null
+++ b/contrib/go/_std_1.22/src/testing/example.go
@@ -0,0 +1,97 @@
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package testing
+
+import (
+	"fmt"
+	"sort"
+	"strings"
+	"time"
+)
+
+type InternalExample struct {
+	Name      string
+	F         func()
+	Output    string
+	Unordered bool
+}
+
+// RunExamples is an internal function but exported because it is cross-package;
+// it is part of the implementation of the "go test" command.
+func RunExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ok bool) {
+	_, ok = runExamples(matchString, examples)
+	return ok
+}
+
+func runExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ran, ok bool) {
+	ok = true
+
+	m := newMatcher(matchString, *match, "-test.run", *skip)
+
+	var eg InternalExample
+	for _, eg = range examples {
+		_, matched, _ := m.fullName(nil, eg.Name)
+		if !matched {
+			continue
+		}
+		ran = true
+		if !runExample(eg) {
+			ok = false
+		}
+	}
+
+	return ran, ok
+}
+
+func sortLines(output string) string {
+	lines := strings.Split(output, "
")
+	sort.Strings(lines)
+	return strings.Join(lines, "
")
+}
+
+// processRunResult computes a summary and status of the result of running an example test.
+// stdout is the captured output from stdout of the test.
+// recovered is the result of invoking recover after running the test, in case it panicked.
+//
+// If stdout doesn't match the expected output or if recovered is non-nil, it'll print the cause of failure to stdout.
+// If the test is chatty/verbose, it'll print a success message to stdout.
+// If recovered is non-nil, it'll panic with that value.
+// If the test panicked with nil, or invoked runtime.Goexit, it'll be
+// made to fail and panic with errNilPanicOrGoexit
+func (eg *InternalExample) processRunResult(stdout string, timeSpent time.Duration, finished bool, recovered any) (passed bool) {
+	passed = true
+	dstr := fmtDuration(timeSpent)
+	var fail string
+	got := strings.TrimSpace(stdout)
+	want := strings.TrimSpace(eg.Output)
+	if eg.Unordered {
+		if sortLines(got) != sortLines(want) && recovered == nil {
+			fail = fmt.Sprintf("got:
%s
want (unordered):
%s
", stdout, eg.Output)
+		}
+	} else {
+		if got != want && recovered == nil {
+			fail = fmt.Sprintf("got:
%s
want:
%s
", got, want)
+		}
+	}
+	if fail != "" || !finished || recovered != nil {
+		fmt.Printf("%s--- FAIL: %s (%s)
%s", chatty.prefix(), eg.Name, dstr, fail)
+		passed = false
+	} else if chatty.on {
+		fmt.Printf("%s--- PASS: %s (%s)
", chatty.prefix(), eg.Name, dstr)
+	}
+
+	if chatty.on && chatty.json {
+		fmt.Printf("%s=== NAME   %s
", chatty.prefix(), "")
+	}
+
+	if recovered != nil {
+		// Propagate the previously recovered result, by panicking.
+		panic(recovered)
+	} else if !finished {
+		panic(errNilPanicOrGoexit)
+	}
+
+	return
+}
diff --git a/contrib/go/_std_1.21/src/testing/fuzz.go b/contrib/go/_std_1.22/src/testing/fuzz.go
similarity index 99%
rename from contrib/go/_std_1.21/src/testing/fuzz.go
rename to contrib/go/_std_1.22/src/testing/fuzz.go
index d31a3f81f528..d50ea793e0e1 100644
--- a/contrib/go/_std_1.21/src/testing/fuzz.go
+++ b/contrib/go/_std_1.22/src/testing/fuzz.go
@@ -59,7 +59,7 @@ type InternalFuzzTarget struct {
 // by (*F).Add and entries in the testdata/fuzz/<FuzzTestName> directory. After
 // any necessary setup and calls to (*F).Add, the fuzz test must then call
 // (*F).Fuzz to provide the fuzz target. See the testing package documentation
-// for an example, and see the F.Fuzz and F.Add method documentation for
+// for an example, and see the [F.Fuzz] and [F.Add] method documentation for
 // details.
 //
 // *F methods can only be called before (*F).Fuzz. Once the test is
@@ -206,7 +206,7 @@ var supportedTypes = map[reflect.Type]bool{
 //
 // When fuzzing, F.Fuzz does not return until a problem is found, time runs out
 // (set with -fuzztime), or the test process is interrupted by a signal. F.Fuzz
-// should be called exactly once, unless F.Skip or F.Fail is called beforehand.
+// should be called exactly once, unless F.Skip or [F.Fail] is called beforehand.
 func (f *F) Fuzz(ff any) {
 	if f.fuzzCalled {
 		panic("testing: F.Fuzz called more than once")
@@ -636,6 +636,7 @@ func fRunner(f *F, fn func(*F)) {
 		// Unfortunately, recovering here adds stack frames, but the location of
 		// the original panic should still be
 		// clear.
+		f.checkRaces()
 		if f.Failed() {
 			numFailed.Add(1)
 		}
@@ -719,6 +720,7 @@ func fRunner(f *F, fn func(*F)) {
 	}()
 
 	f.start = time.Now()
+	f.resetRaces()
 	fn(f)
 
 	// Code beyond this point will not be executed when FailNow or SkipNow
diff --git a/contrib/go/_std_1.21/src/testing/internal/testdeps/deps.go b/contrib/go/_std_1.22/src/testing/internal/testdeps/deps.go
similarity index 99%
rename from contrib/go/_std_1.21/src/testing/internal/testdeps/deps.go
rename to contrib/go/_std_1.22/src/testing/internal/testdeps/deps.go
index 2e85a41b0775..868307550eab 100644
--- a/contrib/go/_std_1.21/src/testing/internal/testdeps/deps.go
+++ b/contrib/go/_std_1.22/src/testing/internal/testdeps/deps.go
@@ -27,7 +27,7 @@ import (
 )
 
 // TestDeps is an implementation of the testing.testDeps interface,
-// suitable for passing to testing.MainStart.
+// suitable for passing to [testing.MainStart].
 type TestDeps struct{}
 
 var matchPat string
diff --git a/contrib/go/_std_1.22/src/testing/internal/testdeps/ya.make b/contrib/go/_std_1.22/src/testing/internal/testdeps/ya.make
new file mode 100644
index 000000000000..ffc5fa9989ca
--- /dev/null
+++ b/contrib/go/_std_1.22/src/testing/internal/testdeps/ya.make
@@ -0,0 +1,7 @@
+GO_LIBRARY()
+IF (TRUE)
+    SRCS(
+        deps.go
+    )
+ENDIF()
+END()
diff --git a/contrib/go/_std_1.22/src/testing/match.go b/contrib/go/_std_1.22/src/testing/match.go
new file mode 100644
index 000000000000..84804dc2ecff
--- /dev/null
+++ b/contrib/go/_std_1.22/src/testing/match.go
@@ -0,0 +1,317 @@
+// Copyright 2015 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package testing
+
+import (
+	"fmt"
+	"os"
+	"strconv"
+	"strings"
+	"sync"
+)
+
+// matcher sanitizes, uniques, and filters names of subtests and subbenchmarks.
+type matcher struct {
+	filter    filterMatch
+	skip      filterMatch
+	matchFunc func(pat, str string) (bool, error)
+
+	mu sync.Mutex
+
+	// subNames is used to deduplicate subtest names.
+	// Each key is the subtest name joined to the deduplicated name of the parent test.
+	// Each value is the count of the number of occurrences of the given subtest name
+	// already seen.
+	subNames map[string]int32
+}
+
+type filterMatch interface {
+	// matches checks the name against the receiver's pattern strings using the
+	// given match function.
+	matches(name []string, matchString func(pat, str string) (bool, error)) (ok, partial bool)
+
+	// verify checks that the receiver's pattern strings are valid filters by
+	// calling the given match function.
+	verify(name string, matchString func(pat, str string) (bool, error)) error
+}
+
+// simpleMatch matches a test name if all of the pattern strings match in
+// sequence.
+type simpleMatch []string
+
+// alternationMatch matches a test name if one of the alternations match.
+type alternationMatch []filterMatch
+
+// TODO: fix test_main to avoid race and improve caching, also allowing to
+// eliminate this Mutex.
+var matchMutex sync.Mutex
+
+func allMatcher() *matcher {
+	return newMatcher(nil, "", "", "")
+}
+
+func newMatcher(matchString func(pat, str string) (bool, error), patterns, name, skips string) *matcher {
+	var filter, skip filterMatch
+	if patterns == "" {
+		filter = simpleMatch{} // always partial true
+	} else {
+		filter = splitRegexp(patterns)
+		if err := filter.verify(name, matchString); err != nil {
+			fmt.Fprintf(os.Stderr, "testing: invalid regexp for %s
", err)
+			os.Exit(1)
+		}
+	}
+	if skips == "" {
+		skip = alternationMatch{} // always false
+	} else {
+		skip = splitRegexp(skips)
+		if err := skip.verify("-test.skip", matchString); err != nil {
+			fmt.Fprintf(os.Stderr, "testing: invalid regexp for %v
", err)
+			os.Exit(1)
+		}
+	}
+	return &matcher{
+		filter:    filter,
+		skip:      skip,
+		matchFunc: matchString,
+		subNames:  map[string]int32{},
+	}
+}
+
+func (m *matcher) fullName(c *common, subname string) (name string, ok, partial bool) {
+	name = subname
+
+	m.mu.Lock()
+	defer m.mu.Unlock()
+
+	if c != nil && c.level > 0 {
+		name = m.unique(c.name, rewrite(subname))
+	}
+
+	matchMutex.Lock()
+	defer matchMutex.Unlock()
+
+	// We check the full array of paths each time to allow for the case that a pattern contains a '/'.
+	elem := strings.Split(name, "/")
+
+	// filter must match.
+	// accept partial match that may produce full match later.
+	ok, partial = m.filter.matches(elem, m.matchFunc)
+	if !ok {
+		return name, false, false
+	}
+
+	// skip must not match.
+	// ignore partial match so we can get to more precise match later.
+	skip, partialSkip := m.skip.matches(elem, m.matchFunc)
+	if skip && !partialSkip {
+		return name, false, false
+	}
+
+	return name, ok, partial
+}
+
+// clearSubNames clears the matcher's internal state, potentially freeing
+// memory. After this is called, T.Name may return the same strings as it did
+// for earlier subtests.
+func (m *matcher) clearSubNames() {
+	m.mu.Lock()
+	defer m.mu.Unlock()
+	clear(m.subNames)
+}
+
+func (m simpleMatch) matches(name []string, matchString func(pat, str string) (bool, error)) (ok, partial bool) {
+	for i, s := range name {
+		if i >= len(m) {
+			break
+		}
+		if ok, _ := matchString(m[i], s); !ok {
+			return false, false
+		}
+	}
+	return true, len(name) < len(m)
+}
+
+func (m simpleMatch) verify(name string, matchString func(pat, str string) (bool, error)) error {
+	for i, s := range m {
+		m[i] = rewrite(s)
+	}
+	// Verify filters before doing any processing.
+	for i, s := range m {
+		if _, err := matchString(s, "non-empty"); err != nil {
+			return fmt.Errorf("element %d of %s (%q): %s", i, name, s, err)
+		}
+	}
+	return nil
+}
+
+func (m alternationMatch) matches(name []string, matchString func(pat, str string) (bool, error)) (ok, partial bool) {
+	for _, m := range m {
+		if ok, partial = m.matches(name, matchString); ok {
+			return ok, partial
+		}
+	}
+	return false, false
+}
+
+func (m alternationMatch) verify(name string, matchString func(pat, str string) (bool, error)) error {
+	for i, m := range m {
+		if err := m.verify(name, matchString); err != nil {
+			return fmt.Errorf("alternation %d of %s", i, err)
+		}
+	}
+	return nil
+}
+
+func splitRegexp(s string) filterMatch {
+	a := make(simpleMatch, 0, strings.Count(s, "/"))
+	b := make(alternationMatch, 0, strings.Count(s, "|"))
+	cs := 0
+	cp := 0
+	for i := 0; i < len(s); {
+		switch s[i] {
+		case '[':
+			cs++
+		case ']':
+			if cs--; cs < 0 { // An unmatched ']' is legal.
+				cs = 0
+			}
+		case '(':
+			if cs == 0 {
+				cp++
+			}
+		case ')':
+			if cs == 0 {
+				cp--
+			}
+		case '\\':
+			i++
+		case '/':
+			if cs == 0 && cp == 0 {
+				a = append(a, s[:i])
+				s = s[i+1:]
+				i = 0
+				continue
+			}
+		case '|':
+			if cs == 0 && cp == 0 {
+				a = append(a, s[:i])
+				s = s[i+1:]
+				i = 0
+				b = append(b, a)
+				a = make(simpleMatch, 0, len(a))
+				continue
+			}
+		}
+		i++
+	}
+
+	a = append(a, s)
+	if len(b) == 0 {
+		return a
+	}
+	return append(b, a)
+}
+
+// unique creates a unique name for the given parent and subname by affixing it
+// with one or more counts, if necessary.
+func (m *matcher) unique(parent, subname string) string {
+	base := parent + "/" + subname
+
+	for {
+		n := m.subNames[base]
+		if n < 0 {
+			panic("subtest count overflow")
+		}
+		m.subNames[base] = n + 1
+
+		if n == 0 && subname != "" {
+			prefix, nn := parseSubtestNumber(base)
+			if len(prefix) < len(base) && nn < m.subNames[prefix] {
+				// This test is explicitly named like "parent/subname#NN",
+				// and #NN was already used for the NNth occurrence of "parent/subname".
+				// Loop to add a disambiguating suffix.
+				continue
+			}
+			return base
+		}
+
+		name := fmt.Sprintf("%s#%02d", base, n)
+		if m.subNames[name] != 0 {
+			// This is the nth occurrence of base, but the name "parent/subname#NN"
+			// collides with the first occurrence of a subtest *explicitly* named
+			// "parent/subname#NN". Try the next number.
+			continue
+		}
+
+		return name
+	}
+}
+
+// parseSubtestNumber splits a subtest name into a "#%02d"-formatted int32
+// suffix (if present), and a prefix preceding that suffix (always).
+func parseSubtestNumber(s string) (prefix string, nn int32) {
+	i := strings.LastIndex(s, "#")
+	if i < 0 {
+		return s, 0
+	}
+
+	prefix, suffix := s[:i], s[i+1:]
+	if len(suffix) < 2 || (len(suffix) > 2 && suffix[0] == '0') {
+		// Even if suffix is numeric, it is not a possible output of a "%02" format
+		// string: it has either too few digits or too many leading zeroes.
+		return s, 0
+	}
+	if suffix == "00" {
+		if !strings.HasSuffix(prefix, "/") {
+			// We only use "#00" as a suffix for subtests named with the empty
+			// string — it isn't a valid suffix if the subtest name is non-empty.
+			return s, 0
+		}
+	}
+
+	n, err := strconv.ParseInt(suffix, 10, 32)
+	if err != nil || n < 0 {
+		return s, 0
+	}
+	return prefix, int32(n)
+}
+
+// rewrite rewrites a subname to having only printable characters and no white
+// space.
+func rewrite(s string) string {
+	b := []byte{}
+	for _, r := range s {
+		switch {
+		case isSpace(r):
+			b = append(b, '_')
+		case !strconv.IsPrint(r):
+			s := strconv.QuoteRune(r)
+			b = append(b, s[1:len(s)-1]...)
+		default:
+			b = append(b, string(r)...)
+		}
+	}
+	return string(b)
+}
+
+func isSpace(r rune) bool {
+	if r < 0x2000 {
+		switch r {
+		// Note: not the same as Unicode Z class.
+		case '\t', '
', '\v', '\f', '\r', ' ', 0x85, 0xA0, 0x1680:
+			return true
+		}
+	} else {
+		if r <= 0x200a {
+			return true
+		}
+		switch r {
+		case 0x2028, 0x2029, 0x202f, 0x205f, 0x3000:
+			return true
+		}
+	}
+	return false
+}
diff --git a/contrib/go/_std_1.21/src/testing/newcover.go b/contrib/go/_std_1.22/src/testing/newcover.go
similarity index 100%
rename from contrib/go/_std_1.21/src/testing/newcover.go
rename to contrib/go/_std_1.22/src/testing/newcover.go
diff --git a/contrib/go/_std_1.21/src/testing/run_example.go b/contrib/go/_std_1.22/src/testing/run_example.go
similarity index 100%
rename from contrib/go/_std_1.21/src/testing/run_example.go
rename to contrib/go/_std_1.22/src/testing/run_example.go
diff --git a/contrib/go/_std_1.21/src/testing/testing.go b/contrib/go/_std_1.22/src/testing/testing.go
similarity index 93%
rename from contrib/go/_std_1.21/src/testing/testing.go
rename to contrib/go/_std_1.22/src/testing/testing.go
index fcf7048f2340..5c06aea5f8fe 100644
--- a/contrib/go/_std_1.21/src/testing/testing.go
+++ b/contrib/go/_std_1.22/src/testing/testing.go
@@ -398,7 +398,7 @@ var initRan bool
 // the "go test" command before running test functions, so Init is only needed
 // when calling functions such as Benchmark without using "go test".
 //
-// Init has no effect if it was already called.
+// Init is not safe to call concurrently. It has no effect if it was already called.
 func Init() {
 	if initRan {
 		return
@@ -611,7 +611,6 @@ type common struct {
 	bench          bool           // Whether the current test is a benchmark.
 	hasSub         atomic.Bool    // whether there are sub-benchmarks.
 	cleanupStarted atomic.Bool    // Registered cleanup callbacks have started to execute
-	raceErrors     int            // Number of races detected during test.
 	runner         string         // Function name of tRunner running the test.
 	isParallel     bool           // Whether the test is parallel.
 
@@ -625,6 +624,9 @@ type common struct {
 	signal   chan bool // To signal a test is done.
 	sub      []*T      // Queue of subtests to be run in parallel.
 
+	lastRaceErrors  atomic.Int64 // Max value of race.Errors seen during the test or its subtests.
+	raceErrorLogged atomic.Bool
+
 	tempDirMu  sync.Mutex
 	tempDir    string
 	tempDirErr error
@@ -771,9 +773,7 @@ func (c *common) decorate(s string, skip int) string {
 	if file != "" {
 		if *fullPath {
 			// If relative path, truncate file name at last file name separator.
-		} else if index := strings.LastIndex(file, "/"); index >= 0 {
-			file = file[index+1:]
-		} else if index = strings.LastIndex(file, "\\"); index >= 0 {
+		} else if index := strings.LastIndexAny(file, `/\`); index >= 0 {
 			file = file[index+1:]
 		}
 	} else {
@@ -957,9 +957,15 @@ func (c *common) Fail() {
 // Failed reports whether the function has failed.
 func (c *common) Failed() bool {
 	c.mu.RLock()
-	failed := c.failed
-	c.mu.RUnlock()
-	return failed || c.raceErrors+race.Errors() > 0
+	defer c.mu.RUnlock()
+
+	if !c.done && int64(race.Errors()) > c.lastRaceErrors.Load() {
+		c.mu.RUnlock()
+		c.checkRaces()
+		c.mu.RLock()
+	}
+
+	return c.failed
 }
 
 // FailNow marks the function as having failed and stops its execution
@@ -1098,7 +1104,7 @@ func (c *common) Skipf(format string, args ...any) {
 }
 
 // SkipNow marks the test as having been skipped and stops its execution
-// by calling runtime.Goexit.
+// by calling [runtime.Goexit].
 // If a test fails (see Error, Errorf, Fail) and is then skipped,
 // it is still considered to have failed.
 // Execution will continue at the next test or benchmark. See also FailNow.
@@ -1175,7 +1181,7 @@ func (c *common) Cleanup(f func()) {
 }
 
 // TempDir returns a temporary directory for the test to use.
-// The directory is automatically removed by Cleanup when the test and
+// The directory is automatically removed when the test and
 // all its subtests complete.
 // Each subsequent call to t.TempDir returns a unique directory;
 // if the directory creation fails, TempDir terminates the test by calling Fatal.
@@ -1300,7 +1306,7 @@ func (c *common) Setenv(key, value string) {
 	}
 }
 
-// panicHanding is an argument to runCleanup.
+// panicHanding controls the panic handling used by runCleanup.
 type panicHandling int
 
 const (
@@ -1309,8 +1315,8 @@ const (
 )
 
 // runCleanup is called at the end of the test.
-// If catchPanic is true, this will catch panics, and return the recovered
-// value if any.
+// If ph is recoverAndReturnPanic, it will catch panics, and return the
+// recovered value if any.
 func (c *common) runCleanup(ph panicHandling) (panicVal any) {
 	c.cleanupStarted.Store(true)
 	defer c.cleanupStarted.Store(false)
@@ -1348,6 +1354,69 @@ func (c *common) runCleanup(ph panicHandling) (panicVal any) {
 	}
 }
 
+// resetRaces updates c.parent's count of data race errors (or the global count,
+// if c has no parent), and updates c.lastRaceErrors to match.
+//
+// Any races that occurred prior to this call to resetRaces will
+// not be attributed to c.
+func (c *common) resetRaces() {
+	if c.parent == nil {
+		c.lastRaceErrors.Store(int64(race.Errors()))
+	} else {
+		c.lastRaceErrors.Store(c.parent.checkRaces())
+	}
+}
+
+// checkRaces checks whether the global count of data race errors has increased
+// since c's count was last reset.
+//
+// If so, it marks c as having failed due to those races (logging an error for
+// the first such race), and updates the race counts for the parents of c so
+// that if they are currently suspended (such as in a call to T.Run) they will
+// not log separate errors for the race(s).
+//
+// Note that multiple tests may be marked as failed due to the same race if they
+// are executing in parallel.
+func (c *common) checkRaces() (raceErrors int64) {
+	raceErrors = int64(race.Errors())
+	for {
+		last := c.lastRaceErrors.Load()
+		if raceErrors <= last {
+			// All races have already been reported.
+			return raceErrors
+		}
+		if c.lastRaceErrors.CompareAndSwap(last, raceErrors) {
+			break
+		}
+	}
+
+	if c.raceErrorLogged.CompareAndSwap(false, true) {
+		// This is the first race we've encountered for this test.
+		// Mark the test as failed, and log the reason why only once.
+		// (Note that the race detector itself will still write a goroutine
+		// dump for any further races it detects.)
+		c.Errorf("race detected during execution of test")
+	}
+
+	// Update the parent(s) of this test so that they don't re-report the race.
+	parent := c.parent
+	for parent != nil {
+		for {
+			last := parent.lastRaceErrors.Load()
+			if raceErrors <= last {
+				// This race was already reported by another (likely parallel) subtest.
+				return raceErrors
+			}
+			if parent.lastRaceErrors.CompareAndSwap(last, raceErrors) {
+				break
+			}
+		}
+		parent = parent.parent
+	}
+
+	return raceErrors
+}
+
 // callerName gives the function name (qualified with a package path)
 // for the caller after skip frames (where 0 means the current function).
 func callerName(skip int) string {
@@ -1392,7 +1461,18 @@ func (t *T) Parallel() {
 
 	// Add to the list of tests to be released by the parent.
 	t.parent.sub = append(t.parent.sub, t)
-	t.raceErrors += race.Errors()
+
+	// Report any races during execution of this test up to this point.
+	//
+	// We will assume that any races that occur between here and the point where
+	// we unblock are not caused by this subtest. That assumption usually holds,
+	// although it can be wrong if the test spawns a goroutine that races in the
+	// background while the rest of the test is blocked on the call to Parallel.
+	// If that happens, we will misattribute the background race to some other
+	// test, or to no test at all — but that false-negative is so unlikely that it
+	// is not worth adding race-report noise for the common case where the test is
+	// completely suspended during the call to Parallel.
+	t.checkRaces()
 
 	if t.chatty != nil {
 		t.chatty.Updatef(t.name, "=== PAUSE %s
", t.name)
@@ -1407,9 +1487,16 @@ func (t *T) Parallel() {
 		t.chatty.Updatef(t.name, "=== CONT  %s
", t.name)
 	}
 	running.Store(t.name, time.Now())
-
 	t.start = time.Now()
-	t.raceErrors += -race.Errors()
+
+	// Reset the local race counter to ignore any races that happened while this
+	// goroutine was blocked, such as in the parent test or in other parallel
+	// subtests.
+	//
+	// (Note that we don't call parent.checkRaces here:
+	// if other parallel subtests have already introduced races, we want to
+	// let them report those races instead of attributing them to the parent.)
+	t.lastRaceErrors.Store(int64(race.Errors()))
 }
 
 // Setenv calls os.Setenv(key, value) and uses Cleanup to
@@ -1457,14 +1544,13 @@ func tRunner(t *T, fn func(t *T)) {
 	// a call to runtime.Goexit, record the duration and send
 	// a signal saying that the test is done.
 	defer func() {
+		t.checkRaces()
+
+		// TODO(#61034): This is the wrong place for this check.
 		if t.Failed() {
 			numFailed.Add(1)
 		}
 
-		if t.raceErrors+race.Errors() > 0 {
-			t.Errorf("race detected during execution of test")
-		}
-
 		// Check if the test panicked or Goexited inappropriately.
 		//
 		// If this happens in a normal test, print output but continue panicking.
@@ -1552,20 +1638,28 @@ func tRunner(t *T, fn func(t *T)) {
 
 		if len(t.sub) > 0 {
 			// Run parallel subtests.
-			// Decrease the running count for this test.
+
+			// Decrease the running count for this test and mark it as no longer running.
 			t.context.release()
+			running.Delete(t.name)
+
 			// Release the parallel subtests.
 			close(t.barrier)
 			// Wait for subtests to complete.
 			for _, sub := range t.sub {
 				<-sub.signal
 			}
+
+			// Run any cleanup callbacks, marking the test as running
+			// in case the cleanup hangs.
 			cleanupStart := time.Now()
+			running.Store(t.name, cleanupStart)
 			err := t.runCleanup(recoverAndReturnPanic)
 			t.duration += time.Since(cleanupStart)
 			if err != nil {
 				doPanic(err)
 			}
+			t.checkRaces()
 			if !t.isParallel {
 				// Reacquire the count for sequential tests. See comment in Run.
 				t.context.waitParallel()
@@ -1591,7 +1685,7 @@ func tRunner(t *T, fn func(t *T)) {
 	}()
 
 	t.start = time.Now()
-	t.raceErrors = -race.Errors()
+	t.resetRaces()
 	fn(t)
 
 	// code beyond here will not be executed when FailNow is invoked
@@ -1646,11 +1740,19 @@ func (t *T) Run(name string, f func(t *T)) bool {
 	// without being preempted, even when their parent is a parallel test. This
 	// may especially reduce surprises if *parallel == 1.
 	go tRunner(t, f)
+
+	// The parent goroutine will block until the subtest either finishes or calls
+	// Parallel, but in general we don't know whether the parent goroutine is the
+	// top-level test function or some other goroutine it has spawned.
+	// To avoid confusing false-negatives, we leave the parent in the running map
+	// even though in the typical case it is blocked.
+
 	if !<-t.signal {
 		// At this point, it is likely that FailNow was called on one of the
 		// parent tests by one of the subtests. Continue aborting up the chain.
 		runtime.Goexit()
 	}
+
 	if t.chatty != nil && t.chatty.json {
 		t.chatty.Updatef(t.parent.name, "=== NAME  %s
", t.parent.name)
 	}
@@ -1938,7 +2040,12 @@ func (m *M) Run() (code int) {
 				testOk = false
 			}
 		}
-		if !testOk || !exampleOk || !fuzzTargetsOk || !runBenchmarks(m.deps.ImportPath(), m.deps.MatchString, m.benchmarks) || race.Errors() > 0 {
+		anyFailed := !testOk || !exampleOk || !fuzzTargetsOk || !runBenchmarks(m.deps.ImportPath(), m.deps.MatchString, m.benchmarks)
+		if !anyFailed && race.Errors() > 0 {
+			fmt.Print(chatty.prefix(), "testing: race detected outside of test execution
")
+			anyFailed = true
+		}
+		if anyFailed {
 			fmt.Print(chatty.prefix(), "FAIL
")
 			m.exitCode = 1
 			return
diff --git a/contrib/go/_std_1.21/src/testing/testing_other.go b/contrib/go/_std_1.22/src/testing/testing_other.go
similarity index 100%
rename from contrib/go/_std_1.21/src/testing/testing_other.go
rename to contrib/go/_std_1.22/src/testing/testing_other.go
diff --git a/contrib/go/_std_1.21/src/testing/testing_windows.go b/contrib/go/_std_1.22/src/testing/testing_windows.go
similarity index 100%
rename from contrib/go/_std_1.21/src/testing/testing_windows.go
rename to contrib/go/_std_1.22/src/testing/testing_windows.go
diff --git a/contrib/go/_std_1.22/src/testing/ya.make b/contrib/go/_std_1.22/src/testing/ya.make
new file mode 100644
index 000000000000..89bc52003d09
--- /dev/null
+++ b/contrib/go/_std_1.22/src/testing/ya.make
@@ -0,0 +1,29 @@
+GO_LIBRARY()
+IF (OS_DARWIN AND ARCH_ARM64 AND RACE AND CGO_ENABLED OR OS_DARWIN AND ARCH_ARM64 AND RACE AND NOT CGO_ENABLED OR OS_DARWIN AND ARCH_ARM64 AND NOT RACE AND CGO_ENABLED OR OS_DARWIN AND ARCH_ARM64 AND NOT RACE AND NOT CGO_ENABLED OR OS_DARWIN AND ARCH_X86_64 AND RACE AND CGO_ENABLED OR OS_DARWIN AND ARCH_X86_64 AND RACE AND NOT CGO_ENABLED OR OS_DARWIN AND ARCH_X86_64 AND NOT RACE AND CGO_ENABLED OR OS_DARWIN AND ARCH_X86_64 AND NOT RACE AND NOT CGO_ENABLED OR OS_LINUX AND ARCH_AARCH64 AND RACE AND CGO_ENABLED OR OS_LINUX AND ARCH_AARCH64 AND RACE AND NOT CGO_ENABLED OR OS_LINUX AND ARCH_AARCH64 AND NOT RACE AND CGO_ENABLED OR OS_LINUX AND ARCH_AARCH64 AND NOT RACE AND NOT CGO_ENABLED OR OS_LINUX AND ARCH_X86_64 AND RACE AND CGO_ENABLED OR OS_LINUX AND ARCH_X86_64 AND RACE AND NOT CGO_ENABLED OR OS_LINUX AND ARCH_X86_64 AND NOT RACE AND CGO_ENABLED OR OS_LINUX AND ARCH_X86_64 AND NOT RACE AND NOT CGO_ENABLED)
+    SRCS(
+        allocs.go
+        benchmark.go
+        cover.go
+        example.go
+        fuzz.go
+        match.go
+        newcover.go
+        run_example.go
+        testing.go
+        testing_other.go
+    )
+ELSEIF (OS_WINDOWS AND ARCH_X86_64 AND RACE AND CGO_ENABLED OR OS_WINDOWS AND ARCH_X86_64 AND RACE AND NOT CGO_ENABLED OR OS_WINDOWS AND ARCH_X86_64 AND NOT RACE AND CGO_ENABLED OR OS_WINDOWS AND ARCH_X86_64 AND NOT RACE AND NOT CGO_ENABLED)
+    SRCS(
+        allocs.go
+        benchmark.go
+        cover.go
+        example.go
+        fuzz.go
+        match.go
+        newcover.go
+        run_example.go
+        testing.go
+        testing_windows.go
+    )
+ENDIF()
+END()
diff --git a/contrib/libs/protobuf_old/src/google/protobuf/stubs/bytestream.cc b/contrib/libs/protobuf_old/src/google/protobuf/stubs/bytestream.cc
new file mode 100644
index 000000000000..980d6f6cfc56
--- /dev/null
+++ b/contrib/libs/protobuf_old/src/google/protobuf/stubs/bytestream.cc
@@ -0,0 +1,194 @@
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include <google/protobuf/stubs/bytestream.h>
+
+#include <string.h>
+#include <algorithm>
+
+#include <google/protobuf/stubs/logging.h>
+
+namespace google {
+namespace protobuf {
+namespace strings {
+
+void ByteSource::CopyTo(ByteSink* sink, size_t n) {
+  while (n > 0) {
+    StringPiece fragment = Peek();
+    if (fragment.empty()) {
+      GOOGLE_LOG(DFATAL) << "ByteSource::CopyTo() overran input.";
+      break;
+    }
+    std::size_t fragment_size = std::min<std::size_t>(n, fragment.size());
+    sink->Append(fragment.data(), fragment_size);
+    Skip(fragment_size);
+    n -= fragment_size;
+  }
+}
+
+void ByteSink::Flush() {}
+
+void UncheckedArrayByteSink::Append(const char* data, size_t n) {
+  if (data != dest_) {
+    // Catch cases where the pointer returned by GetAppendBuffer() was modified.
+    GOOGLE_DCHECK(!(dest_ <= data && data < (dest_ + n)))
+        << "Append() data[] overlaps with dest_[]";
+    memcpy(dest_, data, n);
+  }
+  dest_ += n;
+}
+
+CheckedArrayByteSink::CheckedArrayByteSink(char* outbuf, size_t capacity)
+    : outbuf_(outbuf), capacity_(capacity), size_(0), overflowed_(false) {
+}
+
+void CheckedArrayByteSink::Append(const char* bytes, size_t n) {
+  size_t available = capacity_ - size_;
+  if (n > available) {
+    n = available;
+    overflowed_ = true;
+  }
+  if (n > 0 && bytes != (outbuf_ + size_)) {
+    // Catch cases where the pointer returned by GetAppendBuffer() was modified.
+    GOOGLE_DCHECK(!(outbuf_ <= bytes && bytes < (outbuf_ + capacity_)))
+        << "Append() bytes[] overlaps with outbuf_[]";
+    memcpy(outbuf_ + size_, bytes, n);
+  }
+  size_ += n;
+}
+
+GrowingArrayByteSink::GrowingArrayByteSink(size_t estimated_size)
+    : capacity_(estimated_size),
+      buf_(new char[estimated_size]),
+      size_(0) {
+}
+
+GrowingArrayByteSink::~GrowingArrayByteSink() {
+  delete[] buf_;  // Just in case the user didn't call GetBuffer.
+}
+
+void GrowingArrayByteSink::Append(const char* bytes, size_t n) {
+  size_t available = capacity_ - size_;
+  if (bytes != (buf_ + size_)) {
+    // Catch cases where the pointer returned by GetAppendBuffer() was modified.
+    // We need to test for this before calling Expand() which may reallocate.
+    GOOGLE_DCHECK(!(buf_ <= bytes && bytes < (buf_ + capacity_)))
+        << "Append() bytes[] overlaps with buf_[]";
+  }
+  if (n > available) {
+    Expand(n - available);
+  }
+  if (n > 0 && bytes != (buf_ + size_)) {
+    memcpy(buf_ + size_, bytes, n);
+  }
+  size_ += n;
+}
+
+char* GrowingArrayByteSink::GetBuffer(size_t* nbytes) {
+  ShrinkToFit();
+  char* b = buf_;
+  *nbytes = size_;
+  buf_ = nullptr;
+  size_ = capacity_ = 0;
+  return b;
+}
+
+void GrowingArrayByteSink::Expand(size_t amount) {  // Expand by at least 50%.
+  size_t new_capacity = std::max(capacity_ + amount, (3 * capacity_) / 2);
+  char* bigger = new char[new_capacity];
+  memcpy(bigger, buf_, size_);
+  delete[] buf_;
+  buf_ = bigger;
+  capacity_ = new_capacity;
+}
+
+void GrowingArrayByteSink::ShrinkToFit() {
+  // Shrink only if the buffer is large and size_ is less than 3/4
+  // of capacity_.
+  if (capacity_ > 256 && size_ < (3 * capacity_) / 4) {
+    char* just_enough = new char[size_];
+    memcpy(just_enough, buf_, size_);
+    delete[] buf_;
+    buf_ = just_enough;
+    capacity_ = size_;
+  }
+}
+
+void StringByteSink::Append(const char* data, size_t n) {
+  dest_->append(data, n);
+}
+
+size_t ArrayByteSource::Available() const {
+  return input_.size();
+}
+
+StringPiece ArrayByteSource::Peek() {
+  return input_;
+}
+
+void ArrayByteSource::Skip(size_t n) {
+  GOOGLE_DCHECK_LE(n, input_.size());
+  input_.remove_prefix(n);
+}
+
+LimitByteSource::LimitByteSource(ByteSource *source, size_t limit)
+  : source_(source),
+    limit_(limit) {
+}
+
+size_t LimitByteSource::Available() const {
+  size_t available = source_->Available();
+  if (available > limit_) {
+    available = limit_;
+  }
+
+  return available;
+}
+
+StringPiece LimitByteSource::Peek() {
+  StringPiece piece = source_->Peek();
+  return StringPiece(piece.data(), std::min(piece.size(), limit_));
+}
+
+void LimitByteSource::Skip(size_t n) {
+  GOOGLE_DCHECK_LE(n, limit_);
+  source_->Skip(n);
+  limit_ -= n;
+}
+
+void LimitByteSource::CopyTo(ByteSink *sink, size_t n) {
+  GOOGLE_DCHECK_LE(n, limit_);
+  source_->CopyTo(sink, n);
+  limit_ -= n;
+}
+
+}  // namespace strings
+}  // namespace protobuf
+}  // namespace google
diff --git a/contrib/libs/protobuf_old/src/google/protobuf/stubs/bytestream.h b/contrib/libs/protobuf_old/src/google/protobuf/stubs/bytestream.h
new file mode 100644
index 000000000000..05d69ab89fcc
--- /dev/null
+++ b/contrib/libs/protobuf_old/src/google/protobuf/stubs/bytestream.h
@@ -0,0 +1,351 @@
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// This file declares the ByteSink and ByteSource abstract interfaces. These
+// interfaces represent objects that consume (ByteSink) or produce (ByteSource)
+// a sequence of bytes. Using these abstract interfaces in your APIs can help
+// make your code work with a variety of input and output types.
+//
+// This file also declares the following commonly used implementations of these
+// interfaces.
+//
+//   ByteSink:
+//      UncheckedArrayByteSink  Writes to an array, without bounds checking
+//      CheckedArrayByteSink    Writes to an array, with bounds checking
+//      GrowingArrayByteSink    Allocates and writes to a growable buffer
+//      StringByteSink          Writes to an STL string
+//      NullByteSink            Consumes a never-ending stream of bytes
+//
+//   ByteSource:
+//      ArrayByteSource         Reads from an array or string/StringPiece
+//      LimitedByteSource       Limits the number of bytes read from an
+
+#ifndef GOOGLE_PROTOBUF_STUBS_BYTESTREAM_H_
+#define GOOGLE_PROTOBUF_STUBS_BYTESTREAM_H_
+
+#include <stddef.h>
+#include <string>
+
+#include <google/protobuf/stubs/common.h>
+#include <google/protobuf/stubs/stringpiece.h>
+
+#include <google/protobuf/port_def.inc>
+
+class CordByteSink;
+
+namespace google {
+namespace protobuf {
+namespace strings {
+
+// An abstract interface for an object that consumes a sequence of bytes. This
+// interface offers a way to append data as well as a Flush() function.
+//
+// Example:
+//
+//   string my_data;
+//   ...
+//   ByteSink* sink = ...
+//   sink->Append(my_data.data(), my_data.size());
+//   sink->Flush();
+//
+class PROTOBUF_EXPORT ByteSink {
+ public:
+  ByteSink() {}
+  virtual ~ByteSink() {}
+
+  // Appends the "n" bytes starting at "bytes".
+  virtual void Append(const char* bytes, size_t n) = 0;
+
+  // Flushes internal buffers. The default implementation does nothing. ByteSink
+  // subclasses may use internal buffers that require calling Flush() at the end
+  // of the stream.
+  virtual void Flush();
+
+ private:
+  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ByteSink);
+};
+
+// An abstract interface for an object that produces a fixed-size sequence of
+// bytes.
+//
+// Example:
+//
+//   ByteSource* source = ...
+//   while (source->Available() > 0) {
+//     StringPiece data = source->Peek();
+//     ... do something with "data" ...
+//     source->Skip(data.length());
+//   }
+//
+class PROTOBUF_EXPORT ByteSource {
+ public:
+  ByteSource() {}
+  virtual ~ByteSource() {}
+
+  // Returns the number of bytes left to read from the source. Available()
+  // should decrease by N each time Skip(N) is called. Available() may not
+  // increase. Available() returning 0 indicates that the ByteSource is
+  // exhausted.
+  //
+  // Note: Size() may have been a more appropriate name as it's more
+  //       indicative of the fixed-size nature of a ByteSource.
+  virtual size_t Available() const = 0;
+
+  // Returns a StringPiece of the next contiguous region of the source. Does not
+  // reposition the source. The returned region is empty iff Available() == 0.
+  //
+  // The returned region is valid until the next call to Skip() or until this
+  // object is destroyed, whichever occurs first.
+  //
+  // The length of the returned StringPiece will be <= Available().
+  virtual StringPiece Peek() = 0;
+
+  // Skips the next n bytes. Invalidates any StringPiece returned by a previous
+  // call to Peek().
+  //
+  // REQUIRES: Available() >= n
+  virtual void Skip(size_t n) = 0;
+
+  // Writes the next n bytes in this ByteSource to the given ByteSink, and
+  // advances this ByteSource past the copied bytes. The default implementation
+  // of this method just copies the bytes normally, but subclasses might
+  // override CopyTo to optimize certain cases.
+  //
+  // REQUIRES: Available() >= n
+  virtual void CopyTo(ByteSink* sink, size_t n);
+
+ private:
+  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ByteSource);
+};
+
+//
+// Some commonly used implementations of ByteSink
+//
+
+// Implementation of ByteSink that writes to an unsized byte array. No
+// bounds-checking is performed--it is the caller's responsibility to ensure
+// that the destination array is large enough.
+//
+// Example:
+//
+//   char buf[10];
+//   UncheckedArrayByteSink sink(buf);
+//   sink.Append("hi", 2);    // OK
+//   sink.Append(data, 100);  // WOOPS! Overflows buf[10].
+//
+class PROTOBUF_EXPORT UncheckedArrayByteSink : public ByteSink {
+ public:
+  explicit UncheckedArrayByteSink(char* dest) : dest_(dest) {}
+  virtual void Append(const char* data, size_t n) override;
+
+  // Returns the current output pointer so that a caller can see how many bytes
+  // were produced.
+  //
+  // Note: this method is not part of the ByteSink interface.
+  char* CurrentDestination() const { return dest_; }
+
+ private:
+  char* dest_;
+  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(UncheckedArrayByteSink);
+};
+
+// Implementation of ByteSink that writes to a sized byte array. This sink will
+// not write more than "capacity" bytes to outbuf. Once "capacity" bytes are
+// appended, subsequent bytes will be ignored and Overflowed() will return true.
+// Overflowed() does not cause a runtime error (i.e., it does not CHECK fail).
+//
+// Example:
+//
+//   char buf[10];
+//   CheckedArrayByteSink sink(buf, 10);
+//   sink.Append("hi", 2);    // OK
+//   sink.Append(data, 100);  // Will only write 8 more bytes
+//
+class PROTOBUF_EXPORT CheckedArrayByteSink : public ByteSink {
+ public:
+  CheckedArrayByteSink(char* outbuf, size_t capacity);
+  virtual void Append(const char* bytes, size_t n) override;
+
+  // Returns the number of bytes actually written to the sink.
+  size_t NumberOfBytesWritten() const { return size_; }
+
+  // Returns true if any bytes were discarded, i.e., if there was an
+  // attempt to write more than 'capacity' bytes.
+  bool Overflowed() const { return overflowed_; }
+
+ private:
+  char* outbuf_;
+  const size_t capacity_;
+  size_t size_;
+  bool overflowed_;
+  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(CheckedArrayByteSink);
+};
+
+// Implementation of ByteSink that allocates an internal buffer (a char array)
+// and expands it as needed to accommodate appended data (similar to a string),
+// and allows the caller to take ownership of the internal buffer via the
+// GetBuffer() method. The buffer returned from GetBuffer() must be deleted by
+// the caller with delete[]. GetBuffer() also sets the internal buffer to be
+// empty, and subsequent appends to the sink will create a new buffer. The
+// destructor will free the internal buffer if GetBuffer() was not called.
+//
+// Example:
+//
+//   GrowingArrayByteSink sink(10);
+//   sink.Append("hi", 2);
+//   sink.Append(data, n);
+//   const char* buf = sink.GetBuffer();  // Ownership transferred
+//   delete[] buf;
+//
+class PROTOBUF_EXPORT GrowingArrayByteSink : public strings::ByteSink {
+ public:
+  explicit GrowingArrayByteSink(size_t estimated_size);
+  virtual ~GrowingArrayByteSink();
+  virtual void Append(const char* bytes, size_t n) override;
+
+  // Returns the allocated buffer, and sets nbytes to its size. The caller takes
+  // ownership of the buffer and must delete it with delete[].
+  char* GetBuffer(size_t* nbytes);
+
+ private:
+  void Expand(size_t amount);
+  void ShrinkToFit();
+
+  size_t capacity_;
+  char* buf_;
+  size_t size_;
+  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(GrowingArrayByteSink);
+};
+
+// Implementation of ByteSink that appends to the given string.
+// Existing contents of "dest" are not modified; new data is appended.
+//
+// Example:
+//
+//   string dest = "Hello ";
+//   StringByteSink sink(&dest);
+//   sink.Append("World", 5);
+//   assert(dest == "Hello World");
+//
+class PROTOBUF_EXPORT StringByteSink : public ByteSink {
+ public:
+  explicit StringByteSink(TProtoStringType* dest) : dest_(dest) {}
+  virtual void Append(const char* data, size_t n) override;
+
+ private:
+  TProtoStringType* dest_;
+  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(StringByteSink);
+};
+
+// Implementation of ByteSink that discards all data.
+//
+// Example:
+//
+//   NullByteSink sink;
+//   sink.Append(data, data.size());  // All data ignored.
+//
+class PROTOBUF_EXPORT NullByteSink : public ByteSink {
+ public:
+  NullByteSink() {}
+  void Append(const char* /*data*/, size_t /*n*/) override {}
+
+ private:
+  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(NullByteSink);
+};
+
+//
+// Some commonly used implementations of ByteSource
+//
+
+// Implementation of ByteSource that reads from a StringPiece.
+//
+// Example:
+//
+//   string data = "Hello";
+//   ArrayByteSource source(data);
+//   assert(source.Available() == 5);
+//   assert(source.Peek() == "Hello");
+//
+class PROTOBUF_EXPORT ArrayByteSource : public ByteSource {
+ public:
+  explicit ArrayByteSource(StringPiece s) : input_(s) {}
+
+  virtual size_t Available() const override;
+  virtual StringPiece Peek() override;
+  virtual void Skip(size_t n) override;
+
+ private:
+  StringPiece   input_;
+  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ArrayByteSource);
+};
+
+// Implementation of ByteSource that wraps another ByteSource, limiting the
+// number of bytes returned.
+//
+// The caller maintains ownership of the underlying source, and may not use the
+// underlying source while using the LimitByteSource object.  The underlying
+// source's pointer is advanced by n bytes every time this LimitByteSource
+// object is advanced by n.
+//
+// Example:
+//
+//   string data = "Hello World";
+//   ArrayByteSource abs(data);
+//   assert(abs.Available() == data.size());
+//
+//   LimitByteSource limit(abs, 5);
+//   assert(limit.Available() == 5);
+//   assert(limit.Peek() == "Hello");
+//
+class PROTOBUF_EXPORT LimitByteSource : public ByteSource {
+ public:
+  // Returns at most "limit" bytes from "source".
+  LimitByteSource(ByteSource* source, size_t limit);
+
+  virtual size_t Available() const override;
+  virtual StringPiece Peek() override;
+  virtual void Skip(size_t n) override;
+
+  // We override CopyTo so that we can forward to the underlying source, in
+  // case it has an efficient implementation of CopyTo.
+  virtual void CopyTo(ByteSink* sink, size_t n) override;
+
+ private:
+  ByteSource* source_;
+  size_t limit_;
+};
+
+}  // namespace strings
+}  // namespace protobuf
+}  // namespace google
+
+#include <google/protobuf/port_undef.inc>
+
+#endif  // GOOGLE_PROTOBUF_STUBS_BYTESTREAM_H_
diff --git a/yt/yt/client/unittests/composite_compare_ut.cpp b/yt/yt/client/unittests/composite_compare_ut.cpp
index 5332abe182a1..5e792919fabd 100644
--- a/yt/yt/client/unittests/composite_compare_ut.cpp
+++ b/yt/yt/client/unittests/composite_compare_ut.cpp
@@ -8,12 +8,14 @@
 namespace NYT::NTableClient {
 namespace {
 
+using namespace NYson;
+
 ////////////////////////////////////////////////////////////////////////////////
 
 TEST(TCompositeCompare, Simple)
 {
     auto compare = [] (TStringBuf lhs, TStringBuf rhs) {
-        return CompareCompositeValues(NYson::TYsonStringBuf(lhs), NYson::TYsonStringBuf(rhs));
+        return CompareCompositeValues(TYsonStringBuf(lhs), TYsonStringBuf(rhs));
     };
 
     EXPECT_EQ(-1, compare("-4", "42"));
@@ -59,7 +61,7 @@ TEST(TCompositeCompare, Simple)
 TEST(TCompositeCompare, CompositeFingerprint)
 {
     auto getFarmHash = [] (TStringBuf value) {
-        return CompositeFarmHash(NYson::TYsonStringBuf(value));
+        return CompositeFarmHash(TYsonStringBuf(value));
     };
 
     EXPECT_EQ(getFarmHash("-42"), GetFarmFingerprint(MakeUnversionedInt64Value(-42)));
@@ -70,6 +72,75 @@ TEST(TCompositeCompare, CompositeFingerprint)
     EXPECT_EQ(getFarmHash("#"), GetFarmFingerprint(MakeUnversionedNullValue()));
 }
 
+TEST(TCompositeCompare, TruncateCompositeValue)
+{
+    auto normalizeYson = [] (TStringBuf yson) {
+        return yson.empty() ? TString(yson) : ConvertToYsonString(TYsonString(yson), EYsonFormat::Binary).ToString();
+    };
+
+    auto getTruncatedYson = [&] (TStringBuf original, i64 size) {
+        auto truncatedCompositeValue = TruncateCompositeValue(TYsonString(original), size);
+        return truncatedCompositeValue ? truncatedCompositeValue->ToString() : "";
+    };
+
+    // When we rebuild the whole string during truncation, we should produce the correct normalized binary YSON version of the string as output.
+    auto checkFullStringIdempotence = [&] (TStringBuf yson) {
+        auto normalizedYson = normalizeYson(yson);
+        EXPECT_EQ(normalizedYson, getTruncatedYson(yson, std::numeric_limits<i64>::max()));
+        EXPECT_EQ(normalizedYson, getTruncatedYson(yson, std::ssize(normalizedYson)));
+    };
+
+    auto checkTruncatedYson = [&] (TStringBuf expectedTruncatedYson, TStringBuf originalYson, i64 size) {
+        auto normalizedExpectedTruncatedYson = normalizeYson(expectedTruncatedYson);
+        auto truncatedYson = getTruncatedYson(originalYson, size);
+
+        // For easier debugging.
+        EXPECT_EQ(normalizedExpectedTruncatedYson.size(), truncatedYson.size());
+        EXPECT_EQ(normalizedExpectedTruncatedYson, truncatedYson);
+    };
+
+    checkFullStringIdempotence("[[5; 7]; [1; 5];]");
+    checkFullStringIdempotence("[[5; 7]; [1; 5; 4; 3]; [2; 0; 0; 7]]");
+    checkFullStringIdempotence("[[5; 7]; [1; 5; 4; 3; [g; r; i; t; #; k; #; n]]; [%true; [%false; 0;];]; [2; 0; 0; 7]]");
+    checkFullStringIdempotence("this-string-desperately-wants-to-be-filled-with-some-funny-references-but-i-have-no-ideas");
+    checkFullStringIdempotence("%true");
+    checkFullStringIdempotence("#");
+    checkFullStringIdempotence("\"\"");
+
+    checkTruncatedYson("[[5; 7]; [1; 5];]", "[[5; 7]; [1; 5; 4; 3]; [2; 0; 0; 7]]", 20);
+    checkTruncatedYson("[[5; 7]; [1; 5];]", "[[5; 7]; [1; 5; 4; 3]; [2; 0; 0; 7]]", 21);
+    checkTruncatedYson("[[5; 7]; [1; 5];]", "[[5; 7]; [1; 5; 4; 3]; [2; 0; 0; 7]]", 22);
+    // We need 3 more bytes for the next integer: 1 for the type flag, 1 for the varint, 1 for the item separator.
+    checkTruncatedYson("[[5; 7]; [1; 5; 4;];]", "[[5; 7]; [1; 5; 4; 3]; [2; 0; 0; 7]]", 23);
+    // The value 1543 takes up 4 extra bytes, since it is represented as 2 varint bytes.
+    checkTruncatedYson("[[5; 7]; [1; 5; 4; 1543];]", "[[5; 7]; [1; 5; 4; 1543]; [2; 0; 0; 7]]", 27);
+
+    checkTruncatedYson("[[#; 0;];]", "[[#; 0; %true; x; #]; 1;]", 10);
+    // We need 2 more bytes for the boolean: 1 for the type flag which encodes the value itself, 1 for the item serpator.
+    checkTruncatedYson("[[#; 0; %true];]", "[[#; 0; %true; #; x]; 1;]", 12);
+    // Same for entities.
+    checkTruncatedYson("[[#; 0; %true; #;];]", "[[#; 0; %true; #; x]; 1;]", 14);
+
+    // NB: "" is actually std::nullopt returned from the function, it is just easier to visualize this way.
+    checkTruncatedYson("", "abacaba", 1);
+    checkTruncatedYson("", "1", 1);
+    checkTruncatedYson("", "[]", 1);
+    // Entity takes up only 1 byte!
+    checkTruncatedYson("#", "#", 1);
+
+    checkTruncatedYson("this-string", "this-string-desperately-wants-to-be-filled-with-some-funny-references-but-i-have-no-ideas", 14);
+    checkTruncatedYson("this-string-", "this-string-desperately-wants-to-be-filled-with-some-funny-references-but-i-have-no-ideas", 15);
+    checkTruncatedYson("this-string-desperatel", "this-string-desperately-wants-to-be-filled-with-some-funny-references-but-i-have-no-ideas", 25);
+    checkTruncatedYson("[please; [take; [me; ha;];];]", "[please; [take; [me; haha; too; late]]]", 34);
+    // The actual size of the resulting yson is only 4 bytes, but during truncation it is too hard to account for the fact that longer strings
+    // take up more bytes for their length, since it is represented as a varint.
+    checkTruncatedYson("aa", TString(1000, 'a'), 5);
+    checkTruncatedYson("\"\"", "erase-me", 2);
+
+    checkTruncatedYson("[[5; 7]; [1; 5; 4; 3]; [];]", "[[5; 7]; [1; 5; 4; 3]; [{hello=darkness}; 0; 0; 7]]", 10000);
+    checkTruncatedYson("[[5; 7];]", "[[5; 7]; <my-name=borat>[1; 5; 4; 3]; [{greetings=xoxo}; 0; 0; 7]]", 10000);
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 
 } // namespace
diff --git a/yt/yt/core/concurrency/unittests/fair_share_invoker_pool_ut.cpp b/yt/yt/core/concurrency/unittests/fair_share_invoker_pool_ut.cpp
index 65cb477b6f3d..e6f0b6feaca1 100644
--- a/yt/yt/core/concurrency/unittests/fair_share_invoker_pool_ut.cpp
+++ b/yt/yt/core/concurrency/unittests/fair_share_invoker_pool_ut.cpp
@@ -23,7 +23,7 @@ namespace {
 
 ////////////////////////////////////////////////////////////////////////////////
 
-constexpr auto Margin = TDuration::MilliSeconds(1);
+constexpr auto Margin = TDuration::MilliSeconds(20);
 constexpr auto Quantum = TDuration::MilliSeconds(100);
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -427,7 +427,7 @@ TEST_F(TFairShareInvokerPoolTest, CpuTimeAccountingBetweenContextSwitchesIsNotSu
         EXPECT_TRUE(!invocationOrder.empty());
     }).AsyncVia(invokerPool->GetInvoker(0)).Run();
 
-    YT_VERIFY(started.Wait(Quantum * 100));
+    started.Wait();
 
     // After 10 quantums of time (see notification of the #started variable) we start Fairness test in the second thread.
     // In case of better implementation we expect to have non-fair CPU time distribution between first and second invokers,
@@ -457,7 +457,7 @@ TEST_F(TFairShareInvokerPoolTest, GetTotalWaitTimeEstimateStuckAction)
     NThreading::TEvent event;
 
     auto action = BIND([&event] {
-        event.Wait(TDuration::Seconds(100));
+        event.Wait();
     })
         .AsyncVia(invokerPool->GetInvoker(0))
         .Run();
@@ -481,7 +481,7 @@ TEST_F(TFairShareInvokerPoolTest, GetTotalWaitTimeEstimateRelevancyDecay)
     NThreading::TEvent event;
 
     auto action = BIND([&event] {
-        event.Wait(100 * Quantum);
+        event.Wait();
     })
         .AsyncVia(invokerPool->GetInvoker(0))
         .Run();
@@ -507,14 +507,14 @@ TEST_F(TFairShareInvokerPoolTest, GetTotalWaitTimeEstimateSeveralActions)
 
     auto invokerPool = CreateInvokerPool(Queues_[0]->GetInvoker(), 1);
     // Make aggregator never forget a sample.
-    invokerPool->UpdateActionTimeRelevancyHalflife(TDuration::Days(100000000000000000));
+    invokerPool->UpdateActionTimeRelevancyHalflife(TDuration::Max());
 
     std::vector<NThreading::TEvent> leashes(ActionCount);
     std::vector<TFuture<void>> actions;
 
     for (int idx = 0; idx < ActionCount; ++idx) {
         actions.push_back(BIND([&leashes, idx] {
-            leashes[idx].Wait(100 * Quantum);
+            leashes[idx].Wait();
         })
             .AsyncVia(invokerPool->GetInvoker(0))
             .Run());
@@ -556,7 +556,7 @@ TEST_F(TFairShareInvokerPoolTest, GetTotalWaitEstimateUncorrelatedWithOtherInvok
     };
     auto invokerPool = CreateInvokerPool(Queues_[0]->GetInvoker(), 2);
     // Make aggregator never forget a sample.
-    invokerPool->UpdateActionTimeRelevancyHalflife(TDuration::Days(100000000000000000));
+    invokerPool->UpdateActionTimeRelevancyHalflife(TDuration::Max());
 
     std::vector<NThreading::TEvent> leashes(2);
     std::vector<TFuture<void>> actions;
@@ -568,7 +568,7 @@ TEST_F(TFairShareInvokerPoolTest, GetTotalWaitEstimateUncorrelatedWithOtherInvok
             } else {
                 executionOrderEnforcer(2);
             }
-            leashes[idx].Wait(100 * Quantum);
+            leashes[idx].Wait();
         })
             .AsyncVia(invokerPool->GetInvoker(0))
             .Run());
@@ -577,7 +577,7 @@ TEST_F(TFairShareInvokerPoolTest, GetTotalWaitEstimateUncorrelatedWithOtherInvok
     NThreading::TEvent secondaryLeash;
     auto secondaryAction = BIND([&executionOrderEnforcer, &secondaryLeash] {
         executionOrderEnforcer(1);
-        secondaryLeash.Wait(100 * Quantum);
+        secondaryLeash.Wait();
     })
         .AsyncVia(invokerPool->GetInvoker(1))
         .Run();
diff --git a/yt/yt/core/concurrency/unittests/profiled_fair_share_invoker_pool_ut.cpp b/yt/yt/core/concurrency/unittests/profiled_fair_share_invoker_pool_ut.cpp
index 89b84ad4eac3..86055fe9aaea 100644
--- a/yt/yt/core/concurrency/unittests/profiled_fair_share_invoker_pool_ut.cpp
+++ b/yt/yt/core/concurrency/unittests/profiled_fair_share_invoker_pool_ut.cpp
@@ -28,7 +28,7 @@ using namespace NProfiling;
 
 ////////////////////////////////////////////////////////////////////////////////
 
-constexpr auto Margin = TDuration::MilliSeconds(1);
+constexpr auto Margin = TDuration::MilliSeconds(20);
 constexpr auto Quantum = TDuration::MilliSeconds(100);
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -440,7 +440,7 @@ TEST_F(TProfiledFairShareInvokerPoolTest, CpuTimeAccountingBetweenContextSwitche
         EXPECT_TRUE(!invocationOrder.empty());
     }).AsyncVia(invokerPool->GetInvoker(0)).Run();
 
-    YT_VERIFY(started.Wait(Quantum * 100));
+    started.Wait();
 
     // After 10 quantums of time (see notification of the #started variable) we start Fairness test in the second thread.
     // In case of better implementation we expect to have non-fair CPU time distribution between first and second invokers,
@@ -470,7 +470,7 @@ TEST_F(TProfiledFairShareInvokerPoolTest, GetTotalWaitTimeEstimateStuckAction)
     NThreading::TEvent event;
 
     auto action = BIND([&event]{
-        event.Wait(TDuration::Seconds(100));
+        event.Wait();
     })
     .AsyncVia(invokerPool->GetInvoker(0))
     .Run();
@@ -494,7 +494,7 @@ TEST_F(TProfiledFairShareInvokerPoolTest, GetTotalWaitTimeEstimateRelevancyDecay
     NThreading::TEvent event;
 
     auto action = BIND([&event]{
-        event.Wait(100 * Quantum);
+        event.Wait();
     })
     .AsyncVia(invokerPool->GetInvoker(0))
     .Run();
@@ -520,14 +520,14 @@ TEST_F(TProfiledFairShareInvokerPoolTest, GetTotalWaitTimeEstimateSeveralActions
 
     auto invokerPool = CreateInvokerPool(Queues_[0]->GetInvoker(), 1);
     // Make aggregator never forget a sample.
-    invokerPool->UpdateActionTimeRelevancyHalflife(TDuration::Days(100000000000000000));
+    invokerPool->UpdateActionTimeRelevancyHalflife(TDuration::Max());
 
     std::vector<NThreading::TEvent> leashes(ActionCount);
     std::vector<TFuture<void>> actions;
 
     for (int idx = 0; idx < ActionCount; ++idx) {
         actions.emplace_back(BIND([&leashes, idx] {
-            leashes[idx].Wait(100 * Quantum);
+            leashes[idx].Wait();
         })
         .AsyncVia(invokerPool->GetInvoker(0))
         .Run());
@@ -569,7 +569,7 @@ TEST_F(TProfiledFairShareInvokerPoolTest, GetTotalWaitEstimateUncorrelatedWithOt
     };
     auto invokerPool = CreateInvokerPool(Queues_[0]->GetInvoker(), 2);
     // Make aggregator never forget a sample.
-    invokerPool->UpdateActionTimeRelevancyHalflife(TDuration::Days(100000000000000000));
+    invokerPool->UpdateActionTimeRelevancyHalflife(TDuration::Max());
 
     std::vector<NThreading::TEvent> leashes(2);
     std::vector<TFuture<void>> actions;
@@ -581,7 +581,7 @@ TEST_F(TProfiledFairShareInvokerPoolTest, GetTotalWaitEstimateUncorrelatedWithOt
             } else {
                 executionOrderEnforcer(2);
             }
-            leashes[idx].Wait(100 * Quantum);
+            leashes[idx].Wait();
         })
         .AsyncVia(invokerPool->GetInvoker(0))
         .Run());
@@ -590,7 +590,7 @@ TEST_F(TProfiledFairShareInvokerPoolTest, GetTotalWaitEstimateUncorrelatedWithOt
     NThreading::TEvent secondaryLeash;
     auto secondaryAction = BIND([&executionOrderEnforcer, &secondaryLeash] {
         executionOrderEnforcer(1);
-        secondaryLeash.Wait(100 * Quantum);
+        secondaryLeash.Wait();
     }).AsyncVia(invokerPool->GetInvoker(1)).Run();
 
     auto start = GetInstant();
diff --git a/yt/yt/core/misc/unittests/error_ut.cpp b/yt/yt/core/misc/unittests/error_ut.cpp
index e83e76235802..6fc88ef8abc5 100644
--- a/yt/yt/core/misc/unittests/error_ut.cpp
+++ b/yt/yt/core/misc/unittests/error_ut.cpp
@@ -670,7 +670,7 @@ TEST(TErrorTest, CompositeYTExceptionToError)
         try {
             throw TSimpleException("inner message");
         } catch (const std::exception& ex) {
-            throw TCompositeException(ex, "outer message");
+            throw TSimpleException(ex, "outer message");
         }
     } catch (const std::exception& ex) {
         TError outerError(ex);
@@ -683,6 +683,37 @@ TEST(TErrorTest, CompositeYTExceptionToError)
     }
 }
 
+TEST(TErrorTest, YTExceptionWithAttributesToError)
+{
+    try {
+        throw TSimpleException("message")
+            << TExceptionAttribute{"Int64 value", static_cast<i64>(42)}
+            << TExceptionAttribute{"double value", 7.77}
+            << TExceptionAttribute{"bool value", false}
+            << TExceptionAttribute{"String value", "FooBar"};
+    } catch (const std::exception& ex) {
+        TError error(ex);
+        EXPECT_EQ(NYT::EErrorCode::Generic, error.GetCode());
+        EXPECT_EQ("message", error.GetMessage());
+
+        auto i64value = error.Attributes().Find<i64>("Int64 value");
+        EXPECT_TRUE(i64value);
+        EXPECT_EQ(*i64value, static_cast<i64>(42));
+
+        auto doubleValue = error.Attributes().Find<double>("double value");
+        EXPECT_TRUE(doubleValue);
+        EXPECT_EQ(*doubleValue, 7.77);
+
+        auto boolValue = error.Attributes().Find<bool>("bool value");
+        EXPECT_TRUE(boolValue);
+        EXPECT_EQ(*boolValue, false);
+
+        auto stringValue = error.Attributes().Find<TString>("String value");
+        EXPECT_TRUE(stringValue);
+        EXPECT_EQ(*stringValue, "FooBar");
+    }
+}
+
 TEST(TErrorTest, ErrorSanitizer)
 {
     auto checkSantizied = [&] (const TError& error) {
