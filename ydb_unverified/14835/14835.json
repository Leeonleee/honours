{
  "repo": "ydb-platform/ydb",
  "pull_number": 14835,
  "instance_id": "ydb-platform__ydb-14835",
  "issue_numbers": [
    "14578"
  ],
  "base_commit": "4d7998d6ef0cc65a9b29d2b752aa9fa999549b78",
  "patch": "diff --git a/ydb/core/tablet_flat/flat_executor_gclogic.cpp b/ydb/core/tablet_flat/flat_executor_gclogic.cpp\nindex a2a6ab80cd6f..77839c150da8 100644\n--- a/ydb/core/tablet_flat/flat_executor_gclogic.cpp\n+++ b/ydb/core/tablet_flat/flat_executor_gclogic.cpp\n@@ -207,12 +207,6 @@ TExecutorGCLogic::TChannelInfo::TChannelInfo()\n {\n }\n \n-void TExecutorGCLogic::TChannelInfo::ApplyDelta(TGCTime time, TGCBlobDelta& delta) {\n-    TGCBlobDelta& committedDelta = CommittedDelta[time];\n-    DoSwap(committedDelta, delta);\n-    Y_DEBUG_ABORT_UNLESS(delta.Created.empty() && delta.Deleted.empty());\n-}\n-\n void TExecutorGCLogic::MergeVectors(TVector<TLogoBlobID>& destination, const TVector<TLogoBlobID>& source) {\n     if (!source.empty()) {\n         destination.insert(destination.end(), source.begin(), source.end());\n@@ -388,7 +382,7 @@ void TExecutorGCLogic::TChannelInfo::SendCollectGarbage(TGCTime uncommittedTime,\n \n     // The first barrier of gen:0 (zero entry) is special\n     TGCTime zeroTime{ generation, 0 };\n-    if (KnownGcBarrier < zeroTime && collectBarrier < zeroTime && zeroTime <= uncommittedTime) {\n+    if (CommitedGcBarrier < zeroTime && collectBarrier < zeroTime && zeroTime <= uncommittedTime) {\n         collectBarrier = zeroTime;\n     }\n \ndiff --git a/ydb/core/tablet_flat/flat_executor_gclogic.h b/ydb/core/tablet_flat/flat_executor_gclogic.h\nindex f0f77a95936c..cf15070a4a73 100644\n--- a/ydb/core/tablet_flat/flat_executor_gclogic.h\n+++ b/ydb/core/tablet_flat/flat_executor_gclogic.h\n@@ -91,7 +91,6 @@ class TExecutorGCLogic {\n         ui32 GcWaitFor;\n \n         inline TChannelInfo();\n-        void ApplyDelta(TGCTime time, TGCBlobDelta &delta);\n         void SendCollectGarbage(TGCTime uncommittedTime, const TTabletStorageInfo *tabletStorageInfo, ui32 channel, ui32 generation, const TActorContext& executor);\n         void SendCollectGarbageEntry(const TActorContext &ctx, TVector<TLogoBlobID> &&keep, TVector<TLogoBlobID> &&notKeep, ui64 tabletid, ui32 channel, ui32 bsgroup, ui32 generation);\n         void OnCollectGarbageSuccess();\ndiff --git a/ydb/core/tablet_flat/flat_executor_ut.cpp b/ydb/core/tablet_flat/flat_executor_ut.cpp\nindex 7c2556c30716..293daf518848 100644\n--- a/ydb/core/tablet_flat/flat_executor_ut.cpp\n+++ b/ydb/core/tablet_flat/flat_executor_ut.cpp\n@@ -6819,5 +6819,72 @@ Y_UNIT_TEST_SUITE(TFlatTableExecutor_Reboot) {\n     }\n }\n \n+Y_UNIT_TEST_SUITE(TFlatTableExecutor_Gc) {\n+    Y_UNIT_TEST(TestFailedGcAfterReboot) {\n+        TMyEnvBase env;\n+        TRowsModel rows;\n+\n+        //env->SetLogPriority(NKikimrServices::RESOURCE_BROKER, NActors::NLog::PRI_DEBUG);\n+        //env->SetLogPriority(NKikimrServices::TABLET_EXECUTOR, NActors::NLog::PRI_DEBUG);\n+\n+        env.FireTablet(env.Edge, env.Tablet, [&env](const TActorId &tablet, TTabletStorageInfo *info) {\n+            return new TTestFlatTablet(env.Edge, tablet, info);\n+        });\n+        env.WaitForWakeUp();\n+\n+        TIntrusivePtr<TCompactionPolicy> policy = new TCompactionPolicy;\n+\n+        env.SendSync(rows.MakeScheme(std::move(policy)));\n+        env.SendSync(rows.MakeRows(1));\n+\n+        std::vector<std::pair<ui32, ui32>> gcBarriers;\n+        auto gcRequestObserver = env->AddObserver<TEvBlobStorage::TEvCollectGarbage>([&](auto & ev) {\n+            auto* msg = ev->Get();\n+            if (msg->Channel == 1) {\n+                Cerr << \"... observed \" << msg->ToString() << Endl;\n+                gcBarriers.emplace_back(msg->CollectGeneration, msg->CollectStep);\n+            }\n+        });\n+\n+        std::deque<TEvBlobStorage::TEvCollectGarbageResult::TPtr> gcResults;\n+        auto gcResultObserver = env->AddObserver<TEvBlobStorage::TEvCollectGarbageResult>([&](auto& ev) {\n+            auto* msg = ev->Get();\n+            if (msg->Channel == 1 && msg->PerGenerationCounter == 1) {\n+                Cerr << \"... intercepted \" << msg->ToString() << Endl;\n+                gcResults.push_back(std::move(ev));\n+            }\n+        });\n+\n+        Cerr << \"... restarting tablet\" << Endl;\n+        env.SendSync(new TEvents::TEvPoison, false, true);\n+        env.WaitForGone();\n+        env.FireTablet(env.Edge, env.Tablet, [&env](const TActorId &tablet, TTabletStorageInfo *info) {\n+            return new TTestFlatTablet(env.Edge, tablet, info);\n+        });\n+        env.WaitForWakeUp();\n+\n+        env->SimulateSleep(TDuration::MilliSeconds(10));\n+        UNIT_ASSERT_VALUES_EQUAL(gcBarriers.size(), 1u);\n+        UNIT_ASSERT_VALUES_EQUAL(gcResults.size(), 1u);\n+        UNIT_ASSERT_VALUES_EQUAL(gcBarriers[0].second, 0u);\n+\n+        // Replace gc result with an error\n+        Cerr << \"... faking a gc error\" << Endl;\n+        {\n+            gcResultObserver.Remove();\n+            gcResults.front()->Get()->Status = NKikimrProto::ERROR;\n+            env->Send(gcResults.front().Release(), 0, true);\n+            gcResults.pop_front();\n+        }\n+\n+        // This write will incidentally cause a new gc attempt\n+        env.SendSync(rows.MakeRows(1), /* retry */ true);\n+\n+        env->SimulateSleep(TDuration::MilliSeconds(10));\n+        UNIT_ASSERT_C(gcBarriers.size() >= 2, gcBarriers.size());\n+        UNIT_ASSERT_C(gcBarriers[0] <= gcBarriers[1], \"unexpected barrier decrease\");\n+    }\n+}\n+\n }\n }\n",
  "test_patch": "diff --git a/ydb/core/tablet_flat/test/libs/exec/runner.h b/ydb/core/tablet_flat/test/libs/exec/runner.h\nindex 79712ab05fc8..fcee6abc5c3b 100644\n--- a/ydb/core/tablet_flat/test/libs/exec/runner.h\n+++ b/ydb/core/tablet_flat/test/libs/exec/runner.h\n@@ -56,6 +56,11 @@ namespace NFake {\n             SetupModelServices();\n         }\n \n+        TTestActorRuntime& operator*() noexcept\n+        {\n+            return Env;\n+        }\n+\n         TTestActorRuntime* operator->() noexcept\n         {\n             return &Env;\n",
  "problem_statement": "LocalDB: gc sends decreasing barriers\nLooks like executor may send a decreasing barrier in the same generation in some cases:\n\n```\n2025-02-14T11:24:20.133183Z :BS_HULLRECS CRIT: VDISK[0:_:0:6:0]: Db# Barriers ValidateGCCmd: decreasing barrier: existing key# [72057594037932033 1 3805 1 soft] barrier# 3805:0 new key# [72057594037932033 1 3805 2 soft] barrier# 3804:111\n2025-02-14T11:24:20.132194Z :BS_HULLRECS CRIT: VDISK[0:_:0:1:0]: Db# Barriers ValidateGCCmd: decreasing barrier: existing key# [72057594037932033 1 3805 1 soft] barrier# 3805:0 new key# [72057594037932033 1 3805 2 soft] barrier# 3804:111\n2025-02-14T11:24:20.132176Z :BS_HULLRECS CRIT: VDISK[0:_:0:0:0]: Db# Barriers ValidateGCCmd: decreasing barrier: existing key# [72057594037932033 1 3805 1 soft] barrier# 3805:0 new key# [72057594037932033 1 3805 2 soft] barrier# 3804:111\n2025-02-14T11:24:20.133725Z :BS_HULLRECS CRIT: VDISK[0:_:0:5:0]: Db# Barriers ValidateGCCmd: decreasing barrier: existing key# [72057594037932033 1 3805 1 soft] barrier# 3805:0 new key# [72057594037932033 1 3805 2 soft] barrier# 3804:111\n2025-02-14T11:24:20.132201Z :BS_HULLRECS CRIT: VDISK[0:_:0:2:0]: Db# Barriers ValidateGCCmd: decreasing barrier: existing key# [72057594037932033 1 3805 1 soft] barrier# 3805:0 new key# [72057594037932033 1 3805 2 soft] barrier# 3804:111\n2025-02-14T11:24:20.132117Z :BS_HULLRECS CRIT: VDISK[0:_:0:7:0]: Db# Barriers ValidateGCCmd: decreasing barrier: existing key# [72057594037932033 1 3805 1 soft] barrier# 3805:0 new key# [72057594037932033 1 3805 2 soft] barrier# 3804:111\n```\n",
  "hints_text": "I think such a kickback is possible when gc barrier for gen:0 fails, in which case we would clear `CollectSent` and later we would choose barrier based on the last `CommittedDelta` entry. We probably need to fix the `zeroTime` check to use `CommittedGcBarrier` instead of `KnownGcBarrier`, as until the first barrier completes we should keep retrying.",
  "created_at": "2025-02-20T11:00:33Z",
  "modified_files": [
    "ydb/core/tablet_flat/flat_executor_gclogic.cpp",
    "ydb/core/tablet_flat/flat_executor_gclogic.h",
    "ydb/core/tablet_flat/flat_executor_ut.cpp"
  ],
  "modified_test_files": [
    "ydb/core/tablet_flat/test/libs/exec/runner.h"
  ]
}