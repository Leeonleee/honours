{
  "repo": "ydb-platform/ydb",
  "pull_number": 19750,
  "instance_id": "ydb-platform__ydb-19750",
  "issue_numbers": [
    "19683"
  ],
  "base_commit": "946d88cee0b5f0e5acae118e47e685942146408d",
  "patch": "diff --git a/ydb/core/tx/schemeshard/schemeshard_build_index__progress.cpp b/ydb/core/tx/schemeshard/schemeshard_build_index__progress.cpp\nindex b969f3f4ff08..a6ae4fb62949 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_build_index__progress.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard_build_index__progress.cpp\n@@ -348,9 +348,9 @@ THolder<TEvSchemeShard::TEvModifySchemeTransaction> CreateBuildPropose(\n         op.SetName(TString::Join(PostingTable, suffix));\n         NTableIndex::FillIndexTableColumns(tableInfo->Columns, implTableColumns.Keys, implTableColumns.Columns, op);\n         auto& policy = *resetPartitionsSettings();\n-        const auto shards = tableInfo->GetShard2PartitionIdx().size();\n-        policy.SetMinPartitionsCount(shards);\n-        policy.SetMaxPartitionsCount(shards);\n+        // Prevent merging partitions\n+        policy.SetMinPartitionsCount(32768);\n+        policy.SetMaxPartitionsCount(0);\n \n         LOG_DEBUG_S((TlsActivationContext->AsActorContext()), NKikimrServices::BUILD_INDEX, \n             \"CreateBuildPropose \" << buildInfo.Id << \" \" << buildInfo.State << \" \" << propose->Record.ShortDebugString());\n@@ -867,6 +867,10 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n         if (NoShardsAdded(buildInfo)) {\n             AddAllShards(buildInfo);\n         }\n+        size_t i = 0;\n+        for (auto& [shardIdx, shardStatus]: buildInfo.Shards) {\n+            shardStatus.Index = i++;\n+        }\n         return SendToShards(buildInfo, [&](TShardIdx shardIdx) { SendPrefixKMeansRequest(shardIdx, buildInfo); }) &&\n                buildInfo.DoneShards.size() == buildInfo.Shards.size();\n     }\n@@ -1428,7 +1432,7 @@ struct TSchemeShard::TIndexBuilder::TTxProgress: public TSchemeShard::TIndexBuil\n                 LOG_D(\"shard \" << x.ShardIdx << \" range \" << buildInfo.KMeans.RangeToDebugStr(shardRange));\n                 buildInfo.AddParent(shardRange, x.ShardIdx);\n             }\n-            auto [it, emplaced] = buildInfo.Shards.emplace(x.ShardIdx, TIndexBuildInfo::TShardStatus{std::move(shardRange), \"\", buildInfo.Shards.size()});\n+            auto [it, emplaced] = buildInfo.Shards.emplace(x.ShardIdx, TIndexBuildInfo::TShardStatus{std::move(shardRange), \"\"});\n             Y_ENSURE(emplaced);\n             shardRange.From = std::move(bound);\n \ndiff --git a/ydb/core/tx/schemeshard/schemeshard_info_types.cpp b/ydb/core/tx/schemeshard/schemeshard_info_types.cpp\nindex 4ddf617643f5..bfee71855f5f 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_info_types.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard_info_types.cpp\n@@ -2203,10 +2203,9 @@ void TImportInfo::AddNotifySubscriber(const TActorId &actorId) {\n     Subscribers.insert(actorId);\n }\n \n-TIndexBuildInfo::TShardStatus::TShardStatus(TSerializedTableRange range, TString lastKeyAck, size_t shardsCount)\n+TIndexBuildInfo::TShardStatus::TShardStatus(TSerializedTableRange range, TString lastKeyAck)\n     : Range(std::move(range))\n     , LastKeyAck(std::move(lastKeyAck))\n-    , Index(shardsCount)\n {}\n \n void TIndexBuildInfo::SerializeToProto(TSchemeShard* ss, NKikimrSchemeOp::TIndexBuildConfig* result) const {\ndiff --git a/ydb/core/tx/schemeshard/schemeshard_info_types.h b/ydb/core/tx/schemeshard/schemeshard_info_types.h\nindex 2cd0ed0194ba..26cc3775e129 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_info_types.h\n+++ b/ydb/core/tx/schemeshard/schemeshard_info_types.h\n@@ -3345,7 +3345,7 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {\n         TSerializedTableRange Range;\n         TString LastKeyAck;\n         ui64 SeqNoRound = 0;\n-        size_t Index = 0;  // size of Shards map before this element was added\n+        size_t Index = 0; // used only in prefixed vector index: a unique number of shard in the list\n \n         NKikimrIndexBuilder::EBuildStatus Status = NKikimrIndexBuilder::EBuildStatus::INVALID;\n \n@@ -3354,7 +3354,7 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {\n \n         TBillingStats Processed;\n \n-        TShardStatus(TSerializedTableRange range, TString lastKeyAck, size_t shardsCount);\n+        TShardStatus(TSerializedTableRange range, TString lastKeyAck);\n \n         TString ToString(TShardIdx shardIdx = InvalidShardIdx) const {\n             TStringBuilder result;\n@@ -3698,7 +3698,7 @@ struct TIndexBuildInfo: public TSimpleRefCount<TIndexBuildInfo> {\n             AddParent(bound, shardIdx);\n         }\n         Shards.emplace(\n-            shardIdx, TIndexBuildInfo::TShardStatus(std::move(bound), std::move(lastKeyAck), Shards.size()));\n+            shardIdx, TIndexBuildInfo::TShardStatus(std::move(bound), std::move(lastKeyAck)));\n         TIndexBuildInfo::TShardStatus &shardStatus = Shards.at(shardIdx);\n \n         shardStatus.Status =\ndiff --git a/ydb/core/tx/schemeshard/ut_helpers/helpers.cpp b/ydb/core/tx/schemeshard/ut_helpers/helpers.cpp\nindex dc5826a9accb..542099b6b6f8 100644\n--- a/ydb/core/tx/schemeshard/ut_helpers/helpers.cpp\n+++ b/ydb/core/tx/schemeshard/ut_helpers/helpers.cpp\n@@ -1837,10 +1837,10 @@ namespace NSchemeShardUT_Private {\n     }\n \n     void AsyncBuildVectorIndex(TTestActorRuntime& runtime, ui64 id, ui64 schemeShard, const TString &dbName,\n-                              const TString &src, const TString &name, TString column, TVector<TString> dataColumns)\n+                              const TString &src, const TString &name, TVector<TString> columns, TVector<TString> dataColumns)\n     {\n         AsyncBuildIndex(runtime, id, schemeShard, dbName, src, TBuildIndexConfig{\n-            name, NKikimrSchemeOp::EIndexTypeGlobalVectorKmeansTree, {column}, std::move(dataColumns)\n+            name, NKikimrSchemeOp::EIndexTypeGlobalVectorKmeansTree, columns, std::move(dataColumns)\n         });\n     }\n \n@@ -2707,7 +2707,8 @@ namespace NSchemeShardUT_Private {\n         return CountRows(runtime, TTestTxConfig::SchemeShard, table);\n     }\n \n-    void WriteVectorTableRows(TTestActorRuntime& runtime, ui64 schemeShardId, ui64 txId, const TString & tablePath, bool withValue, ui32 shard, ui32 min, ui32 max) {\n+    void WriteVectorTableRows(TTestActorRuntime& runtime, ui64 schemeShardId, ui64 txId, const TString & tablePath,\n+        ui32 shard, ui32 min, ui32 max, std::vector<ui32> columnIds) {\n         TVector<TCell> cells;\n         ui8 str[6] = { 0 };\n         str[4] = (ui8)Ydb::Table::VectorIndexSettings::VECTOR_TYPE_UINT8;\n@@ -2718,16 +2719,15 @@ namespace NSchemeShardUT_Private {\n             str[3] = ((key+106)*47) % 256;\n             cells.emplace_back(TCell::Make(key));\n             cells.emplace_back(TCell((const char*)str, 5));\n-            if (withValue) {\n-                // optionally use the same value for an additional covered string column\n-                cells.emplace_back(TCell((const char*)str, 5));\n-            }\n+            // optional prefix ui32 column\n+            cells.emplace_back(TCell::Make(key % 17));\n+            // optionally use the same value for an additional covered string column\n+            cells.emplace_back(TCell((const char*)str, 5));\n         }\n-        std::vector<ui32> columnIds{1, 2};\n-        if (withValue) {\n-            columnIds.push_back(3);\n+        if (!columnIds.size()) {\n+            columnIds = {1, 2, 3, 4};\n         }\n-        TSerializedCellMatrix matrix(cells, max-min, withValue ? 3 : 2);\n+        TSerializedCellMatrix matrix(cells, max-min, columnIds.size());\n         WriteOp(runtime, schemeShardId, txId, tablePath,\n             shard, NKikimrDataEvents::TEvWrite::TOperation::OPERATION_UPSERT,\n             columnIds, std::move(matrix), true);\ndiff --git a/ydb/core/tx/schemeshard/ut_helpers/helpers.h b/ydb/core/tx/schemeshard/ut_helpers/helpers.h\nindex b51430cdb40c..1e31fe9d8358 100644\n--- a/ydb/core/tx/schemeshard/ut_helpers/helpers.h\n+++ b/ydb/core/tx/schemeshard/ut_helpers/helpers.h\n@@ -397,7 +397,7 @@ namespace NSchemeShardUT_Private {\n     void AsyncBuildColumn(TTestActorRuntime& runtime, ui64 id, ui64 schemeShard, const TString &dbName, const TString &src, const TString& columnName, const Ydb::TypedValue& literal);\n     void AsyncBuildIndex(TTestActorRuntime& runtime, ui64 id, ui64 schemeShard, const TString &dbName, const TString &src, const TBuildIndexConfig &cfg);\n     void AsyncBuildIndex(TTestActorRuntime& runtime, ui64 id, ui64 schemeShard, const TString &dbName, const TString &src, const TString &name, TVector<TString> columns, TVector<TString> dataColumns = {});\n-    void AsyncBuildVectorIndex(TTestActorRuntime& runtime, ui64 id, ui64 schemeShard, const TString &dbName, const TString &src, const TString &name, TString column, TVector<TString> dataColumns = {});\n+    void AsyncBuildVectorIndex(TTestActorRuntime& runtime, ui64 id, ui64 schemeShard, const TString &dbName, const TString &src, const TString &name, TVector<TString> columns, TVector<TString> dataColumns = {});\n     void TestBuildColumn(TTestActorRuntime& runtime, ui64 id, ui64 schemeShard, const TString &dbName,\n         const TString &src, const TString& columnName, const Ydb::TypedValue& literal, Ydb::StatusIds::StatusCode expectedStatus);\n     void TestBuildIndex(TTestActorRuntime& runtime, ui64 id, ui64 schemeShard, const TString &dbName, const TString &src, const TBuildIndexConfig &cfg, Ydb::StatusIds::StatusCode expectedStatus = Ydb::StatusIds::SUCCESS);\n@@ -662,8 +662,8 @@ namespace NSchemeShardUT_Private {\n     ui32 CountRows(TTestActorRuntime& runtime, const TString& table);\n \n     void WriteVectorTableRows(TTestActorRuntime& runtime, ui64 schemeShardId, ui64 txId, const TString & tablePath,\n-        bool withValue, ui32 shard, ui32 min, ui32 max);\n-    \n+        ui32 shard, ui32 min, ui32 max, std::vector<ui32> columnIds = {});\n+\n     void TestCreateServerLessDb(TTestActorRuntime& runtime, TTestEnv& env, ui64& txId, ui64& tenantSchemeShard);\n \n } //NSchemeShardUT_Private\ndiff --git a/ydb/core/tx/schemeshard/ut_index_build/ut_vector_index_build.cpp b/ydb/core/tx/schemeshard/ut_index_build/ut_vector_index_build.cpp\nindex c6339d1e7bf6..3175679c413a 100644\n--- a/ydb/core/tx/schemeshard/ut_index_build/ut_vector_index_build.cpp\n+++ b/ydb/core/tx/schemeshard/ut_index_build/ut_vector_index_build.cpp\n@@ -15,8 +15,7 @@ using namespace NSchemeShard;\n using namespace NSchemeShardUT_Private;\n \n Y_UNIT_TEST_SUITE (VectorIndexBuildTest) {\n-    // TODO: this is awful why do we check everything here\n-    Y_UNIT_TEST(PleaseSplitMeOnMultipleTestsAndDoNotUseServerless) {\n+    Y_UNIT_TEST(CreateAndDrop) {\n         TTestBasicRuntime runtime;\n         TTestEnv env(runtime);\n         ui64 txId = 100;\n@@ -27,11 +26,115 @@ Y_UNIT_TEST_SUITE (VectorIndexBuildTest) {\n         ui64 tenantSchemeShard = 0;\n         TestCreateServerLessDb(runtime, env, txId, tenantSchemeShard);\n \n-        // Just create main table\n         TestCreateTable(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB\", R\"(\n             Name: \"Table\"\n             Columns { Name: \"key\"       Type: \"Uint32\" }\n             Columns { Name: \"embedding\" Type: \"String\" }\n+            Columns { Name: \"prefix\"    Type: \"Uint32\" }\n+            Columns { Name: \"value\"     Type: \"String\" }\n+            KeyColumnNames: [\"key\"]\n+        )\");\n+        env.TestWaitNotification(runtime, txId, tenantSchemeShard);\n+\n+        // Write data directly into shards\n+        WriteVectorTableRows(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB/Table\", 0, 0, 200);\n+\n+        TestDescribeResult(DescribePath(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB/Table\"),\n+            {NLs::PathExist, NLs::IndexesCount(0), NLs::PathVersionEqual(3)});\n+\n+        ui64 buildIndexTx = ++txId;\n+        TestBuildVectorIndex(runtime, buildIndexTx, tenantSchemeShard, \"/MyRoot/ServerLessDB\", \"/MyRoot/ServerLessDB/Table\", \"index1\", \"embedding\");\n+        env.TestWaitNotification(runtime, buildIndexTx, tenantSchemeShard);\n+\n+        auto buildIndexOperations = TestListBuildIndex(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB\");\n+        UNIT_ASSERT_VALUES_EQUAL(buildIndexOperations.EntriesSize(), 1);\n+\n+        auto buildIndexOperation = TestGetBuildIndex(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB\", buildIndexTx);\n+        UNIT_ASSERT_VALUES_EQUAL(buildIndexOperation.GetIndexBuild().GetState(), Ydb::Table::IndexBuildState::STATE_DONE);\n+\n+        TestDescribeResult(DescribePath(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB/Table\"),\n+            {NLs::PathExist, NLs::IndexesCount(1), NLs::PathVersionEqual(6)});\n+\n+        TestDescribeResult(DescribePath(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB/Table/index1\", true, true, true),\n+            {NLs::PathExist, NLs::IndexState(NKikimrSchemeOp::EIndexState::EIndexStateReady)});\n+\n+        TestForgetBuildIndex(runtime, ++txId, tenantSchemeShard, \"/MyRoot/ServerLessDB\", buildIndexTx);\n+        buildIndexOperations = TestListBuildIndex(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB\");\n+        UNIT_ASSERT_VALUES_EQUAL(buildIndexOperations.EntriesSize(), 0);\n+\n+        TestDropTableIndex(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB\", R\"(\n+            TableName: \"Table\"\n+            IndexName: \"index1\"\n+        )\");\n+        env.TestWaitNotification(runtime, txId, tenantSchemeShard);\n+\n+        Cerr << \"... rebooting scheme shard\" << Endl;\n+        RebootTablet(runtime, tenantSchemeShard, runtime.AllocateEdgeActor());\n+\n+        TestDescribeResult(DescribePath(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB/Table\"),\n+            {NLs::PathExist, NLs::IndexesCount(0), NLs::PathVersionEqual(8)});\n+    }\n+\n+    Y_UNIT_TEST(RecreatedColumns) {\n+        TTestBasicRuntime runtime;\n+        TTestEnv env(runtime);\n+        ui64 txId = 100;\n+\n+        runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_TRACE);\n+        runtime.SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_TRACE);\n+\n+        ui64 tenantSchemeShard = 0;\n+        TestCreateServerLessDb(runtime, env, txId, tenantSchemeShard);\n+\n+        TestCreateTable(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB\", R\"(\n+            Name: \"Table\"\n+            Columns { Name: \"key\"       Type: \"Uint32\" }\n+            Columns { Name: \"embedding\" Type: \"String\" }\n+            Columns { Name: \"prefix\"    Type: \"Uint32\" }\n+            Columns { Name: \"value\"     Type: \"String\" }\n+            KeyColumnNames: [\"key\"]\n+        )\");\n+        env.TestWaitNotification(runtime, txId, tenantSchemeShard);\n+\n+        // Test that index build succeeds on recreated columns\n+        TestAlterTable(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB\", R\"(\n+            Name: \"Table\"\n+            DropColumns { Name: \"embedding\" }\n+        )\");\n+        env.TestWaitNotification(runtime, txId, tenantSchemeShard);\n+\n+        TestAlterTable(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB\", R\"(\n+            Name: \"Table\"\n+            Columns { Name: \"embedding\"   Type: \"String\" }\n+        )\");\n+        env.TestWaitNotification(runtime, txId, tenantSchemeShard);\n+\n+        WriteVectorTableRows(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB/Table\", 0, 0, 200, {1, 5, 3, 4});\n+\n+        TestBuildVectorIndex(runtime, ++txId, tenantSchemeShard, \"/MyRoot/ServerLessDB\", \"/MyRoot/ServerLessDB/Table\", \"index2\", \"embedding\");\n+        env.TestWaitNotification(runtime, txId, tenantSchemeShard);\n+\n+        TestDescribeResult(DescribePath(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB/Table\"),\n+            {NLs::PathExist, NLs::IndexesCount(1), NLs::PathVersionEqual(8)});\n+    }\n+\n+    Y_UNIT_TEST(SimpleDuplicates) {\n+        TTestBasicRuntime runtime;\n+        TTestEnv env(runtime);\n+        ui64 txId = 100;\n+\n+        runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_TRACE);\n+        runtime.SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_TRACE);\n+\n+        ui64 tenantSchemeShard = 0;\n+        TestCreateServerLessDb(runtime, env, txId, tenantSchemeShard);\n+\n+        TestCreateTable(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB\", R\"(\n+            Name: \"Table\"\n+            Columns { Name: \"key\"       Type: \"Uint32\" }\n+            Columns { Name: \"embedding\" Type: \"String\" }\n+            Columns { Name: \"prefix\"    Type: \"Uint32\" }\n+            Columns { Name: \"value\"     Type: \"String\" }\n             KeyColumnNames: [\"key\"]\n             SplitBoundary { KeyPrefix { Tuple { Optional { Uint32: 50 } } } }\n             SplitBoundary { KeyPrefix { Tuple { Optional { Uint32: 150 } } } }\n@@ -39,21 +142,19 @@ Y_UNIT_TEST_SUITE (VectorIndexBuildTest) {\n         env.TestWaitNotification(runtime, txId, tenantSchemeShard);\n \n         // Write data directly into shards\n-        WriteVectorTableRows(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB/Table\", false, 0, 0, 50);\n-        WriteVectorTableRows(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB/Table\", false, 1, 50, 150);\n-        WriteVectorTableRows(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB/Table\", false, 2, 150, 200);\n+        WriteVectorTableRows(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB/Table\", 0, 0, 50);\n+        WriteVectorTableRows(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB/Table\", 1, 50, 150);\n+        WriteVectorTableRows(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB/Table\", 2, 150, 200);\n \n         TestDescribeResult(DescribePath(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB/Table\"),\n-                           {NLs::PathExist,\n-                            NLs::IndexesCount(0),\n-                            NLs::PathVersionEqual(3)});\n+            {NLs::PathExist, NLs::IndexesCount(0), NLs::PathVersionEqual(3)});\n \n         TBlockEvents<TEvDataShard::TEvReshuffleKMeansRequest> reshuffleBlocker(runtime, [&](const auto& ) {\n             return true;\n         });\n \n         ui64 buildIndexTx = ++txId;\n-        AsyncBuildVectorIndex(runtime, buildIndexTx, tenantSchemeShard, \"/MyRoot/ServerLessDB\", \"/MyRoot/ServerLessDB/Table\", \"index1\", \"embedding\");\n+        AsyncBuildVectorIndex(runtime, buildIndexTx, tenantSchemeShard, \"/MyRoot/ServerLessDB\", \"/MyRoot/ServerLessDB/Table\", \"index1\", {\"embedding\"});\n \n         // Wait for the first \"reshuffle\" request (samples will be already collected on the first level)\n         // and reboot the scheme shard to verify that its intermediate state is persisted correctly.\n@@ -96,21 +197,9 @@ Y_UNIT_TEST_SUITE (VectorIndexBuildTest) {\n         level1Blocker.Stop().Unblock();\n \n         // Now wait for the index build\n-        {\n-            auto expectedStatus = Ydb::StatusIds::SUCCESS;\n-            TAutoPtr<IEventHandle> handle;\n-            TEvIndexBuilder::TEvCreateResponse* event = runtime.GrabEdgeEvent<TEvIndexBuilder::TEvCreateResponse>(handle);\n-            UNIT_ASSERT(event);\n-\n-            Cerr << \"BUILDINDEX RESPONSE CREATE: \" << event->ToString() << Endl;\n-            UNIT_ASSERT_EQUAL_C(event->Record.GetStatus(), expectedStatus,\n-                                \"status mismatch\"\n-                                    << \" got \" << Ydb::StatusIds::StatusCode_Name(event->Record.GetStatus())\n-                                    << \" expected \"  << Ydb::StatusIds::StatusCode_Name(expectedStatus)\n-                                    << \" issues was \" << event->Record.GetIssues());\n-        }\n-\n         env.TestWaitNotification(runtime, buildIndexTx, tenantSchemeShard);\n+        TestDescribeResult(DescribePath(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB/Table\"),\n+            {NLs::PathExist, NLs::IndexesCount(1), NLs::PathVersionEqual(6)});\n \n         // Check row count in the posting table\n         {\n@@ -118,56 +207,115 @@ Y_UNIT_TEST_SUITE (VectorIndexBuildTest) {\n             Cerr << \"... posting table contains \" << rows << \" rows\" << Endl;\n             UNIT_ASSERT_VALUES_EQUAL(rows, 200);\n         }\n+    }\n \n-        auto buildIndexOperations = TestListBuildIndex(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB\");\n-        UNIT_ASSERT_VALUES_EQUAL(buildIndexOperations.EntriesSize(), 1);\n-\n-        auto buildIndexOperation = TestGetBuildIndex(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB\", buildIndexTx);\n-        UNIT_ASSERT_VALUES_EQUAL(buildIndexOperation.GetIndexBuild().GetState(), Ydb::Table::IndexBuildState::STATE_DONE);\n-\n-        TestDescribeResult(DescribePath(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB/Table\"),\n-                           {NLs::PathExist,\n-                            NLs::IndexesCount(1),\n-                            NLs::PathVersionEqual(6)});\n+    Y_UNIT_TEST(PrefixedDuplicates) {\n+        TTestBasicRuntime runtime;\n+        TTestEnv env(runtime);\n+        ui64 txId = 100;\n \n-        TestDescribeResult(DescribePath(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB/Table/index1\", true, true, true),\n-                           {NLs::PathExist,\n-                            NLs::IndexState(NKikimrSchemeOp::EIndexState::EIndexStateReady)});\n+        runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_TRACE);\n+        runtime.SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_TRACE);\n \n-        TestForgetBuildIndex(runtime, ++txId, tenantSchemeShard, \"/MyRoot/ServerLessDB\", buildIndexTx);\n-        buildIndexOperations = TestListBuildIndex(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB\");\n-        UNIT_ASSERT_VALUES_EQUAL(buildIndexOperations.EntriesSize(), 0);\n+        ui64 tenantSchemeShard = 0;\n+        TestCreateServerLessDb(runtime, env, txId, tenantSchemeShard);\n \n-        TestDropTableIndex(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB\", R\"(\n-            TableName: \"Table\"\n-            IndexName: \"index1\"\n+        // Just create main table\n+        TestCreateTable(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB\", R\"(\n+            Name: \"Table\"\n+            Columns { Name: \"key\"       Type: \"Uint32\" }\n+            Columns { Name: \"embedding\" Type: \"String\" }\n+            Columns { Name: \"prefix\"    Type: \"Uint32\" }\n+            Columns { Name: \"value\"     Type: \"String\" }\n+            KeyColumnNames: [\"key\"]\n+            SplitBoundary { KeyPrefix { Tuple { Optional { Uint32: 50 } } } }\n+            SplitBoundary { KeyPrefix { Tuple { Optional { Uint32: 150 } } } }\n         )\");\n         env.TestWaitNotification(runtime, txId, tenantSchemeShard);\n \n-        Cerr << \"... rebooting scheme shard\" << Endl;\n-        RebootTablet(runtime, tenantSchemeShard, runtime.AllocateEdgeActor());\n+        // Write data directly into shards\n+        WriteVectorTableRows(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB/Table\", 0, 0, 50);\n+        WriteVectorTableRows(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB/Table\", 1, 50, 150);\n+        WriteVectorTableRows(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB/Table\", 2, 150, 200);\n+\n+        runtime.SetLogPriority(NKikimrServices::TX_DATASHARD, NLog::PRI_TRACE);\n+        runtime.SetLogPriority(NKikimrServices::BUILD_INDEX, NLog::PRI_TRACE);\n \n         TestDescribeResult(DescribePath(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB/Table\"),\n-                           {NLs::PathExist,\n-                            NLs::IndexesCount(0),\n-                            NLs::PathVersionEqual(8)});\n+            {NLs::PathExist, NLs::IndexesCount(0), NLs::PathVersionEqual(3)});\n \n-        // Test that index build succeeds on recreated columns\n+        TBlockEvents<TEvSchemeShard::TEvModifySchemeTransaction> lockBlocker(runtime, [&](const auto& ev) {\n+            const auto& tx = ev->Get()->Record.GetTransaction(0);\n+            if (tx.GetOperationType() == NKikimrSchemeOp::ESchemeOpCreateLock &&\n+                tx.GetLockConfig().GetName() == \"indexImplPostingTable0build\") {\n+                return true;\n+            }\n+            return false;\n+        });\n \n-        TestAlterTable(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB\", R\"(\n-              Name: \"Table\"\n-              DropColumns { Name: \"embedding\" }\n-        )\");\n-        env.TestWaitNotification(runtime, txId, tenantSchemeShard);\n+        // Build vector index with max_shards_in_flight > 1 to guarantee double upload of the same shard\n+        const ui64 buildIndexId = ++txId;\n+        AsyncBuildVectorIndex(runtime, buildIndexId, tenantSchemeShard, \"/MyRoot/ServerLessDB\", \"/MyRoot/ServerLessDB/Table\", \"index1\", {\"prefix\", \"embedding\"});\n \n-        TestAlterTable(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB\", R\"(\n-              Name: \"Table\"\n-              Columns { Name: \"embedding\"   Type: \"String\" }\n-        )\");\n-        env.TestWaitNotification(runtime, txId, tenantSchemeShard);\n+        // Wait for the \"lock\" request\n+        runtime.WaitFor(\"LockBuildRequest\", [&]{ return lockBlocker.size(); });\n+        lockBlocker.Stop();\n \n-        TestBuildVectorIndex(runtime, ++txId, tenantSchemeShard, \"/MyRoot/ServerLessDB\", \"/MyRoot/ServerLessDB/Table\", \"index2\", \"embedding\");\n-        env.TestWaitNotification(runtime, txId, tenantSchemeShard);\n+        // Reshard the first level secondary-index-like prefix table (0build)\n+        // Force out-of-order shard indexes (1, 3, 2)\n+        {\n+            auto indexDesc = DescribePath(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB/Table/index1/indexImplPostingTable0build\", true, true, true);\n+            auto parts = indexDesc.GetPathDescription().GetTablePartitions();\n+            UNIT_ASSERT_EQUAL(parts.size(), 1);\n+            TestSplitTable(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB/Table/index1/indexImplPostingTable0build\", Sprintf(R\"(\n+                SourceTabletId: %lu\n+                SplitBoundary { KeyPrefix { Tuple { Optional { Uint32: 10 } } Tuple { Optional { Uint32: 100 } } } }\n+            )\", parts[0].GetDatashardId()));\n+            env.TestWaitNotification(runtime, txId, tenantSchemeShard);\n+        }\n+        {\n+            auto indexDesc = DescribePath(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB/Table/index1/indexImplPostingTable0build\", true, true, true);\n+            auto parts = indexDesc.GetPathDescription().GetTablePartitions();\n+            UNIT_ASSERT_EQUAL(parts.size(), 2);\n+            TestSplitTable(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB/Table/index1/indexImplPostingTable0build\", Sprintf(R\"(\n+                SourceTabletId: %lu\n+                SplitBoundary { KeyPrefix { Tuple { Optional { Uint32: 5 } } Tuple { Optional { Uint32: 100 } } } }\n+            )\", parts[0].GetDatashardId()));\n+            env.TestWaitNotification(runtime, txId, tenantSchemeShard);\n+        }\n+\n+        int prefixSeen = 0;\n+        TBlockEvents<TEvDataShard::TEvPrefixKMeansRequest> prefixBlocker(runtime, [&](const auto& ) {\n+            return (++prefixSeen) == 2;\n+        });\n+        TBlockEvents<TEvDataShard::TEvPrefixKMeansResponse> prefixResponseBlocker(runtime, [&](const auto& ) {\n+            return true;\n+        });\n+\n+        lockBlocker.Unblock(lockBlocker.size());\n+\n+        // Wait for the first scan to finish to prevent it from aborting on split\n+        // Wait for the second PrefixKMeansRequest and reboot the scheme shard\n+        runtime.WaitFor(\"Second PrefixKMeansRequest\", [&]{ return prefixBlocker.size() && prefixResponseBlocker.size(); });\n+        Cerr << \"... rebooting scheme shard\" << Endl;\n+        RebootTablet(runtime, tenantSchemeShard, runtime.AllocateEdgeActor());\n+\n+        prefixResponseBlocker.Stop();\n+        prefixResponseBlocker.Unblock(prefixResponseBlocker.size());\n+        prefixBlocker.Stop();\n+        prefixBlocker.Unblock(prefixBlocker.size());\n+\n+        // Now wait for the index build\n+        env.TestWaitNotification(runtime, buildIndexId, tenantSchemeShard);\n+        TestDescribeResult(DescribePath(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB/Table\"),\n+            {NLs::PathExist, NLs::IndexesCount(1), NLs::PathVersionEqual(6)});\n+\n+        // Check row count in the posting table\n+        {\n+            auto rows = CountRows(runtime, tenantSchemeShard, \"/MyRoot/ServerLessDB/Table/index1/indexImplPostingTable\");\n+            Cerr << \"... posting table contains \" << rows << \" rows\" << Endl;\n+            UNIT_ASSERT_VALUES_EQUAL(rows, 200);\n+        }\n     }\n \n     Y_UNIT_TEST(CommonDB) {\n@@ -204,11 +352,13 @@ Y_UNIT_TEST_SUITE (VectorIndexBuildTest) {\n             Name: \"Table\"\n             Columns { Name: \"key\"       Type: \"Uint32\" }\n             Columns { Name: \"embedding\" Type: \"String\" }\n+            Columns { Name: \"prefix\"    Type: \"Uint32\" }\n+            Columns { Name: \"value\"     Type: \"String\" }\n             KeyColumnNames: [\"key\"]\n         )\");\n         env.TestWaitNotification(runtime, txId, tenantSchemeShard);\n \n-        WriteVectorTableRows(runtime, tenantSchemeShard, ++txId, \"/MyRoot/CommonDB/Table\", false, 0, 100, 300);\n+        WriteVectorTableRows(runtime, tenantSchemeShard, ++txId, \"/MyRoot/CommonDB/Table\", 0, 100, 300);\n \n         TestDescribeResult(DescribePath(runtime, tenantSchemeShard, \"/MyRoot/CommonDB/Table\"), {\n             NLs::PathExist,\n@@ -291,6 +441,8 @@ Y_UNIT_TEST_SUITE (VectorIndexBuildTest) {\n             Name: \"Table\"\n             Columns { Name: \"key\"       Type: \"Uint32\" }\n             Columns { Name: \"embedding\" Type: \"String\" }\n+            Columns { Name: \"prefix\"    Type: \"Uint32\" }\n+            Columns { Name: \"value\"     Type: \"String\" }\n             KeyColumnNames: [\"key\"]\n             SplitBoundary { KeyPrefix { Tuple { Optional { Uint32: 50 } } } }\n             SplitBoundary { KeyPrefix { Tuple { Optional { Uint32: 150 } } } }\n@@ -298,9 +450,9 @@ Y_UNIT_TEST_SUITE (VectorIndexBuildTest) {\n         env.TestWaitNotification(runtime, txId, tenantSchemeShard);\n \n         // Write data directly into shards\n-        WriteVectorTableRows(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB/Table\", false, 0, 0, 50);\n-        WriteVectorTableRows(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB/Table\", false, 1, 50, 150);\n-        WriteVectorTableRows(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB/Table\", false, 2, 150, 200);\n+        WriteVectorTableRows(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB/Table\", 0, 0, 50);\n+        WriteVectorTableRows(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB/Table\", 1, 50, 150);\n+        WriteVectorTableRows(runtime, tenantSchemeShard, ++txId, \"/MyRoot/ServerLessDB/Table\", 2, 150, 200);\n \n         TBlockEvents<NMetering::TEvMetering::TEvWriteMeteringJson> meteringBlocker(runtime, [&](const auto& ev) {\n             Cerr << \"TEvWriteMeteringJson \" << ev->Get()->MeteringJson << Endl;\n@@ -623,7 +775,7 @@ Y_UNIT_TEST_SUITE (VectorIndexBuildTest) {\n         });\n \n         const ui64 buildIndexTx = ++txId;\n-        AsyncBuildVectorIndex(runtime, buildIndexTx, TTestTxConfig::SchemeShard, \"/MyRoot\", \"/MyRoot/vectors\", \"index1\", \"embedding\");\n+        AsyncBuildVectorIndex(runtime, buildIndexTx, TTestTxConfig::SchemeShard, \"/MyRoot\", \"/MyRoot/vectors\", \"index1\", {\"embedding\"});\n \n         runtime.WaitFor(\"block\", [&]{ return blocked.size(); });\n         blocked.Stop().Unblock();\n@@ -687,7 +839,7 @@ Y_UNIT_TEST_SUITE (VectorIndexBuildTest) {\n         }\n \n         const ui64 buildIndexTx = ++txId;\n-        AsyncBuildVectorIndex(runtime, buildIndexTx, TTestTxConfig::SchemeShard, \"/MyRoot\", \"/MyRoot/vectors\", \"index1\", \"embedding\");\n+        AsyncBuildVectorIndex(runtime, buildIndexTx, TTestTxConfig::SchemeShard, \"/MyRoot\", \"/MyRoot/vectors\", \"index1\", {\"embedding\"});\n \n         env.TestWaitNotification(runtime, buildIndexTx);\n \n@@ -848,7 +1000,7 @@ Y_UNIT_TEST_SUITE (VectorIndexBuildTest) {\n         });\n \n         const ui64 buildIndexTx = ++txId;\n-        AsyncBuildVectorIndex(runtime, buildIndexTx, TTestTxConfig::SchemeShard, \"/MyRoot\", \"/MyRoot/vectors\", \"index1\", \"embedding\");\n+        AsyncBuildVectorIndex(runtime, buildIndexTx, TTestTxConfig::SchemeShard, \"/MyRoot\", \"/MyRoot/vectors\", \"index1\", {\"embedding\"});\n \n         runtime.WaitFor(\"block\", [&]{ return blocked.size(); });\n         blocked.Stop().Unblock();\ndiff --git a/ydb/core/tx/schemeshard/ut_vector_index_build_reboots/ut_vector_index_build_reboots.cpp b/ydb/core/tx/schemeshard/ut_vector_index_build_reboots/ut_vector_index_build_reboots.cpp\nindex f6fe3e333f53..22818569a324 100644\n--- a/ydb/core/tx/schemeshard/ut_vector_index_build_reboots/ut_vector_index_build_reboots.cpp\n+++ b/ydb/core/tx/schemeshard/ut_vector_index_build_reboots/ut_vector_index_build_reboots.cpp\n@@ -1,3 +1,4 @@\n+#include <ydb/core/tx/scheme_board/events_schemeshard.h>\n #include <ydb/core/tx/schemeshard/ut_helpers/helpers.h>\n #include <ydb/core/tx/schemeshard/ut_helpers/test_with_reboots.h>\n \n@@ -9,11 +10,24 @@ using namespace NSchemeShardUT_Private;\n \n \n Y_UNIT_TEST_SUITE(VectorIndexBuildTestReboots) {\n-    Y_UNIT_TEST_WITH_REBOOTS(BaseCase) {\n+    Y_UNIT_TEST_WITH_REBOOTS_FLAG(BaseCase, Prefixed) {\n         // Without killOnCommit, the schemeshard doesn't get rebooted on TEvDataShard::Ev***KMeansResponse's,\n         // and thus the vector index build process is never interrupted at all because there are no other\n         // events to reboot on.\n         T t(true /*killOnCommit*/);\n+        // speed up the test:\n+        // only check scheme shard reboots\n+        t.TabletIds.clear();\n+        t.TabletIds.push_back(t.SchemeShardTabletId);\n+        // white list some more events\n+        t.NoRebootEventTypes.insert(TEvSchemeShard::EvModifySchemeTransaction);\n+        t.NoRebootEventTypes.insert(TSchemeBoardEvents::EvUpdateAck);\n+        t.NoRebootEventTypes.insert(TEvSchemeShard::EvNotifyTxCompletionRegistered);\n+        t.NoRebootEventTypes.insert(TEvTabletPipe::EvServerDisconnected);\n+        t.NoRebootEventTypes.insert(TEvTabletPipe::EvServerConnected);\n+        t.NoRebootEventTypes.insert(TEvTabletPipe::EvClientConnected);\n+        t.NoRebootEventTypes.insert(TEvTabletPipe::EvClientDestroyed);\n+        t.NoRebootEventTypes.insert(TEvDataShard::EvBuildIndexProgressResponse);\n         t.Run([&](TTestActorRuntime& runtime, bool& activeZone) {\n             {\n                 TInactiveZone inactive(activeZone);\n@@ -22,6 +36,7 @@ Y_UNIT_TEST_SUITE(VectorIndexBuildTestReboots) {\n                     Name: \"dir/Table\"\n                     Columns { Name: \"key\"       Type: \"Uint32\" }\n                     Columns { Name: \"embedding\" Type: \"String\" }\n+                    Columns { Name: \"prefix\"    Type: \"Uint32\" }\n                     Columns { Name: \"value\"     Type: \"String\" }\n                     KeyColumnNames: [\"key\"]\n                     SplitBoundary { KeyPrefix { Tuple { Optional { Uint32: 50 } } } }\n@@ -31,21 +46,24 @@ Y_UNIT_TEST_SUITE(VectorIndexBuildTestReboots) {\n                 )\");\n                 t.TestEnv->TestWaitNotification(runtime, t.TxId);\n \n-                WriteVectorTableRows(runtime, TTestTxConfig::SchemeShard, ++t.TxId, \"/MyRoot/dir/Table\", true, 0, 0, 50);\n-                WriteVectorTableRows(runtime, TTestTxConfig::SchemeShard, ++t.TxId, \"/MyRoot/dir/Table\", true, 1, 50, 150);\n-                WriteVectorTableRows(runtime, TTestTxConfig::SchemeShard, ++t.TxId, \"/MyRoot/dir/Table\", true, 2, 150, 250);\n-                WriteVectorTableRows(runtime, TTestTxConfig::SchemeShard, ++t.TxId, \"/MyRoot/dir/Table\", true, 3, 250, 350);\n-                WriteVectorTableRows(runtime, TTestTxConfig::SchemeShard, ++t.TxId, \"/MyRoot/dir/Table\", true, 4, 350, 400);\n+                WriteVectorTableRows(runtime, TTestTxConfig::SchemeShard, ++t.TxId, \"/MyRoot/dir/Table\", 0, 0, 50);\n+                WriteVectorTableRows(runtime, TTestTxConfig::SchemeShard, ++t.TxId, \"/MyRoot/dir/Table\", 1, 50, 150);\n+                WriteVectorTableRows(runtime, TTestTxConfig::SchemeShard, ++t.TxId, \"/MyRoot/dir/Table\", 2, 150, 250);\n+                WriteVectorTableRows(runtime, TTestTxConfig::SchemeShard, ++t.TxId, \"/MyRoot/dir/Table\", 3, 250, 350);\n+                WriteVectorTableRows(runtime, TTestTxConfig::SchemeShard, ++t.TxId, \"/MyRoot/dir/Table\", 4, 350, 400);\n             }\n \n-            ui64 buildIndexId = ++t.TxId;\n-            auto sender = runtime.AllocateEdgeActor();\n-            auto request = CreateBuildIndexRequest(buildIndexId, \"/MyRoot\", \"/MyRoot/dir/Table\", TBuildIndexConfig{\n-                \"index1\", NKikimrSchemeOp::EIndexTypeGlobalVectorKmeansTree, {\"embedding\"}, {\"value\"}\n-            });\n-            // with too many scan events, the test works infinite time\n-            request->Record.MutableSettings()->MutableScanSettings()->Clear();\n-            ForwardToTablet(runtime, TTestTxConfig::SchemeShard, sender, request);\n+            const ui64 buildIndexId = ++t.TxId;\n+            {\n+                auto indexColumns = (Prefixed ? TVector<TString>{\"prefix\", \"embedding\"} : TVector<TString>{\"embedding\"});\n+                auto sender = runtime.AllocateEdgeActor();\n+                auto request = CreateBuildIndexRequest(buildIndexId, \"/MyRoot\", \"/MyRoot/dir/Table\", TBuildIndexConfig{\n+                    \"index1\", NKikimrSchemeOp::EIndexTypeGlobalVectorKmeansTree, indexColumns, {\"value\"}\n+                });\n+                // with too many scan events, the test works infinite time\n+                request->Record.MutableSettings()->MutableScanSettings()->Clear();\n+                ForwardToTablet(runtime, TTestTxConfig::SchemeShard, sender, request);\n+            }\n \n             {\n                 auto descr = TestGetBuildIndex(runtime, TTestTxConfig::SchemeShard, \"/MyRoot\", buildIndexId);\n@@ -70,18 +88,17 @@ Y_UNIT_TEST_SUITE(VectorIndexBuildTestReboots) {\n                                    {NLs::PathExist,\n                                     NLs::IndexState(NKikimrSchemeOp::EIndexState::EIndexStateReady)});\n                 using namespace NTableIndex::NTableVectorKmeansTreeIndex;\n-                TestDescribeResult(DescribePath(runtime, indexPath + \"/\" + LevelTable, true, true, true),\n-                                   {NLs::PathExist});\n-                TestDescribeResult(DescribePath(runtime, indexPath + \"/\" + PostingTable, true, true, true),\n-                                   {NLs::PathExist});\n-                TestDescribeResult(DescribePath(runtime, indexPath + \"/\" + PostingTable + BuildSuffix0, true, true, true),\n-                                   {NLs::PathNotExist});\n-                TestDescribeResult(DescribePath(runtime, indexPath + \"/\" + PostingTable + BuildSuffix1, true, true, true),\n-                                   {NLs::PathNotExist});\n+                if (Prefixed) {\n+                    TestDescribeResult(DescribePath(runtime, indexPath + \"/\" + PrefixTable, true, true, true), {NLs::PathExist});\n+                }\n+                TestDescribeResult(DescribePath(runtime, indexPath + \"/\" + LevelTable, true, true, true), {NLs::PathExist});\n+                TestDescribeResult(DescribePath(runtime, indexPath + \"/\" + PostingTable, true, true, true), {NLs::PathExist});\n+                TestDescribeResult(DescribePath(runtime, indexPath + \"/\" + PostingTable + BuildSuffix0, true, true, true), {NLs::PathNotExist});\n+                TestDescribeResult(DescribePath(runtime, indexPath + \"/\" + PostingTable + BuildSuffix1, true, true, true), {NLs::PathNotExist});\n \n                 // Check row count in the posting table\n                 {\n-                    auto rows = CountRows(runtime, TTestTxConfig::SchemeShard, \"/MyRoot/dir/Table/index1/indexImplPostingTable\");\n+                    auto rows = CountRows(runtime, TTestTxConfig::SchemeShard, \"/MyRoot/dir/Table/index1/\" + TString(PostingTable));\n                     Cerr << \"... posting table contains \" << rows << \" rows\" << Endl;\n                     UNIT_ASSERT_VALUES_EQUAL(rows, 400);\n                 }\n",
  "test_patch": "diff --git a/ydb/core/tx/schemeshard/ut_helpers/test_env.cpp b/ydb/core/tx/schemeshard/ut_helpers/test_env.cpp\nindex 18ef1be1609d..8875e141e7a5 100644\n--- a/ydb/core/tx/schemeshard/ut_helpers/test_env.cpp\n+++ b/ydb/core/tx/schemeshard/ut_helpers/test_env.cpp\n@@ -1054,6 +1054,22 @@ NSchemeShardUT_Private::TTestWithReboots::TTestWithReboots(bool killOnCommit, NS\n     TabletIds.push_back(datashard+6);\n     TabletIds.push_back(datashard+7);\n     TabletIds.push_back(datashard+8);\n+\n+    NoRebootEventTypes.insert(TEvSchemeShard::EvModifySchemeTransaction);\n+    NoRebootEventTypes.insert(TEvSchemeShard::EvDescribeScheme);\n+    NoRebootEventTypes.insert(TEvSchemeShard::EvNotifyTxCompletion);\n+    NoRebootEventTypes.insert(TEvSchemeShard::EvMeasureSelfResponseTime);\n+    NoRebootEventTypes.insert(TEvSchemeShard::EvWakeupToMeasureSelfResponseTime);\n+    NoRebootEventTypes.insert(TEvTablet::EvLocalMKQL);\n+    NoRebootEventTypes.insert(TEvFakeHive::EvSubscribeToTabletDeletion);\n+    NoRebootEventTypes.insert(TEvSchemeShard::EvCancelTx);\n+    NoRebootEventTypes.insert(TEvExport::EvCreateExportRequest);\n+    NoRebootEventTypes.insert(TEvIndexBuilder::EvCreateRequest);\n+    NoRebootEventTypes.insert(TEvIndexBuilder::EvGetRequest);\n+    NoRebootEventTypes.insert(TEvIndexBuilder::EvCancelRequest);\n+    NoRebootEventTypes.insert(TEvIndexBuilder::EvForgetRequest);\n+    // without it, ut_vector_index_build_reboots test hangs on GetRequest on the very first reboot\n+    NoRebootEventTypes.insert(TEvTablet::EvCommitResult);\n }\n \n void NSchemeShardUT_Private::TTestWithReboots::Run(std::function<void (TTestActorRuntime &, bool &)> testScenario) {\n@@ -1088,9 +1104,10 @@ struct NSchemeShardUT_Private::TTestWithReboots::TFinalizer {\n };\n \n void NSchemeShardUT_Private::TTestWithReboots::RunWithTabletReboots(std::function<void (TTestActorRuntime &, bool &)> testScenario) {\n-    RunTestWithReboots(TabletIds,\n-                       [&]() {\n-        return PassUserRequests;\n+    RunTestWithReboots(TabletIds, [&]() {\n+        return [this](TTestActorRuntimeBase& runtime, TAutoPtr<IEventHandle>& event) {\n+            return PassUserRequests(runtime, event);\n+        };\n     },\n     [&](const TString& dispatchName, std::function<void(TTestActorRuntime&)> setup, bool& activeZone) {\n         TFinalizer finalizer(*this);\n@@ -1104,7 +1121,9 @@ void NSchemeShardUT_Private::TTestWithReboots::RunWithTabletReboots(std::functio\n void NSchemeShardUT_Private::TTestWithReboots::RunWithPipeResets(std::function<void (TTestActorRuntime &, bool &)> testScenario) {\n     RunTestWithPipeResets(TabletIds,\n                           [&]() {\n-        return PassUserRequests;\n+        return [this](TTestActorRuntimeBase& runtime, TAutoPtr<IEventHandle>& event) {\n+            return PassUserRequests(runtime, event);\n+        };\n     },\n     [&](const TString& dispatchName, std::function<void(TTestActorRuntime&)> setup, bool& activeZone) {\n         TFinalizer finalizer(*this);\n@@ -1173,22 +1192,7 @@ void NSchemeShardUT_Private::TTestWithReboots::Finalize() {\n \n bool NSchemeShardUT_Private::TTestWithReboots::PassUserRequests(TTestActorRuntimeBase &runtime, TAutoPtr<IEventHandle> &event) {\n     Y_UNUSED(runtime);\n-    return event->Type == TEvSchemeShard::EvModifySchemeTransaction ||\n-           event->Type == TEvSchemeShard::EvDescribeScheme ||\n-           event->Type == TEvSchemeShard::EvNotifyTxCompletion ||\n-           event->Type == TEvSchemeShard::EvMeasureSelfResponseTime ||\n-           event->Type == TEvSchemeShard::EvWakeupToMeasureSelfResponseTime ||\n-           event->Type == TEvTablet::EvLocalMKQL ||\n-           event->Type == TEvFakeHive::EvSubscribeToTabletDeletion ||\n-           event->Type == TEvSchemeShard::EvCancelTx ||\n-           event->Type == TEvExport::EvCreateExportRequest ||\n-           event->Type == TEvIndexBuilder::EvCreateRequest ||\n-           event->Type == TEvIndexBuilder::EvGetRequest ||\n-           event->Type == TEvIndexBuilder::EvCancelRequest ||\n-           event->Type == TEvIndexBuilder::EvForgetRequest ||\n-           // without it, ut_vector_index_build_reboots test hangs on GetRequest on the very first reboot\n-           event->Type == TEvTablet::EvCommitResult\n-        ;\n+    return NoRebootEventTypes.contains(event->Type);\n }\n \n NSchemeShardUT_Private::TTestEnvOptions& NSchemeShardUT_Private::TTestWithReboots::GetTestEnvOptions() {\ndiff --git a/ydb/core/tx/schemeshard/ut_helpers/test_env.h b/ydb/core/tx/schemeshard/ut_helpers/test_env.h\nindex 94ed674a728c..deb55914977d 100644\n--- a/ydb/core/tx/schemeshard/ut_helpers/test_env.h\n+++ b/ydb/core/tx/schemeshard/ut_helpers/test_env.h\n@@ -171,6 +171,7 @@ namespace NSchemeShardUT_Private {\n \n     public:\n         TVector<ui64> TabletIds;\n+        TSet<ui32> NoRebootEventTypes;\n         THolder<TTestActorRuntime> Runtime;\n         TTestEnvOptions EnvOpts;\n         THolder<TTestEnv> TestEnv;\n@@ -204,7 +205,7 @@ namespace NSchemeShardUT_Private {\n     private:\n         virtual TTestEnv* CreateTestEnv();\n         // Make sure that user requests are not dropped\n-        static bool PassUserRequests(TTestActorRuntimeBase& runtime, TAutoPtr<IEventHandle>& event);\n+        bool PassUserRequests(TTestActorRuntimeBase& runtime, TAutoPtr<IEventHandle>& event);\n \n     private:\n         struct TFinalizer;\ndiff --git a/ydb/core/tx/schemeshard/ut_helpers/test_with_reboots.h b/ydb/core/tx/schemeshard/ut_helpers/test_with_reboots.h\nindex bb802089d2a8..70e09a35b40f 100644\n--- a/ydb/core/tx/schemeshard/ut_helpers/test_with_reboots.h\n+++ b/ydb/core/tx/schemeshard/ut_helpers/test_with_reboots.h\n@@ -38,4 +38,19 @@ class TTestWithPipeResets: public TTestWithReboots {\n     template <typename T>                                   \\\n     void N(NUnitTest::TTestContext&)\n \n+#define Y_UNIT_TEST_WITH_REBOOTS_FLAG(N, OPT)               \\\n+    template <typename T, bool OPT>                         \\\n+    void N(NUnitTest::TTestContext&);                       \\\n+    struct TTestRegistration##N {                           \\\n+        TTestRegistration##N() {                            \\\n+            TCurrentTest::AddTest(#N \"-\" #OPT \"[TabletReboots]\", static_cast<void (*)(NUnitTest::TTestContext&)>(&N<TTestWithTabletReboots, false>), false); \\\n+            TCurrentTest::AddTest(#N \"-\" #OPT \"[PipeResets]\", static_cast<void (*)(NUnitTest::TTestContext&)>(&N<TTestWithPipeResets, false>), false); \\\n+            TCurrentTest::AddTest(#N \"+\" #OPT \"[TabletReboots]\", static_cast<void (*)(NUnitTest::TTestContext&)>(&N<TTestWithTabletReboots, true>), false); \\\n+            TCurrentTest::AddTest(#N \"+\" #OPT \"[PipeResets]\", static_cast<void (*)(NUnitTest::TTestContext&)>(&N<TTestWithPipeResets, true>), false); \\\n+        }                                                   \\\n+    };                                                      \\\n+    static TTestRegistration##N testRegistration##N;        \\\n+    template <typename T, bool OPT>                         \\\n+    void N(NUnitTest::TTestContext&)\n+\n }\n",
  "problem_statement": "Duplicate rows in prefixed vector index tables after node reboots\nWhen cluster nodes are rebooted multiple times during prefixed vector index build, the resuting posting table contains more rows than the input table which means that there are duplicates.\n\nIt seems to begin with the \"posting1build\" table which is built using PrefixKMeansRequests in datashard - it seems to be the first table which contains more rows that needed.\n",
  "hints_text": "",
  "created_at": "2025-06-17T13:20:10Z"
}