{
  "repo": "ydb-platform/ydb",
  "pull_number": 745,
  "instance_id": "ydb-platform__ydb-745",
  "issue_numbers": [
    "711"
  ],
  "base_commit": "74f9996fd8d73c80efe3898402f5d0c847726b32",
  "patch": "diff --git a/.gitignore b/.gitignore\nindex 9f73be657f2c..e5d1f13253e4 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -21,6 +21,8 @@ __pycache__/\n *_pb2.py\n *_pb2_grpc.py\n *_pb2.pyi\n+*.pb.h\n+*.pb.cc\n \n # MacOS specific\n .DS_Store\ndiff --git a/ydb/core/base/events.h b/ydb/core/base/events.h\nindex 62fbea255dab..d192a702ffc8 100644\n--- a/ydb/core/base/events.h\n+++ b/ydb/core/base/events.h\n@@ -170,6 +170,7 @@ struct TKikimrEvents : TEvents {\n         ES_DB_METADATA_CACHE,\n         ES_TABLE_CREATOR,\n         ES_PQ_PARTITION_CHOOSER,\n+        ES_GRAPH,\n     };\n };\n \ndiff --git a/ydb/core/base/pool_stats_collector.cpp b/ydb/core/base/pool_stats_collector.cpp\nindex e6e1b613a1f2..fe3041d40249 100644\n--- a/ydb/core/base/pool_stats_collector.cpp\n+++ b/ydb/core/base/pool_stats_collector.cpp\n@@ -9,6 +9,9 @@\n #include <ydb/library/actors/core/actor_bootstrapped.h>\n #include <ydb/library/actors/helpers/pool_stats_collector.h>\n \n+#include <ydb/core/graph/api/service.h>\n+#include <ydb/core/graph/api/events.h>\n+\n namespace NKikimr {\n \n // Periodically collects stats from executor threads and exposes them as mon counters\n@@ -44,11 +47,15 @@ class TStatsCollectingActor : public NActors::TStatsCollectingActor {\n         MiniKQLPoolStats.Update();\n \n         TVector<std::tuple<TString, double, ui32>> pools;\n+        double cpuUsage = 0;\n         for (const auto& pool : PoolCounters) {\n             pools.emplace_back(pool.Name, pool.Usage, pool.Threads);\n+            cpuUsage += pool.Usage;\n         }\n \n         ctx.Send(NNodeWhiteboard::MakeNodeWhiteboardServiceId(ctx.SelfID.NodeId()), new NNodeWhiteboard::TEvWhiteboard::TEvSystemStateUpdate(pools));\n+\n+        ctx.Send(NGraph::MakeGraphServiceId(), new NGraph::TEvGraph::TEvSendMetrics(\"cpu_usage\", cpuUsage));\n     }\n \n private:\ndiff --git a/ydb/core/base/ya.make b/ydb/core/base/ya.make\nindex c4520c1375ed..085cf88f37d1 100644\n--- a/ydb/core/base/ya.make\n+++ b/ydb/core/base/ya.make\n@@ -88,6 +88,7 @@ PEERDIR(\n     ydb/core/base/services\n     ydb/core/debug\n     ydb/core/erasure\n+    ydb/core/graph/api\n     ydb/core/protos\n     ydb/core/protos/out\n     ydb/core/scheme\ndiff --git a/ydb/core/cms/console/console_tenants_manager.cpp b/ydb/core/cms/console/console_tenants_manager.cpp\nindex 955e8926f13a..e4982abd3630 100644\n--- a/ydb/core/cms/console/console_tenants_manager.cpp\n+++ b/ydb/core/cms/console/console_tenants_manager.cpp\n@@ -451,6 +451,7 @@ class TSubDomainManip : public TActorBootstrapped<TSubDomainManip> {\n         subdomain.SetName(Subdomain.second);\n         if (Tenant->IsExternalSubdomain) {\n             subdomain.SetExternalSchemeShard(true);\n+            subdomain.SetGraphShard(true);\n             if (Tenant->IsExternalHive) {\n                 subdomain.SetExternalHive(true);\n             }\ndiff --git a/ydb/core/driver_lib/run/config.h b/ydb/core/driver_lib/run/config.h\nindex f71205feccef..01a0c089816b 100644\n--- a/ydb/core/driver_lib/run/config.h\n+++ b/ydb/core/driver_lib/run/config.h\n@@ -83,6 +83,7 @@ union TBasicKikimrServicesMask {\n         // next 64 flags\n \n         bool EnableDatabaseMetadataCache:1;\n+        bool EnableGraphService:1;\n     };\n \n     struct {\ndiff --git a/ydb/core/driver_lib/run/kikimr_services_initializers.cpp b/ydb/core/driver_lib/run/kikimr_services_initializers.cpp\nindex 615589b3bcc9..535c2135f6d2 100644\n--- a/ydb/core/driver_lib/run/kikimr_services_initializers.cpp\n+++ b/ydb/core/driver_lib/run/kikimr_services_initializers.cpp\n@@ -214,6 +214,9 @@\n #include <ydb/library/actors/util/affinity.h>\n #include <ydb/library/actors/wilson/wilson_uploader.h>\n \n+#include <ydb/core/graph/api/service.h>\n+#include <ydb/core/graph/api/shard.h>\n+\n #include <library/cpp/logger/global/global.h>\n #include <library/cpp/logger/log.h>\n \n@@ -1022,7 +1025,7 @@ void TLocalServiceInitializer::InitializeServices(\n     addToLocalConfig(TTabletTypes::ReplicationController, &NReplication::CreateController, TMailboxType::ReadAsFilled, appData->UserPoolId);\n     addToLocalConfig(TTabletTypes::BlobDepot, &NBlobDepot::CreateBlobDepot, TMailboxType::ReadAsFilled, appData->UserPoolId);\n     addToLocalConfig(TTabletTypes::StatisticsAggregator, &NStat::CreateStatisticsAggregator, TMailboxType::ReadAsFilled, appData->UserPoolId);\n-\n+    addToLocalConfig(TTabletTypes::GraphShard, &NGraph::CreateGraphShard, TMailboxType::ReadAsFilled, appData->UserPoolId);\n \n     TTenantPoolConfig::TPtr tenantPoolConfig = new TTenantPoolConfig(Config.GetTenantPoolConfig(), localConfig);\n     if (!tenantPoolConfig->IsEnabled && !tenantPoolConfig->StaticSlots.empty())\n@@ -2688,5 +2691,16 @@ void TDatabaseMetadataCacheInitializer::InitializeServices(NActors::TActorSystem\n         TActorSetupCmd(CreateDatabaseMetadataCache(appData->TenantName), TMailboxType::HTSwap, appData->UserPoolId));\n }\n \n+TGraphServiceInitializer::TGraphServiceInitializer(const TKikimrRunConfig& runConfig)\n+    : IKikimrServicesInitializer(runConfig)\n+{\n+}\n+\n+void TGraphServiceInitializer::InitializeServices(NActors::TActorSystemSetup* setup, const NKikimr::TAppData* appData) {\n+    setup->LocalServices.emplace_back(\n+        NGraph::MakeGraphServiceId(),\n+        TActorSetupCmd(NGraph::CreateGraphService(appData->TenantName), TMailboxType::HTSwap, appData->UserPoolId));\n+}\n+\n } // namespace NKikimrServicesInitializers\n } // namespace NKikimr\ndiff --git a/ydb/core/driver_lib/run/kikimr_services_initializers.h b/ydb/core/driver_lib/run/kikimr_services_initializers.h\nindex a15bd6c04080..ffeed3395060 100644\n--- a/ydb/core/driver_lib/run/kikimr_services_initializers.h\n+++ b/ydb/core/driver_lib/run/kikimr_services_initializers.h\n@@ -612,5 +612,13 @@ class TDatabaseMetadataCacheInitializer : public IKikimrServicesInitializer {\n \n     void InitializeServices(NActors::TActorSystemSetup* setup, const NKikimr::TAppData* appData) override;\n };\n+\n+class TGraphServiceInitializer : public IKikimrServicesInitializer {\n+public:\n+    TGraphServiceInitializer(const TKikimrRunConfig& runConfig);\n+\n+    void InitializeServices(NActors::TActorSystemSetup* setup, const NKikimr::TAppData* appData) override;\n+};\n+\n } // namespace NKikimrServicesInitializers\n } // namespace NKikimr\ndiff --git a/ydb/core/driver_lib/run/run.cpp b/ydb/core/driver_lib/run/run.cpp\nindex 66bd3c186d22..ae17b5a6d571 100644\n--- a/ydb/core/driver_lib/run/run.cpp\n+++ b/ydb/core/driver_lib/run/run.cpp\n@@ -1617,6 +1617,10 @@ TIntrusivePtr<TServiceInitializersList> TKikimrRunner::CreateServiceInitializers\n         sil->AddServiceInitializer(new TDatabaseMetadataCacheInitializer(runConfig));\n     }\n \n+    if (serviceMask.EnableGraphService) {\n+        sil->AddServiceInitializer(new TGraphServiceInitializer(runConfig));\n+    }\n+\n     return sil;\n }\n \ndiff --git a/ydb/core/driver_lib/run/ya.make b/ydb/core/driver_lib/run/ya.make\nindex c7699785460b..b6025b7c4e2f 100644\n--- a/ydb/core/driver_lib/run/ya.make\n+++ b/ydb/core/driver_lib/run/ya.make\n@@ -67,6 +67,8 @@ PEERDIR(\n     ydb/core/formats\n     ydb/core/fq/libs/init\n     ydb/core/fq/libs/logs\n+    ydb/core/graph/service\n+    ydb/core/graph/shard\n     ydb/core/grpc_services\n     ydb/core/grpc_services/base\n     ydb/core/grpc_services/auth_processor\ndiff --git a/ydb/core/graph/api/events.h b/ydb/core/graph/api/events.h\nnew file mode 100644\nindex 000000000000..b05350630cf2\n--- /dev/null\n+++ b/ydb/core/graph/api/events.h\n@@ -0,0 +1,48 @@\n+#pragma once\n+\n+#include <ydb/core/base/events.h>\n+#include <ydb/core/graph/protos/graph.pb.h>\n+\n+namespace NKikimr {\n+namespace NGraph {\n+\n+struct TEvGraph {\n+    enum EEv {\n+        // requests\n+        EvSendMetrics = EventSpaceBegin(TKikimrEvents::ES_GRAPH),\n+        EvGetMetrics,\n+        EvMetricsResult,\n+        EvEnd\n+    };\n+\n+    static_assert(EvEnd < EventSpaceEnd(TKikimrEvents::ES_GRAPH), \"expect EvEnd < EventSpaceEnd(TKikimrEvents::ES_GRAPH)\");\n+\n+    struct TEvSendMetrics : TEventPB<TEvSendMetrics, NKikimrGraph::TEvSendMetrics, EvSendMetrics> {\n+        TEvSendMetrics() = default;\n+\n+        TEvSendMetrics(const TString& name, double value) {\n+            NKikimrGraph::TMetric* metric = Record.AddMetrics();\n+            metric->SetName(name);\n+            metric->SetValue(value);\n+        }\n+    };\n+\n+    struct TEvGetMetrics : TEventPB<TEvGetMetrics, NKikimrGraph::TEvGetMetrics, EvGetMetrics> {\n+        TEvGetMetrics() = default;\n+\n+        TEvGetMetrics(const NKikimrGraph::TEvGetMetrics& request)\n+            : TEventPB<TEvGetMetrics, NKikimrGraph::TEvGetMetrics, EvGetMetrics>(request)\n+        {}\n+    };\n+\n+    struct TEvMetricsResult : TEventPB<TEvMetricsResult, NKikimrGraph::TEvMetricsResult, EvMetricsResult> {\n+        TEvMetricsResult() = default;\n+\n+        TEvMetricsResult(NKikimrGraph::TEvMetricsResult&& result)\n+            : TEventPB<TEvMetricsResult, NKikimrGraph::TEvMetricsResult, EvMetricsResult>(std::move(result))\n+        {}\n+    };\n+};\n+\n+} // NGraph\n+} // NKikimr\ndiff --git a/ydb/core/graph/api/service.h b/ydb/core/graph/api/service.h\nnew file mode 100644\nindex 000000000000..88c66eaa8e50\n--- /dev/null\n+++ b/ydb/core/graph/api/service.h\n@@ -0,0 +1,18 @@\n+#pragma once\n+\n+#include <ydb/library/actors/core/actor.h>\n+\n+namespace NKikimr {\n+namespace NGraph {\n+\n+using namespace NActors;\n+\n+inline TActorId MakeGraphServiceId(ui32 node = 0) {\n+    char x[12] = {'g','r','a','p','h','s', 'v', 'c'};\n+    return TActorId(node, TStringBuf(x, 12));\n+}\n+\n+IActor* CreateGraphService(const TString& database);\n+\n+} // NGraph\n+} // NKikimr\ndiff --git a/ydb/core/graph/api/shard.h b/ydb/core/graph/api/shard.h\nnew file mode 100644\nindex 000000000000..bf204ab67a1c\n--- /dev/null\n+++ b/ydb/core/graph/api/shard.h\n@@ -0,0 +1,14 @@\n+#pragma once\n+\n+#include <ydb/library/actors/core/actor.h>\n+#include <ydb/core/base/blobstorage.h>\n+\n+namespace NKikimr {\n+namespace NGraph {\n+\n+using namespace NActors;\n+\n+IActor* CreateGraphShard(const TActorId& tablet, TTabletStorageInfo* info);\n+\n+} // NGraph\n+} // NKikimr\ndiff --git a/ydb/core/graph/api/ya.make b/ydb/core/graph/api/ya.make\nnew file mode 100644\nindex 000000000000..e986b2c92d7c\n--- /dev/null\n+++ b/ydb/core/graph/api/ya.make\n@@ -0,0 +1,18 @@\n+LIBRARY()\n+\n+OWNER(\n+    xenoxeno\n+    g:kikimr\n+)\n+\n+SRCS(\n+    events.h\n+    service.h\n+    shard.h\n+)\n+\n+PEERDIR(\n+    ydb/core/graph/protos\n+)\n+\n+END()\ndiff --git a/ydb/core/graph/protos/graph.proto b/ydb/core/graph/protos/graph.proto\nnew file mode 100644\nindex 000000000000..279d76859249\n--- /dev/null\n+++ b/ydb/core/graph/protos/graph.proto\n@@ -0,0 +1,31 @@\n+syntax = \"proto3\";\n+\n+package NKikimrGraph;\n+\n+option java_package = \"ru.yandex.kikimr.proto\";\n+\n+message TMetric {\n+    string Name = 1;\n+    double Value = 2;\n+}\n+\n+message TEvSendMetrics {\n+    repeated TMetric Metrics = 1;\n+}\n+\n+message TEvGetMetrics {\n+    optional uint64 TimeFrom = 1;\n+    optional uint64 TimeTo = 2;\n+    repeated string Metrics = 3;\n+    optional uint32 MaxPoints = 4;\n+}\n+\n+message TMetricData {\n+    repeated double Values = 1 [packed = true];\n+}\n+\n+message TEvMetricsResult {\n+    repeated uint64 Time = 1 [packed = true];\n+    repeated TMetricData Data = 2;\n+    string Error = 3;\n+}\ndiff --git a/ydb/core/graph/protos/ya.make b/ydb/core/graph/protos/ya.make\nnew file mode 100644\nindex 000000000000..3b975a1d2390\n--- /dev/null\n+++ b/ydb/core/graph/protos/ya.make\n@@ -0,0 +1,14 @@\n+PROTO_LIBRARY()\n+\n+OWNER(\n+    xenoxeno\n+    g:kikimr\n+)\n+\n+SRCS(\n+    graph.proto\n+)\n+\n+EXCLUDE_TAGS(GO_PROTO)\n+\n+END()\ndiff --git a/ydb/core/graph/service/log.h b/ydb/core/graph/service/log.h\nnew file mode 100644\nindex 000000000000..a987f248e2ca\n--- /dev/null\n+++ b/ydb/core/graph/service/log.h\n@@ -0,0 +1,25 @@\n+#pragma once\n+\n+#if defined BLOG_D || defined BLOG_I || defined BLOG_ERROR || defined BLOG_TRACE\n+#error log macro definition clash\n+#endif\n+\n+#include <util/generic/string.h>\n+#include <ydb/library/actors/core/log.h>\n+\n+namespace NKikimr {\n+namespace NGraph {\n+\n+TString GetLogPrefix();\n+\n+}\n+}\n+\n+#define BLOG_D(stream) ALOG_DEBUG(NKikimrServices::GRAPH, GetLogPrefix() << stream)\n+#define BLOG_I(stream) ALOG_INFO(NKikimrServices::GRAPH, GetLogPrefix() << stream)\n+#define BLOG_W(stream) ALOG_WARN(NKikimrServices::GRAPH, GetLogPrefix() << stream)\n+#define BLOG_NOTICE(stream) ALOG_NOTICE(NKikimrServices::GRAPH, GetLogPrefix() << stream)\n+#define BLOG_ERROR(stream) ALOG_ERROR(NKikimrServices::GRAPH, GetLogPrefix() << stream)\n+#define BLOG_CRIT(stream) ALOG_CRIT(NKikimrServices::GRAPH, GetLogPrefix() << stream)\n+#define BLOG_TRACE(stream) ALOG_TRACE(NKikimrServices::GRAPH, GetLogPrefix() << stream)\n+#define Y_ENSURE_LOG(cond, stream) if (!(cond)) { BLOG_ERROR(\"Failed condition \\\"\" << #cond << \"\\\" \" << stream); }\ndiff --git a/ydb/core/graph/service/service_impl.cpp b/ydb/core/graph/service/service_impl.cpp\nnew file mode 100644\nindex 000000000000..5ecd8f983ddb\n--- /dev/null\n+++ b/ydb/core/graph/service/service_impl.cpp\n@@ -0,0 +1,234 @@\n+#include \"log.h\"\n+#include <ydb/core/graph/api/service.h>\n+#include <ydb/core/graph/api/events.h>\n+#include <ydb/library/actors/core/actor.h>\n+#include <ydb/library/services/services.pb.h>\n+#include <ydb/core/base/tablet_pipe.h>\n+#include <ydb/core/base/path.h>\n+#include <ydb/core/tx/scheme_cache/scheme_cache.h>\n+\n+namespace NKikimr {\n+namespace NGraph {\n+\n+class TGraphService : public TActor<TGraphService> {\n+private:\n+    using TBase = TActor<TGraphService>;\n+    static constexpr TDuration RESOLVE_TIMEOUT = TDuration::Seconds(1);\n+    static constexpr TDuration CONNECT_TIMEOUT = TDuration::Seconds(1);\n+    static constexpr TDuration GET_TIMEOUT = TDuration::Seconds(10);\n+    static constexpr size_t MAX_INFLIGHT = 100;\n+    TString Database;\n+    TInstant ResolveTimestamp;\n+    ui64 GraphShardId = 0;\n+    TInstant ConnectTimestamp;\n+    TActorId GraphShardPipe = {};\n+\n+    struct TGetMetricsRequest {\n+        ui64 Id;\n+        TInstant Deadline;\n+        TActorId Sender;\n+        ui64 Cookie;\n+        NKikimrGraph::TEvGetMetrics Request;\n+    };\n+\n+    ui64 RequestId = 0;\n+    std::deque<TGetMetricsRequest> RequestsInFlight;\n+\n+public:\n+    static constexpr NKikimrServices::TActivity::EType ActorActivityType() {\n+        return NKikimrServices::TActivity::GRAPH_SERVICE;\n+    }\n+\n+    TGraphService(const TString& database)\n+        : TActor(&TGraphService::StateWork)\n+        , Database(database)\n+    {\n+    }\n+\n+    TString GetLogPrefix() const {\n+        return \"SVC \";\n+    }\n+\n+    void ResolveDatabase() {\n+        if (ResolveTimestamp && (ResolveTimestamp + RESOLVE_TIMEOUT > TActivationContext::Now())) {\n+            BLOG_TRACE(\"ResolveDatabase too soon\");\n+            return; // too soon\n+        }\n+\n+        BLOG_D(\"ResolveDatabase \" << Database);\n+        TAutoPtr<NSchemeCache::TSchemeCacheNavigate> request(new NSchemeCache::TSchemeCacheNavigate());\n+        NSchemeCache::TSchemeCacheNavigate::TEntry entry;\n+        entry.Operation = NSchemeCache::TSchemeCacheNavigate::OpList;\n+        entry.SyncVersion = false;\n+        entry.Path = SplitPath(Database);\n+        request->ResultSet.emplace_back(entry);\n+        Send(MakeSchemeCacheID(), new TEvTxProxySchemeCache::TEvNavigateKeySet(request));\n+        ResolveTimestamp = TActivationContext::Now();\n+    }\n+\n+    NTabletPipe::TClientConfig GetPipeClientConfig() {\n+        NTabletPipe::TClientConfig clientConfig;\n+        clientConfig.RetryPolicy = {.RetryLimitCount = 3};\n+        return clientConfig;\n+    }\n+\n+    void ConnectShard() {\n+        if (GraphShardId) {\n+            if (ConnectTimestamp && (ConnectTimestamp + CONNECT_TIMEOUT > TActivationContext::Now())) {\n+                BLOG_TRACE(\"ConnectShard too soon\");\n+                return; // too soon\n+            }\n+            BLOG_D(\"ConnectToShard \" << GraphShardId);\n+            IActor* pipeActor = NTabletPipe::CreateClient(TBase::SelfId(), GraphShardId, GetPipeClientConfig());\n+            GraphShardPipe = TBase::RegisterWithSameMailbox(pipeActor);\n+            ConnectTimestamp = TActivationContext::Now();\n+        } else {\n+            ResolveDatabase();\n+        }\n+    }\n+\n+    void SendRequest(const TGetMetricsRequest& request) {\n+        if (GraphShardPipe) {\n+            TEvGraph::TEvGetMetrics* event = new TEvGraph::TEvGetMetrics();\n+            event->Record = request.Request;\n+            NTabletPipe::SendData(SelfId(), GraphShardPipe, event, request.Id);\n+        } else {\n+            ConnectShard();\n+        }\n+    }\n+\n+    void EnqueueRequest(TEvGraph::TEvGetMetrics::TPtr& ev) {\n+        if (RequestsInFlight.size() >= MAX_INFLIGHT) {\n+            TEvGraph::TEvMetricsResult* response = new TEvGraph::TEvMetricsResult();\n+            response->Record.SetError(\"Maximum number of outstanding requests reached\");\n+            Send(ev->Sender, response, 0, ev->Cookie);\n+            return;\n+        }\n+        if (RequestsInFlight.empty()) {\n+            Schedule(GET_TIMEOUT, new TEvents::TEvWakeup());\n+        }\n+        RequestsInFlight.push_back({\n+            .Id = ++RequestId,\n+            .Deadline = TActivationContext::Now() + GET_TIMEOUT,\n+            .Sender = ev->Sender,\n+            .Cookie = ev->Cookie,\n+            .Request = std::move(ev->Get()->Record)\n+        });\n+        SendRequest(RequestsInFlight.back());\n+    }\n+\n+    void DiscardOldRequests(TInstant now) {\n+        while (!RequestsInFlight.empty() && RequestsInFlight.front().Deadline <= now) {\n+            BLOG_W(\"Discarding request with id \" << RequestsInFlight.front().Id);\n+            TEvGraph::TEvMetricsResult* response = new TEvGraph::TEvMetricsResult();\n+            response->Record.SetError(\"Request timed out\");\n+            Send(RequestsInFlight.front().Sender, response, 0, RequestsInFlight.front().Cookie);\n+            RequestsInFlight.pop_front();\n+        }\n+    }\n+\n+    void ResendRequests() {\n+        for (const TGetMetricsRequest& request : RequestsInFlight) {\n+            BLOG_TRACE(\"Resending request \" << request.Id);\n+            NTabletPipe::SendData(SelfId(), GraphShardPipe, new TEvGraph::TEvGetMetrics(request.Request), request.Id);\n+        }\n+    }\n+\n+    void Handle(TEvGraph::TEvSendMetrics::TPtr& ev) {\n+        BLOG_TRACE(\"TEvSendMetrics\");\n+        if (GraphShardPipe) {\n+            NTabletPipe::SendData(SelfId(), GraphShardPipe, ev.Get()->Release());\n+        } else {\n+            ConnectShard();\n+            BLOG_TRACE(\"Dropped metrics\");\n+        }\n+    }\n+\n+    void Handle(TEvGraph::TEvGetMetrics::TPtr& ev) {\n+        BLOG_TRACE(\"TEvGetMetrics\");\n+        if (!GraphShardPipe) {\n+            ConnectShard();\n+        }\n+        EnqueueRequest(ev);\n+    }\n+\n+    void Handle(TEvTxProxySchemeCache::TEvNavigateKeySetResult::TPtr& ev) {\n+        TAutoPtr<NSchemeCache::TSchemeCacheNavigate> request = ev->Get()->Request;\n+        if (!request->ResultSet.empty() && request->ResultSet.front().Status == NSchemeCache::TSchemeCacheNavigate::EStatus::Ok) {\n+            const NSchemeCache::TSchemeCacheNavigate::TEntry& response = request->ResultSet.front();\n+            if (response.DomainDescription) {\n+                if (response.DomainDescription->Description.GetProcessingParams().GetGraphShard() != 0) {\n+                    GraphShardId = response.DomainDescription->Description.GetProcessingParams().GetGraphShard();\n+                    BLOG_D(\"Database \" << Database << \" resolved to shard \" << GraphShardId);\n+                    ConnectShard();\n+                    return;\n+                }\n+            }\n+            BLOG_W(\"Error resolving database \" << Database << \" incomplete response / no graph shard\");\n+        } else {\n+            if (!request->ResultSet.empty()) {\n+                BLOG_W(\"Error resolving database \" << Database << \" error \" << request->ResultSet.front().Status);\n+            } else {\n+                BLOG_W(\"Error resolving database \" << Database << \" no response\");\n+            }\n+        }\n+    }\n+\n+    void Handle(TEvTabletPipe::TEvClientConnected::TPtr& ev) {\n+        if (ev->Get()->Status == NKikimrProto::OK) {\n+            BLOG_D(\"Connected to shard \" << GraphShardId);\n+            ResendRequests();\n+        } else {\n+            BLOG_W(\"Error connecting to shard \" << GraphShardId << \" error \" << ev->Get()->Status);\n+            NTabletPipe::CloseClient(TBase::SelfId(), GraphShardPipe);\n+            GraphShardPipe = {};\n+        }\n+    }\n+\n+    void Handle(TEvTabletPipe::TEvClientDestroyed::TPtr&) {\n+        BLOG_W(\"Connection to shard was destroyed\");\n+        NTabletPipe::CloseClient(TBase::SelfId(), GraphShardPipe);\n+        GraphShardPipe = {};\n+    }\n+\n+    void Handle(TEvGraph::TEvMetricsResult::TPtr& ev) {\n+        auto id(ev->Cookie);\n+        BLOG_TRACE(\"TEvMetricsResult \" << id);\n+        for (auto it = RequestsInFlight.begin(); it != RequestsInFlight.end(); ++it) {\n+            if (it->Id == id) {\n+                BLOG_TRACE(\"TEvMetricsResult found request \" << id << \" resending to \" << it->Sender);\n+                Send(it->Sender, ev->Release().Release(), 0, it->Cookie);\n+                RequestsInFlight.erase(it);\n+                return;\n+            }\n+        }\n+        BLOG_W(\"Couldn't find request with id \" << id);\n+    }\n+\n+    void HandleTimeout() {\n+        TInstant now(TActivationContext::Now());\n+        DiscardOldRequests(now);\n+        if (!RequestsInFlight.empty()) {\n+            Schedule(RequestsInFlight.front().Deadline - now, new TEvents::TEvWakeup());\n+        }\n+    }\n+\n+    STATEFN(StateWork) {\n+        switch (ev->GetTypeRewrite()) {\n+            hFunc(TEvGraph::TEvSendMetrics, Handle);\n+            hFunc(TEvGraph::TEvGetMetrics, Handle);\n+            hFunc(TEvGraph::TEvMetricsResult, Handle);\n+            hFunc(TEvTxProxySchemeCache::TEvNavigateKeySetResult, Handle);\n+            hFunc(TEvTabletPipe::TEvClientConnected, Handle);\n+            cFunc(TEvents::TSystem::Wakeup, HandleTimeout);\n+        }\n+    }\n+};\n+\n+\n+IActor* CreateGraphService(const TString& database) {\n+    return new TGraphService(database);\n+}\n+\n+} // NGraph\n+} // NKikimr\ndiff --git a/ydb/core/graph/service/ya.make b/ydb/core/graph/service/ya.make\nnew file mode 100644\nindex 000000000000..9a9bda397686\n--- /dev/null\n+++ b/ydb/core/graph/service/ya.make\n@@ -0,0 +1,18 @@\n+LIBRARY()\n+\n+OWNER(\n+    xenoxeno\n+    g:kikimr\n+)\n+\n+SRCS(\n+    log.h\n+    service_impl.cpp\n+)\n+\n+PEERDIR(\n+    ydb/core/base\n+    ydb/core/graph/api\n+)\n+\n+END()\ndiff --git a/ydb/core/graph/shard/backends.cpp b/ydb/core/graph/shard/backends.cpp\nnew file mode 100644\nindex 000000000000..7573c6e04cb0\n--- /dev/null\n+++ b/ydb/core/graph/shard/backends.cpp\n@@ -0,0 +1,251 @@\n+#include \"log.h\"\n+#include \"backends.h\"\n+#include \"schema.h\"\n+\n+namespace NKikimr {\n+namespace NGraph {\n+\n+template<>\n+std::vector<TInstant> TMemoryBackend::Downsample<TInstant>(const std::vector<TInstant>& data, size_t maxPoints) {\n+    if (data.size() <= maxPoints) {\n+        return data;\n+    }\n+    std::vector<TInstant> result;\n+    double coeff = (double)maxPoints / data.size();\n+    result.resize(maxPoints);\n+    size_t ltrg = maxPoints;\n+    for (size_t src = 0; src < data.size(); ++src) {\n+        size_t trg = floor(coeff * src);\n+        if (trg != ltrg) {\n+            result[trg] = data[src]; // we expect sorted data so we practically use min() here\n+            ltrg = trg;\n+        }\n+    }\n+    return result;\n+}\n+\n+template<>\n+std::vector<double> TMemoryBackend::Downsample<double>(const std::vector<double>& data, size_t maxPoints) {\n+    if (data.size() <= maxPoints) {\n+        return data;\n+    }\n+    std::vector<double> result;\n+    double coeff = (double)maxPoints / data.size();\n+    result.resize(maxPoints);\n+    size_t ltrg = 0;\n+    long cnt = 0;\n+    for (size_t src = 0; src < data.size(); ++src) {\n+        if (isnan(data[src])) {\n+            continue;\n+        }\n+        size_t trg = floor(coeff * src);\n+        if (trg != ltrg && cnt > 0) {\n+            if (cnt > 1) {\n+                result[ltrg] /= cnt;\n+            }\n+            cnt = 0;\n+        }\n+        result[trg] += data[src];\n+        ++cnt;\n+        ltrg = trg;\n+    }\n+    if (cnt > 1) {\n+        result[ltrg] /= cnt;\n+    }\n+    return result;\n+}\n+\n+void TMemoryBackend::StoreMetrics(TMetricsData&& data) {\n+    if (!MetricsValues.empty() && MetricsValues.back().Timestamp >= data.Timestamp) {\n+        BLOG_ERROR(\"Invalid timestamp ordering for \" << data.Timestamp << \" and \" << MetricsValues.back().Timestamp);\n+    }\n+    TMetricsRecord& record = MetricsValues.emplace_back();\n+    record.Timestamp = data.Timestamp;\n+    for (const auto& [name, value] : data.Values) {\n+        auto itMetricsIndex = MetricsIndex.find(name);\n+        if (itMetricsIndex == MetricsIndex.end()) {\n+            itMetricsIndex = MetricsIndex.emplace(name, MetricsIndex.size()).first;\n+        }\n+        size_t idx = itMetricsIndex->second;\n+        if (idx <= record.Values.size()) {\n+            record.Values.resize(idx + 1, NAN);\n+        }\n+        record.Values[idx] = value;\n+    }\n+    BLOG_TRACE(\"Stored metrics\");\n+}\n+\n+void TMemoryBackend::GetMetrics(const NKikimrGraph::TEvGetMetrics& get, NKikimrGraph::TEvMetricsResult& result) const {\n+    auto itLeft = get.HasTimeFrom()\n+        ? std::lower_bound(MetricsValues.begin(), MetricsValues.end(), TInstant::Seconds(get.GetTimeFrom()))\n+        : MetricsValues.begin();\n+    auto itRight = get.HasTimeTo()\n+        ? std::upper_bound(itLeft, MetricsValues.end(), TInstant::Seconds(get.GetTimeTo()))\n+        : MetricsValues.end();\n+    std::vector<size_t> indexes;\n+    for (const TString& metric : get.GetMetrics()) {\n+        auto itMetricsIndex = MetricsIndex.find(metric);\n+        size_t idx;\n+        if (itMetricsIndex != MetricsIndex.end()) {\n+            idx = itMetricsIndex->second;\n+        } else {\n+            idx = MetricsIndex.size(); // non-existent index\n+        }\n+        indexes.push_back(idx);\n+    }\n+    std::vector<TInstant> timestamps;\n+    std::vector<std::vector<double>> values;\n+    values.resize(indexes.size());\n+    for (auto it = itLeft; it != itRight; ++it) {\n+        timestamps.push_back(it->Timestamp);\n+        for (size_t num = 0; num < indexes.size(); ++num) {\n+            size_t idx = indexes[num];\n+            if (idx < it->Values.size()) {\n+                values[num].push_back(it->Values[idx]);\n+            } else {\n+                values[num].push_back(NAN);\n+            }\n+        }\n+    }\n+    if (get.HasMaxPoints() && timestamps.size() > get.GetMaxPoints()) {\n+        timestamps = Downsample(timestamps, get.GetMaxPoints());\n+        BLOG_TRACE(\"GetMetrics timestamps=\" << timestamps.size());\n+        for (std::vector<double>& values : values) {\n+            values = Downsample(values, get.GetMaxPoints());\n+            BLOG_TRACE(\"GetMetrics values=\" << values.size());\n+        }\n+    }\n+    result.Clear();\n+    auto time = result.MutableTime();\n+    time->Reserve(timestamps.size());\n+    for (const TInstant t : timestamps) {\n+        time->Add(t.Seconds());\n+    }\n+    for (std::vector<double>& values : values) {\n+        result.AddData()->MutableValues()->Add(values.begin(), values.end());\n+    }\n+}\n+\n+void TMemoryBackend::ClearData(TInstant cutline, TInstant& newStartTimestamp) {\n+    auto itCutLine = std::lower_bound(MetricsValues.begin(), MetricsValues.end(), cutline);\n+    MetricsValues.erase(MetricsValues.begin(), itCutLine);\n+    if (!MetricsValues.empty()) {\n+        newStartTimestamp = MetricsValues.front().Timestamp;\n+    } else {\n+        newStartTimestamp = {};\n+    }\n+}\n+\n+TString TMemoryBackend::GetLogPrefix() const {\n+    return \"MEM \";\n+}\n+\n+bool TLocalBackend::StoreMetrics(NTabletFlatExecutor::TTransactionContext& txc, TMetricsData&& data) {\n+    NIceDb::TNiceDb db(txc.DB);\n+    for (const auto& [name, value] : data.Values) {\n+        auto itId = MetricsIndex.find(name);\n+        if (itId == MetricsIndex.end()) {\n+            itId = MetricsIndex.emplace(name, MetricsIndex.size()).first;\n+            db.Table<Schema::MetricsIndex>().Key(name).Update<Schema::MetricsIndex::Id>(itId->second);\n+        }\n+        ui64 id = itId->second;\n+        db.Table<Schema::MetricsValues>().Key(data.Timestamp.Seconds(), id).Update<Schema::MetricsValues::Value>(value);\n+    }\n+    BLOG_TRACE(\"Stored metrics\");\n+    return true;\n+}\n+\n+bool TLocalBackend::GetMetrics(NTabletFlatExecutor::TTransactionContext& txc, const NKikimrGraph::TEvGetMetrics& get, NKikimrGraph::TEvMetricsResult& result) const {\n+    NIceDb::TNiceDb db(txc.DB);\n+    ui64 minTime = std::numeric_limits<ui64>::min();\n+    ui64 maxTime = std::numeric_limits<ui64>::max();\n+    std::unordered_map<ui64, ui64> metricIdx;\n+    if (get.HasTimeFrom()) {\n+        minTime = get.GetTimeFrom();\n+    }\n+    if (get.HasTimeTo()) {\n+        maxTime = get.GetTimeTo();\n+    }\n+    for (size_t nMetric = 0; nMetric < get.MetricsSize(); ++nMetric) {\n+        TString name = get.GetMetrics(nMetric);\n+        auto itMetricIdx = MetricsIndex.find(name);\n+        if (itMetricIdx != MetricsIndex.end()) {\n+            metricIdx[itMetricIdx->second] = nMetric;\n+        }\n+    }\n+    std::vector<TInstant> timestamps;\n+    std::vector<std::vector<double>> values;\n+    auto rowset = db.Table<Schema::MetricsValues>().GreaterOrEqual(minTime).LessOrEqual(maxTime).Select();\n+    if (!rowset.IsReady()) {\n+        return false;\n+    }\n+    ui64 lastTime = 0;\n+    values.resize(get.MetricsSize());\n+    while (!rowset.EndOfSet()) {\n+        ui64 time = rowset.GetValue<Schema::MetricsValues::Timestamp>();\n+        if (time != lastTime) {\n+            lastTime = time;\n+            timestamps.push_back(TInstant::Seconds(time));\n+            for (auto& vals : values) {\n+                vals.emplace_back(NAN);\n+            }\n+        }\n+        ui64 id = rowset.GetValue<Schema::MetricsValues::Id>();\n+        auto itIdx = metricIdx.find(id);\n+        if (itIdx != metricIdx.end()) {\n+            values.back()[itIdx->second] = rowset.GetValue<Schema::MetricsValues::Value>();\n+        }\n+        if (!rowset.Next()) {\n+            return false;\n+        }\n+    }\n+    if (get.HasMaxPoints() && timestamps.size() > get.GetMaxPoints()) {\n+        timestamps = TMemoryBackend::Downsample(timestamps, get.GetMaxPoints());\n+        BLOG_TRACE(\"GetMetrics timestamps=\" << timestamps.size());\n+        for (std::vector<double>& values : values) {\n+            values = TMemoryBackend::Downsample(values, get.GetMaxPoints());\n+            BLOG_TRACE(\"GetMetrics values=\" << values.size());\n+        }\n+    }\n+    result.Clear();\n+    auto time = result.MutableTime();\n+    time->Reserve(timestamps.size());\n+    for (const TInstant t : timestamps) {\n+        time->Add(t.Seconds());\n+    }\n+    for (std::vector<double>& values : values) {\n+        result.AddData()->MutableValues()->Add(values.begin(), values.end());\n+    }\n+    return true;\n+}\n+\n+bool TLocalBackend::ClearData(NTabletFlatExecutor::TTransactionContext& txc, TInstant cutline, TInstant& newStartTimestamp) {\n+    NIceDb::TNiceDb db(txc.DB);\n+    ui64 rows = 0;\n+    auto rowset = db.Table<Schema::MetricsValues>().LessOrEqual(cutline.Seconds()).Select();\n+    if (!rowset.IsReady()) {\n+        return false;\n+    }\n+    while (!rowset.EndOfSet()) {\n+        ui64 timestamp = rowset.GetValue<Schema::MetricsValues::Timestamp>();\n+        ui64 id = rowset.GetValue<Schema::MetricsValues::Id>();\n+        db.Table<Schema::MetricsValues>().Key(timestamp, id).Delete();\n+        newStartTimestamp = TInstant::Seconds(timestamp);\n+        if (++rows >= MAX_ROWS_TO_DELETE) {\n+            break;\n+        }\n+        if (!rowset.Next()) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+TString TLocalBackend::GetLogPrefix() const {\n+    return \"DB \";\n+}\n+\n+\n+} // NGraph\n+} // NKikimr\n+\ndiff --git a/ydb/core/graph/shard/backends.h b/ydb/core/graph/shard/backends.h\nnew file mode 100644\nindex 000000000000..0c9e82e0ba8b\n--- /dev/null\n+++ b/ydb/core/graph/shard/backends.h\n@@ -0,0 +1,62 @@\n+#pragma once\n+\n+#include <ydb/core/graph/api/events.h>\n+#include <ydb/core/tablet_flat/tablet_flat_executed.h>\n+\n+namespace NKikimr {\n+namespace NGraph {\n+\n+enum class EBackendType {\n+    Memory = 0,\n+    Local = 1,\n+    External = 2,\n+};\n+\n+struct TMetricsData {\n+    TInstant Timestamp;\n+    std::unordered_map<TString, double> Values;\n+};\n+\n+class TMemoryBackend {\n+public:\n+    void StoreMetrics(TMetricsData&& data);\n+    void GetMetrics(const NKikimrGraph::TEvGetMetrics& get, NKikimrGraph::TEvMetricsResult& result) const;\n+    void ClearData(TInstant cutline, TInstant& newStartTimestamp);\n+\n+    template<typename ValueType>\n+    static std::vector<ValueType> Downsample(const std::vector<ValueType>& data, size_t maxPoints);\n+\n+    TString GetLogPrefix() const;\n+\n+    struct TMetricsRecord {\n+        TInstant Timestamp;\n+        TSmallVec<double> Values;\n+\n+        std::strong_ordering operator <=>(const TMetricsRecord& rec) const {\n+            return Timestamp.GetValue() <=> rec.Timestamp.GetValue();\n+        }\n+\n+        std::strong_ordering operator <=>(TInstant time) const {\n+            return Timestamp.GetValue() <=> time.GetValue();\n+        }\n+    };\n+\n+    std::unordered_map<TString, size_t> MetricsIndex; // mapping name -> id\n+    std::deque<TMetricsRecord> MetricsValues;\n+};\n+\n+class TLocalBackend {\n+public:\n+    static constexpr ui64 MAX_ROWS_TO_DELETE = 1000;\n+\n+    bool StoreMetrics(NTabletFlatExecutor::TTransactionContext& txc, TMetricsData&& data);\n+    bool GetMetrics(NTabletFlatExecutor::TTransactionContext& txc, const NKikimrGraph::TEvGetMetrics& get, NKikimrGraph::TEvMetricsResult& result) const;\n+    bool ClearData(NTabletFlatExecutor::TTransactionContext& txc, TInstant cutline, TInstant& newStartTimestamp);\n+\n+    TString GetLogPrefix() const;\n+\n+    std::unordered_map<TString, ui64> MetricsIndex; // mapping name -> id\n+};\n+\n+} // NGraph\n+} // NKikimr\ndiff --git a/ydb/core/graph/shard/log.h b/ydb/core/graph/shard/log.h\nnew file mode 100644\nindex 000000000000..c401e075ad01\n--- /dev/null\n+++ b/ydb/core/graph/shard/log.h\n@@ -0,0 +1,42 @@\n+#pragma once\n+\n+#if defined BLOG_D || defined BLOG_I || defined BLOG_ERROR || defined BLOG_TRACE\n+#error log macro definition clash\n+#endif\n+\n+#include <util/generic/string.h>\n+#include <ydb/library/actors/core/log.h>\n+#include <ydb/core/tablet_flat/tablet_flat_executor.h>\n+\n+namespace NKikimr {\n+namespace NGraph {\n+\n+TString GetLogPrefix();\n+\n+template <typename T>\n+class TTransactionBase : public NKikimr::NTabletFlatExecutor::TTransactionBase<T> {\n+protected:\n+    using TSelf = T;\n+    using TBase = TTransactionBase<T>;\n+\n+public:\n+    TTransactionBase(T* self)\n+        : NKikimr::NTabletFlatExecutor::TTransactionBase<T>(self)\n+    {}\n+\n+    TString GetLogPrefix() const {\n+        return NKikimr::NTabletFlatExecutor::TTransactionBase<T>::Self->GetLogPrefix();\n+    }\n+};\n+\n+}\n+}\n+\n+#define BLOG_D(stream) ALOG_DEBUG(NKikimrServices::GRAPH, GetLogPrefix() << stream)\n+#define BLOG_I(stream) ALOG_INFO(NKikimrServices::GRAPH, GetLogPrefix() << stream)\n+#define BLOG_W(stream) ALOG_WARN(NKikimrServices::GRAPH, GetLogPrefix() << stream)\n+#define BLOG_NOTICE(stream) ALOG_NOTICE(NKikimrServices::GRAPH, GetLogPrefix() << stream)\n+#define BLOG_ERROR(stream) ALOG_ERROR(NKikimrServices::GRAPH, GetLogPrefix() << stream)\n+#define BLOG_CRIT(stream) ALOG_CRIT(NKikimrServices::GRAPH, GetLogPrefix() << stream)\n+#define BLOG_TRACE(stream) ALOG_TRACE(NKikimrServices::GRAPH, GetLogPrefix() << stream)\n+#define Y_ENSURE_LOG(cond, stream) if (!(cond)) { BLOG_ERROR(\"Failed condition \\\"\" << #cond << \"\\\" \" << stream); }\ndiff --git a/ydb/core/graph/shard/protos/counters_shard.proto b/ydb/core/graph/shard/protos/counters_shard.proto\nnew file mode 100644\nindex 000000000000..3ca00fe86588\n--- /dev/null\n+++ b/ydb/core/graph/shard/protos/counters_shard.proto\n@@ -0,0 +1,29 @@\n+import \"ydb/core/protos/counters.proto\";\n+\n+package NKikimr.NGraphShard;\n+\n+option java_package = \"ru.yandex.kikimr.proto\";\n+\n+option (TabletTypeName) = \"GraphShard\"; // Used as prefix for all counters\n+\n+enum ESimpleCounters {\n+    COUNTER_SIMPLE_IGNORE = 0;\n+}\n+\n+enum ECumulativeCounters {\n+    COUNTER_CUMULATIVE_IGNORE = 0;\n+}\n+\n+enum EPercentileCounters {\n+    COUNTER_PERCENTILE_IGNORE = 0;\n+}\n+\n+enum ETxTypes {\n+    TXTYPE_INIT_SCHEMA = 1                                [(TxTypeOpts) = {Name: \"TxInitSchema\"}];\n+    TXTYPE_MONITORING = 2                                 [(TxTypeOpts) = {Name: \"TxMonitoring\"}];\n+    TXTYPE_STORE_METRICS = 3                              [(TxTypeOpts) = {Name: \"TxStoreMetrics\"}];\n+    TXTYPE_CLEAR_DATA = 4                                 [(TxTypeOpts) = {Name: \"TxClearData\"}];\n+    TXTYPE_GET_METRICS = 5                                [(TxTypeOpts) = {Name: \"TxGetMetrics\"}];\n+    TXTYPE_STARTUP = 6                                    [(TxTypeOpts) = {Name: \"TxStartup\"}];\n+    TXTYPE_CHANGE_BACKEND = 7                             [(TxTypeOpts) = {Name: \"TxChangeBackend\"}];\n+}\ndiff --git a/ydb/core/graph/shard/protos/ya.make b/ydb/core/graph/shard/protos/ya.make\nnew file mode 100644\nindex 000000000000..13ca24b18e4b\n--- /dev/null\n+++ b/ydb/core/graph/shard/protos/ya.make\n@@ -0,0 +1,18 @@\n+PROTO_LIBRARY()\n+\n+OWNER(\n+    xenoxeno\n+    g:kikimr\n+)\n+\n+SRCS(\n+    counters_shard.proto\n+)\n+\n+PEERDIR(\n+    ydb/core/protos\n+)\n+\n+EXCLUDE_TAGS(GO_PROTO)\n+\n+END()\ndiff --git a/ydb/core/graph/shard/schema.h b/ydb/core/graph/shard/schema.h\nnew file mode 100644\nindex 000000000000..85fee6ad1bbf\n--- /dev/null\n+++ b/ydb/core/graph/shard/schema.h\n@@ -0,0 +1,47 @@\n+#pragma once\n+#include <ydb/core/tablet_flat/flat_cxx_database.h>\n+\n+namespace NKikimr {\n+namespace NGraph {\n+\n+struct Schema : NIceDb::Schema {\n+    struct State : Table<1> {\n+        struct Name : Column<1, NScheme::NTypeIds::Text> {};\n+        struct ValueUI64 : Column<2, NScheme::NTypeIds::Uint64> {};\n+        struct ValueText : Column<3, NScheme::NTypeIds::Text> {};\n+\n+        using TKey = TableKey<Name>;\n+        using TColumns = TableColumns<Name, ValueUI64, ValueText>;\n+    };\n+\n+    struct MetricsIndex : Table<2> {\n+        struct Name : Column<1, NScheme::NTypeIds::Text> {};\n+        struct Id : Column<2, NScheme::NTypeIds::Uint64> {};\n+\n+        using TKey = TableKey<Name>;\n+        using TColumns = TableColumns<Name, Id>;\n+    };\n+\n+    struct MetricsValues : Table<3> {\n+        struct Timestamp : Column<1, NScheme::NTypeIds::Uint64> {};\n+        struct Id : Column<2, NScheme::NTypeIds::Uint64> {};\n+        struct Value : Column<3, NScheme::NTypeIds::Double> {};\n+\n+        using TKey = TableKey<Timestamp, Id>;\n+        using TColumns = TableColumns<Timestamp, Id, Value>;\n+    };\n+\n+    using TTables = SchemaTables<\n+                            State,\n+                            MetricsIndex,\n+                            MetricsValues\n+                            >;\n+\n+    using TSettings = SchemaSettings<\n+                                    ExecutorLogBatching<true>,\n+                                    ExecutorLogFlushPeriod<TDuration::MicroSeconds(512).GetValue()>\n+                                    >;\n+};\n+\n+} // NGraph\n+} // NKikimr\ndiff --git a/ydb/core/graph/shard/shard_impl.cpp b/ydb/core/graph/shard/shard_impl.cpp\nnew file mode 100644\nindex 000000000000..e5361e37ed37\n--- /dev/null\n+++ b/ydb/core/graph/shard/shard_impl.cpp\n@@ -0,0 +1,111 @@\n+#include \"shard_impl.h\"\n+#include \"log.h\"\n+#include <ydb/core/graph/api/events.h>\n+#include <ydb/core/engine/minikql/flat_local_tx_factory.h>\n+#include <ydb/core/base/tablet_pipe.h>\n+\n+namespace NKikimr {\n+namespace NGraph {\n+\n+TGraphShard::TGraphShard(TTabletStorageInfo* info, const TActorId& tablet)\n+    : TActor(&TThis::StateWork)\n+    , TTabletExecutedFlat(info, tablet, new NMiniKQL::TMiniKQLFactory)\n+{\n+\n+}\n+\n+TString TGraphShard::GetLogPrefix() const {\n+    return \"SHARD \";\n+}\n+\n+void TGraphShard::OnActivateExecutor(const TActorContext&) {\n+    BLOG_D(\"OnActivateExecutor\");\n+    ExecuteTxInitSchema();\n+}\n+\n+void TGraphShard::OnTabletDead(TEvTablet::TEvTabletDead::TPtr&, const TActorContext&) {\n+    BLOG_D(\"OnTabletDead\");\n+    PassAway();\n+}\n+\n+void TGraphShard::OnDetach(const TActorContext&) {\n+    BLOG_D(\"OnDetach\");\n+    PassAway();\n+}\n+\n+bool TGraphShard::OnRenderAppHtmlPage(NMon::TEvRemoteHttpInfo::TPtr ev, const TActorContext&) {\n+    if (!Executor() || !Executor()->GetStats().IsActive)\n+        return false;\n+\n+    if (!ev)\n+        return true;\n+\n+    ExecuteTxMonitoring(std::move(ev));\n+    return true;\n+}\n+\n+void TGraphShard::OnReadyToWork() {\n+    SignalTabletActive(ActorContext());\n+}\n+\n+STFUNC(TGraphShard::StateWork) {\n+    switch (ev->GetTypeRewrite()) {\n+        hFunc(TEvSubDomain::TEvConfigure, Handle);\n+        hFunc(TEvTabletPipe::TEvServerConnected, Handle);\n+        hFunc(TEvTabletPipe::TEvServerDisconnected, Handle);\n+        hFunc(TEvGraph::TEvSendMetrics, Handle);\n+        hFunc(TEvGraph::TEvGetMetrics, Handle);\n+    default:\n+        if (!HandleDefaultEvents(ev, SelfId())) {\n+            BLOG_W(\"StateWork unhandled event type: \" << ev->GetTypeRewrite() << \" event: \" << ev->ToString());\n+        }\n+        break;\n+    }\n+}\n+\n+void TGraphShard::Handle(TEvTabletPipe::TEvServerConnected::TPtr& ev) {\n+    BLOG_TRACE(\"Handle TEvTabletPipe::TEvServerConnected(\" << ev->Get()->ClientId << \") \" << ev->Get()->ServerId);\n+}\n+\n+void TGraphShard::Handle(TEvTabletPipe::TEvServerDisconnected::TPtr& ev) {\n+    BLOG_TRACE(\"Handle TEvTabletPipe::TEvServerDisconnected(\" << ev->Get()->ClientId << \") \" << ev->Get()->ServerId);\n+}\n+\n+void TGraphShard::Handle(TEvSubDomain::TEvConfigure::TPtr& ev) {\n+    BLOG_D(\"Handle TEvSubDomain::TEvConfigure(\" << ev->Get()->Record.ShortDebugString() << \")\");\n+    Send(ev->Sender, new TEvSubDomain::TEvConfigureStatus(NKikimrTx::TEvSubDomainConfigurationAck::SUCCESS, TabletID()));\n+}\n+\n+void TGraphShard::Handle(TEvGraph::TEvSendMetrics::TPtr& ev) {\n+    BLOG_TRACE(\"Handle TEvGraph::TEvSendMetrics from \" << ev->Sender);\n+    TInstant now = TInstant::Seconds(TActivationContext::Now().Seconds()); // 1 second resolution\n+    if (StartTimestamp == TInstant()) {\n+        StartTimestamp = now;\n+    }\n+    if (now != MetricsData.Timestamp) {\n+        if (MetricsData.Timestamp != TInstant()) {\n+            ExecuteTxStoreMetrics(std::move(MetricsData));\n+        }\n+        MetricsData.Timestamp = now;\n+        MetricsData.Values.clear();\n+    }\n+    if ((now - StartTimestamp) > DURATION_CLEAR_TRIGGER && (now - ClearTimestamp) < DURATION_CLEAR_PERIOD) {\n+        ClearTimestamp = now;\n+        ExecuteTxClearData();\n+    }\n+    for (const auto& metric : ev->Get()->Record.GetMetrics()) {\n+        MetricsData.Values[metric.GetName()] += metric.GetValue(); // simple accumulation by name of metric\n+    }\n+}\n+\n+void TGraphShard::Handle(TEvGraph::TEvGetMetrics::TPtr& ev) {\n+    BLOG_TRACE(\"Handle TEvGraph::TEvGetMetrics from \" << ev->Sender);\n+    ExecuteTxGetMetrics(ev);\n+}\n+\n+IActor* CreateGraphShard(const TActorId& tablet, TTabletStorageInfo* info) {\n+    return new NGraph::TGraphShard(info, tablet);\n+}\n+\n+} // NGraph\n+} // NKikimr\ndiff --git a/ydb/core/graph/shard/shard_impl.h b/ydb/core/graph/shard/shard_impl.h\nnew file mode 100644\nindex 000000000000..fca4eafbc014\n--- /dev/null\n+++ b/ydb/core/graph/shard/shard_impl.h\n@@ -0,0 +1,61 @@\n+#pragma once\n+\n+#include <ydb/library/actors/core/actor.h>\n+#include <ydb/library/actors/core/event.h>\n+#include <ydb/core/base/tablet.h>\n+#include <ydb/core/base/tablet_pipe.h>\n+#include <ydb/core/tablet_flat/tablet_flat_executed.h>\n+#include <ydb/core/tx/tx.h>\n+#include <ydb/core/graph/shard/protos/counters_shard.pb.h>\n+#include <ydb/core/graph/api/events.h>\n+#include \"backends.h\"\n+\n+namespace NKikimr {\n+namespace NGraph {\n+\n+class TGraphShard : public TActor<TGraphShard>, public NTabletFlatExecutor::TTabletExecutedFlat {\n+public:\n+    TGraphShard(TTabletStorageInfo* info, const TActorId& tablet);\n+    TString GetLogPrefix() const;\n+\n+    void OnActivateExecutor(const TActorContext& ctx) override;\n+    void DefaultSignalTabletActive(const TActorContext&) override {}\n+    void OnDetach(const TActorContext&) override;\n+    void OnTabletDead(TEvTablet::TEvTabletDead::TPtr&, const TActorContext&) override;\n+    bool OnRenderAppHtmlPage(NMon::TEvRemoteHttpInfo::TPtr ev, const TActorContext&) override;\n+    void OnReadyToWork();\n+\n+    void Handle(TEvTabletPipe::TEvServerConnected::TPtr& ev);\n+    void Handle(TEvTabletPipe::TEvServerDisconnected::TPtr& ev);\n+    void Handle(TEvSubDomain::TEvConfigure::TPtr& ev);\n+    void Handle(TEvGraph::TEvSendMetrics::TPtr& ev);\n+    void Handle(TEvGraph::TEvGetMetrics::TPtr& ev);\n+\n+//protected:\n+    void ExecuteTxInitSchema();\n+    void ExecuteTxStartup();\n+    void ExecuteTxMonitoring(NMon::TEvRemoteHttpInfo::TPtr ev);\n+    void ExecuteTxStoreMetrics(TMetricsData&& data);\n+    void ExecuteTxClearData();\n+    void ExecuteTxGetMetrics(TEvGraph::TEvGetMetrics::TPtr ev);\n+    void ExecuteTxChangeBackend(EBackendType backend);\n+\n+    STATEFN(StateWork);\n+\n+    // how often we could issue a clear operation\n+    static constexpr TDuration DURATION_CLEAR_PERIOD = TDuration::Minutes(10);\n+    // after what size of metrics data we issue a clear operation\n+    static constexpr TDuration DURATION_CLEAR_TRIGGER = TDuration::Hours(25);\n+    // the maximum size of metrics data to keep\n+    static constexpr TDuration DURATION_TO_KEEP = TDuration::Hours(24);\n+\n+    TMetricsData MetricsData; // current accumulated metrics, ready to be stored\n+    TInstant StartTimestamp; // the earliest point of metrics\n+    TInstant ClearTimestamp; // last time of clear operation\n+    EBackendType BackendType = EBackendType::Memory;\n+    TMemoryBackend MemoryBackend;\n+    TLocalBackend LocalBackend;\n+};\n+\n+} // NGraph\n+} // NKikimr\ndiff --git a/ydb/core/graph/shard/tx_change_backend.cpp b/ydb/core/graph/shard/tx_change_backend.cpp\nnew file mode 100644\nindex 000000000000..42a677f15036\n--- /dev/null\n+++ b/ydb/core/graph/shard/tx_change_backend.cpp\n@@ -0,0 +1,37 @@\n+#include \"shard_impl.h\"\n+#include \"log.h\"\n+#include \"schema.h\"\n+\n+namespace NKikimr {\n+namespace NGraph {\n+\n+class TTxChangeBackend : public TTransactionBase<TGraphShard> {\n+private:\n+    EBackendType Backend;\n+public:\n+    TTxChangeBackend(TGraphShard* shard, EBackendType backend)\n+        : TBase(shard)\n+        , Backend(backend)\n+    {}\n+\n+    TTxType GetTxType() const override { return NGraphShard::TXTYPE_CHANGE_BACKEND; }\n+\n+    bool Execute(TTransactionContext& txc, const TActorContext&) override {\n+        BLOG_D(\"TTxChangeBackend::Execute (\" << static_cast<ui64>(Backend) << \")\");\n+        NIceDb::TNiceDb db(txc.DB);\n+        db.Table<Schema::State>().Key(TString(\"backend\")).Update<Schema::State::ValueUI64>(static_cast<ui64>(Backend));\n+        return true;\n+    }\n+\n+    void Complete(const TActorContext&) override {\n+        BLOG_D(\"TTxChangeBackend::Complete\");\n+    }\n+};\n+\n+void TGraphShard::ExecuteTxChangeBackend(EBackendType backend) {\n+    Execute(new TTxChangeBackend(this, backend));\n+}\n+\n+} // NGraph\n+} // NKikimr\n+\ndiff --git a/ydb/core/graph/shard/tx_clear_data.cpp b/ydb/core/graph/shard/tx_clear_data.cpp\nnew file mode 100644\nindex 000000000000..f5808e54f9d7\n--- /dev/null\n+++ b/ydb/core/graph/shard/tx_clear_data.cpp\n@@ -0,0 +1,42 @@\n+#include \"shard_impl.h\"\n+#include \"log.h\"\n+#include \"schema.h\"\n+\n+namespace NKikimr {\n+namespace NGraph {\n+\n+class TTxClearData : public TTransactionBase<TGraphShard> {\n+public:\n+    TTxClearData(TGraphShard* shard)\n+        : TBase(shard)\n+    {}\n+\n+    TTxType GetTxType() const override { return NGraphShard::TXTYPE_CLEAR_DATA; }\n+\n+    bool Execute(TTransactionContext& txc, const TActorContext&) override {\n+        BLOG_D(\"TTxClearData::Execute\");\n+        TInstant cutline = TActivationContext::Now() - TGraphShard::DURATION_TO_KEEP;\n+        switch (Self->BackendType) {\n+            case EBackendType::Memory:\n+                Self->MemoryBackend.ClearData(cutline, Self->StartTimestamp);\n+                return true;\n+            case EBackendType::Local:\n+                return Self->LocalBackend.ClearData(txc, cutline, Self->StartTimestamp);\n+            case EBackendType::External:\n+                break;\n+        }\n+        return true;\n+    }\n+\n+    void Complete(const TActorContext&) override {\n+        BLOG_D(\"TTxClearData::Complete\");\n+    }\n+};\n+\n+void TGraphShard::ExecuteTxClearData() {\n+    Execute(new TTxClearData(this));\n+}\n+\n+} // NGraph\n+} // NKikimr\n+\ndiff --git a/ydb/core/graph/shard/tx_get_metrics.cpp b/ydb/core/graph/shard/tx_get_metrics.cpp\nnew file mode 100644\nindex 000000000000..1602de1b3dcf\n--- /dev/null\n+++ b/ydb/core/graph/shard/tx_get_metrics.cpp\n@@ -0,0 +1,46 @@\n+#include \"shard_impl.h\"\n+#include \"log.h\"\n+\n+namespace NKikimr {\n+namespace NGraph {\n+\n+class TTxGetMetrics : public TTransactionBase<TGraphShard> {\n+private:\n+    TEvGraph::TEvGetMetrics::TPtr Event;\n+    NKikimrGraph::TEvMetricsResult Result;\n+public:\n+    TTxGetMetrics(TGraphShard* shard, TEvGraph::TEvGetMetrics::TPtr ev)\n+        : TBase(shard)\n+        , Event(ev)\n+    {}\n+\n+    TTxType GetTxType() const override { return NGraphShard::TXTYPE_GET_METRICS; }\n+\n+    bool Execute(TTransactionContext& txc, const TActorContext&) override {\n+        BLOG_D(\"TTxGetMetrics::Execute\");\n+        switch (Self->BackendType) {\n+            case EBackendType::Memory:\n+                Self->MemoryBackend.GetMetrics(Event->Get()->Record, Result);\n+                return true;\n+            case EBackendType::Local:\n+                return Self->LocalBackend.GetMetrics(txc, Event->Get()->Record, Result);\n+            case EBackendType::External:\n+                break;\n+        }\n+        return true;\n+    }\n+\n+    void Complete(const TActorContext& ctx) override {\n+        BLOG_D(\"TTxGetMetric::Complete\");\n+        BLOG_TRACE(\"TxGetMetrics returned \" << Result.TimeSize() << \" points\");\n+        ctx.Send(Event->Sender, new TEvGraph::TEvMetricsResult(std::move(Result)), Event->Cookie);\n+    }\n+};\n+\n+void TGraphShard::ExecuteTxGetMetrics(TEvGraph::TEvGetMetrics::TPtr ev) {\n+    Execute(new TTxGetMetrics(this, ev));\n+}\n+\n+} // NGraph\n+} // NKikimr\n+\ndiff --git a/ydb/core/graph/shard/tx_init_schema.cpp b/ydb/core/graph/shard/tx_init_schema.cpp\nnew file mode 100644\nindex 000000000000..840619ac8450\n--- /dev/null\n+++ b/ydb/core/graph/shard/tx_init_schema.cpp\n@@ -0,0 +1,36 @@\n+#include \"shard_impl.h\"\n+#include \"log.h\"\n+#include \"schema.h\"\n+\n+namespace NKikimr {\n+namespace NGraph {\n+\n+class TTxInitSchema : public TTransactionBase<TGraphShard> {\n+public:\n+    TTxInitSchema(TGraphShard* shard)\n+        : TBase(shard)\n+    {}\n+\n+    TTxType GetTxType() const override { return NGraphShard::TXTYPE_INIT_SCHEMA; }\n+\n+    bool Execute(TTransactionContext& txc, const TActorContext&) override {\n+        BLOG_D(\"TTxInitScheme::Execute\");\n+        NIceDb::TNiceDb db(txc.DB);\n+        db.Materialize<Schema>();\n+        db.Table<Schema::State>().Key(TString(\"version\")).Update<Schema::State::ValueUI64>(1);\n+        return true;\n+    }\n+\n+    void Complete(const TActorContext&) override {\n+        BLOG_D(\"TTxInitScheme::Complete\");\n+        Self->ExecuteTxStartup();\n+    }\n+};\n+\n+void TGraphShard::ExecuteTxInitSchema() {\n+    Execute(new TTxInitSchema(this));\n+}\n+\n+} // NGraph\n+} // NKikimr\n+\ndiff --git a/ydb/core/graph/shard/tx_monitoring.cpp b/ydb/core/graph/shard/tx_monitoring.cpp\nnew file mode 100644\nindex 000000000000..9629f84a60f7\n--- /dev/null\n+++ b/ydb/core/graph/shard/tx_monitoring.cpp\n@@ -0,0 +1,80 @@\n+#include \"shard_impl.h\"\n+#include \"log.h\"\n+\n+namespace NKikimr {\n+namespace NGraph {\n+\n+class TTxMonitoring : public TTransactionBase<TGraphShard> {\n+private:\n+    NMon::TEvRemoteHttpInfo::TPtr Event;\n+\n+public:\n+    TTxMonitoring(TGraphShard* shard, NMon::TEvRemoteHttpInfo::TPtr ev)\n+        : TBase(shard)\n+        , Event(std::move(ev))\n+    {}\n+\n+    TTxType GetTxType() const override { return NGraphShard::TXTYPE_MONITORING; }\n+\n+    bool Execute(TTransactionContext&, const TActorContext&) override {\n+        BLOG_D(\"TTxMonitoring::Execute\");\n+        return true;\n+    }\n+\n+    void Complete(const TActorContext& ctx) override {\n+        BLOG_D(\"TTxMonitoring::Complete\");\n+        TStringBuilder html;\n+        html << \"<html>\";\n+        html << \"<style>\";\n+        html << \"table.simple-table1 th { text-align: center; }\";\n+        html << \"table.simple-table1 td { padding: 1px 3px; }\";\n+        html << \"table.simple-table1 td:nth-child(1) { text-align: right; }\";\n+        html << \"</style>\";\n+\n+        html << \"<table class='simple-table1'>\";\n+\n+        html << \"<tr><td>Backend</td><td>\";\n+        switch (Self->BackendType) {\n+            case EBackendType::Memory:\n+                html << \"Memory\";\n+                break;\n+            case EBackendType::Local:\n+                html << \"Local\";\n+                break;\n+            case EBackendType::External:\n+                html << \"External\";\n+                break;\n+        }\n+        html << \"</td></tr>\";\n+\n+        html << \"<tr><td>Memory.MetricsSize</td><td>\" << Self->MemoryBackend.MetricsIndex.size() << \"</td></tr>\";\n+        html << \"<tr><td>Memory.RecordsSize</td><td>\" << Self->MemoryBackend.MetricsValues.size() << \"</td></tr>\";\n+\n+        html << \"<tr><td>Local.MetricsSize</td><td>\" << Self->LocalBackend.MetricsIndex.size() << \"</td></tr>\";\n+        html << \"<tr><td>Local.StartTimestamp</td><td>\" << Self->StartTimestamp << \"</td></tr>\";\n+\n+        html << \"</table>\";\n+        html << \"</html>\";\n+        ctx.Send(Event->Sender, new NMon::TEvRemoteHttpInfoRes(html));\n+    }\n+};\n+\n+void TGraphShard::ExecuteTxMonitoring(NMon::TEvRemoteHttpInfo::TPtr ev) {\n+    if (ev->Get()->Cgi().Has(\"action\")) {\n+        if (ev->Get()->Cgi().Get(\"action\") == \"change_backend\") {\n+            ui64 backend = FromStringWithDefault(ev->Get()->Cgi().Get(\"backend\"), 0);\n+            if (backend >= 0 && backend <= 2) {\n+                ExecuteTxChangeBackend(static_cast<EBackendType>(backend));\n+                Send(ev->Sender, new NMon::TEvRemoteHttpInfoRes(\"<html><p>ok</p></html>\"));\n+                return;\n+            }\n+        }\n+        Send(ev->Sender, new NMon::TEvRemoteHttpInfoRes(\"<html><p>bad parameters</p></html>\"));\n+        return;\n+    }\n+    Execute(new TTxMonitoring(this, std::move(ev)));\n+}\n+\n+} // NGraph\n+} // NKikimr\n+\ndiff --git a/ydb/core/graph/shard/tx_startup.cpp b/ydb/core/graph/shard/tx_startup.cpp\nnew file mode 100644\nindex 000000000000..dd1d5756e96f\n--- /dev/null\n+++ b/ydb/core/graph/shard/tx_startup.cpp\n@@ -0,0 +1,68 @@\n+#include \"shard_impl.h\"\n+#include \"log.h\"\n+#include \"schema.h\"\n+#include \"backends.h\"\n+\n+namespace NKikimr {\n+namespace NGraph {\n+\n+class TTxStartup : public TTransactionBase<TGraphShard> {\n+public:\n+    TTxStartup(TGraphShard* shard)\n+        : TBase(shard)\n+    {}\n+\n+    TTxType GetTxType() const override { return NGraphShard::TXTYPE_STARTUP; }\n+\n+    bool Execute(TTransactionContext& txc, const TActorContext&) override {\n+        BLOG_D(\"TTxStartup::Execute\");\n+        NIceDb::TNiceDb db(txc.DB);\n+        {\n+            auto row = db.Table<Schema::State>().Key(TString(\"backend\")).Select();\n+            if (!row.IsReady()) {\n+                return false;\n+            }\n+            if (!row.EndOfSet()) {\n+                ui64 backend = row.GetValue<Schema::State::ValueUI64>();\n+                if (backend >= 0 && backend <= 2) {\n+                    Self->BackendType = static_cast<EBackendType>(backend);\n+                }\n+            }\n+        }\n+        {\n+            auto rowset = db.Table<Schema::MetricsIndex>().Select();\n+            if (!rowset.IsReady()) {\n+                return false;\n+            }\n+            while (!rowset.EndOfSet()) {\n+                Self->LocalBackend.MetricsIndex[rowset.GetValue<Schema::MetricsIndex::Name>()] = rowset.GetValue<Schema::MetricsIndex::Id>();\n+                if (!rowset.Next()) {\n+                    return false;\n+                }\n+            }\n+        }\n+        {\n+            auto rowset = db.Table<Schema::MetricsValues>().Select();\n+            if (!rowset.IsReady()) {\n+                return false;\n+            }\n+            if (!rowset.EndOfSet()) {\n+                Self->StartTimestamp = TInstant::Seconds(rowset.GetValue<Schema::MetricsValues::Timestamp>());\n+            }\n+        }\n+        return true;\n+    }\n+\n+    void Complete(const TActorContext&) override {\n+        BLOG_D(\"TTxStartup::Complete\");\n+        Self->OnReadyToWork();\n+    }\n+};\n+\n+void TGraphShard::ExecuteTxStartup() {\n+    Execute(new TTxStartup(this));\n+}\n+\n+} // NGraph\n+} // NKikimr\n+\ndiff --git a/ydb/core/graph/shard/tx_store_metrics.cpp b/ydb/core/graph/shard/tx_store_metrics.cpp\nnew file mode 100644\nindex 000000000000..78456361c60b\n--- /dev/null\n+++ b/ydb/core/graph/shard/tx_store_metrics.cpp\n@@ -0,0 +1,45 @@\n+#include \"shard_impl.h\"\n+#include \"log.h\"\n+\n+namespace NKikimr {\n+namespace NGraph {\n+\n+class TTxStoreMetrics : public TTransactionBase<TGraphShard> {\n+private:\n+    TMetricsData Data;\n+\n+public:\n+    TTxStoreMetrics(TGraphShard* shard, TMetricsData&& data)\n+        : TBase(shard)\n+        , Data(std::move(data))\n+    {}\n+\n+    TTxType GetTxType() const override { return NGraphShard::TXTYPE_STORE_METRICS; }\n+\n+    bool Execute(TTransactionContext& txc, const TActorContext&) override {\n+        BLOG_D(\"TTxStoreMetrics::Execute\");\n+        switch (Self->BackendType) {\n+            case EBackendType::Memory:\n+                Self->MemoryBackend.StoreMetrics(std::move(Data));\n+                return true;\n+            case EBackendType::Local:\n+                return Self->LocalBackend.StoreMetrics(txc, std::move(Data));\n+            case EBackendType::External:\n+                // TODO\n+                break;\n+        }\n+        return true;\n+    }\n+\n+    void Complete(const TActorContext&) override {\n+        BLOG_D(\"TTxStoreMetrics::Complete\");\n+    }\n+};\n+\n+void TGraphShard::ExecuteTxStoreMetrics(TMetricsData&& data) {\n+    Execute(new TTxStoreMetrics(this, std::move(data)));\n+}\n+\n+} // NGraph\n+} // NKikimr\n+\ndiff --git a/ydb/core/graph/shard/ut/shard_ut.cpp b/ydb/core/graph/shard/ut/shard_ut.cpp\nnew file mode 100644\nindex 000000000000..c700c2f141c2\n--- /dev/null\n+++ b/ydb/core/graph/shard/ut/shard_ut.cpp\n@@ -0,0 +1,185 @@\n+#include <library/cpp/testing/unittest/registar.h>\n+#include <ydb/core/testlib/test_client.h>\n+#include <ydb/core/testlib/tenant_runtime.h>\n+#include <ydb/core/tx/schemeshard/ut_helpers/test_env.h>\n+#include <ydb/core/tx/schemeshard/ut_helpers/helpers.h>\n+#include <util/stream/output.h>\n+#include <ydb/core/graph/shard/backends.h>\n+\n+#ifdef NDEBUG\n+#define Ctest Cnull\n+#else\n+#define Ctest Cerr\n+#endif\n+\n+Y_DECLARE_OUT_SPEC(, std::vector<TInstant>, stream, value) {\n+    stream << '[';\n+    for (auto it = value.begin(); it != value.end(); ++it) {\n+        if (it != value.begin()) {\n+            stream << ',';\n+        }\n+        stream << it->GetValue();\n+    }\n+    stream << ']';\n+}\n+\n+Y_DECLARE_OUT_SPEC(, std::vector<double>, stream, value) {\n+    stream << '[';\n+    for (auto it = value.begin(); it != value.end(); ++it) {\n+        if (it != value.begin()) {\n+            stream << ',';\n+        }\n+        stream << *it;\n+    }\n+    stream << ']';\n+}\n+\n+namespace NKikimr {\n+\n+using namespace Tests;\n+using namespace NSchemeShardUT_Private;\n+\n+Y_UNIT_TEST_SUITE(GraphShard) {\n+    Y_UNIT_TEST(DownsampleFixed) {\n+        std::vector<TInstant> sourceData = {\n+            TInstant::FromValue( 1 ),\n+            TInstant::FromValue( 2 ),\n+            TInstant::FromValue( 3 ),\n+            TInstant::FromValue( 4 ),\n+            TInstant::FromValue( 5 ),\n+            TInstant::FromValue( 6 ),\n+            TInstant::FromValue( 7 ),\n+            TInstant::FromValue( 8 ),\n+            TInstant::FromValue( 9 ),\n+            TInstant::FromValue( 10 )\n+        };\n+        {\n+            std::vector<TInstant> targetData = NGraph::TMemoryBackend::Downsample(sourceData, 10);\n+            Ctest << targetData << Endl;\n+            std::vector<TInstant> canonData = {\n+                TInstant::FromValue( 1 ),\n+                TInstant::FromValue( 2 ),\n+                TInstant::FromValue( 3 ),\n+                TInstant::FromValue( 4 ),\n+                TInstant::FromValue( 5 ),\n+                TInstant::FromValue( 6 ),\n+                TInstant::FromValue( 7 ),\n+                TInstant::FromValue( 8 ),\n+                TInstant::FromValue( 9 ),\n+                TInstant::FromValue( 10 )\n+            };\n+            UNIT_ASSERT(targetData == canonData);\n+        }\n+        {\n+            std::vector<TInstant> targetData = NGraph::TMemoryBackend::Downsample(sourceData, 5);\n+            Ctest << targetData << Endl;\n+            std::vector<TInstant> canonData = {\n+                TInstant::FromValue( 1 ),\n+                TInstant::FromValue( 3 ),\n+                TInstant::FromValue( 5 ),\n+                TInstant::FromValue( 7 ),\n+                TInstant::FromValue( 9 )\n+            };\n+            UNIT_ASSERT(targetData == canonData);\n+        }\n+        {\n+            std::vector<TInstant> targetData = NGraph::TMemoryBackend::Downsample(sourceData, 1);\n+            Ctest << targetData << Endl;\n+            std::vector<TInstant> canonData = { TInstant::FromValue( 1 ) };\n+            UNIT_ASSERT(targetData == canonData);\n+        }\n+    }\n+\n+    Y_UNIT_TEST(DownsampleFloat) {\n+        std::vector<double> sourceData = {1,2,3,4,5, 6, 7, 8, 9, 10};\n+        {\n+            std::vector<double> targetData = NGraph::TMemoryBackend::Downsample(sourceData, 10);\n+            Ctest << targetData << Endl;\n+            std::vector<double> canonData = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n+            UNIT_ASSERT(targetData == canonData);\n+        }\n+        {\n+            std::vector<double> targetData = NGraph::TMemoryBackend::Downsample(sourceData, 5);\n+            Ctest << targetData << Endl;\n+            std::vector<double> canonData = {1.5, 3.5, 5.5, 7.5, 9.5};\n+            UNIT_ASSERT(targetData == canonData);\n+        }\n+        {\n+            std::vector<double> targetData = NGraph::TMemoryBackend::Downsample(sourceData, 1);\n+            Ctest << targetData << Endl;\n+            std::vector<double> canonData = {5.5};\n+            UNIT_ASSERT(targetData == canonData);\n+        }\n+    }\n+\n+    TTenantTestConfig GetTenantTestConfig() {\n+        return {\n+            .Domains = {\n+                {\n+                    .Name = DOMAIN1_NAME,\n+                    .SchemeShardId = SCHEME_SHARD1_ID,\n+                    .Subdomains = {TENANT1_1_NAME, TENANT1_2_NAME}\n+                }\n+            },\n+            .HiveId = HIVE_ID,\n+            .FakeTenantSlotBroker = true,\n+            .FakeSchemeShard = true,\n+            .CreateConsole = false,\n+            .Nodes = {\n+                {\n+                    .TenantPoolConfig = {\n+                        .StaticSlots = {\n+                            {\n+                                .Tenant = DOMAIN1_NAME,\n+                                .Limit = {\n+                                    .CPU = 1,\n+                                    .Memory = 1,\n+                                    .Network = 1\n+                                }\n+                            }\n+                        },\n+                        .NodeType = \"node-type\"\n+                    }\n+                }\n+            },\n+            .DataCenterCount = 1\n+        };\n+    }\n+\n+    Y_UNIT_TEST(CreateGraphShard) {\n+        TTestBasicRuntime runtime;\n+\n+        runtime.SetLogPriority(NKikimrServices::GRAPH, NLog::PRI_TRACE);\n+        runtime.SetLogPriority(NKikimrServices::HIVE, NLog::PRI_TRACE);\n+\n+        TTestEnv env(runtime);\n+        ui64 txId = 100;\n+        TestCreateExtSubDomain(runtime, ++txId,  \"/MyRoot\", R\"(\n+            Name: \"db1\"\n+        )\");\n+\n+        env.TestWaitNotification(runtime, txId);\n+\n+        TestAlterExtSubDomain(runtime, ++txId,  \"/MyRoot\", R\"(\n+            Name: \"db1\"\n+            PlanResolution: 50\n+            Coordinators: 1\n+            Mediators: 1\n+            TimeCastBucketsPerMediator: 2\n+            StoragePools {\n+                Name: \"pool-1\"\n+                Kind: \"hdd\"\n+            }\n+            ExternalSchemeShard: true\n+            ExternalHive: true\n+            GraphShard: true\n+        )\");\n+\n+        env.TestWaitNotification(runtime, txId);\n+\n+        auto result = DescribePath(runtime, \"/MyRoot/db1\");\n+        UNIT_ASSERT(result.GetPathDescription().GetDomainDescription().GetProcessingParams().GetGraphShard() != 0);\n+    }\n+}\n+\n+} // NKikimr\ndiff --git a/ydb/core/graph/shard/ut/ya.make b/ydb/core/graph/shard/ut/ya.make\nnew file mode 100644\nindex 000000000000..9f3d2861bd14\n--- /dev/null\n+++ b/ydb/core/graph/shard/ut/ya.make\n@@ -0,0 +1,22 @@\n+UNITTEST_FOR(ydb/core/graph/shard)\n+\n+OWNER(\n+    xenoxeno\n+    g:kikimr\n+)\n+\n+SIZE(SMALL)\n+\n+SRC(\n+    shard_ut.cpp\n+)\n+\n+PEERDIR(\n+    ydb/library/actors/helpers\n+    ydb/core/tx/schemeshard/ut_helpers\n+    ydb/core/testlib/default\n+)\n+\n+YQL_LAST_ABI_VERSION()\n+\n+END()\ndiff --git a/ydb/core/graph/shard/ya.make b/ydb/core/graph/shard/ya.make\nnew file mode 100644\nindex 000000000000..20feec5286cb\n--- /dev/null\n+++ b/ydb/core/graph/shard/ya.make\n@@ -0,0 +1,35 @@\n+LIBRARY()\n+\n+OWNER(\n+    xenoxeno\n+    g:kikimr\n+)\n+\n+SRCS(\n+    backends.cpp\n+    backends.h\n+    log.h\n+    schema.h\n+    shard_impl.cpp\n+    shard_impl.h\n+    tx_change_backend.cpp\n+    tx_clear_data.cpp\n+    tx_get_metrics.cpp\n+    tx_init_schema.cpp\n+    tx_monitoring.cpp\n+    tx_startup.cpp\n+    tx_store_metrics.cpp\n+)\n+\n+PEERDIR(\n+    ydb/library/actors/core\n+    ydb/core/base\n+    ydb/core/tablet\n+    ydb/core/tablet_flat\n+    ydb/core/graph/api\n+    ydb/core/graph/shard/protos\n+)\n+\n+END()\n+\n+RECURSE_FOR_TESTS(ut)\ndiff --git a/ydb/core/graph/ut/graph_ut.cpp b/ydb/core/graph/ut/graph_ut.cpp\nnew file mode 100644\nindex 000000000000..104fafc10504\n--- /dev/null\n+++ b/ydb/core/graph/ut/graph_ut.cpp\n@@ -0,0 +1,184 @@\n+#include <library/cpp/testing/unittest/registar.h>\n+#include <ydb/core/testlib/test_client.h>\n+#include <ydb/core/testlib/tenant_runtime.h>\n+#include <ydb/core/tx/schemeshard/ut_helpers/test_env.h>\n+#include <ydb/core/tx/schemeshard/ut_helpers/helpers.h>\n+#include <ydb/core/graph/api/service.h>\n+#include <ydb/core/graph/api/events.h>\n+\n+#ifdef NDEBUG\n+#define Ctest Cnull\n+#else\n+#define Ctest Cerr\n+#endif\n+\n+namespace NKikimr {\n+\n+using namespace Tests;\n+using namespace NSchemeShardUT_Private;\n+\n+Y_UNIT_TEST_SUITE(Graph) {\n+    TTenantTestConfig GetTenantTestConfig() {\n+        return {\n+            .Domains = {\n+                {\n+                    .Name = DOMAIN1_NAME,\n+                    .SchemeShardId = SCHEME_SHARD1_ID,\n+                    .Subdomains = {TENANT1_1_NAME, TENANT1_2_NAME}\n+                }\n+            },\n+            .HiveId = HIVE_ID,\n+            .FakeTenantSlotBroker = true,\n+            .FakeSchemeShard = true,\n+            .CreateConsole = false,\n+            .Nodes = {\n+                {\n+                    .TenantPoolConfig = {\n+                        .StaticSlots = {\n+                            {\n+                                .Tenant = DOMAIN1_NAME,\n+                                .Limit = {\n+                                    .CPU = 1,\n+                                    .Memory = 1,\n+                                    .Network = 1\n+                                }\n+                            }\n+                        },\n+                        .NodeType = \"node-type\"\n+                    }\n+                }\n+            },\n+            .DataCenterCount = 1\n+        };\n+    }\n+\n+\n+\n+    Y_UNIT_TEST(CreateGraphShard) {\n+        TTestBasicRuntime runtime;\n+\n+        runtime.SetLogPriority(NKikimrServices::GRAPH, NLog::PRI_TRACE);\n+        runtime.SetLogPriority(NKikimrServices::HIVE, NLog::PRI_TRACE);\n+\n+        TTestEnv env(runtime);\n+        ui64 txId = 100;\n+        TestCreateExtSubDomain(runtime, ++txId,  \"/MyRoot\", R\"(\n+            Name: \"db1\"\n+        )\");\n+\n+        env.TestWaitNotification(runtime, txId);\n+\n+        TestAlterExtSubDomain(runtime, ++txId,  \"/MyRoot\", R\"(\n+            Name: \"db1\"\n+            PlanResolution: 50\n+            Coordinators: 1\n+            Mediators: 1\n+            TimeCastBucketsPerMediator: 2\n+            StoragePools {\n+                Name: \"pool-1\"\n+                Kind: \"hdd\"\n+            }\n+            ExternalSchemeShard: true\n+            ExternalHive: true\n+            GraphShard: true\n+        )\");\n+\n+        env.TestWaitNotification(runtime, txId);\n+\n+        auto result = DescribePath(runtime, \"/MyRoot/db1\");\n+        UNIT_ASSERT(result.GetPathDescription().GetDomainDescription().GetProcessingParams().GetGraphShard() != 0);\n+    }\n+\n+    Y_UNIT_TEST(UseGraphShard) {\n+        TTestBasicRuntime runtime;\n+\n+        runtime.SetLogPriority(NKikimrServices::GRAPH, NLog::PRI_TRACE);\n+        runtime.SetLogPriority(NKikimrServices::HIVE, NLog::PRI_TRACE);\n+\n+        TTestEnv::ENABLE_SCHEMESHARD_LOG = false;\n+        TTestEnv env(runtime);\n+        ui64 txId = 100;\n+\n+        TestCreateExtSubDomain(runtime, ++txId,  \"/MyRoot\", R\"(\n+            Name: \"db1\"\n+        )\");\n+\n+        env.TestWaitNotification(runtime, txId);\n+\n+        TestAlterExtSubDomain(runtime, ++txId,  \"/MyRoot\", R\"(\n+            Name: \"db1\"\n+            PlanResolution: 50\n+            Coordinators: 1\n+            Mediators: 1\n+            TimeCastBucketsPerMediator: 2\n+            StoragePools {\n+                Name: \"pool-1\"\n+                Kind: \"hdd\"\n+            }\n+            ExternalSchemeShard: true\n+            ExternalHive: true\n+            GraphShard: true\n+        )\");\n+\n+        env.TestWaitNotification(runtime, txId);\n+\n+        NKikimrScheme::TEvDescribeSchemeResult result = DescribePath(runtime, \"/MyRoot/db1\");\n+        UNIT_ASSERT(result.GetPathDescription().GetDomainDescription().GetProcessingParams().GetGraphShard() != 0);\n+\n+        IActor* service = NGraph::CreateGraphService(\"/MyRoot/db1\");\n+        TActorId serviceId = runtime.Register(service);\n+        runtime.RegisterService(NGraph::MakeGraphServiceId(), serviceId);\n+        TActorId sender = runtime.AllocateEdgeActor();\n+\n+        // this call is needed to wait for establishing of pipe connection\n+        {\n+            NGraph::TEvGraph::TEvGetMetrics* event = new NGraph::TEvGraph::TEvGetMetrics();\n+            event->Record.AddMetrics(\"test.metric1\");\n+            runtime.Send(NGraph::MakeGraphServiceId(), sender, event);\n+            TAutoPtr<IEventHandle> handle;\n+            NGraph::TEvGraph::TEvMetricsResult* response = runtime.GrabEdgeEventRethrow<NGraph::TEvGraph::TEvMetricsResult>(handle);\n+            Ctest << \"Received result: \" << response->Record.ShortDebugString() << Endl;\n+        }\n+\n+        {\n+            NGraph::TEvGraph::TEvSendMetrics* event = new NGraph::TEvGraph::TEvSendMetrics();\n+            NKikimrGraph::TMetric* metric = event->Record.AddMetrics();\n+            metric->SetName(\"test.metric1\");\n+            metric->SetValue(13);\n+            runtime.Send(NGraph::MakeGraphServiceId(), sender, event);\n+        }\n+\n+        runtime.SimulateSleep(TDuration::Seconds(1));\n+\n+        {\n+            NGraph::TEvGraph::TEvSendMetrics* event = new NGraph::TEvGraph::TEvSendMetrics();\n+            NKikimrGraph::TMetric* metric = event->Record.AddMetrics();\n+            metric->SetName(\"test.metric1\");\n+            metric->SetValue(14);\n+            runtime.Send(NGraph::MakeGraphServiceId(), sender, event);\n+        }\n+\n+        runtime.SimulateSleep(TDuration::Seconds(1));\n+\n+        {\n+            NGraph::TEvGraph::TEvSendMetrics* event = new NGraph::TEvGraph::TEvSendMetrics();\n+            NKikimrGraph::TMetric* metric = event->Record.AddMetrics();\n+            metric->SetName(\"test.metric1\");\n+            metric->SetValue(15);\n+            runtime.Send(NGraph::MakeGraphServiceId(), sender, event);\n+        }\n+\n+        {\n+            NGraph::TEvGraph::TEvGetMetrics* event = new NGraph::TEvGraph::TEvGetMetrics();\n+            event->Record.AddMetrics(\"test.metric1\");\n+            runtime.Send(NGraph::MakeGraphServiceId(), sender, event);\n+            TAutoPtr<IEventHandle> handle;\n+            NGraph::TEvGraph::TEvMetricsResult* response = runtime.GrabEdgeEventRethrow<NGraph::TEvGraph::TEvMetricsResult>(handle);\n+            Ctest << \"Received result: \" << response->Record.ShortDebugString() << Endl;\n+            UNIT_ASSERT(response->Record.DataSize() > 0);\n+            UNIT_ASSERT(response->Record.GetData(0).ShortDebugString() == \"Values: 13 Values: 14\");\n+        }\n+    }\n+}\n+\n+} // NKikimr\ndiff --git a/ydb/core/graph/ut/ya.make b/ydb/core/graph/ut/ya.make\nnew file mode 100644\nindex 000000000000..b69d8208f9c5\n--- /dev/null\n+++ b/ydb/core/graph/ut/ya.make\n@@ -0,0 +1,24 @@\n+UNITTEST_FOR(ydb/core/graph)\n+\n+OWNER(\n+    xenoxeno\n+    g:kikimr\n+)\n+\n+SIZE(SMALL)\n+\n+SRC(\n+    graph_ut.cpp\n+)\n+\n+PEERDIR(\n+    ydb/library/actors/helpers\n+    ydb/core/tx/schemeshard/ut_helpers\n+    ydb/core/testlib/default\n+    ydb/core/graph/shard\n+    ydb/core/graph/service\n+)\n+\n+YQL_LAST_ABI_VERSION()\n+\n+END()\ndiff --git a/ydb/core/graph/ya.make b/ydb/core/graph/ya.make\nnew file mode 100644\nindex 000000000000..50821e8f78a5\n--- /dev/null\n+++ b/ydb/core/graph/ya.make\n@@ -0,0 +1,13 @@\n+OWNER(\n+    xenoxeno\n+    g:kikimr\n+)\n+\n+RECURSE(\n+    api\n+    protos\n+    service\n+    shard\n+)\n+\n+RECURSE_FOR_TESTS(ut)\ndiff --git a/ydb/core/mind/hive/hive_statics.cpp b/ydb/core/mind/hive/hive_statics.cpp\nindex e3d6c65eb7bd..9e3f4695ba00 100644\n--- a/ydb/core/mind/hive/hive_statics.cpp\n+++ b/ydb/core/mind/hive/hive_statics.cpp\n@@ -384,7 +384,7 @@ void MakeTabletTypeSet(std::vector<TTabletTypes::EType>& list) {\n \n bool IsValidTabletType(TTabletTypes::EType type) {\n     return (type > TTabletTypes::Unknown\n-            && type < TTabletTypes::Reserved41\n+            && type < TTabletTypes::EType_MAX\n             );\n }\n \ndiff --git a/ydb/core/mind/hive/monitoring.cpp b/ydb/core/mind/hive/monitoring.cpp\nindex 18e885f3cd7c..7eb691103a72 100644\n--- a/ydb/core/mind/hive/monitoring.cpp\n+++ b/ydb/core/mind/hive/monitoring.cpp\n@@ -1,4 +1,4 @@\n-#include <library/cpp/monlib/service/pages/templates.h> \n+#include <library/cpp/monlib/service/pages/templates.h>\n #include <library/cpp/json/json_writer.h>\n #include <library/cpp/protobuf/json/proto2json.h>\n #include <util/string/vector.h>\n@@ -747,7 +747,8 @@ class TTxMonEvent_Settings : public TTransactionBase<THive> {\n              TTabletTypes::NodeBroker,\n              TTabletTypes::TestShard,\n              TTabletTypes::BlobDepot,\n-             TTabletTypes::ColumnShard}) {\n+             TTabletTypes::ColumnShard,\n+             TTabletTypes::GraphShard}) {\n             if (shortType == LongToShortTabletName(TTabletTypes::TypeToStr(tabletType))) {\n                 return tabletType;\n             }\n@@ -1280,6 +1281,8 @@ class TTxMonEvent_Landing : public TTransactionBase<THive> {\n             return \"BD\";\n         case TTabletTypes::StatisticsAggregator:\n             return \"SA\";\n+        case TTabletTypes::GraphShard:\n+            return \"GS\";\n         default:\n             return Sprintf(\"%d\", (int)type);\n         }\ndiff --git a/ydb/core/protos/counters_schemeshard.proto b/ydb/core/protos/counters_schemeshard.proto\nindex 8b2a205471dd..ffb53502d2e8 100644\n--- a/ydb/core/protos/counters_schemeshard.proto\n+++ b/ydb/core/protos/counters_schemeshard.proto\n@@ -193,6 +193,8 @@ enum ESimpleCounters {\n     COUNTER_IN_FLIGHT_OPS_TxCreateView = 155                [(CounterOpts) = {Name: \"InFlightOps/CreateView\"}];\n     COUNTER_IN_FLIGHT_OPS_TxAlterView = 156                 [(CounterOpts) = {Name: \"InFlightOps/AlterView\"}];\n     COUNTER_IN_FLIGHT_OPS_TxDropView = 157                  [(CounterOpts) = {Name: \"InFlightOps/DropView\"}];\n+\n+    COUNTER_GRAPHSHARD_COUNT = 158 [(CounterOpts) = {Name: \"GraphShards\"}];\n }\n \n enum ECumulativeCounters {\ndiff --git a/ydb/core/protos/flat_tx_scheme.proto b/ydb/core/protos/flat_tx_scheme.proto\nindex 2a7488687896..598bf412cfa7 100644\n--- a/ydb/core/protos/flat_tx_scheme.proto\n+++ b/ydb/core/protos/flat_tx_scheme.proto\n@@ -358,6 +358,7 @@ message TEvSyncTenantSchemeShard {\n     optional uint64 TenantHive = 8;\n     optional uint64 TenantSysViewProcessor = 9;\n     optional uint64 TenantStatisticsAggregator = 11;\n+    optional fixed64 TenantGraphShard = 12;\n \n     optional string TenantRootACL = 10;\n }\n@@ -379,6 +380,7 @@ message TEvUpdateTenantSchemeShard {\n     optional uint64 TenantHive = 10;\n     optional uint64 TenantSysViewProcessor = 11;\n     optional uint64 TenantStatisticsAggregator = 16;\n+    optional fixed64 TenantGraphShard = 18;\n \n     optional NKikimrSubDomains.TSchemeQuotas DeclaredSchemeQuotas = 12;\n     optional Ydb.Cms.DatabaseQuotas DatabaseQuotas = 14;\ndiff --git a/ydb/core/protos/subdomains.proto b/ydb/core/protos/subdomains.proto\nindex cafd60f519c6..e740544f8565 100644\n--- a/ydb/core/protos/subdomains.proto\n+++ b/ydb/core/protos/subdomains.proto\n@@ -25,6 +25,7 @@ message TSubDomainSettings {\n     optional Ydb.Cms.DatabaseQuotas DatabaseQuotas = 12;\n     optional TAuditSettings AuditSettings = 13;\n     optional bool ExternalStatisticsAggregator = 14 [default = false];\n+    optional bool GraphShard = 16 [default = false];\n }\n \n message TProcessingParams {\n@@ -38,8 +39,7 @@ message TProcessingParams {\n     optional fixed64 Hive = 7;\n     optional fixed64 SysViewProcessor = 8;\n     optional fixed64 StatisticsAggregator = 10;\n-\n-    //put there SubSchemeShard and SubHive at the future\n+    optional fixed64 GraphShard = 11;\n \n     // Plan resolution for idle coordinators\n     optional uint64 IdlePlanResolution = 9;\ndiff --git a/ydb/core/protos/tablet.proto b/ydb/core/protos/tablet.proto\nindex 1723064942e4..08903c7d0fbf 100644\n--- a/ydb/core/protos/tablet.proto\n+++ b/ydb/core/protos/tablet.proto\n@@ -48,14 +48,15 @@ message TTabletTypes {\n         ReplicationController = 38;\n         BlobDepot = 39;\n         StatisticsAggregator = 40;\n+        GraphShard = 41;\n \n         // when adding a new tablet type and keeping parse compatibility with the old version\n         // rename existing reserved item to desired one, and add new reserved item to\n         // the end of reserved list\n-        Reserved41 = 41;\n         Reserved42 = 42;\n         Reserved43 = 43;\n         Reserved44 = 44;\n+        Reserved45 = 45;\n \n         UserTypeStart = 255;\n         TypeInvalid = -1;\ndiff --git a/ydb/core/tablet/tablet_counters_app.cpp b/ydb/core/tablet/tablet_counters_app.cpp\nindex bfed7ffd13cb..f3c768574409 100644\n--- a/ydb/core/tablet/tablet_counters_app.cpp\n+++ b/ydb/core/tablet/tablet_counters_app.cpp\n@@ -6,6 +6,7 @@\n #include <ydb/core/protos/counters_datashard.pb.h>\n #include <ydb/core/protos/counters_hive.pb.h>\n #include <ydb/core/protos/counters_kesus.pb.h>\n+#include <ydb/core/graph/shard/protos/counters_shard.pb.h>\n \n namespace NKikimr {\n \n@@ -35,6 +36,12 @@ THolder<TTabletCountersBase> CreateAppCountersByTabletType(TTabletTypes::EType t\n             NKesus::ECumulativeCounters_descriptor,\n             NKesus::EPercentileCounters_descriptor\n         >>();\n+    case TTabletTypes::GraphShard:\n+        return MakeHolder<TAppProtobufTabletCounters<\n+            NGraphShard::ESimpleCounters_descriptor,\n+            NGraphShard::ECumulativeCounters_descriptor,\n+            NGraphShard::EPercentileCounters_descriptor\n+        >>();\n     default:\n         return {};\n     }\ndiff --git a/ydb/core/tablet/ya.make b/ydb/core/tablet/ya.make\nindex 662e29c87583..7013c5cd0897 100644\n--- a/ydb/core/tablet/ya.make\n+++ b/ydb/core/tablet/ya.make\n@@ -64,6 +64,7 @@ PEERDIR(\n     library/cpp/deprecated/enum_codegen\n     library/cpp/yson\n     ydb/core/base\n+    ydb/core/graph/shard/protos\n     ydb/core/mon\n     ydb/core/mon_alloc\n     ydb/core/node_whiteboard\ndiff --git a/ydb/core/tx/schemeshard/schemeshard.h b/ydb/core/tx/schemeshard/schemeshard.h\nindex be4b061765c1..e5f8cfe07d42 100644\n--- a/ydb/core/tx/schemeshard/schemeshard.h\n+++ b/ydb/core/tx/schemeshard/schemeshard.h\n@@ -497,32 +497,38 @@ struct TEvSchemeShard {\n                                                       EvSyncTenantSchemeShard> {\n         TEvSyncTenantSchemeShard() = default;\n \n-        TEvSyncTenantSchemeShard(const TPathId& domainKey,\n-                                 ui64 tabletId,\n-                                 ui64 generation,\n-                                 ui64 effectiveACLVersion,\n-                                 ui64 subdomainVersion,\n-                                 ui64 userAttrsVersion,\n-                                 ui64 tenantHive,\n-                                 ui64 tenantSysViewProcessor,\n-                                 ui64 tenantStatisticsAggregator,\n-                                 const TString& rootACL)\n+        struct TEvSyncTenantSchemeShardInitializer {\n+            TPathId DomainKey;\n+            ui64 TabletId;\n+            ui64 Generation;\n+            ui64 EffectiveACLVersion;\n+            ui64 SubdomainVersion;\n+            ui64 UserAttrsVersion;\n+            ui64 TenantHive;\n+            ui64 TenantSysViewProcessor;\n+            ui64 TenantStatisticsAggregator;\n+            ui64 TenantGraphShard;\n+            TString RootACL;\n+        };\n+\n+        TEvSyncTenantSchemeShard(const TEvSyncTenantSchemeShardInitializer& _)\n         {\n-            Record.SetDomainSchemeShard(domainKey.OwnerId);\n-            Record.SetDomainPathId(domainKey.LocalPathId);\n+            Record.SetDomainSchemeShard(_.DomainKey.OwnerId);\n+            Record.SetDomainPathId(_.DomainKey.LocalPathId);\n \n-            Record.SetTabletID(tabletId);\n-            Record.SetGeneration(generation);\n+            Record.SetTabletID(_.TabletId);\n+            Record.SetGeneration(_.Generation);\n \n-            Record.SetEffectiveACLVersion(effectiveACLVersion);\n-            Record.SetSubdomainVersion(subdomainVersion);\n-            Record.SetUserAttributesVersion(userAttrsVersion);\n+            Record.SetEffectiveACLVersion(_.EffectiveACLVersion);\n+            Record.SetSubdomainVersion(_.SubdomainVersion);\n+            Record.SetUserAttributesVersion(_.UserAttrsVersion);\n \n-            Record.SetTenantHive(tenantHive);\n-            Record.SetTenantSysViewProcessor(tenantSysViewProcessor);\n-            Record.SetTenantStatisticsAggregator(tenantStatisticsAggregator);\n+            Record.SetTenantHive(_.TenantHive);\n+            Record.SetTenantSysViewProcessor(_.TenantSysViewProcessor);\n+            Record.SetTenantStatisticsAggregator(_.TenantStatisticsAggregator);\n+            Record.SetTenantGraphShard(_.TenantGraphShard);\n \n-            Record.SetTenantRootACL(rootACL);\n+            Record.SetTenantRootACL(_.RootACL);\n         }\n \n     };\n@@ -575,6 +581,10 @@ struct TEvSchemeShard {\n         void SetUpdateTenantRootACL(const TString& acl) {\n             Record.SetUpdateTenantRootACL(acl);\n         }\n+\n+        void SetTenantGraphShard(ui64 gs) {\n+            Record.SetTenantGraphShard(gs);\n+        }\n     };\n \n     struct TEvFindTabletSubDomainPathId\ndiff --git a/ydb/core/tx/schemeshard/schemeshard__delete_tablet_reply.cpp b/ydb/core/tx/schemeshard/schemeshard__delete_tablet_reply.cpp\nindex 83b6cd3cce54..18f1881f250f 100644\n--- a/ydb/core/tx/schemeshard/schemeshard__delete_tablet_reply.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard__delete_tablet_reply.cpp\n@@ -107,6 +107,9 @@ struct TSchemeShard::TTxDeleteTabletReply : public TSchemeShard::TRwTxBase {\n             case ETabletType::StatisticsAggregator:\n                 Self->TabletCounters->Simple()[COUNTER_STATISTICS_AGGREGATOR_COUNT].Sub(1);\n                 break;\n+            case ETabletType::GraphShard:\n+                Self->TabletCounters->Simple()[COUNTER_GRAPHSHARD_COUNT].Sub(1);\n+                break;\n             default:\n                 Y_FAIL_S(\"Unknown TabletType\"\n                          << \", ShardIdx \" << ShardIdx\ndiff --git a/ydb/core/tx/schemeshard/schemeshard__init.cpp b/ydb/core/tx/schemeshard/schemeshard__init.cpp\nindex eb877822b0bc..10ec3bdf51d1 100644\n--- a/ydb/core/tx/schemeshard/schemeshard__init.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard__init.cpp\n@@ -3923,6 +3923,9 @@ struct TSchemeShard::TTxInit : public TTransactionBase<TSchemeShard> {\n             case ETabletType::StatisticsAggregator:\n                 Self->TabletCounters->Simple()[COUNTER_STATISTICS_AGGREGATOR_COUNT].Add(1);\n                 break;\n+            case ETabletType::GraphShard:\n+                Self->TabletCounters->Simple()[COUNTER_GRAPHSHARD_COUNT].Add(1);\n+                break;\n             default:\n                 Y_FAIL_S(\"dont know how to interpret tablet type\"\n                          << \", type id: \" << (ui32)si.second.TabletType\ndiff --git a/ydb/core/tx/schemeshard/schemeshard__init_root.cpp b/ydb/core/tx/schemeshard/schemeshard__init_root.cpp\nindex 6b9d51a8b4a6..908784e3f2c7 100644\n--- a/ydb/core/tx/schemeshard/schemeshard__init_root.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard__init_root.cpp\n@@ -399,7 +399,7 @@ struct TSchemeShard::TTxInitTenantSchemeShard : public TSchemeShard::TRwTxBase {\n         if (record.HasServerlessComputeResourcesMode()) {\n             subdomain->SetServerlessComputeResourcesMode(record.GetServerlessComputeResourcesMode());\n         }\n-        \n+\n         RegisterShard(db, subdomain, processingParams.GetCoordinators(), TTabletTypes::Coordinator);\n         RegisterShard(db, subdomain, processingParams.GetMediators(), TTabletTypes::Mediator);\n         RegisterShard(db, subdomain, TVector<ui64>{processingParams.GetSchemeShard()}, TTabletTypes::SchemeShard);\n@@ -412,6 +412,9 @@ struct TSchemeShard::TTxInitTenantSchemeShard : public TSchemeShard::TRwTxBase {\n         if (processingParams.HasStatisticsAggregator()) {\n             RegisterShard(db, subdomain, TVector<ui64>{processingParams.GetStatisticsAggregator()}, TTabletTypes::StatisticsAggregator);\n         }\n+        if (processingParams.HasGraphShard()) {\n+            RegisterShard(db, subdomain, TVector<ui64>{processingParams.GetGraphShard()}, TTabletTypes::GraphShard);\n+        }\n \n         subdomain->Initialize(Self->ShardInfos);\n \ndiff --git a/ydb/core/tx/schemeshard/schemeshard__operation_alter_extsubdomain.cpp b/ydb/core/tx/schemeshard/schemeshard__operation_alter_extsubdomain.cpp\nindex 3150caded05a..5a4f9c88152c 100644\n--- a/ydb/core/tx/schemeshard/schemeshard__operation_alter_extsubdomain.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard__operation_alter_extsubdomain.cpp\n@@ -37,6 +37,7 @@ struct TParamsDelta {\n     uint8_t AddExternalHive = 0;\n     uint8_t AddExternalSysViewProcessor = 0;\n     uint8_t AddExternalStatisticsAggregator = 0;\n+    uint8_t AddGraphShard = 0;\n     bool SharedTxSupportAdded = false;\n     TVector<TStoragePool> StoragePoolsAdded;\n };\n@@ -188,6 +189,21 @@ VerifyParams(TParamsDelta* delta, const TPathId pathId, const TSubDomainInfo::TP\n         }\n     }\n \n+    // GraphShard checks\n+    uint8_t addGraphShard = 0;\n+    if (input.GetGraphShard()) {\n+        const bool prev = bool(current->GetTenantGraphShardID());\n+        const bool next = input.GetGraphShard();\n+        const bool changed = (prev != next);\n+\n+        if (changed) {\n+            if (next == false) {\n+                return paramError(\"GraphShard could only be added, not removed\");\n+            }\n+            addGraphShard = 1;\n+        }\n+    }\n+\n     // Second params check: combinations\n \n     bool sharedTxSupportAdded = (coordinatorsAdded + mediatorsAdded) > 0;\n@@ -271,6 +287,7 @@ VerifyParams(TParamsDelta* delta, const TPathId pathId, const TSubDomainInfo::TP\n     delta->AddExternalHive = addExternalHive;\n     delta->AddExternalSysViewProcessor = addExternalSysViewProcessor;\n     delta->AddExternalStatisticsAggregator = addExternalStatisticsAggregator;\n+    delta->AddGraphShard = addGraphShard;\n     delta->SharedTxSupportAdded = sharedTxSupportAdded;\n     delta->StoragePoolsAdded = std::move(storagePoolsAdded);\n \n@@ -780,7 +797,7 @@ class TAlterExtSubDomain: public TSubOperation {\n \n         //NOTE: ExternalHive, ExternalSysViewProcessor and ExternalStatisticsAggregator are _not_ counted against limits\n         ui64 tabletsToCreateUnderLimit = delta.AddExternalSchemeShard + delta.CoordinatorsAdded + delta.MediatorsAdded;\n-        ui64 tabletsToCreateOverLimit = delta.AddExternalSysViewProcessor + delta.AddExternalStatisticsAggregator;\n+        ui64 tabletsToCreateOverLimit = delta.AddExternalSysViewProcessor + delta.AddExternalStatisticsAggregator + delta.AddGraphShard;\n         ui64 tabletsToCreateTotal = tabletsToCreateUnderLimit + tabletsToCreateOverLimit;\n \n         // Check path limits\n@@ -857,7 +874,8 @@ class TAlterExtSubDomain: public TSubOperation {\n                 delta.AddExternalSchemeShard ||\n                 delta.AddExternalSysViewProcessor ||\n                 delta.AddExternalHive ||\n-                delta.AddExternalStatisticsAggregator)\n+                delta.AddExternalStatisticsAggregator ||\n+                delta.AddGraphShard)\n             {\n                 if (!context.SS->ResolveSubdomainsChannels(alter->GetStoragePools(), channelsBinding)) {\n                     result->SetError(NKikimrScheme::StatusInvalidParameter, \"failed to construct channels binding\");\n@@ -866,8 +884,8 @@ class TAlterExtSubDomain: public TSubOperation {\n             }\n \n             // Declare shards.\n-            // - hive always come first (OwnerIdx 1)\n-            // - schemeshard always come second (OwnerIdx 2)\n+            // - hive always comes first (OwnerIdx 1)\n+            // - schemeshard always comes second (OwnerIdx 2)\n             // - others follow\n             //\n             if (delta.AddExternalHive && !context.SS->EnableAlterDatabaseCreateHiveFirst) {\n@@ -887,6 +905,9 @@ class TAlterExtSubDomain: public TSubOperation {\n             if (delta.AddExternalStatisticsAggregator) {\n                 AddShardsTo(txState, OperationId.GetTxId(), basenameId, 1, TTabletTypes::StatisticsAggregator, channelsBinding, context.SS);\n             }\n+            if (delta.AddGraphShard) {\n+                AddShardsTo(txState, OperationId.GetTxId(), basenameId, 1, TTabletTypes::GraphShard, channelsBinding, context.SS);\n+            }\n             Y_ABORT_UNLESS(txState.Shards.size() == tabletsToCreateTotal);\n         }\n \ndiff --git a/ydb/core/tx/schemeshard/schemeshard__operation_common_subdomain.h b/ydb/core/tx/schemeshard/schemeshard__operation_common_subdomain.h\nindex 9f4cf9b22cde..1048d07c1040 100644\n--- a/ydb/core/tx/schemeshard/schemeshard__operation_common_subdomain.h\n+++ b/ydb/core/tx/schemeshard/schemeshard__operation_common_subdomain.h\n@@ -258,6 +258,16 @@ class TConfigureParts: public TSubOperationState {\n                 context.OnComplete.BindMsgToPipe(OperationId, tabletID, idx, event);\n                 break;\n             }\n+            case ETabletType::GraphShard: {\n+                LOG_DEBUG_S(context.Ctx, NKikimrServices::FLAT_TX_SCHEMESHARD,\n+                    \"Send configure request to graph shard: \" << tabletID <<\n+                    \" opId: \" << OperationId <<\n+                    \" schemeshard: \" << ssId);\n+                shard.Operation = TTxState::ConfigureParts;\n+                auto event = new TEvSubDomain::TEvConfigure(processing);\n+                context.OnComplete.BindMsgToPipe(OperationId, tabletID, idx, event);\n+                break;\n+            }\n             default:\n                 Y_FAIL_S(\"Unexpected type, we don't create tablets with type \" << ETabletType::TypeToStr(type));\n             }\ndiff --git a/ydb/core/tx/schemeshard/schemeshard__operation_side_effects.cpp b/ydb/core/tx/schemeshard/schemeshard__operation_side_effects.cpp\nindex 5f5022967f46..843fe9805593 100644\n--- a/ydb/core/tx/schemeshard/schemeshard__operation_side_effects.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard__operation_side_effects.cpp\n@@ -525,6 +525,11 @@ void TSideEffects::DoUpdateTenant(TSchemeShard* ss, NTabletFlatExecutor::TTransa\n             }\n         }\n \n+        if (!tenantLink.TenantGraphShard && subDomain->GetTenantGraphShardID()) {\n+            message->SetTenantGraphShard(ui64(subDomain->GetTenantGraphShardID()));\n+            hasChanges = true;\n+        }\n+\n         if (!hasChanges) {\n             LOG_INFO_S(ctx, NKikimrServices::FLAT_TX_SCHEMESHARD,\n                        \"DoUpdateTenant no hasChanges\"\ndiff --git a/ydb/core/tx/schemeshard/schemeshard__sync_update_tenants.cpp b/ydb/core/tx/schemeshard/schemeshard__sync_update_tenants.cpp\nindex 9d75aacb1f23..dc87be3b16ea 100644\n--- a/ydb/core/tx/schemeshard/schemeshard__sync_update_tenants.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard__sync_update_tenants.cpp\n@@ -192,6 +192,14 @@ struct TSchemeShard::TTxUpdateTenant : public TSchemeShard::TRwTxBase {\n             Y_ABORT_UNLESS(tenantSA == subdomain->GetTenantStatisticsAggregatorID());\n         }\n \n+        if (record.HasTenantGraphShard()) {\n+            TTabletId tenantGS = TTabletId(record.GetTenantGraphShard());\n+            if (!subdomain->GetTenantGraphShardID()) {\n+                addPrivateShard(tenantGS, ETabletType::GraphShard);\n+            }\n+            Y_ABORT_UNLESS(tenantGS == subdomain->GetTenantGraphShardID());\n+        }\n+\n         if (record.HasUpdateTenantRootACL()) {\n             // KIKIMR-10699: transfer tenants root ACL from GSS to the TSS\n             // here TSS sees the ACL from GSS\ndiff --git a/ydb/core/tx/schemeshard/schemeshard_domain_links.cpp b/ydb/core/tx/schemeshard/schemeshard_domain_links.cpp\nindex 299ab2918594..35e50d05b282 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_domain_links.cpp\n+++ b/ydb/core/tx/schemeshard/schemeshard_domain_links.cpp\n@@ -20,16 +20,20 @@ THolder<TEvSchemeShard::TEvSyncTenantSchemeShard> TParentDomainLink::MakeSyncMsg\n     Y_ABORT_UNLESS(Self->PathsById.contains(Self->RootPathId()));\n     auto& rootSubdomain = Self->SubDomains.at(Self->RootPathId());\n \n-    return MakeHolder<TEvSchemeShard::TEvSyncTenantSchemeShard>(Self->ParentDomainId,\n-                                                                    Self->TabletID(),\n-                                                                    Self->Generation(),\n-                                                                    Self->ParentDomainEffectiveACLVersion,\n-                                                                    rootSubdomain->GetVersion(),\n-                                                                    rootPath->UserAttrs->AlterVersion,\n-                                                                    ui64(rootSubdomain->GetTenantHiveID()),\n-                                                                    ui64(rootSubdomain->GetTenantSysViewProcessorID()),\n-                                                                    ui64(rootSubdomain->GetTenantStatisticsAggregatorID()),\n-                                                                    rootPath->ACL);\n+    TEvSchemeShard::TEvSyncTenantSchemeShard* ptr = new TEvSchemeShard::TEvSyncTenantSchemeShard({\n+        .DomainKey = Self->ParentDomainId,\n+        .TabletId = Self->TabletID(),\n+        .Generation = Self->Generation(),\n+        .EffectiveACLVersion = Self->ParentDomainEffectiveACLVersion,\n+        .SubdomainVersion = rootSubdomain->GetVersion(),\n+        .UserAttrsVersion = rootPath->UserAttrs->AlterVersion,\n+        .TenantHive = ui64(rootSubdomain->GetTenantHiveID()),\n+        .TenantSysViewProcessor = ui64(rootSubdomain->GetTenantSysViewProcessorID()),\n+        .TenantStatisticsAggregator = ui64(rootSubdomain->GetTenantStatisticsAggregatorID()),\n+        .TenantGraphShard = ui64(rootSubdomain->GetTenantGraphShardID()),\n+        .RootACL = rootPath->ACL\n+    });\n+    return THolder<TEvSchemeShard::TEvSyncTenantSchemeShard>(ptr);\n }\n \n void TParentDomainLink::SendSync(const TActorContext &ctx) {\n@@ -109,6 +113,7 @@ void TSubDomainsLinks::TLink::Out(IOutputStream& stream) const {\n            << \", TenantHive: \" << TenantHive\n            << \", TenantSysViewProcessor: \" << TenantSysViewProcessor\n            << \", TenantStatisticsAggregator: \" << TenantStatisticsAggregator\n+           << \", TenantGraphShard: \" << TenantGraphShard\n            << \", TenantRootACL: \" << TenantRootACL\n            << \"}\";\n }\n@@ -125,6 +130,8 @@ TSubDomainsLinks::TLink::TLink(const NKikimrScheme::TEvSyncTenantSchemeShard &re\n         TTabletId(record.GetTenantSysViewProcessor()) : InvalidTabletId)\n     , TenantStatisticsAggregator(record.HasTenantStatisticsAggregator() ?\n         TTabletId(record.GetTenantStatisticsAggregator()) : InvalidTabletId)\n+    , TenantGraphShard(record.HasTenantGraphShard() ?\n+        TTabletId(record.GetTenantGraphShard()) : InvalidTabletId)\n     , TenantRootACL(record.GetTenantRootACL())\n {}\n \ndiff --git a/ydb/core/tx/schemeshard/schemeshard_domain_links.h b/ydb/core/tx/schemeshard/schemeshard_domain_links.h\nindex fa207d179202..a7fda70dfd2b 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_domain_links.h\n+++ b/ydb/core/tx/schemeshard/schemeshard_domain_links.h\n@@ -42,6 +42,7 @@ class TSubDomainsLinks {\n         TTabletId TenantHive = InvalidTabletId;\n         TTabletId TenantSysViewProcessor = InvalidTabletId;\n         TTabletId TenantStatisticsAggregator = InvalidTabletId;\n+        TTabletId TenantGraphShard = InvalidTabletId;\n         TString TenantRootACL;\n \n         TLink() = default;\ndiff --git a/ydb/core/tx/schemeshard/schemeshard_info_types.h b/ydb/core/tx/schemeshard/schemeshard_info_types.h\nindex e9cceb6ae359..e7cd70eddaf9 100644\n--- a/ydb/core/tx/schemeshard/schemeshard_info_types.h\n+++ b/ydb/core/tx/schemeshard/schemeshard_info_types.h\n@@ -1576,6 +1576,13 @@ struct TSubDomainInfo: TSimpleRefCount<TSubDomainInfo> {\n         return TTabletId(ProcessingParams.GetStatisticsAggregator());\n     }\n \n+    TTabletId GetTenantGraphShardID() const {\n+        if (!ProcessingParams.HasGraphShard()) {\n+            return InvalidTabletId;\n+        }\n+        return TTabletId(ProcessingParams.GetGraphShard());\n+    }\n+\n     ui64 GetPathsInside() const {\n         return PathsInsideCount;\n     }\n@@ -1953,6 +1960,13 @@ struct TSubDomainInfo: TSimpleRefCount<TSubDomainInfo> {\n         if (statisticsAggregators.size()) {\n             ProcessingParams.SetStatisticsAggregator(ui64(statisticsAggregators.front()));\n         }\n+\n+        ProcessingParams.ClearGraphShard();\n+        TVector<TTabletId> graphs = FilterPrivateTablets(ETabletType::GraphShard, allShards);\n+        Y_VERIFY_S(graphs.size() <= 1, \"size was: \" << graphs.size());\n+        if (graphs.size()) {\n+            ProcessingParams.SetGraphShard(ui64(graphs.front()));\n+        }\n     }\n \n     void InitializeAsGlobal(NKikimrSubDomains::TProcessingParams&& processingParams) {\ndiff --git a/ydb/core/tx/schemeshard/ut_base/ut_base.cpp b/ydb/core/tx/schemeshard/ut_base/ut_base.cpp\nindex aae3cefa646d..5b58e11db1c5 100644\n--- a/ydb/core/tx/schemeshard/ut_base/ut_base.cpp\n+++ b/ydb/core/tx/schemeshard/ut_base/ut_base.cpp\n@@ -144,7 +144,7 @@ Y_UNIT_TEST_SUITE(TSchemeShardTest) {\n         ~TLocaleGuard() {\n             std::locale::global(OriginalLocale_);\n         }\n-    \n+\n     private:\n         const std::locale OriginalLocale_;\n     };\ndiff --git a/ydb/core/viewer/json_graph.h b/ydb/core/viewer/json_graph.h\nnew file mode 100644\nindex 000000000000..05b86088d08b\n--- /dev/null\n+++ b/ydb/core/viewer/json_graph.h\n@@ -0,0 +1,172 @@\n+#pragma once\n+#include <ydb/library/actors/core/actor_bootstrapped.h>\n+#include <ydb/library/actors/core/mon.h>\n+#include <ydb/core/graph/api/service.h>\n+#include <ydb/core/graph/api/events.h>\n+#include <library/cpp/json/json_writer.h>\n+#include \"viewer.h\"\n+#include \"log.h\"\n+\n+namespace NKikimr {\n+namespace NViewer {\n+\n+using namespace NActors;\n+\n+class TJsonGraph : public TActorBootstrapped<TJsonGraph> {\n+    IViewer* Viewer;\n+    NMon::TEvHttpInfo::TPtr Event;\n+    std::vector<TString> Metrics;\n+\n+public:\n+    static constexpr NKikimrServices::TActivity::EType ActorActivityType() {\n+        return NKikimrServices::TActivity::VIEWER_HANDLER;\n+    }\n+\n+    TJsonGraph(IViewer* viewer, NMon::TEvHttpInfo::TPtr &ev)\n+        : Viewer(viewer)\n+        , Event(ev)\n+    {}\n+\n+    void Bootstrap() {\n+        BLOG_TRACE(\"Graph received request for \" << Event->Get()->Request.GetUri());\n+        const auto& params(Event->Get()->Request.GetParams());\n+        NKikimrGraph::TEvGetMetrics getRequest;\n+        if (params.Has(\"target\")) {\n+            StringSplitter(params.Get(\"target\")).Split(',').SkipEmpty().Collect(&Metrics);\n+            for (const auto& metric : Metrics) {\n+                getRequest.AddMetrics(metric);\n+            }\n+        } else {\n+            Send(Event->Sender, new NMon::TEvHttpInfoRes(Viewer->GetHTTPBADREQUEST(Event->Get(), {}, \"Bad Request\"), 0, NMon::IEvHttpInfoRes::EContentType::Custom));\n+            return PassAway();\n+        }\n+        if (params.Has(\"from\")) {\n+            getRequest.SetTimeFrom(FromStringWithDefault<ui32>(params.Get(\"from\")));\n+        }\n+        if (params.Has(\"until\")) {\n+            getRequest.SetTimeTo(FromStringWithDefault<ui32>(params.Get(\"until\")));\n+        }\n+        if (params.Has(\"maxDataPoints\")) {\n+            getRequest.SetMaxPoints(FromStringWithDefault<ui32>(params.Get(\"maxDataPoints\"), 1000));\n+        }\n+        Send(NGraph::MakeGraphServiceId(), new NGraph::TEvGraph::TEvGetMetrics(std::move(getRequest)));\n+        Schedule(TDuration::Seconds(30), new TEvents::TEvWakeup());\n+        Become(&TThis::StateWork);\n+    }\n+\n+    STATEFN(StateWork) {\n+        switch (ev->GetTypeRewrite()) {\n+            hFunc(NGraph::TEvGraph::TEvMetricsResult, Handle);\n+            cFunc(TEvents::TSystem::Wakeup, Timeout);\n+        }\n+    }\n+\n+    void Handle(NGraph::TEvGraph::TEvMetricsResult::TPtr& ev) {\n+        const auto& params(Event->Get()->Request.GetParams());\n+        const auto& response(ev->Get()->Record);\n+        NJson::TJsonValue json;\n+\n+        if (response.GetError()) {\n+            json[\"status\"] = \"error\";\n+            json[\"error\"] = response.GetError();\n+            Send(Event->Sender, new NMon::TEvHttpInfoRes(Viewer->GetHTTPOKJSON(Event->Get()) + NJson::WriteJson(json, false), 0, NMon::IEvHttpInfoRes::EContentType::Custom));\n+            return PassAway();\n+        }\n+        if (response.DataSize() != Metrics.size()) {\n+            json[\"status\"] = \"error\";\n+            json[\"error\"] = \"Invalid data size received\";\n+            Send(Event->Sender, new NMon::TEvHttpInfoRes(Viewer->GetHTTPOKJSON(Event->Get()) + NJson::WriteJson(json, false), 0, NMon::IEvHttpInfoRes::EContentType::Custom));\n+            return PassAway();\n+        }\n+        for (size_t nMetric = 0; nMetric < response.DataSize(); ++nMetric) {\n+            const auto& protoMetric(response.GetData(nMetric));\n+            if (response.TimeSize() != protoMetric.ValuesSize()) {\n+                json[\"status\"] = \"error\";\n+                json[\"error\"] = \"Invalid value size received\";\n+                Send(Event->Sender, new NMon::TEvHttpInfoRes(Viewer->GetHTTPOKJSON(Event->Get()) + NJson::WriteJson(json, false), 0, NMon::IEvHttpInfoRes::EContentType::Custom));\n+                return PassAway();\n+            }\n+        }\n+        if (!params.Has(\"format\") || params.Get(\"format\") == \"graphite\") { // graphite\n+            json.SetType(NJson::JSON_ARRAY);\n+            for (size_t nMetric = 0; nMetric < response.DataSize(); ++nMetric) {\n+                const auto& protoMetric(response.GetData(nMetric));\n+                NJson::TJsonValue& jsonMetric(json.AppendValue({}));\n+                jsonMetric[\"target\"] = Metrics[nMetric];\n+                jsonMetric[\"title\"] = Metrics[nMetric];\n+                jsonMetric[\"tags\"][\"name\"] = Metrics[nMetric];\n+                NJson::TJsonValue& jsonDataPoints(jsonMetric[\"datapoints\"]);\n+                jsonDataPoints.SetType(NJson::JSON_ARRAY);\n+                for (size_t nTime = 0; nTime < response.TimeSize(); ++nTime) {\n+                    NJson::TJsonValue& jsonDataPoint(jsonDataPoints.AppendValue({}));\n+                    jsonDataPoint.AppendValue(response.GetTime(nTime));\n+                    double value = protoMetric.GetValues(nTime);\n+                    if (isnan(value)) {\n+                        jsonDataPoint.AppendValue(NJson::TJsonValue(NJson::JSON_NULL));\n+                    } else {\n+                        jsonDataPoint.AppendValue(value);\n+                    }\n+                }\n+            }\n+        } else { // prometheus\n+            json[\"status\"] = \"success\";\n+            NJson::TJsonValue& jsonData(json[\"data\"]);\n+            jsonData[\"resultType\"] = \"matrix\";\n+            NJson::TJsonValue& jsonResults(jsonData[\"result\"]);\n+            jsonResults.SetType(NJson::JSON_ARRAY);\n+            for (size_t nMetric = 0; nMetric < response.DataSize(); ++nMetric) {\n+                const auto& protoMetric(response.GetData(nMetric));\n+                NJson::TJsonValue& jsonResult(jsonResults.AppendValue({}));\n+                jsonResult[\"metric\"][\"__name__\"] = Metrics[nMetric];\n+                NJson::TJsonValue& jsonValues(jsonResult[\"values\"]);\n+                jsonValues.SetType(NJson::JSON_ARRAY);\n+                for (size_t nTime = 0; nTime < response.TimeSize(); ++nTime) {\n+                    NJson::TJsonValue& jsonDataPoint(jsonValues.AppendValue({}));\n+                    jsonDataPoint.AppendValue(response.GetTime(nTime));\n+                    double value = protoMetric.GetValues(nTime);\n+                    if (isnan(value)) {\n+                        jsonDataPoint.AppendValue(NJson::TJsonValue(NJson::JSON_NULL));\n+                    } else {\n+                        jsonDataPoint.AppendValue(value);\n+                    }\n+                }\n+            }\n+        }\n+\n+        Send(Event->Sender, new NMon::TEvHttpInfoRes(Viewer->GetHTTPOKJSON(Event->Get()) + NJson::WriteJson(json, false), 0, NMon::IEvHttpInfoRes::EContentType::Custom));\n+        PassAway();\n+    }\n+\n+    void Timeout() {\n+        Send(Event->Sender, new NMon::TEvHttpInfoRes(Viewer->GetHTTPGATEWAYTIMEOUT(Event->Get()), 0, NMon::IEvHttpInfoRes::EContentType::Custom));\n+        PassAway();\n+    }\n+};\n+\n+template <>\n+struct TJsonRequestParameters<TJsonGraph> {\n+    static TString GetParameters() {\n+        return R\"___([{\"name\":\"target\",\"in\":\"query\",\"description\":\"metrics comma delimited\",\"required\":true,\"type\":\"string\"},\n+                      {\"name\":\"from\",\"in\":\"query\",\"description\":\"time in seconds\",\"required\":false,\"type\":\"integer\"},\n+                      {\"name\":\"until\",\"in\":\"query\",\"description\":\"time in seconds\",\"required\":false,\"type\":\"integer\"},\n+                      {\"name\":\"maxDataPoints\",\"in\":\"query\",\"description\":\"maximum number of data points\",\"required\":false,\"type\":\"integer\"},\n+                      {\"name\":\"format\",\"in\":\"query\",\"description\":\"response format, could be prometheus or graphite\",\"required\":false,\"type\":\"string\"}])___\";\n+    }\n+};\n+\n+template <>\n+struct TJsonRequestSummary<TJsonGraph> {\n+    static TString GetSummary() {\n+        return \"\\\"Graph data\\\"\";\n+    }\n+};\n+\n+template <>\n+struct TJsonRequestDescription<TJsonGraph> {\n+    static TString GetDescription() {\n+        return \"\\\"Returns graph data\\\"\";\n+    }\n+};\n+\n+}\n+}\ndiff --git a/ydb/core/viewer/json_handlers_viewer.cpp b/ydb/core/viewer/json_handlers_viewer.cpp\nindex 3b5e219e4654..0ade1a646182 100644\n--- a/ydb/core/viewer/json_handlers_viewer.cpp\n+++ b/ydb/core/viewer/json_handlers_viewer.cpp\n@@ -36,6 +36,8 @@\n #include \"json_healthcheck.h\"\n #include \"json_nodes.h\"\n #include \"json_acl.h\"\n+#include \"json_graph.h\"\n+#include \"json_render.h\"\n \n namespace NKikimr::NViewer {\n \n@@ -76,4 +78,6 @@ void TViewerJsonHandlers::Init() {\n     JsonHandlers[\"/json/healthcheck\"] = new TJsonHandler<TJsonHealthCheck>;\n     JsonHandlers[\"/json/nodes\"] = new TJsonHandler<TJsonNodes>;\n     JsonHandlers[\"/json/acl\"] = new TJsonHandler<TJsonACL>;\n+    JsonHandlers[\"/json/graph\"] = new TJsonHandler<TJsonGraph>;\n+    JsonHandlers[\"/json/render\"] = new TJsonHandler<TJsonRender>;\n }}\ndiff --git a/ydb/core/viewer/json_render.h b/ydb/core/viewer/json_render.h\nnew file mode 100644\nindex 000000000000..83fdb356a35d\n--- /dev/null\n+++ b/ydb/core/viewer/json_render.h\n@@ -0,0 +1,158 @@\n+#pragma once\n+#include <ydb/library/actors/core/actor_bootstrapped.h>\n+#include <ydb/library/actors/core/mon.h>\n+#include <ydb/core/graph/api/service.h>\n+#include <ydb/core/graph/api/events.h>\n+#include <library/cpp/json/json_writer.h>\n+#include \"viewer.h\"\n+#include \"log.h\"\n+\n+namespace NKikimr {\n+namespace NViewer {\n+\n+using namespace NActors;\n+\n+class TJsonRender : public TActorBootstrapped<TJsonRender> {\n+    IViewer* Viewer;\n+    NMon::TEvHttpInfo::TPtr Event;\n+    std::vector<TString> Metrics;\n+\n+public:\n+    static constexpr NKikimrServices::TActivity::EType ActorActivityType() {\n+        return NKikimrServices::TActivity::VIEWER_HANDLER;\n+    }\n+\n+    TJsonRender(IViewer* viewer, NMon::TEvHttpInfo::TPtr &ev)\n+        : Viewer(viewer)\n+        , Event(ev)\n+    {}\n+\n+    void Bootstrap() {\n+        auto postData = Event->Get()->Request.GetPostContent();\n+        BLOG_D(\"PostData=\" << postData);\n+        NKikimrGraph::TEvGetMetrics getRequest;\n+        if (postData) {\n+            TCgiParameters params(postData);\n+            if (params.Has(\"target\")) {\n+                StringSplitter(params.Get(\"target\")).Split(',').SkipEmpty().Collect(&Metrics);\n+                for (const auto& metric : Metrics) {\n+                    getRequest.AddMetrics(metric);\n+                }\n+            } else {\n+                static const TString png1x1 = \"\\x89\\x50\\x4e\\x47\\x0d\\x0a\\x1a\\x0a\\x00\\x00\\x00\\x0d\\x49\\x48\\x44\\x52\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\x01\"\n+                                            \"\\x03\\x00\\x00\\x00\\x25\\xdb\\x56\\xca\\x00\\x00\\x00\\x03\\x50\\x4c\\x54\\x45\\x00\\x00\\x00\\xa7\\x7a\\x3d\\xda\\x00\\x00\"\n+                                            \"\\x00\\x01\\x74\\x52\\x4e\\x53\\x00\\x40\\xe6\\xd8\\x66\\x00\\x00\\x00\\x0a\\x49\\x44\\x41\\x54\\x08\\xd7\\x63\\x60\\x00\\x00\"\n+                                            \"\\x00\\x02\\x00\\x01\\xe2\\x21\\xbc\\x33\\x00\\x00\\x00\\x00\\x49\\x45\\x4e\\x44\\xae\\x42\\x60\\x82\";\n+                Send(Event->Sender, new NMon::TEvHttpInfoRes(Viewer->GetHTTPOK(Event->Get(), \"image/png\", png1x1), 0, NMon::IEvHttpInfoRes::EContentType::Custom));\n+                return PassAway();\n+            }\n+            if (params.Has(\"from\")) {\n+                getRequest.SetTimeFrom(FromStringWithDefault<ui32>(params.Get(\"from\")));\n+            }\n+            if (params.Has(\"until\")) {\n+                getRequest.SetTimeTo(FromStringWithDefault<ui32>(params.Get(\"until\")));\n+            }\n+            if (params.Has(\"maxDataPoints\")) {\n+                getRequest.SetMaxPoints(FromStringWithDefault<ui32>(params.Get(\"maxDataPoints\"), 1000));\n+            }\n+        } else {\n+            Send(Event->Sender, new NMon::TEvHttpInfoRes(Viewer->GetHTTPBADREQUEST(Event->Get(), {}, \"Bad Request\"), 0, NMon::IEvHttpInfoRes::EContentType::Custom));\n+            return PassAway();\n+        }\n+        Send(NGraph::MakeGraphServiceId(), new NGraph::TEvGraph::TEvGetMetrics(std::move(getRequest)));\n+        Schedule(TDuration::Seconds(30), new TEvents::TEvWakeup());\n+        Become(&TThis::StateWork);\n+    }\n+\n+    STATEFN(StateWork) {\n+        switch (ev->GetTypeRewrite()) {\n+            hFunc(NGraph::TEvGraph::TEvMetricsResult, Handle);\n+            cFunc(TEvents::TSystem::Wakeup, Timeout);\n+        }\n+    }\n+\n+    void Handle(NGraph::TEvGraph::TEvMetricsResult::TPtr& ev) {\n+        const auto& response(ev->Get()->Record);\n+        NJson::TJsonValue json;\n+\n+        if (response.GetError()) {\n+            json[\"status\"] = \"error\";\n+            json[\"error\"] = response.GetError();\n+            Send(Event->Sender, new NMon::TEvHttpInfoRes(Viewer->GetHTTPOKJSON(Event->Get()) + NJson::WriteJson(json, false), 0, NMon::IEvHttpInfoRes::EContentType::Custom));\n+            return PassAway();\n+        }\n+        if (response.DataSize() != Metrics.size()) {\n+            json[\"status\"] = \"error\";\n+            json[\"error\"] = \"Invalid data size received\";\n+            Send(Event->Sender, new NMon::TEvHttpInfoRes(Viewer->GetHTTPOKJSON(Event->Get()) + NJson::WriteJson(json, false), 0, NMon::IEvHttpInfoRes::EContentType::Custom));\n+            return PassAway();\n+        }\n+        for (size_t nMetric = 0; nMetric < response.DataSize(); ++nMetric) {\n+            const auto& protoMetric(response.GetData(nMetric));\n+            if (response.TimeSize() != protoMetric.ValuesSize()) {\n+                json[\"status\"] = \"error\";\n+                json[\"error\"] = \"Invalid value size received\";\n+                Send(Event->Sender, new NMon::TEvHttpInfoRes(Viewer->GetHTTPOKJSON(Event->Get()) + NJson::WriteJson(json, false), 0, NMon::IEvHttpInfoRes::EContentType::Custom));\n+                return PassAway();\n+            }\n+        }\n+        { // graphite\n+            json.SetType(NJson::JSON_ARRAY);\n+            for (size_t nMetric = 0; nMetric < response.DataSize(); ++nMetric) {\n+                const auto& protoMetric(response.GetData(nMetric));\n+                NJson::TJsonValue& jsonMetric(json.AppendValue({}));\n+                jsonMetric[\"target\"] = Metrics[nMetric];\n+                jsonMetric[\"title\"] = Metrics[nMetric];\n+                jsonMetric[\"tags\"][\"name\"] = Metrics[nMetric];\n+                NJson::TJsonValue& jsonDataPoints(jsonMetric[\"datapoints\"]);\n+                jsonDataPoints.SetType(NJson::JSON_ARRAY);\n+                for (size_t nTime = 0; nTime < response.TimeSize(); ++nTime) {\n+                    NJson::TJsonValue& jsonDataPoint(jsonDataPoints.AppendValue({}));\n+                    double value = protoMetric.GetValues(nTime);\n+                    if (isnan(value)) {\n+                        jsonDataPoint.AppendValue(NJson::TJsonValue(NJson::JSON_NULL));\n+                    } else {\n+                        jsonDataPoint.AppendValue(value);\n+                    }\n+                    jsonDataPoint.AppendValue(response.GetTime(nTime));\n+                }\n+            }\n+        }\n+\n+        Send(Event->Sender, new NMon::TEvHttpInfoRes(Viewer->GetHTTPOKJSON(Event->Get()) + NJson::WriteJson(json, false), 0, NMon::IEvHttpInfoRes::EContentType::Custom));\n+        PassAway();\n+    }\n+\n+    void Timeout() {\n+        Send(Event->Sender, new NMon::TEvHttpInfoRes(Viewer->GetHTTPGATEWAYTIMEOUT(Event->Get()), 0, NMon::IEvHttpInfoRes::EContentType::Custom));\n+        PassAway();\n+    }\n+};\n+\n+template <>\n+struct TJsonRequestParameters<TJsonRender> {\n+    static TString GetParameters() {\n+        return R\"___([{\"name\":\"target\",\"in\":\"query\",\"description\":\"metrics comma delimited\",\"required\":true,\"type\":\"string\"},\n+                      {\"name\":\"from\",\"in\":\"query\",\"description\":\"time in seconds\",\"required\":false,\"type\":\"integer\"},\n+                      {\"name\":\"until\",\"in\":\"query\",\"description\":\"time in seconds\",\"required\":false,\"type\":\"integer\"},\n+                      {\"name\":\"maxDataPoints\",\"in\":\"query\",\"description\":\"maximum number of data points\",\"required\":false,\"type\":\"integer\"},\n+                      {\"name\":\"format\",\"in\":\"query\",\"description\":\"response format\",\"required\":false,\"type\":\"string\"}])___\";\n+    }\n+};\n+\n+template <>\n+struct TJsonRequestSummary<TJsonRender> {\n+    static TString GetSummary() {\n+        return \"\\\"Graph data\\\"\";\n+    }\n+};\n+\n+template <>\n+struct TJsonRequestDescription<TJsonRender> {\n+    static TString GetDescription() {\n+        return \"\\\"Returns graph data in graphite format\\\"\";\n+    }\n+};\n+\n+}\n+}\ndiff --git a/ydb/core/viewer/viewer.cpp b/ydb/core/viewer/viewer.cpp\nindex 643670e5ea4b..65279dd2cbeb 100644\n--- a/ydb/core/viewer/viewer.cpp\n+++ b/ydb/core/viewer/viewer.cpp\n@@ -152,6 +152,7 @@ class TViewer : public TActorBootstrapped<TViewer>, public IViewer {\n \n     TString GetCORS(const NMon::TEvHttpInfo* request) override;\n     TString GetHTTPOKJSON(const NMon::TEvHttpInfo* request, TString response) override;\n+    TString GetHTTPOK(const NMon::TEvHttpInfo* request, TString type, TString response) override;\n     TString GetHTTPGATEWAYTIMEOUT(const NMon::TEvHttpInfo* request) override;\n     TString GetHTTPBADREQUEST(const NMon::TEvHttpInfo* request, TString type, TString response) override;\n \n@@ -491,6 +492,22 @@ TString TViewer::GetHTTPBADREQUEST(const NMon::TEvHttpInfo* request, TString con\n     return res;\n }\n \n+TString TViewer::GetHTTPOK(const NMon::TEvHttpInfo* request, TString contentType = {}, TString response = {}) {\n+    TStringBuilder res;\n+    res << \"HTTP/1.1 200 Ok\\r\\n\"\n+        << \"Content-Type: \" << contentType << \"\\r\\n\"\n+        << \"X-Worker-Name: \" << CurrentWorkerName << \"\\r\\n\";\n+    res << GetCORS(request);\n+    if (response) {\n+        res << \"Content-Length: \" << response.size() << \"\\r\\n\";\n+    }\n+    res << \"\\r\\n\";\n+    if (response) {\n+        res << response;\n+    }\n+    return res;\n+}\n+\n NKikimrViewer::EFlag GetFlagFromTabletState(NKikimrWhiteboard::TTabletStateInfo::ETabletState state) {\n     NKikimrViewer::EFlag flag = NKikimrViewer::EFlag::Grey;\n     switch (state) {\ndiff --git a/ydb/core/viewer/viewer.h b/ydb/core/viewer/viewer.h\nindex cb4642d570a1..7fdab30f8332 100644\n--- a/ydb/core/viewer/viewer.h\n+++ b/ydb/core/viewer/viewer.h\n@@ -154,6 +154,7 @@ class IViewer {\n         const TContentHandler& handler) = 0;\n \n     virtual TString GetCORS(const NMon::TEvHttpInfo* request) = 0;\n+    virtual TString GetHTTPOK(const NMon::TEvHttpInfo* request, TString contentType = {}, TString response = {}) = 0;\n     virtual TString GetHTTPOKJSON(const NMon::TEvHttpInfo* request, TString response = {}) = 0;\n     virtual TString GetHTTPGATEWAYTIMEOUT(const NMon::TEvHttpInfo* request) = 0;\n     virtual TString GetHTTPBADREQUEST(const NMon::TEvHttpInfo* request, TString contentType = {}, TString response = {}) = 0;\ndiff --git a/ydb/core/viewer/ya.make b/ydb/core/viewer/ya.make\nindex ec0fd7a831c9..1dd3163c5a13 100644\n--- a/ydb/core/viewer/ya.make\n+++ b/ydb/core/viewer/ya.make\n@@ -22,6 +22,7 @@ SRCS(\n     json_describe.h\n     json_local_rpc.h\n     json_getblob.h\n+    json_graph.h\n     json_handlers_vdisk.cpp\n     json_handlers_viewer.cpp\n     json_healthcheck.h\n@@ -35,6 +36,7 @@ SRCS(\n     json_nodes.h\n     json_pdiskinfo.h\n     json_query.h\n+    json_render.h\n     json_storage.h\n     json_sysinfo.h\n     json_tabletcounters.h\n@@ -259,6 +261,7 @@ PEERDIR(\n     ydb/core/blobstorage/base\n     ydb/core/blobstorage/vdisk/common\n     ydb/core/client/server\n+    ydb/core/graph/api\n     ydb/core/grpc_services\n     ydb/core/grpc_services/local_rpc\n     ydb/core/health_check\ndiff --git a/ydb/core/ya.make b/ydb/core/ya.make\nindex cc7fb2396778..68203ab5b585 100644\n--- a/ydb/core/ya.make\n+++ b/ydb/core/ya.make\n@@ -17,6 +17,7 @@ RECURSE(\n     filestore\n     fq\n     formats\n+    graph\n     grpc_caching\n     grpc_services\n     grpc_streaming\ndiff --git a/ydb/library/services/services.proto b/ydb/library/services/services.proto\nindex ebd5ed391159..525fdd251952 100644\n--- a/ydb/library/services/services.proto\n+++ b/ydb/library/services/services.proto\n@@ -83,6 +83,8 @@ enum EServiceKikimr {\n     TENANT_POOL = 303;\n     LABELS_MAINTAINER = 305;\n \n+    GRAPH = 306;\n+\n     // TABLET section\n     TABLET_EXECUTOR = 310;\n     TABLET_MAIN = 311;\n@@ -1012,5 +1014,6 @@ message TActivity {\n         PQ_FETCH_REQUEST = 621;\n         STATISTICS_AGGREGATOR = 622;\n         KAFKA_READ_SESSION_ACTOR = 623;\n+        GRAPH_SERVICE = 624;\n     };\n };\n",
  "test_patch": "diff --git a/ydb/core/testlib/tablet_helpers.cpp b/ydb/core/testlib/tablet_helpers.cpp\nindex c691ac509e66..c43138f127ac 100644\n--- a/ydb/core/testlib/tablet_helpers.cpp\n+++ b/ydb/core/testlib/tablet_helpers.cpp\n@@ -44,6 +44,7 @@\n #include <ydb/core/persqueue/pq.h>\n #include <ydb/core/sys_view/processor/processor.h>\n #include <ydb/core/statistics/aggregator/aggregator.h>\n+#include <ydb/core/graph/api/shard.h>\n \n #include <ydb/core/testlib/basics/storage.h>\n #include <ydb/core/testlib/basics/appdata.h>\n@@ -1221,6 +1222,8 @@ namespace NKikimr {\n                     bootstrapperActorId = Boot(ctx, type, &CreatePersQueue, DataGroupErasure);\n                 } else if (type == TTabletTypes::StatisticsAggregator) {\n                     bootstrapperActorId = Boot(ctx, type, &NStat::CreateStatisticsAggregator, DataGroupErasure);\n+                } else if (type == TTabletTypes::GraphShard) {\n+                    bootstrapperActorId = Boot(ctx, type, &NGraph::CreateGraphShard, DataGroupErasure);\n                 } else {\n                     status = NKikimrProto::ERROR;\n                 }\ndiff --git a/ydb/core/testlib/tenant_runtime.cpp b/ydb/core/testlib/tenant_runtime.cpp\nindex 0f7eac140f57..88ba8b75905c 100644\n--- a/ydb/core/testlib/tenant_runtime.cpp\n+++ b/ydb/core/testlib/tenant_runtime.cpp\n@@ -793,11 +793,11 @@ void TTenantTestRuntime::Setup(bool createTenantPools)\n     if (ENABLE_DETAILED_LOG) {\n         SetLogPriority(NKikimrServices::LOCAL, NLog::PRI_DEBUG);\n         SetLogPriority(NKikimrServices::TENANT_POOL, NLog::PRI_DEBUG);\n-        SetLogPriority(NKikimrServices::LABELS_MAINTAINER, NLog::PRI_DEBUG);\n+        //SetLogPriority(NKikimrServices::LABELS_MAINTAINER, NLog::PRI_DEBUG);\n         SetLogPriority(NKikimrServices::TENANT_SLOT_BROKER, NLog::PRI_DEBUG);\n-        SetLogPriority(NKikimrServices::CMS, NLog::PRI_DEBUG);\n-        SetLogPriority(NKikimrServices::CMS_CONFIGS, NLog::PRI_TRACE);\n-        SetLogPriority(NKikimrServices::CMS_TENANTS, NLog::PRI_TRACE);\n+        //SetLogPriority(NKikimrServices::CMS, NLog::PRI_DEBUG);\n+        //SetLogPriority(NKikimrServices::CMS_CONFIGS, NLog::PRI_TRACE);\n+        //SetLogPriority(NKikimrServices::CMS_TENANTS, NLog::PRI_TRACE);\n         SetLogPriority(NKikimrServices::CONFIGS_DISPATCHER, NLog::PRI_TRACE);\n         SetLogPriority(NKikimrServices::CONFIGS_CACHE, NLog::PRI_TRACE);\n         SetLogPriority(NKikimrServices::HIVE, NLog::PRI_DEBUG);\ndiff --git a/ydb/core/tx/schemeshard/ut_helpers/test_env.cpp b/ydb/core/tx/schemeshard/ut_helpers/test_env.cpp\nindex 724a3ec21a70..7bf426409458 100644\n--- a/ydb/core/tx/schemeshard/ut_helpers/test_env.cpp\n+++ b/ydb/core/tx/schemeshard/ut_helpers/test_env.cpp\n@@ -15,7 +15,7 @@\n #include <library/cpp/testing/unittest/registar.h>\n \n \n-static const bool ENABLE_SCHEMESHARD_LOG = true;\n+bool NSchemeShardUT_Private::TTestEnv::ENABLE_SCHEMESHARD_LOG = true;\n static const bool ENABLE_DATASHARD_LOG = false;\n static const bool ENABLE_COORDINATOR_MEDIATOR_LOG = false;\n static const bool ENABLE_SCHEMEBOARD_LOG = false;\ndiff --git a/ydb/core/tx/schemeshard/ut_helpers/test_env.h b/ydb/core/tx/schemeshard/ut_helpers/test_env.h\nindex 2cce554c1bcb..745c0dfef648 100644\n--- a/ydb/core/tx/schemeshard/ut_helpers/test_env.h\n+++ b/ydb/core/tx/schemeshard/ut_helpers/test_env.h\n@@ -77,6 +77,8 @@ namespace NSchemeShardUT_Private {\n         THolder<NYdb::TDriver> YdbDriver;\n \n     public:\n+        static bool ENABLE_SCHEMESHARD_LOG;\n+\n         TTestEnv(TTestActorRuntime& runtime, ui32 nchannels = 4, bool enablePipeRetries = true,\n             TSchemeShardFactory ssFactory = &CreateFlatTxSchemeShard, bool enableSystemViews = false);\n         TTestEnv(TTestActorRuntime& runtime, const TTestEnvOptions& opts,\n",
  "problem_statement": "add graph data backend for rendering built-in graphs in the ui\nadd backend to collect relatively small (<10) number of metrics in time-series format (for relatively short period 1day - 7days max)\n",
  "hints_text": "",
  "created_at": "2023-12-27T10:53:37Z",
  "modified_files": [
    ".gitignore",
    "ydb/core/base/events.h",
    "ydb/core/base/pool_stats_collector.cpp",
    "ydb/core/base/ya.make",
    "ydb/core/cms/console/console_tenants_manager.cpp",
    "ydb/core/driver_lib/run/config.h",
    "ydb/core/driver_lib/run/kikimr_services_initializers.cpp",
    "ydb/core/driver_lib/run/kikimr_services_initializers.h",
    "ydb/core/driver_lib/run/run.cpp",
    "ydb/core/driver_lib/run/ya.make",
    "b/ydb/core/graph/api/events.h",
    "b/ydb/core/graph/api/service.h",
    "b/ydb/core/graph/api/shard.h",
    "b/ydb/core/graph/api/ya.make",
    "b/ydb/core/graph/protos/graph.proto",
    "b/ydb/core/graph/protos/ya.make",
    "b/ydb/core/graph/service/log.h",
    "b/ydb/core/graph/service/service_impl.cpp",
    "b/ydb/core/graph/service/ya.make",
    "b/ydb/core/graph/shard/backends.cpp",
    "b/ydb/core/graph/shard/backends.h",
    "b/ydb/core/graph/shard/log.h",
    "b/ydb/core/graph/shard/protos/counters_shard.proto",
    "b/ydb/core/graph/shard/protos/ya.make",
    "b/ydb/core/graph/shard/schema.h",
    "b/ydb/core/graph/shard/shard_impl.cpp",
    "b/ydb/core/graph/shard/shard_impl.h",
    "b/ydb/core/graph/shard/tx_change_backend.cpp",
    "b/ydb/core/graph/shard/tx_clear_data.cpp",
    "b/ydb/core/graph/shard/tx_get_metrics.cpp",
    "b/ydb/core/graph/shard/tx_init_schema.cpp",
    "b/ydb/core/graph/shard/tx_monitoring.cpp",
    "b/ydb/core/graph/shard/tx_startup.cpp",
    "b/ydb/core/graph/shard/tx_store_metrics.cpp",
    "b/ydb/core/graph/shard/ut/shard_ut.cpp",
    "b/ydb/core/graph/shard/ut/ya.make",
    "b/ydb/core/graph/shard/ya.make",
    "b/ydb/core/graph/ut/graph_ut.cpp",
    "b/ydb/core/graph/ut/ya.make",
    "b/ydb/core/graph/ya.make",
    "ydb/core/mind/hive/hive_statics.cpp",
    "ydb/core/mind/hive/monitoring.cpp",
    "ydb/core/protos/counters_schemeshard.proto",
    "ydb/core/protos/flat_tx_scheme.proto",
    "ydb/core/protos/subdomains.proto",
    "ydb/core/protos/tablet.proto",
    "ydb/core/tablet/tablet_counters_app.cpp",
    "ydb/core/tablet/ya.make",
    "ydb/core/tx/schemeshard/schemeshard.h",
    "ydb/core/tx/schemeshard/schemeshard__delete_tablet_reply.cpp",
    "ydb/core/tx/schemeshard/schemeshard__init.cpp",
    "ydb/core/tx/schemeshard/schemeshard__init_root.cpp",
    "ydb/core/tx/schemeshard/schemeshard__operation_alter_extsubdomain.cpp",
    "ydb/core/tx/schemeshard/schemeshard__operation_common_subdomain.h",
    "ydb/core/tx/schemeshard/schemeshard__operation_side_effects.cpp",
    "ydb/core/tx/schemeshard/schemeshard__sync_update_tenants.cpp",
    "ydb/core/tx/schemeshard/schemeshard_domain_links.cpp",
    "ydb/core/tx/schemeshard/schemeshard_domain_links.h",
    "ydb/core/tx/schemeshard/schemeshard_info_types.h",
    "ydb/core/tx/schemeshard/ut_base/ut_base.cpp",
    "b/ydb/core/viewer/json_graph.h",
    "ydb/core/viewer/json_handlers_viewer.cpp",
    "b/ydb/core/viewer/json_render.h",
    "ydb/core/viewer/viewer.cpp",
    "ydb/core/viewer/viewer.h",
    "ydb/core/viewer/ya.make",
    "ydb/core/ya.make",
    "ydb/library/services/services.proto"
  ],
  "modified_test_files": [
    "ydb/core/testlib/tablet_helpers.cpp",
    "ydb/core/testlib/tenant_runtime.cpp",
    "ydb/core/tx/schemeshard/ut_helpers/test_env.cpp",
    "ydb/core/tx/schemeshard/ut_helpers/test_env.h"
  ]
}