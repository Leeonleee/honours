{
  "repo": "ydb-platform/ydb",
  "pull_number": 6401,
  "instance_id": "ydb-platform__ydb-6401",
  "issue_numbers": [
    "6220"
  ],
  "base_commit": "ab119a2fa80082a678a1b9df3740894b2f4a49d5",
  "patch": "diff --git a/ydb/core/tx/coordinator/coordinator__acquire_read_step.cpp b/ydb/core/tx/coordinator/coordinator__acquire_read_step.cpp\nindex d34df2ed3f30..d74c67376705 100644\n--- a/ydb/core/tx/coordinator/coordinator__acquire_read_step.cpp\n+++ b/ydb/core/tx/coordinator/coordinator__acquire_read_step.cpp\n@@ -103,7 +103,12 @@ void TTxCoordinator::Handle(TEvTxProxy::TEvAcquireReadStep::TPtr& ev, const TAct\n         return;\n     }\n \n-    if (ReadOnlyLeaseEnabled()) {\n+    // Note: when volatile state is preserved we don't want to update the last\n+    // acquired step, because the new generation might miss that and invariants\n+    // not read-step not going back would be violated. Run the code below using\n+    // the normal tx, which will almost certainly fail (the storage is supposed\n+    // to be blocked already), or successfully persist the new read step.\n+    if (ReadOnlyLeaseEnabled() && !VolatileState.Preserved) {\n         // We acquire read step using a read-only lease from executor\n         // It is guaranteed that any future generation was not running at\n         // the time ConfirmReadOnlyLease was called.\ndiff --git a/ydb/core/tx/coordinator/coordinator__plan_step.cpp b/ydb/core/tx/coordinator/coordinator__plan_step.cpp\nindex 2954ff4faafb..c5ce361b4b52 100644\n--- a/ydb/core/tx/coordinator/coordinator__plan_step.cpp\n+++ b/ydb/core/tx/coordinator/coordinator__plan_step.cpp\n@@ -1,4 +1,5 @@\n #include \"coordinator_impl.h\"\n+#include \"coordinator_hooks.h\"\n \n #include <util/generic/hash_set.h>\n \n@@ -42,7 +43,29 @@ struct TTxCoordinator::TTxPlanStep : public TTransactionBase<TTxCoordinator> {\n     }\n \n     void Plan(TTransactionContext &txc, const TActorContext &ctx) {\n-        Y_UNUSED(txc);\n+        if (Self->VolatileState.Preserved) {\n+            // A preserved state indicates a newer generation has been started\n+            // already, and this coordinator will stop eventually. Decline\n+            // all pending transactions.\n+            for (auto& slot : Slots) {\n+                for (auto& proposal : slot) {\n+                    Self->MonCounters.StepPlannedDeclinedTx->Inc();\n+                    ProxyPlanConfirmations.Queue.emplace_back(\n+                        proposal.TxId,\n+                        proposal.Proxy,\n+                        TEvTxProxy::TEvProposeTransactionStatus::EStatus::StatusRestarting,\n+                        0);\n+                    ++DeclinedCounter;\n+                }\n+            }\n+            Self->SendStepConfirmations(ProxyPlanConfirmations, ctx);\n+            return;\n+        }\n+\n+        if (auto* hooks = ICoordinatorHooks::Get(); Y_UNLIKELY(hooks)) {\n+            hooks->BeginPlanStep(Self->TabletID(), Self->Executor()->Generation(), PlanOnStep);\n+        }\n+\n         NIceDb::TNiceDb db(txc.DB);\n         ExecStartMoment = ctx.Now();\n         const bool lowDiskSpace = Self->Executor()->GetStats().IsAnyChannelYellowStop;\ndiff --git a/ydb/core/tx/coordinator/coordinator__restore_transaction.cpp b/ydb/core/tx/coordinator/coordinator__restore_transaction.cpp\nindex af411d349ed5..f3269e362cab 100644\n--- a/ydb/core/tx/coordinator/coordinator__restore_transaction.cpp\n+++ b/ydb/core/tx/coordinator/coordinator__restore_transaction.cpp\n@@ -125,10 +125,12 @@ struct TTxCoordinator::TTxRestoreTransactions : public TTransactionBase<TTxCoord\n         return true;\n     }\n \n-    void RestoreVolatileSteps() {\n+    TStepId RestoreVolatileSteps() {\n+        TStepId maxStep = 0;\n         for (auto &pr : Self->VolatileTransactions) {\n             auto txId = pr.first;\n             auto &tx = pr.second;\n+            maxStep = Max(maxStep, tx.PlanOnStep);\n             for (auto &prmed : tx.UnconfirmedAffectedSet) {\n                 auto medId = prmed.first;\n                 auto &medTx = GetMediatorTx(medId, tx.PlanOnStep, txId);\n@@ -137,6 +139,7 @@ struct TTxCoordinator::TTxRestoreTransactions : public TTransactionBase<TTxCoord\n                 }\n             }\n         }\n+        return maxStep;\n     }\n \n     TTxType GetTxType() const override { return TXTYPE_INIT; }\n@@ -146,15 +149,24 @@ struct TTxCoordinator::TTxRestoreTransactions : public TTransactionBase<TTxCoord\n         bool result = Restore(transactions, txc, ctx);\n         if (!result)\n             return false;\n-        RestoreVolatileSteps();\n+        TStepId maxVolatileStep = RestoreVolatileSteps();\n         i64 txCounter = transactions.size() + Self->VolatileTransactions.size();\n         Self->Transactions.swap(transactions);\n         *Self->MonCounters.TxInFly += txCounter;\n         Self->MonCounters.CurrentTxInFly = txCounter;\n \n-        if (Self->PrevStateActorId) {\n-            NIceDb::TNiceDb db(txc.DB);\n+        NIceDb::TNiceDb db(txc.DB);\n \n+        // Previous coordinator might have had transactions that were after\n+        // its persistent blocked range, but before LastPlanned was updated.\n+        // Since we pick them up as planned and send to mediators we also need\n+        // to make sure LastPlanned reflects that.\n+        if (Self->VolatileState.LastPlanned < maxVolatileStep) {\n+            Self->VolatileState.LastPlanned = maxVolatileStep;\n+            Schema::SaveState(db, Schema::State::KeyLastPlanned, maxVolatileStep);\n+        }\n+\n+        if (Self->PrevStateActorId) {\n             ui64 volatileLeaseMs = Self->VolatilePlanLeaseMs;\n             if (volatileLeaseMs > 0) {\n                 // Make sure we start and persist new state actor before allowing clients to acquire new read steps\ndiff --git a/ydb/core/tx/coordinator/coordinator_hooks.cpp b/ydb/core/tx/coordinator/coordinator_hooks.cpp\nindex 742ed2bdc4b6..225ed046ac1e 100644\n--- a/ydb/core/tx/coordinator/coordinator_hooks.cpp\n+++ b/ydb/core/tx/coordinator/coordinator_hooks.cpp\n@@ -14,6 +14,12 @@ namespace NKikimr::NFlatTxCoordinator {\n         return true;\n     }\n \n+    void ICoordinatorHooks::BeginPlanStep(ui64 tabletId, ui64 generation, ui64 planStep) {\n+        Y_UNUSED(tabletId);\n+        Y_UNUSED(generation);\n+        Y_UNUSED(planStep);\n+    }\n+\n     ICoordinatorHooks* ICoordinatorHooks::Get() {\n         return CoordinatorHooks.load(std::memory_order_acquire);\n     }\ndiff --git a/ydb/core/tx/coordinator/coordinator_hooks.h b/ydb/core/tx/coordinator/coordinator_hooks.h\nindex 4f96fd25d146..e38dbc72cc96 100644\n--- a/ydb/core/tx/coordinator/coordinator_hooks.h\n+++ b/ydb/core/tx/coordinator/coordinator_hooks.h\n@@ -10,6 +10,7 @@ namespace NKikimr::NFlatTxCoordinator {\n \n     public:\n         virtual bool PersistConfig(ui64 tabletId, const NKikimrSubDomains::TProcessingParams& config);\n+        virtual void BeginPlanStep(ui64 tabletId, ui64 generation, ui64 planStep);\n \n     public:\n         static ICoordinatorHooks* Get();\ndiff --git a/ydb/core/tx/coordinator/coordinator_impl.cpp b/ydb/core/tx/coordinator/coordinator_impl.cpp\nindex cfdc7bb55fc5..9a130616231b 100644\n--- a/ydb/core/tx/coordinator/coordinator_impl.cpp\n+++ b/ydb/core/tx/coordinator/coordinator_impl.cpp\n@@ -328,6 +328,11 @@ ui64 TTxCoordinator::AlignPlanStep(ui64 step) {\n void TTxCoordinator::Handle(TEvPrivate::TEvPlanTick::TPtr &ev, const TActorContext &ctx) {\n     //LOG_DEBUG_S(ctx, NKikimrServices::TX_COORDINATOR, \"tablet# \" << TabletID() << \" HANDLE EvPlanTick LastPlanned \" << VolatileState.LastPlanned);\n \n+    if (VolatileState.Preserved) {\n+        // Avoid planning any new transactions, wait until we are stopped\n+        return;\n+    }\n+\n     ui64 next = ev->Get()->Step;\n     while (!PendingPlanTicks.empty() && PendingPlanTicks.front() <= next) {\n         PendingPlanTicks.pop_front();\n@@ -556,8 +561,14 @@ void TTxCoordinator::TryInitMonCounters(const TActorContext &ctx) {\n }\n \n void TTxCoordinator::SendMediatorStep(TMediator &mediator, const TActorContext &ctx) {\n+    if (VolatileState.Preserved) {\n+        // We don't want to send new steps when state has been preserved and\n+        // potentially sent to newer generations.\n+        return;\n+    }\n+\n     if (!mediator.Active) {\n-        // We don't want to update LastSentStep when mediators are not empty\n+        // We don't want to update LastSentStep when mediators are not connected\n         return;\n     }\n \ndiff --git a/ydb/core/tx/coordinator/coordinator_impl.h b/ydb/core/tx/coordinator/coordinator_impl.h\nindex 83272721ee4c..8369e8418f6e 100644\n--- a/ydb/core/tx/coordinator/coordinator_impl.h\n+++ b/ydb/core/tx/coordinator/coordinator_impl.h\n@@ -433,6 +433,10 @@ class TTxCoordinator : public TActor<TTxCoordinator>, public TTabletExecutedFlat\n         TVector<TAcquireReadStepRequest> AcquireReadStepPending;\n         bool AcquireReadStepFlushing = false;\n         bool AcquireReadStepStarting = false;\n+\n+        // When true the state has been preserved by the state actor\n+        // Any changes will not be migrated to newer generations\n+        bool Preserved = false;\n     };\n \n public:\ndiff --git a/ydb/core/tx/coordinator/coordinator_state.cpp b/ydb/core/tx/coordinator/coordinator_state.cpp\nindex fa1351c54770..70f91a736244 100644\n--- a/ydb/core/tx/coordinator/coordinator_state.cpp\n+++ b/ydb/core/tx/coordinator/coordinator_state.cpp\n@@ -80,6 +80,7 @@ void TCoordinatorStateActor::PreserveState() {\n         Y_ABORT_UNLESS(ok);\n     }\n \n+    Owner->VolatileState.Preserved = true;\n }\n \n STFUNC(TCoordinatorStateActor::StateWork) {\ndiff --git a/ydb/core/tx/coordinator/coordinator_volatile_ut.cpp b/ydb/core/tx/coordinator/coordinator_volatile_ut.cpp\nindex 8d75974813aa..cb57683785b4 100644\n--- a/ydb/core/tx/coordinator/coordinator_volatile_ut.cpp\n+++ b/ydb/core/tx/coordinator/coordinator_volatile_ut.cpp\n@@ -1,5 +1,6 @@\n #include <ydb/core/tx/coordinator/public/events.h>\n #include <ydb/core/tx/coordinator/coordinator_impl.h>\n+#include <ydb/core/tx/coordinator/coordinator_hooks.h>\n #include <ydb/core/tx/tx.h>\n #include <ydb/core/tx/tx_processing.h>\n #include <ydb/core/tablet_flat/tablet_flat_executed.h>\n@@ -357,6 +358,539 @@ namespace NKikimr::NFlatTxCoordinator::NTest {\n             UNIT_ASSERT_VALUES_EQUAL(observedSteps.size(), 1u);\n         }\n \n+        /**\n+         * Tests a scenario where coordinator's volatile lease expires, which\n+         * causes coordinator to update the lease during volatile planning.\n+         * That transaction is migrated to a newer instance, but commit updating\n+         * last known step fails. A bug caused new instances to reach a confused\n+         * state, which could cause it to attempt planning more transactions in\n+         * the same step, violating invariants.\n+         */\n+        Y_UNIT_TEST(CoordinatorMigrateUncommittedVolatileTx) {\n+            struct TCoordinatorHooks : public ICoordinatorHooks {\n+                std::vector<ui64> PlannedSteps;\n+\n+                void BeginPlanStep(ui64 tabletId, ui64 generation, ui64 planStep) override {\n+                    Cerr << \"... coordinator \" << tabletId << \" gen \" << generation << \" is planning step \" << planStep << Endl;\n+                    PlannedSteps.push_back(planStep);\n+                }\n+            } hooks;\n+            TCoordinatorHooksGuard hooksGuard(hooks);\n+\n+            TPortManager pm;\n+            TServerSettings serverSettings(pm.GetPort(2134));\n+            serverSettings.SetDomainName(\"Root\")\n+                .SetNodeCount(1)\n+                .SetUseRealThreads(false)\n+                .SetDomainPlanResolution(50);\n+\n+            Tests::TServer::TPtr server = new TServer(serverSettings);\n+\n+            auto &runtime = *server->GetRuntime();\n+            runtime.SetLogPriority(NKikimrServices::TX_COORDINATOR, NActors::NLog::PRI_DEBUG);\n+            runtime.SetLogPriority(NKikimrServices::BOOTSTRAPPER, NActors::NLog::PRI_DEBUG);\n+            // runtime.SetLogPriority(NKikimrServices::TX_MEDIATOR, NActors::NLog::PRI_DEBUG);\n+            // runtime.SetLogPriority(NKikimrServices::TX_MEDIATOR_EXEC_QUEUE, NActors::NLog::PRI_DEBUG);\n+            // runtime.SetLogPriority(NKikimrServices::TX_MEDIATOR_TABLETQUEUE, NActors::NLog::PRI_DEBUG);\n+\n+            auto sender = runtime.AllocateEdgeActor();\n+            ui64 coordinatorId = ChangeStateStorage(Coordinator, server->GetSettings().Domain);\n+            ui64 tabletId = ChangeStateStorage(TTestTxConfig::TxTablet0, server->GetSettings().Domain);\n+\n+            CreateTestBootstrapper(runtime,\n+                CreateTestTabletInfo(tabletId, TTabletTypes::Dummy),\n+                [](const TActorId& tablet, TTabletStorageInfo* info) {\n+                    return new TPlanTargetTablet(tablet, info);\n+                });\n+\n+            {\n+                TDispatchOptions options;\n+                options.FinalEvents.push_back(TDispatchOptions::TFinalEventCondition(TEvTablet::EvBoot, 1));\n+                runtime.DispatchEvents(options);\n+            }\n+\n+            auto waitFor = [&](const auto& condition, const TString& description) {\n+                for (int i = 0; i < 5 && !condition(); ++i) {\n+                    Cerr << \"... waiting for \" << description << Endl;\n+                    TDispatchOptions options;\n+                    options.CustomFinalCondition = [&]() {\n+                        return condition();\n+                    };\n+                    runtime.DispatchEvents(options);\n+                }\n+                UNIT_ASSERT_C(condition(), \"... failed to wait for \" << description);\n+            };\n+\n+            // Wait for the first idle mediator step\n+            waitFor([&]{ return hooks.PlannedSteps.size() >= 2; }, \"the first two planned steps\");\n+\n+            auto oldTimestamp = runtime.GetCurrentTime();\n+            auto oldCoordinatorSysActorId = ResolveTablet(runtime, coordinatorId, 0, /* sysTablet */ true);\n+            auto oldCoordinatorUserActorId = ResolveTablet(runtime, coordinatorId, 0, /* sysTablet */ false);\n+\n+            // Sleep for 500ms, so the default volatile lease of 250ms will expire\n+            runtime.SimulateSleep(TDuration::MilliSeconds(500));\n+\n+            hooks.PlannedSteps.clear();\n+\n+            // Start blocking EvPut responses for the new plan (but allowing data to commit)\n+            std::vector<std::unique_ptr<IEventHandle>> blockedPutResponses;\n+            auto blockPutResponses = runtime.AddObserver<TEvBlobStorage::TEvPutResult>(\n+                [&](TEvBlobStorage::TEvPutResult::TPtr& ev) {\n+                    auto* msg = ev->Get();\n+                    if (hooks.PlannedSteps.size() > 0 && msg->Id.TabletID() == coordinatorId) {\n+                        // Block commits from coordinator\n+                        Cerr << \"... blocking put \" << msg->Id << \" response\" << Endl;\n+                        blockedPutResponses.emplace_back(ev.Release());\n+                    }\n+                });\n+\n+            // Block target tablet's accept messages to keep transactions in mediator\n+            std::vector<std::unique_ptr<IEventHandle>> blockedPlanStepAccepted;\n+            auto blockPlanStepAccepted = runtime.AddObserver<TEvTxProcessing::TEvPlanStepAccepted>(\n+                [&](TEvTxProcessing::TEvPlanStepAccepted::TPtr& ev) {\n+                    auto* msg = ev->Get();\n+                    if (msg->Record.GetTabletId() == tabletId) {\n+                        Cerr << \"... blocked accept from \" << tabletId << Endl;\n+                        blockedPlanStepAccepted.emplace_back(ev.Release());\n+                    }\n+                });\n+\n+            // Plan a persistent transaction\n+            ui64 persistentTxId = 10000000;\n+            if (auto propose = std::make_unique<TEvTxProxy::TEvProposeTransaction>(coordinatorId, persistentTxId, 0, Min<ui64>(), Max<ui64>())) {\n+                auto* tx = propose->Record.MutableTransaction();\n+                auto* affected = tx->AddAffectedSet();\n+                affected->SetTabletId(tabletId);\n+                affected->SetFlags(TEvTxProxy::TEvProposeTransaction::AffectedWrite);\n+\n+                runtime.SendToPipe(coordinatorId, sender, propose.release());\n+            }\n+\n+            // Wait until we have some commit responses blocked\n+            // This will ensure planned tx is persisted, but coordinator will not act on it yet\n+            waitFor([&]{ return blockedPutResponses.size() > 0; }, \"blocked put responses\");\n+\n+            UNIT_ASSERT_VALUES_EQUAL(hooks.PlannedSteps.size(), 1u);\n+            ui64 persistentPlanStep = hooks.PlannedSteps.at(0);\n+            hooks.PlannedSteps.clear();\n+\n+            // Stop blocking put responses\n+            blockPutResponses.Remove();\n+\n+            // Start blocking EvPut requests (not allowing data to commit)\n+            std::vector<std::unique_ptr<IEventHandle>> blockedPutRequests;\n+            auto blockPutRequests = runtime.AddObserver<TEvBlobStorage::TEvPut>(\n+                [&](TEvBlobStorage::TEvPut::TPtr& ev) {\n+                    auto* msg = ev->Get();\n+                    if (msg->Id.TabletID() == coordinatorId) {\n+                        // Block commits from coordinator\n+                        Cerr << \"... blocking put \" << msg->Id << \" request\" << Endl;\n+                        blockedPutRequests.emplace_back(ev.Release());\n+                    }\n+                });\n+\n+            // Plan a volatile transaction, expected to be planned for Step+1\n+            ui64 volatileTxId1 = 10000010;\n+            if (auto propose = std::make_unique<TEvTxProxy::TEvProposeTransaction>(coordinatorId, volatileTxId1, 0, Min<ui64>(), Max<ui64>())) {\n+                auto* tx = propose->Record.MutableTransaction();\n+                tx->SetFlags(TEvTxProxy::TEvProposeTransaction::FlagVolatile);\n+                auto* affected = tx->AddAffectedSet();\n+                affected->SetTabletId(tabletId);\n+                affected->SetFlags(TEvTxProxy::TEvProposeTransaction::AffectedWrite);\n+\n+                runtime.SendToPipe(coordinatorId, sender, propose.release());\n+            }\n+\n+            // Wait until it's actually planned\n+            waitFor([&]{ return hooks.PlannedSteps.size() >= 1; }, \"planned volatile tx\");\n+\n+            UNIT_ASSERT_VALUES_EQUAL(hooks.PlannedSteps.size(), 1u);\n+            ui64 volatilePlanStep = hooks.PlannedSteps.at(0);\n+            hooks.PlannedSteps.clear();\n+\n+            UNIT_ASSERT_C(volatilePlanStep > persistentPlanStep,\n+                \"Volatile plan step \" << volatilePlanStep << \" should be after persistent plan step \" << persistentPlanStep);\n+\n+            // Make sure everything settles\n+            runtime.SimulateSleep(TDuration::MilliSeconds(1));\n+\n+            // We expect there to be a commit attempt (extending the lease and updating last planned)\n+            UNIT_ASSERT_C(blockedPutRequests.size() > 0, \"expected to have put requests blocked by now\");\n+            blockPutRequests.Remove();\n+\n+            // We want to start a new instance in parallel\n+            // Block the old bootstrapper from starting unwanted instances when current tablet dies\n+            bool oldTabletStopped = false;\n+            auto blockOldTabletDead = runtime.AddObserver<TEvTablet::TEvTabletDead>(\n+                [&](TEvTablet::TEvTabletDead::TPtr& ev) {\n+                    if (ev->Sender == oldCoordinatorSysActorId) {\n+                        if (ev->GetRecipientRewrite() == oldCoordinatorUserActorId) {\n+                            oldTabletStopped = true;\n+                        } else {\n+                            ev.Reset();\n+                        }\n+                    }\n+                });\n+\n+            // New instance will migrate the in-memory state, block it from reaching the new instance temporarily\n+            std::vector<std::unique_ptr<IEventHandle>> blockedStateResponses;\n+            auto blockStateResponses = runtime.AddObserver<TEvTxCoordinator::TEvCoordinatorStateResponse>(\n+                [&](TEvTxCoordinator::TEvCoordinatorStateResponse::TPtr& ev) {\n+                    Cerr << \"... blocking state response from \" << ev->Sender << \" to \" << ev->GetRecipientRewrite() << Endl;\n+                    Cerr << ev->Get()->Record.DebugString();\n+                    blockedStateResponses.emplace_back(ev.Release());\n+                });\n+\n+            // Rewind to some older time\n+            runtime.UpdateCurrentTime(oldTimestamp, /* rewind */ true);\n+\n+            // Start a new bootstrapper, which will boot a new instance in parallel\n+            Cerr << \"... starting a new coordinator instance\" << Endl;\n+            CreateTestBootstrapper(runtime, CreateTestTabletInfo(coordinatorId, TTabletTypes::Coordinator), &CreateFlatTxCoordinator);\n+\n+            // Wait until new coordinator almost receives the in-memory state\n+            waitFor([&]{ return blockedStateResponses.size() >= 1; }, \"migrated state\");\n+\n+            // Unblock previously blocked blobstorage messages\n+            // Since new coordinator has started the storage is already blocked\n+            Cerr << \"... unblocking put responses and requests\" << Endl;\n+            for (auto& ev : blockedPutResponses) {\n+                runtime.Send(ev.release(), 0, true);\n+            }\n+            blockedPutResponses.clear();\n+            for (auto& ev : blockedPutRequests) {\n+                runtime.Send(ev.release(), 0, true);\n+            }\n+            blockedPutRequests.clear();\n+\n+            // Sleep a little, so everything settles (e.g. committed plan is sent to mediator)\n+            runtime.SimulateSleep(TDuration::MilliSeconds(1));\n+\n+            waitFor([&]{ return oldTabletStopped; }, \"old tablet stopped\");\n+            hooks.PlannedSteps.clear();\n+\n+            // Unblock the in-memory state transfer\n+            blockStateResponses.Remove();\n+            for (auto& ev : blockedStateResponses) {\n+                runtime.Send(ev.release(), 0, true);\n+            }\n+            blockedStateResponses.clear();\n+\n+            // Make sure new requests go to the new instance\n+            InvalidateTabletResolverCache(runtime, coordinatorId);\n+\n+            // Plan another volatile transaction, with a smaller TxId\n+            ui64 volatileTxId2 = 10000005;\n+            if (auto propose = std::make_unique<TEvTxProxy::TEvProposeTransaction>(coordinatorId, volatileTxId2, 0, Min<ui64>(), Max<ui64>())) {\n+                auto* tx = propose->Record.MutableTransaction();\n+                tx->SetFlags(TEvTxProxy::TEvProposeTransaction::FlagVolatile);\n+                auto* affected = tx->AddAffectedSet();\n+                affected->SetTabletId(tabletId);\n+                affected->SetFlags(TEvTxProxy::TEvProposeTransaction::AffectedWrite);\n+\n+                runtime.SendToPipe(coordinatorId, sender, propose.release());\n+            }\n+\n+            // Wait until it's actually planned\n+            waitFor([&]{ return hooks.PlannedSteps.size() >= 1; }, \"planned volatile tx\");\n+\n+            UNIT_ASSERT_VALUES_EQUAL(hooks.PlannedSteps.size(), 1u);\n+            ui64 volatilePlanStep2 = hooks.PlannedSteps.at(0);\n+            hooks.PlannedSteps.clear();\n+\n+            // Wait until everything settles (e.g. mediators receive all pending transactions)\n+            runtime.SimulateSleep(TDuration::MilliSeconds(1));\n+\n+            // Reboot the target tablet to trigger the original assertion\n+            Cerr << \"... rebooting target tablet\" << Endl;\n+            RebootTablet(runtime, tabletId, sender);\n+\n+            // Wait until everything settles\n+            runtime.SimulateSleep(TDuration::MilliSeconds(1));\n+\n+            // Validate the new plan does not go back in time\n+            UNIT_ASSERT_C(volatilePlanStep2 > volatilePlanStep,\n+                \"New volatile plan step \" << volatilePlanStep2 << \" is expected to be after \" << volatilePlanStep);\n+        }\n+\n+        /**\n+         * This scenario tests an empty volatile plan that is scheduled behind\n+         * a persistent plan, which finishes committing after an in-memory\n+         * state has been snapshotted and migrated. There was a bug where this\n+         * empty plan step would not be considered as confirmed, and could be\n+         * erroneously considered as unused by a previous generation.\n+         */\n+        Y_UNIT_TEST(CoordinatorRestartWithEnqueuedVolatileStep) {\n+            struct TCoordinatorHooks : public ICoordinatorHooks {\n+                std::vector<ui64> PlannedSteps;\n+\n+                void BeginPlanStep(ui64 tabletId, ui64 generation, ui64 planStep) override {\n+                    Cerr << \"... coordinator \" << tabletId << \" gen \" << generation << \" is planning step \" << planStep << Endl;\n+                    PlannedSteps.push_back(planStep);\n+                }\n+            } hooks;\n+            TCoordinatorHooksGuard hooksGuard(hooks);\n+\n+            TPortManager pm;\n+            TServerSettings serverSettings(pm.GetPort(2134));\n+            serverSettings.SetDomainName(\"Root\")\n+                .SetNodeCount(1)\n+                .SetUseRealThreads(false)\n+                .SetDomainPlanResolution(50);\n+\n+            Tests::TServer::TPtr server = new TServer(serverSettings);\n+\n+            auto &runtime = *server->GetRuntime();\n+            runtime.SetLogPriority(NKikimrServices::TX_COORDINATOR, NActors::NLog::PRI_DEBUG);\n+            runtime.SetLogPriority(NKikimrServices::BOOTSTRAPPER, NActors::NLog::PRI_DEBUG);\n+            runtime.SetLogPriority(NKikimrServices::TX_MEDIATOR, NActors::NLog::PRI_DEBUG);\n+            runtime.SetLogPriority(NKikimrServices::TX_MEDIATOR_EXEC_QUEUE, NActors::NLog::PRI_DEBUG);\n+            runtime.SetLogPriority(NKikimrServices::TX_MEDIATOR_TABLETQUEUE, NActors::NLog::PRI_DEBUG);\n+\n+            auto sender = runtime.AllocateEdgeActor();\n+            ui64 coordinatorId = ChangeStateStorage(Coordinator, server->GetSettings().Domain);\n+            ui64 mediatorId = ChangeStateStorage(Mediator, server->GetSettings().Domain);\n+            ui64 tabletId = ChangeStateStorage(TTestTxConfig::TxTablet0, server->GetSettings().Domain);\n+\n+            CreateTestBootstrapper(runtime,\n+                CreateTestTabletInfo(tabletId, TTabletTypes::Dummy),\n+                [](const TActorId& tablet, TTabletStorageInfo* info) {\n+                    return new TPlanTargetTablet(tablet, info);\n+                });\n+\n+            {\n+                TDispatchOptions options;\n+                options.FinalEvents.push_back(TDispatchOptions::TFinalEventCondition(TEvTablet::EvBoot, 1));\n+                runtime.DispatchEvents(options);\n+            }\n+\n+            auto waitFor = [&](const auto& condition, const TString& description) {\n+                for (int i = 0; i < 5 && !condition(); ++i) {\n+                    Cerr << \"... waiting for \" << description << Endl;\n+                    TDispatchOptions options;\n+                    options.CustomFinalCondition = [&]() {\n+                        return condition();\n+                    };\n+                    runtime.DispatchEvents(options);\n+                }\n+                UNIT_ASSERT_C(condition(), \"... failed to wait for \" << description);\n+            };\n+\n+            // Wait for the first idle mediator step\n+            waitFor([&]{ return hooks.PlannedSteps.size() >= 2; }, \"the first two planned steps\");\n+            runtime.SimulateSleep(TDuration::MilliSeconds(1));\n+\n+            hooks.PlannedSteps.clear();\n+\n+            auto oldTimestamp = runtime.GetCurrentTime();\n+            auto oldCoordinatorSysActorId = ResolveTablet(runtime, coordinatorId, 0, /* sysTablet */ true);\n+            auto oldCoordinatorUserActorId = ResolveTablet(runtime, coordinatorId, 0, /* sysTablet */ false);\n+\n+            // Start blocking EvPut responses for the new plan (but allowing data to commit)\n+            std::vector<std::unique_ptr<IEventHandle>> blockedPutResponses;\n+            auto blockPutResponses = runtime.AddObserver<TEvBlobStorage::TEvPutResult>(\n+                [&](TEvBlobStorage::TEvPutResult::TPtr& ev) {\n+                    auto* msg = ev->Get();\n+                    if (hooks.PlannedSteps.size() > 0 && msg->Id.TabletID() == coordinatorId) {\n+                        // Block commits from coordinator\n+                        Cerr << \"... blocking put \" << msg->Id << \" response\" << Endl;\n+                        blockedPutResponses.emplace_back(ev.Release());\n+                    }\n+                });\n+\n+            // Block target tablet's accept messages to keep transactions in mediator\n+            std::vector<std::unique_ptr<IEventHandle>> blockedPlanStepAccepted;\n+            auto blockPlanStepAccepted = runtime.AddObserver<TEvTxProcessing::TEvPlanStepAccepted>(\n+                [&](TEvTxProcessing::TEvPlanStepAccepted::TPtr& ev) {\n+                    auto* msg = ev->Get();\n+                    if (msg->Record.GetTabletId() == tabletId) {\n+                        Cerr << \"... blocked accept from \" << tabletId << Endl;\n+                        blockedPlanStepAccepted.emplace_back(ev.Release());\n+                    }\n+                });\n+\n+            // step -> list of transactions\n+            std::map<ui64, std::vector<ui64>> observedSteps;\n+            auto observeSteps = runtime.AddObserver<TEvTxCoordinator::TEvCoordinatorStep>(\n+                [&](TEvTxCoordinator::TEvCoordinatorStep::TPtr& ev) {\n+                    auto* msg = ev->Get();\n+                    Cerr << \"... observed step:\" << Endl;\n+                    Cerr << msg->Record.DebugString();\n+                    if (msg->Record.GetCoordinatorID() != coordinatorId) {\n+                        return;\n+                    }\n+                    ui64 step = msg->Record.GetStep();\n+                    std::vector<ui64> txIds;\n+                    for (const auto& tx : msg->Record.GetTransactions()) {\n+                        txIds.push_back(tx.GetTxId());\n+                    }\n+                    std::sort(txIds.begin(), txIds.end());\n+                    auto it = observedSteps.find(step);\n+                    if (it == observedSteps.end()) {\n+                        observedSteps[step] = std::move(txIds);\n+                    } else {\n+                        auto dumpTxIds = [](const std::vector<ui64>& txIds) -> TString {\n+                            TStringBuilder sb;\n+                            sb << \"{\";\n+                            bool first = true;\n+                            for (ui64 txId : txIds) {\n+                                if (first) {\n+                                    first = false;\n+                                } else {\n+                                    sb << \", \";\n+                                }\n+                                sb << txId;\n+                            }\n+                            sb << \"}\";\n+                            return std::move(sb);\n+                        };\n+                        UNIT_ASSERT_C(it->second == txIds,\n+                            \"Step \" << step << \" changed transactions list \"\n+                            << dumpTxIds(it->second) << \" -> \" << dumpTxIds(txIds));\n+                    }\n+                });\n+\n+            // txId -> step\n+            std::map<ui64, ui64> observedTabletTxs;\n+            auto observeTabletTxs = runtime.AddObserver<TEvTxProcessing::TEvPlanStep>(\n+                [&](TEvTxProcessing::TEvPlanStep::TPtr& ev) {\n+                    auto* msg = ev->Get();\n+                    Cerr << \"... observed tablet step:\" << Endl;\n+                    Cerr << msg->Record.DebugString();\n+                    ui64 step = msg->Record.GetStep();\n+                    for (auto& tx : msg->Record.GetTransactions()) {\n+                        observedTabletTxs[tx.GetTxId()] = step;\n+                    }\n+                });\n+\n+            // Plan a persistent transaction\n+            ui64 persistentTxId = 10000000;\n+            if (auto propose = std::make_unique<TEvTxProxy::TEvProposeTransaction>(coordinatorId, persistentTxId, 0, Min<ui64>(), Max<ui64>())) {\n+                auto* tx = propose->Record.MutableTransaction();\n+                auto* affected = tx->AddAffectedSet();\n+                affected->SetTabletId(tabletId);\n+                affected->SetFlags(TEvTxProxy::TEvProposeTransaction::AffectedWrite);\n+\n+                runtime.SendToPipe(coordinatorId, sender, propose.release());\n+            }\n+\n+            // Wait until we have some commit responses blocked\n+            waitFor([&]{ return blockedPutResponses.size() > 0; }, \"blocked put responses\");\n+\n+            UNIT_ASSERT_VALUES_EQUAL(hooks.PlannedSteps.size(), 1u);\n+            ui64 persistentPlanStep = hooks.PlannedSteps.at(0);\n+            hooks.PlannedSteps.clear();\n+\n+            // Require an empty step, it should be divisible by plan resolution\n+            runtime.SendToPipe(coordinatorId, sender, new TEvTxProxy::TEvRequirePlanSteps(coordinatorId, persistentPlanStep + 50));\n+\n+            // Wait until it is also planned\n+            waitFor([&]{ return hooks.PlannedSteps.size() >= 1; }, \"planning for the required step\");\n+\n+            UNIT_ASSERT_VALUES_EQUAL(hooks.PlannedSteps.size(), 1u);\n+            ui64 volatileEmptyPlanStep = hooks.PlannedSteps.at(0);\n+            hooks.PlannedSteps.clear();\n+\n+            // Stop blocking newer put responses\n+            blockPutResponses.Remove();\n+\n+            // Make sure everything settles\n+            runtime.SimulateSleep(TDuration::MilliSeconds(1));\n+\n+            // We want to start a new instance in parallel\n+            // Block the old bootstrapper from starting unwanted instances when current tablet dies\n+            bool oldTabletStopped = false;\n+            auto blockOldTabletDead = runtime.AddObserver<TEvTablet::TEvTabletDead>(\n+                [&](TEvTablet::TEvTabletDead::TPtr& ev) {\n+                    if (ev->Sender == oldCoordinatorSysActorId) {\n+                        if (ev->GetRecipientRewrite() == oldCoordinatorUserActorId) {\n+                            oldTabletStopped = true;\n+                        } else {\n+                            ev.Reset();\n+                        }\n+                    }\n+                });\n+\n+            // New instance will migrate the in-memory state, block it from reaching the new instance temporarily\n+            std::vector<std::unique_ptr<IEventHandle>> blockedStateResponses;\n+            auto blockStateResponses = runtime.AddObserver<TEvTxCoordinator::TEvCoordinatorStateResponse>(\n+                [&](TEvTxCoordinator::TEvCoordinatorStateResponse::TPtr& ev) {\n+                    Cerr << \"... blocking state response from \" << ev->Sender << \" to \" << ev->GetRecipientRewrite() << Endl;\n+                    Cerr << ev->Get()->Record.DebugString();\n+                    blockedStateResponses.emplace_back(ev.Release());\n+                });\n+\n+            // Rewind to some older time\n+            runtime.UpdateCurrentTime(oldTimestamp, /* rewind */ true);\n+\n+            // Start a new bootstrapper, which will boot a new instance in parallel\n+            Cerr << \"... starting a new coordinator instance\" << Endl;\n+            CreateTestBootstrapper(runtime, CreateTestTabletInfo(coordinatorId, TTabletTypes::Coordinator), &CreateFlatTxCoordinator);\n+\n+            // Wait until new coordinator almost receives the in-memory state\n+            waitFor([&]{ return blockedStateResponses.size() >= 1; }, \"migrated state\");\n+\n+            // Unblock previously blocked blobstorage messages\n+            // Since new coordinator has started the storage is already blocked\n+            Cerr << \"... unblocking put responses and requests\" << Endl;\n+            for (auto& ev : blockedPutResponses) {\n+                runtime.Send(ev.release(), 0, true);\n+            }\n+            blockedPutResponses.clear();\n+\n+            // Sleep a little, so everything settles (e.g. committed plan is sent to mediator)\n+            runtime.SimulateSleep(TDuration::MilliSeconds(1));\n+\n+            waitFor([&]{ return oldTabletStopped; }, \"old tablet stopped\");\n+            hooks.PlannedSteps.clear();\n+\n+            // Unblock the in-memory state transfer\n+            blockStateResponses.Remove();\n+            for (auto& ev : blockedStateResponses) {\n+                runtime.Send(ev.release(), 0, true);\n+            }\n+            blockedStateResponses.clear();\n+\n+            size_t oldObservedSteps = observedSteps.size();\n+\n+            // Make sure new requests go to the new instance\n+            InvalidateTabletResolverCache(runtime, coordinatorId);\n+\n+            // Plan another persistent transaction\n+            ui64 persistentTxId2 = 10000011;\n+            Cerr << \"... trying to plan tx \" << persistentTxId2 << Endl;\n+            if (auto propose = std::make_unique<TEvTxProxy::TEvProposeTransaction>(coordinatorId, persistentTxId2, 0, Min<ui64>(), Max<ui64>())) {\n+                auto* tx = propose->Record.MutableTransaction();\n+                auto* affected = tx->AddAffectedSet();\n+                affected->SetTabletId(tabletId);\n+                affected->SetFlags(TEvTxProxy::TEvProposeTransaction::AffectedWrite);\n+\n+                runtime.SendToPipe(coordinatorId, sender, propose.release());\n+            }\n+\n+            // Wait until it's actually planned\n+            waitFor([&]{ return hooks.PlannedSteps.size() >= 1; }, \"planned another persistent tx\");\n+\n+            // Wait until mediator observes it\n+            waitFor([&]{ return observedSteps.size() > oldObservedSteps; }, \"new step reaches mediator\");\n+\n+            runtime.SimulateSleep(TDuration::MilliSeconds(50));\n+            UNIT_ASSERT_C(observedTabletTxs.contains(persistentTxId2),\n+                \"Tablet did not observe a persistent tx \" << persistentTxId2);\n+\n+            Y_UNUSED(sender);\n+            Y_UNUSED(coordinatorId);\n+            Y_UNUSED(mediatorId);\n+\n+            Y_UNUSED(oldTimestamp);\n+            Y_UNUSED(oldCoordinatorSysActorId);\n+            Y_UNUSED(oldCoordinatorUserActorId);\n+\n+            Y_UNUSED(persistentPlanStep);\n+            Y_UNUSED(volatileEmptyPlanStep);\n+        }\n+\n     } // Y_UNIT_TEST_SUITE(CoordinatorVolatile)\n \n } // namespace NKikimr::NFlatTxCoordinator::NTest\n",
  "test_patch": "diff --git a/ydb/library/actors/testlib/test_runtime.cpp b/ydb/library/actors/testlib/test_runtime.cpp\nindex dfa44493a044..12c63197c658 100644\n--- a/ydb/library/actors/testlib/test_runtime.cpp\n+++ b/ydb/library/actors/testlib/test_runtime.cpp\n@@ -834,7 +834,7 @@ namespace NActors {\n         return TMonotonic::MicroSeconds(CurrentTimestamp);\n     }\n \n-    void TTestActorRuntimeBase::UpdateCurrentTime(TInstant newTime) {\n+    void TTestActorRuntimeBase::UpdateCurrentTime(TInstant newTime, bool rewind) {\n         static int counter = 0;\n         ++counter;\n         if (VERBOSE) {\n@@ -842,7 +842,7 @@ namespace NActors {\n         }\n         TGuard<TMutex> guard(Mutex);\n         Y_ABORT_UNLESS(!UseRealThreads);\n-        if (newTime.MicroSeconds() > CurrentTimestamp) {\n+        if (rewind || newTime.MicroSeconds() > CurrentTimestamp) {\n             CurrentTimestamp = newTime.MicroSeconds();\n             for (auto& kv : Nodes) {\n                 AtomicStore(kv.second->ActorSystemTimestamp, CurrentTimestamp);\ndiff --git a/ydb/library/actors/testlib/test_runtime.h b/ydb/library/actors/testlib/test_runtime.h\nindex b7c3f82a0803..9d83426c0e60 100644\n--- a/ydb/library/actors/testlib/test_runtime.h\n+++ b/ydb/library/actors/testlib/test_runtime.h\n@@ -255,7 +255,13 @@ namespace NActors {\n         TIntrusivePtr<IMonotonicTimeProvider> GetMonotonicTimeProvider();\n         TInstant GetCurrentTime() const;\n         TMonotonic GetCurrentMonotonicTime() const;\n-        void UpdateCurrentTime(TInstant newTime);\n+        /**\n+         * When `rewind` is true allows time to go backwards. This is unsafe,\n+         * since both wallclock and monotonic times are currently linked and\n+         * both go backwards, but it may be necessary for testing wallclock\n+         * time oddities.\n+         */\n+        void UpdateCurrentTime(TInstant newTime, bool rewind = false);\n         void AdvanceCurrentTime(TDuration duration);\n         void AddLocalService(const TActorId& actorId, TActorSetupCmd cmd, ui32 nodeIndex = 0);\n         virtual void Initialize();\n",
  "problem_statement": "Coordinator: inconsistent plans due to a race during state migration\nSeems like it is possible to have multiple incompatible plans at the same plan step due to a race, which was found during internal testing of the future 24.3 release. Need to write a test case and a fix.\r\n\r\nSee internal ticket KIKIMR-21697 for details.\n",
  "hints_text": "",
  "created_at": "2024-07-08T10:49:41Z"
}