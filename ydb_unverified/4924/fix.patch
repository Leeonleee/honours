diff --git a/ydb/library/yql/core/common_opt/yql_co_pgselect.cpp b/ydb/library/yql/core/common_opt/yql_co_pgselect.cpp
index 27f74d28b24d..3b72813d139d 100644
--- a/ydb/library/yql/core/common_opt/yql_co_pgselect.cpp
+++ b/ydb/library/yql/core/common_opt/yql_co_pgselect.cpp
@@ -947,6 +947,9 @@ TUsedColumns GatherUsedColumns(const TExprNode::TPtr& result, const TExprNode::T
         for (ui32 i = 0; i < groupTuple->ChildrenSize(); ++i) {
             auto join = groupTuple->Child(i);
             auto joinType = join->Child(0)->Content();
+            if (joinType == "push") {
+                continue;
+            }
             if (join->ChildrenSize() > 2) {
                 Y_ENSURE(join->ChildrenSize() > 3, "Excepted at least 4 args there");
                 Y_ENSURE(join->Child(1)->IsAtom(), "Supported only USING clause there");
@@ -957,7 +960,9 @@ TUsedColumns GatherUsedColumns(const TExprNode::TPtr& result, const TExprNode::T
                     if (lr->Child(0)->IsAtom()) {
                         usedColumns.insert(std::make_pair(TString(lr->Child(0)->Content()), std::make_pair(Max<ui32>(), TString())));
                     }
-                    usedColumns.insert(std::make_pair(TString(lr->Child(1)->Content()), std::make_pair(Max<ui32>(), TString())));
+                    if (lr->Child(1)->IsAtom()) {
+                        usedColumns.insert(std::make_pair(TString(lr->Child(1)->Content()), std::make_pair(Max<ui32>(), TString())));
+                    }
                     joinUsingColumns.emplace_back(ToString(groupNo), join->Child(2)->Child(col)->Content());
                 }
                 continue;
@@ -1441,7 +1446,7 @@ TExprNode::TPtr BuildSingleInputPredicateJoin(TPositionHandle pos, TStringBuf jo
     }
 }
 
-bool GatherJoinInputs(const TExprNode& root, const TExprNode& row, ui32 rightInputIndex, const THashMap<TString, ui32>& memberToInput,
+bool GatherJoinInputs(const TExprNode& root, const TExprNode& row, const THashSet<ui32>& rightInputIndexes, const THashMap<TString, ui32>& memberToInput,
     bool& hasLeftInput, bool& hasRightInput) {
     hasLeftInput = false;
     hasRightInput = false;
@@ -1460,7 +1465,7 @@ bool GatherJoinInputs(const TExprNode& root, const TExprNode& row, ui32 rightInp
         auto name = p->Child(1)->Content();
         auto inputPtr = memberToInput.FindPtr(name);
         YQL_ENSURE(inputPtr);
-        if (*inputPtr == rightInputIndex) {
+        if (rightInputIndexes.contains(*inputPtr)) {
             hasRightInput = true;
         } else {
             hasLeftInput = true;
@@ -1538,23 +1543,43 @@ std::tuple<TVector<ui32>, TExprNode::TListType> BuildJoinGroups(TPositionHandle
 
     ui32 inputIndex = 0;
     for (ui32 groupNo = 0; groupNo < joinOps->Tail().ChildrenSize(); ++groupNo) {
-        groupForIndex.push_back(groupNo);
         auto groupTuple = joinOps->Tail().Child(groupNo);
         if (groupTuple->ChildrenSize() == 0) {
             joinGroups.push_back(cleanedInputs[inputIndex++]);
             continue;
         }
-
-        auto current = cleanedInputs[inputIndex++];
+        TVector<TExprNode::TPtr> stack;
+        TVector<THashSet<ui32>> stackInputIdxs;
         for (ui32 i = 0; i < groupTuple->ChildrenSize(); ++i) {
-            groupForIndex.push_back(groupNo);
-            auto with = cleanedInputs[inputIndex++];
             // current = join current & with
             auto join = groupTuple->Child(i);
             auto joinType = join->Child(0)->Content();
+            if (joinType == "push") {
+                stackInputIdxs.emplace_back();
+                stackInputIdxs.back().emplace(inputIndex);
+                stack.push_back(cleanedInputs[inputIndex++]);
+                groupForIndex.push_back(groupNo);
+                continue;
+            }
+            auto with = stack.back();
+            stack.pop_back();
+            auto current = stack.back();
+            stack.pop_back();
+
+            auto rightIdxs = stackInputIdxs.back();
+            stackInputIdxs.pop_back();
+            auto leftIdxs = stackInputIdxs.back();
+            stackInputIdxs.pop_back();
+
+            THashSet<ui32> newIndexes = rightIdxs;
+            for (auto e: leftIdxs) {
+                newIndexes.emplace(e);
+            }
+            
             auto cartesian = JoinColumns(pos, current, with, nullptr, {}, ctx);
             if (joinType == "cross") {
-                current = cartesian;
+                stackInputIdxs.emplace_back(std::move(newIndexes));
+                stack.push_back(cartesian);
                 continue;
             }
             if (join->ChildrenSize() > 2) {
@@ -1566,14 +1591,51 @@ std::tuple<TVector<ui32>, TExprNode::TListType> BuildJoinGroups(TPositionHandle
                 TExprNode::TListType leftColumns;
                 TExprNode::TListType rightColumns;
                 TExprNode::TListType toRemove;
+                auto buildRenameLambda = [&ctx, &pos] (const TExprNode::TPtr& newName, const TExprNode::TPtr& oldName) {
+                    return ctx.Builder(pos)
+                        .Lambda()
+                            .Param("row")
+                            .Callable(0, "RemoveMember")
+                                .Callable(0, "AddMember")
+                                    .Arg(0, "row")
+                                    .Add(1, newName)
+                                    .Callable(2, "Member")
+                                        .Arg(0, "row")
+                                        .Add(1, oldName)
+                                    .Seal()
+                                .Seal()
+                                .Add(1, oldName)
+                            .Seal()
+                        .Seal().Build();
+                };
+
                 for (auto& col: join->Child(3)->ChildrenList()) {
                     if (col->Child(0)->IsAtom()) {
                         leftColumns.push_back(col->Child(0));
                     } else {
-                        toRemove.push_back(col->Child(0)->Child(0));
-                        leftColumns.push_back(col->Child(0)->Child(0));
+                        auto pname = col->Child(0)->Child(0);
+                        auto lname = ctx.Builder(pos).Atom(TString("_left_.") + pname->Content()).Build();
+                        left = ctx.Builder(pos)
+                            .Callable("OrderedMap")
+                                .Add(0, left)
+                                .Add(1, buildRenameLambda(lname, pname))
+                            .Seal().Build();
+                        toRemove.push_back(lname);
+                        leftColumns.push_back(lname);
+                    }
+                    if (col->Child(1)->IsAtom()) {
+                        rightColumns.push_back(col->Child(1));
+                    } else {
+                        auto pname = col->Child(1)->Child(0);
+                        auto lname = ctx.Builder(pos).Atom(TString("_right_.") + pname->Content()).Build();
+                        right = ctx.Builder(pos)
+                            .Callable("OrderedMap")
+                                .Add(0, right)
+                                .Add(1, buildRenameLambda(lname, pname))
+                            .Seal().Build();
+                        toRemove.push_back(lname);
+                        rightColumns.push_back(lname);
                     }
-                    rightColumns.push_back(col->Child(1));
                 }
                 current = BuildEquiJoin(pos, joinType, left, right, leftColumns, rightColumns, ctx);
                 auto secondStruct = ctx.Builder(pos)
@@ -1634,21 +1696,25 @@ std::tuple<TVector<ui32>, TExprNode::TListType> BuildJoinGroups(TPositionHandle
                         .Seal()
                     .Seal()
                     .Build();
+                stackInputIdxs.emplace_back(std::move(newIndexes));
+                stack.push_back(current);
                 continue;
             }
 
             auto predicate = join->Tail().TailPtr();
             if (!IsDepended(predicate->Tail(), predicate->Head().Head())) {
-                current = BuildConstPredicateJoin(pos, joinType, predicate, cartesian, current, with, ctx);
+                stackInputIdxs.emplace_back(std::move(newIndexes));
+                stack.push_back(BuildConstPredicateJoin(pos, joinType, predicate, cartesian, current, with, ctx));
                 continue;
             }
 
             // collect inputs from predicate
             bool hasLeftInput;
             bool hasRightInput;
-            if (GatherJoinInputs(predicate->Tail(), predicate->Head().Head(), inputIndex - 1, memberToInput, hasLeftInput, hasRightInput)) {
+            if (GatherJoinInputs(predicate->Tail(), predicate->Head().Head(), rightIdxs, memberToInput, hasLeftInput, hasRightInput)) {
                 if (hasLeftInput && !hasRightInput) {
-                    current = BuildSingleInputPredicateJoin(pos, joinType, predicate, current, with, ctx);
+                    stackInputIdxs.emplace_back(std::move(newIndexes));
+                    stack.push_back(BuildSingleInputPredicateJoin(pos, joinType, predicate, current, with, ctx));
                     continue;
                 } else if (!hasLeftInput && hasRightInput) {
                     auto reverseJoinType = joinType;
@@ -1658,7 +1724,8 @@ std::tuple<TVector<ui32>, TExprNode::TListType> BuildJoinGroups(TPositionHandle
                         reverseJoinType = "left";
                     }
 
-                    current = BuildSingleInputPredicateJoin(pos, reverseJoinType, predicate, with, current, ctx);
+                    stackInputIdxs.emplace_back(std::move(newIndexes));
+                    stack.push_back(BuildSingleInputPredicateJoin(pos, reverseJoinType, predicate, with, current, ctx));
                     continue;
                 } else if (hasLeftInput && hasRightInput) {
                     TExprNode::TListType andTerms;
@@ -1676,7 +1743,7 @@ std::tuple<TVector<ui32>, TExprNode::TListType> BuildJoinGroups(TPositionHandle
                             continue;
                         }
 
-                        YQL_ENSURE(GatherJoinInputs(*andTerm, predicate->Head().Head(), inputIndex - 1, memberToInput, hasLeftInput, hasRightInput));
+                        YQL_ENSURE(GatherJoinInputs(*andTerm, predicate->Head().Head(), rightIdxs, memberToInput, hasLeftInput, hasRightInput));
                         if (!hasLeftInput && !hasRightInput) {
                             bad = true;
                             break;
@@ -1702,7 +1769,7 @@ std::tuple<TVector<ui32>, TExprNode::TListType> BuildJoinGroups(TPositionHandle
                         if (left->IsCallable("Member") && &left->Head() == &predicate->Head().Head()) {
                             auto inputPtr = memberToInput.FindPtr(left->Child(1)->Content());
                             YQL_ENSURE(inputPtr);
-                            leftOnLeft = (*inputPtr < inputIndex - 1);
+                            leftOnLeft = leftIdxs.contains(*inputPtr);
                             (leftOnLeft ? leftColumns : rightColumns).push_back(left->ChildPtr(1));
                         } else {
                             bad = true;
@@ -1713,7 +1780,7 @@ std::tuple<TVector<ui32>, TExprNode::TListType> BuildJoinGroups(TPositionHandle
                         if (right->IsCallable("Member") && &right->Head() == &predicate->Head().Head()) {
                             auto inputPtr = memberToInput.FindPtr(right->Child(1)->Content());
                             YQL_ENSURE(inputPtr);
-                            rightOnRight = (*inputPtr == inputIndex - 1);
+                            rightOnRight = rightIdxs.contains(*inputPtr);
                             (rightOnRight ? rightColumns : leftColumns).push_back(right->ChildPtr(1));
                         } else {
                             bad = true;
@@ -1784,7 +1851,8 @@ std::tuple<TVector<ui32>, TExprNode::TListType> BuildJoinGroups(TPositionHandle
                                 .Build();
                         }
 
-                        current = joined;
+                        stackInputIdxs.emplace_back(std::move(newIndexes));
+                        stack.push_back(joined);
                         continue;
                     }
                 }
@@ -1792,34 +1860,38 @@ std::tuple<TVector<ui32>, TExprNode::TListType> BuildJoinGroups(TPositionHandle
 
             auto filteredCartesian = BuildFilter(pos, cartesian, predicate, {}, {}, ctx, optCtx);
             if (joinType == "inner") {
-                current = filteredCartesian;
+                stackInputIdxs.emplace_back(std::move(newIndexes));
+                stack.push_back(filteredCartesian);
             } else if (joinType == "left") {
-                current = ctx.Builder(pos)
+                stackInputIdxs.emplace_back(std::move(newIndexes));
+                stack.push_back(ctx.Builder(pos)
                     .Callable("UnionAll")
                         .Add(0, filteredCartesian)
                         .Add(1, BuildMinus(pos, current, with, predicate, ctx))
                     .Seal()
-                    .Build();
+                    .Build());
             } else if (joinType == "right") {
-                current = ctx.Builder(pos)
+                stackInputIdxs.emplace_back(std::move(newIndexes));
+                stack.push_back(ctx.Builder(pos)
                     .Callable("UnionAll")
                         .Add(0, filteredCartesian)
                         .Add(1, BuildMinus(pos, with, current, predicate, ctx))
                     .Seal()
-                    .Build();
+                    .Build());
             } else {
                 YQL_ENSURE(joinType == "full");
-                current = ctx.Builder(pos)
+                stackInputIdxs.emplace_back(std::move(newIndexes));
+                stack.push_back(ctx.Builder(pos)
                     .Callable("UnionAll")
                         .Add(0, filteredCartesian)
                         .Add(1, BuildMinus(pos, current, with, predicate, ctx))
                         .Add(2, BuildMinus(pos, with, current, predicate, ctx))
                     .Seal()
-                    .Build();
+                    .Build());
             }
         }
-
-        joinGroups.push_back(current);
+        Y_ENSURE(stack.size() == 1, "Expected stack.size() == 1 after all joins");
+        joinGroups.push_back(stack.back());
     }
 
     return { groupForIndex, joinGroups };
diff --git a/ydb/library/yql/core/type_ann/type_ann_pg.cpp b/ydb/library/yql/core/type_ann/type_ann_pg.cpp
index daee760b6bb2..0548dc2ccf10 100644
--- a/ydb/library/yql/core/type_ann/type_ann_pg.cpp
+++ b/ydb/library/yql/core/type_ann/type_ann_pg.cpp
@@ -4068,8 +4068,15 @@ IGraphTransformer::TStatus PgSetItemWrapper(const TExprNode::TPtr& input, TExprN
                         if (!EnsureTuple(*child, ctx.Expr)) {
                             return IGraphTransformer::TStatus::Error;
                         }
-
-                        totalTupleSizes += child->ChildrenSize() + 1;
+                        for (const auto& e: child->Children()) {
+                            if (!EnsureTupleMinSize(*e, 1, ctx.Expr)) {
+                                return IGraphTransformer::TStatus::Error;
+                            }
+                            if (!EnsureAtom(e->Head(), ctx.Expr)) {
+                                return IGraphTransformer::TStatus::Error;
+                            }
+                            totalTupleSizes += e->Head().Content() == "push";
+                        }
                     }
 
                     if (totalTupleSizes != inputs.size()) {
@@ -4084,8 +4091,6 @@ IGraphTransformer::TStatus PgSetItemWrapper(const TExprNode::TPtr& input, TExprN
                     ui32 inputIndex = 0;
                     THashSet<TString> usedInUsingBefore;
                     for (ui32 joinGroupNo = 0; joinGroupNo < data.ChildrenSize(); ++joinGroupNo) {
-                        joinInputs.push_back(inputs[inputIndex]);
-                        ++inputIndex;
                         // same names allowed in group, but not allowed in different since columns must not repeat
                         THashSet<TString> usedInUsingInThatGroup;
                         for (ui32 i = 0; i < data.Child(joinGroupNo)->ChildrenSize(); ++i) {
@@ -4099,6 +4104,11 @@ IGraphTransformer::TStatus PgSetItemWrapper(const TExprNode::TPtr& input, TExprN
                             }
 
                             auto joinType = child->Head().Content();
+                            if (joinType == "push") {
+                                joinInputs.push_back(inputs[inputIndex++]);
+                                continue;
+                            }
+
                             if (joinType != "cross" && joinType != "inner" && joinType != "left"
                                 && joinType != "right" && joinType != "full") {
                                 ctx.Expr.AddError(TIssue(ctx.Expr.GetPosition(option->Head().Pos()),
@@ -4110,9 +4120,6 @@ IGraphTransformer::TStatus PgSetItemWrapper(const TExprNode::TPtr& input, TExprN
                                 if (!EnsureTupleSize(*child, 1, ctx.Expr)) {
                                     return IGraphTransformer::TStatus::Error;
                                 }
-
-                                joinInputs.push_back(inputs[inputIndex]);
-                                ++inputIndex;
                             }
                             else {
                                 if (!EnsureTupleMinSize(*child, 2, ctx.Expr)) {
@@ -4127,8 +4134,6 @@ IGraphTransformer::TStatus PgSetItemWrapper(const TExprNode::TPtr& input, TExprN
                                     }
                                 }
 
-                                joinInputs.push_back(inputs[inputIndex]);
-                                ++inputIndex;
                                 if (rightSideIsOptional) {
                                     MakeOptionalColumns(joinInputs.back().Type, ctx.Expr);
                                 }
@@ -4172,24 +4177,49 @@ IGraphTransformer::TStatus PgSetItemWrapper(const TExprNode::TPtr& input, TExprN
                             TInputs groupInputs;
                             THashSet<TString> usedInUsingBefore;
                             THashSet<TString> groupPossibleAliases;
-                            if (data.Child(joinGroupNo)->ChildrenSize() > 0) {
-                                groupInputs.push_back(inputs[inputIndex]);
-                                auto alias = inputs[inputIndex].Alias;
-                                if (!alias.empty()) {
-                                    groupPossibleAliases.insert(alias);
-                                }
-                            }
+                            TVector<TVector<ui32>> indexes;
+                            TVector<THashMap<TString, TString>> usingNames;
 
-                            ++inputIndex;
-                            for (ui32 i = 0; i < data.Child(joinGroupNo)->ChildrenSize(); ++i, ++inputIndex) {
-                                groupInputs.push_back(inputs[inputIndex]);
-                                auto alias = inputs[inputIndex].Alias;
-                                if (!alias.empty()) {
-                                    groupPossibleAliases.insert(alias);
-                                }
+                            for (ui32 i = 0; i < data.Child(joinGroupNo)->ChildrenSize(); ++i) {
 
                                 auto child = data.Child(joinGroupNo)->Child(i);
                                 auto joinType = child->Head().Content();
+                                if (joinType == "push") {
+                                    indexes.push_back(TVector{(ui32)groupInputs.size()});
+                                    usingNames.emplace_back();
+                                    groupInputs.push_back(inputs[inputIndex]);
+                                    auto alias = inputs[inputIndex].Alias;
+                                    if (!alias.empty()) {
+                                        groupPossibleAliases.insert(alias);
+                                    }
+                                    ++inputIndex;
+                                    newGroupItems.push_back(data.Child(joinGroupNo)->ChildPtr(i));
+                                    continue;
+                                }
+
+                                auto rightSide = indexes.back();
+                                indexes.pop_back();
+                                auto leftSide = indexes.back();
+                                indexes.pop_back();
+                                auto newVal = leftSide;
+                                for (auto& e: rightSide) {
+                                    newVal.push_back(e);
+                                }
+
+                                auto rightSideUsing = usingNames.back();
+                                usingNames.pop_back();
+                                auto leftSideUsing = usingNames.back();
+                                usingNames.pop_back();
+
+                                indexes.emplace_back(std::move(newVal));
+
+                                auto sideUsing = leftSideUsing;
+                                for (auto& e: rightSideUsing) {
+                                    sideUsing[e.first] = e.second;
+                                }
+
+                                usingNames.emplace_back(std::move(sideUsing));
+
                                 if (joinType == "cross") {
                                     newGroupItems.push_back(data.Child(joinGroupNo)->ChildPtr(i));
                                 } else if (needRewrite && child->ChildrenSize() > 1 && child->Child(1)->Content() != "using") {
@@ -4237,14 +4267,13 @@ IGraphTransformer::TStatus PgSetItemWrapper(const TExprNode::TPtr& input, TExprN
                                     for (ui32 colIdx = 0; colIdx < inp->ChildrenSize(); ++colIdx) {
                                         auto name = inp->Child(colIdx)->Content();
                                         TExprNode::TListType lrNames(2);
-                                        auto& rightInput = groupInputs.back();
                                         auto lcase = to_lower(TString(name));
-                                        if (usedInUsingBefore.contains(lcase)) {
-                                            // when a join b using (x) join c using (x) => remove x from output projection of first join marked as list
-                                            lrNames[0] = ctx.Expr.NewList(inp->Pos(), {ctx.Expr.NewAtom(inp->Pos(), repeatedColumnsInUsing[lcase])});
+
+                                        if (leftSideUsing.contains(lcase)) {
+                                            lrNames[0] = ctx.Expr.NewList(inp->Pos(), {ctx.Expr.NewAtom(inp->Pos(), leftSideUsing[lcase])});
                                         } else {
                                             int matchCount = 0;
-                                            for (size_t j = 0; j <= groupInputs.size() - 2; ++j) {
+                                            for (const auto& j: leftSide) {
                                                 bool isVirtual;
                                                 auto pos = groupInputs[j].Type->FindItemI(name, &isVirtual);
                                                 if (!pos) {
@@ -4262,14 +4291,31 @@ IGraphTransformer::TStatus PgSetItemWrapper(const TExprNode::TPtr& input, TExprN
                                                 return IGraphTransformer::TStatus::Error;
                                             }
                                         }
-                                        bool isVirtual;
-                                        auto pos = rightInput.Type->FindItemI(name, &isVirtual);
-                                        usedInUsingBefore.emplace(lcase);
-                                        if (!pos) {
-                                            ctx.Expr.AddError(TIssue(ctx.Expr.GetPosition(child->Pos()), TStringBuilder() << "Can't find column: " << name));
-                                            return IGraphTransformer::TStatus::Error;
+                                        
+                                        if (rightSideUsing.contains(lcase)) {
+                                            lrNames[1] = ctx.Expr.NewList(inp->Pos(), {ctx.Expr.NewAtom(inp->Pos(), rightSideUsing[lcase])});
+                                        } else {
+                                            int matchCount = 0;
+                                            for (const auto& j: rightSide) {
+                                                bool isVirtual;
+                                                auto pos = groupInputs[j].Type->FindItemI(name, &isVirtual);
+                                                if (!pos) {
+                                                    continue;
+                                                }
+                                                lrNames[1] = ctx.Expr.NewAtom(inp->Pos(), MakeAliasedColumn(groupInputs[j].Alias, groupInputs[j].Type->GetItems()[*pos]->GetCleanName(isVirtual)));
+                                                ++matchCount;
+                                            }
+                                            if (!matchCount) {
+                                                ctx.Expr.AddError(TIssue(ctx.Expr.GetPosition(child->Pos()), TStringBuilder() << "Can't find column: " << name));
+                                                return IGraphTransformer::TStatus::Error;
+                                            }
+                                            if (matchCount > 1) {
+                                                ctx.Expr.AddError(TIssue(ctx.Expr.GetPosition(child->Pos()), TStringBuilder() << " common column name \"" << name << "\" appears more than once in right table "));
+                                                return IGraphTransformer::TStatus::Error;
+                                            }
                                         }
-                                        lrNames[1] = ctx.Expr.NewAtom(inp->Pos(), MakeAliasedColumn(rightInput.Alias, rightInput.Type->GetItems()[*pos]->GetCleanName(isVirtual)));
+
+                                        usingNames.back()[lcase] = name;
                                         nodes[colIdx] = ctx.Expr.NewList(inp->Pos(), std::move(lrNames));
                                     }
                                     TExprNode::TListType newJoin(4);
diff --git a/ydb/library/yql/sql/pg/pg_sql.cpp b/ydb/library/yql/sql/pg/pg_sql.cpp
index c8b780ffa422..3058f53732fc 100644
--- a/ydb/library/yql/sql/pg/pg_sql.cpp
+++ b/ydb/library/yql/sql/pg/pg_sql.cpp
@@ -918,7 +918,7 @@ class TConverter : public IPGParseEvents {
                     }
 
                     AddFrom(*p, fromList);
-                    joinOps.push_back(QL());
+                    joinOps.push_back(QL(QL(QA("push"))));
                 } else {
                     TTraverseNodeStack traverseNodeStack;
                     traverseNodeStack.push({ node, false });
@@ -934,6 +934,7 @@ class TConverter : public IPGParseEvents {
                             }
                             AddFrom(*p, fromList);
                             traverseNodeStack.pop();
+                            oneJoinGroup.push_back(QL(QA("push")));
                         } else {
                             auto join = CAST_NODE(JoinExpr, top.first);
                             if (!join->larg || !join->rarg) {
@@ -952,18 +953,8 @@ class TConverter : public IPGParseEvents {
                             }
 
                             if (!top.second) {
-                                if (NodeTag(join->rarg) != T_JoinExpr) {
-                                    traverseNodeStack.push({ join->rarg, false });
-                                }
-                                if (NodeTag(join->larg) != T_JoinExpr) {
-                                    traverseNodeStack.push({ join->larg, false });
-                                }
-                                if (NodeTag(join->rarg) == T_JoinExpr) {
-                                    traverseNodeStack.push({ join->rarg, false });
-                                }
-                                if (NodeTag(join->larg) == T_JoinExpr) {
-                                    traverseNodeStack.push({ join->larg, false });
-                                }
+                                traverseNodeStack.push({ join->rarg, false });
+                                traverseNodeStack.push({ join->larg, false });
                                 top.second = true;
                             } else {
                                 TString op;
