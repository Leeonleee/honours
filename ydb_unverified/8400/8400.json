{
  "repo": "ydb-platform/ydb",
  "pull_number": 8400,
  "instance_id": "ydb-platform__ydb-8400",
  "issue_numbers": [
    "6860"
  ],
  "base_commit": "d74e4a9f67860522f31556cdfcd08e6fa7ce75c6",
  "patch": "diff --git a/ydb/core/driver_lib/run/run.cpp b/ydb/core/driver_lib/run/run.cpp\nindex 463dd5e47f07..3f28f42dda05 100644\n--- a/ydb/core/driver_lib/run/run.cpp\n+++ b/ydb/core/driver_lib/run/run.cpp\n@@ -122,6 +122,7 @@\n #include <ydb/services/ydb/ydb_scripting.h>\n #include <ydb/services/ydb/ydb_table.h>\n #include <ydb/services/ydb/ydb_object_storage.h>\n+#include <ydb/services/tablet/ydb_tablet.h>\n \n #include <ydb/core/fq/libs/init/init.h>\n \n@@ -597,6 +598,8 @@ void TKikimrRunner::InitializeGRpc(const TKikimrRunConfig& runConfig) {\n         names[\"keyvalue\"] = &hasKeyValue;\n         TServiceCfg hasReplication = services.empty();\n         names[\"replication\"] = &hasReplication;\n+        TServiceCfg hasTabletService = services.empty();\n+        names[\"tablet_service\"] = &hasTabletService;\n \n         std::unordered_set<TString> enabled;\n         for (const auto& name : services) {\n@@ -872,6 +875,11 @@ void TKikimrRunner::InitializeGRpc(const TKikimrRunConfig& runConfig) {\n                 grpcRequestProxies[0], hasReplication.IsRlAllowed()));\n         }\n \n+        if (hasTabletService) {\n+            server.AddService(new NGRpcService::TGRpcYdbTabletService(ActorSystem.Get(), Counters, grpcRequestProxies,\n+                hasTabletService.IsRlAllowed(), grpcConfig.GetHandlersPerCompletionQueue()));\n+        }\n+\n         if (ModuleFactories) {\n             for (const auto& service : ModuleFactories->GrpcServiceFactory.Create(enabled, disabled, ActorSystem.Get(), Counters, grpcRequestProxies[0])) {\n                 server.AddService(service);\ndiff --git a/ydb/core/driver_lib/run/ya.make b/ydb/core/driver_lib/run/ya.make\nindex b83ac0465eb7..30a23d8f6528 100644\n--- a/ydb/core/driver_lib/run/ya.make\n+++ b/ydb/core/driver_lib/run/ya.make\n@@ -165,6 +165,7 @@ PEERDIR(\n     ydb/services/persqueue_v1\n     ydb/services/rate_limiter\n     ydb/services/replication\n+    ydb/services/tablet\n     ydb/services/ydb\n )\n \ndiff --git a/ydb/core/engine/minikql/flat_local_tx_minikql.h b/ydb/core/engine/minikql/flat_local_tx_minikql.h\nindex 71f197789a68..62686fdf1b21 100644\n--- a/ydb/core/engine/minikql/flat_local_tx_minikql.h\n+++ b/ydb/core/engine/minikql/flat_local_tx_minikql.h\n@@ -106,7 +106,7 @@ class TFlatLocalMiniKQL : public NTabletFlatExecutor::ITransaction {\n     bool PrepareParams(TTransactionContext &txc, const TAppData *appData) {\n         Y_UNUSED(txc);\n         if (SourceProgram.Params.Binary) {\n-            SerializedMiniKQLParams = SourceProgram.Program.Binary;\n+            SerializedMiniKQLParams = SourceProgram.Params.Binary;\n             return true;\n         }\n \ndiff --git a/ydb/core/grpc_services/audit_dml_operations.cpp b/ydb/core/grpc_services/audit_dml_operations.cpp\nindex 9d428d0c6ba0..272d064755a3 100644\n--- a/ydb/core/grpc_services/audit_dml_operations.cpp\n+++ b/ydb/core/grpc_services/audit_dml_operations.cpp\n@@ -3,6 +3,7 @@\n #include <ydb/public/api/protos/ydb_table.pb.h>\n #include <ydb/public/api/protos/ydb_scripting.pb.h>\n #include <ydb/public/api/protos/ydb_query.pb.h>\n+#include <ydb/public/api/protos/draft/ydb_tablet.pb.h>\n \n #include \"base/base.h\"\n \n@@ -196,4 +197,24 @@ void AuditContextAppend(IAuditCtx* ctx, const Ydb::Query::ExecuteScriptRequest&\n }\n // log updated_row_count collected from ExecuteScriptMetadata.exec_stats?\n \n+// TabletService, ExecuteTabletMiniKQL\n+template <>\n+void AuditContextAppend(IAuditCtx* ctx, const Ydb::Tablet::ExecuteTabletMiniKQLRequest& request) {\n+    if (request.dry_run()) {\n+        return;\n+    }\n+    ctx->AddAuditLogPart(\"tablet_id\", TStringBuilder() << request.tablet_id());\n+    ctx->AddAuditLogPart(\"program_text\", PrepareText(request.program()));\n+}\n+\n+// TabletService, ChangeTabletSchema\n+template <>\n+void AuditContextAppend(IAuditCtx* ctx, const Ydb::Tablet::ChangeTabletSchemaRequest& request) {\n+    if (request.dry_run()) {\n+        return;\n+    }\n+    ctx->AddAuditLogPart(\"tablet_id\", TStringBuilder() << request.tablet_id());\n+    ctx->AddAuditLogPart(\"schema_changes\", PrepareText(request.schema_changes()));\n+}\n+\n } // namespace NKikimr::NGRpcService\ndiff --git a/ydb/core/grpc_services/audit_dml_operations.h b/ydb/core/grpc_services/audit_dml_operations.h\nindex 9c8b600d5aff..f3145e708dd3 100644\n--- a/ydb/core/grpc_services/audit_dml_operations.h\n+++ b/ydb/core/grpc_services/audit_dml_operations.h\n@@ -28,6 +28,13 @@ class ExecuteScriptRequest;\n \n }\n \n+namespace Ydb::Tablet {\n+\n+class ExecuteTabletMiniKQLRequest;\n+class ChangeTabletSchemaRequest;\n+\n+}\n+\n namespace NKikimr::NGRpcService {\n \n class IAuditCtx;\n@@ -80,4 +87,8 @@ template <> void AuditContextAppend(IAuditCtx* ctx, const Ydb::Query::ExecuteQue\n // ExecuteSrcipt\n template <> void AuditContextAppend(IAuditCtx* ctx, const Ydb::Query::ExecuteScriptRequest& request);\n \n+// TabletService\n+template <> void AuditContextAppend(IAuditCtx* ctx, const Ydb::Tablet::ExecuteTabletMiniKQLRequest& request);\n+template <> void AuditContextAppend(IAuditCtx* ctx, const Ydb::Tablet::ChangeTabletSchemaRequest& request);\n+\n } // namespace NKikimr::NGRpcService\ndiff --git a/ydb/core/grpc_services/query/rpc_fetch_script_results.cpp b/ydb/core/grpc_services/query/rpc_fetch_script_results.cpp\nindex e25877095cc3..5f729d990731 100644\n--- a/ydb/core/grpc_services/query/rpc_fetch_script_results.cpp\n+++ b/ydb/core/grpc_services/query/rpc_fetch_script_results.cpp\n@@ -71,7 +71,7 @@ class TFetchScriptResultsRPC : public TRpcRequestActor<TFetchScriptResultsRPC, T\n             return;\n         }\n \n-        Register(NKqp::CreateGetScriptExecutionResultActor(SelfId(), DatabaseName, ExecutionId, req->result_set_index(), RowsOffset, req->rows_limit(), req->rows_limit() ? 0 : MAX_SIZE_LIMIT, Request->GetDeadline()));\n+        Register(NKqp::CreateGetScriptExecutionResultActor(SelfId(), GetDatabaseName(), ExecutionId, req->result_set_index(), RowsOffset, req->rows_limit(), req->rows_limit() ? 0 : MAX_SIZE_LIMIT, Request->GetDeadline()));\n \n         Become(&TFetchScriptResultsRPC::StateFunc);\n     }\ndiff --git a/ydb/core/grpc_services/rpc_backup.cpp b/ydb/core/grpc_services/rpc_backup.cpp\nindex 94a694d759d4..37760e8050d7 100644\n--- a/ydb/core/grpc_services/rpc_backup.cpp\n+++ b/ydb/core/grpc_services/rpc_backup.cpp\n@@ -42,7 +42,7 @@ class TBackupCollectionsRPC\n \n         auto ev = MakeHolder<typename NSchemeShard::TEvBackup::TEvApiMapping<TIn>::TEv>();\n         ev->Record.SetTxId(this->TxId);\n-        ev->Record.SetDatabaseName(this->DatabaseName);\n+        ev->Record.SetDatabaseName(this->GetDatabaseName());\n         if (this->UserToken) {\n             ev->Record.SetUserSID(this->UserToken->GetUserSID());\n         }\ndiff --git a/ydb/core/grpc_services/rpc_cancel_operation.cpp b/ydb/core/grpc_services/rpc_cancel_operation.cpp\nindex 885310b244a2..5b602ddc5341 100644\n--- a/ydb/core/grpc_services/rpc_cancel_operation.cpp\n+++ b/ydb/core/grpc_services/rpc_cancel_operation.cpp\n@@ -43,11 +43,11 @@ class TCancelOperationRPC: public TRpcOperationRequestActor<TCancelOperationRPC,\n     IEventBase* MakeRequest() override {\n         switch (OperationId.GetKind()) {\n         case TOperationId::EXPORT:\n-            return new TEvExport::TEvCancelExportRequest(TxId, DatabaseName, RawOperationId);\n+            return new TEvExport::TEvCancelExportRequest(TxId, GetDatabaseName(), RawOperationId);\n         case TOperationId::IMPORT:\n-            return new TEvImport::TEvCancelImportRequest(TxId, DatabaseName, RawOperationId);\n+            return new TEvImport::TEvCancelImportRequest(TxId, GetDatabaseName(), RawOperationId);\n         case TOperationId::BUILD_INDEX:\n-            return new TEvIndexBuilder::TEvCancelRequest(TxId, DatabaseName, RawOperationId);\n+            return new TEvIndexBuilder::TEvCancelRequest(TxId, GetDatabaseName(), RawOperationId);\n         default:\n             Y_ABORT(\"unreachable\");\n         }\n@@ -141,7 +141,7 @@ class TCancelOperationRPC: public TRpcOperationRequestActor<TCancelOperationRPC,\n     }\n \n     void SendCancelScriptExecutionOperation() {\n-        Send(NKqp::MakeKqpProxyID(SelfId().NodeId()), new NKqp::TEvCancelScriptExecutionOperation(DatabaseName, OperationId));\n+        Send(NKqp::MakeKqpProxyID(SelfId().NodeId()), new NKqp::TEvCancelScriptExecutionOperation(GetDatabaseName(), OperationId));\n     }\n \n private:\ndiff --git a/ydb/core/grpc_services/rpc_export.cpp b/ydb/core/grpc_services/rpc_export.cpp\nindex 6bf1b5c713ad..572b9c34e485 100644\n--- a/ydb/core/grpc_services/rpc_export.cpp\n+++ b/ydb/core/grpc_services/rpc_export.cpp\n@@ -37,7 +37,7 @@ class TExportRPC: public TRpcOperationRequestActor<TDerived, TEvRequest, true>,\n \n         auto ev = MakeHolder<TEvExport::TEvCreateExportRequest>();\n         ev->Record.SetTxId(this->TxId);\n-        ev->Record.SetDatabaseName(this->DatabaseName);\n+        ev->Record.SetDatabaseName(this->GetDatabaseName());\n         if (this->UserToken) {\n             ev->Record.SetUserSID(this->UserToken->GetUserSID());\n         }\n@@ -64,7 +64,7 @@ class TExportRPC: public TRpcOperationRequestActor<TDerived, TEvRequest, true>,\n     TVector<TString> ExtractPaths() {\n         TVector<TString> paths;\n \n-        paths.emplace_back(this->DatabaseName); // first entry is database\n+        paths.emplace_back(this->GetDatabaseName()); // first entry is database\n         ExtractPaths(paths, this->GetProtoRequest()->settings());\n \n         return paths;\n@@ -74,7 +74,7 @@ class TExportRPC: public TRpcOperationRequestActor<TDerived, TEvRequest, true>,\n         Y_ABORT_UNLESS(!paths.empty());\n \n         auto request = MakeHolder<NSchemeCache::TSchemeCacheNavigate>();\n-        request->DatabaseName = this->DatabaseName;\n+        request->DatabaseName = this->GetDatabaseName();\n \n         for (const auto& path : paths) {\n             auto& entry = request->ResultSet.emplace_back();\ndiff --git a/ydb/core/grpc_services/rpc_forget_operation.cpp b/ydb/core/grpc_services/rpc_forget_operation.cpp\nindex 4619222b6de9..2dca82f6a064 100644\n--- a/ydb/core/grpc_services/rpc_forget_operation.cpp\n+++ b/ydb/core/grpc_services/rpc_forget_operation.cpp\n@@ -44,11 +44,11 @@ class TForgetOperationRPC: public TRpcOperationRequestActor<TForgetOperationRPC,\n     IEventBase* MakeRequest() override {\n         switch (OperationId.GetKind()) {\n         case TOperationId::EXPORT:\n-            return new TEvExport::TEvForgetExportRequest(TxId, DatabaseName, RawOperationId);\n+            return new TEvExport::TEvForgetExportRequest(TxId, GetDatabaseName(), RawOperationId);\n         case TOperationId::IMPORT:\n-            return new TEvImport::TEvForgetImportRequest(TxId, DatabaseName, RawOperationId);\n+            return new TEvImport::TEvForgetImportRequest(TxId, GetDatabaseName(), RawOperationId);\n         case TOperationId::BUILD_INDEX:\n-            return new TEvIndexBuilder::TEvForgetRequest(TxId, DatabaseName, RawOperationId);\n+            return new TEvIndexBuilder::TEvForgetRequest(TxId, GetDatabaseName(), RawOperationId);\n         default:\n             Y_ABORT(\"unreachable\");\n         }\n@@ -97,7 +97,7 @@ class TForgetOperationRPC: public TRpcOperationRequestActor<TForgetOperationRPC,\n     }\n \n     void SendForgetScriptExecutionOperation() {\n-        Send(NKqp::MakeKqpProxyID(SelfId().NodeId()), new NKqp::TEvForgetScriptExecutionOperation(DatabaseName, OperationId));\n+        Send(NKqp::MakeKqpProxyID(SelfId().NodeId()), new NKqp::TEvForgetScriptExecutionOperation(GetDatabaseName(), OperationId));\n     }\n \n public:\ndiff --git a/ydb/core/grpc_services/rpc_get_operation.cpp b/ydb/core/grpc_services/rpc_get_operation.cpp\nindex 3fdaa8b1d24f..a4a8e3b7656a 100644\n--- a/ydb/core/grpc_services/rpc_get_operation.cpp\n+++ b/ydb/core/grpc_services/rpc_get_operation.cpp\n@@ -56,11 +56,11 @@ class TGetOperationRPC : public TRpcOperationRequestActor<TGetOperationRPC, TEvG\n     IEventBase* MakeRequest() override {\n         switch (OperationId_.GetKind()) {\n         case TOperationId::EXPORT:\n-            return new NSchemeShard::TEvExport::TEvGetExportRequest(DatabaseName, RawOperationId_);\n+            return new NSchemeShard::TEvExport::TEvGetExportRequest(GetDatabaseName(), RawOperationId_);\n         case TOperationId::IMPORT:\n-            return new NSchemeShard::TEvImport::TEvGetImportRequest(DatabaseName, RawOperationId_);\n+            return new NSchemeShard::TEvImport::TEvGetImportRequest(GetDatabaseName(), RawOperationId_);\n         case TOperationId::BUILD_INDEX:\n-            return new NSchemeShard::TEvIndexBuilder::TEvGetRequest(DatabaseName, RawOperationId_);\n+            return new NSchemeShard::TEvIndexBuilder::TEvGetRequest(GetDatabaseName(), RawOperationId_);\n         default:\n             Y_ABORT(\"unreachable\");\n         }\n@@ -199,7 +199,7 @@ class TGetOperationRPC : public TRpcOperationRequestActor<TGetOperationRPC, TEvG\n     }\n \n     void SendGetScriptExecutionOperation() {\n-        Send(NKqp::MakeKqpProxyID(SelfId().NodeId()), new NKqp::TEvGetScriptExecutionOperation(DatabaseName, OperationId_));\n+        Send(NKqp::MakeKqpProxyID(SelfId().NodeId()), new NKqp::TEvGetScriptExecutionOperation(GetDatabaseName(), OperationId_));\n     }\n \n     void Handle(NSchemeShard::TEvExport::TEvGetExportResponse::TPtr& ev, const TActorContext& ctx) {\ndiff --git a/ydb/core/grpc_services/rpc_import.cpp b/ydb/core/grpc_services/rpc_import.cpp\nindex 174e9df84cb9..89061b2f8b65 100644\n--- a/ydb/core/grpc_services/rpc_import.cpp\n+++ b/ydb/core/grpc_services/rpc_import.cpp\n@@ -35,7 +35,7 @@ class TImportRPC: public TRpcOperationRequestActor<TDerived, TEvRequest, true>,\n \n         auto ev = MakeHolder<TEvImport::TEvCreateImportRequest>();\n         ev->Record.SetTxId(this->TxId);\n-        ev->Record.SetDatabaseName(this->DatabaseName);\n+        ev->Record.SetDatabaseName(this->GetDatabaseName());\n         if (this->UserToken) {\n             ev->Record.SetUserSID(this->UserToken->GetUserSID());\n         }\ndiff --git a/ydb/core/grpc_services/rpc_import_data.cpp b/ydb/core/grpc_services/rpc_import_data.cpp\nindex 250421386d10..75565ebcb31c 100644\n--- a/ydb/core/grpc_services/rpc_import_data.cpp\n+++ b/ydb/core/grpc_services/rpc_import_data.cpp\n@@ -120,7 +120,7 @@ class TImportDataRPC: public TRpcRequestActor<TImportDataRPC, TEvImportDataReque\n \n     void ResolvePath() {\n         auto request = MakeHolder<TNavigate>();\n-        request->DatabaseName = NKikimr::CanonizePath(DatabaseName);\n+        request->DatabaseName = NKikimr::CanonizePath(GetDatabaseName());\n \n         auto& entry = request->ResultSet.emplace_back();\n         entry.Operation = TNavigate::OpTable;\n@@ -179,7 +179,7 @@ class TImportDataRPC: public TRpcRequestActor<TImportDataRPC, TEvImportDataReque\n \n     void ResolveKeys() {\n         auto request = MakeHolder<TResolve>();\n-        request->DatabaseName = NKikimr::CanonizePath(DatabaseName);\n+        request->DatabaseName = NKikimr::CanonizePath(GetDatabaseName());\n \n         request->ResultSet.emplace_back(std::move(KeyDesc));\n         request->ResultSet.back().Access = NACLib::UpdateRow;\ndiff --git a/ydb/core/grpc_services/rpc_list_operations.cpp b/ydb/core/grpc_services/rpc_list_operations.cpp\nindex 20742675b5f7..47805e7b56d0 100644\n--- a/ydb/core/grpc_services/rpc_list_operations.cpp\n+++ b/ydb/core/grpc_services/rpc_list_operations.cpp\n@@ -54,13 +54,13 @@ class TListOperationsRPC: public TRpcOperationRequestActor<TListOperationsRPC, T\n \n         switch (ParseKind(GetProtoRequest()->kind())) {\n         case TOperationId::SS_BG_TASKS:\n-            return new NSchemeShard::NBackground::TEvListRequest(DatabaseName, request.page_size(), request.page_token());\n+            return new NSchemeShard::NBackground::TEvListRequest(GetDatabaseName(), request.page_size(), request.page_token());\n         case TOperationId::EXPORT:\n-            return new TEvExport::TEvListExportsRequest(DatabaseName, request.page_size(), request.page_token(), request.kind());\n+            return new TEvExport::TEvListExportsRequest(GetDatabaseName(), request.page_size(), request.page_token(), request.kind());\n         case TOperationId::IMPORT:\n-            return new TEvImport::TEvListImportsRequest(DatabaseName, request.page_size(), request.page_token(), request.kind());\n+            return new TEvImport::TEvListImportsRequest(GetDatabaseName(), request.page_size(), request.page_token(), request.kind());\n         case TOperationId::BUILD_INDEX:\n-            return new TEvIndexBuilder::TEvListRequest(DatabaseName, request.page_size(), request.page_token());\n+            return new TEvIndexBuilder::TEvListRequest(GetDatabaseName(), request.page_size(), request.page_token());\n         default:\n             Y_ABORT(\"unreachable\");\n         }\n@@ -141,7 +141,7 @@ class TListOperationsRPC: public TRpcOperationRequestActor<TListOperationsRPC, T\n     }\n \n     void SendListScriptExecutions() {\n-        Send(NKqp::MakeKqpProxyID(SelfId().NodeId()), new NKqp::TEvListScriptExecutionOperations(DatabaseName, GetProtoRequest()->page_size(), GetProtoRequest()->page_token()));\n+        Send(NKqp::MakeKqpProxyID(SelfId().NodeId()), new NKqp::TEvListScriptExecutionOperations(GetDatabaseName(), GetProtoRequest()->page_size(), GetProtoRequest()->page_token()));\n     }\n \n     void Handle(NKqp::TEvListScriptExecutionOperationsResponse::TPtr& ev) {\ndiff --git a/ydb/core/grpc_services/rpc_login.cpp b/ydb/core/grpc_services/rpc_login.cpp\nindex f259181d2e8b..b80e713d74d5 100644\n--- a/ydb/core/grpc_services/rpc_login.cpp\n+++ b/ydb/core/grpc_services/rpc_login.cpp\n@@ -43,7 +43,7 @@ class TLoginRPC : public TRpcRequestActor<TLoginRPC, TEvLoginRequest, true> {\n         const Ydb::Auth::LoginRequest* protoRequest = GetProtoRequest();\n         Credentials = PrepareCredentials(protoRequest->user(), protoRequest->password(), AppData()->AuthConfig);\n         TString domainName = \"/\" + AppData()->DomainsInfo->GetDomain()->Name;\n-        PathToDatabase = AppData()->AuthConfig.GetDomainLoginOnly() ? domainName : DatabaseName;\n+        PathToDatabase = AppData()->AuthConfig.GetDomainLoginOnly() ? domainName : GetDatabaseName();\n         auto sendParameters = GetSendParameters(Credentials, PathToDatabase);\n         Send(sendParameters.Recipient, sendParameters.Event.Release());\n         Become(&TThis::StateWork, Timeout, new TEvents::TEvWakeup());\ndiff --git a/ydb/core/grpc_services/rpc_operation_request_base.h b/ydb/core/grpc_services/rpc_operation_request_base.h\nindex cf8cca65c18b..14548d11dfd0 100644\n--- a/ydb/core/grpc_services/rpc_operation_request_base.h\n+++ b/ydb/core/grpc_services/rpc_operation_request_base.h\n@@ -47,14 +47,14 @@ class TRpcOperationRequestActor: public TRpcRequestActor<TDerived, TEvRequest, H\n \n     void ResolveDatabase() {\n         LOG_D(\"Resolve database\"\n-            << \": name# \" << this->DatabaseName);\n+            << \": name# \" << this->GetDatabaseName());\n \n         auto request = MakeHolder<NSchemeCache::TSchemeCacheNavigate>();\n-        request->DatabaseName = this->DatabaseName;\n+        request->DatabaseName = this->GetDatabaseName();\n \n         auto& entry = request->ResultSet.emplace_back();\n         entry.Operation = NSchemeCache::TSchemeCacheNavigate::OpPath;\n-        entry.Path = NKikimr::SplitPath(this->DatabaseName);\n+        entry.Path = NKikimr::SplitPath(this->GetDatabaseName());\n \n         this->Send(MakeSchemeCacheID(), new TEvTxProxySchemeCache::TEvNavigateKeySet(request.Release()));\n     }\ndiff --git a/ydb/core/grpc_services/rpc_request_base.h b/ydb/core/grpc_services/rpc_request_base.h\nindex 3a8ff0f57803..e1ec39ace266 100644\n--- a/ydb/core/grpc_services/rpc_request_base.h\n+++ b/ydb/core/grpc_services/rpc_request_base.h\n@@ -128,10 +128,16 @@ class TRpcRequestActor: public TActorBootstrapped<TDerived> {\n \n     explicit TRpcRequestActor(TRequestCtx* ev)\n         : Request(ev)\n-        , DatabaseName(Request->GetDatabaseName().GetOrElse(DatabaseFromDomain(AppData())))\n+        , UserToken(CreateUserToken(Request.Get()))\n     {\n-        if (const auto& userToken = Request->GetSerializedToken()) {\n-            UserToken = MakeHolder<NACLib::TUserToken>(userToken);\n+    }\n+\n+private:\n+    static THolder<const NACLib::TUserToken> CreateUserToken(TRequestCtx* request) {\n+        if (const auto& userToken = request->GetSerializedToken()) {\n+            return MakeHolder<NACLib::TUserToken>(userToken);\n+        } else {\n+            return {};\n         }\n     }\n \n@@ -164,9 +170,24 @@ class TRpcRequestActor: public TActorBootstrapped<TDerived> {\n     }\n \n protected:\n-    THolder<TRequestCtx> Request;\n-    const TString DatabaseName;\n-    THolder<const NACLib::TUserToken> UserToken;\n+    const TString& GetDatabaseName() const {\n+        if (!DatabaseName_.has_value()) {\n+            auto name = Request->GetDatabaseName();\n+            if (name) {\n+                DatabaseName_.emplace(std::move(*name));\n+            } else {\n+                DatabaseName_.emplace(DatabaseFromDomain(AppData()));\n+            }\n+        }\n+        return *DatabaseName_;\n+    }\n+\n+protected:\n+    const THolder<TRequestCtx> Request;\n+    const THolder<const NACLib::TUserToken> UserToken;\n+\n+private:\n+    mutable std::optional<TString> DatabaseName_;\n \n }; // TRpcRequestActor\n \ndiff --git a/ydb/core/grpc_services/tablet/rpc_change_schema.cpp b/ydb/core/grpc_services/tablet/rpc_change_schema.cpp\nnew file mode 100644\nindex 000000000000..72a2f5af8455\n--- /dev/null\n+++ b/ydb/core/grpc_services/tablet/rpc_change_schema.cpp\n@@ -0,0 +1,160 @@\n+#include \"rpc_change_schema.h\"\n+#include \"service_tablet.h\"\n+\n+#include <ydb/core/grpc_services/rpc_request_base.h>\n+#include <ydb/core/grpc_services/audit_dml_operations.h>\n+#include <ydb/core/base/tablet.h>\n+#include <ydb/core/base/tablet_pipe.h>\n+#include <ydb/core/protos/scheme_log.pb.h>\n+\n+#include <library/cpp/protobuf/json/json2proto.h>\n+#include <library/cpp/protobuf/json/proto2json.h>\n+\n+namespace NKikimr::NGRpcService {\n+\n+class TRpcChangeTabletSchema : public TRpcRequestActor<TRpcChangeTabletSchema, TEvChangeTabletSchemaRequest> {\n+    using TBase = TRpcRequestActor<TRpcChangeTabletSchema, TEvChangeTabletSchemaRequest>;\n+\n+public:\n+    using TBase::TBase;\n+\n+    void Bootstrap() {\n+        if (!CheckAccess()) {\n+            auto error = TStringBuilder() << \"Access denied\";\n+            if (this->UserToken) {\n+                error << \": '\" << this->UserToken->GetUserSID() << \"' is not an admin\";\n+            }\n+\n+            this->Reply(Ydb::StatusIds::UNAUTHORIZED, NKikimrIssues::TIssuesIds::ACCESS_DENIED, error);\n+            return;\n+        }\n+\n+        auto* req = this->GetProtoRequest();\n+        AuditContextAppend(Request.Get(), *req);\n+\n+        try {\n+            TabletId = req->tablet_id();\n+            TabletReq = std::make_unique<TEvTablet::TEvLocalSchemeTx>();\n+            if (const auto& changes = req->schema_changes(); !changes.empty()) {\n+                NProtobufJson::Json2Proto(changes, *TabletReq->Record.MutableSchemeChanges(), {\n+                    .FieldNameMode = NProtobufJson::TJson2ProtoConfig::FieldNameSnakeCaseDense,\n+                    .AllowUnknownFields = false,\n+                    .MapAsObject = true,\n+                    .EnumValueMode = NProtobufJson::TJson2ProtoConfig::EnumSnakeCaseInsensitive,\n+                });\n+            }\n+            TabletReq->Record.SetDryRun(req->dry_run());\n+        } catch (const std::exception& e) {\n+            this->Reply(Ydb::StatusIds::BAD_REQUEST, e.what());\n+            return;\n+        }\n+\n+        PipeClient = RegisterWithSameMailbox(NTabletPipe::CreateClient(SelfId(), TabletId, NTabletPipe::TClientRetryPolicy{\n+            // We need at least one retry since local resolver cache may be outdated\n+            .RetryLimitCount = 1,\n+        }));\n+\n+        Schedule(TDuration::Seconds(60), new TEvents::TEvWakeup);\n+\n+        Become(&TThis::StateWork);\n+    }\n+\n+private:\n+    bool CheckAccess() const {\n+        if (AppData()->AdministrationAllowedSIDs.empty()) {\n+            return true;\n+        }\n+\n+        if (!this->UserToken) {\n+            return false;\n+        }\n+\n+        for (const auto& sid : AppData()->AdministrationAllowedSIDs) {\n+            if (this->UserToken->IsExist(sid)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+private:\n+    STFUNC(StateWork) {\n+        switch (ev->GetTypeRewrite()) {\n+            hFunc(TEvTabletPipe::TEvClientConnected, Handle);\n+            hFunc(TEvTabletPipe::TEvClientDestroyed, Handle);\n+            hFunc(TEvTablet::TEvLocalSchemeTxResponse, Handle);\n+            hFunc(TEvents::TEvWakeup, Handle);\n+        }\n+    }\n+\n+    void Handle(TEvTabletPipe::TEvClientConnected::TPtr& ev) {\n+        auto* msg = ev->Get();\n+        if (msg->Status != NKikimrProto::OK) {\n+            this->Reply(Ydb::StatusIds::UNAVAILABLE,\n+                TStringBuilder() << \"Tablet \" << TabletId << \" is unavailable\");\n+            return;\n+        }\n+\n+        NTabletPipe::SendData(SelfId(), PipeClient, TabletReq.release());\n+    }\n+\n+    void Handle(TEvTabletPipe::TEvClientDestroyed::TPtr&) {\n+        this->Reply(Ydb::StatusIds::UNDETERMINED,\n+            TStringBuilder() << \"Tablet \" << TabletId << \" disconnected\");\n+    }\n+\n+    void Handle(TEvTablet::TEvLocalSchemeTxResponse::TPtr& ev) {\n+        NTabletPipe::CloseClient(SelfId(), PipeClient);\n+\n+        auto* msg = ev->Get();\n+        if (msg->Record.GetStatus() != NKikimrProto::OK) {\n+            this->Reply(Ydb::StatusIds::GENERIC_ERROR,\n+                msg->Record.HasErrorReason() ? msg->Record.GetErrorReason() : \"Unknown error\");\n+            return;\n+        }\n+\n+        auto* response = google::protobuf::Arena::CreateMessage<Ydb::Tablet::ChangeTabletSchemaResponse>(Request->GetArena());\n+        response->set_status(Ydb::StatusIds::SUCCESS);\n+        if (msg->Record.HasFullScheme()) {\n+            try {\n+                TString text;\n+                NProtobufJson::Proto2Json(msg->Record.GetFullScheme(), text, {\n+                    .EnumMode = NProtobufJson::TProto2JsonConfig::EnumName,\n+                    .FieldNameMode = NProtobufJson::TProto2JsonConfig::FieldNameSnakeCaseDense,\n+                    .MapAsObject = true,\n+                });\n+                response->set_schema(std::move(text));\n+            } catch (const std::exception& e) {\n+                response->set_status(Ydb::StatusIds::GENERIC_ERROR);\n+                auto* issue = response->add_issues();\n+                issue->set_severity(NYql::TSeverityIds::S_ERROR);\n+                issue->set_message(e.what());\n+            }\n+        }\n+        Request->Reply(response, response->status());\n+        PassAway();\n+    }\n+\n+    void Handle(TEvents::TEvWakeup::TPtr&) {\n+        NTabletPipe::CloseClient(SelfId(), PipeClient);\n+        this->Reply(Ydb::StatusIds::TIMEOUT,\n+            TStringBuilder() << \"Tablet \" << TabletId << \" is not responding\");\n+    }\n+\n+private:\n+    ui64 TabletId;\n+    std::unique_ptr<TEvTablet::TEvLocalSchemeTx> TabletReq;\n+    TActorId PipeClient;\n+};\n+\n+void DoChangeTabletSchemaRequest(std::unique_ptr<IRequestNoOpCtx> p, const IFacilityProvider& f) {\n+    f.RegisterActor(new TRpcChangeTabletSchema(p.release()));\n+}\n+\n+template<>\n+IActor* TEvChangeTabletSchemaRequest::CreateRpcActor(NKikimr::NGRpcService::IRequestNoOpCtx* msg) {\n+    return new TRpcChangeTabletSchema(msg);\n+}\n+\n+} // namespace NKikimr::NGRpcService\ndiff --git a/ydb/core/grpc_services/tablet/rpc_change_schema.h b/ydb/core/grpc_services/tablet/rpc_change_schema.h\nnew file mode 100644\nindex 000000000000..59566e28fc72\n--- /dev/null\n+++ b/ydb/core/grpc_services/tablet/rpc_change_schema.h\n@@ -0,0 +1,11 @@\n+#pragma once\n+#include <ydb/core/grpc_services/base/base.h>\n+#include <ydb/public/api/protos/draft/ydb_tablet.pb.h>\n+\n+namespace NKikimr::NGRpcService {\n+\n+using TEvChangeTabletSchemaRequest = TGrpcRequestNoOperationCall<\n+    Ydb::Tablet::ChangeTabletSchemaRequest,\n+    Ydb::Tablet::ChangeTabletSchemaResponse>;\n+\n+} // namespace NKikimr::NGRpcService\ndiff --git a/ydb/core/grpc_services/tablet/rpc_change_schema_ut.cpp b/ydb/core/grpc_services/tablet/rpc_change_schema_ut.cpp\nnew file mode 100644\nindex 000000000000..1228ab5a3f1a\n--- /dev/null\n+++ b/ydb/core/grpc_services/tablet/rpc_change_schema_ut.cpp\n@@ -0,0 +1,130 @@\n+#include \"rpc_change_schema.h\"\n+#include <ydb/core/testlib/test_client.h>\n+#include <ydb/core/testlib/tablet_helpers.h>\n+#include <ydb/core/grpc_services/local_rpc/local_rpc.h>\n+\n+#include <library/cpp/testing/unittest/registar.h>\n+\n+namespace NKikimr::NGRpcService {\n+\n+using namespace Tests;\n+\n+Y_UNIT_TEST_SUITE(TabletService_ChangeSchema) {\n+\n+    NThreading::TFuture<Ydb::Tablet::ChangeTabletSchemaResponse> ChangeSchema(\n+            TTestActorRuntime& runtime, ui64 tabletId, const TString& changes,\n+            const TString& token = {},\n+            bool dryRun = false)\n+    {\n+        // Cerr << \"ChangeSchema: <<<\" << changes << \">>>\" << Endl;\n+        Ydb::Tablet::ChangeTabletSchemaRequest request;\n+        request.set_tablet_id(tabletId);\n+        request.set_schema_changes(changes);\n+        request.set_dry_run(dryRun);\n+        return NRpcService::DoLocalRpc<TEvChangeTabletSchemaRequest>(\n+            std::move(request), \"/Root\", token, runtime.GetActorSystem(0));\n+    }\n+\n+    TString MakeSchemaChange() {\n+        return R\"__(\n+            {\"delta\": [\n+                {\"delta_type\": \"AddTable\",\n+                 \"table_id\": 5555,\n+                 \"table_name\": \"MyAwesomeTable\"},\n+                {\"delta_type\": \"AddColumn\",\n+                 \"table_id\": 5555,\n+                 \"column_id\": 1,\n+                 \"column_name\": \"MyAwesomeKey\",\n+                 \"column_type\": 4},\n+                {\"delta_type\": \"AddColumnToKey\",\n+                 \"table_id\": 5555,\n+                 \"column_id\": 1}\n+            ]}\n+        )__\";\n+    }\n+\n+    Y_UNIT_TEST(Basics) {\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings.SetDomainName(\"Root\")\n+            .SetUseRealThreads(false);\n+\n+        Tests::TServer::TPtr server = new TServer(serverSettings);\n+        auto& runtime = *server->GetRuntime();\n+\n+        auto sender = runtime.AllocateEdgeActor();\n+        server->SetupRootStoragePools(sender);\n+\n+        ui64 schemeShardId = ChangeStateStorage(Tests::SchemeRoot, server->GetSettings().Domain);\n+\n+        Cerr << \"... reading schema\" << Endl;\n+        auto future = ChangeSchema(runtime, schemeShardId, \"\");\n+        auto result = runtime.WaitFuture(std::move(future));\n+        // Cerr << \"Got result:\\n\" << result.DebugString();\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::SUCCESS, result.DebugString());\n+        UNIT_ASSERT_C(result.schema().StartsWith(R\"__({\"delta\":[{\"delta_type\":\"AddTable\",\"table_id\":1,\"table_name\":\"Paths\"},)__\"), result.schema());\n+\n+        Cerr << \"... changing schema (dry run)\" << Endl;\n+        future = ChangeSchema(runtime, schemeShardId, MakeSchemaChange(), {}, /* dryRun */ true);\n+        result = runtime.WaitFuture(std::move(future));\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::SUCCESS, result.DebugString());\n+        UNIT_ASSERT_C(result.schema().Contains(R\"__({\"delta_type\":\"AddTable\",\"table_id\":5555,\"table_name\":\"MyAwesomeTable\"})__\"), result.schema());\n+\n+        Cerr << \"... reading schema\" << Endl;\n+        future = ChangeSchema(runtime, schemeShardId, \"\");\n+        result = runtime.WaitFuture(std::move(future));\n+        // Cerr << \"Got result:\\n\" << result.DebugString();\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::SUCCESS, result.DebugString());\n+        UNIT_ASSERT_C(!result.schema().Contains(\"MyAwesomeTable\"), result.schema());\n+\n+        Cerr << \"... changing schema\" << Endl;\n+        future = ChangeSchema(runtime, schemeShardId, MakeSchemaChange());\n+        result = runtime.WaitFuture(std::move(future));\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::SUCCESS, result.DebugString());\n+        UNIT_ASSERT_C(result.schema().Contains(R\"__({\"delta_type\":\"AddTable\",\"table_id\":5555,\"table_name\":\"MyAwesomeTable\"})__\"), result.schema());\n+\n+        Cerr << \"... reading schema\" << Endl;\n+        future = ChangeSchema(runtime, schemeShardId, \"\");\n+        result = runtime.WaitFuture(std::move(future));\n+        // Cerr << \"Got result:\\n\" << result.DebugString();\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::SUCCESS, result.DebugString());\n+        UNIT_ASSERT_C(result.schema().Contains(R\"__({\"delta_type\":\"AddTable\",\"table_id\":5555,\"table_name\":\"MyAwesomeTable\"})__\"), result.schema());\n+    }\n+\n+    Y_UNIT_TEST(OnlyAdminsAllowed) {\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings.SetDomainName(\"Root\")\n+            .SetUseRealThreads(false);\n+\n+        Tests::TServer::TPtr server = new TServer(serverSettings);\n+        auto& runtime = *server->GetRuntime();\n+        runtime.GetAppData().AdministrationAllowedSIDs.push_back(\"root@builtin\");\n+\n+        auto sender = runtime.AllocateEdgeActor();\n+        server->SetupRootStoragePools(sender);\n+\n+        ui64 schemeShardId = ChangeStateStorage(Tests::SchemeRoot, server->GetSettings().Domain);\n+\n+        Cerr << \"... reading schema (without token)\" << Endl;\n+        auto future = ChangeSchema(runtime, schemeShardId, \"\");\n+        auto result = runtime.WaitFuture(std::move(future));\n+        // Cerr << \"Got result:\\n\" << result.DebugString();\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::UNAUTHORIZED, result.DebugString());\n+\n+        Cerr << \"... reading schema (non-admin token)\" << Endl;\n+        future = ChangeSchema(runtime, schemeShardId, \"\", NACLib::TUserToken(\"user@builtin\", {}).SerializeAsString());\n+        result = runtime.WaitFuture(std::move(future));\n+        // Cerr << \"Got result:\\n\" << result.DebugString();\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::UNAUTHORIZED, result.DebugString());\n+\n+        Cerr << \"... reading schema (admin token)\" << Endl;\n+        future = ChangeSchema(runtime, schemeShardId, \"\", NACLib::TUserToken(\"root@builtin\", {}).SerializeAsString());\n+        result = runtime.WaitFuture(std::move(future));\n+        // Cerr << \"Got result:\\n\" << result.DebugString();\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::SUCCESS, result.DebugString());\n+    }\n+\n+} // Y_UNIT_TEST_SUITE(TabletService_ChangeSchema)\n+\n+} // namespace NKikimr::NGRpcService\ndiff --git a/ydb/core/grpc_services/tablet/rpc_execute_mkql.cpp b/ydb/core/grpc_services/tablet/rpc_execute_mkql.cpp\nnew file mode 100644\nindex 000000000000..921730f5209f\n--- /dev/null\n+++ b/ydb/core/grpc_services/tablet/rpc_execute_mkql.cpp\n@@ -0,0 +1,208 @@\n+#include \"rpc_execute_mkql.h\"\n+#include \"service_tablet.h\"\n+\n+#include <ydb/core/grpc_services/rpc_request_base.h>\n+#include <ydb/core/grpc_services/audit_dml_operations.h>\n+#include <ydb/core/base/tablet.h>\n+#include <ydb/core/base/tablet_pipe.h>\n+#include <ydb/core/protos/tx_proxy.pb.h>\n+\n+#include <ydb/library/mkql_proto/mkql_proto.h>\n+#include <ydb/library/yql/minikql/computation/mkql_computation_node_holders.h>\n+#include <ydb/library/yql/minikql/mkql_alloc.h>\n+#include <ydb/library/yql/minikql/mkql_mem_info.h>\n+#include <ydb/library/yql/minikql/mkql_node.h>\n+#include <ydb/library/yql/minikql/mkql_node_serialization.h>\n+\n+namespace NKikimr::NGRpcService {\n+\n+\n+class TRpcExecuteTabletMiniKQL : public TRpcRequestActor<TRpcExecuteTabletMiniKQL, TEvExecuteTabletMiniKQLRequest> {\n+    using TBase = TRpcRequestActor<TRpcExecuteTabletMiniKQL, TEvExecuteTabletMiniKQLRequest>;\n+\n+public:\n+    using TBase::TBase;\n+\n+    void Bootstrap() {\n+        if (!CheckAccess()) {\n+            auto error = TStringBuilder() << \"Access denied\";\n+            if (this->UserToken) {\n+                error << \": '\" << this->UserToken->GetUserSID() << \"' is not an admin\";\n+            }\n+\n+            this->Reply(Ydb::StatusIds::UNAUTHORIZED, NKikimrIssues::TIssuesIds::ACCESS_DENIED, error);\n+            return;\n+        }\n+\n+        auto* req = this->GetProtoRequest();\n+        AuditContextAppend(Request.Get(), *req);\n+\n+        try {\n+            TabletId = req->tablet_id();\n+            TabletReq = std::make_unique<TEvTablet::TEvLocalMKQL>();\n+            auto* tx = TabletReq->Record.MutableProgram();\n+            tx->MutableProgram()->SetText(req->program());\n+            if (const auto& params = req->parameters(); !params.empty()) {\n+                auto* functionRegistry = AppData()->FunctionRegistry;\n+                NMiniKQL::TScopedAlloc alloc(__LOCATION__, TAlignedPagePoolCounters(), functionRegistry->SupportsSizedAllocators());\n+                NMiniKQL::TTypeEnvironment env(alloc);\n+                NMiniKQL::TMemoryUsageInfo memInfo(\"TRpcExecuteTabletMiniKQL\");\n+                NMiniKQL::THolderFactory factory(alloc.Ref(), memInfo, functionRegistry);\n+                // NKikimrMiniKQL.TParams\n+                auto* protoParams = tx->MutableParams()->MutableProto();\n+                protoParams->MutableType()->SetKind(NKikimrMiniKQL::ETypeKind::Struct);\n+                auto* protoStructType = protoParams->MutableType()->MutableStruct();\n+                auto* protoValue = protoParams->MutableValue();\n+                for (const auto& pr : params) {\n+                    auto* protoMember = protoStructType->AddMember();\n+                    protoMember->SetName(pr.first);\n+                    auto [pType, value] = NMiniKQL::ImportValueFromProto(pr.second.type(), pr.second.value(), env, factory);\n+                    ExportTypeToProto(pType, *protoMember->MutableType());\n+                    ExportValueToProto(pType, value, *protoValue->AddStruct());\n+                }\n+                // Tablet needs a serialized runtime node for parameters\n+                auto node = NMiniKQL::ImportValueFromProto(*protoParams, env);\n+                tx->MutableParams()->SetBin(NMiniKQL::SerializeRuntimeNode(node, env));\n+                // We no longer need the protobuf parameters\n+                tx->MutableParams()->ClearProto();\n+            }\n+\n+            if (req->dry_run()) {\n+                tx->SetMode(NKikimrTxUserProxy::TMiniKQLTransaction::COMPILE);\n+            }\n+        } catch (const std::exception& e) {\n+            this->Reply(Ydb::StatusIds::BAD_REQUEST, e.what());\n+            return;\n+        }\n+\n+        PipeClient = RegisterWithSameMailbox(NTabletPipe::CreateClient(SelfId(), TabletId, NTabletPipe::TClientRetryPolicy{\n+            // We need at least one retry since local resolver cache may be outdated\n+            .RetryLimitCount = 1,\n+        }));\n+\n+        Schedule(TDuration::Seconds(60), new TEvents::TEvWakeup);\n+\n+        Become(&TThis::StateWork);\n+    }\n+\n+private:\n+    bool CheckAccess() const {\n+        if (AppData()->AdministrationAllowedSIDs.empty()) {\n+            return true;\n+        }\n+\n+        if (!this->UserToken) {\n+            return false;\n+        }\n+\n+        for (const auto& sid : AppData()->AdministrationAllowedSIDs) {\n+            if (this->UserToken->IsExist(sid)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+private:\n+    STFUNC(StateWork) {\n+        switch (ev->GetTypeRewrite()) {\n+            hFunc(TEvTabletPipe::TEvClientConnected, Handle);\n+            hFunc(TEvTabletPipe::TEvClientDestroyed, Handle);\n+            hFunc(TEvTablet::TEvLocalMKQLResponse, Handle);\n+            hFunc(TEvents::TEvWakeup, Handle);\n+        }\n+    }\n+\n+    void Handle(TEvTabletPipe::TEvClientConnected::TPtr& ev) {\n+        auto* msg = ev->Get();\n+        if (msg->Status != NKikimrProto::OK) {\n+            this->Reply(Ydb::StatusIds::UNAVAILABLE,\n+                TStringBuilder() << \"Tablet \" << TabletId << \" is unavailable\");\n+            return;\n+        }\n+\n+        NTabletPipe::SendData(SelfId(), PipeClient, TabletReq.release());\n+    }\n+\n+    void Handle(TEvTabletPipe::TEvClientDestroyed::TPtr&) {\n+        this->Reply(Ydb::StatusIds::UNDETERMINED,\n+            TStringBuilder() << \"Tablet \" << TabletId << \" disconnected\");\n+    }\n+\n+    void Handle(TEvTablet::TEvLocalMKQLResponse::TPtr& ev) {\n+        NTabletPipe::CloseClient(SelfId(), PipeClient);\n+\n+        auto* msg = ev->Get();\n+        auto* response = google::protobuf::Arena::CreateMessage<Ydb::Tablet::ExecuteTabletMiniKQLResponse>(Request->GetArena());\n+\n+        if (msg->Record.HasCompileResults()) {\n+            for (const auto& issue : msg->Record.GetCompileResults().GetProgramCompileErrors()) {\n+                *response->add_issues() = issue;\n+            }\n+            for (const auto& issue : msg->Record.GetCompileResults().GetParamsCompileErrors()) {\n+                *response->add_issues() = issue;\n+            }\n+        }\n+\n+        if (const TString& errors = msg->Record.GetMiniKQLErrors(); !errors.empty()) {\n+            auto* issue = response->add_issues();\n+            issue->set_severity(NYql::TSeverityIds::S_ERROR);\n+            issue->set_message(errors);\n+        }\n+\n+        if (msg->Record.GetStatus() != NKikimrProto::OK) {\n+            response->set_status(Ydb::StatusIds::GENERIC_ERROR);\n+            Request->Reply(response, response->status());\n+            return PassAway();\n+        }\n+\n+        response->set_status(Ydb::StatusIds::SUCCESS);\n+\n+        if (msg->Record.HasExecutionEngineEvaluatedResponse()) {\n+            try {\n+                const auto& protoResult = msg->Record.GetExecutionEngineEvaluatedResponse();\n+                auto* functionRegistry = AppData()->FunctionRegistry;\n+                NMiniKQL::TScopedAlloc alloc(__LOCATION__, TAlignedPagePoolCounters(), functionRegistry->SupportsSizedAllocators());\n+                NMiniKQL::TTypeEnvironment env(alloc);\n+                NMiniKQL::TMemoryUsageInfo memInfo(\"TRpcExecuteTabletMiniKQL\");\n+                NMiniKQL::THolderFactory factory(alloc.Ref(), memInfo, functionRegistry);\n+                auto [pType, value] = NMiniKQL::ImportValueFromProto(protoResult.GetType(), protoResult.GetValue(), env, factory);\n+                ExportTypeToProto(pType, *response->mutable_result()->mutable_type());\n+                ExportValueToProto(pType, value, *response->mutable_result()->mutable_value());\n+            } catch (const std::exception& e) {\n+                response->set_status(Ydb::StatusIds::GENERIC_ERROR);\n+                auto* issue = response->add_issues();\n+                issue->set_severity(NYql::TSeverityIds::S_ERROR);\n+                issue->set_message(e.what());\n+                Request->Reply(response, response->status());\n+                return PassAway();\n+            }\n+        }\n+\n+        Request->Reply(response, response->status());\n+        return PassAway();\n+    }\n+\n+    void Handle(TEvents::TEvWakeup::TPtr&) {\n+        NTabletPipe::CloseClient(SelfId(), PipeClient);\n+        this->Reply(Ydb::StatusIds::TIMEOUT,\n+            TStringBuilder() << \"Tablet \" << TabletId << \" is not responding\");\n+    }\n+\n+private:\n+    ui64 TabletId;\n+    std::unique_ptr<TEvTablet::TEvLocalMKQL> TabletReq;\n+    TActorId PipeClient;\n+};\n+\n+void DoExecuteTabletMiniKQLRequest(std::unique_ptr<IRequestNoOpCtx> p, const IFacilityProvider& f) {\n+    f.RegisterActor(new TRpcExecuteTabletMiniKQL(p.release()));\n+}\n+\n+template<>\n+IActor* TEvExecuteTabletMiniKQLRequest::CreateRpcActor(NKikimr::NGRpcService::IRequestNoOpCtx* msg) {\n+    return new TRpcExecuteTabletMiniKQL(msg);\n+}\n+\n+} // namespace NKikimr::NGRpcService\ndiff --git a/ydb/core/grpc_services/tablet/rpc_execute_mkql.h b/ydb/core/grpc_services/tablet/rpc_execute_mkql.h\nnew file mode 100644\nindex 000000000000..45c5f4421d83\n--- /dev/null\n+++ b/ydb/core/grpc_services/tablet/rpc_execute_mkql.h\n@@ -0,0 +1,11 @@\n+#pragma once\n+#include <ydb/core/grpc_services/base/base.h>\n+#include <ydb/public/api/protos/draft/ydb_tablet.pb.h>\n+\n+namespace NKikimr::NGRpcService {\n+\n+using TEvExecuteTabletMiniKQLRequest = TGrpcRequestNoOperationCall<\n+    Ydb::Tablet::ExecuteTabletMiniKQLRequest,\n+    Ydb::Tablet::ExecuteTabletMiniKQLResponse>;\n+\n+} // namespace NKikimr::NGRpcService\ndiff --git a/ydb/core/grpc_services/tablet/rpc_execute_mkql_ut.cpp b/ydb/core/grpc_services/tablet/rpc_execute_mkql_ut.cpp\nnew file mode 100644\nindex 000000000000..9eb251ec44f1\n--- /dev/null\n+++ b/ydb/core/grpc_services/tablet/rpc_execute_mkql_ut.cpp\n@@ -0,0 +1,285 @@\n+#include \"rpc_execute_mkql.h\"\n+#include <ydb/core/testlib/test_client.h>\n+#include <ydb/core/testlib/tablet_helpers.h>\n+#include <ydb/core/grpc_services/local_rpc/local_rpc.h>\n+\n+#include <library/cpp/testing/unittest/registar.h>\n+\n+namespace NKikimr::NGRpcService {\n+\n+using namespace Tests;\n+\n+Y_UNIT_TEST_SUITE(TabletService_ExecuteMiniKQL) {\n+\n+    Ydb::TypedValue MakeUint64(ui64 value) {\n+        Ydb::TypedValue ret;\n+        ret.mutable_type()->set_type_id(Ydb::Type::UINT64);\n+        ret.mutable_value()->set_uint64_value(value);\n+        return ret;\n+    }\n+\n+    NThreading::TFuture<Ydb::Tablet::ExecuteTabletMiniKQLResponse> ExecuteMiniKQL(\n+            TTestActorRuntime& runtime, ui64 tabletId, const TString& program,\n+            const std::unordered_map<TString, Ydb::TypedValue>& params = {},\n+            const TString& token = {},\n+            bool dryRun = false)\n+    {\n+        // Cerr << \"ExecuteMiniKQL: <<<\" << program << \">>>\" << Endl;\n+        Ydb::Tablet::ExecuteTabletMiniKQLRequest request;\n+        request.set_tablet_id(tabletId);\n+        request.set_program(program);\n+        for (const auto& pr : params) {\n+            (*request.mutable_parameters())[pr.first] = pr.second;\n+        }\n+        request.set_dry_run(dryRun);\n+        return NRpcService::DoLocalRpc<TEvExecuteTabletMiniKQLRequest>(\n+            std::move(request), \"/Root\", token, runtime.GetActorSystem(0));\n+    }\n+\n+    Y_UNIT_TEST(BasicMiniKQLRead) {\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings.SetDomainName(\"Root\")\n+            .SetUseRealThreads(false);\n+\n+        Tests::TServer::TPtr server = new TServer(serverSettings);\n+        auto& runtime = *server->GetRuntime();\n+\n+        auto sender = runtime.AllocateEdgeActor();\n+        server->SetupRootStoragePools(sender);\n+\n+        ui64 schemeShardId = ChangeStateStorage(Tests::SchemeRoot, server->GetSettings().Domain);\n+        auto future = ExecuteMiniKQL(runtime, schemeShardId, R\"___((\n+            (let key '('('Id (Uint64 '1))))\n+            (let select '('Id 'Name))\n+            (return (AsList\n+                (SetResult 'row (SelectRow 'Paths key select))\n+            ))\n+        ))___\");\n+        auto result = runtime.WaitFuture(std::move(future));\n+        // Cerr << \"Got result:\\n\" << result.DebugString();\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::SUCCESS, result.DebugString());\n+        UNIT_ASSERT_VALUES_EQUAL_C(\n+            result.result().value().ShortDebugString(),\n+            \"items { items { uint64_value: 1 } items { text_value: \\\"Root\\\" } }\",\n+            result.DebugString());\n+    }\n+\n+    Y_UNIT_TEST(ParamsMiniKQLRead) {\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings.SetDomainName(\"Root\")\n+            .SetUseRealThreads(false);\n+\n+        Tests::TServer::TPtr server = new TServer(serverSettings);\n+        auto& runtime = *server->GetRuntime();\n+\n+        auto sender = runtime.AllocateEdgeActor();\n+        server->SetupRootStoragePools(sender);\n+\n+        ui64 schemeShardId = ChangeStateStorage(Tests::SchemeRoot, server->GetSettings().Domain);\n+        auto future = ExecuteMiniKQL(runtime, schemeShardId, R\"___((\n+            (let p (Parameter 'p (DataType 'Uint64)))\n+            (let key '('('Id p)))\n+            (let select '('Id 'Name))\n+            (return (AsList\n+                (SetResult 'p p)\n+                (SetResult 'row (SelectRow 'Paths key select))\n+            ))\n+        ))___\", {{\"p\", MakeUint64(1)}});\n+        auto result = runtime.WaitFuture(std::move(future));\n+        // Cerr << \"Got result:\\n\" << result.DebugString();\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::SUCCESS, result.DebugString());\n+        UNIT_ASSERT_VALUES_EQUAL_C(\n+            result.result().value().ShortDebugString(),\n+            \"items { uint64_value: 1 } items { items { uint64_value: 1 } items { text_value: \\\"Root\\\" } }\",\n+            result.DebugString());\n+    }\n+\n+    Ydb::TypedValue MakeMalformedValue() {\n+        Ydb::TypedValue ret;\n+        // Type is a struct with 2 members\n+        Ydb::StructType* s = ret.mutable_type()->mutable_struct_type();\n+        Ydb::StructMember* m1 = s->add_members();\n+        m1->set_name(\"m1\");\n+        m1->mutable_type()->set_type_id(Ydb::Type::UINT64);\n+        Ydb::StructMember* m2 = s->add_members();\n+        m2->set_name(\"m2\");\n+        m2->mutable_type()->set_type_id(Ydb::Type::UINT64);\n+        // Value has only one member: malformed\n+        ret.mutable_value()->add_items()->set_uint64_value(42);\n+        return ret;\n+    }\n+\n+    Y_UNIT_TEST(MalformedParams) {\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings.SetDomainName(\"Root\")\n+            .SetUseRealThreads(false);\n+\n+        Tests::TServer::TPtr server = new TServer(serverSettings);\n+        auto& runtime = *server->GetRuntime();\n+\n+        auto sender = runtime.AllocateEdgeActor();\n+        server->SetupRootStoragePools(sender);\n+\n+        ui64 schemeShardId = ChangeStateStorage(Tests::SchemeRoot, server->GetSettings().Domain);\n+        auto future = ExecuteMiniKQL(runtime, schemeShardId, R\"___((\n+            (let p (Parameter 'p (DataType 'Uint64)))\n+            (let key '('('Id p)))\n+            (let select '('Id 'Name))\n+            (return (AsList\n+                (SetResult 'p p)\n+                (SetResult 'row (SelectRow 'Paths key select))\n+            ))\n+        ))___\", {{\"p\", MakeMalformedValue()}});\n+        auto result = runtime.WaitFuture(std::move(future));\n+        // Cerr << \"Got result:\\n\" << result.DebugString();\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::BAD_REQUEST, result.DebugString());\n+    }\n+\n+    Y_UNIT_TEST(MalformedProgram) {\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings.SetDomainName(\"Root\")\n+            .SetUseRealThreads(false);\n+\n+        Tests::TServer::TPtr server = new TServer(serverSettings);\n+        auto& runtime = *server->GetRuntime();\n+\n+        auto sender = runtime.AllocateEdgeActor();\n+        server->SetupRootStoragePools(sender);\n+\n+        ui64 schemeShardId = ChangeStateStorage(Tests::SchemeRoot, server->GetSettings().Domain);\n+        auto future = ExecuteMiniKQL(runtime, schemeShardId, R\"___((\n+            (let key '('('Id (Uint64 '1))))\n+            (let select '('Id 'Name))\n+            (return (AsList\n+                (SetResult 'row (SelectRow 'NoSuchTable key select))\n+            ))\n+        ))___\");\n+        auto result = runtime.WaitFuture(std::move(future));\n+        // Cerr << \"Got result:\\n\" << result.DebugString();\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::GENERIC_ERROR, result.DebugString());\n+    }\n+\n+    Y_UNIT_TEST(DryRunEraseRow) {\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings.SetDomainName(\"Root\")\n+            .SetUseRealThreads(false);\n+\n+        Tests::TServer::TPtr server = new TServer(serverSettings);\n+        auto& runtime = *server->GetRuntime();\n+\n+        auto sender = runtime.AllocateEdgeActor();\n+        server->SetupRootStoragePools(sender);\n+\n+        ui64 schemeShardId = ChangeStateStorage(Tests::SchemeRoot, server->GetSettings().Domain);\n+        auto future = ExecuteMiniKQL(runtime, schemeShardId, R\"___((\n+            (let key '('('Id (Uint64 '1))))\n+            (return (AsList\n+                (EraseRow 'Paths key)\n+            ))\n+        ))___\", {}, {}, /* dryRun */ true);\n+        auto result = runtime.WaitFuture(std::move(future));\n+        // Cerr << \"Got result (dry run EraseRow):\\n\" << result.DebugString();\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::SUCCESS, result.DebugString());\n+\n+        future = ExecuteMiniKQL(runtime, schemeShardId, R\"___((\n+            (let key '('('Id (Uint64 '1))))\n+            (let select '('Id 'Name))\n+            (return (AsList\n+                (SetResult 'row (SelectRow 'Paths key select))\n+            ))\n+        ))___\");\n+        result = runtime.WaitFuture(std::move(future));\n+        // Cerr << \"Got result (SelectRow):\\n\" << result.DebugString();\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::SUCCESS, result.DebugString());\n+        UNIT_ASSERT_VALUES_EQUAL_C(\n+            result.result().value().ShortDebugString(),\n+            \"items { items { uint64_value: 1 } items { text_value: \\\"Root\\\" } }\",\n+            result.DebugString());\n+\n+        // Repeat request without dry_run\n+        future = ExecuteMiniKQL(runtime, schemeShardId, R\"___((\n+            (let key '('('Id (Uint64 '1))))\n+            (return (AsList\n+                (EraseRow 'Paths key)\n+            ))\n+        ))___\");\n+        result = runtime.WaitFuture(std::move(future));\n+        // Cerr << \"Got result (EraseRow):\\n\" << result.DebugString();\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::SUCCESS, result.DebugString());\n+\n+        future = ExecuteMiniKQL(runtime, schemeShardId, R\"___((\n+            (let key '('('Id (Uint64 '1))))\n+            (let select '('Id 'Name))\n+            (return (AsList\n+                (SetResult 'row (SelectRow 'Paths key select))\n+            ))\n+        ))___\");\n+        result = runtime.WaitFuture(std::move(future));\n+        // Cerr << \"Got result (SelectRow):\\n\" << result.DebugString();\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::SUCCESS, result.DebugString());\n+        UNIT_ASSERT_VALUES_EQUAL_C(\n+            result.result().value().ShortDebugString(),\n+            \"items { nested_value { null_flag_value: NULL_VALUE } }\",\n+            result.DebugString());\n+    }\n+\n+    Y_UNIT_TEST(OnlyAdminsAllowed) {\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings.SetDomainName(\"Root\")\n+            .SetUseRealThreads(false);\n+\n+        Tests::TServer::TPtr server = new TServer(serverSettings);\n+        auto& runtime = *server->GetRuntime();\n+        runtime.GetAppData().AdministrationAllowedSIDs.push_back(\"root@builtin\");\n+\n+        auto sender = runtime.AllocateEdgeActor();\n+        server->SetupRootStoragePools(sender);\n+\n+        ui64 schemeShardId = ChangeStateStorage(Tests::SchemeRoot, server->GetSettings().Domain);\n+        auto future = ExecuteMiniKQL(runtime, schemeShardId, R\"___((\n+            (let key '('('Id (Uint64 '1))))\n+            (let select '('Id 'Name))\n+            (return (AsList\n+                (SetResult 'row (SelectRow 'Paths key select))\n+            ))\n+        ))___\");\n+        auto result = runtime.WaitFuture(std::move(future));\n+        // Cerr << \"Got result:\\n\" << result.DebugString();\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::UNAUTHORIZED, result.DebugString());\n+\n+        future = ExecuteMiniKQL(runtime, schemeShardId, R\"___((\n+            (let key '('('Id (Uint64 '1))))\n+            (let select '('Id 'Name))\n+            (return (AsList\n+                (SetResult 'row (SelectRow 'Paths key select))\n+            ))\n+        ))___\", {}, NACLib::TUserToken(\"user@builtin\", {}).SerializeAsString());\n+        result = runtime.WaitFuture(std::move(future));\n+        // Cerr << \"Got result:\\n\" << result.DebugString();\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::UNAUTHORIZED, result.DebugString());\n+\n+        future = ExecuteMiniKQL(runtime, schemeShardId, R\"___((\n+            (let key '('('Id (Uint64 '1))))\n+            (let select '('Id 'Name))\n+            (return (AsList\n+                (SetResult 'row (SelectRow 'Paths key select))\n+            ))\n+        ))___\", {}, NACLib::TUserToken(\"root@builtin\", {}).SerializeAsString());\n+        result = runtime.WaitFuture(std::move(future));\n+        // Cerr << \"Got result:\\n\" << result.DebugString();\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::SUCCESS, result.DebugString());\n+        UNIT_ASSERT_VALUES_EQUAL_C(\n+            result.result().value().ShortDebugString(),\n+            \"items { items { uint64_value: 1 } items { text_value: \\\"Root\\\" } }\",\n+            result.DebugString());\n+    }\n+\n+} // Y_UNIT_TEST_SUITE(TabletService_ExecuteMiniKQL)\n+\n+} // namespace NKikimr::NGRpcService\ndiff --git a/ydb/core/grpc_services/tablet/rpc_restart_tablet.cpp b/ydb/core/grpc_services/tablet/rpc_restart_tablet.cpp\nnew file mode 100644\nindex 000000000000..3b1d91d252e4\n--- /dev/null\n+++ b/ydb/core/grpc_services/tablet/rpc_restart_tablet.cpp\n@@ -0,0 +1,102 @@\n+#include \"rpc_restart_tablet.h\"\n+#include \"service_tablet.h\"\n+\n+#include <ydb/core/grpc_services/rpc_request_base.h>\n+#include <ydb/core/base/tablet_pipe.h>\n+\n+namespace NKikimr::NGRpcService {\n+\n+class TRpcRestartTablet : public TRpcRequestActor<TRpcRestartTablet, TEvRestartTabletRequest> {\n+    using TBase = TRpcRequestActor<TRpcRestartTablet, TEvRestartTabletRequest>;\n+\n+public:\n+    using TBase::TBase;\n+\n+    void Bootstrap() {\n+        if (!CheckAccess()) {\n+            auto error = TStringBuilder() << \"Access denied\";\n+            if (this->UserToken) {\n+                error << \": '\" << this->UserToken->GetUserSID() << \"' is not an admin\";\n+            }\n+\n+            this->Reply(Ydb::StatusIds::UNAUTHORIZED, NKikimrIssues::TIssuesIds::ACCESS_DENIED, error);\n+            return;\n+        }\n+\n+        auto* req = this->GetProtoRequest();\n+        TabletId = req->tablet_id();\n+        PipeClient = RegisterWithSameMailbox(NTabletPipe::CreateClient(SelfId(), TabletId, NTabletPipe::TClientRetryPolicy{\n+            // We need at least one retry since local resolver cache may be outdated\n+            .RetryLimitCount = 1,\n+        }));\n+\n+        Schedule(TDuration::Seconds(60), new TEvents::TEvWakeup);\n+\n+        Become(&TThis::StateWork);\n+    }\n+\n+private:\n+    bool CheckAccess() const {\n+        if (AppData()->AdministrationAllowedSIDs.empty()) {\n+            return true;\n+        }\n+\n+        if (!this->UserToken) {\n+            return false;\n+        }\n+\n+        for (const auto& sid : AppData()->AdministrationAllowedSIDs) {\n+            if (this->UserToken->IsExist(sid)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+private:\n+    STFUNC(StateWork) {\n+        switch (ev->GetTypeRewrite()) {\n+            hFunc(TEvTabletPipe::TEvClientConnected, Handle);\n+            hFunc(TEvTabletPipe::TEvClientDestroyed, Handle);\n+            hFunc(TEvents::TEvWakeup, Handle);\n+        }\n+    }\n+\n+    void Handle(TEvTabletPipe::TEvClientConnected::TPtr& ev) {\n+        auto* msg = ev->Get();\n+        if (msg->Status != NKikimrProto::OK) {\n+            this->Reply(Ydb::StatusIds::UNAVAILABLE,\n+                TStringBuilder() << \"Tablet \" << TabletId << \" is unavailable\");\n+            return;\n+        }\n+\n+        // Note: we send the poison message and wait for the pipe to close\n+        NTabletPipe::SendData(SelfId(), PipeClient, new TEvents::TEvPoison);\n+    }\n+\n+    void Handle(TEvTabletPipe::TEvClientDestroyed::TPtr&) {\n+        this->Reply(Ydb::StatusIds::SUCCESS);\n+    }\n+\n+    void Handle(TEvents::TEvWakeup::TPtr&) {\n+        NTabletPipe::CloseClient(SelfId(), PipeClient);\n+        this->Reply(Ydb::StatusIds::TIMEOUT,\n+            TStringBuilder() << \"Tablet \" << TabletId << \" is not responding\");\n+    }\n+\n+private:\n+    ui64 TabletId;\n+    TActorId PipeClient;\n+};\n+\n+void DoRestartTabletRequest(std::unique_ptr<IRequestNoOpCtx> p, const IFacilityProvider& f) {\n+    f.RegisterActor(new TRpcRestartTablet(p.release()));\n+}\n+\n+template<>\n+IActor* TEvRestartTabletRequest::CreateRpcActor(NKikimr::NGRpcService::IRequestNoOpCtx* msg) {\n+    return new TRpcRestartTablet(msg);\n+}\n+\n+} // namespace NKikimr::NGRpcService\ndiff --git a/ydb/core/grpc_services/tablet/rpc_restart_tablet.h b/ydb/core/grpc_services/tablet/rpc_restart_tablet.h\nnew file mode 100644\nindex 000000000000..f4615e9cee54\n--- /dev/null\n+++ b/ydb/core/grpc_services/tablet/rpc_restart_tablet.h\n@@ -0,0 +1,11 @@\n+#pragma once\n+#include <ydb/core/grpc_services/base/base.h>\n+#include <ydb/public/api/protos/draft/ydb_tablet.pb.h>\n+\n+namespace NKikimr::NGRpcService {\n+\n+using TEvRestartTabletRequest = TGrpcRequestNoOperationCall<\n+    Ydb::Tablet::RestartTabletRequest,\n+    Ydb::Tablet::RestartTabletResponse>;\n+\n+} // namespace NKikimr::NGRpcService\ndiff --git a/ydb/core/grpc_services/tablet/rpc_restart_tablet_ut.cpp b/ydb/core/grpc_services/tablet/rpc_restart_tablet_ut.cpp\nnew file mode 100644\nindex 000000000000..4b585fcf7d06\n--- /dev/null\n+++ b/ydb/core/grpc_services/tablet/rpc_restart_tablet_ut.cpp\n@@ -0,0 +1,97 @@\n+#include \"rpc_restart_tablet.h\"\n+#include <ydb/core/testlib/test_client.h>\n+#include <ydb/core/testlib/tablet_helpers.h>\n+#include <ydb/core/grpc_services/local_rpc/local_rpc.h>\n+\n+#include <library/cpp/testing/unittest/registar.h>\n+\n+namespace NKikimr::NGRpcService {\n+\n+using namespace Tests;\n+\n+Y_UNIT_TEST_SUITE(TabletService_Restart) {\n+\n+    NThreading::TFuture<Ydb::Tablet::RestartTabletResponse> RestartRpc(\n+            TTestActorRuntime& runtime, ui64 tabletId,\n+            const TString& token = {})\n+    {\n+        Ydb::Tablet::RestartTabletRequest request;\n+        request.set_tablet_id(tabletId);\n+        return NRpcService::DoLocalRpc<TEvRestartTabletRequest>(\n+            std::move(request), \"/Root\", token, runtime.GetActorSystem(0));\n+    }\n+\n+    Y_UNIT_TEST(Basics) {\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings.SetDomainName(\"Root\")\n+            .SetUseRealThreads(false);\n+\n+        Tests::TServer::TPtr server = new TServer(serverSettings);\n+        auto& runtime = *server->GetRuntime();\n+\n+        auto sender = runtime.AllocateEdgeActor();\n+        server->SetupRootStoragePools(sender);\n+\n+        ui64 schemeShardId = ChangeStateStorage(Tests::SchemeRoot, server->GetSettings().Domain);\n+        auto actorBefore = ResolveTablet(runtime, schemeShardId);\n+\n+        Cerr << \"... restarting tablet \" << schemeShardId << Endl;\n+        auto future = RestartRpc(runtime, schemeShardId);\n+        auto result = runtime.WaitFuture(std::move(future));\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::SUCCESS, result.DebugString());\n+\n+        runtime.SimulateSleep(TDuration::Seconds(1));\n+        InvalidateTabletResolverCache(runtime, schemeShardId);\n+        auto actorAfter = ResolveTablet(runtime, schemeShardId);\n+\n+        UNIT_ASSERT_C(actorBefore != actorAfter, \"SchemeShard actor \" << actorBefore << \" didn't change\");\n+    }\n+\n+    Y_UNIT_TEST(OnlyAdminsAllowed) {\n+        TPortManager pm;\n+        TServerSettings serverSettings(pm.GetPort(2134));\n+        serverSettings.SetDomainName(\"Root\")\n+            .SetUseRealThreads(false);\n+\n+        Tests::TServer::TPtr server = new TServer(serverSettings);\n+        auto& runtime = *server->GetRuntime();\n+        runtime.GetAppData().AdministrationAllowedSIDs.push_back(\"root@builtin\");\n+\n+        auto sender = runtime.AllocateEdgeActor();\n+        server->SetupRootStoragePools(sender);\n+\n+        ui64 schemeShardId = ChangeStateStorage(Tests::SchemeRoot, server->GetSettings().Domain);\n+        auto actorBefore = ResolveTablet(runtime, schemeShardId);\n+\n+        Cerr << \"... restarting tablet \" << schemeShardId << \" (without token)\" << Endl;\n+        auto future = RestartRpc(runtime, schemeShardId);\n+        auto result = runtime.WaitFuture(std::move(future));\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::UNAUTHORIZED, result.DebugString());\n+\n+        Cerr << \"... restarting tablet \" << schemeShardId << \" (non-admin token)\" << Endl;\n+        future = RestartRpc(runtime, schemeShardId, NACLib::TUserToken(\"user@builtin\", {}).SerializeAsString());\n+        result = runtime.WaitFuture(std::move(future));\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::UNAUTHORIZED, result.DebugString());\n+\n+        runtime.SimulateSleep(TDuration::Seconds(1));\n+        InvalidateTabletResolverCache(runtime, schemeShardId);\n+        auto actorNoRestart = ResolveTablet(runtime, schemeShardId);\n+\n+        UNIT_ASSERT_C(actorBefore == actorNoRestart, \"SchemeShard actor \" << actorBefore << \" changed to \" << actorNoRestart);\n+\n+        Cerr << \"... restarting tablet \" << schemeShardId << \" (admin token)\" << Endl;\n+        future = RestartRpc(runtime, schemeShardId, NACLib::TUserToken(\"root@builtin\", {}).SerializeAsString());\n+        result = runtime.WaitFuture(std::move(future));\n+        UNIT_ASSERT_VALUES_EQUAL_C(result.status(), Ydb::StatusIds::SUCCESS, result.DebugString());\n+\n+        runtime.SimulateSleep(TDuration::Seconds(1));\n+        InvalidateTabletResolverCache(runtime, schemeShardId);\n+        auto actorAfter = ResolveTablet(runtime, schemeShardId);\n+\n+        UNIT_ASSERT_C(actorBefore != actorAfter, \"SchemeShard actor \" << actorBefore << \" didn't change\");\n+    }\n+\n+} // Y_UNIT_TEST_SUITE(TabletService_Restart)\n+\n+} // namespace NKikimr::NGRpcService\ndiff --git a/ydb/core/grpc_services/tablet/service_tablet.h b/ydb/core/grpc_services/tablet/service_tablet.h\nnew file mode 100644\nindex 000000000000..07b494d783a2\n--- /dev/null\n+++ b/ydb/core/grpc_services/tablet/service_tablet.h\n@@ -0,0 +1,15 @@\n+#pragma once\n+\n+#include <memory>\n+\n+namespace NKikimr::NGRpcService {\n+\n+class IRequestOpCtx;\n+class IRequestNoOpCtx;\n+class IFacilityProvider;\n+\n+void DoExecuteTabletMiniKQLRequest(std::unique_ptr<IRequestNoOpCtx> p, const IFacilityProvider& f);\n+void DoChangeTabletSchemaRequest(std::unique_ptr<IRequestNoOpCtx> p, const IFacilityProvider& f);\n+void DoRestartTabletRequest(std::unique_ptr<IRequestNoOpCtx> p, const IFacilityProvider& f);\n+\n+} // namespace NKikimr::NGRpcService\ndiff --git a/ydb/core/grpc_services/tablet/ut/ya.make b/ydb/core/grpc_services/tablet/ut/ya.make\nnew file mode 100644\nindex 000000000000..077370dd8cf2\n--- /dev/null\n+++ b/ydb/core/grpc_services/tablet/ut/ya.make\n@@ -0,0 +1,18 @@\n+UNITTEST_FOR(ydb/core/grpc_services/tablet)\n+\n+SIZE(MEDIUM)\n+\n+SRCS(\n+    rpc_change_schema_ut.cpp\n+    rpc_execute_mkql_ut.cpp\n+    rpc_restart_tablet_ut.cpp\n+)\n+\n+PEERDIR(\n+    ydb/core/testlib/default\n+    ydb/core/grpc_services/local_rpc\n+)\n+\n+YQL_LAST_ABI_VERSION()\n+\n+END()\ndiff --git a/ydb/core/grpc_services/tablet/ya.make b/ydb/core/grpc_services/tablet/ya.make\nnew file mode 100644\nindex 000000000000..7c832b6ad364\n--- /dev/null\n+++ b/ydb/core/grpc_services/tablet/ya.make\n@@ -0,0 +1,28 @@\n+LIBRARY()\n+\n+SRCS(\n+    rpc_change_schema.cpp\n+    rpc_execute_mkql.cpp\n+    rpc_restart_tablet.cpp\n+    service_tablet.h\n+)\n+\n+PEERDIR(\n+    ydb/core/base\n+    ydb/core/grpc_services\n+    ydb/core/grpc_services/base\n+    ydb/core/protos\n+    ydb/library/mkql_proto\n+    ydb/library/yql/minikql\n+    ydb/library/yql/minikql/computation\n+    ydb/public/api/protos\n+    library/cpp/protobuf/json\n+)\n+\n+YQL_LAST_ABI_VERSION()\n+\n+END()\n+\n+RECURSE_FOR_TESTS(\n+    ut\n+)\ndiff --git a/ydb/core/grpc_services/ya.make b/ydb/core/grpc_services/ya.make\nindex 63344c31d9fb..7b9eb6b92fa6 100644\n--- a/ydb/core/grpc_services/ya.make\n+++ b/ydb/core/grpc_services/ya.make\n@@ -152,6 +152,7 @@ RECURSE(\n     base\n     counters\n     local_rpc\n+    tablet\n )\n \n RECURSE_FOR_TESTS(\ndiff --git a/ydb/services/tablet/ya.make b/ydb/services/tablet/ya.make\nnew file mode 100644\nindex 000000000000..a525f7899dd0\n--- /dev/null\n+++ b/ydb/services/tablet/ya.make\n@@ -0,0 +1,15 @@\n+LIBRARY()\n+\n+SRCS(\n+    ydb_tablet.cpp\n+)\n+\n+PEERDIR(\n+    ydb/library/grpc/server\n+    ydb/public/api/grpc/draft\n+    ydb/core/grpc_services\n+    ydb/core/grpc_services/base\n+    ydb/core/grpc_services/tablet\n+)\n+\n+END()\ndiff --git a/ydb/services/tablet/ydb_tablet.cpp b/ydb/services/tablet/ydb_tablet.cpp\nnew file mode 100644\nindex 000000000000..f6e78a3c4e35\n--- /dev/null\n+++ b/ydb/services/tablet/ydb_tablet.cpp\n@@ -0,0 +1,55 @@\n+#include \"ydb_tablet.h\"\n+\n+#include <ydb/core/grpc_services/tablet/service_tablet.h>\n+#include <ydb/core/grpc_services/grpc_helper.h>\n+#include <ydb/core/grpc_services/base/base.h>\n+\n+namespace NKikimr::NGRpcService {\n+\n+TGRpcYdbTabletService::TGRpcYdbTabletService(\n+        NActors::TActorSystem *system,\n+        TIntrusivePtr<::NMonitoring::TDynamicCounters> counters,\n+        const TVector<NActors::TActorId>& proxies,\n+        bool rlAllowed,\n+        size_t handlersPerCompletionQueue)\n+    : TBase(system, counters, proxies, rlAllowed)\n+    , HandlersPerCompletionQueue(handlersPerCompletionQueue)\n+{}\n+\n+void TGRpcYdbTabletService::SetupIncomingRequests(NYdbGrpc::TLoggerPtr logger) {\n+    auto getCounterBlock = CreateCounterCb(Counters_, ActorSystem_);\n+\n+    size_t proxyCounter = 0;\n+\n+#ifdef ADD_REQUEST_LIMIT\n+#error ADD_REQUEST_LIMIT macro already defined\n+#endif\n+\n+#define ADD_REQUEST_LIMIT(NAME, CB, LIMIT_TYPE, ...) do {                                                               \\\n+    for (size_t i = 0; i < HandlersPerCompletionQueue; ++i) {                                                           \\\n+        for (auto* cq: CQS) {                                                                                           \\\n+            auto proxy = GRpcProxies_[proxyCounter++ % GRpcProxies_.size()];                                            \\\n+            MakeIntrusive<TGRpcRequest<Ydb::Tablet::NAME##Request, Ydb::Tablet::NAME##Response, TGRpcYdbTabletService>> \\\n+                (this, &Service_, cq,                                                                                   \\\n+                    [this, proxy](NYdbGrpc::IRequestContextBase *ctx) {                                                 \\\n+                        NGRpcService::ReportGrpcReqToMon(*ActorSystem_, ctx->GetPeer());                                \\\n+                        ActorSystem_->Send(proxy,                                                                       \\\n+                            new TGrpcRequestNoOperationCall<Ydb::Tablet::NAME##Request, Ydb::Tablet::NAME##Response>    \\\n+                                (ctx, &CB, TRequestAuxSettings {                                                        \\\n+                                    .RlMode = RLSWITCH(TRateLimiterMode::LIMIT_TYPE),                                   \\\n+                                    __VA_OPT__(.AuditMode = TAuditMode::__VA_ARGS__,)                                   \\\n+                                }));                                                                                    \\\n+                    }, &Ydb::Tablet::V1::TabletService::AsyncService::Request ## NAME,                                  \\\n+                    #NAME, logger, getCounterBlock(\"tablet\", #NAME))->Run();                                            \\\n+        }                                                                                                               \\\n+    }                                                                                                                   \\\n+} while(0)\n+\n+    ADD_REQUEST_LIMIT(ExecuteTabletMiniKQL, DoExecuteTabletMiniKQLRequest, Rps, Auditable);\n+    ADD_REQUEST_LIMIT(ChangeTabletSchema, DoChangeTabletSchemaRequest, Rps, Auditable);\n+    ADD_REQUEST_LIMIT(RestartTablet, DoRestartTabletRequest, Rps);\n+\n+#undef ADD_REQUEST_LIMIT\n+}\n+\n+} // namespace NKikimr::NGRpcService\ndiff --git a/ydb/services/tablet/ydb_tablet.h b/ydb/services/tablet/ydb_tablet.h\nnew file mode 100644\nindex 000000000000..638314c495aa\n--- /dev/null\n+++ b/ydb/services/tablet/ydb_tablet.h\n@@ -0,0 +1,31 @@\n+#pragma once\n+\n+#include <ydb/library/actors/core/actorsystem.h>\n+#include <ydb/library/grpc/server/grpc_server.h>\n+#include <ydb/core/grpc_services/base/base_service.h>\n+\n+#include <ydb/public/api/grpc/draft/ydb_tablet_v1.grpc.pb.h>\n+\n+namespace NKikimr::NGRpcService {\n+\n+class TGRpcYdbTabletService\n+    : public TGrpcServiceBase<Ydb::Tablet::V1::TabletService>\n+{\n+    using TBase = TGrpcServiceBase<Ydb::Tablet::V1::TabletService>;\n+\n+public:\n+    TGRpcYdbTabletService(\n+        NActors::TActorSystem *system,\n+        TIntrusivePtr<::NMonitoring::TDynamicCounters> counters,\n+        const TVector<NActors::TActorId>& proxies,\n+        bool rlAllowed,\n+        size_t handlersPerCompletionQueue = 1);\n+\n+private:\n+    void SetupIncomingRequests(NYdbGrpc::TLoggerPtr logger);\n+\n+private:\n+    const size_t HandlersPerCompletionQueue;\n+};\n+\n+} // namespace NKikimr::NGRpcService\ndiff --git a/ydb/services/ya.make b/ydb/services/ya.make\nindex 636feb611120..fc40a9c57421 100644\n--- a/ydb/services/ya.make\n+++ b/ydb/services/ya.make\n@@ -20,6 +20,7 @@ RECURSE(\n     persqueue_v1\n     rate_limiter\n     replication\n+    tablet\n     ydb\n     ymq\n )\n",
  "test_patch": "diff --git a/ydb/core/testlib/test_client.cpp b/ydb/core/testlib/test_client.cpp\nindex 05aee2c04386..c9c1b802ae68 100644\n--- a/ydb/core/testlib/test_client.cpp\n+++ b/ydb/core/testlib/test_client.cpp\n@@ -29,6 +29,7 @@\n #include <ydb/services/ydb/ydb_scripting.h>\n #include <ydb/services/ydb/ydb_table.h>\n #include <ydb/services/ydb/ydb_logstore.h>\n+#include <ydb/services/tablet/ydb_tablet.h>\n #include <ydb/services/discovery/grpc_service.h>\n #include <ydb/services/rate_limiter/grpc_service.h>\n #include <ydb/services/persqueue_cluster_discovery/grpc_service.h>\n@@ -429,6 +430,7 @@ namespace Tests {\n         GRpcServer->AddService(new NGRpcService::TGRpcYmqService(system, counters, grpcRequestProxies[0], true));\n         GRpcServer->AddService(new NGRpcService::TGRpcMonitoringService(system, counters, grpcRequestProxies[0], true));\n         GRpcServer->AddService(new NGRpcService::TGRpcYdbQueryService(system, counters, grpcRequestProxies, true, 1));\n+        GRpcServer->AddService(new NGRpcService::TGRpcYdbTabletService(system, counters, grpcRequestProxies, true, 1));\n         if (Settings->EnableYq) {\n             GRpcServer->AddService(new NGRpcService::TGRpcFederatedQueryService(system, counters, grpcRequestProxies[0]));\n             GRpcServer->AddService(new NGRpcService::TGRpcFqPrivateTaskService(system, counters, grpcRequestProxies[0]));\ndiff --git a/ydb/core/testlib/ya.make b/ydb/core/testlib/ya.make\nindex 5a63f36a639f..4d7fab765fcd 100644\n--- a/ydb/core/testlib/ya.make\n+++ b/ydb/core/testlib/ya.make\n@@ -111,6 +111,7 @@ PEERDIR(\n     ydb/services/replication\n     ydb/services/monitoring\n     ydb/services/metadata/ds_table\n+    ydb/services/tablet\n     ydb/services/ydb\n \n     ydb/core/http_proxy\n",
  "problem_statement": "Implement TabletService\nTabletService (added in #5545) will allows us to remove legacy grpc APIs later.\n",
  "hints_text": "",
  "created_at": "2024-08-28T13:47:43Z"
}